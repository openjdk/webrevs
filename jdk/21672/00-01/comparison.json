{"files":[{"patch":"@@ -28,1 +28,1 @@\n-. report-utils.sh\n+. .github\/scripts\/report-utils.sh\n","filename":".github\/scripts\/gen-build-failure-report.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-. report-utils.sh\n+. .github\/scripts\/report-utils.sh\n","filename":".github\/scripts\/gen-test-results.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-            debian-repository: https:\/\/snapshot.debian.org\/archive\/debian\/20240228T034848Z\/\n+            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n@@ -134,0 +134,1 @@\n+          --no-merged-usr\n@@ -154,0 +155,3 @@\n+          # \/{bin,sbin,lib}\/ are not symbolic links to \/usr\/{bin,sbin,lib}\/ when debootstrap with --no-merged-usr\n+          rm -rf sysroot\/{sbin,bin}\n+          rm -rf sysroot\/lib\/{udev,systemd}\n","filename":".github\/workflows\/build-cross-compile.yml","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -437,1 +437,1 @@\n-<h4 id=\"jtreg_test_thread_factory\">JTREG_TEST_THREAD_FACTORY<\/h4>\n+<h4 id=\"test_thread_factory\">TEST_THREAD_FACTORY<\/h4>\n","filename":"doc\/testing.html","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -383,1 +383,1 @@\n-#### JTREG_TEST_THREAD_FACTORY\n+#### TEST_THREAD_FACTORY\n","filename":"doc\/testing.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+\t$(info $(_) TEST_DEPS=\"dependency1 ...\" # Specify additional dependencies for running tests, e.g docs-jdk\n","filename":"make\/Global.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-      COMPARE_BUILD JTREG GTEST MICRO TEST_OPTS TEST_VM_OPTS\n+      COMPARE_BUILD JTREG GTEST MICRO TEST_OPTS TEST_VM_OPTS TEST_DEPS\n","filename":"make\/InitSupport.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -788,1 +788,1 @@\n-    DEPS := jdk-image test-image, \\\n+    DEPS := jdk-image test-image $(TEST_DEPS), \\\n@@ -794,1 +794,1 @@\n-    DEPS := exploded-image test-image, \\\n+    DEPS := exploded-image test-image $(TEST_DEPS), \\\n@@ -1113,2 +1113,2 @@\n-  $(foreach t, $(filter-out test-make%, $(ALL_TEST_TARGETS)), $(eval $t: jdk-image test-image))\n-  $(foreach t, $(ALL_EXPLODED_TEST_TARGETS), $(eval $t: exploded-image test-image))\n+  $(foreach t, $(filter-out test-make%, $(ALL_TEST_TARGETS)), $(eval $t: jdk-image test-image $(TEST_DEPS)))\n+  $(foreach t, $(ALL_EXPLODED_TEST_TARGETS), $(eval $t: exploded-image test-image $(TEST_DEPS)))\n","filename":"make\/Main.gmk","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -267,0 +267,1 @@\n+docs_JTREG_PROBLEM_LIST += $(TOPDIR)\/test\/docs\/ProblemList.txt\n@@ -742,0 +743,5 @@\n+  # Pass along the path to the tidy html checker\n+  ifneq ($$(TIDY), )\n+    $1_JTREG_BASIC_OPTIONS += -Dtidy=$$(TIDY)\n+  endif\n+\n@@ -871,0 +877,2 @@\n+  $1_JTREG_BASIC_OPTIONS += -e:DOCS_JDK_IMAGE_DIR=$$(DOCS_JDK_IMAGE_DIR)\n+\n","filename":"make\/RunTests.gmk","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -205,0 +205,1 @@\n+LIB_TESTS_SETUP_TIDY\n","filename":"make\/autoconf\/configure.ac","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -939,1 +939,1 @@\n-      FLAGS_COMPILER_CHECK_ARGUMENTS(ARGUMENT: [${BRANCH_PROTECTION_FLAG}],\n+      FLAGS_COMPILER_CHECK_ARGUMENTS(ARGUMENT: [$BRANCH_PROTECTION_FLAG],\n@@ -944,1 +944,0 @@\n-  BRANCH_PROTECTION_CFLAGS=\"\"\n@@ -946,1 +945,1 @@\n-      RESULT: USE_BRANCH_PROTECTION, AVAILABLE: $BRANCH_PROTECTION_AVAILABLE,\n+      RESULT: BRANCH_PROTECTION_ENABLED, AVAILABLE: $BRANCH_PROTECTION_AVAILABLE,\n@@ -948,2 +947,1 @@\n-      IF_ENABLED: [ BRANCH_PROTECTION_CFLAGS=${BRANCH_PROTECTION_FLAG}])\n-  AC_SUBST(BRANCH_PROTECTION_CFLAGS)\n+      IF_ENABLED: [BRANCH_PROTECTION_CFLAGS=$BRANCH_PROTECTION_FLAG])\n","filename":"make\/autoconf\/flags-cflags.m4","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -153,0 +153,4 @@\n+  if test \"x$BRANCH_PROTECTION_ENABLED\" = \"xtrue\"; then\n+    $2JVM_ASFLAGS=\"${$2JVM_ASFLAGS} $BRANCH_PROTECTION_FLAG\"\n+  fi\n+\n","filename":"make\/autoconf\/flags-other.m4","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -311,0 +311,26 @@\n+# Setup the tidy html checker\n+AC_DEFUN_ONCE([LIB_TESTS_SETUP_TIDY],\n+[\n+  UTIL_LOOKUP_PROGS(TIDY, tidy)\n+\n+  if test \"x$TIDY\" != x; then\n+    AC_MSG_CHECKING([if tidy is working properly])\n+    tidy_output=`$TIDY --version 2>&1`\n+    if ! $ECHO \"$tidy_output\" | $GREP -q \"HTML Tidy\" 2>&1 > \/dev\/null; then\n+      AC_MSG_RESULT([no])\n+      AC_MSG_NOTICE([$TIDY is not a valid tidy executable and will be ignored. Output from --version: $tidy_output])\n+      TIDY=\n+    elif ! $ECHO \"$tidy_output\" | $GREP -q \"version\" 2>&1 > \/dev\/null; then\n+      AC_MSG_RESULT([no])\n+      AC_MSG_NOTICE([$TIDY is missing a proper version number and will be ignored. Output from --version: $tidy_output])\n+      TIDY=\n+    else\n+      AC_MSG_RESULT([yes])\n+      AC_MSG_CHECKING([for tidy version])\n+      tidy_version=`$ECHO $tidy_output | $SED -e 's\/.*version \/\/g'`\n+      AC_MSG_RESULT([$tidy_version])\n+    fi\n+  fi\n+  AC_SUBST(TIDY)\n+])\n+\n","filename":"make\/autoconf\/lib-tests.m4","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -432,1 +432,0 @@\n-BRANCH_PROTECTION_CFLAGS := @BRANCH_PROTECTION_CFLAGS@\n@@ -747,0 +746,1 @@\n+TIDY := @TIDY@\n","filename":"make\/autoconf\/spec.gmk.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -139,1 +139,1 @@\n-          $(CHMOD) u+w '$(call DecodeSpace, $@)'; \\\n+          $(CHMOD) -h u+w '$(call DecodeSpace, $@)'; \\\n","filename":"make\/common\/FileUtils.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-JTREG_TESTROOTS += $(addprefix $(TOPDIR)\/test\/, hotspot\/jtreg jdk langtools jaxp lib-test)\n+JTREG_TESTROOTS += $(addprefix $(TOPDIR)\/test\/, hotspot\/jtreg jdk langtools jaxp lib-test docs)\n","filename":"make\/common\/FindTests.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -418,1 +418,1 @@\n-            dependencies: [\"devkit\", \"gtest\", \"build_devkit\", \"graphviz\", \"pandoc\"],\n+            dependencies: [\"devkit\", \"gtest\", \"build_devkit\", \"graphviz\", \"pandoc\", \"tidy\"],\n@@ -444,1 +444,1 @@\n-            dependencies: [\"devkit\", \"gtest\", \"graphviz\", \"pandoc\"],\n+            dependencies: [\"devkit\", \"gtest\", \"graphviz\", \"pandoc\", \"tidy\"],\n@@ -456,1 +456,1 @@\n-            dependencies: [\"devkit\", \"gtest\", \"graphviz\", \"pandoc\"],\n+            dependencies: [\"devkit\", \"gtest\", \"graphviz\", \"pandoc\", \"tidy\"],\n@@ -489,1 +489,1 @@\n-            dependencies: [\"devkit\", \"gtest\", \"build_devkit\", \"graphviz\", \"pandoc\"],\n+            dependencies: [\"devkit\", \"gtest\", \"build_devkit\", \"graphviz\", \"pandoc\", \"tidy\"],\n@@ -960,1 +960,1 @@\n-    if (testedProfile == null) {\n+    if (testedProfile == null || testedProfile == \"docs\") {\n@@ -1002,0 +1002,11 @@\n+    var testOnlyProfilesPrebuiltDocs = {\n+        \"run-test-prebuilt-docs\": clone(testOnlyProfilesPrebuilt[\"run-test-prebuilt\"])\n+    };\n+\n+    testOnlyProfilesPrebuiltDocs[\"run-test-prebuilt-docs\"].dependencies.push(\"docs.doc_api_spec\", \"tidy\");\n+    testOnlyProfilesPrebuiltDocs[\"run-test-prebuilt-docs\"].environment[\"DOCS_JDK_IMAGE_DIR\"]\n+        = input.get(\"docs.doc_api_spec\", \"install_path\");\n+    testOnlyProfilesPrebuiltDocs[\"run-test-prebuilt-docs\"].environment[\"TIDY\"]\n+        = input.get(\"tidy\", \"home_path\") + \"\/bin\/tidy\";\n+    testOnlyProfilesPrebuiltDocs[\"run-test-prebuilt-docs\"].labels = \"test-docs\";\n+\n@@ -1005,1 +1016,1 @@\n-    if (input.profile == \"run-test-prebuilt\") {\n+    if (input.profile == \"run-test-prebuilt\" || input.profile == \"run-test-prebuilt-docs\") {\n@@ -1010,10 +1021,7 @@\n-    if (profiles[testedProfile] != null) {\n-        testOnlyProfilesPrebuilt[\"run-test-prebuilt\"][\"target_os\"]\n-            = profiles[testedProfile][\"target_os\"];\n-        testOnlyProfilesPrebuilt[\"run-test-prebuilt\"][\"target_cpu\"]\n-            = profiles[testedProfile][\"target_cpu\"];\n-    } else if (profiles[testImageProfile] != null) {\n-        testOnlyProfilesPrebuilt[\"run-test-prebuilt\"][\"target_os\"]\n-            = profiles[testImageProfile][\"target_os\"];\n-        testOnlyProfilesPrebuilt[\"run-test-prebuilt\"][\"target_cpu\"]\n-            = profiles[testImageProfile][\"target_cpu\"];\n+    function updateProfileTargets(profiles, testedProfile, testImageProfile, targetProfile, runTestProfile) {\n+        var profileToCheck = profiles[testedProfile] || profiles[testImageProfile];\n+\n+        if (profileToCheck != null) {\n+            targetProfile[runTestProfile][\"target_os\"] = profileToCheck[\"target_os\"];\n+            targetProfile[runTestProfile][\"target_cpu\"] = profileToCheck[\"target_cpu\"];\n+        }\n@@ -1021,0 +1029,5 @@\n+\n+    updateProfileTargets(profiles, testedProfile, testImageProfile, testOnlyProfilesPrebuilt, \"run-test-prebuilt\");\n+    updateProfileTargets(profiles, testedProfile, testImageProfile, testOnlyProfilesPrebuiltDocs, \"run-test-prebuilt-docs\");\n+\n+    profiles = concatObjects(profiles, testOnlyProfilesPrebuiltDocs);\n@@ -1070,0 +1083,2 @@\n+        profiles[\"run-test-prebuilt-docs\"] = concatObjects(profiles[\"run-test-prebuilt-docs\"],\n+            runTestPrebuiltSrcFullExtra);\n@@ -1278,0 +1293,8 @@\n+        tidy: {\n+            organization: common.organization,\n+            ext: \"tar.gz\",\n+            revision: \"5.9.20+1\",\n+            environment_path: input.get(\"tidy\", \"home_path\") + \"\/bin\/tidy\",\n+            configure_args: \"TIDY=\" + input.get(\"tidy\", \"home_path\") + \"\/bin\/tidy\",\n+            module: \"tidy-html-\" + (input.target_os === \"macosx\" ? input.target_os : input.target_platform),\n+        },\n","filename":"make\/conf\/jib-profiles.js","additions":39,"deletions":16,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+    jdk.jsobject \\\n@@ -82,1 +83,0 @@\n-    jdk.jsobject \\\n","filename":"make\/conf\/module-loader-map.conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+#!\/bin\/bash\n+#\n+# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# Creates a tidy bundle in the build directory. A dependency that can be\n+# used to validate and correct HTML.\n+\n+# wget, cmake and gcc are required to build tidy.\n+\n+set -e\n+\n+GITHUB_USER=\"htacg\"\n+REPO_NAME=\"tidy-html5\"\n+COMMIT_HASH=\"d08ddc2860aa95ba8e301343a30837f157977cba\"\n+SCRIPT_DIR=\"$(cd \"$(dirname $0)\" > \/dev\/null && pwd)\"\n+INSTALL_PREFIX=\"${SCRIPT_DIR}\/..\/..\/build\/tidy\/tidy\/\"\n+BUILD_DIR=\"build\/cmake\"\n+\n+OS_NAME=$(uname -s)\n+OS_ARCH=$(uname -m)\n+\n+DOWNLOAD_URL=\"https:\/\/github.com\/$GITHUB_USER\/$REPO_NAME\/archive\/$COMMIT_HASH.tar.gz\"\n+OUTPUT_FILE=\"$REPO_NAME-$COMMIT_HASH.tar.gz\"\n+\n+wget \"$DOWNLOAD_URL\" -O \"$OUTPUT_FILE\"\n+\n+tar -xzf \"$OUTPUT_FILE\"\n+rm -rf \"$OUTPUT_FILE\"\n+\n+SRC_DIR=\"$REPO_NAME-$COMMIT_HASH\"\n+\n+mkdir -p \"$SRC_DIR\/$BUILD_DIR\"\n+cd \"$SRC_DIR\/$BUILD_DIR\"\n+\n+case $OS_NAME in\n+  Linux|Darwin)\n+    echo \"Building Tidy HTML5 for Unix-like platform ($OS_NAME)...\"\n+\n+    CMAKE_ARCH_OPTIONS=\"\"\n+    if [ \"$OS_NAME\" == \"Darwin\" ]; then\n+      if [[ \"$OS_ARCH\" == \"arm64\" || \"$OS_ARCH\" == \"x86_64\" ]]; then\n+        CMAKE_ARCH_OPTIONS=\"-DCMAKE_OSX_ARCHITECTURES=x86_64;arm64\"\n+      fi\n+    fi\n+\n+    cmake ..\/.. -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=\"$INSTALL_PREFIX\" $CMAKE_ARCH_OPTIONS\n+    make install\n+    ;;\n+\n+  *)\n+    echo \"Unsupported OS: $OS_NAME\"\n+    exit 1\n+    ;;\n+esac\n+\n+cd \"$SCRIPT_DIR\"\n+rm -rf \"$SRC_DIR\"\n+\n+cd \"$INSTALL_PREFIX..\"\n+PACKAGED_FILE=\"tidy-html5.tar.gz\"\n+\n+tar -czvf \"$PACKAGED_FILE\" -C \"$INSTALL_PREFIX..\" tidy\n+\n+echo \"Created $INSTALL_PREFIX..$PACKAGED_FILE\"\n","filename":"make\/devkit\/createTidyBundle.sh","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -278,1 +278,1 @@\n-        __ ldr(rscratch1, Address(OSR_buf, slot_offset + 1*BytesPerWord));\n+        __ ldr(rscratch1, __ form_address(rscratch1, OSR_buf, slot_offset + 1*BytesPerWord, 0));\n@@ -284,2 +284,2 @@\n-      __ ldr(r19, Address(OSR_buf, slot_offset));\n-      __ ldr(r20, Address(OSR_buf, slot_offset + BytesPerWord));\n+      __ ldr(r19, __ form_address(rscratch1, OSR_buf, slot_offset, 0));\n+      __ ldr(r20, __ form_address(rscratch1, OSR_buf, slot_offset + BytesPerWord, 0));\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,0 +67,1 @@\n+\"       hint    #0x24; \/\/ bti j\\n\"                                      \\\n@@ -69,0 +70,1 @@\n+\"       hint    #0x24; \/\/ bti j\\n\"                                      \\\n@@ -73,0 +75,1 @@\n+\"       hint    #0x24; \/\/ bti j\\n\"                                      \\\n@@ -77,0 +80,1 @@\n+\"       hint    #0x24; \/\/ bti j\\n\"                                      \\\n@@ -83,0 +87,1 @@\n+\"       hint    #0x24; \/\/ bti j\\n\"                                      \\\n@@ -89,0 +94,1 @@\n+\"       hint    #0x24; \/\/ bti j\\n\"                                      \\\n@@ -97,0 +103,1 @@\n+\"       hint    #0x24; \/\/ bti j\\n\"                                      \\\n@@ -106,0 +113,1 @@\n+\"       hint    #0x24; \/\/ bti j\\n\"                                      \\\n@@ -113,0 +121,1 @@\n+\"       hint    #0x24; \/\/ bti j\\n\"                                      \\\n","filename":"src\/hotspot\/cpu\/aarch64\/copy_aarch64.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1377,1 +1377,3 @@\n-      if (shift)  __ lsr(r15, r15, shift);\n+      if (shift > 0) {\n+        __ lsr(r15, r15, shift);\n+      }\n@@ -1405,3 +1407,9 @@\n-    \/\/ We have a count of units and some trailing bytes.  Adjust the\n-    \/\/ count and do a bulk copy of words.\n-    __ lsr(r15, count, exact_log2(wordSize\/granularity));\n+    \/\/ We have a count of units and some trailing bytes. Adjust the\n+    \/\/ count and do a bulk copy of words. If the shift is zero\n+    \/\/ perform a move instead to benefit from zero latency moves.\n+    int shift = exact_log2(wordSize\/granularity);\n+    if (shift > 0) {\n+      __ lsr(r15, count, shift);\n+    } else {\n+      __ mov(r15, count);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -136,3 +136,14 @@\n-  { assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), \"adjust code below\");\n-    int monitor_offset = BytesPerWord * method()->max_locals() +\n-      (2 * BytesPerWord) * (number_of_locks - 1);\n+  {\n+    assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), \"adjust code below\");\n+\n+    const int locals_space = BytesPerWord * method()->max_locals();\n+    int monitor_offset = locals_space + (2 * BytesPerWord) * (number_of_locks - 1);\n+    bool use_OSR_bias = false;\n+\n+    if (!Assembler::is_simm16(monitor_offset + BytesPerWord) && number_of_locks > 0) {\n+      \/\/ Offsets too large for ld instructions. Use bias.\n+      __ add_const_optimized(OSR_buf, OSR_buf, locals_space);\n+      monitor_offset -= locals_space;\n+      use_OSR_bias = true;\n+    }\n+\n@@ -164,0 +175,5 @@\n+\n+    if (use_OSR_bias) {\n+      \/\/ Restore.\n+      __ sub_const_optimized(OSR_buf, OSR_buf, locals_space);\n+    }\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -12271,1 +12271,1 @@\n-                       iRegIdst tmp1, iRegIdst tmp2, regCTR ctr, flagsRegCR0 cr0, flagsRegCR0 cr1) %{\n+                       iRegIdst tmp1, iRegIdst tmp2, regCTR ctr, flagsRegCR0 cr0, flagsRegCR1 cr1) %{\n@@ -12286,1 +12286,1 @@\n-                       iRegIdst tmp1, iRegIdst tmp2, regCTR ctr, flagsRegCR0 cr0, flagsRegCR0 cr1) %{\n+                       iRegIdst tmp1, iRegIdst tmp2, regCTR ctr, flagsRegCR0 cr0, flagsRegCR1 cr1) %{\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2895,1 +2895,1 @@\n-  \/\/ All calls and jumps must go via MASM.\n+  \/\/ All calls and jumps must go via MASM. Only use x1 (aka ra) as link register for now.\n@@ -2897,0 +2897,1 @@\n+    assert(Rd != x5 && Rs != x5, \"Register x5 must not be used for calls\/jumps.\");\n@@ -2911,0 +2912,1 @@\n+    assert(Rd != x5, \"Register x5 must not be used for calls\/jumps.\");\n@@ -2918,1 +2920,0 @@\n-\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-  \/\/ so use ra as the tmp register for rt_call.\n+  \/\/ so use x1\/ra as the tmp register for rt_call.\n@@ -278,1 +278,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(_stub)), t1);\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(_stub)));\n","filename":"src\/hotspot\/cpu\/riscv\/c1_CodeStubs_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -274,2 +274,2 @@\n-  __ mv(t0, runtime_path);\n-  __ jalr(t0);\n+  __ mv(t1, runtime_path);\n+  __ jalr(t1);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/g1\/g1BarrierSetAssembler_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -342,2 +342,2 @@\n-    __ mv(t0, stub->slow_path());\n-    __ jalr(t0);\n+    __ mv(t1, stub->slow_path());\n+    __ jalr(t1);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/x\/xBarrierSetAssembler_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -727,2 +727,2 @@\n-    __ mv(t0, stub->slow_path());\n-    __ jalr(t0);\n+    __ mv(t1, stub->slow_path());\n+    __ jalr(t1);\n@@ -761,1 +761,1 @@\n-      __ la(t0, RuntimeAddress(ZBarrierSetRuntime::store_barrier_on_native_oop_field_without_healing_addr()));\n+      __ rt_call(ZBarrierSetRuntime::store_barrier_on_native_oop_field_without_healing_addr());\n@@ -763,1 +763,1 @@\n-      __ la(t0, RuntimeAddress(ZBarrierSetRuntime::store_barrier_on_oop_field_with_healing_addr()));\n+      __ rt_call(ZBarrierSetRuntime::store_barrier_on_oop_field_with_healing_addr());\n@@ -765,1 +765,1 @@\n-      __ la(t0, RuntimeAddress(ZBarrierSetRuntime::no_keepalive_store_barrier_on_oop_field_without_healing_addr()));\n+      __ rt_call(ZBarrierSetRuntime::no_keepalive_store_barrier_on_oop_field_without_healing_addr());\n@@ -767,1 +767,1 @@\n-      __ la(t0, RuntimeAddress(ZBarrierSetRuntime::store_barrier_on_oop_field_without_healing_addr()));\n+      __ rt_call(ZBarrierSetRuntime::store_barrier_on_oop_field_without_healing_addr());\n@@ -769,1 +769,0 @@\n-    __ jalr(t0);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/z\/zBarrierSetAssembler_riscv.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -115,1 +115,0 @@\n-  product(bool, UseZtso, false, EXPERIMENTAL, \"Assume Ztso memory model\")        \\\n@@ -118,0 +117,1 @@\n+  product(bool, UseZtso, false, EXPERIMENTAL, \"Assume Ztso memory model\")        \\\n@@ -119,1 +119,1 @@\n-  product(bool, UseZvfh, false, EXPERIMENTAL, \"Use Zvfh instructions\")           \\\n+  product(bool, UseZvfh, false, \"Use Zvfh instructions\")                         \\\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -424,2 +424,2 @@\n-    ld(t0, Address(method, Method::interpreter_entry_offset()));\n-    jr(t0);\n+    ld(t1, Address(method, Method::interpreter_entry_offset()));\n+    jr(t1);\n@@ -429,2 +429,2 @@\n-  ld(t0, Address(method, Method::from_interpreted_offset()));\n-  jr(t0);\n+  ld(t1, Address(method, Method::from_interpreted_offset()));\n+  jr(t1);\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -457,6 +457,1 @@\n-    RuntimeAddress target(StubRoutines::forward_exception_entry());\n-    relocate(target.rspec(), [&] {\n-      int32_t offset;\n-      la(t0, target.target(), offset);\n-      jr(t0, offset);\n-    });\n+    j(RuntimeAddress(StubRoutines::forward_exception_entry()));\n@@ -763,2 +758,2 @@\n-  movptr(t0, 0, offset, t1); \/\/ lui + lui + slli + add\n-  jr(t0, offset);\n+  movptr(t1, 0, offset, t0); \/\/ lui + lui + slli + add\n+  jr(t1, offset);\n@@ -771,3 +766,3 @@\n-  push_reg(RegSet::of(t0, xmethod), sp);   \/\/ push << t0 & xmethod >> to sp\n-  mv(t0, entry_point, offset);\n-  jalr(t0, offset);\n+  push_reg(RegSet::of(t1, xmethod), sp);   \/\/ push << t1 & xmethod >> to sp\n+  mv(t1, entry_point, offset);\n+  jalr(t1, offset);\n@@ -777,1 +772,1 @@\n-  pop_reg(RegSet::of(t0, xmethod), sp);   \/\/ pop << t0 & xmethod >> from sp\n+  pop_reg(RegSet::of(t1, xmethod), sp);   \/\/ pop << t1 & xmethod >> from sp\n@@ -944,0 +939,1 @@\n+  assert(temp != x5, \"temp register must not be x5.\");\n@@ -971,1 +967,2 @@\n-    assert(temp != noreg && temp != x0, \"expecting a register\");\n+    assert(temp != noreg && temp != x0, \"Expecting a register\");\n+    assert(temp != x1 && temp != x5, \"temp register must not be x1\/x5.\");\n@@ -978,2 +975,2 @@\n-void MacroAssembler::j(const Address &adr, Register temp) {\n-  switch (adr.getMode()) {\n+void MacroAssembler::j(const Address &dest, Register temp) {\n+  switch (dest.getMode()) {\n@@ -981,2 +978,4 @@\n-      relocate(adr.rspec(), [&] {\n-        j(adr.target(), temp);\n+      relocate(dest.rspec(), [&] {\n+        int32_t offset;\n+        la(temp, dest.target(), offset);\n+        jr(temp, offset);\n@@ -987,2 +986,2 @@\n-      int32_t offset = ((int32_t)adr.offset() << 20) >> 20;\n-      la(temp, Address(adr.base(), adr.offset() - offset));\n+      int32_t offset = ((int32_t)dest.offset() << 20) >> 20;\n+      la(temp, Address(dest.base(), dest.offset() - offset));\n@@ -1009,0 +1008,1 @@\n+  assert(Rd != x1 && Rd != x5, \"Rd register must not be x1\/x5.\");\n@@ -1015,0 +1015,1 @@\n+  assert(temp != x5, \"temp register must not be x5.\");\n@@ -1022,0 +1023,1 @@\n+  assert(Rs != x5, \"Rs register must not be x5.\");\n@@ -1026,0 +1028,1 @@\n+  assert(tmp != x5, \"tmp register must not be x5.\");\n@@ -1765,1 +1768,1 @@\n-         \"offset is too large to be patched in one jal instruction!\\n\");\n+         \"offset (%ld) is too large to be patched in one jal instruction!\\n\", offset);\n@@ -3661,0 +3664,1 @@\n+  assert(tmp != x5, \"tmp register must not be x5.\");\n@@ -4075,1 +4079,1 @@\n-  assert_different_registers(r_sub_klass, r_super_klass, tmp1, tmp2, tmp3, result, t0);\n+  assert_different_registers(r_sub_klass, r_super_klass, tmp1, tmp2, tmp3, result, t0, t1);\n@@ -4142,2 +4146,2 @@\n-  mv(ra, CAST_FROM_FN_PTR(address, Thread::current));\n-  jalr(ra);\n+  mv(t1, CAST_FROM_FN_PTR(address, Thread::current));\n+  jalr(t1);\n@@ -4190,2 +4194,1 @@\n-  la(t0, RuntimeAddress(SharedRuntime::throw_delayed_StackOverflowError_entry()));\n-  jr(t0);\n+  j(RuntimeAddress(SharedRuntime::throw_delayed_StackOverflowError_entry()));\n@@ -4302,1 +4305,1 @@\n-    load_link_jump(target);\n+    load_link_jump(target, t1);\n@@ -4312,1 +4315,1 @@\n-  movptr(t1, (address)Universe::non_oop_word(), t0);\n+  movptr(t0, (address)Universe::non_oop_word(), t1);\n@@ -4326,1 +4329,1 @@\n-  Register data = t1;\n+  Register data = t0;\n@@ -4328,1 +4331,1 @@\n-  Register tmp1 = t0; \/\/ t0 always scratch\n+  Register tmp1 = t1; \/\/ scratch\n@@ -4426,2 +4429,2 @@\n-    ld(t0, target);  \/\/ auipc + ld\n-    jr(t0);          \/\/ jalr\n+    ld(t1, target);  \/\/ auipc + ld\n+    jr(t1);          \/\/ jalr\n@@ -5151,1 +5154,1 @@\n-\/\/ ptr, cnt, and t0 are clobbered.\n+\/\/ ptr, cnt, t1, and t0 are clobbered.\n@@ -5155,1 +5158,1 @@\n-  assert_different_registers(cnt, t0);\n+  assert_different_registers(cnt, t0, t1);\n@@ -5173,0 +5176,1 @@\n+      \/\/ Clobbers t1\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":37,"deletions":33,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -630,1 +630,1 @@\n-  void load_link_jump(const address source, Register temp = t0);\n+  void load_link_jump(const address source, Register temp);\n@@ -638,0 +638,24 @@\n+  \/\/ Hotspot only use the standard calling convention using x1\/ra.\n+  \/\/ The alternative calling convection using x5\/t0 is not used.\n+  \/\/ Using x5 as a temp causes the CPU to mispredict returns.\n+\n+  \/\/ JALR, return address stack updates:\n+  \/\/ | rd is x1\/x5 | rs1 is x1\/x5 | rd=rs1 | RAS action\n+  \/\/ | ----------- | ------------ | ------ |-------------\n+  \/\/ |     No      |      No      |   —    | None\n+  \/\/ |     No      |      Yes     |   —    | Pop\n+  \/\/ |     Yes     |      No      |   —    | Push\n+  \/\/ |     Yes     |      Yes     |   No   | Pop, then push\n+  \/\/ |     Yes     |      Yes     |   Yes  | Push\n+  \/\/\n+  \/\/ JAL, return address stack updates:\n+  \/\/ | rd is x1\/x5 | RAS action\n+  \/\/ | ----------- | ----------\n+  \/\/ |     Yes     | Push\n+  \/\/ |     No      | None\n+  \/\/\n+  \/\/ JUMPs   uses Rd = x0\/zero and Rs = x6\/t1 or imm\n+  \/\/ CALLS   uses Rd = x1\/ra   and Rs = x6\/t1 or imm (or x1\/ra*)\n+  \/\/ RETURNS uses Rd = x0\/zero and Rs = x1\/ra\n+  \/\/ *use of x1\/ra should not normally be used, special case only.\n+\n@@ -641,3 +665,3 @@\n-  void j(const address dest, Register temp = t0);\n-  void j(const Address &adr, Register temp = t0);\n-  void j(Label &l, Register temp = t0);\n+  void j(const address dest, Register temp = t1);\n+  void j(const Address &dest, Register temp = t1);\n+  void j(Label &l, Register temp = noreg);\n@@ -649,1 +673,1 @@\n-  void call(const address dest, Register temp = t0);\n+  void call(const address dest, Register temp = t1);\n@@ -657,1 +681,2 @@\n-  void rt_call(address dest, Register tmp = t0);\n+  \/\/ Clobebrs t1\n+  void rt_call(address dest, Register tmp = t1);\n@@ -1168,2 +1193,3 @@\n-  void far_call(const Address &entry, Register tmp = t0);\n-  void far_jump(const Address &entry, Register tmp = t0);\n+  \/\/ Clobbers t1 default.\n+  void far_call(const Address &entry, Register tmp = t1);\n+  void far_jump(const Address &entry, Register tmp = t1);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":34,"deletions":8,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -112,4 +112,4 @@\n-    __ lwu(t0, Address(xthread, JavaThread::interp_only_mode_offset()));\n-    __ beqz(t0, run_compiled_code);\n-    __ ld(t0, Address(method, Method::interpreter_entry_offset()));\n-    __ jr(t0);\n+    __ lwu(t1, Address(xthread, JavaThread::interp_only_mode_offset()));\n+    __ beqz(t1, run_compiled_code);\n+    __ ld(t1, Address(method, Method::interpreter_entry_offset()));\n+    __ jr(t1);\n@@ -121,2 +121,2 @@\n-  __ ld(t0,Address(method, entry_offset));\n-  __ jr(t0);\n+  __ ld(t1, Address(method, entry_offset));\n+  __ jr(t1);\n","filename":"src\/hotspot\/cpu\/riscv\/methodHandles_riscv.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -94,4 +94,4 @@\n-      (MacroAssembler::extract_rd(addr)                    == x5) &&\n-      (MacroAssembler::extract_rd(addr + instr_size)       == x5) &&\n-      (MacroAssembler::extract_rs1(addr + instr_size)      == x5) &&\n-      (MacroAssembler::extract_rs1(addr + 2 * instr_size)  == x5) &&\n+      (MacroAssembler::extract_rd(addr)                    == x6) &&\n+      (MacroAssembler::extract_rd(addr + instr_size)       == x6) &&\n+      (MacroAssembler::extract_rs1(addr + instr_size)      == x6) &&\n+      (MacroAssembler::extract_rs1(addr + 2 * instr_size)  == x6) &&\n@@ -463,4 +463,4 @@\n-      (MacroAssembler::extract_rd(addr)                    == x5) &&\n-      (MacroAssembler::extract_rd(addr + instr_size)       == x5) &&\n-      (MacroAssembler::extract_rs1(addr + instr_size)      == x5) &&\n-      (MacroAssembler::extract_rs1(addr + 2 * instr_size)  == x5) &&\n+      (MacroAssembler::extract_rd(addr)                    == x6) &&\n+      (MacroAssembler::extract_rd(addr + instr_size)       == x6) &&\n+      (MacroAssembler::extract_rs1(addr + instr_size)      == x6) &&\n+      (MacroAssembler::extract_rs1(addr + 2 * instr_size)  == x6) &&\n@@ -792,2 +792,2 @@\n-  a.movptr(t0, entry, offset, t1); \/\/ lui, lui, slli, add\n-  a.jr(t0, offset); \/\/ jalr\n+  a.movptr(t1, entry, offset, t0); \/\/ lui, lui, slli, add\n+  a.jr(t1, offset); \/\/ jalr\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1264,2 +1264,2 @@\n-  \/\/   la(t1, retaddr)                ->  auipc + addi\n-  \/\/   la(t0, RuntimeAddress(addr))   ->  lui + addi + slli + addi + slli + addi\n+  \/\/   la(t0, retaddr)                ->  auipc + addi\n+  \/\/   la(t1, RuntimeAddress(addr))   ->  lui + addi + slli + addi + slli + addi\n@@ -1268,1 +1268,1 @@\n-  \/\/   jalr(t0)                       ->  jalr\n+  \/\/   jalr(t1)                       ->  jalr\n@@ -1825,2 +1825,2 @@\n-    st->print_cr(\"\\tlwu t0, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\\t# compressed klass\");\n-    st->print_cr(\"\\tlwu t2, [t1      + CompiledICData::speculated_klass_offset()]\\t# compressed klass\");\n+    st->print_cr(\"\\tlwu t1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\\t# compressed klass\");\n+    st->print_cr(\"\\tlwu t2, [t0      + CompiledICData::speculated_klass_offset()]\\t# compressed klass\");\n@@ -1828,2 +1828,2 @@\n-    st->print_cr(\"\\tld t0, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\\t# compressed klass\");\n-    st->print_cr(\"\\tld t2, [t1      + CompiledICData::speculated_klass_offset()]\\t# compressed klass\");\n+    st->print_cr(\"\\tld t1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\\t# compressed klass\");\n+    st->print_cr(\"\\tld t2, [t0      + CompiledICData::speculated_klass_offset()]\\t# compressed klass\");\n@@ -1831,1 +1831,1 @@\n-  st->print_cr(\"\\tbeq t0, t2, ic_hit\");\n+  st->print_cr(\"\\tbeq t1, t2, ic_hit\");\n@@ -1860,2 +1860,2 @@\n-  \/\/ auipc t0, #exception_blob_entry_point\n-  \/\/ jr (offset)t0\n+  \/\/ auipc t1, #exception_blob_entry_point\n+  \/\/ jr (offset)t1\n@@ -2507,2 +2507,2 @@\n-      __ la(t1, retaddr);\n-      __ la(t0, RuntimeAddress(entry));\n+      __ la(t0, retaddr);\n+      __ la(t1, RuntimeAddress(entry));\n@@ -2511,2 +2511,2 @@\n-      __ sd(t1, Address(sp, wordSize));\n-      __ jalr(t0);\n+      __ sd(t0, Address(sp, wordSize));\n+      __ jalr(t1);\n@@ -9992,1 +9992,1 @@\n-instruct CallDynamicJavaDirect(method meth, rFlagsReg cr)\n+instruct CallDynamicJavaDirect(method meth)\n@@ -9996,1 +9996,1 @@\n-  effect(USE meth, KILL cr);\n+  effect(USE meth);\n@@ -10011,1 +10011,1 @@\n-instruct CallRuntimeDirect(method meth, rFlagsReg cr)\n+instruct CallRuntimeDirect(method meth)\n@@ -10015,1 +10015,1 @@\n-  effect(USE meth, KILL cr);\n+  effect(USE meth);\n@@ -10028,1 +10028,1 @@\n-instruct CallLeafDirect(method meth, rFlagsReg cr)\n+instruct CallLeafDirect(method meth)\n@@ -10032,1 +10032,1 @@\n-  effect(USE meth, KILL cr);\n+  effect(USE meth);\n@@ -10045,1 +10045,1 @@\n-instruct CallLeafDirectVector(method meth, rFlagsReg cr)\n+instruct CallLeafDirectVector(method meth)\n@@ -10049,1 +10049,1 @@\n-  effect(USE meth, KILL cr);\n+  effect(USE meth);\n@@ -10062,1 +10062,1 @@\n-instruct CallLeafNoFPDirect(method meth, rFlagsReg cr)\n+instruct CallLeafNoFPDirect(method meth)\n@@ -10066,1 +10066,1 @@\n-  effect(USE meth, KILL cr);\n+  effect(USE meth);\n@@ -10101,1 +10101,1 @@\n-                                       iRegP_R11 tmpR11, iRegP_R12 tmpR12, iRegP_R13 tmpR13, iRegP_R16 tmpR16)\n+                                       iRegP_R11 tmpR11, iRegP_R12 tmpR12, iRegP_R13 tmpR13, iRegP_R16 tmpR16, rFlagsReg cr)\n@@ -10105,1 +10105,1 @@\n-  effect(TEMP tmpR11, TEMP tmpR12, TEMP tmpR13, TEMP tmpR16);\n+  effect(TEMP tmpR11, TEMP tmpR12, TEMP tmpR13, TEMP tmpR16, KILL cr);\n@@ -10382,1 +10382,1 @@\n-                            iRegP_R31 tmp2, Universe dummy)\n+                            iRegP_R31 tmp2, rFlagsReg cr, Universe dummy)\n@@ -10387,1 +10387,1 @@\n-  effect(USE_KILL cnt, USE_KILL base, TEMP tmp1, TEMP tmp2);\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp1, TEMP tmp2, KILL cr);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":28,"deletions":28,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -354,1 +354,1 @@\n-  __ mv(t0, x10);\n+  __ mv(t1, x10);\n@@ -368,1 +368,1 @@\n-  \/\/ t0:  exception handler\n+  \/\/ t1:  exception handler\n@@ -372,1 +372,1 @@\n-  __ jr(t0);\n+  __ jr(t1);\n","filename":"src\/hotspot\/cpu\/riscv\/runtime_riscv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -471,2 +471,2 @@\n-  __ ld(t0, Address(xmethod, in_bytes(Method::interpreter_entry_offset())));\n-  __ jr(t0);\n+  __ ld(t1, Address(xmethod, in_bytes(Method::interpreter_entry_offset())));\n+  __ jr(t1);\n@@ -613,2 +613,1 @@\n-  const Register data = t1;\n-  const Register tmp = t2;  \/\/ A call-clobbered register not used for arg passing\n+  const Register data = t0;\n@@ -1143,2 +1142,1 @@\n-  __ la(t0, RuntimeAddress(StubRoutines::forward_exception_entry()));\n-  __ jr(t0);\n+  __ j(RuntimeAddress(StubRoutines::forward_exception_entry()));\n@@ -1455,2 +1453,0 @@\n-\n-  const Register ic_reg = t1;\n@@ -1740,0 +1736,1 @@\n+  \/\/ Clobbers t1\n@@ -2622,2 +2619,2 @@\n-  __ ld(t0, Address(xthread, Thread::pending_exception_offset()));\n-  __ bnez(t0, pending);\n+  __ ld(t1, Address(xthread, Thread::pending_exception_offset()));\n+  __ bnez(t1, pending);\n@@ -2629,2 +2626,2 @@\n-  \/\/ x10 is where we want to jump, overwrite t0 which is saved and temporary\n-  __ sd(x10, Address(sp, reg_saver.reg_offset_in_bytes(t0)));\n+  \/\/ x10 is where we want to jump, overwrite t1 which is saved and temporary\n+  __ sd(x10, Address(sp, reg_saver.reg_offset_in_bytes(t1)));\n@@ -2634,2 +2631,1 @@\n-\n-  __ jr(t0);\n+  __ jr(t1);\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":10,"deletions":14,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -511,1 +511,1 @@\n-    __ j(StubRoutines::_call_stub_return_address);\n+    __ j(RuntimeAddress(StubRoutines::_call_stub_return_address));\n@@ -3785,2 +3785,1 @@\n-    __ la(t0, RuntimeAddress(SharedRuntime::throw_StackOverflowError_entry()));\n-    __ jr(t0);\n+    __ j(RuntimeAddress(SharedRuntime::throw_StackOverflowError_entry()));\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -169,1 +169,0 @@\n-  Register continuation = ra;\n@@ -188,1 +187,0 @@\n-      continuation = x9;  \/\/ The first callee-saved register\n@@ -195,0 +193,1 @@\n+      __ mv(ra, x9);\n@@ -201,1 +200,0 @@\n-      continuation = x9;  \/\/ The first callee-saved register\n@@ -208,0 +206,1 @@\n+      __ mv(ra, x9);\n@@ -214,1 +213,0 @@\n-      continuation = x9;  \/\/ The first callee-saved register\n@@ -221,0 +219,1 @@\n+      __ mv(ra, x9);\n@@ -227,1 +226,0 @@\n-      continuation = x9;  \/\/ The first callee-saved register\n@@ -234,0 +232,1 @@\n+      __ mv(ra, x9);\n@@ -240,1 +239,0 @@\n-      continuation = x9;  \/\/ The first callee-saved register\n@@ -247,0 +245,1 @@\n+      __ mv(ra, x9);\n@@ -253,1 +252,0 @@\n-      continuation = x9;  \/\/ The first callee-saved register\n@@ -260,0 +258,1 @@\n+      __ mv(ra, x9);\n@@ -264,1 +263,0 @@\n-      continuation = x9;\n@@ -274,0 +272,1 @@\n+      __ mv(ra, x9);\n@@ -299,1 +298,1 @@\n-    __ jr(continuation);\n+    __ ret();\n@@ -425,1 +424,1 @@\n-  __ j(address(Interpreter::throw_exception_entry()));\n+  __ j(RuntimeAddress(Interpreter::throw_exception_entry()));\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -708,1 +708,1 @@\n-  \/\/ destroys x11, t0\n+  \/\/ destroys x11, t0, t1\n@@ -721,2 +721,2 @@\n-  __ mv(t0, Interpreter::_throw_ArrayIndexOutOfBoundsException_entry);\n-  __ jr(t0);\n+  __ mv(t1, Interpreter::_throw_ArrayIndexOutOfBoundsException_entry);\n+  __ jr(t1);\n@@ -1088,1 +1088,1 @@\n-  __ j(Interpreter::_throw_ArrayStoreException_entry);\n+  __ j(RuntimeAddress(Interpreter::_throw_ArrayStoreException_entry));\n@@ -1316,2 +1316,2 @@\n-  __ mv(t0, Interpreter::_throw_ArithmeticException_entry);\n-  __ jr(t0);\n+  __ mv(t1, Interpreter::_throw_ArithmeticException_entry);\n+  __ jr(t1);\n@@ -1329,2 +1329,2 @@\n-  __ mv(t0, Interpreter::_throw_ArithmeticException_entry);\n-  __ jr(t0);\n+  __ mv(t1, Interpreter::_throw_ArithmeticException_entry);\n+  __ jr(t1);\n@@ -1348,2 +1348,2 @@\n-  __ mv(t0, Interpreter::_throw_ArithmeticException_entry);\n-  __ jr(t0);\n+  __ mv(t1, Interpreter::_throw_ArithmeticException_entry);\n+  __ jr(t1);\n@@ -1361,2 +1361,2 @@\n-  __ mv(t0, Interpreter::_throw_ArithmeticException_entry);\n-  __ jr(t0);\n+  __ mv(t1, Interpreter::_throw_ArithmeticException_entry);\n+  __ jr(t1);\n@@ -1771,2 +1771,2 @@\n-    __ ld(t0, Address(x9, nmethod::osr_entry_point_offset()));\n-    __ jr(t0);\n+    __ ld(t1, Address(x9, nmethod::osr_entry_point_offset()));\n+    __ jr(t1);\n@@ -2174,1 +2174,1 @@\n-  const Register temp = x9;\n+  const Register temp = x9; \/\/ s1\n@@ -3675,1 +3675,1 @@\n-  __ j(Interpreter::_throw_ClassCastException_entry);\n+  __ j(RuntimeAddress(Interpreter::_throw_ClassCastException_entry));\n@@ -3782,1 +3782,1 @@\n-  __ j(Interpreter::throw_exception_entry());\n+  __ j(RuntimeAddress(Interpreter::throw_exception_entry()));\n@@ -3965,2 +3965,2 @@\n-  __ ld(t0, Address(t0));\n-  __ jr(t0);\n+  __ ld(t1, Address(t0));\n+  __ jr(t1);\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -270,2 +270,2 @@\n-  __ ld(t0, Address(xmethod, Method::from_compiled_offset()));\n-  __ jalr(t0);\n+  __ ld(t1, Address(xmethod, Method::from_compiled_offset()));\n+  __ jalr(t1);\n","filename":"src\/hotspot\/cpu\/riscv\/upcallLinker_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -134,2 +134,2 @@\n-  __ ld(t0, Address(xmethod, Method::from_compiled_offset()));\n-  __ jr(t0);\n+  __ ld(t1, Address(xmethod, Method::from_compiled_offset()));\n+  __ jr(t1);\n@@ -163,0 +163,7 @@\n+  \/\/ Real entry arguments:\n+  \/\/  t0: CompiledICData\n+  \/\/  j_rarg0: Receiver\n+  \/\/ Make sure the move of CompiledICData from t0 to t1 is the frist thing that happens.\n+  \/\/ Otherwise we risk clobber t0 as it is used as scratch.\n+  __ mv(t1, t0);\n+\n@@ -173,2 +180,2 @@\n-  \/\/ Entry arguments:\n-  \/\/  t1: CompiledICData\n+  \/\/ Arguments from this point:\n+  \/\/  t1 (moved from t0): CompiledICData\n@@ -223,2 +230,2 @@\n-  __ ld(t0, Address(xmethod, Method::from_compiled_offset()));\n-  __ jr(t0);\n+  __ ld(t1, Address(xmethod, Method::from_compiled_offset()));\n+  __ jr(t1);\n","filename":"src\/hotspot\/cpu\/riscv\/vtableStubs_riscv.cpp","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -219,1 +219,5 @@\n-    __ unlock_object(Rtmp1, Rtmp2, lock->as_register(), *stub->entry());\n+    if (LockingMode == LM_MONITOR) {\n+      __ branch_optimized(Assembler::bcondAlways, *stub->entry());\n+    } else {\n+      __ unlock_object(Rtmp1, Rtmp2, lock->as_register(), *stub->entry());\n+    }\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -123,0 +123,2 @@\n+  } else {\n+    assert(false, \"Unhandled LockingMode:%d\", LockingMode);\n@@ -154,0 +156,2 @@\n+  } else {\n+    assert(false, \"Unhandled LockingMode:%d\", LockingMode);\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4442,5 +4442,0 @@\n-void Assembler::orw(Register dst, Register src) {\n-  (void)prefix_and_encode(dst->encoding(), src->encoding());\n-  emit_arith(0x0B, 0xC0, dst, src);\n-}\n-\n@@ -6754,0 +6749,21 @@\n+void Assembler::sha512msg1(XMMRegister dst, XMMRegister src) {\n+  assert(VM_Version::supports_sha512() && VM_Version::supports_avx(), \"\");\n+  InstructionAttr attributes(AVX_256bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0xCC, (0xC0 | encode));\n+}\n+\n+void Assembler::sha512msg2(XMMRegister dst, XMMRegister src) {\n+  assert(VM_Version::supports_sha512() && VM_Version::supports_avx(), \"\");\n+  InstructionAttr attributes(AVX_256bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0xCD, (0xC0 | encode));\n+}\n+\n+void Assembler::sha512rnds2(XMMRegister dst, XMMRegister nds, XMMRegister src) {\n+  assert(VM_Version::supports_sha512() && VM_Version::supports_avx(), \"\");\n+  InstructionAttr attributes(AVX_256bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0xCB, (0xC0 | encode));\n+}\n+\n@@ -11668,0 +11684,13 @@\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x5A);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::vbroadcasti128(XMMRegister dst, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx2(), \"\");\n+  assert(vector_len == AVX_256bit, \"\");\n+  assert(dst != xnoreg, \"sanity\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T4, \/* input_size_in_bits *\/ EVEX_32bit);\n+  \/\/ swap src<->dst for encoding\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":34,"deletions":5,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -1904,1 +1904,0 @@\n-  void orw(Register dst, Register src);\n@@ -2348,0 +2347,3 @@\n+  void sha512rnds2(XMMRegister dst, XMMRegister nds, XMMRegister src);\n+  void sha512msg1(XMMRegister dst, XMMRegister src);\n+  void sha512msg2(XMMRegister dst, XMMRegister src);\n@@ -3038,0 +3040,1 @@\n+  void vbroadcasti128(XMMRegister dst, Address src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -840,0 +840,1 @@\n+  Label zf_bad_zero;\n@@ -841,1 +842,1 @@\n-  stop(\"Fast Unlock ZF != 1\");\n+  jmp(zf_bad_zero);\n@@ -850,1 +851,1 @@\n-  jccb(Assembler::notZero, zf_correct);\n+  jcc(Assembler::notZero, zf_correct);\n@@ -852,0 +853,2 @@\n+  bind(zf_bad_zero);\n+  stop(\"Fast Unlock ZF != 1\");\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -366,0 +366,1 @@\n+#ifdef COMPILER2\n@@ -368,0 +369,3 @@\n+#else\n+  return false;\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/zBarrierSetAssembler_x86.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3485,0 +3485,11 @@\n+void MacroAssembler::vbroadcasti128(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n+  if (reachable(src)) {\n+    Assembler::vbroadcasti128(dst, as_Address(src), vector_len);\n+  } else {\n+    lea(rscratch, src);\n+    Assembler::vbroadcasti128(dst, Address(rscratch, 0), vector_len);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1121,0 +1121,1 @@\n+  void sha512_update_ni_x1(Register arg_hash, Register arg_msg, Register ofs, Register limit, bool multi_block);\n@@ -1219,0 +1220,3 @@\n+  using Assembler::vbroadcasti128;\n+  void vbroadcasti128(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch = noreg);\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1522,0 +1522,179 @@\n+\/\/Implemented using Intel IpSec implementation (intel-ipsec-mb on github)\n+void MacroAssembler::sha512_update_ni_x1(Register arg_hash, Register arg_msg, Register ofs, Register limit, bool multi_block) {\n+    Label done_hash, block_loop;\n+    address K512_W = StubRoutines::x86::k512_W_addr();\n+\n+    vbroadcasti128(xmm15, ExternalAddress(StubRoutines::x86::pshuffle_byte_flip_mask_addr_sha512()), Assembler::AVX_256bit, r10);\n+\n+    \/\/load current hash value and transform\n+    vmovdqu(xmm0, Address(arg_hash));\n+    vmovdqu(xmm1, Address(arg_hash, 32));\n+    \/\/ymm0 = D C B A, ymm1 = H G F E\n+    vperm2i128(xmm2, xmm0, xmm1, 0x20);\n+    vperm2i128(xmm3, xmm0, xmm1, 0x31);\n+    \/\/ymm2 = F E B A, ymm3 = H G D C\n+    vpermq(xmm13, xmm2, 0x1b, Assembler::AVX_256bit);\n+    vpermq(xmm14, xmm3, 0x1b, Assembler::AVX_256bit);\n+    \/\/ymm13 = A B E F, ymm14 = C D G H\n+\n+    lea(rax, ExternalAddress(K512_W));\n+    align(32);\n+    bind(block_loop);\n+    vmovdqu(xmm11, xmm13);\/\/ABEF\n+    vmovdqu(xmm12, xmm14);\/\/CDGH\n+\n+    \/\/R0 - R3\n+    vmovdqu(xmm0, Address(arg_msg, 0 * 32));\n+    vpshufb(xmm3, xmm0, xmm15, Assembler::AVX_256bit);\/\/ymm0 \/ ymm3 = W[0..3]\n+    vpaddq(xmm0, xmm3, Address(rax, 0 * 32), Assembler::AVX_256bit);\n+    sha512rnds2(xmm12, xmm11, xmm0);\n+    vperm2i128(xmm0, xmm0, xmm0, 0x01);\n+    sha512rnds2(xmm11, xmm12, xmm0);\n+\n+    \/\/R4 - R7\n+    vmovdqu(xmm0, Address(arg_msg, 1 * 32));\n+    vpshufb(xmm4, xmm0, xmm15, Assembler::AVX_256bit);\/\/ymm0 \/ ymm4 = W[4..7]\n+    vpaddq(xmm0, xmm4, Address(rax, 1 * 32), Assembler::AVX_256bit);\n+    sha512rnds2(xmm12, xmm11, xmm0);\n+    vperm2i128(xmm0, xmm0, xmm0, 0x01);\n+    sha512rnds2(xmm11, xmm12, xmm0);\n+    sha512msg1(xmm3, xmm4); \/\/ymm3 = W[0..3] + S0(W[1..4])\n+\n+    \/\/R8 - R11\n+    vmovdqu(xmm0, Address(arg_msg, 2 * 32));\n+    vpshufb(xmm5, xmm0, xmm15, Assembler::AVX_256bit);\/\/ymm0 \/ ymm5 = W[8..11]\n+    vpaddq(xmm0, xmm5, Address(rax, 2 * 32), Assembler::AVX_256bit);\n+    sha512rnds2(xmm12, xmm11, xmm0);\n+    vperm2i128(xmm0, xmm0, xmm0, 0x01);\n+    sha512rnds2(xmm11, xmm12, xmm0);\n+    sha512msg1(xmm4, xmm5);\/\/ymm4 = W[4..7] + S0(W[5..8])\n+\n+    \/\/R12 - R15\n+    vmovdqu(xmm0, Address(arg_msg, 3 * 32));\n+    vpshufb(xmm6, xmm0, xmm15, Assembler::AVX_256bit); \/\/ymm0 \/ ymm6 = W[12..15]\n+    vpaddq(xmm0, xmm6, Address(rax, 3 * 32), Assembler::AVX_256bit);\n+    vpermq(xmm8, xmm6, 0x1b, Assembler::AVX_256bit); \/\/ymm8 = W[12] W[13] W[14] W[15]\n+    vpermq(xmm9, xmm5, 0x39, Assembler::AVX_256bit); \/\/ymm9 = W[8]  W[11] W[10] W[9]\n+    vpblendd(xmm8, xmm8, xmm9, 0x3f, Assembler::AVX_256bit); \/\/ymm8 = W[12] W[11] W[10] W[9]\n+    vpaddq(xmm3, xmm3, xmm8, Assembler::AVX_256bit);\n+    sha512msg2(xmm3, xmm6);\/\/W[16..19] = xmm3 + W[9..12] + S1(W[14..17])\n+    sha512rnds2(xmm12, xmm11, xmm0);\n+    vperm2i128(xmm0, xmm0, xmm0, 0x01);\n+    sha512rnds2(xmm11, xmm12, xmm0);\n+    sha512msg1(xmm5, xmm6); \/\/ymm5 = W[8..11] + S0(W[9..12])\n+\n+    \/\/R16 - R19, R32 - R35, R48 - R51\n+    for (int i = 4, j = 3; j > 0; j--) {\n+      vpaddq(xmm0, xmm3, Address(rax, i * 32), Assembler::AVX_256bit);\n+      vpermq(xmm8, xmm3, 0x1b, Assembler::AVX_256bit);\/\/ymm8 = W[16] W[17] W[18] W[19]\n+      vpermq(xmm9, xmm6, 0x39, Assembler::AVX_256bit);\/\/ymm9 = W[12] W[15] W[14] W[13]\n+      vpblendd(xmm7, xmm8, xmm9, 0x3f, Assembler::AVX_256bit);\/\/xmm7 = W[16] W[15] W[14] W[13]\n+      vpaddq(xmm4, xmm4, xmm7, Assembler::AVX_256bit);\/\/ymm4 = W[4..7] + S0(W[5..8]) + W[13..16]\n+      sha512msg2(xmm4, xmm3);\/\/ymm4 += S1(W[14..17])\n+      sha512rnds2(xmm12, xmm11, xmm0);\n+      vperm2i128(xmm0, xmm0, xmm0, 0x01);\n+      sha512rnds2(xmm11, xmm12, xmm0);\n+      sha512msg1(xmm6, xmm3); \/\/ymm6 = W[12..15] + S0(W[13..16])\n+      i += 1;\n+      \/\/R20 - R23, R36 - R39, R52 - R55\n+      vpaddq(xmm0, xmm4, Address(rax, i * 32), Assembler::AVX_256bit);\n+      vpermq(xmm8, xmm4, 0x1b, Assembler::AVX_256bit);\/\/ymm8 = W[20] W[21] W[22] W[23]\n+      vpermq(xmm9, xmm3, 0x39, Assembler::AVX_256bit);\/\/ymm9 = W[16] W[19] W[18] W[17]\n+      vpblendd(xmm7, xmm8, xmm9, 0x3f, Assembler::AVX_256bit);\/\/ymm7 = W[20] W[19] W[18] W[17]\n+      vpaddq(xmm5, xmm5, xmm7, Assembler::AVX_256bit);\/\/ymm5 = W[8..11] + S0(W[9..12]) + W[17..20]\n+      sha512msg2(xmm5, xmm4);\/\/ymm5 += S1(W[18..21])\n+      sha512rnds2(xmm12, xmm11, xmm0);\n+      vperm2i128(xmm0, xmm0, xmm0, 0x01);\n+      sha512rnds2(xmm11, xmm12, xmm0);\n+      sha512msg1(xmm3, xmm4); \/\/ymm3 = W[16..19] + S0(W[17..20])\n+      i += 1;\n+      \/\/R24 - R27, R40 - R43, R56 - R59\n+      vpaddq(xmm0, xmm5, Address(rax, i * 32), Assembler::AVX_256bit);\n+      vpermq(xmm8, xmm5, 0x1b, Assembler::AVX_256bit);\/\/ymm8 = W[24] W[25] W[26] W[27]\n+      vpermq(xmm9, xmm4, 0x39, Assembler::AVX_256bit);\/\/ymm9 = W[20] W[23] W[22] W[21]\n+      vpblendd(xmm7, xmm8, xmm9, 0x3f, Assembler::AVX_256bit);\/\/ymm7 = W[24] W[23] W[22] W[21]\n+      vpaddq(xmm6, xmm6, xmm7, Assembler::AVX_256bit);\/\/ymm6 = W[12..15] + S0(W[13..16]) + W[21..24]\n+      sha512msg2(xmm6, xmm5);\/\/ymm6 += S1(W[22..25])\n+      sha512rnds2(xmm12, xmm11, xmm0);\n+      vperm2i128(xmm0, xmm0, xmm0, 0x01);\n+      sha512rnds2(xmm11, xmm12, xmm0);\n+      sha512msg1(xmm4, xmm5);\/\/ymm4 = W[20..23] + S0(W[21..24])\n+      i += 1;\n+      \/\/R28 - R31, R44 - R47, R60 - R63\n+      vpaddq(xmm0, xmm6, Address(rax, i * 32), Assembler::AVX_256bit);\n+      vpermq(xmm8, xmm6, 0x1b, Assembler::AVX_256bit);\/\/ymm8 = W[28] W[29] W[30] W[31]\n+      vpermq(xmm9, xmm5, 0x39, Assembler::AVX_256bit);\/\/ymm9 = W[24] W[27] W[26] W[25]\n+      vpblendd(xmm7, xmm8, xmm9, 0x3f, Assembler::AVX_256bit);\/\/ymm7 = W[28] W[27] W[26] W[25]\n+      vpaddq(xmm3, xmm3, xmm7, Assembler::AVX_256bit);\/\/ymm3 = W[16..19] + S0(W[17..20]) + W[25..28]\n+      sha512msg2(xmm3, xmm6); \/\/ymm3 += S1(W[26..29])\n+      sha512rnds2(xmm12, xmm11, xmm0);\n+      vperm2i128(xmm0, xmm0, xmm0, 0x01);\n+      sha512rnds2(xmm11, xmm12, xmm0);\n+      sha512msg1(xmm5, xmm6);\/\/ymm5 = W[24..27] + S0(W[25..28])\n+      i += 1;\n+    }\n+    \/\/R64 - R67\n+    vpaddq(xmm0, xmm3, Address(rax, 16 * 32), Assembler::AVX_256bit);\n+    vpermq(xmm8, xmm3, 0x1b, Assembler::AVX_256bit);\/\/ymm8 = W[64] W[65] W[66] W[67]\n+    vpermq(xmm9, xmm6, 0x39, Assembler::AVX_256bit);\/\/ymm9 = W[60] W[63] W[62] W[61]\n+    vpblendd(xmm7, xmm8, xmm9, 0x3f, Assembler::AVX_256bit);\/\/ymm7 = W[64] W[63] W[62] W[61]\n+    vpaddq(xmm4, xmm4, xmm7, Assembler::AVX_256bit);\/\/ymm4 = W[52..55] + S0(W[53..56]) + W[61..64]\n+    sha512msg2(xmm4, xmm3);\/\/ymm4 += S1(W[62..65])\n+    sha512rnds2(xmm12, xmm11, xmm0);\n+    vperm2i128(xmm0, xmm0, xmm0, 0x01);\n+    sha512rnds2(xmm11, xmm12, xmm0);\n+    sha512msg1(xmm6, xmm3);\/\/ymm6 = W[60..63] + S0(W[61..64])\n+\n+    \/\/R68 - R71\n+    vpaddq(xmm0, xmm4, Address(rax, 17 * 32), Assembler::AVX_256bit);\n+    vpermq(xmm8, xmm4, 0x1b, Assembler::AVX_256bit);\/\/ymm8 = W[68] W[69] W[70] W[71]\n+    vpermq(xmm9, xmm3, 0x39, Assembler::AVX_256bit);\/\/ymm9 = W[64] W[67] W[66] W[65]\n+    vpblendd(xmm7, xmm8, xmm9, 0x3f, Assembler::AVX_256bit);\/\/ymm7 = W[68] W[67] W[66] W[65]\n+    vpaddq(xmm5, xmm5, xmm7, Assembler::AVX_256bit);\/\/ymm5 = W[56..59] + S0(W[57..60]) + W[65..68]\n+    sha512msg2(xmm5, xmm4);\/\/ymm5 += S1(W[66..69])\n+    sha512rnds2(xmm12, xmm11, xmm0);\n+    vperm2i128(xmm0, xmm0, xmm0, 0x01);\n+    sha512rnds2(xmm11, xmm12, xmm0);\n+\n+    \/\/R72 - R75\n+    vpaddq(xmm0, xmm5, Address(rax, 18 * 32), Assembler::AVX_256bit);\n+    vpermq(xmm8, xmm5, 0x1b, Assembler::AVX_256bit);\/\/ymm8 = W[72] W[73] W[74] W[75]\n+    vpermq(xmm9, xmm4, 0x39, Assembler::AVX_256bit);\/\/ymm9 = W[68] W[71] W[70] W[69]\n+    vpblendd(xmm7, xmm8, xmm9, 0x3f, Assembler::AVX_256bit);\/\/ymm7 = W[72] W[71] W[70] W[69]\n+    vpaddq(xmm6, xmm6, xmm7, Assembler::AVX_256bit);\/\/ymm6 = W[60..63] + S0(W[61..64]) + W[69..72]\n+    sha512msg2(xmm6, xmm5);\/\/ymm6 += S1(W[70..73])\n+    sha512rnds2(xmm12, xmm11, xmm0);\n+    vperm2i128(xmm0, xmm0, xmm0, 0x01);\n+    sha512rnds2(xmm11, xmm12, xmm0);\n+\n+    \/\/R76 - R79\n+    vpaddq(xmm0, xmm6, Address(rax, 19 * 32), Assembler::AVX_256bit);\n+    sha512rnds2(xmm12, xmm11, xmm0);\n+    vperm2i128(xmm0, xmm0, xmm0, 0x01);\n+    sha512rnds2(xmm11, xmm12, xmm0);\n+\n+    \/\/update hash value\n+    vpaddq(xmm14, xmm14, xmm12, Assembler::AVX_256bit);\n+    vpaddq(xmm13, xmm13, xmm11, Assembler::AVX_256bit);\n+\n+    if (multi_block) {\n+      addptr(arg_msg, 4 * 32);\n+      addptr(ofs, 128);\n+      cmpptr(ofs, limit);\n+      jcc(Assembler::belowEqual, block_loop);\n+      movptr(rax, ofs); \/\/return ofs\n+    }\n+\n+    \/\/store the hash value back in memory\n+    \/\/xmm13 = ABEF\n+    \/\/xmm14 = CDGH\n+    vperm2i128(xmm1, xmm13, xmm14, 0x31);\n+    vperm2i128(xmm2, xmm13, xmm14, 0x20);\n+    vpermq(xmm1, xmm1, 0xb1, Assembler::AVX_256bit);\/\/ymm1 = D C B A\n+    vpermq(xmm2, xmm2, 0xb1, Assembler::AVX_256bit);\/\/ymm2 = H G F E\n+    vmovdqu(Address(arg_hash, 0 * 32), xmm1);\n+    vmovdqu(Address(arg_hash, 1 * 32), xmm2);\n+\n+    bind(done_hash);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_sha.cpp","additions":179,"deletions":0,"binary":false,"changes":179,"status":"modified"},{"patch":"@@ -1561,1 +1561,1 @@\n-  assert(VM_Version::supports_bmi2(), \"\");\n+  assert(VM_Version::supports_bmi2() || VM_Version::supports_sha512(), \"\");\n@@ -1571,11 +1571,0 @@\n-  const XMMRegister msg = xmm0;\n-  const XMMRegister state0 = xmm1;\n-  const XMMRegister state1 = xmm2;\n-  const XMMRegister msgtmp0 = xmm3;\n-  const XMMRegister msgtmp1 = xmm4;\n-  const XMMRegister msgtmp2 = xmm5;\n-  const XMMRegister msgtmp3 = xmm6;\n-  const XMMRegister msgtmp4 = xmm7;\n-\n-  const XMMRegister shuf_mask = xmm8;\n-\n@@ -1584,3 +1573,16 @@\n-  __ sha512_AVX2(msg, state0, state1, msgtmp0, msgtmp1, msgtmp2, msgtmp3, msgtmp4,\n-  buf, state, ofs, limit, rsp, multi_block, shuf_mask);\n-\n+  if (VM_Version::supports_sha512()) {\n+      __ sha512_update_ni_x1(state, buf, ofs, limit, multi_block);\n+  } else {\n+    const XMMRegister msg = xmm0;\n+    const XMMRegister state0 = xmm1;\n+    const XMMRegister state1 = xmm2;\n+    const XMMRegister msgtmp0 = xmm3;\n+    const XMMRegister msgtmp1 = xmm4;\n+    const XMMRegister msgtmp2 = xmm5;\n+    const XMMRegister msgtmp3 = xmm6;\n+    const XMMRegister msgtmp4 = xmm7;\n+\n+    const XMMRegister shuf_mask = xmm8;\n+    __ sha512_AVX2(msg, state0, state1, msgtmp0, msgtmp1, msgtmp2, msgtmp3, msgtmp4,\n+      buf, state, ofs, limit, rsp, multi_block, shuf_mask);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":17,"deletions":15,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1063,0 +1063,1 @@\n+    _features &= ~CPU_SHA512;\n@@ -1307,1 +1308,1 @@\n-  if (UseSHA && supports_avx2() && supports_bmi2()) {\n+  if (UseSHA && supports_avx2() && (supports_bmi2() || supports_sha512())) {\n@@ -3010,0 +3011,2 @@\n+    if (sefsl1_cpuid7_eax.bits.sha512 != 0)\n+      result |= CPU_SHA512;\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -286,1 +286,2 @@\n-      uint32_t             : 23,\n+      uint32_t    sha512   : 1,\n+                           : 22,\n@@ -418,1 +419,2 @@\n-    decl(APX_F,             \"apx_f\",             60) \/* Intel Advanced Performance Extensions*\/\n+    decl(APX_F,             \"apx_f\",             60) \/* Intel Advanced Performance Extensions*\/\\\n+    decl(SHA512,            \"sha512\",            61) \/* SHA512 instructions*\/\n@@ -641,2 +643,2 @@\n-  static void set_avx_cpuFeatures() { _features = (CPU_SSE | CPU_SSE2 | CPU_AVX | CPU_VZEROUPPER ); }\n-  static void set_evex_cpuFeatures() { _features = (CPU_AVX512F | CPU_SSE | CPU_SSE2 | CPU_VZEROUPPER ); }\n+  static void set_avx_cpuFeatures() { _features |= (CPU_SSE | CPU_SSE2 | CPU_AVX | CPU_VZEROUPPER ); }\n+  static void set_evex_cpuFeatures() { _features |= (CPU_AVX512F | CPU_SSE | CPU_SSE2 | CPU_VZEROUPPER ); }\n@@ -644,0 +646,1 @@\n+  static void set_bmi_cpuFeatures() { _features |= (CPU_BMI1 | CPU_BMI2 | CPU_LZCNT); }\n@@ -760,0 +763,1 @@\n+  static bool supports_sha512()       { return (_features & CPU_SHA512) != 0; }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3689,0 +3689,1 @@\n+  predicate(n->as_StoreVector()->memory_size() >= 16);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-    _thread_type(),\n","filename":"src\/hotspot\/os\/aix\/osThread_aix.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-  int _thread_type;\n@@ -55,7 +54,0 @@\n-  int thread_type() const {\n-    return _thread_type;\n-  }\n-  void set_thread_type(int type) {\n-    _thread_type = type;\n-  }\n-\n","filename":"src\/hotspot\/os\/aix\/osThread_aix.hpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -701,3 +701,0 @@\n-  \/\/ Set the correct thread state.\n-  osthread->set_thread_type(thr_type);\n-\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n-    _thread_type(),\n","filename":"src\/hotspot\/os\/bsd\/osThread_bsd.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,0 @@\n-  int _thread_type;\n@@ -59,7 +58,0 @@\n-  int thread_type() const {\n-    return _thread_type;\n-  }\n-  void set_thread_type(int type) {\n-    _thread_type = type;\n-  }\n-\n","filename":"src\/hotspot\/os\/bsd\/osThread_bsd.hpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -636,3 +636,0 @@\n-  \/\/ set the correct thread state\n-  osthread->set_thread_type(thr_type);\n-\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-    _thread_type(),\n","filename":"src\/hotspot\/os\/linux\/osThread_linux.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,0 @@\n-  int _thread_type;\n@@ -50,7 +49,0 @@\n-  int thread_type() const {\n-    return _thread_type;\n-  }\n-  void set_thread_type(int type) {\n-    _thread_type = type;\n-  }\n-\n","filename":"src\/hotspot\/os\/linux\/osThread_linux.hpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -977,3 +977,0 @@\n-  \/\/ set the correct thread state\n-  osthread->set_thread_type(thr_type);\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-\/\/ The AttachListener thread services a queue of operations. It blocks in the dequeue\n-\/\/ function until an operation is enqueued. A client enqueues an operation by creating\n+\/\/ The AttachListener thread services a queue of operation requests. It blocks in the dequeue\n+\/\/ function until a request is enqueued. A client enqueues a request by creating\n@@ -39,2 +39,2 @@\n-\/\/ JVM_EnqueueOperation function which checks the operation parameters and enqueues\n-\/\/ the operation to the queue serviced by the attach listener. The thread created by\n+\/\/ JVM_EnqueueOperation or JVM_EnqueueOperation_v2 function which checks the operation parameters\n+\/\/ and enqueues the operation request to the queue. The thread created by\n@@ -42,2 +42,2 @@\n-\/\/ it simple operations are pre-allocated at initialization time. An enqueue thus\n-\/\/ takes a preallocated operation, populates the operation parameters, adds it to\n+\/\/ it simple operation requests are pre-allocated at initialization time. An enqueue thus\n+\/\/ takes a preallocated request, populates the operation parameters, adds it to\n@@ -46,0 +46,7 @@\n+\/\/ Differences between Attach API v1 and v2:\n+\/\/ In v1 (jdk6+) client calls JVM_EnqueueOperation function and passes all operation parameters\n+\/\/ as arguments of the function.\n+\/\/ In v2 (jdk24+) client calls JVM_EnqueueOperation_v2 function and passes only pipe name.\n+\/\/ Attach listeners connects to the pipe (in read\/write mode) and reads all operation parameters\n+\/\/ (the same way as other platform implementations read them using sockets).\n+\/\/\n@@ -58,2 +65,148 @@\n-\/\/ forward reference\n-class Win32AttachOperation;\n+class PipeChannel : public AttachOperation::RequestReader, public AttachOperation::ReplyWriter {\n+private:\n+  HANDLE _hPipe;\n+public:\n+  PipeChannel() : _hPipe(INVALID_HANDLE_VALUE) {}\n+  ~PipeChannel() {\n+    close();\n+  }\n+\n+  bool opened() const {\n+    return _hPipe != INVALID_HANDLE_VALUE;\n+  }\n+\n+  bool open(const char* pipe, bool write_only) {\n+    _hPipe = ::CreateFile(pipe,\n+                          GENERIC_WRITE | (write_only ? 0 : GENERIC_READ),\n+                          0,              \/\/ no sharing\n+                          nullptr,        \/\/ default security attributes\n+                          OPEN_EXISTING,  \/\/ opens existing pipe\n+                          0,              \/\/ default attributes\n+                          nullptr);       \/\/ no template file\n+    if (_hPipe == INVALID_HANDLE_VALUE) {\n+      log_error(attach)(\"could not open (%d) pipe %s\", GetLastError(), pipe);\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  void close() {\n+    if (opened()) {\n+      CloseHandle(_hPipe);\n+      _hPipe = INVALID_HANDLE_VALUE;\n+    }\n+  }\n+\n+  \/\/ RequestReader\n+  int read(void* buffer, int size) override {\n+    assert(opened(), \"must be\");\n+    DWORD nread;\n+    BOOL fSuccess = ReadFile(_hPipe,\n+                             buffer,\n+                             (DWORD)size,\n+                             &nread,\n+                             nullptr);   \/\/ not overlapped\n+    return fSuccess ? (int)nread : -1;\n+  }\n+\n+  \/\/ ReplyWriter\n+  int write(const void* buffer, int size) override {\n+    assert(opened(), \"must be\");\n+    DWORD written;\n+    BOOL fSuccess = WriteFile(_hPipe,\n+                              buffer,\n+                              (DWORD)size,\n+                              &written,\n+                              nullptr);  \/\/ not overlapped\n+    return fSuccess ? (int)written : -1;\n+  }\n+\n+  void flush() override {\n+    assert(opened(), \"must be\");\n+    FlushFileBuffers(_hPipe);\n+  }\n+};\n+\n+class Win32AttachOperation: public AttachOperation {\n+public:\n+  enum {\n+    pipe_name_max = 256             \/\/ maximum pipe name\n+  };\n+\n+private:\n+  PipeChannel _pipe;\n+\n+public:\n+  \/\/ for v1 pipe must be write-only\n+  void open_pipe(const char* pipe_name, bool write_only) {\n+    _pipe.open(pipe_name, write_only);\n+  }\n+\n+  bool read_request() {\n+      return AttachOperation::read_request(&_pipe);\n+  }\n+\n+public:\n+  void complete(jint result, bufferedStream* result_stream) override;\n+};\n+\n+\n+\/\/ Win32AttachOperationRequest is an element of AttachOperation request list.\n+class Win32AttachOperationRequest {\n+private:\n+  AttachAPIVersion _ver;\n+  char _name[AttachOperation::name_length_max + 1];\n+  char _arg[AttachOperation::arg_count_max][AttachOperation::arg_length_max + 1];\n+  char _pipe[Win32AttachOperation::pipe_name_max + 1];\n+\n+  Win32AttachOperationRequest* _next;\n+\n+  void set_value(char* dst, const char* str, size_t dst_size) {\n+    if (str != nullptr) {\n+        assert(strlen(str) < dst_size, \"exceeds maximum length\");\n+        strncpy(dst, str, dst_size - 1);\n+        dst[dst_size - 1] = '\\0';\n+    } else {\n+      strcpy(dst, \"\");\n+    }\n+  }\n+\n+public:\n+  void set(AttachAPIVersion ver, const char* pipename,\n+           const char* cmd = nullptr,\n+           const char* arg0 = nullptr,\n+           const char* arg1 = nullptr,\n+           const char* arg2 = nullptr) {\n+      _ver = ver;\n+      set_value(_name, cmd, sizeof(_name));\n+      set_value(_arg[0], arg0, sizeof(_arg[0]));\n+      set_value(_arg[1], arg1, sizeof(_arg[1]));\n+      set_value(_arg[2], arg2, sizeof(_arg[2]));\n+      set_value(_pipe, pipename, sizeof(_pipe));\n+  }\n+  AttachAPIVersion ver() const {\n+    return _ver;\n+  }\n+  const char* cmd() const {\n+    return _name;\n+  }\n+  const char* arg(int i) const {\n+    return (i >= 0 && i < AttachOperation::arg_count_max) ? _arg[i] : nullptr;\n+  }\n+  const char* pipe() const {\n+    return _pipe;\n+  }\n+\n+  Win32AttachOperationRequest* next() const {\n+    return _next;\n+  }\n+  void set_next(Win32AttachOperationRequest* next) {\n+    _next = next;\n+  }\n+\n+  \/\/ noarg constructor as operation is preallocated\n+  Win32AttachOperationRequest() {\n+    set(ATTACH_API_V1, \"<nopipe>\");\n+    set_next(nullptr);\n+  }\n+};\n@@ -72,1 +225,1 @@\n-  static Win32AttachOperation* _avail;\n+  static Win32AttachOperationRequest* _avail;\n@@ -75,2 +228,2 @@\n-  static Win32AttachOperation* _head;\n-  static Win32AttachOperation* _tail;\n+  static Win32AttachOperationRequest* _head;\n+  static Win32AttachOperationRequest* _tail;\n@@ -79,2 +232,2 @@\n-  static Win32AttachOperation* head()                       { return _head; }\n-  static void set_head(Win32AttachOperation* head)          { _head = head; }\n+  static Win32AttachOperationRequest* head()                       { return _head; }\n+  static void set_head(Win32AttachOperationRequest* head)          { _head = head; }\n@@ -82,2 +235,2 @@\n-  static Win32AttachOperation* tail()                       { return _tail; }\n-  static void set_tail(Win32AttachOperation* tail)          { _tail = tail; }\n+  static Win32AttachOperationRequest* tail()                       { return _tail; }\n+  static void set_tail(Win32AttachOperationRequest* tail)          { _tail = tail; }\n@@ -104,2 +257,2 @@\n-  static Win32AttachOperation* available()                  { return _avail; }\n-  static void set_available(Win32AttachOperation* avail)    { _avail = avail; }\n+  static Win32AttachOperationRequest* available()                  { return _avail; }\n+  static void set_available(Win32AttachOperationRequest* avail)    { _avail = avail; }\n@@ -108,1 +261,2 @@\n-  static int enqueue(char* cmd, char* arg1, char* arg2, char* arg3, char* pipename);\n+  static int enqueue(AttachAPIVersion ver, const char* cmd,\n+      const char* arg1, const char* arg2, const char* arg3, const char* pipename);\n@@ -117,42 +271,3 @@\n-Win32AttachOperation* Win32AttachListener::_avail;\n-Win32AttachOperation* Win32AttachListener::_head;\n-Win32AttachOperation* Win32AttachListener::_tail;\n-\n-\n-\/\/ Win32AttachOperation is an AttachOperation that additionally encapsulates the name\n-\/\/ of a pipe which is used to send the operation reply\/output to the client.\n-\/\/ Win32AttachOperation can also be linked in a list.\n-\n-class Win32AttachOperation: public AttachOperation {\n- private:\n-  friend class Win32AttachListener;\n-\n-  enum {\n-    pipe_name_max = 256             \/\/ maximum pipe name\n-  };\n-\n-  char _pipe[pipe_name_max + 1];\n-\n-  const char* pipe() const                              { return _pipe; }\n-  void set_pipe(const char* pipe) {\n-    assert(strlen(pipe) <= pipe_name_max, \"exceeds maximum length of pipe name\");\n-    os::snprintf(_pipe, sizeof(_pipe), \"%s\", pipe);\n-  }\n-\n-  HANDLE open_pipe();\n-  static BOOL write_pipe(HANDLE hPipe, char* buf, int len);\n-\n-  Win32AttachOperation* _next;\n-\n-  Win32AttachOperation* next() const                    { return _next; }\n-  void set_next(Win32AttachOperation* next)             { _next = next; }\n-\n-  \/\/ noarg constructor as operation is preallocated\n-  Win32AttachOperation() : AttachOperation(\"<noname>\") {\n-    set_pipe(\"<nopipe>\");\n-    set_next(nullptr);\n-  }\n-\n- public:\n-  void complete(jint result, bufferedStream* result_stream);\n-};\n+Win32AttachOperationRequest* Win32AttachListener::_avail;\n+Win32AttachOperationRequest* Win32AttachListener::_head;\n+Win32AttachOperationRequest* Win32AttachListener::_tail;\n@@ -174,1 +289,1 @@\n-    Win32AttachOperation* op = new Win32AttachOperation();\n+    Win32AttachOperationRequest* op = new Win32AttachOperationRequest();\n@@ -179,0 +294,2 @@\n+  AttachListener::set_supported_version(ATTACH_API_V2);\n+\n@@ -185,1 +302,5 @@\n-int Win32AttachListener::enqueue(char* cmd, char* arg0, char* arg1, char* arg2, char* pipename) {\n+int Win32AttachListener::enqueue(AttachAPIVersion ver, const char* cmd,\n+    const char* arg0, const char* arg1, const char* arg2, const char* pipename) {\n+\n+  log_debug(attach)(\"AttachListener::enqueue, ver = %d, cmd = %s\", (int)ver, cmd);\n+\n@@ -213,1 +334,1 @@\n-  Win32AttachOperation* op = available();\n+  Win32AttachOperationRequest* op = available();\n@@ -226,5 +347,1 @@\n-    op->set_name(cmd);\n-    op->set_arg(0, arg0);\n-    op->set_arg(1, arg1);\n-    op->set_arg(2, arg2);\n-    op->set_pipe(pipename);\n+    op->set(ver, pipename, cmd, arg0, arg1, arg2);\n@@ -239,0 +356,1 @@\n+\n@@ -258,0 +376,4 @@\n+    Win32AttachOperation* op = nullptr;\n+    Win32AttachOperationRequest* request = head();\n+    if (request != nullptr) {\n+      log_debug(attach)(\"AttachListener::dequeue, got request, ver = %d, cmd = %s\", request->ver(), request->cmd());\n@@ -259,3 +381,1 @@\n-    Win32AttachOperation* op = head();\n-    if (op != nullptr) {\n-      set_head(op->next());\n+      set_head(request->next());\n@@ -265,0 +385,23 @@\n+\n+      switch (request->ver()) {\n+      case ATTACH_API_V1:\n+        op = new Win32AttachOperation();\n+        op->set_name(request->cmd());\n+        for (int i = 0; i < AttachOperation::arg_count_max; i++) {\n+          op->append_arg(request->arg(i));\n+        }\n+        op->open_pipe(request->pipe(), true\/*write-only*\/);\n+        break;\n+      case ATTACH_API_V2:\n+        op = new Win32AttachOperation();\n+        op->open_pipe(request->pipe(), false\/*write-only*\/);\n+        if (!op->read_request()) {\n+          log_error(attach)(\"AttachListener::dequeue, reading request ERROR\");\n+          delete op;\n+          op = nullptr;\n+        }\n+        break;\n+      default:\n+        log_error(attach)(\"AttachListener::dequeue, unsupported version: %d\", request->ver(), request->cmd());\n+        break;\n+      }\n@@ -266,0 +409,4 @@\n+    \/\/ put the operation back on the available list\n+    request->set_next(Win32AttachListener::available());\n+    Win32AttachListener::set_available(request);\n+\n@@ -269,0 +416,1 @@\n+      log_debug(attach)(\"AttachListener::dequeue, return op: %s\", op->name());\n@@ -274,37 +422,0 @@\n-\n-\/\/ open the pipe to the client\n-HANDLE Win32AttachOperation::open_pipe() {\n-  HANDLE hPipe = ::CreateFile( pipe(),  \/\/ pipe name\n-                        GENERIC_WRITE,   \/\/ write only\n-                        0,              \/\/ no sharing\n-                        nullptr,           \/\/ default security attributes\n-                        OPEN_EXISTING,  \/\/ opens existing pipe\n-                        0,              \/\/ default attributes\n-                        nullptr);          \/\/ no template file\n-  return hPipe;\n-}\n-\n-\/\/ write to the pipe\n-BOOL Win32AttachOperation::write_pipe(HANDLE hPipe, char* buf, int len) {\n-  do {\n-    DWORD nwrote;\n-\n-    BOOL fSuccess = WriteFile(  hPipe,                  \/\/ pipe handle\n-                                (LPCVOID)buf,           \/\/ message\n-                                (DWORD)len,             \/\/ message length\n-                                &nwrote,                \/\/ bytes written\n-                                nullptr);                  \/\/ not overlapped\n-    if (!fSuccess) {\n-      return fSuccess;\n-    }\n-    buf += nwrote;\n-    len -= nwrote;\n-  } while (len > 0);\n-  return TRUE;\n-}\n-\n-\/\/ Complete the operation:\n-\/\/   - open the pipe to the client\n-\/\/   - write the operation result (a jint)\n-\/\/   - write the operation output (the result stream)\n-\/\/\n@@ -315,18 +426,1 @@\n-  HANDLE hPipe = open_pipe();\n-  int lastError = (int)::GetLastError();\n-  if (hPipe != INVALID_HANDLE_VALUE) {\n-    BOOL fSuccess;\n-\n-    char msg[32];\n-    os::snprintf(msg, sizeof(msg), \"%d\\n\", result);\n-    msg[sizeof(msg) - 1] = '\\0';\n-\n-    fSuccess = write_pipe(hPipe, msg, (int)strlen(msg));\n-    if (fSuccess) {\n-      fSuccess = write_pipe(hPipe, (char*)result_stream->base(), (int)(result_stream->size()));\n-    }\n-    lastError = (int)::GetLastError();\n-\n-    \/\/ Need to flush buffers\n-    FlushFileBuffers(hPipe);\n-    CloseHandle(hPipe);\n+  write_reply(&_pipe, result, result_stream);\n@@ -334,21 +428,1 @@\n-    if (fSuccess) {\n-      log_debug(attach)(\"wrote result of attach operation %s to pipe %s\", name(), pipe());\n-    } else {\n-      log_error(attach)(\"failure (%d) writing result of operation %s to pipe %s\", lastError, name(), pipe());\n-    }\n-  } else {\n-    log_error(attach)(\"could not open (%d) pipe %s to send result of operation %s\", lastError, pipe(), name());\n-  }\n-\n-  DWORD res = ::WaitForSingleObject(Win32AttachListener::mutex(), INFINITE);\n-  assert(res != WAIT_FAILED,   \"WaitForSingleObject failed with error code: %lu\", GetLastError());\n-  assert(res == WAIT_OBJECT_0, \"WaitForSingleObject failed with return value: %lu\", res);\n-\n-  if (res == WAIT_OBJECT_0) {\n-\n-    \/\/ put the operation back on the available list\n-    set_next(Win32AttachListener::available());\n-    Win32AttachListener::set_available(this);\n-\n-    ::ReleaseMutex(Win32AttachListener::mutex());\n-  }\n+  delete this;\n@@ -358,1 +432,1 @@\n-\/\/ AttachOperation functions\n+\/\/ AttachListener functions\n@@ -407,3 +481,3 @@\n-    JVM_EnqueueOperation(char* cmd, char* arg0, char* arg1, char* arg2, char* pipename) {\n-      return (jint)Win32AttachListener::enqueue(cmd, arg0, arg1, arg2, pipename);\n-    }\n+  JVM_EnqueueOperation(char* cmd, char* arg0, char* arg1, char* arg2, char* pipename) {\n+    return (jint)Win32AttachListener::enqueue(ATTACH_API_V1, cmd, arg0, arg1, arg2, pipename);\n+  }\n@@ -411,0 +485,4 @@\n+  JNIEXPORT jint JNICALL\n+  JVM_EnqueueOperation_v2(char* pipename) {\n+    return (jint)Win32AttachListener::enqueue(ATTACH_API_V2, \"\", \"\", \"\", \"\", pipename);\n+  }\n","filename":"src\/hotspot\/os\/windows\/attachListener_windows.cpp","additions":229,"deletions":151,"binary":false,"changes":380,"status":"modified"},{"patch":"@@ -5756,0 +5756,7 @@\n+    \/\/ The following code is only here to maintain the\n+    \/\/ characteristics\/performance from when an ObjectMonitor\n+    \/\/ \"responsible\" thread used to issue timed parks.\n+    HighResolutionInterval *phri = nullptr;\n+    if (!ForceTimeHighResolution) {\n+      phri = new HighResolutionInterval((jlong)1);\n+    }\n@@ -5757,0 +5764,1 @@\n+    delete phri; \/\/ if it is null, harmless\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+        hint    #0x22 \/\/ bti c\n@@ -44,0 +45,1 @@\n+        hint    #0x22 \/\/ bti c\n@@ -59,0 +61,1 @@\n+        hint    #0x22 \/\/ bti c\n@@ -60,1 +63,1 @@\n-        ldadd x1, x2, [x0]\n+        ldadd   x1, x2, [x0]\n@@ -73,0 +76,1 @@\n+        hint    #0x22 \/\/ bti c\n@@ -74,1 +78,1 @@\n-        ldadd w1, w2, [x0]\n+        ldadd   w1, w2, [x0]\n@@ -87,0 +91,1 @@\n+        hint    #0x22 \/\/ bti c\n@@ -101,0 +106,1 @@\n+        hint    #0x22 \/\/ bti c\n@@ -115,0 +121,1 @@\n+        hint    #0x22 \/\/ bti c\n@@ -134,0 +141,1 @@\n+        hint    #0x22 \/\/ bti c\n@@ -152,0 +160,1 @@\n+        hint    #0x22 \/\/ bti c\n@@ -170,0 +179,1 @@\n+        hint    #0x22 \/\/ bti c\n@@ -186,0 +196,1 @@\n+        hint    #0x22 \/\/ bti c\n@@ -202,0 +213,1 @@\n+        hint    #0x22 \/\/ bti c\n@@ -218,0 +230,1 @@\n+        hint    #0x22 \/\/ bti c\n@@ -234,0 +247,1 @@\n+        hint    #0x22 \/\/ bti c\n@@ -251,0 +265,1 @@\n+        hint    #0x22 \/\/ bti c\n@@ -267,0 +282,1 @@\n+        hint    #0x22 \/\/ bti c\n@@ -280,0 +296,32 @@\n+\n+\/* Emit .note.gnu.property section in case of PAC or BTI being enabled.\n+ * For more details see \"ELF for the Arm® 64-bit Architecture (AArch64)\".\n+ * https:\/\/github.com\/ARM-software\/abi-aa\/blob\/main\/aaelf64\/aaelf64.rst\n+ *\/\n+#ifdef __ARM_FEATURE_BTI_DEFAULT\n+    #ifdef __ARM_FEATURE_PAC_DEFAULT\n+        #define GNU_PROPERTY_AARCH64_FEATURE 3\n+    #else\n+        #define GNU_PROPERTY_AARCH64_FEATURE 1\n+    #endif\n+#else\n+    #ifdef __ARM_FEATURE_PAC_DEFAULT\n+        #define GNU_PROPERTY_AARCH64_FEATURE 2\n+    #else\n+        #define GNU_PROPERTY_AARCH64_FEATURE 0\n+    #endif\n+#endif\n+\n+#if (GNU_PROPERTY_AARCH64_FEATURE != 0)\n+        .pushsection .note.gnu.property, \"a\"\n+        .align  3\n+        .long   4          \/* name length *\/\n+        .long   0x10       \/* data length *\/\n+        .long   5          \/* note type: NT_GNU_PROPERTY_TYPE_0 *\/\n+        .string \"GNU\"      \/* vendor name *\/\n+        .long   0xc0000000 \/* GNU_PROPERTY_AARCH64_FEATURE_1_AND *\/\n+        .long   4          \/* pr_datasze *\/\n+        .long   GNU_PROPERTY_AARCH64_FEATURE\n+        .long   0\n+        .popsection\n+#endif\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/atomic_linux_aarch64.S","additions":50,"deletions":2,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -86,1 +86,3 @@\n-        ret                             \/\/ -8 == 0 words\n+        \/\/ -8 == 0 words\n+        hint    #0x24 \/\/ bti j\n+        ret\n@@ -88,1 +90,3 @@\n-        ldr     t0, [s, #16]            \/\/ -7 == 1 word\n+        \/\/ -7 == 1 word\n+        hint    #0x24 \/\/ bti j\n+        ldr     t0, [s, #16]\n@@ -92,1 +96,3 @@\n-        ldp     t0, t1, [s, #16]        \/\/ -6 = 2 words\n+        \/\/ -6 == 2 words\n+        hint    #0x24 \/\/ bti j\n+        ldp     t0, t1, [s, #16]\n@@ -96,1 +102,3 @@\n-        ldp     t0, t1, [s, #16]        \/\/ -5 = 3 words\n+        \/\/ -5 == 3 words\n+        hint    #0x24 \/\/ bti j\n+        ldp     t0, t1, [s, #16]\n@@ -102,1 +110,3 @@\n-        ldp     t0, t1, [s, #16]        \/\/ -4 = 4 words\n+        \/\/ -4 == 4 words\n+        hint    #0x24 \/\/ bti j\n+        ldp     t0, t1, [s, #16]\n@@ -108,1 +118,3 @@\n-        ldp     t0, t1, [s, #16]        \/\/ -3 = 5 words\n+        \/\/ -3 == 5 words\n+        hint    #0x24 \/\/ bti j\n+        ldp     t0, t1, [s, #16]\n@@ -116,1 +128,3 @@\n-        ldp     t0, t1, [s, #16]        \/\/ -2 = 6 words\n+        \/\/ -2 == 6 words\n+        hint    #0x24 \/\/ bti j\n+        ldp     t0, t1, [s, #16]\n@@ -124,1 +138,3 @@\n-        ldp     t0, t1, [s, #16]        \/\/ -1 = 7 words\n+        \/\/ -1 == 7 words\n+        hint    #0x24 \/\/ bti j\n+        ldp     t0, t1, [s, #16]\n@@ -131,2 +147,1 @@\n-        str     t6, [d, #64]\n-        \/\/ Is always aligned here, code for 7 words is one instruction\n+        \/\/ Is always aligned here, code for 7 words is two instructions\n@@ -136,0 +151,1 @@\n+        str     t6, [d, #64]\n@@ -187,1 +203,3 @@\n-        ret                             \/\/ -8 == 0 words\n+        \/\/ -8 == 0 words\n+        hint    #0x24 \/\/ bti j\n+        ret\n@@ -189,1 +207,3 @@\n-        ldr     t0, [s, #-8]            \/\/ -7 == 1 word\n+        \/\/ -7 == 1 word\n+        hint    #0x24 \/\/ bti j\n+        ldr     t0, [s, #-8]\n@@ -193,1 +213,3 @@\n-        ldp     t0, t1, [s, #-16]       \/\/ -6 = 2 words\n+        \/\/ -6 == 2 words\n+        hint    #0x24 \/\/ bti j\n+        ldp     t0, t1, [s, #-16]\n@@ -197,1 +219,3 @@\n-        ldp     t0, t1, [s, #-16]       \/\/ -5 = 3 words\n+        \/\/ -5 == 3 words\n+        hint    #0x24 \/\/ bti j\n+        ldp     t0, t1, [s, #-16]\n@@ -203,1 +227,3 @@\n-        ldp     t0, t1, [s, #-16]       \/\/ -4 = 4 words\n+        \/\/ -4 == 4 words\n+        hint    #0x24 \/\/ bti j\n+        ldp     t0, t1, [s, #-16]\n@@ -209,1 +235,3 @@\n-        ldp     t0, t1, [s, #-16]       \/\/ -3 = 5 words\n+        \/\/ -3 == 5 words\n+        hint    #0x24 \/\/ bti j\n+        ldp     t0, t1, [s, #-16]\n@@ -217,1 +245,3 @@\n-        ldp     t0, t1, [s, #-16]       \/\/ -2 = 6 words\n+        \/\/ -2 == 6 words\n+        hint    #0x24 \/\/ bti j\n+        ldp     t0, t1, [s, #-16]\n@@ -225,1 +255,3 @@\n-        ldp     t0, t1, [s, #-16]       \/\/ -1 = 7 words\n+        \/\/ -1 == 7 words\n+        hint    #0x24 \/\/ bti j\n+        ldp     t0, t1, [s, #-16]\n@@ -232,2 +264,1 @@\n-        str     t6, [d, #-56]\n-        \/\/ Is always aligned here, code for 7 words is one instruction\n+        \/\/ Is always aligned here, code for 7 words is two instructions\n@@ -237,0 +268,1 @@\n+        str     t6, [d, #-56]\n@@ -238,0 +270,32 @@\n+\n+\/* Emit .note.gnu.property section in case of PAC or BTI being enabled.\n+ * For more details see \"ELF for the Arm® 64-bit Architecture (AArch64)\".\n+ * https:\/\/github.com\/ARM-software\/abi-aa\/blob\/main\/aaelf64\/aaelf64.rst\n+ *\/\n+#ifdef __ARM_FEATURE_BTI_DEFAULT\n+    #ifdef __ARM_FEATURE_PAC_DEFAULT\n+        #define GNU_PROPERTY_AARCH64_FEATURE 3\n+    #else\n+        #define GNU_PROPERTY_AARCH64_FEATURE 1\n+    #endif\n+#else\n+    #ifdef __ARM_FEATURE_PAC_DEFAULT\n+        #define GNU_PROPERTY_AARCH64_FEATURE 2\n+    #else\n+        #define GNU_PROPERTY_AARCH64_FEATURE 0\n+    #endif\n+#endif\n+\n+#if (GNU_PROPERTY_AARCH64_FEATURE != 0)\n+        .pushsection .note.gnu.property, \"a\"\n+        .align  3\n+        .long   4          \/* name length *\/\n+        .long   0x10       \/* data length *\/\n+        .long   5          \/* note type: NT_GNU_PROPERTY_TYPE_0 *\/\n+        .string \"GNU\"      \/* vendor name *\/\n+        .long   0xc0000000 \/* GNU_PROPERTY_AARCH64_FEATURE_1_AND *\/\n+        .long   4          \/* pr_datasze *\/\n+        .long   GNU_PROPERTY_AARCH64_FEATURE\n+        .long   0\n+        .popsection\n+#endif\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/copy_linux_aarch64.S","additions":84,"deletions":20,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -51,0 +51,32 @@\n+\n+\/* Emit .note.gnu.property section in case of PAC or BTI being enabled.\n+ * For more details see \"ELF for the Arm® 64-bit Architecture (AArch64)\".\n+ * https:\/\/github.com\/ARM-software\/abi-aa\/blob\/main\/aaelf64\/aaelf64.rst\n+ *\/\n+#ifdef __ARM_FEATURE_BTI_DEFAULT\n+    #ifdef __ARM_FEATURE_PAC_DEFAULT\n+        #define GNU_PROPERTY_AARCH64_FEATURE 3\n+    #else\n+        #define GNU_PROPERTY_AARCH64_FEATURE 1\n+    #endif\n+#else\n+    #ifdef __ARM_FEATURE_PAC_DEFAULT\n+        #define GNU_PROPERTY_AARCH64_FEATURE 2\n+    #else\n+        #define GNU_PROPERTY_AARCH64_FEATURE 0\n+    #endif\n+#endif\n+\n+#if (GNU_PROPERTY_AARCH64_FEATURE != 0)\n+        .pushsection .note.gnu.property, \"a\"\n+        .align  3\n+        .long   4          \/* name length *\/\n+        .long   0x10       \/* data length *\/\n+        .long   5          \/* note type: NT_GNU_PROPERTY_TYPE_0 *\/\n+        .string \"GNU\"      \/* vendor name *\/\n+        .long   0xc0000000 \/* GNU_PROPERTY_AARCH64_FEATURE_1_AND *\/\n+        .long   4          \/* pr_datasze *\/\n+        .long   GNU_PROPERTY_AARCH64_FEATURE\n+        .long   0\n+        .popsection\n+#endif\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/safefetch_linux_aarch64.S","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -47,0 +47,32 @@\n+\n+\/* Emit .note.gnu.property section in case of PAC or BTI being enabled.\n+ * For more details see \"ELF for the Arm® 64-bit Architecture (AArch64)\".\n+ * https:\/\/github.com\/ARM-software\/abi-aa\/blob\/main\/aaelf64\/aaelf64.rst\n+ *\/\n+#ifdef __ARM_FEATURE_BTI_DEFAULT\n+    #ifdef __ARM_FEATURE_PAC_DEFAULT\n+        #define GNU_PROPERTY_AARCH64_FEATURE 3\n+    #else\n+        #define GNU_PROPERTY_AARCH64_FEATURE 1\n+    #endif\n+#else\n+    #ifdef __ARM_FEATURE_PAC_DEFAULT\n+        #define GNU_PROPERTY_AARCH64_FEATURE 2\n+    #else\n+        #define GNU_PROPERTY_AARCH64_FEATURE 0\n+    #endif\n+#endif\n+\n+#if (GNU_PROPERTY_AARCH64_FEATURE != 0)\n+        .pushsection .note.gnu.property, \"a\"\n+        .align  3\n+        .long   4          \/* name length *\/\n+        .long   0x10       \/* data length *\/\n+        .long   5          \/* note type: NT_GNU_PROPERTY_TYPE_0 *\/\n+        .string \"GNU\"      \/* vendor name *\/\n+        .long   0xc0000000 \/* GNU_PROPERTY_AARCH64_FEATURE_1_AND *\/\n+        .long   4          \/* pr_datasze *\/\n+        .long   GNU_PROPERTY_AARCH64_FEATURE\n+        .long   0\n+        .popsection\n+#endif\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/threadLS_linux_aarch64.S","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-#define   RISCV_HWPROBE_EXT_ZVFHMIN             (1 << 31)\n+#define   RISCV_HWPROBE_EXT_ZVFHMIN             (1ULL << 31)\n@@ -181,0 +181,3 @@\n+  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZVFH)) {\n+    VM_Version::ext_Zvfh.enable_feature();\n+  }\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/riscv_hwprobe.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -389,0 +389,7 @@\n+  \/\/ Klass is being deallocated. Java mirror can still be alive, and it should not\n+  \/\/ point to dead klass. We need to break the link from mirror to the Klass.\n+  \/\/ See how InstanceKlass::deallocate_contents does it for normal mirrors.\n+  oop mirror = _scratch_java_mirror_table->get_oop(k);\n+  if (mirror != nullptr) {\n+    java_lang_Class::set_klass(mirror, nullptr);\n+  }\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-  \/\/ Can this VM write a heap region into the CDS archive? Currently only {G1|Parallel|Serial}+compressed_cp\n+  \/\/ Can this VM write a heap region into the CDS archive?\n@@ -152,1 +152,6 @@\n-      return (UseG1GC || UseParallelGC || UseSerialGC) && UseCompressedClassPointers;\n+      \/\/ Need compressed class pointers for heap region dump.\n+      if (!UseCompressedClassPointers) {\n+        return false;\n+      }\n+      \/\/ Almost all GCs support heap region dump, except ZGC (so far).\n+      return !UseZGC;\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -723,1 +723,1 @@\n-                                                      Deoptimization::Action_none));\n+                                                         Deoptimization::Action_none));\n@@ -729,0 +729,6 @@\n+    if (!con.is_loaded()) {\n+      trap(str, nullptr, Deoptimization::make_trap_request(Deoptimization::Reason_unloaded,\n+                                                           Deoptimization::Action_reinterpret,\n+                                                           cp_index));\n+      return;\n+    }\n@@ -2210,1 +2216,0 @@\n-    \/\/ %%% FIXME: ldc of Class can generate an exception\n@@ -2214,1 +2219,1 @@\n-      return str.is_in_error();\n+      return str.is_in_error() || !str.get_constant().is_loaded();\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -414,17 +414,0 @@\n-#ifdef ASSERT\n-PRAGMA_DIAG_PUSH\n-PRAGMA_FORMAT_NONLITERAL_IGNORED\n-void ClassFileParser::report_assert_property_failure(const char* msg, TRAPS) const {\n-  ResourceMark rm(THREAD);\n-  fatal(msg, _class_name->as_C_string());\n-}\n-\n-void ClassFileParser::report_assert_property_failure(const char* msg,\n-                                                     int index,\n-                                                     TRAPS) const {\n-  ResourceMark rm(THREAD);\n-  fatal(msg, index, _class_name->as_C_string());\n-}\n-PRAGMA_DIAG_POP\n-#endif\n-\n@@ -465,1 +448,1 @@\n-        check_property(valid_klass_reference_at(klass_ref_index),\n+        guarantee_property(valid_klass_reference_at(klass_ref_index),\n@@ -468,1 +451,1 @@\n-        check_property(valid_cp_range(name_and_type_ref_index, length) &&\n+        guarantee_property(valid_cp_range(name_and_type_ref_index, length) &&\n@@ -485,1 +468,1 @@\n-        check_property(\n+        guarantee_property(\n@@ -495,1 +478,1 @@\n-        check_property(valid_symbol_at(name_ref_index),\n+        guarantee_property(valid_symbol_at(name_ref_index),\n@@ -498,1 +481,1 @@\n-        check_property(valid_symbol_at(signature_ref_index),\n+        guarantee_property(valid_symbol_at(signature_ref_index),\n@@ -512,1 +495,1 @@\n-        check_property(valid_symbol_at(class_index),\n+        guarantee_property(valid_symbol_at(class_index),\n@@ -520,1 +503,1 @@\n-        check_property(valid_symbol_at(string_index),\n+        guarantee_property(valid_symbol_at(string_index),\n@@ -529,1 +512,1 @@\n-        check_property(valid_cp_range(ref_index, length),\n+        guarantee_property(valid_cp_range(ref_index, length),\n@@ -540,1 +523,1 @@\n-            check_property(\n+            guarantee_property(\n@@ -548,1 +531,1 @@\n-            check_property(\n+            guarantee_property(\n@@ -556,1 +539,1 @@\n-            check_property(\n+            guarantee_property(\n@@ -564,1 +547,1 @@\n-            check_property(\n+            guarantee_property(\n@@ -582,1 +565,1 @@\n-        check_property(valid_symbol_at(ref_index),\n+        guarantee_property(valid_symbol_at(ref_index),\n@@ -591,1 +574,1 @@\n-        check_property(valid_cp_range(name_and_type_ref_index, length) &&\n+        guarantee_property(valid_cp_range(name_and_type_ref_index, length) &&\n@@ -606,1 +589,1 @@\n-        check_property(valid_cp_range(name_and_type_ref_index, length) &&\n+        guarantee_property(valid_cp_range(name_and_type_ref_index, length) &&\n@@ -824,1 +807,1 @@\n-      check_property(\n+      guarantee_property(\n@@ -1258,4 +1241,4 @@\n-    check_property(valid_symbol_at(attribute_name_index),\n-                   \"Invalid field attribute index %u in class file %s\",\n-                   attribute_name_index,\n-                   CHECK);\n+    guarantee_property(valid_symbol_at(attribute_name_index),\n+                       \"Invalid field attribute index %u in class file %s\",\n+                       attribute_name_index,\n+                       CHECK);\n@@ -1270,1 +1253,1 @@\n-      check_property(\n+      guarantee_property(\n@@ -1416,1 +1399,1 @@\n-    check_property(valid_symbol_at(name_index),\n+    guarantee_property(valid_symbol_at(name_index),\n@@ -1423,1 +1406,1 @@\n-    check_property(valid_symbol_at(signature_index),\n+    guarantee_property(valid_symbol_at(signature_index),\n@@ -1601,1 +1584,1 @@\n-  check_property(\n+  guarantee_property(\n@@ -1791,1 +1774,1 @@\n-      check_property(\n+      guarantee_property(\n@@ -2140,1 +2123,1 @@\n-  check_property(\n+  guarantee_property(\n@@ -2238,1 +2221,1 @@\n-    check_property(\n+    guarantee_property(\n@@ -2313,4 +2296,4 @@\n-        check_property(valid_symbol_at(code_attribute_name_index),\n-                       \"Invalid code attribute name index %u in class file %s\",\n-                       code_attribute_name_index,\n-                       CHECK_NULL);\n+        guarantee_property(valid_symbol_at(code_attribute_name_index),\n+                           \"Invalid code attribute name index %u in class file %s\",\n+                           code_attribute_name_index,\n+                           CHECK_NULL);\n@@ -2801,1 +2784,1 @@\n-  check_property(\n+  guarantee_property(\n@@ -2815,1 +2798,1 @@\n-  check_property(\n+  guarantee_property(\n@@ -2962,1 +2945,1 @@\n-    check_property(\n+    guarantee_property(\n@@ -2968,1 +2951,1 @@\n-    check_property(\n+    guarantee_property(\n@@ -2982,1 +2965,1 @@\n-    check_property(\n+    guarantee_property(\n@@ -3058,1 +3041,1 @@\n-    check_property(\n+    guarantee_property(\n@@ -3091,1 +3074,1 @@\n-      check_property(\n+      guarantee_property(\n@@ -3140,1 +3123,1 @@\n-    check_property(valid_symbol_at(name_index),\n+    guarantee_property(valid_symbol_at(name_index),\n@@ -3147,1 +3130,1 @@\n-    check_property(valid_symbol_at(descriptor_index),\n+    guarantee_property(valid_symbol_at(descriptor_index),\n@@ -3170,1 +3153,1 @@\n-      check_property(\n+      guarantee_property(\n@@ -3268,1 +3251,1 @@\n-  check_property(\n+  guarantee_property(\n@@ -3326,1 +3309,1 @@\n-    check_property(\n+    guarantee_property(\n@@ -3343,1 +3326,1 @@\n-      check_property(\n+      guarantee_property(\n@@ -3404,1 +3387,1 @@\n-    check_property(\n+    guarantee_property(\n@@ -3516,1 +3499,1 @@\n-        check_property(valid_klass_reference_at(enclosing_method_class_index),\n+        guarantee_property(valid_klass_reference_at(enclosing_method_class_index),\n@@ -3583,1 +3566,1 @@\n-          check_property(\n+          guarantee_property(\n@@ -3792,4 +3775,4 @@\n-    check_property(_class_name == vmSymbols::java_lang_Object(),\n-                   \"Invalid superclass index %u in class file %s\",\n-                   super_class_index,\n-                   CHECK_NULL);\n+    guarantee_property(_class_name == vmSymbols::java_lang_Object(),\n+                       \"Invalid superclass index %u in class file %s\",\n+                       super_class_index,\n+                       CHECK_NULL);\n@@ -3797,4 +3780,4 @@\n-    check_property(valid_klass_reference_at(super_class_index),\n-                   \"Invalid superclass index %u in class file %s\",\n-                   super_class_index,\n-                   CHECK_NULL);\n+    guarantee_property(valid_klass_reference_at(super_class_index),\n+                       \"Invalid superclass index %u in class file %s\",\n+                       super_class_index,\n+                       CHECK_NULL);\n@@ -4079,20 +4062,0 @@\n-    \/\/ If the loader is not the boot loader then throw an exception if its\n-    \/\/ superclass is in package jdk.internal.reflect and its loader is not a\n-    \/\/ special reflection class loader\n-    if (!this_klass->class_loader_data()->is_the_null_class_loader_data()) {\n-      PackageEntry* super_package = super->package();\n-      if (super_package != nullptr &&\n-          super_package->name()->fast_compare(vmSymbols::jdk_internal_reflect()) == 0 &&\n-          !java_lang_ClassLoader::is_reflection_class_loader(this_klass->class_loader())) {\n-        ResourceMark rm(THREAD);\n-        Exceptions::fthrow(\n-          THREAD_AND_LOCATION,\n-          vmSymbols::java_lang_IllegalAccessError(),\n-          \"class %s loaded by %s cannot access jdk\/internal\/reflect superclass %s\",\n-          this_klass->external_name(),\n-          this_klass->class_loader_data()->loader_name_and_id(),\n-          super->external_name());\n-        return;\n-      }\n-    }\n-\n@@ -5109,1 +5072,1 @@\n-  Handle clh = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(cl));\n+  Handle clh = Handle(THREAD, cl);\n@@ -5546,1 +5509,1 @@\n-  check_property(\n+  guarantee_property(\n@@ -5727,3 +5690,3 @@\n-    check_property(_local_interfaces == Universe::the_empty_instance_klass_array(),\n-                   \"java.lang.Object cannot implement an interface in class file %s\",\n-                   CHECK);\n+    guarantee_property(_local_interfaces == Universe::the_empty_instance_klass_array(),\n+                       \"java.lang.Object cannot implement an interface in class file %s\",\n+                       CHECK);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":60,"deletions":97,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -381,38 +381,0 @@\n-  void report_assert_property_failure(const char* msg, TRAPS) const PRODUCT_RETURN;\n-  void report_assert_property_failure(const char* msg, int index, TRAPS) const PRODUCT_RETURN;\n-\n-  inline void assert_property(bool b, const char* msg, TRAPS) const {\n-#ifdef ASSERT\n-    if (!b) {\n-      report_assert_property_failure(msg, THREAD);\n-    }\n-#endif\n-  }\n-\n-  inline void assert_property(bool b, const char* msg, int index, TRAPS) const {\n-#ifdef ASSERT\n-    if (!b) {\n-      report_assert_property_failure(msg, index, THREAD);\n-    }\n-#endif\n-  }\n-\n-  inline void check_property(bool property,\n-                             const char* msg,\n-                             int index,\n-                             TRAPS) const {\n-    if (_need_verify) {\n-      guarantee_property(property, msg, index, CHECK);\n-    } else {\n-      assert_property(property, msg, index, CHECK);\n-    }\n-  }\n-\n-  inline void check_property(bool property, const char* msg, TRAPS) const {\n-    if (_need_verify) {\n-      guarantee_property(property, msg, CHECK);\n-    } else {\n-      assert_property(property, msg, CHECK);\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":0,"deletions":38,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -647,2 +647,0 @@\n-  } else if (class_loader()->is_a(vmClasses::reflect_DelegatingClassLoader_klass())) {\n-    size = 1;  \/\/ there's only one class in relection class loader and no initiated classes\n@@ -818,2 +816,0 @@\n-      } else if (class_loader()->is_a(vmClasses::reflect_DelegatingClassLoader_klass())) {\n-        metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::ReflectionMetaspaceType);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4766,3 +4766,0 @@\n-  \/\/ Fix for 4474172; see evaluation for more details\n-  loader = non_reflection_class_loader(loader);\n-\n@@ -4777,23 +4774,0 @@\n-\/\/ Return true if this is one of the class loaders associated with\n-\/\/ the generated bytecodes for serialization constructor returned\n-\/\/ by sun.reflect.ReflectionFactory::newConstructorForSerialization\n-bool java_lang_ClassLoader::is_reflection_class_loader(oop loader) {\n-  if (loader != nullptr) {\n-    Klass* delegating_cl_class = vmClasses::reflect_DelegatingClassLoader_klass();\n-    \/\/ This might be null in non-1.4 JDKs\n-    return (delegating_cl_class != nullptr && loader->is_a(delegating_cl_class));\n-  }\n-  return false;\n-}\n-\n-oop java_lang_ClassLoader::non_reflection_class_loader(oop loader) {\n-  \/\/ See whether this is one of the class loaders associated with\n-  \/\/ the generated bytecodes for reflection, and if so, \"magically\"\n-  \/\/ delegate to its parent to prevent class loading from occurring\n-  \/\/ in places where applications using reflection didn't expect it.\n-  if (is_reflection_class_loader(loader)) {\n-    return parent(loader);\n-  }\n-  return loader;\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1505,8 +1505,0 @@\n-  \/\/ Return true if this is one of the class loaders associated with\n-  \/\/ the generated bytecodes for serialization constructor returned\n-  \/\/ by sun.reflect.ReflectionFactory::newConstructorForSerialization\n-  static bool is_reflection_class_loader(oop loader);\n-\n-  \/\/ Fix for 4474172\n-  static oop  non_reflection_class_loader(oop loader);\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -312,5 +312,0 @@\n-  \/\/ Make sure loader is not the jdk.internal.reflect.DelegatingClassLoader.\n-  if (loader != java_lang_ClassLoader::non_reflection_class_loader(loader)) {\n-    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),\n-              \"Class loader is an invalid delegating class loader\");\n-  }\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -601,2 +601,0 @@\n-  \/\/ Fix for 4474172; see evaluation for more details\n-  class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));\n@@ -768,6 +766,1 @@\n-  \/\/ The result of this call should be consistent with the result\n-  \/\/ of the call to resolve_instance_class_or_null().\n-  \/\/ See evaluation 6790209 and 4474172 for more details.\n-  oop class_loader_oop = java_lang_ClassLoader::non_reflection_class_loader(class_loader());\n-  ClassLoaderData* loader_data = ClassLoaderData::class_loader_data_or_null(class_loader_oop);\n-\n+  ClassLoaderData* loader_data = ClassLoaderData::class_loader_data_or_null(class_loader());\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -406,3 +406,0 @@\n-      \/\/ Fix for 4474172; see evaluation for more details\n-      class_loader = Handle(\n-        THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -278,4 +278,0 @@\n-  Klass* refl_serialization_ctor_klass = vmClasses::reflect_SerializationConstructorAccessorImpl_klass();\n-\n-  bool is_reflect_accessor = refl_serialization_ctor_klass != nullptr &&\n-                                klass->is_subtype_of(refl_serialization_ctor_klass);\n@@ -298,6 +294,1 @@\n-    !(klass->is_shared() && klass->is_rewritten()) &&\n-\n-    \/\/ As of the fix for 4486457 we disable verification for all of the\n-    \/\/ dynamically-generated bytecodes associated with\n-    \/\/ jdk\/internal\/reflect\/SerializationConstructorAccessor.\n-    (!is_reflect_accessor));\n+    !(klass->is_shared() && klass->is_rewritten()));\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -110,1 +110,0 @@\n-  do_klass(reflect_DelegatingClassLoader_klass,         reflect_DelegatingClassLoader                         ) \\\n@@ -114,1 +113,0 @@\n-  do_klass(reflect_SerializationConstructorAccessorImpl_klass,           reflect_SerializationConstructorAccessorImpl ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -265,1 +265,0 @@\n-  template(reflect_DelegatingClassLoader,             \"jdk\/internal\/reflect\/DelegatingClassLoader\")   \\\n@@ -270,1 +269,0 @@\n-  template(reflect_SerializationConstructorAccessorImpl,             \"jdk\/internal\/reflect\/SerializationConstructorAccessorImpl\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2598,0 +2598,1 @@\n+  size_t total_old_allocated = _old_evac_stats.allocated() + _old_evac_stats.direct_allocated();\n@@ -2599,1 +2600,1 @@\n-    add_allocated_bytes_since_last_gc(_old_evac_stats.allocated() * HeapWordSize);\n+    add_allocated_bytes_since_last_gc(total_old_allocated * HeapWordSize);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n- }\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1IHOPControl.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-  \/\/ Total number of bytes allocated in the old generation during\n-  \/\/ last mutator period.\n+  \/\/ Total number of bytes allocated in the old generation at the end\n+  \/\/ of the last gc.\n@@ -38,2 +38,2 @@\n-  \/\/ Total growth of the old geneneration for last mutator period,\n-  \/\/ taking eager reclaim into consideration.\n+  \/\/ Total growth of the old geneneration since the last gc,\n+  \/\/ taking eager-reclaim into consideration.\n@@ -45,1 +45,1 @@\n-  \/\/ Non-humongous old generation allocations during last mutator period.\n+  \/\/ Non-humongous old generation allocations since the last gc.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OldGenAllocationTracker.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/spaceDecorator.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableSpace.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/shared\/spaceDecorator.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+#include \"gc\/shared\/spaceDecorator.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include \"gc\/shared\/spaceDecorator.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+#include \"gc\/shared\/spaceDecorator.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/psYoungGen.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -94,0 +94,1 @@\n+     static_field(CollectedHeap,               _lab_alignment_reserve,                        size_t)                                \\\n","filename":"src\/hotspot\/share\/gc\/shared\/vmStructs_gc.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1044,0 +1044,1 @@\n+        !u->depends_only_on_test() && \/\/ preserve dependency on test\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/z\/zLargePages.inline.hpp\"\n@@ -49,0 +50,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -235,3 +237,8 @@\n-  const ZPhysicalMemoryManager* const _physical;\n-  volatile zoffset                    _start;\n-  const zoffset_end                   _end;\n+  volatile uintptr_t _current;\n+  const uintptr_t    _end;\n+\n+  static void pretouch(zaddress zaddr, size_t size) {\n+    const uintptr_t addr = untype(zaddr);\n+    const size_t page_size = ZLargePages::is_explicit() ? ZGranuleSize : os::vm_page_size();\n+    os::pretouch_memory((void*)addr, (void*)(addr + size), page_size);\n+  }\n@@ -240,1 +247,1 @@\n-  ZPreTouchTask(const ZPhysicalMemoryManager* physical, zoffset start, zoffset_end end)\n+  ZPreTouchTask(zoffset start, zoffset_end end)\n@@ -242,3 +249,2 @@\n-      _physical(physical),\n-      _start(start),\n-      _end(end) {}\n+      _current(untype(start)),\n+      _end(untype(end)) {}\n@@ -247,0 +253,2 @@\n+    const size_t size = ZGranuleSize;\n+\n@@ -248,4 +256,3 @@\n-      \/\/ Get granule offset\n-      const size_t size = ZGranuleSize;\n-      const zoffset offset = to_zoffset(Atomic::fetch_then_add((uintptr_t*)&_start, size));\n-      if (offset >= _end) {\n+      \/\/ Claim an offset for this thread\n+      const uintptr_t claimed = Atomic::fetch_then_add(&_current, size);\n+      if (claimed >= _end) {\n@@ -256,2 +263,6 @@\n-      \/\/ Pre-touch granule\n-      _physical->pretouch(offset, size);\n+      \/\/ At this point we know that we have a valid zoffset \/ zaddress.\n+      const zoffset offset = to_zoffset(claimed);\n+      const zaddress addr = ZOffset::address(offset);\n+\n+      \/\/ Pre-touch the granule\n+      pretouch(addr, size);\n@@ -274,1 +285,1 @@\n-    ZPreTouchTask task(&_physical, page->start(), page->end());\n+    ZPreTouchTask task(page->start(), page->end());\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.cpp","additions":25,"deletions":14,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-  add_segment(segment);\n+  _segments.append(segment);\n@@ -53,2 +53,2 @@\n-  : _segments() {\n-  add_segments(pmem);\n+  : _segments(pmem.nsegments()) {\n+  _segments.appendAll(&pmem._segments);\n@@ -58,2 +58,4 @@\n-  \/\/ Free segments\n-  _segments.clear_and_deallocate();\n+  \/\/ Check for self-assignment\n+  if (this == &pmem) {\n+    return *this;\n+  }\n@@ -61,2 +63,4 @@\n-  \/\/ Copy segments\n-  add_segments(pmem);\n+  \/\/ Free and copy segments\n+  _segments.clear_and_deallocate();\n+  _segments.reserve(pmem.nsegments());\n+  _segments.appendAll(&pmem._segments);\n@@ -356,6 +360,0 @@\n-void ZPhysicalMemoryManager::pretouch(zoffset offset, size_t size) const {\n-  const uintptr_t addr = untype(ZOffset::address(offset));\n-  const size_t page_size = ZLargePages::is_explicit() ? ZGranuleSize : os::vm_page_size();\n-  os::pretouch_memory((void*)addr, (void*)(addr + size), page_size);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zPhysicalMemory.cpp","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -87,4 +87,0 @@\n-  void pretouch_view(zaddress addr, size_t size) const;\n-  void map_view(zaddress_unsafe addr, const ZPhysicalMemory& pmem) const;\n-  void unmap_view(zaddress_unsafe addr, size_t size) const;\n-\n@@ -105,2 +101,0 @@\n-  void pretouch(zoffset offset, size_t size) const;\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zPhysicalMemory.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1203,7 +1203,1 @@\n-    \/\/ Disable verification for the dynamically-generated reflection bytecodes\n-    \/\/ for serialization constructor accessor.\n-    bool is_reflect = klass_to_check->is_subclass_of(\n-                        vmClasses::reflect_SerializationConstructorAccessorImpl_klass());\n-\n-    if (!is_reflect &&\n-        !klass_to_check->is_same_or_direct_interface(resolved_klass)) {\n+    if (!klass_to_check->is_same_or_direct_interface(resolved_klass)) {\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-volatile intx JVMCI::_fatal_log_init_thread = -1;\n+volatile intx JVMCI::_first_error_tid = -1;\n@@ -357,1 +357,1 @@\n-  if (_fatal_log_init_thread == invalid_id && Atomic::cmpxchg(&_fatal_log_init_thread, invalid_id, current_thread_id) == invalid_id) {\n+  if (_first_error_tid == invalid_id && Atomic::cmpxchg(&_first_error_tid, invalid_id, current_thread_id) == invalid_id) {\n@@ -378,8 +378,7 @@\n-  } else {\n-    \/\/ Another thread won the race to initialize the stream. Give it time\n-    \/\/ to complete initialization. VM locks cannot be used as the current\n-    \/\/ thread might not be attached to the VM (e.g. a native thread started\n-    \/\/ within libjvmci).\n-    while (_fatal_log_fd == -1) {\n-      os::naked_short_sleep(50);\n-    }\n+  } else if (_first_error_tid != current_thread_id) {\n+    \/\/ This is not the first thread reporting a libjvmci error\n+    tty->print_cr(\"[thread \" INTX_FORMAT \" also had an error in the JVMCI native library]\",\n+                    current_thread_id);\n+\n+    \/\/ Fatal error reporting is single threaded so just block this thread.\n+    os::infinite_sleep();\n","filename":"src\/hotspot\/share\/jvmci\/jvmci.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -120,2 +120,2 @@\n-  \/\/ Native thread id of thread that will initialize _fatal_log_fd.\n-  static volatile intx _fatal_log_init_thread;\n+  \/\/ Thread id of the first thread reporting a libjvmci error.\n+  static volatile intx _first_error_tid;\n","filename":"src\/hotspot\/share\/jvmci\/jvmci.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -372,0 +372,3 @@\n+\/\/ Compressed oop support is not relevant in 32bit builds.\n+#ifdef _LP64\n+\n@@ -597,2 +600,2 @@\n-    while (addresses[i] &&                                 \/\/ End of array not yet reached.\n-           ((_base == nullptr) ||                             \/\/ No previous try succeeded.\n+    while ((addresses[i] != nullptr) &&                    \/\/ End of array not yet reached.\n+           ((_base == nullptr) ||                          \/\/ No previous try succeeded.\n@@ -615,0 +618,2 @@\n+#endif \/\/ _LP64\n+\n@@ -639,0 +644,1 @@\n+#ifdef _LP64\n@@ -646,0 +652,3 @@\n+#else\n+    ShouldNotReachHere();\n+#endif \/\/ _LP64\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,0 +136,4 @@\n+\n+  \/\/ Compressed oop support is not relevant in 32bit builds.\n+#ifdef _LP64\n+\n@@ -144,0 +148,3 @@\n+\n+#endif \/\/ _LP64\n+\n","filename":"src\/hotspot\/share\/memory\/virtualspace.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2455,5 +2455,5 @@\n-  \/\/ be rewritten during runtime (see Rewriter::rewrite_jsrs()). So setting the _methods to\n-  \/\/ be writable. The length check on the _methods is necessary because classes which\n-  \/\/ don't have any methods share the Universe::_the_empty_method_array which is in the RO region.\n-  if (_methods != nullptr && _methods->length() > 0 &&\n-      !can_be_verified_at_dumptime() && methods_contain_jsr_bytecode()) {\n+  \/\/ be rewritten during runtime (see Rewriter::rewrite_jsrs()) but they cannot be safely\n+  \/\/ checked here with ByteCodeStream. All methods that can't be verified are made writable.\n+  \/\/ The length check on the _methods is necessary because classes which don't have any\n+  \/\/ methods share the Universe::_the_empty_method_array which is in the RO region.\n+  if (_methods != nullptr && _methods->length() > 0 && !can_be_verified_at_dumptime()) {\n@@ -2700,15 +2700,0 @@\n-\n-bool InstanceKlass::methods_contain_jsr_bytecode() const {\n-  Thread* thread = Thread::current();\n-  for (int i = 0; i < _methods->length(); i++) {\n-    methodHandle m(thread, _methods->at(i));\n-    BytecodeStream bcs(m);\n-    while (!bcs.is_last_bytecode()) {\n-      Bytecodes::Code opcode = bcs.next();\n-      if (opcode == Bytecodes::_jsr || opcode == Bytecodes::_jsr_w) {\n-        return true;\n-      }\n-    }\n-  }\n-  return false;\n-}\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":5,"deletions":20,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1119,1 +1119,0 @@\n-  bool methods_contain_jsr_bytecode() const;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -273,1 +273,1 @@\n-macro(Opaque4)\n+macro(OpaqueNotNull)\n@@ -275,0 +275,1 @@\n+macro(OpaqueTemplateAssertionPredicate)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -396,1 +396,1 @@\n-  if (dead->Opcode() == Op_Opaque4) {\n+  if (dead->is_OpaqueTemplateAssertionPredicate()) {\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -373,1 +373,2 @@\n-  GrowableArray<Node*>  _template_assertion_predicate_opaqs; \/\/ List of Opaque4 nodes for Template Assertion Predicates.\n+  \/\/ List of OpaqueTemplateAssertionPredicateNode nodes for Template Assertion Predicates.\n+  GrowableArray<Node*>  _template_assertion_predicate_opaqs;\n@@ -773,1 +774,1 @@\n-           \"duplicate entry in template assertion predicate opaque4 list\");\n+           \"Duplicate entry in Template Assertion Predicate OpaqueTemplateAssertionPredicate list\");\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -577,3 +577,1 @@\n-          \/\/ We may have Opaque4 node between If and Bool nodes.\n-          \/\/ Bail out in such case - we need to preserve Opaque4 for correct\n-          \/\/ processing predicates after loop opts.\n+          \/\/ We may have an OpaqueNotNull node between If and Bool nodes. Bail out in such case.\n@@ -585,0 +583,2 @@\n+          } else {\n+            assert(iff->in(1)->is_OpaqueNotNull(), \"must be OpaqueNotNull\");\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1461,1 +1461,1 @@\n-\/\/ an Opaque4 node that will cause the check to be removed after loop\n+\/\/ an OpaqueNotNull node that will cause the check to be removed after loop\n@@ -1469,3 +1469,3 @@\n-  Node *tst = _gvn.transform(new BoolNode(chk, BoolTest::ne));\n-  Node* opaq = _gvn.transform(new Opaque4Node(C, tst, intcon(1)));\n-  IfNode *iff = new IfNode(control(), opaq, PROB_MAX, COUNT_UNKNOWN);\n+  Node* tst = _gvn.transform(new BoolNode(chk, BoolTest::ne));\n+  Node* opaq = _gvn.transform(new OpaqueNotNullNode(C, tst));\n+  IfNode* iff = new IfNode(control(), opaq, PROB_MAX, COUNT_UNKNOWN);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -341,1 +341,2 @@\n-\/\/ is set, then the Opaque4 nodes of the Assertion Predicates are put on the list instead of the projections.\n+\/\/ is set, then the OpaqueTemplateAssertionPredicate nodes of the Assertion Predicates are put on the list instead of\n+\/\/ the projections.\n@@ -356,1 +357,1 @@\n-    if (bol->is_Opaque4()) {\n+    if (bol->is_OpaqueTemplateAssertionPredicate()) {\n@@ -359,1 +360,1 @@\n-        \/\/ Collect the predicate Opaque4 node.\n+        \/\/ Collect the OpaqueTemplateAssertionPredicateNode.\n@@ -377,2 +378,2 @@\n-  TemplateAssertionExpression template_assertion_expression(template_assertion_predicate->in(1)->as_Opaque4());\n-  Opaque4Node* cloned_opaque4_node = template_assertion_expression.clone(parse_predicate_proj->in(0)->in(0), this);\n+  TemplateAssertionExpression template_assertion_expression(template_assertion_predicate->in(1)->as_OpaqueTemplateAssertionPredicate());\n+  OpaqueTemplateAssertionPredicateNode* cloned_opaque_node = template_assertion_expression.clone(parse_predicate_proj->in(0)->in(0), this);\n@@ -381,1 +382,1 @@\n-  _igvn.replace_input_of(if_proj->in(0), 1, cloned_opaque4_node);\n+  _igvn.replace_input_of(if_proj->in(0), 1, cloned_opaque_node);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1192,2 +1192,4 @@\n-        assert(bol->is_Opaque4() || bol->is_OpaqueInitializedAssertionPredicate(),\n-               \"Opaque node of non-null-check or of Initialized Assertion Predicate\");\n+        assert(bol->is_OpaqueNotNull() ||\n+               bol->is_OpaqueTemplateAssertionPredicate() ||\n+               bol->is_OpaqueInitializedAssertionPredicate(),\n+               \"Opaque node of a non-null-check or an Assertion Predicate\");\n@@ -1362,1 +1364,1 @@\n-      if (bol->is_Opaque4()) {\n+      if (bol->is_OpaqueTemplateAssertionPredicate()) {\n@@ -1402,0 +1404,1 @@\n+#ifdef ASSERT\n@@ -1406,1 +1409,0 @@\n-#ifdef ASSERT\n@@ -1432,1 +1434,0 @@\n-#endif\n@@ -1436,0 +1437,1 @@\n+#endif \/\/ ASSERT\n@@ -1478,2 +1480,2 @@\n-\/\/ We keep the Opaque4 node since it's still a template. Since the templates are eventually removed after loop opts,\n-\/\/ these are never executed. We therefore insert a Halt node instead of an uncommon trap.\n+\/\/ We keep the OpaqueTemplateAssertionPredicate node since it's still a template. Since the templates are eventually\n+\/\/ removed after loop opts, these are never executed. We therefore insert a Halt node instead of an uncommon trap.\n@@ -1483,1 +1485,1 @@\n-  TemplateAssertionExpression template_assertion_expression(iff->in(1)->as_Opaque4());\n+  TemplateAssertionExpression template_assertion_expression(iff->in(1)->as_OpaqueTemplateAssertionPredicate());\n@@ -1485,1 +1487,2 @@\n-  Opaque4Node* new_opaque_node = template_assertion_expression.clone_and_replace_init(new_init, control, this);\n+  OpaqueTemplateAssertionPredicateNode* new_opaque_node =\n+      template_assertion_expression.clone_and_replace_init(new_init, control, this);\n@@ -1925,12 +1928,7 @@\n-    if (bol->is_Opaque4()) {\n-      if (assertion_predicate_has_loop_opaque_node(iff)) {\n-        \/\/ This is a Template Assertion Predicate for the initial or last access.\n-        \/\/ Create an Initialized Assertion Predicates for it accordingly:\n-        \/\/ - For the initial access a[init] (same as before)\n-        \/\/ - For the last access a[init+new_stride-orig_stride] (with the new unroll stride)\n-        prev_proj = create_initialized_assertion_predicate(iff, init, max_value, prev_proj);\n-      } else {\n-        \/\/ Ignore Opaque4 from a non-null-check for an intrinsic or unsafe access. This could happen when we maximally\n-        \/\/ unroll a non-main loop with such an If with an Opaque4 node directly above the loop entry.\n-        assert(!loop_head->is_main_loop(), \"Opaque4 node from a non-null check - should not be at main loop\");\n-      }\n+    if (bol->is_OpaqueTemplateAssertionPredicate()) {\n+      assert(assertion_predicate_has_loop_opaque_node(iff), \"must find OpaqueLoop* nodes\");\n+      \/\/ This is a Template Assertion Predicate for the initial or last access.\n+      \/\/ Create an Initialized Assertion Predicates for it accordingly:\n+      \/\/ - For the initial access a[init] (same as before)\n+      \/\/ - For the last access a[init+new_stride-orig_stride] (with the new unroll stride)\n+      prev_proj = create_initialized_assertion_predicate(iff, init, max_value, prev_proj);\n@@ -1944,0 +1942,1 @@\n+    assert(!bol->is_OpaqueNotNull() || !loop_head->is_main_loop(), \"OpaqueNotNull should not be at main loop\");\n@@ -1970,1 +1969,1 @@\n-    if (iff->in(1)->is_Opaque4()) {\n+    if (iff->in(1)->is_OpaqueTemplateAssertionPredicate()) {\n@@ -2003,1 +2002,1 @@\n-    if (bol->is_Opaque4()) {\n+    if (bol->is_OpaqueTemplateAssertionPredicate()) {\n@@ -2897,1 +2896,1 @@\n-      new_limit_ctrl = dominated_node(new_limit_ctrl, offset_ctrl, limit_ctrl);\n+      Node* next_limit_ctrl = dominated_node(new_limit_ctrl, offset_ctrl, limit_ctrl);\n@@ -2918,1 +2917,1 @@\n-      register_new_node(offset, new_limit_ctrl);\n+      register_new_node(offset, next_limit_ctrl);\n@@ -2921,1 +2920,1 @@\n-      register_new_node(limit, new_limit_ctrl);\n+      register_new_node(limit, next_limit_ctrl);\n@@ -2927,1 +2926,1 @@\n-          add_constraint(stride_con, lscale_con, offset, zero, limit, new_limit_ctrl, &pre_limit, &main_limit);\n+          add_constraint(stride_con, lscale_con, offset, zero, limit, next_limit_ctrl, &pre_limit, &main_limit);\n@@ -2980,1 +2979,1 @@\n-          register_new_node(offset, new_limit_ctrl);\n+          register_new_node(offset, next_limit_ctrl);\n@@ -2982,1 +2981,1 @@\n-          register_new_node(limit, new_limit_ctrl);\n+          register_new_node(limit, next_limit_ctrl);\n@@ -2988,1 +2987,1 @@\n-            register_new_node(limit, new_limit_ctrl);\n+            register_new_node(limit, next_limit_ctrl);\n@@ -2995,1 +2994,1 @@\n-          add_constraint(stride_con, lscale_con, offset, mini, limit, new_limit_ctrl, &pre_limit, &main_limit);\n+          add_constraint(stride_con, lscale_con, offset, mini, limit, next_limit_ctrl, &pre_limit, &main_limit);\n@@ -3004,0 +3003,3 @@\n+      \/\/ Only update variable tracking control for new nodes if it's indeed a range check that can be eliminated (and\n+      \/\/ limits are updated)\n+      new_limit_ctrl = next_limit_ctrl;\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":33,"deletions":31,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2829,0 +2829,4 @@\n+  if (ctrl == nullptr) {\n+    \/\/ Dying loop.\n+    return nullptr;\n+  }\n@@ -3950,0 +3954,35 @@\n+\/\/ This optimization looks for patterns similar to:\n+\/\/\n+\/\/    int a = init2;\n+\/\/    for (int iv = init; iv < limit; iv += stride_con) {\n+\/\/      a += stride_con2;\n+\/\/    }\n+\/\/\n+\/\/ and transforms it to:\n+\/\/\n+\/\/    int iv2 = init2\n+\/\/    int iv = init\n+\/\/    loop:\n+\/\/      if (iv >= limit) goto exit\n+\/\/      iv += stride_con\n+\/\/      iv2 = init2 + (iv - init) * (stride_con2 \/ stride_con)\n+\/\/      goto loop\n+\/\/    exit:\n+\/\/    ...\n+\/\/\n+\/\/ Such transformation introduces more optimization opportunities. In this\n+\/\/ particular example, the loop can be eliminated entirely given that\n+\/\/ `stride_con2 \/ stride_con` is exact  (i.e., no remainder). Checks are in\n+\/\/ place to only perform this optimization if such a division is exact. This\n+\/\/ example will be transformed into its semantic equivalence:\n+\/\/\n+\/\/     int iv2 = (iv * stride_con2 \/ stride_con) + (init2 - (init * stride_con2 \/ stride_con))\n+\/\/\n+\/\/ which corresponds to the structure of transformed subgraph.\n+\/\/\n+\/\/ However, if there is a mismatch between types of the loop and the parallel\n+\/\/ induction variable (e.g., a long-typed IV in an int-typed loop), type\n+\/\/ conversions are required:\n+\/\/\n+\/\/     long iv2 = ((long) iv * stride_con2 \/ stride_con) + (init2 - ((long) init * stride_con2 \/ stride_con))\n+\/\/\n@@ -3962,1 +4001,1 @@\n-  int stride_con = cl->stride_con();\n+  jlong stride_con = cl->stride_con();\n@@ -3979,1 +4018,1 @@\n-        incr2->Opcode() != Op_AddI ||\n+        (incr2->Opcode() != Op_AddI && incr2->Opcode() != Op_AddL) ||\n@@ -3995,1 +4034,4 @@\n-    int stride_con2 = incr2->in(2)->get_int();\n+\n+    \/\/ Determine the basic type of the stride constant (and the iv being incremented).\n+    BasicType stride_con2_bt = incr2->Opcode() == Op_AddI ? T_INT : T_LONG;\n+    jlong stride_con2 = incr2->in(2)->get_integer_as_long(stride_con2_bt);\n@@ -3998,2 +4040,3 @@\n-    \/\/ if stride_con2 is min_int and stride_con is -1.\n-    if (stride_con2 == min_jint && stride_con == -1) {\n+    \/\/ if stride_con2 is min_jint (or min_jlong, respectively) and\n+    \/\/ stride_con is -1.\n+    if (stride_con2 == min_signed_integer(stride_con2_bt) && stride_con == -1) {\n@@ -4010,1 +4053,5 @@\n-    int ratio_con = stride_con2\/stride_con;\n+    jlong ratio_con = stride_con2 \/ stride_con;\n+\n+    if ((ratio_con * stride_con) != stride_con2) { \/\/ Check for exact (no remainder)\n+        continue;\n+    }\n@@ -4012,1 +4059,0 @@\n-    if ((ratio_con * stride_con) == stride_con2) { \/\/ Check for exact\n@@ -4014,4 +4060,4 @@\n-      if (TraceLoopOpts) {\n-        tty->print(\"Parallel IV: %d \", phi2->_idx);\n-        loop->dump_head();\n-      }\n+    if (TraceLoopOpts) {\n+      tty->print(\"Parallel IV: %d \", phi2->_idx);\n+      loop->dump_head();\n+    }\n@@ -4019,25 +4065,31 @@\n-      \/\/ Convert to using the trip counter.  The parallel induction\n-      \/\/ variable differs from the trip counter by a loop-invariant\n-      \/\/ amount, the difference between their respective initial values.\n-      \/\/ It is scaled by the 'ratio_con'.\n-      Node* ratio = _igvn.intcon(ratio_con);\n-      set_ctrl(ratio, C->root());\n-      Node* ratio_init = new MulINode(init, ratio);\n-      _igvn.register_new_node_with_optimizer(ratio_init, init);\n-      set_early_ctrl(ratio_init, false);\n-      Node* diff = new SubINode(init2, ratio_init);\n-      _igvn.register_new_node_with_optimizer(diff, init2);\n-      set_early_ctrl(diff, false);\n-      Node* ratio_idx = new MulINode(phi, ratio);\n-      _igvn.register_new_node_with_optimizer(ratio_idx, phi);\n-      set_ctrl(ratio_idx, cl);\n-      Node* add = new AddINode(ratio_idx, diff);\n-      _igvn.register_new_node_with_optimizer(add);\n-      set_ctrl(add, cl);\n-      _igvn.replace_node( phi2, add );\n-      \/\/ Sometimes an induction variable is unused\n-      if (add->outcnt() == 0) {\n-        _igvn.remove_dead_node(add);\n-      }\n-      --i; \/\/ deleted this phi; rescan starting with next position\n-      continue;\n+\n+    \/\/ Convert to using the trip counter.  The parallel induction\n+    \/\/ variable differs from the trip counter by a loop-invariant\n+    \/\/ amount, the difference between their respective initial values.\n+    \/\/ It is scaled by the 'ratio_con'.\n+    Node* ratio = _igvn.integercon(ratio_con, stride_con2_bt);\n+    set_ctrl(ratio, C->root());\n+\n+    Node* init_converted = insert_convert_node_if_needed(stride_con2_bt, init);\n+    Node* phi_converted = insert_convert_node_if_needed(stride_con2_bt, phi);\n+\n+    Node* ratio_init = MulNode::make(init_converted, ratio, stride_con2_bt);\n+    _igvn.register_new_node_with_optimizer(ratio_init, init_converted);\n+    set_early_ctrl(ratio_init, false);\n+\n+    Node* diff = SubNode::make(init2, ratio_init, stride_con2_bt);\n+    _igvn.register_new_node_with_optimizer(diff, init2);\n+    set_early_ctrl(diff, false);\n+\n+    Node* ratio_idx = MulNode::make(phi_converted, ratio, stride_con2_bt);\n+    _igvn.register_new_node_with_optimizer(ratio_idx, phi_converted);\n+    set_ctrl(ratio_idx, cl);\n+\n+    Node* add = AddNode::make(ratio_idx, diff, stride_con2_bt);\n+    _igvn.register_new_node_with_optimizer(add);\n+    set_ctrl(add, cl);\n+\n+    _igvn.replace_node( phi2, add );\n+    \/\/ Sometimes an induction variable is unused\n+    if (add->outcnt() == 0) {\n+      _igvn.remove_dead_node(add);\n@@ -4045,0 +4097,8 @@\n+    --i; \/\/ deleted this phi; rescan starting with next position\n+  }\n+}\n+\n+Node* PhaseIdealLoop::insert_convert_node_if_needed(BasicType target, Node* input) {\n+  BasicType source = _igvn.type(input)->basic_type();\n+  if (source == target) {\n+    return input;\n@@ -4046,0 +4106,6 @@\n+\n+  Node* converted = ConvertNode::create_convert(source, target, input);\n+  _igvn.register_new_node_with_optimizer(converted, input);\n+  set_early_ctrl(converted, false);\n+\n+  return converted;\n@@ -4380,1 +4446,2 @@\n-\/\/ replacing the Opaque4 node of the If node with true. These nodes will be removed during the next round of IGVN.\n+\/\/ replacing the OpaqueTemplateAssertionPredicate node of the If node with true. These nodes will be removed during the\n+\/\/ next round of IGVN.\n@@ -4421,3 +4488,4 @@\n-    Opaque4Node* opaque4_node = C->template_assertion_predicate_opaq_node(i - 1)->as_Opaque4();\n-    if (!useful_predicates.member(opaque4_node)) { \/\/ not in the useful list\n-      _igvn.replace_node(opaque4_node, opaque4_node->in(2));\n+    OpaqueTemplateAssertionPredicateNode* opaque_node =\n+        C->template_assertion_predicate_opaq_node(i - 1)->as_OpaqueTemplateAssertionPredicate();\n+    if (!useful_predicates.member(opaque_node)) { \/\/ not in the useful list\n+      _igvn.replace_node(opaque_node, _igvn.intcon(1));\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":108,"deletions":40,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -958,1 +958,1 @@\n-  static bool assertion_predicate_has_loop_opaque_node(IfNode* iff);\n+  DEBUG_ONLY(static bool assertion_predicate_has_loop_opaque_node(IfNode* iff);)\n@@ -1137,0 +1137,2 @@\n+  Node* insert_convert_node_if_needed(BasicType target, Node* input);\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -790,4 +790,3 @@\n-  if (bol->is_Opaque4()) {\n-    \/\/ Ignore Template Assertion Predicates with Opaque4 nodes.\n-    assert(assertion_predicate_has_loop_opaque_node(iff),\n-           \"must be Template Assertion Predicate, non-null-check with Opaque4 cannot form a diamond with Halt\");\n+  if (bol->is_OpaqueTemplateAssertionPredicate()) {\n+    \/\/ Ignore Template Assertion Predicates with OpaqueTemplateAssertionPredicate nodes.\n+    assert(assertion_predicate_has_loop_opaque_node(iff), \"must find OpaqueLoop* nodes\");\n@@ -1705,1 +1704,1 @@\n-      !n->is_Opaque4() &&\n+      !n->is_OpaqueNotNull() &&\n@@ -1707,0 +1706,1 @@\n+      !n->is_OpaqueTemplateAssertionPredicate() &&\n@@ -1948,4 +1948,5 @@\n-  if (n_loop->_head->is_CountedLoop() && n_loop->_head->as_CountedLoop()->is_pre_loop() &&\n-      u_loop->_head->is_CountedLoop() && u_loop->_head->as_CountedLoop()->is_main_loop() &&\n-      n_loop->_next == get_loop(u_loop->_head->as_CountedLoop()->skip_strip_mined())) {\n-    return false;\n+  if (n_loop->_head->is_CountedLoop() && n_loop->_head->as_CountedLoop()->is_pre_loop()) {\n+    CountedLoopNode* pre_loop = n_loop->_head->as_CountedLoop();\n+    if (is_dominator(pre_loop->loopexit(), ctrl)) {\n+      return false;\n+    }\n@@ -2023,2 +2024,2 @@\n-      assert(b->is_Bool() || b->is_Opaque4() || b->is_OpaqueInitializedAssertionPredicate(),\n-             \"bool, non-null check with Opaque4 node or Initialized Assertion Predicate with its Opaque node\");\n+      assert(b->is_Bool() || b->is_OpaqueNotNull() || b->is_OpaqueInitializedAssertionPredicate(),\n+             \"bool, non-null check with OpaqueNotNull or Initialized Assertion Predicate with its Opaque node\");\n@@ -2030,1 +2031,1 @@\n-  if (n->is_Opaque4() || n->is_OpaqueInitializedAssertionPredicate()) {\n+  if (n->is_OpaqueNotNull() || n->is_OpaqueInitializedAssertionPredicate()) {\n@@ -2204,1 +2205,3 @@\n-      if (use->is_If() || use->is_CMove() || use->is_Opaque4() || use->is_OpaqueInitializedAssertionPredicate() ||\n+      assert(!use->is_OpaqueTemplateAssertionPredicate(),\n+             \"should not clone a Template Assertion Predicate which should be removed once it's useless\");\n+      if (use->is_If() || use->is_CMove() || use->is_OpaqueNotNull() || use->is_OpaqueInitializedAssertionPredicate() ||\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2431,1 +2431,1 @@\n-               n->is_Opaque4()             ||\n+               n->is_OpaqueNotNull()       ||\n@@ -2483,7 +2483,4 @@\n-      } else if (n->is_Opaque4()) {\n-        \/\/ With Opaque4 nodes, the expectation is that the test of input 1\n-        \/\/ is always equal to the constant value of input 2. So we can\n-        \/\/ remove the Opaque4 and replace it by input 2. In debug builds,\n-        \/\/ leave the non constant test in instead to sanity check that it\n-        \/\/ never fails (if it does, that subgraph was constructed so, at\n-        \/\/ runtime, a Halt node is executed).\n+      } else if (n->is_OpaqueNotNull()) {\n+        \/\/ Tests with OpaqueNotNull nodes are implicitly known to be true. Replace the node with true. In debug builds,\n+        \/\/ we leave the test in the graph to have an additional sanity check at runtime. If the test fails (i.e. a bug),\n+        \/\/ we will execute a Halt node.\n@@ -2493,1 +2490,1 @@\n-        _igvn.replace_node(n, n->in(2));\n+        _igvn.replace_node(n, _igvn.intcon(1));\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -614,1 +614,1 @@\n-  if (is_Opaque4()) {\n+  if (is_OpaqueTemplateAssertionPredicate()) {\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-class Opaque4Node;\n+class OpaqueNotNullNode;\n@@ -143,0 +143,1 @@\n+class OpaqueTemplateAssertionPredicateNode;\n@@ -799,1 +800,1 @@\n-    DEFINE_CLASS_ID(Opaque4,  Node, 17)\n+    DEFINE_CLASS_ID(OpaqueNotNull,  Node, 17)\n@@ -801,3 +802,4 @@\n-    DEFINE_CLASS_ID(Move,     Node, 19)\n-    DEFINE_CLASS_ID(LShift,   Node, 20)\n-    DEFINE_CLASS_ID(Neg,      Node, 21)\n+    DEFINE_CLASS_ID(OpaqueTemplateAssertionPredicate,  Node, 19)\n+    DEFINE_CLASS_ID(Move,     Node, 20)\n+    DEFINE_CLASS_ID(LShift,   Node, 21)\n+    DEFINE_CLASS_ID(Neg,      Node, 22)\n@@ -973,1 +975,1 @@\n-  DEFINE_CLASS_QUERY(Opaque4)\n+  DEFINE_CLASS_QUERY(OpaqueNotNull)\n@@ -975,0 +977,1 @@\n+  DEFINE_CLASS_QUERY(OpaqueTemplateAssertionPredicate)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -85,1 +85,18 @@\n-const Type* Opaque4Node::Value(PhaseGVN* phase) const {\n+const Type* OpaqueNotNullNode::Value(PhaseGVN* phase) const {\n+  return phase->type(in(1));\n+}\n+\n+Node* OpaqueTemplateAssertionPredicateNode::Identity(PhaseGVN* phase) {\n+  if (phase->C->post_loop_opts_phase()) {\n+    \/\/ Template Assertion Predicates only serve as templates to create Initialized Assertion Predicates when splitting\n+    \/\/ a loop during loop opts. They are not used anymore once loop opts are over and can then be removed. They feed\n+    \/\/ into the bool input of an If node and can thus be replaced by true to let the Template Assertion Predicate be\n+    \/\/ folded away (the success path is always the true path by design).\n+    return phase->intcon(1);\n+  } else {\n+    phase->C->record_for_post_loop_opts_igvn(this);\n+  }\n+  return this;\n+}\n+\n+const Type* OpaqueTemplateAssertionPredicateNode::Value(PhaseGVN* phase) const {\n","filename":"src\/hotspot\/share\/opto\/opaquenode.cpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -94,7 +94,7 @@\n-\/\/ Input 1 is a check that we know implicitly is always true or false\n-\/\/ but the compiler has no way to prove. If during optimizations, that\n-\/\/ check becomes true or false, the Opaque4 node is replaced by that\n-\/\/ constant true or false. Input 2 is the constant value we know the\n-\/\/ test takes. After loop optimizations, we replace input 1 by input 2\n-\/\/ so the control that depends on that test can be removed and there's\n-\/\/ no overhead at runtime. Used for instance by\n+\/\/ This node is used in the context of intrinsics. We sometimes implicitly know that an object is non-null even though\n+\/\/ the compiler cannot prove it. We therefore add a corresponding cast to propagate this implicit knowledge. However,\n+\/\/ this cast could become top during optimizations (input to cast becomes null) and the data path is folded. To ensure\n+\/\/ that the control path is also properly folded, we insert an If node with a OpaqueNotNullNode as condition. During\n+\/\/ macro expansion, we replace the OpaqueNotNullNodes with true in product builds such that the actually unneeded checks\n+\/\/ are folded and do not end up in the emitted code. In debug builds, we keep the actual checks as additional\n+\/\/ verification code (i.e. removing OpaqueNotNullNodes and use the BoolNode inputs instead). For more details, also see\n@@ -102,4 +102,4 @@\n-class Opaque4Node : public Node {\n-  public:\n-  Opaque4Node(Compile* C, Node* tst, Node* final_tst) : Node(nullptr, tst, final_tst) {\n-    init_class_id(Class_Opaque4);\n+class OpaqueNotNullNode : public Node {\n+ public:\n+  OpaqueNotNullNode(Compile* C, Node* tst) : Node(nullptr, tst) {\n+    init_class_id(Class_OpaqueNotNull);\n@@ -115,0 +115,15 @@\n+\/\/ This node is used for Template Assertion Predicate BoolNodes. A Template Assertion Predicate is always removed\n+\/\/ after loop opts and thus is never converted to actual code. In the post loop opts IGVN phase, the\n+\/\/ OpaqueTemplateAssertionPredicateNode is replaced by true in order to fold the Template Assertion Predicate away.\n+class OpaqueTemplateAssertionPredicateNode : public Node {\n+ public:\n+  OpaqueTemplateAssertionPredicateNode(BoolNode* bol) : Node(nullptr, bol) {\n+    init_class_id(Class_OpaqueTemplateAssertionPredicate);\n+  }\n+\n+  virtual int Opcode() const;\n+  virtual Node* Identity(PhaseGVN* phase);\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual const Type* bottom_type() const { return TypeInt::BOOL; }\n+};\n+\n@@ -116,2 +131,4 @@\n-\/\/ to true. Therefore, we get rid of them in product builds during macro expansion as they are useless. In debug builds\n-\/\/ we keep them as additional verification code (i.e. removing this node and use the BoolNode input instead).\n+\/\/ to true. During  macro expansion, we replace the OpaqueInitializedAssertionPredicateNodes with true in product builds\n+\/\/ such that the actually unneeded checks are folded and do not end up in the emitted code. In debug builds, we keep the\n+\/\/ actual checks as additional verification code (i.e. removing OpaqueInitializedAssertionPredicateNodes and use the\n+\/\/ BoolNode inputs instead).\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":30,"deletions":13,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -1961,0 +1961,2 @@\n+    \/\/ ciTypeFlow should trap if the ldc is in error state or if the constant is not loaded\n+    assert(!iter().is_in_error(), \"ldc is in error state\");\n@@ -1962,19 +1964,4 @@\n-    if (constant.is_loaded()) {\n-      const Type* con_type = Type::make_from_constant(constant);\n-      if (con_type != nullptr) {\n-        push_node(con_type->basic_type(), makecon(con_type));\n-      }\n-    } else {\n-      \/\/ If the constant is unresolved or in error state, run this BC in the interpreter.\n-      if (iter().is_in_error()) {\n-        uncommon_trap(Deoptimization::make_trap_request(Deoptimization::Reason_unhandled,\n-                                                        Deoptimization::Action_none),\n-                      nullptr, \"constant in error state\", true \/* must_throw *\/);\n-\n-      } else {\n-        int index = iter().get_constant_pool_index();\n-        uncommon_trap(Deoptimization::make_trap_request(Deoptimization::Reason_unloaded,\n-                                                        Deoptimization::Action_reinterpret,\n-                                                        index),\n-                      nullptr, \"unresolved constant\", false \/* must_throw *\/);\n-      }\n+    assert(constant.is_loaded(), \"constant is not loaded\");\n+    const Type* con_type = Type::make_from_constant(constant);\n+    if (con_type != nullptr) {\n+      push_node(con_type->basic_type(), makecon(con_type));\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":6,"deletions":19,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+  assert(start_proj != nullptr, \"should not be null\");\n@@ -44,0 +45,6 @@\n+\/\/ An Assertion Predicate has always a true projection on the success path.\n+bool may_be_assertion_predicate_if(const Node* node) {\n+  assert(node != nullptr, \"should not be null\");\n+  return node->is_IfTrue() && RegularPredicate::may_be_predicate_if(node->as_IfProj());\n+}\n+\n@@ -45,1 +52,1 @@\n-  if (maybe_success_proj == nullptr || !maybe_success_proj->is_IfProj() || !maybe_success_proj->in(0)->is_If()) {\n+  if (!may_be_assertion_predicate_if(maybe_success_proj)) {\n@@ -51,2 +58,2 @@\n-\/\/ Check if the If node of `predicate_proj` has an Opaque4 (Template Assertion Predicate) or an\n-\/\/ OpaqueInitializedAssertionPredicate (Initialized Assertion Predicate) node as input.\n+\/\/ Check if the If node of `predicate_proj` has an OpaqueTemplateAssertionPredicate (Template Assertion Predicate) or\n+\/\/ an OpaqueInitializedAssertionPredicate (Initialized Assertion Predicate) node as input.\n@@ -56,1 +63,1 @@\n-  return bol->is_Opaque4() || bol->is_OpaqueInitializedAssertionPredicate();\n+  return bol->is_OpaqueTemplateAssertionPredicate() || bol->is_OpaqueInitializedAssertionPredicate();\n@@ -111,0 +118,1 @@\n+\/\/ Note that this method can be called during IGVN, so we also need to check that the If is not top.\n@@ -112,1 +120,1 @@\n-  if (node->is_IfProj()) {\n+  if (node->is_IfProj() && node->in(0)->is_If()) {\n@@ -133,2 +141,1 @@\n-\/\/ A Template Assertion Predicate has an If\/RangeCheckNode and either an UCT or a halt node depending on where it\n-\/\/ was created.\n+\/\/ Template Assertion Predicates always have the dedicated OpaqueTemplateAssertionPredicate to identify them.\n@@ -136,1 +143,1 @@\n-  if (!RegularPredicate::may_be_predicate_if(node)) {\n+  if (!may_be_assertion_predicate_if(node)) {\n@@ -140,4 +147,1 @@\n-  if (if_node->in(1)->is_Opaque4()) {\n-    return RegularPredicateWithUCT::has_valid_uncommon_trap(node) || AssertionPredicateWithHalt::has_halt(node);\n-  }\n-  return false;\n+  return if_node->in(1)->is_OpaqueTemplateAssertionPredicate();\n@@ -146,1 +150,2 @@\n-\/\/ Initialized Assertion Predicates always have the dedicated opaque node and a halt node.\n+\/\/ Initialized Assertion Predicates always have the dedicated OpaqueInitiailizedAssertionPredicate node to identify\n+\/\/ them.\n@@ -148,1 +153,1 @@\n-  if (!AssertionPredicateWithHalt::is_predicate(node)) {\n+  if (!may_be_assertion_predicate_if(node)) {\n@@ -234,5 +239,5 @@\n-\/\/ Creates an identical clone of this Template Assertion Expression (i.e.cloning all nodes from the Opaque4Node to and\n-\/\/ including the OpaqueLoop* nodes). The cloned nodes are rewired to reflect the same graph structure as found for this\n-\/\/ Template Assertion Expression. The cloned nodes get 'new_ctrl' as ctrl. There is no other update done for the cloned\n-\/\/ nodes. Return the newly cloned Opaque4Node.\n-Opaque4Node* TemplateAssertionExpression::clone(Node* new_ctrl, PhaseIdealLoop* phase) {\n+\/\/ Creates an identical clone of this Template Assertion Expression (i.e.cloning all nodes from the\n+\/\/ OpaqueTemplateAssertionPredicate to and including the OpaqueLoop* nodes). The cloned nodes are rewired to reflect the\n+\/\/ same graph structure as found for this Template Assertion Expression. The cloned nodes get 'new_ctrl' as ctrl. There\n+\/\/ is no other update done for the cloned nodes. Return the newly cloned OpaqueTemplateAssertionPredicate.\n+OpaqueTemplateAssertionPredicateNode* TemplateAssertionExpression::clone(Node* new_ctrl, PhaseIdealLoop* phase) {\n@@ -244,2 +249,2 @@\n-Opaque4Node* TemplateAssertionExpression::clone_and_replace_init(Node* new_init, Node* new_ctrl,\n-                                                                 PhaseIdealLoop* phase) {\n+OpaqueTemplateAssertionPredicateNode*\n+TemplateAssertionExpression::clone_and_replace_init(Node* new_init, Node* new_ctrl, PhaseIdealLoop* phase) {\n@@ -252,3 +257,3 @@\n-Opaque4Node* TemplateAssertionExpression::clone_and_replace_init_and_stride(Node* new_control, Node* new_init,\n-                                                                            Node* new_stride,\n-                                                                            PhaseIdealLoop* phase) {\n+OpaqueTemplateAssertionPredicateNode*\n+TemplateAssertionExpression::clone_and_replace_init_and_stride(Node* new_control, Node* new_init, Node* new_stride,\n+                                                               PhaseIdealLoop* phase) {\n@@ -337,2 +342,3 @@\n-Opaque4Node* TemplateAssertionExpression::clone(const TransformStrategyForOpaqueLoopNodes& transform_strategy,\n-                                                Node* new_ctrl, PhaseIdealLoop* phase) {\n+OpaqueTemplateAssertionPredicateNode*\n+TemplateAssertionExpression::clone(const TransformStrategyForOpaqueLoopNodes& transform_strategy, Node* new_ctrl,\n+                                   PhaseIdealLoop* phase) {\n@@ -345,1 +351,1 @@\n-  const Unique_Node_List& collected_nodes = data_nodes_on_path_to_targets.collect(_opaque4_node);\n+  const Unique_Node_List& collected_nodes = data_nodes_on_path_to_targets.collect(_opaque_node);\n@@ -348,3 +354,3 @@\n-  assert(orig_to_new.contains(_opaque4_node), \"must exist\");\n-  Node* opaque4_clone = *orig_to_new.get(_opaque4_node);\n-  return opaque4_clone->as_Opaque4();\n+  assert(orig_to_new.contains(_opaque_node), \"must exist\");\n+  Node* opaque_node_clone = *orig_to_new.get(_opaque_node);\n+  return opaque_node_clone->as_OpaqueTemplateAssertionPredicate();\n@@ -372,1 +378,1 @@\n-  return node->is_If() && node->in(1)->is_Opaque4();\n+  return node->is_If() && node->in(1)->is_OpaqueTemplateAssertionPredicate();\n@@ -394,2 +400,2 @@\n-  \/\/ Create the expression for a Template Assertion Predicate with an Opaque4 node.\n-  Opaque4Node* create_for_template(Node* new_control, Node* operand, bool& does_overflow) const {\n+  \/\/ Create the expression for a Template Assertion Predicate with an OpaqueTemplateAssertionPredicate node.\n+  OpaqueTemplateAssertionPredicateNode* create_for_template(Node* new_control, Node* operand, bool& does_overflow) const {\n@@ -398,1 +404,1 @@\n-    return create_opaque4_node(new_control, bool_for_expression);\n+    return create_opaque_node(new_control, bool_for_expression);\n@@ -402,4 +408,3 @@\n-  Opaque4Node* create_opaque4_node(Node* new_control, BoolNode* bool_for_expression) const {\n-    Compile* C = _phase->C;\n-    Opaque4Node* new_expression = new Opaque4Node(C, bool_for_expression, _phase->igvn().intcon(1));\n-    C->add_template_assertion_predicate_opaq(new_expression);\n+  OpaqueTemplateAssertionPredicateNode* create_opaque_node(Node* new_control, BoolNode* bool_for_expression) const {\n+    OpaqueTemplateAssertionPredicateNode* new_expression = new OpaqueTemplateAssertionPredicateNode(bool_for_expression);\n+    _phase->C->add_template_assertion_predicate_opaq(new_expression);\n@@ -459,2 +464,2 @@\n-  assert(assertion_expression->is_Opaque4() || assertion_expression->is_OpaqueInitializedAssertionPredicate(),\n-         \"not a valid assertion expression\");\n+  assert(assertion_expression->is_OpaqueTemplateAssertionPredicate() ||\n+         assertion_expression->is_OpaqueInitializedAssertionPredicate(), \"not a valid assertion expression\");\n@@ -513,2 +518,2 @@\n-  Opaque4Node* template_assertion_predicate_expression = create_for_init_value(new_control, opaque_init,\n-                                                                               does_overflow);\n+  OpaqueTemplateAssertionPredicateNode* template_assertion_predicate_expression =\n+      create_for_init_value(new_control, opaque_init, does_overflow);\n@@ -532,2 +537,3 @@\n-Opaque4Node* TemplateAssertionPredicateCreator::create_for_init_value(Node* new_control, OpaqueLoopInitNode* opaque_init,\n-                                                                      bool& does_overflow) const {\n+OpaqueTemplateAssertionPredicateNode*\n+TemplateAssertionPredicateCreator::create_for_init_value(Node* new_control, OpaqueLoopInitNode* opaque_init,\n+                                                         bool& does_overflow) const {\n@@ -539,2 +545,3 @@\n-    Opaque4Node* template_assertion_predicate_expression, ParsePredicateSuccessProj* parse_predicate_success_proj,\n-    const Deoptimization::DeoptReason deopt_reason, const int if_opcode, const bool does_overflow\n+    OpaqueTemplateAssertionPredicateNode* template_assertion_predicate_expression,\n+    ParsePredicateSuccessProj* parse_predicate_success_proj, const Deoptimization::DeoptReason deopt_reason,\n+    const int if_opcode, const bool does_overflow\n@@ -549,2 +556,3 @@\n-Opaque4Node* TemplateAssertionPredicateCreator::create_for_last_value(Node* new_control, OpaqueLoopInitNode* opaque_init,\n-                                                                      bool& does_overflow) const {\n+OpaqueTemplateAssertionPredicateNode*\n+TemplateAssertionPredicateCreator::create_for_last_value(Node* new_control, OpaqueLoopInitNode* opaque_init,\n+                                                         bool& does_overflow) const {\n@@ -571,1 +579,1 @@\n-    Node* new_control, Opaque4Node* template_assertion_predicate_expression, bool does_overflow\n+    Node* new_control, OpaqueTemplateAssertionPredicateNode* template_assertion_predicate_expression, bool does_overflow\n@@ -584,2 +592,2 @@\n-  Opaque4Node* template_assertion_predicate_expression = create_for_init_value(new_control, opaque_init,\n-                                                                               does_overflow);\n+  OpaqueTemplateAssertionPredicateNode* template_assertion_predicate_expression =\n+      create_for_init_value(new_control, opaque_init, does_overflow);\n@@ -600,1 +608,1 @@\n-\/\/ - Opaque4 with OpaqueInitializedAssertionPredicate\n+\/\/ - OpaqueTemplateAssertionPredicateNode with OpaqueInitializedAssertionPredicate\n@@ -605,12 +613,12 @@\n-\/\/             |  OpaqueLoopInitNode  OpaqueLoopStrideNode                      \/        new_init    new_stride\n-\/\/  Template   |                 \\     \/                                        |              \\     \/\n-\/\/  Assertion  |                   ...                               Assertion  |                ...\n-\/\/  Expression |                    |                                Expression |                 |\n-\/\/             |                   Bool                                         |              new Bool\n-\/\/             |                    |                                           |                 |\n-\/\/             \\                 Opaque4           ======>      new_control     \\  OpaqueInitializedAssertionPredicate\n-\/\/                                  |                                      \\      \/\n-\/\/                                 If                                       new If\n-\/\/                               \/    \\                                     \/    \\\n-\/\/                         success     fail path                   new success   new Halt\n-\/\/                           proj    (Halt or UCT)                     proj\n+\/\/             |  OpaqueLoopInitNode  OpaqueLoopStrideNode                        \/        new_init    new_stride\n+\/\/  Template   |                 \\     \/                                          |              \\     \/\n+\/\/  Assertion  |                   ...                                 Assertion  |                ...\n+\/\/  Expression |                    |                                  Expression |                 |\n+\/\/             |                   Bool                                           |              new Bool\n+\/\/             |                    |                                             |                 |\n+\/\/             \\      OpaqueTemplateAssertionPredicate    ===>    new_control     \\  OpaqueInitializedAssertionPredicate\n+\/\/                                  |                                        \\      \/\n+\/\/                                 If                                         new If\n+\/\/                               \/    \\                                       \/    \\\n+\/\/                         success     fail path                     new success   new Halt\n+\/\/                           proj    (Halt or UCT)                       proj\n@@ -654,1 +662,2 @@\n-  Opaque4Node* template_opaque = template_assertion_predicate->in(1)->as_Opaque4();\n+  OpaqueTemplateAssertionPredicateNode* template_opaque =\n+      template_assertion_predicate->in(1)->as_OpaqueTemplateAssertionPredicate();\n@@ -656,3 +665,2 @@\n-  Opaque4Node* tmp_opaque = template_assertion_expression.clone_and_replace_init_and_stride(new_control, new_init,\n-                                                                                            new_stride,\n-                                                                                            _phase);\n+  OpaqueTemplateAssertionPredicateNode* tmp_opaque =\n+      template_assertion_expression.clone_and_replace_init_and_stride(new_control, new_init, new_stride, _phase);\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":76,"deletions":68,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -85,2 +85,2 @@\n- *                        We use special Opaque4 nodes to block some optimizations and replace the Assertion Predicates\n- *                        later in product builds.\n+ *                        We use special OpaqueTemplateAssertionPredicateNode nodes to block some optimizations and replace\n+ *                        the Assertion Predicates later in product builds.\n@@ -434,2 +434,2 @@\n-\/\/ A Template Assertion Predicate represents the Opaque4Node for the initial value or the last value of a\n-\/\/ Template Assertion Predicate and all the nodes up to and including the OpaqueLoop* nodes.\n+\/\/ A Template Assertion Predicate represents the OpaqueTemplateAssertionPredicateNode for the initial value or the last\n+\/\/ value of a Template Assertion Predicate and all the nodes up to and including the OpaqueLoop* nodes.\n@@ -437,1 +437,1 @@\n-  Opaque4Node* _opaque4_node;\n+  OpaqueTemplateAssertionPredicateNode* _opaque_node;\n@@ -440,1 +440,1 @@\n-  explicit TemplateAssertionExpression(Opaque4Node* opaque4_node) : _opaque4_node(opaque4_node) {}\n+  explicit TemplateAssertionExpression(OpaqueTemplateAssertionPredicateNode* opaque_node) : _opaque_node(opaque_node) {}\n@@ -443,1 +443,2 @@\n-  Opaque4Node* clone(const TransformStrategyForOpaqueLoopNodes& transform_strategy, Node* new_ctrl, PhaseIdealLoop* phase);\n+  OpaqueTemplateAssertionPredicateNode* clone(const TransformStrategyForOpaqueLoopNodes& transform_strategy,\n+                                              Node* new_ctrl, PhaseIdealLoop* phase);\n@@ -446,4 +447,4 @@\n-  Opaque4Node* clone(Node* new_ctrl, PhaseIdealLoop* phase);\n-  Opaque4Node* clone_and_replace_init(Node* new_init, Node* new_ctrl, PhaseIdealLoop* phase);\n-  Opaque4Node* clone_and_replace_init_and_stride(Node* new_control, Node* new_init, Node* new_stride,\n-                                                 PhaseIdealLoop* phase);\n+  OpaqueTemplateAssertionPredicateNode* clone(Node* new_ctrl, PhaseIdealLoop* phase);\n+  OpaqueTemplateAssertionPredicateNode* clone_and_replace_init(Node* new_init, Node* new_ctrl, PhaseIdealLoop* phase);\n+  OpaqueTemplateAssertionPredicateNode* clone_and_replace_init_and_stride(Node* new_control, Node* new_init,\n+                                                                          Node* new_stride, PhaseIdealLoop* phase);\n@@ -557,2 +558,4 @@\n-  Opaque4Node* create_for_init_value(Node* new_control, OpaqueLoopInitNode* opaque_init, bool& does_overflow) const;\n-  Opaque4Node* create_for_last_value(Node* new_control, OpaqueLoopInitNode* opaque_init, bool& does_overflow) const;\n+  OpaqueTemplateAssertionPredicateNode* create_for_init_value(Node* new_control, OpaqueLoopInitNode* opaque_init,\n+                                                              bool& does_overflow) const;\n+  OpaqueTemplateAssertionPredicateNode* create_for_last_value(Node* new_control, OpaqueLoopInitNode* opaque_init,\n+                                                              bool& does_overflow) const;\n@@ -560,1 +563,1 @@\n-  IfTrueNode* create_if_node_with_uncommon_trap(Opaque4Node* template_assertion_predicate_expression,\n+  IfTrueNode* create_if_node_with_uncommon_trap(OpaqueTemplateAssertionPredicateNode* template_assertion_predicate_expression,\n@@ -565,1 +568,2 @@\n-  IfTrueNode* create_if_node_with_halt(Node* new_control, Opaque4Node* template_assertion_predicate_expression,\n+  IfTrueNode* create_if_node_with_halt(Node* new_control,\n+                                       OpaqueTemplateAssertionPredicateNode* template_assertion_predicate_expression,\n@@ -690,4 +694,9 @@\n-    PredicateBlockIterator profiled_loop_predicate_iterator(current, Deoptimization::Reason_profile_predicate);\n-    current = profiled_loop_predicate_iterator.for_each(predicate_visitor);\n-    PredicateBlockIterator loop_predicate_iterator(current, Deoptimization::Reason_predicate);\n-    return loop_predicate_iterator.for_each(predicate_visitor);\n+    if (UseLoopPredicate) {\n+      if (UseProfiledLoopPredicate) {\n+        PredicateBlockIterator profiled_loop_predicate_iterator(current, Deoptimization::Reason_profile_predicate);\n+        current = profiled_loop_predicate_iterator.for_each(predicate_visitor);\n+      }\n+      PredicateBlockIterator loop_predicate_iterator(current, Deoptimization::Reason_predicate);\n+      current = loop_predicate_iterator.for_each(predicate_visitor);\n+    }\n+    return current;\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":28,"deletions":19,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -325,1 +325,2 @@\n-            if (use->is_Opaque4() || use->is_OpaqueInitializedAssertionPredicate()) {\n+            if (use->is_OpaqueNotNull() || use->is_OpaqueTemplateAssertionPredicate() ||\n+                use->is_OpaqueInitializedAssertionPredicate()) {\n@@ -354,2 +355,3 @@\n-              \/\/ Uses are either IfNodes, CMoves, Opaque4, or OpaqueInitializedAssertionPredicates\n-              if (u->is_Opaque4() || u->is_OpaqueInitializedAssertionPredicate()) {\n+              \/\/ Uses are either IfNodes, CMoves, OpaqueNotNull, or Opaque*AssertionPredicate\n+              if (u->is_OpaqueNotNull() || u->is_OpaqueTemplateAssertionPredicate() ||\n+                  u->is_OpaqueInitializedAssertionPredicate()) {\n@@ -424,2 +426,3 @@\n-    Opaque4Node* opaque4_node = template_assertion_predicate->in(1)->as_Opaque4();\n-    TemplateAssertionExpression template_assertion_expression(opaque4_node);\n+    OpaqueTemplateAssertionPredicateNode* opaque_node =\n+        template_assertion_predicate->in(1)->as_OpaqueTemplateAssertionPredicate();\n+    TemplateAssertionExpression template_assertion_expression(opaque_node);\n@@ -427,2 +430,2 @@\n-    Opaque4Node* cloned_opaque4_node = template_assertion_expression.clone(new_ctrl, this);\n-    igvn().replace_input_of(template_assertion_predicate, 1, cloned_opaque4_node);\n+    OpaqueTemplateAssertionPredicateNode* cloned_opaque_node = template_assertion_expression.clone(new_ctrl, this);\n+    igvn().replace_input_of(template_assertion_predicate, 1, cloned_opaque_node);\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -3281,4 +3281,1 @@\n-      \/\/ Skip reflection related frames\n-      if (!ik->is_subclass_of(vmClasses::reflect_SerializationConstructorAccessorImpl_klass())) {\n-        return JNIHandles::make_local(THREAD, loader);\n-      }\n+      return JNIHandles::make_local(THREAD, loader);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1335,1 +1335,1 @@\n-  if (jvf->method()->is_native()) {\n+  if (jvf->method()->is_native() || (depth == 0 && state->top_frame_is_exiting())) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1877,0 +1877,4 @@\n+  \/\/ Do not allow NotifyFramePop to add new FramePop event request at\n+  \/\/ depth 0 as it is already late in the method exiting dance.\n+  state->set_top_frame_is_exiting();\n+\n@@ -1885,0 +1889,4 @@\n+  \/\/ The JRT_BLOCK_END can safepoint in ThreadInVMfromJava desctructor. Now it is safe to allow\n+  \/\/ adding FramePop event requests as no safepoint can happen before removing activation.\n+  state->clr_top_frame_is_exiting();\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+  _top_frame_is_exiting = false;\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -193,0 +193,1 @@\n+  bool              _top_frame_is_exiting;\n@@ -360,0 +361,5 @@\n+  \/\/ For synchronization between NotifyFramePop and FramePop posting code.\n+  void set_top_frame_is_exiting() { _top_frame_is_exiting = true;  }\n+  void clr_top_frame_is_exiting() { _top_frame_is_exiting = false; }\n+  bool top_frame_is_exiting()     { return _top_frame_is_exiting;  }\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1293,1 +1293,1 @@\n-  if (Metaspace::contains(addr)) {\n+  if (Metaspace::initialized() && Metaspace::contains(addr)) {\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -451,6 +451,0 @@\n-  \/\/ Allow all accesses from jdk\/internal\/reflect\/SerializationConstructorAccessorImpl subclasses to\n-  \/\/ succeed trivially.\n-  if (vmClasses::reflect_SerializationConstructorAccessorImpl_klass_is_loaded() &&\n-      current_class->is_subclass_of(vmClasses::reflect_SerializationConstructorAccessorImpl_klass())) {\n-    return ACCESS_OK;\n-  }\n@@ -661,6 +655,0 @@\n-  \/\/ Allow all accesses from jdk\/internal\/reflect\/SerializationConstructorAccessorImpl subclasses to\n-  \/\/ succeed trivially.\n-  if (current_class->is_subclass_of(vmClasses::reflect_SerializationConstructorAccessorImpl_klass())) {\n-    return true;\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+#include \"sanitizers\/ub.hpp\"\n+\n+#include <limits>\n@@ -113,0 +116,1 @@\n+ATTRIBUTE_NO_UBSAN\n@@ -118,0 +122,2 @@\n+  static_assert(std::numeric_limits<double>::is_iec559, \"IEEE 754 required\");\n+\n@@ -207,0 +213,1 @@\n+ATTRIBUTE_NO_UBSAN\n@@ -212,0 +219,2 @@\n+  static_assert(std::numeric_limits<double>::is_iec559, \"IEEE 754 required\");\n+\n@@ -443,0 +452,1 @@\n+ATTRIBUTE_NO_UBSAN\n@@ -449,0 +459,2 @@\n+\n+  static_assert(std::numeric_limits<double>::is_iec559, \"IEEE 754 required\");\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntimeTrans.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -53,0 +53,32 @@\n+AttachAPIVersion AttachListener::_supported_version = ATTACH_API_V1;\n+\n+static bool get_bool_sys_prop(const char* name, bool default_value, TRAPS) {\n+  ResourceMark rm(THREAD);\n+  HandleMark hm(THREAD);\n+\n+  \/\/ setup the arguments to getProperty\n+  Handle key_str = java_lang_String::create_from_str(name, CHECK_(default_value));\n+  \/\/ return value\n+  JavaValue result(T_OBJECT);\n+  \/\/ public static String getProperty(String key, String def);\n+  JavaCalls::call_static(&result,\n+                         vmClasses::System_klass(),\n+                         vmSymbols::getProperty_name(),\n+                         vmSymbols::string_string_signature(),\n+                         key_str,\n+                         CHECK_(default_value));\n+  oop value_oop = result.get_oop();\n+  if (value_oop != nullptr) {\n+    \/\/ convert Java String to utf8 string\n+    char* value = java_lang_String::as_utf8_string(value_oop);\n+    if (strcasecmp(value, \"true\") == 0) {\n+        return true;\n+    }\n+    if (strcasecmp(value, \"false\") == 0) {\n+        return false;\n+    }\n+  }\n+  return default_value;\n+}\n+\n+\n@@ -354,0 +386,6 @@\n+\/\/ Implementation of \"getversion\" command\n+static jint get_version(AttachOperation* op, outputStream* out) {\n+  out->print(\"%d\", (int)AttachListener::get_supported_version());\n+  return JNI_OK;\n+}\n+\n@@ -368,0 +406,1 @@\n+  { \"getversion\",       get_version },\n@@ -475,0 +514,172 @@\n+\n+void AttachListener::set_supported_version(AttachAPIVersion version) {\n+\/\/  _supported_version = version;\n+  const char* prop_name = \"jdk.attach.compat\";\n+  if (!get_bool_sys_prop(prop_name, false, JavaThread::current())) {\n+    _supported_version = version;\n+  }\n+}\n+\n+AttachAPIVersion AttachListener::get_supported_version() {\n+  return _supported_version;\n+}\n+\n+\n+int AttachOperation::RequestReader::read_uint() {\n+  const int MAX_VALUE = INT_MAX \/ 20;\n+  char ch;\n+  int value = 0;\n+  while (true) {\n+    int n = read(&ch, 1);\n+    if (n != 1) {\n+      \/\/ IO errors (n < 0) are logged by read().\n+      if (n == 0) { \/\/ EOF\n+        log_error(attach)(\"Failed to read int value: EOF\");\n+      }\n+      return -1;\n+    }\n+    if (ch == '\\0') {\n+      return value;\n+    }\n+    if (ch < '0' || ch > '9') {\n+      log_error(attach)(\"Failed to read int value: unexpected symbol: %c\", ch);\n+      return -1;\n+    }\n+    \/\/ Ensure there is no integer overflow.\n+    if (value >= MAX_VALUE) {\n+      log_error(attach)(\"Failed to read int value: too big\");\n+      return -1;\n+    }\n+    value = value * 10 + (ch - '0');\n+  }\n+}\n+\n+\/\/ Reads operation name and arguments.\n+\/\/ buffer_size: maximum data size;\n+\/\/ min_str_count: minimum number of strings in the request (name + arguments);\n+\/\/ min_read_size: minimum data size.\n+bool AttachOperation::read_request_data(AttachOperation::RequestReader* reader,\n+                                        int buffer_size, int min_str_count, int min_read_size) {\n+  char* buffer = (char*)os::malloc(buffer_size, mtServiceability);\n+  int str_count = 0;\n+  int off = 0;\n+  int left = buffer_size;\n+\n+  \/\/ Read until all (expected) strings or expected bytes have been read, the buffer is full, or EOF.\n+  do {\n+    int n = reader->read(buffer + off, left);\n+    if (n < 0) {\n+      os::free(buffer);\n+      return false;\n+    }\n+    if (n == 0) { \/\/ EOF\n+      break;\n+    }\n+    if (min_str_count > 0) { \/\/ need to count arguments\n+      for (int i = 0; i < n; i++) {\n+        if (buffer[off + i] == '\\0') {\n+          str_count++;\n+        }\n+      }\n+    }\n+    off += n;\n+    left -= n;\n+  } while (left > 0 && (off < min_read_size || str_count < min_str_count));\n+\n+  if (off < min_read_size || str_count < min_str_count) { \/\/ unexpected EOF\n+    log_error(attach)(\"Failed to read request: incomplete request\");\n+    os::free(buffer);\n+    return false;\n+  }\n+  \/\/ Request must ends with '\\0'.\n+  if (buffer[off - 1] != '\\0') {\n+    log_error(attach)(\"Failed to read request: not terminated\");\n+    os::free(buffer);\n+    return false;\n+  }\n+\n+  \/\/ Parse request.\n+  \/\/ Command name is the 1st string.\n+  set_name(buffer);\n+  log_debug(attach)(\"read request: cmd = %s\", buffer);\n+\n+  \/\/ Arguments.\n+  char* end = buffer + off;\n+  for (char* cur = strchr(buffer, '\\0') + 1; cur < end; cur = strchr(cur, '\\0') + 1) {\n+    log_debug(attach)(\"read request: arg = %s\", cur);\n+    append_arg(cur);\n+  }\n+\n+  os::free(buffer);\n+\n+  return true;\n+}\n+\n+bool AttachOperation::read_request(RequestReader* reader) {\n+  uint ver = reader->read_uint();\n+  int buffer_size = 0;\n+  \/\/ Read conditions:\n+  int min_str_count = 0; \/\/ expected number of strings in the request\n+  int min_read_size = 1; \/\/ expected size of the request data (by default 1 symbol for terminating '\\0')\n+  switch (ver) {\n+  case ATTACH_API_V1: \/\/ <ver>0<cmd>0<arg>0<arg>0<arg>0\n+    \/\/ Always contain a command (up to name_length_max chars)\n+    \/\/ and arg_count_max(3) arguments (each up to arg_length_max chars).\n+    buffer_size = (name_length_max + 1) + arg_count_max * (arg_length_max + 1);\n+    min_str_count = 1 \/*name*\/ + arg_count_max;\n+    break;\n+  case ATTACH_API_V2: \/\/ <ver>0<size>0<cmd>0<arg>0<arg>0<arg>0\n+    if (AttachListener::get_supported_version() < 2) {\n+        log_error(attach)(\"Failed to read request: v2 is unsupported ot disabled\");\n+        return false;\n+    }\n+\n+    \/\/ read size of the data\n+    buffer_size = reader->read_uint();\n+    if (buffer_size < 0) {\n+      return false;\n+    }\n+    log_debug(attach)(\"v2 request, data size = %d\", buffer_size);\n+\n+    \/\/ Sanity check: max request size is 256K.\n+    if (buffer_size > 256 * 1024) {\n+      log_error(attach)(\"Failed to read request: too big\");\n+      return false;\n+    }\n+    \/\/ Must contain exact 'buffer_size' bytes.\n+    min_read_size = buffer_size;\n+    break;\n+  default:\n+    log_error(attach)(\"Failed to read request: unknown version (%d)\", ver);\n+    return false;\n+  }\n+\n+  return read_request_data(reader, buffer_size, min_str_count, min_read_size);\n+}\n+\n+bool AttachOperation::ReplyWriter::write_fully(const void* buffer, int size) {\n+  const char* buf = (const char*)buffer;\n+  do {\n+    int n = write(buf, size);\n+    if (n < 0) {\n+      return false;\n+    }\n+    buf += n;\n+    size -= n;\n+  } while (size > 0);\n+  return true;\n+}\n+\n+bool AttachOperation::write_reply(ReplyWriter* writer, jint result, bufferedStream* result_stream) {\n+  char msg[32];\n+  os::snprintf_checked(msg, sizeof(msg), \"%d\\n\", result);\n+  if (!writer->write_fully(msg, (int)strlen(msg))) {\n+    return false;\n+  }\n+  if (!writer->write_fully(result_stream->base(), (int)result_stream->size())) {\n+    return false;\n+  }\n+  writer->flush();\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/services\/attachListener.cpp","additions":211,"deletions":0,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -62,0 +63,14 @@\n+\/*\n+Version 1 (since jdk6): attach operations always have 3 (AttachOperation::arg_count_max)\n+  arguments, each up to 1024 (AttachOperation::arg_length_max) chars.\n+Version 2 (since jdk24): attach operations may have any number of arguments of any length;\n+  for safety default implementation restricts attach operation request size by 256KB.\n+  To detect if target VM supports version 2, client sends \"getversion\" command.\n+  Old VM reports \"Operation not recognized\" error, newer VM reports version supported by the implementation.\n+  If the target VM does not support version 2, client uses version 1 to enqueue operations.\n+*\/\n+enum AttachAPIVersion: int {\n+    ATTACH_API_V1 = 1,\n+    ATTACH_API_V2 = 2\n+};\n+\n@@ -96,0 +111,2 @@\n+  static AttachAPIVersion _supported_version;\n+\n@@ -97,0 +114,3 @@\n+  static void set_supported_version(AttachAPIVersion version);\n+  static AttachAPIVersion get_supported_version();\n+\n@@ -139,2 +159,3 @@\n-class AttachOperation: public CHeapObj<mtInternal> {\n- public:\n+class AttachOperation: public CHeapObj<mtServiceability> {\n+public:\n+  \/\/ v1 constants\n@@ -151,3 +172,3 @@\n- private:\n-  char _name[name_length_max+1];\n-  char _arg[arg_count_max][arg_length_max+1];\n+private:\n+  char* _name;\n+  GrowableArrayCHeap<char*, mtServiceability> _args;\n@@ -155,2 +176,6 @@\n- public:\n-  const char* name() const                      { return _name; }\n+  static char* copy_str(const char* value) {\n+    return value == nullptr ? nullptr : os::strdup(value, mtServiceability);\n+  }\n+\n+public:\n+  const char* name() const { return _name; }\n@@ -160,4 +185,6 @@\n-    assert(strlen(name) <= name_length_max, \"exceeds maximum name length\");\n-    size_t len = MIN2(strlen(name), (size_t)name_length_max);\n-    memcpy(_name, name, len);\n-    _name[len] = '\\0';\n+    os::free(_name);\n+    _name = copy_str(name);\n+  }\n+\n+  int arg_count() const {\n+    return _args.length();\n@@ -168,2 +195,11 @@\n-    assert(i>=0 && i<arg_count_max, \"invalid argument index\");\n-    return _arg[i];\n+    \/\/ Historically clients expect empty string for absent or null arguments.\n+    if (i >= _args.length() || _args.at(i) == nullptr) {\n+      static char empty_str[] = \"\";\n+      return empty_str;\n+    }\n+    return _args.at(i);\n+  }\n+\n+  \/\/ appends an argument\n+  void append_arg(const char* arg) {\n+    _args.append(copy_str(arg));\n@@ -173,10 +209,2 @@\n-  void set_arg(int i, char* arg) {\n-    assert(i>=0 && i<arg_count_max, \"invalid argument index\");\n-    if (arg == nullptr) {\n-      _arg[i][0] = '\\0';\n-    } else {\n-      assert(strlen(arg) <= arg_length_max, \"exceeds maximum argument length\");\n-      size_t len = MIN2(strlen(arg), (size_t)arg_length_max);\n-      memcpy(_arg[i], arg, len);\n-      _arg[i][len] = '\\0';\n-    }\n+  void set_arg(int i, const char* arg) {\n+    _args.at_put_grow(i, copy_str(arg), nullptr);\n@@ -185,2 +213,2 @@\n-  \/\/ create an operation of a given name\n-  AttachOperation(const char* name) {\n+  \/\/ create an v1 operation of a given name (for compatibility, deprecated)\n+  AttachOperation(const char* name) : _name(nullptr) {\n@@ -188,1 +216,1 @@\n-    for (int i=0; i<arg_count_max; i++) {\n+    for (int i = 0; i < arg_count_max; i++) {\n@@ -193,0 +221,10 @@\n+  AttachOperation() : _name(nullptr) {\n+  }\n+\n+  virtual ~AttachOperation() {\n+    os::free(_name);\n+    for (GrowableArrayIterator<char*> it = _args.begin(); it != _args.end(); ++it) {\n+      os::free(*it);\n+    }\n+  }\n+\n@@ -195,0 +233,31 @@\n+\n+  \/\/ Helper classes\/methods for platform-specific implementations.\n+  class RequestReader {\n+  public:\n+    \/\/ Returns number of bytes read,\n+    \/\/ 0 on EOF, negative value on error.\n+    virtual int read(void* buffer, int size) = 0;\n+\n+    \/\/ Reads unsigned value, returns -1 on error.\n+    int read_uint();\n+  };\n+\n+  \/\/ Reads standard operation request (v1 or v2).\n+  bool read_request(RequestReader* reader);\n+\n+  class ReplyWriter {\n+  public:\n+    \/\/ Returns number of bytes written, negative value on error.\n+    virtual int write(const void* buffer, int size) = 0;\n+\n+    virtual void flush() {}\n+\n+    bool write_fully(const void* buffer, int size);\n+  };\n+\n+  \/\/ Writes standard operation reply (to be called from 'complete' method).\n+  bool write_reply(ReplyWriter* writer, jint result, bufferedStream* result_stream);\n+\n+private:\n+  bool read_request_data(AttachOperation::RequestReader* reader, int buffer_size, int min_str_count, int min_read_size);\n+\n@@ -196,0 +265,1 @@\n+\n","filename":"src\/hotspot\/share\/services\/attachListener.hpp","additions":97,"deletions":27,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-#include \"runtime\/interfaceSupport.inline.hpp\"\n@@ -163,5 +162,0 @@\n-  \/\/ Debug on cmd (only makes sense with JVMTI since the agentlib needs it).\n-#if INCLUDE_JVMTI\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<DebugOnCmdStartDCmd>(full_export, true, true));\n-#endif \/\/ INCLUDE_JVMTI\n-\n@@ -1061,39 +1055,0 @@\n-#if INCLUDE_JVMTI\n-extern \"C\" typedef char const* (JNICALL *debugInit_startDebuggingViaCommandPtr)(JNIEnv* env, jthread thread, char const** transport_name,\n-                                                                                char const** address, jboolean* first_start);\n-static debugInit_startDebuggingViaCommandPtr dvc_start_ptr = nullptr;\n-\n-void DebugOnCmdStartDCmd::execute(DCmdSource source, TRAPS) {\n-  char const* transport = nullptr;\n-  char const* addr = nullptr;\n-  jboolean is_first_start = JNI_FALSE;\n-  JavaThread* thread = THREAD;\n-  jthread jt = JNIHandles::make_local(thread->threadObj());\n-  ThreadToNativeFromVM ttn(thread);\n-  const char *error = \"Could not find jdwp agent.\";\n-\n-  if (!dvc_start_ptr) {\n-    JvmtiAgentList::Iterator it = JvmtiAgentList::agents();\n-    while (it.has_next()) {\n-      JvmtiAgent* agent = it.next();\n-      if ((strcmp(\"jdwp\", agent->name()) == 0) && (dvc_start_ptr == nullptr)) {\n-        char const* func = \"debugInit_startDebuggingViaCommand\";\n-        dvc_start_ptr = (debugInit_startDebuggingViaCommandPtr) os::find_agent_function(agent, false, &func, 1);\n-      }\n-    }\n-  }\n-\n-  if (dvc_start_ptr) {\n-    error = dvc_start_ptr(thread->jni_environment(), jt, &transport, &addr, &is_first_start);\n-  }\n-\n-  if (error != nullptr) {\n-    output()->print_cr(\"Debugging has not been started: %s\", error);\n-  } else {\n-    output()->print_cr(is_first_start ? \"Debugging has been started.\" : \"Debugging is already active.\");\n-    output()->print_cr(\"Transport : %s\", transport ? transport : \"#unknown\");\n-    output()->print_cr(\"Address : %s\", addr ? addr : \"#unknown\");\n-  }\n-}\n-#endif \/\/ INCLUDE_JVMTI\n-\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":0,"deletions":45,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -889,21 +889,0 @@\n-#if INCLUDE_JVMTI\n-class DebugOnCmdStartDCmd : public DCmd {\n-public:\n-  DebugOnCmdStartDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}\n-  static const char* name() {\n-    return \"VM.start_java_debugging\";\n-  }\n-  static const char* description() {\n-    return \"Starts up the Java debugging if the jdwp agentlib was enabled with the option onjcmd=y.\";\n-  }\n-  static const char* impact() {\n-    return \"High: Switches the VM into Java debug mode.\";\n-  }\n-  static const JavaPermission permission() {\n-    JavaPermission p = { \"java.lang.management.ManagementPermission\", \"control\", nullptr };\n-    return p;\n-  }\n-  virtual void execute(DCmdSource source, TRAPS);\n-};\n-#endif \/\/ INCLUDE_JVMTI\n-\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-import jdk.internal.util.StaticProperty;\n+import sun.nio.cs.UTF_8;\n@@ -583,1 +583,2 @@\n-     * (e.g., keyboard and\/or display) specified by the host environment or user.\n+     * (e.g., keyboard and\/or display) specified by the host environment or user,\n+     * which defaults to the one based on {@link System##stdout.encoding stdout.encoding}.\n@@ -617,1 +618,0 @@\n-    private static native String encoding();\n@@ -619,1 +619,3 @@\n-    static final Charset CHARSET;\n+    static final Charset CHARSET =\n+        Charset.forName(GetPropertyAction.privilegedGetProperty(\"stdout.encoding\"), UTF_8.INSTANCE);\n+    private static final Console cons = instantiateConsole();\n@@ -621,20 +623,0 @@\n-        Charset cs = null;\n-\n-        if (istty) {\n-            String csname = encoding();\n-            if (csname == null) {\n-                csname = GetPropertyAction.privilegedGetProperty(\"stdout.encoding\");\n-            }\n-            if (csname != null) {\n-                cs = Charset.forName(csname, null);\n-            }\n-        }\n-        if (cs == null) {\n-            cs = Charset.forName(StaticProperty.nativeEncoding(),\n-                    Charset.defaultCharset());\n-        }\n-\n-        CHARSET = cs;\n-\n-        cons = instantiateConsole();\n-\n@@ -692,1 +674,0 @@\n-    private static final Console cons;\n","filename":"src\/java.base\/share\/classes\/java\/io\/Console.java","additions":6,"deletions":25,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -143,0 +143,113 @@\n+    \/**\n+     * Returns a {@code Reader} that reads characters from a\n+     * {@code CharSequence}. The reader is initially open and reading starts at\n+     * the first character in the sequence.\n+     *\n+     * <p> The returned reader supports the {@link #mark mark()} and\n+     * {@link #reset reset()} operations.\n+     *\n+     * <p> The resulting reader is not safe for use by multiple\n+     * concurrent threads. If the reader is to be used by more than one\n+     * thread it should be controlled by appropriate synchronization.\n+     *\n+     * <p> If the sequence changes while the reader is open, e.g. the length\n+     * changes, the behavior is undefined.\n+     *\n+     * @param cs {@code CharSequence} providing the character stream.\n+     * @return a {@code Reader} which reads characters from {@code cs}\n+     * @throws NullPointerException if {@code cs} is {@code null}\n+     *\n+     * @since 24\n+     *\/\n+    public static Reader of(final CharSequence cs) {\n+        Objects.requireNonNull(cs);\n+\n+        return new Reader() {\n+            private boolean isClosed;\n+            private int next = 0;\n+            private int mark = 0;\n+\n+            \/** Check to make sure that the stream has not been closed *\/\n+            private void ensureOpen() throws IOException {\n+                if (isClosed)\n+                    throw new IOException(\"Stream closed\");\n+            }\n+\n+            @Override\n+            public int read() throws IOException {\n+                ensureOpen();\n+                if (next >= cs.length())\n+                    return -1;\n+                return cs.charAt(next++);\n+            }\n+\n+            @Override\n+            public int read(char[] cbuf, int off, int len) throws IOException {\n+                ensureOpen();\n+                Objects.checkFromIndexSize(off, len, cbuf.length);\n+                if (len == 0) {\n+                    return 0;\n+                }\n+                int length = cs.length();\n+                if (next >= length)\n+                    return -1;\n+                int n = Math.min(length - next, len);\n+                switch (cs) {\n+                    case String s -> s.getChars(next, next + n, cbuf, off);\n+                    case StringBuilder sb -> sb.getChars(next, next + n, cbuf, off);\n+                    case StringBuffer sb -> sb.getChars(next, next + n, cbuf, off);\n+                    case CharBuffer cb -> cb.get(next, cbuf, off, n);\n+                    default -> {\n+                        for (int i = 0; i < n; i++)\n+                            cbuf[off + i] = cs.charAt(next + i);\n+                    }\n+                }\n+                next += n;\n+                return n;\n+            }\n+\n+            @Override\n+            public long skip(long n) throws IOException {\n+                ensureOpen();\n+                if (next >= cs.length())\n+                    return 0;\n+                \/\/ Bound skip by beginning and end of the source\n+                long r = Math.min(cs.length() - next, n);\n+                r = Math.max(-next, r);\n+                next += (int)r;\n+                return r;\n+            }\n+\n+            @Override\n+            public boolean ready() throws IOException {\n+                ensureOpen();\n+                return true;\n+            }\n+\n+            @Override\n+            public boolean markSupported() {\n+                return true;\n+            }\n+\n+            @Override\n+            public void mark(int readAheadLimit) throws IOException {\n+                if (readAheadLimit < 0){\n+                    throw new IllegalArgumentException(\"Read-ahead limit < 0\");\n+                }\n+                ensureOpen();\n+                mark = next;\n+            }\n+\n+            @Override\n+            public void reset() throws IOException {\n+                ensureOpen();\n+                next = mark;\n+            }\n+\n+            @Override\n+            public void close() {\n+                isClosed = true;\n+            }\n+        };\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/Reader.java","additions":114,"deletions":1,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,4 @@\n+ * @apiNote\n+ * {@link Reader#of(CharSequence)} provides a method to read from any\n+ * {@link CharSequence} that may be more efficient than {@code StringReader}.\n+ *\n@@ -39,4 +43,1 @@\n-    private final int length;\n-    private String str;\n-    private int next = 0;\n-    private int mark = 0;\n+    private final Reader r;\n@@ -50,8 +51,1 @@\n-        this.length = s.length();\n-        this.str = s;\n-    }\n-\n-    \/** Check to make sure that the stream has not been closed *\/\n-    private void ensureOpen() throws IOException {\n-        if (str == null)\n-            throw new IOException(\"Stream closed\");\n+        r = Reader.of(s);\n@@ -70,4 +64,1 @@\n-            ensureOpen();\n-            if (next >= length)\n-                return -1;\n-            return str.charAt(next++);\n+            return r.read();\n@@ -97,11 +88,1 @@\n-            ensureOpen();\n-            Objects.checkFromIndexSize(off, len, cbuf.length);\n-            if (len == 0) {\n-                return 0;\n-            }\n-            if (next >= length)\n-                return -1;\n-            int n = Math.min(length - next, len);\n-            str.getChars(next, next + n, cbuf, off);\n-            next += n;\n-            return n;\n+            return r.read(cbuf, off, len);\n@@ -133,8 +114,1 @@\n-            ensureOpen();\n-            if (next >= length)\n-                return 0;\n-            \/\/ Bound skip by beginning and end of the source\n-            long r = Math.min(length - next, n);\n-            r = Math.max(-next, r);\n-            next += (int)r;\n-            return r;\n+            return r.skip(n);\n@@ -153,2 +127,1 @@\n-            ensureOpen();\n-            return true;\n+            return r.ready();\n@@ -179,3 +152,0 @@\n-        if (readAheadLimit < 0){\n-            throw new IllegalArgumentException(\"Read-ahead limit < 0\");\n-        }\n@@ -183,2 +153,1 @@\n-            ensureOpen();\n-            mark = next;\n+            r.mark(readAheadLimit);\n@@ -196,2 +165,1 @@\n-            ensureOpen();\n-            next = mark;\n+            r.reset();\n@@ -210,1 +178,5 @@\n-            str = null;\n+            try {\n+                r.close();\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/io\/StringReader.java","additions":18,"deletions":46,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -258,2 +258,2 @@\n-        if (obj instanceof Boolean) {\n-            return value == ((Boolean)obj).booleanValue();\n+        if (obj instanceof Boolean b) {\n+            return value == b.booleanValue();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Boolean.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -480,2 +480,2 @@\n-        if (obj instanceof Byte) {\n-            return value == ((Byte)obj).byteValue();\n+        if (obj instanceof Byte b) {\n+            return value == b.byteValue();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Byte.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -9069,2 +9069,2 @@\n-        if (obj instanceof Character) {\n-            return value == ((Character)obj).charValue();\n+        if (obj instanceof Character c) {\n+            return value == c.charValue();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Character.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1260,3 +1260,2 @@\n-        return (obj instanceof Double)\n-               && (doubleToLongBits(((Double)obj).value) ==\n-                      doubleToLongBits(value));\n+        return (obj instanceof Double d) &&\n+            (doubleToLongBits(d.value) == doubleToLongBits(value));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Double.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -892,2 +892,2 @@\n-        return (obj instanceof Float)\n-               && (floatToIntBits(((Float)obj).value) == floatToIntBits(value));\n+        return (obj instanceof Float f) &&\n+            (floatToIntBits(f.value) == floatToIntBits(value));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1150,2 +1150,2 @@\n-        if (obj instanceof Integer) {\n-            return value == ((Integer)obj).intValue();\n+        if (obj instanceof Integer i) {\n+            return value == i.intValue();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1248,2 +1248,2 @@\n-        if (obj instanceof Long) {\n-            return value == ((Long)obj).longValue();\n+        if (obj instanceof Long ell) {\n+            return value == ell.longValue();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -486,2 +486,2 @@\n-        if (obj instanceof Short) {\n-            return value == ((Short)obj).shortValue();\n+        if (obj instanceof Short s) {\n+            return value == s.shortValue();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Short.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -150,2 +150,1 @@\n-     * {@link Console#charset()} if the {@code Console} exists,\n-     * <a href=\"#stdout.encoding\">stdout.encoding<\/a> otherwise.\n+     * {@link ##stdout.encoding stdout.encoding}.\n@@ -171,2 +170,1 @@\n-     * @see     Console#charset()\n-     * @see     <a href=\"#stdout.encoding\">stdout.encoding<\/a>\n+     * @see     ##stdout.encoding stdout.encoding\n@@ -188,2 +186,1 @@\n-     * equivalent to {@link Console#charset()} if the {@code Console}\n-     * exists, <a href=\"#stderr.encoding\">stderr.encoding<\/a> otherwise.\n+     * equivalent to {@link ##stderr.encoding stderr.encoding}.\n@@ -191,2 +188,1 @@\n-     * @see     Console#charset()\n-     * @see     <a href=\"#stderr.encoding\">stderr.encoding<\/a>\n+     * @see     ##stderr.encoding stderr.encoding\n@@ -791,1 +787,2 @@\n-     *     <td>Character encoding name for {@link System#out System.out}.\n+     *     <td>Character encoding name for {@link System#out System.out} and\n+     *     {@link System#console() System.console()}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.util.stream.Stream;\n@@ -31,0 +30,2 @@\n+import jdk.internal.constant.ArrayClassDescImpl;\n+import jdk.internal.constant.ConstantUtils;\n@@ -32,2 +33,1 @@\n-import jdk.internal.constant.ReferenceClassDescImpl;\n-import sun.invoke.util.Wrapper;\n+import jdk.internal.constant.ClassOrInterfaceDescImpl;\n@@ -35,10 +35,1 @@\n-import static java.util.stream.Collectors.joining;\n-import static jdk.internal.constant.ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS;\n-import static jdk.internal.constant.ConstantUtils.arrayDepth;\n-import static jdk.internal.constant.ConstantUtils.binaryToInternal;\n-import static jdk.internal.constant.ConstantUtils.concat;\n-import static jdk.internal.constant.ConstantUtils.forPrimitiveType;\n-import static jdk.internal.constant.ConstantUtils.internalToBinary;\n-import static jdk.internal.constant.ConstantUtils.validateBinaryClassName;\n-import static jdk.internal.constant.ConstantUtils.validateInternalClassName;\n-import static jdk.internal.constant.ConstantUtils.validateMemberName;\n+import static jdk.internal.constant.ConstantUtils.*;\n@@ -67,1 +58,2 @@\n-                ReferenceClassDescImpl {\n+                ClassOrInterfaceDescImpl,\n+                ArrayClassDescImpl {\n@@ -87,1 +79,1 @@\n-        return ClassDesc.ofDescriptor(concat(\"L\", binaryToInternal(name), \";\"));\n+        return ConstantUtils.binaryNameToDesc(name);\n@@ -113,1 +105,1 @@\n-        return ClassDesc.ofDescriptor(concat(\"L\", name, \";\"));\n+        return ConstantUtils.internalNameToDesc(name);\n@@ -132,0 +124,1 @@\n+        validateMemberName(className, false);\n@@ -133,1 +126,1 @@\n-            return of(className);\n+            return internalNameToDesc(className);\n@@ -135,2 +128,1 @@\n-        validateMemberName(className, false);\n-        return ofDescriptor('L' + binaryToInternal(packageName) +\n+        return ClassOrInterfaceDescImpl.ofValidated('L' + binaryToInternal(packageName) +\n@@ -171,1 +163,1 @@\n-               : ReferenceClassDescImpl.of(descriptor);\n+               : parseReferenceTypeDesc(descriptor);\n@@ -183,14 +175,1 @@\n-    default ClassDesc arrayType() {\n-        String desc = descriptorString();\n-        int depth = arrayDepth(desc);\n-        if (depth >= MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n-            throw new IllegalStateException(\n-                    \"Cannot create an array type descriptor with more than \" +\n-                    MAX_ARRAY_TYPE_DESC_DIMENSIONS + \" dimensions\");\n-        }\n-        String newDesc = \"[\".concat(desc);\n-        if (desc.length() == 1 && desc.charAt(0) == 'V') {\n-            throw new IllegalArgumentException(\"not a valid reference type descriptor: \" + newDesc);\n-        }\n-        return ReferenceClassDescImpl.ofValidated(newDesc);\n-    }\n+    ClassDesc arrayType();\n@@ -209,18 +188,1 @@\n-    default ClassDesc arrayType(int rank) {\n-        if (rank <= 0) {\n-            throw new IllegalArgumentException(\"rank \" + rank + \" is not a positive value\");\n-        }\n-        String desc = descriptorString();\n-        long currentDepth = arrayDepth(desc);\n-        long netRank = currentDepth + rank;\n-        if (netRank > MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n-            throw new IllegalArgumentException(\"rank: \" + netRank +\n-                    \" exceeds maximum supported dimension of \" +\n-                    MAX_ARRAY_TYPE_DESC_DIMENSIONS);\n-        }\n-        String newDesc = new StringBuilder(desc.length() + rank).repeat('[', rank).append(desc).toString();\n-        if (desc.length() == 1 && desc.charAt(0) == 'V') {\n-            throw new IllegalArgumentException(\"not a valid reference type descriptor: \" + newDesc);\n-        }\n-        return ReferenceClassDescImpl.ofValidated(newDesc);\n-    }\n+    ClassDesc arrayType(int rank);\n@@ -246,7 +208,1 @@\n-        validateMemberName(nestedName, false);\n-        if (!isClassOrInterface())\n-            throw new IllegalStateException(\"Outer class is not a class or interface type\");\n-        String desc = descriptorString();\n-        StringBuilder sb = new StringBuilder(desc.length() + nestedName.length() + 1);\n-        sb.append(desc, 0, desc.length() - 1).append('$').append(nestedName).append(';');\n-        return ReferenceClassDescImpl.ofValidated(sb.toString());\n+        throw new IllegalStateException(\"Outer class is not a class or interface type\");\n@@ -269,10 +225,1 @@\n-        if (!isClassOrInterface())\n-            throw new IllegalStateException(\"Outer class is not a class or interface type\");\n-        validateMemberName(firstNestedName, false);\n-        \/\/ implicit null-check\n-        for (String addNestedNames : moreNestedNames) {\n-            validateMemberName(addNestedNames, false);\n-        }\n-        return moreNestedNames.length == 0\n-               ? nested(firstNestedName)\n-               : nested(firstNestedName + Stream.of(moreNestedNames).collect(joining(\"$\", \"$\", \"\")));\n+        throw new IllegalStateException(\"Outer class is not a class or interface type\");\n@@ -287,1 +234,1 @@\n-        return descriptorString().charAt(0) == '[';\n+        return false;\n@@ -296,1 +243,1 @@\n-        return descriptorString().length() == 1;\n+        return false;\n@@ -305,1 +252,1 @@\n-        return descriptorString().charAt(0) == 'L';\n+        return false;\n@@ -316,8 +263,0 @@\n-        if (isArray()) {\n-            String desc = descriptorString();\n-            if (desc.length() == 2) {\n-                return Wrapper.forBasicType(desc.charAt(1)).basicClassDescriptor();\n-            } else {\n-                return ReferenceClassDescImpl.ofValidated(desc.substring(1));\n-            }\n-        }\n@@ -335,5 +274,1 @@\n-        if (!isClassOrInterface())\n-            return \"\";\n-        String desc = descriptorString();\n-        int index = desc.lastIndexOf('\/');\n-        return (index == -1) ? \"\" : internalToBinary(desc.substring(1, index));\n+        return \"\";\n@@ -343,9 +278,5 @@\n-     * Returns a human-readable name for the type described by this descriptor.\n-     *\n-     * @implSpec\n-     * <p>The default implementation returns the simple name\n-     * (e.g., {@code int}) for primitive types, the unqualified class name\n-     * for class or interface types, or the display name of the component type\n-     * suffixed with the appropriate number of {@code []} pairs for array types.\n-     *\n-     * @return the human-readable name\n+     * {@return a human-readable name for this {@code ClassDesc}}\n+     * For primitive types, this method returns the simple name (such as {@code int}).\n+     * For class or interface types, this method returns the unqualified class name.\n+     * For array types, this method returns the human-readable name of the component\n+     * type suffixed with the appropriate number of {@code []} pairs.\n@@ -353,17 +284,1 @@\n-    default String displayName() {\n-        if (isPrimitive())\n-            return Wrapper.forBasicType(descriptorString().charAt(0)).primitiveSimpleName();\n-        else if (isClassOrInterface()) {\n-            String desc = descriptorString();\n-            return desc.substring(Math.max(1, desc.lastIndexOf('\/') + 1), desc.length() - 1);\n-        }\n-        else if (isArray()) {\n-            int depth = arrayDepth(descriptorString());\n-            ClassDesc c = this;\n-            for (int i=0; i<depth; i++)\n-                c = c.componentType();\n-            return c.displayName().concat(\"[]\".repeat(depth));\n-        }\n-        else\n-            throw new IllegalStateException(descriptorString());\n-    }\n+    String displayName();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ClassDesc.java","additions":26,"deletions":111,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import jdk.internal.constant.ClassOrInterfaceDescImpl;\n+import jdk.internal.constant.ConstantUtils;\n@@ -29,1 +31,0 @@\n-import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -71,1 +72,1 @@\n-    public static final ClassDesc CD_Object = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Object;\");\n+    public static final ClassDesc CD_Object = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/Object;\");\n@@ -74,1 +75,1 @@\n-    public static final ClassDesc CD_String = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/String;\");\n+    public static final ClassDesc CD_String = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/String;\");\n@@ -77,1 +78,1 @@\n-    public static final ClassDesc CD_Class = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Class;\");\n+    public static final ClassDesc CD_Class = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/Class;\");\n@@ -80,1 +81,1 @@\n-    public static final ClassDesc CD_Number = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Number;\");\n+    public static final ClassDesc CD_Number = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/Number;\");\n@@ -83,1 +84,1 @@\n-    public static final ClassDesc CD_Integer = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Integer;\");\n+    public static final ClassDesc CD_Integer = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/Integer;\");\n@@ -86,1 +87,1 @@\n-    public static final ClassDesc CD_Long = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Long;\");\n+    public static final ClassDesc CD_Long = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/Long;\");\n@@ -89,1 +90,1 @@\n-    public static final ClassDesc CD_Float = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Float;\");\n+    public static final ClassDesc CD_Float = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/Float;\");\n@@ -92,1 +93,1 @@\n-    public static final ClassDesc CD_Double = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Double;\");\n+    public static final ClassDesc CD_Double = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/Double;\");\n@@ -95,1 +96,1 @@\n-    public static final ClassDesc CD_Short = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Short;\");\n+    public static final ClassDesc CD_Short = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/Short;\");\n@@ -98,1 +99,1 @@\n-    public static final ClassDesc CD_Byte = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Byte;\");\n+    public static final ClassDesc CD_Byte = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/Byte;\");\n@@ -101,1 +102,1 @@\n-    public static final ClassDesc CD_Character = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Character;\");\n+    public static final ClassDesc CD_Character = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/Character;\");\n@@ -104,1 +105,1 @@\n-    public static final ClassDesc CD_Boolean = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Boolean;\");\n+    public static final ClassDesc CD_Boolean = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/Boolean;\");\n@@ -107,1 +108,1 @@\n-    public static final ClassDesc CD_Void = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Void;\");\n+    public static final ClassDesc CD_Void = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/Void;\");\n@@ -110,1 +111,1 @@\n-    public static final ClassDesc CD_Throwable = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Throwable;\");\n+    public static final ClassDesc CD_Throwable = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/Throwable;\");\n@@ -113,1 +114,1 @@\n-    public static final ClassDesc CD_Exception = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Exception;\");\n+    public static final ClassDesc CD_Exception = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/Exception;\");\n@@ -116,1 +117,1 @@\n-    public static final ClassDesc CD_Enum = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Enum;\");\n+    public static final ClassDesc CD_Enum = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/Enum;\");\n@@ -119,1 +120,1 @@\n-    public static final ClassDesc CD_VarHandle = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/VarHandle;\");\n+    public static final ClassDesc CD_VarHandle = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/VarHandle;\");\n@@ -122,1 +123,1 @@\n-    public static final ClassDesc CD_MethodHandles = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandles;\");\n+    public static final ClassDesc CD_MethodHandles = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandles;\");\n@@ -125,1 +126,1 @@\n-    public static final ClassDesc CD_MethodHandles_Lookup = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandles$Lookup;\");\n+    public static final ClassDesc CD_MethodHandles_Lookup = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandles$Lookup;\");\n@@ -128,1 +129,1 @@\n-    public static final ClassDesc CD_MethodHandle = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandle;\");\n+    public static final ClassDesc CD_MethodHandle = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandle;\");\n@@ -131,1 +132,1 @@\n-    public static final ClassDesc CD_MethodType = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodType;\");\n+    public static final ClassDesc CD_MethodType = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodType;\");\n@@ -134,1 +135,1 @@\n-    public static final ClassDesc CD_CallSite = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/CallSite;\");\n+    public static final ClassDesc CD_CallSite = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/CallSite;\");\n@@ -137,1 +138,1 @@\n-    public static final ClassDesc CD_Collection = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/Collection;\");\n+    public static final ClassDesc CD_Collection = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/util\/Collection;\");\n@@ -140,1 +141,1 @@\n-    public static final ClassDesc CD_List = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/List;\");\n+    public static final ClassDesc CD_List = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/util\/List;\");\n@@ -143,1 +144,1 @@\n-    public static final ClassDesc CD_Set = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/Set;\");\n+    public static final ClassDesc CD_Set = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/util\/Set;\");\n@@ -146,1 +147,1 @@\n-    public static final ClassDesc CD_Map = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/Map;\");\n+    public static final ClassDesc CD_Map = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/util\/Map;\");\n@@ -149,1 +150,1 @@\n-    public static final ClassDesc CD_ConstantDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/ConstantDesc;\");\n+    public static final ClassDesc CD_ConstantDesc = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/constant\/ConstantDesc;\");\n@@ -152,1 +153,1 @@\n-    public static final ClassDesc CD_ClassDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/ClassDesc;\");\n+    public static final ClassDesc CD_ClassDesc = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/constant\/ClassDesc;\");\n@@ -155,1 +156,1 @@\n-    public static final ClassDesc CD_EnumDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Enum$EnumDesc;\");\n+    public static final ClassDesc CD_EnumDesc = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/Enum$EnumDesc;\");\n@@ -158,1 +159,1 @@\n-    public static final ClassDesc CD_MethodTypeDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/MethodTypeDesc;\");\n+    public static final ClassDesc CD_MethodTypeDesc = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/constant\/MethodTypeDesc;\");\n@@ -161,1 +162,1 @@\n-    public static final ClassDesc CD_MethodHandleDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/MethodHandleDesc;\");\n+    public static final ClassDesc CD_MethodHandleDesc = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/constant\/MethodHandleDesc;\");\n@@ -164,1 +165,1 @@\n-    public static final ClassDesc CD_DirectMethodHandleDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/DirectMethodHandleDesc;\");\n+    public static final ClassDesc CD_DirectMethodHandleDesc = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/constant\/DirectMethodHandleDesc;\");\n@@ -167,1 +168,1 @@\n-    public static final ClassDesc CD_VarHandleDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/VarHandle$VarHandleDesc;\");\n+    public static final ClassDesc CD_VarHandleDesc = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/VarHandle$VarHandleDesc;\");\n@@ -170,1 +171,1 @@\n-    public static final ClassDesc CD_MethodHandleDesc_Kind = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/DirectMethodHandleDesc$Kind;\");\n+    public static final ClassDesc CD_MethodHandleDesc_Kind = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/constant\/DirectMethodHandleDesc$Kind;\");\n@@ -173,1 +174,1 @@\n-    public static final ClassDesc CD_DynamicConstantDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/DynamicConstantDesc;\");\n+    public static final ClassDesc CD_DynamicConstantDesc = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/constant\/DynamicConstantDesc;\");\n@@ -176,1 +177,1 @@\n-    public static final ClassDesc CD_DynamicCallSiteDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/DynamicCallSiteDesc;\");\n+    public static final ClassDesc CD_DynamicCallSiteDesc = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/constant\/DynamicCallSiteDesc;\");\n@@ -179,1 +180,6 @@\n-    public static final ClassDesc CD_ConstantBootstraps = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/ConstantBootstraps;\");\n+    public static final ClassDesc CD_ConstantBootstraps = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/ConstantBootstraps;\");\n+\n+    static {\n+        \/\/ avoid circular initialization\n+        ConstantUtils.CD_Object_array = CD_Object.arrayType();\n+    }\n@@ -232,1 +238,1 @@\n-            CD_Object, CD_MethodHandle, CD_Object.arrayType());\n+            CD_Object, CD_MethodHandle, ConstantUtils.CD_Object_array);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantDescs.java","additions":45,"deletions":39,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+import jdk.internal.constant.ClassOrInterfaceDescImpl;\n+import jdk.internal.constant.ConstantUtils;\n@@ -46,1 +48,0 @@\n-import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -68,2 +69,2 @@\n-    private static final ClassDesc CD_LambdaForm = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm;\");\n-    private static final ClassDesc CD_BoundMethodHandle = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/BoundMethodHandle;\");\n+    private static final ClassDesc CD_LambdaForm = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm;\");\n+    private static final ClassDesc CD_BoundMethodHandle = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/BoundMethodHandle;\");\n@@ -977,1 +978,1 @@\n-             : ReferenceClassDescImpl.ofValidated(cls.descriptorString());\n+             : ConstantUtils.referenceClassDesc(cls.descriptorString());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ClassSpecializer.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.constant.ClassOrInterfaceDescImpl;\n@@ -56,1 +57,0 @@\n-import static java.lang.invoke.MethodType.methodType;\n@@ -59,1 +59,0 @@\n-import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -160,1 +159,1 @@\n-        lambdaClassEntry = pool.classEntry(ReferenceClassDescImpl.ofValidated(ConstantUtils.concat(\"L\", lambdaClassName, \";\")));\n+        lambdaClassEntry = pool.classEntry(ConstantUtils.internalNameToDesc(lambdaClassName));\n@@ -410,3 +409,3 @@\n-        private static final ClassDesc CD_SerializedLambda = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/SerializedLambda;\");\n-        private static final ClassDesc CD_ObjectOutputStream = ReferenceClassDescImpl.ofValidated(\"Ljava\/io\/ObjectOutputStream;\");\n-        private static final ClassDesc CD_ObjectInputStream = ReferenceClassDescImpl.ofValidated(\"Ljava\/io\/ObjectInputStream;\");\n+        private static final ClassDesc CD_SerializedLambda = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/SerializedLambda;\");\n+        private static final ClassDesc CD_ObjectOutputStream = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/io\/ObjectOutputStream;\");\n+        private static final ClassDesc CD_ObjectInputStream = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/io\/ObjectInputStream;\");\n@@ -421,1 +420,1 @@\n-        static final ClassDesc CD_NotSerializableException = ReferenceClassDescImpl.ofValidated(\"Ljava\/io\/NotSerializableException;\");\n+        static final ClassDesc CD_NotSerializableException = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/io\/NotSerializableException;\");\n@@ -424,1 +423,1 @@\n-                CD_Class, CD_String, CD_String, CD_String, CD_int, CD_String, CD_String, CD_String, CD_String, ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\"));\n+                CD_Class, CD_String, CD_String, CD_String, CD_int, CD_String, CD_String, CD_String, CD_String, ConstantUtils.CD_Object_array);\n@@ -560,1 +559,1 @@\n-        return cls.isHidden() ? null : ReferenceClassDescImpl.ofValidated(cls.descriptorString());\n+        return cls.isHidden() ? null : ConstantUtils.referenceClassDesc(cls.descriptorString());\n@@ -565,1 +564,1 @@\n-                                 : ReferenceClassDescImpl.ofValidated(cls.descriptorString());\n+                                 : ConstantUtils.referenceClassDesc(cls.descriptorString());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.constant.ClassOrInterfaceDescImpl;\n+import jdk.internal.constant.ConstantUtils;\n@@ -53,1 +55,0 @@\n-import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -62,1 +63,0 @@\n-import static jdk.internal.constant.ConstantUtils.concat;\n@@ -72,10 +72,10 @@\n-    private static final ClassDesc CD_CasesHolder = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandleImpl$CasesHolder;\");\n-    private static final ClassDesc CD_DirectMethodHandle = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/DirectMethodHandle;\");\n-    private static final ClassDesc CD_MemberName = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MemberName;\");\n-    private static final ClassDesc CD_MethodHandleImpl = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandleImpl;\");\n-    private static final ClassDesc CD_LambdaForm = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm;\");\n-    private static final ClassDesc CD_LambdaForm_Name = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm$Name;\");\n-    private static final ClassDesc CD_LoopClauses = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandleImpl$LoopClauses;\");\n-    private static final ClassDesc CD_Object_array  = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\");\n-    private static final ClassDesc CD_MethodHandle_array = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/invoke\/MethodHandle;\");\n-    private static final ClassDesc CD_MethodHandle_array2 = ReferenceClassDescImpl.ofValidated(\"[[Ljava\/lang\/invoke\/MethodHandle;\");\n+    private static final ClassDesc CD_CasesHolder = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandleImpl$CasesHolder;\");\n+    private static final ClassDesc CD_DirectMethodHandle = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/DirectMethodHandle;\");\n+    private static final ClassDesc CD_MemberName = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MemberName;\");\n+    private static final ClassDesc CD_MethodHandleImpl = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandleImpl;\");\n+    private static final ClassDesc CD_LambdaForm = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm;\");\n+    private static final ClassDesc CD_LambdaForm_Name = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm$Name;\");\n+    private static final ClassDesc CD_LoopClauses = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandleImpl$LoopClauses;\");\n+    private static final ClassDesc CD_Object_array = ConstantUtils.CD_Object_array;\n+    private static final ClassDesc CD_MethodHandle_array = CD_MethodHandle.arrayType();\n+    private static final ClassDesc CD_MethodHandle_array2 = CD_MethodHandle_array.arrayType();\n@@ -136,1 +136,1 @@\n-        this.classEntry = pool.classEntry(ReferenceClassDescImpl.ofValidated(concat(\"L\", className, \";\")));\n+        this.classEntry = pool.classEntry(ConstantUtils.internalNameToDesc(className));\n@@ -520,5 +520,5 @@\n-    static final Annotation DONTINLINE      = Annotation.of(ReferenceClassDescImpl.ofValidated(\"Ljdk\/internal\/vm\/annotation\/DontInline;\"));\n-    static final Annotation FORCEINLINE     = Annotation.of(ReferenceClassDescImpl.ofValidated(\"Ljdk\/internal\/vm\/annotation\/ForceInline;\"));\n-    static final Annotation HIDDEN          = Annotation.of(ReferenceClassDescImpl.ofValidated(\"Ljdk\/internal\/vm\/annotation\/Hidden;\"));\n-    static final Annotation INJECTEDPROFILE = Annotation.of(ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/InjectedProfile;\"));\n-    static final Annotation LF_COMPILED     = Annotation.of(ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm$Compiled;\"));\n+    static final Annotation DONTINLINE      = Annotation.of(ClassOrInterfaceDescImpl.ofValidated(\"Ljdk\/internal\/vm\/annotation\/DontInline;\"));\n+    static final Annotation FORCEINLINE     = Annotation.of(ClassOrInterfaceDescImpl.ofValidated(\"Ljdk\/internal\/vm\/annotation\/ForceInline;\"));\n+    static final Annotation HIDDEN          = Annotation.of(ClassOrInterfaceDescImpl.ofValidated(\"Ljdk\/internal\/vm\/annotation\/Hidden;\"));\n+    static final Annotation INJECTEDPROFILE = Annotation.of(ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/InjectedProfile;\"));\n+    static final Annotation LF_COMPILED     = Annotation.of(ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm$Compiled;\"));\n@@ -1652,1 +1652,1 @@\n-             : ReferenceClassDescImpl.ofValidated(cls.descriptorString());\n+             : ConstantUtils.referenceClassDesc(cls.descriptorString());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -304,1 +304,0 @@\n-        COLLECT(\"collect\"),\n@@ -306,2 +305,0 @@\n-        CONVERT(\"convert\"),\n-        SPREAD(\"spread\"),\n@@ -309,1 +306,0 @@\n-        FIELD(\"field\"),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import jdk.internal.constant.ClassOrInterfaceDescImpl;\n+import jdk.internal.constant.ConstantUtils;\n@@ -31,1 +33,0 @@\n-import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -57,1 +58,0 @@\n-import java.util.Set;\n@@ -70,1 +70,0 @@\n-import static java.lang.invoke.MethodHandles.Lookup.ClassOption.NESTMATE;\n@@ -1041,1 +1040,1 @@\n-        private static final ClassDesc CD_Object_array = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\");\n+        private static final ClassDesc CD_Object_array = ConstantUtils.CD_Object_array;\n@@ -1270,1 +1269,1 @@\n-            return ClassFile.of().build(ReferenceClassDescImpl.ofValidated(\"LInjectedInvoker;\"), clb -> clb\n+            return ClassFile.of().build(ClassOrInterfaceDescImpl.ofValidated(\"LInjectedInvoker;\"), clb -> clb\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -466,1 +466,0 @@\n-     * @param target a direct method handle to crack into symbolic reference components\n@@ -468,0 +467,1 @@\n+     * @param target a direct method handle to crack into symbolic reference components\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.constant.ClassOrInterfaceDescImpl;\n@@ -33,1 +34,0 @@\n-import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -1091,4 +1091,4 @@\n-        static final ClassDesc CD_StringConcatHelper = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/StringConcatHelper;\");\n-        static final ClassDesc CD_StringConcatBase   = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/StringConcatHelper$StringConcatBase;\");\n-        static final ClassDesc CD_Array_byte         = ReferenceClassDescImpl.ofValidated(\"[B\");\n-        static final ClassDesc CD_Array_String       = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/String;\");\n+        static final ClassDesc CD_StringConcatHelper = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/StringConcatHelper;\");\n+        static final ClassDesc CD_StringConcatBase   = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/StringConcatHelper$StringConcatBase;\");\n+        static final ClassDesc CD_Array_byte         = CD_byte.arrayType();\n+        static final ClassDesc CD_Array_String       = CD_String.arrayType();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+\n+import jdk.internal.constant.ConstantUtils;\n@@ -34,1 +36,0 @@\n-import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -205,1 +206,1 @@\n-             : ReferenceClassDescImpl.ofValidated(cls.descriptorString());\n+             : ConstantUtils.referenceClassDesc(cls.descriptorString());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/TypeConvertingMethodAdapter.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2374,1 +2374,0 @@\n-         * @param name the unqualified name of the field\n@@ -2377,0 +2376,1 @@\n+         * @param name the unqualified name of the field\n@@ -2393,1 +2393,0 @@\n-         * @param name the unqualified name of the field\n@@ -2396,0 +2395,1 @@\n+         * @param name the unqualified name of the field\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -260,1 +260,1 @@\n- * incompatibly will result in a {@link\n+ * incompatibly will result in an {@link\n@@ -289,1 +289,0 @@\n-     * @since 1.5\n@@ -305,1 +304,0 @@\n-     * @since 1.5\n@@ -319,1 +317,0 @@\n-     * @since 1.5\n@@ -481,1 +478,0 @@\n-     * @since 1.5\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AnnotatedElement.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+\n+import jdk.internal.constant.ClassOrInterfaceDescImpl;\n@@ -44,1 +46,0 @@\n-import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -67,12 +68,12 @@\n-            CD_ClassLoader = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/ClassLoader;\"),\n-            CD_Class_array = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/Class;\"),\n-            CD_ClassNotFoundException = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/ClassNotFoundException;\"),\n-            CD_NoClassDefFoundError = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/NoClassDefFoundError;\"),\n-            CD_IllegalAccessException = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/IllegalAccessException;\"),\n-            CD_InvocationHandler = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/reflect\/InvocationHandler;\"),\n-            CD_Method = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/reflect\/Method;\"),\n-            CD_NoSuchMethodError = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/NoSuchMethodError;\"),\n-            CD_NoSuchMethodException = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/NoSuchMethodException;\"),\n-            CD_Object_array = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\"),\n-            CD_Proxy = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/reflect\/Proxy;\"),\n-            CD_UndeclaredThrowableException = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/reflect\/UndeclaredThrowableException;\");\n+            CD_ClassLoader = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/ClassLoader;\"),\n+            CD_Class_array = CD_Class.arrayType(),\n+            CD_ClassNotFoundException = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/ClassNotFoundException;\"),\n+            CD_NoClassDefFoundError = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/NoClassDefFoundError;\"),\n+            CD_IllegalAccessException = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/IllegalAccessException;\"),\n+            CD_InvocationHandler = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/reflect\/InvocationHandler;\"),\n+            CD_Method = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/reflect\/Method;\"),\n+            CD_NoSuchMethodError = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/NoSuchMethodError;\"),\n+            CD_NoSuchMethodException = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/NoSuchMethodException;\"),\n+            CD_Object_array = ConstantUtils.CD_Object_array,\n+            CD_Proxy = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/reflect\/Proxy;\"),\n+            CD_UndeclaredThrowableException = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/reflect\/UndeclaredThrowableException;\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import jdk.internal.constant.ClassOrInterfaceDescImpl;\n@@ -53,1 +54,0 @@\n-import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -85,2 +85,2 @@\n-    private static final ClassDesc CD_BiPredicate = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/function\/BiPredicate;\");\n-    private static final ClassDesc CD_Objects = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/Objects;\");\n+    private static final ClassDesc CD_BiPredicate = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/util\/function\/BiPredicate;\");\n+    private static final ClassDesc CD_Objects = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/util\/Objects;\");\n@@ -587,1 +587,1 @@\n-                            cb.invokestatic(referenceClassDesc(ExactConversionsSupport.class),\n+                            cb.invokestatic(ConstantUtils.referenceClassDesc(ExactConversionsSupport.class),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3112,7 +3112,3 @@\n-        if (intCompact == 0 || (intVal != null && intVal.signum() == 0)) {\n-            return BigDecimal.ZERO;\n-        } else if (intCompact != INFLATED) {\n-            return createAndStripZerosToMatchScale(intCompact, scale, Long.MIN_VALUE);\n-        } else {\n-            return createAndStripZerosToMatchScale(intVal, scale, Long.MIN_VALUE);\n-        }\n+        return intCompact == 0 || (intVal != null && intVal.signum() == 0)\n+                ? BigDecimal.ZERO\n+                : stripZerosToMatchScale(intVal, intCompact, scale, Long.MIN_VALUE);\n@@ -5222,0 +5218,26 @@\n+    \/**\n+     * {@code FIVE_TO_2_TO[n] == 5^(2^n)}\n+     *\/\n+    private static final BigInteger[] FIVE_TO_2_TO = new BigInteger[16 + 1];\n+\n+    static {\n+        BigInteger pow = FIVE_TO_2_TO[0] = BigInteger.valueOf(5L);\n+        for (int i = 1; i < FIVE_TO_2_TO.length; i++)\n+            FIVE_TO_2_TO[i] = pow = pow.multiply(pow);\n+    }\n+\n+    \/**\n+     * @param n a non-negative integer\n+     * @return {@code 5^(2^n)}\n+     *\/\n+    private static BigInteger fiveToTwoToThe(int n) {\n+        int i = Math.min(n, FIVE_TO_2_TO.length - 1);\n+        BigInteger pow = FIVE_TO_2_TO[i];\n+        for (; i < n; i++)\n+            pow = pow.multiply(pow);\n+\n+        return pow;\n+    }\n+\n+    private static final double LOG_5_OF_2 = 0.43067655807339306; \/\/ double closest to log5(2)\n+\n@@ -5227,0 +5249,1 @@\n+     * Assumes {@code intVal != 0}.\n@@ -5233,0 +5256,22 @@\n+        \/\/ avoid overflow of scale - preferredScale\n+        preferredScale = Math.clamp(preferredScale, Integer.MIN_VALUE - 1L, Integer.MAX_VALUE);\n+        int powsOf2 = intVal.getLowestSetBit();\n+        \/\/ scale - preferredScale >= remainingZeros >= max{n : (intVal % 10^n) == 0 && n <= scale - preferredScale}\n+        \/\/ a multiple of 10^n must be a multiple of 2^n\n+        long remainingZeros = Math.min(scale - preferredScale, powsOf2);\n+        if (remainingZeros <= 0L)\n+            return valueOf(intVal, scale, 0);\n+\n+        final int sign = intVal.signum;\n+        if (sign < 0)\n+            intVal = intVal.negate(); \/\/ speed up computation of shiftRight() and bitLength()\n+\n+        intVal = intVal.shiftRight(powsOf2); \/\/ remove powers of 2\n+        \/\/ Let k = max{n : (intVal % 5^n) == 0}, m = max{n : 5^n <= intVal}, so m >= k.\n+        \/\/ Let b = intVal.bitLength(). It can be shown that\n+        \/\/ | b * LOG_5_OF_2 - b log5(2) | < 2^(-21) (fp viz. real arithmetic),\n+        \/\/ which entails m <= maxPowsOf5 <= m + 1, where maxPowsOf5 is as below.\n+        \/\/ Hence, maxPowsOf5 >= k.\n+        long maxPowsOf5 = Math.round(intVal.bitLength() * LOG_5_OF_2);\n+        remainingZeros = Math.min(remainingZeros, maxPowsOf5);\n+\n@@ -5234,9 +5279,45 @@\n-        while (intVal.compareMagnitude(BigInteger.TEN) >= 0\n-               && scale > preferredScale) {\n-            if (intVal.testBit(0))\n-                break; \/\/ odd number cannot end in 0\n-            qr = intVal.divideAndRemainder(BigInteger.TEN);\n-            if (qr[1].signum() != 0)\n-                break; \/\/ non-0 remainder\n-            intVal = qr[0];\n-            scale = checkScale(intVal,(long) scale - 1); \/\/ could Overflow\n+        \/\/ Remove 5^(2^i) from the factors of intVal, until 5^remainingZeros < 5^(2^i).\n+        \/\/ Let z = max{n >= 0 : ((intVal * 2^powsOf2) % 10^n) == 0 && n <= scale - preferredScale},\n+        \/\/ then the condition min(scale - preferredScale, powsOf2) >= remainingZeros >= z\n+        \/\/ and the values ((intVal * 2^powsOf2) \/ 10^z) and (scale - z)\n+        \/\/ are preserved invariants after each iteration.\n+        \/\/ Note that if intVal % 5^(2^i) != 0, the loop condition will become false.\n+        for (int i = 0; remainingZeros >= 1L << i; i++) {\n+            final int exp = 1 << i;\n+            qr = intVal.divideAndRemainder(fiveToTwoToThe(i));\n+            if (qr[1].signum != 0) { \/\/ non-0 remainder\n+                remainingZeros = exp - 1;\n+            } else {\n+                intVal = qr[0];\n+                scale = checkScale(intVal, (long) scale - exp); \/\/ could Overflow\n+                remainingZeros -= exp;\n+                powsOf2 -= exp;\n+            }\n+        }\n+\n+        \/\/ bitLength(remainingZeros) == min{n >= 0 : 5^(2^n) > 5^remainingZeros}\n+        \/\/ so, while the loop condition is true,\n+        \/\/ the invariant i == max{n : 5^(2^n) <= 5^remainingZeros},\n+        \/\/ which is equivalent to i == bitLength(remainingZeros) - 1,\n+        \/\/ is preserved at the beginning of each iteration.\n+        \/\/ Note that the loop stops exactly when remainingZeros == 0.\n+        \/\/ Using the same definition of z for the first loop, the invariants\n+        \/\/ min(scale - preferredScale, powsOf2) >= remainingZeros >= z,\n+        \/\/ ((intVal * 2^powsOf2) \/ 10^z) and (scale - z)\n+        \/\/ are preserved in this loop as well, so, when the loop ends,\n+        \/\/ remainingZeros == 0 implies z == 0, hence (intVal * 2^powsOf2) and scale\n+        \/\/ have the correct values to return.\n+        for (int i = BigInteger.bitLengthForLong(remainingZeros) - 1; i >= 0; i--) {\n+            final int exp = 1 << i;\n+            qr = intVal.divideAndRemainder(fiveToTwoToThe(i));\n+            if (qr[1].signum != 0) { \/\/ non-0 remainder\n+                remainingZeros = exp - 1;\n+            } else {\n+                intVal = qr[0];\n+                scale = checkScale(intVal, (long) scale - exp); \/\/ could Overflow\n+                remainingZeros -= exp;\n+                powsOf2 -= exp;\n+\n+                if (remainingZeros < exp >> 1) \/\/ else i == bitLength(remainingZeros) already\n+                    i = BigInteger.bitLengthForLong(remainingZeros);\n+            }\n@@ -5244,1 +5325,3 @@\n-        return valueOf(intVal, scale, 0);\n+\n+        intVal = intVal.shiftLeft(powsOf2); \/\/ restore remaining powers of 2\n+        return valueOf(sign >= 0 ? intVal : intVal.negate(), scale, 0);\n@@ -5252,0 +5335,1 @@\n+     * Assumes {@code compactVal != 0 && compactVal != INFLATED}.\n@@ -5258,8 +5342,3 @@\n-        while (Math.abs(compactVal) >= 10L && scale > preferredScale) {\n-            if ((compactVal & 1L) != 0L)\n-                break; \/\/ odd number cannot end in 0\n-            long r = compactVal % 10L;\n-            if (r != 0L)\n-                break; \/\/ non-0 remainder\n-            compactVal \/= 10;\n-            scale = checkScale(compactVal, (long) scale - 1); \/\/ could Overflow\n+        while (compactVal % 10L == 0L && scale > preferredScale) {\n+            compactVal \/= 10L;\n+            scale = checkScale(compactVal, scale - 1L); \/\/ could Overflow\n@@ -5270,7 +5349,7 @@\n-    private static BigDecimal stripZerosToMatchScale(BigInteger intVal, long intCompact, int scale, int preferredScale) {\n-        if(intCompact!=INFLATED) {\n-            return createAndStripZerosToMatchScale(intCompact, scale, preferredScale);\n-        } else {\n-            return createAndStripZerosToMatchScale(intVal==null ? INFLATED_BIGINT : intVal,\n-                                                   scale, preferredScale);\n-        }\n+    \/**\n+     * Assumes {@code intVal != 0 && intCompact != 0}.\n+     *\/\n+    private static BigDecimal stripZerosToMatchScale(BigInteger intVal, long intCompact, int scale, long preferredScale) {\n+        return intCompact != INFLATED\n+            ? createAndStripZerosToMatchScale(intCompact, scale, preferredScale)\n+            : createAndStripZerosToMatchScale(intVal == null ? INFLATED_BIGINT : intVal, scale, preferredScale);\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":111,"deletions":32,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -2782,0 +2782,7 @@\n+    \/**\n+     * Package private method to return bit length for a long.\n+     *\/\n+    static int bitLengthForLong(long n) {\n+        return 64 - Long.numberOfLeadingZeros(n);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -89,3 +89,0 @@\n-     * @param extensions a map of X.509 Extensions. Each key is an OID String\n-     *    that maps to the corresponding Extension. The map is copied to\n-     *    prevent subsequent modification.\n@@ -95,0 +92,3 @@\n+     * @param extensions a map of X.509 Extensions. Each key is an OID String\n+     *    that maps to the corresponding Extension. The map is copied to\n+     *    prevent subsequent modification.\n","filename":"src\/java.base\/share\/classes\/java\/security\/cert\/CertificateRevokedException.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,3 +108,0 @@\n-     * @param random the random bit source to use to generate key bits;\n-     * can be null.\n-     *\n@@ -114,0 +111,3 @@\n+     * @param random the random bit source to use to generate key bits;\n+     * can be null.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/security\/interfaces\/DSAKeyPairGenerator.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -352,0 +352,1 @@\n+     * @throws NullPointerException if {@code infinity} is {@code null}\n@@ -354,0 +355,1 @@\n+        this.infinity = Objects.requireNonNull(infinity);\n@@ -355,1 +357,0 @@\n-        this.infinity = infinity;\n@@ -373,0 +374,1 @@\n+     * @throws NullPointerException if {@code NaN} is {@code null}\n@@ -375,0 +377,1 @@\n+        this.NaN = Objects.requireNonNull(NaN);\n@@ -376,1 +379,0 @@\n-        this.NaN = NaN;\n@@ -417,2 +419,4 @@\n-     * Sets the currency symbol for the currency of these\n-     * DecimalFormatSymbols in their locale.\n+     * Sets the currency symbol for the currency of this\n+     * {@code DecimalFormatSymbols} in their locale. Unlike {@link\n+     * #setInternationalCurrencySymbol(String)}, this method does not update\n+     * the currency attribute nor the international currency symbol attribute.\n@@ -421,0 +425,1 @@\n+     * @throws NullPointerException if {@code currency} is {@code null}\n@@ -425,0 +430,1 @@\n+        Objects.requireNonNull(currency);\n@@ -451,2 +457,1 @@\n-     * then the currency attribute is set to null and the currency symbol\n-     * attribute is not modified.\n+     * then the currency attribute and the currency symbol attribute are not modified.\n@@ -455,0 +460,1 @@\n+     * @throws NullPointerException if {@code currencyCode} is {@code null}\n@@ -459,2 +465,4 @@\n-    public void setInternationalCurrencySymbol(String currencyCode)\n-    {\n+    public void setInternationalCurrencySymbol(String currencyCode) {\n+        Objects.requireNonNull(currencyCode);\n+        \/\/ init over setting currencyInit flag as true so that currency has\n+        \/\/ fallback if code is not valid\n@@ -464,8 +472,4 @@\n-        currency = null;\n-        if (currencyCode != null) {\n-            try {\n-                currency = Currency.getInstance(currencyCode);\n-                currencySymbol = currency.getSymbol();\n-            } catch (IllegalArgumentException e) {\n-            }\n-        }\n+        try {\n+            currency = Currency.getInstance(currencyCode);\n+            currencySymbol = currency.getSymbol(locale);\n+        } catch (IllegalArgumentException _) {} \/\/ Simply ignore if not valid\n@@ -475,5 +479,1 @@\n-     * Gets the currency of these DecimalFormatSymbols. May be null if the\n-     * currency symbol attribute was previously set to a value that's not\n-     * a valid ISO 4217 currency code.\n-     *\n-     * @return the currency used, or null\n+     * {@return the {@code Currency} of this {@code DecimalFormatSymbols}}\n@@ -488,1 +488,1 @@\n-     * Sets the currency of these DecimalFormatSymbols.\n+     * Sets the currency of this {@code DecimalFormatSymbols}.\n@@ -500,3 +500,1 @@\n-        if (currency == null) {\n-            throw new NullPointerException();\n-        }\n+        Objects.requireNonNull(currency);\n@@ -558,3 +556,1 @@\n-        if (exp == null) {\n-            throw new NullPointerException();\n-        }\n+        Objects.requireNonNull(exp);\n@@ -770,1 +766,2 @@\n-            getCurrencySymbol().equals(other.getCurrencySymbol()) && \/\/ possible currency init occurs here\n+            \/\/ Currency fields are lazy. Init via get call to ensure non-null\n+            getCurrencySymbol().equals(other.getCurrencySymbol()) &&\n@@ -803,1 +800,2 @@\n-                getCurrencySymbol(), \/\/ possible currency init occurs here\n+                \/\/ Currency fields are lazy. Init via get call to ensure non-null\n+                getCurrencySymbol(),\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormatSymbols.java","additions":28,"deletions":30,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n- * The <i>ArgumentIndex<\/i> value is a non-negative integer written\n+ * The {@code ArgumentIndex} value is a non-negative integer written\n@@ -118,1 +118,4 @@\n- * The <i>FormatType<\/i> and <i>FormatStyle<\/i> values are used to create\n+ * Any constructor or method that takes a String pattern parameter will throw an {@code IllegalArgumentException} if the\n+ * pattern contains an {@code ArgumentIndex} value that is equal to or exceeds an implementation limit.\n+ * <p>\n+ * The {@code FormatType} and {@code FormatStyle} values are used to create\n@@ -124,0 +127,1 @@\n+ * @implNote In the reference implementation, the limit of {@code ArgumentIndex} is 10,000.\n@@ -2040,1 +2044,1 @@\n-            int lastOffset = patt.length() + 1;\n+            int lastOffset = patt.length();\n","filename":"src\/java.base\/share\/classes\/java\/text\/MessageFormat.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3494,1 +3494,0 @@\n-     * @param <U> the class of the objects in the original array\n@@ -3496,0 +3495,1 @@\n+     * @param <U> the class of the objects in the original array\n@@ -3785,1 +3785,0 @@\n-     * @param <U> the class of the objects in the original array\n@@ -3787,0 +3786,1 @@\n+     * @param <U> the class of the objects in the original array\n","filename":"src\/java.base\/share\/classes\/java\/util\/Arrays.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1129,22 +1129,5 @@\n-        String language, region, script, country, variant;\n-        language = StaticProperty.USER_LANGUAGE;\n-        \/\/ for compatibility, check for old user.region property\n-        region = StaticProperty.USER_REGION;\n-        if (!region.isEmpty()) {\n-            \/\/ region can be of form country, country_variant, or _variant\n-            int i = region.indexOf('_');\n-            if (i >= 0) {\n-                country = region.substring(0, i);\n-                variant = region.substring(i + 1);\n-            } else {\n-                country = region;\n-                variant = \"\";\n-            }\n-            script = \"\";\n-        } else {\n-            script = StaticProperty.USER_SCRIPT;\n-            country = StaticProperty.USER_COUNTRY;\n-            variant = StaticProperty.USER_VARIANT;\n-        }\n-\n-        return getInstance(language, script, country, variant,\n+        return getInstance(\n+                StaticProperty.USER_LANGUAGE,\n+                StaticProperty.USER_SCRIPT,\n+                StaticProperty.USER_COUNTRY,\n+                StaticProperty.USER_VARIANT,\n","filename":"src\/java.base\/share\/classes\/java\/util\/Locale.java","additions":5,"deletions":22,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -596,9 +596,0 @@\n-        \/\/ derive it ourselves\n-        if (ZoneInfoFile.useOldMapping() && id.length() == 3) {\n-            if (\"EST\".equals(id))\n-                return ZoneId.of(\"America\/New_York\");\n-            if (\"MST\".equals(id))\n-                return ZoneId.of(\"America\/Denver\");\n-            if (\"HST\".equals(id))\n-                return ZoneId.of(\"America\/Honolulu\");\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/TimeZone.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -44,1 +44,7 @@\n- * supported by the Java runtime environment itself.\n+ * supported by the Java runtime environment itself. Locale sensitive service\n+ * providers are deployed on the application module path or the application class\n+ * path. In order to be looked up, providers must be visible to the {@link\n+ * ClassLoader#getSystemClassLoader() system class loader}.\n+ * See {@link java.util.ServiceLoader##developing-service-providers Deploying\n+ * Service Providers} for further detail on deploying a locale sensitive service\n+ * provider as a module or on the class path.\n@@ -47,10 +53,21 @@\n- * Implementations of these locale sensitive services can be made available\n- * by adding them to the application's class path. A provider identifies itself with a\n- * provider-configuration file in the resource directory META-INF\/services,\n- * using the fully qualified provider interface class name as the file name.\n- * The file should contain a list of fully-qualified concrete provider class names,\n- * one per line. A line is terminated by any one of a line feed ('\\n'), a carriage\n- * return ('\\r'), or a carriage return followed immediately by a line feed. Space\n- * and tab characters surrounding each name, as well as blank lines, are ignored.\n- * The comment character is '#' ('\\u0023'); on each line all characters following\n- * the first comment character are ignored. The file must be encoded in UTF-8.\n+ *\n+ * <p> For a locale sensitive service provider deployed in a module, the <i>provides<\/i>\n+ * directive must be specified in the module declaration. The <i>provides<\/i>\n+ * directive specifies both the service and the service provider.\n+ *\n+ * <p> For example, an implementation of the {@link java.text.spi.DateFormatProvider\n+ * DateFormatProvider} class deployed as a module might specify the following directive:\n+ * <pre>{@code\n+ *     provides java.text.spi.DateFormatProvider with com.example.ExternalDateFormatProvider;\n+ * }<\/pre>\n+ *\n+ * <p> For a Locale Service Provider deployed on the class path, the provider\n+ * identifies itself with a provider-configuration file in the resource directory\n+ * META-INF\/services. The file name should be the fully fully qualified provider\n+ * interface class name. The file should contain a list of fully-qualified concrete\n+ * provider class names, one per line. A line is terminated by any one of a line\n+ * feed ('\\n'), a carriage return ('\\r'), or a carriage return followed immediately\n+ * by a line feed. Space and tab characters surrounding each name, as well as\n+ * blank lines, are ignored. The comment character is '#' ('\\u0023'); on each line\n+ * all characters following the first comment character are ignored. The file must\n+ * be encoded in UTF-8.\n@@ -91,2 +108,2 @@\n- * locale's extensions} are ignored by default. (If locale's extensions should\n- * also be checked, the {@code isSupportedLocale} method must be overridden.)\n+ * locale's extensions} are ignored by default. (If a locale's extensions should\n+ * also be checked, the {@code isSupportedLocale} method must be overridden).\n","filename":"src\/java.base\/share\/classes\/java\/util\/spi\/LocaleServiceProvider.java","additions":30,"deletions":13,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1091,1 +1091,0 @@\n-     * @param <A> the intermediate accumulation type of the downstream collector\n@@ -1093,0 +1092,1 @@\n+     * @param <A> the intermediate accumulation type of the downstream collector\n@@ -1095,1 +1095,0 @@\n-     * @param downstream a {@code Collector} implementing the downstream reduction\n@@ -1098,0 +1097,1 @@\n+     * @param downstream a {@code Collector} implementing the downstream reduction\n@@ -1253,1 +1253,0 @@\n-     * @param downstream a {@code Collector} implementing the downstream reduction\n@@ -1256,0 +1255,1 @@\n+     * @param downstream a {@code Collector} implementing the downstream reduction\n@@ -1350,1 +1350,0 @@\n-     * @param <A> the intermediate accumulation type of the downstream collector\n@@ -1352,0 +1351,1 @@\n+     * @param <A> the intermediate accumulation type of the downstream collector\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Collectors.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -94,1 +94,4 @@\n-\n+    \/\/ CEN header size + name length + comment length + extra length\n+    \/\/ should not exceed 65,535 bytes per the PKWare APP.NOTE\n+    \/\/ 4.4.10, 4.4.11, & 4.4.12.\n+    private static final int MAX_COMBINED_CEN_HEADER_SIZE = 0xFFFF;\n@@ -102,2 +105,2 @@\n-     * @throws IllegalArgumentException if the entry name is longer than\n-     *         0xFFFF bytes\n+     * @throws IllegalArgumentException if the combined length of the entry name\n+     * and the {@linkplain #CENHDR CEN Header size} exceeds 65,535 bytes.\n@@ -107,1 +110,1 @@\n-        if (name.length() > 0xFFFF) {\n+        if (!isCENHeaderValid(name, null, null)) {\n@@ -522,2 +525,4 @@\n-     * @throws IllegalArgumentException if the length of the specified\n-     *         extra field data is greater than 0xFFFF bytes\n+     * @throws IllegalArgumentException if the combined length of the specified\n+     * extra field data, the {@linkplain #getName() entry name},\n+     * the {@linkplain #getComment() entry comment}, and the\n+     * {@linkplain #CENHDR CEN Header size} exceeds 65,535 bytes.\n@@ -544,1 +549,1 @@\n-            if (extra.length > 0xFFFF) {\n+            if (!isCENHeaderValid(name, extra, comment)) {\n@@ -645,5 +650,0 @@\n-     *\n-     * <p>ZIP entry comments have maximum length of 0xffff. If the length of the\n-     * specified comment string is greater than 0xFFFF bytes after encoding, only\n-     * the first 0xFFFF bytes are output to the ZIP file entry.\n-     *\n@@ -651,1 +651,4 @@\n-     *\n+     * @throws IllegalArgumentException if the combined length\n+     * of the specified entry comment, the {@linkplain #getName() entry name},\n+     * the {@linkplain #getExtra() extra field data}, and the\n+     * {@linkplain #CENHDR CEN Header size} exceeds 65,535 bytes.\n@@ -655,0 +658,5 @@\n+        if (comment != null) {\n+            if (!isCENHeaderValid(name, extra, comment)) {\n+                throw new IllegalArgumentException(\"entry comment too long\");\n+            }\n+        }\n@@ -705,0 +713,18 @@\n+\n+    \/**\n+     * Initial validation that the CEN header size + name length + comment length\n+     * + extra length do not exceed 65,535 bytes per the PKWare APP.NOTE\n+     * 4.4.10, 4.4.11, & 4.4.12.   Prior to writing out the CEN Header,\n+     * ZipOutputStream::writeCEN will do an additional validation  of the combined\n+     * length of the fields after encoding the name and comment to a byte array.\n+     * @param name Zip entry name\n+     * @param extra Zip extra data\n+     * @param comment Zip entry comment\n+     * @return true if valid CEN Header size; false otherwise\n+     *\/\n+     static boolean isCENHeaderValid(String name, byte[] extra, String comment) {\n+        int clen = comment == null ? 0 : comment.length();\n+        int elen = extra == null ? 0 : extra.length;\n+        long headerSize = (long)CENHDR + name.length() + clen + elen;\n+        return headerSize <= MAX_COMBINED_CEN_HEADER_SIZE;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipEntry.java","additions":39,"deletions":13,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import static java.util.zip.ZipEntry.isCENHeaderValid;\n@@ -265,0 +266,6 @@\n+        \/\/ CEN header size + name length + comment length + extra length\n+        \/\/ should not exceed 65,535 bytes per the PKWare APP.NOTE\n+        \/\/ 4.4.10, 4.4.11, & 4.4.12.\n+        if (!isCENHeaderValid(e.name, e.extra, e.comment) ) {\n+            throw new ZipException(\"invalid CEN header (bad header size)\");\n+        }\n@@ -605,0 +612,16 @@\n+\n+        int clen = 0;\n+        byte[] commentBytes = null;\n+        if (e.comment != null) {\n+            commentBytes = zc.getBytes(e.comment);\n+            clen = commentBytes.length;\n+        }\n+\n+        \/\/ CEN header size + name length + comment length + extra length\n+        \/\/ should not exceed 65,535 bytes per the PKWare APP.NOTE\n+        \/\/ 4.4.10, 4.4.11, & 4.4.12.\n+        long headerSize = (long)CENHDR + nlen + clen + elen;\n+        if (headerSize > 0xFFFF ) {\n+            throw new ZipException(\"invalid CEN header (bad header size)\");\n+        }\n+\n@@ -636,6 +659,0 @@\n-        byte[] commentBytes = null;\n-        int clen = 0;\n-        if (e.comment != null) {\n-            commentBytes = zc.getBytes(e.comment);\n-            clen = Math.min(commentBytes.length, 0xffff);\n-        }\n@@ -689,7 +706,0 @@\n-        \/\/ CEN header size + name length + comment length + extra length\n-        \/\/ should not exceed 65,535 bytes per the PKWare APP.NOTE\n-        \/\/ 4.4.10, 4.4.11, & 4.4.12.\n-        long headerSize = (long)CENHDR + nlen + clen + elen;\n-        if (headerSize > 0xFFFF ) {\n-            throw new ZipException(\"invalid CEN header (bad header size)\");\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipOutputStream.java","additions":23,"deletions":13,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -385,32 +385,0 @@\n-        \/**\n-         * Returns if this utf8 entry's content equals a substring\n-         * of {@code s} obtained as {@code s.substring(start, end - start)}.\n-         * This check avoids a substring allocation.\n-         *\/\n-        public boolean equalsRegion(String s, int start, int end) {\n-            \/\/ start and end values trusted\n-            if (state == State.RAW)\n-                inflate();\n-            int len = charLen;\n-            if (len != end - start)\n-                return false;\n-\n-            var sv = stringValue;\n-            if (sv != null) {\n-                return sv.regionMatches(0, s, start, len);\n-            }\n-\n-            var chars = this.chars;\n-            if (chars != null) {\n-                for (int i = 0; i < len; i++)\n-                    if (chars[i] != s.charAt(start + i))\n-                        return false;\n-            } else {\n-                var bytes = this.rawBytes;\n-                for (int i = 0; i < len; i++)\n-                    if (bytes[offset + i] != s.charAt(start + i))\n-                        return false;\n-            }\n-            return true;\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -37,2 +37,0 @@\n-import jdk.internal.constant.ConstantUtils;\n-\n@@ -397,18 +395,0 @@\n-    private AbstractPoolEntry.Utf8EntryImpl tryFindUtf8OfRegion(int hash, String target, int start, int end) {\n-        EntryMap map = map();\n-        while (true) {\n-            for (int token = map.firstToken(hash); token != -1; token = map.nextToken(hash, token)) {\n-                PoolEntry e = entryByIndex(map.getIndexByToken(token));\n-                if (e.tag() == TAG_UTF8\n-                        && e instanceof AbstractPoolEntry.Utf8EntryImpl ce\n-                        && ce.equalsRegion(target, start, end))\n-                    return ce;\n-            }\n-            if (!doneFullScan) {\n-                fullScan();\n-                continue;\n-            }\n-            return null;\n-        }\n-    }\n-\n@@ -432,2 +412,1 @@\n-                    var desc = cd.descriptorString();\n-                    if (ce.ref1.equalsRegion(desc, 1, desc.length() - 1)) {\n+                    if (ce.ref1.equalsString(Util.toInternalName(cd))) {\n@@ -457,2 +436,3 @@\n-        var utfHash = Util.internalNameHash(desc);\n-        var utf = tryFindUtf8OfRegion(AbstractPoolEntry.hashString(utfHash), desc, 1, desc.length() - 1);\n+        String internalName = Util.toInternalName(cd);\n+        var utfHash = internalName.hashCode();\n+        var utf = tryFindUtf8(AbstractPoolEntry.hashString(utfHash), internalName);\n@@ -460,1 +440,1 @@\n-            utf = internalAdd(new AbstractPoolEntry.Utf8EntryImpl(this, size, ConstantUtils.dropFirstAndLastChar(desc), utfHash));\n+            utf = internalAdd(new AbstractPoolEntry.Utf8EntryImpl(this, size, internalName, utfHash));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":5,"deletions":25,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -46,2 +46,1 @@\n-import jdk.internal.constant.PrimitiveClassDescImpl;\n-import jdk.internal.constant.ReferenceClassDescImpl;\n+import jdk.internal.constant.ClassOrInterfaceDescImpl;\n@@ -50,1 +49,1 @@\n-import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import static java.lang.classfile.ClassFile.*;\n@@ -1062,1 +1061,1 @@\n-                    desc instanceof PrimitiveClassDescImpl\n+                    desc.isPrimitive()\n@@ -1072,1 +1071,1 @@\n-                    desc instanceof PrimitiveClassDescImpl\n+                    desc.isPrimitive()\n@@ -1277,1 +1276,1 @@\n-                    if (desc instanceof ReferenceClassDescImpl) {\n+                    if (!desc.isPrimitive()) {\n@@ -1462,8 +1461,8 @@\n-            INT_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[I\")),\n-            BOOLEAN_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[Z\")),\n-            BYTE_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[B\")),\n-            CHAR_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[C\")),\n-            SHORT_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[S\")),\n-            LONG_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[J\")),\n-            DOUBLE_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[D\")),\n-            FLOAT_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[F\")),\n+            INT_ARRAY_TYPE = referenceType(CD_int.arrayType()),\n+            BOOLEAN_ARRAY_TYPE = referenceType(CD_boolean.arrayType()),\n+            BYTE_ARRAY_TYPE = referenceType(CD_byte.arrayType()),\n+            CHAR_ARRAY_TYPE = referenceType(CD_char.arrayType()),\n+            SHORT_ARRAY_TYPE = referenceType(CD_short.arrayType()),\n+            LONG_ARRAY_TYPE = referenceType(CD_long.arrayType()),\n+            DOUBLE_ARRAY_TYPE = referenceType(CD_double.arrayType()),\n+            FLOAT_ARRAY_TYPE = referenceType(CD_float.arrayType()),\n@@ -1534,2 +1533,2 @@\n-        private static final ClassDesc CD_Cloneable = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Cloneable;\");\n-        private static final ClassDesc CD_Serializable = ReferenceClassDescImpl.ofValidated(\"Ljava\/io\/Serializable;\");\n+        private static final ClassDesc CD_Cloneable = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/Cloneable;\");\n+        private static final ClassDesc CD_Serializable = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/io\/Serializable;\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":15,"deletions":16,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import jdk.internal.constant.ClassOrInterfaceDescImpl;\n@@ -136,4 +137,4 @@\n-        var desc = cd.descriptorString();\n-        if (desc.charAt(0) == 'L')\n-            return desc.substring(1, desc.length() - 1);\n-        throw new IllegalArgumentException(desc);\n+        if (cd instanceof ClassOrInterfaceDescImpl coi) {\n+            return coi.internalName();\n+        }\n+        throw new IllegalArgumentException(cd.descriptorString());\n@@ -324,9 +325,0 @@\n-    \/**\n-     * Returns the hash code of an internal name given the class or interface L descriptor.\n-     *\/\n-    public static int internalNameHash(String desc) {\n-        if (desc.length() > 0xffff)\n-            throw new IllegalArgumentException(\"String too long: \".concat(Integer.toString(desc.length())));\n-        return (desc.hashCode() - pow31(desc.length() - 1) * 'L' - ';') * INVERSE_31;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.constant;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.invoke.MethodHandles;\n+\n+import jdk.internal.vm.annotation.Stable;\n+import sun.invoke.util.Wrapper;\n+\n+import static java.lang.constant.ConstantDescs.CD_void;\n+import static jdk.internal.constant.ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS;\n+\n+\/**\n+ * An array class descriptor.\n+ * Restrictions: <ul>\n+ * <li>{@code rank} must be in {@code [1, 255]}\n+ * <li>{@code element} must not be void or array\n+ * <\/ul>\n+ *\/\n+public final class ArrayClassDescImpl implements ClassDesc {\n+    private final ClassDesc elementType;\n+    private final int rank;\n+    private @Stable String cachedDescriptorString;\n+\n+    public static ArrayClassDescImpl ofValidatedDescriptor(String desc) {\n+        assert desc.charAt(0) == '[';\n+        var lastChar = desc.charAt(desc.length() - 1);\n+        ArrayClassDescImpl ret;\n+        if (lastChar != ';') {\n+            \/\/ Primitive element arrays\n+            ret = ofValidated(Wrapper.forBasicType(lastChar).basicClassDescriptor(), desc.length() - 1);\n+        } else {\n+            int level = ConstantUtils.arrayDepth(desc, 0);\n+            ret = ofValidated(ClassOrInterfaceDescImpl.ofValidated(desc.substring(level)), level);\n+        }\n+        ret.cachedDescriptorString = desc;\n+        return ret;\n+    }\n+\n+    public static ArrayClassDescImpl ofValidated(ClassDesc elementType, int rank) {\n+        assert !elementType.isArray() && elementType != CD_void;\n+        assert rank > 0 && rank <= MAX_ARRAY_TYPE_DESC_DIMENSIONS;\n+\n+        return new ArrayClassDescImpl(elementType, rank);\n+    }\n+\n+    private ArrayClassDescImpl(ClassDesc elementType, int rank) {\n+        this.elementType = elementType;\n+        this.rank = rank;\n+    }\n+\n+    @Override\n+    public ClassDesc arrayType() {\n+        int rank = this.rank + 1;\n+        if (rank > MAX_ARRAY_TYPE_DESC_DIMENSIONS)\n+            throw new IllegalStateException(ConstantUtils.invalidArrayRankMessage(rank));\n+        return new ArrayClassDescImpl(elementType, rank);\n+    }\n+\n+    @Override\n+    public ClassDesc arrayType(int rank) {\n+        if (rank <= 0) {\n+            throw new IllegalArgumentException(\"rank \" + rank + \" is not a positive value\");\n+        }\n+        rank += this.rank;\n+        ConstantUtils.validateArrayRank(rank);\n+        return new ArrayClassDescImpl(elementType, rank);\n+    }\n+\n+    @Override\n+    public boolean isArray() {\n+        return true;\n+    }\n+\n+    @Override\n+    public ClassDesc componentType() {\n+        return rank == 1 ? elementType : new ArrayClassDescImpl(elementType, rank - 1);\n+    }\n+\n+    @Override\n+    public String displayName() {\n+        return elementType.displayName() + \"[]\".repeat(rank);\n+    }\n+\n+    @Override\n+    public String descriptorString() {\n+        var desc = cachedDescriptorString;\n+        if (desc != null)\n+            return desc;\n+\n+        return cachedDescriptorString = computeDescriptor();\n+    }\n+\n+    private String computeDescriptor() {\n+        var componentDesc = elementType.descriptorString();\n+        StringBuilder sb = new StringBuilder(rank + componentDesc.length());\n+        sb.repeat('[', rank);\n+        sb.append(componentDesc);\n+        return sb.toString();\n+    }\n+\n+    @Override\n+    public Class<?> resolveConstantDesc(MethodHandles.Lookup lookup) throws ReflectiveOperationException {\n+        if (elementType.isPrimitive()) {\n+            return lookup.findClass(descriptorString());\n+        }\n+        \/\/ Class.forName is slow on class or interface arrays\n+        Class<?> clazz = elementType.resolveConstantDesc(lookup);\n+        for (int i = 0; i < rank; i++)\n+            clazz = clazz.arrayType();\n+        return clazz;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o instanceof ArrayClassDescImpl constant) {\n+            return elementType.equals(constant.elementType) && rank == constant.rank;\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return descriptorString().hashCode();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"ArrayClassDesc[%s, %d]\", elementType.displayName(), rank);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ArrayClassDescImpl.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.constant;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.invoke.MethodHandles;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+import static jdk.internal.constant.ConstantUtils.*;\n+\n+\/**\n+ * A class or interface descriptor.\n+ * Restrictions:\n+ * <ul>\n+ * <li>Starts with 'L'\n+ * <li>Ends with ';'\n+ * <li>No '.' or '[' or ';' in the middle\n+ * <li>No leading\/trailing\/consecutive '\/'\n+ * <\/ul>\n+ *\/\n+public final class ClassOrInterfaceDescImpl implements ClassDesc {\n+    private final String descriptor;\n+    private @Stable String internalName;\n+\n+    \/**\n+     * Creates a {@linkplain ClassOrInterfaceDescImpl} from a pre-validated descriptor string\n+     * for a class or interface.\n+     *\/\n+    public static ClassOrInterfaceDescImpl ofValidated(String descriptor) {\n+        assert ConstantUtils.skipOverFieldSignature(descriptor, 0, descriptor.length())\n+                == descriptor.length() : descriptor;\n+        assert descriptor.charAt(0) == 'L';\n+        return new ClassOrInterfaceDescImpl(descriptor);\n+    }\n+\n+    ClassOrInterfaceDescImpl(String descriptor) {\n+        this.descriptor = descriptor;\n+    }\n+\n+    public String internalName() {\n+        var internalName = this.internalName;\n+        if (internalName == null) {\n+            this.internalName = internalName = dropFirstAndLastChar(descriptor);\n+        }\n+        return internalName;\n+    }\n+\n+    @Override\n+    public ClassDesc arrayType(int rank) {\n+        ConstantUtils.validateArrayRank(rank);\n+        return ArrayClassDescImpl.ofValidated(this, rank);\n+    }\n+\n+    @Override\n+    public ClassDesc arrayType() {\n+        return ArrayClassDescImpl.ofValidated(this, 1);\n+    }\n+\n+    @Override\n+    public ClassDesc nested(String nestedName) {\n+        validateMemberName(nestedName, false);\n+        String desc = descriptorString();\n+        StringBuilder sb = new StringBuilder(desc.length() + nestedName.length() + 1);\n+        sb.append(desc, 0, desc.length() - 1).append('$').append(nestedName).append(';');\n+        return ofValidated(sb.toString());\n+    }\n+\n+    @Override\n+    public ClassDesc nested(String firstNestedName, String... moreNestedNames) {\n+        validateMemberName(firstNestedName, false);\n+        \/\/ implicit null-check\n+        for (String addNestedNames : moreNestedNames) {\n+            validateMemberName(addNestedNames, false);\n+        }\n+        return moreNestedNames.length == 0\n+                ? nested(firstNestedName)\n+                : nested(firstNestedName + \"$\" + String.join(\"$\", moreNestedNames));\n+\n+    }\n+\n+    @Override\n+    public boolean isClassOrInterface() {\n+        return true;\n+    }\n+\n+    @Override\n+    public String packageName() {\n+        String desc = descriptorString();\n+        int index = desc.lastIndexOf('\/');\n+        return (index == -1) ? \"\" : internalToBinary(desc.substring(1, index));\n+    }\n+\n+    @Override\n+    public String displayName() {\n+        String desc = descriptorString();\n+        return desc.substring(Math.max(1, desc.lastIndexOf('\/') + 1), desc.length() - 1);\n+    }\n+\n+    @Override\n+    public String descriptorString() {\n+        return descriptor;\n+    }\n+\n+    @Override\n+    public Class<?> resolveConstantDesc(MethodHandles.Lookup lookup)\n+            throws ReflectiveOperationException {\n+        return lookup.findClass(internalToBinary(internalName()));\n+    }\n+\n+    \/**\n+     * Returns {@code true} if this {@linkplain ClassOrInterfaceDescImpl} is\n+     * equal to another {@linkplain ClassOrInterfaceDescImpl}.  Equality is\n+     * determined by the two class descriptors having equal class descriptor\n+     * strings.\n+     *\n+     * @param o the {@code ClassDesc} to compare to this\n+     *       {@code ClassDesc}\n+     * @return {@code true} if the specified {@code ClassDesc}\n+     *      is equal to this {@code ClassDesc}.\n+     *\/\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o instanceof ClassOrInterfaceDescImpl constant) {\n+            return descriptor.equals(constant.descriptor);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return descriptor.hashCode();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"ClassOrInterfaceDesc[%s]\", displayName());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ClassOrInterfaceDescImpl.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -34,2 +35,0 @@\n-import java.util.ArrayList;\n-import java.util.List;\n@@ -53,0 +52,1 @@\n+    public static @Stable ClassDesc CD_Object_array; \/\/ set from ConstantDescs, avoid circular initialization\n@@ -73,1 +73,12 @@\n-        return ReferenceClassDescImpl.ofValidated(concat(\"L\", binaryToInternal(binaryName), \";\"));\n+        return internalNameToDesc(binaryToInternal(binaryName));\n+    }\n+\n+    \/**\n+     * Creates a {@linkplain ClassDesc} from a pre-validated internal name\n+     * for a class or interface type. Validated version of {@link\n+     * ClassDesc#ofInternalName(String)}.\n+     *\n+     * @param internalName a binary name\n+     *\/\n+    public static ClassDesc internalNameToDesc(String internalName) {\n+        return ClassOrInterfaceDescImpl.ofValidated(concat(\"L\", internalName, \";\"));\n@@ -94,1 +105,15 @@\n-        return ReferenceClassDescImpl.ofValidated(type.descriptorString());\n+        return referenceClassDesc(type.descriptorString());\n+    }\n+\n+    \/**\n+     * Creates a {@linkplain ClassDesc} from a pre-validated descriptor string\n+     * for a class or interface type or an array type.\n+     *\n+     * @param descriptor a field descriptor string for a class or interface type\n+     * @jvms 4.3.2 Field Descriptors\n+     *\/\n+    public static ClassDesc referenceClassDesc(String descriptor) {\n+        if (descriptor.charAt(0) == '[') {\n+            return ArrayClassDescImpl.ofValidatedDescriptor(descriptor);\n+        }\n+        return ClassOrInterfaceDescImpl.ofValidated(descriptor);\n@@ -131,0 +156,20 @@\n+    \/**\n+     * Creates a {@linkplain ClassDesc} from a descriptor string for a class or\n+     * interface type or an array type.\n+     *\n+     * @param descriptor a field descriptor string for a class or interface type\n+     * @throws IllegalArgumentException if the descriptor string is not a valid\n+     * field descriptor string, or does not describe a class or interface type\n+     * @jvms 4.3.2 Field Descriptors\n+     *\/\n+    public static ClassDesc parseReferenceTypeDesc(String descriptor) {\n+        int dLen = descriptor.length();\n+        int len = ConstantUtils.skipOverFieldSignature(descriptor, 0, dLen);\n+        if (len <= 1 || len != dLen)\n+            throw new IllegalArgumentException(String.format(\"not a valid reference type descriptor: %s\", descriptor));\n+        if (descriptor.charAt(0) == '[') {\n+            return ArrayClassDescImpl.ofValidatedDescriptor(descriptor);\n+        }\n+        return ClassOrInterfaceDescImpl.ofValidated(descriptor);\n+    }\n+\n@@ -143,2 +188,3 @@\n-            if (ch == ';' || ch == '[' || ch == '\/')\n-                throw new IllegalArgumentException(\"Invalid class name: \" + name);\n+            if (ch == ';' || ch == '[' || ch == '\/'\n+                    || ch == '.' && (i == 0 || i + 1 == name.length() || name.charAt(i - 1) == '.'))\n+                throw invalidClassName(name);\n@@ -161,2 +207,3 @@\n-            if (ch == ';' || ch == '[' || ch == '.')\n-                throw new IllegalArgumentException(\"Invalid class name: \" + name);\n+            if (ch == ';' || ch == '[' || ch == '.'\n+                    || ch == '\/' && (i == 0 || i + 1 == name.length() || name.charAt(i - 1) == '\/'))\n+                throw invalidClassName(name);\n@@ -259,1 +306,13 @@\n-    public static int arrayDepth(String descriptorString) {\n+    public static void validateArrayRank(int rank) {\n+        \/\/ array rank must be representable with u1 and nonzero\n+        if (rank == 0 || (rank & ~0xFF) != 0) {\n+            throw new IllegalArgumentException(invalidArrayRankMessage(rank));\n+        }\n+    }\n+\n+    \/**\n+     * Retrieves the array depth on a trusted descriptor.\n+     * Uses a simple loop with the assumption that most descriptors have\n+     * 0 or very low array depths.\n+     *\/\n+    public static int arrayDepth(String descriptorString, int off) {\n@@ -261,1 +320,1 @@\n-        while (descriptorString.charAt(depth) == '[')\n+        while (descriptorString.charAt(off) == '[') {\n@@ -263,0 +322,2 @@\n+            off++;\n+        }\n@@ -299,1 +360,16 @@\n-        return ReferenceClassDescImpl.ofValidated(descriptor.substring(start, start + len));\n+        int arrayDepth = arrayDepth(descriptor, start);\n+        if (arrayDepth == 0) {\n+            return ClassOrInterfaceDescImpl.ofValidated(descriptor.substring(start, start + len));\n+        } else if (arrayDepth + 1 == len) {\n+            return ArrayClassDescImpl.ofValidated(forPrimitiveType(descriptor, start + arrayDepth), arrayDepth);\n+        } else {\n+            return ArrayClassDescImpl.ofValidated(ClassOrInterfaceDescImpl.ofValidated(descriptor.substring(start + arrayDepth, start + len)), arrayDepth);\n+        }\n+    }\n+\n+    static String invalidArrayRankMessage(int rank) {\n+        return \"Array rank must be within [1, 255]: \" + rank;\n+    }\n+\n+    static IllegalArgumentException invalidClassName(String className) {\n+        return new IllegalArgumentException(\"Invalid class name: \".concat(className));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ConstantUtils.java","additions":87,"deletions":11,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import static java.lang.constant.ConstantDescs.CD_void;\n@@ -48,1 +49,0 @@\n-import static jdk.internal.constant.PrimitiveClassDescImpl.CD_void;\n@@ -89,1 +89,1 @@\n-        if (arg.descriptorString().charAt(0) == 'V') \/\/ implicit null check\n+        if (requireNonNull(arg) == CD_void)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/MethodTypeDescImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -96,0 +96,25 @@\n+    @Override\n+    public boolean isPrimitive() {\n+        return true;\n+    }\n+\n+    @Override\n+    public ClassDesc arrayType(int rank) {\n+        ConstantUtils.validateArrayRank(rank);\n+        if (this == CD_void)\n+            throw new IllegalArgumentException(\"not a valid reference type descriptor: \" + \"[\".repeat(rank) + \"V\");\n+        return ArrayClassDescImpl.ofValidated(this, rank);\n+    }\n+\n+    @Override\n+    public ClassDesc arrayType() {\n+        if (this == CD_void)\n+            throw new IllegalArgumentException(\"not a valid reference type descriptor: [V\");\n+        return ArrayClassDescImpl.ofValidated(this, 1);\n+    }\n+\n+    @Override\n+    public String displayName() {\n+        return wrapper().primitiveSimpleName();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/PrimitiveClassDescImpl.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1,135 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.constant;\n-\n-import java.lang.constant.ClassDesc;\n-import java.lang.invoke.MethodHandles;\n-\n-import static jdk.internal.constant.ConstantUtils.*;\n-\n-\/**\n- * A <a href=\"package-summary.html#nominal\">nominal descriptor<\/a> for a class,\n- * interface, or array type.  A {@linkplain ReferenceClassDescImpl} corresponds to a\n- * {@code Constant_Class_info} entry in the constant pool of a classfile.\n- *\/\n-public final class ReferenceClassDescImpl implements ClassDesc {\n-    private final String descriptor;\n-\n-    private ReferenceClassDescImpl(String descriptor) {\n-        this.descriptor = descriptor;\n-    }\n-\n-    \/**\n-     * Creates a {@linkplain ClassDesc} from a descriptor string for a class or\n-     * interface type or an array type.\n-     *\n-     * @param descriptor a field descriptor string for a class or interface type\n-     * @throws IllegalArgumentException if the descriptor string is not a valid\n-     * field descriptor string, or does not describe a class or interface type\n-     * @jvms 4.3.2 Field Descriptors\n-     *\/\n-    public static ReferenceClassDescImpl of(String descriptor) {\n-        int dLen = descriptor.length();\n-        int len = ConstantUtils.skipOverFieldSignature(descriptor, 0, dLen);\n-        if (len <= 1 || len != dLen)\n-            throw new IllegalArgumentException(String.format(\"not a valid reference type descriptor: %s\", descriptor));\n-        return new ReferenceClassDescImpl(descriptor);\n-    }\n-\n-    \/**\n-     * Creates a {@linkplain ClassDesc} from a pre-validated descriptor string\n-     * for a class or interface type or an array type.\n-     *\n-     * @param descriptor a field descriptor string for a class or interface type\n-     * @jvms 4.3.2 Field Descriptors\n-     *\/\n-    public static ReferenceClassDescImpl ofValidated(String descriptor) {\n-        assert ConstantUtils.skipOverFieldSignature(descriptor, 0, descriptor.length())\n-                == descriptor.length() : descriptor;\n-        return new ReferenceClassDescImpl(descriptor);\n-    }\n-\n-    @Override\n-    public String descriptorString() {\n-        return descriptor;\n-    }\n-\n-    @Override\n-    public Class<?> resolveConstantDesc(MethodHandles.Lookup lookup)\n-            throws ReflectiveOperationException {\n-        if (isArray()) {\n-            if (isPrimitiveArray()) {\n-                return lookup.findClass(descriptor);\n-            }\n-            \/\/ Class.forName is slow on class or interface arrays\n-            int depth = ConstantUtils.arrayDepth(descriptor);\n-            Class<?> clazz = lookup.findClass(internalToBinary(descriptor.substring(depth + 1, descriptor.length() - 1)));\n-            for (int i = 0; i < depth; i++)\n-                clazz = clazz.arrayType();\n-            return clazz;\n-        }\n-        return lookup.findClass(internalToBinary(dropFirstAndLastChar(descriptor)));\n-    }\n-\n-    \/**\n-     * Whether the descriptor is one of a primitive array, given this is\n-     * already a valid reference type descriptor.\n-     *\/\n-    private boolean isPrimitiveArray() {\n-        \/\/ All L-type descriptors must end with a semicolon; same for reference\n-        \/\/ arrays, leaving primitive arrays the only ones without a final semicolon\n-        return descriptor.charAt(descriptor.length() - 1) != ';';\n-    }\n-\n-    \/**\n-     * Returns {@code true} if this {@linkplain ReferenceClassDescImpl} is\n-     * equal to another {@linkplain ReferenceClassDescImpl}.  Equality is\n-     * determined by the two class descriptors having equal class descriptor\n-     * strings.\n-     *\n-     * @param o the {@code ClassDesc} to compare to this\n-     *       {@code ClassDesc}\n-     * @return {@code true} if the specified {@code ClassDesc}\n-     *      is equal to this {@code ClassDesc}.\n-     *\/\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) return true;\n-        if (o instanceof ReferenceClassDescImpl constant) {\n-            return descriptor.equals(constant.descriptor);\n-        }\n-        return false;\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return descriptor.hashCode();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"ClassDesc[%s]\", displayName());\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ReferenceClassDescImpl.java","additions":0,"deletions":135,"binary":false,"changes":135,"status":"deleted"},{"patch":"@@ -67,5 +67,4 @@\n-        \/\/ not used, but required for interim javac to not warn.\n-        VIRTUAL_THREADS,\n-        FOREIGN,\n-        @JEP(number=459, title=\"String Templates\", status=\"Second Preview\")\n-        STRING_TEMPLATES,\n+        \/\/ while building the interim javac, the ClassReader will produce a warning when loading a class\n+        \/\/ keeping the constant of a feature that has been integrated or dropped, serves the purpose of muting such warnings.\n+\n+        \/\/---\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -54,2 +54,2 @@\n-        private static final String PLATFORM_LOADER_INDEX = \"PLATFORM\";\n-        private static final String APP_LOADER_INDEX      = \"APP\";\n+        private static final String PLATFORM_LOADER_NAME = \"PLATFORM\";\n+        private static final String APP_LOADER_NAME      = \"APP\";\n@@ -58,1 +58,1 @@\n-         * Map from module to a class loader index. The index is resolved to the\n+         * Map from module to a class loader name. The name is resolved to the\n@@ -68,2 +68,1 @@\n-         * index value in the internal map. The index is stored as a boxed value\n-         * so that we can cheaply do identity comparisons during bootstrap.\n+         * loader name in the internal map.\n@@ -77,1 +76,1 @@\n-                        map.put(mn, PLATFORM_LOADER_INDEX);\n+                        map.put(mn, PLATFORM_LOADER_NAME);\n@@ -79,1 +78,1 @@\n-                        map.put(mn, APP_LOADER_INDEX);\n+                        map.put(mn, APP_LOADER_NAME);\n@@ -89,1 +88,1 @@\n-            if (loader == APP_LOADER_INDEX) {\n+            if (APP_LOADER_NAME.equals(loader)) {\n@@ -91,1 +90,1 @@\n-            } else if (loader == PLATFORM_LOADER_INDEX) {\n+            } else if (PLATFORM_LOADER_NAME.equals(loader)) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleLoaderMap.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1,722 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-import java.lang.reflect.*;\n-import jdk.internal.misc.Unsafe;\n-\n-\/** Shared functionality for all accessor generators *\/\n-\n-class AccessorGenerator implements ClassFileConstants {\n-    static final Unsafe unsafe = Unsafe.getUnsafe();\n-\n-    \/\/ Constants because there's no way to say \"short integer constant\",\n-    \/\/ i.e., \"1S\"\n-    protected static final short S0 = (short) 0;\n-    protected static final short S1 = (short) 1;\n-    protected static final short S2 = (short) 2;\n-    protected static final short S3 = (short) 3;\n-    protected static final short S4 = (short) 4;\n-    protected static final short S5 = (short) 5;\n-    protected static final short S6 = (short) 6;\n-\n-    \/\/ Instance variables for shared functionality\n-    protected ClassFileAssembler asm;\n-    protected int   modifiers;\n-    protected short thisClass;\n-    protected short superClass;\n-    protected short targetClass;\n-    \/\/ Common constant pool entries to FieldAccessor and MethodAccessor\n-    protected short throwableClass;\n-    protected short classCastClass;\n-    protected short nullPointerClass;\n-    protected short illegalArgumentClass;\n-    protected short invocationTargetClass;\n-    protected short initIdx;\n-    protected short initNameAndTypeIdx;\n-    protected short initStringNameAndTypeIdx;\n-    protected short nullPointerCtorIdx;\n-    protected short illegalArgumentCtorIdx;\n-    protected short illegalArgumentStringCtorIdx;\n-    protected short invocationTargetCtorIdx;\n-    protected short superCtorIdx;\n-    protected short objectClass;\n-    protected short toStringIdx;\n-    protected short codeIdx;\n-    protected short exceptionsIdx;\n-    \/\/ Boxing\n-    protected short valueOfIdx;\n-    protected short booleanIdx;\n-    protected short booleanBoxIdx;\n-    protected short booleanUnboxIdx;\n-    protected short byteIdx;\n-    protected short byteBoxIdx;\n-    protected short byteUnboxIdx;\n-    protected short characterIdx;\n-    protected short characterBoxIdx;\n-    protected short characterUnboxIdx;\n-    protected short doubleIdx;\n-    protected short doubleBoxIdx;\n-    protected short doubleUnboxIdx;\n-    protected short floatIdx;\n-    protected short floatBoxIdx;\n-    protected short floatUnboxIdx;\n-    protected short integerIdx;\n-    protected short integerBoxIdx;\n-    protected short integerUnboxIdx;\n-    protected short longIdx;\n-    protected short longBoxIdx;\n-    protected short longUnboxIdx;\n-    protected short shortIdx;\n-    protected short shortBoxIdx;\n-    protected short shortUnboxIdx;\n-\n-    protected final short NUM_COMMON_CPOOL_ENTRIES = (short) 30;\n-    protected final short NUM_BOXING_CPOOL_ENTRIES = (short) 73;\n-\n-    \/\/ Requires that superClass has been set up\n-    protected void emitCommonConstantPoolEntries() {\n-        \/\/ +   [UTF-8] \"java\/lang\/Throwable\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"java\/lang\/ClassCastException\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"java\/lang\/NullPointerException\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"java\/lang\/IllegalArgumentException\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"java\/lang\/InvocationTargetException\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"<init>\"\n-        \/\/ +   [UTF-8] \"()V\"\n-        \/\/ +   [CONSTANT_NameAndType_info] for above\n-        \/\/ +   [CONSTANT_Methodref_info] for NullPointerException's constructor\n-        \/\/ +   [CONSTANT_Methodref_info] for IllegalArgumentException's constructor\n-        \/\/ +   [UTF-8] \"(Ljava\/lang\/String;)V\"\n-        \/\/ +   [CONSTANT_NameAndType_info] for \"<init>(Ljava\/lang\/String;)V\"\n-        \/\/ +   [CONSTANT_Methodref_info] for IllegalArgumentException's constructor taking a String\n-        \/\/ +   [UTF-8] \"(Ljava\/lang\/Throwable;)V\"\n-        \/\/ +   [CONSTANT_NameAndType_info] for \"<init>(Ljava\/lang\/Throwable;)V\"\n-        \/\/ +   [CONSTANT_Methodref_info] for InvocationTargetException's constructor\n-        \/\/ +   [CONSTANT_Methodref_info] for \"super()\"\n-        \/\/ +   [UTF-8] \"java\/lang\/Object\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"toString\"\n-        \/\/ +   [UTF-8] \"()Ljava\/lang\/String;\"\n-        \/\/ +   [CONSTANT_NameAndType_info] for \"toString()Ljava\/lang\/String;\"\n-        \/\/ +   [CONSTANT_Methodref_info] for Object's toString method\n-        \/\/ +   [UTF-8] \"Code\"\n-        \/\/ +   [UTF-8] \"Exceptions\"\n-        asm.emitConstantPoolUTF8(\"java\/lang\/Throwable\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        throwableClass = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"java\/lang\/ClassCastException\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        classCastClass = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"java\/lang\/NullPointerException\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        nullPointerClass = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"java\/lang\/IllegalArgumentException\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        illegalArgumentClass = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"java\/lang\/reflect\/InvocationTargetException\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        invocationTargetClass = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"<init>\");\n-        initIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"()V\");\n-        asm.emitConstantPoolNameAndType(initIdx, asm.cpi());\n-        initNameAndTypeIdx = asm.cpi();\n-        asm.emitConstantPoolMethodref(nullPointerClass, initNameAndTypeIdx);\n-        nullPointerCtorIdx = asm.cpi();\n-        asm.emitConstantPoolMethodref(illegalArgumentClass, initNameAndTypeIdx);\n-        illegalArgumentCtorIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"(Ljava\/lang\/String;)V\");\n-        asm.emitConstantPoolNameAndType(initIdx, asm.cpi());\n-        initStringNameAndTypeIdx = asm.cpi();\n-        asm.emitConstantPoolMethodref(illegalArgumentClass, initStringNameAndTypeIdx);\n-        illegalArgumentStringCtorIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"(Ljava\/lang\/Throwable;)V\");\n-        asm.emitConstantPoolNameAndType(initIdx, asm.cpi());\n-        asm.emitConstantPoolMethodref(invocationTargetClass, asm.cpi());\n-        invocationTargetCtorIdx = asm.cpi();\n-        asm.emitConstantPoolMethodref(superClass, initNameAndTypeIdx);\n-        superCtorIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"java\/lang\/Object\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        objectClass = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"toString\");\n-        asm.emitConstantPoolUTF8(\"()Ljava\/lang\/String;\");\n-        asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());\n-        asm.emitConstantPoolMethodref(objectClass, asm.cpi());\n-        toStringIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"Code\");\n-        codeIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"Exceptions\");\n-        exceptionsIdx = asm.cpi();\n-    }\n-\n-    \/** Constant pool entries required to be able to box\/unbox primitive\n-        types. Note that we don't emit these if we don't need them. *\/\n-    protected void emitBoxingContantPoolEntries() {\n-        \/\/  *  [UTF-8] \"valueOf\"\n-        \/\/  *  [UTF-8] \"java\/lang\/Boolean\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(Z)Ljava\/lang\/Boolean;\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"booleanValue\"\n-        \/\/  *  [UTF-8] \"()Z\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Byte\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(B)Ljava\/lang\/Byte;\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"byteValue\"\n-        \/\/  *  [UTF-8] \"()B\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Character\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(C)Ljava\/lang\/Character;\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"charValue\"\n-        \/\/  *  [UTF-8] \"()C\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Double\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(D)Ljava\/lang\/Double;\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"doubleValue\"\n-        \/\/  *  [UTF-8] \"()D\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Float\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(F)Ljava\/lang\/Float;\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"floatValue\"\n-        \/\/  *  [UTF-8] \"()F\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Integer\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(I)Ljava\/lang\/Integer;\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"intValue\"\n-        \/\/  *  [UTF-8] \"()I\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Long\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(J)Ljava\/lang\/Long;\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"longValue\"\n-        \/\/  *  [UTF-8] \"()J\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Short\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(S)Ljava\/lang\/Short;\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"shortValue\"\n-        \/\/  *  [UTF-8] \"()S\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-\n-        \/\/ valueOf-method name\n-        asm.emitConstantPoolUTF8(\"valueOf\");\n-        valueOfIdx = asm.cpi();\n-\n-        \/\/ Boolean\n-        asm.emitConstantPoolUTF8(\"java\/lang\/Boolean\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        booleanIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"(Z)Ljava\/lang\/Boolean;\");\n-        asm.emitConstantPoolNameAndType(valueOfIdx, asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S2), asm.cpi());\n-        booleanBoxIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"booleanValue\");\n-        asm.emitConstantPoolUTF8(\"()Z\");\n-        asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S6), asm.cpi());\n-        booleanUnboxIdx = asm.cpi();\n-\n-        \/\/ Byte\n-        asm.emitConstantPoolUTF8(\"java\/lang\/Byte\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        byteIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"(B)Ljava\/lang\/Byte;\");\n-        asm.emitConstantPoolNameAndType(valueOfIdx, asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S2), asm.cpi());\n-        byteBoxIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"byteValue\");\n-        asm.emitConstantPoolUTF8(\"()B\");\n-        asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S6), asm.cpi());\n-        byteUnboxIdx = asm.cpi();\n-\n-        \/\/ Character\n-        asm.emitConstantPoolUTF8(\"java\/lang\/Character\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        characterIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"(C)Ljava\/lang\/Character;\");\n-        asm.emitConstantPoolNameAndType(valueOfIdx, asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S2), asm.cpi());\n-        characterBoxIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"charValue\");\n-        asm.emitConstantPoolUTF8(\"()C\");\n-        asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S6), asm.cpi());\n-        characterUnboxIdx = asm.cpi();\n-\n-        \/\/ Double\n-        asm.emitConstantPoolUTF8(\"java\/lang\/Double\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        doubleIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"(D)Ljava\/lang\/Double;\");\n-        asm.emitConstantPoolNameAndType(valueOfIdx, asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S2), asm.cpi());\n-        doubleBoxIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"doubleValue\");\n-        asm.emitConstantPoolUTF8(\"()D\");\n-        asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S6), asm.cpi());\n-        doubleUnboxIdx = asm.cpi();\n-\n-        \/\/ Float\n-        asm.emitConstantPoolUTF8(\"java\/lang\/Float\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        floatIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"(F)Ljava\/lang\/Float;\");\n-        asm.emitConstantPoolNameAndType(valueOfIdx, asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S2), asm.cpi());\n-        floatBoxIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"floatValue\");\n-        asm.emitConstantPoolUTF8(\"()F\");\n-        asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S6), asm.cpi());\n-        floatUnboxIdx = asm.cpi();\n-\n-        \/\/ Integer\n-        asm.emitConstantPoolUTF8(\"java\/lang\/Integer\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        integerIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"(I)Ljava\/lang\/Integer;\");\n-        asm.emitConstantPoolNameAndType(valueOfIdx, asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S2), asm.cpi());\n-        integerBoxIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"intValue\");\n-        asm.emitConstantPoolUTF8(\"()I\");\n-        asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S6), asm.cpi());\n-        integerUnboxIdx = asm.cpi();\n-\n-        \/\/ Long\n-        asm.emitConstantPoolUTF8(\"java\/lang\/Long\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        longIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"(J)Ljava\/lang\/Long;\");\n-        asm.emitConstantPoolNameAndType(valueOfIdx, asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S2), asm.cpi());\n-        longBoxIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"longValue\");\n-        asm.emitConstantPoolUTF8(\"()J\");\n-        asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S6), asm.cpi());\n-        longUnboxIdx = asm.cpi();\n-\n-        \/\/ Short\n-        asm.emitConstantPoolUTF8(\"java\/lang\/Short\");\n-        asm.emitConstantPoolClass(asm.cpi());\n-        shortIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"(S)Ljava\/lang\/Short;\");\n-        asm.emitConstantPoolNameAndType(valueOfIdx, asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S2), asm.cpi());\n-        shortBoxIdx = asm.cpi();\n-        asm.emitConstantPoolUTF8(\"shortValue\");\n-        asm.emitConstantPoolUTF8(\"()S\");\n-        asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());\n-        asm.emitConstantPoolMethodref(sub(asm.cpi(), S6), asm.cpi());\n-        shortUnboxIdx = asm.cpi();\n-    }\n-\n-    \/\/ Necessary because of Java's annoying promotion rules\n-    protected static short add(short s1, short s2) {\n-        return (short) (s1 + s2);\n-    }\n-\n-    protected static short sub(short s1, short s2) {\n-        return (short) (s1 - s2);\n-    }\n-\n-    protected boolean isStatic() {\n-        return Modifier.isStatic(modifiers);\n-    }\n-\n-    protected boolean isPrivate() {\n-        return Modifier.isPrivate(modifiers);\n-    }\n-\n-    \/** Returns class name in \"internal\" form (i.e., '\/' separators\n-        instead of '.') *\/\n-    protected static String getClassName\n-        (Class<?> c, boolean addPrefixAndSuffixForNonPrimitiveTypes)\n-    {\n-        if (c.isPrimitive()) {\n-            if (c == Boolean.TYPE) {\n-                return \"Z\";\n-            } else if (c == Byte.TYPE) {\n-                return \"B\";\n-            } else if (c == Character.TYPE) {\n-                return \"C\";\n-            } else if (c == Double.TYPE) {\n-                return \"D\";\n-            } else if (c == Float.TYPE) {\n-                return \"F\";\n-            } else if (c == Integer.TYPE) {\n-                return \"I\";\n-            } else if (c == Long.TYPE) {\n-                return \"J\";\n-            } else if (c == Short.TYPE) {\n-                return \"S\";\n-            } else if (c == Void.TYPE) {\n-                return \"V\";\n-            }\n-            throw new InternalError(\"Should have found primitive type\");\n-        } else if (c.isArray()) {\n-            return \"[\" + getClassName(c.getComponentType(), true);\n-        } else {\n-            if (addPrefixAndSuffixForNonPrimitiveTypes) {\n-                return internalize(\"L\" + c.getName() + \";\");\n-            } else {\n-                return internalize(c.getName());\n-            }\n-        }\n-    }\n-\n-    private static String internalize(String className) {\n-        return className.replace('.', '\/');\n-    }\n-\n-    protected void emitConstructor() {\n-        \/\/ Generate code into fresh code buffer\n-        ClassFileAssembler cb = new ClassFileAssembler();\n-        \/\/ 0 incoming arguments\n-        cb.setMaxLocals(1);\n-        cb.opc_aload_0();\n-        cb.opc_invokespecial(superCtorIdx, 0, 0);\n-        cb.opc_return();\n-\n-        \/\/ Emit method\n-        emitMethod(initIdx, cb.getMaxLocals(), cb, null, null);\n-    }\n-\n-    \/\/ The descriptor's index in the constant pool must be (1 +\n-    \/\/ nameIdx). \"numArgs\" must indicate ALL arguments, including the\n-    \/\/ implicit \"this\" argument; double and long arguments each count\n-    \/\/ as 2 in this count. The code buffer must NOT contain the code\n-    \/\/ length. The exception table may be null, but if non-null must\n-    \/\/ NOT contain the exception table's length. The checked exception\n-    \/\/ indices may be null.\n-    protected void emitMethod(short nameIdx,\n-                              int numArgs,\n-                              ClassFileAssembler code,\n-                              ClassFileAssembler exceptionTable,\n-                              short[] checkedExceptionIndices)\n-    {\n-        int codeLen = code.getLength();\n-        int excLen  = 0;\n-        if (exceptionTable != null) {\n-            excLen = exceptionTable.getLength();\n-            if ((excLen % 8) != 0) {\n-                throw new IllegalArgumentException(\"Illegal exception table\");\n-            }\n-        }\n-        int attrLen = 12 + codeLen + excLen;\n-        excLen = excLen \/ 8; \/\/ No-op if no exception table\n-\n-        asm.emitShort(ACC_PUBLIC);\n-        asm.emitShort(nameIdx);\n-        asm.emitShort(add(nameIdx, S1));\n-        if (checkedExceptionIndices == null) {\n-            \/\/ Code attribute only\n-            asm.emitShort(S1);\n-        } else {\n-            \/\/ Code and Exceptions attributes\n-            asm.emitShort(S2);\n-        }\n-        \/\/ Code attribute\n-        asm.emitShort(codeIdx);\n-        asm.emitInt(attrLen);\n-        asm.emitShort(code.getMaxStack());\n-        asm.emitShort((short) Math.max(numArgs, code.getMaxLocals()));\n-        asm.emitInt(codeLen);\n-        asm.append(code);\n-        asm.emitShort((short) excLen);\n-        if (exceptionTable != null) {\n-            asm.append(exceptionTable);\n-        }\n-        asm.emitShort(S0); \/\/ No additional attributes for Code attribute\n-        if (checkedExceptionIndices != null) {\n-            \/\/ Exceptions attribute\n-            asm.emitShort(exceptionsIdx);\n-            asm.emitInt(2 + 2 * checkedExceptionIndices.length);\n-            asm.emitShort((short) checkedExceptionIndices.length);\n-            for (int i = 0; i < checkedExceptionIndices.length; i++) {\n-                asm.emitShort(checkedExceptionIndices[i]);\n-            }\n-        }\n-    }\n-\n-    protected short indexForPrimitiveType(Class<?> type) {\n-        if (type == Boolean.TYPE) {\n-            return booleanIdx;\n-        } else if (type == Byte.TYPE) {\n-            return byteIdx;\n-        } else if (type == Character.TYPE) {\n-            return characterIdx;\n-        } else if (type == Double.TYPE) {\n-            return doubleIdx;\n-        } else if (type == Float.TYPE) {\n-            return floatIdx;\n-        } else if (type == Integer.TYPE) {\n-            return integerIdx;\n-        } else if (type == Long.TYPE) {\n-            return longIdx;\n-        } else if (type == Short.TYPE) {\n-            return shortIdx;\n-        }\n-        throw new InternalError(\"Should have found primitive type\");\n-    }\n-\n-    protected short boxingMethodForPrimitiveType(Class<?> type) {\n-        if (type == Boolean.TYPE) {\n-            return booleanBoxIdx;\n-        } else if (type == Byte.TYPE) {\n-            return byteBoxIdx;\n-        } else if (type == Character.TYPE) {\n-            return characterBoxIdx;\n-        } else if (type == Double.TYPE) {\n-            return doubleBoxIdx;\n-        } else if (type == Float.TYPE) {\n-            return floatBoxIdx;\n-        } else if (type == Integer.TYPE) {\n-            return integerBoxIdx;\n-        } else if (type == Long.TYPE) {\n-            return longBoxIdx;\n-        } else if (type == Short.TYPE) {\n-            return shortBoxIdx;\n-        }\n-        throw new InternalError(\"Should have found primitive type\");\n-    }\n-\n-    \/** Returns true for widening or identity conversions for primitive\n-        types only *\/\n-    protected static boolean canWidenTo(Class<?> type, Class<?> otherType) {\n-        if (!type.isPrimitive()) {\n-            return false;\n-        }\n-\n-        \/\/ Widening conversions (from JVM spec):\n-        \/\/  byte to short, int, long, float, or double\n-        \/\/  short to int, long, float, or double\n-        \/\/  char to int, long, float, or double\n-        \/\/  int to long, float, or double\n-        \/\/  long to float or double\n-        \/\/  float to double\n-\n-        if (type == Boolean.TYPE) {\n-            if (otherType == Boolean.TYPE) {\n-                return true;\n-            }\n-        } else if (type == Byte.TYPE) {\n-            if (   otherType == Byte.TYPE\n-                   || otherType == Short.TYPE\n-                   || otherType == Integer.TYPE\n-                   || otherType == Long.TYPE\n-                   || otherType == Float.TYPE\n-                   || otherType == Double.TYPE) {\n-                return true;\n-            }\n-        } else if (type == Short.TYPE) {\n-            if (   otherType == Short.TYPE\n-                   || otherType == Integer.TYPE\n-                   || otherType == Long.TYPE\n-                   || otherType == Float.TYPE\n-                   || otherType == Double.TYPE) {\n-                return true;\n-            }\n-        } else if (type == Character.TYPE) {\n-            if (   otherType == Character.TYPE\n-                   || otherType == Integer.TYPE\n-                   || otherType == Long.TYPE\n-                   || otherType == Float.TYPE\n-                   || otherType == Double.TYPE) {\n-                return true;\n-            }\n-        } else if (type == Integer.TYPE) {\n-            if (   otherType == Integer.TYPE\n-                   || otherType == Long.TYPE\n-                   || otherType == Float.TYPE\n-                   || otherType == Double.TYPE) {\n-                return true;\n-            }\n-        } else if (type == Long.TYPE) {\n-            if (   otherType == Long.TYPE\n-                   || otherType == Float.TYPE\n-                   || otherType == Double.TYPE) {\n-                return true;\n-            }\n-        } else if (type == Float.TYPE) {\n-            if (   otherType == Float.TYPE\n-                   || otherType == Double.TYPE) {\n-                return true;\n-            }\n-        } else if (type == Double.TYPE) {\n-            if (otherType == Double.TYPE) {\n-                return true;\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n-    \/** Emits the widening bytecode for the given primitive conversion\n-        (or none if the identity conversion). Requires that a primitive\n-        conversion exists; i.e., canWidenTo must have already been\n-        called and returned true. *\/\n-    protected static void emitWideningBytecodeForPrimitiveConversion\n-        (ClassFileAssembler cb,\n-         Class<?> fromType,\n-         Class<?> toType)\n-    {\n-        \/\/ Note that widening conversions for integral types (i.e., \"b2s\",\n-        \/\/ \"s2i\") are no-ops since values on the Java stack are\n-        \/\/ sign-extended.\n-\n-        \/\/ Widening conversions (from JVM spec):\n-        \/\/  byte to short, int, long, float, or double\n-        \/\/  short to int, long, float, or double\n-        \/\/  char to int, long, float, or double\n-        \/\/  int to long, float, or double\n-        \/\/  long to float or double\n-        \/\/  float to double\n-\n-        if (   fromType == Byte.TYPE\n-               || fromType == Short.TYPE\n-               || fromType == Character.TYPE\n-               || fromType == Integer.TYPE) {\n-            if (toType == Long.TYPE) {\n-                cb.opc_i2l();\n-            } else if (toType == Float.TYPE) {\n-                cb.opc_i2f();\n-            } else if (toType == Double.TYPE) {\n-                cb.opc_i2d();\n-            }\n-        } else if (fromType == Long.TYPE) {\n-            if (toType == Float.TYPE) {\n-                cb.opc_l2f();\n-            } else if (toType == Double.TYPE) {\n-                cb.opc_l2d();\n-            }\n-        } else if (fromType == Float.TYPE) {\n-            if (toType == Double.TYPE) {\n-                cb.opc_f2d();\n-            }\n-        }\n-\n-        \/\/ Otherwise, was identity or no-op conversion. Fall through.\n-    }\n-\n-    protected short unboxingMethodForPrimitiveType(Class<?> primType) {\n-        if (primType == Boolean.TYPE) {\n-            return booleanUnboxIdx;\n-        } else if (primType == Byte.TYPE) {\n-            return byteUnboxIdx;\n-        } else if (primType == Character.TYPE) {\n-            return characterUnboxIdx;\n-        } else if (primType == Short.TYPE) {\n-            return shortUnboxIdx;\n-        } else if (primType == Integer.TYPE) {\n-            return integerUnboxIdx;\n-        } else if (primType == Long.TYPE) {\n-            return longUnboxIdx;\n-        } else if (primType == Float.TYPE) {\n-            return floatUnboxIdx;\n-        } else if (primType == Double.TYPE) {\n-            return doubleUnboxIdx;\n-        }\n-        throw new InternalError(\"Illegal primitive type \" + primType.getName());\n-    }\n-\n-    protected static final Class<?>[] primitiveTypes = new Class<?>[] {\n-        Boolean.TYPE,\n-        Byte.TYPE,\n-        Character.TYPE,\n-        Short.TYPE,\n-        Integer.TYPE,\n-        Long.TYPE,\n-        Float.TYPE,\n-        Double.TYPE\n-    };\n-\n-    \/** We don't consider \"Void\" to be a primitive type *\/\n-    protected static boolean isPrimitive(Class<?> c) {\n-        return (c.isPrimitive() && c != Void.TYPE);\n-    }\n-\n-    protected int typeSizeInStackSlots(Class<?> c) {\n-        if (c == Void.TYPE) {\n-            return 0;\n-        }\n-        if (c == Long.TYPE || c == Double.TYPE) {\n-            return 2;\n-        }\n-        return 1;\n-    }\n-\n-    private ClassFileAssembler illegalArgumentCodeBuffer;\n-    protected ClassFileAssembler illegalArgumentCodeBuffer() {\n-        if (illegalArgumentCodeBuffer == null) {\n-            illegalArgumentCodeBuffer = new ClassFileAssembler();\n-            illegalArgumentCodeBuffer.opc_new(illegalArgumentClass);\n-            illegalArgumentCodeBuffer.opc_dup();\n-            illegalArgumentCodeBuffer.opc_invokespecial(illegalArgumentCtorIdx, 0, 0);\n-            illegalArgumentCodeBuffer.opc_athrow();\n-        }\n-\n-        return illegalArgumentCodeBuffer;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/AccessorGenerator.java","additions":0,"deletions":722,"binary":false,"changes":722,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-\/** A growable array of bytes. *\/\n-\n-interface ByteVector {\n-    public int  getLength();\n-    public byte get(int index);\n-    public void put(int index, byte value);\n-    public void add(byte value);\n-    public void trim();\n-    public byte[] getData();\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ByteVector.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-class ByteVectorFactory {\n-    static ByteVector create() {\n-        return new ByteVectorImpl();\n-    }\n-\n-    static ByteVector create(int sz) {\n-        return new ByteVectorImpl(sz);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ByteVectorFactory.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,88 +0,0 @@\n-\/*\n- * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-class ByteVectorImpl implements ByteVector {\n-    private byte[] data;\n-    private int pos;\n-\n-    public ByteVectorImpl() {\n-        this(100);\n-    }\n-\n-    public ByteVectorImpl(int sz) {\n-        data = new byte[sz];\n-        pos = -1;\n-    }\n-\n-    public int getLength() {\n-        return pos + 1;\n-    }\n-\n-    public byte get(int index) {\n-        if (index >= data.length) {\n-            resize(index);\n-            pos = index;\n-        }\n-        return data[index];\n-    }\n-\n-    public void put(int index, byte value) {\n-        if (index >= data.length) {\n-            resize(index);\n-            pos = index;\n-        }\n-        data[index] = value;\n-    }\n-\n-    public void add(byte value) {\n-        if (++pos >= data.length) {\n-            resize(pos);\n-        }\n-        data[pos] = value;\n-    }\n-\n-    public void trim() {\n-        if (pos != data.length - 1) {\n-            byte[] newData = new byte[pos + 1];\n-            System.arraycopy(data, 0, newData, 0, pos + 1);\n-            data = newData;\n-        }\n-    }\n-\n-    public byte[] getData() {\n-        return data;\n-    }\n-\n-    private void resize(int minSize) {\n-        if (minSize <= 2 * data.length) {\n-            minSize = 2 * data.length;\n-        }\n-        byte[] newData = new byte[minSize];\n-        System.arraycopy(data, 0, newData, 0, data.length);\n-        data = newData;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ByteVectorImpl.java","additions":0,"deletions":88,"binary":false,"changes":88,"status":"deleted"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.SharedSecrets;\n-\n-\/** Utility class which assists in calling defineClass() by\n- *  creating a new class loader which delegates to the one needed in\n- *  order for proper resolution of the given bytecodes to occur.\n- *\n- *  This is only used to define SerializationConstructorAccessor.\n- *\/\n-\n-class ClassDefiner {\n-    static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n-\n-    \/** <P> We define generated code into a new class loader which\n-      delegates to the defining loader of the target class. It is\n-      necessary for the VM to be able to resolve references to the\n-      target class from the generated bytecodes, which could not occur\n-      if the generated code was loaded into the bootstrap class\n-      loader. <\/P>\n-\n-      <P> There are two primary reasons for creating a new loader\n-      instead of defining these bytecodes directly into the defining\n-      loader of the target class: first, it avoids any possible\n-      security risk of having these bytecodes in the same loader.\n-      Second, it allows the generated bytecodes to be unloaded earlier\n-      than would otherwise be possible, decreasing run-time\n-      footprint. <\/P>\n-    *\/\n-    static Class<?> defineClass(String name, byte[] bytes, int off, int len,\n-                                final ClassLoader parentClassLoader)\n-    {\n-        @SuppressWarnings(\"removal\")\n-        ClassLoader newLoader = AccessController.doPrivileged(\n-            new PrivilegedAction<ClassLoader>() {\n-                public ClassLoader run() {\n-                        return new DelegatingClassLoader(parentClassLoader);\n-                    }\n-                });\n-        return JLA.defineClass(newLoader, name, bytes, null, \"__ClassDefiner__\");\n-    }\n-}\n-\n-\n-\/\/ NOTE: this class's name and presence are known to the virtual\n-\/\/ machine as of the fix for 4474172.\n-class DelegatingClassLoader extends ClassLoader {\n-    DelegatingClassLoader(ClassLoader parent) {\n-        super(parent);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ClassDefiner.java","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -1,671 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2004, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-import sun.nio.cs.UTF_8;\n-\n-class ClassFileAssembler implements ClassFileConstants {\n-    private ByteVector vec;\n-    private short cpIdx = 0;\n-\n-    public ClassFileAssembler() {\n-        this(ByteVectorFactory.create());\n-    }\n-\n-    public ClassFileAssembler(ByteVector vec) {\n-        this.vec = vec;\n-    }\n-\n-    public ByteVector getData() {\n-        return vec;\n-    }\n-\n-    \/** Length in bytes *\/\n-    public short getLength() {\n-        return (short) vec.getLength();\n-    }\n-\n-    public void emitMagicAndVersion() {\n-        emitInt(0xCAFEBABE);\n-        emitShort((short) 0);\n-        emitShort((short) 49);\n-    }\n-\n-    public void emitInt(int val) {\n-        emitByte((byte) (val >> 24));\n-        emitByte((byte) ((val >> 16) & 0xFF));\n-        emitByte((byte) ((val >> 8) & 0xFF));\n-        emitByte((byte) (val & 0xFF));\n-    }\n-\n-    public void emitShort(short val) {\n-        emitByte((byte) ((val >> 8) & 0xFF));\n-        emitByte((byte) (val & 0xFF));\n-    }\n-\n-    \/\/ Support for labels; package-private\n-    void emitShort(short bci, short val) {\n-        vec.put(bci,     (byte) ((val >> 8) & 0xFF));\n-        vec.put(bci + 1, (byte) (val & 0xFF));\n-    }\n-\n-    public void emitByte(byte val) {\n-        vec.add(val);\n-    }\n-\n-    public void append(ClassFileAssembler asm) {\n-        append(asm.vec);\n-    }\n-\n-    public void append(ByteVector vec) {\n-        for (int i = 0; i < vec.getLength(); i++) {\n-            emitByte(vec.get(i));\n-        }\n-    }\n-\n-    \/** Keeps track of the current (one-based) constant pool index;\n-        incremented after emitting one of the following constant pool\n-        entries. Can fetch the current constant pool index for use in\n-        later entries.  Index points at the last valid constant pool\n-        entry; initially invalid. It is illegal to fetch the constant\n-        pool index before emitting at least one constant pool entry. *\/\n-    public short cpi() {\n-        if (cpIdx == 0) {\n-            throw new RuntimeException(\"Illegal use of ClassFileAssembler\");\n-        }\n-        return cpIdx;\n-    }\n-\n-    public void emitConstantPoolUTF8(String str) {\n-        byte[] bytes = str.getBytes(UTF_8.INSTANCE);\n-        emitByte(CONSTANT_Utf8);\n-        emitShort((short) bytes.length);\n-        for (int i = 0; i < bytes.length; i++) {\n-            emitByte(bytes[i]);\n-        }\n-        cpIdx++;\n-    }\n-\n-    public void emitConstantPoolClass(short index) {\n-        emitByte(CONSTANT_Class);\n-        emitShort(index);\n-        cpIdx++;\n-    }\n-\n-    public void emitConstantPoolNameAndType(short nameIndex, short typeIndex) {\n-        emitByte(CONSTANT_NameAndType);\n-        emitShort(nameIndex);\n-        emitShort(typeIndex);\n-        cpIdx++;\n-    }\n-\n-    public void emitConstantPoolFieldref\n-        (short classIndex, short nameAndTypeIndex)\n-    {\n-        emitByte(CONSTANT_Fieldref);\n-        emitShort(classIndex);\n-        emitShort(nameAndTypeIndex);\n-        cpIdx++;\n-    }\n-\n-    public void emitConstantPoolMethodref\n-        (short classIndex, short nameAndTypeIndex)\n-    {\n-        emitByte(CONSTANT_Methodref);\n-        emitShort(classIndex);\n-        emitShort(nameAndTypeIndex);\n-        cpIdx++;\n-    }\n-\n-    public void emitConstantPoolInterfaceMethodref\n-        (short classIndex, short nameAndTypeIndex)\n-    {\n-        emitByte(CONSTANT_InterfaceMethodref);\n-        emitShort(classIndex);\n-        emitShort(nameAndTypeIndex);\n-        cpIdx++;\n-    }\n-\n-    public void emitConstantPoolString(short utf8Index) {\n-        emitByte(CONSTANT_String);\n-        emitShort(utf8Index);\n-        cpIdx++;\n-    }\n-\n-    \/\/----------------------------------------------------------------------\n-    \/\/ Opcodes. Keeps track of maximum stack and locals. Make a new\n-    \/\/ assembler for each piece of assembled code, then append the\n-    \/\/ result to the previous assembler's class file.\n-    \/\/\n-\n-    private int stack     = 0;\n-    private int maxStack  = 0;\n-    private int maxLocals = 0;\n-\n-    private void incStack() {\n-        setStack(stack + 1);\n-    }\n-\n-    private void decStack() {\n-        --stack;\n-    }\n-\n-    public short getMaxStack() {\n-        return (short) maxStack;\n-    }\n-\n-    public short getMaxLocals() {\n-        return (short) maxLocals;\n-    }\n-\n-    \/** It's necessary to be able to specify the number of arguments at\n-        the beginning of the method (which translates to the initial\n-        value of max locals) *\/\n-    public void setMaxLocals(int maxLocals) {\n-        this.maxLocals = maxLocals;\n-    }\n-\n-    \/** Needed to do flow control. Returns current stack depth. *\/\n-    public int getStack() {\n-        return stack;\n-    }\n-\n-    \/** Needed to do flow control. *\/\n-    public void setStack(int value) {\n-        stack = value;\n-        if (stack > maxStack) {\n-            maxStack = stack;\n-        }\n-    }\n-\n-    \/\/-----------\/\/\n-    \/\/ Constants \/\/\n-    \/\/-----------\/\/\n-\n-    public void opc_aconst_null() {\n-        emitByte(opc_aconst_null);\n-        incStack();\n-    }\n-\n-    public void opc_sipush(short constant) {\n-        emitByte(opc_sipush);\n-        emitShort(constant);\n-        incStack();\n-    }\n-\n-    public void opc_ldc(byte cpIdx) {\n-        emitByte(opc_ldc);\n-        emitByte(cpIdx);\n-        incStack();\n-    }\n-\n-    \/\/---------------------------------\/\/\n-    \/\/ Local variable loads and stores \/\/\n-    \/\/---------------------------------\/\/\n-\n-    public void opc_iload_0() {\n-        emitByte(opc_iload_0);\n-        if (maxLocals < 1) maxLocals = 1;\n-        incStack();\n-    }\n-\n-    public void opc_iload_1() {\n-        emitByte(opc_iload_1);\n-        if (maxLocals < 2) maxLocals = 2;\n-        incStack();\n-    }\n-\n-    public void opc_iload_2() {\n-        emitByte(opc_iload_2);\n-        if (maxLocals < 3) maxLocals = 3;\n-        incStack();\n-    }\n-\n-    public void opc_iload_3() {\n-        emitByte(opc_iload_3);\n-        if (maxLocals < 4) maxLocals = 4;\n-        incStack();\n-    }\n-\n-    public void opc_lload_0() {\n-        emitByte(opc_lload_0);\n-        if (maxLocals < 2) maxLocals = 2;\n-        incStack();\n-        incStack();\n-    }\n-\n-    public void opc_lload_1() {\n-        emitByte(opc_lload_1);\n-        if (maxLocals < 3) maxLocals = 3;\n-        incStack();\n-        incStack();\n-    }\n-\n-    public void opc_lload_2() {\n-        emitByte(opc_lload_2);\n-        if (maxLocals < 4) maxLocals = 4;\n-        incStack();\n-        incStack();\n-    }\n-\n-    public void opc_lload_3() {\n-        emitByte(opc_lload_3);\n-        if (maxLocals < 5) maxLocals = 5;\n-        incStack();\n-        incStack();\n-    }\n-\n-    public void opc_fload_0() {\n-        emitByte(opc_fload_0);\n-        if (maxLocals < 1) maxLocals = 1;\n-        incStack();\n-    }\n-\n-    public void opc_fload_1() {\n-        emitByte(opc_fload_1);\n-        if (maxLocals < 2) maxLocals = 2;\n-        incStack();\n-    }\n-\n-    public void opc_fload_2() {\n-        emitByte(opc_fload_2);\n-        if (maxLocals < 3) maxLocals = 3;\n-        incStack();\n-    }\n-\n-    public void opc_fload_3() {\n-        emitByte(opc_fload_3);\n-        if (maxLocals < 4) maxLocals = 4;\n-        incStack();\n-    }\n-\n-    public void opc_dload_0() {\n-        emitByte(opc_dload_0);\n-        if (maxLocals < 2) maxLocals = 2;\n-        incStack();\n-        incStack();\n-    }\n-\n-    public void opc_dload_1() {\n-        emitByte(opc_dload_1);\n-        if (maxLocals < 3) maxLocals = 3;\n-        incStack();\n-        incStack();\n-    }\n-\n-    public void opc_dload_2() {\n-        emitByte(opc_dload_2);\n-        if (maxLocals < 4) maxLocals = 4;\n-        incStack();\n-        incStack();\n-    }\n-\n-    public void opc_dload_3() {\n-        emitByte(opc_dload_3);\n-        if (maxLocals < 5) maxLocals = 5;\n-        incStack();\n-        incStack();\n-    }\n-\n-    public void opc_aload_0() {\n-        emitByte(opc_aload_0);\n-        if (maxLocals < 1) maxLocals = 1;\n-        incStack();\n-    }\n-\n-    public void opc_aload_1() {\n-        emitByte(opc_aload_1);\n-        if (maxLocals < 2) maxLocals = 2;\n-        incStack();\n-    }\n-\n-    public void opc_aload_2() {\n-        emitByte(opc_aload_2);\n-        if (maxLocals < 3) maxLocals = 3;\n-        incStack();\n-    }\n-\n-    public void opc_aload_3() {\n-        emitByte(opc_aload_3);\n-        if (maxLocals < 4) maxLocals = 4;\n-        incStack();\n-    }\n-\n-    public void opc_aaload() {\n-        emitByte(opc_aaload);\n-        decStack();\n-    }\n-\n-    public void opc_astore_0() {\n-        emitByte(opc_astore_0);\n-        if (maxLocals < 1) maxLocals = 1;\n-        decStack();\n-    }\n-\n-    public void opc_astore_1() {\n-        emitByte(opc_astore_1);\n-        if (maxLocals < 2) maxLocals = 2;\n-        decStack();\n-    }\n-\n-    public void opc_astore_2() {\n-        emitByte(opc_astore_2);\n-        if (maxLocals < 3) maxLocals = 3;\n-        decStack();\n-    }\n-\n-    public void opc_astore_3() {\n-        emitByte(opc_astore_3);\n-        if (maxLocals < 4) maxLocals = 4;\n-        decStack();\n-    }\n-\n-    \/\/--------------------\/\/\n-    \/\/ Stack manipulation \/\/\n-    \/\/--------------------\/\/\n-\n-    public void opc_pop() {\n-        emitByte(opc_pop);\n-        decStack();\n-    }\n-\n-    public void opc_dup() {\n-        emitByte(opc_dup);\n-        incStack();\n-    }\n-\n-    public void opc_dup_x1() {\n-        emitByte(opc_dup_x1);\n-        incStack();\n-    }\n-\n-    public void opc_swap() {\n-        emitByte(opc_swap);\n-    }\n-\n-    \/\/---------------------------\/\/\n-    \/\/ Widening conversions only \/\/\n-    \/\/---------------------------\/\/\n-\n-    public void opc_i2l() {\n-        emitByte(opc_i2l);\n-    }\n-\n-    public void opc_i2f() {\n-        emitByte(opc_i2f);\n-    }\n-\n-    public void opc_i2d() {\n-        emitByte(opc_i2d);\n-    }\n-\n-    public void opc_l2f() {\n-        emitByte(opc_l2f);\n-    }\n-\n-    public void opc_l2d() {\n-        emitByte(opc_l2d);\n-    }\n-\n-    public void opc_f2d() {\n-        emitByte(opc_f2d);\n-    }\n-\n-    \/\/--------------\/\/\n-    \/\/ Control flow \/\/\n-    \/\/--------------\/\/\n-\n-    public void opc_ifeq(short bciOffset) {\n-        emitByte(opc_ifeq);\n-        emitShort(bciOffset);\n-        decStack();\n-    }\n-\n-    \/** Control flow with forward-reference BCI. Stack assumes\n-        straight-through control flow. *\/\n-    public void opc_ifeq(Label l) {\n-        short instrBCI = getLength();\n-        emitByte(opc_ifeq);\n-        l.add(this, instrBCI, getLength(), getStack() - 1);\n-        emitShort((short) -1); \/\/ Must be patched later\n-    }\n-\n-    public void opc_if_icmpeq(short bciOffset) {\n-        emitByte(opc_if_icmpeq);\n-        emitShort(bciOffset);\n-        setStack(getStack() - 2);\n-    }\n-\n-    \/** Control flow with forward-reference BCI. Stack assumes straight\n-        control flow. *\/\n-    public void opc_if_icmpeq(Label l) {\n-        short instrBCI = getLength();\n-        emitByte(opc_if_icmpeq);\n-        l.add(this, instrBCI, getLength(), getStack() - 2);\n-        emitShort((short) -1); \/\/ Must be patched later\n-    }\n-\n-    public void opc_goto(short bciOffset) {\n-        emitByte(opc_goto);\n-        emitShort(bciOffset);\n-    }\n-\n-    \/** Control flow with forward-reference BCI. Stack assumes straight\n-        control flow. *\/\n-    public void opc_goto(Label l) {\n-        short instrBCI = getLength();\n-        emitByte(opc_goto);\n-        l.add(this, instrBCI, getLength(), getStack());\n-        emitShort((short) -1); \/\/ Must be patched later\n-    }\n-\n-    public void opc_ifnull(short bciOffset) {\n-        emitByte(opc_ifnull);\n-        emitShort(bciOffset);\n-        decStack();\n-    }\n-\n-    \/** Control flow with forward-reference BCI. Stack assumes straight\n-        control flow. *\/\n-    public void opc_ifnull(Label l) {\n-        short instrBCI = getLength();\n-        emitByte(opc_ifnull);\n-        l.add(this, instrBCI, getLength(), getStack() - 1);\n-        emitShort((short) -1); \/\/ Must be patched later\n-        decStack();\n-    }\n-\n-    public void opc_ifnonnull(short bciOffset) {\n-        emitByte(opc_ifnonnull);\n-        emitShort(bciOffset);\n-        decStack();\n-    }\n-\n-    \/** Control flow with forward-reference BCI. Stack assumes straight\n-        control flow. *\/\n-    public void opc_ifnonnull(Label l) {\n-        short instrBCI = getLength();\n-        emitByte(opc_ifnonnull);\n-        l.add(this, instrBCI, getLength(), getStack() - 1);\n-        emitShort((short) -1); \/\/ Must be patched later\n-        decStack();\n-    }\n-\n-    \/\/---------------------\/\/\n-    \/\/ Return instructions \/\/\n-    \/\/---------------------\/\/\n-\n-    public void opc_ireturn() {\n-        emitByte(opc_ireturn);\n-        setStack(0);\n-    }\n-\n-    public void opc_lreturn() {\n-        emitByte(opc_lreturn);\n-        setStack(0);\n-    }\n-\n-    public void opc_freturn() {\n-        emitByte(opc_freturn);\n-        setStack(0);\n-    }\n-\n-    public void opc_dreturn() {\n-        emitByte(opc_dreturn);\n-        setStack(0);\n-    }\n-\n-    public void opc_areturn() {\n-        emitByte(opc_areturn);\n-        setStack(0);\n-    }\n-\n-    public void opc_return() {\n-        emitByte(opc_return);\n-        setStack(0);\n-    }\n-\n-    \/\/------------------\/\/\n-    \/\/ Field operations \/\/\n-    \/\/------------------\/\/\n-\n-    public void opc_getstatic(short fieldIndex, int fieldSizeInStackSlots) {\n-        emitByte(opc_getstatic);\n-        emitShort(fieldIndex);\n-        setStack(getStack() + fieldSizeInStackSlots);\n-    }\n-\n-    public void opc_putstatic(short fieldIndex, int fieldSizeInStackSlots) {\n-        emitByte(opc_putstatic);\n-        emitShort(fieldIndex);\n-        setStack(getStack() - fieldSizeInStackSlots);\n-    }\n-\n-    public void opc_getfield(short fieldIndex, int fieldSizeInStackSlots) {\n-        emitByte(opc_getfield);\n-        emitShort(fieldIndex);\n-        setStack(getStack() + fieldSizeInStackSlots - 1);\n-    }\n-\n-    public void opc_putfield(short fieldIndex, int fieldSizeInStackSlots) {\n-        emitByte(opc_putfield);\n-        emitShort(fieldIndex);\n-        setStack(getStack() - fieldSizeInStackSlots - 1);\n-    }\n-\n-    \/\/--------------------\/\/\n-    \/\/ Method invocations \/\/\n-    \/\/--------------------\/\/\n-\n-    \/** Long and double arguments and return types count as 2 arguments;\n-        other values count as 1. *\/\n-    public void opc_invokevirtual(short methodIndex,\n-                                  int numArgs,\n-                                  int numReturnValues)\n-    {\n-        emitByte(opc_invokevirtual);\n-        emitShort(methodIndex);\n-        setStack(getStack() - numArgs - 1 + numReturnValues);\n-    }\n-\n-    \/** Long and double arguments and return types count as 2 arguments;\n-        other values count as 1. *\/\n-    public void opc_invokespecial(short methodIndex,\n-                                  int numArgs,\n-                                  int numReturnValues)\n-    {\n-        emitByte(opc_invokespecial);\n-        emitShort(methodIndex);\n-        setStack(getStack() - numArgs - 1 + numReturnValues);\n-    }\n-\n-    \/** Long and double arguments and return types count as 2 arguments;\n-        other values count as 1. *\/\n-    public void opc_invokestatic(short methodIndex,\n-                                 int numArgs,\n-                                 int numReturnValues)\n-    {\n-        emitByte(opc_invokestatic);\n-        emitShort(methodIndex);\n-        setStack(getStack() - numArgs + numReturnValues);\n-    }\n-\n-    \/** Long and double arguments and return types count as 2 arguments;\n-        other values count as 1. *\/\n-    public void opc_invokeinterface(short methodIndex,\n-                                    int numArgs,\n-                                    byte count,\n-                                    int numReturnValues)\n-    {\n-        emitByte(opc_invokeinterface);\n-        emitShort(methodIndex);\n-        emitByte(count);\n-        emitByte((byte) 0);\n-        setStack(getStack() - numArgs - 1 + numReturnValues);\n-    }\n-\n-    \/\/--------------\/\/\n-    \/\/ Array length \/\/\n-    \/\/--------------\/\/\n-\n-    public void opc_arraylength() {\n-        emitByte(opc_arraylength);\n-    }\n-\n-    \/\/-----\/\/\n-    \/\/ New \/\/\n-    \/\/-----\/\/\n-\n-    public void opc_new(short classIndex) {\n-        emitByte(opc_new);\n-        emitShort(classIndex);\n-        incStack();\n-    }\n-\n-    \/\/--------\/\/\n-    \/\/ Athrow \/\/\n-    \/\/--------\/\/\n-\n-    public void opc_athrow() {\n-        emitByte(opc_athrow);\n-        setStack(1);\n-    }\n-\n-    \/\/--------------------------\/\/\n-    \/\/ Checkcast and instanceof \/\/\n-    \/\/--------------------------\/\/\n-\n-    \/** Assumes the checkcast succeeds *\/\n-    public void opc_checkcast(short classIndex) {\n-        emitByte(opc_checkcast);\n-        emitShort(classIndex);\n-    }\n-\n-    public void opc_instanceof(short classIndex) {\n-        emitByte(opc_instanceof);\n-        emitShort(classIndex);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ClassFileAssembler.java","additions":0,"deletions":671,"binary":false,"changes":671,"status":"deleted"},{"patch":"@@ -1,140 +0,0 @@\n-\/*\n- * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-\/** Minimal set of class file constants for assembly of field and\n-    method accessors. *\/\n-\n-interface ClassFileConstants {\n-    \/\/ Constants\n-    public static final byte opc_aconst_null   = (byte) 0x1;\n-    public static final byte opc_sipush        = (byte) 0x11;\n-    public static final byte opc_ldc           = (byte) 0x12;\n-\n-    \/\/ Local variable loads and stores\n-    public static final byte opc_iload_0       = (byte) 0x1a;\n-    public static final byte opc_iload_1       = (byte) 0x1b;\n-    public static final byte opc_iload_2       = (byte) 0x1c;\n-    public static final byte opc_iload_3       = (byte) 0x1d;\n-    public static final byte opc_lload_0       = (byte) 0x1e;\n-    public static final byte opc_lload_1       = (byte) 0x1f;\n-    public static final byte opc_lload_2       = (byte) 0x20;\n-    public static final byte opc_lload_3       = (byte) 0x21;\n-    public static final byte opc_fload_0       = (byte) 0x22;\n-    public static final byte opc_fload_1       = (byte) 0x23;\n-    public static final byte opc_fload_2       = (byte) 0x24;\n-    public static final byte opc_fload_3       = (byte) 0x25;\n-    public static final byte opc_dload_0       = (byte) 0x26;\n-    public static final byte opc_dload_1       = (byte) 0x27;\n-    public static final byte opc_dload_2       = (byte) 0x28;\n-    public static final byte opc_dload_3       = (byte) 0x29;\n-    public static final byte opc_aload_0       = (byte) 0x2a;\n-    public static final byte opc_aload_1       = (byte) 0x2b;\n-    public static final byte opc_aload_2       = (byte) 0x2c;\n-    public static final byte opc_aload_3       = (byte) 0x2d;\n-    public static final byte opc_aaload        = (byte) 0x32;\n-    public static final byte opc_astore_0      = (byte) 0x4b;\n-    public static final byte opc_astore_1      = (byte) 0x4c;\n-    public static final byte opc_astore_2      = (byte) 0x4d;\n-    public static final byte opc_astore_3      = (byte) 0x4e;\n-\n-    \/\/ Stack manipulation\n-    public static final byte opc_pop           = (byte) 0x57;\n-    public static final byte opc_dup           = (byte) 0x59;\n-    public static final byte opc_dup_x1        = (byte) 0x5a;\n-    public static final byte opc_swap          = (byte) 0x5f;\n-\n-    \/\/ Conversions\n-    public static final byte opc_i2l           = (byte) 0x85;\n-    public static final byte opc_i2f           = (byte) 0x86;\n-    public static final byte opc_i2d           = (byte) 0x87;\n-    public static final byte opc_l2i           = (byte) 0x88;\n-    public static final byte opc_l2f           = (byte) 0x89;\n-    public static final byte opc_l2d           = (byte) 0x8a;\n-    public static final byte opc_f2i           = (byte) 0x8b;\n-    public static final byte opc_f2l           = (byte) 0x8c;\n-    public static final byte opc_f2d           = (byte) 0x8d;\n-    public static final byte opc_d2i           = (byte) 0x8e;\n-    public static final byte opc_d2l           = (byte) 0x8f;\n-    public static final byte opc_d2f           = (byte) 0x90;\n-    public static final byte opc_i2b           = (byte) 0x91;\n-    public static final byte opc_i2c           = (byte) 0x92;\n-    public static final byte opc_i2s           = (byte) 0x93;\n-\n-    \/\/ Control flow\n-    public static final byte opc_ifeq          = (byte) 0x99;\n-    public static final byte opc_if_icmpeq     = (byte) 0x9f;\n-    public static final byte opc_goto          = (byte) 0xa7;\n-\n-    \/\/ Return instructions\n-    public static final byte opc_ireturn       = (byte) 0xac;\n-    public static final byte opc_lreturn       = (byte) 0xad;\n-    public static final byte opc_freturn       = (byte) 0xae;\n-    public static final byte opc_dreturn       = (byte) 0xaf;\n-    public static final byte opc_areturn       = (byte) 0xb0;\n-    public static final byte opc_return        = (byte) 0xb1;\n-\n-    \/\/ Field operations\n-    public static final byte opc_getstatic     = (byte) 0xb2;\n-    public static final byte opc_putstatic     = (byte) 0xb3;\n-    public static final byte opc_getfield      = (byte) 0xb4;\n-    public static final byte opc_putfield      = (byte) 0xb5;\n-\n-    \/\/ Method invocations\n-    public static final byte opc_invokevirtual   = (byte) 0xb6;\n-    public static final byte opc_invokespecial   = (byte) 0xb7;\n-    public static final byte opc_invokestatic    = (byte) 0xb8;\n-    public static final byte opc_invokeinterface = (byte) 0xb9;\n-\n-    \/\/ Array length\n-    public static final byte opc_arraylength     = (byte) 0xbe;\n-\n-    \/\/ New\n-    public static final byte opc_new           = (byte) 0xbb;\n-\n-    \/\/ Athrow\n-    public static final byte opc_athrow        = (byte) 0xbf;\n-\n-    \/\/ Checkcast and instanceof\n-    public static final byte opc_checkcast     = (byte) 0xc0;\n-    public static final byte opc_instanceof    = (byte) 0xc1;\n-\n-    \/\/ Ifnull and ifnonnull\n-    public static final byte opc_ifnull        = (byte) 0xc6;\n-    public static final byte opc_ifnonnull     = (byte) 0xc7;\n-\n-    \/\/ Constant pool tags\n-    public static final byte CONSTANT_Class              = (byte) 7;\n-    public static final byte CONSTANT_Fieldref           = (byte) 9;\n-    public static final byte CONSTANT_Methodref          = (byte) 10;\n-    public static final byte CONSTANT_InterfaceMethodref = (byte) 11;\n-    public static final byte CONSTANT_NameAndType        = (byte) 12;\n-    public static final byte CONSTANT_String             = (byte) 8;\n-    public static final byte CONSTANT_Utf8               = (byte) 1;\n-\n-    \/\/ Access flags\n-    public static final short ACC_PUBLIC = (short) 0x0001;\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ClassFileConstants.java","additions":0,"deletions":140,"binary":false,"changes":140,"status":"deleted"},{"patch":"@@ -30,6 +30,1 @@\n-\/** Package-private implementation of the ConstructorAccessor\n-    interface which has access to all classes and all fields,\n-    regardless of language restrictions. See MagicAccessorImpl. *\/\n-\n-abstract class ConstructorAccessorImpl extends MagicAccessorImpl\n-    implements ConstructorAccessor {\n+abstract class ConstructorAccessorImpl implements ConstructorAccessor {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ConstructorAccessorImpl.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,6 +31,1 @@\n-\/** Package-private implementation of the FieldAccessor interface\n-    which has access to all classes and all fields, regardless of\n-    language restrictions. See MagicAccessorImpl. *\/\n-\n-abstract class FieldAccessorImpl extends MagicAccessorImpl\n-    implements FieldAccessor {\n+abstract class FieldAccessorImpl implements FieldAccessor {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/FieldAccessorImpl.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,76 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-import java.util.List;\n-import java.util.ArrayList;\n-\n-\/** Allows forward references in bytecode streams emitted by\n-    ClassFileAssembler. Assumes that the start of the method body is\n-    the first byte in the assembler's buffer. May be used at more than\n-    one branch site. *\/\n-\n-class Label {\n-    static class PatchInfo {\n-        PatchInfo(ClassFileAssembler asm,\n-                  short instrBCI,\n-                  short patchBCI,\n-                  int stackDepth)\n-        {\n-            this.asm = asm;\n-            this.instrBCI   = instrBCI;\n-            this.patchBCI   = patchBCI;\n-            this.stackDepth = stackDepth;\n-        }\n-        \/\/ This won't work for more than one assembler anyway, so this is\n-        \/\/ unnecessary\n-        final ClassFileAssembler asm;\n-        final short instrBCI;\n-        final short patchBCI;\n-        final int   stackDepth;\n-    }\n-    private final List<PatchInfo> patches = new ArrayList<>();\n-\n-    public Label() {\n-    }\n-\n-    void add(ClassFileAssembler asm,\n-             short instrBCI,\n-             short patchBCI,\n-             int stackDepth)\n-    {\n-        patches.add(new PatchInfo(asm, instrBCI, patchBCI, stackDepth));\n-    }\n-\n-    public void bind() {\n-        for (PatchInfo patch : patches){\n-            short curBCI = patch.asm.getLength();\n-            short offset = (short) (curBCI - patch.instrBCI);\n-            patch.asm.emitShort(patch.patchBCI, offset);\n-            patch.asm.setStack(patch.stackDepth);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/Label.java","additions":0,"deletions":76,"binary":false,"changes":76,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-\/** <P> MagicAccessorImpl (named for parity with FieldAccessorImpl and\n-    others, not because it actually implements an interface) is a\n-    marker class in the hierarchy. All subclasses of this class are\n-    \"magically\" granted access by the VM to otherwise inaccessible\n-    fields and methods of other classes. It is used to hold the code\n-    for dynamically-generated FieldAccessorImpl and MethodAccessorImpl\n-    subclasses. (Use of the word \"unsafe\" was avoided in this class's\n-    name to avoid confusion with {@link jdk.internal.misc.Unsafe}.) <\/P>\n-\n-    <P> The bug fix for 4486457 also necessitated disabling\n-    verification for this class and all subclasses, as opposed to just\n-    SerializationConstructorAccessorImpl and subclasses, to avoid\n-    having to indicate to the VM which of these dynamically-generated\n-    stub classes were known to be able to pass the verifier. <\/P>\n-\n-    <P> Do not change the name of this class without also changing the\n-    VM's code. <\/P> *\/\n-\n-class MagicAccessorImpl {\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MagicAccessorImpl.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -30,5 +30,1 @@\n-\/** <P> Package-private implementation of the MethodAccessor interface\n-    which has access to all classes and all fields, regardless of\n-    language restrictions. See MagicAccessor. <\/P>\n-\n-    <P> This class is known to the VM; do not change its name without\n+\/** <P> This class is known to the VM; do not change its name without\n@@ -43,2 +39,1 @@\n-abstract class MethodAccessorImpl extends MagicAccessorImpl\n-    implements MethodAccessor {\n+abstract class MethodAccessorImpl implements MethodAccessor {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodAccessorImpl.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -337,10 +337,2 @@\n-        ConstructorAccessor acc;\n-        if (useOldSerializableConstructor()) {\n-            acc = new SerializationConstructorAccessorGenerator().\n-                                generateSerializationConstructor(cl,\n-                                                                 constructorToCall.getParameterTypes(),\n-                                                                 constructorToCall.getModifiers(),\n-                                                                 constructorToCall.getDeclaringClass());\n-        } else {\n-            acc = MethodHandleAccessorFactory.newSerializableConstructorAccessor(cl, constructorToCall);\n-        }\n+        ConstructorAccessor acc = MethodHandleAccessorFactory\n+                .newSerializableConstructorAccessor(cl, constructorToCall);\n@@ -510,4 +502,0 @@\n-    static boolean useOldSerializableConstructor() {\n-        return config().useOldSerializableConstructor;\n-    }\n-\n@@ -530,1 +518,0 @@\n-                                                            false,  \/\/ useOldSerializeableConstructor\n@@ -545,1 +532,0 @@\n-                          boolean useOldSerializableConstructor,\n@@ -569,2 +555,0 @@\n-        boolean useOldSerializableConstructor =\n-            \"true\".equals(props.getProperty(\"jdk.reflect.useOldSerializableConstructor\"));\n@@ -574,1 +558,1 @@\n-        return new Config(useNativeAccessorOnly, useOldSerializableConstructor, disableSerialConstructorChecks);\n+        return new Config(useNativeAccessorOnly, disableSerialConstructorChecks);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":3,"deletions":19,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1,725 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-\n-\n-\/** Generator for jdk.internal.reflect.SerializationConstructorAccessorImpl\n-    objects using bytecodes to implement a constructor for serialization\n-    returned by ReflectionFactory::newConstructorForSerialization. *\/\n-\n-class SerializationConstructorAccessorGenerator extends AccessorGenerator {\n-\n-    private static final short NUM_BASE_CPOOL_ENTRIES   = (short) 12;\n-    \/\/ One for invoke() plus one for constructor\n-    private static final short NUM_METHODS              = (short) 2;\n-    \/\/ Only used if forSerialization is true\n-    private static final short NUM_SERIALIZATION_CPOOL_ENTRIES = (short) 2;\n-\n-    private static volatile int methodSymnum;\n-    private static volatile int constructorSymnum;\n-    private static volatile int serializationConstructorSymnum;\n-\n-    private Class<?>   declaringClass;\n-    private Class<?>[] parameterTypes;\n-    private Class<?>   returnType;\n-    private boolean    isConstructor;\n-    private boolean    forSerialization;\n-\n-    private short targetMethodRef;\n-    private short invokeIdx;\n-    private short invokeDescriptorIdx;\n-    \/\/ Constant pool index of CONSTANT_Class_info for first\n-    \/\/ non-primitive parameter type. Should be incremented by 2.\n-    private short nonPrimitiveParametersBaseIdx;\n-\n-    SerializationConstructorAccessorGenerator() {\n-    }\n-\n-    \/** This routine is not thread-safe *\/\n-    public SerializationConstructorAccessorImpl\n-    generateSerializationConstructor(Class<?> declaringClass,\n-                                     Class<?>[] parameterTypes,\n-                                     int modifiers,\n-                                     Class<?> targetConstructorClass)\n-    {\n-        return (SerializationConstructorAccessorImpl)\n-            generate(declaringClass,\n-                     \"<init>\",\n-                     parameterTypes,\n-                     Void.TYPE,\n-                     modifiers,\n-                     true,\n-                     true,\n-                     targetConstructorClass);\n-    }\n-\n-    \/** This routine is not thread-safe *\/\n-    @SuppressWarnings(\"removal\")\n-    private MagicAccessorImpl generate(final Class<?> declaringClass,\n-                                       String name,\n-                                       Class<?>[] parameterTypes,\n-                                       Class<?>   returnType,\n-                                       int modifiers,\n-                                       boolean isConstructor,\n-                                       boolean forSerialization,\n-                                       Class<?> serializationTargetClass)\n-    {\n-        ByteVector vec = ByteVectorFactory.create();\n-        asm = new ClassFileAssembler(vec);\n-        this.declaringClass = declaringClass;\n-        this.parameterTypes = parameterTypes;\n-        this.returnType = returnType;\n-        this.modifiers = modifiers;\n-        this.isConstructor = isConstructor;\n-        this.forSerialization = forSerialization;\n-\n-        asm.emitMagicAndVersion();\n-\n-        \/\/ Constant pool entries:\n-        \/\/ ( * = Boxing information: optional)\n-        \/\/ (+  = Shared entries provided by AccessorGenerator)\n-        \/\/ (^  = Only present if generating SerializationConstructorAccessor)\n-        \/\/     [UTF-8] [This class's name]\n-        \/\/     [CONSTANT_Class_info] for above\n-        \/\/     [UTF-8] \"jdk\/internal\/reflect\/{MethodAccessorImpl,ConstructorAccessorImpl,SerializationConstructorAccessorImpl}\"\n-        \/\/     [CONSTANT_Class_info] for above\n-        \/\/     [UTF-8] [Target class's name]\n-        \/\/     [CONSTANT_Class_info] for above\n-        \/\/ ^   [UTF-8] [Serialization: Class's name in which to invoke constructor]\n-        \/\/ ^   [CONSTANT_Class_info] for above\n-        \/\/     [UTF-8] target method or constructor name\n-        \/\/     [UTF-8] target method or constructor signature\n-        \/\/     [CONSTANT_NameAndType_info] for above\n-        \/\/     [CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info] for target method\n-        \/\/     [UTF-8] \"invoke\" or \"newInstance\"\n-        \/\/     [UTF-8] invoke or newInstance descriptor\n-        \/\/     [UTF-8] descriptor for type of non-primitive parameter 1\n-        \/\/     [CONSTANT_Class_info] for type of non-primitive parameter 1\n-        \/\/     ...\n-        \/\/     [UTF-8] descriptor for type of non-primitive parameter n\n-        \/\/     [CONSTANT_Class_info] for type of non-primitive parameter n\n-        \/\/ +   [UTF-8] \"java\/lang\/Exception\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"java\/lang\/ClassCastException\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"java\/lang\/NullPointerException\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"java\/lang\/IllegalArgumentException\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"java\/lang\/InvocationTargetException\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"<init>\"\n-        \/\/ +   [UTF-8] \"()V\"\n-        \/\/ +   [CONSTANT_NameAndType_info] for above\n-        \/\/ +   [CONSTANT_Methodref_info] for NullPointerException's constructor\n-        \/\/ +   [CONSTANT_Methodref_info] for IllegalArgumentException's constructor\n-        \/\/ +   [UTF-8] \"(Ljava\/lang\/String;)V\"\n-        \/\/ +   [CONSTANT_NameAndType_info] for \"<init>(Ljava\/lang\/String;)V\"\n-        \/\/ +   [CONSTANT_Methodref_info] for IllegalArgumentException's constructor taking a String\n-        \/\/ +   [UTF-8] \"(Ljava\/lang\/Throwable;)V\"\n-        \/\/ +   [CONSTANT_NameAndType_info] for \"<init>(Ljava\/lang\/Throwable;)V\"\n-        \/\/ +   [CONSTANT_Methodref_info] for InvocationTargetException's constructor\n-        \/\/ +   [CONSTANT_Methodref_info] for \"super()\"\n-        \/\/ +   [UTF-8] \"java\/lang\/Object\"\n-        \/\/ +   [CONSTANT_Class_info] for above\n-        \/\/ +   [UTF-8] \"toString\"\n-        \/\/ +   [UTF-8] \"()Ljava\/lang\/String;\"\n-        \/\/ +   [CONSTANT_NameAndType_info] for \"toString()Ljava\/lang\/String;\"\n-        \/\/ +   [CONSTANT_Methodref_info] for Object's toString method\n-        \/\/ +   [UTF-8] \"Code\"\n-        \/\/ +   [UTF-8] \"Exceptions\"\n-        \/\/  *  [UTF-8] \"java\/lang\/Boolean\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(Z)V\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"booleanValue\"\n-        \/\/  *  [UTF-8] \"()Z\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Byte\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(B)V\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"byteValue\"\n-        \/\/  *  [UTF-8] \"()B\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Character\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(C)V\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"charValue\"\n-        \/\/  *  [UTF-8] \"()C\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Double\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(D)V\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"doubleValue\"\n-        \/\/  *  [UTF-8] \"()D\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Float\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(F)V\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"floatValue\"\n-        \/\/  *  [UTF-8] \"()F\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Integer\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(I)V\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"intValue\"\n-        \/\/  *  [UTF-8] \"()I\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Long\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(J)V\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"longValue\"\n-        \/\/  *  [UTF-8] \"()J\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"java\/lang\/Short\"\n-        \/\/  *  [CONSTANT_Class_info] for above\n-        \/\/  *  [UTF-8] \"(S)V\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-        \/\/  *  [UTF-8] \"shortValue\"\n-        \/\/  *  [UTF-8] \"()S\"\n-        \/\/  *  [CONSTANT_NameAndType_info] for above\n-        \/\/  *  [CONSTANT_Methodref_info] for above\n-\n-        short numCPEntries = NUM_BASE_CPOOL_ENTRIES + NUM_COMMON_CPOOL_ENTRIES;\n-        boolean usesPrimitives = usesPrimitiveTypes();\n-        if (usesPrimitives) {\n-            numCPEntries += NUM_BOXING_CPOOL_ENTRIES;\n-        }\n-        if (forSerialization) {\n-            numCPEntries += NUM_SERIALIZATION_CPOOL_ENTRIES;\n-        }\n-\n-        \/\/ Add in variable-length number of entries to be able to describe\n-        \/\/ non-primitive parameter types and checked exceptions.\n-        numCPEntries += (short) (2 * numNonPrimitiveParameterTypes());\n-\n-        asm.emitShort(add(numCPEntries, S1));\n-\n-        final String generatedName = generateName(isConstructor, forSerialization);\n-        asm.emitConstantPoolUTF8(generatedName);\n-        asm.emitConstantPoolClass(asm.cpi());\n-        thisClass = asm.cpi();\n-        if (isConstructor) {\n-            if (forSerialization) {\n-                asm.emitConstantPoolUTF8\n-                    (\"jdk\/internal\/reflect\/SerializationConstructorAccessorImpl\");\n-            } else {\n-                asm.emitConstantPoolUTF8(\"jdk\/internal\/reflect\/ConstructorAccessorImpl\");\n-            }\n-        } else {\n-            asm.emitConstantPoolUTF8(\"jdk\/internal\/reflect\/MethodAccessorImpl\");\n-        }\n-        asm.emitConstantPoolClass(asm.cpi());\n-        superClass = asm.cpi();\n-        asm.emitConstantPoolUTF8(getClassName(declaringClass, false));\n-        asm.emitConstantPoolClass(asm.cpi());\n-        targetClass = asm.cpi();\n-        short serializationTargetClassIdx = (short) 0;\n-        if (forSerialization) {\n-            asm.emitConstantPoolUTF8(getClassName(serializationTargetClass, false));\n-            asm.emitConstantPoolClass(asm.cpi());\n-            serializationTargetClassIdx = asm.cpi();\n-        }\n-        asm.emitConstantPoolUTF8(name);\n-        asm.emitConstantPoolUTF8(buildInternalSignature());\n-        asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());\n-        if (isInterface()) {\n-            asm.emitConstantPoolInterfaceMethodref(targetClass, asm.cpi());\n-        } else {\n-            if (forSerialization) {\n-                asm.emitConstantPoolMethodref(serializationTargetClassIdx, asm.cpi());\n-            } else {\n-                asm.emitConstantPoolMethodref(targetClass, asm.cpi());\n-            }\n-        }\n-        targetMethodRef = asm.cpi();\n-        if (isConstructor) {\n-            asm.emitConstantPoolUTF8(\"newInstance\");\n-        } else {\n-            asm.emitConstantPoolUTF8(\"invoke\");\n-        }\n-        invokeIdx = asm.cpi();\n-        if (isConstructor) {\n-            asm.emitConstantPoolUTF8(\"([Ljava\/lang\/Object;)Ljava\/lang\/Object;\");\n-        } else {\n-            asm.emitConstantPoolUTF8\n-                (\"(Ljava\/lang\/Object;[Ljava\/lang\/Object;)Ljava\/lang\/Object;\");\n-        }\n-        invokeDescriptorIdx = asm.cpi();\n-\n-        \/\/ Output class information for non-primitive parameter types\n-        nonPrimitiveParametersBaseIdx = add(asm.cpi(), S2);\n-        for (int i = 0; i < parameterTypes.length; i++) {\n-            Class<?> c = parameterTypes[i];\n-            if (!isPrimitive(c)) {\n-                asm.emitConstantPoolUTF8(getClassName(c, false));\n-                asm.emitConstantPoolClass(asm.cpi());\n-            }\n-        }\n-\n-        \/\/ Entries common to FieldAccessor, MethodAccessor and ConstructorAccessor\n-        emitCommonConstantPoolEntries();\n-\n-        \/\/ Boxing entries\n-        if (usesPrimitives) {\n-            emitBoxingContantPoolEntries();\n-        }\n-\n-        if (asm.cpi() != numCPEntries) {\n-            throw new InternalError(\"Adjust this code (cpi = \" + asm.cpi() +\n-                                    \", numCPEntries = \" + numCPEntries + \")\");\n-        }\n-\n-        \/\/ Access flags\n-        asm.emitShort(ACC_PUBLIC);\n-\n-        \/\/ This class\n-        asm.emitShort(thisClass);\n-\n-        \/\/ Superclass\n-        asm.emitShort(superClass);\n-\n-        \/\/ Interfaces count and interfaces\n-        asm.emitShort(S0);\n-\n-        \/\/ Fields count and fields\n-        asm.emitShort(S0);\n-\n-        \/\/ Methods count and methods\n-        asm.emitShort(NUM_METHODS);\n-\n-        emitConstructor();\n-        emitInvoke();\n-\n-        \/\/ Additional attributes (none)\n-        asm.emitShort(S0);\n-\n-        \/\/ Load class\n-        vec.trim();\n-        final byte[] bytes = vec.getData();\n-        \/\/ Note: the class loader is the only thing that really matters\n-        \/\/ here -- it's important to get the generated code into the\n-        \/\/ same namespace as the target class. Since the generated code\n-        \/\/ is privileged anyway, the protection domain probably doesn't\n-        \/\/ matter.\n-        return AccessController.doPrivileged(\n-            new PrivilegedAction<MagicAccessorImpl>() {\n-                @SuppressWarnings(\"deprecation\") \/\/ Class.newInstance\n-                public MagicAccessorImpl run() {\n-                        try {\n-                        return (MagicAccessorImpl)\n-                        ClassDefiner.defineClass\n-                                (generatedName,\n-                                 bytes,\n-                                 0,\n-                                 bytes.length,\n-                                 declaringClass.getClassLoader()).newInstance();\n-                        } catch (InstantiationException | IllegalAccessException e) {\n-                            throw new InternalError(e);\n-                        }\n-                    }\n-                });\n-    }\n-\n-    \/** This emits the code for either invoke() or newInstance() *\/\n-    private void emitInvoke() {\n-        \/\/ NOTE that this code will only handle 65535 parameters since we\n-        \/\/ use the sipush instruction to get the array index on the\n-        \/\/ operand stack.\n-        if (parameterTypes.length > 65535) {\n-            throw new InternalError(\"Can't handle more than 65535 parameters\");\n-        }\n-\n-        \/\/ Generate code into fresh code buffer\n-        ClassFileAssembler cb = new ClassFileAssembler();\n-        if (isConstructor) {\n-            \/\/ 1 incoming argument\n-            cb.setMaxLocals(2);\n-        } else {\n-            \/\/ 2 incoming arguments\n-            cb.setMaxLocals(3);\n-        }\n-\n-        short illegalArgStartPC = 0;\n-\n-        if (isConstructor) {\n-            \/\/ Instantiate target class before continuing\n-            \/\/ new <target class type>\n-            \/\/ dup\n-            cb.opc_new(targetClass);\n-            cb.opc_dup();\n-        } else {\n-            \/\/ Get target object on operand stack if necessary.\n-\n-            \/\/ We need to do an explicit null check here; we won't see\n-            \/\/ NullPointerExceptions from the invoke bytecode, since it's\n-            \/\/ covered by an exception handler.\n-            if (!isStatic()) {\n-                \/\/ aload_1\n-                \/\/ ifnonnull <checkcast label>\n-                \/\/ new <NullPointerException>\n-                \/\/ dup\n-                \/\/ invokespecial <NullPointerException ctor>\n-                \/\/ athrow\n-                \/\/ <checkcast label:>\n-                \/\/ aload_1\n-                \/\/ checkcast <target class's type>\n-                cb.opc_aload_1();\n-                Label l = new Label();\n-                cb.opc_ifnonnull(l);\n-                cb.opc_new(nullPointerClass);\n-                cb.opc_dup();\n-                cb.opc_invokespecial(nullPointerCtorIdx, 0, 0);\n-                cb.opc_athrow();\n-                l.bind();\n-                illegalArgStartPC = cb.getLength();\n-                cb.opc_aload_1();\n-                cb.opc_checkcast(targetClass);\n-            }\n-        }\n-\n-        \/\/ Have to check length of incoming array and throw\n-        \/\/ IllegalArgumentException if not correct. A concession to the\n-        \/\/ JCK (isn't clearly specified in the spec): we allow null in the\n-        \/\/ case where the argument list is zero length.\n-        \/\/ if no-arg:\n-        \/\/   aload_2 | aload_1 (Method | Constructor)\n-        \/\/   ifnull <success label>\n-        \/\/ aload_2 | aload_1\n-        \/\/ arraylength\n-        \/\/ sipush <num parameter types>\n-        \/\/ if_icmpeq <success label>\n-        \/\/ new <IllegalArgumentException>\n-        \/\/ dup\n-        \/\/ invokespecial <IllegalArgumentException ctor>\n-        \/\/ athrow\n-        \/\/ <success label:>\n-        Label successLabel = new Label();\n-        if (parameterTypes.length == 0) {\n-            if (isConstructor) {\n-                cb.opc_aload_1();\n-            } else {\n-                cb.opc_aload_2();\n-            }\n-            cb.opc_ifnull(successLabel);\n-        }\n-        if (isConstructor) {\n-            cb.opc_aload_1();\n-        } else {\n-            cb.opc_aload_2();\n-        }\n-        cb.opc_arraylength();\n-        cb.opc_sipush((short) parameterTypes.length);\n-        cb.opc_if_icmpeq(successLabel);\n-        cb.opc_new(illegalArgumentClass);\n-        cb.opc_dup();\n-        cb.opc_invokespecial(illegalArgumentCtorIdx, 0, 0);\n-        cb.opc_athrow();\n-        successLabel.bind();\n-\n-        \/\/ Iterate through incoming actual parameters, ensuring that each\n-        \/\/ is compatible with the formal parameter type, and pushing the\n-        \/\/ actual on the operand stack (unboxing and widening if necessary).\n-\n-        short paramTypeCPIdx = nonPrimitiveParametersBaseIdx;\n-        Label nextParamLabel = null;\n-        byte count = 1; \/\/ both invokeinterface opcode's \"count\" as well as\n-        \/\/ num args of other invoke bytecodes\n-        for (int i = 0; i < parameterTypes.length; i++) {\n-            Class<?> paramType = parameterTypes[i];\n-            count += (byte) typeSizeInStackSlots(paramType);\n-            if (nextParamLabel != null) {\n-                nextParamLabel.bind();\n-                nextParamLabel = null;\n-            }\n-            \/\/ aload_2 | aload_1\n-            \/\/ sipush <index>\n-            \/\/ aaload\n-            if (isConstructor) {\n-                cb.opc_aload_1();\n-            } else {\n-                cb.opc_aload_2();\n-            }\n-            cb.opc_sipush((short) i);\n-            cb.opc_aaload();\n-            if (isPrimitive(paramType)) {\n-                \/\/ Unboxing code.\n-                \/\/ Put parameter into temporary local variable\n-                \/\/ astore_3 | astore_2\n-                if (isConstructor) {\n-                    cb.opc_astore_2();\n-                } else {\n-                    cb.opc_astore_3();\n-                }\n-\n-                \/\/ repeat for all possible widening conversions:\n-                \/\/   aload_3 | aload_2\n-                \/\/   instanceof <primitive boxing type>\n-                \/\/   ifeq <next unboxing label>\n-                \/\/   aload_3 | aload_2\n-                \/\/   checkcast <primitive boxing type> \/\/ Note: this is \"redundant\",\n-                \/\/                                     \/\/ but necessary for the verifier\n-                \/\/   invokevirtual <unboxing method>\n-                \/\/   <widening conversion bytecode, if necessary>\n-                \/\/   goto <next parameter label>\n-                \/\/ <next unboxing label:> ...\n-                \/\/ last unboxing label:\n-                \/\/   new <IllegalArgumentException>\n-                \/\/   dup\n-                \/\/   invokespecial <IllegalArgumentException ctor>\n-                \/\/   athrow\n-\n-                Label l = null; \/\/ unboxing label\n-                nextParamLabel = new Label();\n-\n-                for (int j = 0; j < primitiveTypes.length; j++) {\n-                    Class<?> c = primitiveTypes[j];\n-                    if (canWidenTo(c, paramType)) {\n-                        if (l != null) {\n-                            l.bind();\n-                        }\n-                        \/\/ Emit checking and unboxing code for this type\n-                        if (isConstructor) {\n-                            cb.opc_aload_2();\n-                        } else {\n-                            cb.opc_aload_3();\n-                        }\n-                        cb.opc_instanceof(indexForPrimitiveType(c));\n-                        l = new Label();\n-                        cb.opc_ifeq(l);\n-                        if (isConstructor) {\n-                            cb.opc_aload_2();\n-                        } else {\n-                            cb.opc_aload_3();\n-                        }\n-                        cb.opc_checkcast(indexForPrimitiveType(c));\n-                        cb.opc_invokevirtual(unboxingMethodForPrimitiveType(c),\n-                                             0,\n-                                             typeSizeInStackSlots(c));\n-                        emitWideningBytecodeForPrimitiveConversion(cb,\n-                                                                   c,\n-                                                                   paramType);\n-                        cb.opc_goto(nextParamLabel);\n-                    }\n-                }\n-\n-                if (l == null) {\n-                    throw new InternalError\n-                        (\"Must have found at least identity conversion\");\n-                }\n-\n-                \/\/ Fell through; given object is null or invalid. According to\n-                \/\/ the spec, we can throw IllegalArgumentException for both of\n-                \/\/ these cases.\n-\n-                l.bind();\n-                cb.opc_new(illegalArgumentClass);\n-                cb.opc_dup();\n-                cb.opc_invokespecial(illegalArgumentCtorIdx, 0, 0);\n-                cb.opc_athrow();\n-            } else {\n-                \/\/ Emit appropriate checkcast\n-                cb.opc_checkcast(paramTypeCPIdx);\n-                paramTypeCPIdx = add(paramTypeCPIdx, S2);\n-                \/\/ Fall through to next argument\n-            }\n-        }\n-        \/\/ Bind last goto if present\n-        if (nextParamLabel != null) {\n-            nextParamLabel.bind();\n-        }\n-\n-        short invokeStartPC = cb.getLength();\n-\n-        \/\/ OK, ready to perform the invocation.\n-        if (isConstructor) {\n-            cb.opc_invokespecial(targetMethodRef, count, 0);\n-        } else {\n-            if (isStatic()) {\n-                cb.opc_invokestatic(targetMethodRef,\n-                                    count,\n-                                    typeSizeInStackSlots(returnType));\n-            } else {\n-                if (isInterface()) {\n-                    cb.opc_invokeinterface(targetMethodRef,\n-                                           count,\n-                                           count,\n-                                           typeSizeInStackSlots(returnType));\n-                } else {\n-                    cb.opc_invokevirtual(targetMethodRef,\n-                                         count,\n-                                         typeSizeInStackSlots(returnType));\n-                }\n-            }\n-        }\n-\n-        short invokeEndPC = cb.getLength();\n-\n-        if (!isConstructor) {\n-            \/\/ Box return value if necessary\n-            if (isPrimitive(returnType)) {\n-                cb.opc_invokestatic(boxingMethodForPrimitiveType(returnType),\n-                                    typeSizeInStackSlots(returnType),\n-                                    0);\n-            } else if (returnType == Void.TYPE) {\n-                cb.opc_aconst_null();\n-            }\n-        }\n-        cb.opc_areturn();\n-\n-        \/\/ We generate two exception handlers; one which is responsible\n-        \/\/ for catching ClassCastException and NullPointerException and\n-        \/\/ throwing IllegalArgumentException, and the other which catches\n-        \/\/ all java\/lang\/Throwable objects thrown from the target method\n-        \/\/ and wraps them in InvocationTargetExceptions.\n-\n-        short classCastHandler = cb.getLength();\n-\n-        \/\/ ClassCast, etc. exception handler\n-        cb.setStack(1);\n-        cb.opc_invokespecial(toStringIdx, 0, 1);\n-        cb.opc_new(illegalArgumentClass);\n-        cb.opc_dup_x1();\n-        cb.opc_swap();\n-        cb.opc_invokespecial(illegalArgumentStringCtorIdx, 1, 0);\n-        cb.opc_athrow();\n-\n-        short invocationTargetHandler = cb.getLength();\n-\n-        \/\/ InvocationTargetException exception handler\n-        cb.setStack(1);\n-        cb.opc_new(invocationTargetClass);\n-        cb.opc_dup_x1();\n-        cb.opc_swap();\n-        cb.opc_invokespecial(invocationTargetCtorIdx, 1, 0);\n-        cb.opc_athrow();\n-\n-        \/\/ Generate exception table. We cover the entire code sequence\n-        \/\/ with an exception handler which catches ClassCastException and\n-        \/\/ converts it into an IllegalArgumentException.\n-\n-        ClassFileAssembler exc = new ClassFileAssembler();\n-\n-        exc.emitShort(illegalArgStartPC);       \/\/ start PC\n-        exc.emitShort(invokeStartPC);           \/\/ end PC\n-        exc.emitShort(classCastHandler);        \/\/ handler PC\n-        exc.emitShort(classCastClass);          \/\/ catch type\n-\n-        exc.emitShort(illegalArgStartPC);       \/\/ start PC\n-        exc.emitShort(invokeStartPC);           \/\/ end PC\n-        exc.emitShort(classCastHandler);        \/\/ handler PC\n-        exc.emitShort(nullPointerClass);        \/\/ catch type\n-\n-        exc.emitShort(invokeStartPC);           \/\/ start PC\n-        exc.emitShort(invokeEndPC);             \/\/ end PC\n-        exc.emitShort(invocationTargetHandler); \/\/ handler PC\n-        exc.emitShort(throwableClass);          \/\/ catch type\n-\n-        emitMethod(invokeIdx, cb.getMaxLocals(), cb, exc,\n-                   new short[] { invocationTargetClass });\n-    }\n-\n-    private boolean usesPrimitiveTypes() {\n-        \/\/ We need to emit boxing\/unboxing constant pool information if\n-        \/\/ the method takes a primitive type for any of its parameters or\n-        \/\/ returns a primitive value (except void)\n-        if (returnType.isPrimitive()) {\n-            return true;\n-        }\n-        for (int i = 0; i < parameterTypes.length; i++) {\n-            if (parameterTypes[i].isPrimitive()) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    private int numNonPrimitiveParameterTypes() {\n-        int num = 0;\n-        for (int i = 0; i < parameterTypes.length; i++) {\n-            if (!parameterTypes[i].isPrimitive()) {\n-                ++num;\n-            }\n-        }\n-        return num;\n-    }\n-\n-    private boolean isInterface() {\n-        return declaringClass.isInterface();\n-    }\n-\n-    private String buildInternalSignature() {\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(\"(\");\n-        for (int i = 0; i < parameterTypes.length; i++) {\n-            sb.append(getClassName(parameterTypes[i], true));\n-        }\n-        sb.append(\")\");\n-        sb.append(getClassName(returnType, true));\n-        return sb.toString();\n-    }\n-\n-    private static synchronized String generateName(boolean isConstructor,\n-                                                    boolean forSerialization)\n-    {\n-        if (isConstructor) {\n-            if (forSerialization) {\n-                int num = ++serializationConstructorSymnum;\n-                return \"jdk\/internal\/reflect\/GeneratedSerializationConstructorAccessor\" + num;\n-            } else {\n-                int num = ++constructorSymnum;\n-                return \"jdk\/internal\/reflect\/GeneratedConstructorAccessor\" + num;\n-            }\n-        } else {\n-            int num = ++methodSymnum;\n-            return \"jdk\/internal\/reflect\/GeneratedMethodAccessor\" + num;\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/SerializationConstructorAccessorGenerator.java","additions":0,"deletions":725,"binary":false,"changes":725,"status":"deleted"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-\/** <P> Java serialization (in java.io) expects to be able to\n-    instantiate a class and invoke a no-arg constructor of that\n-    class's first non-Serializable superclass. This is not a valid\n-    operation according to the VM specification; one can not (for\n-    classes A and B, where B is a subclass of A) write \"new B;\n-    invokespecial A()\" without getting a verification error. <\/P>\n-\n-    <P> In all other respects, the bytecode-based reflection framework\n-    can be reused for this purpose. This marker class was originally\n-    known to the VM and verification disabled for it and all\n-    subclasses, but the bug fix for 4486457 necessitated disabling\n-    verification for all of the dynamically-generated bytecodes\n-    associated with reflection. This class has been left in place to\n-    make future debugging easier. <\/P> *\/\n-\n-abstract class SerializationConstructorAccessorImpl\n-    extends ConstructorAccessorImpl {\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/SerializationConstructorAccessorImpl.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,1 +101,18 @@\n-        USER_SCRIPT = getProperty(props, \"user.script\", \"\");\n+        \/\/ for compatibility, check for old user.region property\n+        USER_REGION = getProperty(props, \"user.region\", \"\");\n+        if (!USER_REGION.isEmpty()) {\n+            \/\/ region can be of form country, country_variant, or _variant\n+            int i = USER_REGION.indexOf('_');\n+            if (i >= 0) {\n+                USER_COUNTRY = USER_REGION.substring(0, i);\n+                USER_VARIANT = USER_REGION.substring(i + 1);\n+            } else {\n+                USER_COUNTRY = USER_REGION;\n+                USER_VARIANT = \"\";\n+            }\n+            USER_SCRIPT = \"\";\n+        } else {\n+            USER_SCRIPT = getProperty(props, \"user.script\", \"\");\n+            USER_COUNTRY = getProperty(props, \"user.country\", \"\");\n+            USER_VARIANT = getProperty(props, \"user.variant\", \"\");\n+        }\n@@ -104,1 +121,0 @@\n-        USER_COUNTRY = getProperty(props, \"user.country\", \"\");\n@@ -107,1 +123,0 @@\n-        USER_VARIANT = getProperty(props, \"user.variant\", \"\");\n@@ -113,1 +128,0 @@\n-        USER_REGION = getProperty(props, \"user.region\", \"\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/StaticProperty.java","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -56,0 +57,4 @@\n+    \/\/ if isOther is true, then the file being read is not a regular file,\n+    \/\/ nor a directory, nor a symbolic link, hence possibly not seekable\n+    private @Stable Boolean isOther;\n+\n@@ -63,0 +68,11 @@\n+    private boolean isOther() throws IOException {\n+        Boolean isOther = this.isOther;\n+        if (isOther == null) {\n+            if (ch instanceof FileChannelImpl fci)\n+                this.isOther = isOther = fci.isOther();\n+            else\n+                this.isOther = isOther = Boolean.FALSE;\n+        }\n+        return isOther;\n+    }\n+\n@@ -108,1 +124,2 @@\n-        if (!(ch instanceof SeekableByteChannel sbc))\n+        if (!(ch instanceof SeekableByteChannel sbc) ||\n+             (ch instanceof FileChannelImpl fci && isOther()))\n@@ -159,1 +176,2 @@\n-        if (!(ch instanceof SeekableByteChannel sbc))\n+        if (!(ch instanceof SeekableByteChannel sbc) ||\n+             (ch instanceof FileChannelImpl fci && isOther()))\n@@ -195,1 +213,3 @@\n-        if (ch instanceof SeekableByteChannel sbc) {\n+        if (ch instanceof FileChannelImpl fci) {\n+            return fci.available();\n+        } else if (ch instanceof SeekableByteChannel sbc) {\n@@ -205,1 +225,2 @@\n-        if (ch instanceof SeekableByteChannel sbc) {\n+        if (ch instanceof SeekableByteChannel sbc &&\n+            !(ch instanceof FileChannelImpl fci && isOther())) {\n@@ -227,1 +248,2 @@\n-        if (ch instanceof FileChannel fc) {\n+        if (ch instanceof FileChannel fc &&\n+            !(fc instanceof FileChannelImpl fci && isOther())) {\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ChannelInputStream.java","additions":28,"deletions":6,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -457,0 +457,1 @@\n+\n@@ -532,0 +533,43 @@\n+    \/**\n+     * Returns an estimate of the number of remaining bytes that can be read\n+     * from this channel without blocking.\n+     *\/\n+    int available() throws IOException {\n+        ensureOpen();\n+        synchronized (positionLock) {\n+            int a = -1;\n+            int ti = -1;\n+            try {\n+                beginBlocking();\n+                ti = threads.add();\n+                if (!isOpen())\n+                    return -1;\n+                a = nd.available(fd);\n+            } finally {\n+                threads.remove(ti);\n+                endBlocking(a > -1);\n+            }\n+            return a;\n+        }\n+    }\n+\n+    \/**\n+     * Tells whether the channel represents something other than a regular\n+     * file, directory, or symbolic link.\n+     *\/\n+    boolean isOther() throws IOException {\n+        ensureOpen();\n+        int ti = -1;\n+        Boolean isOther = null;\n+        try {\n+            beginBlocking();\n+            ti = threads.add();\n+            if (!isOpen())\n+                return false;\n+            return isOther = nd.isOther(fd);\n+        } finally {\n+            threads.remove(ti);\n+            endBlocking(isOther != null);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,4 @@\n+    abstract int available(FileDescriptor fd) throws IOException;\n+\n+    abstract boolean isOther(FileDescriptor fd) throws IOException;\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileDispatcher.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -283,1 +283,1 @@\n-                                            X500Principal prevCertIssuer) {\n+                X500Principal prevCertIssuer) throws CRLException {\n@@ -289,2 +289,8 @@\n-                X500Name issuerDN = (X500Name) names.get(0).getName();\n-                return issuerDN.asX500Principal();\n+                Iterator<GeneralName> itr = names.iterator();\n+                while (itr.hasNext()) {\n+                    if (itr.next().getName() instanceof X500Name issuerDN) {\n+                        return issuerDN.asX500Principal();\n+                    }\n+                }\n+                throw new CRLException(\"Parsing error: CertificateIssuer \"\n+                         + \"field does not contain an X.500 DN\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509CRLImpl.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.time.ZoneId;\n@@ -46,1 +47,0 @@\n-import java.util.Locale;\n@@ -53,1 +53,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -68,4 +67,2 @@\n-        int len = regions.length + oldMappings.length;\n-        if (!USE_OLDMAPPING) {\n-            len += 3;    \/\/ EST\/HST\/MST not in tzdb.dat\n-        }\n+        var shortIDs = ZoneId.SHORT_IDS.keySet();\n+        int len = regions.length + shortIDs.size();\n@@ -74,7 +71,2 @@\n-        if (!USE_OLDMAPPING) {\n-            ids[i++] = \"EST\";\n-            ids[i++] = \"HST\";\n-            ids[i++] = \"MST\";\n-        }\n-        for (int j = 0; j < oldMappings.length; j++) {\n-            ids[i++] = oldMappings[j][0];\n+        for (var id : shortIDs) {\n+            ids[i++] = id;\n@@ -219,31 +211,0 @@\n-    \/\/ Flag for supporting JDK backward compatible IDs, such as \"EST\".\n-    private static final boolean USE_OLDMAPPING;\n-\n-    private static final String[][] oldMappings = new String[][] {\n-        { \"ACT\", \"Australia\/Darwin\" },\n-        { \"AET\", \"Australia\/Sydney\" },\n-        { \"AGT\", \"America\/Argentina\/Buenos_Aires\" },\n-        { \"ART\", \"Africa\/Cairo\" },\n-        { \"AST\", \"America\/Anchorage\" },\n-        { \"BET\", \"America\/Sao_Paulo\" },\n-        { \"BST\", \"Asia\/Dhaka\" },\n-        { \"CAT\", \"Africa\/Harare\" },\n-        { \"CNT\", \"America\/St_Johns\" },\n-        { \"CST\", \"America\/Chicago\" },\n-        { \"CTT\", \"Asia\/Shanghai\" },\n-        { \"EAT\", \"Africa\/Addis_Ababa\" },\n-        { \"ECT\", \"Europe\/Paris\" },\n-        { \"IET\", \"America\/Indiana\/Indianapolis\" },\n-        { \"IST\", \"Asia\/Kolkata\" },\n-        { \"JST\", \"Asia\/Tokyo\" },\n-        { \"MIT\", \"Pacific\/Apia\" },\n-        { \"NET\", \"Asia\/Yerevan\" },\n-        { \"NST\", \"Pacific\/Auckland\" },\n-        { \"PLT\", \"Asia\/Karachi\" },\n-        { \"PNT\", \"America\/Phoenix\" },\n-        { \"PRT\", \"America\/Puerto_Rico\" },\n-        { \"PST\", \"America\/Los_Angeles\" },\n-        { \"SST\", \"Pacific\/Guadalcanal\" },\n-        { \"VST\", \"Asia\/Ho_Chi_Minh\" },\n-    };\n-\n@@ -251,4 +212,0 @@\n-        String oldmapping = GetPropertyAction\n-                .privilegedGetProperty(\"sun.timezone.ids.oldmapping\", \"false\")\n-                .toLowerCase(Locale.ROOT);\n-        USE_OLDMAPPING = (oldmapping.equals(\"yes\") || oldmapping.equals(\"true\"));\n@@ -277,18 +234,0 @@\n-    private static void addOldMapping() {\n-        for (String[] alias : oldMappings) {\n-            aliases.put(alias[0], alias[1]);\n-        }\n-        if (USE_OLDMAPPING) {\n-            aliases.put(\"EST\", \"America\/New_York\");\n-            aliases.put(\"MST\", \"America\/Denver\");\n-        } else {\n-            aliases.put(\"EST\", \"America\/Panama\");\n-            aliases.put(\"MST\", \"America\/Phoenix\");\n-        }\n-        aliases.put(\"HST\", \"Pacific\/Honolulu\");\n-    }\n-\n-    public static boolean useOldMapping() {\n-       return USE_OLDMAPPING;\n-    }\n-\n@@ -353,1 +292,1 @@\n-        addOldMapping();\n+        aliases.putAll(ZoneId.SHORT_IDS);\n","filename":"src\/java.base\/share\/classes\/sun\/util\/calendar\/ZoneInfoFile.java","additions":6,"deletions":67,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -170,4 +170,0 @@\n-grant codeBase \"jrt:\/jdk.jsobject\" {\n-    permission java.security.AllPermission;\n-};\n-\n","filename":"src\/java.base\/share\/lib\/security\/default.policy","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,0 +96,8 @@\n+    int available(FileDescriptor fd) throws IOException {\n+        return available0(fd);\n+    }\n+\n+    boolean isOther(FileDescriptor fd) throws IOException {\n+        return isOther0(fd);\n+    }\n+\n@@ -199,0 +207,4 @@\n+    static native int available0(FileDescriptor fd) throws IOException;\n+\n+    static native boolean isOther0(FileDescriptor fd) throws IOException;\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/UnixFileDispatcherImpl.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,6 +39,0 @@\n-\n-JNIEXPORT jstring JNICALL\n-Java_java_io_Console_encoding(JNIEnv *env, jclass cls)\n-{\n-    return NULL;\n-}\n","filename":"src\/java.base\/unix\/native\/libjava\/Console_md.c","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include <sys\/ioctl.h>\n@@ -44,0 +45,1 @@\n+#include \"java_lang_Integer.h\"\n@@ -46,0 +48,1 @@\n+#include \"io_util_md.h\"\n@@ -181,0 +184,51 @@\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_available0(JNIEnv *env, jobject this, jobject fdo)\n+{\n+    jint fd = fdval(env, fdo);\n+    struct stat fbuf;\n+    jlong size = -1;\n+\n+    if (fstat(fd, &fbuf) != -1) {\n+        int mode = fbuf.st_mode;\n+        if (S_ISCHR(mode) || S_ISFIFO(mode) || S_ISSOCK(mode)) {\n+            int n = ioctl(fd, FIONREAD, &n);\n+            if (n >= 0) {\n+                return n;\n+            }\n+        } else if (S_ISREG(mode)) {\n+            size = fbuf.st_size;\n+        }\n+    }\n+\n+    jlong position;\n+    if ((position = lseek(fd, 0, SEEK_CUR)) == -1) {\n+        return 0;\n+    }\n+\n+    if (size < position) {\n+        if ((size = lseek(fd, 0, SEEK_END)) == -1)\n+            return 0;\n+        else if (lseek(fd, position, SEEK_SET) == -1)\n+            return 0;\n+    }\n+\n+    jlong available = size - position;\n+    return available > java_lang_Integer_MAX_VALUE ?\n+        java_lang_Integer_MAX_VALUE : (jint)available;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_isOther0(JNIEnv *env, jobject this, jobject fdo)\n+{\n+    jint fd = fdval(env, fdo);\n+    struct stat fbuf;\n+\n+    if (fstat(fd, &fbuf) == -1)\n+        handle(env, -1, \"isOther failed\");\n+\n+    if (S_ISREG(fbuf.st_mode) || S_ISDIR(fbuf.st_mode) || S_ISLNK(fbuf.st_mode))\n+        return JNI_FALSE;\n+\n+    return JNI_TRUE;\n+}\n+\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/UnixFileDispatcherImpl.c","additions":54,"deletions":0,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,0 +104,8 @@\n+    int available(FileDescriptor fd) throws IOException {\n+        return available0(fd);\n+    }\n+\n+    boolean isOther(FileDescriptor fd) throws IOException {\n+        return isOther0(fd);\n+    }\n+\n@@ -225,0 +233,4 @@\n+\n+    static native int available0(FileDescriptor fd) throws IOException;\n+\n+    static native boolean isOther0(FileDescriptor fd) throws IOException;\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/FileDispatcherImpl.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,14 +52,0 @@\n-\n-JNIEXPORT jstring JNICALL\n-Java_java_io_Console_encoding(JNIEnv *env, jclass cls)\n-{\n-    char buf[64];\n-    int cp = GetConsoleCP();\n-    if (cp >= 874 && cp <= 950)\n-        snprintf(buf, sizeof(buf), \"ms%d\", cp);\n-    else if (cp == 65001)\n-        snprintf(buf, sizeof(buf), \"UTF-8\");\n-    else\n-        snprintf(buf, sizeof(buf), \"cp%d\", cp);\n-    return JNU_NewStringPlatform(env, buf);\n-}\n","filename":"src\/java.base\/windows\/native\/libjava\/Console_md.c","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include <winioctl.h>\n@@ -36,0 +37,1 @@\n+#include \"io_util_md.h\"\n@@ -395,0 +397,69 @@\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_available0(JNIEnv *env, jobject this, jobject fdo)\n+{\n+    HANDLE handle = (HANDLE)(handleval(env, fdo));\n+    DWORD type = GetFileType(handle);\n+    jlong available = 0;\n+\n+    \/\/ Calculate the number of bytes available for a regular file,\n+    \/\/ and return the default (zero) for other types.\n+    if (type == FILE_TYPE_DISK) {\n+        jlong current, end;\n+        LARGE_INTEGER distance, pos, filesize;\n+        distance.QuadPart = 0;\n+        if (SetFilePointerEx(handle, distance, &pos, FILE_CURRENT) == 0) {\n+            JNU_ThrowIOExceptionWithLastError(env, \"Available failed\");\n+            return IOS_THROWN;\n+        }\n+        current = (jlong)pos.QuadPart;\n+        if (GetFileSizeEx(handle, &filesize) == 0) {\n+            JNU_ThrowIOExceptionWithLastError(env, \"Available failed\");\n+            return IOS_THROWN;\n+        }\n+        end = (jlong)filesize.QuadPart;\n+        available = end - current;\n+        if (available > java_lang_Integer_MAX_VALUE) {\n+            available = java_lang_Integer_MAX_VALUE;\n+        } else if (available < 0) {\n+            available = 0;\n+        }\n+    }\n+\n+    return (jint)available;\n+}\n+\n+\n+JNIEXPORT jboolean JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_isOther0(JNIEnv *env, jobject this, jobject fdo)\n+{\n+    HANDLE handle = (HANDLE)(handleval(env, fdo));\n+\n+    BY_HANDLE_FILE_INFORMATION finfo;\n+    if (!GetFileInformationByHandle(handle, &finfo))\n+        JNU_ThrowIOExceptionWithLastError(env, \"isOther failed\");\n+    DWORD fattr = finfo.dwFileAttributes;\n+\n+    if ((fattr & FILE_ATTRIBUTE_DEVICE) != 0)\n+        return (jboolean)JNI_TRUE;\n+\n+    if ((fattr & FILE_ATTRIBUTE_REPARSE_POINT) != 0) {\n+        int size = MAXIMUM_REPARSE_DATA_BUFFER_SIZE;\n+        void* lpOutBuffer = (void*)malloc(size*sizeof(char));\n+        if (lpOutBuffer == NULL)\n+            JNU_ThrowOutOfMemoryError(env, \"isOther failed\");\n+\n+        DWORD bytesReturned;\n+        if (!DeviceIoControl(handle, FSCTL_GET_REPARSE_POINT, NULL, 0,\n+                             lpOutBuffer, (DWORD)size, &bytesReturned, NULL)) {\n+            free(lpOutBuffer);\n+            JNU_ThrowIOExceptionWithLastError(env, \"isOther failed\");\n+        }\n+        ULONG reparseTag = (*((PULONG)lpOutBuffer));\n+        free(lpOutBuffer);\n+        return reparseTag == IO_REPARSE_TAG_SYMLINK ?\n+            (jboolean)JNI_FALSE : (jboolean)JNI_TRUE;\n+    }\n+\n+    return (jboolean)JNI_FALSE;\n+}\n+\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/FileDispatcherImpl.c","additions":72,"deletions":1,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -84,1 +84,0 @@\n-     * @param name  fully qualified package name, or an empty string for an unnamed package\n@@ -86,0 +85,1 @@\n+     * @param name  fully qualified package name, or an empty string for an unnamed package\n@@ -170,1 +170,0 @@\n-     * @param name  the canonical name\n@@ -172,0 +171,1 @@\n+     * @param name  the canonical name\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Elements.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -557,3 +557,0 @@\n-     * @param   constraints     the desired absolute position, one of {@code CENTER},\n-     *                          {@code NORTH}, {@code SOUTH},\n-     *                          {@code EAST}, {@code WEST}\n@@ -563,0 +560,3 @@\n+     * @param   constraints     the desired absolute position, one of {@code CENTER},\n+     *                          {@code NORTH}, {@code SOUTH},\n+     *                          {@code EAST}, {@code WEST}\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/BorderLayout.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -567,1 +567,0 @@\n-     * @param op the filter to be applied to the image before rendering\n@@ -570,0 +569,1 @@\n+     * @param op the filter to be applied to the image before rendering\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Graphics2D.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -502,1 +502,0 @@\n-     * @param actions                 the permitted source drag actions\n@@ -504,0 +503,1 @@\n+     * @param actions                 the permitted source drag actions\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/dnd\/DragSource.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -209,0 +209,3 @@\n+     * @param when   A long that gives the time the event occurred.\n+     *               Passing negative or zero value\n+     *               is not recommended\n@@ -213,3 +216,0 @@\n-     * @param when   A long that gives the time the event occurred.\n-     *               Passing negative or zero value\n-     *               is not recommended\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/event\/ActionEvent.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2967,2 +2967,0 @@\n-     * @param ptDst the array into which the transform point objects are\n-     * returned\n@@ -2971,0 +2969,2 @@\n+     * @param ptDst the array into which the transform point objects are\n+     * returned\n@@ -3041,0 +3041,2 @@\n+     * @param srcOff the offset to the first point to be transformed\n+     * in the source array\n@@ -3044,2 +3046,0 @@\n-     * @param srcOff the offset to the first point to be transformed\n-     * in the source array\n@@ -3156,0 +3156,2 @@\n+     * @param srcOff the offset to the first point to be transformed\n+     * in the source array\n@@ -3159,2 +3161,0 @@\n-     * @param srcOff the offset to the first point to be transformed\n-     * in the source array\n@@ -3267,0 +3267,2 @@\n+     * @param srcOff the offset to the first point to be transformed\n+     * in the source array\n@@ -3270,2 +3272,0 @@\n-     * @param srcOff the offset to the first point to be transformed\n-     * in the source array\n@@ -3363,0 +3363,2 @@\n+     * @param srcOff the offset to the first point to be transformed\n+     * in the source array\n@@ -3366,2 +3368,0 @@\n-     * @param srcOff the offset to the first point to be transformed\n-     * in the source array\n@@ -3545,0 +3545,2 @@\n+     * @param srcOff the offset to the first point to be transformed\n+     * in the source array\n@@ -3548,2 +3550,0 @@\n-     * @param srcOff the offset to the first point to be transformed\n-     * in the source array\n@@ -3758,0 +3758,2 @@\n+     * @param srcOff the offset to the first vector to be transformed\n+     * in the source array\n@@ -3761,2 +3763,0 @@\n-     * @param srcOff the offset to the first vector to be transformed\n-     * in the source array\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/geom\/AffineTransform.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -381,2 +381,0 @@\n-     * @param parentName the name of the element that will be the\n-     * new parent of the element.\n@@ -385,0 +383,2 @@\n+     * @param parentName the name of the element that will be the\n+     * new parent of the element.\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/metadata\/IIOMetadataFormatImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1780,1 +1780,0 @@\n-         * @param group the {@code Group} to add\n@@ -1783,0 +1782,1 @@\n+         * @param group the {@code Group} to add\n@@ -2531,1 +2531,0 @@\n-         * @param alignment the alignment\n@@ -2533,0 +2532,1 @@\n+         * @param alignment the alignment\n@@ -2547,1 +2547,0 @@\n-         * @param alignment the alignment\n@@ -2549,0 +2548,1 @@\n+         * @param alignment the alignment\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/GroupLayout.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -168,0 +168,1 @@\n+     * @param type how the two components are being placed\n@@ -174,1 +175,0 @@\n-     * @param type how the two components are being placed\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/LayoutStyle.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,2 +76,0 @@\n-     * @param message Descriptive text to be placed in the dialog box\n-     *                if one is popped up.\n@@ -80,0 +78,2 @@\n+     * @param message Descriptive text to be placed in the dialog box\n+     *                if one is popped up.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/ProgressMonitorInputStream.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -727,2 +727,0 @@\n-     * @param host the component hosting the view (used to call repaint)\n-     * @param a  the region allocated for the view to render into\n@@ -733,0 +731,2 @@\n+     * @param a  the region allocated for the view to render into\n+     * @param host the component hosting the view (used to call repaint)\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/PlainView.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -295,0 +295,4 @@\n+     * @param offsets the return value of the offset from the\n+     *  origin for each column\n+     * @param spans the return value of how much to allocated to\n+     *  each column\n@@ -298,4 +302,0 @@\n-     * @param spans the return value of how much to allocated to\n-     *  each column\n-     * @param offsets the return value of the offset from the\n-     *  origin for each column\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/TableView.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -331,0 +331,1 @@\n+     * @param html the HTML string\n@@ -333,1 +334,0 @@\n-     * @param html the HTML string\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/HTMLEditorKit.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -190,1 +190,0 @@\n-            \/\/JAVA_INT,    \/\/ return type\n@@ -473,1 +472,1 @@\n-                \/*int ret =*\/ jdk_hb_shape_handle.invokeExact(\n+                jdk_hb_shape_handle.invokeExact(\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/HBShaper.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n-JDKEXPORT int jdk_hb_shape(\n+JDKEXPORT void jdk_hb_shape(\n@@ -95,1 +95,0 @@\n-     int ret;\n@@ -101,1 +100,0 @@\n-         float yPtSize = euclidianDistance(matrix[2], matrix[3]);\n@@ -135,1 +133,1 @@\n-     ret = (*store_layout_results_fn)\n+     (*store_layout_results_fn)\n@@ -144,1 +142,1 @@\n-     return ret;\n+     return;\n","filename":"src\/java.desktop\/share\/native\/libfontmanager\/HBShaper_Panama.c","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -516,2 +516,0 @@\n-    FTScalerInfo *scalerInfo =\n-             (FTScalerInfo*) jlong_to_ptr(pScaler);\n@@ -1655,1 +1653,0 @@\n-    jobject point = NULL;\n","filename":"src\/java.desktop\/share\/native\/libfontmanager\/freetypeScaler.c","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-typedef int (*store_layoutdata_func_t)\n+typedef void (*store_layoutdata_func_t)\n@@ -65,1 +65,1 @@\n-JDKEXPORT int jdk_hb_shape(\n+JDKEXPORT void jdk_hb_shape(\n","filename":"src\/java.desktop\/share\/native\/libfontmanager\/hb-jdk-p.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -270,1 +270,0 @@\n-        int direction, ascent, descent;\n","filename":"src\/java.desktop\/unix\/native\/libfontmanager\/X11FontScaler.c","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -185,1 +185,0 @@\n-     * @param object  The <CODE>Attribute<\/CODE> object to be inserted.\n@@ -188,0 +187,1 @@\n+     * @param object  The <CODE>Attribute<\/CODE> object to be inserted.\n@@ -205,1 +205,0 @@\n-     * @param object  The value to which the attribute element should be set.\n@@ -207,0 +206,1 @@\n+     * @param object  The value to which the attribute element should be set.\n@@ -241,1 +241,0 @@\n-     * @param list  Elements to be inserted into the list.\n@@ -244,0 +243,1 @@\n+     * @param list  Elements to be inserted into the list.\n","filename":"src\/java.management\/share\/classes\/javax\/management\/AttributeList.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,1 +83,0 @@\n-     * @param className The name of the class to be loaded.\n@@ -85,0 +84,1 @@\n+     * @param className The name of the class to be loaded.\n","filename":"src\/java.management\/share\/classes\/javax\/management\/DefaultLoaderRepository.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,1 @@\n+     * @param description A human readable description of the constructor.\n@@ -81,1 +82,0 @@\n-     * @param description A human readable description of the constructor.\n@@ -93,0 +93,1 @@\n+     * @param description A human readable description of the constructor.\n@@ -96,1 +97,0 @@\n-     * @param description A human readable description of the constructor.\n","filename":"src\/java.management\/share\/classes\/javax\/management\/MBeanConstructorInfo.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,0 +100,1 @@\n+     * @param description A human readable description of the operation.\n@@ -102,1 +103,0 @@\n-     * @param description A human readable description of the operation.\n","filename":"src\/java.management\/share\/classes\/javax\/management\/MBeanOperationInfo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -625,0 +625,1 @@\n+     * @param loaderName The object name of the class loader to be used.\n@@ -629,1 +630,0 @@\n-     * @param loaderName The object name of the class loader to be used.\n@@ -714,1 +714,0 @@\n-     * @param data The byte array to be de-sererialized.\n@@ -718,0 +717,1 @@\n+     * @param data The byte array to be de-sererialized.\n","filename":"src\/java.management\/share\/classes\/javax\/management\/MBeanServer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -281,0 +281,1 @@\n+     * @param loaderName The object name of the class loader to be used.\n@@ -285,1 +286,0 @@\n-     * @param loaderName The object name of the class loader to be used.\n","filename":"src\/java.management\/share\/classes\/javax\/management\/MBeanServerConnection.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,1 +103,0 @@\n-     * @param className The name of the class to be loaded.\n@@ -107,0 +106,1 @@\n+     * @param className The name of the class to be loaded.\n@@ -136,1 +136,0 @@\n-     * @param className The name of the class to be loaded.\n@@ -140,0 +139,1 @@\n+     * @param className The name of the class to be loaded.\n","filename":"src\/java.management\/share\/classes\/javax\/management\/loading\/ClassLoaderRepository.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,1 +91,0 @@\n-     * @param className The name of the class to be loaded.\n@@ -93,0 +92,1 @@\n+     * @param className The name of the class to be loaded.\n","filename":"src\/java.management\/share\/classes\/javax\/management\/loading\/DefaultLoaderRepository.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -139,0 +139,1 @@\n+         * @param description A human readable description of the operation.\n@@ -141,1 +142,0 @@\n-         * @param description A human readable description of the operation.\n@@ -163,2 +163,0 @@\n-         * @param operationMethod The java.lang.reflect.Method object\n-         * describing the MBean operation.\n@@ -167,0 +165,2 @@\n+         * @param operationMethod The java.lang.reflect.Method object\n+         * describing the MBean operation.\n","filename":"src\/java.management\/share\/classes\/javax\/management\/modelmbean\/ModelMBeanOperationInfo.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -488,1 +488,0 @@\n-      * @param n        The non-null components to add.\n@@ -491,0 +490,1 @@\n+      * @param n        The non-null components to add.\n@@ -528,1 +528,0 @@\n-      * @param  comp    The non-null component to add.\n@@ -531,0 +530,1 @@\n+      * @param  comp    The non-null component to add.\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/CompositeName.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -475,1 +475,0 @@\n-      * @param n        The non-null components to add.\n@@ -478,0 +477,1 @@\n+      * @param n        The non-null components to add.\n@@ -515,1 +515,0 @@\n-      * @param  comp    The non-null component to add.\n@@ -518,0 +517,1 @@\n+      * @param  comp    The non-null component to add.\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/CompoundName.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -218,2 +218,0 @@\n-     * @param n\n-     *          the components to add\n@@ -223,0 +221,2 @@\n+     * @param n\n+     *          the components to add\n@@ -251,2 +251,0 @@\n-     * @param comp\n-     *          the component to add\n@@ -256,0 +254,2 @@\n+     * @param comp\n+     *          the component to add\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/Name.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -167,0 +167,1 @@\n+      * @param addr     The non-null address of the object.\n@@ -170,1 +171,0 @@\n-      * @param addr     The non-null address of the object.\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/Reference.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2000, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -166,3 +166,0 @@\n-     * @param timelim   The number of milliseconds to wait before returning.\n-     *                  If 0, wait indefinitely.\n-     * @param deref     If true, dereference links during search.\n@@ -171,2 +168,2 @@\n-     * @param retobj    If true, return the object bound to the name of the\n-     *                  entry; if false, do not return object.\n+     * @param timelim   The number of milliseconds to wait before returning.\n+     *                  If 0, wait indefinitely.\n@@ -176,0 +173,3 @@\n+     * @param retobj    If true, return the object bound to the name of the\n+     *                  entry; if false, do not return object.\n+     * @param deref     If true, dereference links during search.\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/directory\/SearchControls.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -439,1 +439,0 @@\n-     * @param suffix    The non-null components to add.\n@@ -442,0 +441,1 @@\n+     * @param suffix    The non-null components to add.\n@@ -474,1 +474,0 @@\n-     * @param suffixRdns        The non-null suffix {@code Rdn}s to add.\n@@ -477,0 +476,1 @@\n+     * @param suffixRdns        The non-null suffix {@code Rdn}s to add.\n@@ -527,1 +527,0 @@\n-     * @param  comp     The non-null component to add.\n@@ -530,0 +529,1 @@\n+     * @param  comp     The non-null component to add.\n@@ -551,1 +551,0 @@\n-     * @param  comp     The non-null RDN to add.\n@@ -554,0 +553,1 @@\n+     * @param  comp     The non-null RDN to add.\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/ldap\/LdapName.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -146,2 +146,0 @@\n-     * @param reqCtls The possibly null request controls to use for the new context.\n-     * If null or the empty array means use no request controls.\n@@ -151,0 +149,2 @@\n+     * @param reqCtls The possibly null request controls to use for the new context.\n+     * If null or the empty array means use no request controls.\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/ldap\/LdapReferralException.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -413,0 +413,8 @@\n+         * @implNote\n+         * In the JDK built-in implementation of the {@code HttpClient},\n+         * if a {@link HttpRequest} has an {@code Authorization} or {@code\n+         * Proxy-Authorization} header set then its value is used and\n+         * the {@link Authenticator} is not invoked for the corresponding\n+         * authentication. In this case, any authentication errors are returned\n+         * to the user and requests are not automatically retried.\n+         *\n","filename":"src\/java.net.http\/share\/classes\/java\/net\/http\/HttpClient.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -247,0 +247,8 @@\n+        if (req.getUserSetAuthFlag(SERVER) && status == UNAUTHORIZED) {\n+            \/\/ return the response. We don't handle it.\n+            return null;\n+        } else if (req.getUserSetAuthFlag(PROXY) && status == PROXY_UNAUTHORIZED) {\n+            \/\/ same\n+            return null;\n+        }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/AuthenticationFilter.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,2 @@\n+import static java.net.Authenticator.RequestorType.PROXY;\n+import static java.net.Authenticator.RequestorType.SERVER;\n@@ -94,1 +96,0 @@\n-\n@@ -107,1 +108,3 @@\n-                      connection.contextRestricted(request, client));\n+                      connection.contextRestricted(request));\n+\n+        Utils.setUserAuthFlags(request, userHeaders);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1Request.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+\n+import static jdk.internal.net.http.frame.SettingsFrame.INITIAL_CONNECTION_WINDOW_SIZE;\n@@ -294,0 +296,4 @@\n+        \/\/ The min value is the max between the streamWindow and\n+        \/\/ the initial connection window size\n+        int minValue = Math.max(INITIAL_CONNECTION_WINDOW_SIZE, streamWindow);\n+\n@@ -296,1 +302,1 @@\n-                streamWindow, Integer.MAX_VALUE, defaultValue);\n+                minValue, Integer.MAX_VALUE, defaultValue);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2ClientImpl.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -95,0 +95,1 @@\n+import static jdk.internal.net.http.frame.SettingsFrame.INITIAL_CONNECTION_WINDOW_SIZE;\n@@ -1083,0 +1084,28 @@\n+    \/\/ This method is called when a DataFrame that was added\n+    \/\/ to a Stream::inputQ is later dropped from the queue\n+    \/\/ without being consumed.\n+    \/\/\n+    \/\/ Before adding a frame to the queue, the Stream calls\n+    \/\/ connection.windowUpdater.canBufferUnprocessedBytes(), which\n+    \/\/ increases the count of unprocessed bytes in the connection.\n+    \/\/ After consuming the frame, it calls connection.windowUpdater::processed,\n+    \/\/ which decrements the count of unprocessed bytes, and possibly\n+    \/\/ sends a window update to the peer.\n+    \/\/\n+    \/\/ This method is called when connection.windowUpdater::processed\n+    \/\/ will not be called, which can happen when consuming the frame\n+    \/\/ fails, or when an empty DataFrame terminates the stream,\n+    \/\/ or when the stream is cancelled while data is still\n+    \/\/ sitting in its inputQ. In the later case, it is called for\n+    \/\/ each frame that is dropped from the queue.\n+    final void releaseUnconsumed(DataFrame df) {\n+        windowUpdater.released(df.payloadLength());\n+        dropDataFrame(df);\n+    }\n+\n+    \/\/ This method can be called directly when a DataFrame is dropped\n+    \/\/ before\/without having been added to any Stream::inputQ.\n+    \/\/ In that case, the number of unprocessed bytes hasn't been incremented\n+    \/\/ by the stream, and does not need to be decremented.\n+    \/\/ Otherwise, if the frame is dropped after having been added to the\n+    \/\/ inputQ, releaseUnconsumed above should be called.\n@@ -1468,2 +1497,3 @@\n-        final int len = windowUpdater.initialWindowSize - DEFAULT_INITIAL_WINDOW_SIZE;\n-        if (len != 0) {\n+        final int len = windowUpdater.initialWindowSize - INITIAL_CONNECTION_WINDOW_SIZE;\n+        assert len >= 0;\n+        if (len > 0) {\n@@ -1472,1 +1502,1 @@\n-                        len, windowUpdater.initialWindowSize, DEFAULT_INITIAL_WINDOW_SIZE);\n+                        len, windowUpdater.initialWindowSize, INITIAL_CONNECTION_WINDOW_SIZE);\n@@ -1927,0 +1957,13 @@\n+\n+        @Override\n+        protected boolean windowSizeExceeded(long received) {\n+            if (connection.isOpen()) {\n+                try {\n+                    connection.protocolError(ErrorFrame.FLOW_CONTROL_ERROR,\n+                            \"connection window exceeded\");\n+                } catch (IOException io) {\n+                    connection.shutdown(io);\n+                }\n+            }\n+            return true;\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":46,"deletions":3,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -359,1 +359,1 @@\n-    BiPredicate<String,String> contextRestricted(HttpRequestImpl request, HttpClient client) {\n+    BiPredicate<String,String> contextRestricted(HttpRequestImpl request) {\n@@ -363,1 +363,1 @@\n-            return Utils.PROXY_TUNNEL_RESTRICTED(client);\n+            return Utils.PROXY_TUNNEL_RESTRICTED();\n@@ -365,1 +365,1 @@\n-            return Utils.CONTEXT_RESTRICTED(client);\n+            return Utils.ACCEPT_ALL;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpConnection.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.net.Authenticator;\n@@ -50,0 +51,2 @@\n+import static java.net.Authenticator.RequestorType.PROXY;\n+import static java.net.Authenticator.RequestorType.SERVER;\n@@ -69,0 +72,2 @@\n+    private volatile boolean userSetAuthorization;\n+    private volatile boolean userSetProxyAuthorization;\n@@ -336,0 +341,24 @@\n+    \/**\n+     * These flags are set if the user set an Authorization or Proxy-Authorization header\n+     * overriding headers produced by an Authenticator that was also set\n+     *\n+     * The values are checked in the AuthenticationFilter which tells the library\n+     * to return whatever response received to the user instead of causing request\n+     * to be resent, in case of error.\n+     *\/\n+    public void setUserSetAuthFlag(Authenticator.RequestorType type, boolean value) {\n+        if (type == SERVER) {\n+            userSetAuthorization = value;\n+        } else {\n+            userSetProxyAuthorization = value;\n+        }\n+    }\n+\n+    public boolean getUserSetAuthFlag(Authenticator.RequestorType type) {\n+        if (type == SERVER) {\n+            return userSetAuthorization;\n+        } else {\n+            return userSetProxyAuthorization;\n+        }\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpRequestImpl.java","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -163,1 +163,0 @@\n-\n@@ -170,1 +169,1 @@\n-    private final WindowUpdateSender windowUpdater;\n+    private final WindowUpdateSender streamWindowUpdater;\n@@ -220,1 +219,2 @@\n-                    connection.ensureWindowUpdated(df); \/\/ must update connection window\n+                    \/\/ consumed will not be called\n+                    connection.releaseUnconsumed(df); \/\/ must update connection window\n@@ -235,1 +235,5 @@\n-                        connection.dropDataFrame(df); \/\/ must update connection window\n+                        \/\/ Data frames that have been added to the inputQ\n+                        \/\/ must be released using releaseUnconsumed() to\n+                        \/\/ account for the amount of unprocessed bytes\n+                        \/\/ tracked by the connection.windowUpdater.\n+                        connection.releaseUnconsumed(df);\n@@ -286,2 +290,6 @@\n-            if (frame instanceof DataFrame) {\n-                connection.dropDataFrame((DataFrame)frame);\n+            if (frame instanceof DataFrame df) {\n+                \/\/ Data frames that have been added to the inputQ\n+                \/\/ must be released using releaseUnconsumed() to\n+                \/\/ account for the amount of unprocessed bytes\n+                \/\/ tracked by the connection.windowUpdater.\n+                connection.releaseUnconsumed(df);\n@@ -313,2 +321,1 @@\n-        connection.windowUpdater.update(len);\n-\n+        connection.windowUpdater.processed(len);\n@@ -316,0 +323,2 @@\n+            streamWindowUpdater.processed(len);\n+        } else {\n@@ -318,1 +327,1 @@\n-            windowUpdater.update(len);\n+            streamWindowUpdater.released(len);\n@@ -388,2 +397,15 @@\n-        inputQ.add(df);\n-        sched.runOrSchedule();\n+        try {\n+            int len = df.payloadLength();\n+            if (len > 0) {\n+                \/\/ we return from here if the connection is being closed.\n+                if (!connection.windowUpdater.canBufferUnprocessedBytes(len)) return;\n+                \/\/ we return from here if the stream is being closed.\n+                if (closed || !streamWindowUpdater.canBufferUnprocessedBytes(len)) {\n+                    connection.releaseUnconsumed(df);\n+                    return;\n+                }\n+            }\n+            inputQ.add(df);\n+        } finally {\n+            sched.runOrSchedule();\n+        }\n@@ -473,1 +495,1 @@\n-        this.windowUpdater = new StreamWindowUpdateSender(connection);\n+        this.streamWindowUpdater = new StreamWindowUpdateSender(connection);\n@@ -509,0 +531,2 @@\n+                \/\/ Data frames that have not been added to the inputQ\n+                \/\/ can be released using dropDataFrame\n@@ -828,1 +852,2 @@\n-        userh = HttpHeaders.of(userh.map(), Utils.CONTEXT_RESTRICTED(client()));\n+        userh = HttpHeaders.of(userh.map(), Utils.ACCEPT_ALL);\n+        Utils.setUserAuthFlags(request, userh);\n@@ -1429,0 +1454,4 @@\n+        onProtocolError(cause, ResetFrame.PROTOCOL_ERROR);\n+    }\n+\n+    void onProtocolError(final IOException cause, int code) {\n@@ -1430,1 +1459,3 @@\n-            debug.log(\"cancelling exchange on stream %d due to protocol error: %s\", streamid, cause.getMessage());\n+            debug.log(\"cancelling exchange on stream %d due to protocol error [%s]: %s\",\n+                    streamid, ErrorFrame.stringForCode(code),\n+                    cause.getMessage());\n@@ -1434,1 +1465,1 @@\n-        cancelImpl(cause, ResetFrame.PROTOCOL_ERROR);\n+        cancelImpl(cause, code);\n@@ -1738,0 +1769,7 @@\n+\n+        @Override\n+        protected boolean windowSizeExceeded(long received) {\n+            onProtocolError(new ProtocolException(\"stream %s flow control window exceeded\"\n+                            .formatted(streamid)), ResetFrame.FLOW_CONTROL_ERROR);\n+            return true;\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":53,"deletions":15,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.util.concurrent.atomic.AtomicLong;\n@@ -36,0 +37,4 @@\n+\/**\n+ * A class that tracks the amount of flow controlled\n+ * data received on an HTTP\/2 connection\n+ *\/\n@@ -41,0 +46,1 @@\n+    \/\/ The threshold at which window updates are sent in bytes\n@@ -42,0 +48,2 @@\n+    \/\/ The flow control window in bytes\n+    final int windowSize;\n@@ -43,1 +51,8 @@\n-    final AtomicInteger received = new AtomicInteger();\n+    \/\/ The amount of flow controlled data received and processed, in bytes,\n+    \/\/ since the start of the window.\n+    \/\/ The window is exhausted when received + unprocessed >= windowSize\n+    final AtomicLong received = new AtomicLong();\n+    \/\/ The amount of flow controlled data received and unprocessed, in bytes,\n+    \/\/ since the start of the window.\n+    \/\/ The window is exhausted when received + unprocessed >= windowSize\n+    final AtomicLong unprocessed = new AtomicLong();\n@@ -56,0 +71,1 @@\n+        this.windowSize = initWindowSize;\n@@ -69,0 +85,1 @@\n+    \/\/ O for the connection window, > 0 for a stream window\n@@ -71,0 +88,99 @@\n+\n+    \/**\n+     * {@return {@code true} if buffering the given amount of\n+     * flow controlled data would not exceed the flow control\n+     * window}\n+     * <p>\n+     * This method is called before buffering and processing\n+     * a DataFrame. The count of unprocessed bytes is incremented\n+     * by the given amount, and checked against the number of\n+     * available bytes in the flow control window.\n+     * <p>\n+     * This method returns {@code true} if the bytes can be buffered\n+     * without exceeding the flow control window, {@code false}\n+     * if the flow control window is exceeded and corrective\n+     * action (close\/reset) has been taken.\n+     * <p>\n+     * When this method returns true, either {@link #processed(int)}\n+     * or {@link #released(int)} must eventually be called to release\n+     * the bytes from the flow control window.\n+     *\n+     * @implSpec\n+     * an HTTP\/2 endpoint may disable its own flow control\n+     * (see <a href=\"https:\/\/www.rfc-editor.org\/rfc\/rfc9113.html#section-5.2.1\">\n+     *     RFC 9113, section 5.2.1<\/a>), in which case this\n+     * method may return true even if the flow control window would\n+     * be exceeded: that is, the flow control window is exceeded but\n+     * the endpoint decided to take no corrective action.\n+     *\n+     * @param  len a number of unprocessed bytes, which\n+     *             the caller wants to buffer.\n+     *\/\n+    boolean canBufferUnprocessedBytes(int len) {\n+        return !checkWindowSizeExceeded(unprocessed.addAndGet(len));\n+    }\n+\n+    \/\/ adds the provided amount to the amount of already\n+    \/\/ received and processed bytes and checks whether the\n+    \/\/ flow control window is exceeded. If so, take\n+    \/\/ corrective actions and return true.\n+    private boolean checkWindowSizeExceeded(long len) {\n+        \/\/ because windowSize is bound by Integer.MAX_VALUE\n+        \/\/ we will never reach the point where received.get() + len\n+        \/\/ could overflow\n+        long rcv = received.get() + len;\n+        return rcv > windowSize && windowSizeExceeded(rcv);\n+    }\n+\n+    \/**\n+     * Called after unprocessed buffered bytes have been\n+     * processed, to release part of the flow control window\n+     *\n+     * @apiNote this method is called only when releasing bytes\n+     * that where buffered after calling\n+     * {@link #canBufferUnprocessedBytes(int)}.\n+     *\n+     * @param delta the amount of processed bytes to release\n+     *\/\n+    void processed(int delta) {\n+        long rest = unprocessed.addAndGet(-delta);\n+        assert rest >= 0;\n+        update(delta);\n+    }\n+\n+    \/**\n+     * Called when it is desired to release unprocessed bytes\n+     * without processing them, or without triggering the\n+     * sending of a window update. This method can be called\n+     * instead of calling {@link #processed(int)}.\n+     * When this method is called instead of calling {@link #processed(int)},\n+     * it should generally be followed by a call to {@link #update(int)},\n+     * unless the stream or connection is being closed.\n+     *\n+     * @apiNote this method should only be called to release bytes that\n+     * have been buffered after calling {@link\n+     * #canBufferUnprocessedBytes(int)}.\n+     *\n+     * @param delta the amount of bytes to release from the window\n+     *\n+     * @return the amount of remaining unprocessed bytes\n+     *\/\n+    long released(int delta) {\n+        long rest = unprocessed.addAndGet(-delta);\n+        assert rest >= 0;\n+        return rest;\n+    }\n+\n+    \/**\n+     * This method is called to update the flow control window,\n+     * and possibly send a window update\n+     *\n+     * @apiNote this method can be called directly if a frame is\n+     * dropped before calling {@link #canBufferUnprocessedBytes(int)}.\n+     * Otherwise, either {@link #processed(int)} or {@link #released(int)}\n+     * should be called, depending on whether sending a window update\n+     * is desired or not. It is typically not desired to send an update\n+     * if the stream or connection is being closed.\n+     *\n+     * @param delta the amount of bytes released from the window.\n+     *\/\n@@ -72,1 +188,1 @@\n-        int rcv = received.addAndGet(delta);\n+        long rcv = received.addAndGet(delta);\n@@ -74,0 +190,3 @@\n+        if (rcv > windowSize && windowSizeExceeded(rcv)) {\n+            return;\n+        }\n@@ -77,2 +196,2 @@\n-                int tosend = received.get();\n-                if( tosend > limit) {\n+                int tosend = (int)Math.min(received.get(), Integer.MAX_VALUE);\n+                if (tosend > limit) {\n@@ -90,0 +209,1 @@\n+        assert delta > 0 : \"illegal window update delta: \" + delta;\n@@ -107,0 +227,12 @@\n+    \/**\n+     * Called when the flow control window size is exceeded\n+     * This method may return false if flow control is disabled\n+     * in this endpoint.\n+     *\n+     * @param received the amount of data received, which is greater\n+     *                 than {@code windowSize}\n+     * @return {@code true} if the error was reported to the peer\n+     *         and no further window update should be sent.\n+     *\/\n+    protected abstract boolean windowSizeExceeded(long received);\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/WindowUpdateSender.java","additions":137,"deletions":5,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -85,0 +85,2 @@\n+import static java.net.Authenticator.RequestorType.PROXY;\n+import static java.net.Authenticator.RequestorType.SERVER;\n@@ -213,13 +215,0 @@\n-    \/\/ Headers that are not generally restricted, and can therefore be set by users,\n-    \/\/ but can in some contexts be overridden by the implementation.\n-    \/\/ Currently, only contains \"Authorization\" which will\n-    \/\/ be overridden, when an Authenticator is set on the HttpClient.\n-    \/\/ Needs to be BiPred<String,String> to fit with general form of predicates\n-    \/\/ used by caller.\n-\n-    public static final BiPredicate<String, String> CONTEXT_RESTRICTED(HttpClient client) {\n-        return (k, v) -> client.authenticator().isEmpty() ||\n-                (!k.equalsIgnoreCase(\"Authorization\")\n-                        && !k.equalsIgnoreCase(\"Proxy-Authorization\"));\n-    }\n-\n@@ -228,3 +217,2 @@\n-    private static final BiPredicate<String, String> HOST_RESTRICTED = (k,v) -> !\"host\".equalsIgnoreCase(k);\n-    public static final BiPredicate<String, String> PROXY_TUNNEL_RESTRICTED(HttpClient client)  {\n-        return CONTEXT_RESTRICTED(client).and(HOST_RESTRICTED);\n+    public static final BiPredicate<String, String> PROXY_TUNNEL_RESTRICTED()  {\n+        return (k,v) -> !\"host\".equalsIgnoreCase(k);\n@@ -313,0 +301,13 @@\n+    \/**\n+     * Check the user headers to see if the Authorization or ProxyAuthorization\n+     * were set. We need to set special flags in the request if so. Otherwise\n+     * we can't distinguish user set from Authenticator set headers\n+     *\/\n+    public static void setUserAuthFlags(HttpRequestImpl request, HttpHeaders userHeaders) {\n+        if (userHeaders.firstValue(\"Authorization\").isPresent()) {\n+            request.setUserSetAuthFlag(SERVER, true);\n+        }\n+        if (userHeaders.firstValue(\"Proxy-Authorization\").isPresent()) {\n+            request.setUserSetAuthFlag(PROXY, true);\n+        }\n+    }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Utils.java","additions":17,"deletions":16,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -466,0 +466,10 @@\n+                if (id == SettingsFrame.INITIAL_WINDOW_SIZE && val < 0) {\n+                    return new MalformedFrame(ErrorFrame.FLOW_CONTROL_ERROR,\n+                            \"SettingsFrame with INITIAL_WINDOW_SIZE > 2^31 -1: \"\n+                                    + (val & 0xffffffffL));\n+                }\n+                if (id == SettingsFrame.MAX_FRAME_SIZE && (val < 16384 || val > 16777215)) {\n+                    return new MalformedFrame(ErrorFrame.PROTOCOL_ERROR,\n+                            \"SettingsFrame with MAX_FRAME_SIZE out of range: \"\n+                                    + (val & 0xffffffffL));\n+                }\n@@ -533,1 +543,6 @@\n-        return new WindowUpdateFrame(streamid, getInt() & 0x7fffffff);\n+        int update = getInt();\n+        if (update < 0) {\n+            return new MalformedFrame(ErrorFrame.FLOW_CONTROL_ERROR,\n+                    \"WindowUpdateFrame with value > 2^31 -1 \" + (update & 0xffffffffL));\n+        }\n+        return new WindowUpdateFrame(streamid, update & 0x7fffffff);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/frame\/FramesDecoder.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -169,0 +169,5 @@\n+    \/\/ Initial connection window size. This cannot be updated using the\n+    \/\/ SETTINGS frame.\n+    public static final int INITIAL_CONNECTION_WINDOW_SIZE = DEFAULT_INITIAL_WINDOW_SIZE;\n+\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/frame\/SettingsFrame.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -60,3 +60,5 @@\n- * The HTTP\/2 client connection window size in bytes. The maximum size is 2^31-1. This value\n- * cannot be smaller than the stream window size, which can be configured through the\n- * {@code jdk.httpclient.windowsize} system property.\n+ * The HTTP\/2 client connection window size in bytes. Valid values are in the range\n+ * [2^16-1, 2^31-1]. If an invalid value is provided, the default value is used.\n+ * The implementation guarantees that the actual value will be no smaller than the stream\n+ * window size, which can be configured through the {@code jdk.httpclient.windowsize}\n+ * system property.\n@@ -153,1 +155,2 @@\n- * The HTTP\/2 client stream window size in bytes.\n+ * The HTTP\/2 client stream window size in bytes. Valid values are in the range [2^14, 2^31-1].\n+ * If an invalid value is provided, the default value is used.\n","filename":"src\/java.net.http\/share\/classes\/module-info.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,4 @@\n+        \/\/ print deprecation warning\n+        getError().println(getMessage(\"deprecated.warning\",\n+                new Object[] { PROGRAM_NAME }));\n+\n","filename":"src\/java.scripting\/share\/classes\/com\/sun\/tools\/script\/shell\/Main.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,3 @@\n+\n+deprecated.warning=\\\n+        Warning: {0} is deprecated and will be removed in a future release.\n\\ No newline at end of file\n","filename":"src\/java.scripting\/share\/classes\/com\/sun\/tools\/script\/shell\/messages.properties","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,2 +41,0 @@\n-     * @param name The name of the procedure to be called.\n-     *\n@@ -48,0 +46,2 @@\n+     * @param name The name of the procedure to be called.\n+     *\n","filename":"src\/java.scripting\/share\/classes\/javax\/script\/Invocable.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+ * <p> The {@code jrunscript} tool is deprecated and will be removed\n+ * in a future release.\n","filename":"src\/java.scripting\/share\/classes\/module-info.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-.\\\" Copyright (c) 2006, 2018, Oracle and\/or its affiliates. All rights reserved.\n+.\\\" Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,1 @@\n+It is deprecated and will be removed in a future release.\n","filename":"src\/java.scripting\/share\/man\/jrunscript.1","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1564,2 +1564,0 @@\n-     * @param startRow the position in the <code>ResultSet<\/code> from where to start\n-     *                populating the records in this <code>CachedRowSet<\/code>\n@@ -1568,0 +1566,2 @@\n+     * @param startRow the position in the <code>ResultSet<\/code> from where to start\n+     *                populating the records in this <code>CachedRowSet<\/code>\n","filename":"src\/java.sql.rowset\/share\/classes\/javax\/sql\/rowset\/CachedRowSet.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -261,0 +261,1 @@\n+   * @param prefix the prefix of the QName of the new StartElement\n@@ -263,1 +264,0 @@\n-   * @param prefix the prefix of the QName of the new StartElement\n@@ -275,0 +275,1 @@\n+   * @param prefix the prefix of the QName of the new StartElement\n@@ -277,1 +278,0 @@\n-   * @param prefix the prefix of the QName of the new StartElement\n@@ -296,0 +296,1 @@\n+   * @param prefix the prefix of the QName of the new StartElement\n@@ -298,1 +299,0 @@\n-   * @param prefix the prefix of the QName of the new StartElement\n@@ -326,0 +326,1 @@\n+   * @param prefix the prefix of the QName of the new StartElement\n@@ -328,1 +329,0 @@\n-   * @param prefix the prefix of the QName of the new StartElement\n@@ -336,0 +336,1 @@\n+   * @param prefix the prefix of the QName of the new StartElement\n@@ -338,1 +339,0 @@\n-   * @param prefix the prefix of the QName of the new StartElement\n","filename":"src\/java.xml\/share\/classes\/javax\/xml\/stream\/XMLEventFactory.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,0 @@\n-   * @param th a nested exception\n@@ -82,0 +81,1 @@\n+   * @param th a nested exception\n@@ -91,1 +91,0 @@\n-   * @param th a nested exception\n@@ -94,0 +93,1 @@\n+   * @param th a nested exception\n","filename":"src\/java.xml\/share\/classes\/javax\/xml\/stream\/XMLStreamException.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -212,1 +212,0 @@\n-   * @param localName local name of the tag, may not be null\n@@ -214,0 +213,1 @@\n+   * @param localName local name of the tag, may not be null\n","filename":"src\/java.xml\/share\/classes\/javax\/xml\/stream\/XMLStreamWriter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,0 +70,1 @@\n+     * @param msg The detail message.\n@@ -72,1 +73,0 @@\n-     * @param msg The detail message.\n","filename":"src\/java.xml\/share\/classes\/javax\/xml\/transform\/TransformerConfigurationException.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,0 +72,1 @@\n+     * @param message The detail message.\n@@ -74,1 +75,0 @@\n-     * @param message The detail message.\n","filename":"src\/java.xml\/share\/classes\/javax\/xml\/validation\/SchemaFactoryConfigurationError.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+import java.nio.charset.StandardCharsets;\n+\n@@ -105,1 +107,1 @@\n-            String result = readErrorMessage(in);\n+            String result = readMessage(in);\n@@ -330,0 +332,39 @@\n+    \/\/ Attach API version support\n+    protected static final int VERSION_1 = 1;\n+    protected static final int VERSION_2 = 2;\n+\n+    \/*\n+     * Detects Attach API version supported by target VM.\n+     *\/\n+    protected int detectVersion() throws IOException {\n+        try {\n+            InputStream reply = execute(\"getversion\");\n+            String message = readMessage(reply);\n+            reply.close();\n+            try {\n+                int supportedVersion = Integer.parseUnsignedInt(message);\n+                \/\/ we expect only VERSION_2\n+                if (supportedVersion == VERSION_2) {\n+                    return VERSION_2;\n+                }\n+            } catch (NumberFormatException nfe) {\n+                \/\/ bad reply - fallback to VERSION_1\n+            }\n+        } catch (AttachOperationFailedException | AgentLoadException ex) {\n+            \/\/ the command is not supported, the VM supports VERSION_1 only\n+        }\n+        return VERSION_1;\n+    }\n+\n+    \/*\n+     * For testing purposes Attach API v2 may be disabled.\n+     *\/\n+    protected boolean isAPIv2Enabled() {\n+        \/\/ if \"jdk.attach.compat\" property is set, only v1 is enabled.\n+        try {\n+            String value = System.getProperty(\"jdk.attach.compat\");\n+            return !(\"true\".equalsIgnoreCase(value));\n+        } catch (SecurityException se) {\n+        }\n+        return true;\n+    }\n@@ -370,1 +411,1 @@\n-    String readErrorMessage(InputStream in) throws IOException {\n+    String readMessage(InputStream in) throws IOException {\n@@ -403,1 +444,1 @@\n-            String message = readErrorMessage(sis);\n+            String message = readMessage(sis);\n@@ -420,0 +461,45 @@\n+    \/*\n+     * Helper writer interface to send commands to the target VM.\n+     *\/\n+    public static interface AttachOutputStream {\n+        abstract void write(byte[] buffer, int offset, int length) throws IOException;\n+    }\n+\n+    private int dataSize(Object obj) {\n+        return (obj == null ? 0 : obj.toString().getBytes(StandardCharsets.UTF_8).length) + 1;\n+    }\n+\n+    \/*\n+     * Writes object (usually String or Integer) to the attach writer.\n+     *\/\n+    private void writeString(AttachOutputStream writer, Object obj) throws IOException {\n+        if (obj != null) {\n+            String s = obj.toString();\n+            if (s.length() > 0) {\n+                byte[] b = s.getBytes(StandardCharsets.UTF_8);\n+                writer.write(b, 0, b.length);\n+            }\n+        }\n+        byte b[] = new byte[1];\n+        b[0] = 0;\n+        writer.write(b, 0, 1);\n+    }\n+\n+    protected void writeCommand(AttachOutputStream writer, int ver, String cmd, Object ... args) throws IOException {\n+        writeString(writer, ver);\n+        if (ver == VERSION_2) {\n+            \/\/ for v2 write size of the data\n+            int size = dataSize(cmd);\n+            for (Object arg: args) {\n+                size += dataSize(arg);\n+            }\n+            writeString(writer, size);\n+        }\n+        writeString(writer, cmd);\n+        \/\/ v1 commands always write 3 arguments\n+        int argNumber = ver == VERSION_1 ? 3 : args.length;\n+        for (int i = 0; i < argNumber; i++) {\n+            writeString(writer, i < args.length ? args[i] : null);\n+        }\n+    }\n+\n","filename":"src\/jdk.attach\/share\/classes\/sun\/tools\/attach\/HotSpotVirtualMachine.java","additions":89,"deletions":3,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.tools.attach.AttachOperationFailedException;\n@@ -45,0 +46,1 @@\n+    private int ver = VERSION_1;        \/\/ updated in ctor depending on detectVersion result\n@@ -54,3 +56,0 @@\n-        \/\/ The target VM might be a pre-6.0 VM so we enqueue a \"null\" command\n-        \/\/ which minimally tests that the enqueue function exists in the target\n-        \/\/ VM.\n@@ -58,1 +57,8 @@\n-            enqueue(hProcess, stub, null, null);\n+            if (isAPIv2Enabled()) {\n+                ver = detectVersion();\n+            } else {\n+                \/\/ The target VM might be a pre-6.0 VM so we enqueue a \"null\" command\n+                \/\/ which minimally tests that the enqueue function exists in the target\n+                \/\/ VM.\n+                enqueue(hProcess, stub, VERSION_1, null, null);\n+            }\n@@ -76,1 +82,0 @@\n-        assert args.length <= 3;        \/\/ includes null\n@@ -86,1 +91,1 @@\n-            hPipe = createPipe(pipename);\n+            hPipe = createPipe(ver, pipename);\n@@ -91,1 +96,1 @@\n-            hPipe = createPipe(pipename);\n+            hPipe = createPipe(ver, pipename);\n@@ -102,2 +107,7 @@\n-            \/\/ enqueue the command to the process\n-            enqueue(hProcess, stub, cmd, pipename, args);\n+            \/\/ enqueue the command to the process.\n+            if (ver == VERSION_1) {\n+                enqueue(hProcess, stub, ver, cmd, pipename, args);\n+            } else {\n+                \/\/ for v2 operations request contains only pipe name.\n+                enqueue(hProcess, stub, ver, null, pipename);\n+            }\n@@ -105,2 +115,1 @@\n-            \/\/ wait for command to complete - process will connect with the\n-            \/\/ completion status\n+            \/\/ wait for the target VM to connect to the pipe.\n@@ -109,0 +118,12 @@\n+            IOException ioe = null;\n+\n+            if (ver == VERSION_2) {\n+                PipeOutputStream writer = new PipeOutputStream(hPipe);\n+\n+                try {\n+                    writeCommand(writer, ver, cmd, args);\n+                } catch (IOException x) {\n+                    ioe = x;\n+                }\n+            }\n+\n@@ -113,1 +134,1 @@\n-            processCompletionStatus(null, cmd, in);\n+            processCompletionStatus(ioe, cmd, in);\n@@ -124,0 +145,11 @@\n+    private static class PipeOutputStream implements AttachOutputStream {\n+        private long hPipe;\n+        public PipeOutputStream(long hPipe) {\n+            this.hPipe = hPipe;\n+        }\n+        @Override\n+        public void write(byte[] buffer, int offset, int length) throws IOException {\n+            VirtualMachineImpl.writePipe(hPipe, buffer, offset, length);\n+        }\n+    }\n+\n@@ -152,1 +184,1 @@\n-    static native long createPipe(String name) throws IOException;\n+    static native long createPipe(int ver, String name) throws IOException;\n@@ -160,1 +192,3 @@\n-    static native void enqueue(long hProcess, byte[] stub,\n+    static native void writePipe(long hPipe, byte buf[], int off, int buflen) throws IOException;\n+\n+    static native void enqueue(long hProcess, byte[] stub, int ver,\n","filename":"src\/jdk.attach\/windows\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":48,"deletions":14,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-\/* exported function in target VM *\/\n+\/* exported functions in target VM *\/\n@@ -52,0 +52,2 @@\n+typedef jint (WINAPI* EnqueueOperationFunc_v2)\n+    (const char* pipename);\n@@ -73,0 +75,1 @@\n+   jint version;\n@@ -78,0 +81,1 @@\n+   char func_v2[MAX_FUNC_LENGTH];\n@@ -105,1 +109,0 @@\n-    EnqueueOperationFunc addr;\n@@ -112,5 +115,21 @@\n-    addr = (EnqueueOperationFunc)(pData->_GetProcAddress(h, pData->func1));\n-    if (addr == NULL) {\n-        addr = (EnqueueOperationFunc)(pData->_GetProcAddress(h, pData->func2));\n-    }\n-    if (addr == NULL) {\n+    if (pData->version == 1) {\n+        EnqueueOperationFunc addr = (EnqueueOperationFunc)(pData->_GetProcAddress(h, pData->func1));\n+        if (addr == NULL) {\n+            addr = (EnqueueOperationFunc)(pData->_GetProcAddress(h, pData->func2));\n+        }\n+        if (addr == NULL) {\n+            return ERR_GET_ENQUEUE_FUNC_FAIL;\n+        }\n+        \/* \"null\" command - does nothing in the target VM *\/\n+        if (pData->cmd[0] == '\\0') {\n+            return 0;\n+        } else {\n+            return (*addr)(pData->cmd, pData->arg[0], pData->arg[1], pData->arg[2], pData->pipename);\n+        }\n+    } else if (pData->version == 2) {\n+        EnqueueOperationFunc_v2 addr = (EnqueueOperationFunc_v2)(pData->_GetProcAddress(h, pData->func_v2));\n+        if (addr == NULL) {\n+            return ERR_GET_ENQUEUE_FUNC_FAIL;\n+        }\n+        return (*addr)(pData->pipename);\n+    } else {\n@@ -120,6 +139,0 @@\n-    \/* \"null\" command - does nothing in the target VM *\/\n-    if (pData->cmd[0] == '\\0') {\n-        return 0;\n-    } else {\n-        return (*addr)(pData->cmd, pData->arg[0], pData->arg[1], pData->arg[2], pData->pipename);\n-    }\n@@ -264,1 +277,1 @@\n-  (JNIEnv *env, jclass cls, jstring pipename)\n+  (JNIEnv *env, jclass cls, jint ver, jstring pipename)\n@@ -292,1 +305,2 @@\n-          PIPE_ACCESS_INBOUND,          \/\/ read access\n+          ver == 1 ? PIPE_ACCESS_INBOUND  \/\/ read access\n+                   : PIPE_ACCESS_DUPLEX,  \/\/ read-write access\n@@ -380,0 +394,32 @@\n+\/*\n+ * Class:     sun_tools_attach_VirtualMachineImpl\n+ * Method:    writePipe\n+ * Signature: (J[BII)V\n+ *\/\n+JNIEXPORT void JNICALL Java_sun_tools_attach_VirtualMachineImpl_writePipe\n+  (JNIEnv *env, jclass cls, jlong hPipe, jbyteArray buffer, jint offset, jint length)\n+{\n+    jsize remaining = length;\n+    do {\n+        jbyte buf[128];\n+        jsize len = sizeof(buf);\n+        DWORD written;\n+\n+        if (len > remaining) {\n+            len = remaining;\n+        }\n+        (*env)->GetByteArrayRegion(env, buffer, offset, len, buf);\n+\n+        BOOL fSuccess = WriteFile((HANDLE)hPipe, buf, len, &written, NULL);\n+\n+        if (!fSuccess) {\n+            JNU_ThrowIOExceptionWithLastError(env, \"WriteFile\");\n+            return;\n+        }\n+\n+        offset += written;\n+        remaining -= written;\n+\n+    } while (remaining > 0);\n+}\n+\n@@ -386,2 +432,2 @@\n-  (JNIEnv *env, jclass cls, jlong handle, jbyteArray stub, jstring cmd,\n-   jstring pipename, jobjectArray args)\n+  (JNIEnv *env, jclass cls, jlong handle, jbyteArray stub, jint ver,\n+   jstring cmd, jstring pipename, jobjectArray args)\n@@ -402,0 +448,2 @@\n+    data.version = ver;\n+\n@@ -408,0 +456,1 @@\n+    strcpy(data.func_v2, \"JVM_EnqueueOperation_v2\");\n","filename":"src\/jdk.attach\/windows\/native\/libattach\/VirtualMachineImpl.c","additions":66,"deletions":17,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-import com.sun.tools.javac.code.Type.UnknownType;\n@@ -411,3 +410,0 @@\n-        \/\/ Create the unknown type\n-        unknownType = new UnknownType();\n-\n@@ -486,2 +482,2 @@\n-        unknownSymbol.members_field = new Scope.ErrorScope(unknownSymbol);\n-        unknownSymbol.type = unknownType;\n+        \/\/ Create the unknown type\n+        unknownType = new ErrorType(unknownSymbol, Type.noType);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -503,1 +503,1 @@\n-            sb.append(getAnnotationMirrors());\n+            sb.append(getAnnotationMirrors().toString(\" \"));\n@@ -2411,24 +2411,0 @@\n-    public static class UnknownType extends Type {\n-\n-        public UnknownType() {\n-            \/\/ Unknown is a synthesized internal type, so it cannot be\n-            \/\/ annotated.\n-            super(null, List.nil());\n-        }\n-\n-        @Override\n-        public TypeTag getTag() {\n-            return UNKNOWN;\n-        }\n-\n-        @Override @DefinedBy(Api.LANGUAGE_MODEL)\n-        public <R, P> R accept(TypeVisitor<R, P> v, P p) {\n-            return v.visitUnknown(this, p);\n-        }\n-\n-        @Override\n-        public boolean isPartial() {\n-            return true;\n-        }\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -124,4 +124,0 @@\n-    \/** The tag of an unknown type\n-     *\/\n-    UNKNOWN,\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeTag.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1219,1 +1219,1 @@\n-                if (t == s || t.qtype == s || s.hasTag(ERROR) || s.hasTag(UNKNOWN)) {\n+                if (t == s || t.qtype == s || s.hasTag(ERROR)) {\n@@ -1469,1 +1469,1 @@\n-                if (t == s || t.qtype == s || s.hasTag(ERROR) || s.hasTag(UNKNOWN)) {\n+                if (t == s || t.qtype == s || s.hasTag(ERROR)) {\n@@ -2425,1 +2425,1 @@\n-                             NONE, ERROR, UNKNOWN, UNDETVAR, UNINITIALIZED_THIS,\n+                             NONE, ERROR, UNDETVAR, UNINITIALIZED_THIS,\n@@ -3331,0 +3331,4 @@\n+    \/* this class won't substitute all types for example UndetVars are never substituted, this is\n+     * by design as UndetVars are used locally during inference and shouldn't escape from inference routines,\n+     * some specialized applications could need a tailored solution\n+     *\/\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -804,2 +804,2 @@\n-        boolean isSubtype(Type s, Type t, Warner warn) {\n-            return doIncorporationOp(IncorporationBinaryOpKind.IS_SUBTYPE, s, t, warn);\n+        boolean isSubtype(Type s, Type t, Warner warn, InferenceContext ic) {\n+            return doIncorporationOp(IncorporationBinaryOpKind.IS_SUBTYPE, s, t, warn, ic);\n@@ -811,2 +811,2 @@\n-        boolean isSameType(Type s, Type t) {\n-            return doIncorporationOp(IncorporationBinaryOpKind.IS_SAME_TYPE, s, t, null);\n+        boolean isSameType(Type s, Type t, InferenceContext ic) {\n+            return doIncorporationOp(IncorporationBinaryOpKind.IS_SAME_TYPE, s, t, null, ic);\n@@ -856,1 +856,1 @@\n-                    boolean success = checkBound(t, b, from, to, warn);\n+                    boolean success = checkBound(t, b, from, to, warn, inferenceContext);\n@@ -876,1 +876,1 @@\n-        boolean checkBound(Type s, Type t, InferenceBound ib_s, InferenceBound ib_t, Warner warn) {\n+        boolean checkBound(Type s, Type t, InferenceBound ib_s, InferenceBound ib_t, Warner warn, InferenceContext ic) {\n@@ -878,1 +878,1 @@\n-                return isSubtype(s, t, warn);\n+                return isSubtype(s, t, warn, ic);\n@@ -880,1 +880,1 @@\n-                return isSubtype(t, s, warn);\n+                return isSubtype(t, s, warn, ic);\n@@ -882,1 +882,1 @@\n-                return isSameType(s, t);\n+                return isSameType(s, t, ic);\n@@ -1013,1 +1013,1 @@\n-                                        inferenceContext.asUndetVar(allParamsSuperBound2.head))) {\n+                                        inferenceContext.asUndetVar(allParamsSuperBound2.head), inferenceContext)) {\n@@ -1197,2 +1197,2 @@\n-    boolean doIncorporationOp(IncorporationBinaryOpKind opKind, Type op1, Type op2, Warner warn) {\n-            IncorporationBinaryOp newOp = new IncorporationBinaryOp(opKind, op1, op2);\n+    boolean doIncorporationOp(IncorporationBinaryOpKind opKind, Type op1, Type op2, Warner warn, InferenceContext ic) {\n+            IncorporationBinaryOpKey newOp = new IncorporationBinaryOpKey(opKind, ic.asTypeVar(op1), ic.asTypeVar(op2), types);\n@@ -1201,1 +1201,1 @@\n-                incorporationCache.put(newOp, res = newOp.apply(warn));\n+                incorporationCache.put(newOp, res = opKind.apply(op1, op2, warn, types));\n@@ -1235,12 +1235,1 @@\n-    class IncorporationBinaryOp {\n-\n-        IncorporationBinaryOpKind opKind;\n-        Type op1;\n-        Type op2;\n-\n-        IncorporationBinaryOp(IncorporationBinaryOpKind opKind, Type op1, Type op2) {\n-            this.opKind = opKind;\n-            this.op1 = op1;\n-            this.op2 = op2;\n-        }\n-\n+    record IncorporationBinaryOpKey(IncorporationBinaryOpKind opKind, Type op1, Type op2, Types types) {\n@@ -1249,4 +1238,4 @@\n-            return (o instanceof IncorporationBinaryOp incorporationBinaryOp)\n-                    && opKind == incorporationBinaryOp.opKind\n-                    && types.isSameType(op1, incorporationBinaryOp.op1)\n-                    && types.isSameType(op2, incorporationBinaryOp.op2);\n+            return (o instanceof IncorporationBinaryOpKey anotherKey)\n+                    && opKind == anotherKey.opKind\n+                    && types.isSameType(op1, anotherKey.op1)\n+                    && types.isSameType(op2, anotherKey.op2);\n@@ -1254,1 +1243,0 @@\n-\n@@ -1264,4 +1252,0 @@\n-\n-        boolean apply(Warner warn) {\n-            return opKind.apply(op1, op2, warn, types);\n-        }\n@@ -1271,1 +1255,1 @@\n-    Map<IncorporationBinaryOp, Boolean> incorporationCache = new LinkedHashMap<>();\n+    Map<IncorporationBinaryOpKey, Boolean> incorporationCache = new LinkedHashMap<>();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Infer.java","additions":19,"deletions":35,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -217,0 +217,14 @@\n+    \/**\n+     * Replace all undet vars in a given type with corresponding free variables\n+     *\/\n+    public final Type asTypeVar(Type t) {\n+        return asTypeVarFun.apply(t);\n+    }\n+\n+    Types.TypeMapping<Void> asTypeVarFun = new Type.StructuralTypeMapping<>() {\n+        @Override\n+        public Type visitUndetVar(UndetVar uv, Void aVoid) {\n+            return uv.qtype;\n+        }\n+    };\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/InferenceContext.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,9 @@\n-        return this.nameMap.computeIfAbsent(string, s -> new NameImpl(this, intern ? s.intern() : s));\n+        Name name = nameMap.get(string);\n+        if (name == null) {\n+            if (intern) {\n+                string = string.intern();\n+            }\n+            name = new NameImpl(this, string);\n+            nameMap.put(string, name);\n+        }\n+        return name;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/StringNameTable.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -434,2 +434,0 @@\n-     * @param switchpointFallback the fallback method handle in case a switch\n-     * point is invalidated.\n@@ -438,0 +436,2 @@\n+     * @param switchpointFallback the fallback method handle in case a switch\n+     * point is invalidated.\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/linker\/GuardedInvocation.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,1 @@\n-    long minFillerArraySize = Array.baseOffsetInBytes(BasicType.T_INT);\n+    long labAlignmentReserve = VM.getVM().getLabAlignmentReserve();\n@@ -82,1 +82,1 @@\n-    return Math.max(minFillerArraySize, reserveForAllocationPrefetch * heapWordSize);\n+    return Math.max(labAlignmentReserve, reserveForAllocationPrefetch) * heapWordSize;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ThreadLocalAllocBuffer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,0 +130,1 @@\n+  private int          labAlignmentReserve;\n@@ -141,6 +142,6 @@\n-  private static Type intType;\n-  private static Type uintType;\n-  private static Type intxType;\n-  private static Type uintxType;\n-  private static Type sizetType;\n-  private static Type uint64tType;\n+  private static CIntegerType intType;\n+  private static CIntegerType uintType;\n+  private static CIntegerType intxType;\n+  private static CIntegerType uintxType;\n+  private static CIntegerType sizetType;\n+  private static CIntegerType uint64tType;\n@@ -435,5 +436,0 @@\n-\n-       Type threadLocalAllocBuffer = db.lookupType(\"ThreadLocalAllocBuffer\");\n-       CIntegerType intType = (CIntegerType) db.lookupType(\"int\");\n-       CIntegerField reserveForAllocationPrefetchField = threadLocalAllocBuffer.getCIntegerField(\"_reserve_for_allocation_prefetch\");\n-       reserveForAllocationPrefetch = (int)reserveForAllocationPrefetchField.getCInteger(intType);\n@@ -446,0 +442,17 @@\n+    \/\/ Initialize common primitive types\n+    intType = (CIntegerType) db.lookupType(\"int\");\n+    uintType = (CIntegerType) db.lookupType(\"uint\");\n+    intxType = (CIntegerType) db.lookupType(\"intx\");\n+    uintxType = (CIntegerType) db.lookupType(\"uintx\");\n+    sizetType = (CIntegerType) db.lookupType(\"size_t\");\n+    uint64tType = (CIntegerType) db.lookupType(\"uint64_t\");\n+    boolType = (CIntegerType) db.lookupType(\"bool\");\n+\n+    Type threadLocalAllocBuffer = db.lookupType(\"ThreadLocalAllocBuffer\");\n+    CIntegerField reserveForAllocationPrefetchField = threadLocalAllocBuffer.getCIntegerField(\"_reserve_for_allocation_prefetch\");\n+    reserveForAllocationPrefetch = (int)reserveForAllocationPrefetchField.getCInteger(intType);\n+\n+    Type collectedHeap = db.lookupType(\"CollectedHeap\");\n+    CIntegerField labAlignmentReserveField = collectedHeap.getCIntegerField(\"_lab_alignment_reserve\");\n+    labAlignmentReserve = (int)labAlignmentReserveField.getCInteger(sizetType);\n+\n@@ -496,8 +509,0 @@\n-    intType = db.lookupType(\"int\");\n-    uintType = db.lookupType(\"uint\");\n-    intxType = db.lookupType(\"intx\");\n-    uintxType = db.lookupType(\"uintx\");\n-    sizetType = db.lookupType(\"size_t\");\n-    uint64tType = db.lookupType(\"uint64_t\");\n-    boolType = (CIntegerType) db.lookupType(\"bool\");\n-\n@@ -932,0 +937,4 @@\n+  public int getLabAlignmentReserve() {\n+    return labAlignmentReserve;\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/VM.java","additions":29,"deletions":20,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -259,0 +259,1 @@\n+        SHA512,\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/amd64\/AMD64.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import java.util.HashSet;\n+import java.util.Set;\n@@ -215,0 +217,7 @@\n+            \/\/ Extract options\n+            new Option(false, OptionType.EXTRACT, \"--keep-old-files\", \"-k\") {\n+                void process(Main jartool, String opt, String arg) {\n+                    jartool.kflag = true;\n+                }\n+            },\n+\n@@ -248,0 +257,8 @@\n+            },\n+            new Option(true, true, OptionType.EXTRACT, \"--dir\") {\n+                void process(Main jartool, String opt, String arg) throws BadArgs {\n+                    if (jartool.xdestDir != null) {\n+                        throw new BadArgs(\"error.extract.multiple.dest.dir\").showUsage(true);\n+                    }\n+                    jartool.xdestDir = arg;\n+                }\n@@ -257,0 +274,1 @@\n+        EXTRACT(\"extract\"),\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/GNUStyleOptions.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -158,0 +158,1 @@\n+     * kflag: keep existing file\n@@ -159,1 +160,1 @@\n-    boolean cflag, uflag, xflag, tflag, vflag, flag0, Mflag, iflag, pflag, dflag, validate;\n+    boolean cflag, uflag, xflag, tflag, vflag, flag0, Mflag, iflag, pflag, dflag, kflag, validate;\n@@ -163,0 +164,3 @@\n+    \/\/ destination directory for extraction\n+    String xdestDir = null;\n+\n@@ -375,0 +379,9 @@\n+                if (xdestDir != null) {\n+                    final Path destPath = Paths.get(xdestDir);\n+                    try {\n+                        Files.createDirectories(destPath);\n+                    } catch (IOException ioe) {\n+                        throw new IOException(formatMsg(\"error.create.dir\",\n+                                destPath.toString()), ioe);\n+                    }\n+                }\n@@ -585,0 +598,3 @@\n+                        case 'k':\n+                            kflag = true;\n+                            break;\n@@ -615,0 +631,3 @@\n+        if (kflag && !xflag) {\n+            warn(formatMsg(\"warn.option.is.ignored\", \"--keep-old-files\/-k\/k\"));\n+        }\n@@ -634,0 +653,5 @@\n+                        if (xflag && xdestDir != null) {\n+                            \/\/ extract option doesn't allow more than one destination directory\n+                            usageError(getMsg(\"error.extract.multiple.dest.dir\"));\n+                            return false;\n+                        }\n@@ -645,2 +669,6 @@\n-                        pathsMap.get(version).add(dir);\n-                        nameBuf[k++] = dir + args[++i];\n+                        if (xflag) {\n+                            xdestDir = dir;\n+                        } else {\n+                            pathsMap.get(version).add(dir);\n+                            nameBuf[k++] = dir + args[++i];\n+                        }\n@@ -705,0 +733,4 @@\n+        if (xflag && pflag && xdestDir != null) {\n+            usageError(getMsg(\"error.extract.pflag.not.allowed\"));\n+            return false;\n+        }\n@@ -1358,1 +1390,1 @@\n-                    File f = new File(name.replace('\/', File.separatorChar));\n+                    File f = new File(xdestDir, name.replace('\/', File.separatorChar));\n@@ -1369,0 +1401,4 @@\n+        if (vflag) {\n+            output(formatMsg(\"out.extract.dir\", Path.of(xdestDir == null ? \".\" : xdestDir).normalize()\n+                    .toAbsolutePath().toString()));\n+        }\n@@ -1397,0 +1433,4 @@\n+        if (vflag) {\n+            output(formatMsg(\"out.extract.dir\", Path.of(xdestDir == null ? \".\" : xdestDir).normalize()\n+                    .toAbsolutePath().toString()));\n+        }\n@@ -1426,1 +1466,1 @@\n-        \/\/ The spec requres all slashes MUST be forward '\/', it is possible\n+        \/\/ The spec requires all slashes MUST be forward '\/', it is possible\n@@ -1429,1 +1469,1 @@\n-        \/\/ our \"safe\" check for leading slahs and dot-dot. So replace them\n+        \/\/ our \"safe\" check for leading slash and dot-dot. So replace them\n@@ -1435,1 +1475,9 @@\n-        File f = new File(name.replace('\/', File.separatorChar));\n+        \/\/ the xdestDir points to the user specified location where the jar needs to\n+        \/\/ be extracted. By default xdestDir is null and represents current working\n+        \/\/ directory.\n+        \/\/ jar extraction using -P option is only allowed when the destination\n+        \/\/ directory isn't specified (and hence defaults to current working directory).\n+        \/\/ In such cases using this java.io.File constructor which accepts a null parent path\n+        \/\/ allows us to extract entries that may have leading slashes and hence may need\n+        \/\/ to be extracted outside of the current directory.\n+        File f = new File(xdestDir, name.replace('\/', File.separatorChar));\n@@ -1455,0 +1503,6 @@\n+            if (f.exists() && kflag) {\n+                if (vflag) {\n+                    output(formatMsg(\"out.kept\", name));\n+                }\n+                return rc;\n+            }\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Main.java","additions":61,"deletions":7,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,4 @@\n+error.extract.multiple.dest.dir=\\\n+        You may not specify the '-C' or '--dir' option more than once with the '-x' option\n+error.extract.pflag.not.allowed=\\\n+        You may not specify '-Px' with the '-C' or '--dir' options\n@@ -146,0 +150,2 @@\n+warn.option.is.ignored=\\\n+        Warning: The {0} option is not valid with current usage, will be ignored.\n@@ -168,0 +174,2 @@\n+out.kept=\\\n+        \\ \\ skipped: {0} exists\n@@ -172,0 +180,2 @@\n+out.extract.dir=\\\n+        extracting to directory: {0}\n@@ -193,0 +203,1 @@\n+When used in extract mode, extracts the jar to the specified directory\\n\\\n@@ -248,1 +259,4 @@\n-\\  -x, --extract              Extract named (or all) files from the archive\n+\\  -x, --extract              Extract named (or all) files from the archive.\\n\\\n+\\                             If a file with the same name appears more than once in\\n\\\n+\\                             the archive, each copy will be extracted, with later copies\\n\\\n+\\                             overwriting (replacing) earlier copies unless -k is specified.\n@@ -260,1 +274,2 @@\n-\\                             following file\n+\\                             following file. When used in extract mode, extracts\\n\\\n+\\                             the jar to the specified directory\n@@ -310,0 +325,9 @@\n+main.help.opt.extract=\\\n+\\ Operation modifiers valid only in extract mode:\\n\n+main.help.opt.extract.keep-old-files=\\\n+\\  -k, --keep-old-files       Do not overwrite existing files.\\n\\\n+\\                             If a Jar file entry with the same name exists in the target\\n\\\n+\\                             directory, the existing file will not be overwritten.\\n\\\n+\\                             As a result, if a file appears more than once in an\\n\\\n+\\                             archive, later copies will not overwrite earlier copies.\\n\\\n+\\                             Also note that some file system can be case insensitive.\n@@ -327,0 +351,4 @@\n+main.help.opt.extract=\\\n+\\ Operation modifiers valid only in extract mode:\\n\n+main.help.opt.extract.dir=\\\n+\\  --dir                    Directory into which the jar will be extracted\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/resources\/jar.properties","additions":31,"deletions":3,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-.\\\" Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+.\\\" Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,0 +121,3 @@\n+If a file with the same name appears more than once in the archive, each\n+copy will be extracted, with later copies overwriting (replacing)\n+earlier copies unless -k is specified.\n@@ -130,2 +133,3 @@\n-Changes the specified directory and includes the \\f[I]files\\f[R]\n-specified at the end of the command line.\n+When used with the create operation mode, changes the specified\n+directory and includes the \\f[I]files\\f[R] specified at the end of the\n+command line.\n@@ -137,0 +141,5 @@\n+.PP\n+When used with the extract operation mode, specifies the destination\n+directory where the JAR file will be extracted.\n+Unlike with the create operation mode, this option can be specified only\n+once with the extract operation mode.\n@@ -205,0 +214,12 @@\n+.SH OPERATION MODIFIERS VALID ONLY IN EXTRACT MODE\n+.TP\n+\\f[V]--dir\\f[R] \\f[I]DIR\\f[R]\n+Directory into which the JAR file will be extracted.\n+.TP\n+\\f[V]-k\\f[R] or \\f[V]--keep-old-files\\f[R]\n+Do not overwrite existing files.\n+If a Jar file entry with the same name exists in the target directory,\n+the existing file will not be overwritten.\n+As a result, if a file appears more than once in an archive, later\n+copies will not overwrite earlier copies.\n+Also note that some file system can be case insensitive.\n@@ -345,0 +366,14 @@\n+.IP \\[bu] 2\n+Extract the JAR file \\f[V]foo.jar\\f[R] to \\f[V]\/tmp\/bar\/\\f[R] directory:\n+.RS 2\n+.RS\n+.PP\n+\\f[V]jar -xf foo.jar -C \/tmp\/bar\/\\f[R]\n+.RE\n+.PP\n+Alternatively, you can also do:\n+.RS\n+.PP\n+\\f[V]jar --extract --file foo.jar --dir \/tmp\/bar\/\\f[R]\n+.RE\n+.RE\n","filename":"src\/jdk.jartool\/share\/man\/jar.1","additions":38,"deletions":3,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,0 @@\n-     * @param value the new value\n@@ -113,0 +112,1 @@\n+     * @param value the new value\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/ArrayReference.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -264,1 +264,0 @@\n-     * @param depth the step depth\n@@ -266,0 +265,1 @@\n+     * @param depth the step depth\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/request\/EventRequestManager.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -84,3 +84,0 @@\n-static jboolean allowStartViaJcmd = JNI_FALSE;  \/* if true we allow the debugging to be started via a jcmd *\/\n-static jboolean startedViaJcmd = JNI_FALSE;     \/* if false, we have not yet started debugging via a jcmd *\/\n-\n@@ -986,1 +983,0 @@\n-    jboolean onJcmd = JNI_FALSE;\n@@ -1234,4 +1230,0 @@\n-        } else if (strcmp(buf, \"onjcmd\") == 0) {\n-            if (!get_boolean(&str, &onJcmd)) {\n-                goto syntax_error;\n-            }\n@@ -1288,14 +1280,0 @@\n-    if (onJcmd) {\n-        if (launchOnInit != NULL) {\n-            errmsg = \"Cannot combine onjcmd and launch suboptions\";\n-            goto bad_option_with_errmsg;\n-        }\n-        if (!isServer) {\n-            errmsg = \"Can only use onjcmd with server=y\";\n-            goto bad_option_with_errmsg;\n-        }\n-        suspendOnInit = JNI_FALSE;\n-        initOnStartup = JNI_FALSE;\n-        allowStartViaJcmd = JNI_TRUE;\n-    }\n-\n@@ -1370,42 +1348,0 @@\n-\n-static jboolean getFirstTransport(void *item, void *arg)\n-{\n-    TransportSpec** store = arg;\n-    *store = item;\n-\n-    return JNI_FALSE; \/* Want the first *\/\n-}\n-\n-\/* Call to start up debugging. *\/\n-JNIEXPORT char const* JNICALL debugInit_startDebuggingViaCommand(JNIEnv* env, jthread thread, char const** transport_name,\n-                                                                char const** address, jboolean* first_start) {\n-    jboolean is_first_start = JNI_FALSE;\n-    TransportSpec* spec = NULL;\n-\n-    if (!vmInitialized) {\n-        return \"Not yet initialized. Try again later.\";\n-    }\n-\n-    if (!allowStartViaJcmd) {\n-        return \"Starting debugging via jcmd was not enabled via the onjcmd option of the jdwp agent.\";\n-    }\n-\n-    if (!startedViaJcmd) {\n-        startedViaJcmd = JNI_TRUE;\n-        is_first_start = JNI_TRUE;\n-        initialize(env, thread, EI_VM_INIT, NULL);\n-    }\n-\n-    bagEnumerateOver(transports, getFirstTransport, &spec);\n-\n-    if ((spec != NULL) && (transport_name != NULL) && (address != NULL)) {\n-        *transport_name = spec->name;\n-        *address = spec->address;\n-    }\n-\n-    if (first_start != NULL) {\n-        *first_start = is_first_start;\n-    }\n-\n-    return NULL;\n-}\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/debugInit.c","additions":0,"deletions":64,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.io.IOException;\n@@ -151,14 +150,0 @@\n-\n-            \/\/ Signing will not work without Xcode with command line developer tools\n-            try {\n-                ProcessBuilder pb = new ProcessBuilder(\"\/usr\/bin\/xcrun\", \"--help\");\n-                Process p = pb.start();\n-                int code = p.waitFor();\n-                if (code != 0) {\n-                    throw new ConfigException(\n-                        I18N.getString(\"error.no.xcode.signing\"),\n-                        I18N.getString(\"error.no.xcode.signing.advice\"));\n-                }\n-            } catch (IOException | InterruptedException ex) {\n-                throw new ConfigException(ex);\n-            }\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacAppBundler.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-import static jdk.jpackage.internal.MacBaseInstallerBundler.SIGNING_KEY_USER;\n@@ -79,2 +78,0 @@\n-import static jdk.jpackage.internal.StandardBundlerParam.getPredefinedAppImage;\n-import static jdk.jpackage.internal.StandardBundlerParam.hasPredefinedAppImage;\n@@ -757,0 +754,8 @@\n+                \/\/ Signing might not work without Xcode with command line\n+                \/\/ developer tools. Show user if Xcode is missing as possible\n+                \/\/ reason.\n+                if (!isXcodeDevToolsInstalled()) {\n+                    Log.info(I18N.getString(\n+                        \"message.codesign.failed.reason.xcode.tools\"));\n+                }\n+\n@@ -767,0 +772,10 @@\n+    private static boolean isXcodeDevToolsInstalled() {\n+        try {\n+            Executor.of(\"\/usr\/bin\/xcrun\", \"--help\").executeExpectSuccess();\n+        } catch (IOException e) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacAppImageBuilder.java","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -42,2 +42,0 @@\n-error.no.xcode.signing=Xcode with command line developer tools is required for signing\n-error.no.xcode.signing.advice=Install Xcode with command line developer tools.\n@@ -98,0 +96,1 @@\n+message.codesign.failed.reason.xcode.tools=Possible reason for \"codesign\" failure is missing Xcode with command line developer tools. Install Xcode with command line developer tools to see if it resolves the problem.\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/MacResources.properties","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,2 +42,0 @@\n-error.no.xcode.signing=Für die Signatur ist Xcode mit Befehlszeilen-Entwicklertools erforderlich\n-error.no.xcode.signing.advice=Installieren Sie Xcode mit Befehlszeilen-Entwicklertools.\n@@ -98,0 +96,1 @@\n+message.codesign.failed.reason.xcode.tools=Possible reason for \"codesign\" failure is missing Xcode with command line developer tools. Install Xcode with command line developer tools to see if it resolves the problem.\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/MacResources_de.properties","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,2 +42,0 @@\n-error.no.xcode.signing=署名には、Xcodeとコマンドライン・デベロッパ・ツールが必要です\n-error.no.xcode.signing.advice=Xcodeとコマンドライン・デベロッパ・ツールをインストールしてください。\n@@ -98,0 +96,1 @@\n+message.codesign.failed.reason.xcode.tools=Possible reason for \"codesign\" failure is missing Xcode with command line developer tools. Install Xcode with command line developer tools to see if it resolves the problem.\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/MacResources_ja.properties","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,2 +42,0 @@\n-error.no.xcode.signing=需要使用带命令行开发人员工具的 Xcode 进行签名\n-error.no.xcode.signing.advice=安装带命令行开发人员工具的 Xcode。\n@@ -98,0 +96,1 @@\n+message.codesign.failed.reason.xcode.tools=Possible reason for \"codesign\" failure is missing Xcode with command line developer tools. Install Xcode with command line developer tools to see if it resolves the problem.\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/MacResources_zh_CN.properties","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+ * @deprecated The jdk.jsobject module will be delivered with JavaFX.\n@@ -32,0 +33,2 @@\n+@Deprecated(since = \"24\", forRemoval = true)\n+@SuppressWarnings(\"removal\")\n","filename":"src\/jdk.jsobject\/share\/classes\/module-info.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+ * @deprecated The jdk.jsobject module will be delivered with JavaFX.\n@@ -34,0 +35,2 @@\n+@Deprecated(since = \"24\", forRemoval = true)\n+@SuppressWarnings(\"removal\")\n","filename":"src\/jdk.jsobject\/share\/classes\/netscape\/javascript\/JSException.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+ * @deprecated The jdk.jsobject module will be delivered with JavaFX.\n@@ -48,0 +49,2 @@\n+@Deprecated(since = \"24\", forRemoval = true)\n+@SuppressWarnings(\"removal\")\n","filename":"src\/jdk.jsobject\/share\/classes\/netscape\/javascript\/JSObject.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,6 @@\n+ * <p>\n+ * <b>Deprecated, for removal: This API element is subject to removal\n+ * in a future version.<\/b><br>\n+ * <em>The jdk.jsobject module will be delivered with JavaFX.<\/em>\n+ * <\/p>\n+ *\n","filename":"src\/jdk.jsobject\/share\/classes\/netscape\/javascript\/package-info.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -484,4 +484,0 @@\n-     * @param  association\n-     *         The association whose option should be set, or {@code null}\n-     *         if this option should be set at the channel's socket level.\n-     *\n@@ -492,0 +488,4 @@\n+     * @param  association\n+     *         The association whose option should be set, or {@code null}\n+     *         if this option should be set at the channel's socket level.\n+     *\n","filename":"src\/jdk.sctp\/share\/classes\/com\/sun\/nio\/sctp\/SctpMultiChannel.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+###########################################################################\n+#\n+# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+###########################################################################\n+\n+#############################################################################\n+#\n+# List of quarantined tests -- tests that should not be run by default, because\n+# they may fail due to known reason. The reason (CR#) must be mandatory specified.\n+#\n+# List items are testnames followed by labels, all MUST BE commented\n+#   as to why they are here and use a label:\n+#     generic-all   Problems on all platforms\n+#     generic-ARCH  Where ARCH is one of: x64, i586, ppc64, ppc64le, s390x etc.\n+#     OSNAME-all    Where OSNAME is one of: linux, windows, macosx, aix\n+#     OSNAME-ARCH   Specific on to one OSNAME and ARCH, e.g. macosx-x64\n+#     OSNAME-REV    Specific on to one OSNAME and REV, e.g. macosx-10.7.4\n+#\n+# More than one label is allowed but must be on the same line.\n+#\n+#############################################################################\n","filename":"test\/docs\/ProblemList.txt","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+#\n+# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+#\n+\n+# This file identifies the root of the test-suite hierarchy.\n+# It also contains test-suite configuration information.\n+\n+# The list of keywords supported in the entire test suite.  The\n+# \"intermittent\" keyword marks tests known to fail intermittently.\n+# The \"randomness\" keyword marks tests using randomness with test\n+# cases differing from run to run. (A test using a fixed random seed\n+# would not count as \"randomness\" by this definition.) Extra care\n+# should be taken to handle test failures of intermittent or\n+# randomness tests.\n+\n+# Group definitions\n+groups=TEST.groups\n+\n+# Minimum jtreg version\n+requiredVersion=7.4+1\n+\n+# Use new module options\n+useNewOptions=true\n+\n+# Use --patch-module instead of -Xmodule:\n+useNewPatchModule=true\n+\n+# Path to libraries in the topmost test directory. This is needed so @library\n+# does not need ..\/..\/ notation to reach them\n+external.lib.roots = ..\/..\/\n","filename":"test\/docs\/TEST.ROOT","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+#  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+#  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+#  This code is free software; you can redistribute it and\/or modify it\n+#  under the terms of the GNU General Public License version 2 only, as\n+#  published by the Free Software Foundation.\n+#\n+#  This code is distributed in the hope that it will be useful, but WITHOUT\n+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+#  version 2 for more details (a copy is included in the LICENSE file that\n+#  accompanied this code).\n+#\n+#  You should have received a copy of the GNU General Public License version\n+#  2 along with this work; if not, write to the Free Software Foundation,\n+#  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+#  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+#  or visit www.oracle.com if you need additional information or have any\n+#  questions.\n+#\n+\n+# Docs-specific test groups\n+\n+docs_all = \\\n+    \/\n+\n+tier2 = \\\n+    :docs_all\n","filename":"test\/docs\/TEST.groups","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib ..\/..\/tools\/tester\n+ * @build jtreg.SkippedException\n+ * @summary example of a test on the generated documentation\n+ * @run main TestDocs\n+ *\/\n+\n+import java.nio.file.Files;\n+\n+public class TestDocs {\n+    public static void main(String... args) throws Exception {\n+        var docs = DocTester.resolveDocs();\n+        System.err.println(\"Path to the docs is: \" + docs);\n+        System.err.println(\"Do docs exits?\");\n+        System.err.println(Files.exists(docs));\n+        System.err.println(\"tidy location\");\n+        System.err.println(System.getProperty(\"tidy\"));\n+        System.err.println(\"End of test\");\n+    }\n+}\n","filename":"test\/docs\/jdk\/javadoc\/TestDocs.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import jtreg.SkippedException;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+\/**\n+ * Test framework for performing tests on the generated documentation.\n+ *\/\n+public class DocTester {\n+    private final static String DIR = System.getenv(\"DOCS_JDK_IMAGE_DIR\");\n+    private static final Path firstCandidate = Path.of(System.getProperty(\"test.jdk\"))\n+            .getParent().resolve(\"docs\");\n+\n+    public static Path resolveDocs() {\n+        if (DIR != null && !DIR.isBlank() && Files.exists(Path.of(DIR))) {\n+            return Path.of(DIR);\n+        } else if (Files.exists(firstCandidate)) {\n+            return firstCandidate;\n+        }else {\n+            throw new SkippedException(\"docs folder not found in either location\");\n+        }\n+    }\n+}\n","filename":"test\/docs\/tools\/tester\/DocTester.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,1293 @@\n+\/\/ BEGIN  Generated code -- do not edit\n+\/\/ Generated by x86-asmtest.py\n+#ifdef _LP64\n+    __ shldl(r22, r14);                                                         \/\/    {load}shld r22d, r14d    IID0\n+#endif \/\/ _LP64\n+    __ shrdl(rcx, rbx);                                                         \/\/    {load}shrd ecx, ebx    IID1\n+#ifdef _LP64\n+    __ adcl(r24, r18);                                                          \/\/    {load}adc r24d, r18d    IID2\n+    __ cmpl(r8, r19);                                                           \/\/    {load}cmp r8d, r19d    IID3\n+    __ imull(r25, r19);                                                         \/\/    {load}imul r25d, r19d    IID4\n+    __ popcntl(r19, r15);                                                       \/\/    {load}popcnt r19d, r15d    IID5\n+    __ sbbl(r21, r19);                                                          \/\/    {load}sbb r21d, r19d    IID6\n+    __ subl(r17, r29);                                                          \/\/    {load}sub r17d, r29d    IID7\n+    __ tzcntl(r21, rdx);                                                        \/\/    {load}tzcnt r21d, edx    IID8\n+    __ lzcntl(rcx, r23);                                                        \/\/    {load}lzcnt ecx, r23d    IID9\n+    __ addl(r10, r11);                                                          \/\/    {load}add r10d, r11d    IID10\n+    __ andl(r21, r14);                                                          \/\/    {load}and r21d, r14d    IID11\n+    __ orl(r12, r30);                                                           \/\/    {load}or r12d, r30d    IID12\n+    __ xorl(r19, r30);                                                          \/\/    {load}xor r19d, r30d    IID13\n+    __ movl(r27, r11);                                                          \/\/    {load}mov r27d, r11d    IID14\n+    __ bsfl(r10, r12);                                                          \/\/    {load}bsf r10d, r12d    IID15\n+    __ bsrl(r16, r10);                                                          \/\/    {load}bsr r16d, r10d    IID16\n+    __ xchgl(r16, r28);                                                         \/\/    {load}xchg r16d, r28d    IID17\n+    __ testl(r25, r16);                                                         \/\/    {load}test r25d, r16d    IID18\n+    __ addb(Address(r27, rdx, (Address::ScaleFactor)1, +0x6f304723), rcx);      \/\/    add byte ptr [r27+rdx*2+0x6f304723], cl    IID19\n+    __ addw(Address(r19, rcx, (Address::ScaleFactor)2, +0x17244c57), r17);      \/\/    add word ptr [r19+rcx*4+0x17244c57], r17w    IID20\n+    __ addl(Address(r23, r16, (Address::ScaleFactor)1, +0x138df419), r19);      \/\/    add dword ptr [r23+r16*2+0x138df419], r19d    IID21\n+    __ adcl(Address(r8, r11, (Address::ScaleFactor)3, -0x164f7a73), rcx);       \/\/    adc dword ptr [r8+r11*8-0x164f7a73], ecx    IID22\n+    __ andb(Address(rdx, r17, (Address::ScaleFactor)3, +0x4df7f181), r22);      \/\/    and byte ptr [rdx+r17*8+0x4df7f181], r22b    IID23\n+    __ andl(Address(r15, -0x41884769), r23);                                    \/\/    and dword ptr [r15-0x41884769], r23d    IID24\n+    __ cmpb(Address(r20, r18, (Address::ScaleFactor)0, -0x1b827588), r8);       \/\/    cmp byte ptr [r20+r18*1-0x1b827588], r8b    IID25\n+    __ cmpw(Address(r9, r22, (Address::ScaleFactor)3, +0x564ead70), r31);       \/\/    cmp word ptr [r9+r22*8+0x564ead70], r31w    IID26\n+    __ cmpl(Address(r10, r24, (Address::ScaleFactor)2, +0xf08ffec), rcx);       \/\/    cmp dword ptr [r10+r24*4+0xf08ffec], ecx    IID27\n+    __ orb(Address(r27, r15, (Address::ScaleFactor)0, +0xf18eac7), r19);        \/\/    or byte ptr [r27+r15*1+0xf18eac7], r19b    IID28\n+    __ orl(Address(r16, r31, (Address::ScaleFactor)2, +0x3a452790), r12);       \/\/    or dword ptr [r16+r31*4+0x3a452790], r12d    IID29\n+    __ xorb(Address(r20, r13, (Address::ScaleFactor)0, +0x61dde6b7), r10);      \/\/    xor byte ptr [r20+r13*1+0x61dde6b7], r10b    IID30\n+    __ xorl(Address(r27, -0x77a99463), rbx);                                    \/\/    xor dword ptr [r27-0x77a99463], ebx    IID31\n+    __ subl(Address(r9, r11, (Address::ScaleFactor)0, +0x4e20f145), r10);       \/\/    sub dword ptr [r9+r11*1+0x4e20f145], r10d    IID32\n+    __ movb(Address(r23, r23, (Address::ScaleFactor)0, -0x3f51b77), r10);       \/\/    mov byte ptr [r23+r23*1-0x3f51b77], r10b    IID33\n+    __ movl(Address(r31, r22, (Address::ScaleFactor)0, +0xfac5466), r30);       \/\/    mov dword ptr [r31+r22*1+0xfac5466], r30d    IID34\n+    __ xaddb(Address(rbx, -0x70025991), r31);                                   \/\/    xadd byte ptr [rbx-0x70025991], r31b    IID35\n+    __ xaddw(Address(r17, r26, (Address::ScaleFactor)1, -0x530c0221), r29);     \/\/    xadd word ptr [r17+r26*2-0x530c0221], r29w    IID36\n+    __ xaddl(Address(r9, r21, (Address::ScaleFactor)0, -0x7b7336bf), r17);      \/\/    xadd dword ptr [r9+r21*1-0x7b7336bf], r17d    IID37\n+    __ adcl(Address(r24, r12, (Address::ScaleFactor)2, +0x691b07e5), 65536);    \/\/    adc dword ptr [r24+r12*4+0x691b07e5], 65536    IID38\n+    __ andl(Address(r14, r9, (Address::ScaleFactor)0, -0x115d5957), 16);        \/\/    and dword ptr [r14+r9*1-0x115d5957], 16    IID39\n+    __ addb(Address(r21, -0x1d3e83ad), 64);                                     \/\/    add byte ptr [r21-0x1d3e83ad], 64    IID40\n+    __ addw(Address(r12, +0x3a7acf9a), 4096);                                   \/\/    add word ptr [r12+0x3a7acf9a], 4096    IID41\n+    __ addl(Address(r30, r14, (Address::ScaleFactor)1, -0x2073ed16), 256);      \/\/    add dword ptr [r30+r14*2-0x2073ed16], 256    IID42\n+    __ cmpb(Address(r28, r18, (Address::ScaleFactor)0, +0x6fd326d5), 16);       \/\/    cmp byte ptr [r28+r18*1+0x6fd326d5], 16    IID43\n+    __ cmpw(Address(r12, r14, (Address::ScaleFactor)1, +0x2ae6568f), 256);      \/\/    cmp word ptr [r12+r14*2+0x2ae6568f], 256    IID44\n+    __ cmpl(Address(r24, r30, (Address::ScaleFactor)3, -0x11b9aeac), 1048576);  \/\/    cmp dword ptr [r24+r30*8-0x11b9aeac], 1048576    IID45\n+    __ sarl(Address(r22, r30, (Address::ScaleFactor)2, +0x60cb9115), 1);        \/\/    sar dword ptr [r22+r30*4+0x60cb9115], 1    IID46\n+    __ sall(Address(r31, r8, (Address::ScaleFactor)1, +0x236d8ab9), 16);        \/\/    sal dword ptr [r31+r8*2+0x236d8ab9], 16    IID47\n+    __ sbbl(Address(r21, r12, (Address::ScaleFactor)1, -0x7d9b9f18), 16777216); \/\/    sbb dword ptr [r21+r12*2-0x7d9b9f18], 16777216    IID48\n+    __ shrl(Address(r29, r17, (Address::ScaleFactor)0, -0x7c54f216), 8);        \/\/    shr dword ptr [r29+r17*1-0x7c54f216], 8    IID49\n+    __ subl(Address(r8, r27, (Address::ScaleFactor)2, -0x1190e2c6), 16);        \/\/    sub dword ptr [r8+r27*4-0x1190e2c6], 16    IID50\n+    __ xorl(Address(rdx, +0x50dd3396), 1048576);                                \/\/    xor dword ptr [rdx+0x50dd3396], 1048576    IID51\n+    __ orb(Address(r20, -0x7dd1f614), 64);                                      \/\/    or byte ptr [r20-0x7dd1f614], 64    IID52\n+    __ orl(Address(r18, +0x6f852a9f), 16);                                      \/\/    or dword ptr [r18+0x6f852a9f], 16    IID53\n+    __ movb(Address(r20, r8, (Address::ScaleFactor)2, +0x436e2aa), 1);          \/\/    mov byte ptr [r20+r8*4+0x436e2aa], 1    IID54\n+    __ movl(Address(rcx, r14, (Address::ScaleFactor)1, +0x883df84), 16);        \/\/    mov dword ptr [rcx+r14*2+0x883df84], 16    IID55\n+    __ testb(Address(r11, r10, (Address::ScaleFactor)1, -0x1fc2039b), 16);      \/\/    test byte ptr [r11+r10*2-0x1fc2039b], 16    IID56\n+    __ testl(Address(r29, +0x73b9f003), 67108864);                              \/\/    test dword ptr [r29+0x73b9f003], 67108864    IID57\n+    __ cmpl_imm32(Address(r29, rcx, (Address::ScaleFactor)2, +0x4ca2b092), 4194304); \/\/    cmp dword ptr [r29+rcx*4+0x4ca2b092], 4194304    IID58\n+    __ addl(r8, Address(rdx, r24, (Address::ScaleFactor)2, -0x1e1524dc));       \/\/    add r8d, dword ptr [rdx+r24*4-0x1e1524dc]    IID59\n+    __ andl(r19, Address(r20, r20, (Address::ScaleFactor)1, +0x6286892));       \/\/    and r19d, dword ptr [r20+r20*2+0x6286892]    IID60\n+    __ cmpb(r11, Address(r13, -0x42e0bf9e));                                    \/\/    cmp r11b, byte ptr [r13-0x42e0bf9e]    IID61\n+    __ cmpl(r20, Address(rbx, r30, (Address::ScaleFactor)3, -0x30497735));      \/\/    cmp r20d, dword ptr [rbx+r30*8-0x30497735]    IID62\n+    __ lzcntl(r8, Address(rdx, r9, (Address::ScaleFactor)1, +0xe2e99e));        \/\/    lzcnt r8d, dword ptr [rdx+r9*2+0xe2e99e]    IID63\n+    __ orl(r9, Address(r29, r25, (Address::ScaleFactor)1, +0x50169f63));        \/\/    or r9d, dword ptr [r29+r25*2+0x50169f63]    IID64\n+    __ adcl(r17, Address(r31, r21, (Address::ScaleFactor)3, +0x79efd170));      \/\/    adc r17d, dword ptr [r31+r21*8+0x79efd170]    IID65\n+    __ imull(r23, Address(r8, -0xa521f73));                                     \/\/    imul r23d, dword ptr [r8-0xa521f73]    IID66\n+    __ popcntl(r30, Address(r10, +0x44352901));                                 \/\/    popcnt r30d, dword ptr [r10+0x44352901]    IID67\n+    __ sbbl(r16, Address(r18, r14, (Address::ScaleFactor)1, -0xda8278a));       \/\/    sbb r16d, dword ptr [r18+r14*2-0xda8278a]    IID68\n+    __ subl(r17, Address(r22, +0x2d63aab3));                                    \/\/    sub r17d, dword ptr [r22+0x2d63aab3]    IID69\n+    __ tzcntl(r23, Address(r21, r11, (Address::ScaleFactor)0, -0x18bc7469));    \/\/    tzcnt r23d, dword ptr [r21+r11*1-0x18bc7469]    IID70\n+    __ xorb(r9, Address(r19, rdx, (Address::ScaleFactor)0, -0x5f6207ed));       \/\/    xor r9b, byte ptr [r19+rdx*1-0x5f6207ed]    IID71\n+    __ xorw(r11, Address(r21, r10, (Address::ScaleFactor)2, -0x63c79f2b));      \/\/    xor r11w, word ptr [r21+r10*4-0x63c79f2b]    IID72\n+    __ xorl(r29, Address(r31, rcx, (Address::ScaleFactor)3, +0x34d93c0f));      \/\/    xor r29d, dword ptr [r31+rcx*8+0x34d93c0f]    IID73\n+    __ movb(r17, Address(r8, r18, (Address::ScaleFactor)2, -0x38ff3ad7));       \/\/    mov r17b, byte ptr [r8+r18*4-0x38ff3ad7]    IID74\n+    __ movl(r31, Address(r20, r11, (Address::ScaleFactor)2, -0x1d23470c));      \/\/    mov r31d, dword ptr [r20+r11*4-0x1d23470c]    IID75\n+    __ leal(r31, Address(rbx, r12, (Address::ScaleFactor)2, -0x3b4a4215));      \/\/    lea r31d, dword ptr [rbx+r12*4-0x3b4a4215]    IID76\n+    __ xchgb(r20, Address(r30, r24, (Address::ScaleFactor)0, -0x5c4e82bc));     \/\/    xchg r20b, byte ptr [r30+r24*1-0x5c4e82bc]    IID77\n+    __ xchgw(r13, Address(r10, r21, (Address::ScaleFactor)3, +0x19bd4a03));     \/\/    xchg r13w, word ptr [r10+r21*8+0x19bd4a03]    IID78\n+    __ xchgl(r23, Address(r16, r13, (Address::ScaleFactor)2, -0x6a0293d6));     \/\/    xchg r23d, dword ptr [r16+r13*4-0x6a0293d6]    IID79\n+    __ testl(r13, Address(r9, +0x34a6ff61));                                    \/\/    test r13d, dword ptr [r9+0x34a6ff61]    IID80\n+    __ addb(r23, 4);                                                            \/\/    add r23b, 4    IID81\n+    __ addl(r28, 65536);                                                        \/\/    add r28d, 65536    IID82\n+#endif \/\/ _LP64\n+    __ andl(rdx, 65536);                                                        \/\/    and edx, 65536    IID83\n+#ifdef _LP64\n+    __ adcl(r27, 1048576);                                                      \/\/    adc r27d, 1048576    IID84\n+    __ cmpb(r13, 4);                                                            \/\/    cmp r13b, 4    IID85\n+    __ cmpl(r29, 268435456);                                                    \/\/    cmp r29d, 268435456    IID86\n+    __ rcll(r20, 16);                                                           \/\/    rcl r20d, 16    IID87\n+    __ roll(r25, 2);                                                            \/\/    rol r25d, 2    IID88\n+#endif \/\/ _LP64\n+    __ rorl(rdx, 4);                                                            \/\/    ror edx, 4    IID89\n+    __ sarl(rcx, 1);                                                            \/\/    sar ecx, 1    IID90\n+#ifdef _LP64\n+    __ sall(r19, 16);                                                           \/\/    sal r19d, 16    IID91\n+    __ sbbl(r9, 1);                                                             \/\/    sbb r9d, 1    IID92\n+    __ shll(r20, 8);                                                            \/\/    shl r20d, 8    IID93\n+#endif \/\/ _LP64\n+    __ shrl(rcx, 1);                                                            \/\/    shr ecx, 1    IID94\n+#ifdef _LP64\n+    __ subl(r19, 16777216);                                                     \/\/    sub r19d, 16777216    IID95\n+    __ xorl(r16, 4096);                                                         \/\/    xor r16d, 4096    IID96\n+    __ movl(r24, 65536);                                                        \/\/    mov r24d, 65536    IID97\n+    __ testb(r20, 64);                                                          \/\/    test r20b, 64    IID98\n+    __ testl(r28, 16777216);                                                    \/\/    test r28d, 16777216    IID99\n+    __ subl_imm32(r29, 262144);                                                 \/\/    sub r29d, 262144    IID100\n+    __ cmovl(Assembler::Condition::overflow, r8, Address(r26, r28, (Address::ScaleFactor)1, +0x210f06d)); \/\/    cmovo r8d, dword ptr [r26+r28*2+0x210f06d]    IID101\n+    __ cmovl(Assembler::Condition::noOverflow, rbx, Address(r18, rbx, (Address::ScaleFactor)0, -0x264fce2a)); \/\/    cmovno ebx, dword ptr [r18+rbx*1-0x264fce2a]    IID102\n+    __ cmovl(Assembler::Condition::below, r29, Address(r17, r24, (Address::ScaleFactor)0, +0x46c06acb)); \/\/    cmovb r29d, dword ptr [r17+r24*1+0x46c06acb]    IID103\n+    __ cmovl(Assembler::Condition::aboveEqual, r17, Address(r25, r11, (Address::ScaleFactor)3, -0x3b21f455)); \/\/    cmovae r17d, dword ptr [r25+r11*8-0x3b21f455]    IID104\n+    __ cmovl(Assembler::Condition::zero, r23, Address(r20, r31, (Address::ScaleFactor)0, -0x5a03317b)); \/\/    cmovz r23d, dword ptr [r20+r31*1-0x5a03317b]    IID105\n+    __ cmovl(Assembler::Condition::notZero, r31, Address(r31, r15, (Address::ScaleFactor)2, -0x53fc2e65)); \/\/    cmovnz r31d, dword ptr [r31+r15*4-0x53fc2e65]    IID106\n+    __ cmovl(Assembler::Condition::belowEqual, r28, Address(rdx, rcx, (Address::ScaleFactor)3, -0x3bc9229f)); \/\/    cmovbe r28d, dword ptr [rdx+rcx*8-0x3bc9229f]    IID107\n+    __ cmovl(Assembler::Condition::above, r31, Address(rdx, r19, (Address::ScaleFactor)3, +0x7bf1761c)); \/\/    cmova r31d, dword ptr [rdx+r19*8+0x7bf1761c]    IID108\n+    __ cmovl(Assembler::Condition::negative, rdx, Address(r17, r18, (Address::ScaleFactor)0, -0x1da2fc03)); \/\/    cmovs edx, dword ptr [r17+r18*1-0x1da2fc03]    IID109\n+    __ cmovl(Assembler::Condition::positive, r9, Address(r21, r23, (Address::ScaleFactor)2, -0x2799454a)); \/\/    cmovns r9d, dword ptr [r21+r23*4-0x2799454a]    IID110\n+    __ cmovl(Assembler::Condition::parity, r27, Address(r13, -0x654c249c));     \/\/    cmovp r27d, dword ptr [r13-0x654c249c]    IID111\n+    __ cmovl(Assembler::Condition::noParity, rdx, Address(r24, r10, (Address::ScaleFactor)3, +0x6c96beb2)); \/\/    cmovnp edx, dword ptr [r24+r10*8+0x6c96beb2]    IID112\n+    __ cmovl(Assembler::Condition::less, r9, Address(rcx, r8, (Address::ScaleFactor)3, +0x573e1892)); \/\/    cmovl r9d, dword ptr [rcx+r8*8+0x573e1892]    IID113\n+    __ cmovl(Assembler::Condition::greaterEqual, r31, Address(r26, r14, (Address::ScaleFactor)2, +0x717110b1)); \/\/    cmovge r31d, dword ptr [r26+r14*4+0x717110b1]    IID114\n+    __ cmovl(Assembler::Condition::lessEqual, r24, Address(r19, r14, (Address::ScaleFactor)2, +0x119faad7)); \/\/    cmovle r24d, dword ptr [r19+r14*4+0x119faad7]    IID115\n+    __ cmovl(Assembler::Condition::greater, r12, Address(r13, r12, (Address::ScaleFactor)0, +0xd537805)); \/\/    cmovg r12d, dword ptr [r13+r12*1+0xd537805]    IID116\n+    __ setb(Assembler::Condition::overflow, r10);                               \/\/    seto r10b    IID117\n+#endif \/\/ _LP64\n+    __ setb(Assembler::Condition::noOverflow, rbx);                             \/\/    setno bl    IID118\n+#ifdef _LP64\n+    __ setb(Assembler::Condition::below, r13);                                  \/\/    setb r13b    IID119\n+    __ setb(Assembler::Condition::aboveEqual, r23);                             \/\/    setae r23b    IID120\n+    __ setb(Assembler::Condition::zero, r24);                                   \/\/    setz r24b    IID121\n+    __ setb(Assembler::Condition::notZero, r15);                                \/\/    setnz r15b    IID122\n+    __ setb(Assembler::Condition::belowEqual, r21);                             \/\/    setbe r21b    IID123\n+    __ setb(Assembler::Condition::above, r17);                                  \/\/    seta r17b    IID124\n+    __ setb(Assembler::Condition::negative, r10);                               \/\/    sets r10b    IID125\n+    __ setb(Assembler::Condition::positive, r24);                               \/\/    setns r24b    IID126\n+    __ setb(Assembler::Condition::parity, r16);                                 \/\/    setp r16b    IID127\n+    __ setb(Assembler::Condition::noParity, r28);                               \/\/    setnp r28b    IID128\n+    __ setb(Assembler::Condition::less, r11);                                   \/\/    setl r11b    IID129\n+    __ setb(Assembler::Condition::greaterEqual, r25);                           \/\/    setge r25b    IID130\n+    __ setb(Assembler::Condition::lessEqual, r18);                              \/\/    setle r18b    IID131\n+    __ setb(Assembler::Condition::greater, r14);                                \/\/    setg r14b    IID132\n+    __ divl(r30);                                                               \/\/    div r30d    IID133\n+    __ idivl(r23);                                                              \/\/    idiv r23d    IID134\n+    __ imull(r28);                                                              \/\/    imul r28d    IID135\n+    __ mull(r31);                                                               \/\/    mul r31d    IID136\n+    __ negl(r27);                                                               \/\/    neg r27d    IID137\n+    __ notl(r16);                                                               \/\/    not r16d    IID138\n+#endif \/\/ _LP64\n+    __ roll(rdx);                                                               \/\/    rol edx, cl    IID139\n+#ifdef _LP64\n+    __ rorl(r12);                                                               \/\/    ror r12d, cl    IID140\n+    __ sarl(r14);                                                               \/\/    sar r14d, cl    IID141\n+    __ sall(r19);                                                               \/\/    sal r19d, cl    IID142\n+    __ shll(r10);                                                               \/\/    shl r10d, cl    IID143\n+    __ shrl(r20);                                                               \/\/    shr r20d, cl    IID144\n+#endif \/\/ _LP64\n+    __ incrementl(rbx);                                                         \/\/    inc ebx    IID145\n+#ifdef _LP64\n+    __ decrementl(r14);                                                         \/\/    dec r14d    IID146\n+    __ mull(Address(r12, -0x57a4fa5e));                                         \/\/    mul dword ptr [r12-0x57a4fa5e]    IID147\n+    __ negl(Address(rbx, -0x3db4cfc7));                                         \/\/    neg dword ptr [rbx-0x3db4cfc7]    IID148\n+    __ sarl(Address(r21, -0x7e70ad30));                                         \/\/    sar dword ptr [r21-0x7e70ad30], cl    IID149\n+    __ sall(Address(r21, r28, (Address::ScaleFactor)3, -0x23456bc9));           \/\/    sal dword ptr [r21+r28*8-0x23456bc9], cl    IID150\n+    __ shrl(Address(r11, r13, (Address::ScaleFactor)1, -0xe00fc44));            \/\/    shr dword ptr [r11+r13*2-0xe00fc44], cl    IID151\n+    __ incrementl(Address(r19, -0x5e6ad56a));                                   \/\/    inc dword ptr [r19-0x5e6ad56a]    IID152\n+    __ decrementl(Address(rcx, r20, (Address::ScaleFactor)0, -0x2530b9c4));     \/\/    dec dword ptr [rcx+r20*1-0x2530b9c4]    IID153\n+    __ imull(r17, Address(r8, r24, (Address::ScaleFactor)1, +0x2efecf26), 1048576); \/\/    imul r17d, dword ptr [r8+r24*2+0x2efecf26], 1048576    IID154\n+    __ imull(r9, r8, 268435456);                                                \/\/    imul r9d, r8d, 268435456    IID155\n+    __ shldl(r10, r15, 8);                                                      \/\/    shld r10d, r15d, 8    IID156\n+    __ shrdl(r29, r22, 2);                                                      \/\/    shrd r29d, r22d, 2    IID157\n+    __ movzbl(r14, Address(r19, -0x6c33584));                                   \/\/    movzx r14d, byte ptr [r19-0x6c33584]    IID158\n+    __ movzwl(r25, Address(r12, r27, (Address::ScaleFactor)0, +0x2d05fa44));    \/\/    movzx r25d, word ptr [r12+r27*1+0x2d05fa44]    IID159\n+    __ movsbl(r12, Address(r30, r15, (Address::ScaleFactor)0, +0x65bccac1));    \/\/    movsx r12d, byte ptr [r30+r15*1+0x65bccac1]    IID160\n+    __ movswl(r26, Address(r10, r24, (Address::ScaleFactor)0, +0x1d707459));    \/\/    movsx r26d, word ptr [r10+r24*1+0x1d707459]    IID161\n+    __ movzbl(r18, r8);                                                         \/\/    movzx r18d, r8b    IID162\n+    __ movzwl(r31, r9);                                                         \/\/    movzx r31d, r9w    IID163\n+    __ movsbl(r15, r22);                                                        \/\/    movsx r15d, r22b    IID164\n+    __ movswl(r24, r24);                                                        \/\/    movsx r24d, r24w    IID165\n+    __ cmpxchgb(r18, Address(r12, r28, (Address::ScaleFactor)1, -0x4855a65f));  \/\/    cmpxchg byte ptr [r12+r28*2-0x4855a65f], r18b    IID166\n+    __ cmpxchgw(r28, Address(rdx, r14, (Address::ScaleFactor)3, +0x16f5a558));  \/\/    cmpxchg word ptr [rdx+r14*8+0x16f5a558], r28w    IID167\n+    __ cmpxchgl(rdx, Address(r18, rdx, (Address::ScaleFactor)1, +0x50258d9c));  \/\/    cmpxchg dword ptr [r18+rdx*2+0x50258d9c], edx    IID168\n+#endif \/\/ _LP64\n+#ifdef _LP64\n+    __ adcq(r9, rbx);                                                           \/\/    {load}adc r9, rbx    IID169\n+    __ cmpq(r26, r24);                                                          \/\/    {load}cmp r26, r24    IID170\n+    __ imulq(r14, rdx);                                                         \/\/    {load}imul r14, rdx    IID171\n+    __ popcntq(r25, r30);                                                       \/\/    {load}popcnt r25, r30    IID172\n+    __ sbbq(r24, r19);                                                          \/\/    {load}sbb r24, r19    IID173\n+    __ subq(r15, r11);                                                          \/\/    {load}sub r15, r11    IID174\n+    __ tzcntq(r18, r21);                                                        \/\/    {load}tzcnt r18, r21    IID175\n+    __ lzcntq(r15, r27);                                                        \/\/    {load}lzcnt r15, r27    IID176\n+    __ addq(r21, r20);                                                          \/\/    {load}add r21, r20    IID177\n+    __ andq(r11, r26);                                                          \/\/    {load}and r11, r26    IID178\n+    __ orq(r29, r15);                                                           \/\/    {load}or r29, r15    IID179\n+    __ xorq(r24, r21);                                                          \/\/    {load}xor r24, r21    IID180\n+    __ movq(r14, r13);                                                          \/\/    {load}mov r14, r13    IID181\n+    __ bsfq(r11, r22);                                                          \/\/    {load}bsf r11, r22    IID182\n+    __ bsrq(r14, r23);                                                          \/\/    {load}bsr r14, r23    IID183\n+    __ btq(r22, rcx);                                                           \/\/    {load}bt r22, rcx    IID184\n+    __ xchgq(r25, r29);                                                         \/\/    {load}xchg r25, r29    IID185\n+    __ testq(r15, r8);                                                          \/\/    {load}test r15, r8    IID186\n+    __ addq(Address(r14, r10, (Address::ScaleFactor)3, -0x36e6fa02), r16);      \/\/    add qword ptr [r14+r10*8-0x36e6fa02], r16    IID187\n+    __ andq(Address(rbx, r8, (Address::ScaleFactor)3, -0x279a21b8), r18);       \/\/    and qword ptr [rbx+r8*8-0x279a21b8], r18    IID188\n+    __ cmpq(Address(r24, +0x62c3c9ef), r13);                                    \/\/    cmp qword ptr [r24+0x62c3c9ef], r13    IID189\n+    __ orq(Address(r11, r22, (Address::ScaleFactor)2, +0x419fb378), r11);       \/\/    or qword ptr [r11+r22*4+0x419fb378], r11    IID190\n+    __ xorq(Address(r25, r14, (Address::ScaleFactor)2, -0x32b449dd), r13);      \/\/    xor qword ptr [r25+r14*4-0x32b449dd], r13    IID191\n+    __ subq(Address(r28, r31, (Address::ScaleFactor)3, +0x6ce1d361), r19);      \/\/    sub qword ptr [r28+r31*8+0x6ce1d361], r19    IID192\n+    __ movq(Address(r25, r25, (Address::ScaleFactor)2, -0x3f5767c), r11);       \/\/    mov qword ptr [r25+r25*4-0x3f5767c], r11    IID193\n+    __ xaddq(Address(r19, r17, (Address::ScaleFactor)3, +0x1febf06c), r20);     \/\/    xadd qword ptr [r19+r17*8+0x1febf06c], r20    IID194\n+    __ andq(Address(r26, r17, (Address::ScaleFactor)1, -0x6b865f05), 65536);    \/\/    and qword ptr [r26+r17*2-0x6b865f05], 65536    IID195\n+    __ addq(Address(r27, -0x6ec95d87), 65536);                                  \/\/    add qword ptr [r27-0x6ec95d87], 65536    IID196\n+    __ cmpq(Address(rbx, r26, (Address::ScaleFactor)2, -0x1eabea4), 1048576);   \/\/    cmp qword ptr [rbx+r26*4-0x1eabea4], 1048576    IID197\n+    __ sarq(Address(rbx, r19, (Address::ScaleFactor)0, +0x3c3c3de8), 8);        \/\/    sar qword ptr [rbx+r19*1+0x3c3c3de8], 8    IID198\n+    __ salq(Address(r20, r23, (Address::ScaleFactor)1, +0x68519b6d), 8);        \/\/    sal qword ptr [r20+r23*2+0x68519b6d], 8    IID199\n+    __ sbbq(Address(r31, r22, (Address::ScaleFactor)0, -0x7b3d1e85), 16);       \/\/    sbb qword ptr [r31+r22*1-0x7b3d1e85], 16    IID200\n+    __ shrq(Address(r15, r18, (Address::ScaleFactor)3, +0x4d9d824), 4);         \/\/    shr qword ptr [r15+r18*8+0x4d9d824], 4    IID201\n+    __ subq(Address(rdx, r29, (Address::ScaleFactor)2, +0x7e4aea85), 1);        \/\/    sub qword ptr [rdx+r29*4+0x7e4aea85], 1    IID202\n+    __ xorq(Address(r23, r10, (Address::ScaleFactor)1, +0x2895c620), 16777216); \/\/    xor qword ptr [r23+r10*2+0x2895c620], 16777216    IID203\n+    __ orq(Address(r14, r13, (Address::ScaleFactor)0, -0x771b399b), 1);         \/\/    or qword ptr [r14+r13*1-0x771b399b], 1    IID204\n+    __ movq(Address(r22, -0x63459b5a), 256);                                    \/\/    mov qword ptr [r22-0x63459b5a], 256    IID205\n+    __ testq(Address(r13, -0xb9691c5), -1);                                     \/\/    test qword ptr [r13-0xb9691c5], -1    IID206\n+    __ addq(r17, Address(r15, -0x51b64b0d));                                    \/\/    add r17, qword ptr [r15-0x51b64b0d]    IID207\n+    __ andq(rcx, Address(r16, rcx, (Address::ScaleFactor)3, -0x1c8e4b54));      \/\/    and rcx, qword ptr [r16+rcx*8-0x1c8e4b54]    IID208\n+    __ cmpq(r23, Address(r17, rcx, (Address::ScaleFactor)3, -0x44705560));      \/\/    cmp r23, qword ptr [r17+rcx*8-0x44705560]    IID209\n+    __ lzcntq(r19, Address(r19, +0x487fe792));                                  \/\/    lzcnt r19, qword ptr [r19+0x487fe792]    IID210\n+    __ orq(r11, Address(r17, -0x65de4329));                                     \/\/    or r11, qword ptr [r17-0x65de4329]    IID211\n+    __ adcq(r29, Address(r9, -0x7092dc03));                                     \/\/    adc r29, qword ptr [r9-0x7092dc03]    IID212\n+    __ imulq(r9, Address(r26, r26, (Address::ScaleFactor)3, -0x118287f7));      \/\/    imul r9, qword ptr [r26+r26*8-0x118287f7]    IID213\n+    __ popcntq(r19, Address(r15, r19, (Address::ScaleFactor)1, -0x6e31ef95));   \/\/    popcnt r19, qword ptr [r15+r19*2-0x6e31ef95]    IID214\n+    __ sbbq(r30, Address(r23, -0x46545c5e));                                    \/\/    sbb r30, qword ptr [r23-0x46545c5e]    IID215\n+    __ subq(r23, Address(r31, r18, (Address::ScaleFactor)3, +0x663c37d8));      \/\/    sub r23, qword ptr [r31+r18*8+0x663c37d8]    IID216\n+    __ tzcntq(r24, Address(r24, r25, (Address::ScaleFactor)3, -0x465a78f1));    \/\/    tzcnt r24, qword ptr [r24+r25*8-0x465a78f1]    IID217\n+    __ xorq(r14, Address(r15, r19, (Address::ScaleFactor)1, +0x4196affa));      \/\/    xor r14, qword ptr [r15+r19*2+0x4196affa]    IID218\n+    __ movq(rdx, Address(r25, r29, (Address::ScaleFactor)1, +0x115a6157));      \/\/    mov rdx, qword ptr [r25+r29*2+0x115a6157]    IID219\n+    __ leaq(r19, Address(r28, r31, (Address::ScaleFactor)2, +0x6b82f933));      \/\/    lea r19, qword ptr [r28+r31*4+0x6b82f933]    IID220\n+    __ cvttsd2siq(rcx, Address(r24, r21, (Address::ScaleFactor)3, -0x39dc99eb)); \/\/    cvttsd2si rcx, qword ptr [r24+r21*8-0x39dc99eb]    IID221\n+    __ xchgq(r29, Address(r17, r24, (Address::ScaleFactor)3, +0x5902f01d));     \/\/    xchg r29, qword ptr [r17+r24*8+0x5902f01d]    IID222\n+    __ testq(r12, Address(r24, r29, (Address::ScaleFactor)2, +0x8865bfc));      \/\/    test r12, qword ptr [r24+r29*4+0x8865bfc]    IID223\n+    __ addq(r10, 16);                                                           \/\/    add r10, 16    IID224\n+    __ andq(r26, 256);                                                          \/\/    and r26, 256    IID225\n+    __ adcq(rcx, 1);                                                            \/\/    adc rcx, 1    IID226\n+    __ cmpq(r21, 65536);                                                        \/\/    cmp r21, 65536    IID227\n+    __ rclq(r28, 4);                                                            \/\/    rcl r28, 4    IID228\n+    __ rcrq(r28, 16);                                                           \/\/    rcr r28, 16    IID229\n+    __ rolq(r18, 1);                                                            \/\/    rol r18, 1    IID230\n+    __ rorq(r26, 2);                                                            \/\/    ror r26, 2    IID231\n+    __ sarq(r19, 2);                                                            \/\/    sar r19, 2    IID232\n+    __ salq(r14, 8);                                                            \/\/    sal r14, 8    IID233\n+    __ sbbq(r10, 65536);                                                        \/\/    sbb r10, 65536    IID234\n+    __ shlq(r30, 1);                                                            \/\/    shl r30, 1    IID235\n+    __ shrq(r15, 8);                                                            \/\/    shr r15, 8    IID236\n+    __ subq(r21, 1048576);                                                      \/\/    sub r21, 1048576    IID237\n+    __ xorq(rbx, 268435456);                                                    \/\/    xor rbx, 268435456    IID238\n+    __ movq(r19, 16);                                                           \/\/    mov r19, 16    IID239\n+    __ mov64(r19, 17179869184);                                                 \/\/    mov r19, 17179869184    IID240\n+    __ btq(r21, 1);                                                             \/\/    bt r21, 1    IID241\n+    __ testq(r15, -65536);                                                      \/\/    test r15, -65536    IID242\n+    __ orq_imm32(r21, 1073741824);                                              \/\/    or r21, 1073741824    IID243\n+    __ subq_imm32(r19, 65536);                                                  \/\/    sub r19, 65536    IID244\n+    __ cmovq(Assembler::Condition::overflow, r15, Address(r29, -0x5c98219a));   \/\/    cmovo r15, qword ptr [r29-0x5c98219a]    IID245\n+    __ cmovq(Assembler::Condition::noOverflow, rcx, Address(r21, +0x22cc581));  \/\/    cmovno rcx, qword ptr [r21+0x22cc581]    IID246\n+    __ cmovq(Assembler::Condition::below, r15, Address(r29, r13, (Address::ScaleFactor)2, -0x5e968fb9)); \/\/    cmovb r15, qword ptr [r29+r13*4-0x5e968fb9]    IID247\n+    __ cmovq(Assembler::Condition::aboveEqual, r26, Address(r24, +0x440c6894)); \/\/    cmovae r26, qword ptr [r24+0x440c6894]    IID248\n+    __ cmovq(Assembler::Condition::zero, r17, Address(r23, r26, (Address::ScaleFactor)3, +0x23558b4e)); \/\/    cmovz r17, qword ptr [r23+r26*8+0x23558b4e]    IID249\n+    __ cmovq(Assembler::Condition::notZero, r9, Address(r16, r29, (Address::ScaleFactor)3, -0x1289a3c9)); \/\/    cmovnz r9, qword ptr [r16+r29*8-0x1289a3c9]    IID250\n+    __ cmovq(Assembler::Condition::belowEqual, r8, Address(r11, -0x49e134cc));  \/\/    cmovbe r8, qword ptr [r11-0x49e134cc]    IID251\n+    __ cmovq(Assembler::Condition::above, r26, Address(r11, r20, (Address::ScaleFactor)1, -0x3ef9057a)); \/\/    cmova r26, qword ptr [r11+r20*2-0x3ef9057a]    IID252\n+    __ cmovq(Assembler::Condition::negative, r11, Address(r26, r13, (Address::ScaleFactor)2, +0x4bd18f9f)); \/\/    cmovs r11, qword ptr [r26+r13*4+0x4bd18f9f]    IID253\n+    __ cmovq(Assembler::Condition::positive, r8, Address(r9, r11, (Address::ScaleFactor)3, +0x4b42a528)); \/\/    cmovns r8, qword ptr [r9+r11*8+0x4b42a528]    IID254\n+    __ cmovq(Assembler::Condition::parity, r12, Address(r19, r9, (Address::ScaleFactor)1, +0x68559a1c)); \/\/    cmovp r12, qword ptr [r19+r9*2+0x68559a1c]    IID255\n+    __ cmovq(Assembler::Condition::noParity, r22, Address(r18, r17, (Address::ScaleFactor)1, +0x2c4d8e80)); \/\/    cmovnp r22, qword ptr [r18+r17*2+0x2c4d8e80]    IID256\n+    __ cmovq(Assembler::Condition::less, r26, Address(r18, r30, (Address::ScaleFactor)0, -0x2ae8896e)); \/\/    cmovl r26, qword ptr [r18+r30*1-0x2ae8896e]    IID257\n+    __ cmovq(Assembler::Condition::greaterEqual, r22, Address(r11, +0x4fefa622)); \/\/    cmovge r22, qword ptr [r11+0x4fefa622]    IID258\n+    __ cmovq(Assembler::Condition::lessEqual, r28, Address(r18, r27, (Address::ScaleFactor)1, +0x6b7a8c34)); \/\/    cmovle r28, qword ptr [r18+r27*2+0x6b7a8c34]    IID259\n+    __ cmovq(Assembler::Condition::greater, r20, Address(r23, r20, (Address::ScaleFactor)0, -0x12e725c5)); \/\/    cmovg r20, qword ptr [r23+r20*1-0x12e725c5]    IID260\n+    __ call(r9);                                                                \/\/    call r9    IID261\n+    __ divq(r22);                                                               \/\/    div r22    IID262\n+    __ idivq(r29);                                                              \/\/    idiv r29    IID263\n+    __ imulq(rbx);                                                              \/\/    imul rbx    IID264\n+    __ mulq(r27);                                                               \/\/    mul r27    IID265\n+    __ negq(rbx);                                                               \/\/    neg rbx    IID266\n+    __ notq(r17);                                                               \/\/    not r17    IID267\n+    __ rolq(r25);                                                               \/\/    rol r25, cl    IID268\n+    __ rorq(rbx);                                                               \/\/    ror rbx, cl    IID269\n+    __ sarq(r17);                                                               \/\/    sar r17, cl    IID270\n+    __ salq(r28);                                                               \/\/    sal r28, cl    IID271\n+    __ shlq(r28);                                                               \/\/    shl r28, cl    IID272\n+    __ shrq(r30);                                                               \/\/    shr r30, cl    IID273\n+    __ incrementq(r27);                                                         \/\/    inc r27    IID274\n+    __ decrementq(rdx);                                                         \/\/    dec rdx    IID275\n+    __ pushp(r27);                                                              \/\/    pushp r27    IID276\n+    __ popp(r10);                                                               \/\/    popp r10    IID277\n+    __ call(Address(r27, -0x22db8705));                                         \/\/    call qword ptr [r27-0x22db8705]    IID278\n+    __ mulq(Address(r27, r21, (Address::ScaleFactor)0, -0x1f59ff9c));           \/\/    mul qword ptr [r27+r21*1-0x1f59ff9c]    IID279\n+    __ negq(Address(r19, rcx, (Address::ScaleFactor)3, +0x7a47b812));           \/\/    neg qword ptr [r19+rcx*8+0x7a47b812]    IID280\n+    __ sarq(Address(r18, r21, (Address::ScaleFactor)1, -0x48857a46));           \/\/    sar qword ptr [r18+r21*2-0x48857a46], cl    IID281\n+    __ salq(Address(r24, -0x7a2bda2c));                                         \/\/    sal qword ptr [r24-0x7a2bda2c], cl    IID282\n+    __ shrq(Address(r24, +0x1abd92f));                                          \/\/    shr qword ptr [r24+0x1abd92f], cl    IID283\n+    __ incrementq(Address(r9, r9, (Address::ScaleFactor)3, +0x31a92520));       \/\/    inc qword ptr [r9+r9*8+0x31a92520]    IID284\n+    __ decrementq(Address(r9, r8, (Address::ScaleFactor)0, +0x7f14b4bd));       \/\/    dec qword ptr [r9+r8*1+0x7f14b4bd]    IID285\n+    __ imulq(r14, Address(r29, r15, (Address::ScaleFactor)1, +0x5281cf9c), 256); \/\/    imul r14, qword ptr [r29+r15*2+0x5281cf9c], 256    IID286\n+    __ imulq(r16, r28, 1048576);                                                \/\/    imul r16, r28, 1048576    IID287\n+    __ shldq(r17, r24, 2);                                                      \/\/    shld r17, r24, 2    IID288\n+    __ shrdq(r16, r11, 2);                                                      \/\/    shrd r16, r11, 2    IID289\n+    __ pop2(r10, r11);                                                          \/\/    {load}pop2 r11, r10    IID290\n+    __ pop2p(r15, r24);                                                         \/\/    {load}pop2p r24, r15    IID291\n+    __ push2(r28, r11);                                                         \/\/    {load}push2 r11, r28    IID292\n+    __ push2p(r12, r31);                                                        \/\/    {load}push2p r31, r12    IID293\n+    __ movzbq(r24, Address(r22, r16, (Address::ScaleFactor)0, +0x511be837));    \/\/    movzx r24, byte ptr [r22+r16*1+0x511be837]    IID294\n+    __ movzwq(r15, Address(r15, r26, (Address::ScaleFactor)2, -0x38794ee));     \/\/    movzx r15, word ptr [r15+r26*4-0x38794ee]    IID295\n+    __ movsbq(r15, Address(r25, r16, (Address::ScaleFactor)3, -0x7a092741));    \/\/    movsx r15, byte ptr [r25+r16*8-0x7a092741]    IID296\n+    __ movswq(rdx, Address(r28, r19, (Address::ScaleFactor)2, +0x79da6a));      \/\/    movsx rdx, word ptr [r28+r19*4+0x79da6a]    IID297\n+    __ movzbq(r27, r9);                                                         \/\/    movzx r27, r9b    IID298\n+    __ movzwq(r25, r21);                                                        \/\/    movzx r25, r21w    IID299\n+    __ movsbq(r14, r12);                                                        \/\/    movsx r14, r12b    IID300\n+    __ movswq(r23, r11);                                                        \/\/    movsx r23, r11w    IID301\n+    __ cmpxchgq(r30, Address(r12, -0x65a974df));                                \/\/    cmpxchg qword ptr [r12-0x65a974df], r30    IID302\n+#endif \/\/ _LP64\n+\n+  static const uint8_t insns[] =\n+  {\n+#ifdef _LP64\n+    0xd5, 0x94, 0xa5, 0xf6,                                                          \/\/ IID0\n+#endif \/\/ _LP64\n+    0x0f, 0xad, 0xd9,                                                                \/\/ IID1\n+#ifdef _LP64\n+    0xd5, 0x54, 0x13, 0xc2,                                                          \/\/ IID2\n+    0xd5, 0x14, 0x3b, 0xc3,                                                          \/\/ IID3\n+    0xd5, 0xd4, 0xaf, 0xcb,                                                          \/\/ IID4\n+    0xf3, 0xd5, 0xc1, 0xb8, 0xdf,                                                    \/\/ IID5\n+    0xd5, 0x50, 0x1b, 0xeb,                                                          \/\/ IID6\n+    0xd5, 0x51, 0x2b, 0xcd,                                                          \/\/ IID7\n+    0xf3, 0xd5, 0xc0, 0xbc, 0xea,                                                    \/\/ IID8\n+    0xf3, 0xd5, 0x90, 0xbd, 0xcf,                                                    \/\/ IID9\n+    0x45, 0x03, 0xd3,                                                                \/\/ IID10\n+    0xd5, 0x41, 0x23, 0xee,                                                          \/\/ IID11\n+    0xd5, 0x15, 0x0b, 0xe6,                                                          \/\/ IID12\n+    0xd5, 0x51, 0x33, 0xde,                                                          \/\/ IID13\n+    0xd5, 0x45, 0x8b, 0xdb,                                                          \/\/ IID14\n+    0x45, 0x0f, 0xbc, 0xd4,                                                          \/\/ IID15\n+    0xd5, 0xc1, 0xbd, 0xc2,                                                          \/\/ IID16\n+    0xd5, 0x51, 0x87, 0xc4,                                                          \/\/ IID17\n+    0xd5, 0x54, 0x85, 0xc8,                                                          \/\/ IID18\n+    0xd5, 0x11, 0x00, 0x8c, 0x53, 0x23, 0x47, 0x30, 0x6f,                            \/\/ IID19\n+    0x66, 0xd5, 0x50, 0x01, 0x8c, 0x8b, 0x57, 0x4c, 0x24, 0x17,                      \/\/ IID20\n+    0xd5, 0x70, 0x01, 0x9c, 0x47, 0x19, 0xf4, 0x8d, 0x13,                            \/\/ IID21\n+    0x43, 0x11, 0x8c, 0xd8, 0x8d, 0x85, 0xb0, 0xe9,                                  \/\/ IID22\n+    0xd5, 0x60, 0x20, 0xb4, 0xca, 0x81, 0xf1, 0xf7, 0x4d,                            \/\/ IID23\n+    0xd5, 0x41, 0x21, 0xbf, 0x97, 0xb8, 0x77, 0xbe,                                  \/\/ IID24\n+    0xd5, 0x34, 0x38, 0x84, 0x14, 0x78, 0x8a, 0x7d, 0xe4,                            \/\/ IID25\n+    0x66, 0xd5, 0x65, 0x39, 0xbc, 0xf1, 0x70, 0xad, 0x4e, 0x56,                      \/\/ IID26\n+    0xd5, 0x23, 0x39, 0x8c, 0x82, 0xec, 0xff, 0x08, 0x0f,                            \/\/ IID27\n+    0xd5, 0x53, 0x08, 0x9c, 0x3b, 0xc7, 0xea, 0x18, 0x0f,                            \/\/ IID28\n+    0xd5, 0x36, 0x09, 0xa4, 0xb8, 0x90, 0x27, 0x45, 0x3a,                            \/\/ IID29\n+    0xd5, 0x16, 0x30, 0x94, 0x2c, 0xb7, 0xe6, 0xdd, 0x61,                            \/\/ IID30\n+    0xd5, 0x11, 0x31, 0x9b, 0x9d, 0x6b, 0x56, 0x88,                                  \/\/ IID31\n+    0x47, 0x29, 0x94, 0x19, 0x45, 0xf1, 0x20, 0x4e,                                  \/\/ IID32\n+    0xd5, 0x34, 0x88, 0x94, 0x3f, 0x89, 0xe4, 0x0a, 0xfc,                            \/\/ IID33\n+    0xd5, 0x75, 0x89, 0xb4, 0x37, 0x66, 0x54, 0xac, 0x0f,                            \/\/ IID34\n+    0xd5, 0xc4, 0xc0, 0xbb, 0x6f, 0xa6, 0xfd, 0x8f,                                  \/\/ IID35\n+    0x66, 0xd5, 0xf6, 0xc1, 0xac, 0x51, 0xdf, 0xfd, 0xf3, 0xac,                      \/\/ IID36\n+    0xd5, 0xe1, 0xc1, 0x8c, 0x29, 0x41, 0xc9, 0x8c, 0x84,                            \/\/ IID37\n+    0xd5, 0x13, 0x81, 0x94, 0xa0, 0xe5, 0x07, 0x1b, 0x69, 0x00, 0x00, 0x01, 0x00,    \/\/ IID38\n+    0x43, 0x83, 0xa4, 0x0e, 0xa9, 0xa6, 0xa2, 0xee, 0x10,                            \/\/ IID39\n+    0xd5, 0x10, 0x80, 0x85, 0x53, 0x7c, 0xc1, 0xe2, 0x40,                            \/\/ IID40\n+    0x66, 0x41, 0x81, 0x84, 0x24, 0x9a, 0xcf, 0x7a, 0x3a, 0x00, 0x10,                \/\/ IID41\n+    0xd5, 0x13, 0x81, 0x84, 0x76, 0xea, 0x12, 0x8c, 0xdf, 0x00, 0x01, 0x00, 0x00,    \/\/ IID42\n+    0xd5, 0x31, 0x80, 0xbc, 0x14, 0xd5, 0x26, 0xd3, 0x6f, 0x10,                      \/\/ IID43\n+    0x66, 0x43, 0x81, 0xbc, 0x74, 0x8f, 0x56, 0xe6, 0x2a, 0x00, 0x01,                \/\/ IID44\n+    0xd5, 0x33, 0x81, 0xbc, 0xf0, 0x54, 0x51, 0x46, 0xee, 0x00, 0x00, 0x10, 0x00,    \/\/ IID45\n+    0xd5, 0x32, 0xd1, 0xbc, 0xb6, 0x15, 0x91, 0xcb, 0x60,                            \/\/ IID46\n+    0xd5, 0x13, 0xc1, 0xa4, 0x47, 0xb9, 0x8a, 0x6d, 0x23, 0x10,                      \/\/ IID47\n+    0xd5, 0x12, 0x81, 0x9c, 0x65, 0xe8, 0x60, 0x64, 0x82, 0x00, 0x00, 0x00, 0x01,    \/\/ IID48\n+    0xd5, 0x31, 0xc1, 0xac, 0x0d, 0xea, 0x0d, 0xab, 0x83, 0x08,                      \/\/ IID49\n+    0xd5, 0x23, 0x83, 0xac, 0x98, 0x3a, 0x1d, 0x6f, 0xee, 0x10,                      \/\/ IID50\n+    0x81, 0xb2, 0x96, 0x33, 0xdd, 0x50, 0x00, 0x00, 0x10, 0x00,                      \/\/ IID51\n+    0xd5, 0x10, 0x80, 0x8c, 0x24, 0xec, 0x09, 0x2e, 0x82, 0x40,                      \/\/ IID52\n+    0xd5, 0x10, 0x83, 0x8a, 0x9f, 0x2a, 0x85, 0x6f, 0x10,                            \/\/ IID53\n+    0xd5, 0x12, 0xc6, 0x84, 0x84, 0xaa, 0xe2, 0x36, 0x04, 0x01,                      \/\/ IID54\n+    0x42, 0xc7, 0x84, 0x71, 0x84, 0xdf, 0x83, 0x08, 0x10, 0x00, 0x00, 0x00,          \/\/ IID55\n+    0x43, 0xf6, 0x84, 0x53, 0x65, 0xfc, 0x3d, 0xe0, 0x10,                            \/\/ IID56\n+    0xd5, 0x11, 0xf7, 0x85, 0x03, 0xf0, 0xb9, 0x73, 0x00, 0x00, 0x00, 0x04,          \/\/ IID57\n+    0xd5, 0x11, 0x81, 0xbc, 0x8d, 0x92, 0xb0, 0xa2, 0x4c, 0x00, 0x00, 0x40, 0x00,    \/\/ IID58\n+    0xd5, 0x26, 0x03, 0x84, 0x82, 0x24, 0xdb, 0xea, 0xe1,                            \/\/ IID59\n+    0xd5, 0x70, 0x23, 0x9c, 0x64, 0x92, 0x68, 0x28, 0x06,                            \/\/ IID60\n+    0x45, 0x3a, 0x9d, 0x62, 0x40, 0x1f, 0xbd,                                        \/\/ IID61\n+    0xd5, 0x62, 0x3b, 0xa4, 0xf3, 0xcb, 0x88, 0xb6, 0xcf,                            \/\/ IID62\n+    0xf3, 0x46, 0x0f, 0xbd, 0x84, 0x4a, 0x9e, 0xe9, 0xe2, 0x00,                      \/\/ IID63\n+    0xd5, 0x37, 0x0b, 0x8c, 0x4d, 0x63, 0x9f, 0x16, 0x50,                            \/\/ IID64\n+    0xd5, 0x71, 0x13, 0x8c, 0xef, 0x70, 0xd1, 0xef, 0x79,                            \/\/ IID65\n+    0xd5, 0xc1, 0xaf, 0xb8, 0x8d, 0xe0, 0xad, 0xf5,                                  \/\/ IID66\n+    0xf3, 0xd5, 0xc5, 0xb8, 0xb2, 0x01, 0x29, 0x35, 0x44,                            \/\/ IID67\n+    0xd5, 0x52, 0x1b, 0x84, 0x72, 0x76, 0xd8, 0x57, 0xf2,                            \/\/ IID68\n+    0xd5, 0x50, 0x2b, 0x8e, 0xb3, 0xaa, 0x63, 0x2d,                                  \/\/ IID69\n+    0xf3, 0xd5, 0xd2, 0xbc, 0xbc, 0x1d, 0x97, 0x8b, 0x43, 0xe7,                      \/\/ IID70\n+    0xd5, 0x14, 0x32, 0x8c, 0x13, 0x13, 0xf8, 0x9d, 0xa0,                            \/\/ IID71\n+    0x66, 0xd5, 0x16, 0x33, 0x9c, 0x95, 0xd5, 0x60, 0x38, 0x9c,                      \/\/ IID72\n+    0xd5, 0x55, 0x33, 0xac, 0xcf, 0x0f, 0x3c, 0xd9, 0x34,                            \/\/ IID73\n+    0xd5, 0x61, 0x8a, 0x8c, 0x90, 0x29, 0xc5, 0x00, 0xc7,                            \/\/ IID74\n+    0xd5, 0x56, 0x8b, 0xbc, 0x9c, 0xf4, 0xb8, 0xdc, 0xe2,                            \/\/ IID75\n+    0xd5, 0x46, 0x8d, 0xbc, 0xa3, 0xeb, 0xbd, 0xb5, 0xc4,                            \/\/ IID76\n+    0xd5, 0x73, 0x86, 0xa4, 0x06, 0x44, 0x7d, 0xb1, 0xa3,                            \/\/ IID77\n+    0x66, 0xd5, 0x25, 0x87, 0xac, 0xea, 0x03, 0x4a, 0xbd, 0x19,                      \/\/ IID78\n+    0xd5, 0x52, 0x87, 0xbc, 0xa8, 0x2a, 0x6c, 0xfd, 0x95,                            \/\/ IID79\n+    0x45, 0x85, 0xa9, 0x61, 0xff, 0xa6, 0x34,                                        \/\/ IID80\n+    0xd5, 0x10, 0x80, 0xc7, 0x04,                                                    \/\/ IID81\n+    0xd5, 0x11, 0x81, 0xc4, 0x00, 0x00, 0x01, 0x00,                                  \/\/ IID82\n+#endif \/\/ _LP64\n+    0x81, 0xe2, 0x00, 0x00, 0x01, 0x00,                                              \/\/ IID83\n+#ifdef _LP64\n+    0xd5, 0x11, 0x81, 0xd3, 0x00, 0x00, 0x10, 0x00,                                  \/\/ IID84\n+    0x41, 0x80, 0xfd, 0x04,                                                          \/\/ IID85\n+    0xd5, 0x11, 0x81, 0xfd, 0x00, 0x00, 0x00, 0x10,                                  \/\/ IID86\n+    0xd5, 0x10, 0xc1, 0xd4, 0x10,                                                    \/\/ IID87\n+    0xd5, 0x11, 0xc1, 0xc1, 0x02,                                                    \/\/ IID88\n+#endif \/\/ _LP64\n+    0xc1, 0xca, 0x04,                                                                \/\/ IID89\n+    0xd1, 0xf9,                                                                      \/\/ IID90\n+#ifdef _LP64\n+    0xd5, 0x10, 0xc1, 0xe3, 0x10,                                                    \/\/ IID91\n+    0x41, 0x83, 0xd9, 0x01,                                                          \/\/ IID92\n+    0xd5, 0x10, 0xc1, 0xe4, 0x08,                                                    \/\/ IID93\n+#endif \/\/ _LP64\n+    0xd1, 0xe9,                                                                      \/\/ IID94\n+#ifdef _LP64\n+    0xd5, 0x10, 0x81, 0xeb, 0x00, 0x00, 0x00, 0x01,                                  \/\/ IID95\n+    0xd5, 0x10, 0x81, 0xf0, 0x00, 0x10, 0x00, 0x00,                                  \/\/ IID96\n+    0xd5, 0x11, 0xb8, 0x00, 0x00, 0x01, 0x00,                                        \/\/ IID97\n+    0xd5, 0x10, 0xf6, 0xc4, 0x40,                                                    \/\/ IID98\n+    0xd5, 0x11, 0xf7, 0xc4, 0x00, 0x00, 0x00, 0x01,                                  \/\/ IID99\n+    0xd5, 0x11, 0x81, 0xed, 0x00, 0x00, 0x04, 0x00,                                  \/\/ IID100\n+    0xd5, 0xb7, 0x40, 0x84, 0x62, 0x6d, 0xf0, 0x10, 0x02,                            \/\/ IID101\n+    0xd5, 0x90, 0x41, 0x9c, 0x1a, 0xd6, 0x31, 0xb0, 0xd9,                            \/\/ IID102\n+    0xd5, 0xf6, 0x42, 0xac, 0x01, 0xcb, 0x6a, 0xc0, 0x46,                            \/\/ IID103\n+    0xd5, 0xd3, 0x43, 0x8c, 0xd9, 0xab, 0x0b, 0xde, 0xc4,                            \/\/ IID104\n+    0xd5, 0xf2, 0x44, 0xbc, 0x3c, 0x85, 0xce, 0xfc, 0xa5,                            \/\/ IID105\n+    0xd5, 0xd7, 0x45, 0xbc, 0xbf, 0x9b, 0xd1, 0x03, 0xac,                            \/\/ IID106\n+    0xd5, 0xc4, 0x46, 0xa4, 0xca, 0x61, 0xdd, 0x36, 0xc4,                            \/\/ IID107\n+    0xd5, 0xe4, 0x47, 0xbc, 0xda, 0x1c, 0x76, 0xf1, 0x7b,                            \/\/ IID108\n+    0xd5, 0xb0, 0x48, 0x94, 0x11, 0xfd, 0x03, 0x5d, 0xe2,                            \/\/ IID109\n+    0xd5, 0xb4, 0x49, 0x8c, 0xbd, 0xb6, 0xba, 0x66, 0xd8,                            \/\/ IID110\n+    0xd5, 0xc5, 0x4a, 0x9d, 0x64, 0xdb, 0xb3, 0x9a,                                  \/\/ IID111\n+    0xd5, 0x93, 0x4b, 0x94, 0xd0, 0xb2, 0xbe, 0x96, 0x6c,                            \/\/ IID112\n+    0x46, 0x0f, 0x4c, 0x8c, 0xc1, 0x92, 0x18, 0x3e, 0x57,                            \/\/ IID113\n+    0xd5, 0xd7, 0x4d, 0xbc, 0xb2, 0xb1, 0x10, 0x71, 0x71,                            \/\/ IID114\n+    0xd5, 0xd6, 0x4e, 0x84, 0xb3, 0xd7, 0xaa, 0x9f, 0x11,                            \/\/ IID115\n+    0x47, 0x0f, 0x4f, 0xa4, 0x25, 0x05, 0x78, 0x53, 0x0d,                            \/\/ IID116\n+    0x41, 0x0f, 0x90, 0xc2,                                                          \/\/ IID117\n+#endif \/\/ _LP64\n+    0x0f, 0x91, 0xc3,                                                                \/\/ IID118\n+#ifdef _LP64\n+    0x41, 0x0f, 0x92, 0xc5,                                                          \/\/ IID119\n+    0xd5, 0x90, 0x93, 0xc7,                                                          \/\/ IID120\n+    0xd5, 0x91, 0x94, 0xc0,                                                          \/\/ IID121\n+    0x41, 0x0f, 0x95, 0xc7,                                                          \/\/ IID122\n+    0xd5, 0x90, 0x96, 0xc5,                                                          \/\/ IID123\n+    0xd5, 0x90, 0x97, 0xc1,                                                          \/\/ IID124\n+    0x41, 0x0f, 0x98, 0xc2,                                                          \/\/ IID125\n+    0xd5, 0x91, 0x99, 0xc0,                                                          \/\/ IID126\n+    0xd5, 0x90, 0x9a, 0xc0,                                                          \/\/ IID127\n+    0xd5, 0x91, 0x9b, 0xc4,                                                          \/\/ IID128\n+    0x41, 0x0f, 0x9c, 0xc3,                                                          \/\/ IID129\n+    0xd5, 0x91, 0x9d, 0xc1,                                                          \/\/ IID130\n+    0xd5, 0x90, 0x9e, 0xc2,                                                          \/\/ IID131\n+    0x41, 0x0f, 0x9f, 0xc6,                                                          \/\/ IID132\n+    0xd5, 0x11, 0xf7, 0xf6,                                                          \/\/ IID133\n+    0xd5, 0x10, 0xf7, 0xff,                                                          \/\/ IID134\n+    0xd5, 0x11, 0xf7, 0xec,                                                          \/\/ IID135\n+    0xd5, 0x11, 0xf7, 0xe7,                                                          \/\/ IID136\n+    0xd5, 0x11, 0xf7, 0xdb,                                                          \/\/ IID137\n+    0xd5, 0x10, 0xf7, 0xd0,                                                          \/\/ IID138\n+#endif \/\/ _LP64\n+    0xd3, 0xc2,                                                                      \/\/ IID139\n+#ifdef _LP64\n+    0x41, 0xd3, 0xcc,                                                                \/\/ IID140\n+    0x41, 0xd3, 0xfe,                                                                \/\/ IID141\n+    0xd5, 0x10, 0xd3, 0xe3,                                                          \/\/ IID142\n+    0x41, 0xd3, 0xe2,                                                                \/\/ IID143\n+    0xd5, 0x10, 0xd3, 0xec,                                                          \/\/ IID144\n+#endif \/\/ _LP64\n+    0xff, 0xc3,                                                                      \/\/ IID145\n+#ifdef _LP64\n+    0x41, 0xff, 0xce,                                                                \/\/ IID146\n+    0x41, 0xf7, 0xa4, 0x24, 0xa2, 0x05, 0x5b, 0xa8,                                  \/\/ IID147\n+    0xf7, 0x9b, 0x39, 0x30, 0x4b, 0xc2,                                              \/\/ IID148\n+    0xd5, 0x10, 0xd3, 0xbd, 0xd0, 0x52, 0x8f, 0x81,                                  \/\/ IID149\n+    0xd5, 0x32, 0xd3, 0xa4, 0xe5, 0x37, 0x94, 0xba, 0xdc,                            \/\/ IID150\n+    0x43, 0xd3, 0xac, 0x6b, 0xbc, 0x03, 0xff, 0xf1,                                  \/\/ IID151\n+    0xd5, 0x10, 0xff, 0x83, 0x96, 0x2a, 0x95, 0xa1,                                  \/\/ IID152\n+    0xd5, 0x20, 0xff, 0x8c, 0x21, 0x3c, 0x46, 0xcf, 0xda,                            \/\/ IID153\n+    0xd5, 0x63, 0x69, 0x8c, 0x40, 0x26, 0xcf, 0xfe, 0x2e, 0x00, 0x00, 0x10, 0x00,    \/\/ IID154\n+    0x45, 0x69, 0xc8, 0x00, 0x00, 0x00, 0x10,                                        \/\/ IID155\n+    0x45, 0x0f, 0xa4, 0xfa, 0x08,                                                    \/\/ IID156\n+    0xd5, 0xd1, 0xac, 0xf5, 0x02,                                                    \/\/ IID157\n+    0xd5, 0x94, 0xb6, 0xb3, 0x7c, 0xca, 0x3c, 0xf9,                                  \/\/ IID158\n+    0xd5, 0xe7, 0xb7, 0x8c, 0x1c, 0x44, 0xfa, 0x05, 0x2d,                            \/\/ IID159\n+    0xd5, 0x97, 0xbe, 0xa4, 0x3e, 0xc1, 0xca, 0xbc, 0x65,                            \/\/ IID160\n+    0xd5, 0xe7, 0xbf, 0x94, 0x02, 0x59, 0x74, 0x70, 0x1d,                            \/\/ IID161\n+    0xd5, 0xc1, 0xb6, 0xd0,                                                          \/\/ IID162\n+    0xd5, 0xc5, 0xb7, 0xf9,                                                          \/\/ IID163\n+    0xd5, 0x94, 0xbe, 0xfe,                                                          \/\/ IID164\n+    0xd5, 0xd5, 0xbf, 0xc0,                                                          \/\/ IID165\n+    0xd5, 0xe3, 0xb0, 0x94, 0x64, 0xa1, 0x59, 0xaa, 0xb7,                            \/\/ IID166\n+    0x66, 0xd5, 0xc6, 0xb1, 0xa4, 0xf2, 0x58, 0xa5, 0xf5, 0x16,                      \/\/ IID167\n+    0xd5, 0x90, 0xb1, 0x94, 0x52, 0x9c, 0x8d, 0x25, 0x50,                            \/\/ IID168\n+    0x4c, 0x13, 0xcb,                                                                \/\/ IID169\n+    0xd5, 0x5d, 0x3b, 0xd0,                                                          \/\/ IID170\n+    0x4c, 0x0f, 0xaf, 0xf2,                                                          \/\/ IID171\n+    0xf3, 0xd5, 0xdd, 0xb8, 0xce,                                                    \/\/ IID172\n+    0xd5, 0x5c, 0x1b, 0xc3,                                                          \/\/ IID173\n+    0x4d, 0x2b, 0xfb,                                                                \/\/ IID174\n+    0xf3, 0xd5, 0xd8, 0xbc, 0xd5,                                                    \/\/ IID175\n+    0xf3, 0xd5, 0x9d, 0xbd, 0xfb,                                                    \/\/ IID176\n+    0xd5, 0x58, 0x03, 0xec,                                                          \/\/ IID177\n+    0xd5, 0x1d, 0x23, 0xda,                                                          \/\/ IID178\n+    0xd5, 0x4d, 0x0b, 0xef,                                                          \/\/ IID179\n+    0xd5, 0x5c, 0x33, 0xc5,                                                          \/\/ IID180\n+    0x4d, 0x8b, 0xf5,                                                                \/\/ IID181\n+    0xd5, 0x9c, 0xbc, 0xde,                                                          \/\/ IID182\n+    0xd5, 0x9c, 0xbd, 0xf7,                                                          \/\/ IID183\n+    0xd5, 0x98, 0xa3, 0xce,                                                          \/\/ IID184\n+    0xd5, 0x5d, 0x87, 0xcd,                                                          \/\/ IID185\n+    0x4d, 0x85, 0xf8,                                                                \/\/ IID186\n+    0xd5, 0x4b, 0x01, 0x84, 0xd6, 0xfe, 0x05, 0x19, 0xc9,                            \/\/ IID187\n+    0xd5, 0x4a, 0x21, 0x94, 0xc3, 0x48, 0xde, 0x65, 0xd8,                            \/\/ IID188\n+    0xd5, 0x1d, 0x39, 0xa8, 0xef, 0xc9, 0xc3, 0x62,                                  \/\/ IID189\n+    0xd5, 0x2d, 0x09, 0x9c, 0xb3, 0x78, 0xb3, 0x9f, 0x41,                            \/\/ IID190\n+    0xd5, 0x1f, 0x31, 0xac, 0xb1, 0x23, 0xb6, 0x4b, 0xcd,                            \/\/ IID191\n+    0xd5, 0x7b, 0x29, 0x9c, 0xfc, 0x61, 0xd3, 0xe1, 0x6c,                            \/\/ IID192\n+    0xd5, 0x3f, 0x89, 0x9c, 0x89, 0x84, 0x89, 0x0a, 0xfc,                            \/\/ IID193\n+    0xd5, 0xf8, 0xc1, 0xa4, 0xcb, 0x6c, 0xf0, 0xeb, 0x1f,                            \/\/ IID194\n+    0xd5, 0x39, 0x81, 0xa4, 0x4a, 0xfb, 0xa0, 0x79, 0x94, 0x00, 0x00, 0x01, 0x00,    \/\/ IID195\n+    0xd5, 0x19, 0x81, 0x83, 0x79, 0xa2, 0x36, 0x91, 0x00, 0x00, 0x01, 0x00,          \/\/ IID196\n+    0xd5, 0x2a, 0x81, 0xbc, 0x93, 0x5c, 0x41, 0x15, 0xfe, 0x00, 0x00, 0x10, 0x00,    \/\/ IID197\n+    0xd5, 0x28, 0xc1, 0xbc, 0x1b, 0xe8, 0x3d, 0x3c, 0x3c, 0x08,                      \/\/ IID198\n+    0xd5, 0x38, 0xc1, 0xa4, 0x7c, 0x6d, 0x9b, 0x51, 0x68, 0x08,                      \/\/ IID199\n+    0xd5, 0x39, 0x83, 0x9c, 0x37, 0x7b, 0xe1, 0xc2, 0x84, 0x10,                      \/\/ IID200\n+    0xd5, 0x29, 0xc1, 0xac, 0xd7, 0x24, 0xd8, 0xd9, 0x04, 0x04,                      \/\/ IID201\n+    0xd5, 0x2a, 0x83, 0xac, 0xaa, 0x85, 0xea, 0x4a, 0x7e, 0x01,                      \/\/ IID202\n+    0xd5, 0x1a, 0x81, 0xb4, 0x57, 0x20, 0xc6, 0x95, 0x28, 0x00, 0x00, 0x00, 0x01,    \/\/ IID203\n+    0x4b, 0x83, 0x8c, 0x2e, 0x65, 0xc6, 0xe4, 0x88, 0x01,                            \/\/ IID204\n+    0xd5, 0x18, 0xc7, 0x86, 0xa6, 0x64, 0xba, 0x9c, 0x00, 0x01, 0x00, 0x00,          \/\/ IID205\n+    0x49, 0xf7, 0x85, 0x3b, 0x6e, 0x69, 0xf4, 0xff, 0xff, 0xff, 0xff,                \/\/ IID206\n+    0xd5, 0x49, 0x03, 0x8f, 0xf3, 0xb4, 0x49, 0xae,                                  \/\/ IID207\n+    0xd5, 0x18, 0x23, 0x8c, 0xc8, 0xac, 0xb4, 0x71, 0xe3,                            \/\/ IID208\n+    0xd5, 0x58, 0x3b, 0xbc, 0xc9, 0xa0, 0xaa, 0x8f, 0xbb,                            \/\/ IID209\n+    0xf3, 0xd5, 0xd8, 0xbd, 0x9b, 0x92, 0xe7, 0x7f, 0x48,                            \/\/ IID210\n+    0xd5, 0x1c, 0x0b, 0x99, 0xd7, 0xbc, 0x21, 0x9a,                                  \/\/ IID211\n+    0xd5, 0x4d, 0x13, 0xa9, 0xfd, 0x23, 0x6d, 0x8f,                                  \/\/ IID212\n+    0xd5, 0xbf, 0xaf, 0x8c, 0xd2, 0x09, 0x78, 0x7d, 0xee,                            \/\/ IID213\n+    0xf3, 0xd5, 0xe9, 0xb8, 0x9c, 0x5f, 0x6b, 0x10, 0xce, 0x91,                      \/\/ IID214\n+    0xd5, 0x5c, 0x1b, 0xb7, 0xa2, 0xa3, 0xab, 0xb9,                                  \/\/ IID215\n+    0xd5, 0x79, 0x2b, 0xbc, 0xd7, 0xd8, 0x37, 0x3c, 0x66,                            \/\/ IID216\n+    0xf3, 0xd5, 0xff, 0xbc, 0x84, 0xc8, 0x0f, 0x87, 0xa5, 0xb9,                      \/\/ IID217\n+    0xd5, 0x2d, 0x33, 0xb4, 0x5f, 0xfa, 0xaf, 0x96, 0x41,                            \/\/ IID218\n+    0xd5, 0x3b, 0x8b, 0x94, 0x69, 0x57, 0x61, 0x5a, 0x11,                            \/\/ IID219\n+    0xd5, 0x7b, 0x8d, 0x9c, 0xbc, 0x33, 0xf9, 0x82, 0x6b,                            \/\/ IID220\n+    0xf2, 0xd5, 0xb9, 0x2c, 0x8c, 0xe8, 0x15, 0x66, 0x23, 0xc6,                      \/\/ IID221\n+    0xd5, 0x7e, 0x87, 0xac, 0xc1, 0x1d, 0xf0, 0x02, 0x59,                            \/\/ IID222\n+    0xd5, 0x3f, 0x85, 0xa4, 0xa8, 0xfc, 0x5b, 0x86, 0x08,                            \/\/ IID223\n+    0x49, 0x83, 0xc2, 0x10,                                                          \/\/ IID224\n+    0xd5, 0x19, 0x81, 0xe2, 0x00, 0x01, 0x00, 0x00,                                  \/\/ IID225\n+    0x48, 0x83, 0xd1, 0x01,                                                          \/\/ IID226\n+    0xd5, 0x18, 0x81, 0xfd, 0x00, 0x00, 0x01, 0x00,                                  \/\/ IID227\n+    0xd5, 0x19, 0xc1, 0xd4, 0x04,                                                    \/\/ IID228\n+    0xd5, 0x19, 0xc1, 0xdc, 0x10,                                                    \/\/ IID229\n+    0xd5, 0x18, 0xd1, 0xc2,                                                          \/\/ IID230\n+    0xd5, 0x19, 0xc1, 0xca, 0x02,                                                    \/\/ IID231\n+    0xd5, 0x18, 0xc1, 0xfb, 0x02,                                                    \/\/ IID232\n+    0x49, 0xc1, 0xe6, 0x08,                                                          \/\/ IID233\n+    0x49, 0x81, 0xda, 0x00, 0x00, 0x01, 0x00,                                        \/\/ IID234\n+    0xd5, 0x19, 0xd1, 0xe6,                                                          \/\/ IID235\n+    0x49, 0xc1, 0xef, 0x08,                                                          \/\/ IID236\n+    0xd5, 0x18, 0x81, 0xed, 0x00, 0x00, 0x10, 0x00,                                  \/\/ IID237\n+    0x48, 0x81, 0xf3, 0x00, 0x00, 0x00, 0x10,                                        \/\/ IID238\n+    0xd5, 0x18, 0xc7, 0xc3, 0x10, 0x00, 0x00, 0x00,                                  \/\/ IID239\n+    0xd5, 0x18, 0xbb, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,                \/\/ IID240\n+    0xd5, 0x98, 0xba, 0xe5, 0x01,                                                    \/\/ IID241\n+    0x49, 0xf7, 0xc7, 0x00, 0x00, 0xff, 0xff,                                        \/\/ IID242\n+    0xd5, 0x18, 0x81, 0xcd, 0x00, 0x00, 0x00, 0x40,                                  \/\/ IID243\n+    0xd5, 0x18, 0x81, 0xeb, 0x00, 0x00, 0x01, 0x00,                                  \/\/ IID244\n+    0xd5, 0x9d, 0x40, 0xbd, 0x66, 0xde, 0x67, 0xa3,                                  \/\/ IID245\n+    0xd5, 0x98, 0x41, 0x8d, 0x81, 0xc5, 0x2c, 0x02,                                  \/\/ IID246\n+    0xd5, 0x9f, 0x42, 0xbc, 0xad, 0x47, 0x70, 0x69, 0xa1,                            \/\/ IID247\n+    0xd5, 0xdd, 0x43, 0x90, 0x94, 0x68, 0x0c, 0x44,                                  \/\/ IID248\n+    0xd5, 0xfa, 0x44, 0x8c, 0xd7, 0x4e, 0x8b, 0x55, 0x23,                            \/\/ IID249\n+    0xd5, 0xbe, 0x45, 0x8c, 0xe8, 0x37, 0x5c, 0x76, 0xed,                            \/\/ IID250\n+    0x4d, 0x0f, 0x46, 0x83, 0x34, 0xcb, 0x1e, 0xb6,                                  \/\/ IID251\n+    0xd5, 0xed, 0x47, 0x94, 0x63, 0x86, 0xfa, 0x06, 0xc1,                            \/\/ IID252\n+    0xd5, 0x9f, 0x48, 0x9c, 0xaa, 0x9f, 0x8f, 0xd1, 0x4b,                            \/\/ IID253\n+    0x4f, 0x0f, 0x49, 0x84, 0xd9, 0x28, 0xa5, 0x42, 0x4b,                            \/\/ IID254\n+    0xd5, 0x9e, 0x4a, 0xa4, 0x4b, 0x1c, 0x9a, 0x55, 0x68,                            \/\/ IID255\n+    0xd5, 0xf8, 0x4b, 0xb4, 0x4a, 0x80, 0x8e, 0x4d, 0x2c,                            \/\/ IID256\n+    0xd5, 0xfe, 0x4c, 0x94, 0x32, 0x92, 0x76, 0x17, 0xd5,                            \/\/ IID257\n+    0xd5, 0xc9, 0x4d, 0xb3, 0x22, 0xa6, 0xef, 0x4f,                                  \/\/ IID258\n+    0xd5, 0xfe, 0x4e, 0xa4, 0x5a, 0x34, 0x8c, 0x7a, 0x6b,                            \/\/ IID259\n+    0xd5, 0xf8, 0x4f, 0xa4, 0x27, 0x3b, 0xda, 0x18, 0xed,                            \/\/ IID260\n+    0x41, 0xff, 0xd1,                                                                \/\/ IID261\n+    0xd5, 0x18, 0xf7, 0xf6,                                                          \/\/ IID262\n+    0xd5, 0x19, 0xf7, 0xfd,                                                          \/\/ IID263\n+    0x48, 0xf7, 0xeb,                                                                \/\/ IID264\n+    0xd5, 0x19, 0xf7, 0xe3,                                                          \/\/ IID265\n+    0x48, 0xf7, 0xdb,                                                                \/\/ IID266\n+    0xd5, 0x18, 0xf7, 0xd1,                                                          \/\/ IID267\n+    0xd5, 0x19, 0xd3, 0xc1,                                                          \/\/ IID268\n+    0x48, 0xd3, 0xcb,                                                                \/\/ IID269\n+    0xd5, 0x18, 0xd3, 0xf9,                                                          \/\/ IID270\n+    0xd5, 0x19, 0xd3, 0xe4,                                                          \/\/ IID271\n+    0xd5, 0x19, 0xd3, 0xe4,                                                          \/\/ IID272\n+    0xd5, 0x19, 0xd3, 0xee,                                                          \/\/ IID273\n+    0xd5, 0x19, 0xff, 0xc3,                                                          \/\/ IID274\n+    0x48, 0xff, 0xca,                                                                \/\/ IID275\n+    0xd5, 0x19, 0x53,                                                                \/\/ IID276\n+    0xd5, 0x09, 0x5a,                                                                \/\/ IID277\n+    0xd5, 0x11, 0xff, 0x93, 0xfb, 0x78, 0x24, 0xdd,                                  \/\/ IID278\n+    0xd5, 0x39, 0xf7, 0xa4, 0x2b, 0x64, 0x00, 0xa6, 0xe0,                            \/\/ IID279\n+    0xd5, 0x18, 0xf7, 0x9c, 0xcb, 0x12, 0xb8, 0x47, 0x7a,                            \/\/ IID280\n+    0xd5, 0x38, 0xd3, 0xbc, 0x6a, 0xba, 0x85, 0x7a, 0xb7,                            \/\/ IID281\n+    0xd5, 0x19, 0xd3, 0xa0, 0xd4, 0x25, 0xd4, 0x85,                                  \/\/ IID282\n+    0xd5, 0x19, 0xd3, 0xa8, 0x2f, 0xd9, 0xab, 0x01,                                  \/\/ IID283\n+    0x4b, 0xff, 0x84, 0xc9, 0x20, 0x25, 0xa9, 0x31,                                  \/\/ IID284\n+    0x4b, 0xff, 0x8c, 0x01, 0xbd, 0xb4, 0x14, 0x7f,                                  \/\/ IID285\n+    0xd5, 0x1f, 0x69, 0xb4, 0x7d, 0x9c, 0xcf, 0x81, 0x52, 0x00, 0x01, 0x00, 0x00,    \/\/ IID286\n+    0xd5, 0x59, 0x69, 0xc4, 0x00, 0x00, 0x10, 0x00,                                  \/\/ IID287\n+    0xd5, 0xdc, 0xa4, 0xc1, 0x02,                                                    \/\/ IID288\n+    0xd5, 0x9c, 0xac, 0xd8, 0x02,                                                    \/\/ IID289\n+    0x62, 0xd4, 0x24, 0x18, 0x8f, 0xc2,                                              \/\/ IID290\n+    0x62, 0xd4, 0xbc, 0x10, 0x8f, 0xc7,                                              \/\/ IID291\n+    0x62, 0xdc, 0x24, 0x18, 0xff, 0xf4,                                              \/\/ IID292\n+    0x62, 0xd4, 0x84, 0x10, 0xff, 0xf4,                                              \/\/ IID293\n+    0xd5, 0xfc, 0xb6, 0x84, 0x06, 0x37, 0xe8, 0x1b, 0x51,                            \/\/ IID294\n+    0xd5, 0xaf, 0xb7, 0xbc, 0x97, 0x12, 0x6b, 0x78, 0xfc,                            \/\/ IID295\n+    0xd5, 0xbd, 0xbe, 0xbc, 0xc1, 0xbf, 0xd8, 0xf6, 0x85,                            \/\/ IID296\n+    0xd5, 0xb9, 0xbf, 0x94, 0x9c, 0x6a, 0xda, 0x79, 0x00,                            \/\/ IID297\n+    0xd5, 0xcd, 0xb6, 0xd9,                                                          \/\/ IID298\n+    0xd5, 0xdc, 0xb7, 0xcd,                                                          \/\/ IID299\n+    0x4d, 0x0f, 0xbe, 0xf4,                                                          \/\/ IID300\n+    0xd5, 0xc9, 0xbf, 0xfb,                                                          \/\/ IID301\n+    0xd5, 0xcd, 0xb1, 0xb4, 0x24, 0x21, 0x8b, 0x56, 0x9a,                            \/\/ IID302\n+#endif \/\/ _LP64\n+  };\n+\n+  static const unsigned int insns_lens[] =\n+  {\n+#ifdef _LP64\n+    4,    \/\/ IID0\n+#endif \/\/ _LP64\n+    3,    \/\/ IID1\n+#ifdef _LP64\n+    4,    \/\/ IID2\n+    4,    \/\/ IID3\n+    4,    \/\/ IID4\n+    5,    \/\/ IID5\n+    4,    \/\/ IID6\n+    4,    \/\/ IID7\n+    5,    \/\/ IID8\n+    5,    \/\/ IID9\n+    3,    \/\/ IID10\n+    4,    \/\/ IID11\n+    4,    \/\/ IID12\n+    4,    \/\/ IID13\n+    4,    \/\/ IID14\n+    4,    \/\/ IID15\n+    4,    \/\/ IID16\n+    4,    \/\/ IID17\n+    4,    \/\/ IID18\n+    9,    \/\/ IID19\n+    10,   \/\/ IID20\n+    9,    \/\/ IID21\n+    8,    \/\/ IID22\n+    9,    \/\/ IID23\n+    8,    \/\/ IID24\n+    9,    \/\/ IID25\n+    10,   \/\/ IID26\n+    9,    \/\/ IID27\n+    9,    \/\/ IID28\n+    9,    \/\/ IID29\n+    9,    \/\/ IID30\n+    8,    \/\/ IID31\n+    8,    \/\/ IID32\n+    9,    \/\/ IID33\n+    9,    \/\/ IID34\n+    8,    \/\/ IID35\n+    10,   \/\/ IID36\n+    9,    \/\/ IID37\n+    13,   \/\/ IID38\n+    9,    \/\/ IID39\n+    9,    \/\/ IID40\n+    11,   \/\/ IID41\n+    13,   \/\/ IID42\n+    10,   \/\/ IID43\n+    11,   \/\/ IID44\n+    13,   \/\/ IID45\n+    9,    \/\/ IID46\n+    10,   \/\/ IID47\n+    13,   \/\/ IID48\n+    10,   \/\/ IID49\n+    10,   \/\/ IID50\n+    10,   \/\/ IID51\n+    10,   \/\/ IID52\n+    9,    \/\/ IID53\n+    10,   \/\/ IID54\n+    12,   \/\/ IID55\n+    9,    \/\/ IID56\n+    12,   \/\/ IID57\n+    13,   \/\/ IID58\n+    9,    \/\/ IID59\n+    9,    \/\/ IID60\n+    7,    \/\/ IID61\n+    9,    \/\/ IID62\n+    10,   \/\/ IID63\n+    9,    \/\/ IID64\n+    9,    \/\/ IID65\n+    8,    \/\/ IID66\n+    9,    \/\/ IID67\n+    9,    \/\/ IID68\n+    8,    \/\/ IID69\n+    10,   \/\/ IID70\n+    9,    \/\/ IID71\n+    10,   \/\/ IID72\n+    9,    \/\/ IID73\n+    9,    \/\/ IID74\n+    9,    \/\/ IID75\n+    9,    \/\/ IID76\n+    9,    \/\/ IID77\n+    10,   \/\/ IID78\n+    9,    \/\/ IID79\n+    7,    \/\/ IID80\n+    5,    \/\/ IID81\n+    8,    \/\/ IID82\n+#endif \/\/ _LP64\n+    6,    \/\/ IID83\n+#ifdef _LP64\n+    8,    \/\/ IID84\n+    4,    \/\/ IID85\n+    8,    \/\/ IID86\n+    5,    \/\/ IID87\n+    5,    \/\/ IID88\n+#endif \/\/ _LP64\n+    3,    \/\/ IID89\n+    2,    \/\/ IID90\n+#ifdef _LP64\n+    5,    \/\/ IID91\n+    4,    \/\/ IID92\n+    5,    \/\/ IID93\n+#endif \/\/ _LP64\n+    2,    \/\/ IID94\n+#ifdef _LP64\n+    8,    \/\/ IID95\n+    8,    \/\/ IID96\n+    7,    \/\/ IID97\n+    5,    \/\/ IID98\n+    8,    \/\/ IID99\n+    8,    \/\/ IID100\n+    9,    \/\/ IID101\n+    9,    \/\/ IID102\n+    9,    \/\/ IID103\n+    9,    \/\/ IID104\n+    9,    \/\/ IID105\n+    9,    \/\/ IID106\n+    9,    \/\/ IID107\n+    9,    \/\/ IID108\n+    9,    \/\/ IID109\n+    9,    \/\/ IID110\n+    8,    \/\/ IID111\n+    9,    \/\/ IID112\n+    9,    \/\/ IID113\n+    9,    \/\/ IID114\n+    9,    \/\/ IID115\n+    9,    \/\/ IID116\n+    4,    \/\/ IID117\n+#endif \/\/ _LP64\n+    3,    \/\/ IID118\n+#ifdef _LP64\n+    4,    \/\/ IID119\n+    4,    \/\/ IID120\n+    4,    \/\/ IID121\n+    4,    \/\/ IID122\n+    4,    \/\/ IID123\n+    4,    \/\/ IID124\n+    4,    \/\/ IID125\n+    4,    \/\/ IID126\n+    4,    \/\/ IID127\n+    4,    \/\/ IID128\n+    4,    \/\/ IID129\n+    4,    \/\/ IID130\n+    4,    \/\/ IID131\n+    4,    \/\/ IID132\n+    4,    \/\/ IID133\n+    4,    \/\/ IID134\n+    4,    \/\/ IID135\n+    4,    \/\/ IID136\n+    4,    \/\/ IID137\n+    4,    \/\/ IID138\n+#endif \/\/ _LP64\n+    2,    \/\/ IID139\n+#ifdef _LP64\n+    3,    \/\/ IID140\n+    3,    \/\/ IID141\n+    4,    \/\/ IID142\n+    3,    \/\/ IID143\n+    4,    \/\/ IID144\n+#endif \/\/ _LP64\n+    2,    \/\/ IID145\n+#ifdef _LP64\n+    3,    \/\/ IID146\n+    8,    \/\/ IID147\n+    6,    \/\/ IID148\n+    8,    \/\/ IID149\n+    9,    \/\/ IID150\n+    8,    \/\/ IID151\n+    8,    \/\/ IID152\n+    9,    \/\/ IID153\n+    13,   \/\/ IID154\n+    7,    \/\/ IID155\n+    5,    \/\/ IID156\n+    5,    \/\/ IID157\n+    8,    \/\/ IID158\n+    9,    \/\/ IID159\n+    9,    \/\/ IID160\n+    9,    \/\/ IID161\n+    4,    \/\/ IID162\n+    4,    \/\/ IID163\n+    4,    \/\/ IID164\n+    4,    \/\/ IID165\n+    9,    \/\/ IID166\n+    10,   \/\/ IID167\n+    9,    \/\/ IID168\n+    3,    \/\/ IID169\n+    4,    \/\/ IID170\n+    4,    \/\/ IID171\n+    5,    \/\/ IID172\n+    4,    \/\/ IID173\n+    3,    \/\/ IID174\n+    5,    \/\/ IID175\n+    5,    \/\/ IID176\n+    4,    \/\/ IID177\n+    4,    \/\/ IID178\n+    4,    \/\/ IID179\n+    4,    \/\/ IID180\n+    3,    \/\/ IID181\n+    4,    \/\/ IID182\n+    4,    \/\/ IID183\n+    4,    \/\/ IID184\n+    4,    \/\/ IID185\n+    3,    \/\/ IID186\n+    9,    \/\/ IID187\n+    9,    \/\/ IID188\n+    8,    \/\/ IID189\n+    9,    \/\/ IID190\n+    9,    \/\/ IID191\n+    9,    \/\/ IID192\n+    9,    \/\/ IID193\n+    9,    \/\/ IID194\n+    13,   \/\/ IID195\n+    12,   \/\/ IID196\n+    13,   \/\/ IID197\n+    10,   \/\/ IID198\n+    10,   \/\/ IID199\n+    10,   \/\/ IID200\n+    10,   \/\/ IID201\n+    10,   \/\/ IID202\n+    13,   \/\/ IID203\n+    9,    \/\/ IID204\n+    12,   \/\/ IID205\n+    11,   \/\/ IID206\n+    8,    \/\/ IID207\n+    9,    \/\/ IID208\n+    9,    \/\/ IID209\n+    9,    \/\/ IID210\n+    8,    \/\/ IID211\n+    8,    \/\/ IID212\n+    9,    \/\/ IID213\n+    10,   \/\/ IID214\n+    8,    \/\/ IID215\n+    9,    \/\/ IID216\n+    10,   \/\/ IID217\n+    9,    \/\/ IID218\n+    9,    \/\/ IID219\n+    9,    \/\/ IID220\n+    10,   \/\/ IID221\n+    9,    \/\/ IID222\n+    9,    \/\/ IID223\n+    4,    \/\/ IID224\n+    8,    \/\/ IID225\n+    4,    \/\/ IID226\n+    8,    \/\/ IID227\n+    5,    \/\/ IID228\n+    5,    \/\/ IID229\n+    4,    \/\/ IID230\n+    5,    \/\/ IID231\n+    5,    \/\/ IID232\n+    4,    \/\/ IID233\n+    7,    \/\/ IID234\n+    4,    \/\/ IID235\n+    4,    \/\/ IID236\n+    8,    \/\/ IID237\n+    7,    \/\/ IID238\n+    8,    \/\/ IID239\n+    11,   \/\/ IID240\n+    5,    \/\/ IID241\n+    7,    \/\/ IID242\n+    8,    \/\/ IID243\n+    8,    \/\/ IID244\n+    8,    \/\/ IID245\n+    8,    \/\/ IID246\n+    9,    \/\/ IID247\n+    8,    \/\/ IID248\n+    9,    \/\/ IID249\n+    9,    \/\/ IID250\n+    8,    \/\/ IID251\n+    9,    \/\/ IID252\n+    9,    \/\/ IID253\n+    9,    \/\/ IID254\n+    9,    \/\/ IID255\n+    9,    \/\/ IID256\n+    9,    \/\/ IID257\n+    8,    \/\/ IID258\n+    9,    \/\/ IID259\n+    9,    \/\/ IID260\n+    3,    \/\/ IID261\n+    4,    \/\/ IID262\n+    4,    \/\/ IID263\n+    3,    \/\/ IID264\n+    4,    \/\/ IID265\n+    3,    \/\/ IID266\n+    4,    \/\/ IID267\n+    4,    \/\/ IID268\n+    3,    \/\/ IID269\n+    4,    \/\/ IID270\n+    4,    \/\/ IID271\n+    4,    \/\/ IID272\n+    4,    \/\/ IID273\n+    4,    \/\/ IID274\n+    3,    \/\/ IID275\n+    3,    \/\/ IID276\n+    3,    \/\/ IID277\n+    8,    \/\/ IID278\n+    9,    \/\/ IID279\n+    9,    \/\/ IID280\n+    9,    \/\/ IID281\n+    8,    \/\/ IID282\n+    8,    \/\/ IID283\n+    8,    \/\/ IID284\n+    8,    \/\/ IID285\n+    13,   \/\/ IID286\n+    8,    \/\/ IID287\n+    5,    \/\/ IID288\n+    5,    \/\/ IID289\n+    6,    \/\/ IID290\n+    6,    \/\/ IID291\n+    6,    \/\/ IID292\n+    6,    \/\/ IID293\n+    9,    \/\/ IID294\n+    9,    \/\/ IID295\n+    9,    \/\/ IID296\n+    9,    \/\/ IID297\n+    4,    \/\/ IID298\n+    4,    \/\/ IID299\n+    4,    \/\/ IID300\n+    4,    \/\/ IID301\n+    9,    \/\/ IID302\n+#endif \/\/ _LP64\n+  };\n+\n+  static const char* insns_strs[] =\n+  {\n+#ifdef _LP64\n+    \"__ shldl(r22, r14);\",                                                                \/\/ IID0\n+#endif \/\/ _LP64\n+    \"__ shrdl(rcx, rbx);\",                                                                \/\/ IID1\n+#ifdef _LP64\n+    \"__ adcl(r24, r18);\",                                                                 \/\/ IID2\n+    \"__ cmpl(r8, r19);\",                                                                  \/\/ IID3\n+    \"__ imull(r25, r19);\",                                                                \/\/ IID4\n+    \"__ popcntl(r19, r15);\",                                                              \/\/ IID5\n+    \"__ sbbl(r21, r19);\",                                                                 \/\/ IID6\n+    \"__ subl(r17, r29);\",                                                                 \/\/ IID7\n+    \"__ tzcntl(r21, rdx);\",                                                               \/\/ IID8\n+    \"__ lzcntl(rcx, r23);\",                                                               \/\/ IID9\n+    \"__ addl(r10, r11);\",                                                                 \/\/ IID10\n+    \"__ andl(r21, r14);\",                                                                 \/\/ IID11\n+    \"__ orl(r12, r30);\",                                                                  \/\/ IID12\n+    \"__ xorl(r19, r30);\",                                                                 \/\/ IID13\n+    \"__ movl(r27, r11);\",                                                                 \/\/ IID14\n+    \"__ bsfl(r10, r12);\",                                                                 \/\/ IID15\n+    \"__ bsrl(r16, r10);\",                                                                 \/\/ IID16\n+    \"__ xchgl(r16, r28);\",                                                                \/\/ IID17\n+    \"__ testl(r25, r16);\",                                                                \/\/ IID18\n+    \"__ addb(Address(r27, rdx, (Address::ScaleFactor)1, +0x6f304723), rcx);\",             \/\/ IID19\n+    \"__ addw(Address(r19, rcx, (Address::ScaleFactor)2, +0x17244c57), r17);\",             \/\/ IID20\n+    \"__ addl(Address(r23, r16, (Address::ScaleFactor)1, +0x138df419), r19);\",             \/\/ IID21\n+    \"__ adcl(Address(r8, r11, (Address::ScaleFactor)3, -0x164f7a73), rcx);\",              \/\/ IID22\n+    \"__ andb(Address(rdx, r17, (Address::ScaleFactor)3, +0x4df7f181), r22);\",             \/\/ IID23\n+    \"__ andl(Address(r15, -0x41884769), r23);\",                                           \/\/ IID24\n+    \"__ cmpb(Address(r20, r18, (Address::ScaleFactor)0, -0x1b827588), r8);\",              \/\/ IID25\n+    \"__ cmpw(Address(r9, r22, (Address::ScaleFactor)3, +0x564ead70), r31);\",              \/\/ IID26\n+    \"__ cmpl(Address(r10, r24, (Address::ScaleFactor)2, +0xf08ffec), rcx);\",              \/\/ IID27\n+    \"__ orb(Address(r27, r15, (Address::ScaleFactor)0, +0xf18eac7), r19);\",               \/\/ IID28\n+    \"__ orl(Address(r16, r31, (Address::ScaleFactor)2, +0x3a452790), r12);\",              \/\/ IID29\n+    \"__ xorb(Address(r20, r13, (Address::ScaleFactor)0, +0x61dde6b7), r10);\",             \/\/ IID30\n+    \"__ xorl(Address(r27, -0x77a99463), rbx);\",                                           \/\/ IID31\n+    \"__ subl(Address(r9, r11, (Address::ScaleFactor)0, +0x4e20f145), r10);\",              \/\/ IID32\n+    \"__ movb(Address(r23, r23, (Address::ScaleFactor)0, -0x3f51b77), r10);\",              \/\/ IID33\n+    \"__ movl(Address(r31, r22, (Address::ScaleFactor)0, +0xfac5466), r30);\",              \/\/ IID34\n+    \"__ xaddb(Address(rbx, -0x70025991), r31);\",                                          \/\/ IID35\n+    \"__ xaddw(Address(r17, r26, (Address::ScaleFactor)1, -0x530c0221), r29);\",            \/\/ IID36\n+    \"__ xaddl(Address(r9, r21, (Address::ScaleFactor)0, -0x7b7336bf), r17);\",             \/\/ IID37\n+    \"__ adcl(Address(r24, r12, (Address::ScaleFactor)2, +0x691b07e5), 65536);\",           \/\/ IID38\n+    \"__ andl(Address(r14, r9, (Address::ScaleFactor)0, -0x115d5957), 16);\",               \/\/ IID39\n+    \"__ addb(Address(r21, -0x1d3e83ad), 64);\",                                            \/\/ IID40\n+    \"__ addw(Address(r12, +0x3a7acf9a), 4096);\",                                          \/\/ IID41\n+    \"__ addl(Address(r30, r14, (Address::ScaleFactor)1, -0x2073ed16), 256);\",             \/\/ IID42\n+    \"__ cmpb(Address(r28, r18, (Address::ScaleFactor)0, +0x6fd326d5), 16);\",              \/\/ IID43\n+    \"__ cmpw(Address(r12, r14, (Address::ScaleFactor)1, +0x2ae6568f), 256);\",             \/\/ IID44\n+    \"__ cmpl(Address(r24, r30, (Address::ScaleFactor)3, -0x11b9aeac), 1048576);\",         \/\/ IID45\n+    \"__ sarl(Address(r22, r30, (Address::ScaleFactor)2, +0x60cb9115), 1);\",               \/\/ IID46\n+    \"__ sall(Address(r31, r8, (Address::ScaleFactor)1, +0x236d8ab9), 16);\",               \/\/ IID47\n+    \"__ sbbl(Address(r21, r12, (Address::ScaleFactor)1, -0x7d9b9f18), 16777216);\",        \/\/ IID48\n+    \"__ shrl(Address(r29, r17, (Address::ScaleFactor)0, -0x7c54f216), 8);\",               \/\/ IID49\n+    \"__ subl(Address(r8, r27, (Address::ScaleFactor)2, -0x1190e2c6), 16);\",               \/\/ IID50\n+    \"__ xorl(Address(rdx, +0x50dd3396), 1048576);\",                                       \/\/ IID51\n+    \"__ orb(Address(r20, -0x7dd1f614), 64);\",                                             \/\/ IID52\n+    \"__ orl(Address(r18, +0x6f852a9f), 16);\",                                             \/\/ IID53\n+    \"__ movb(Address(r20, r8, (Address::ScaleFactor)2, +0x436e2aa), 1);\",                 \/\/ IID54\n+    \"__ movl(Address(rcx, r14, (Address::ScaleFactor)1, +0x883df84), 16);\",               \/\/ IID55\n+    \"__ testb(Address(r11, r10, (Address::ScaleFactor)1, -0x1fc2039b), 16);\",             \/\/ IID56\n+    \"__ testl(Address(r29, +0x73b9f003), 67108864);\",                                     \/\/ IID57\n+    \"__ cmpl_imm32(Address(r29, rcx, (Address::ScaleFactor)2, +0x4ca2b092), 4194304);\",   \/\/ IID58\n+    \"__ addl(r8, Address(rdx, r24, (Address::ScaleFactor)2, -0x1e1524dc));\",              \/\/ IID59\n+    \"__ andl(r19, Address(r20, r20, (Address::ScaleFactor)1, +0x6286892));\",              \/\/ IID60\n+    \"__ cmpb(r11, Address(r13, -0x42e0bf9e));\",                                           \/\/ IID61\n+    \"__ cmpl(r20, Address(rbx, r30, (Address::ScaleFactor)3, -0x30497735));\",             \/\/ IID62\n+    \"__ lzcntl(r8, Address(rdx, r9, (Address::ScaleFactor)1, +0xe2e99e));\",               \/\/ IID63\n+    \"__ orl(r9, Address(r29, r25, (Address::ScaleFactor)1, +0x50169f63));\",               \/\/ IID64\n+    \"__ adcl(r17, Address(r31, r21, (Address::ScaleFactor)3, +0x79efd170));\",             \/\/ IID65\n+    \"__ imull(r23, Address(r8, -0xa521f73));\",                                            \/\/ IID66\n+    \"__ popcntl(r30, Address(r10, +0x44352901));\",                                        \/\/ IID67\n+    \"__ sbbl(r16, Address(r18, r14, (Address::ScaleFactor)1, -0xda8278a));\",              \/\/ IID68\n+    \"__ subl(r17, Address(r22, +0x2d63aab3));\",                                           \/\/ IID69\n+    \"__ tzcntl(r23, Address(r21, r11, (Address::ScaleFactor)0, -0x18bc7469));\",           \/\/ IID70\n+    \"__ xorb(r9, Address(r19, rdx, (Address::ScaleFactor)0, -0x5f6207ed));\",              \/\/ IID71\n+    \"__ xorw(r11, Address(r21, r10, (Address::ScaleFactor)2, -0x63c79f2b));\",             \/\/ IID72\n+    \"__ xorl(r29, Address(r31, rcx, (Address::ScaleFactor)3, +0x34d93c0f));\",             \/\/ IID73\n+    \"__ movb(r17, Address(r8, r18, (Address::ScaleFactor)2, -0x38ff3ad7));\",              \/\/ IID74\n+    \"__ movl(r31, Address(r20, r11, (Address::ScaleFactor)2, -0x1d23470c));\",             \/\/ IID75\n+    \"__ leal(r31, Address(rbx, r12, (Address::ScaleFactor)2, -0x3b4a4215));\",             \/\/ IID76\n+    \"__ xchgb(r20, Address(r30, r24, (Address::ScaleFactor)0, -0x5c4e82bc));\",            \/\/ IID77\n+    \"__ xchgw(r13, Address(r10, r21, (Address::ScaleFactor)3, +0x19bd4a03));\",            \/\/ IID78\n+    \"__ xchgl(r23, Address(r16, r13, (Address::ScaleFactor)2, -0x6a0293d6));\",            \/\/ IID79\n+    \"__ testl(r13, Address(r9, +0x34a6ff61));\",                                           \/\/ IID80\n+    \"__ addb(r23, 4);\",                                                                   \/\/ IID81\n+    \"__ addl(r28, 65536);\",                                                               \/\/ IID82\n+#endif \/\/ _LP64\n+    \"__ andl(rdx, 65536);\",                                                               \/\/ IID83\n+#ifdef _LP64\n+    \"__ adcl(r27, 1048576);\",                                                             \/\/ IID84\n+    \"__ cmpb(r13, 4);\",                                                                   \/\/ IID85\n+    \"__ cmpl(r29, 268435456);\",                                                           \/\/ IID86\n+    \"__ rcll(r20, 16);\",                                                                  \/\/ IID87\n+    \"__ roll(r25, 2);\",                                                                   \/\/ IID88\n+#endif \/\/ _LP64\n+    \"__ rorl(rdx, 4);\",                                                                   \/\/ IID89\n+    \"__ sarl(rcx, 1);\",                                                                   \/\/ IID90\n+#ifdef _LP64\n+    \"__ sall(r19, 16);\",                                                                  \/\/ IID91\n+    \"__ sbbl(r9, 1);\",                                                                    \/\/ IID92\n+    \"__ shll(r20, 8);\",                                                                   \/\/ IID93\n+#endif \/\/ _LP64\n+    \"__ shrl(rcx, 1);\",                                                                   \/\/ IID94\n+#ifdef _LP64\n+    \"__ subl(r19, 16777216);\",                                                            \/\/ IID95\n+    \"__ xorl(r16, 4096);\",                                                                \/\/ IID96\n+    \"__ movl(r24, 65536);\",                                                               \/\/ IID97\n+    \"__ testb(r20, 64);\",                                                                 \/\/ IID98\n+    \"__ testl(r28, 16777216);\",                                                           \/\/ IID99\n+    \"__ subl_imm32(r29, 262144);\",                                                        \/\/ IID100\n+    \"__ cmovl(Assembler::Condition::overflow, r8, Address(r26, r28, (Address::ScaleFactor)1, +0x210f06d));\", \/\/ IID101\n+    \"__ cmovl(Assembler::Condition::noOverflow, rbx, Address(r18, rbx, (Address::ScaleFactor)0, -0x264fce2a));\", \/\/ IID102\n+    \"__ cmovl(Assembler::Condition::below, r29, Address(r17, r24, (Address::ScaleFactor)0, +0x46c06acb));\", \/\/ IID103\n+    \"__ cmovl(Assembler::Condition::aboveEqual, r17, Address(r25, r11, (Address::ScaleFactor)3, -0x3b21f455));\", \/\/ IID104\n+    \"__ cmovl(Assembler::Condition::zero, r23, Address(r20, r31, (Address::ScaleFactor)0, -0x5a03317b));\", \/\/ IID105\n+    \"__ cmovl(Assembler::Condition::notZero, r31, Address(r31, r15, (Address::ScaleFactor)2, -0x53fc2e65));\", \/\/ IID106\n+    \"__ cmovl(Assembler::Condition::belowEqual, r28, Address(rdx, rcx, (Address::ScaleFactor)3, -0x3bc9229f));\", \/\/ IID107\n+    \"__ cmovl(Assembler::Condition::above, r31, Address(rdx, r19, (Address::ScaleFactor)3, +0x7bf1761c));\", \/\/ IID108\n+    \"__ cmovl(Assembler::Condition::negative, rdx, Address(r17, r18, (Address::ScaleFactor)0, -0x1da2fc03));\", \/\/ IID109\n+    \"__ cmovl(Assembler::Condition::positive, r9, Address(r21, r23, (Address::ScaleFactor)2, -0x2799454a));\", \/\/ IID110\n+    \"__ cmovl(Assembler::Condition::parity, r27, Address(r13, -0x654c249c));\",            \/\/ IID111\n+    \"__ cmovl(Assembler::Condition::noParity, rdx, Address(r24, r10, (Address::ScaleFactor)3, +0x6c96beb2));\", \/\/ IID112\n+    \"__ cmovl(Assembler::Condition::less, r9, Address(rcx, r8, (Address::ScaleFactor)3, +0x573e1892));\", \/\/ IID113\n+    \"__ cmovl(Assembler::Condition::greaterEqual, r31, Address(r26, r14, (Address::ScaleFactor)2, +0x717110b1));\", \/\/ IID114\n+    \"__ cmovl(Assembler::Condition::lessEqual, r24, Address(r19, r14, (Address::ScaleFactor)2, +0x119faad7));\", \/\/ IID115\n+    \"__ cmovl(Assembler::Condition::greater, r12, Address(r13, r12, (Address::ScaleFactor)0, +0xd537805));\", \/\/ IID116\n+    \"__ setb(Assembler::Condition::overflow, r10);\",                                      \/\/ IID117\n+#endif \/\/ _LP64\n+    \"__ setb(Assembler::Condition::noOverflow, rbx);\",                                    \/\/ IID118\n+#ifdef _LP64\n+    \"__ setb(Assembler::Condition::below, r13);\",                                         \/\/ IID119\n+    \"__ setb(Assembler::Condition::aboveEqual, r23);\",                                    \/\/ IID120\n+    \"__ setb(Assembler::Condition::zero, r24);\",                                          \/\/ IID121\n+    \"__ setb(Assembler::Condition::notZero, r15);\",                                       \/\/ IID122\n+    \"__ setb(Assembler::Condition::belowEqual, r21);\",                                    \/\/ IID123\n+    \"__ setb(Assembler::Condition::above, r17);\",                                         \/\/ IID124\n+    \"__ setb(Assembler::Condition::negative, r10);\",                                      \/\/ IID125\n+    \"__ setb(Assembler::Condition::positive, r24);\",                                      \/\/ IID126\n+    \"__ setb(Assembler::Condition::parity, r16);\",                                        \/\/ IID127\n+    \"__ setb(Assembler::Condition::noParity, r28);\",                                      \/\/ IID128\n+    \"__ setb(Assembler::Condition::less, r11);\",                                          \/\/ IID129\n+    \"__ setb(Assembler::Condition::greaterEqual, r25);\",                                  \/\/ IID130\n+    \"__ setb(Assembler::Condition::lessEqual, r18);\",                                     \/\/ IID131\n+    \"__ setb(Assembler::Condition::greater, r14);\",                                       \/\/ IID132\n+    \"__ divl(r30);\",                                                                      \/\/ IID133\n+    \"__ idivl(r23);\",                                                                     \/\/ IID134\n+    \"__ imull(r28);\",                                                                     \/\/ IID135\n+    \"__ mull(r31);\",                                                                      \/\/ IID136\n+    \"__ negl(r27);\",                                                                      \/\/ IID137\n+    \"__ notl(r16);\",                                                                      \/\/ IID138\n+#endif \/\/ _LP64\n+    \"__ roll(rdx);\",                                                                      \/\/ IID139\n+#ifdef _LP64\n+    \"__ rorl(r12);\",                                                                      \/\/ IID140\n+    \"__ sarl(r14);\",                                                                      \/\/ IID141\n+    \"__ sall(r19);\",                                                                      \/\/ IID142\n+    \"__ shll(r10);\",                                                                      \/\/ IID143\n+    \"__ shrl(r20);\",                                                                      \/\/ IID144\n+#endif \/\/ _LP64\n+    \"__ incrementl(rbx);\",                                                                \/\/ IID145\n+#ifdef _LP64\n+    \"__ decrementl(r14);\",                                                                \/\/ IID146\n+    \"__ mull(Address(r12, -0x57a4fa5e));\",                                                \/\/ IID147\n+    \"__ negl(Address(rbx, -0x3db4cfc7));\",                                                \/\/ IID148\n+    \"__ sarl(Address(r21, -0x7e70ad30));\",                                                \/\/ IID149\n+    \"__ sall(Address(r21, r28, (Address::ScaleFactor)3, -0x23456bc9));\",                  \/\/ IID150\n+    \"__ shrl(Address(r11, r13, (Address::ScaleFactor)1, -0xe00fc44));\",                   \/\/ IID151\n+    \"__ incrementl(Address(r19, -0x5e6ad56a));\",                                          \/\/ IID152\n+    \"__ decrementl(Address(rcx, r20, (Address::ScaleFactor)0, -0x2530b9c4));\",            \/\/ IID153\n+    \"__ imull(r17, Address(r8, r24, (Address::ScaleFactor)1, +0x2efecf26), 1048576);\",    \/\/ IID154\n+    \"__ imull(r9, r8, 268435456);\",                                                       \/\/ IID155\n+    \"__ shldl(r10, r15, 8);\",                                                             \/\/ IID156\n+    \"__ shrdl(r29, r22, 2);\",                                                             \/\/ IID157\n+    \"__ movzbl(r14, Address(r19, -0x6c33584));\",                                          \/\/ IID158\n+    \"__ movzwl(r25, Address(r12, r27, (Address::ScaleFactor)0, +0x2d05fa44));\",           \/\/ IID159\n+    \"__ movsbl(r12, Address(r30, r15, (Address::ScaleFactor)0, +0x65bccac1));\",           \/\/ IID160\n+    \"__ movswl(r26, Address(r10, r24, (Address::ScaleFactor)0, +0x1d707459));\",           \/\/ IID161\n+    \"__ movzbl(r18, r8);\",                                                                \/\/ IID162\n+    \"__ movzwl(r31, r9);\",                                                                \/\/ IID163\n+    \"__ movsbl(r15, r22);\",                                                               \/\/ IID164\n+    \"__ movswl(r24, r24);\",                                                               \/\/ IID165\n+    \"__ cmpxchgb(r18, Address(r12, r28, (Address::ScaleFactor)1, -0x4855a65f));\",         \/\/ IID166\n+    \"__ cmpxchgw(r28, Address(rdx, r14, (Address::ScaleFactor)3, +0x16f5a558));\",         \/\/ IID167\n+    \"__ cmpxchgl(rdx, Address(r18, rdx, (Address::ScaleFactor)1, +0x50258d9c));\",         \/\/ IID168\n+    \"__ adcq(r9, rbx);\",                                                                  \/\/ IID169\n+    \"__ cmpq(r26, r24);\",                                                                 \/\/ IID170\n+    \"__ imulq(r14, rdx);\",                                                                \/\/ IID171\n+    \"__ popcntq(r25, r30);\",                                                              \/\/ IID172\n+    \"__ sbbq(r24, r19);\",                                                                 \/\/ IID173\n+    \"__ subq(r15, r11);\",                                                                 \/\/ IID174\n+    \"__ tzcntq(r18, r21);\",                                                               \/\/ IID175\n+    \"__ lzcntq(r15, r27);\",                                                               \/\/ IID176\n+    \"__ addq(r21, r20);\",                                                                 \/\/ IID177\n+    \"__ andq(r11, r26);\",                                                                 \/\/ IID178\n+    \"__ orq(r29, r15);\",                                                                  \/\/ IID179\n+    \"__ xorq(r24, r21);\",                                                                 \/\/ IID180\n+    \"__ movq(r14, r13);\",                                                                 \/\/ IID181\n+    \"__ bsfq(r11, r22);\",                                                                 \/\/ IID182\n+    \"__ bsrq(r14, r23);\",                                                                 \/\/ IID183\n+    \"__ btq(r22, rcx);\",                                                                  \/\/ IID184\n+    \"__ xchgq(r25, r29);\",                                                                \/\/ IID185\n+    \"__ testq(r15, r8);\",                                                                 \/\/ IID186\n+    \"__ addq(Address(r14, r10, (Address::ScaleFactor)3, -0x36e6fa02), r16);\",             \/\/ IID187\n+    \"__ andq(Address(rbx, r8, (Address::ScaleFactor)3, -0x279a21b8), r18);\",              \/\/ IID188\n+    \"__ cmpq(Address(r24, +0x62c3c9ef), r13);\",                                           \/\/ IID189\n+    \"__ orq(Address(r11, r22, (Address::ScaleFactor)2, +0x419fb378), r11);\",              \/\/ IID190\n+    \"__ xorq(Address(r25, r14, (Address::ScaleFactor)2, -0x32b449dd), r13);\",             \/\/ IID191\n+    \"__ subq(Address(r28, r31, (Address::ScaleFactor)3, +0x6ce1d361), r19);\",             \/\/ IID192\n+    \"__ movq(Address(r25, r25, (Address::ScaleFactor)2, -0x3f5767c), r11);\",              \/\/ IID193\n+    \"__ xaddq(Address(r19, r17, (Address::ScaleFactor)3, +0x1febf06c), r20);\",            \/\/ IID194\n+    \"__ andq(Address(r26, r17, (Address::ScaleFactor)1, -0x6b865f05), 65536);\",           \/\/ IID195\n+    \"__ addq(Address(r27, -0x6ec95d87), 65536);\",                                         \/\/ IID196\n+    \"__ cmpq(Address(rbx, r26, (Address::ScaleFactor)2, -0x1eabea4), 1048576);\",          \/\/ IID197\n+    \"__ sarq(Address(rbx, r19, (Address::ScaleFactor)0, +0x3c3c3de8), 8);\",               \/\/ IID198\n+    \"__ salq(Address(r20, r23, (Address::ScaleFactor)1, +0x68519b6d), 8);\",               \/\/ IID199\n+    \"__ sbbq(Address(r31, r22, (Address::ScaleFactor)0, -0x7b3d1e85), 16);\",              \/\/ IID200\n+    \"__ shrq(Address(r15, r18, (Address::ScaleFactor)3, +0x4d9d824), 4);\",                \/\/ IID201\n+    \"__ subq(Address(rdx, r29, (Address::ScaleFactor)2, +0x7e4aea85), 1);\",               \/\/ IID202\n+    \"__ xorq(Address(r23, r10, (Address::ScaleFactor)1, +0x2895c620), 16777216);\",        \/\/ IID203\n+    \"__ orq(Address(r14, r13, (Address::ScaleFactor)0, -0x771b399b), 1);\",                \/\/ IID204\n+    \"__ movq(Address(r22, -0x63459b5a), 256);\",                                           \/\/ IID205\n+    \"__ testq(Address(r13, -0xb9691c5), -1);\",                                            \/\/ IID206\n+    \"__ addq(r17, Address(r15, -0x51b64b0d));\",                                           \/\/ IID207\n+    \"__ andq(rcx, Address(r16, rcx, (Address::ScaleFactor)3, -0x1c8e4b54));\",             \/\/ IID208\n+    \"__ cmpq(r23, Address(r17, rcx, (Address::ScaleFactor)3, -0x44705560));\",             \/\/ IID209\n+    \"__ lzcntq(r19, Address(r19, +0x487fe792));\",                                         \/\/ IID210\n+    \"__ orq(r11, Address(r17, -0x65de4329));\",                                            \/\/ IID211\n+    \"__ adcq(r29, Address(r9, -0x7092dc03));\",                                            \/\/ IID212\n+    \"__ imulq(r9, Address(r26, r26, (Address::ScaleFactor)3, -0x118287f7));\",             \/\/ IID213\n+    \"__ popcntq(r19, Address(r15, r19, (Address::ScaleFactor)1, -0x6e31ef95));\",          \/\/ IID214\n+    \"__ sbbq(r30, Address(r23, -0x46545c5e));\",                                           \/\/ IID215\n+    \"__ subq(r23, Address(r31, r18, (Address::ScaleFactor)3, +0x663c37d8));\",             \/\/ IID216\n+    \"__ tzcntq(r24, Address(r24, r25, (Address::ScaleFactor)3, -0x465a78f1));\",           \/\/ IID217\n+    \"__ xorq(r14, Address(r15, r19, (Address::ScaleFactor)1, +0x4196affa));\",             \/\/ IID218\n+    \"__ movq(rdx, Address(r25, r29, (Address::ScaleFactor)1, +0x115a6157));\",             \/\/ IID219\n+    \"__ leaq(r19, Address(r28, r31, (Address::ScaleFactor)2, +0x6b82f933));\",             \/\/ IID220\n+    \"__ cvttsd2siq(rcx, Address(r24, r21, (Address::ScaleFactor)3, -0x39dc99eb));\",       \/\/ IID221\n+    \"__ xchgq(r29, Address(r17, r24, (Address::ScaleFactor)3, +0x5902f01d));\",            \/\/ IID222\n+    \"__ testq(r12, Address(r24, r29, (Address::ScaleFactor)2, +0x8865bfc));\",             \/\/ IID223\n+    \"__ addq(r10, 16);\",                                                                  \/\/ IID224\n+    \"__ andq(r26, 256);\",                                                                 \/\/ IID225\n+    \"__ adcq(rcx, 1);\",                                                                   \/\/ IID226\n+    \"__ cmpq(r21, 65536);\",                                                               \/\/ IID227\n+    \"__ rclq(r28, 4);\",                                                                   \/\/ IID228\n+    \"__ rcrq(r28, 16);\",                                                                  \/\/ IID229\n+    \"__ rolq(r18, 1);\",                                                                   \/\/ IID230\n+    \"__ rorq(r26, 2);\",                                                                   \/\/ IID231\n+    \"__ sarq(r19, 2);\",                                                                   \/\/ IID232\n+    \"__ salq(r14, 8);\",                                                                   \/\/ IID233\n+    \"__ sbbq(r10, 65536);\",                                                               \/\/ IID234\n+    \"__ shlq(r30, 1);\",                                                                   \/\/ IID235\n+    \"__ shrq(r15, 8);\",                                                                   \/\/ IID236\n+    \"__ subq(r21, 1048576);\",                                                             \/\/ IID237\n+    \"__ xorq(rbx, 268435456);\",                                                           \/\/ IID238\n+    \"__ movq(r19, 16);\",                                                                  \/\/ IID239\n+    \"__ mov64(r19, 17179869184);\",                                                        \/\/ IID240\n+    \"__ btq(r21, 1);\",                                                                    \/\/ IID241\n+    \"__ testq(r15, -65536);\",                                                             \/\/ IID242\n+    \"__ orq_imm32(r21, 1073741824);\",                                                     \/\/ IID243\n+    \"__ subq_imm32(r19, 65536);\",                                                         \/\/ IID244\n+    \"__ cmovq(Assembler::Condition::overflow, r15, Address(r29, -0x5c98219a));\",          \/\/ IID245\n+    \"__ cmovq(Assembler::Condition::noOverflow, rcx, Address(r21, +0x22cc581));\",         \/\/ IID246\n+    \"__ cmovq(Assembler::Condition::below, r15, Address(r29, r13, (Address::ScaleFactor)2, -0x5e968fb9));\", \/\/ IID247\n+    \"__ cmovq(Assembler::Condition::aboveEqual, r26, Address(r24, +0x440c6894));\",        \/\/ IID248\n+    \"__ cmovq(Assembler::Condition::zero, r17, Address(r23, r26, (Address::ScaleFactor)3, +0x23558b4e));\", \/\/ IID249\n+    \"__ cmovq(Assembler::Condition::notZero, r9, Address(r16, r29, (Address::ScaleFactor)3, -0x1289a3c9));\", \/\/ IID250\n+    \"__ cmovq(Assembler::Condition::belowEqual, r8, Address(r11, -0x49e134cc));\",         \/\/ IID251\n+    \"__ cmovq(Assembler::Condition::above, r26, Address(r11, r20, (Address::ScaleFactor)1, -0x3ef9057a));\", \/\/ IID252\n+    \"__ cmovq(Assembler::Condition::negative, r11, Address(r26, r13, (Address::ScaleFactor)2, +0x4bd18f9f));\", \/\/ IID253\n+    \"__ cmovq(Assembler::Condition::positive, r8, Address(r9, r11, (Address::ScaleFactor)3, +0x4b42a528));\", \/\/ IID254\n+    \"__ cmovq(Assembler::Condition::parity, r12, Address(r19, r9, (Address::ScaleFactor)1, +0x68559a1c));\", \/\/ IID255\n+    \"__ cmovq(Assembler::Condition::noParity, r22, Address(r18, r17, (Address::ScaleFactor)1, +0x2c4d8e80));\", \/\/ IID256\n+    \"__ cmovq(Assembler::Condition::less, r26, Address(r18, r30, (Address::ScaleFactor)0, -0x2ae8896e));\", \/\/ IID257\n+    \"__ cmovq(Assembler::Condition::greaterEqual, r22, Address(r11, +0x4fefa622));\",      \/\/ IID258\n+    \"__ cmovq(Assembler::Condition::lessEqual, r28, Address(r18, r27, (Address::ScaleFactor)1, +0x6b7a8c34));\", \/\/ IID259\n+    \"__ cmovq(Assembler::Condition::greater, r20, Address(r23, r20, (Address::ScaleFactor)0, -0x12e725c5));\", \/\/ IID260\n+    \"__ call(r9);\",                                                                       \/\/ IID261\n+    \"__ divq(r22);\",                                                                      \/\/ IID262\n+    \"__ idivq(r29);\",                                                                     \/\/ IID263\n+    \"__ imulq(rbx);\",                                                                     \/\/ IID264\n+    \"__ mulq(r27);\",                                                                      \/\/ IID265\n+    \"__ negq(rbx);\",                                                                      \/\/ IID266\n+    \"__ notq(r17);\",                                                                      \/\/ IID267\n+    \"__ rolq(r25);\",                                                                      \/\/ IID268\n+    \"__ rorq(rbx);\",                                                                      \/\/ IID269\n+    \"__ sarq(r17);\",                                                                      \/\/ IID270\n+    \"__ salq(r28);\",                                                                      \/\/ IID271\n+    \"__ shlq(r28);\",                                                                      \/\/ IID272\n+    \"__ shrq(r30);\",                                                                      \/\/ IID273\n+    \"__ incrementq(r27);\",                                                                \/\/ IID274\n+    \"__ decrementq(rdx);\",                                                                \/\/ IID275\n+    \"__ pushp(r27);\",                                                                     \/\/ IID276\n+    \"__ popp(r10);\",                                                                      \/\/ IID277\n+    \"__ call(Address(r27, -0x22db8705));\",                                                \/\/ IID278\n+    \"__ mulq(Address(r27, r21, (Address::ScaleFactor)0, -0x1f59ff9c));\",                  \/\/ IID279\n+    \"__ negq(Address(r19, rcx, (Address::ScaleFactor)3, +0x7a47b812));\",                  \/\/ IID280\n+    \"__ sarq(Address(r18, r21, (Address::ScaleFactor)1, -0x48857a46));\",                  \/\/ IID281\n+    \"__ salq(Address(r24, -0x7a2bda2c));\",                                                \/\/ IID282\n+    \"__ shrq(Address(r24, +0x1abd92f));\",                                                 \/\/ IID283\n+    \"__ incrementq(Address(r9, r9, (Address::ScaleFactor)3, +0x31a92520));\",              \/\/ IID284\n+    \"__ decrementq(Address(r9, r8, (Address::ScaleFactor)0, +0x7f14b4bd));\",              \/\/ IID285\n+    \"__ imulq(r14, Address(r29, r15, (Address::ScaleFactor)1, +0x5281cf9c), 256);\",       \/\/ IID286\n+    \"__ imulq(r16, r28, 1048576);\",                                                       \/\/ IID287\n+    \"__ shldq(r17, r24, 2);\",                                                             \/\/ IID288\n+    \"__ shrdq(r16, r11, 2);\",                                                             \/\/ IID289\n+    \"__ pop2(r10, r11);\",                                                                 \/\/ IID290\n+    \"__ pop2p(r15, r24);\",                                                                \/\/ IID291\n+    \"__ push2(r28, r11);\",                                                                \/\/ IID292\n+    \"__ push2p(r12, r31);\",                                                               \/\/ IID293\n+    \"__ movzbq(r24, Address(r22, r16, (Address::ScaleFactor)0, +0x511be837));\",           \/\/ IID294\n+    \"__ movzwq(r15, Address(r15, r26, (Address::ScaleFactor)2, -0x38794ee));\",            \/\/ IID295\n+    \"__ movsbq(r15, Address(r25, r16, (Address::ScaleFactor)3, -0x7a092741));\",           \/\/ IID296\n+    \"__ movswq(rdx, Address(r28, r19, (Address::ScaleFactor)2, +0x79da6a));\",             \/\/ IID297\n+    \"__ movzbq(r27, r9);\",                                                                \/\/ IID298\n+    \"__ movzwq(r25, r21);\",                                                               \/\/ IID299\n+    \"__ movsbq(r14, r12);\",                                                               \/\/ IID300\n+    \"__ movswq(r23, r11);\",                                                               \/\/ IID301\n+    \"__ cmpxchgq(r30, Address(r12, -0x65a974df));\",                                       \/\/ IID302\n+#endif \/\/ _LP64\n+  };\n+\/\/ END  Generated code -- do not edit\n","filename":"test\/hotspot\/gtest\/x86\/asmtest.out.h","additions":1293,"deletions":0,"binary":false,"changes":1293,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#if defined(X86) && !defined(ZERO)\n+\n+#include \"utilities\/vmassert_uninstall.hpp\"\n+#include <cstring>\n+#include \"utilities\/vmassert_reinstall.hpp\"\n+\n+#include \"asm\/assembler.hpp\"\n+#include \"asm\/assembler.inline.hpp\"\n+#include \"asm\/macroAssembler.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+\n+#include \"unittest.hpp\"\n+\n+#define __ _masm.\n+\n+static void asm_check(const uint8_t *insns, const uint8_t *insns1, const unsigned int *insns_lens, const char *insns_strs[], size_t len) {\n+  ResourceMark rm;\n+  size_t cur_idx = 0;\n+  for (size_t i = 0; i < len; i++) {\n+    size_t insn_len = insns_lens[i];\n+    const char *insn = insns_strs[i];\n+    std::string insn_str(insn);\n+    std::string insns_name = insn_str.substr(3, insn_str.find('(') - 3);\n+\n+    if (std::memcmp(&insns[cur_idx], &insns1[cur_idx], insn_len) != 0) {\n+      stringStream ss;\n+      ss.print(\"%s\\n\", insn);\n+      ss.print(\"Ours:   \");\n+      for (size_t j = 0; j < insn_len; j++) {\n+        ss.print(\"%02x \", (uint8_t)insns[cur_idx + j]);\n+      }\n+      ss.print_cr(\"\");\n+      ss.print(\"Theirs: \");\n+      for (size_t j = 0; j < insn_len; j++) {\n+        ss.print(\"%02x \", (uint8_t)insns1[cur_idx + j]);\n+      }\n+      ADD_FAILURE() << ss.as_string();\n+    }\n+    cur_idx += insn_len;\n+  }\n+}\n+\n+TEST_VM(AssemblerX86, validate) {\n+  FlagSetting flag_change_apx(UseAPX, true);\n+  VM_Version::set_bmi_cpuFeatures();\n+  VM_Version::set_evex_cpuFeatures();\n+  VM_Version::set_avx_cpuFeatures();\n+  VM_Version::set_apx_cpuFeatures();\n+  BufferBlob* b = BufferBlob::create(\"x64Test\", 500000);\n+  CodeBuffer code(b);\n+  MacroAssembler _masm(&code);\n+  address entry = __ pc();\n+\n+  \/\/ To build asmtest.out.h, ensure you have binutils version 2.34 or higher, then run:\n+  \/\/ python3 x86-asmtest.py | expand > asmtest.out.h to generate tests with random inputs\n+  \/\/ python3 x86-asmtest.py --full | expand > asmtest.out.h to generate tests with all possible inputs\n+#include \"asmtest.out.h\"\n+\n+  asm_check((const uint8_t *)entry, (const uint8_t *)insns, insns_lens, insns_strs, sizeof(insns_lens) \/ sizeof(insns_lens[0]));\n+  BufferBlob::free(b);\n+}\n+\n+#endif \/\/ X86\n\\ No newline at end of file\n","filename":"test\/hotspot\/gtest\/x86\/test_assemblerx86.cpp","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,934 @@\n+# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+\n+import os\n+import sys\n+import platform\n+import random\n+import re\n+import subprocess\n+\n+OBJDUMP = \"objdump\"\n+X86_AS = \"as\"\n+X86_OBJCOPY = \"objcopy\"\n+\n+cond_to_suffix = {\n+    'overflow': 'o',\n+    'noOverflow': 'no',\n+    'below': 'b',\n+    'aboveEqual': 'ae',\n+    'zero': 'z',\n+    'notZero': 'nz',\n+    'belowEqual': 'be',\n+    'above': 'a',\n+    'negative': 's',\n+    'positive': 'ns',\n+    'parity': 'p',\n+    'noParity': 'np',\n+    'less': 'l',\n+    'greaterEqual': 'ge',\n+    'lessEqual': 'le',\n+    'greater': 'g',\n+}\n+\n+shift_rot_ops = {'sarl', 'sarq', 'sall', 'salq', 'shll', 'shlq', 'shrl', 'shrq', 'shrdl', 'shrdq', 'shldl', 'shldq', 'rcrq', 'rorl', 'rorq', 'roll', 'rolq', 'rcll', 'rclq'}\n+\n+registers_mapping = {\n+    # skip rax, rsi, rdi, rsp, rbp as they have special encodings\n+    # 'rax': {64: 'rax', 32: 'eax', 16: 'ax', 8: 'al'},\n+    'rcx': {64: 'rcx', 32: 'ecx', 16: 'cx', 8: 'cl'},\n+    'rdx': {64: 'rdx', 32: 'edx', 16: 'dx', 8: 'dl'},\n+    'rbx': {64: 'rbx', 32: 'ebx', 16: 'bx', 8: 'bl'},\n+    # 'rsp': {64: 'rsp', 32: 'esp', 16: 'sp', 8: 'spl'},\n+    # 'rbp': {64: 'rbp', 32: 'ebp', 16: 'bp', 8: 'bpl'},\n+    # 'rsi': {64: 'rsi', 32: 'esi', 16: 'si', 8: 'sil'},\n+    # 'rdi': {64: 'rdi', 32: 'edi', 16: 'di', 8: 'dil'},\n+    'r8': {64: 'r8', 32: 'r8d', 16: 'r8w', 8: 'r8b'},\n+    'r9': {64: 'r9', 32: 'r9d', 16: 'r9w', 8: 'r9b'},\n+    'r10': {64: 'r10', 32: 'r10d', 16: 'r10w', 8: 'r10b'},\n+    'r11': {64: 'r11', 32: 'r11d', 16: 'r11w', 8: 'r11b'},\n+    'r12': {64: 'r12', 32: 'r12d', 16: 'r12w', 8: 'r12b'},\n+    'r13': {64: 'r13', 32: 'r13d', 16: 'r13w', 8: 'r13b'},\n+    'r14': {64: 'r14', 32: 'r14d', 16: 'r14w', 8: 'r14b'},\n+    'r15': {64: 'r15', 32: 'r15d', 16: 'r15w', 8: 'r15b'},\n+    'r16': {64: 'r16', 32: 'r16d', 16: 'r16w', 8: 'r16b'},\n+    'r17': {64: 'r17', 32: 'r17d', 16: 'r17w', 8: 'r17b'},\n+    'r18': {64: 'r18', 32: 'r18d', 16: 'r18w', 8: 'r18b'},\n+    'r19': {64: 'r19', 32: 'r19d', 16: 'r19w', 8: 'r19b'},\n+    'r20': {64: 'r20', 32: 'r20d', 16: 'r20w', 8: 'r20b'},\n+    'r21': {64: 'r21', 32: 'r21d', 16: 'r21w', 8: 'r21b'},\n+    'r22': {64: 'r22', 32: 'r22d', 16: 'r22w', 8: 'r22b'},\n+    'r23': {64: 'r23', 32: 'r23d', 16: 'r23w', 8: 'r23b'},\n+    'r24': {64: 'r24', 32: 'r24d', 16: 'r24w', 8: 'r24b'},\n+    'r25': {64: 'r25', 32: 'r25d', 16: 'r25w', 8: 'r25b'},\n+    'r26': {64: 'r26', 32: 'r26d', 16: 'r26w', 8: 'r26b'},\n+    'r27': {64: 'r27', 32: 'r27d', 16: 'r27w', 8: 'r27b'},\n+    'r28': {64: 'r28', 32: 'r28d', 16: 'r28w', 8: 'r28b'},\n+    'r29': {64: 'r29', 32: 'r29d', 16: 'r29w', 8: 'r29b'},\n+    'r30': {64: 'r30', 32: 'r30d', 16: 'r30w', 8: 'r30b'},\n+    'r31': {64: 'r31', 32: 'r31d', 16: 'r31w', 8: 'r31b'},\n+}\n+\n+class Operand(object):\n+    def generate(self):\n+        return self\n+\n+class Register(Operand):\n+    def generate(self, reg, width):\n+        self.reg = reg\n+        self.areg = registers_mapping.get(reg, {}).get(width, reg)\n+        return self\n+\n+    def cstr(self):\n+        return self.reg\n+\n+    def astr(self):\n+        return self.areg\n+\n+class Immediate(Operand):\n+    def generate(self, value):\n+        self._value = value\n+        return self\n+\n+    def cstr(self):\n+        return str(self._value)\n+\n+    def astr(self):\n+        return str(self._value)\n+\n+class Address(Operand):\n+    width_to_ptr = {\n+        8: \"byte ptr\",\n+        16: \"word ptr\",\n+        32: \"dword ptr\",\n+        64: \"qword ptr\"\n+    }\n+\n+    def generate(self, base, index, width):\n+        self.base = Register().generate(base, 64)\n+        self.index = Register().generate(index, 64)\n+        self._width = width\n+        self._scale_factor = random.choice([-1, 0, 1, 2, 3])\n+        self._disp = random.randint(-2**31, 2**31 - 1)\n+        return self\n+\n+    def cstr(self):\n+        disp_str = \"{0:+#x}\".format(self._disp)\n+        if self._scale_factor == -1:\n+            return f\"Address({self.base.cstr()}, {disp_str})\"\n+        else:\n+            return f\"Address({self.base.cstr()}, {self.index.cstr()}, (Address::ScaleFactor){self._scale_factor}, {disp_str})\"\n+\n+    def astr(self):\n+        ptr_str = self.width_to_ptr.get(self._width, \"qword ptr\")\n+        disp_str = \"{0:+#x}\".format(self._disp)\n+        if self._scale_factor == -1:\n+            return f\"{ptr_str} [{self.base.cstr() + disp_str}]\"\n+        else:\n+            return f\"{ptr_str} [{self.base.cstr()}+{self.index.cstr()}*{2 ** self._scale_factor}{disp_str}]\"\n+\n+class Instruction(object):\n+    def __init__(self, name, aname):\n+        self._name = name\n+        self._aname = aname\n+\n+    def generate_operands(self, *operands):\n+        self.operands = [operand for operand in operands]\n+\n+    def cstr(self):\n+        return f'__ {self._name}(' + ', '.join([op.cstr() for op in self.operands]) + ');'\n+\n+    def astr(self):\n+        # JDK assembler uses 'cl' for shift instructions with one operand by default\n+        cl_str = (', cl' if self._name in shift_rot_ops and len(self.operands) == 1 else '')\n+        return f'{self._aname} ' + ', '.join([op.astr() for op in self.operands]) + cl_str\n+\n+class RegInstruction(Instruction):\n+    def __init__(self, name, aname, width, reg):\n+        super().__init__(name, aname)\n+        self.reg = Register().generate(reg, width)\n+        self.generate_operands(self.reg)\n+\n+class MemInstruction(Instruction):\n+    def __init__(self, name, aname, width, mem_base, mem_idx):\n+        super().__init__(name, aname)\n+        self.mem = Address().generate(mem_base, mem_idx, width)\n+        self.generate_operands(self.mem)\n+\n+class TwoRegInstruction(Instruction):\n+    def __init__(self, name, aname, width, reg1, reg2):\n+        super().__init__(name, aname)\n+        self.reg1 = Register().generate(reg1, width)\n+        self.reg2 = Register().generate(reg2, width)\n+        self.generate_operands(self.reg1, self.reg2)\n+\n+    def astr(self):\n+        return f'{{load}}' + super().astr()\n+\n+class MemRegInstruction(Instruction):\n+    def __init__(self, name, aname, width, reg, mem_base, mem_idx):\n+        super().__init__(name, aname)\n+        self.mem = Address().generate(mem_base, mem_idx, width)\n+        self.reg = Register().generate(reg, width)\n+        self.generate_operands(self.mem, self.reg)\n+\n+class RegMemInstruction(Instruction):\n+    def __init__(self, name, aname, width, reg, mem_base, mem_idx):\n+        super().__init__(name, aname)\n+        self.reg = Register().generate(reg, width)\n+        self.mem = Address().generate(mem_base, mem_idx, width)\n+        self.generate_operands(self.reg, self.mem)\n+\n+class RegImmInstruction(Instruction):\n+    def __init__(self, name, aname, width, reg, imm):\n+        super().__init__(name, aname)\n+        self.reg = Register().generate(reg, width)\n+        self.imm = Immediate().generate(imm)\n+        self.generate_operands(self.reg, self.imm)\n+\n+class MemImmInstruction(Instruction):\n+    def __init__(self, name, aname, width, imm, mem_base, mem_idx):\n+        super().__init__(name, aname)\n+        self.mem = Address().generate(mem_base, mem_idx, width)\n+        self.imm = Immediate().generate(imm)\n+        self.generate_operands(self.mem, self.imm)\n+\n+class RegRegImmInstruction(Instruction):\n+    def __init__(self, name, aname, width, reg1, reg2, imm):\n+        super().__init__(name, aname)\n+        self.reg1 = Register().generate(reg1, width)\n+        self.reg2 = Register().generate(reg2, width)\n+        self.imm = Immediate().generate(imm)\n+        self.generate_operands(self.reg1, self.reg2, self.imm)\n+\n+class RegMemImmInstruction(Instruction):\n+    def __init__(self, name, aname, width, reg, imm, mem_base, mem_idx):\n+        super().__init__(name, aname)\n+        self.reg = Register().generate(reg, width)\n+        self.mem = Address().generate(mem_base, mem_idx, width)\n+        self.imm = Immediate().generate(imm)\n+        self.generate_operands(self.reg, self.mem, self.imm)\n+\n+class Pop2Instruction(TwoRegInstruction):\n+    def __init__(self, name, aname, width, reg1, reg2):\n+        super().__init__(name, aname, width, reg1, reg2)\n+\n+    def cstr(self):\n+        # reverse to match the order in OpenJDK\n+        return f'__ {self._name}(' + ', '.join([reg.cstr() for reg in reversed(self.operands)]) + ');'\n+\n+class Push2Instruction(TwoRegInstruction):\n+    def __init__(self, name, aname, width, reg1, reg2):\n+        super().__init__(name, aname, width, reg1, reg2)\n+\n+    def cstr(self):\n+        # reverse to match the order in OpenJDK\n+        return f'__ {self._name}(' + ', '.join([reg.cstr() for reg in reversed(self.operands)]) + ');'\n+\n+class CmpxchgInstruction(MemRegInstruction):\n+    def __init__(self, name, aname, width, reg, mem_base, mem_idx):\n+        super().__init__(name, aname, width, reg, mem_base, mem_idx)\n+\n+    def cstr(self):\n+        # reverse to match the order in OpenJDK\n+        return f'__ {self._name}(' + ', '.join([reg.cstr() for reg in reversed(self.operands)]) + ');'\n+\n+class CondRegMemInstruction(RegMemInstruction):\n+    def __init__(self, name, aname, width, cond, reg, mem_base, mem_idx):\n+        super().__init__(name, aname, width, reg, mem_base, mem_idx)\n+        self.cond = cond\n+\n+    def cstr(self):\n+        return f'__ {self._name}(' + 'Assembler::Condition::' + self.cond + ', ' + ', '.join([self.reg.cstr(), self.mem.cstr()]) + ');'\n+\n+    def astr(self):\n+        return f'{self._aname}' + cond_to_suffix[self.cond] + ' ' + ', '.join([self.reg.astr(), self.mem.astr()])\n+\n+class CondRegInstruction(RegInstruction):\n+    def __init__(self, name, aname, width, cond, reg):\n+        super().__init__(name, aname, width, reg)\n+        self.cond = cond\n+\n+    def cstr(self):\n+        return f'__ {self._name}b(' + 'Assembler::Condition::' + self.cond + ', ' + self.reg.cstr() + ');'\n+\n+    def astr(self):\n+        return f'{self._aname}' + cond_to_suffix[self.cond] + ' ' + self.reg.astr()\n+\n+class MoveRegMemInstruction(Instruction):\n+    def __init__(self, name, aname, width, mem_width, reg, mem_base, mem_idx):\n+        super().__init__(name, aname)\n+        self.reg = Register().generate(reg, width)\n+        self.mem = Address().generate(mem_base, mem_idx, mem_width)\n+        self.generate_operands(self.reg, self.mem)\n+\n+class MoveRegRegInstruction(Instruction):\n+    def __init__(self, name, aname, width, reg_width, reg1, reg2):\n+        super().__init__(name, aname)\n+        self.reg1 = Register().generate(reg1, width)\n+        self.reg2 = Register().generate(reg2, reg_width)\n+        self.generate_operands(self.reg1, self.reg2)\n+\n+test_regs = list(registers_mapping.keys())\n+\n+immediates32 = [2 ** i for i in range(0, 32, 4)]\n+immediates16 = [2 ** i for i in range(0, 16, 2)]\n+immediates8 = [2 ** i for i in range(0, 8, 2)]\n+immediates5 = [2 ** i for i in range(0, 5, 1)]\n+immediate_values_8_to_16_bit = [2 ** i for i in range(8, 16, 2)]\n+immediate_values_16_to_32_bit = [2 ** i for i in range(16, 32, 2)]\n+immediate_values_32_to_64_bit = [2 ** i for i in range(32, 64, 2)]\n+negative_immediates32 = [-2 ** i for i in range(0, 32, 4)]\n+\n+immediate_map = {\n+    8: immediates8,\n+    16: immediates16,\n+    32: immediates32,\n+    64: immediates32\n+}\n+\n+def is_64_reg(reg):\n+    return reg in {'r8', 'r9', 'r10', 'r11', 'r12', 'r13', 'r14', 'r15', 'r16', 'r17', 'r18', 'r19', 'r20', 'r21', 'r22', 'r23', 'r24', 'r25', 'r26', 'r27', 'r28', 'r29', 'r30', 'r31'}\n+\n+def print_instruction(instr, lp64_flag, print_lp64_flag):\n+    cstr = instr.cstr()\n+    astr = instr.astr()\n+    print(\"    %-75s \/\/    %s    IID%s\" % (cstr, astr, len(ifdef_flags)))\n+    ifdef_flags.append(lp64_flag or not print_lp64_flag)\n+    insns_strs.append(cstr)\n+    outfile.write(f\"    {astr}\\n\")\n+\n+def handle_lp64_flag(lp64_flag, print_lp64_flag, *regs):\n+    for reg in regs:\n+        if is_64_reg(reg):\n+            if not lp64_flag and print_lp64_flag:\n+                print(\"#ifdef _LP64\")\n+            return True\n+    if lp64_flag and print_lp64_flag:\n+        print(\"#endif \/\/ _LP64\")\n+        return False\n+    return lp64_flag\n+\n+def get_immediate_list(op_name, width):\n+    # special cases\n+    word_imm_ops = {'addw', 'cmpw'}\n+    dword_imm_ops = {'subl_imm32', 'subq_imm32', 'orq_imm32', 'cmpl_imm32', 'testl'}\n+    qword_imm_ops = {'mov64'}\n+    neg_imm_ops = {'testq'}\n+    bt_ops = {'btq'}\n+\n+    if op_name in shift_rot_ops:\n+        return immediates5\n+    elif op_name in bt_ops:\n+        return immediate_map[8]\n+    elif op_name in word_imm_ops:\n+        return immediate_values_8_to_16_bit\n+    elif op_name in dword_imm_ops:\n+        return immediate_values_16_to_32_bit\n+    elif op_name in qword_imm_ops:\n+        return immediate_values_32_to_64_bit\n+    elif op_name in neg_imm_ops:\n+        return negative_immediates32\n+    else:\n+        return immediate_map[width]\n+\n+lp64_flag = False\n+def generate(RegOp, ops, print_lp64_flag=True, full_set=False):\n+    global lp64_flag\n+    for op in ops:\n+        op_name = op[0]\n+        width = op[2]\n+\n+        if RegOp in [RegInstruction, CondRegInstruction]:\n+            if full_set:\n+                for i in range(len(test_regs)):\n+                    test_reg = test_regs[i]\n+                    lp64_flag = handle_lp64_flag(lp64_flag, print_lp64_flag, test_reg)\n+                    instr = RegOp(*op, reg=test_reg)\n+                    print_instruction(instr, lp64_flag, print_lp64_flag)\n+            else:\n+                test_reg = random.choice(test_regs)\n+                lp64_flag = handle_lp64_flag(lp64_flag, print_lp64_flag, test_reg)\n+                instr = RegOp(*op, reg=test_reg)\n+                print_instruction(instr, lp64_flag, print_lp64_flag)\n+\n+        elif RegOp in [TwoRegInstruction, MoveRegRegInstruction]:\n+            if full_set:\n+                for i in range(len(test_regs)):\n+                    test_reg1 = test_regs[i]\n+                    test_reg2 = test_regs[(i + 1) % len(test_regs)]\n+                    lp64_flag = handle_lp64_flag(lp64_flag, print_lp64_flag, test_reg1, test_reg2)\n+                    instr = RegOp(*op, reg1=test_reg1, reg2=test_reg2)\n+                    print_instruction(instr, lp64_flag, print_lp64_flag)\n+            else:\n+                test_reg1 = random.choice(test_regs)\n+                test_reg2 = random.choice(test_regs)\n+                lp64_flag = handle_lp64_flag(lp64_flag, print_lp64_flag, test_reg1, test_reg2)\n+                instr = RegOp(*op, reg1=test_reg1, reg2=test_reg2)\n+                print_instruction(instr, lp64_flag, print_lp64_flag)\n+\n+        elif RegOp in [MemRegInstruction, RegMemInstruction, MoveRegMemInstruction, CmpxchgInstruction, CondRegMemInstruction]:\n+            if full_set:\n+                for i in range(len(test_regs)):\n+                    test_reg = test_regs[i]\n+                    test_mem_base = test_regs[(i + 1) % len(test_regs)]\n+                    test_mem_idx = test_regs[(i + 2) % len(test_regs)]\n+                    if test_mem_idx == 'rsp':\n+                        continue\n+                    lp64_flag = handle_lp64_flag(lp64_flag, print_lp64_flag, test_reg, test_mem_base, test_mem_idx)\n+                    instr = RegOp(*op, reg=test_reg, mem_base=test_mem_base, mem_idx=test_mem_idx)\n+                    print_instruction(instr, lp64_flag, print_lp64_flag)\n+            else:\n+                filtered_regs = [reg for reg in test_regs if reg != 'rsp']\n+                test_reg = random.choice(test_regs)\n+                test_mem_base = random.choice(test_regs)\n+                test_mem_idx = random.choice(filtered_regs)\n+                lp64_flag = handle_lp64_flag(lp64_flag, print_lp64_flag, test_reg, test_mem_base, test_mem_idx)\n+                instr = RegOp(*op, reg=test_reg, mem_base=test_mem_base, mem_idx=test_mem_idx)\n+                print_instruction(instr, lp64_flag, print_lp64_flag)\n+\n+        elif RegOp in [RegImmInstruction]:\n+            if full_set:\n+                imm_list = get_immediate_list(op_name, width)\n+                for i in range(len(test_regs)):\n+                    test_reg = test_regs[i]\n+                    lp64_flag = handle_lp64_flag(lp64_flag, print_lp64_flag, test_reg)\n+                    for imm in imm_list:\n+                        instr = RegOp(*op, reg=test_reg, imm=imm)\n+                        print_instruction(instr, lp64_flag, print_lp64_flag)\n+            else:\n+                test_reg = random.choice(test_regs)\n+                imm = random.choice(get_immediate_list(op_name, width))\n+                lp64_flag = handle_lp64_flag(lp64_flag, print_lp64_flag, test_reg)\n+                instr = RegOp(*op, reg=test_reg, imm=imm)\n+                print_instruction(instr, lp64_flag, print_lp64_flag)\n+\n+        elif RegOp in [MemImmInstruction]:\n+            if full_set:\n+                imm_list = get_immediate_list(op_name, width)\n+                for imm in imm_list:\n+                    for i in range(len(test_regs)):\n+                        test_mem_base = test_regs[i]\n+                        test_mem_idx = test_regs[(i + 1) % len(test_regs)]\n+                        if test_mem_idx == 'rsp':\n+                            continue\n+                        lp64_flag = handle_lp64_flag(lp64_flag, print_lp64_flag, test_mem_base, test_mem_idx)\n+                        instr = RegOp(*op, imm=imm, mem_base=test_mem_base, mem_idx=test_mem_idx)\n+                        print_instruction(instr, lp64_flag, print_lp64_flag)\n+\n+            else:\n+                filtered_regs = [reg for reg in test_regs if reg != 'rsp']\n+                imm = random.choice(get_immediate_list(op_name, width))\n+                test_mem_base = random.choice(test_regs)\n+                test_mem_idx = random.choice(filtered_regs)\n+                lp64_flag = handle_lp64_flag(lp64_flag, print_lp64_flag, test_mem_base, test_mem_idx)\n+                instr = RegOp(*op, imm=imm, mem_base=test_mem_base, mem_idx=test_mem_idx)\n+                print_instruction(instr, lp64_flag, print_lp64_flag)\n+\n+        elif RegOp in [MemInstruction]:\n+            if full_set:\n+                for i in range(len(test_regs)):\n+                    test_mem_base = test_regs[i]\n+                    test_mem_idx = test_regs[(i + 1) % len(test_regs)]\n+                    if test_mem_idx == 'rsp':\n+                        continue\n+                    lp64_flag = handle_lp64_flag(lp64_flag, print_lp64_flag, test_mem_base, test_mem_idx)\n+                    instr = RegOp(*op, mem_base=test_mem_base, mem_idx=test_mem_idx)\n+                    print_instruction(instr, lp64_flag, print_lp64_flag)\n+            else:\n+                filtered_regs = [reg for reg in test_regs if reg != 'rsp']\n+                test_mem_base = random.choice(test_regs)\n+                test_mem_idx = random.choice(filtered_regs)\n+                lp64_flag = handle_lp64_flag(lp64_flag, print_lp64_flag, test_mem_base, test_mem_idx)\n+                instr = RegOp(*op, mem_base=test_mem_base, mem_idx=test_mem_idx)\n+                print_instruction(instr, lp64_flag, print_lp64_flag)\n+\n+        elif RegOp in [RegRegImmInstruction]:\n+            if full_set:\n+                imm_list = get_immediate_list(op_name, width)\n+                for i in range(len(test_regs)):\n+                    test_reg1 = test_regs[i]\n+                    test_reg2 = test_regs[(i + 1) % len(test_regs)]\n+                    lp64_flag = handle_lp64_flag(lp64_flag, print_lp64_flag, test_reg1, test_reg2)\n+                    for imm in imm_list:\n+                        instr = RegOp(*op, reg1=test_reg1, reg2=test_reg2, imm=imm)\n+                        print_instruction(instr, lp64_flag, print_lp64_flag)\n+            else:\n+                imm = random.choice(get_immediate_list(op_name, width))\n+                test_reg1 = random.choice(test_regs)\n+                test_reg2 = random.choice(test_regs)\n+                lp64_flag = handle_lp64_flag(lp64_flag, print_lp64_flag, test_reg1, test_reg2)\n+                instr = RegOp(*op, reg1=test_reg1, reg2=test_reg2, imm=imm)\n+                print_instruction(instr, lp64_flag, print_lp64_flag)\n+\n+        elif RegOp in [RegMemImmInstruction]:\n+            if full_set:\n+                imm_list = get_immediate_list(op_name, width)\n+                for i in range(len(test_regs)):\n+                    test_reg = test_regs[i]\n+                    test_mem_base = test_regs[(i + 1) % len(test_regs)]\n+                    test_mem_idx = test_regs[(i + 2) % len(test_regs)]\n+                    if test_mem_idx == 'rsp':\n+                        continue\n+                    lp64_flag = handle_lp64_flag(lp64_flag, print_lp64_flag, test_reg, test_mem_base, test_mem_idx)\n+                    for imm in imm_list:\n+                        instr = RegOp(*op, reg=test_reg, mem_base=test_mem_base, mem_idx=test_mem_idx, imm=imm)\n+                        print_instruction(instr, lp64_flag, print_lp64_flag)\n+            else:\n+                imm = random.choice(get_immediate_list(op_name, width))\n+                filtered_regs = [reg for reg in test_regs if reg != 'rsp']\n+                test_reg = random.choice(test_regs)\n+                test_mem_base = random.choice(test_regs)\n+                test_mem_idx = random.choice(filtered_regs)\n+                lp64_flag = handle_lp64_flag(lp64_flag, print_lp64_flag, test_reg, test_mem_base, test_mem_idx)\n+                instr = RegOp(*op, reg=test_reg, imm=imm, mem_base=test_mem_base, mem_idx=test_mem_idx)\n+                print_instruction(instr, lp64_flag, print_lp64_flag)\n+\n+        elif RegOp in [Push2Instruction, Pop2Instruction]:\n+            if full_set:\n+                for i in range(len(test_regs)):\n+                    test_reg1 = test_regs[i]\n+                    test_reg2 = test_regs[(i + 1) % len(test_regs)]\n+                    lp64_flag = handle_lp64_flag(lp64_flag, print_lp64_flag, test_reg1, test_reg2)\n+                    if test_reg1 == 'rsp' or test_reg2 == 'rsp':\n+                        continue\n+                    instr = RegOp(*op, reg1=test_reg1, reg2=test_reg2)\n+                    print_instruction(instr, lp64_flag, print_lp64_flag)\n+            else:\n+                filtered_regs = [reg for reg in test_regs if reg != 'rsp']\n+                test_reg1, test_reg2 = random.sample(filtered_regs, 2)\n+                lp64_flag = handle_lp64_flag(lp64_flag, print_lp64_flag, test_reg1, test_reg2)\n+                instr = RegOp(*op, reg1=test_reg1, reg2=test_reg2)\n+                print_instruction(instr, lp64_flag, print_lp64_flag)\n+\n+        else:\n+            raise ValueError(f\"Unsupported instruction type: {RegOp}\")\n+\n+def print_with_ifdef(ifdef_flags, items, item_formatter, width):\n+    under_defined = False\n+    iid = 0\n+    for idx, item in enumerate(items):\n+        if ifdef_flags[idx]:\n+            if not under_defined:\n+                print(\"#ifdef _LP64\")\n+                under_defined = True\n+        else:\n+            if under_defined:\n+                print(\"#endif \/\/ _LP64\")\n+                under_defined = False\n+        print(\"    %-*s \/\/ IID%s\" % (width, item_formatter(item) + \",\", iid))\n+        iid += 1\n+    if under_defined:\n+        print(\"#endif \/\/ _LP64\")\n+\n+instruction_set = {\n+    TwoRegInstruction: [\n+        ('shldl', 'shld', 32),\n+        ('shrdl', 'shrd', 32),\n+        ('adcl', 'adc', 32),\n+        ('cmpl', 'cmp', 32),\n+        ('imull', 'imul', 32),\n+        ('popcntl', 'popcnt', 32),\n+        ('sbbl', 'sbb', 32),\n+        ('subl', 'sub', 32),\n+        ('tzcntl', 'tzcnt', 32),\n+        ('lzcntl', 'lzcnt', 32),\n+        ('addl', 'add', 32),\n+        ('andl', 'and', 32),\n+        ('orl', 'or', 32),\n+        ('xorl', 'xor', 32),\n+        ('movl', 'mov', 32),\n+        ('bsfl', 'bsf', 32),\n+        ('bsrl', 'bsr', 32),\n+        ('xchgl', 'xchg', 32),\n+        ('testl', 'test', 32),\n+    ],\n+    MemRegInstruction: [\n+        ('addb', 'add', 8),\n+        ('addw', 'add', 16),\n+        ('addl', 'add', 32),\n+        ('adcl', 'adc', 32),\n+        ('andb', 'and', 8),\n+        ('andl', 'and', 32),\n+        ('cmpb', 'cmp', 8),\n+        ('cmpw', 'cmp', 16),\n+        ('cmpl', 'cmp', 32),\n+        ('orb', 'or', 8),\n+        ('orl', 'or', 32),\n+        ('xorb', 'xor', 8),\n+        ('xorl', 'xor', 32),\n+        ('subl', 'sub', 32),\n+        ('movb', 'mov', 8),\n+        ('movl', 'mov', 32),\n+        ('xaddb', 'xadd', 8),\n+        ('xaddw', 'xadd', 16),\n+        ('xaddl', 'xadd', 32),\n+    ],\n+    MemImmInstruction: [\n+        ('adcl', 'adc', 32),\n+        ('andl', 'and', 32),\n+        ('addb', 'add', 8),\n+        ('addw', 'add', 16),\n+        ('addl', 'add', 32),\n+        ('cmpb', 'cmp', 8),\n+        ('cmpw', 'cmp', 16),\n+        ('cmpl', 'cmp', 32),\n+        ('sarl', 'sar', 32),\n+        ('sall', 'sal', 32),\n+        ('sbbl', 'sbb', 32),\n+        ('shrl', 'shr', 32),\n+        ('subl', 'sub', 32),\n+        ('xorl', 'xor', 32),\n+        ('orb', 'or', 8),\n+        ('orl', 'or', 32),\n+        ('movb', 'mov', 8),\n+        ('movl', 'mov', 32),\n+        ('testb', 'test', 8),\n+        ('testl', 'test', 32),\n+        ('cmpl_imm32', 'cmp', 32),\n+    ],\n+    RegMemInstruction: [\n+        ('addl', 'add', 32),\n+        ('andl', 'and', 32),\n+        ('cmpb', 'cmp', 8),\n+        ('cmpl', 'cmp', 32),\n+        ('lzcntl', 'lzcnt', 32),\n+        ('orl', 'or', 32),\n+        ('adcl', 'adc', 32),\n+        ('imull', 'imul', 32),\n+        ('popcntl', 'popcnt', 32),\n+        ('sbbl', 'sbb', 32),\n+        ('subl', 'sub', 32),\n+        ('tzcntl', 'tzcnt', 32),\n+        ('xorb', 'xor', 8),\n+        ('xorw', 'xor', 16),\n+        ('xorl', 'xor', 32),\n+        ('movb', 'mov', 8),\n+        ('movl', 'mov', 32),\n+        ('leal', 'lea', 32),\n+        ('xchgb', 'xchg', 8),\n+        ('xchgw', 'xchg', 16),\n+        ('xchgl', 'xchg', 32),\n+        ('testl', 'test', 32),\n+    ],\n+    RegImmInstruction: [\n+        ('addb', 'add', 8),\n+        ('addl', 'add', 32),\n+        ('andl', 'and', 32),\n+        ('adcl', 'adc', 32),\n+        ('cmpb', 'cmp', 8),\n+        ('cmpl', 'cmp', 32),\n+        ('rcll', 'rcl', 32),\n+        ('roll', 'rol', 32),\n+        ('rorl', 'ror', 32),\n+        ('sarl', 'sar', 32),\n+        ('sall', 'sal', 32),\n+        ('sbbl', 'sbb', 32),\n+        ('shll', 'shl', 32),\n+        ('shrl', 'shr', 32),\n+        ('subl', 'sub', 32),\n+        ('xorl', 'xor', 32),\n+        ('movl', 'mov', 32),\n+        ('testb', 'test', 8),\n+        ('testl', 'test', 32),\n+        ('subl_imm32', 'sub', 32),\n+    ],\n+    CondRegMemInstruction: [\n+        ('cmovl', 'cmov', 32, key) for key in cond_to_suffix.keys()\n+    ],\n+    CondRegInstruction: [\n+        ('set', 'set', 8, key) for key in cond_to_suffix.keys()\n+    ],\n+    RegInstruction: [\n+        ('divl', 'div', 32),\n+        ('idivl', 'idiv', 32),\n+        ('imull', 'imul', 32),\n+        ('mull', 'mul', 32),\n+        ('negl', 'neg', 32),\n+        ('notl', 'not', 32),\n+        ('roll', 'rol', 32),\n+        ('rorl', 'ror', 32),\n+        ('sarl', 'sar', 32),\n+        ('sall', 'sal', 32),\n+        ('shll', 'shl', 32),\n+        ('shrl', 'shr', 32),\n+        ('incrementl', 'inc', 32),\n+        ('decrementl', 'dec', 32),\n+    ],\n+    MemInstruction: [\n+        ('mull', 'mul', 32),\n+        ('negl', 'neg', 32),\n+        ('sarl', 'sar', 32),\n+        ('sall', 'sal', 32),\n+        ('shrl', 'shr', 32),\n+        ('incrementl', 'inc', 32),\n+        ('decrementl', 'dec', 32),\n+    ],\n+    RegMemImmInstruction: [\n+        ('imull', 'imul', 32),\n+    ],\n+    RegRegImmInstruction: [\n+        ('imull', 'imul', 32),\n+        ('shldl', 'shld', 32),\n+        ('shrdl', 'shrd', 32),\n+    ],\n+    MoveRegMemInstruction: [\n+        ('movzbl', 'movzx', 32, 8),\n+        ('movzwl', 'movzx', 32, 16),\n+        ('movsbl', 'movsx', 32, 8),\n+        ('movswl', 'movsx', 32, 16),\n+    ],\n+    MoveRegRegInstruction: [\n+        ('movzbl', 'movzx', 32, 8),\n+        ('movzwl', 'movzx', 32, 16),\n+        ('movsbl', 'movsx', 32, 8),\n+        ('movswl', 'movsx', 32, 16),\n+    ],\n+    CmpxchgInstruction: [\n+        ('cmpxchgb', 'cmpxchg', 8),\n+        ('cmpxchgw', 'cmpxchg', 16),\n+        ('cmpxchgl', 'cmpxchg', 32),\n+    ],\n+}\n+\n+instruction_set64 = {\n+    TwoRegInstruction: [\n+        ('adcq', 'adc', 64),\n+        ('cmpq', 'cmp', 64),\n+        ('imulq', 'imul', 64),\n+        ('popcntq', 'popcnt', 64),\n+        ('sbbq', 'sbb', 64),\n+        ('subq', 'sub', 64),\n+        ('tzcntq', 'tzcnt', 64),\n+        ('lzcntq', 'lzcnt', 64),\n+        ('addq', 'add', 64),\n+        ('andq', 'and', 64),\n+        ('orq', 'or', 64),\n+        ('xorq', 'xor', 64),\n+        ('movq', 'mov', 64),\n+        ('bsfq', 'bsf', 64),\n+        ('bsrq', 'bsr', 64),\n+        ('btq', 'bt', 64),\n+        ('xchgq', 'xchg', 64),\n+        ('testq', 'test', 64),\n+    ],\n+    MemRegInstruction: [\n+        ('addq', 'add', 64),\n+        ('andq', 'and', 64),\n+        ('cmpq', 'cmp', 64),\n+        ('orq', 'or', 64),\n+        ('xorq', 'xor', 64),\n+        ('subq', 'sub', 64),\n+        ('movq', 'mov', 64),\n+        ('xaddq', 'xadd', 64),\n+    ],\n+    MemImmInstruction: [\n+        ('andq', 'and', 64),\n+        ('addq', 'add', 64),\n+        ('cmpq', 'cmp', 64),\n+        ('sarq', 'sar', 64),\n+        ('salq', 'sal', 64),\n+        ('sbbq', 'sbb', 64),\n+        ('shrq', 'shr', 64),\n+        ('subq', 'sub', 64),\n+        ('xorq', 'xor', 64),\n+        ('orq', 'or', 64),\n+        ('movq', 'mov', 64),\n+        ('testq', 'test', 64),\n+    ],\n+    RegMemInstruction: [\n+        ('addq', 'add', 64),\n+        ('andq', 'and', 64),\n+        ('cmpq', 'cmp', 64),\n+        ('lzcntq', 'lzcnt', 64),\n+        ('orq', 'or', 64),\n+        ('adcq', 'adc', 64),\n+        ('imulq', 'imul', 64),\n+        ('popcntq', 'popcnt', 64),\n+        ('sbbq', 'sbb', 64),\n+        ('subq', 'sub', 64),\n+        ('tzcntq', 'tzcnt', 64),\n+        ('xorq', 'xor', 64),\n+        ('movq', 'mov', 64),\n+        ('leaq', 'lea', 64),\n+        ('cvttsd2siq', 'cvttsd2si', 64),\n+        ('xchgq', 'xchg', 64),\n+        ('testq', 'test', 64),\n+    ],\n+    RegImmInstruction: [\n+        ('addq', 'add', 64),\n+        ('andq', 'and', 64),\n+        ('adcq', 'adc', 64),\n+        ('cmpq', 'cmp', 64),\n+        ('rclq', 'rcl', 64),\n+        ('rcrq', 'rcr', 64),\n+        ('rolq', 'rol', 64),\n+        ('rorq', 'ror', 64),\n+        ('sarq', 'sar', 64),\n+        ('salq', 'sal', 64),\n+        ('sbbq', 'sbb', 64),\n+        ('shlq', 'shl', 64),\n+        ('shrq', 'shr', 64),\n+        ('subq', 'sub', 64),\n+        ('xorq', 'xor', 64),\n+        ('movq', 'mov', 64),\n+        ('mov64', 'mov', 64),\n+        ('btq', 'bt', 64),\n+        ('testq', 'test', 64),\n+        ('orq_imm32', 'or', 64),\n+        ('subq_imm32', 'sub', 64)\n+    ],\n+    CondRegMemInstruction: [\n+        ('cmovq', 'cmov', 64, key) for key in cond_to_suffix.keys()\n+    ],\n+    RegInstruction: [\n+        ('call', 'call', 64),\n+        ('divq', 'div', 64),\n+        ('idivq', 'idiv', 64),\n+        ('imulq', 'imul', 64),\n+        ('mulq', 'mul', 64),\n+        ('negq', 'neg', 64),\n+        ('notq', 'not', 64),\n+        ('rolq', 'rol', 64),\n+        ('rorq', 'ror', 64),\n+        ('sarq', 'sar', 64),\n+        ('salq', 'sal', 64),\n+        ('shlq', 'shl', 64),\n+        ('shrq', 'shr', 64),\n+        ('incrementq', 'inc', 64),\n+        ('decrementq', 'dec', 64),\n+        ('pushp', 'pushp', 64),\n+        ('popp', 'popp', 64)\n+    ],\n+    MemInstruction: [\n+        ('call', 'call', 64),\n+        ('mulq', 'mul', 64),\n+        ('negq', 'neg', 64),\n+        ('sarq', 'sar', 64),\n+        ('salq', 'sal', 64),\n+        ('shrq', 'shr', 64),\n+        ('incrementq', 'inc', 64),\n+        ('decrementq', 'dec', 64)\n+    ],\n+    RegMemImmInstruction: [\n+        ('imulq', 'imul', 64)\n+    ],\n+    RegRegImmInstruction: [\n+        ('imulq', 'imul', 64),\n+        ('shldq', 'shld', 64),\n+        ('shrdq', 'shrd', 64)\n+    ],\n+    Pop2Instruction: [\n+        ('pop2', 'pop2', 64),\n+        ('pop2p', 'pop2p', 64)\n+    ],\n+    Push2Instruction: [\n+        ('push2', 'push2', 64),\n+        ('push2p', 'push2p', 64)\n+    ],\n+    MoveRegMemInstruction: [\n+        ('movzbq', 'movzx', 64, 8),\n+        ('movzwq', 'movzx', 64, 16),\n+        ('movsbq', 'movsx', 64, 8),\n+        ('movswq', 'movsx', 64, 16),\n+    ],\n+    MoveRegRegInstruction: [\n+        ('movzbq', 'movzx', 64, 8),\n+        ('movzwq', 'movzx', 64, 16),\n+        ('movsbq', 'movsx', 64, 8),\n+        ('movswq', 'movsx', 64, 16),\n+    ],\n+    CmpxchgInstruction: [\n+        ('cmpxchgq', 'cmpxchg', 64),\n+    ],\n+}\n+\n+if __name__ == \"__main__\":\n+    if platform.system() != \"Linux\":\n+        print(\"This script only works on Linux\")\n+        exit(1)\n+\n+    full_set = '--full' in sys.argv\n+\n+    ifdef_flags = []\n+    insns_strs = []\n+\n+    print(\"\/\/ BEGIN  Generated code -- do not edit\")\n+    print(\"\/\/ Generated by x86-asmtest.py\")\n+\n+    outfile = open(\"x86ops.s\", \"w\")\n+    outfile.write(\".intel_syntax noprefix\\n\")\n+\n+    for RegOp, ops in instruction_set.items():\n+        generate(RegOp, ops, True, full_set)\n+        \n+    if lp64_flag:\n+        lp64_flag = False\n+        print(\"#endif \/\/ _LP64\")\n+\n+    print(\"#ifdef _LP64\")\n+    for RegOp, ops in instruction_set64.items():\n+        generate(RegOp, ops, False, full_set)\n+    print(\"#endif \/\/ _LP64\")\n+\n+    outfile.close()\n+\n+    subprocess.check_call([X86_AS, \"x86ops.s\", \"-o\", \"x86ops.o\",])\n+    subprocess.check_call([X86_OBJCOPY, \"-O\", \"binary\", \"-j\", \".text\", \"x86ops.o\", \"x86ops.bin\"])\n+\n+    infile = open(\"x86ops.bin\", \"rb\")\n+    bytes = bytearray(infile.read())\n+    infile.close()\n+\n+    disassembly_text = subprocess.check_output([OBJDUMP, \"-M\", \"intel\", \"-d\", \"x86ops.o\", \"--insn-width=16\"], text=True)\n+    lines = disassembly_text.split(\"\\n\")\n+    instruction_regex = re.compile(r'^\\s*([0-9a-f]+):\\s*([0-9a-f\\s]+?)(?:\\s{2,})')\n+    instructions = []\n+\n+    for i, line in enumerate(lines):\n+        match = instruction_regex.match(line)\n+        if match:\n+            offset = int(match.group(1), 16)\n+            insns = match.group(2).split()\n+            binary_code = \", \".join([f\"0x{insn}\" for insn in insns])\n+            length = len(insns)\n+            instructions.append((length, binary_code))\n+\n+    print()\n+    print(\"  static const uint8_t insns[] =\")\n+    print(\"  {\")\n+    print_with_ifdef(ifdef_flags, instructions, lambda x: f\"{x[1]}\", 80)\n+    print(\"  };\")\n+    print()\n+    print(\"  static const unsigned int insns_lens[] =\")\n+    print(\"  {\")\n+    print_with_ifdef(ifdef_flags, instructions, lambda x: f\"{x[0]}\", 5)\n+    print(\"  };\")\n+    print()\n+    print(\"  static const char* insns_strs[] =\")\n+    print(\"  {\")\n+    print_with_ifdef(ifdef_flags, insns_strs, lambda x: f\"\\\"{x}\\\"\", 85)\n+    print(\"  };\")\n+\n+    print(\"\/\/ END  Generated code -- do not edit\")\n+\n+    for f in [\"x86ops.s\", \"x86ops.o\", \"x86ops.bin\"]:\n+        os.remove(f)\n\\ No newline at end of file\n","filename":"test\/hotspot\/gtest\/x86\/x86-asmtest.py","additions":934,"deletions":0,"binary":false,"changes":934,"status":"added"},{"patch":"@@ -58,2 +58,0 @@\n-\n-runtime\/condy\/escapeAnalysis\/TestEscapeCondy.java 8339694 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test that OSR correctly handles method with large number of locals\n+ * @bug 8335662\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   compiler.c1.TestOSRLotsOfLocals\n+ *\/\n+package compiler.c1;\n+\n+import java.lang.reflect.Method;\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+import static compiler.whitebox.CompilerWhiteBoxTest.COMP_LEVEL_SIMPLE;\n+\n+public class TestOSRLotsOfLocals {\n+\n+    private static WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+    public static void main(String... args) throws Exception {\n+        Method method = TestOSRLotsOfLocals.class.getDeclaredMethod(\"lotsOfLocals\");\n+\n+        wb.enqueueMethodForCompilation(method, COMP_LEVEL_SIMPLE, 0);\n+        while (wb.isMethodQueuedForCompilation(method)) {\n+            Thread.onSpinWait();\n+        }\n+    }\n+\n+    private static synchronized void lotsOfLocals() {\n+        boolean b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49, b50, b51, b52, b53, b54, b55, b56, b57, b58, b59, b60, b61, b62, b63, b64, b65, b66, b67, b68, b69, b70, b71, b72, b73, b74, b75, b76, b77, b78, b79, b80, b81, b82, b83, b84, b85, b86, b87, b88, b89, b90, b91, b92, b93, b94, b95, b96, b97, b98, b99,\n+                b100, b101, b102, b103, b104, b105, b106, b107, b108, b109, b110, b111, b112, b113, b114, b115, b116, b117, b118, b119, b120, b121, b122, b123, b124, b125, b126, b127, b128, b129, b130, b131, b132, b133, b134, b135, b136, b137, b138, b139, b140, b141, b142, b143, b144, b145, b146, b147, b148, b149, b150, b151, b152, b153, b154, b155, b156, b157, b158, b159, b160, b161, b162, b163, b164, b165, b166, b167, b168, b169, b170, b171, b172, b173, b174, b175, b176, b177, b178, b179, b180, b181, b182, b183, b184, b185, b186, b187, b188, b189, b190, b191, b192, b193, b194, b195, b196, b197, b198, b199,\n+                b200, b201, b202, b203, b204, b205, b206, b207, b208, b209, b210, b211, b212, b213, b214, b215, b216, b217, b218, b219, b220, b221, b222, b223, b224, b225, b226, b227, b228, b229, b230, b231, b232, b233, b234, b235, b236, b237, b238, b239, b240, b241, b242, b243, b244, b245, b246, b247, b248, b249, b250, b251, b252, b253, b254, b255, b256, b257, b258, b259, b260, b261, b262, b263, b264, b265, b266, b267, b268, b269, b270, b271, b272, b273, b274, b275, b276, b277, b278, b279, b280, b281, b282, b283, b284, b285, b286, b287, b288, b289, b290, b291, b292, b293, b294, b295, b296, b297, b298, b299,\n+                b300, b301, b302, b303, b304, b305, b306, b307, b308, b309, b310, b311, b312, b313, b314, b315, b316, b317, b318, b319, b320, b321, b322, b323, b324, b325, b326, b327, b328, b329, b330, b331, b332, b333, b334, b335, b336, b337, b338, b339, b340, b341, b342, b343, b344, b345, b346, b347, b348, b349, b350, b351, b352, b353, b354, b355, b356, b357, b358, b359, b360, b361, b362, b363, b364, b365, b366, b367, b368, b369, b370, b371, b372, b373, b374, b375, b376, b377, b378, b379, b380, b381, b382, b383, b384, b385, b386, b387, b388, b389, b390, b391, b392, b393, b394, b395, b396, b397, b398, b399,\n+                b400, b401, b402, b403, b404, b405, b406, b407, b408, b409, b410, b411, b412, b413, b414, b415, b416, b417, b418, b419, b420, b421, b422, b423, b424, b425, b426, b427, b428, b429, b430, b431, b432, b433, b434, b435, b436, b437, b438, b439, b440, b441, b442, b443, b444, b445, b446, b447, b448, b449, b450, b451, b452, b453, b454, b455, b456, b457, b458, b459, b460, b461, b462, b463, b464, b465, b466, b467, b468, b469, b470, b471, b472, b473, b474, b475, b476, b477, b478, b479, b480, b481, b482, b483, b484, b485, b486, b487, b488, b489, b490, b491, b492, b493, b494, b495, b496, b497, b498, b499,\n+                b500, b501, b502, b503, b504, b505, b506, b507, b508, b509, b510, b511, b512, b513, b514, b515, b516, b517, b518, b519, b520, b521, b522, b523, b524, b525, b526, b527, b528, b529, b530, b531, b532, b533, b534, b535, b536, b537, b538, b539, b540, b541, b542, b543, b544, b545, b546, b547, b548, b549, b550, b551, b552, b553, b554, b555, b556, b557, b558, b559, b560, b561, b562, b563, b564, b565, b566, b567, b568, b569, b570, b571, b572, b573, b574, b575, b576, b577, b578, b579, b580, b581, b582, b583, b584, b585, b586, b587, b588, b589, b590, b591, b592, b593, b594, b595, b596, b597, b598, b599,\n+                b600, b601, b602, b603, b604, b605, b606, b607, b608, b609, b610, b611, b612, b613, b614, b615, b616, b617, b618, b619, b620, b621, b622, b623, b624, b625, b626, b627, b628, b629, b630, b631, b632, b633, b634, b635, b636, b637, b638, b639, b640, b641, b642, b643, b644, b645, b646, b647, b648, b649, b650, b651, b652, b653, b654, b655, b656, b657, b658, b659, b660, b661, b662, b663, b664, b665, b666, b667, b668, b669, b670, b671, b672, b673, b674, b675, b676, b677, b678, b679, b680, b681, b682, b683, b684, b685, b686, b687, b688, b689, b690, b691, b692, b693, b694, b695, b696, b697, b698, b699,\n+                b700, b701, b702, b703, b704, b705, b706, b707, b708, b709, b710, b711, b712, b713, b714, b715, b716, b717, b718, b719, b720, b721, b722, b723, b724, b725, b726, b727, b728, b729, b730, b731, b732, b733, b734, b735, b736, b737, b738, b739, b740, b741, b742, b743, b744, b745, b746, b747, b748, b749, b750, b751, b752, b753, b754, b755, b756, b757, b758, b759, b760, b761, b762, b763, b764, b765, b766, b767, b768, b769, b770, b771, b772, b773, b774, b775, b776, b777, b778, b779, b780, b781, b782, b783, b784, b785, b786, b787, b788, b789, b790, b791, b792, b793, b794, b795, b796, b797, b798, b799,\n+                b800, b801, b802, b803, b804, b805, b806, b807, b808, b809, b810, b811, b812, b813, b814, b815, b816, b817, b818, b819, b820, b821, b822, b823, b824, b825, b826, b827, b828, b829, b830, b831, b832, b833, b834, b835, b836, b837, b838, b839, b840, b841, b842, b843, b844, b845, b846, b847, b848, b849, b850, b851, b852, b853, b854, b855, b856, b857, b858, b859, b860, b861, b862, b863, b864, b865, b866, b867, b868, b869, b870, b871, b872, b873, b874, b875, b876, b877, b878, b879, b880, b881, b882, b883, b884, b885, b886, b887, b888, b889, b890, b891, b892, b893, b894, b895, b896, b897, b898, b899,\n+                b900, b901, b902, b903, b904, b905, b906, b907, b908, b909, b910, b911, b912, b913, b914, b915, b916, b917, b918, b919, b920, b921, b922, b923, b924, b925, b926, b927, b928, b929, b930, b931, b932, b933, b934, b935, b936, b937, b938, b939, b940, b941, b942, b943, b944, b945, b946, b947, b948, b949, b950, b951, b952, b953, b954, b955, b956, b957, b958, b959, b960, b961, b962, b963, b964, b965, b966, b967, b968, b969, b970, b971, b972, b973, b974, b975, b976, b977, b978, b979, b980, b981, b982, b983, b984, b985, b986, b987, b988, b989, b990, b991, b992, b993, b994, b995, b996, b997, b998, b999,\n+                b1000, b1001, b1002, b1003, b1004, b1005, b1006, b1007, b1008, b1009, b1010, b1011, b1012, b1013, b1014, b1015, b1016, b1017, b1018, b1019, b1020, b1021, b1022, b1023, b1024, b1025, b1026, b1027, b1028, b1029, b1030, b1031, b1032, b1033, b1034, b1035, b1036, b1037, b1038, b1039, b1040, b1041, b1042, b1043, b1044, b1045, b1046, b1047, b1048, b1049, b1050, b1051, b1052, b1053, b1054, b1055, b1056, b1057, b1058, b1059, b1060, b1061, b1062, b1063, b1064, b1065, b1066, b1067, b1068, b1069, b1070, b1071, b1072, b1073, b1074, b1075, b1076, b1077, b1078, b1079, b1080, b1081, b1082, b1083, b1084, b1085, b1086, b1087, b1088, b1089, b1090, b1091, b1092, b1093, b1094, b1095, b1096, b1097, b1098, b1099,\n+                b1100, b1101, b1102, b1103, b1104, b1105, b1106, b1107, b1108, b1109, b1110, b1111, b1112, b1113, b1114, b1115, b1116, b1117, b1118, b1119, b1120, b1121, b1122, b1123, b1124, b1125, b1126, b1127, b1128, b1129, b1130, b1131, b1132, b1133, b1134, b1135, b1136, b1137, b1138, b1139, b1140, b1141, b1142, b1143, b1144, b1145, b1146, b1147, b1148, b1149, b1150, b1151, b1152, b1153, b1154, b1155, b1156, b1157, b1158, b1159, b1160, b1161, b1162, b1163, b1164, b1165, b1166, b1167, b1168, b1169, b1170, b1171, b1172, b1173, b1174, b1175, b1176, b1177, b1178, b1179, b1180, b1181, b1182, b1183, b1184, b1185, b1186, b1187, b1188, b1189, b1190, b1191, b1192, b1193, b1194, b1195, b1196, b1197, b1198, b1199,\n+                b1200, b1201, b1202, b1203, b1204, b1205, b1206, b1207, b1208, b1209, b1210, b1211, b1212, b1213, b1214, b1215, b1216, b1217, b1218, b1219, b1220, b1221, b1222, b1223, b1224, b1225, b1226, b1227, b1228, b1229, b1230, b1231, b1232, b1233, b1234, b1235, b1236, b1237, b1238, b1239, b1240, b1241, b1242, b1243, b1244, b1245, b1246, b1247, b1248, b1249, b1250, b1251, b1252, b1253, b1254, b1255, b1256, b1257, b1258, b1259, b1260, b1261, b1262, b1263, b1264, b1265, b1266, b1267, b1268, b1269, b1270, b1271, b1272, b1273, b1274, b1275, b1276, b1277, b1278, b1279, b1280, b1281, b1282, b1283, b1284, b1285, b1286, b1287, b1288, b1289, b1290, b1291, b1292, b1293, b1294, b1295, b1296, b1297, b1298, b1299,\n+                b1300, b1301, b1302, b1303, b1304, b1305, b1306, b1307, b1308, b1309, b1310, b1311, b1312, b1313, b1314, b1315, b1316, b1317, b1318, b1319, b1320, b1321, b1322, b1323, b1324, b1325, b1326, b1327, b1328, b1329, b1330, b1331, b1332, b1333, b1334, b1335, b1336, b1337, b1338, b1339, b1340, b1341, b1342, b1343, b1344, b1345, b1346, b1347, b1348, b1349, b1350, b1351, b1352, b1353, b1354, b1355, b1356, b1357, b1358, b1359, b1360, b1361, b1362, b1363, b1364, b1365, b1366, b1367, b1368, b1369, b1370, b1371, b1372, b1373, b1374, b1375, b1376, b1377, b1378, b1379, b1380, b1381, b1382, b1383, b1384, b1385, b1386, b1387, b1388, b1389, b1390, b1391, b1392, b1393, b1394, b1395, b1396, b1397, b1398, b1399,\n+                b1400, b1401, b1402, b1403, b1404, b1405, b1406, b1407, b1408, b1409, b1410, b1411, b1412, b1413, b1414, b1415, b1416, b1417, b1418, b1419, b1420, b1421, b1422, b1423, b1424, b1425, b1426, b1427, b1428, b1429, b1430, b1431, b1432, b1433, b1434, b1435, b1436, b1437, b1438, b1439, b1440, b1441, b1442, b1443, b1444, b1445, b1446, b1447, b1448, b1449, b1450, b1451, b1452, b1453, b1454, b1455, b1456, b1457, b1458, b1459, b1460, b1461, b1462, b1463, b1464, b1465, b1466, b1467, b1468, b1469, b1470, b1471, b1472, b1473, b1474, b1475, b1476, b1477, b1478, b1479, b1480, b1481, b1482, b1483, b1484, b1485, b1486, b1487, b1488, b1489, b1490, b1491, b1492, b1493, b1494, b1495, b1496, b1497, b1498, b1499,\n+                b1500, b1501, b1502, b1503, b1504, b1505, b1506, b1507, b1508, b1509, b1510, b1511, b1512, b1513, b1514, b1515, b1516, b1517, b1518, b1519, b1520, b1521, b1522, b1523, b1524, b1525, b1526, b1527, b1528, b1529, b1530, b1531, b1532, b1533, b1534, b1535, b1536, b1537, b1538, b1539, b1540, b1541, b1542, b1543, b1544, b1545, b1546, b1547, b1548, b1549, b1550, b1551, b1552, b1553, b1554, b1555, b1556, b1557, b1558, b1559, b1560, b1561, b1562, b1563, b1564, b1565, b1566, b1567, b1568, b1569, b1570, b1571, b1572, b1573, b1574, b1575, b1576, b1577, b1578, b1579, b1580, b1581, b1582, b1583, b1584, b1585, b1586, b1587, b1588, b1589, b1590, b1591, b1592, b1593, b1594, b1595, b1596, b1597, b1598, b1599,\n+                b1600, b1601, b1602, b1603, b1604, b1605, b1606, b1607, b1608, b1609, b1610, b1611, b1612, b1613, b1614, b1615, b1616, b1617, b1618, b1619, b1620, b1621, b1622, b1623, b1624, b1625, b1626, b1627, b1628, b1629, b1630, b1631, b1632, b1633, b1634, b1635, b1636, b1637, b1638, b1639, b1640, b1641, b1642, b1643, b1644, b1645, b1646, b1647, b1648, b1649, b1650, b1651, b1652, b1653, b1654, b1655, b1656, b1657, b1658, b1659, b1660, b1661, b1662, b1663, b1664, b1665, b1666, b1667, b1668, b1669, b1670, b1671, b1672, b1673, b1674, b1675, b1676, b1677, b1678, b1679, b1680, b1681, b1682, b1683, b1684, b1685, b1686, b1687, b1688, b1689, b1690, b1691, b1692, b1693, b1694, b1695, b1696, b1697, b1698, b1699,\n+                b1700, b1701, b1702, b1703, b1704, b1705, b1706, b1707, b1708, b1709, b1710, b1711, b1712, b1713, b1714, b1715, b1716, b1717, b1718, b1719, b1720, b1721, b1722, b1723, b1724, b1725, b1726, b1727, b1728, b1729, b1730, b1731, b1732, b1733, b1734, b1735, b1736, b1737, b1738, b1739, b1740, b1741, b1742, b1743, b1744, b1745, b1746, b1747, b1748, b1749, b1750, b1751, b1752, b1753, b1754, b1755, b1756, b1757, b1758, b1759, b1760, b1761, b1762, b1763, b1764, b1765, b1766, b1767, b1768, b1769, b1770, b1771, b1772, b1773, b1774, b1775, b1776, b1777, b1778, b1779, b1780, b1781, b1782, b1783, b1784, b1785, b1786, b1787, b1788, b1789, b1790, b1791, b1792, b1793, b1794, b1795, b1796, b1797, b1798, b1799,\n+                b1800, b1801, b1802, b1803, b1804, b1805, b1806, b1807, b1808, b1809, b1810, b1811, b1812, b1813, b1814, b1815, b1816, b1817, b1818, b1819, b1820, b1821, b1822, b1823, b1824, b1825, b1826, b1827, b1828, b1829, b1830, b1831, b1832, b1833, b1834, b1835, b1836, b1837, b1838, b1839, b1840, b1841, b1842, b1843, b1844, b1845, b1846, b1847, b1848, b1849, b1850, b1851, b1852, b1853, b1854, b1855, b1856, b1857, b1858, b1859, b1860, b1861, b1862, b1863, b1864, b1865, b1866, b1867, b1868, b1869, b1870, b1871, b1872, b1873, b1874, b1875, b1876, b1877, b1878, b1879, b1880, b1881, b1882, b1883, b1884, b1885, b1886, b1887, b1888, b1889, b1890, b1891, b1892, b1893, b1894, b1895, b1896, b1897, b1898, b1899,\n+                b1900, b1901, b1902, b1903, b1904, b1905, b1906, b1907, b1908, b1909, b1910, b1911, b1912, b1913, b1914, b1915, b1916, b1917, b1918, b1919, b1920, b1921, b1922, b1923, b1924, b1925, b1926, b1927, b1928, b1929, b1930, b1931, b1932, b1933, b1934, b1935, b1936, b1937, b1938, b1939, b1940, b1941, b1942, b1943, b1944, b1945, b1946, b1947, b1948, b1949, b1950, b1951, b1952, b1953, b1954, b1955, b1956, b1957, b1958, b1959, b1960, b1961, b1962, b1963, b1964, b1965, b1966, b1967, b1968, b1969, b1970, b1971, b1972, b1973, b1974, b1975, b1976, b1977, b1978, b1979, b1980, b1981, b1982, b1983, b1984, b1985, b1986, b1987, b1988, b1989, b1990, b1991, b1992, b1993, b1994, b1995, b1996, b1997, b1998, b1999,\n+                b2000, b2001, b2002, b2003, b2004, b2005, b2006, b2007, b2008, b2009, b2010, b2011, b2012, b2013, b2014, b2015, b2016, b2017, b2018, b2019, b2020, b2021, b2022, b2023, b2024, b2025, b2026, b2027, b2028, b2029, b2030, b2031, b2032, b2033, b2034, b2035, b2036, b2037, b2038, b2039, b2040, b2041, b2042, b2043, b2044, b2045, b2046, b2047, b2048, b2049, b2050, b2051, b2052, b2053, b2054, b2055, b2056, b2057, b2058, b2059, b2060, b2061, b2062, b2063, b2064, b2065, b2066, b2067, b2068, b2069, b2070, b2071, b2072, b2073, b2074, b2075, b2076, b2077, b2078, b2079, b2080, b2081, b2082, b2083, b2084, b2085, b2086, b2087, b2088, b2089, b2090, b2091, b2092, b2093, b2094, b2095, b2096, b2097, b2098, b2099,\n+                b2100, b2101, b2102, b2103, b2104, b2105, b2106, b2107, b2108, b2109, b2110, b2111, b2112, b2113, b2114, b2115, b2116, b2117, b2118, b2119, b2120, b2121, b2122, b2123, b2124, b2125, b2126, b2127, b2128, b2129, b2130, b2131, b2132, b2133, b2134, b2135, b2136, b2137, b2138, b2139, b2140, b2141, b2142, b2143, b2144, b2145, b2146, b2147, b2148, b2149, b2150, b2151, b2152, b2153, b2154, b2155, b2156, b2157, b2158, b2159, b2160, b2161, b2162, b2163, b2164, b2165, b2166, b2167, b2168, b2169, b2170, b2171, b2172, b2173, b2174, b2175, b2176, b2177, b2178, b2179, b2180, b2181, b2182, b2183, b2184, b2185, b2186, b2187, b2188, b2189, b2190, b2191, b2192, b2193, b2194, b2195, b2196, b2197, b2198, b2199,\n+                b2200, b2201, b2202, b2203, b2204, b2205, b2206, b2207, b2208, b2209, b2210, b2211, b2212, b2213, b2214, b2215, b2216, b2217, b2218, b2219, b2220, b2221, b2222, b2223, b2224, b2225, b2226, b2227, b2228, b2229, b2230, b2231, b2232, b2233, b2234, b2235, b2236, b2237, b2238, b2239, b2240, b2241, b2242, b2243, b2244, b2245, b2246, b2247, b2248, b2249, b2250, b2251, b2252, b2253, b2254, b2255, b2256, b2257, b2258, b2259, b2260, b2261, b2262, b2263, b2264, b2265, b2266, b2267, b2268, b2269, b2270, b2271, b2272, b2273, b2274, b2275, b2276, b2277, b2278, b2279, b2280, b2281, b2282, b2283, b2284, b2285, b2286, b2287, b2288, b2289, b2290, b2291, b2292, b2293, b2294, b2295, b2296, b2297, b2298, b2299,\n+                b2300, b2301, b2302, b2303, b2304, b2305, b2306, b2307, b2308, b2309, b2310, b2311, b2312, b2313, b2314, b2315, b2316, b2317, b2318, b2319, b2320, b2321, b2322, b2323, b2324, b2325, b2326, b2327, b2328, b2329, b2330, b2331, b2332, b2333, b2334, b2335, b2336, b2337, b2338, b2339, b2340, b2341, b2342, b2343, b2344, b2345, b2346, b2347, b2348, b2349, b2350, b2351, b2352, b2353, b2354, b2355, b2356, b2357, b2358, b2359, b2360, b2361, b2362, b2363, b2364, b2365, b2366, b2367, b2368, b2369, b2370, b2371, b2372, b2373, b2374, b2375, b2376, b2377, b2378, b2379, b2380, b2381, b2382, b2383, b2384, b2385, b2386, b2387, b2388, b2389, b2390, b2391, b2392, b2393, b2394, b2395, b2396, b2397, b2398, b2399,\n+                b2400, b2401, b2402, b2403, b2404, b2405, b2406, b2407, b2408, b2409, b2410, b2411, b2412, b2413, b2414, b2415, b2416, b2417, b2418, b2419, b2420, b2421, b2422, b2423, b2424, b2425, b2426, b2427, b2428, b2429, b2430, b2431, b2432, b2433, b2434, b2435, b2436, b2437, b2438, b2439, b2440, b2441, b2442, b2443, b2444, b2445, b2446, b2447, b2448, b2449, b2450, b2451, b2452, b2453, b2454, b2455, b2456, b2457, b2458, b2459, b2460, b2461, b2462, b2463, b2464, b2465, b2466, b2467, b2468, b2469, b2470, b2471, b2472, b2473, b2474, b2475, b2476, b2477, b2478, b2479, b2480, b2481, b2482, b2483, b2484, b2485, b2486, b2487, b2488, b2489, b2490, b2491, b2492, b2493, b2494, b2495, b2496, b2497, b2498, b2499,\n+                b2500, b2501, b2502, b2503, b2504, b2505, b2506, b2507, b2508, b2509, b2510, b2511, b2512, b2513, b2514, b2515, b2516, b2517, b2518, b2519, b2520, b2521, b2522, b2523, b2524, b2525, b2526, b2527, b2528, b2529, b2530, b2531, b2532, b2533, b2534, b2535, b2536, b2537, b2538, b2539, b2540, b2541, b2542, b2543, b2544, b2545, b2546, b2547, b2548, b2549, b2550, b2551, b2552, b2553, b2554, b2555, b2556, b2557, b2558, b2559, b2560, b2561, b2562, b2563, b2564, b2565, b2566, b2567, b2568, b2569, b2570, b2571, b2572, b2573, b2574, b2575, b2576, b2577, b2578, b2579, b2580, b2581, b2582, b2583, b2584, b2585, b2586, b2587, b2588, b2589, b2590, b2591, b2592, b2593, b2594, b2595, b2596, b2597, b2598, b2599,\n+                b2600, b2601, b2602, b2603, b2604, b2605, b2606, b2607, b2608, b2609, b2610, b2611, b2612, b2613, b2614, b2615, b2616, b2617, b2618, b2619, b2620, b2621, b2622, b2623, b2624, b2625, b2626, b2627, b2628, b2629, b2630, b2631, b2632, b2633, b2634, b2635, b2636, b2637, b2638, b2639, b2640, b2641, b2642, b2643, b2644, b2645, b2646, b2647, b2648, b2649, b2650, b2651, b2652, b2653, b2654, b2655, b2656, b2657, b2658, b2659, b2660, b2661, b2662, b2663, b2664, b2665, b2666, b2667, b2668, b2669, b2670, b2671, b2672, b2673, b2674, b2675, b2676, b2677, b2678, b2679, b2680, b2681, b2682, b2683, b2684, b2685, b2686, b2687, b2688, b2689, b2690, b2691, b2692, b2693, b2694, b2695, b2696, b2697, b2698, b2699,\n+                b2700, b2701, b2702, b2703, b2704, b2705, b2706, b2707, b2708, b2709, b2710, b2711, b2712, b2713, b2714, b2715, b2716, b2717, b2718, b2719, b2720, b2721, b2722, b2723, b2724, b2725, b2726, b2727, b2728, b2729, b2730, b2731, b2732, b2733, b2734, b2735, b2736, b2737, b2738, b2739, b2740, b2741, b2742, b2743, b2744, b2745, b2746, b2747, b2748, b2749, b2750, b2751, b2752, b2753, b2754, b2755, b2756, b2757, b2758, b2759, b2760, b2761, b2762, b2763, b2764, b2765, b2766, b2767, b2768, b2769, b2770, b2771, b2772, b2773, b2774, b2775, b2776, b2777, b2778, b2779, b2780, b2781, b2782, b2783, b2784, b2785, b2786, b2787, b2788, b2789, b2790, b2791, b2792, b2793, b2794, b2795, b2796, b2797, b2798, b2799,\n+                b2800, b2801, b2802, b2803, b2804, b2805, b2806, b2807, b2808, b2809, b2810, b2811, b2812, b2813, b2814, b2815, b2816, b2817, b2818, b2819, b2820, b2821, b2822, b2823, b2824, b2825, b2826, b2827, b2828, b2829, b2830, b2831, b2832, b2833, b2834, b2835, b2836, b2837, b2838, b2839, b2840, b2841, b2842, b2843, b2844, b2845, b2846, b2847, b2848, b2849, b2850, b2851, b2852, b2853, b2854, b2855, b2856, b2857, b2858, b2859, b2860, b2861, b2862, b2863, b2864, b2865, b2866, b2867, b2868, b2869, b2870, b2871, b2872, b2873, b2874, b2875, b2876, b2877, b2878, b2879, b2880, b2881, b2882, b2883, b2884, b2885, b2886, b2887, b2888, b2889, b2890, b2891, b2892, b2893, b2894, b2895, b2896, b2897, b2898, b2899,\n+                b2900, b2901, b2902, b2903, b2904, b2905, b2906, b2907, b2908, b2909, b2910, b2911, b2912, b2913, b2914, b2915, b2916, b2917, b2918, b2919, b2920, b2921, b2922, b2923, b2924, b2925, b2926, b2927, b2928, b2929, b2930, b2931, b2932, b2933, b2934, b2935, b2936, b2937, b2938, b2939, b2940, b2941, b2942, b2943, b2944, b2945, b2946, b2947, b2948, b2949, b2950, b2951, b2952, b2953, b2954, b2955, b2956, b2957, b2958, b2959, b2960, b2961, b2962, b2963, b2964, b2965, b2966, b2967, b2968, b2969, b2970, b2971, b2972, b2973, b2974, b2975, b2976, b2977, b2978, b2979, b2980, b2981, b2982, b2983, b2984, b2985, b2986, b2987, b2988, b2989, b2990, b2991, b2992, b2993, b2994, b2995, b2996, b2997, b2998, b2999,\n+                b3000, b3001, b3002, b3003, b3004, b3005, b3006, b3007, b3008, b3009, b3010, b3011, b3012, b3013, b3014, b3015, b3016, b3017, b3018, b3019, b3020, b3021, b3022, b3023, b3024, b3025, b3026, b3027, b3028, b3029, b3030, b3031, b3032, b3033, b3034, b3035, b3036, b3037, b3038, b3039, b3040, b3041, b3042, b3043, b3044, b3045, b3046, b3047, b3048, b3049, b3050, b3051, b3052, b3053, b3054, b3055, b3056, b3057, b3058, b3059, b3060, b3061, b3062, b3063, b3064, b3065, b3066, b3067, b3068, b3069, b3070, b3071, b3072, b3073, b3074, b3075, b3076, b3077, b3078, b3079, b3080, b3081, b3082, b3083, b3084, b3085, b3086, b3087, b3088, b3089, b3090, b3091, b3092, b3093, b3094, b3095, b3096, b3097, b3098, b3099,\n+                b3100, b3101, b3102, b3103, b3104, b3105, b3106, b3107, b3108, b3109, b3110, b3111, b3112, b3113, b3114, b3115, b3116, b3117, b3118, b3119, b3120, b3121, b3122, b3123, b3124, b3125, b3126, b3127, b3128, b3129, b3130, b3131, b3132, b3133, b3134, b3135, b3136, b3137, b3138, b3139, b3140, b3141, b3142, b3143, b3144, b3145, b3146, b3147, b3148, b3149, b3150, b3151, b3152, b3153, b3154, b3155, b3156, b3157, b3158, b3159, b3160, b3161, b3162, b3163, b3164, b3165, b3166, b3167, b3168, b3169, b3170, b3171, b3172, b3173, b3174, b3175, b3176, b3177, b3178, b3179, b3180, b3181, b3182, b3183, b3184, b3185, b3186, b3187, b3188, b3189, b3190, b3191, b3192, b3193, b3194, b3195, b3196, b3197, b3198, b3199,\n+                b3200, b3201, b3202, b3203, b3204, b3205, b3206, b3207, b3208, b3209, b3210, b3211, b3212, b3213, b3214, b3215, b3216, b3217, b3218, b3219, b3220, b3221, b3222, b3223, b3224, b3225, b3226, b3227, b3228, b3229, b3230, b3231, b3232, b3233, b3234, b3235, b3236, b3237, b3238, b3239, b3240, b3241, b3242, b3243, b3244, b3245, b3246, b3247, b3248, b3249, b3250, b3251, b3252, b3253, b3254, b3255, b3256, b3257, b3258, b3259, b3260, b3261, b3262, b3263, b3264, b3265, b3266, b3267, b3268, b3269, b3270, b3271, b3272, b3273, b3274, b3275, b3276, b3277, b3278, b3279, b3280, b3281, b3282, b3283, b3284, b3285, b3286, b3287, b3288, b3289, b3290, b3291, b3292, b3293, b3294, b3295, b3296, b3297, b3298, b3299,\n+                b3300, b3301, b3302, b3303, b3304, b3305, b3306, b3307, b3308, b3309, b3310, b3311, b3312, b3313, b3314, b3315, b3316, b3317, b3318, b3319, b3320, b3321, b3322, b3323, b3324, b3325, b3326, b3327, b3328, b3329, b3330, b3331, b3332, b3333, b3334, b3335, b3336, b3337, b3338, b3339, b3340, b3341, b3342, b3343, b3344, b3345, b3346, b3347, b3348, b3349, b3350, b3351, b3352, b3353, b3354, b3355, b3356, b3357, b3358, b3359, b3360, b3361, b3362, b3363, b3364, b3365, b3366, b3367, b3368, b3369, b3370, b3371, b3372, b3373, b3374, b3375, b3376, b3377, b3378, b3379, b3380, b3381, b3382, b3383, b3384, b3385, b3386, b3387, b3388, b3389, b3390, b3391, b3392, b3393, b3394, b3395, b3396, b3397, b3398, b3399,\n+                b3400, b3401, b3402, b3403, b3404, b3405, b3406, b3407, b3408, b3409, b3410, b3411, b3412, b3413, b3414, b3415, b3416, b3417, b3418, b3419, b3420, b3421, b3422, b3423, b3424, b3425, b3426, b3427, b3428, b3429, b3430, b3431, b3432, b3433, b3434, b3435, b3436, b3437, b3438, b3439, b3440, b3441, b3442, b3443, b3444, b3445, b3446, b3447, b3448, b3449, b3450, b3451, b3452, b3453, b3454, b3455, b3456, b3457, b3458, b3459, b3460, b3461, b3462, b3463, b3464, b3465, b3466, b3467, b3468, b3469, b3470, b3471, b3472, b3473, b3474, b3475, b3476, b3477, b3478, b3479, b3480, b3481, b3482, b3483, b3484, b3485, b3486, b3487, b3488, b3489, b3490, b3491, b3492, b3493, b3494, b3495, b3496, b3497, b3498, b3499,\n+                b3500, b3501, b3502, b3503, b3504, b3505, b3506, b3507, b3508, b3509, b3510, b3511, b3512, b3513, b3514, b3515, b3516, b3517, b3518, b3519, b3520, b3521, b3522, b3523, b3524, b3525, b3526, b3527, b3528, b3529, b3530, b3531, b3532, b3533, b3534, b3535, b3536, b3537, b3538, b3539, b3540, b3541, b3542, b3543, b3544, b3545, b3546, b3547, b3548, b3549, b3550, b3551, b3552, b3553, b3554, b3555, b3556, b3557, b3558, b3559, b3560, b3561, b3562, b3563, b3564, b3565, b3566, b3567, b3568, b3569, b3570, b3571, b3572, b3573, b3574, b3575, b3576, b3577, b3578, b3579, b3580, b3581, b3582, b3583, b3584, b3585, b3586, b3587, b3588, b3589, b3590, b3591, b3592, b3593, b3594, b3595, b3596, b3597, b3598, b3599,\n+                b3600, b3601, b3602, b3603, b3604, b3605, b3606, b3607, b3608, b3609, b3610, b3611, b3612, b3613, b3614, b3615, b3616, b3617, b3618, b3619, b3620, b3621, b3622, b3623, b3624, b3625, b3626, b3627, b3628, b3629, b3630, b3631, b3632, b3633, b3634, b3635, b3636, b3637, b3638, b3639, b3640, b3641, b3642, b3643, b3644, b3645, b3646, b3647, b3648, b3649, b3650, b3651, b3652, b3653, b3654, b3655, b3656, b3657, b3658, b3659, b3660, b3661, b3662, b3663, b3664, b3665, b3666, b3667, b3668, b3669, b3670, b3671, b3672, b3673, b3674, b3675, b3676, b3677, b3678, b3679, b3680, b3681, b3682, b3683, b3684, b3685, b3686, b3687, b3688, b3689, b3690, b3691, b3692, b3693, b3694, b3695, b3696, b3697, b3698, b3699,\n+                b3700, b3701, b3702, b3703, b3704, b3705, b3706, b3707, b3708, b3709, b3710, b3711, b3712, b3713, b3714, b3715, b3716, b3717, b3718, b3719, b3720, b3721, b3722, b3723, b3724, b3725, b3726, b3727, b3728, b3729, b3730, b3731, b3732, b3733, b3734, b3735, b3736, b3737, b3738, b3739, b3740, b3741, b3742, b3743, b3744, b3745, b3746, b3747, b3748, b3749, b3750, b3751, b3752, b3753, b3754, b3755, b3756, b3757, b3758, b3759, b3760, b3761, b3762, b3763, b3764, b3765, b3766, b3767, b3768, b3769, b3770, b3771, b3772, b3773, b3774, b3775, b3776, b3777, b3778, b3779, b3780, b3781, b3782, b3783, b3784, b3785, b3786, b3787, b3788, b3789, b3790, b3791, b3792, b3793, b3794, b3795, b3796, b3797, b3798, b3799,\n+                b3800, b3801, b3802, b3803, b3804, b3805, b3806, b3807, b3808, b3809, b3810, b3811, b3812, b3813, b3814, b3815, b3816, b3817, b3818, b3819, b3820, b3821, b3822, b3823, b3824, b3825, b3826, b3827, b3828, b3829, b3830, b3831, b3832, b3833, b3834, b3835, b3836, b3837, b3838, b3839, b3840, b3841, b3842, b3843, b3844, b3845, b3846, b3847, b3848, b3849, b3850, b3851, b3852, b3853, b3854, b3855, b3856, b3857, b3858, b3859, b3860, b3861, b3862, b3863, b3864, b3865, b3866, b3867, b3868, b3869, b3870, b3871, b3872, b3873, b3874, b3875, b3876, b3877, b3878, b3879, b3880, b3881, b3882, b3883, b3884, b3885, b3886, b3887, b3888, b3889, b3890, b3891, b3892, b3893, b3894, b3895, b3896, b3897, b3898, b3899,\n+                b3900, b3901, b3902, b3903, b3904, b3905, b3906, b3907, b3908, b3909, b3910, b3911, b3912, b3913, b3914, b3915, b3916, b3917, b3918, b3919, b3920, b3921, b3922, b3923, b3924, b3925, b3926, b3927, b3928, b3929, b3930, b3931, b3932, b3933, b3934, b3935, b3936, b3937, b3938, b3939, b3940, b3941, b3942, b3943, b3944, b3945, b3946, b3947, b3948, b3949, b3950, b3951, b3952, b3953, b3954, b3955, b3956, b3957, b3958, b3959, b3960, b3961, b3962, b3963, b3964, b3965, b3966, b3967, b3968, b3969, b3970, b3971, b3972, b3973, b3974, b3975, b3976, b3977, b3978, b3979, b3980, b3981, b3982, b3983, b3984, b3985, b3986, b3987, b3988, b3989, b3990, b3991, b3992, b3993, b3994, b3995, b3996, b3997, b3998, b3999,\n+                b4000, b4001, b4002, b4003, b4004, b4005, b4006, b4007, b4008, b4009, b4010, b4011, b4012, b4013, b4014, b4015, b4016, b4017, b4018, b4019, b4020, b4021, b4022, b4023, b4024, b4025, b4026, b4027, b4028, b4029, b4030, b4031, b4032, b4033, b4034, b4035, b4036, b4037, b4038, b4039, b4040, b4041, b4042, b4043, b4044, b4045, b4046, b4047, b4048, b4049, b4050, b4051, b4052, b4053, b4054, b4055, b4056, b4057, b4058, b4059, b4060, b4061, b4062, b4063, b4064, b4065, b4066, b4067, b4068, b4069, b4070, b4071, b4072, b4073, b4074, b4075, b4076, b4077, b4078, b4079, b4080, b4081, b4082, b4083, b4084, b4085, b4086, b4087, b4088, b4089, b4090, b4091, b4092, b4093, b4094, b4095, b4096, b4097, b4098, b4099;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/TestOSRLotsOfLocals.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -39,0 +39,1 @@\n+ *                   -XX:CompileCommand=MemLimit,*.*,0\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestScalarReplacementMaxLiveNodes.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8339694\n+ * @summary Test compilation of unresolved constant dynamics.\n+ * @library \/test\/lib\n+ * @compile TestUnresolvedConstantDynamicHelper.jasm\n+ * @run driver TestUnresolvedConstantDynamic\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileCommand=compileonly,TestUnresolvedConstantDynamicHelper::test* TestUnresolvedConstantDynamic\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+\n+public class TestUnresolvedConstantDynamic {\n+\n+    public static void main(String[] args) {\n+        Asserts.assertEquals(TestUnresolvedConstantDynamicHelper.testBooleanArray(true)[0], true);\n+        Asserts.assertEquals(TestUnresolvedConstantDynamicHelper.testStringArray(\"42\")[0], \"42\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestUnresolvedConstantDynamic.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+public class TestUnresolvedConstantDynamicHelper version 55:0 {\n+    public Method \"<init>\":\"()V\" stack 1 locals 1 {\n+        aload_0;\n+        invokespecial Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+    }\n+\n+    private static Method newBooleanArray:\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/Class;)[Z\" stack 1 locals 3 {\n+        iconst_1;\n+        newarray boolean;\n+        areturn;\n+    }\n+\n+    private static Method newStringArray:\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/Class;)[Ljava\/lang\/String;\" stack 1 locals 3 {\n+        iconst_1;\n+        anewarray class java\/lang\/String;\n+        areturn;\n+    }\n+\n+    public static Method testBooleanArray:\"(Z)[Z\" stack 4 locals 2 {\n+        ldc Dynamic REF_invokeStatic:TestUnresolvedConstantDynamicHelper.newBooleanArray:\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/Class;)[Z\":name:\"[Z\";\n+        dup;\n+        iconst_0;\n+        iload_0;\n+        bastore;\n+        areturn;\n+    }\n+\n+    public static Method testStringArray:\"(Ljava\/lang\/String;)[Ljava\/lang\/String;\" stack 4 locals 2 {\n+        ldc Dynamic REF_invokeStatic:TestUnresolvedConstantDynamicHelper.newStringArray:\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/Class;)[Ljava\/lang\/String;\":name:\"[Ljava\/lang\/String;\";\n+        dup;\n+        iconst_0;\n+        aload_0;\n+        aastore;\n+        areturn;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestUnresolvedConstantDynamicHelper.jasm","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -51,2 +51,1 @@\n-            \"-XX:+UseJVMCICompiler\",\n-            \"-Djvmci.Compiler=null\",\n+            \"-XX:+EnableJVMCI\",\n@@ -59,1 +58,0 @@\n-        output.stdoutShouldContain(\"jvmci.Compiler=null\");\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/TestJVMCISavedProperties.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -112,1 +112,2 @@\n-        \"zvbb\"\n+        \"zvbb\",\n+        \"zvfh\"\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,391 @@\n+\/*\n+ * Copyright (c) 2024 Red Hat and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.parallel_iv;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+import java.util.Random;\n+\n+\/**\n+ * @test\n+ * @bug 8328528\n+ * @summary test the long typed parallel iv replacing transformation for int counted loop\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.loopopts.parallel_iv.TestParallelIvInIntCountedLoop\n+ *\/\n+public class TestParallelIvInIntCountedLoop {\n+    private static final Random RNG = Utils.getRandomInstance();\n+\n+    \/\/ stride2 must be a multiple of stride and must not overflow for the optimization to work\n+    private static final int STRIDE = RNG.nextInt(1, Integer.MAX_VALUE \/ 16);\n+    private static final int STRIDE_2 = STRIDE * RNG.nextInt(1, 16);\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\n+                \"-XX:+IgnoreUnrecognizedVMOptions\", \/\/ StressLongCountedLoop is only available in debug builds\n+                \"-XX:StressLongCountedLoop=0\", \/\/ Don't convert int counted loops to long ones\n+                \"-XX:PerMethodTrapLimit=100\" \/\/ allow slow-path loop limit checks\n+        );\n+    }\n+\n+    \/*\n+     * The IR framework can only test against static code, and the transformation relies on strides being constants to\n+     * perform constant propagation. Therefore, we have no choice but repeating the same test case multiple times with\n+     * different numbers.\n+     *\n+     * For good measures, randomly initialized static final stride and stride2 is also tested.\n+     *\/\n+\n+    \/\/ A controlled test making sure a simple non-counted loop can be found by the test framework.\n+    @Test\n+    @Arguments(values = { Argument.NUMBER_42 }) \/\/ otherwise a large number may take too long\n+    @IR(counts = { IRNode.COUNTED_LOOP, \">=1\" })\n+    private static int testControlledSimpleLoop(int stop) {\n+        int a = 0;\n+        for (int i = 0; i < stop; i++) {\n+            a += i; \/\/ cannot be extracted to multiplications\n+        }\n+\n+        return a;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.COUNTED_LOOP })\n+    private static int testIntCountedLoopWithIntIV(int stop) {\n+        int a = 0;\n+        for (int i = 0; i < stop; i++) {\n+            a += 1;\n+        }\n+\n+        return a;\n+    }\n+\n+    @Run(test = \"testIntCountedLoopWithIntIV\")\n+    private static void runTestIntCountedLoopWithIntIv() {\n+        int s = RNG.nextInt(0, Integer.MAX_VALUE);\n+        Asserts.assertEQ(s, testIntCountedLoopWithIntIV(s));\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.COUNTED_LOOP })\n+    private static int testIntCountedLoopWithIntIVZero(int stop) {\n+        int a = 0;\n+        for (int i = 0; i < stop; i++) {\n+            a += 0;\n+        }\n+\n+        return a;\n+    }\n+\n+    @Run(test = \"testIntCountedLoopWithIntIVZero\")\n+    private static void runTestIntCountedLoopWithIntIVZero() {\n+        int s = RNG.nextInt(0, Integer.MAX_VALUE);\n+        Asserts.assertEQ(0, testIntCountedLoopWithIntIVZero(s));\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.COUNTED_LOOP })\n+    private static int testIntCountedLoopWithIntIVMax(int stop) {\n+        int a = 0;\n+        for (int i = 0; i < stop; i++) {\n+            a += Integer.MAX_VALUE;\n+        }\n+\n+        return a;\n+    }\n+\n+    @Run(test = \"testIntCountedLoopWithIntIVMax\")\n+    private static void runTestIntCountedLoopWithIntIVMax() {\n+        int s = RNG.nextInt(0, Integer.MAX_VALUE);\n+        Asserts.assertEQ(s * Integer.MAX_VALUE, testIntCountedLoopWithIntIVMax(s));\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.COUNTED_LOOP })\n+    private static int testIntCountedLoopWithIntIVMaxMinusOne(int stop) {\n+        int a = 0;\n+        for (int i = 0; i < stop; i++) {\n+            a += Integer.MAX_VALUE - 1;\n+        }\n+\n+        return a;\n+    }\n+\n+    @Run(test = \"testIntCountedLoopWithIntIVMaxMinusOne\")\n+    private static void runTestIntCountedLoopWithIntIVMaxMinusOne() {\n+        int s = RNG.nextInt(0, Integer.MAX_VALUE);\n+        Asserts.assertEQ(s * (Integer.MAX_VALUE - 1), testIntCountedLoopWithIntIVMaxMinusOne(s));\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.COUNTED_LOOP })\n+    private static int testIntCountedLoopWithIntIVMaxPlusOne(int stop) {\n+        int a = 0;\n+        for (int i = 0; i < stop; i++) {\n+            a += Integer.MAX_VALUE + 1;\n+        }\n+\n+        return a;\n+    }\n+\n+    @Run(test = \"testIntCountedLoopWithIntIVMaxPlusOne\")\n+    private static void runTestIntCountedLoopWithIntIVMaxPlusOne() {\n+        int s = RNG.nextInt(0, Integer.MAX_VALUE);\n+        Asserts.assertEQ(s * (Integer.MAX_VALUE + 1), testIntCountedLoopWithIntIVMaxPlusOne(s));\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.COUNTED_LOOP })\n+    private static int testIntCountedLoopWithIntIVWithStrideTwo(int stop) {\n+        int a = 0;\n+        for (int i = 0; i < stop; i += 2) {\n+            a += 2; \/\/ this stride2 constant must be a multiple of the first stride (i += ...) for optimization\n+        }\n+\n+        return a;\n+    }\n+\n+    @Run(test = \"testIntCountedLoopWithIntIVWithStrideTwo\")\n+    private static void runTestIntCountedLoopWithIntIVWithStrideTwo() {\n+        \/\/ Since we can't easily determine expected values if loop variables overflow when incrementing, we make sure\n+        \/\/ `stop` is less than (MAX_VALUE - stride).\n+        int s = RNG.nextInt(0, Integer.MAX_VALUE - 2);\n+        Asserts.assertEQ(Math.ceilDiv(s, 2) * 2, testIntCountedLoopWithIntIVWithStrideTwo(s));\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.COUNTED_LOOP })\n+    private static int testIntCountedLoopWithIntIVWithStrideMinusOne(int stop) {\n+        int a = 0;\n+        for (int i = stop; i > 0; i += -1) {\n+            a += 1;\n+        }\n+\n+        return a;\n+    }\n+\n+    @Run(test = \"testIntCountedLoopWithIntIVWithStrideMinusOne\")\n+    private static void runTestIntCountedLoopWithIntIVWithStrideMinusOne() {\n+        int s = RNG.nextInt(0, Integer.MAX_VALUE);\n+        Asserts.assertEQ(s, testIntCountedLoopWithIntIVWithStrideMinusOne(s));\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.COUNTED_LOOP })\n+    private static int testIntCountedLoopWithIntIVWithRandomStrides(int stop) {\n+        int a = 0;\n+        for (int i = 0; i < stop; i += STRIDE) {\n+            a += STRIDE_2;\n+        }\n+\n+        return a;\n+    }\n+\n+    @Run(test = \"testIntCountedLoopWithIntIVWithRandomStrides\")\n+    private static void runTestIntCountedLoopWithIntIVWithRandomStrides() {\n+        \/\/ Make sure `stop` is less than (MAX_VALUE - stride) to avoid overflows.\n+        int s = RNG.nextInt(0, Integer.MAX_VALUE - STRIDE);\n+        Asserts.assertEQ(Math.ceilDiv(s, STRIDE) * STRIDE_2, testIntCountedLoopWithIntIVWithRandomStrides(s));\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.COUNTED_LOOP })\n+    private static int testIntCountedLoopWithIntIVWithRandomStridesAndInits(int init, int init2, int stop) {\n+        int a = init;\n+        for (int i = init2; i < stop; i += STRIDE) {\n+            a += STRIDE_2;\n+        }\n+\n+        return a;\n+    }\n+\n+    @Run(test = \"testIntCountedLoopWithIntIVWithRandomStridesAndInits\")\n+    private static void runTestIntCountedLoopWithIntIVWithRandomStridesAndInits() {\n+        int s = RNG.nextInt(0, Integer.MAX_VALUE - STRIDE);\n+        int init1 = RNG.nextInt();\n+        int init2 = RNG.nextInt(Integer.MIN_VALUE + s + 1, s); \/\/ Limit bounds to avoid loop variables from overflowing.\n+        Asserts.assertEQ(Math.ceilDiv((s - init2), STRIDE) * STRIDE_2 + init1,\n+                testIntCountedLoopWithIntIVWithRandomStridesAndInits(init1, init2, s));\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.COUNTED_LOOP })\n+    private static long testIntCountedLoopWithLongIV(int stop) {\n+        long a = 0;\n+        for (int i = 0; i < stop; i++) {\n+            a += 1;\n+        }\n+\n+        return a;\n+    }\n+\n+    @Run(test = \"testIntCountedLoopWithLongIV\")\n+    private static void runTestIntCountedLoopWithLongIV() {\n+        int s = RNG.nextInt(0, Integer.MAX_VALUE);\n+        Asserts.assertEQ((long) s, testIntCountedLoopWithLongIV(s));\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.COUNTED_LOOP })\n+    private static long testIntCountedLoopWithLongIVZero(int stop) {\n+        long a = 0;\n+        for (int i = 0; i < stop; i++) {\n+            a += 0;\n+        }\n+\n+        return a;\n+    }\n+\n+    @Run(test = \"testIntCountedLoopWithLongIVZero\")\n+    private static void runTestIntCountedLoopWithLongIVZero() {\n+        int s = RNG.nextInt(0, Integer.MAX_VALUE);\n+        Asserts.assertEQ((long) 0, testIntCountedLoopWithLongIVZero(s));\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.COUNTED_LOOP })\n+    private static long testIntCountedLoopWithLongIVMax(int stop) {\n+        long a = 0;\n+        for (int i = 0; i < stop; i++) {\n+            a += Long.MAX_VALUE;\n+        }\n+\n+        return a;\n+    }\n+\n+    @Run(test = \"testIntCountedLoopWithLongIVMax\")\n+    private static void runTestIntCountedLoopWithLongIVMax() {\n+        int s = RNG.nextInt(0, Integer.MAX_VALUE);\n+        Asserts.assertEQ((long) s * Long.MAX_VALUE, testIntCountedLoopWithLongIVMax(s));\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.COUNTED_LOOP })\n+    private static long testIntCountedLoopWithLongIVMaxMinusOne(int stop) {\n+        long a = 0;\n+        for (int i = 0; i < stop; i++) {\n+            a += Long.MAX_VALUE - 1;\n+        }\n+\n+        return a;\n+    }\n+\n+    @Run(test = \"testIntCountedLoopWithLongIVMaxMinusOne\")\n+    private static void runTestIntCountedLoopWithLongIVMaxMinusOne() {\n+        int s = RNG.nextInt(0, Integer.MAX_VALUE);\n+        Asserts.assertEQ((long) s * (Long.MAX_VALUE - 1L), testIntCountedLoopWithLongIVMaxMinusOne(s));\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.COUNTED_LOOP })\n+    private static long testIntCountedLoopWithLongIVMaxPlusOne(int stop) {\n+        long a = 0;\n+        for (int i = 0; i < stop; i++) {\n+            a += Long.MAX_VALUE + 1;\n+        }\n+\n+        return a;\n+    }\n+\n+    @Run(test = \"testIntCountedLoopWithLongIVMaxPlusOne\")\n+    private static void runTestIntCountedLoopWithLongIVMaxPlusOne() {\n+        int s = RNG.nextInt(0, Integer.MAX_VALUE);\n+        Asserts.assertEQ((long) s * (Long.MAX_VALUE + 1L), testIntCountedLoopWithLongIVMaxPlusOne(s));\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.COUNTED_LOOP })\n+    private static long testIntCountedLoopWithLongIVWithStrideTwo(int stop) {\n+        long a = 0;\n+        for (int i = 0; i < stop; i += 2) {\n+            a += 2;\n+        }\n+\n+        return a;\n+    }\n+\n+    @Run(test = \"testIntCountedLoopWithLongIVWithStrideTwo\")\n+    private static void runTestIntCountedLoopWithLongIVWithStrideTwo() {\n+        int s = RNG.nextInt(0, Integer.MAX_VALUE - 2);\n+        Asserts.assertEQ(Math.ceilDiv(s, 2L) * 2L, testIntCountedLoopWithLongIVWithStrideTwo(s));\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.COUNTED_LOOP })\n+    private static long testIntCountedLoopWithLongIVWithStrideMinusOne(int stop) {\n+        long a = 0;\n+        for (int i = stop; i > 0; i += -1) {\n+            a += 1;\n+        }\n+\n+        return a;\n+    }\n+\n+    @Run(test = \"testIntCountedLoopWithLongIVWithStrideMinusOne\")\n+    private static void runTestIntCountedLoopWithLongIVWithStrideMinusOne() {\n+        int s = RNG.nextInt(0, Integer.MAX_VALUE);\n+        Asserts.assertEQ((long) s, testIntCountedLoopWithLongIVWithStrideMinusOne(s));\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.COUNTED_LOOP })\n+    private static long testIntCountedLoopWithLongIVWithRandomStrides(int stop) {\n+        long a = 0;\n+        for (int i = 0; i < stop; i += STRIDE) {\n+            a += STRIDE_2;\n+        }\n+\n+        return a;\n+    }\n+\n+    @Run(test = \"testIntCountedLoopWithLongIVWithRandomStrides\")\n+    private static void runTestIntCountedLoopWithLongIVWithRandomStrides() {\n+        int s = RNG.nextInt(0, Integer.MAX_VALUE - STRIDE);\n+        Asserts.assertEQ(Math.ceilDiv(s, (long) STRIDE) * (long) STRIDE_2,\n+                testIntCountedLoopWithLongIVWithRandomStrides(s));\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.COUNTED_LOOP })\n+    private static long testIntCountedLoopWithLongIVWithRandomStridesAndInits(long init, int init2, int stop) {\n+        long a = init;\n+        for (int i = init2; i < stop; i += STRIDE) {\n+            a += STRIDE_2;\n+        }\n+\n+        return a;\n+    }\n+\n+    @Run(test = \"testIntCountedLoopWithLongIVWithRandomStridesAndInits\")\n+    private static void runTestIntCountedLoopWithLongIVWithRandomStridesAndInits() {\n+        int s = RNG.nextInt(0, Integer.MAX_VALUE - STRIDE);\n+        long init1 = RNG.nextLong();\n+        int init2 = RNG.nextInt(Integer.MIN_VALUE + s + 1, s); \/\/ Limit bounds to avoid loop variables from overflowing.\n+        Asserts.assertEQ(Math.ceilDiv(((long) s - init2), (long) STRIDE) * (long) STRIDE_2 + init1,\n+                testIntCountedLoopWithLongIVWithRandomStridesAndInits(init1, init2, s));\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/parallel_iv\/TestParallelIvInIntCountedLoop.java","additions":391,"deletions":0,"binary":false,"changes":391,"status":"added"},{"patch":"@@ -24,88 +24,0 @@\n-\/*\n- * Summary:\n- *   Test SuperWord vectorization with different access offsets\n- *   and various MaxVectorSize values, and +- AlignVector.\n- *\n- * Note: this test is auto-generated. Please modify \/ generate with script:\n- *       https:\/\/bugs.openjdk.org\/browse\/JDK-8333729\n- *\n- * Types: int, long, short, char, byte, float, double\n- * Offsets: 0, -1, 1, -2, 2, -3, 3, -4, 4, -7, 7, -8, 8, -14, 14, -16, 16, -18, 18, -20, 20, -31, 31, -32, 32, -63, 63, -64, 64, -65, 65, -128, 128, -129, 129, -192, 192\n- *\n- * Checking if we should vectorize is a bit complicated. It depends on\n- * Matcher::vector_width_in_bytes, of the respective platforms (eg. x86.ad)\n- * This vector_width can be further constrained by MaxVectorSize.\n- *\n- * With '-XX:-AlignVector', we vectorize if:\n- *  - Vectors have at least 4 bytes:    vector_width >= 4\n- *  - Vectors hold at least 2 elements: vector_width >= 2 * sizeofop(velt_type)\n- *    -> min_vector_width = max(4, 2 * sizeofop(velt_type))\n- *    -> simplifies to: vector_width >= min_vector_width\n- *  - No cyclic dependency:\n- *    - Access: data[i + offset] = data[i] * fac;\n- *    - byte_offset = offset * sizeofop(type)\n- *    - Cyclic dependency if: 0 < byte_offset < vector_width\n- *\n- * Note: sizeofop(type) = sizeof(type), except sizeofop(char) = 2\n- *\n- * Different types can lead to different vector_width. This depends on\n- * the CPU-features.\n- *\n- * Definition:\n- *     MaxVectorSize: limit through flag\n- *     vector_width: limit given by specific CPU feature for a specific velt_type\n- *     actual_vector_width: what is actually vectorized with\n- *     min_vector_width: what is minimally required for vectorization\n- *\n- *     min_vector_width = max(4, 2 * sizeofop(velt_type))\n- *     MaxVectorSize >= vector_width >= actual_vector_width >= min_vector_width\n- *\n- * In general, we cannot easily specify negative IR rules, that require no\n- * vectorization to happen. We may improve the SuperWord algorithm later,\n- * or some additional optimization collapses some Loads, and suddenly cyclic\n- * dependency disappears, and we can vectorize.\n- *\n- * With '-XX:+AlignVector' we do the following:\n- *\n- * Must vectorize cleanly if:\n- *   1) guaranteed no misalignment AND\n- *   2) guaratneed no cyclic dependency\n- *\n- * Must not vectorize at all if:\n- *   1) guaranteed misalignment AND\n- *   2) guaranteed no cyclic dependency\n- *\n- * We could imagine a case with cyclic dependency, where C2 detects\n- * that only the first load is needed, and so no vectorization is\n- * required for it, and hence the store vector can be aligned.\n- *\n- * The alignment criteria is\n- *     byte_offset % aw == 0\n- * where align width (aw) is\n- *     aw = min(actual_vector_width, ObjectAlignmentInBytes)\n- * For simplicity, we assume that ObjectAlignmentInBytes == 8,\n- * which currently can only be changed manually and then no IR\n- * rule is run.\n- * This allows us to do the computation statically.\n- * Further, we define:\n- *     aw_min = min(min_vector_width, ObjectAlignmentInBytes)\n- *     aw_max = min(vector_width, ObjectAlignmentInBytes)\n- *     aw_min <= aw <= aw_max\n- *\n- * Again, we have no cyclic dependency, except when:\n- *     byte_offset > 0 and p.vector_width > byte_offset\n- * Here we must ensure that:\n- *     byte_offset >= MaxVectorSize\n- *\n- * Guaranteed no misalignment:\n- *     byte_offset % aw_max == 0\n- *       implies\n- *         byte_offset % aw == 0\n- *\n- * Guaranteed misalignment:\n- *     byte_offset % aw_min != 0\n- *       implies\n- *         byte_offset % aw != 0\n- *\n- *\/\n-\n@@ -117,0 +29,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -125,0 +38,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -136,0 +50,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -147,0 +62,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -158,0 +74,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -169,0 +86,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -180,0 +98,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -191,0 +110,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -194,22 +114,0 @@\n-\/*\n- * @test id=sse4-v002-A\n- * @bug 8298935 8308606 8310308 8312570 8310190\n- * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n- * @requires vm.compiler2.enabled\n- * @requires (os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\")\n- * @requires vm.cpu.features ~= \".*sse4.*\"\n- * @library \/test\/lib \/\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets sse4-v002-A\n- *\/\n-\n-\/*\n- * @test id=sse4-v002-U\n- * @bug 8298935 8308606 8310308 8312570 8310190\n- * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n- * @requires vm.compiler2.enabled\n- * @requires (os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\")\n- * @requires vm.cpu.features ~= \".*sse4.*\"\n- * @library \/test\/lib \/\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets sse4-v002-U\n- *\/\n-\n@@ -224,0 +122,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -235,0 +134,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -246,0 +146,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -257,0 +158,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -268,0 +170,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -279,0 +182,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -290,0 +194,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -301,0 +206,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -312,0 +218,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -323,0 +230,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -334,0 +242,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -345,0 +254,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -356,0 +266,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -367,0 +278,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -378,0 +290,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -389,0 +302,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -399,0 +313,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -409,0 +324,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -419,0 +335,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -429,0 +346,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -439,0 +357,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -449,0 +368,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -459,0 +379,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -469,0 +390,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -479,0 +401,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -489,0 +412,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -493,1 +417,0 @@\n-import compiler.lib.ir_framework.*;\n@@ -495,784 +418,2 @@\n-public class TestDependencyOffsets {\n-    static final int RANGE = 512;\n-\n-    static int[] goldIntP0 = new int[RANGE];\n-    static int[] goldIntM1 = new int[RANGE];\n-    static int[] goldIntP1 = new int[RANGE];\n-    static int[] goldIntM2 = new int[RANGE];\n-    static int[] goldIntP2 = new int[RANGE];\n-    static int[] goldIntM3 = new int[RANGE];\n-    static int[] goldIntP3 = new int[RANGE];\n-    static int[] goldIntM4 = new int[RANGE];\n-    static int[] goldIntP4 = new int[RANGE];\n-    static int[] goldIntM7 = new int[RANGE];\n-    static int[] goldIntP7 = new int[RANGE];\n-    static int[] goldIntM8 = new int[RANGE];\n-    static int[] goldIntP8 = new int[RANGE];\n-    static int[] goldIntM14 = new int[RANGE];\n-    static int[] goldIntP14 = new int[RANGE];\n-    static int[] goldIntM16 = new int[RANGE];\n-    static int[] goldIntP16 = new int[RANGE];\n-    static int[] goldIntM18 = new int[RANGE];\n-    static int[] goldIntP18 = new int[RANGE];\n-    static int[] goldIntM20 = new int[RANGE];\n-    static int[] goldIntP20 = new int[RANGE];\n-    static int[] goldIntM31 = new int[RANGE];\n-    static int[] goldIntP31 = new int[RANGE];\n-    static int[] goldIntM32 = new int[RANGE];\n-    static int[] goldIntP32 = new int[RANGE];\n-    static int[] goldIntM63 = new int[RANGE];\n-    static int[] goldIntP63 = new int[RANGE];\n-    static int[] goldIntM64 = new int[RANGE];\n-    static int[] goldIntP64 = new int[RANGE];\n-    static int[] goldIntM65 = new int[RANGE];\n-    static int[] goldIntP65 = new int[RANGE];\n-    static int[] goldIntM128 = new int[RANGE];\n-    static int[] goldIntP128 = new int[RANGE];\n-    static int[] goldIntM129 = new int[RANGE];\n-    static int[] goldIntP129 = new int[RANGE];\n-    static int[] goldIntM192 = new int[RANGE];\n-    static int[] goldIntP192 = new int[RANGE];\n-    static long[] goldLongP0 = new long[RANGE];\n-    static long[] goldLongM1 = new long[RANGE];\n-    static long[] goldLongP1 = new long[RANGE];\n-    static long[] goldLongM2 = new long[RANGE];\n-    static long[] goldLongP2 = new long[RANGE];\n-    static long[] goldLongM3 = new long[RANGE];\n-    static long[] goldLongP3 = new long[RANGE];\n-    static long[] goldLongM4 = new long[RANGE];\n-    static long[] goldLongP4 = new long[RANGE];\n-    static long[] goldLongM7 = new long[RANGE];\n-    static long[] goldLongP7 = new long[RANGE];\n-    static long[] goldLongM8 = new long[RANGE];\n-    static long[] goldLongP8 = new long[RANGE];\n-    static long[] goldLongM14 = new long[RANGE];\n-    static long[] goldLongP14 = new long[RANGE];\n-    static long[] goldLongM16 = new long[RANGE];\n-    static long[] goldLongP16 = new long[RANGE];\n-    static long[] goldLongM18 = new long[RANGE];\n-    static long[] goldLongP18 = new long[RANGE];\n-    static long[] goldLongM20 = new long[RANGE];\n-    static long[] goldLongP20 = new long[RANGE];\n-    static long[] goldLongM31 = new long[RANGE];\n-    static long[] goldLongP31 = new long[RANGE];\n-    static long[] goldLongM32 = new long[RANGE];\n-    static long[] goldLongP32 = new long[RANGE];\n-    static long[] goldLongM63 = new long[RANGE];\n-    static long[] goldLongP63 = new long[RANGE];\n-    static long[] goldLongM64 = new long[RANGE];\n-    static long[] goldLongP64 = new long[RANGE];\n-    static long[] goldLongM65 = new long[RANGE];\n-    static long[] goldLongP65 = new long[RANGE];\n-    static long[] goldLongM128 = new long[RANGE];\n-    static long[] goldLongP128 = new long[RANGE];\n-    static long[] goldLongM129 = new long[RANGE];\n-    static long[] goldLongP129 = new long[RANGE];\n-    static long[] goldLongM192 = new long[RANGE];\n-    static long[] goldLongP192 = new long[RANGE];\n-    static short[] goldShortP0 = new short[RANGE];\n-    static short[] goldShortM1 = new short[RANGE];\n-    static short[] goldShortP1 = new short[RANGE];\n-    static short[] goldShortM2 = new short[RANGE];\n-    static short[] goldShortP2 = new short[RANGE];\n-    static short[] goldShortM3 = new short[RANGE];\n-    static short[] goldShortP3 = new short[RANGE];\n-    static short[] goldShortM4 = new short[RANGE];\n-    static short[] goldShortP4 = new short[RANGE];\n-    static short[] goldShortM7 = new short[RANGE];\n-    static short[] goldShortP7 = new short[RANGE];\n-    static short[] goldShortM8 = new short[RANGE];\n-    static short[] goldShortP8 = new short[RANGE];\n-    static short[] goldShortM14 = new short[RANGE];\n-    static short[] goldShortP14 = new short[RANGE];\n-    static short[] goldShortM16 = new short[RANGE];\n-    static short[] goldShortP16 = new short[RANGE];\n-    static short[] goldShortM18 = new short[RANGE];\n-    static short[] goldShortP18 = new short[RANGE];\n-    static short[] goldShortM20 = new short[RANGE];\n-    static short[] goldShortP20 = new short[RANGE];\n-    static short[] goldShortM31 = new short[RANGE];\n-    static short[] goldShortP31 = new short[RANGE];\n-    static short[] goldShortM32 = new short[RANGE];\n-    static short[] goldShortP32 = new short[RANGE];\n-    static short[] goldShortM63 = new short[RANGE];\n-    static short[] goldShortP63 = new short[RANGE];\n-    static short[] goldShortM64 = new short[RANGE];\n-    static short[] goldShortP64 = new short[RANGE];\n-    static short[] goldShortM65 = new short[RANGE];\n-    static short[] goldShortP65 = new short[RANGE];\n-    static short[] goldShortM128 = new short[RANGE];\n-    static short[] goldShortP128 = new short[RANGE];\n-    static short[] goldShortM129 = new short[RANGE];\n-    static short[] goldShortP129 = new short[RANGE];\n-    static short[] goldShortM192 = new short[RANGE];\n-    static short[] goldShortP192 = new short[RANGE];\n-    static char[] goldCharP0 = new char[RANGE];\n-    static char[] goldCharM1 = new char[RANGE];\n-    static char[] goldCharP1 = new char[RANGE];\n-    static char[] goldCharM2 = new char[RANGE];\n-    static char[] goldCharP2 = new char[RANGE];\n-    static char[] goldCharM3 = new char[RANGE];\n-    static char[] goldCharP3 = new char[RANGE];\n-    static char[] goldCharM4 = new char[RANGE];\n-    static char[] goldCharP4 = new char[RANGE];\n-    static char[] goldCharM7 = new char[RANGE];\n-    static char[] goldCharP7 = new char[RANGE];\n-    static char[] goldCharM8 = new char[RANGE];\n-    static char[] goldCharP8 = new char[RANGE];\n-    static char[] goldCharM14 = new char[RANGE];\n-    static char[] goldCharP14 = new char[RANGE];\n-    static char[] goldCharM16 = new char[RANGE];\n-    static char[] goldCharP16 = new char[RANGE];\n-    static char[] goldCharM18 = new char[RANGE];\n-    static char[] goldCharP18 = new char[RANGE];\n-    static char[] goldCharM20 = new char[RANGE];\n-    static char[] goldCharP20 = new char[RANGE];\n-    static char[] goldCharM31 = new char[RANGE];\n-    static char[] goldCharP31 = new char[RANGE];\n-    static char[] goldCharM32 = new char[RANGE];\n-    static char[] goldCharP32 = new char[RANGE];\n-    static char[] goldCharM63 = new char[RANGE];\n-    static char[] goldCharP63 = new char[RANGE];\n-    static char[] goldCharM64 = new char[RANGE];\n-    static char[] goldCharP64 = new char[RANGE];\n-    static char[] goldCharM65 = new char[RANGE];\n-    static char[] goldCharP65 = new char[RANGE];\n-    static char[] goldCharM128 = new char[RANGE];\n-    static char[] goldCharP128 = new char[RANGE];\n-    static char[] goldCharM129 = new char[RANGE];\n-    static char[] goldCharP129 = new char[RANGE];\n-    static char[] goldCharM192 = new char[RANGE];\n-    static char[] goldCharP192 = new char[RANGE];\n-    static byte[] goldByteP0 = new byte[RANGE];\n-    static byte[] goldByteM1 = new byte[RANGE];\n-    static byte[] goldByteP1 = new byte[RANGE];\n-    static byte[] goldByteM2 = new byte[RANGE];\n-    static byte[] goldByteP2 = new byte[RANGE];\n-    static byte[] goldByteM3 = new byte[RANGE];\n-    static byte[] goldByteP3 = new byte[RANGE];\n-    static byte[] goldByteM4 = new byte[RANGE];\n-    static byte[] goldByteP4 = new byte[RANGE];\n-    static byte[] goldByteM7 = new byte[RANGE];\n-    static byte[] goldByteP7 = new byte[RANGE];\n-    static byte[] goldByteM8 = new byte[RANGE];\n-    static byte[] goldByteP8 = new byte[RANGE];\n-    static byte[] goldByteM14 = new byte[RANGE];\n-    static byte[] goldByteP14 = new byte[RANGE];\n-    static byte[] goldByteM16 = new byte[RANGE];\n-    static byte[] goldByteP16 = new byte[RANGE];\n-    static byte[] goldByteM18 = new byte[RANGE];\n-    static byte[] goldByteP18 = new byte[RANGE];\n-    static byte[] goldByteM20 = new byte[RANGE];\n-    static byte[] goldByteP20 = new byte[RANGE];\n-    static byte[] goldByteM31 = new byte[RANGE];\n-    static byte[] goldByteP31 = new byte[RANGE];\n-    static byte[] goldByteM32 = new byte[RANGE];\n-    static byte[] goldByteP32 = new byte[RANGE];\n-    static byte[] goldByteM63 = new byte[RANGE];\n-    static byte[] goldByteP63 = new byte[RANGE];\n-    static byte[] goldByteM64 = new byte[RANGE];\n-    static byte[] goldByteP64 = new byte[RANGE];\n-    static byte[] goldByteM65 = new byte[RANGE];\n-    static byte[] goldByteP65 = new byte[RANGE];\n-    static byte[] goldByteM128 = new byte[RANGE];\n-    static byte[] goldByteP128 = new byte[RANGE];\n-    static byte[] goldByteM129 = new byte[RANGE];\n-    static byte[] goldByteP129 = new byte[RANGE];\n-    static byte[] goldByteM192 = new byte[RANGE];\n-    static byte[] goldByteP192 = new byte[RANGE];\n-    static float[] goldFloatP0 = new float[RANGE];\n-    static float[] goldFloatM1 = new float[RANGE];\n-    static float[] goldFloatP1 = new float[RANGE];\n-    static float[] goldFloatM2 = new float[RANGE];\n-    static float[] goldFloatP2 = new float[RANGE];\n-    static float[] goldFloatM3 = new float[RANGE];\n-    static float[] goldFloatP3 = new float[RANGE];\n-    static float[] goldFloatM4 = new float[RANGE];\n-    static float[] goldFloatP4 = new float[RANGE];\n-    static float[] goldFloatM7 = new float[RANGE];\n-    static float[] goldFloatP7 = new float[RANGE];\n-    static float[] goldFloatM8 = new float[RANGE];\n-    static float[] goldFloatP8 = new float[RANGE];\n-    static float[] goldFloatM14 = new float[RANGE];\n-    static float[] goldFloatP14 = new float[RANGE];\n-    static float[] goldFloatM16 = new float[RANGE];\n-    static float[] goldFloatP16 = new float[RANGE];\n-    static float[] goldFloatM18 = new float[RANGE];\n-    static float[] goldFloatP18 = new float[RANGE];\n-    static float[] goldFloatM20 = new float[RANGE];\n-    static float[] goldFloatP20 = new float[RANGE];\n-    static float[] goldFloatM31 = new float[RANGE];\n-    static float[] goldFloatP31 = new float[RANGE];\n-    static float[] goldFloatM32 = new float[RANGE];\n-    static float[] goldFloatP32 = new float[RANGE];\n-    static float[] goldFloatM63 = new float[RANGE];\n-    static float[] goldFloatP63 = new float[RANGE];\n-    static float[] goldFloatM64 = new float[RANGE];\n-    static float[] goldFloatP64 = new float[RANGE];\n-    static float[] goldFloatM65 = new float[RANGE];\n-    static float[] goldFloatP65 = new float[RANGE];\n-    static float[] goldFloatM128 = new float[RANGE];\n-    static float[] goldFloatP128 = new float[RANGE];\n-    static float[] goldFloatM129 = new float[RANGE];\n-    static float[] goldFloatP129 = new float[RANGE];\n-    static float[] goldFloatM192 = new float[RANGE];\n-    static float[] goldFloatP192 = new float[RANGE];\n-    static double[] goldDoubleP0 = new double[RANGE];\n-    static double[] goldDoubleM1 = new double[RANGE];\n-    static double[] goldDoubleP1 = new double[RANGE];\n-    static double[] goldDoubleM2 = new double[RANGE];\n-    static double[] goldDoubleP2 = new double[RANGE];\n-    static double[] goldDoubleM3 = new double[RANGE];\n-    static double[] goldDoubleP3 = new double[RANGE];\n-    static double[] goldDoubleM4 = new double[RANGE];\n-    static double[] goldDoubleP4 = new double[RANGE];\n-    static double[] goldDoubleM7 = new double[RANGE];\n-    static double[] goldDoubleP7 = new double[RANGE];\n-    static double[] goldDoubleM8 = new double[RANGE];\n-    static double[] goldDoubleP8 = new double[RANGE];\n-    static double[] goldDoubleM14 = new double[RANGE];\n-    static double[] goldDoubleP14 = new double[RANGE];\n-    static double[] goldDoubleM16 = new double[RANGE];\n-    static double[] goldDoubleP16 = new double[RANGE];\n-    static double[] goldDoubleM18 = new double[RANGE];\n-    static double[] goldDoubleP18 = new double[RANGE];\n-    static double[] goldDoubleM20 = new double[RANGE];\n-    static double[] goldDoubleP20 = new double[RANGE];\n-    static double[] goldDoubleM31 = new double[RANGE];\n-    static double[] goldDoubleP31 = new double[RANGE];\n-    static double[] goldDoubleM32 = new double[RANGE];\n-    static double[] goldDoubleP32 = new double[RANGE];\n-    static double[] goldDoubleM63 = new double[RANGE];\n-    static double[] goldDoubleP63 = new double[RANGE];\n-    static double[] goldDoubleM64 = new double[RANGE];\n-    static double[] goldDoubleP64 = new double[RANGE];\n-    static double[] goldDoubleM65 = new double[RANGE];\n-    static double[] goldDoubleP65 = new double[RANGE];\n-    static double[] goldDoubleM128 = new double[RANGE];\n-    static double[] goldDoubleP128 = new double[RANGE];\n-    static double[] goldDoubleM129 = new double[RANGE];\n-    static double[] goldDoubleP129 = new double[RANGE];\n-    static double[] goldDoubleM192 = new double[RANGE];\n-    static double[] goldDoubleP192 = new double[RANGE];\n-\n-    static {\n-        \/\/ compute the gold standard in interpreter mode\n-        init(goldIntP0);\n-        testIntP0(goldIntP0);\n-        init(goldIntM1);\n-        testIntM1(goldIntM1);\n-        init(goldIntP1);\n-        testIntP1(goldIntP1);\n-        init(goldIntM2);\n-        testIntM2(goldIntM2);\n-        init(goldIntP2);\n-        testIntP2(goldIntP2);\n-        init(goldIntM3);\n-        testIntM3(goldIntM3);\n-        init(goldIntP3);\n-        testIntP3(goldIntP3);\n-        init(goldIntM4);\n-        testIntM4(goldIntM4);\n-        init(goldIntP4);\n-        testIntP4(goldIntP4);\n-        init(goldIntM7);\n-        testIntM7(goldIntM7);\n-        init(goldIntP7);\n-        testIntP7(goldIntP7);\n-        init(goldIntM8);\n-        testIntM8(goldIntM8);\n-        init(goldIntP8);\n-        testIntP8(goldIntP8);\n-        init(goldIntM14);\n-        testIntM14(goldIntM14);\n-        init(goldIntP14);\n-        testIntP14(goldIntP14);\n-        init(goldIntM16);\n-        testIntM16(goldIntM16);\n-        init(goldIntP16);\n-        testIntP16(goldIntP16);\n-        init(goldIntM18);\n-        testIntM18(goldIntM18);\n-        init(goldIntP18);\n-        testIntP18(goldIntP18);\n-        init(goldIntM20);\n-        testIntM20(goldIntM20);\n-        init(goldIntP20);\n-        testIntP20(goldIntP20);\n-        init(goldIntM31);\n-        testIntM31(goldIntM31);\n-        init(goldIntP31);\n-        testIntP31(goldIntP31);\n-        init(goldIntM32);\n-        testIntM32(goldIntM32);\n-        init(goldIntP32);\n-        testIntP32(goldIntP32);\n-        init(goldIntM63);\n-        testIntM63(goldIntM63);\n-        init(goldIntP63);\n-        testIntP63(goldIntP63);\n-        init(goldIntM64);\n-        testIntM64(goldIntM64);\n-        init(goldIntP64);\n-        testIntP64(goldIntP64);\n-        init(goldIntM65);\n-        testIntM65(goldIntM65);\n-        init(goldIntP65);\n-        testIntP65(goldIntP65);\n-        init(goldIntM128);\n-        testIntM128(goldIntM128);\n-        init(goldIntP128);\n-        testIntP128(goldIntP128);\n-        init(goldIntM129);\n-        testIntM129(goldIntM129);\n-        init(goldIntP129);\n-        testIntP129(goldIntP129);\n-        init(goldIntM192);\n-        testIntM192(goldIntM192);\n-        init(goldIntP192);\n-        testIntP192(goldIntP192);\n-        init(goldLongP0);\n-        testLongP0(goldLongP0);\n-        init(goldLongM1);\n-        testLongM1(goldLongM1);\n-        init(goldLongP1);\n-        testLongP1(goldLongP1);\n-        init(goldLongM2);\n-        testLongM2(goldLongM2);\n-        init(goldLongP2);\n-        testLongP2(goldLongP2);\n-        init(goldLongM3);\n-        testLongM3(goldLongM3);\n-        init(goldLongP3);\n-        testLongP3(goldLongP3);\n-        init(goldLongM4);\n-        testLongM4(goldLongM4);\n-        init(goldLongP4);\n-        testLongP4(goldLongP4);\n-        init(goldLongM7);\n-        testLongM7(goldLongM7);\n-        init(goldLongP7);\n-        testLongP7(goldLongP7);\n-        init(goldLongM8);\n-        testLongM8(goldLongM8);\n-        init(goldLongP8);\n-        testLongP8(goldLongP8);\n-        init(goldLongM14);\n-        testLongM14(goldLongM14);\n-        init(goldLongP14);\n-        testLongP14(goldLongP14);\n-        init(goldLongM16);\n-        testLongM16(goldLongM16);\n-        init(goldLongP16);\n-        testLongP16(goldLongP16);\n-        init(goldLongM18);\n-        testLongM18(goldLongM18);\n-        init(goldLongP18);\n-        testLongP18(goldLongP18);\n-        init(goldLongM20);\n-        testLongM20(goldLongM20);\n-        init(goldLongP20);\n-        testLongP20(goldLongP20);\n-        init(goldLongM31);\n-        testLongM31(goldLongM31);\n-        init(goldLongP31);\n-        testLongP31(goldLongP31);\n-        init(goldLongM32);\n-        testLongM32(goldLongM32);\n-        init(goldLongP32);\n-        testLongP32(goldLongP32);\n-        init(goldLongM63);\n-        testLongM63(goldLongM63);\n-        init(goldLongP63);\n-        testLongP63(goldLongP63);\n-        init(goldLongM64);\n-        testLongM64(goldLongM64);\n-        init(goldLongP64);\n-        testLongP64(goldLongP64);\n-        init(goldLongM65);\n-        testLongM65(goldLongM65);\n-        init(goldLongP65);\n-        testLongP65(goldLongP65);\n-        init(goldLongM128);\n-        testLongM128(goldLongM128);\n-        init(goldLongP128);\n-        testLongP128(goldLongP128);\n-        init(goldLongM129);\n-        testLongM129(goldLongM129);\n-        init(goldLongP129);\n-        testLongP129(goldLongP129);\n-        init(goldLongM192);\n-        testLongM192(goldLongM192);\n-        init(goldLongP192);\n-        testLongP192(goldLongP192);\n-        init(goldShortP0);\n-        testShortP0(goldShortP0);\n-        init(goldShortM1);\n-        testShortM1(goldShortM1);\n-        init(goldShortP1);\n-        testShortP1(goldShortP1);\n-        init(goldShortM2);\n-        testShortM2(goldShortM2);\n-        init(goldShortP2);\n-        testShortP2(goldShortP2);\n-        init(goldShortM3);\n-        testShortM3(goldShortM3);\n-        init(goldShortP3);\n-        testShortP3(goldShortP3);\n-        init(goldShortM4);\n-        testShortM4(goldShortM4);\n-        init(goldShortP4);\n-        testShortP4(goldShortP4);\n-        init(goldShortM7);\n-        testShortM7(goldShortM7);\n-        init(goldShortP7);\n-        testShortP7(goldShortP7);\n-        init(goldShortM8);\n-        testShortM8(goldShortM8);\n-        init(goldShortP8);\n-        testShortP8(goldShortP8);\n-        init(goldShortM14);\n-        testShortM14(goldShortM14);\n-        init(goldShortP14);\n-        testShortP14(goldShortP14);\n-        init(goldShortM16);\n-        testShortM16(goldShortM16);\n-        init(goldShortP16);\n-        testShortP16(goldShortP16);\n-        init(goldShortM18);\n-        testShortM18(goldShortM18);\n-        init(goldShortP18);\n-        testShortP18(goldShortP18);\n-        init(goldShortM20);\n-        testShortM20(goldShortM20);\n-        init(goldShortP20);\n-        testShortP20(goldShortP20);\n-        init(goldShortM31);\n-        testShortM31(goldShortM31);\n-        init(goldShortP31);\n-        testShortP31(goldShortP31);\n-        init(goldShortM32);\n-        testShortM32(goldShortM32);\n-        init(goldShortP32);\n-        testShortP32(goldShortP32);\n-        init(goldShortM63);\n-        testShortM63(goldShortM63);\n-        init(goldShortP63);\n-        testShortP63(goldShortP63);\n-        init(goldShortM64);\n-        testShortM64(goldShortM64);\n-        init(goldShortP64);\n-        testShortP64(goldShortP64);\n-        init(goldShortM65);\n-        testShortM65(goldShortM65);\n-        init(goldShortP65);\n-        testShortP65(goldShortP65);\n-        init(goldShortM128);\n-        testShortM128(goldShortM128);\n-        init(goldShortP128);\n-        testShortP128(goldShortP128);\n-        init(goldShortM129);\n-        testShortM129(goldShortM129);\n-        init(goldShortP129);\n-        testShortP129(goldShortP129);\n-        init(goldShortM192);\n-        testShortM192(goldShortM192);\n-        init(goldShortP192);\n-        testShortP192(goldShortP192);\n-        init(goldCharP0);\n-        testCharP0(goldCharP0);\n-        init(goldCharM1);\n-        testCharM1(goldCharM1);\n-        init(goldCharP1);\n-        testCharP1(goldCharP1);\n-        init(goldCharM2);\n-        testCharM2(goldCharM2);\n-        init(goldCharP2);\n-        testCharP2(goldCharP2);\n-        init(goldCharM3);\n-        testCharM3(goldCharM3);\n-        init(goldCharP3);\n-        testCharP3(goldCharP3);\n-        init(goldCharM4);\n-        testCharM4(goldCharM4);\n-        init(goldCharP4);\n-        testCharP4(goldCharP4);\n-        init(goldCharM7);\n-        testCharM7(goldCharM7);\n-        init(goldCharP7);\n-        testCharP7(goldCharP7);\n-        init(goldCharM8);\n-        testCharM8(goldCharM8);\n-        init(goldCharP8);\n-        testCharP8(goldCharP8);\n-        init(goldCharM14);\n-        testCharM14(goldCharM14);\n-        init(goldCharP14);\n-        testCharP14(goldCharP14);\n-        init(goldCharM16);\n-        testCharM16(goldCharM16);\n-        init(goldCharP16);\n-        testCharP16(goldCharP16);\n-        init(goldCharM18);\n-        testCharM18(goldCharM18);\n-        init(goldCharP18);\n-        testCharP18(goldCharP18);\n-        init(goldCharM20);\n-        testCharM20(goldCharM20);\n-        init(goldCharP20);\n-        testCharP20(goldCharP20);\n-        init(goldCharM31);\n-        testCharM31(goldCharM31);\n-        init(goldCharP31);\n-        testCharP31(goldCharP31);\n-        init(goldCharM32);\n-        testCharM32(goldCharM32);\n-        init(goldCharP32);\n-        testCharP32(goldCharP32);\n-        init(goldCharM63);\n-        testCharM63(goldCharM63);\n-        init(goldCharP63);\n-        testCharP63(goldCharP63);\n-        init(goldCharM64);\n-        testCharM64(goldCharM64);\n-        init(goldCharP64);\n-        testCharP64(goldCharP64);\n-        init(goldCharM65);\n-        testCharM65(goldCharM65);\n-        init(goldCharP65);\n-        testCharP65(goldCharP65);\n-        init(goldCharM128);\n-        testCharM128(goldCharM128);\n-        init(goldCharP128);\n-        testCharP128(goldCharP128);\n-        init(goldCharM129);\n-        testCharM129(goldCharM129);\n-        init(goldCharP129);\n-        testCharP129(goldCharP129);\n-        init(goldCharM192);\n-        testCharM192(goldCharM192);\n-        init(goldCharP192);\n-        testCharP192(goldCharP192);\n-        init(goldByteP0);\n-        testByteP0(goldByteP0);\n-        init(goldByteM1);\n-        testByteM1(goldByteM1);\n-        init(goldByteP1);\n-        testByteP1(goldByteP1);\n-        init(goldByteM2);\n-        testByteM2(goldByteM2);\n-        init(goldByteP2);\n-        testByteP2(goldByteP2);\n-        init(goldByteM3);\n-        testByteM3(goldByteM3);\n-        init(goldByteP3);\n-        testByteP3(goldByteP3);\n-        init(goldByteM4);\n-        testByteM4(goldByteM4);\n-        init(goldByteP4);\n-        testByteP4(goldByteP4);\n-        init(goldByteM7);\n-        testByteM7(goldByteM7);\n-        init(goldByteP7);\n-        testByteP7(goldByteP7);\n-        init(goldByteM8);\n-        testByteM8(goldByteM8);\n-        init(goldByteP8);\n-        testByteP8(goldByteP8);\n-        init(goldByteM14);\n-        testByteM14(goldByteM14);\n-        init(goldByteP14);\n-        testByteP14(goldByteP14);\n-        init(goldByteM16);\n-        testByteM16(goldByteM16);\n-        init(goldByteP16);\n-        testByteP16(goldByteP16);\n-        init(goldByteM18);\n-        testByteM18(goldByteM18);\n-        init(goldByteP18);\n-        testByteP18(goldByteP18);\n-        init(goldByteM20);\n-        testByteM20(goldByteM20);\n-        init(goldByteP20);\n-        testByteP20(goldByteP20);\n-        init(goldByteM31);\n-        testByteM31(goldByteM31);\n-        init(goldByteP31);\n-        testByteP31(goldByteP31);\n-        init(goldByteM32);\n-        testByteM32(goldByteM32);\n-        init(goldByteP32);\n-        testByteP32(goldByteP32);\n-        init(goldByteM63);\n-        testByteM63(goldByteM63);\n-        init(goldByteP63);\n-        testByteP63(goldByteP63);\n-        init(goldByteM64);\n-        testByteM64(goldByteM64);\n-        init(goldByteP64);\n-        testByteP64(goldByteP64);\n-        init(goldByteM65);\n-        testByteM65(goldByteM65);\n-        init(goldByteP65);\n-        testByteP65(goldByteP65);\n-        init(goldByteM128);\n-        testByteM128(goldByteM128);\n-        init(goldByteP128);\n-        testByteP128(goldByteP128);\n-        init(goldByteM129);\n-        testByteM129(goldByteM129);\n-        init(goldByteP129);\n-        testByteP129(goldByteP129);\n-        init(goldByteM192);\n-        testByteM192(goldByteM192);\n-        init(goldByteP192);\n-        testByteP192(goldByteP192);\n-        init(goldFloatP0);\n-        testFloatP0(goldFloatP0);\n-        init(goldFloatM1);\n-        testFloatM1(goldFloatM1);\n-        init(goldFloatP1);\n-        testFloatP1(goldFloatP1);\n-        init(goldFloatM2);\n-        testFloatM2(goldFloatM2);\n-        init(goldFloatP2);\n-        testFloatP2(goldFloatP2);\n-        init(goldFloatM3);\n-        testFloatM3(goldFloatM3);\n-        init(goldFloatP3);\n-        testFloatP3(goldFloatP3);\n-        init(goldFloatM4);\n-        testFloatM4(goldFloatM4);\n-        init(goldFloatP4);\n-        testFloatP4(goldFloatP4);\n-        init(goldFloatM7);\n-        testFloatM7(goldFloatM7);\n-        init(goldFloatP7);\n-        testFloatP7(goldFloatP7);\n-        init(goldFloatM8);\n-        testFloatM8(goldFloatM8);\n-        init(goldFloatP8);\n-        testFloatP8(goldFloatP8);\n-        init(goldFloatM14);\n-        testFloatM14(goldFloatM14);\n-        init(goldFloatP14);\n-        testFloatP14(goldFloatP14);\n-        init(goldFloatM16);\n-        testFloatM16(goldFloatM16);\n-        init(goldFloatP16);\n-        testFloatP16(goldFloatP16);\n-        init(goldFloatM18);\n-        testFloatM18(goldFloatM18);\n-        init(goldFloatP18);\n-        testFloatP18(goldFloatP18);\n-        init(goldFloatM20);\n-        testFloatM20(goldFloatM20);\n-        init(goldFloatP20);\n-        testFloatP20(goldFloatP20);\n-        init(goldFloatM31);\n-        testFloatM31(goldFloatM31);\n-        init(goldFloatP31);\n-        testFloatP31(goldFloatP31);\n-        init(goldFloatM32);\n-        testFloatM32(goldFloatM32);\n-        init(goldFloatP32);\n-        testFloatP32(goldFloatP32);\n-        init(goldFloatM63);\n-        testFloatM63(goldFloatM63);\n-        init(goldFloatP63);\n-        testFloatP63(goldFloatP63);\n-        init(goldFloatM64);\n-        testFloatM64(goldFloatM64);\n-        init(goldFloatP64);\n-        testFloatP64(goldFloatP64);\n-        init(goldFloatM65);\n-        testFloatM65(goldFloatM65);\n-        init(goldFloatP65);\n-        testFloatP65(goldFloatP65);\n-        init(goldFloatM128);\n-        testFloatM128(goldFloatM128);\n-        init(goldFloatP128);\n-        testFloatP128(goldFloatP128);\n-        init(goldFloatM129);\n-        testFloatM129(goldFloatM129);\n-        init(goldFloatP129);\n-        testFloatP129(goldFloatP129);\n-        init(goldFloatM192);\n-        testFloatM192(goldFloatM192);\n-        init(goldFloatP192);\n-        testFloatP192(goldFloatP192);\n-        init(goldDoubleP0);\n-        testDoubleP0(goldDoubleP0);\n-        init(goldDoubleM1);\n-        testDoubleM1(goldDoubleM1);\n-        init(goldDoubleP1);\n-        testDoubleP1(goldDoubleP1);\n-        init(goldDoubleM2);\n-        testDoubleM2(goldDoubleM2);\n-        init(goldDoubleP2);\n-        testDoubleP2(goldDoubleP2);\n-        init(goldDoubleM3);\n-        testDoubleM3(goldDoubleM3);\n-        init(goldDoubleP3);\n-        testDoubleP3(goldDoubleP3);\n-        init(goldDoubleM4);\n-        testDoubleM4(goldDoubleM4);\n-        init(goldDoubleP4);\n-        testDoubleP4(goldDoubleP4);\n-        init(goldDoubleM7);\n-        testDoubleM7(goldDoubleM7);\n-        init(goldDoubleP7);\n-        testDoubleP7(goldDoubleP7);\n-        init(goldDoubleM8);\n-        testDoubleM8(goldDoubleM8);\n-        init(goldDoubleP8);\n-        testDoubleP8(goldDoubleP8);\n-        init(goldDoubleM14);\n-        testDoubleM14(goldDoubleM14);\n-        init(goldDoubleP14);\n-        testDoubleP14(goldDoubleP14);\n-        init(goldDoubleM16);\n-        testDoubleM16(goldDoubleM16);\n-        init(goldDoubleP16);\n-        testDoubleP16(goldDoubleP16);\n-        init(goldDoubleM18);\n-        testDoubleM18(goldDoubleM18);\n-        init(goldDoubleP18);\n-        testDoubleP18(goldDoubleP18);\n-        init(goldDoubleM20);\n-        testDoubleM20(goldDoubleM20);\n-        init(goldDoubleP20);\n-        testDoubleP20(goldDoubleP20);\n-        init(goldDoubleM31);\n-        testDoubleM31(goldDoubleM31);\n-        init(goldDoubleP31);\n-        testDoubleP31(goldDoubleP31);\n-        init(goldDoubleM32);\n-        testDoubleM32(goldDoubleM32);\n-        init(goldDoubleP32);\n-        testDoubleP32(goldDoubleP32);\n-        init(goldDoubleM63);\n-        testDoubleM63(goldDoubleM63);\n-        init(goldDoubleP63);\n-        testDoubleP63(goldDoubleP63);\n-        init(goldDoubleM64);\n-        testDoubleM64(goldDoubleM64);\n-        init(goldDoubleP64);\n-        testDoubleP64(goldDoubleP64);\n-        init(goldDoubleM65);\n-        testDoubleM65(goldDoubleM65);\n-        init(goldDoubleP65);\n-        testDoubleP65(goldDoubleP65);\n-        init(goldDoubleM128);\n-        testDoubleM128(goldDoubleM128);\n-        init(goldDoubleP128);\n-        testDoubleP128(goldDoubleP128);\n-        init(goldDoubleM129);\n-        testDoubleM129(goldDoubleM129);\n-        init(goldDoubleP129);\n-        testDoubleP129(goldDoubleP129);\n-        init(goldDoubleM192);\n-        testDoubleM192(goldDoubleM192);\n-        init(goldDoubleP192);\n-        testDoubleP192(goldDoubleP192);\n-    }\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.compile_framework.*;\n@@ -1280,7 +421,9 @@\n-    public static void main(String args[]) {\n-        TestFramework framework = new TestFramework(TestDependencyOffsets.class);\n-        framework.addFlags(\"-XX:-TieredCompilation\",\n-                           \"-XX:CompileCommand=compileonly,compiler.loopopts.superword.TestDependencyOffsets::init\",\n-                           \"-XX:CompileCommand=compileonly,compiler.loopopts.superword.TestDependencyOffsets::test*\",\n-                           \"-XX:CompileCommand=compileonly,compiler.loopopts.superword.TestDependencyOffsets::verify\",\n-                           \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:LoopUnrollLimit=250\");\n+import jdk.test.lib.Utils;\n+import java.util.Arrays;\n+import java.util.stream.Collectors;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.HashMap;\n+import java.util.Random;\n@@ -1288,0 +431,50 @@\n+\/*\n+ * We want to test SuperWord \/ AutoVectorization with different constant offsets (positive and negative):\n+ *   for (int i = ...) { a[i + offset] = b[i] * 11; }\n+ *\n+ * To test aliasing, we have 3 modes: single-array, aliasing and non-aliasing.\n+ * We test for various primitive types (int, long, short, char, byte, float, double).\n+ * We run all test under various settings of MaxVectorSize and +-AlignVector.\n+ * Finally, we verify the results and check that vectors of the expected length were created (IR rules).\n+ *\/\n+public class TestDependencyOffsets {\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+    private static final int SIZE = 5_000 + RANDOM.nextInt(1000);\n+\n+    \/*\n+     * Template for the inner test class.\n+     *\/\n+    private static String generate(CompileFramework comp, String[] flags) {\n+        return String.format(\"\"\"\n+               import compiler.lib.ir_framework.*;\n+\n+               public class InnerTest {\n+                   private static int SIZE = %s;\n+\n+                   public static void main(String args[]) {\n+                       TestFramework framework = new TestFramework(InnerTest.class);\n+                       framework.addFlags(\"-classpath\", \"%s\");\n+                       framework.addFlags(%s);\n+                       framework.setDefaultWarmup(0);\n+                       framework.start();\n+                   }\n+\n+                   \/\/ ------------------------- Init ---------------------------\n+               %s\n+\n+                   \/\/ ------------------------- Verify -------------------------\n+               %s\n+\n+                   \/\/ ------------------------- Tests --------------------------\n+               %s\n+               }\n+               \"\"\",\n+               SIZE,\n+               comp.getEscapedClassPathOfCompiledClasses(),\n+               Arrays.stream(flags).map(s -> \"\\\"\" + s + \"\\\"\").collect(Collectors.joining(\", \")),\n+               Arrays.stream(TYPES).map(Type::generateInit).collect(Collectors.joining(\"\\n\")),\n+               Arrays.stream(TYPES).map(Type::generateVerify).collect(Collectors.joining(\"\\n\")),\n+               getTests().stream().map(TestDefinition::generate).collect(Collectors.joining(\"\\n\")));\n+    }\n+\n+    public static void main(String[] args) {\n@@ -1292,2097 +485,193 @@\n-        switch (args[0]) {\n-        case \"vanilla-A\":\n-            framework.addFlags(\"-XX:+AlignVector\");\n-            break;\n-        case \"vanilla-U\":\n-            framework.addFlags(\"-XX:-AlignVector\");\n-            break;\n-        case \"sse4-v016-A\":\n-            framework.addFlags(\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=16\", \"-XX:+AlignVector\");\n-            break;\n-        case \"sse4-v016-U\":\n-            framework.addFlags(\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=16\", \"-XX:-AlignVector\");\n-            break;\n-        case \"sse4-v008-A\":\n-            framework.addFlags(\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=8\", \"-XX:+AlignVector\");\n-            break;\n-        case \"sse4-v008-U\":\n-            framework.addFlags(\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=8\", \"-XX:-AlignVector\");\n-            break;\n-        case \"sse4-v004-A\":\n-            framework.addFlags(\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=4\", \"-XX:+AlignVector\");\n-            break;\n-        case \"sse4-v004-U\":\n-            framework.addFlags(\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=4\", \"-XX:-AlignVector\");\n-            break;\n-        case \"sse4-v002-A\":\n-            framework.addFlags(\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=4\", \"-XX:+AlignVector\");\n-            break;\n-        case \"sse4-v002-U\":\n-            framework.addFlags(\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=4\", \"-XX:-AlignVector\");\n-            break;\n-        case \"avx1-v032-A\":\n-            framework.addFlags(\"-XX:UseAVX=1\", \"-XX:MaxVectorSize=32\", \"-XX:+AlignVector\");\n-            break;\n-        case \"avx1-v032-U\":\n-            framework.addFlags(\"-XX:UseAVX=1\", \"-XX:MaxVectorSize=32\", \"-XX:-AlignVector\");\n-            break;\n-        case \"avx1-v016-A\":\n-            framework.addFlags(\"-XX:UseAVX=1\", \"-XX:MaxVectorSize=16\", \"-XX:+AlignVector\");\n-            break;\n-        case \"avx1-v016-U\":\n-            framework.addFlags(\"-XX:UseAVX=1\", \"-XX:MaxVectorSize=16\", \"-XX:-AlignVector\");\n-            break;\n-        case \"avx2-v032-A\":\n-            framework.addFlags(\"-XX:UseAVX=2\", \"-XX:MaxVectorSize=32\", \"-XX:+AlignVector\");\n-            break;\n-        case \"avx2-v032-U\":\n-            framework.addFlags(\"-XX:UseAVX=2\", \"-XX:MaxVectorSize=32\", \"-XX:-AlignVector\");\n-            break;\n-        case \"avx2-v016-A\":\n-            framework.addFlags(\"-XX:UseAVX=2\", \"-XX:MaxVectorSize=16\", \"-XX:+AlignVector\");\n-            break;\n-        case \"avx2-v016-U\":\n-            framework.addFlags(\"-XX:UseAVX=2\", \"-XX:MaxVectorSize=16\", \"-XX:-AlignVector\");\n-            break;\n-        case \"avx512-v064-A\":\n-            framework.addFlags(\"-XX:UseAVX=3\", \"-XX:+UseKNLSetting\", \"-XX:MaxVectorSize=64\", \"-XX:+AlignVector\");\n-            break;\n-        case \"avx512-v064-U\":\n-            framework.addFlags(\"-XX:UseAVX=3\", \"-XX:+UseKNLSetting\", \"-XX:MaxVectorSize=64\", \"-XX:-AlignVector\");\n-            break;\n-        case \"avx512-v032-A\":\n-            framework.addFlags(\"-XX:UseAVX=3\", \"-XX:+UseKNLSetting\", \"-XX:MaxVectorSize=32\", \"-XX:+AlignVector\");\n-            break;\n-        case \"avx512-v032-U\":\n-            framework.addFlags(\"-XX:UseAVX=3\", \"-XX:+UseKNLSetting\", \"-XX:MaxVectorSize=32\", \"-XX:-AlignVector\");\n-            break;\n-        case \"avx512bw-v064-A\":\n-            framework.addFlags(\"-XX:UseAVX=3\", \"-XX:MaxVectorSize=64\", \"-XX:+AlignVector\");\n-            break;\n-        case \"avx512bw-v064-U\":\n-            framework.addFlags(\"-XX:UseAVX=3\", \"-XX:MaxVectorSize=64\", \"-XX:-AlignVector\");\n-            break;\n-        case \"avx512bw-v032-A\":\n-            framework.addFlags(\"-XX:UseAVX=3\", \"-XX:MaxVectorSize=32\", \"-XX:+AlignVector\");\n-            break;\n-        case \"avx512bw-v032-U\":\n-            framework.addFlags(\"-XX:UseAVX=3\", \"-XX:MaxVectorSize=32\", \"-XX:-AlignVector\");\n-            break;\n-        case \"vec-v064-A\":\n-            framework.addFlags(\"-XX:MaxVectorSize=64\", \"-XX:+AlignVector\");\n-            break;\n-        case \"vec-v064-U\":\n-            framework.addFlags(\"-XX:MaxVectorSize=64\", \"-XX:-AlignVector\");\n-            break;\n-        case \"vec-v032-A\":\n-            framework.addFlags(\"-XX:MaxVectorSize=32\", \"-XX:+AlignVector\");\n-            break;\n-        case \"vec-v032-U\":\n-            framework.addFlags(\"-XX:MaxVectorSize=32\", \"-XX:-AlignVector\");\n-            break;\n-        case \"vec-v016-A\":\n-            framework.addFlags(\"-XX:MaxVectorSize=16\", \"-XX:+AlignVector\");\n-            break;\n-        case \"vec-v016-U\":\n-            framework.addFlags(\"-XX:MaxVectorSize=16\", \"-XX:-AlignVector\");\n-            break;\n-        case \"vec-v008-A\":\n-            framework.addFlags(\"-XX:MaxVectorSize=8\", \"-XX:+AlignVector\");\n-            break;\n-        case \"vec-v008-U\":\n-            framework.addFlags(\"-XX:MaxVectorSize=8\", \"-XX:-AlignVector\");\n-            break;\n-        case \"vec-v004-A\":\n-            framework.addFlags(\"-XX:MaxVectorSize=4\", \"-XX:+AlignVector\");\n-            break;\n-        case \"vec-v004-U\":\n-            framework.addFlags(\"-XX:MaxVectorSize=4\", \"-XX:-AlignVector\");\n-            break;\n-        default:\n-            throw new RuntimeException(\"Test argument not recognized: \" + args[0]);\n-        }\n-        framework.start();\n-    }\n-\n-    \/\/ ------------------- Tests -------------------\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP0(int[] data) {\n-        for (int j = 0; j < RANGE; j++) {\n-            data[j + 0] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP0\")\n-    @Warmup(0)\n-    public static void runIntP0() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP0(data);\n-        verify(\"testIntP0\", data, goldIntP0);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM1(int[] data) {\n-        for (int j = 1; j < RANGE; j++) {\n-            data[j + -1] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntM1\")\n-    @Warmup(0)\n-    public static void runIntM1() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM1(data);\n-        verify(\"testIntM1\", data, goldIntM1);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP1(int[] data) {\n-        for (int j = 0; j < RANGE - 1; j++) {\n-            data[j + 1] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP1\")\n-    @Warmup(0)\n-    public static void runIntP1() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP1(data);\n-        verify(\"testIntP1\", data, goldIntP1);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM2(int[] data) {\n-        for (int j = 2; j < RANGE; j++) {\n-            data[j + -2] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntM2\")\n-    @Warmup(0)\n-    public static void runIntM2() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM2(data);\n-        verify(\"testIntM2\", data, goldIntM2);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP2(int[] data) {\n-        for (int j = 0; j < RANGE - 2; j++) {\n-            data[j + 2] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP2\")\n-    @Warmup(0)\n-    public static void runIntP2() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP2(data);\n-        verify(\"testIntP2\", data, goldIntP2);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM3(int[] data) {\n-        for (int j = 3; j < RANGE; j++) {\n-            data[j + -3] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntM3\")\n-    @Warmup(0)\n-    public static void runIntM3() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM3(data);\n-        verify(\"testIntM3\", data, goldIntM3);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    \/\/   positive byte_offset 12 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    \/\/   positive byte_offset 12 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    \/\/   positive byte_offset 12 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    \/\/   positive byte_offset 12 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 12 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP3(int[] data) {\n-        for (int j = 0; j < RANGE - 3; j++) {\n-            data[j + 3] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP3\")\n-    @Warmup(0)\n-    public static void runIntP3() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP3(data);\n-        verify(\"testIntP3\", data, goldIntP3);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM4(int[] data) {\n-        for (int j = 4; j < RANGE; j++) {\n-            data[j + -4] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntM4\")\n-    @Warmup(0)\n-    public static void runIntM4() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM4(data);\n-        verify(\"testIntM4\", data, goldIntM4);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP4(int[] data) {\n-        for (int j = 0; j < RANGE - 4; j++) {\n-            data[j + 4] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP4\")\n-    @Warmup(0)\n-    public static void runIntP4() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP4(data);\n-        verify(\"testIntP4\", data, goldIntP4);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM7(int[] data) {\n-        for (int j = 7; j < RANGE; j++) {\n-            data[j + -7] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntM7\")\n-    @Warmup(0)\n-    public static void runIntM7() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM7(data);\n-        verify(\"testIntM7\", data, goldIntM7);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    \/\/   positive byte_offset 28 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    \/\/   positive byte_offset 28 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 28 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP7(int[] data) {\n-        for (int j = 0; j < RANGE - 7; j++) {\n-            data[j + 7] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP7\")\n-    @Warmup(0)\n-    public static void runIntP7() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP7(data);\n-        verify(\"testIntP7\", data, goldIntP7);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM8(int[] data) {\n-        for (int j = 8; j < RANGE; j++) {\n-            data[j + -8] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntM8\")\n-    @Warmup(0)\n-    public static void runIntM8() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM8(data);\n-        verify(\"testIntM8\", data, goldIntM8);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    \/\/   positive byte_offset 32 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 32 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP8(int[] data) {\n-        for (int j = 0; j < RANGE - 8; j++) {\n-            data[j + 8] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP8\")\n-    @Warmup(0)\n-    public static void runIntP8() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP8(data);\n-        verify(\"testIntP8\", data, goldIntP8);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM14(int[] data) {\n-        for (int j = 14; j < RANGE; j++) {\n-            data[j + -14] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntM14\")\n-    @Warmup(0)\n-    public static void runIntM14() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM14(data);\n-        verify(\"testIntM14\", data, goldIntM14);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    \/\/   positive byte_offset 56 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 56\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 56\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 56 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 56\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 56\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP14(int[] data) {\n-        for (int j = 0; j < RANGE - 14; j++) {\n-            data[j + 14] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP14\")\n-    @Warmup(0)\n-    public static void runIntP14() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP14(data);\n-        verify(\"testIntP14\", data, goldIntP14);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM16(int[] data) {\n-        for (int j = 16; j < RANGE; j++) {\n-            data[j + -16] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntM16\")\n-    @Warmup(0)\n-    public static void runIntM16() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM16(data);\n-        verify(\"testIntM16\", data, goldIntM16);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 64 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 64\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 64\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP16(int[] data) {\n-        for (int j = 0; j < RANGE - 16; j++) {\n-            data[j + 16] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP16\")\n-    @Warmup(0)\n-    public static void runIntP16() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP16(data);\n-        verify(\"testIntP16\", data, goldIntP16);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM18(int[] data) {\n-        for (int j = 18; j < RANGE; j++) {\n-            data[j + -18] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntM18\")\n-    @Warmup(0)\n-    public static void runIntM18() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM18(data);\n-        verify(\"testIntM18\", data, goldIntM18);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 72 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 72\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 72\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP18(int[] data) {\n-        for (int j = 0; j < RANGE - 18; j++) {\n-            data[j + 18] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP18\")\n-    @Warmup(0)\n-    public static void runIntP18() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP18(data);\n-        verify(\"testIntP18\", data, goldIntP18);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM20(int[] data) {\n-        for (int j = 20; j < RANGE; j++) {\n-            data[j + -20] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntM20\")\n-    @Warmup(0)\n-    public static void runIntM20() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM20(data);\n-        verify(\"testIntM20\", data, goldIntM20);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 80 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 80\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 80\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP20(int[] data) {\n-        for (int j = 0; j < RANGE - 20; j++) {\n-            data[j + 20] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP20\")\n-    @Warmup(0)\n-    public static void runIntP20() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP20(data);\n-        verify(\"testIntP20\", data, goldIntP20);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM31(int[] data) {\n-        for (int j = 31; j < RANGE; j++) {\n-            data[j + -31] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntM31\")\n-    @Warmup(0)\n-    public static void runIntM31() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM31(data);\n-        verify(\"testIntM31\", data, goldIntM31);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 124 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 124\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 124\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP31(int[] data) {\n-        for (int j = 0; j < RANGE - 31; j++) {\n-            data[j + 31] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP31\")\n-    @Warmup(0)\n-    public static void runIntP31() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP31(data);\n-        verify(\"testIntP31\", data, goldIntP31);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM32(int[] data) {\n-        for (int j = 32; j < RANGE; j++) {\n-            data[j + -32] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntM32\")\n-    @Warmup(0)\n-    public static void runIntM32() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM32(data);\n-        verify(\"testIntM32\", data, goldIntM32);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 128 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 128\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 128\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP32(int[] data) {\n-        for (int j = 0; j < RANGE - 32; j++) {\n-            data[j + 32] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP32\")\n-    @Warmup(0)\n-    public static void runIntP32() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP32(data);\n-        verify(\"testIntP32\", data, goldIntP32);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM63(int[] data) {\n-        for (int j = 63; j < RANGE; j++) {\n-            data[j + -63] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntM63\")\n-    @Warmup(0)\n-    public static void runIntM63() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM63(data);\n-        verify(\"testIntM63\", data, goldIntM63);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 252 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 252\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 252\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP63(int[] data) {\n-        for (int j = 0; j < RANGE - 63; j++) {\n-            data[j + 63] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP63\")\n-    @Warmup(0)\n-    public static void runIntP63() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP63(data);\n-        verify(\"testIntP63\", data, goldIntP63);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM64(int[] data) {\n-        for (int j = 64; j < RANGE; j++) {\n-            data[j + -64] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntM64\")\n-    @Warmup(0)\n-    public static void runIntM64() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM64(data);\n-        verify(\"testIntM64\", data, goldIntM64);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP64(int[] data) {\n-        for (int j = 0; j < RANGE - 64; j++) {\n-            data[j + 64] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP64\")\n-    @Warmup(0)\n-    public static void runIntP64() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP64(data);\n-        verify(\"testIntP64\", data, goldIntP64);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM65(int[] data) {\n-        for (int j = 65; j < RANGE; j++) {\n-            data[j + -65] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntM65\")\n-    @Warmup(0)\n-    public static void runIntM65() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM65(data);\n-        verify(\"testIntM65\", data, goldIntM65);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP65(int[] data) {\n-        for (int j = 0; j < RANGE - 65; j++) {\n-            data[j + 65] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP65\")\n-    @Warmup(0)\n-    public static void runIntP65() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP65(data);\n-        verify(\"testIntP65\", data, goldIntP65);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM128(int[] data) {\n-        for (int j = 128; j < RANGE; j++) {\n-            data[j + -128] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntM128\")\n-    @Warmup(0)\n-    public static void runIntM128() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM128(data);\n-        verify(\"testIntM128\", data, goldIntM128);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP128(int[] data) {\n-        for (int j = 0; j < RANGE - 128; j++) {\n-            data[j + 128] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP128\")\n-    @Warmup(0)\n-    public static void runIntP128() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP128(data);\n-        verify(\"testIntP128\", data, goldIntP128);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM129(int[] data) {\n-        for (int j = 129; j < RANGE; j++) {\n-            data[j + -129] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntM129\")\n-    @Warmup(0)\n-    public static void runIntM129() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM129(data);\n-        verify(\"testIntM129\", data, goldIntM129);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP129(int[] data) {\n-        for (int j = 0; j < RANGE - 129; j++) {\n-            data[j + 129] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP129\")\n-    @Warmup(0)\n-    public static void runIntP129() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP129(data);\n-        verify(\"testIntP129\", data, goldIntP129);\n-    }\n+        String[] flags = switch (args[0]) {\n+            case \"vanilla-A\" -> new String[] {\"-XX:+AlignVector\"};\n+            case \"vanilla-U\" -> new String[] {\"-XX:-AlignVector\"};\n+            case \"sse4-v016-A\" -> new String[] {\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=16\", \"-XX:+AlignVector\"};\n+            case \"sse4-v016-U\" -> new String[] {\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=16\", \"-XX:-AlignVector\"};\n+            case \"sse4-v008-A\" -> new String[] {\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=8\", \"-XX:+AlignVector\"};\n+            case \"sse4-v008-U\" -> new String[] {\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=8\", \"-XX:-AlignVector\"};\n+            case \"sse4-v004-A\" -> new String[] {\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=4\", \"-XX:+AlignVector\"};\n+            case \"sse4-v004-U\" -> new String[] {\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=4\", \"-XX:-AlignVector\"};\n+            case \"avx1-v032-A\" -> new String[] {\"-XX:UseAVX=1\", \"-XX:MaxVectorSize=32\", \"-XX:+AlignVector\"};\n+            case \"avx1-v032-U\" -> new String[] {\"-XX:UseAVX=1\", \"-XX:MaxVectorSize=32\", \"-XX:-AlignVector\"};\n+            case \"avx1-v016-A\" -> new String[] {\"-XX:UseAVX=1\", \"-XX:MaxVectorSize=16\", \"-XX:+AlignVector\"};\n+            case \"avx1-v016-U\" -> new String[] {\"-XX:UseAVX=1\", \"-XX:MaxVectorSize=16\", \"-XX:-AlignVector\"};\n+            case \"avx2-v032-A\" -> new String[] {\"-XX:UseAVX=2\", \"-XX:MaxVectorSize=32\", \"-XX:+AlignVector\"};\n+            case \"avx2-v032-U\" -> new String[] {\"-XX:UseAVX=2\", \"-XX:MaxVectorSize=32\", \"-XX:-AlignVector\"};\n+            case \"avx2-v016-A\" -> new String[] {\"-XX:UseAVX=2\", \"-XX:MaxVectorSize=16\", \"-XX:+AlignVector\"};\n+            case \"avx2-v016-U\" -> new String[] {\"-XX:UseAVX=2\", \"-XX:MaxVectorSize=16\", \"-XX:-AlignVector\"};\n+            case \"avx512-v064-A\" -> new String[] {\"-XX:UseAVX=3\", \"-XX:+UseKNLSetting\", \"-XX:MaxVectorSize=64\", \"-XX:+AlignVector\"};\n+            case \"avx512-v064-U\" -> new String[] {\"-XX:UseAVX=3\", \"-XX:+UseKNLSetting\", \"-XX:MaxVectorSize=64\", \"-XX:-AlignVector\"};\n+            case \"avx512-v032-A\" -> new String[] {\"-XX:UseAVX=3\", \"-XX:+UseKNLSetting\", \"-XX:MaxVectorSize=32\", \"-XX:+AlignVector\"};\n+            case \"avx512-v032-U\" -> new String[] {\"-XX:UseAVX=3\", \"-XX:+UseKNLSetting\", \"-XX:MaxVectorSize=32\", \"-XX:-AlignVector\"};\n+            case \"avx512bw-v064-A\" -> new String[] {\"-XX:UseAVX=3\", \"-XX:MaxVectorSize=64\", \"-XX:+AlignVector\"};\n+            case \"avx512bw-v064-U\" -> new String[] {\"-XX:UseAVX=3\", \"-XX:MaxVectorSize=64\", \"-XX:-AlignVector\"};\n+            case \"avx512bw-v032-A\" -> new String[] {\"-XX:UseAVX=3\", \"-XX:MaxVectorSize=32\", \"-XX:+AlignVector\"};\n+            case \"avx512bw-v032-U\" -> new String[] {\"-XX:UseAVX=3\", \"-XX:MaxVectorSize=32\", \"-XX:-AlignVector\"};\n+            case \"vec-v064-A\" -> new String[] {\"-XX:MaxVectorSize=64\", \"-XX:+AlignVector\"};\n+            case \"vec-v064-U\" -> new String[] {\"-XX:MaxVectorSize=64\", \"-XX:-AlignVector\"};\n+            case \"vec-v032-A\" -> new String[] {\"-XX:MaxVectorSize=32\", \"-XX:+AlignVector\"};\n+            case \"vec-v032-U\" -> new String[] {\"-XX:MaxVectorSize=32\", \"-XX:-AlignVector\"};\n+            case \"vec-v016-A\" -> new String[] {\"-XX:MaxVectorSize=16\", \"-XX:+AlignVector\"};\n+            case \"vec-v016-U\" -> new String[] {\"-XX:MaxVectorSize=16\", \"-XX:-AlignVector\"};\n+            case \"vec-v008-A\" -> new String[] {\"-XX:MaxVectorSize=8\", \"-XX:+AlignVector\"};\n+            case \"vec-v008-U\" -> new String[] {\"-XX:MaxVectorSize=8\", \"-XX:-AlignVector\"};\n+            case \"vec-v004-A\" -> new String[] {\"-XX:MaxVectorSize=4\", \"-XX:+AlignVector\"};\n+            case \"vec-v004-U\" -> new String[] {\"-XX:MaxVectorSize=4\", \"-XX:-AlignVector\"};\n+            default -> { throw new RuntimeException(\"Test argument not recognized: \" + args[0]); }\n+        };\n+\n+        CompileFramework comp = new CompileFramework();\n+        long time0 = System.currentTimeMillis();\n+        comp.addJavaSourceCode(\"InnerTest\", generate(comp, flags));\n+        long time1 = System.currentTimeMillis();\n+        comp.compile();\n+        long time2 = System.currentTimeMillis();\n+        comp.invoke(\"InnerTest\", \"main\", new Object[] {null});\n+        long time3 = System.currentTimeMillis();\n+        System.out.println(\"Generate: \" + (time1 - time0));\n+        System.out.println(\"Compile:  \" + (time2 - time1));\n+        System.out.println(\"Run:      \" + (time3 - time2));\n+    }\n+\n+    static record Type (String name, int size, String value, String operator, String irNode) {\n+        String letter() {\n+            return name.substring(0, 1).toUpperCase();\n+        }\n+\n+        \/*\n+         * Template for init method generation.\n+         *\/\n+        String generateInit() {\n+            return String.format(\"\"\"\n+                       static void init(%s[] a, %s[] b) {\n+                           for (int i = 0; i < SIZE; i++) {\n+                               a[i] = (%s)(2 * i);\n+                               b[i] = (%s)(3 * i);\n+                           }\n+                       }\n+                   \"\"\",\n+                   name, name, name, name);\n+        }\n+\n+        \/*\n+         * Template for verify method generation.\n+         *\/\n+        String generateVerify() {\n+            return String.format(\"\"\"\n+                       static void verify(String context, %s[] aTest, %s[] bTest, %s[] aGold, %s[] bGold) {\n+                           for (int i = 0; i < SIZE; i++) {\n+                               if (aTest[i] != aGold[i] || bTest[i] != bGold[i]) {\n+                                   throw new RuntimeException(\"Wrong result in \" + context + \" at i=\" + i + \": \" +\n+                                                              \"aTest=\" + aTest[i] + \", aGold=\" + aGold[i] +\n+                                                              \"bTest=\" + bTest[i] + \", bGold=\" + bGold[i]);\n+                               }\n+                           }\n+                       }\n+                   \"\"\",\n+                   name, name, name, name);\n+        }\n+    }\n+\n+    static final Type[] TYPES = new Type[] {\n+        new Type(\"int\",    4, \"-11\",    \"*\", \"MUL_VI\"),\n+        new Type(\"long\",   8, \"-11\",    \"+\", \"ADD_VL\"), \/\/ aarch64 NEON does not support MulVL\n+        new Type(\"short\",  2, \"-11\",    \"*\", \"MUL_VS\"),\n+        new Type(\"char\",   2, \"-11\",    \"*\", \"MUL_VS\"), \/\/ char behaves like short\n+        new Type(\"byte\",   1, \"11\",     \"*\", \"MUL_VB\"),\n+        new Type(\"float\",  4, \"1.001f\", \"*\", \"MUL_VF\"),\n+        new Type(\"double\", 8, \"1.001\",  \"*\", \"MUL_VD\"),\n+    };\n+\n+    \/*\n+     * Every CPU can define its own Matcher::min_vector_size. This happens to be different for\n+     * our targeted platforms: x86 \/ sse4.1 and aarch64 \/ asimd.\n+     *\/\n+    static record CPUMinVectorWidth (String applyIfCPUFeature, int minVectorWidth) {}\n+\n+    static final String SSE4_ASIMD = \"        applyIfCPUFeatureOr = {\\\"sse4.1\\\", \\\"true\\\", \\\"asimd\\\", \\\"true\\\"})\\n\";\n+    static final String SSE4       = \"        applyIfCPUFeature = {\\\"sse4.1\\\", \\\"true\\\"})\\n\";\n+    static final String ASIMD      = \"        applyIfCPUFeature = {\\\"asimd\\\", \\\"true\\\"})\\n\";\n+\n+    static CPUMinVectorWidth[] getCPUMinVectorWidth(String typeName) {\n+        return switch (typeName) {\n+            case \"byte\"   -> new CPUMinVectorWidth[]{new CPUMinVectorWidth(SSE4_ASIMD, 4 )};\n+            case \"char\"   -> new CPUMinVectorWidth[]{new CPUMinVectorWidth(SSE4,       4 ),\n+                                                     new CPUMinVectorWidth(ASIMD,      8 )};\n+            case \"short\"  -> new CPUMinVectorWidth[]{new CPUMinVectorWidth(SSE4,       4 ),\n+                                                     new CPUMinVectorWidth(ASIMD,      8 )};\n+            case \"int\"    -> new CPUMinVectorWidth[]{new CPUMinVectorWidth(SSE4_ASIMD, 8 )};\n+            case \"long\"   -> new CPUMinVectorWidth[]{new CPUMinVectorWidth(SSE4_ASIMD, 16)};\n+            case \"float\"  -> new CPUMinVectorWidth[]{new CPUMinVectorWidth(SSE4_ASIMD, 8 )};\n+            case \"double\" -> new CPUMinVectorWidth[]{new CPUMinVectorWidth(SSE4_ASIMD, 16)};\n+            default -> { throw new RuntimeException(\"type not supported: \" + typeName); }\n+        };\n+    }\n+\n+    static List<Integer> getOffsets() {\n+        \/\/ Some carefully hand-picked values\n+        int[] always = new int[] {\n+            0,\n+            -1, 1,\n+            -2, 2,     \/\/ 2^1\n+            -3, 3,\n+            -4, 4,     \/\/ 2^2\n+            -7, 7,\n+            -8, 8,     \/\/ 2^3\n+            -14, 14,\n+            -16, 16,   \/\/ 2^4\n+            -18, 18,\n+            -20, 20,\n+            -31, 31,\n+            -32, 32,   \/\/ 2^5\n+            -63, 63,\n+            -64, 64,   \/\/ 2^6\n+            -65, 65,\n+            -128, 128, \/\/ 2^7\n+            -129, 129,\n+            -192, 192, \/\/ 3 * 64\n+        };\n+        Set<Integer> set = Arrays.stream(always).boxed().collect(Collectors.toSet());\n+\n+        \/\/ Sample some random values on an exponential scale\n+        for (int i = 0; i < 10; i++) {\n+            int base = 4 << i;\n+            int offset = base + RANDOM.nextInt(base);\n+            set.add(offset);\n+            set.add(-offset);\n+        }\n+\n+        return new ArrayList<Integer>(set);\n+    }\n+\n+    static record TestDefinition (int id, Type type, int offset) {\n+\n+        \/*\n+         * Template for test generation, together with its static variables, static initialization,\n+         * @IR rules and @Run method (initialization, execution and verification).\n+         *\/\n+        String generate() {\n+            int start = offset >= 0 ? 0 : -offset;\n+            String end = offset >= 0 ? \"SIZE - \" + offset : \"SIZE\";\n+\n+            String aliasingComment;\n+            String secondArgument;\n+            String loadFrom;\n+            switch (RANDOM.nextInt(3)) {\n+            case 0: \/\/ a[i + offset] = a[i]\n+                aliasingComment = \"single-array\";\n+                secondArgument = \"a\";\n+                loadFrom = \"a\";\n+                break;\n+            case 1: \/\/ a[i + offset] = b[i], but a and b alias, i.e. at runtime a == b.\n+                aliasingComment = \"aliasing\";\n+                secondArgument = \"a\";\n+                loadFrom = \"b\";\n+                break;\n+            case 2: \/\/ a[i + offset] = b[i], and a and b do not alias, i.e. at runtime a != b.\n+                aliasingComment = \"non-aliasing\";\n+                secondArgument = \"b\";\n+                loadFrom = \"b\";\n+                break;\n+            default:\n+                throw new RuntimeException(\"impossible\");\n+            }\n@@ -3390,44 +679,130 @@\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM192(int[] data) {\n-        for (int j = 192; j < RANGE; j++) {\n-            data[j + -192] = (int)(data[j] * (int)-11);\n+            return String.format(\"\"\"\n+                       \/\/ test%d: type=%s, offset=%d, mode=%s\n+                       static %s[] aGold%d = new %s[SIZE];\n+                       static %s[] bGold%d = new %s[SIZE];\n+                       static %s[] aTest%d = new %s[SIZE];\n+                       static %s[] bTest%d = new %s[SIZE];\n+\n+                       static {\n+                           init(aGold%d, bGold%d);\n+                           test%d(aGold%d, %sGold%d);\n+                       }\n+\n+                       @Test\n+                   %s\n+                       public static void test%d(%s[] a, %s[] b) {\n+                           for (int i = %d; i < %s; i++) {\n+                               a[i + %d] = (%s)(%s[i] %s %s);\n+                           }\n+                       }\n+\n+                       @Run(test = \"test%s\")\n+                       public static void run%s() {\n+                           init(aTest%d, bTest%d);\n+                           test%d(aTest%d, %sTest%d);\n+                           verify(\"test%d\", aTest%d, bTest%d, aGold%d, bGold%d);\n+                       }\n+                   \"\"\",\n+                   \/\/ title\n+                   id, type.name, offset, aliasingComment,\n+                   \/\/ static\n+                   type.name, id, type.name,\n+                   type.name, id, type.name,\n+                   type.name, id, type.name,\n+                   type.name, id, type.name,\n+                   id, id, id, id, secondArgument, id,\n+                   \/\/ IR rules\n+                   generateIRRules(),\n+                   \/\/ test\n+                   id, type.name, type.name,\n+                   start, end,\n+                   offset, type.name, loadFrom, type.operator, type.value,\n+                   \/\/ run\n+                   id, id, id, id, id, id, secondArgument, id, id, id, id, id, id);\n+        }\n+\n+        \/*\n+         * We generate a number of IR rules for every TestDefinition. If an what kind of vectorization we\n+         * expect depends on AlignVector and MaxVectorSize, as well as the byteOffset between the load and\n+         * store.\n+         *\/\n+        String generateIRRules() {\n+            StringBuilder builder = new StringBuilder();\n+\n+            for (CPUMinVectorWidth cm : getCPUMinVectorWidth(type.name)) {\n+                String applyIfCPUFeature = cm.applyIfCPUFeature;\n+                int minVectorWidth = cm.minVectorWidth;\n+                builder.append(\"    \/\/ minVectorWidth = \" + minVectorWidth + \"\\n\");\n+\n+                int byteOffset = offset * type.size;\n+                builder.append(\"    \/\/ byteOffset = \" + byteOffset + \" = offset * type.size\\n\");\n+\n+                \/\/ In a store-forward case, later iterations load from stores of previous iterations.\n+                \/\/ If the offset is too small, that leads to cyclic dependencies in the vectors. Hence,\n+                \/\/ we use shorter vectors to avoid cycles and still vectorize. Vector lengths have to\n+                \/\/ be powers-of-2, and smaller or equal to the byteOffset. So we round down to the next\n+                \/\/ power of two.\n+                int infinity = 256; \/\/ No vector size is ever larger than this.\n+                int maxVectorWidth = infinity; \/\/ no constraint by default\n+                if (0 < byteOffset && byteOffset < maxVectorWidth) {\n+                    int log2 = 31 - Integer.numberOfLeadingZeros(offset);\n+                    int floorPow2 = 1 << log2;\n+                    maxVectorWidth = Math.min(maxVectorWidth, floorPow2 * type.size);\n+                    builder.append(\"    \/\/ Vectors must have at most \" + floorPow2 +\n+                                   \" elements: maxVectorWidth = \" + maxVectorWidth +\n+                                   \" to avoid cyclic dependency.\\n\");\n+                }\n+\n+                \/\/ Rule 1: No strict alignment: -XX:-AlignVector\n+                IRRule r1 = new IRRule(type, type.irNode, applyIfCPUFeature);\n+                r1.addApplyIf(\"\\\"AlignVector\\\", \\\"false\\\"\");\n+                r1.addApplyIf(\"\\\"MaxVectorSize\\\", \\\">=\" + minVectorWidth + \"\\\"\");\n+\n+                if (maxVectorWidth < minVectorWidth) {\n+                    builder.append(\"    \/\/ maxVectorWidth < minVectorWidth -> expect no vectorization.\\n\");\n+                    r1.setNegative();\n+                } else if (maxVectorWidth < infinity) {\n+                    r1.setSize(\"min(\" + (maxVectorWidth \/ type.size) + \",max_\" + type.name + \")\");\n+                }\n+                r1.generate(builder);\n+\n+                \/\/ Rule 2: strict alignment: -XX:+AlignVector\n+                IRRule r2 = new IRRule(type, type.irNode, applyIfCPUFeature);\n+                r2.addApplyIf(\"\\\"AlignVector\\\", \\\"true\\\"\");\n+                r2.addApplyIf(\"\\\"MaxVectorSize\\\", \\\">=\" + minVectorWidth + \"\\\"\");\n+\n+                \/\/ All vectors must be aligned by some alignment width aw:\n+                \/\/   aw = min(actualVectorWidth, ObjectAlignmentInBytes)\n+                \/\/ The runtime aw must thus lay between these two values:\n+                \/\/   awMin <= aw <= awMax\n+                int awMin = Math.min(minVectorWidth, 8);\n+                int awMax = 8;\n+\n+                \/\/ We must align both the load and the store, thus we must also be able to align\n+                \/\/ for the difference of the two, i.e. byteOffset must be a multiple of aw:\n+                \/\/   byteOffset % aw == 0\n+                \/\/ We don't know the aw, only awMin and awMax. But:\n+                \/\/   byteOffset % awMax == 0      ->      byteOffset % aw == 0\n+                \/\/   byteOffset % awMin != 0      ->      byteOffset % aw != 0\n+                builder.append(\"    \/\/ awMin = \" + awMin + \" = min(minVectorWidth, 8)\\n\");\n+                builder.append(\"    \/\/ awMax = \" + awMax + \"\\n\");\n+\n+                if (byteOffset % awMax == 0) {\n+                    builder.append(\"    \/\/ byteOffset % awMax == 0   -> always trivially aligned\\n\");\n+                } else if (byteOffset % awMin != 0) {\n+                    builder.append(\"    \/\/ byteOffset % awMin != 0   -> can never align -> expect no vectorization.\\n\");\n+                    r2.setNegative();\n+                } else {\n+                    builder.append(\"    \/\/ Alignment unknown -> disable IR rule.\\n\");\n+                    r2.disable();\n+                }\n+\n+                if (maxVectorWidth < minVectorWidth) {\n+                    builder.append(\"    \/\/ Not at least 2 elements or 4 bytes -> expect no vectorization.\\n\");\n+                    r2.setNegative();\n+                } else if (maxVectorWidth < infinity) {\n+                    r2.setSize(\"min(\" + (maxVectorWidth \/ type.size) + \",max_\" + type.name + \")\");\n+                }\n+                r2.generate(builder);\n+            }\n+            return builder.toString();\n@@ -3437,8 +812,2 @@\n-    @Run(test = \"testIntM192\")\n-    @Warmup(0)\n-    public static void runIntM192() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM192(data);\n-        verify(\"testIntM192\", data, goldIntM192);\n-    }\n+    static List<TestDefinition> getTests() {\n+        List<TestDefinition> tests = new ArrayList<>();\n@@ -3446,44 +815,6 @@\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP192(int[] data) {\n-        for (int j = 0; j < RANGE - 192; j++) {\n-            data[j + 192] = (int)(data[j] * (int)-11);\n+        \/\/ Cross product of all types and offsets.\n+        int id = 0;\n+        for (Type type : TYPES) {\n+            for (int offset : getOffsets()) {\n+                tests.add(new TestDefinition(id++, type, offset));\n+            }\n@@ -3491,1 +822,0 @@\n-    }\n@@ -3493,7 +823,1 @@\n-    @Run(test = \"testIntP192\")\n-    @Warmup(0)\n-    public static void runIntP192() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP192(data);\n-        verify(\"testIntP192\", data, goldIntP192);\n+        return tests;\n@@ -3502,55 +826,8 @@\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP0(long[] data) {\n-        for (int j = 0; j < RANGE; j++) {\n-            data[j + 0] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongP0\")\n-    @Warmup(0)\n-    public static void runLongP0() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP0(data);\n-        verify(\"testLongP0\", data, goldLongP0);\n-    }\n+    static class IRRule {\n+        Type type;\n+        String irNode;\n+        String applyIfCPUFeature;\n+        String size;\n+        boolean isEnabled;\n+        boolean isPositiveRule;\n+        ArrayList<String> applyIf;\n@@ -3558,44 +835,8 @@\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM1(long[] data) {\n-        for (int j = 1; j < RANGE; j++) {\n-            data[j + -1] = (long)(data[j] + (long)-11);\n+        IRRule(Type type, String irNode, String applyIfCPUFeature) {\n+            this.type = type;\n+            this.irNode = irNode;\n+            this.applyIfCPUFeature = applyIfCPUFeature;\n+            this.size = null;\n+            this.isPositiveRule = true;\n+            this.isEnabled = true;\n+            this.applyIf = new ArrayList<String>();\n@@ -3603,10 +844,0 @@\n-    }\n-\n-    @Run(test = \"testLongM1\")\n-    @Warmup(0)\n-    public static void runLongM1() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM1(data);\n-        verify(\"testLongM1\", data, goldLongM1);\n-    }\n@@ -3614,29 +845,2 @@\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect alignment.\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect alignment.\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect alignment.\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect alignment.\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect alignment.\n-    \/\/   No positive IR rule: conditions impossible.\n-    public static void testLongP1(long[] data) {\n-        for (int j = 0; j < RANGE - 1; j++) {\n-            data[j + 1] = (long)(data[j] + (long)-11);\n+        void setSize(String size) {\n+            this.size = size;\n@@ -3644,1 +848,0 @@\n-    }\n@@ -3646,53 +849,2 @@\n-    @Run(test = \"testLongP1\")\n-    @Warmup(0)\n-    public static void runLongP1() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP1(data);\n-        verify(\"testLongP1\", data, goldLongP1);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM2(long[] data) {\n-        for (int j = 2; j < RANGE; j++) {\n-            data[j + -2] = (long)(data[j] + (long)-11);\n+        void setNegative() {\n+            this.isPositiveRule = false;\n@@ -3700,10 +852,0 @@\n-    }\n-\n-    @Run(test = \"testLongM2\")\n-    @Warmup(0)\n-    public static void runLongM2() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM2(data);\n-        verify(\"testLongM2\", data, goldLongM2);\n-    }\n@@ -3711,47 +853,2 @@\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP2(long[] data) {\n-        for (int j = 0; j < RANGE - 2; j++) {\n-            data[j + 2] = (long)(data[j] + (long)-11);\n+        void disable() {\n+            this.isEnabled = false;\n@@ -3759,10 +856,0 @@\n-    }\n-\n-    @Run(test = \"testLongP2\")\n-    @Warmup(0)\n-    public static void runLongP2() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP2(data);\n-        verify(\"testLongP2\", data, goldLongP2);\n-    }\n@@ -3770,44 +857,2 @@\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM3(long[] data) {\n-        for (int j = 3; j < RANGE; j++) {\n-            data[j + -3] = (long)(data[j] + (long)-11);\n+        void addApplyIf(String constraint) {\n+            this.applyIf.add(constraint);\n@@ -3815,10 +860,0 @@\n-    }\n-\n-    @Run(test = \"testLongM3\")\n-    @Warmup(0)\n-    public static void runLongM3() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM3(data);\n-        verify(\"testLongM3\", data, goldLongM3);\n-    }\n@@ -3826,49 +861,5 @@\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    \/\/   positive byte_offset 24 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    \/\/   positive byte_offset 24 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 24 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP3(long[] data) {\n-        for (int j = 0; j < RANGE - 3; j++) {\n-            data[j + 3] = (long)(data[j] + (long)-11);\n-        }\n-    }\n+        void generate(StringBuilder builder) {\n+            if (!isEnabled) {\n+                builder.append(\"    \/\/ No IR rule: disabled.\\n\");\n+            } else {\n+                builder.append(counts());\n@@ -3876,8 +867,8 @@\n-    @Run(test = \"testLongP3\")\n-    @Warmup(0)\n-    public static void runLongP3() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP3(data);\n-        verify(\"testLongP3\", data, goldLongP3);\n-    }\n+                \/\/ applyIf\n+                if (!applyIf.isEmpty()) {\n+                    builder.append(\"        applyIf\");\n+                    builder.append(applyIf.size() > 1 ? \"And\" : \"\");\n+                    builder.append(\" = {\");\n+                    builder.append(String.join(\", \", applyIf));\n+                    builder.append(\"},\\n\");\n+                }\n@@ -3885,44 +876,3 @@\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM4(long[] data) {\n-        for (int j = 4; j < RANGE; j++) {\n-            data[j + -4] = (long)(data[j] + (long)-11);\n+                \/\/ CPU features\n+                builder.append(applyIfCPUFeature);\n+            }\n@@ -3930,1 +880,0 @@\n-    }\n@@ -3932,11969 +881,25 @@\n-    @Run(test = \"testLongM4\")\n-    @Warmup(0)\n-    public static void runLongM4() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM4(data);\n-        verify(\"testLongM4\", data, goldLongM4);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    \/\/   positive byte_offset 32 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 32 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP4(long[] data) {\n-        for (int j = 0; j < RANGE - 4; j++) {\n-            data[j + 4] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongP4\")\n-    @Warmup(0)\n-    public static void runLongP4() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP4(data);\n-        verify(\"testLongP4\", data, goldLongP4);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM7(long[] data) {\n-        for (int j = 7; j < RANGE; j++) {\n-            data[j + -7] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongM7\")\n-    @Warmup(0)\n-    public static void runLongM7() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM7(data);\n-        verify(\"testLongM7\", data, goldLongM7);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    \/\/   positive byte_offset 56 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 56\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 56\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 56 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 56\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 56\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP7(long[] data) {\n-        for (int j = 0; j < RANGE - 7; j++) {\n-            data[j + 7] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongP7\")\n-    @Warmup(0)\n-    public static void runLongP7() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP7(data);\n-        verify(\"testLongP7\", data, goldLongP7);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM8(long[] data) {\n-        for (int j = 8; j < RANGE; j++) {\n-            data[j + -8] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongM8\")\n-    @Warmup(0)\n-    public static void runLongM8() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM8(data);\n-        verify(\"testLongM8\", data, goldLongM8);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 64 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 64\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 64\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP8(long[] data) {\n-        for (int j = 0; j < RANGE - 8; j++) {\n-            data[j + 8] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongP8\")\n-    @Warmup(0)\n-    public static void runLongP8() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP8(data);\n-        verify(\"testLongP8\", data, goldLongP8);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM14(long[] data) {\n-        for (int j = 14; j < RANGE; j++) {\n-            data[j + -14] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongM14\")\n-    @Warmup(0)\n-    public static void runLongM14() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM14(data);\n-        verify(\"testLongM14\", data, goldLongM14);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 112 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 112\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 112\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP14(long[] data) {\n-        for (int j = 0; j < RANGE - 14; j++) {\n-            data[j + 14] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongP14\")\n-    @Warmup(0)\n-    public static void runLongP14() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP14(data);\n-        verify(\"testLongP14\", data, goldLongP14);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM16(long[] data) {\n-        for (int j = 16; j < RANGE; j++) {\n-            data[j + -16] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongM16\")\n-    @Warmup(0)\n-    public static void runLongM16() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM16(data);\n-        verify(\"testLongM16\", data, goldLongM16);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 128 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 128\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 128\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP16(long[] data) {\n-        for (int j = 0; j < RANGE - 16; j++) {\n-            data[j + 16] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongP16\")\n-    @Warmup(0)\n-    public static void runLongP16() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP16(data);\n-        verify(\"testLongP16\", data, goldLongP16);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM18(long[] data) {\n-        for (int j = 18; j < RANGE; j++) {\n-            data[j + -18] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongM18\")\n-    @Warmup(0)\n-    public static void runLongM18() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM18(data);\n-        verify(\"testLongM18\", data, goldLongM18);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 144 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 144\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 144\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP18(long[] data) {\n-        for (int j = 0; j < RANGE - 18; j++) {\n-            data[j + 18] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongP18\")\n-    @Warmup(0)\n-    public static void runLongP18() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP18(data);\n-        verify(\"testLongP18\", data, goldLongP18);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM20(long[] data) {\n-        for (int j = 20; j < RANGE; j++) {\n-            data[j + -20] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongM20\")\n-    @Warmup(0)\n-    public static void runLongM20() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM20(data);\n-        verify(\"testLongM20\", data, goldLongM20);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 160 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 160\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 160\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP20(long[] data) {\n-        for (int j = 0; j < RANGE - 20; j++) {\n-            data[j + 20] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongP20\")\n-    @Warmup(0)\n-    public static void runLongP20() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP20(data);\n-        verify(\"testLongP20\", data, goldLongP20);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM31(long[] data) {\n-        for (int j = 31; j < RANGE; j++) {\n-            data[j + -31] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongM31\")\n-    @Warmup(0)\n-    public static void runLongM31() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM31(data);\n-        verify(\"testLongM31\", data, goldLongM31);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 248 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 248\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 248\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP31(long[] data) {\n-        for (int j = 0; j < RANGE - 31; j++) {\n-            data[j + 31] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongP31\")\n-    @Warmup(0)\n-    public static void runLongP31() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP31(data);\n-        verify(\"testLongP31\", data, goldLongP31);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM32(long[] data) {\n-        for (int j = 32; j < RANGE; j++) {\n-            data[j + -32] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongM32\")\n-    @Warmup(0)\n-    public static void runLongM32() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM32(data);\n-        verify(\"testLongM32\", data, goldLongM32);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP32(long[] data) {\n-        for (int j = 0; j < RANGE - 32; j++) {\n-            data[j + 32] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongP32\")\n-    @Warmup(0)\n-    public static void runLongP32() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP32(data);\n-        verify(\"testLongP32\", data, goldLongP32);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM63(long[] data) {\n-        for (int j = 63; j < RANGE; j++) {\n-            data[j + -63] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongM63\")\n-    @Warmup(0)\n-    public static void runLongM63() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM63(data);\n-        verify(\"testLongM63\", data, goldLongM63);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP63(long[] data) {\n-        for (int j = 0; j < RANGE - 63; j++) {\n-            data[j + 63] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongP63\")\n-    @Warmup(0)\n-    public static void runLongP63() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP63(data);\n-        verify(\"testLongP63\", data, goldLongP63);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM64(long[] data) {\n-        for (int j = 64; j < RANGE; j++) {\n-            data[j + -64] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongM64\")\n-    @Warmup(0)\n-    public static void runLongM64() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM64(data);\n-        verify(\"testLongM64\", data, goldLongM64);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP64(long[] data) {\n-        for (int j = 0; j < RANGE - 64; j++) {\n-            data[j + 64] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongP64\")\n-    @Warmup(0)\n-    public static void runLongP64() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP64(data);\n-        verify(\"testLongP64\", data, goldLongP64);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM65(long[] data) {\n-        for (int j = 65; j < RANGE; j++) {\n-            data[j + -65] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongM65\")\n-    @Warmup(0)\n-    public static void runLongM65() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM65(data);\n-        verify(\"testLongM65\", data, goldLongM65);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP65(long[] data) {\n-        for (int j = 0; j < RANGE - 65; j++) {\n-            data[j + 65] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongP65\")\n-    @Warmup(0)\n-    public static void runLongP65() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP65(data);\n-        verify(\"testLongP65\", data, goldLongP65);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM128(long[] data) {\n-        for (int j = 128; j < RANGE; j++) {\n-            data[j + -128] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongM128\")\n-    @Warmup(0)\n-    public static void runLongM128() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM128(data);\n-        verify(\"testLongM128\", data, goldLongM128);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP128(long[] data) {\n-        for (int j = 0; j < RANGE - 128; j++) {\n-            data[j + 128] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongP128\")\n-    @Warmup(0)\n-    public static void runLongP128() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP128(data);\n-        verify(\"testLongP128\", data, goldLongP128);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM129(long[] data) {\n-        for (int j = 129; j < RANGE; j++) {\n-            data[j + -129] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongM129\")\n-    @Warmup(0)\n-    public static void runLongM129() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM129(data);\n-        verify(\"testLongM129\", data, goldLongM129);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP129(long[] data) {\n-        for (int j = 0; j < RANGE - 129; j++) {\n-            data[j + 129] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongP129\")\n-    @Warmup(0)\n-    public static void runLongP129() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP129(data);\n-        verify(\"testLongP129\", data, goldLongP129);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM192(long[] data) {\n-        for (int j = 192; j < RANGE; j++) {\n-            data[j + -192] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongM192\")\n-    @Warmup(0)\n-    public static void runLongM192() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM192(data);\n-        verify(\"testLongM192\", data, goldLongM192);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP192(long[] data) {\n-        for (int j = 0; j < RANGE - 192; j++) {\n-            data[j + 192] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongP192\")\n-    @Warmup(0)\n-    public static void runLongP192() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP192(data);\n-        verify(\"testLongP192\", data, goldLongP192);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortP0(short[] data) {\n-        for (int j = 0; j < RANGE; j++) {\n-            data[j + 0] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP0\")\n-    @Warmup(0)\n-    public static void runShortP0() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP0(data);\n-        verify(\"testShortP0\", data, goldShortP0);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortM1(short[] data) {\n-        for (int j = 1; j < RANGE; j++) {\n-            data[j + -1] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM1\")\n-    @Warmup(0)\n-    public static void runShortM1() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM1(data);\n-        verify(\"testShortM1\", data, goldShortM1);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 2 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    \/\/   positive byte_offset 2 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 2 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 2 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 2 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortP1(short[] data) {\n-        for (int j = 0; j < RANGE - 1; j++) {\n-            data[j + 1] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP1\")\n-    @Warmup(0)\n-    public static void runShortP1() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP1(data);\n-        verify(\"testShortP1\", data, goldShortP1);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    public static void testShortM2(short[] data) {\n-        for (int j = 2; j < RANGE; j++) {\n-            data[j + -2] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM2\")\n-    @Warmup(0)\n-    public static void runShortM2() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM2(data);\n-        verify(\"testShortM2\", data, goldShortM2);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    public static void testShortP2(short[] data) {\n-        for (int j = 0; j < RANGE - 2; j++) {\n-            data[j + 2] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP2\")\n-    @Warmup(0)\n-    public static void runShortP2() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP2(data);\n-        verify(\"testShortP2\", data, goldShortP2);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortM3(short[] data) {\n-        for (int j = 3; j < RANGE; j++) {\n-            data[j + -3] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM3\")\n-    @Warmup(0)\n-    public static void runShortM3() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM3(data);\n-        verify(\"testShortM3\", data, goldShortM3);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 6 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    \/\/   positive byte_offset 6 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 6 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 6 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 6 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortP3(short[] data) {\n-        for (int j = 0; j < RANGE - 3; j++) {\n-            data[j + 3] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP3\")\n-    @Warmup(0)\n-    public static void runShortP3() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP3(data);\n-        verify(\"testShortP3\", data, goldShortP3);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortM4(short[] data) {\n-        for (int j = 4; j < RANGE; j++) {\n-            data[j + -4] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM4\")\n-    @Warmup(0)\n-    public static void runShortM4() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM4(data);\n-        verify(\"testShortM4\", data, goldShortM4);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortP4(short[] data) {\n-        for (int j = 0; j < RANGE - 4; j++) {\n-            data[j + 4] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP4\")\n-    @Warmup(0)\n-    public static void runShortP4() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP4(data);\n-        verify(\"testShortP4\", data, goldShortP4);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortM7(short[] data) {\n-        for (int j = 7; j < RANGE; j++) {\n-            data[j + -7] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM7\")\n-    @Warmup(0)\n-    public static void runShortM7() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM7(data);\n-        verify(\"testShortM7\", data, goldShortM7);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 14 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    \/\/   positive byte_offset 14 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 14 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 14 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 14 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortP7(short[] data) {\n-        for (int j = 0; j < RANGE - 7; j++) {\n-            data[j + 7] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP7\")\n-    @Warmup(0)\n-    public static void runShortP7() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP7(data);\n-        verify(\"testShortP7\", data, goldShortP7);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortM8(short[] data) {\n-        for (int j = 8; j < RANGE; j++) {\n-            data[j + -8] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM8\")\n-    @Warmup(0)\n-    public static void runShortM8() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM8(data);\n-        verify(\"testShortM8\", data, goldShortM8);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortP8(short[] data) {\n-        for (int j = 0; j < RANGE - 8; j++) {\n-            data[j + 8] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP8\")\n-    @Warmup(0)\n-    public static void runShortP8() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP8(data);\n-        verify(\"testShortP8\", data, goldShortP8);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    public static void testShortM14(short[] data) {\n-        for (int j = 14; j < RANGE; j++) {\n-            data[j + -14] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM14\")\n-    @Warmup(0)\n-    public static void runShortM14() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM14(data);\n-        verify(\"testShortM14\", data, goldShortM14);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    \/\/   positive byte_offset 28 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 28 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 28 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    public static void testShortP14(short[] data) {\n-        for (int j = 0; j < RANGE - 14; j++) {\n-            data[j + 14] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP14\")\n-    @Warmup(0)\n-    public static void runShortP14() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP14(data);\n-        verify(\"testShortP14\", data, goldShortP14);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortM16(short[] data) {\n-        for (int j = 16; j < RANGE; j++) {\n-            data[j + -16] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM16\")\n-    @Warmup(0)\n-    public static void runShortM16() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM16(data);\n-        verify(\"testShortM16\", data, goldShortM16);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 32 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 32 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortP16(short[] data) {\n-        for (int j = 0; j < RANGE - 16; j++) {\n-            data[j + 16] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP16\")\n-    @Warmup(0)\n-    public static void runShortP16() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP16(data);\n-        verify(\"testShortP16\", data, goldShortP16);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    public static void testShortM18(short[] data) {\n-        for (int j = 18; j < RANGE; j++) {\n-            data[j + -18] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM18\")\n-    @Warmup(0)\n-    public static void runShortM18() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM18(data);\n-        verify(\"testShortM18\", data, goldShortM18);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 36 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 36\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 36 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 36\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    public static void testShortP18(short[] data) {\n-        for (int j = 0; j < RANGE - 18; j++) {\n-            data[j + 18] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP18\")\n-    @Warmup(0)\n-    public static void runShortP18() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP18(data);\n-        verify(\"testShortP18\", data, goldShortP18);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortM20(short[] data) {\n-        for (int j = 20; j < RANGE; j++) {\n-            data[j + -20] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM20\")\n-    @Warmup(0)\n-    public static void runShortM20() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM20(data);\n-        verify(\"testShortM20\", data, goldShortM20);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 40 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 40\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 40\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 40 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 40\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 40\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortP20(short[] data) {\n-        for (int j = 0; j < RANGE - 20; j++) {\n-            data[j + 20] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP20\")\n-    @Warmup(0)\n-    public static void runShortP20() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP20(data);\n-        verify(\"testShortP20\", data, goldShortP20);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortM31(short[] data) {\n-        for (int j = 31; j < RANGE; j++) {\n-            data[j + -31] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM31\")\n-    @Warmup(0)\n-    public static void runShortM31() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM31(data);\n-        verify(\"testShortM31\", data, goldShortM31);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 62 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 62\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 62\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 62 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 62\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 62\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortP31(short[] data) {\n-        for (int j = 0; j < RANGE - 31; j++) {\n-            data[j + 31] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP31\")\n-    @Warmup(0)\n-    public static void runShortP31() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP31(data);\n-        verify(\"testShortP31\", data, goldShortP31);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortM32(short[] data) {\n-        for (int j = 32; j < RANGE; j++) {\n-            data[j + -32] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM32\")\n-    @Warmup(0)\n-    public static void runShortM32() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM32(data);\n-        verify(\"testShortM32\", data, goldShortM32);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 64 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 64\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 64\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortP32(short[] data) {\n-        for (int j = 0; j < RANGE - 32; j++) {\n-            data[j + 32] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP32\")\n-    @Warmup(0)\n-    public static void runShortP32() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP32(data);\n-        verify(\"testShortP32\", data, goldShortP32);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortM63(short[] data) {\n-        for (int j = 63; j < RANGE; j++) {\n-            data[j + -63] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM63\")\n-    @Warmup(0)\n-    public static void runShortM63() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM63(data);\n-        verify(\"testShortM63\", data, goldShortM63);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 126 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 126\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 126\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortP63(short[] data) {\n-        for (int j = 0; j < RANGE - 63; j++) {\n-            data[j + 63] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP63\")\n-    @Warmup(0)\n-    public static void runShortP63() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP63(data);\n-        verify(\"testShortP63\", data, goldShortP63);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortM64(short[] data) {\n-        for (int j = 64; j < RANGE; j++) {\n-            data[j + -64] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM64\")\n-    @Warmup(0)\n-    public static void runShortM64() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM64(data);\n-        verify(\"testShortM64\", data, goldShortM64);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 128 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 128\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 128\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortP64(short[] data) {\n-        for (int j = 0; j < RANGE - 64; j++) {\n-            data[j + 64] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP64\")\n-    @Warmup(0)\n-    public static void runShortP64() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP64(data);\n-        verify(\"testShortP64\", data, goldShortP64);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortM65(short[] data) {\n-        for (int j = 65; j < RANGE; j++) {\n-            data[j + -65] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM65\")\n-    @Warmup(0)\n-    public static void runShortM65() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM65(data);\n-        verify(\"testShortM65\", data, goldShortM65);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 130 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 130\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 130\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortP65(short[] data) {\n-        for (int j = 0; j < RANGE - 65; j++) {\n-            data[j + 65] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP65\")\n-    @Warmup(0)\n-    public static void runShortP65() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP65(data);\n-        verify(\"testShortP65\", data, goldShortP65);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortM128(short[] data) {\n-        for (int j = 128; j < RANGE; j++) {\n-            data[j + -128] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM128\")\n-    @Warmup(0)\n-    public static void runShortM128() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM128(data);\n-        verify(\"testShortM128\", data, goldShortM128);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortP128(short[] data) {\n-        for (int j = 0; j < RANGE - 128; j++) {\n-            data[j + 128] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP128\")\n-    @Warmup(0)\n-    public static void runShortP128() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP128(data);\n-        verify(\"testShortP128\", data, goldShortP128);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortM129(short[] data) {\n-        for (int j = 129; j < RANGE; j++) {\n-            data[j + -129] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM129\")\n-    @Warmup(0)\n-    public static void runShortM129() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM129(data);\n-        verify(\"testShortM129\", data, goldShortM129);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortP129(short[] data) {\n-        for (int j = 0; j < RANGE - 129; j++) {\n-            data[j + 129] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP129\")\n-    @Warmup(0)\n-    public static void runShortP129() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP129(data);\n-        verify(\"testShortP129\", data, goldShortP129);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortM192(short[] data) {\n-        for (int j = 192; j < RANGE; j++) {\n-            data[j + -192] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM192\")\n-    @Warmup(0)\n-    public static void runShortM192() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM192(data);\n-        verify(\"testShortM192\", data, goldShortM192);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortP192(short[] data) {\n-        for (int j = 0; j < RANGE - 192; j++) {\n-            data[j + 192] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP192\")\n-    @Warmup(0)\n-    public static void runShortP192() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP192(data);\n-        verify(\"testShortP192\", data, goldShortP192);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharP0(char[] data) {\n-        for (int j = 0; j < RANGE; j++) {\n-            data[j + 0] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP0\")\n-    @Warmup(0)\n-    public static void runCharP0() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP0(data);\n-        verify(\"testCharP0\", data, goldCharP0);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharM1(char[] data) {\n-        for (int j = 1; j < RANGE; j++) {\n-            data[j + -1] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM1\")\n-    @Warmup(0)\n-    public static void runCharM1() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM1(data);\n-        verify(\"testCharM1\", data, goldCharM1);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 2 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    \/\/   positive byte_offset 2 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 2 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 2 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 2 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharP1(char[] data) {\n-        for (int j = 0; j < RANGE - 1; j++) {\n-            data[j + 1] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP1\")\n-    @Warmup(0)\n-    public static void runCharP1() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP1(data);\n-        verify(\"testCharP1\", data, goldCharP1);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    public static void testCharM2(char[] data) {\n-        for (int j = 2; j < RANGE; j++) {\n-            data[j + -2] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM2\")\n-    @Warmup(0)\n-    public static void runCharM2() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM2(data);\n-        verify(\"testCharM2\", data, goldCharM2);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    public static void testCharP2(char[] data) {\n-        for (int j = 0; j < RANGE - 2; j++) {\n-            data[j + 2] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP2\")\n-    @Warmup(0)\n-    public static void runCharP2() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP2(data);\n-        verify(\"testCharP2\", data, goldCharP2);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharM3(char[] data) {\n-        for (int j = 3; j < RANGE; j++) {\n-            data[j + -3] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM3\")\n-    @Warmup(0)\n-    public static void runCharM3() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM3(data);\n-        verify(\"testCharM3\", data, goldCharM3);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 6 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    \/\/   positive byte_offset 6 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 6 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 6 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 6 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharP3(char[] data) {\n-        for (int j = 0; j < RANGE - 3; j++) {\n-            data[j + 3] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP3\")\n-    @Warmup(0)\n-    public static void runCharP3() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP3(data);\n-        verify(\"testCharP3\", data, goldCharP3);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharM4(char[] data) {\n-        for (int j = 4; j < RANGE; j++) {\n-            data[j + -4] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM4\")\n-    @Warmup(0)\n-    public static void runCharM4() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM4(data);\n-        verify(\"testCharM4\", data, goldCharM4);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharP4(char[] data) {\n-        for (int j = 0; j < RANGE - 4; j++) {\n-            data[j + 4] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP4\")\n-    @Warmup(0)\n-    public static void runCharP4() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP4(data);\n-        verify(\"testCharP4\", data, goldCharP4);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharM7(char[] data) {\n-        for (int j = 7; j < RANGE; j++) {\n-            data[j + -7] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM7\")\n-    @Warmup(0)\n-    public static void runCharM7() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM7(data);\n-        verify(\"testCharM7\", data, goldCharM7);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 14 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    \/\/   positive byte_offset 14 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 14 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 14 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 14 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharP7(char[] data) {\n-        for (int j = 0; j < RANGE - 7; j++) {\n-            data[j + 7] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP7\")\n-    @Warmup(0)\n-    public static void runCharP7() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP7(data);\n-        verify(\"testCharP7\", data, goldCharP7);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharM8(char[] data) {\n-        for (int j = 8; j < RANGE; j++) {\n-            data[j + -8] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM8\")\n-    @Warmup(0)\n-    public static void runCharM8() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM8(data);\n-        verify(\"testCharM8\", data, goldCharM8);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharP8(char[] data) {\n-        for (int j = 0; j < RANGE - 8; j++) {\n-            data[j + 8] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP8\")\n-    @Warmup(0)\n-    public static void runCharP8() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP8(data);\n-        verify(\"testCharP8\", data, goldCharP8);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    public static void testCharM14(char[] data) {\n-        for (int j = 14; j < RANGE; j++) {\n-            data[j + -14] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM14\")\n-    @Warmup(0)\n-    public static void runCharM14() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM14(data);\n-        verify(\"testCharM14\", data, goldCharM14);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    \/\/   positive byte_offset 28 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 28 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 28 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    public static void testCharP14(char[] data) {\n-        for (int j = 0; j < RANGE - 14; j++) {\n-            data[j + 14] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP14\")\n-    @Warmup(0)\n-    public static void runCharP14() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP14(data);\n-        verify(\"testCharP14\", data, goldCharP14);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharM16(char[] data) {\n-        for (int j = 16; j < RANGE; j++) {\n-            data[j + -16] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM16\")\n-    @Warmup(0)\n-    public static void runCharM16() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM16(data);\n-        verify(\"testCharM16\", data, goldCharM16);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 32 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 32 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharP16(char[] data) {\n-        for (int j = 0; j < RANGE - 16; j++) {\n-            data[j + 16] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP16\")\n-    @Warmup(0)\n-    public static void runCharP16() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP16(data);\n-        verify(\"testCharP16\", data, goldCharP16);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    public static void testCharM18(char[] data) {\n-        for (int j = 18; j < RANGE; j++) {\n-            data[j + -18] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM18\")\n-    @Warmup(0)\n-    public static void runCharM18() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM18(data);\n-        verify(\"testCharM18\", data, goldCharM18);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 36 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 36\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 36 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 36\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    public static void testCharP18(char[] data) {\n-        for (int j = 0; j < RANGE - 18; j++) {\n-            data[j + 18] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP18\")\n-    @Warmup(0)\n-    public static void runCharP18() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP18(data);\n-        verify(\"testCharP18\", data, goldCharP18);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharM20(char[] data) {\n-        for (int j = 20; j < RANGE; j++) {\n-            data[j + -20] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM20\")\n-    @Warmup(0)\n-    public static void runCharM20() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM20(data);\n-        verify(\"testCharM20\", data, goldCharM20);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 40 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 40\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 40\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 40 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 40\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 40\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharP20(char[] data) {\n-        for (int j = 0; j < RANGE - 20; j++) {\n-            data[j + 20] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP20\")\n-    @Warmup(0)\n-    public static void runCharP20() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP20(data);\n-        verify(\"testCharP20\", data, goldCharP20);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharM31(char[] data) {\n-        for (int j = 31; j < RANGE; j++) {\n-            data[j + -31] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM31\")\n-    @Warmup(0)\n-    public static void runCharM31() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM31(data);\n-        verify(\"testCharM31\", data, goldCharM31);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 62 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 62\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 62\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 62 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 62\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 62\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharP31(char[] data) {\n-        for (int j = 0; j < RANGE - 31; j++) {\n-            data[j + 31] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP31\")\n-    @Warmup(0)\n-    public static void runCharP31() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP31(data);\n-        verify(\"testCharP31\", data, goldCharP31);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharM32(char[] data) {\n-        for (int j = 32; j < RANGE; j++) {\n-            data[j + -32] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM32\")\n-    @Warmup(0)\n-    public static void runCharM32() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM32(data);\n-        verify(\"testCharM32\", data, goldCharM32);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 64 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 64\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 64\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharP32(char[] data) {\n-        for (int j = 0; j < RANGE - 32; j++) {\n-            data[j + 32] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP32\")\n-    @Warmup(0)\n-    public static void runCharP32() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP32(data);\n-        verify(\"testCharP32\", data, goldCharP32);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharM63(char[] data) {\n-        for (int j = 63; j < RANGE; j++) {\n-            data[j + -63] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM63\")\n-    @Warmup(0)\n-    public static void runCharM63() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM63(data);\n-        verify(\"testCharM63\", data, goldCharM63);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 126 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 126\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 126\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharP63(char[] data) {\n-        for (int j = 0; j < RANGE - 63; j++) {\n-            data[j + 63] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP63\")\n-    @Warmup(0)\n-    public static void runCharP63() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP63(data);\n-        verify(\"testCharP63\", data, goldCharP63);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharM64(char[] data) {\n-        for (int j = 64; j < RANGE; j++) {\n-            data[j + -64] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM64\")\n-    @Warmup(0)\n-    public static void runCharM64() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM64(data);\n-        verify(\"testCharM64\", data, goldCharM64);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 128 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 128\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 128\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharP64(char[] data) {\n-        for (int j = 0; j < RANGE - 64; j++) {\n-            data[j + 64] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP64\")\n-    @Warmup(0)\n-    public static void runCharP64() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP64(data);\n-        verify(\"testCharP64\", data, goldCharP64);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharM65(char[] data) {\n-        for (int j = 65; j < RANGE; j++) {\n-            data[j + -65] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM65\")\n-    @Warmup(0)\n-    public static void runCharM65() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM65(data);\n-        verify(\"testCharM65\", data, goldCharM65);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 130 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 130\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 130\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharP65(char[] data) {\n-        for (int j = 0; j < RANGE - 65; j++) {\n-            data[j + 65] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP65\")\n-    @Warmup(0)\n-    public static void runCharP65() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP65(data);\n-        verify(\"testCharP65\", data, goldCharP65);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharM128(char[] data) {\n-        for (int j = 128; j < RANGE; j++) {\n-            data[j + -128] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM128\")\n-    @Warmup(0)\n-    public static void runCharM128() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM128(data);\n-        verify(\"testCharM128\", data, goldCharM128);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharP128(char[] data) {\n-        for (int j = 0; j < RANGE - 128; j++) {\n-            data[j + 128] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP128\")\n-    @Warmup(0)\n-    public static void runCharP128() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP128(data);\n-        verify(\"testCharP128\", data, goldCharP128);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharM129(char[] data) {\n-        for (int j = 129; j < RANGE; j++) {\n-            data[j + -129] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM129\")\n-    @Warmup(0)\n-    public static void runCharM129() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM129(data);\n-        verify(\"testCharM129\", data, goldCharM129);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharP129(char[] data) {\n-        for (int j = 0; j < RANGE - 129; j++) {\n-            data[j + 129] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP129\")\n-    @Warmup(0)\n-    public static void runCharP129() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP129(data);\n-        verify(\"testCharP129\", data, goldCharP129);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharM192(char[] data) {\n-        for (int j = 192; j < RANGE; j++) {\n-            data[j + -192] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM192\")\n-    @Warmup(0)\n-    public static void runCharM192() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM192(data);\n-        verify(\"testCharM192\", data, goldCharM192);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharP192(char[] data) {\n-        for (int j = 0; j < RANGE - 192; j++) {\n-            data[j + 192] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP192\")\n-    @Warmup(0)\n-    public static void runCharP192() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP192(data);\n-        verify(\"testCharP192\", data, goldCharP192);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteP0(byte[] data) {\n-        for (int j = 0; j < RANGE; j++) {\n-            data[j + 0] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP0\")\n-    @Warmup(0)\n-    public static void runByteP0() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP0(data);\n-        verify(\"testByteP0\", data, goldByteP0);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteM1(byte[] data) {\n-        for (int j = 1; j < RANGE; j++) {\n-            data[j + -1] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM1\")\n-    @Warmup(0)\n-    public static void runByteM1() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM1(data);\n-        verify(\"testByteM1\", data, goldByteM1);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    \/\/   positive byte_offset 1 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 1\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    \/\/   positive byte_offset 1 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 1\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    \/\/   positive byte_offset 1 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 1\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    \/\/   positive byte_offset 1 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 1\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 1 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 1\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteP1(byte[] data) {\n-        for (int j = 0; j < RANGE - 1; j++) {\n-            data[j + 1] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP1\")\n-    @Warmup(0)\n-    public static void runByteP1() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP1(data);\n-        verify(\"testByteP1\", data, goldByteP1);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteM2(byte[] data) {\n-        for (int j = 2; j < RANGE; j++) {\n-            data[j + -2] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM2\")\n-    @Warmup(0)\n-    public static void runByteM2() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM2(data);\n-        verify(\"testByteM2\", data, goldByteM2);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    \/\/   positive byte_offset 2 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    \/\/   positive byte_offset 2 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    \/\/   positive byte_offset 2 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    \/\/   positive byte_offset 2 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 2 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteP2(byte[] data) {\n-        for (int j = 0; j < RANGE - 2; j++) {\n-            data[j + 2] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP2\")\n-    @Warmup(0)\n-    public static void runByteP2() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP2(data);\n-        verify(\"testByteP2\", data, goldByteP2);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteM3(byte[] data) {\n-        for (int j = 3; j < RANGE; j++) {\n-            data[j + -3] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM3\")\n-    @Warmup(0)\n-    public static void runByteM3() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM3(data);\n-        verify(\"testByteM3\", data, goldByteM3);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    \/\/   positive byte_offset 3 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 3\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    \/\/   positive byte_offset 3 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 3\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    \/\/   positive byte_offset 3 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 3\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    \/\/   positive byte_offset 3 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 3\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 3 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 3\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteP3(byte[] data) {\n-        for (int j = 0; j < RANGE - 3; j++) {\n-            data[j + 3] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP3\")\n-    @Warmup(0)\n-    public static void runByteP3() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP3(data);\n-        verify(\"testByteP3\", data, goldByteP3);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    public static void testByteM4(byte[] data) {\n-        for (int j = 4; j < RANGE; j++) {\n-            data[j + -4] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM4\")\n-    @Warmup(0)\n-    public static void runByteM4() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM4(data);\n-        verify(\"testByteM4\", data, goldByteM4);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    public static void testByteP4(byte[] data) {\n-        for (int j = 0; j < RANGE - 4; j++) {\n-            data[j + 4] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP4\")\n-    @Warmup(0)\n-    public static void runByteP4() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP4(data);\n-        verify(\"testByteP4\", data, goldByteP4);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteM7(byte[] data) {\n-        for (int j = 7; j < RANGE; j++) {\n-            data[j + -7] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM7\")\n-    @Warmup(0)\n-    public static void runByteM7() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM7(data);\n-        verify(\"testByteM7\", data, goldByteM7);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    \/\/   positive byte_offset 7 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 7\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 7\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    \/\/   positive byte_offset 7 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 7\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 7\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    \/\/   positive byte_offset 7 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 7\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 7\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    \/\/   positive byte_offset 7 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 7\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 7\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 7 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 7\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 7\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteP7(byte[] data) {\n-        for (int j = 0; j < RANGE - 7; j++) {\n-            data[j + 7] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP7\")\n-    @Warmup(0)\n-    public static void runByteP7() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP7(data);\n-        verify(\"testByteP7\", data, goldByteP7);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteM8(byte[] data) {\n-        for (int j = 8; j < RANGE; j++) {\n-            data[j + -8] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM8\")\n-    @Warmup(0)\n-    public static void runByteM8() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM8(data);\n-        verify(\"testByteM8\", data, goldByteM8);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteP8(byte[] data) {\n-        for (int j = 0; j < RANGE - 8; j++) {\n-            data[j + 8] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP8\")\n-    @Warmup(0)\n-    public static void runByteP8() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP8(data);\n-        verify(\"testByteP8\", data, goldByteP8);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteM14(byte[] data) {\n-        for (int j = 14; j < RANGE; j++) {\n-            data[j + -14] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM14\")\n-    @Warmup(0)\n-    public static void runByteM14() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM14(data);\n-        verify(\"testByteM14\", data, goldByteM14);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    \/\/   positive byte_offset 14 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    \/\/   positive byte_offset 14 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    \/\/   positive byte_offset 14 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    \/\/   positive byte_offset 14 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 14 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteP14(byte[] data) {\n-        for (int j = 0; j < RANGE - 14; j++) {\n-            data[j + 14] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP14\")\n-    @Warmup(0)\n-    public static void runByteP14() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP14(data);\n-        verify(\"testByteP14\", data, goldByteP14);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteM16(byte[] data) {\n-        for (int j = 16; j < RANGE; j++) {\n-            data[j + -16] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM16\")\n-    @Warmup(0)\n-    public static void runByteM16() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM16(data);\n-        verify(\"testByteM16\", data, goldByteM16);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteP16(byte[] data) {\n-        for (int j = 0; j < RANGE - 16; j++) {\n-            data[j + 16] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP16\")\n-    @Warmup(0)\n-    public static void runByteP16() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP16(data);\n-        verify(\"testByteP16\", data, goldByteP16);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteM18(byte[] data) {\n-        for (int j = 18; j < RANGE; j++) {\n-            data[j + -18] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM18\")\n-    @Warmup(0)\n-    public static void runByteM18() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM18(data);\n-        verify(\"testByteM18\", data, goldByteM18);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    \/\/   positive byte_offset 18 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 18\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 18\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    \/\/   positive byte_offset 18 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 18\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 18\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 18 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 18\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 18\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteP18(byte[] data) {\n-        for (int j = 0; j < RANGE - 18; j++) {\n-            data[j + 18] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP18\")\n-    @Warmup(0)\n-    public static void runByteP18() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP18(data);\n-        verify(\"testByteP18\", data, goldByteP18);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    public static void testByteM20(byte[] data) {\n-        for (int j = 20; j < RANGE; j++) {\n-            data[j + -20] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM20\")\n-    @Warmup(0)\n-    public static void runByteM20() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM20(data);\n-        verify(\"testByteM20\", data, goldByteM20);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    \/\/   positive byte_offset 20 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 20\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    \/\/   positive byte_offset 20 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 20\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 20 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 20\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    public static void testByteP20(byte[] data) {\n-        for (int j = 0; j < RANGE - 20; j++) {\n-            data[j + 20] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP20\")\n-    @Warmup(0)\n-    public static void runByteP20() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP20(data);\n-        verify(\"testByteP20\", data, goldByteP20);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteM31(byte[] data) {\n-        for (int j = 31; j < RANGE; j++) {\n-            data[j + -31] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM31\")\n-    @Warmup(0)\n-    public static void runByteM31() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM31(data);\n-        verify(\"testByteM31\", data, goldByteM31);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    \/\/   positive byte_offset 31 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 31\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 31\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    \/\/   positive byte_offset 31 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 31\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 31\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 31 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 31\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 31\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteP31(byte[] data) {\n-        for (int j = 0; j < RANGE - 31; j++) {\n-            data[j + 31] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP31\")\n-    @Warmup(0)\n-    public static void runByteP31() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP31(data);\n-        verify(\"testByteP31\", data, goldByteP31);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteM32(byte[] data) {\n-        for (int j = 32; j < RANGE; j++) {\n-            data[j + -32] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM32\")\n-    @Warmup(0)\n-    public static void runByteM32() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM32(data);\n-        verify(\"testByteM32\", data, goldByteM32);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    \/\/   positive byte_offset 32 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 32 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteP32(byte[] data) {\n-        for (int j = 0; j < RANGE - 32; j++) {\n-            data[j + 32] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP32\")\n-    @Warmup(0)\n-    public static void runByteP32() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP32(data);\n-        verify(\"testByteP32\", data, goldByteP32);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteM63(byte[] data) {\n-        for (int j = 63; j < RANGE; j++) {\n-            data[j + -63] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM63\")\n-    @Warmup(0)\n-    public static void runByteM63() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM63(data);\n-        verify(\"testByteM63\", data, goldByteM63);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    \/\/   positive byte_offset 63 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 63\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 63\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 63 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 63\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 63\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteP63(byte[] data) {\n-        for (int j = 0; j < RANGE - 63; j++) {\n-            data[j + 63] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP63\")\n-    @Warmup(0)\n-    public static void runByteP63() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP63(data);\n-        verify(\"testByteP63\", data, goldByteP63);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteM64(byte[] data) {\n-        for (int j = 64; j < RANGE; j++) {\n-            data[j + -64] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM64\")\n-    @Warmup(0)\n-    public static void runByteM64() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM64(data);\n-        verify(\"testByteM64\", data, goldByteM64);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 64 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 64\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 64\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteP64(byte[] data) {\n-        for (int j = 0; j < RANGE - 64; j++) {\n-            data[j + 64] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP64\")\n-    @Warmup(0)\n-    public static void runByteP64() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP64(data);\n-        verify(\"testByteP64\", data, goldByteP64);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteM65(byte[] data) {\n-        for (int j = 65; j < RANGE; j++) {\n-            data[j + -65] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM65\")\n-    @Warmup(0)\n-    public static void runByteM65() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM65(data);\n-        verify(\"testByteM65\", data, goldByteM65);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 65 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 65\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 65\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteP65(byte[] data) {\n-        for (int j = 0; j < RANGE - 65; j++) {\n-            data[j + 65] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP65\")\n-    @Warmup(0)\n-    public static void runByteP65() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP65(data);\n-        verify(\"testByteP65\", data, goldByteP65);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteM128(byte[] data) {\n-        for (int j = 128; j < RANGE; j++) {\n-            data[j + -128] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM128\")\n-    @Warmup(0)\n-    public static void runByteM128() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM128(data);\n-        verify(\"testByteM128\", data, goldByteM128);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 128 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 128\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 128\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteP128(byte[] data) {\n-        for (int j = 0; j < RANGE - 128; j++) {\n-            data[j + 128] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP128\")\n-    @Warmup(0)\n-    public static void runByteP128() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP128(data);\n-        verify(\"testByteP128\", data, goldByteP128);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteM129(byte[] data) {\n-        for (int j = 129; j < RANGE; j++) {\n-            data[j + -129] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM129\")\n-    @Warmup(0)\n-    public static void runByteM129() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM129(data);\n-        verify(\"testByteM129\", data, goldByteM129);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 129 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 129\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 129\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteP129(byte[] data) {\n-        for (int j = 0; j < RANGE - 129; j++) {\n-            data[j + 129] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP129\")\n-    @Warmup(0)\n-    public static void runByteP129() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP129(data);\n-        verify(\"testByteP129\", data, goldByteP129);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteM192(byte[] data) {\n-        for (int j = 192; j < RANGE; j++) {\n-            data[j + -192] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM192\")\n-    @Warmup(0)\n-    public static void runByteM192() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM192(data);\n-        verify(\"testByteM192\", data, goldByteM192);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 192 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 192\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 192\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteP192(byte[] data) {\n-        for (int j = 0; j < RANGE - 192; j++) {\n-            data[j + 192] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP192\")\n-    @Warmup(0)\n-    public static void runByteP192() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP192(data);\n-        verify(\"testByteP192\", data, goldByteP192);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP0(float[] data) {\n-        for (int j = 0; j < RANGE; j++) {\n-            data[j + 0] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP0\")\n-    @Warmup(0)\n-    public static void runFloatP0() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP0(data);\n-        verify(\"testFloatP0\", data, goldFloatP0);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM1(float[] data) {\n-        for (int j = 1; j < RANGE; j++) {\n-            data[j + -1] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM1\")\n-    @Warmup(0)\n-    public static void runFloatM1() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM1(data);\n-        verify(\"testFloatM1\", data, goldFloatM1);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP1(float[] data) {\n-        for (int j = 0; j < RANGE - 1; j++) {\n-            data[j + 1] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP1\")\n-    @Warmup(0)\n-    public static void runFloatP1() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP1(data);\n-        verify(\"testFloatP1\", data, goldFloatP1);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM2(float[] data) {\n-        for (int j = 2; j < RANGE; j++) {\n-            data[j + -2] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM2\")\n-    @Warmup(0)\n-    public static void runFloatM2() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM2(data);\n-        verify(\"testFloatM2\", data, goldFloatM2);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP2(float[] data) {\n-        for (int j = 0; j < RANGE - 2; j++) {\n-            data[j + 2] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP2\")\n-    @Warmup(0)\n-    public static void runFloatP2() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP2(data);\n-        verify(\"testFloatP2\", data, goldFloatP2);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM3(float[] data) {\n-        for (int j = 3; j < RANGE; j++) {\n-            data[j + -3] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM3\")\n-    @Warmup(0)\n-    public static void runFloatM3() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM3(data);\n-        verify(\"testFloatM3\", data, goldFloatM3);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    \/\/   positive byte_offset 12 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    \/\/   positive byte_offset 12 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    \/\/   positive byte_offset 12 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    \/\/   positive byte_offset 12 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 12 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP3(float[] data) {\n-        for (int j = 0; j < RANGE - 3; j++) {\n-            data[j + 3] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP3\")\n-    @Warmup(0)\n-    public static void runFloatP3() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP3(data);\n-        verify(\"testFloatP3\", data, goldFloatP3);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM4(float[] data) {\n-        for (int j = 4; j < RANGE; j++) {\n-            data[j + -4] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM4\")\n-    @Warmup(0)\n-    public static void runFloatM4() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM4(data);\n-        verify(\"testFloatM4\", data, goldFloatM4);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP4(float[] data) {\n-        for (int j = 0; j < RANGE - 4; j++) {\n-            data[j + 4] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP4\")\n-    @Warmup(0)\n-    public static void runFloatP4() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP4(data);\n-        verify(\"testFloatP4\", data, goldFloatP4);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM7(float[] data) {\n-        for (int j = 7; j < RANGE; j++) {\n-            data[j + -7] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM7\")\n-    @Warmup(0)\n-    public static void runFloatM7() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM7(data);\n-        verify(\"testFloatM7\", data, goldFloatM7);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    \/\/   positive byte_offset 28 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    \/\/   positive byte_offset 28 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 28 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP7(float[] data) {\n-        for (int j = 0; j < RANGE - 7; j++) {\n-            data[j + 7] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP7\")\n-    @Warmup(0)\n-    public static void runFloatP7() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP7(data);\n-        verify(\"testFloatP7\", data, goldFloatP7);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM8(float[] data) {\n-        for (int j = 8; j < RANGE; j++) {\n-            data[j + -8] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM8\")\n-    @Warmup(0)\n-    public static void runFloatM8() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM8(data);\n-        verify(\"testFloatM8\", data, goldFloatM8);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    \/\/   positive byte_offset 32 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 32 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP8(float[] data) {\n-        for (int j = 0; j < RANGE - 8; j++) {\n-            data[j + 8] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP8\")\n-    @Warmup(0)\n-    public static void runFloatP8() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP8(data);\n-        verify(\"testFloatP8\", data, goldFloatP8);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM14(float[] data) {\n-        for (int j = 14; j < RANGE; j++) {\n-            data[j + -14] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM14\")\n-    @Warmup(0)\n-    public static void runFloatM14() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM14(data);\n-        verify(\"testFloatM14\", data, goldFloatM14);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    \/\/   positive byte_offset 56 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 56\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 56\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 56 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 56\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 56\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP14(float[] data) {\n-        for (int j = 0; j < RANGE - 14; j++) {\n-            data[j + 14] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP14\")\n-    @Warmup(0)\n-    public static void runFloatP14() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP14(data);\n-        verify(\"testFloatP14\", data, goldFloatP14);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM16(float[] data) {\n-        for (int j = 16; j < RANGE; j++) {\n-            data[j + -16] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM16\")\n-    @Warmup(0)\n-    public static void runFloatM16() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM16(data);\n-        verify(\"testFloatM16\", data, goldFloatM16);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 64 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 64\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 64\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP16(float[] data) {\n-        for (int j = 0; j < RANGE - 16; j++) {\n-            data[j + 16] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP16\")\n-    @Warmup(0)\n-    public static void runFloatP16() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP16(data);\n-        verify(\"testFloatP16\", data, goldFloatP16);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM18(float[] data) {\n-        for (int j = 18; j < RANGE; j++) {\n-            data[j + -18] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM18\")\n-    @Warmup(0)\n-    public static void runFloatM18() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM18(data);\n-        verify(\"testFloatM18\", data, goldFloatM18);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 72 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 72\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 72\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP18(float[] data) {\n-        for (int j = 0; j < RANGE - 18; j++) {\n-            data[j + 18] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP18\")\n-    @Warmup(0)\n-    public static void runFloatP18() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP18(data);\n-        verify(\"testFloatP18\", data, goldFloatP18);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM20(float[] data) {\n-        for (int j = 20; j < RANGE; j++) {\n-            data[j + -20] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM20\")\n-    @Warmup(0)\n-    public static void runFloatM20() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM20(data);\n-        verify(\"testFloatM20\", data, goldFloatM20);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 80 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 80\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 80\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP20(float[] data) {\n-        for (int j = 0; j < RANGE - 20; j++) {\n-            data[j + 20] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP20\")\n-    @Warmup(0)\n-    public static void runFloatP20() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP20(data);\n-        verify(\"testFloatP20\", data, goldFloatP20);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM31(float[] data) {\n-        for (int j = 31; j < RANGE; j++) {\n-            data[j + -31] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM31\")\n-    @Warmup(0)\n-    public static void runFloatM31() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM31(data);\n-        verify(\"testFloatM31\", data, goldFloatM31);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 124 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 124\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 124\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP31(float[] data) {\n-        for (int j = 0; j < RANGE - 31; j++) {\n-            data[j + 31] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP31\")\n-    @Warmup(0)\n-    public static void runFloatP31() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP31(data);\n-        verify(\"testFloatP31\", data, goldFloatP31);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM32(float[] data) {\n-        for (int j = 32; j < RANGE; j++) {\n-            data[j + -32] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM32\")\n-    @Warmup(0)\n-    public static void runFloatM32() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM32(data);\n-        verify(\"testFloatM32\", data, goldFloatM32);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 128 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 128\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 128\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP32(float[] data) {\n-        for (int j = 0; j < RANGE - 32; j++) {\n-            data[j + 32] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP32\")\n-    @Warmup(0)\n-    public static void runFloatP32() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP32(data);\n-        verify(\"testFloatP32\", data, goldFloatP32);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM63(float[] data) {\n-        for (int j = 63; j < RANGE; j++) {\n-            data[j + -63] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM63\")\n-    @Warmup(0)\n-    public static void runFloatM63() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM63(data);\n-        verify(\"testFloatM63\", data, goldFloatM63);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 252 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 252\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 252\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP63(float[] data) {\n-        for (int j = 0; j < RANGE - 63; j++) {\n-            data[j + 63] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP63\")\n-    @Warmup(0)\n-    public static void runFloatP63() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP63(data);\n-        verify(\"testFloatP63\", data, goldFloatP63);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM64(float[] data) {\n-        for (int j = 64; j < RANGE; j++) {\n-            data[j + -64] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM64\")\n-    @Warmup(0)\n-    public static void runFloatM64() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM64(data);\n-        verify(\"testFloatM64\", data, goldFloatM64);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP64(float[] data) {\n-        for (int j = 0; j < RANGE - 64; j++) {\n-            data[j + 64] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP64\")\n-    @Warmup(0)\n-    public static void runFloatP64() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP64(data);\n-        verify(\"testFloatP64\", data, goldFloatP64);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM65(float[] data) {\n-        for (int j = 65; j < RANGE; j++) {\n-            data[j + -65] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM65\")\n-    @Warmup(0)\n-    public static void runFloatM65() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM65(data);\n-        verify(\"testFloatM65\", data, goldFloatM65);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP65(float[] data) {\n-        for (int j = 0; j < RANGE - 65; j++) {\n-            data[j + 65] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP65\")\n-    @Warmup(0)\n-    public static void runFloatP65() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP65(data);\n-        verify(\"testFloatP65\", data, goldFloatP65);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM128(float[] data) {\n-        for (int j = 128; j < RANGE; j++) {\n-            data[j + -128] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM128\")\n-    @Warmup(0)\n-    public static void runFloatM128() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM128(data);\n-        verify(\"testFloatM128\", data, goldFloatM128);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP128(float[] data) {\n-        for (int j = 0; j < RANGE - 128; j++) {\n-            data[j + 128] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP128\")\n-    @Warmup(0)\n-    public static void runFloatP128() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP128(data);\n-        verify(\"testFloatP128\", data, goldFloatP128);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM129(float[] data) {\n-        for (int j = 129; j < RANGE; j++) {\n-            data[j + -129] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM129\")\n-    @Warmup(0)\n-    public static void runFloatM129() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM129(data);\n-        verify(\"testFloatM129\", data, goldFloatM129);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP129(float[] data) {\n-        for (int j = 0; j < RANGE - 129; j++) {\n-            data[j + 129] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP129\")\n-    @Warmup(0)\n-    public static void runFloatP129() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP129(data);\n-        verify(\"testFloatP129\", data, goldFloatP129);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM192(float[] data) {\n-        for (int j = 192; j < RANGE; j++) {\n-            data[j + -192] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM192\")\n-    @Warmup(0)\n-    public static void runFloatM192() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM192(data);\n-        verify(\"testFloatM192\", data, goldFloatM192);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP192(float[] data) {\n-        for (int j = 0; j < RANGE - 192; j++) {\n-            data[j + 192] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP192\")\n-    @Warmup(0)\n-    public static void runFloatP192() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP192(data);\n-        verify(\"testFloatP192\", data, goldFloatP192);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP0(double[] data) {\n-        for (int j = 0; j < RANGE; j++) {\n-            data[j + 0] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP0\")\n-    @Warmup(0)\n-    public static void runDoubleP0() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP0(data);\n-        verify(\"testDoubleP0\", data, goldDoubleP0);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM1(double[] data) {\n-        for (int j = 1; j < RANGE; j++) {\n-            data[j + -1] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM1\")\n-    @Warmup(0)\n-    public static void runDoubleM1() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM1(data);\n-        verify(\"testDoubleM1\", data, goldDoubleM1);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect alignment.\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect alignment.\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect alignment.\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect alignment.\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect alignment.\n-    \/\/   No positive IR rule: conditions impossible.\n-    public static void testDoubleP1(double[] data) {\n-        for (int j = 0; j < RANGE - 1; j++) {\n-            data[j + 1] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP1\")\n-    @Warmup(0)\n-    public static void runDoubleP1() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP1(data);\n-        verify(\"testDoubleP1\", data, goldDoubleP1);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM2(double[] data) {\n-        for (int j = 2; j < RANGE; j++) {\n-            data[j + -2] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM2\")\n-    @Warmup(0)\n-    public static void runDoubleM2() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM2(data);\n-        verify(\"testDoubleM2\", data, goldDoubleM2);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP2(double[] data) {\n-        for (int j = 0; j < RANGE - 2; j++) {\n-            data[j + 2] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP2\")\n-    @Warmup(0)\n-    public static void runDoubleP2() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP2(data);\n-        verify(\"testDoubleP2\", data, goldDoubleP2);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM3(double[] data) {\n-        for (int j = 3; j < RANGE; j++) {\n-            data[j + -3] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM3\")\n-    @Warmup(0)\n-    public static void runDoubleM3() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM3(data);\n-        verify(\"testDoubleM3\", data, goldDoubleM3);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    \/\/   positive byte_offset 24 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    \/\/   positive byte_offset 24 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 24 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP3(double[] data) {\n-        for (int j = 0; j < RANGE - 3; j++) {\n-            data[j + 3] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP3\")\n-    @Warmup(0)\n-    public static void runDoubleP3() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP3(data);\n-        verify(\"testDoubleP3\", data, goldDoubleP3);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM4(double[] data) {\n-        for (int j = 4; j < RANGE; j++) {\n-            data[j + -4] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM4\")\n-    @Warmup(0)\n-    public static void runDoubleM4() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM4(data);\n-        verify(\"testDoubleM4\", data, goldDoubleM4);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    \/\/   positive byte_offset 32 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 32 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP4(double[] data) {\n-        for (int j = 0; j < RANGE - 4; j++) {\n-            data[j + 4] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP4\")\n-    @Warmup(0)\n-    public static void runDoubleP4() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP4(data);\n-        verify(\"testDoubleP4\", data, goldDoubleP4);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM7(double[] data) {\n-        for (int j = 7; j < RANGE; j++) {\n-            data[j + -7] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM7\")\n-    @Warmup(0)\n-    public static void runDoubleM7() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM7(data);\n-        verify(\"testDoubleM7\", data, goldDoubleM7);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    \/\/   positive byte_offset 56 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 56\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 56\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 56 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 56\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 56\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP7(double[] data) {\n-        for (int j = 0; j < RANGE - 7; j++) {\n-            data[j + 7] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP7\")\n-    @Warmup(0)\n-    public static void runDoubleP7() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP7(data);\n-        verify(\"testDoubleP7\", data, goldDoubleP7);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM8(double[] data) {\n-        for (int j = 8; j < RANGE; j++) {\n-            data[j + -8] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM8\")\n-    @Warmup(0)\n-    public static void runDoubleM8() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM8(data);\n-        verify(\"testDoubleM8\", data, goldDoubleM8);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 64 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 64\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 64\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP8(double[] data) {\n-        for (int j = 0; j < RANGE - 8; j++) {\n-            data[j + 8] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP8\")\n-    @Warmup(0)\n-    public static void runDoubleP8() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP8(data);\n-        verify(\"testDoubleP8\", data, goldDoubleP8);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM14(double[] data) {\n-        for (int j = 14; j < RANGE; j++) {\n-            data[j + -14] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM14\")\n-    @Warmup(0)\n-    public static void runDoubleM14() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM14(data);\n-        verify(\"testDoubleM14\", data, goldDoubleM14);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 112 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 112\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 112\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP14(double[] data) {\n-        for (int j = 0; j < RANGE - 14; j++) {\n-            data[j + 14] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP14\")\n-    @Warmup(0)\n-    public static void runDoubleP14() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP14(data);\n-        verify(\"testDoubleP14\", data, goldDoubleP14);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM16(double[] data) {\n-        for (int j = 16; j < RANGE; j++) {\n-            data[j + -16] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM16\")\n-    @Warmup(0)\n-    public static void runDoubleM16() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM16(data);\n-        verify(\"testDoubleM16\", data, goldDoubleM16);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 128 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 128\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 128\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP16(double[] data) {\n-        for (int j = 0; j < RANGE - 16; j++) {\n-            data[j + 16] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP16\")\n-    @Warmup(0)\n-    public static void runDoubleP16() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP16(data);\n-        verify(\"testDoubleP16\", data, goldDoubleP16);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM18(double[] data) {\n-        for (int j = 18; j < RANGE; j++) {\n-            data[j + -18] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM18\")\n-    @Warmup(0)\n-    public static void runDoubleM18() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM18(data);\n-        verify(\"testDoubleM18\", data, goldDoubleM18);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 144 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 144\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 144\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP18(double[] data) {\n-        for (int j = 0; j < RANGE - 18; j++) {\n-            data[j + 18] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP18\")\n-    @Warmup(0)\n-    public static void runDoubleP18() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP18(data);\n-        verify(\"testDoubleP18\", data, goldDoubleP18);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM20(double[] data) {\n-        for (int j = 20; j < RANGE; j++) {\n-            data[j + -20] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM20\")\n-    @Warmup(0)\n-    public static void runDoubleM20() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM20(data);\n-        verify(\"testDoubleM20\", data, goldDoubleM20);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 160 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 160\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 160\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP20(double[] data) {\n-        for (int j = 0; j < RANGE - 20; j++) {\n-            data[j + 20] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP20\")\n-    @Warmup(0)\n-    public static void runDoubleP20() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP20(data);\n-        verify(\"testDoubleP20\", data, goldDoubleP20);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM31(double[] data) {\n-        for (int j = 31; j < RANGE; j++) {\n-            data[j + -31] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM31\")\n-    @Warmup(0)\n-    public static void runDoubleM31() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM31(data);\n-        verify(\"testDoubleM31\", data, goldDoubleM31);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 248 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 248\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 248\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP31(double[] data) {\n-        for (int j = 0; j < RANGE - 31; j++) {\n-            data[j + 31] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP31\")\n-    @Warmup(0)\n-    public static void runDoubleP31() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP31(data);\n-        verify(\"testDoubleP31\", data, goldDoubleP31);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM32(double[] data) {\n-        for (int j = 32; j < RANGE; j++) {\n-            data[j + -32] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM32\")\n-    @Warmup(0)\n-    public static void runDoubleM32() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM32(data);\n-        verify(\"testDoubleM32\", data, goldDoubleM32);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP32(double[] data) {\n-        for (int j = 0; j < RANGE - 32; j++) {\n-            data[j + 32] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP32\")\n-    @Warmup(0)\n-    public static void runDoubleP32() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP32(data);\n-        verify(\"testDoubleP32\", data, goldDoubleP32);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM63(double[] data) {\n-        for (int j = 63; j < RANGE; j++) {\n-            data[j + -63] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM63\")\n-    @Warmup(0)\n-    public static void runDoubleM63() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM63(data);\n-        verify(\"testDoubleM63\", data, goldDoubleM63);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP63(double[] data) {\n-        for (int j = 0; j < RANGE - 63; j++) {\n-            data[j + 63] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP63\")\n-    @Warmup(0)\n-    public static void runDoubleP63() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP63(data);\n-        verify(\"testDoubleP63\", data, goldDoubleP63);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM64(double[] data) {\n-        for (int j = 64; j < RANGE; j++) {\n-            data[j + -64] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM64\")\n-    @Warmup(0)\n-    public static void runDoubleM64() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM64(data);\n-        verify(\"testDoubleM64\", data, goldDoubleM64);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP64(double[] data) {\n-        for (int j = 0; j < RANGE - 64; j++) {\n-            data[j + 64] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP64\")\n-    @Warmup(0)\n-    public static void runDoubleP64() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP64(data);\n-        verify(\"testDoubleP64\", data, goldDoubleP64);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM65(double[] data) {\n-        for (int j = 65; j < RANGE; j++) {\n-            data[j + -65] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM65\")\n-    @Warmup(0)\n-    public static void runDoubleM65() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM65(data);\n-        verify(\"testDoubleM65\", data, goldDoubleM65);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP65(double[] data) {\n-        for (int j = 0; j < RANGE - 65; j++) {\n-            data[j + 65] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP65\")\n-    @Warmup(0)\n-    public static void runDoubleP65() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP65(data);\n-        verify(\"testDoubleP65\", data, goldDoubleP65);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM128(double[] data) {\n-        for (int j = 128; j < RANGE; j++) {\n-            data[j + -128] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM128\")\n-    @Warmup(0)\n-    public static void runDoubleM128() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM128(data);\n-        verify(\"testDoubleM128\", data, goldDoubleM128);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP128(double[] data) {\n-        for (int j = 0; j < RANGE - 128; j++) {\n-            data[j + 128] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP128\")\n-    @Warmup(0)\n-    public static void runDoubleP128() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP128(data);\n-        verify(\"testDoubleP128\", data, goldDoubleP128);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM129(double[] data) {\n-        for (int j = 129; j < RANGE; j++) {\n-            data[j + -129] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM129\")\n-    @Warmup(0)\n-    public static void runDoubleM129() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM129(data);\n-        verify(\"testDoubleM129\", data, goldDoubleM129);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP129(double[] data) {\n-        for (int j = 0; j < RANGE - 129; j++) {\n-            data[j + 129] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP129\")\n-    @Warmup(0)\n-    public static void runDoubleP129() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP129(data);\n-        verify(\"testDoubleP129\", data, goldDoubleP129);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM192(double[] data) {\n-        for (int j = 192; j < RANGE; j++) {\n-            data[j + -192] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM192\")\n-    @Warmup(0)\n-    public static void runDoubleM192() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM192(data);\n-        verify(\"testDoubleM192\", data, goldDoubleM192);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP192(double[] data) {\n-        for (int j = 0; j < RANGE - 192; j++) {\n-            data[j + 192] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP192\")\n-    @Warmup(0)\n-    public static void runDoubleP192() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP192(data);\n-        verify(\"testDoubleP192\", data, goldDoubleP192);\n-    }\n-\n-    \/\/ ------------------- Initialization -------------------\n-\n-    static void init(int[] data) {\n-        for (int j = 0; j < RANGE; j++) {\n-            data[j] = (int)j;\n-        }\n-    }\n-\n-    static void init(long[] data) {\n-        for (int j = 0; j < RANGE; j++) {\n-            data[j] = (long)j;\n-        }\n-    }\n-\n-    static void init(short[] data) {\n-        for (int j = 0; j < RANGE; j++) {\n-            data[j] = (short)j;\n-        }\n-    }\n-\n-    static void init(char[] data) {\n-        for (int j = 0; j < RANGE; j++) {\n-            data[j] = (char)j;\n-        }\n-    }\n-\n-    static void init(byte[] data) {\n-        for (int j = 0; j < RANGE; j++) {\n-            data[j] = (byte)j;\n-        }\n-    }\n-\n-    static void init(float[] data) {\n-        for (int j = 0; j < RANGE; j++) {\n-            data[j] = (float)j;\n-        }\n-    }\n-\n-    static void init(double[] data) {\n-        for (int j = 0; j < RANGE; j++) {\n-            data[j] = (double)j;\n-        }\n-    }\n-\n-    \/\/ ------------------- Verification -------------------\n-\n-    static void verify(String context, int[] data, int[] gold) {\n-        for (int i = 0; i < RANGE; i++) {\n-            if (data[i] != gold[i]) {\n-                throw new RuntimeException(\" Invalid \" + context + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n-            }\n-        }\n-    }\n-    static void verify(String context, long[] data, long[] gold) {\n-        for (int i = 0; i < RANGE; i++) {\n-            if (data[i] != gold[i]) {\n-                throw new RuntimeException(\" Invalid \" + context + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n-            }\n-        }\n-    }\n-    static void verify(String context, short[] data, short[] gold) {\n-        for (int i = 0; i < RANGE; i++) {\n-            if (data[i] != gold[i]) {\n-                throw new RuntimeException(\" Invalid \" + context + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n-            }\n-        }\n-    }\n-    static void verify(String context, char[] data, char[] gold) {\n-        for (int i = 0; i < RANGE; i++) {\n-            if (data[i] != gold[i]) {\n-                throw new RuntimeException(\" Invalid \" + context + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n-            }\n-        }\n-    }\n-    static void verify(String context, byte[] data, byte[] gold) {\n-        for (int i = 0; i < RANGE; i++) {\n-            if (data[i] != gold[i]) {\n-                throw new RuntimeException(\" Invalid \" + context + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n-            }\n-        }\n-    }\n-    static void verify(String context, float[] data, float[] gold) {\n-        for (int i = 0; i < RANGE; i++) {\n-            if (data[i] != gold[i]) {\n-                throw new RuntimeException(\" Invalid \" + context + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n-            }\n-        }\n-    }\n-    static void verify(String context, double[] data, double[] gold) {\n-        for (int i = 0; i < RANGE; i++) {\n-            if (data[i] != gold[i]) {\n-                throw new RuntimeException(\" Invalid \" + context + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+        String counts() {\n+            if (!isPositiveRule) {\n+               return String.format(\"\"\"\n+                       @IR(failOn = {IRNode.LOAD_VECTOR_%s,\n+                                     IRNode.%s,\n+                                     IRNode.STORE_VECTOR},\n+                   \"\"\",\n+                   type.letter(),\n+                   irNode);\n+            } else if (size == null) {\n+               return String.format(\"\"\"\n+                       @IR(counts = {IRNode.LOAD_VECTOR_%s, \">0\",\n+                                     IRNode.%s, \">0\",\n+                                     IRNode.STORE_VECTOR, \">0\"},\n+                   \"\"\",\n+                   type.letter(),\n+                   irNode);\n+            } else {\n+               return String.format(\"\"\"\n+                       @IR(counts = {IRNode.LOAD_VECTOR_%s, IRNode.VECTOR_SIZE + \"%s\", \">0\",\n+                                     IRNode.%s, IRNode.VECTOR_SIZE + \"%s\", \">0\",\n+                                     IRNode.STORE_VECTOR, \">0\"},\n+                   \"\"\",\n+                   type.letter(), size,\n+                   irNode, size);\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestDependencyOffsets.java","additions":492,"deletions":15487,"binary":false,"changes":15979,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8342287\n+ * @summary Test that a fail path projection of a Template Assertion Predicate is not treated as success path projection.\n+ * @run main\/othervm -XX:-TieredCompilation -Xbatch\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.TestTemplateAssertionPredicateWithTwoUCTs::test\n+ *                   compiler.predicates.TestTemplateAssertionPredicateWithTwoUCTs\n+ *\/\n+\n+package compiler.predicates;\n+\n+public class TestTemplateAssertionPredicateWithTwoUCTs {\n+    static int iFld;\n+\n+    public static void main(String[] strArr) {\n+        for (int i = 0; i < 1000; i++) {\n+            test();\n+        }\n+    }\n+\n+    static void test() {\n+        int[][] lArr = new int[100][1];\n+        for (int i14 = 5; i14 < 273; ++i14) {\n+            int i16 = 1;\n+            while (++i16 < 94) {\n+                lArr[i16][0] += 1;\n+                switch (i14) {\n+                    case 11:\n+                    case 2:\n+                    case 13:\n+                        iFld = 34;\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/TestTemplateAssertionPredicateWithTwoUCTs.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress randomness\n+ * @bug 8342809\n+ * @summary Test that a top input into an IfTrue of an Assertion Predicate is properly handled during IGVN.\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -XX:CompileCommand=compileonly,compiler.predicates.TestTopIntoIfTrue::test -XX:-TieredCompilation\n+ *                   -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:+StressIGVN -XX:StressSeed=1073486978\n+ *                   compiler.predicates.TestTopIntoIfTrue\n+ * @run main\/othervm -XX:CompileCommand=compileonly,compiler.predicates.TestTopIntoIfTrue::test -XX:-TieredCompilation\n+ *                   -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:+StressIGVN compiler.predicates.TestTopIntoIfTrue\n+ *\/\n+\n+package compiler.predicates;\n+\n+public class TestTopIntoIfTrue {\n+    static int iFld;\n+\n+    public static void main(String[] strArr) {\n+        for (int i = 0; i < 100; i++) {\n+            test();\n+        }\n+    }\n+\n+    static void test() {\n+        int x = 10;\n+        for (int i = 1; i < 326; ++i) {\n+            x += 12;\n+            if (x != 0) {\n+                Unloaded.trap(); \/\/ unloaded trap\n+            }\n+            iFld += 34;\n+        }\n+    }\n+}\n+\n+class Unloaded {\n+    static void trap() {}\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/TestTopIntoIfTrue.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8341407\n+ * @summary C2: assert(main_limit == cl->limit() || get_ctrl(main_limit) == new_limit_ctrl) failed: wrong control for added limit\n+ *\n+ * @run main\/othervm -XX:CompileCommand=compileonly,TestLimitControlWhenNoRCEliminated::* -Xcomp TestLimitControlWhenNoRCEliminated\n+ *\n+ *\/\n+\n+public class TestLimitControlWhenNoRCEliminated {\n+    static long[] lArr;\n+    static int iFld;\n+\n+    public static void main(String[] strArr) {\n+        try {\n+            test();\n+        } catch (NullPointerException npe) {}\n+    }\n+\n+    static void test() {\n+        int x = iFld;\n+        int i = 1;\n+        do {\n+            lArr[i - 1] = 9;\n+            x += 1;\n+            iFld += x;\n+            if (x != 0) {\n+                A.foo();\n+            }\n+        } while (++i < 23);\n+    }\n+}\n+\n+class A {\n+    static void foo() {\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestLimitControlWhenNoRCEliminated.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8342330\n+ * @summary C2: \"node pinned on loop exit test?\" assert failure\n+ * @requires vm.flavor == \"server\"\n+  *\n+ * @run main\/othervm -XX:-BackgroundCompilation -XX:-UseOnStackReplacement -XX:-TieredCompilation\n+ *                   -XX:-UseLoopPredicate -XX:LoopMaxUnroll=0 TestSunkRangeFromPreLoopRCE\n+ *\n+ *\/\n+\n+\n+import java.util.Arrays;\n+\n+public class TestSunkRangeFromPreLoopRCE {\n+    private static int[] array = new int[1000];\n+    private static A objectField = new A(42);\n+\n+    public static void main(String[] args) {\n+        boolean[] allTrue = new boolean[1000];\n+        Arrays.fill(allTrue, true);\n+        boolean[] allFalse = new boolean[1000];\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(array.length\/4, allTrue, 1, 0);\n+            test1(array.length\/4, allFalse, 1, 0);\n+        }\n+    }\n+\n+    private static int test1(int stop, boolean[] flags, int otherScale, int x) {\n+        int scale;\n+        for (scale = 0; scale < 4; scale++) {\n+            for (int i = 0; i < 10; i++) {\n+\n+            }\n+        }\n+        if (array == null) {\n+        }\n+        int v = 0;\n+        for (int i = 0; i < stop; i++) {\n+            v += array[i];\n+            v += array[scale * i];\n+            if (i * scale + (objectField.intField + 1) == x) {\n+            }\n+            v += (scale - 4) * (x-objectField.intField);\n+            if (flags[i]) {\n+                return (x-objectField.intField);\n+            }\n+        }\n+        return v;\n+    }\n+\n+    private static class A {\n+        A(int field) {\n+            intField = field;\n+        }\n+        public int intField;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestSunkRangeFromPreLoopRCE.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -28,1 +28,1 @@\n-*           | (os.arch == \"riscv64\" & vm.cpu.features ~= \".*zfh.*\")\n+*           | (os.arch == \"riscv64\" & vm.cpu.features ~= \".*zvfh.*\")\n@@ -43,1 +43,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"f16c\", \"true\", \"avx512vl\", \"true\"}, counts = {IRNode.VECTOR_CAST_HF2F, IRNode.VECTOR_SIZE_ANY, \">= 1\", IRNode.VECTOR_CAST_F2HF, IRNode.VECTOR_SIZE_ANY, \" >= 1\"})\n+    @IR(applyIfCPUFeatureOr = {\"f16c\", \"true\", \"avx512vl\", \"true\", \"zvfh\", \"true\"}, counts = {IRNode.VECTOR_CAST_HF2F, IRNode.VECTOR_SIZE_ANY, \">= 1\", IRNode.VECTOR_CAST_F2HF, IRNode.VECTOR_SIZE_ANY, \" >= 1\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloat16VectorConvChain.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,3 +29,0 @@\n- * @requires (os.simpleArch == \"x64\" & (vm.cpu.features ~= \".*avx512f.*\" | vm.cpu.features ~= \".*f16c.*\")) |\n- *           os.arch == \"aarch64\" |\n- *           (os.arch == \"riscv64\" & vm.cpu.features ~= \".*zvfh.*\")\n@@ -56,1 +53,3 @@\n-    @IR(counts = {IRNode.VECTOR_CAST_F2HF, IRNode.VECTOR_SIZE + \"min(max_float, max_short)\", \"> 0\"})\n+    @IR(counts = {IRNode.VECTOR_CAST_F2HF, IRNode.VECTOR_SIZE + \"min(max_float, max_short)\", \"> 0\"},\n+                  applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"},\n+                  applyIfCPUFeatureOr = {\"f16c\", \"true\", \"avx512f\", \"true\", \"zvfh\", \"true\", \"asimd\", \"true\", \"sve\", \"true\"})\n@@ -70,1 +69,10 @@\n-    @Run(test = {\"test_float_float16\", \"test_float_float16_strided\"}, mode = RunMode.STANDALONE)\n+    @Test\n+    public void test_float_float16_short_vector(short[] sout, float[] finp) {\n+        for (int i = 0; i < finp.length; i+= 4) {\n+            sout[i+0] = Float.floatToFloat16(finp[i+0]);\n+            sout[i+1] = Float.floatToFloat16(finp[i+1]);\n+        }\n+    }\n+\n+    @Run(test = {\"test_float_float16\", \"test_float_float16_strided\",\n+                 \"test_float_float16_short_vector\"}, mode = RunMode.STANDALONE)\n@@ -96,0 +104,9 @@\n+\n+        for (int i = 0; i < ITERS; i++) {\n+            test_float_float16_short_vector(sout, finp);\n+        }\n+\n+        \/\/ Verifying the result\n+        for (int i = 0; i < ARRLEN; i++) {\n+            Asserts.assertEquals(Float.floatToFloat16(finp[i]), sout[i]);\n+        }\n@@ -99,1 +116,3 @@\n-    @IR(counts = {IRNode.VECTOR_CAST_HF2F, IRNode.VECTOR_SIZE + \"min(max_float, max_short)\", \"> 0\"})\n+    @IR(counts = {IRNode.VECTOR_CAST_HF2F, IRNode.VECTOR_SIZE + \"min(max_float, max_short)\", \"> 0\"},\n+                  applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"},\n+                  applyIfCPUFeatureOr = {\"f16c\", \"true\", \"avx512f\", \"true\", \"zvfh\", \"true\", \"asimd\", \"true\", \"sve\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloatConversionsVector.java","additions":25,"deletions":6,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8342496\n+ * @summary C2\/Shenandoah: SEGV in compiled code when running jcstress\n+ * @requires vm.flavor == \"server\"\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation\n+ *                   -XX:+UseShenandoahGC -XX:LoopMaxUnroll=0\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM -XX:StressSeed=270847015\n+ *                   TestLoadBypassesNullCheck\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation\n+ *                   -XX:+UseShenandoahGC -XX:LoopMaxUnroll=0\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM\n+ *                   TestLoadBypassesNullCheck\n+ *\n+ *\/\n+\n+public class TestLoadBypassesNullCheck {\n+    private static A fieldA = new A();\n+    private static Object fieldO = new Object();\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            test1();\n+        }\n+        fieldA = null;\n+        try {\n+            test1();\n+        } catch (NullPointerException npe) {\n+        }\n+    }\n+\n+    private static boolean test1() {\n+        for (int i = 0; i < 1000; i++) {\n+            volatileField = 42;\n+            A a = fieldA;\n+            Object o = a.fieldO;\n+            if (o == fieldO) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static class A {\n+        public Object fieldO;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestLoadBypassesNullCheck.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -37,0 +37,2 @@\n+\n+    static final int WASTE_SIZE = 1024;\n@@ -38,0 +40,1 @@\n+    static Object sink;\n@@ -62,1 +65,4 @@\n-                \/\/ fill until OOM\n+                \/\/ Fill until OOM and fail. This sets up heap for secondary OOM\n+                \/\/ later on, which should be caught by CDS code. The size of waste\n+                \/\/ array defines how much max free space would be left for later\n+                \/\/ code to run with.\n@@ -64,2 +70,2 @@\n-                for (;;) {\n-                    waste.add(new byte[64*1024]);\n+                while (true) {\n+                    waste.add(new byte[WASTE_SIZE]);\n@@ -107,2 +113,2 @@\n-        for (int x=0; x<10; x++) {\n-            Object[] a = new Object[10000];\n+        for (int x = 0; x < 10; x++) {\n+            sink = new byte[WASTE_SIZE];\n@@ -118,1 +124,1 @@\n-            Object o = new Object();\n+            sink = new Object();\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/javaldr\/GCDuringDumpTransformer.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-        \/\/ Dump heap objects with ParallelGC and SerialGC\n+        \/\/ Dump heap objects with Parallel, Serial, Shenandoah GC\n@@ -114,0 +114,3 @@\n+        if (GC.Shenandoah.isSupported()) {\n+            testDump(4, \"-XX:+UseShenandoahGC\", \"\", \"\", false);\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/sharedStrings\/IncompatibleOptions.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Basic compatibility test for Attach API v2\n+ * @bug 8219896\n+ * @library \/test\/lib\n+ * @modules jdk.attach\/sun.tools.attach\n+ *\n+ * @run main\/othervm -Xlog:attach=trace CompatTest\n+ * @run main\/othervm -Xlog:attach=trace -Djdk.attach.compat=true CompatTest\n+ *\/\n+\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n+import java.io.IOException;\n+\n+import com.sun.tools.attach.VirtualMachine;\n+import sun.tools.attach.HotSpotVirtualMachine;\n+\n+import jdk.test.lib.apps.LingeredApp;\n+\n+public class CompatTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ if the test (client part) in the \"compat\" mode\n+        boolean clientCompat = \"true\".equals(System.getProperty(\"jdk.attach.compat\"));\n+        System.out.println(\"Client is in compat mode: \" + clientCompat);\n+        LingeredApp app = null;\n+        try {\n+            app = LingeredApp.startApp(\"-Xlog:attach=trace\");\n+            test(app, clientCompat);\n+        } finally {\n+            LingeredApp.stopApp(app);\n+        }\n+\n+        try {\n+            app = LingeredApp.startApp(\"-Xlog:attach=trace\", \"-Djdk.attach.compat=true\");\n+            \/\/ target VM in \"compat\" mode, always expect failure\n+            test(app, true);\n+        } finally {\n+            LingeredApp.stopApp(app);\n+        }\n+\n+    }\n+\n+    \/\/ The test uses HotSpotVirtualMachine.setFlag method with long flag value.\n+    \/\/ For attach API v1 an exception is expected to be thrown (argument cannot be longer than 1024 characters).\n+    private static String flagName = \"HeapDumpPath\";\n+    \/\/ long for v1\n+    private static String flagValue = \"X\" + \"A\".repeat(1024) + \"X\";\n+\n+    private static void test(LingeredApp app, boolean expectFailure) throws Exception {\n+        System.out.println(\"======== Start ========\");\n+\n+        HotSpotVirtualMachine vm = (HotSpotVirtualMachine)VirtualMachine.attach(String.valueOf(app.getPid()));\n+\n+        BufferedReader replyReader = null;\n+        try {\n+            replyReader = new BufferedReader(new InputStreamReader(\n+                vm.setFlag(flagName, flagValue)));\n+\n+            if (expectFailure) {\n+                throw new RuntimeException(\"No expected exception is thrown\");\n+            }\n+\n+            String line;\n+            while ((line = replyReader.readLine()) != null) {\n+                System.out.println(\"setFlag reply: \" + line);\n+            }\n+            replyReader.close();\n+\n+        } catch (IOException ex) {\n+            System.out.println(\"OK: setFlag thrown expected exception:\");\n+            ex.printStackTrace(System.out);\n+        } finally {\n+            vm.detach();\n+        }\n+\n+        System.out.println(\"======== End ========\");\n+        System.out.println();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/attach\/AttachAPIv2\/CompatTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8340698\n+ * @summary JVMTI FRAME_POP event is sometimes missed if NotifyFramePop is called as a method is returning\n+ * @requires vm.jvmti\n+ * @library \/test\/lib\n+ * @compile NotifyFramePopStressTest.java\n+ * @run main\/othervm\/native -agentlib:NotifyFramePopStressTest NotifyFramePopStressTest\n+ *\/\n+\n+import jtreg.SkippedException;\n+\n+public class NotifyFramePopStressTest {\n+    static volatile boolean done = false;\n+\n+    public static void main(String args[]) {\n+        if (!canGenerateFramePopEvents()) {\n+            throw new SkippedException(\"FramePop event is not supported\");\n+        }\n+        Thread testThread = Thread.currentThread();\n+        Thread controlThread = new Thread(() -> control(testThread), \"Control Thread\");\n+\n+        setFramePopNotificationMode(testThread);\n+        controlThread.start();\n+        sleep(10);\n+\n+        for (int i = 0; i < 10*1000; i++) {\n+            foo();\n+            bar();\n+        }\n+        done = true;\n+\n+        try {\n+            controlThread.join();\n+        } catch (InterruptedException e) {\n+        }\n+\n+        if (failed()) {\n+            throw new RuntimeException(\"Test FAILED: see log for details\");\n+        } else {\n+            log(\"Test PASSED\");\n+        }\n+    }\n+\n+    private static void sleep(long ms) {\n+        try {\n+            Thread.sleep(ms);\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    private static void control(Thread thread) {\n+        int notifyCount = 0;\n+\n+        log(\"control has started\");\n+        while (!done) {\n+            suspend(thread);\n+            if (done) {\n+                \/\/ Double check after suspending the thread. We don't want to do the notify\n+                \/\/ if the main thread thinks it is done. An untimely notify during the\n+                \/\/ join() call will result in a deadlock.\n+                resume(thread);\n+                break;\n+            }\n+            if (notifyFramePop(thread)) {\n+                notifyCount++;\n+                log(\"control incremented notifyCount to \" + notifyCount);\n+            }\n+            resume(thread);\n+            int waitCount = 0;\n+            while (notifyCount != getPopCount()) {\n+                sleep(1);\n+                waitCount++;\n+                if (waitCount > 1000) {\n+                    break;\n+                }\n+            }\n+            if (waitCount > 100) {\n+                log(\"About to fail. notifyCount=\" + notifyCount + \" getPopCount()=\" + getPopCount());\n+                throw new RuntimeException(\"Test FAILED: Waited too long for notify: \" + waitCount);\n+            }\n+        }\n+        log(\"control has finished: \" + notifyCount);\n+    }\n+\n+    private native static void suspend(Thread thread);\n+    private native static void resume(Thread thread);\n+    private native static int getPopCount();\n+    private native static boolean failed();\n+    private native static boolean canGenerateFramePopEvents();\n+    private native static void setFramePopNotificationMode(Thread thread);\n+    private native static boolean notifyFramePop(Thread thread);\n+\n+    private static void log(String msg) {\n+        System.out.println(msg);\n+    }\n+\n+    private static int fetchIntFoo() {\n+        return 13;\n+    }\n+\n+    private static int fetchIntBar() {\n+        return 33;\n+    }\n+\n+    private static int foo() {\n+        return fetchIntFoo();\n+    }\n+\n+    private static int bar() {\n+        return fetchIntBar();\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/NotifyFramePopStressTest\/NotifyFramePopStressTest.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.hpp\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+static jvmtiEnv *jvmti;\n+static jvmtiCapabilities caps;\n+static jvmtiEventCallbacks callbacks;\n+static volatile jint pop_count;\n+static char* volatile last_notify_method;\n+static volatile jboolean failed = JNI_FALSE;\n+static jboolean seenMain = JNI_FALSE;\n+\n+static jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved);\n+\n+JNIEXPORT\n+jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT\n+jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT\n+jint JNICALL JNI_OnLoad(JavaVM *jvm, void *reserved) {\n+  return JNI_VERSION_9;\n+}\n+\n+static void JNICALL\n+FramePop(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread,\n+         jmethodID method, jboolean wasPoppedByException) {\n+  jvmtiError err;\n+  jclass cls = nullptr;\n+  char* csig = nullptr;\n+  char* name = nullptr;\n+\n+  err = jvmti->GetMethodDeclaringClass(method, &cls);\n+  check_jvmti_status(jni, err, \"FramePop: Failed in JVMTI GetMethodDeclaringClass\");\n+\n+  err = jvmti->GetClassSignature(cls, &csig, nullptr);\n+  check_jvmti_status(jni, err, \"FramePop: Failed in JVMTI GetClassSignature\");\n+\n+  name = get_method_name(jvmti, jni, method);\n+  LOG(\"FramePop(%d) event from method: %s %s\\n\", pop_count + 1, csig, name);\n+\n+  if (strcmp(name, \"main\") != 0) { \/\/ ignore FRAME_POP for main that comes in as the test exits\n+    if (strcmp(name, (char*)last_notify_method) != 0) {\n+      LOG(\"ERROR: FramePop event is for wrong method: expected %s, got %s\\n\", last_notify_method, name);\n+      failed = JNI_TRUE;\n+    }\n+  }\n+  pop_count++;\n+  deallocate(jvmti, jni, csig);\n+  deallocate(jvmti, jni, name);\n+}\n+\n+static\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jint res;\n+  jvmtiError err;\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_9);\n+  if (res != JNI_OK || jvmti == nullptr) {\n+    LOG(\"GetEnv(JVMTI_VERSION_9) failed error(%d)\", res);\n+    return JNI_ERR;\n+  }\n+  err = jvmti->GetPotentialCapabilities(&caps);\n+  check_jvmti_error(err, \"Agent: GetPotentialCapabilities failed\");\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  check_jvmti_error(err, \"Agent: AddCapabilities failed\");\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  check_jvmti_error(err, \"Agent: GetCapabilities failed\");\n+\n+  if (caps.can_generate_frame_pop_events) {\n+    callbacks.FramePop = &FramePop;\n+    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+    check_jvmti_error(err, \"Agent: SetEventCallbacks failed\");\n+  }\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_NotifyFramePopStressTest_canGenerateFramePopEvents(JNIEnv *env, jclass cls) {\n+  return caps.can_generate_frame_pop_events ? JNI_TRUE : JNI_FALSE;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_NotifyFramePopStressTest_setFramePopNotificationMode(JNIEnv *env, jclass cl, jthread thread) {\n+  set_event_notification_mode(jvmti, env, JVMTI_ENABLE, JVMTI_EVENT_FRAME_POP, thread);\n+}\n+\n+\/*\n+ * Call NotifyFramePop on the current frame.\n+ *\/\n+JNIEXPORT jboolean JNICALL\n+Java_NotifyFramePopStressTest_notifyFramePop(JNIEnv *jni, jclass cls, jthread thread) {\n+  jmethodID method;\n+  jlocation loc;\n+  char* name;\n+  jvmtiError err;\n+  jboolean isMain;\n+\n+  err = jvmti->GetFrameLocation(thread, 0, &method, &loc);\n+  check_jvmti_status(jni, err, \"notifyFramePop: Failed in JVMTI GetFrameLocation\");\n+\n+  name = get_method_name(jvmti, jni, method);\n+\n+  \/\/ We only want to do a NotifyFramePop once for the main method. The sole purpose is\n+  \/\/ to force the thread into interpOnly mode, which seems to help the test's timing\n+  \/\/ in a way that makes it more likely to reproduce the issue.\n+  isMain = (strcmp(name, \"main\") == 0);\n+  if (isMain) {\n+    if (seenMain) {\n+      deallocate(jvmti, jni, name);\n+      return JNI_FALSE; \/\/ Only do NotifyFramePop once for main()\n+    } else {\n+      seenMain = JNI_TRUE;\n+    }\n+  }\n+\n+  err= jvmti->NotifyFramePop(thread, 0);\n+  if (err == JVMTI_ERROR_OPAQUE_FRAME || err == JVMTI_ERROR_DUPLICATE) {\n+    \/\/LOG(\"\\nNotifyFramePop for method %s returned acceptable error: %s\\n\", name, TranslateError(err));\n+    deallocate(jvmti, jni, name);\n+    return JNI_FALSE;\n+  }\n+  check_jvmti_status(jni, err, \"notifyFramePop: Failed in JVMTI notifyFramePop\");\n+  LOG(\"\\nNotifyFramePop called for method %s\\n\", name);\n+\n+  if (isMain) {\n+    LOG(\"notifyFramePop not counting main method\\n\");\n+    deallocate(jvmti, jni, name);\n+    return JNI_FALSE;\n+  } else {\n+    deallocate(jvmti, jni, last_notify_method);\n+    last_notify_method = name;\n+    return JNI_TRUE;\n+  }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_NotifyFramePopStressTest_suspend(JNIEnv *jni, jclass cls, jthread thread) {\n+  suspend_thread(jvmti, jni, thread);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_NotifyFramePopStressTest_resume(JNIEnv *jni, jclass cls, jthread thread) {\n+  resume_thread(jvmti, jni, thread);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_NotifyFramePopStressTest_getPopCount(JNIEnv *env, jclass cls) {\n+  return pop_count;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_NotifyFramePopStressTest_failed(JNIEnv *env, jclass cls) {\n+  return failed;\n+}\n+\n+#ifdef __cplusplus\n+}\n+#endif\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/NotifyFramePopStressTest\/libNotifyFramePopStressTest.cpp","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -106,1 +106,1 @@\n-            checkLongValue(\"VM_Version::CPU_SHA\",\n+            checkLongValue(\"VM_Version::CPU_SHA \",\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbLongConstant.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-        \/\/ JTREG_TEST_THREAD_FACTORY=Virtual.\n+        \/\/ JTREG=\"TEST_THREAD_FACTORY=Virtual\".\n@@ -160,1 +160,1 @@\n-        \/\/ JTREG_TEST_THREAD_FACTORY=Virtual.\n+        \/\/ JTREG=\"TEST_THREAD_FACTORY=Virtual\".\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-            \/\/ JTREG_TEST_THREAD_FACTORY=Virtual.\n+            \/\/ JTREG=\"TEST_THREAD_FACTORY=Virtual\".\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage004.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-java\/foreign\/TestUpcallStress.java                              8341584 generic-all\n","filename":"test\/jdk\/ProblemList-Xcomp.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -534,0 +534,1 @@\n+java\/io\/IO\/IO.java                                              8337935 linux-ppc64le\n@@ -588,1 +589,1 @@\n-java\/nio\/Buffer\/LimitDirectMemory.java                          8340728 generic-all\n+java\/nio\/Buffer\/LimitDirectMemory.java                          8342849 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,109 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8214892\n- * @summary Test that the onjcmd option of the jdwp agent works.\n- *\n- * @author Ralf Schmelter\n- *\n- * @library \/test\/lib\n- * @run compile --add-exports java.base\/jdk.internal.vm=ALL-UNNAMED -g OnJcmdTest.java\n- * @run main\/othervm --add-exports java.base\/jdk.internal.vm=ALL-UNNAMED -agentlib:jdwp=transport=dt_socket,address=localhost:0,onjcmd=y,server=y OnJcmdTest\n- *\/\n-\n-import java.lang.reflect.Method;\n-import java.util.Properties;\n-\n-import jdk.internal.vm.VMSupport;\n-import jdk.test.lib.JDKToolFinder;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class OnJcmdTest {\n-\n-    private static String getListenerAddress() throws Exception {\n-        Properties props = VMSupport.getAgentProperties();\n-        return props.getProperty(\"sun.jdwp.listenerAddress\", null);\n-    }\n-\n-    public static void main(String[] args) throws Throwable {\n-        \/\/ First check if we get the expected errors.\n-        OutputAnalyzer output = ProcessTools.executeTestJava(\n-                \"-agentlib:jdwp=transport=dt_socket,address=any,onjcmd=y\");\n-        output.shouldContain(\"Can only use onjcmd with server=y\");\n-        output.shouldHaveExitValue(1);\n-\n-        output = ProcessTools.executeTestJava(\n-                \"-agentlib:jdwp=transport=dt_socket,address=any,onjcmd=y,onthrow=a,launch=a\");\n-        output.shouldContain(\"Cannot combine onjcmd and launch suboptions\");\n-        output.shouldHaveExitValue(1);\n-\n-        \/\/ Make sure debugging is not yet started.\n-        String prop = getListenerAddress();\n-\n-        if (prop != null) {\n-            throw new RuntimeException(\"Listener address was set to \" + prop);\n-        }\n-\n-        \/\/ Now start it (test that it is OK to do this more than once).\n-        for (int i = 0; i < 3; ++i) {\n-            String jcmd = JDKToolFinder.getJDKTool(\"jcmd\");\n-            output = ProcessTools.executeProcess(jcmd,\n-                    Long.toString(ProcessTools.getProcessId()),\n-                    \"VM.start_java_debugging\");\n-\n-            String exp_str = i == 0 ? \"Debugging has been started.\" :\n-                                      \"Debugging is already active.\";\n-            output.shouldContain(exp_str);\n-            output.shouldContain(\"Transport : dt_socket\");\n-            output.shouldHaveExitValue(0);\n-        }\n-\n-        \/\/ Now the property should be set, as the jdwp agent waits for a\n-        \/\/ connection.\n-        long t1 = System.currentTimeMillis();\n-        long t2 = t1;\n-\n-        while(t2 - t1 < 4000) {\n-            prop = getListenerAddress();\n-\n-            if (prop != null) {\n-                if (prop.equals(\"localhost:0\")) {\n-                    throw new RuntimeException(\"Port was not expanded\");\n-                } else if (!prop.startsWith(\"dt_socket:\")) {\n-                    throw new RuntimeException(\"Invalid transport prop \" + prop);\n-                }\n-\n-                return;\n-            }\n-\n-            Thread.sleep(50);\n-            t2 = System.currentTimeMillis();\n-        }\n-\n-        throw new RuntimeException(\"Debugging backend didn't start\");\n-    }\n-}\n","filename":"test\/jdk\/com\/sun\/jdi\/OnJcmdTest.java","additions":0,"deletions":109,"binary":false,"changes":109,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @author Artem.Semenov@jetbrains.com\n@@ -34,7 +33,2 @@\n-import javax.swing.*;\n-import javax.swing.event.TableModelEvent;\n-import javax.swing.event.TableModelListener;\n-import javax.swing.table.AbstractTableModel;\n-import javax.swing.table.TableModel;\n-\n-import java.awt.*;\n+import java.awt.FlowLayout;\n+import java.awt.GridLayout;\n@@ -45,0 +39,6 @@\n+import javax.swing.JButton;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+import javax.swing.JTable;\n+import javax.swing.SwingUtilities;\n+import javax.swing.table.AbstractTableModel;\n@@ -70,0 +70,1 @@\n+        table.setPreferredScrollableViewportSize(table.getPreferredSize());\n@@ -85,1 +86,1 @@\n-                + \"Using mouse drag the header of the last culumn so the last column becomes the first one.\"\n+                + \"Using mouse drag the header of the last column so the last column becomes the first one.\"\n@@ -91,0 +92,1 @@\n+        table.setPreferredScrollableViewportSize(table.getPreferredSize());\n@@ -108,0 +110,1 @@\n+        table.setPreferredScrollableViewportSize(table.getPreferredSize());\n@@ -109,0 +112,1 @@\n+        secondTable.setPreferredScrollableViewportSize(secondTable.getPreferredSize());\n@@ -129,2 +133,2 @@\n-\n-                JPanel panel = new JPanel();\n+        table.setPreferredScrollableViewportSize(table.getPreferredSize());\n+        JPanel panel = new JPanel();\n","filename":"test\/jdk\/java\/awt\/a11y\/AccessibleJTableTest.java","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @requires vm.compMode != \"Xcomp\"\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStress.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/**\n+ * @test\n+ * @bug 8341975\n+ * @summary Tests the default charset. It should honor `stdout.encoding`\n+ *          which should be the same as System.out.charset()\n+ * @modules jdk.internal.le\n+ * @run junit\/othervm -Dstdout.encoding=UTF-8 DefaultCharsetTest\n+ * @run junit\/othervm -Dstdout.encoding=ISO-8859-1 DefaultCharsetTest\n+ * @run junit\/othervm -Dstdout.encoding=US-ASCII DefaultCharsetTest\n+ * @run junit\/othervm -Dstdout.encoding=foo DefaultCharsetTest\n+ * @run junit\/othervm DefaultCharsetTest\n+ *\/\n+public class DefaultCharsetTest {\n+    @Test\n+    public void testDefaultCharset() {\n+        var stdoutEncoding = System.getProperty(\"stdout.encoding\");\n+        var sysoutCharset = System.out.charset();\n+        var consoleCharset = System.console().charset();\n+        System.out.println(\"\"\"\n+                    stdout.encoding = %s\n+                    System.out.charset() = %s\n+                    System.console().charset() = %s\n+                \"\"\".formatted(stdoutEncoding, sysoutCharset.name(), consoleCharset.name()));\n+        assertEquals(consoleCharset, sysoutCharset,\n+            \"Charsets for System.out and Console differ for stdout.encoding: %s\".formatted(stdoutEncoding));\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/Console\/DefaultCharsetTest.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,217 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.ReadOnlyBufferException;\n+\n+import org.testng.annotations.*;\n+\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test\n+ * @bug 8341566\n+ * @summary Check for expected behavior of Reader.of().\n+ * @run testng Of\n+ *\/\n+public class Of {\n+    final static String CONTENT = \"Some Reader Test\";\n+\n+    \/*\n+     * Readers to be tested.\n+     *\/\n+    @DataProvider\n+    public static Reader[] readers() {\n+        return new Reader[] {\n+            new StringReader(CONTENT),\n+            Reader.of(CONTENT),\n+            Reader.of(new StringBuffer(CONTENT)),\n+            Reader.of(new StringBuilder(CONTENT)),\n+            Reader.of(ByteBuffer.allocateDirect(CONTENT.length() * 2)\n+                    .asCharBuffer().put(CONTENT).flip()),\n+            Reader.of(CharBuffer.wrap(CONTENT.toCharArray())),\n+            Reader.of(new CharSequence() {\n+                @Override\n+                public char charAt(int index) {\n+                    return CONTENT.charAt(index);\n+                }\n+\n+                @Override\n+                public int length() {\n+                    return CONTENT.length();\n+                }\n+\n+                @Override\n+                public CharSequence subSequence(int start, int end) {\n+                    \/\/ unused by Reader.Of's result\n+                    throw new UnsupportedOperationException();\n+                }\n+\n+                @Override\n+                public String toString() {\n+                    \/\/ Reader.Of's result SHALL NOT convert to String\n+                    throw new UnsupportedOperationException();\n+                }\n+            })\n+        };\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testRead(Reader reader) throws IOException {\n+        String s = \"\";\n+        for (int c; (c = reader.read()) != -1; s += (char) c);\n+        assertEquals(s, CONTENT, \"read() returned wrong value\");\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testReadBII(Reader reader) throws IOException {\n+        char[] c = new char[16];\n+        assertEquals(reader.read(c, 8, 8), 8,\n+                \"read(char[],int,int) does not respect given start or end\");\n+        assertEquals(reader.read(c, 0, 16), 8,\n+                \"read(char[],int,int) does not respect end of stream\");\n+        assertEquals(new String(c),\n+                CONTENT.substring(8, 16) + CONTENT.substring(0, 8),\n+                \"read(char[],int,int) provides wrong content\");\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testReadBIILenZero(Reader reader) throws IOException {\n+        assertEquals(reader.read(new char[1], 0, 0), 0,\n+                \"read(char[],int,int) != 0\");\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testReadDirectCharBuffer(Reader reader) throws IOException {\n+        CharBuffer charBuffer = ByteBuffer.allocateDirect(32).asCharBuffer();\n+        charBuffer.position(8);\n+        assertEquals(reader.read(charBuffer), 8,\n+                \"read(CharBuffer) does not respect position or limit\");\n+        charBuffer.rewind();\n+        assertEquals(reader.read(charBuffer), 8,\n+                \"read(CharBuffer) does not respect end of stream\");\n+        charBuffer.rewind();\n+        assertEquals(charBuffer.toString(),\n+                \/\/ last part first proofs that copy loops correctly stopped\n+                CONTENT.substring(8, 16) + CONTENT.substring(0, 8),\n+                \"read(CharBuffer) provides wrong content\");\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testReadNonDirectCharBuffer(Reader reader) throws IOException {\n+        CharBuffer charBuffer = CharBuffer.allocate(16);\n+        charBuffer.position(8);\n+        assertEquals(reader.read(charBuffer), 8,\n+                \"read(CharBuffer) does not respect position or limit\");\n+        charBuffer.rewind();\n+        assertEquals(reader.read(charBuffer), 8,\n+                \"read(CharBuffer) does not respect end of stream\");\n+        charBuffer.rewind();\n+        assertEquals(charBuffer.toString(),\n+                CONTENT.substring(8, 16) + CONTENT.substring(0, 8),\n+                \"read(CharBuffer) provides wrong content\");\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testReadCharBufferZeroRemaining(Reader reader) throws IOException {\n+        CharBuffer charBuffer = CharBuffer.allocate(0);\n+        assertEquals(reader.read(charBuffer), 0, \"read(CharBuffer) != 0\");\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testReady(Reader reader) throws IOException {\n+        assertTrue(reader.ready());\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testSkip(Reader reader) throws IOException {\n+        assertEquals(reader.skip(8), 8, \"skip() does not respect limit\");\n+        assertEquals(reader.skip(9), 8, \"skip() does not respect end of stream\");\n+        assertEquals(reader.skip(1), 0, \"skip() does not respect empty stream\");\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testTransferTo(Reader reader) throws IOException {\n+        StringWriter sw = new StringWriter(16);\n+        assertEquals(reader.transferTo(sw), 16, \"transferTo() != 16\");\n+        assertEquals(reader.transferTo(sw), 0,\n+                \"transferTo() does not respect empty stream\");\n+        assertEquals(sw.toString(), CONTENT,\n+                \"transferTo() provides wrong content\");\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testReadClosed(Reader reader) throws IOException {\n+        reader.close();\n+        assertThrows(IOException.class, () -> {reader.read();});\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testReadBIIClosed(Reader reader) throws IOException {\n+        reader.close();\n+        assertThrows(IOException.class, () -> reader.read(new char[1], 0, 1));\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testReadCharBufferClosed(Reader reader) throws IOException {\n+        CharBuffer charBuffer = CharBuffer.allocate(1);\n+        reader.close();\n+        assertThrows(IOException.class, () -> reader.read(charBuffer));\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testReadCharBufferZeroRemainingClosed(Reader reader) throws IOException {\n+        CharBuffer charBuffer = CharBuffer.allocate(0);\n+        reader.close();\n+        assertThrows(IOException.class, () -> reader.read(charBuffer));\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testReadyClosed(Reader reader) throws IOException {\n+        reader.close();\n+        assertThrows(IOException.class, () -> reader.ready());\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testSkipClosed(Reader reader) throws IOException {\n+        reader.close();\n+        assertThrows(IOException.class, () -> reader.skip(1));\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testTransferToClosed(Reader reader) throws IOException {\n+        reader.close();\n+        assertThrows(IOException.class, () -> reader.transferTo(new StringWriter(1)));\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testCloseClosed(Reader reader) throws IOException {\n+        reader.close();\n+        reader.close();\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/Reader\/Of.java","additions":217,"deletions":0,"binary":false,"changes":217,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-\/**\n+\/*\n@@ -45,1 +45,1 @@\n- * @bug 8215510 8283075\n+ * @bug 8215510 8283075 8338544\n@@ -71,0 +71,22 @@\n+        } else {\n+            assertNull(r.componentType());\n+        }\n+\n+        if (!r.isClassOrInterface()) {\n+            assertEquals(r.packageName(), \"\");\n+        }\n+    }\n+\n+    private static String classDisplayName(Class<?> c) {\n+        int arrayLevel = 0;\n+        while (c.isArray()) {\n+            arrayLevel++;\n+            c = c.componentType();\n+        }\n+        String name = c.getName();\n+        String simpleClassName;\n+        if (c.isPrimitive()) {\n+            simpleClassName = name;\n+        } else {\n+            int lastDot = name.lastIndexOf('.');\n+            simpleClassName = lastDot == -1 ? name : name.substring(lastDot + 1);\n@@ -72,0 +94,1 @@\n+        return simpleClassName + \"[]\".repeat(arrayLevel);\n@@ -80,0 +103,7 @@\n+        if (r.isArray()) {\n+            testClassDesc(r.componentType(), c.componentType());\n+        }\n+        if (r.isClassOrInterface()) {\n+            assertEquals(r.packageName(), c.getPackageName());\n+        }\n+        assertEquals(r.displayName(), classDisplayName(c));\n@@ -146,1 +176,2 @@\n-            assertEquals(r.arrayType().resolveConstantDesc(LOOKUP), String[].class);\n+            testClassDesc(r.arrayType(), String[].class);\n+            testClassDesc(r.arrayType(3), String[][][].class);\n","filename":"test\/jdk\/java\/lang\/constant\/ClassDescTest.java","additions":35,"deletions":4,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -1,188 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import com.sun.net.httpserver.Headers;\n-import com.sun.net.httpserver.HttpExchange;\n-import com.sun.net.httpserver.HttpHandler;\n-import com.sun.net.httpserver.HttpServer;\n-\n-import java.io.*;\n-import java.net.Authenticator;\n-import java.net.InetSocketAddress;\n-import java.net.ProxySelector;\n-import java.net.URI;\n-import java.net.http.HttpClient;\n-import java.net.http.HttpRequest;\n-import java.net.http.HttpResponse;\n-import java.nio.channels.*;\n-import java.nio.charset.StandardCharsets;\n-\n-import jdk.test.lib.net.IPSupport;\n-\n-\/**\n- * @test\n- * @bug 8263442\n- * @summary Potential bug in jdk.internal.net.http.common.Utils.CONTEXT_RESTRICTED\n- * @library \/test\/lib\n- * @run main\/othervm AuthFilter\n- *\/\n-\n-public class AuthFilter {\n-    static class Auth extends Authenticator {\n-    }\n-\n-    static HttpServer createServer() throws IOException {\n-        HttpServer server = HttpServer.create(new InetSocketAddress(0), 5);\n-        HttpHandler handler = (HttpExchange e) -> {\n-            InputStream is = e.getRequestBody();\n-            is.readAllBytes();\n-            is.close();\n-            Headers reqh = e.getRequestHeaders();\n-            if (reqh.containsKey(\"authorization\")) {\n-                e.sendResponseHeaders(500, -1);\n-            } else {\n-                e.sendResponseHeaders(200, -1);\n-            }\n-        };\n-        server.createContext(\"\/\", handler);\n-        return server;\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        test(false);\n-        test(true);\n-    }\n-\n-    \/**\n-     *  Fake proxy. Just looks for Proxy-Authorization header\n-     *  and returns error if seen. Returns 200 OK if not.\n-     *  Does not actually forward the request\n-     *\/\n-    static class ProxyServer extends Thread {\n-\n-        final ServerSocketChannel server;\n-        final int port;\n-        volatile SocketChannel c;\n-\n-        ProxyServer() throws IOException {\n-            server = ServerSocketChannel.open();\n-            server.bind(new InetSocketAddress(0));\n-            if (server.getLocalAddress() instanceof InetSocketAddress isa) {\n-                port = isa.getPort();\n-            } else {\n-                port = -1;\n-            }\n-        }\n-\n-        int getPort() {\n-            return port;\n-        }\n-\n-        static String ok = \"HTTP\/1.1 200 OK\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n-        static String notok1 = \"HTTP\/1.1 500 Internal Server Error\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n-        static String notok2 = \"HTTP\/1.1 501 Not Implemented\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n-\n-        static void reply(String msg, Writer writer) throws IOException {\n-            writer.write(msg);\n-            writer.flush();\n-        }\n-\n-        public void run() {\n-            try {\n-                c = server.accept();\n-                var cs = StandardCharsets.US_ASCII;\n-                LineNumberReader reader = new LineNumberReader(Channels.newReader(c, cs));\n-                Writer writer = Channels.newWriter(c, cs);\n-\n-                String line;\n-                while ((line=reader.readLine()) != null) {\n-                    if (line.indexOf(\"Proxy-Authorization\") != -1) {\n-                        reply(notok1, writer);\n-                        return;\n-                    }\n-                    if (line.equals(\"\")) {\n-                        \/\/ end of headers\n-                        reply(ok, writer);\n-                        return;\n-                    }\n-                }\n-                reply(notok2, writer);\n-            } catch (IOException e) {\n-            }\n-            try {\n-                server.close();\n-                c.close();\n-            } catch (IOException ee) {}\n-        }\n-    }\n-\n-    private static InetSocketAddress getLoopback(int port) throws IOException {\n-        if (IPSupport.hasIPv4()) {\n-            return new InetSocketAddress(\"127.0.0.1\", port);\n-        } else {\n-            return new InetSocketAddress(\"::1\", port);\n-        }\n-    }\n-\n-    public static void test(boolean useProxy) throws Exception {\n-        HttpServer server = createServer();\n-        int port = server.getAddress().getPort();\n-        ProxyServer proxy;\n-\n-        InetSocketAddress proxyAddr;\n-        String authHdr;\n-        if (useProxy) {\n-            proxy = new ProxyServer();\n-            proxyAddr = getLoopback(proxy.getPort());\n-            proxy.start();\n-            authHdr = \"Proxy-Authorization\";\n-        } else {\n-            authHdr = \"Authorization\";\n-            proxyAddr = null;\n-        }\n-\n-        server.start();\n-\n-        \/\/ proxyAddr == null => proxying disabled\n-        HttpClient client = HttpClient\n-                .newBuilder()\n-                .authenticator(new Auth())\n-                .proxy(ProxySelector.of(proxyAddr))\n-                .build();\n-\n-\n-        URI uri = new URI(\"http:\/\/127.0.0.1:\" + Integer.toString(port));\n-\n-        HttpRequest request = HttpRequest.newBuilder(uri)\n-                .header(authHdr, \"nonsense\")\n-                .GET()\n-                .build();\n-\n-        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\n-        int r = response.statusCode();\n-        System.out.println(r);\n-        server.stop(0);\n-        if (r != 200)\n-            throw new RuntimeException(\"Test failed : \" + r);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/AuthFilter.java","additions":0,"deletions":188,"binary":false,"changes":188,"status":"deleted"},{"patch":"@@ -29,1 +29,1 @@\n- * @build jdk.test.lib.net.SimpleSSLContext jdk.httpclient.test.lib.common.HttpServerAdapters\n+ * @build jdk.test.lib.net.SimpleSSLContext jdk.httpclient.test.lib.common.HttpServerAdapters ReferenceTracker\n","filename":"test\/jdk\/java\/net\/httpclient\/GZIPInputStreamTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -379,1 +379,1 @@\n-        AssertionError fail = TRACKER.check(500);\n+        AssertionError fail = TRACKER.check(1500);\n","filename":"test\/jdk\/java\/net\/httpclient\/ProxySelectorTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,524 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8326949\n+ * @summary Authorization header is removed when a proxy Authenticator is set\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext jdk.httpclient.test.lib.common.HttpServerAdapters\n+ *        jdk.httpclient.test.lib.http2.Http2TestServer\n+ *        jdk.test.lib.net.IPSupport\n+ *\n+ * @modules java.net.http\/jdk.internal.net.http.common\n+ *          java.net.http\/jdk.internal.net.http.frame\n+ *          java.net.http\/jdk.internal.net.http.hpack\n+ *          java.logging\n+ *          java.base\/sun.net.www.http\n+ *          java.base\/sun.net.www\n+ *          java.base\/sun.net\n+ *\n+ * @run main\/othervm UserAuthWithAuthenticator\n+ *\/\n+\n+import java.io.*;\n+import java.net.*;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Version;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpRequest.BodyPublishers;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import javax.net.ssl.*;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.regex.*;\n+import java.util.*;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import jdk.test.lib.net.URIBuilder;\n+import jdk.test.lib.net.IPSupport;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestHandler;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestExchange;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestServer;\n+import jdk.httpclient.test.lib.http2.Http2TestServer;\n+import com.sun.net.httpserver.BasicAuthenticator;\n+\n+import jdk.test.lib.net.URIBuilder;\n+\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+\n+public class UserAuthWithAuthenticator {\n+    private static final String AUTH_PREFIX = \"Basic \";\n+\n+    static class AuthTestHandler implements HttpTestHandler {\n+        volatile String authValue;\n+        final String response = \"Hello world\";\n+\n+        @Override\n+        public void handle(HttpTestExchange t) throws IOException {\n+            try (InputStream is = t.getRequestBody();\n+                 OutputStream os = t.getResponseBody()) {\n+                byte[] bytes = is.readAllBytes();\n+                authValue = t.getRequestHeaders()\n+                        .firstValue(\"Authorization\")\n+                        .orElse(AUTH_PREFIX)\n+                        .substring(AUTH_PREFIX.length());\n+                t.sendResponseHeaders(200, response.length());\n+                os.write(response.getBytes(US_ASCII));\n+                t.close();\n+            }\n+        }\n+\n+        String authValue() {return authValue;}\n+    }\n+\n+    \/\/ if useHeader is true, we expect the Authenticator was not called\n+    \/\/ and the user set header used. If false, Authenticator must\n+    \/\/ be called and the user set header not used.\n+\n+    \/\/ If rightPassword is true we expect the authentication to succeed and 200 OK\n+    \/\/ If false, then an error should be returned.\n+\n+    static void h2Test(final boolean useHeader, boolean rightPassword) throws Exception {\n+        SSLContext ctx;\n+        HttpTestServer h2s = null;\n+        HttpClient client = null;\n+        ExecutorService ex=null;\n+        try {\n+            ctx = new SimpleSSLContext().get();\n+            ex = Executors.newCachedThreadPool();\n+            InetAddress addr = InetAddress.getLoopbackAddress();\n+\n+            h2s = HttpTestServer.of(new Http2TestServer(addr, \"::1\", true, 0, ex,\n+                    10, null, ctx, false));\n+            AuthTestHandler h = new AuthTestHandler();\n+            var context = h2s.addHandler(h, \"\/test1\");\n+            context.setAuthenticator(new BasicAuthenticator(\"realm\") {\n+                public boolean checkCredentials(String username, String password) {\n+                    if (useHeader) {\n+                        return username.equals(\"user\") && password.equals(\"pwd\");\n+                    } else {\n+                        return username.equals(\"serverUser\") && password.equals(\"serverPwd\");\n+                    }\n+                }\n+            });\n+            h2s.start();\n+\n+            int port = h2s.getAddress().getPort();\n+            ServerAuth sa = new ServerAuth();\n+            var plainCreds = rightPassword? \"user:pwd\" : \"user:wrongPwd\";\n+            var encoded = java.util.Base64.getEncoder().encodeToString(plainCreds.getBytes(US_ASCII));\n+\n+            URI uri = URIBuilder.newBuilder()\n+                 .scheme(\"https\")\n+                 .host(addr.getHostAddress())\n+                 .port(port)\n+                 .path(\"\/test1\/foo.txt\")\n+                 .build();\n+\n+            HttpClient.Builder builder = HttpClient.newBuilder()\n+                    .sslContext(ctx)\n+                    .executor(ex);\n+\n+            builder.authenticator(sa);\n+            client = builder.build();\n+\n+            HttpRequest req = HttpRequest.newBuilder(uri)\n+                    .version(HttpClient.Version.HTTP_2)\n+                    .header(useHeader ? \"Authorization\" : \"X-Ignore\", AUTH_PREFIX + encoded)\n+                    .GET()\n+                    .build();\n+\n+            HttpResponse<String> resp = client.send(req, HttpResponse.BodyHandlers.ofString());\n+            if (!useHeader) {\n+                assertTrue(resp.statusCode() == 200, \"Expected 200 response\");\n+                assertTrue(!h.authValue().equals(encoded), \"Expected user set header to not be set\");\n+                assertTrue(h.authValue().equals(sa.authValue()), \"Expected auth value from Authenticator\");\n+                assertTrue(sa.wasCalled(), \"Expected authenticator to be called\");\n+                System.out.println(\"h2Test: using authenticator OK\");\n+            } else if (rightPassword) {\n+                assertTrue(resp.statusCode() == 200, \"Expected 200 response\");\n+                assertTrue(h.authValue().equals(encoded), \"Expected user set header to be set\");\n+                assertTrue(!sa.wasCalled(), \"Expected authenticator not to be called\");\n+                System.out.println(\"h2Test: using user set header OK\");\n+            } else {\n+                assertTrue(resp.statusCode() == 401, \"Expected 401 response\");\n+                assertTrue(!sa.wasCalled(), \"Expected authenticator not to be called\");\n+                System.out.println(\"h2Test: using user set header with wrong password OK\");\n+            }\n+        } finally {\n+            if (h2s != null)\n+                h2s.stop();\n+            if (client != null)\n+                client.close();\n+            if (ex != null)\n+                ex.shutdown();\n+        }\n+    }\n+\n+    static final String data = \"0123456789\";\n+\n+    static final String data1 = \"ABCDEFGHIJKL\";\n+\n+    static final String[] proxyResponses = {\n+        \"HTTP\/1.1 407 Proxy Authentication Required\\r\\n\"+\n+        \"Content-Length: 0\\r\\n\" +\n+        \"Proxy-Authenticate: Basic realm=\\\"Access to the proxy\\\"\\r\\n\\r\\n\"\n+        ,\n+        \"HTTP\/1.1 200 OK\\r\\n\"+\n+        \"Date: Mon, 15 Jan 2001 12:18:21 GMT\\r\\n\" +\n+        \"Server: Apache\/1.3.14 (Unix)\\r\\n\" +\n+        \"Content-Length: \" + data.length() + \"\\r\\n\\r\\n\" + data\n+    };\n+\n+    static final String[] proxyWithErrorResponses = {\n+        \"HTTP\/1.1 407 Proxy Authentication Required\\r\\n\"+\n+        \"Content-Length: 0\\r\\n\" +\n+        \"Proxy-Authenticate: Basic realm=\\\"Access to the proxy\\\"\\r\\n\\r\\n\"\n+        ,\n+        \"HTTP\/1.1 407 Proxy Authentication Required\\r\\n\"+\n+        \"Content-Length: 0\\r\\n\" +\n+        \"Proxy-Authenticate: Basic realm=\\\"Access to the proxy\\\"\\r\\n\\r\\n\"\n+    };\n+\n+    static final String[] serverResponses = {\n+        \"HTTP\/1.1 200 OK\\r\\n\"+\n+        \"Date: Mon, 15 Jan 2001 12:18:21 GMT\\r\\n\" +\n+        \"Server: Apache\/1.3.14 (Unix)\\r\\n\" +\n+        \"Content-Length: \" + data1.length() + \"\\r\\n\\r\\n\" + data1\n+    };\n+\n+    static final String[] authenticatorResponses = {\n+        \"HTTP\/1.1 401 Authentication Required\\r\\n\"+\n+        \"Content-Length: 0\\r\\n\" +\n+        \"WWW-Authenticate: Basic realm=\\\"Access to the server\\\"\\r\\n\\r\\n\"\n+        ,\n+        \"HTTP\/1.1 200 OK\\r\\n\"+\n+        \"Date: Mon, 15 Jan 2001 12:18:21 GMT\\r\\n\" +\n+        \"Server: Apache\/1.3.14 (Unix)\\r\\n\" +\n+        \"Content-Length: \" + data1.length() + \"\\r\\n\\r\\n\" + data1\n+    };\n+\n+    public static void main(String[] args) throws Exception {\n+        testServerOnly();\n+        testServerWithProxy();\n+        testServerWithProxyError();\n+        testServerOnlyAuthenticator();\n+        h2Test(true, true);\n+        h2Test(false, true);\n+        h2Test(true, false);\n+    }\n+\n+    static void testServerWithProxy() throws IOException, InterruptedException {\n+        Mocker proxyMock = new Mocker(proxyResponses);\n+        proxyMock.start();\n+        ProxyAuth p = new ProxyAuth();\n+        try (var client = HttpClient.newBuilder()\n+                .version(java.net.http.HttpClient.Version.HTTP_1_1)\n+                .proxy(new ProxySel(proxyMock.getPort()))\n+                .authenticator(p)\n+                .build()) {\n+\n+            var plainCreds = \"user:pwd\";\n+            var encoded = java.util.Base64.getEncoder().encodeToString(plainCreds.getBytes(US_ASCII));\n+            var request = HttpRequest.newBuilder().uri(URI.create(\"http:\/\/127.0.0.1\/some_url\"))\n+                .setHeader(\"User-Agent\", \"myUserAgent\")\n+                .setHeader(\"Authorization\", AUTH_PREFIX + encoded)\n+                .build();\n+\n+            var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+\n+            assertEquals(200, response.statusCode());\n+            assertTrue(p.wasCalled(), \"Proxy authenticator was not called\");\n+            assertEquals(data, response.body());\n+            var proxyStr = proxyMock.getRequest(1);\n+\n+            assertContains(proxyStr, \"\/some_url\");\n+            assertPattern(\".*^Proxy-Authorization:.*Basic \" + encoded + \".*\", proxyStr);\n+            assertPattern(\".*^User-Agent:.*myUserAgent.*\", proxyStr);\n+            assertPattern(\".*^Authorization:.*Basic.*\", proxyStr);\n+            System.out.println(\"testServerWithProxy: OK\");\n+        } finally {\n+            proxyMock.stopMocker();\n+        }\n+    }\n+\n+    static void testServerWithProxyError() throws IOException, InterruptedException {\n+        Mocker proxyMock = new Mocker(proxyWithErrorResponses);\n+        proxyMock.start();\n+        ProxyAuth p = new ProxyAuth();\n+        try (var client = HttpClient.newBuilder()\n+                .version(java.net.http.HttpClient.Version.HTTP_1_1)\n+                .proxy(new ProxySel(proxyMock.getPort()))\n+                .authenticator(p)\n+                .build()) {\n+\n+            var badCreds = \"user:wrong\";\n+            var encoded1 = java.util.Base64.getEncoder().encodeToString(badCreds.getBytes(US_ASCII));\n+            var request = HttpRequest.newBuilder().uri(URI.create(\"http:\/\/127.0.0.1\/some_url\"))\n+                .setHeader(\"User-Agent\", \"myUserAgent\")\n+                .setHeader(\"Proxy-Authorization\", AUTH_PREFIX + encoded1)\n+                .build();\n+\n+            var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+\n+            var proxyStr = proxyMock.getRequest(0);\n+            assertEquals(407, response.statusCode());\n+            assertPattern(\".*^Proxy-Authorization:.*Basic \" + encoded1 + \".*\", proxyStr);\n+            assertTrue(!p.wasCalled(), \"Proxy Auth should not have been called\");\n+            System.out.println(\"testServerWithProxyError: OK\");\n+        } finally {\n+            proxyMock.stopMocker();\n+        }\n+    }\n+\n+    static void testServerOnly() throws IOException, InterruptedException {\n+        Mocker serverMock = new Mocker(serverResponses);\n+        serverMock.start();\n+        try (var client = HttpClient.newBuilder()\n+                .version(java.net.http.HttpClient.Version.HTTP_1_1)\n+                .build()) {\n+\n+            var plainCreds = \"user:pwd\";\n+            var encoded = java.util.Base64.getEncoder().encodeToString(plainCreds.getBytes(US_ASCII));\n+            var request = HttpRequest.newBuilder().uri(URI.create(serverMock.baseURL() + \"\/some_serv_url\"))\n+                .setHeader(\"User-Agent\", \"myUserAgent\")\n+                .setHeader(\"Authorization\", AUTH_PREFIX + encoded)\n+                .build();\n+\n+            var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+            assertEquals(200, response.statusCode());\n+            assertEquals(data1, response.body());\n+\n+            var serverStr = serverMock.getRequest(0);\n+            assertContains(serverStr, \"\/some_serv_url\");\n+            assertPattern(\".*^User-Agent:.*myUserAgent.*\", serverStr);\n+            assertPattern(\".*^Authorization:.*Basic \" + encoded + \".*\", serverStr);\n+            System.out.println(\"testServerOnly: OK\");\n+        } finally {\n+            serverMock.stopMocker();\n+        }\n+    }\n+\n+    \/\/ This is effectively a regression test for existing behavior\n+    static void testServerOnlyAuthenticator() throws IOException, InterruptedException {\n+        Mocker serverMock = new Mocker(authenticatorResponses);\n+        serverMock.start();\n+        try (var client = HttpClient.newBuilder()\n+                .version(java.net.http.HttpClient.Version.HTTP_1_1)\n+                .authenticator(new ServerAuth())\n+                .build()) {\n+\n+            \/\/ credentials set in the server authenticator\n+            var plainCreds = \"serverUser:serverPwd\";\n+            var encoded = java.util.Base64.getEncoder().encodeToString(plainCreds.getBytes(US_ASCII));\n+            var request = HttpRequest.newBuilder().uri(URI.create(serverMock.baseURL() + \"\/some_serv_url\"))\n+                .setHeader(\"User-Agent\", \"myUserAgent\")\n+                .build();\n+\n+            var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+            assertEquals(200, response.statusCode());\n+            assertEquals(data1, response.body());\n+\n+            var serverStr = serverMock.getRequest(1);\n+            assertContains(serverStr, \"\/some_serv_url\");\n+            assertPattern(\".*^User-Agent:.*myUserAgent.*\", serverStr);\n+            assertPattern(\".*^Authorization:.*Basic \" + encoded + \".*\", serverStr);\n+            System.out.println(\"testServerOnlyAuthenticator: OK\");\n+        } finally {\n+            serverMock.stopMocker();\n+        }\n+    }\n+\n+    static void close(Closeable... clarray) {\n+        for (Closeable c : clarray) {\n+            try {\n+                c.close();\n+            } catch (Exception e) {}\n+        }\n+    }\n+\n+    static class Mocker extends Thread {\n+        final ServerSocket ss;\n+        final String[] responses;\n+        volatile List<String> requests;\n+        volatile InputStream in;\n+        volatile OutputStream out;\n+        volatile Socket s = null;\n+\n+        public Mocker(String[] responses) throws IOException {\n+            this.ss = new ServerSocket(0, 0, InetAddress.getLoopbackAddress());\n+            this.responses = responses;\n+            this.requests = new LinkedList<>();\n+        }\n+\n+        public void stopMocker() {\n+            close(ss, s, in, out);\n+        }\n+\n+        public int getPort() {\n+            return ss.getLocalPort();\n+        }\n+\n+        public String baseURL() {\n+            try {\n+                return URIBuilder.newBuilder()\n+                    .scheme(\"http\")\n+                    .loopback()\n+                    .port(getPort())\n+                    .build()\n+                    .toString();\n+            } catch (URISyntaxException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        private String readRequest() throws IOException {\n+            String req = \"\";\n+            while (!req.endsWith(\"\\r\\n\\r\\n\")) {\n+                int x = in.read();\n+                if (x == -1) {\n+                    s.close();\n+                    s = ss.accept();\n+                    in = s.getInputStream();\n+                    out = s.getOutputStream();\n+                }\n+                req += (char)x;\n+            }\n+            return req;\n+        }\n+\n+        public String getRequest(int i) {\n+            return requests.get(i);\n+        }\n+\n+        public void run() {\n+            try {\n+                int index=0;\n+                s = ss.accept();\n+                in = s.getInputStream();\n+                out = s.getOutputStream();\n+                while (index < responses.length) {\n+                    requests.add(readRequest());\n+                    out.write(responses[index++].getBytes(US_ASCII));\n+                }\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    static class ProxySel extends ProxySelector {\n+        final int port;\n+\n+        ProxySel(int port) {\n+            this.port = port;\n+        }\n+        @Override\n+        public List<Proxy> select(URI uri) {\n+          return List.of(new Proxy(Proxy.Type.HTTP, new InetSocketAddress(\n+              InetAddress.getLoopbackAddress(), port)));\n+        }\n+\n+        @Override\n+        public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {}\n+\n+    }\n+\n+    static class ProxyAuth extends Authenticator {\n+        private volatile boolean called = false;\n+\n+        @Override\n+        protected PasswordAuthentication getPasswordAuthentication() {\n+            called = true;\n+            return new PasswordAuthentication(\"proxyUser\", \"proxyPwd\".toCharArray());\n+        }\n+\n+        boolean wasCalled() {\n+            return called;\n+        }\n+    }\n+\n+    static class ServerAuth extends Authenticator {\n+        private volatile boolean called = false;\n+\n+        private static String USER = \"serverUser\";\n+        private static String PASS = \"serverPwd\";\n+\n+        @Override\n+        protected PasswordAuthentication getPasswordAuthentication() {\n+            called = true;\n+            if (getRequestorType() != RequestorType.SERVER) {\n+                \/\/ We only want to handle server authentication here\n+                return null;\n+            }\n+            return new PasswordAuthentication(USER, PASS.toCharArray());\n+        }\n+\n+        String authValue() {\n+            var plainCreds = USER + \":\" + PASS;\n+            return java.util.Base64.getEncoder().encodeToString(plainCreds.getBytes(US_ASCII));\n+        }\n+\n+        boolean wasCalled() {\n+            return called;\n+        }\n+    }\n+\n+    static void assertTrue(boolean assertion, String failMsg) {\n+        if (!assertion) {\n+            throw new RuntimeException(failMsg);\n+        }\n+    }\n+\n+    static void assertEquals(int a, int b) {\n+        if (a != b) {\n+            String msg = String.format(\"Error: expected %d Got %d\", a, b);\n+            throw new RuntimeException(msg);\n+        }\n+    }\n+\n+    static void assertEquals(String s1, String s2) {\n+        if (!s1.equals(s2)) {\n+            String msg = String.format(\"Error: expected %s Got %s\", s1, s2);\n+            throw new RuntimeException(msg);\n+        }\n+    }\n+\n+    static void assertContains(String container, String containee) {\n+        if (!container.contains(containee)) {\n+            String msg = String.format(\"Error: expected %s Got %s\", container, containee);\n+            throw new RuntimeException(msg);\n+        }\n+    }\n+\n+    static void assertPattern(String pattern, String candidate) {\n+        Pattern pat = Pattern.compile(pattern, Pattern.DOTALL | Pattern.MULTILINE);\n+        Matcher matcher = pat.matcher(candidate);\n+        if (!matcher.matches()) {\n+            String msg = String.format(\"Error: expected %s Got %s\", pattern, candidate);\n+            throw new RuntimeException(msg);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/UserAuthWithAuthenticator.java","additions":524,"deletions":0,"binary":false,"changes":524,"status":"added"},{"patch":"@@ -0,0 +1,365 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8342075\n+ * @summary checks connection flow control\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.http2.Http2TestServer jdk.test.lib.net.SimpleSSLContext\n+ * @run testng\/othervm  -Djdk.internal.httpclient.debug=true\n+ *                      -Djdk.httpclient.connectionWindowSize=65535\n+ *                      -Djdk.httpclient.windowsize=16384\n+ *                      ConnectionFlowControlTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.ProtocolException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpHeaders;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpRequest.BodyPublishers;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandler;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.net.http.HttpResponse.BodySubscriber;\n+import java.net.http.HttpResponse.ResponseInfo;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Flow.Subscription;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSession;\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestServer;\n+import jdk.httpclient.test.lib.http2.BodyOutputStream;\n+import jdk.httpclient.test.lib.http2.Http2Handler;\n+import jdk.httpclient.test.lib.http2.Http2TestExchange;\n+import jdk.httpclient.test.lib.http2.Http2TestExchangeImpl;\n+import jdk.httpclient.test.lib.http2.Http2TestServer;\n+import jdk.httpclient.test.lib.http2.Http2TestServerConnection;\n+import jdk.internal.net.http.common.HttpHeadersBuilder;\n+import jdk.internal.net.http.frame.ContinuationFrame;\n+import jdk.internal.net.http.frame.HeaderFrame;\n+import jdk.internal.net.http.frame.HeadersFrame;\n+import jdk.internal.net.http.frame.Http2Frame;\n+import jdk.internal.net.http.frame.SettingsFrame;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static java.util.List.of;\n+import static java.util.Map.entry;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotEquals;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+public class ConnectionFlowControlTest {\n+\n+    SSLContext sslContext;\n+    HttpTestServer http2TestServer;   \/\/ HTTP\/2 ( h2c )\n+    HttpTestServer https2TestServer;  \/\/ HTTP\/2 ( h2  )\n+    String http2URI;\n+    String https2URI;\n+    final AtomicInteger reqid = new AtomicInteger();\n+\n+\n+    @DataProvider(name = \"variants\")\n+    public Object[][] variants() {\n+        return new Object[][] {\n+                { http2URI },\n+                { https2URI },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"variants\")\n+    void test(String uri) throws Exception {\n+        System.out.printf(\"%ntesting %s%n\", uri);\n+        ConcurrentHashMap<String, CompletableFuture<String>> responseSent = new ConcurrentHashMap<>();\n+        ConcurrentHashMap<String, HttpResponse<InputStream>> responses = new ConcurrentHashMap<>();\n+        FCHttp2TestExchange.setResponseSentCB((s) -> responseSent.get(s).complete(s));\n+        int connectionWindowSize = Math.max(Integer.getInteger(\n+                \"jdk.httpclient.connectionWindowSize\", 65535), 65535);\n+        int windowSize = Math.max(Integer.getInteger(\n+                \"jdk.httpclient.windowsize\", 65535), 16384);\n+        int max = connectionWindowSize \/ windowSize + 2;\n+        System.out.printf(\"connection window: %s, stream window: %s, will make %s requests%n\",\n+                connectionWindowSize, windowSize, max);\n+\n+        try (HttpClient client = HttpClient.newBuilder().sslContext(sslContext).build()) {\n+            String label = null;\n+\n+            Throwable t = null;\n+            try {\n+                String[] keys = new String[max];\n+                for (int i = 0; i < max; i++) {\n+                    String query = \"reqId=\" + reqid.incrementAndGet();\n+                    keys[i] = query;\n+                    URI uriWithQuery = URI.create(uri + \"?\" + query);\n+                    CompletableFuture<String> sent = new CompletableFuture<>();\n+                    responseSent.put(query, sent);\n+                    HttpRequest request = HttpRequest.newBuilder(uriWithQuery)\n+                            .POST(BodyPublishers.ofString(\"Hello there!\"))\n+                            .build();\n+                    System.out.println(\"\\nSending request:\" + uriWithQuery);\n+                    final HttpClient cc = client;\n+                    var response = cc.send(request, BodyHandlers.ofInputStream());\n+                    responses.put(query, response);\n+                    String ckey = response.headers().firstValue(\"X-Connection-Key\").get();\n+                    if (label == null) label = ckey;\n+                    try {\n+                        if (i < max - 1) {\n+                            \/\/ the connection window might be exceeded at i == max - 2, which\n+                            \/\/ means that the last request could go on a new connection.\n+                            assertEquals(ckey, label, \"Unexpected key for \" + query);\n+                        }\n+                    } catch (AssertionError ass) {\n+                        \/\/ since we won't pull all responses, the client\n+                        \/\/ will not exit unless we ask it to shutdown now.\n+                        client.shutdownNow();\n+                        throw ass;\n+                    }\n+                }\n+                try {\n+                    Thread.sleep(1000);\n+                } catch (InterruptedException ie) {\n+                    \/\/ ignore\n+                }\n+                CompletableFuture<?> allsent = CompletableFuture.allOf(responseSent.values().stream()\n+                        .toArray(CompletableFuture<?>[]::new));\n+                allsent.get();\n+                for (int i = 0; i < max; i++) {\n+                    try {\n+                        String query = keys[i];\n+                        var response = responses.get(keys[i]);\n+                        String ckey = response.headers().firstValue(\"X-Connection-Key\").get();\n+                        if (label == null) label = ckey;\n+                        assertEquals(ckey, label, \"Unexpected key for \" + query);\n+                        int wait = uri.startsWith(\"https:\/\/\") ? 500 : 250;\n+                        try (InputStream is = response.body()) {\n+                            Thread.sleep(Utils.adjustTimeout(wait));\n+                            is.readAllBytes();\n+                        }\n+                        System.out.printf(\"%s did not fail: %s%n\", query, response.statusCode());\n+                    } catch (AssertionError t1) {\n+                        \/\/ since we won't pull all responses, the client\n+                        \/\/ will not exit unless we ask it to shutdown now.\n+                        client.shutdownNow();\n+                        throw t1;\n+                    } catch (Throwable t0) {\n+                        System.out.println(\"Got EXPECTED: \" + t0);\n+                        if (t0 instanceof ExecutionException) {\n+                            t0 = t0.getCause();\n+                        }\n+                        t = t0;\n+                        try {\n+                            assertDetailMessage(t0, i);\n+                        } catch (AssertionError e) {\n+                            \/\/ since we won't pull all responses, the client\n+                            \/\/ will not exit unless we ask it to shutdown now.\n+                            client.shutdownNow();\n+                            throw e;\n+                        }\n+                    }\n+                }\n+            } catch (Throwable t0) {\n+                System.out.println(\"Got EXPECTED: \" + t0);\n+                if (t0 instanceof ExecutionException) {\n+                    t0 = t0.getCause();\n+                }\n+                t = t0;\n+            }\n+            if (t == null) {\n+                \/\/ we could fail here if we haven't waited long enough\n+                fail(\"Expected exception, got all responses, should sleep time be raised?\");\n+            } else {\n+                assertDetailMessage(t, max);\n+            }\n+            String query = \"reqId=\" + reqid.incrementAndGet();\n+            URI uriWithQuery = URI.create(uri + \"?\" + query);\n+            CompletableFuture<String> sent = new CompletableFuture<>();\n+            responseSent.put(query, sent);\n+            HttpRequest request = HttpRequest.newBuilder(uriWithQuery)\n+                    .POST(BodyPublishers.ofString(\"Hello there!\"))\n+                    .build();\n+            System.out.println(\"\\nSending last request:\" + uriWithQuery);\n+            var response = client.send(request, BodyHandlers.ofString());\n+            if (label != null) {\n+                String ckey = response.headers().firstValue(\"X-Connection-Key\").get();\n+                assertNotEquals(ckey, label);\n+                System.out.printf(\"last request %s sent on different connection as expected:\" +\n+                        \"\\n\\tlast: %s\\n\\tprevious: %s%n\", query, ckey, label);\n+            }\n+        }\n+    }\n+\n+    \/\/ Assertions based on implementation specific detail messages. Keep in\n+    \/\/ sync with implementation.\n+    static void assertDetailMessage(Throwable throwable, int iterationIndex) {\n+        try {\n+            Throwable cause = throwable;\n+            while (cause != null) {\n+                if (cause instanceof ProtocolException) {\n+                    if (cause.getMessage().contains(\"connection window exceeded\")) {\n+                       System.out.println(\"Found expected exception: \" + cause);\n+                       return;\n+                    }\n+                }\n+                cause = cause.getCause();\n+            }\n+            throw new AssertionError(\n+                    \"ProtocolException(\\\"protocol error: connection window exceeded\\\") not found\",\n+                             throwable);\n+        } catch (AssertionError e) {\n+            System.out.println(\"Exception does not match expectation: \" + throwable);\n+            throwable.printStackTrace(System.out);\n+            throw e;\n+        }\n+    }\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null)\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+\n+        var http2TestServer = new Http2TestServer(\"localhost\", false, 0);\n+        http2TestServer.addHandler(new Http2TestHandler(), \"\/http2\/\");\n+        this.http2TestServer = HttpTestServer.of(http2TestServer);\n+        http2URI = \"http:\/\/\" + this.http2TestServer.serverAuthority() + \"\/http2\/x\";\n+\n+        var https2TestServer = new Http2TestServer(\"localhost\", true, sslContext);\n+        https2TestServer.addHandler(new Http2TestHandler(), \"\/https2\/\");\n+        this.https2TestServer = HttpTestServer.of(https2TestServer);\n+        https2URI = \"https:\/\/\" + this.https2TestServer.serverAuthority() + \"\/https2\/x\";\n+\n+        \/\/ Override the default exchange supplier with a custom one to enable\n+        \/\/ particular test scenarios\n+        http2TestServer.setExchangeSupplier(FCHttp2TestExchange::new);\n+        https2TestServer.setExchangeSupplier(FCHttp2TestExchange::new);\n+\n+        this.http2TestServer.start();\n+        this.https2TestServer.start();\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws Exception {\n+        http2TestServer.stop();\n+        https2TestServer.stop();\n+    }\n+\n+    static class Http2TestHandler implements Http2Handler {\n+\n+        @Override\n+        public void handle(Http2TestExchange t) throws IOException {\n+            String query = t.getRequestURI().getRawQuery();\n+\n+            try (InputStream is = t.getRequestBody();\n+                 OutputStream os = t.getResponseBody()) {\n+\n+                byte[] bytes = is.readAllBytes();\n+                System.out.println(\"Server \" + t.getLocalAddress() + \" received:\\n\"\n+                        + t.getRequestURI() + \": \" + new String(bytes, StandardCharsets.UTF_8));\n+                t.getResponseHeaders().setHeader(\"X-Connection-Key\", t.getConnectionKey());\n+\n+                if (bytes.length == 0) bytes = \"no request body!\".getBytes(StandardCharsets.UTF_8);\n+                int window = Math.max(16384, Integer.getInteger(\"jdk.httpclient.windowsize\", 2*16*1024));\n+                 final int maxChunkSize;\n+                if (t instanceof FCHttp2TestExchange fct) {\n+                    maxChunkSize = Math.min(window, fct.conn.getMaxFrameSize());\n+                } else {\n+                    maxChunkSize = Math.min(window, SettingsFrame.MAX_FRAME_SIZE);\n+                }\n+                byte[] resp = bytes.length < maxChunkSize\n+                        ? bytes\n+                        : Arrays.copyOfRange(bytes, 0, maxChunkSize);\n+                int max = (window \/ resp.length);\n+                \/\/ send in chunks\n+                t.sendResponseHeaders(200, 0);\n+                int sent = 0;\n+                for (int i=0; i<=max; i++) {\n+                    int len = Math.min(resp.length, window - sent);\n+                    if (len <= 0) break;\n+                    if (os instanceof BodyOutputStream bos) {\n+                        try {\n+                            \/\/ we don't wait for the stream window, but we want\n+                            \/\/ to wait for the connection window\n+                            bos.waitForStreamWindow(len);\n+                        } catch (InterruptedException ie) {\n+                            \/\/ ignore and continue...\n+                        }\n+                    }\n+                    ((BodyOutputStream) os).writeUncontrolled(resp, 0, len);\n+                    sent += len;\n+                }\n+                if (sent != window) fail(\"should have sent %s, sent %s\".formatted(window, sent));\n+            }\n+            if (t instanceof FCHttp2TestExchange fct) {\n+                fct.responseSent(query);\n+            } else {\n+                fail(\"Exchange is not %s but %s\"\n+                        .formatted(FCHttp2TestExchange.class.getName(), t.getClass().getName()));\n+            }\n+        }\n+    }\n+\n+    \/\/ A custom Http2TestExchangeImpl that overrides sendResponseHeaders to\n+    \/\/ allow headers to be sent with a number of CONTINUATION frames.\n+    static class FCHttp2TestExchange extends Http2TestExchangeImpl {\n+        static volatile Consumer<String> responseSentCB;\n+        static void setResponseSentCB(Consumer<String> responseSentCB) {\n+            FCHttp2TestExchange.responseSentCB = responseSentCB;\n+        }\n+\n+        final Http2TestServerConnection conn;\n+        FCHttp2TestExchange(int streamid, String method, HttpHeaders reqheaders,\n+                             HttpHeadersBuilder rspheadersBuilder, URI uri, InputStream is,\n+                             SSLSession sslSession, BodyOutputStream os,\n+                             Http2TestServerConnection conn, boolean pushAllowed) {\n+            super(streamid, method, reqheaders, rspheadersBuilder, uri, is, sslSession, os, conn, pushAllowed);\n+            this.conn = conn;\n+        }\n+        public void responseSent(String query) {\n+            System.out.println(\"Server: response sent for \" + query);\n+            responseSentCB.accept(query);\n+        }\n+\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/ConnectionFlowControlTest.java","additions":365,"deletions":0,"binary":false,"changes":365,"status":"added"},{"patch":"@@ -0,0 +1,342 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8342075\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.http2.Http2TestServer jdk.test.lib.net.SimpleSSLContext\n+ * @run testng\/othervm  -Djdk.internal.httpclient.debug=true\n+ *                      -Djdk.httpclient.connectionWindowSize=65535\n+ *                      -Djdk.httpclient.windowsize=16384\n+ *                      StreamFlowControlTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.ProtocolException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpHeaders;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpRequest.BodyPublishers;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSession;\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestServer;\n+import jdk.httpclient.test.lib.http2.BodyOutputStream;\n+import jdk.httpclient.test.lib.http2.Http2Handler;\n+import jdk.httpclient.test.lib.http2.Http2TestExchange;\n+import jdk.httpclient.test.lib.http2.Http2TestExchangeImpl;\n+import jdk.httpclient.test.lib.http2.Http2TestServer;\n+import jdk.httpclient.test.lib.http2.Http2TestServerConnection;\n+import jdk.internal.net.http.common.HttpHeadersBuilder;\n+import jdk.internal.net.http.frame.SettingsFrame;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.fail;\n+\n+public class StreamFlowControlTest {\n+\n+    SSLContext sslContext;\n+    HttpTestServer http2TestServer;   \/\/ HTTP\/2 ( h2c )\n+    HttpTestServer https2TestServer;  \/\/ HTTP\/2 ( h2  )\n+    String http2URI;\n+    String https2URI;\n+    final AtomicInteger reqid = new AtomicInteger();\n+\n+\n+    @DataProvider(name = \"variants\")\n+    public Object[][] variants() {\n+        return new Object[][] {\n+                { http2URI,  false },\n+                { https2URI, false },\n+                { http2URI,  true },\n+                { https2URI, true },\n+        };\n+    }\n+\n+\n+    @Test(dataProvider = \"variants\")\n+    void test(String uri,\n+              boolean sameClient)\n+        throws Exception\n+    {\n+        System.out.printf(\"%ntesting test(%s, %s)%n\", uri, sameClient);\n+        ConcurrentHashMap<String, CompletableFuture<String>>  responseSent = new ConcurrentHashMap<>();\n+        FCHttp2TestExchange.setResponseSentCB((s) -> responseSent.get(s).complete(s));\n+\n+        HttpClient client = null;\n+        try {\n+            int max = sameClient ? 10 : 3;\n+            String label = null;\n+            for (int i = 0; i < max; i++) {\n+                if (!sameClient || client == null)\n+                    client = HttpClient.newBuilder().sslContext(sslContext).build();\n+\n+                String query = \"reqId=\" + reqid.incrementAndGet();\n+                URI uriWithQuery = URI.create(uri + \"?\" + query);\n+                CompletableFuture<String> sent = new CompletableFuture<>();\n+                responseSent.put(query, sent);\n+                HttpRequest request = HttpRequest.newBuilder(uriWithQuery)\n+                        .POST(BodyPublishers.ofString(\"Hello there!\"))\n+                        .build();\n+                System.out.println(\"\\nSending request:\" + uriWithQuery);\n+                final HttpClient cc = client;\n+                try {\n+                    HttpResponse<InputStream> response = cc.send(request, BodyHandlers.ofInputStream());\n+                    if (sameClient) {\n+                        String key = response.headers().firstValue(\"X-Connection-Key\").get();\n+                        if (label == null) label = key;\n+                        assertEquals(key, label, \"Unexpected key for \" + query);\n+                    }\n+                    sent.join();\n+                    \/\/ we have to pull to get the exception, but slow enough\n+                    \/\/ so that DataFrames are buffered up to the point that\n+                    \/\/ the window is exceeded...\n+                    int wait = uri.startsWith(\"https:\/\/\") ? 500 : 350;\n+                    try (InputStream is = response.body()) {\n+                        Thread.sleep(Utils.adjustTimeout(wait));\n+                        is.readAllBytes();\n+                    }\n+                    \/\/ we could fail here if we haven't waited long enough\n+                    fail(\"Expected exception, got :\" + response + \", should sleep time be raised?\");\n+                } catch (IOException ioe) {\n+                    System.out.println(\"Got EXPECTED: \" + ioe);\n+                    assertDetailMessage(ioe, i);\n+                } finally {\n+                    if (!sameClient && client != null) {\n+                        client.close();\n+                        client = null;\n+                    }\n+                }\n+            }\n+        } finally {\n+            if (sameClient && client != null) client.close();\n+        }\n+\n+    }\n+\n+    @Test(dataProvider = \"variants\")\n+    void testAsync(String uri,\n+                   boolean sameClient)\n+    {\n+        System.out.printf(\"%ntesting testAsync(%s, %s)%n\", uri, sameClient);\n+        ConcurrentHashMap<String, CompletableFuture<String>> responseSent = new ConcurrentHashMap<>();\n+        FCHttp2TestExchange.setResponseSentCB((s) -> responseSent.get(s).complete(s));\n+\n+        HttpClient client = null;\n+        try {\n+            int max = sameClient ? 5 : 3;\n+            String label = null;\n+            for (int i = 0; i < max; i++) {\n+                if (!sameClient || client == null)\n+                    client = HttpClient.newBuilder().sslContext(sslContext).build();\n+\n+                String query = \"reqId=\" + reqid.incrementAndGet();\n+                URI uriWithQuery = URI.create(uri + \"?\" + query);\n+                CompletableFuture<String> sent = new CompletableFuture<>();\n+                responseSent.put(query, sent);\n+                HttpRequest request = HttpRequest.newBuilder(uriWithQuery)\n+                        .POST(BodyPublishers.ofString(\"Hello there!\"))\n+                        .build();\n+                System.out.println(\"\\nSending request:\" + uriWithQuery);\n+                final HttpClient cc = client;\n+\n+                Throwable t = null;\n+                try {\n+                    HttpResponse<InputStream> response = cc.sendAsync(request, BodyHandlers.ofInputStream()).get();\n+                    if (sameClient) {\n+                        String key = response.headers().firstValue(\"X-Connection-Key\").get();\n+                        if (label == null) label = key;\n+                        assertEquals(key, label, \"Unexpected key for \" + query);\n+                    }\n+                    sent.join();\n+                    int wait = uri.startsWith(\"https:\/\/\") ? 600 : 300;\n+                    try (InputStream is = response.body()) {\n+                        Thread.sleep(Utils.adjustTimeout(wait));\n+                        is.readAllBytes();\n+                    }\n+                    \/\/ we could fail here if we haven't waited long enough\n+                    fail(\"Expected exception, got :\" + response + \", should sleep time be raised?\");\n+                } catch (Throwable t0) {\n+                    System.out.println(\"Got EXPECTED: \" + t0);\n+                    if (t0 instanceof ExecutionException) {\n+                        t0 = t0.getCause();\n+                    }\n+                    t = t0;\n+                } finally {\n+                    if (!sameClient && client != null) {\n+                        client.close();\n+                        client = null;\n+                    }\n+                }\n+                assertDetailMessage(t, i);\n+            }\n+        } finally {\n+            if (sameClient && client != null) client.close();\n+        }\n+    }\n+\n+    \/\/ Assertions based on implementation specific detail messages. Keep in\n+    \/\/ sync with implementation.\n+    static void assertDetailMessage(Throwable throwable, int iterationIndex) {\n+        try {\n+            Throwable cause = throwable;\n+            while (cause != null) {\n+                if (cause instanceof ProtocolException) {\n+                    if (cause.getMessage().matches(\"stream [0-9]+ flow control window exceeded\")) {\n+                       System.out.println(\"Found expected exception: \" + cause);\n+                       return;\n+                    }\n+                }\n+                cause = cause.getCause();\n+            }\n+            throw new AssertionError(\n+                    \"ProtocolException(\\\"stream X flow control window exceeded\\\") not found\",\n+                             throwable);\n+        } catch (AssertionError e) {\n+            System.out.println(\"Exception does not match expectation: \" + throwable);\n+            throwable.printStackTrace(System.out);\n+            throw e;\n+        }\n+    }\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null)\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+\n+        var http2TestServer = new Http2TestServer(\"localhost\", false, 0);\n+        http2TestServer.addHandler(new Http2TestHandler(), \"\/http2\/\");\n+        this.http2TestServer = HttpTestServer.of(http2TestServer);\n+        http2URI = \"http:\/\/\" + this.http2TestServer.serverAuthority() + \"\/http2\/x\";\n+\n+        var https2TestServer = new Http2TestServer(\"localhost\", true, sslContext);\n+        https2TestServer.addHandler(new Http2TestHandler(), \"\/https2\/\");\n+        this.https2TestServer = HttpTestServer.of(https2TestServer);\n+        https2URI = \"https:\/\/\" + this.https2TestServer.serverAuthority() + \"\/https2\/x\";\n+\n+        \/\/ Override the default exchange supplier with a custom one to enable\n+        \/\/ particular test scenarios\n+        http2TestServer.setExchangeSupplier(FCHttp2TestExchange::new);\n+        https2TestServer.setExchangeSupplier(FCHttp2TestExchange::new);\n+\n+        this.http2TestServer.start();\n+        this.https2TestServer.start();\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws Exception {\n+        http2TestServer.stop();\n+        https2TestServer.stop();\n+    }\n+\n+    static class Http2TestHandler implements Http2Handler {\n+\n+        @Override\n+        public void handle(Http2TestExchange t) throws IOException {\n+            String query = t.getRequestURI().getRawQuery();\n+\n+            try (InputStream is = t.getRequestBody();\n+                 OutputStream os = t.getResponseBody()) {\n+\n+                byte[] bytes = is.readAllBytes();\n+                System.out.println(\"Server \" + t.getLocalAddress() + \" received:\\n\"\n+                        + t.getRequestURI() + \": \" + new String(bytes, StandardCharsets.UTF_8));\n+                t.getResponseHeaders().setHeader(\"X-Connection-Key\", t.getConnectionKey());\n+\n+                if (bytes.length == 0) bytes = \"no request body!\".getBytes(StandardCharsets.UTF_8);\n+                int window = Integer.getInteger(\"jdk.httpclient.windowsize\", 2 * 16 * 1024);\n+                final int maxChunkSize;\n+                if (t instanceof FCHttp2TestExchange fct) {\n+                    maxChunkSize = Math.min(window, fct.conn.getMaxFrameSize());\n+                } else {\n+                    maxChunkSize = Math.min(window, SettingsFrame.MAX_FRAME_SIZE);\n+                }\n+                byte[] resp = bytes.length <= maxChunkSize\n+                        ? bytes\n+                        : Arrays.copyOfRange(bytes, 0, maxChunkSize);\n+                int max = (window \/ resp.length) + 2;\n+                \/\/ send in chunks\n+                t.sendResponseHeaders(200, 0);\n+                for (int i = 0; i <= max; i++) {\n+                    if (t instanceof FCHttp2TestExchange fct) {\n+                        try {\n+                            \/\/ we don't wait for the stream window, but we want\n+                            \/\/ to wait for the connection window\n+                            fct.conn.obtainConnectionWindow(resp.length);\n+                        } catch (InterruptedException ie) {\n+                            \/\/ ignore and continue...\n+                        }\n+                    }\n+                    ((BodyOutputStream) os).writeUncontrolled(resp, 0, resp.length);\n+                }\n+            }\n+            if (t instanceof FCHttp2TestExchange fct) {\n+                fct.responseSent(query);\n+            } else fail(\"Exchange is not %s but %s\"\n+                    .formatted(FCHttp2TestExchange.class.getName(), t.getClass().getName()));\n+        }\n+    }\n+\n+    \/\/ A custom Http2TestExchangeImpl that overrides sendResponseHeaders to\n+    \/\/ allow headers to be sent with a number of CONTINUATION frames.\n+    static class FCHttp2TestExchange extends Http2TestExchangeImpl {\n+        static volatile Consumer<String> responseSentCB;\n+        static void setResponseSentCB(Consumer<String> responseSentCB) {\n+            FCHttp2TestExchange.responseSentCB = responseSentCB;\n+        }\n+\n+        final Http2TestServerConnection conn;\n+        FCHttp2TestExchange(int streamid, String method, HttpHeaders reqheaders,\n+                             HttpHeadersBuilder rspheadersBuilder, URI uri, InputStream is,\n+                             SSLSession sslSession, BodyOutputStream os,\n+                             Http2TestServerConnection conn, boolean pushAllowed) {\n+            super(streamid, method, reqheaders, rspheadersBuilder, uri, is, sslSession, os, conn, pushAllowed);\n+            this.conn = conn;\n+        }\n+        public void responseSent(String query) {\n+            System.out.println(\"Server: response sent for \" + query);\n+            responseSentCB.accept(query);\n+        }\n+\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/StreamFlowControlTest.java","additions":342,"deletions":0,"binary":false,"changes":342,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.Objects;\n@@ -68,0 +69,4 @@\n+        waitForStreamWindow(demand);\n+    }\n+\n+    public void waitForStreamWindow(int demand) throws InterruptedException {\n@@ -86,0 +91,1 @@\n+        Objects.checkFromIndexSize(offset, len, buf.length);\n@@ -107,0 +113,28 @@\n+    \/**\n+     * This method pushes frames onto the stack without checking\n+     * for flow control, allowing the sender to bypass flow\n+     * control for testing purposes\n+     * @param buf     data to send\n+     * @param offset  offset at which the data starts\n+     * @param len     length of the data to send\n+     * @throws IOException if an I\/O error occurs\n+     *\/\n+    public void writeUncontrolled(byte[] buf, int offset, int len)\n+            throws IOException {\n+        Objects.checkFromIndexSize(offset, len, buf.length);\n+        if (closed) {\n+            throw new IOException(\"closed\");\n+        }\n+\n+        if (!goodToGo) {\n+            throw new IllegalStateException(\"sendResponseHeaders must be called first\");\n+        }\n+        int max = conn.getMaxFrameSize();\n+        while (len > 0) {\n+            int n = len > max ? max : len;\n+            send(buf, offset, n, 0);\n+            offset += n;\n+            len -= n;\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/BodyOutputStream.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1377,1 +1377,1 @@\n-    synchronized void obtainConnectionWindow(int amount) throws InterruptedException {\n+    public synchronized void obtainConnectionWindow(int amount) throws InterruptedException {\n@@ -1387,3 +1387,7 @@\n-    synchronized void updateConnectionWindow(int amount) {\n-        sendWindow += amount;\n-        notifyAll();\n+    void updateConnectionWindow(int amount) {\n+        System.out.printf(\"sendWindow (window=%s, amount=%s) is now: %s%n\",\n+                sendWindow, amount, sendWindow + amount);\n+        synchronized (this) {\n+            sendWindow += amount;\n+            notifyAll();\n+        }\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestServerConnection.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,1 +29,3 @@\n-import java.nio.channels.*;\n+import java.nio.channels.Pipe;\n+import java.nio.channels.SelectionKey;\n+import java.nio.channels.Selector;\n@@ -50,1 +52,1 @@\n-        long startTime = System.currentTimeMillis();\n+        long startTime = System.nanoTime();\n@@ -52,1 +54,1 @@\n-        long endTime = System.currentTimeMillis();\n+        long endTime = System.nanoTime();\n@@ -56,2 +58,3 @@\n-        if (endTime - startTime < 1000)\n-            throw new RuntimeException(\"test failed\");\n+        long delta = endTime - startTime;\n+        if (delta < 1_000_000_000)\n+            throw new RuntimeException(\"test failed with delta \" + delta);\n@@ -65,2 +68,0 @@\n-        Pipe p = Pipe.open();\n-        p.source().configureBlocking(false);\n@@ -71,1 +72,1 @@\n-        long startTime = System.currentTimeMillis();\n+        long startTime = System.nanoTime();\n@@ -73,1 +74,1 @@\n-        long endTime = System.currentTimeMillis();\n+        long endTime = System.nanoTime();\n@@ -75,2 +76,3 @@\n-        if (endTime - startTime < 1000)\n-            throw new RuntimeException(\"test failed\");\n+        long delta = endTime - startTime;\n+        if (delta < 1_000_000_000)\n+            throw new RuntimeException(\"test failed with delta \" + delta);\n","filename":"test\/jdk\/java\/nio\/channels\/Selector\/WakeupNow.java","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 8227609\n+ * @bug 8227609 8233451\n@@ -27,1 +27,3 @@\n- * @library ..\n+ * @library .. \/test\/lib\n+ * @build jdk.test.lib.Platform\n+ * @run junit\/othervm --enable-native-access=ALL-UNNAMED InputStreamTest\n@@ -30,0 +32,2 @@\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n@@ -31,0 +35,1 @@\n+import java.io.IOException;\n@@ -32,0 +37,7 @@\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n@@ -33,6 +45,11 @@\n-import java.nio.file.*;\n-import static java.nio.file.Files.*;\n-import static java.nio.file.LinkOption.*;\n-import java.nio.file.attribute.*;\n-import java.io.IOException;\n-import java.util.*;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import jdk.test.lib.Platform;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.condition.DisabledOnOs;\n+import org.junit.jupiter.api.condition.OS;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -42,2 +59,27 @@\n-    public static void main(String[] args) throws IOException {\n-        Path dir = TestUtil.createTemporaryDirectory();\n+    private static final String PIPE = \"pipe\";\n+    private static final Path PIPE_PATH = Path.of(PIPE);\n+    private static final String SENTENCE =\n+        \"Tout est permis mais rien n’est possible\";\n+\n+    private static Path TMPDIR;\n+\n+    private static class mkfifo {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            ValueLayout.JAVA_INT,\n+            ValueLayout.ADDRESS,\n+            ValueLayout.JAVA_SHORT\n+        );\n+\n+        public static final MemorySegment ADDR;\n+        static {\n+            Linker linker = Linker.nativeLinker();\n+            SymbolLookup stdlib = linker.defaultLookup();\n+            ADDR = stdlib.find(\"mkfifo\").orElseThrow();\n+        }\n+\n+        public static final MethodHandle HANDLE =\n+            Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    public static int mkfifo(MemorySegment x0, short x1) {\n+        var mh$ = mkfifo.HANDLE;\n@@ -45,3 +87,3 @@\n-            testSkip(dir);\n-        } finally {\n-            TestUtil.removeAll(dir);\n+            return (int)mh$.invokeExact(x0, x1);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n@@ -51,0 +93,43 @@\n+    private static Thread createWriteThread() {\n+        Thread t = new Thread(\n+            new Runnable() {\n+                public void run() {\n+                    try (FileOutputStream fos = new FileOutputStream(PIPE);) {\n+                        fos.write(SENTENCE.getBytes());\n+                    } catch (IOException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }\n+            }\n+        );\n+        t.start();\n+        return t;\n+    }\n+\n+    @BeforeAll\n+    static void before() throws InterruptedException, IOException {\n+        TMPDIR = TestUtil.createTemporaryDirectory();\n+\n+        if (Platform.isWindows())\n+            return;\n+\n+        Files.deleteIfExists(PIPE_PATH);\n+        try (var newArena = Arena.ofConfined()) {\n+            var addr = newArena.allocateFrom(PIPE);\n+            short mode = 0666;\n+            assertEquals(0, mkfifo(addr, mode));\n+        }\n+        if (Files.notExists(PIPE_PATH))\n+            throw new RuntimeException(\"Failed to create \" + PIPE);\n+    }\n+\n+    @AfterAll\n+    static void after() throws IOException {\n+        TestUtil.removeAll(TMPDIR);\n+\n+        if (Platform.isWindows())\n+            return;\n+\n+        Files.deleteIfExists(PIPE_PATH);\n+    }\n+\n@@ -54,2 +139,3 @@\n-    static void testSkip(Path tmpdir) throws IOException {\n-        Path file = createFile(tmpdir.resolve(\"foo\"));\n+    @Test\n+    void skip() throws IOException {\n+        Path file = Files.createFile(TMPDIR.resolve(\"foo\"));\n@@ -126,3 +212,82 @@\n-    static void assertTrue(boolean okay) {\n-        if (!okay)\n-            throw new RuntimeException(\"Assertion Failed\");\n+    \/**\n+     * Tests that Files.newInputStream(Path).available() does not throw\n+     *\/\n+    @Test\n+    @DisabledOnOs(OS.WINDOWS)\n+    void availableStdin() throws IOException {\n+        Path stdin = Path.of(\"\/dev\", \"stdin\");\n+        if (Files.exists(stdin)) {\n+            try (InputStream s = Files.newInputStream(stdin);) {\n+                s.available();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Tests that Files.newInputStream(Path).skip(0) does not throw\n+     *\/\n+    @Test\n+    @DisabledOnOs(OS.WINDOWS)\n+    void skipStdin() throws IOException {\n+        Path stdin = Path.of(\"\/dev\", \"stdin\");\n+        if (Files.exists(stdin)) {\n+            try (InputStream s = Files.newInputStream(stdin);) {\n+                s.skip(0);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Tests Files.newInputStream(Path).readAllBytes().\n+     *\/\n+    @Test\n+    @DisabledOnOs(OS.WINDOWS)\n+    void readAllBytes() throws InterruptedException, IOException {\n+        Thread t = createWriteThread();\n+        try (InputStream in = Files.newInputStream(Path.of(PIPE))) {\n+            String s = new String(in.readAllBytes());\n+            System.out.println(s);\n+            assertEquals(SENTENCE, s);\n+        } finally {\n+            t.join();\n+        }\n+    }\n+\n+    \/**\n+     * Tests Files.newInputStream(Path).readNBytes(byte[],int,int).\n+     *\/\n+    @Test\n+    @DisabledOnOs(OS.WINDOWS)\n+    void readNBytesNoOverride() throws InterruptedException, IOException {\n+        Thread t = createWriteThread();\n+        try (InputStream in = Files.newInputStream(Path.of(PIPE))) {\n+            final int offset = 11;\n+            final int length = 17;\n+            assert length <= SENTENCE.length();\n+            byte[] b = new byte[offset + length];\n+            int n = in.readNBytes(b, offset, length);\n+            String s = new String(b, offset, length);\n+            System.out.println(s);\n+            assertEquals(SENTENCE.substring(0, length), s);\n+        } finally {\n+            t.join();\n+        }\n+    }\n+\n+    \/**\n+     * Tests Files.newInputStream(Path).readNBytes(int).\n+     *\/\n+    @Test\n+    @DisabledOnOs(OS.WINDOWS)\n+    void readNBytesOverride() throws InterruptedException, IOException {\n+        Thread t = createWriteThread();\n+        try (InputStream in = Files.newInputStream(Path.of(PIPE))) {\n+            final int length = 17;\n+            assert length <= SENTENCE.length();\n+            byte[] b = in.readNBytes(length);\n+            String s = new String(b);\n+            System.out.println(s);\n+            assertEquals(SENTENCE.substring(0, length), s);\n+        } finally {\n+            t.join();\n+        }\n","filename":"test\/jdk\/java\/nio\/file\/Files\/InputStreamTest.java","additions":184,"deletions":19,"binary":false,"changes":203,"status":"modified"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8341445\n+ * @summary DFS setters should throw NPE. This ensures that NPE is not thrown\n+ *          by equals().\n+ * @run junit SettersShouldThrowNPETest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.text.DecimalFormatSymbols;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class SettersShouldThrowNPETest {\n+\n+    \/\/ The public setter methods that should throw NPE\n+    private static final List<Method> NPE_SETTERS =\n+            Arrays.stream(DecimalFormatSymbols.class.getDeclaredMethods())\n+            .filter(m -> Modifier.isPublic(m.getModifiers())\n+                    && m.getName().startsWith(\"set\")\n+                    && Stream.of(m.getParameterTypes()).noneMatch(Class::isPrimitive))\n+            .toList();\n+\n+    \/\/ Non-primitive setters should throw NPE\n+    @ParameterizedTest\n+    @MethodSource(\"setters\")\n+    public void settersThrowNPETest(Method m) {\n+        var dfs = new DecimalFormatSymbols();\n+        InvocationTargetException e =\n+                assertThrows(InvocationTargetException.class, () -> m.invoke(dfs, (Object) null));\n+        if (!(e.getCause() instanceof NullPointerException)) {\n+            throw new RuntimeException(e.getCause() + \" was thrown instead of NPE by : \" + m);\n+        }\n+    }\n+\n+    \/\/ Currency fields are lazy and can be null\n+    \/\/ Ensure when exposed to users, they are never null\n+    @ParameterizedTest\n+    @MethodSource(\"locales\")\n+    public void lazyCurrencyFieldsTest(Locale locale) {\n+        var dfs = new DecimalFormatSymbols(locale);\n+        assertDoesNotThrow(() -> dfs.equals(new DecimalFormatSymbols()));\n+        assertNotNull(dfs.getCurrency());\n+        assertNotNull(dfs.getInternationalCurrencySymbol());\n+        assertNotNull(dfs.getCurrencySymbol());\n+    }\n+\n+    \/\/ Prior to 8341445, if the international currency symbol was invalid,\n+    \/\/ the currency attribute was set to null. However, we should not have null\n+    \/\/ currency fields post initializeCurrency() call. Ensure invalid code\n+    \/\/ does not update the other fields.\n+    @Test\n+    public void setInternationalCurrencySymbolFallbackTest() {\n+        var code = \"fooBarBazQux\";\n+        \/\/ initialize() should provide null for all currency related fields\n+        var dfs = new DecimalFormatSymbols(Locale.ROOT);\n+        \/\/ Load the fallbacks via initCurrency() since the loc is Locale.ROOT\n+        dfs.setInternationalCurrencySymbol(code); \/\/ set invalid code\n+        \/\/ Ensure our values are the expected fallbacks, minus the updated intl code\n+        assertEquals(Currency.getInstance(\"XXX\"), dfs.getCurrency());\n+        assertEquals(\"\\u00A4\", dfs.getCurrencySymbol());\n+        assertEquals(\"fooBarBazQux\", dfs.getInternationalCurrencySymbol());\n+    }\n+\n+    private static List<Method> setters() {\n+        return NPE_SETTERS;\n+    }\n+\n+    private static List<Locale> locales() {\n+        return List.of(Locale.ROOT, Locale.US, Locale.forLanguageTag(\"XXX\"));\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/SettersShouldThrowNPETest.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8331446\n+ * @bug 8331446 8340554\n@@ -73,1 +73,7 @@\n-                new MessageFormat(\"{0,number,short} {0} {1,date,long} foo\")\n+                new MessageFormat(\"{0,number,short} {0} {1,date,long} foo\"),\n+                \/\/ Offset equal to pattern length (0)\n+                new MessageFormat(\"{0}\"),\n+                \/\/ Offset equal to pattern length (1)\n+                new MessageFormat(\"X{0}\"),\n+                \/\/ Offset 1 under pattern length\n+                new MessageFormat(\"X{0}X\")\n","filename":"test\/jdk\/java\/text\/Format\/MessageFormat\/SerializationTest.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8342582\n+ * @summary Test if \"user.region\" system property successfully overrides\n+ *          other locale related system properties at startup\n+ * @modules jdk.localedata\n+ * @run junit\/othervm\n+ *      -Duser.region=DE\n+ *      -Duser.language=en\n+ *      -Duser.script=Latn\n+ *      -Duser.country=US\n+ *      -Duser.variant=FOO UserRegionTest\n+ * @run junit\/othervm\n+ *      -Duser.region=DE_POSIX\n+ *      -Duser.language=en\n+ *      -Duser.script=Latn\n+ *      -Duser.country=US\n+ *      -Duser.variant=FOO UserRegionTest\n+ * @run junit\/othervm\n+ *      -Duser.region=_POSIX\n+ *      -Duser.language=en\n+ *      -Duser.script=Latn\n+ *      -Duser.country=US\n+ *      -Duser.variant=FOO UserRegionTest\n+ *\/\n+\n+import java.util.Locale;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class UserRegionTest {\n+    @Test\n+    public void testDefaultLocale() {\n+        var region = System.getProperty(\"user.region\").split(\"_\");\n+        var expected = Locale.of(System.getProperty(\"user.language\"),\n+                region[0], region.length > 1 ? region[1] : \"\");\n+        assertEquals(expected, Locale.getDefault());\n+        assertEquals(expected, Locale.getDefault(Locale.Category.FORMAT));\n+        assertEquals(expected, Locale.getDefault(Locale.Category.DISPLAY));\n+    }\n+\n+    @Test\n+    public void testNumberFormat() {\n+        if (System.getProperty(\"user.region\").startsWith(\"DE\")) {\n+            assertEquals(\"0,50000\", String.format(\"%.5f\", 0.5f));\n+        } else {\n+            assertEquals(\"0.50000\", String.format(\"%.5f\", 0.5f));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Locale\/UserRegionTest.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -1,120 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 6466476\n- * @summary Compatibility test for the old JDK ID mapping and Olson IDs\n- * @comment Expecting the new (Olson compatible) mapping (default)\n- * @run main\/othervm -Dsun.timezone.ids.oldmapping=null OldIDMappingTest -new\n- * @run main\/othervm -Dsun.timezone.ids.oldmapping=\"\" OldIDMappingTest -new\n- * @run main\/othervm -Dsun.timezone.ids.oldmapping=no OldIDMappingTest -new\n- * @run main\/othervm -Dsun.timezone.ids.oldmapping=No OldIDMappingTest -new\n- * @run main\/othervm -Dsun.timezone.ids.oldmapping=NO OldIDMappingTest -new\n- * @run main\/othervm -Dsun.timezone.ids.oldmapping=false OldIDMappingTest -new\n- * @run main\/othervm -Dsun.timezone.ids.oldmapping=False OldIDMappingTest -new\n- * @run main\/othervm -Dsun.timezone.ids.oldmapping=FALSE OldIDMappingTest -new\n- * @run main\/othervm -Dsun.timezone.ids.oldmapping=Hello OldIDMappingTest -new\n- * @comment Expecting the old mapping\n- * @run main\/othervm -Dsun.timezone.ids.oldmapping=true OldIDMappingTest -old\n- * @run main\/othervm -Dsun.timezone.ids.oldmapping=True OldIDMappingTest -old\n- * @run main\/othervm -Dsun.timezone.ids.oldmapping=TRUE OldIDMappingTest -old\n- * @run main\/othervm -Dsun.timezone.ids.oldmapping=yes OldIDMappingTest -old\n- * @run main\/othervm -Dsun.timezone.ids.oldmapping=Yes OldIDMappingTest -old\n- * @run main\/othervm -Dsun.timezone.ids.oldmapping=YES OldIDMappingTest -old\n- *\/\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.TimeZone;\n-\n-public class OldIDMappingTest {\n-    private static final String MAPPING_PROPERTY_NAME = \"sun.timezone.ids.oldmapping\";\n-    private static final Map<String, String> newmap = new HashMap<String, String>();\n-    static {\n-        \/\/ Add known new mappings\n-        newmap.put(\"EST\", \"EST\");\n-        newmap.put(\"MST\", \"MST\");\n-    }\n-\n-    public static void main(String[] args) {\n-        boolean useOldMapping = true;\n-        String arg = args[0];\n-        if (arg.equals(\"-new\")) {\n-            useOldMapping = false;\n-        } else if (arg.equals(\"-old\")) {\n-            useOldMapping = true;\n-        } else {\n-            throw new RuntimeException(\"-old or -new must be specified; got \" + arg);\n-        }\n-\n-        Map<String, String> oldmap = TzIDOldMapping.MAP;\n-        String prop = System.getProperty(MAPPING_PROPERTY_NAME);\n-        System.out.println(MAPPING_PROPERTY_NAME + \"=\" + prop);\n-\n-        \/\/ Try the test multiple times with modifying TimeZones to\n-        \/\/ make sure TimeZone instances for the old mapping are\n-        \/\/ properly copied (defensive copy).\n-        for (int count = 0; count < 3; count++) {\n-            for (String id : oldmap.keySet()) {\n-                TimeZone tzAlias = TimeZone.getTimeZone(id);\n-                TimeZone tz = TimeZone.getTimeZone(oldmap.get(id));\n-                if (useOldMapping) {\n-                    if (!tzAlias.hasSameRules(tz)) {\n-                        throw new RuntimeException(\"OLDMAP: \" + MAPPING_PROPERTY_NAME\n-                                + \"=\" + prop + \": \" + id\n-                                + \" isn't an alias of \" + oldmap.get(id));\n-                    }\n-                    if (count == 0) {\n-                        System.out.println(\"    \" + id + \" => \" + oldmap.get(id));\n-                    }\n-                    tzAlias.setRawOffset(tzAlias.getRawOffset() * count);\n-                } else {\n-                    if (!newmap.containsKey(id)) {\n-                        \/\/ ignore ids not contained in the new map\n-                        if (count == 0) {\n-                            System.out.println(\"    \" + id + \" => \" + oldmap.get(id));\n-                        }\n-                        tzAlias.setRawOffset(tzAlias.getRawOffset() * count);\n-                        continue;\n-                    }\n-                    if (tzAlias.hasSameRules(tz)) {\n-                        throw new RuntimeException(\"NEWMAP: \" + MAPPING_PROPERTY_NAME\n-                                + \"=\" + prop + \": \" + id\n-                                + \" is an alias of \" + oldmap.get(id));\n-                    }\n-                    tz = TimeZone.getTimeZone(newmap.get(id));\n-                    if (!tzAlias.hasSameRules(tz)) {\n-                        throw new RuntimeException(\"NEWMAP: \" + MAPPING_PROPERTY_NAME\n-                                + \"=\" + prop + \": \" + id\n-                                + \" isn't an alias of \" + newmap.get(id));\n-                    }\n-                    if (count == 0) {\n-                        System.out.println(\"    \" + id + \" => \" + newmap.get(id));\n-                    }\n-                    tzAlias.setRawOffset(tzAlias.getRawOffset() * count);\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/TimeZone\/OldIDMappingTest.java","additions":0,"deletions":120,"binary":false,"changes":120,"status":"deleted"},{"patch":"@@ -1,64 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.Map;\n-import java.util.HashMap;\n-\n-class TzIDOldMapping {\n-    static final Map<String, String> MAP = new HashMap<String, String>();\n-    static {\n-        String[][] oldmap = {\n-            { \"ACT\", \"Australia\/Darwin\" },\n-            { \"AET\", \"Australia\/Sydney\" },\n-            { \"AGT\", \"America\/Argentina\/Buenos_Aires\" },\n-            { \"ART\", \"Africa\/Cairo\" },\n-            { \"AST\", \"America\/Anchorage\" },\n-            { \"BET\", \"America\/Sao_Paulo\" },\n-            { \"BST\", \"Asia\/Dhaka\" },\n-            { \"CAT\", \"Africa\/Harare\" },\n-            { \"CNT\", \"America\/St_Johns\" },\n-            { \"CST\", \"America\/Chicago\" },\n-            { \"CTT\", \"Asia\/Shanghai\" },\n-            { \"EAT\", \"Africa\/Addis_Ababa\" },\n-            { \"ECT\", \"Europe\/Paris\" },\n-            { \"EST\", \"America\/New_York\" },\n-            { \"HST\", \"Pacific\/Honolulu\" },\n-            { \"IET\", \"America\/Indianapolis\" },\n-            { \"IST\", \"Asia\/Calcutta\" },\n-            { \"JST\", \"Asia\/Tokyo\" },\n-            { \"MIT\", \"Pacific\/Apia\" },\n-            { \"MST\", \"America\/Denver\" },\n-            { \"NET\", \"Asia\/Yerevan\" },\n-            { \"NST\", \"Pacific\/Auckland\" },\n-            { \"PLT\", \"Asia\/Karachi\" },\n-            { \"PNT\", \"America\/Phoenix\" },\n-            { \"PRT\", \"America\/Puerto_Rico\" },\n-            { \"PST\", \"America\/Los_Angeles\" },\n-            { \"SST\", \"Pacific\/Guadalcanal\" },\n-            { \"VST\", \"Asia\/Saigon\" },\n-        };\n-        for (String[] pair : oldmap) {\n-            MAP.put(pair[0], pair[1]);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/TimeZone\/TzIDOldMapping.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"deleted"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8340553\n+ * @summary Verify that ZipEntry(String), ZipEntry::setComment, and\n+ * ZipEntry::setExtra throws a IllegalArgumentException when the\n+ * combined length of the fields, including the size of the CEN Header,\n+ * exceeds 65,535 bytes\n+ * @run junit MaxZipEntryFieldSizeTest\n+ *\/\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class MaxZipEntryFieldSizeTest {\n+\n+    \/\/ CEN header size + name length + comment length + extra length\n+    \/\/ should not exceed 65,535 bytes per the PKWare APP.NOTE\n+    \/\/ 4.4.10, 4.4.11, & 4.4.12.\n+    static final int MAX_COMBINED_CEN_HEADER_SIZE = 0xFFFF;\n+    \/\/ Maximum possible size of name length + comment length + extra length\n+    \/\/ for entries in order to not exceed 65,489 bytes\n+    static final int MAX_NAME_COMMENT_EXTRA_SIZE =\n+            MAX_COMBINED_CEN_HEADER_SIZE - ZipFile.CENHDR;\n+    \/\/ Tag for the 'unknown' field type, specified in APPNOTE.txt 'Third party mappings'\n+    static final short UNKNOWN_ZIP_TAG = (short) 0x9902;\n+    \/\/ Zip Entry name used by tests\n+    static final String ENTRY_NAME = \"EntryName\";\n+    \/\/ Max length minus the size of the ENTRY_NAME or ENTRY_COMMENT\n+    static final int MAX_FIELD_LEN_MINUS_ENTRY_NAME =\n+            MAX_NAME_COMMENT_EXTRA_SIZE - 9;\n+\n+    \/**\n+     * Validate an IllegalArgumentException is thrown when the\n+     * combined length of the entry name, entry comment, entry extra data,\n+     * and CEN Header size exceeds 65,535 bytes.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(ints = {30000, 35000})\n+    void combinedLengthTest(int length) {\n+        String comment = \"a\".repeat(length);\n+        byte[] bytes = creatExtraData(length);\n+        int combinedLength = ENTRY_NAME.length() + comment.length() + bytes.length;\n+        boolean expectException = combinedLength > MAX_COMBINED_CEN_HEADER_SIZE;\n+        System.out.printf(\"Combined Len= %s, exception: %s%n\", combinedLength, expectException);\n+        ZipEntry zipEntry = new ZipEntry(ENTRY_NAME);\n+        zipEntry.setComment(comment);\n+        \/\/ The extra data length will trigger the IllegalArgumentException\n+        if (expectException) {\n+            assertThrows(IllegalArgumentException.class, () ->\n+                    zipEntry.setExtra(bytes));\n+        } else {\n+            zipEntry.setExtra(bytes);\n+        }\n+    }\n+\n+    \/**\n+     * Validate an IllegalArgumentException is thrown when the comment\n+     * length exceeds 65,489 bytes.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(ints = {MAX_COMBINED_CEN_HEADER_SIZE,\n+            MAX_NAME_COMMENT_EXTRA_SIZE,\n+            MAX_NAME_COMMENT_EXTRA_SIZE + 1,\n+            MAX_FIELD_LEN_MINUS_ENTRY_NAME,\n+            MAX_FIELD_LEN_MINUS_ENTRY_NAME - 1})\n+    void setCommentLengthTest(int length) {\n+        boolean expectException = length >= MAX_NAME_COMMENT_EXTRA_SIZE;\n+        ZipEntry zipEntry = new ZipEntry(ENTRY_NAME);\n+        String comment = \"a\".repeat(length);\n+        System.out.printf(\"Comment Len= %s, exception: %s%n\", comment.length(), expectException);\n+        \/\/ The comment length will trigger the IllegalArgumentException\n+        if (expectException) {\n+            assertThrows(IllegalArgumentException.class, () ->\n+                    zipEntry.setComment(comment));\n+        } else {\n+            zipEntry.setComment(comment);\n+        }\n+    }\n+\n+    \/**\n+     * Validate an IllegalArgumentException is thrown when the name\n+     * length exceeds 65,489 bytes.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(ints = {MAX_COMBINED_CEN_HEADER_SIZE,\n+            MAX_NAME_COMMENT_EXTRA_SIZE,\n+            MAX_NAME_COMMENT_EXTRA_SIZE + 1,\n+            MAX_FIELD_LEN_MINUS_ENTRY_NAME,\n+            MAX_FIELD_LEN_MINUS_ENTRY_NAME - 1})\n+    void nameLengthTest(int length) {\n+        boolean expectException = length > MAX_NAME_COMMENT_EXTRA_SIZE;\n+        String name = \"a\".repeat(length);\n+        System.out.printf(\"name Len= %s, exception: %s%n\", name.length(), expectException);\n+        \/\/ The name length will trigger the IllegalArgumentException\n+        if (expectException) {\n+            assertThrows(IllegalArgumentException.class, () -> new ZipEntry(name));\n+        } else {\n+            new ZipEntry(name);\n+        }\n+    }\n+\n+    \/**\n+     * Validate an IllegalArgumentException is thrown when the extra data\n+     * length exceeds 65,489 bytes.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(ints = {MAX_COMBINED_CEN_HEADER_SIZE,\n+            MAX_NAME_COMMENT_EXTRA_SIZE,\n+            MAX_NAME_COMMENT_EXTRA_SIZE + 1,\n+            MAX_FIELD_LEN_MINUS_ENTRY_NAME,\n+            MAX_FIELD_LEN_MINUS_ENTRY_NAME - 1})\n+    void setExtraLengthTest(int length) {\n+        boolean expectException = length >= MAX_NAME_COMMENT_EXTRA_SIZE;\n+        byte[] bytes = creatExtraData(length);\n+        ZipEntry zipEntry = new ZipEntry(ENTRY_NAME);\n+        System.out.printf(\"extra Len= %s, exception: %s%n\", bytes.length, expectException);\n+        \/\/ The extra data length will trigger the IllegalArgumentException\n+        if (expectException) {\n+            assertThrows(IllegalArgumentException.class, () -> zipEntry.setExtra(bytes));\n+        } else {\n+            zipEntry.setExtra(bytes);\n+        }\n+    }\n+\n+    \/**\n+     * Create the extra field data which will be passed to ZipEntry::setExtra\n+     * @param length size of the extra data\n+     * @return byte array containing the extra data\n+     *\/\n+    private static byte[] creatExtraData(int length) {\n+        byte[] bytes = new byte[length];\n+        \/\/ Little-endian ByteBuffer for updating the header fields\n+        ByteBuffer buffer = ByteBuffer.wrap(bytes).order(ByteOrder.LITTLE_ENDIAN);\n+        \/\/ We use the 'unknown' tag, specified in APPNOTE.TXT, 4.6.1 Third party mappings'\n+        buffer.putShort(UNKNOWN_ZIP_TAG);\n+        \/\/ Size of the actual (empty) data\n+        buffer.putShort((short) (length - 2 * Short.BYTES));\n+        return bytes;\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/ZipEntry\/MaxZipEntryFieldSizeTest.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -1,169 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 8336025\n- * @summary Verify that ZipOutputStream throws a ZipException when the\n- * CEN header size + name length + comment length + extra length exceeds\n- * 65,535 bytes\n- * @run junit ZipOutputStreamMaxCenHdrTest\n- *\/\n-import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.ValueSource;\n-\n-import java.io.*;\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n-import java.nio.charset.StandardCharsets;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.Arrays;\n-import java.util.zip.ZipEntry;\n-import java.util.zip.ZipException;\n-import java.util.zip.ZipFile;\n-import java.util.zip.ZipOutputStream;\n-\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-public class ZipOutputStreamMaxCenHdrTest {\n-\n-    \/\/ CEN header size + name length + comment length + extra length\n-    \/\/ should not exceed 65,535 bytes per the PKWare APP.NOTE\n-    \/\/ 4.4.10, 4.4.11, & 4.4.12.\n-    static final int MAX_COMBINED_CEN_HEADER_SIZE = 0xFFFF;\n-\n-    \/\/ Maximum possible size of name length + comment length + extra length\n-    \/\/ for entries in order to not exceed 65,489 bytes minus 46 bytes for the CEN\n-    \/\/ header length\n-    static final int MAX_NAME_COMMENT_EXTRA_SIZE =\n-            MAX_COMBINED_CEN_HEADER_SIZE - ZipFile.CENHDR;\n-\n-    \/\/ Tag for the 'unknown' field type, specified in APPNOTE.txt 'Third party mappings'\n-    static final short UNKNOWN_ZIP_TAG = (short) 0x9902;\n-\n-    \/\/ ZIP file to be used by the tests\n-    static final Path ZIP_FILE = Path.of(\"maxCENHdrTest.zip\");\n-\n-    \/**\n-     * Clean up prior to test run\n-     *\n-     * @throws IOException if an error occurs\n-     *\/\n-    @BeforeEach\n-    public void startUp() throws IOException {\n-        Files.deleteIfExists(ZIP_FILE);\n-    }\n-\n-    \/**\n-     * Validate a ZipException is thrown when the combined CEN Header, name\n-     * length, comment length, and extra data length exceeds 65,535 bytes when\n-     * the ZipOutputStream is closed.\n-     *\/\n-    @ParameterizedTest\n-    @ValueSource(ints = {MAX_COMBINED_CEN_HEADER_SIZE,\n-            MAX_COMBINED_CEN_HEADER_SIZE - 1,\n-            MAX_NAME_COMMENT_EXTRA_SIZE,\n-            MAX_NAME_COMMENT_EXTRA_SIZE - 1})\n-    void setCommentTest(int length) throws IOException {\n-        boolean expectZipException = length > MAX_NAME_COMMENT_EXTRA_SIZE;\n-        final byte[] bytes = new byte[length];\n-        Arrays.fill(bytes, (byte) 'a');\n-        ZipEntry zipEntry = new ZipEntry(\"\");\n-        \/\/ The comment length will trigger the ZipException\n-        zipEntry.setComment(new String(bytes, StandardCharsets.UTF_8));\n-        boolean receivedException = writeZipEntry(zipEntry, expectZipException);\n-        assertEquals(receivedException, expectZipException);\n-    }\n-\n-    \/**\n-     * Validate an ZipException is thrown when the combined CEN Header, name\n-     * length, comment length, and extra data length exceeds 65,535 bytes when\n-     * the ZipOutputStream is closed.\n-     *\/\n-    @ParameterizedTest\n-    @ValueSource(ints = {MAX_COMBINED_CEN_HEADER_SIZE,\n-            MAX_COMBINED_CEN_HEADER_SIZE - 1,\n-            MAX_NAME_COMMENT_EXTRA_SIZE,\n-            MAX_NAME_COMMENT_EXTRA_SIZE - 1})\n-    void setNameTest(int length) throws IOException {\n-        boolean expectZipException = length > MAX_NAME_COMMENT_EXTRA_SIZE;\n-        final byte[] bytes = new byte[length];\n-        Arrays.fill(bytes, (byte) 'a');\n-        \/\/ The name length will trigger the ZipException\n-        ZipEntry zipEntry = new ZipEntry(new String(bytes, StandardCharsets.UTF_8));\n-        boolean receivedException = writeZipEntry(zipEntry, expectZipException);\n-        assertEquals(receivedException, expectZipException);\n-    }\n-\n-    \/**\n-     * Validate an ZipException is thrown when the combined CEN Header, name\n-     * length, comment length, and extra data length exceeds 65,535 bytes when\n-     * the ZipOutputStream is closed.\n-     *\/\n-    @ParameterizedTest\n-    @ValueSource(ints = {MAX_COMBINED_CEN_HEADER_SIZE,\n-            MAX_COMBINED_CEN_HEADER_SIZE - 1,\n-            MAX_NAME_COMMENT_EXTRA_SIZE,\n-            MAX_NAME_COMMENT_EXTRA_SIZE - 1})\n-    void setExtraTest(int length) throws IOException {\n-        boolean expectZipException = length > MAX_NAME_COMMENT_EXTRA_SIZE;\n-        final byte[] bytes = new byte[length];\n-        \/\/ Little-endian ByteBuffer for updating the header fields\n-        ByteBuffer buffer = ByteBuffer.wrap(bytes).order(ByteOrder.LITTLE_ENDIAN);\n-        \/\/ We use the 'unknown' tag, specified in APPNOTE.TXT, 4.6.1 Third party mappings'\n-        buffer.putShort(UNKNOWN_ZIP_TAG);\n-        \/\/ Size of the actual (empty) data\n-        buffer.putShort((short) (length - 2 * Short.BYTES));\n-        ZipEntry zipEntry = new ZipEntry(\"\");\n-        \/\/ The extra data length will trigger the ZipException\n-        zipEntry.setExtra(bytes);\n-        boolean receivedException = writeZipEntry(zipEntry, expectZipException);\n-        assertEquals(receivedException, expectZipException);\n-    }\n-\n-    \/**\n-     * Write a single Zip entry using ZipOutputStream\n-     * @param zipEntry the ZipEntry to write\n-     * @param expectZipException true if a ZipException is expected, false otherwse\n-     * @return true if a ZipException was thrown\n-     * @throws IOException if an error occurs\n-     *\/\n-    private static boolean writeZipEntry(ZipEntry zipEntry, boolean expectZipException)\n-            throws IOException {\n-        boolean receivedException = false;\n-        try (ZipOutputStream zos = new ZipOutputStream(\n-                new BufferedOutputStream(Files.newOutputStream(ZIP_FILE)))) {\n-            zos.putNextEntry(zipEntry);\n-            if (expectZipException) {\n-                ZipException ex = assertThrows(ZipException.class, zos::close);\n-                assertTrue(ex.getMessage().matches(\".*bad header size.*\"),\n-                        \"Unexpected ZipException message: \" + ex.getMessage());\n-                receivedException = true;\n-            }\n-        } catch (Exception e) {\n-            throw new RuntimeException(\"Received Unexpected Exception\", e);\n-        }\n-        return receivedException;\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/zip\/ZipOutputStream\/ZipOutputStreamMaxCenHdrTest.java","additions":0,"deletions":169,"binary":false,"changes":169,"status":"deleted"},{"patch":"@@ -113,3 +113,1 @@\n-        String testDir = System.getProperty(\"test.src\");\n-        String testFileName = \"jmxremote.password\";\n-        return testDir + File.separator + testFileName;\n+        return \"jmxremote.password\";\n","filename":"test\/jdk\/javax\/management\/security\/HashedPasswordFileTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n@@ -35,0 +37,6 @@\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.util.concurrent.CountDownLatch;\n+\n@@ -39,1 +47,6 @@\n-public class bug4490179 {\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public final class bug4490179\n+        extends MouseAdapter\n+        implements ActionListener {\n@@ -42,4 +55,9 @@\n-    static volatile Point pt;\n-    static volatile int buttonW;\n-    static volatile int buttonH;\n-    static volatile boolean passed = true;\n+\n+    private static volatile Point buttonCenter;\n+\n+    private static final CountDownLatch windowGainedFocus = new CountDownLatch(1);\n+\n+    private static final CountDownLatch mouseButton1Released = new CountDownLatch(1);\n+    private static final CountDownLatch mouseButton3Released = new CountDownLatch(2);\n+\n+    private static final CountDownLatch actionPerformed = new CountDownLatch(1);\n@@ -50,1 +68,2 @@\n-        robot.setAutoWaitForIdle(true);\n+\n+        final bug4490179 eventHandler = new bug4490179();\n@@ -53,1 +72,0 @@\n-                frame = new JFrame(\"bug4490179\");\n@@ -55,0 +73,4 @@\n+                button.addActionListener(eventHandler);\n+                button.addMouseListener(eventHandler);\n+\n+                frame = new JFrame(\"bug4490179\");\n@@ -56,5 +78,5 @@\n-                button.addActionListener(e -> {\n-                    if ((e.getModifiers() & InputEvent.BUTTON1_MASK)\n-                            != InputEvent.BUTTON1_MASK) {\n-                        System.out.println(\"Status: Failed\");\n-                        passed = false;\n+\n+                frame.addWindowFocusListener(new WindowAdapter() {\n+                    @Override\n+                    public void windowGainedFocus(WindowEvent e) {\n+                        windowGainedFocus.countDown();\n@@ -63,0 +85,1 @@\n+\n@@ -68,0 +91,4 @@\n+\n+            if (!windowGainedFocus.await(1, SECONDS)) {\n+                throw new RuntimeException(\"Window didn't gain focus\");\n+            }\n@@ -69,1 +96,1 @@\n-            robot.delay(1000);\n+\n@@ -71,3 +98,3 @@\n-                pt = button.getLocationOnScreen();\n-                buttonW = button.getSize().width;\n-                buttonH = button.getSize().height;\n+                Point location = button.getLocationOnScreen();\n+                buttonCenter = new Point(location.x + button.getWidth() \/ 2,\n+                                         location.y + button.getHeight() \/ 2);\n@@ -76,2 +103,2 @@\n-            robot.mouseMove(pt.x + buttonW \/ 2, pt.y + buttonH \/ 2);\n-            robot.waitForIdle();\n+            robot.mouseMove(buttonCenter.x, buttonCenter.y);\n+            System.out.println(\"Press \/ Release button 3\");\n@@ -81,0 +108,1 @@\n+            System.out.println(\"Press button 1\");\n@@ -82,0 +110,1 @@\n+            System.out.println(\"Press button 3\");\n@@ -83,0 +112,1 @@\n+            System.out.println(\"Release button 3\");\n@@ -84,2 +114,0 @@\n-            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n-            robot.delay(500);\n@@ -87,2 +115,20 @@\n-            if (!passed) {\n-                throw new RuntimeException(\"Test Failed\");\n+            try {\n+                if (!mouseButton3Released.await(1, SECONDS)) {\n+                    throw new RuntimeException(\"Mouse button 3 isn't released\");\n+                }\n+\n+                robot.waitForIdle();\n+\n+                if (actionPerformed.await(100, MILLISECONDS)) {\n+                    throw new RuntimeException(\"Action event triggered by releasing button 3\");\n+                }\n+            } finally {\n+                System.out.println(\"Release button 1\");\n+                robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            }\n+\n+            if (!mouseButton1Released.await(1, SECONDS)) {\n+                throw new RuntimeException(\"Mouse button 1 isn't released\");\n+            }\n+            if (!actionPerformed.await(100, MILLISECONDS)) {\n+                throw new RuntimeException(\"Action event isn't triggered by releasing button 1\");\n@@ -98,0 +144,17 @@\n+\n+    @Override\n+    public void actionPerformed(ActionEvent e) {\n+        System.out.println(\"    actionPerformed\");\n+        actionPerformed.countDown();\n+    }\n+\n+    @Override\n+    public void mouseReleased(MouseEvent e) {\n+        if (e.getButton() == MouseEvent.BUTTON1) {\n+            System.out.println(\"    mouseReleased: button 1\");\n+            mouseButton1Released.countDown();\n+        } else if (e.getButton() == MouseEvent.BUTTON3) {\n+            System.out.println(\"    mouseReleased: button 3\");\n+            mouseButton3Released.countDown();\n+        }\n+    }\n","filename":"test\/jdk\/javax\/swing\/JButton\/bug4490179.java","additions":85,"deletions":22,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -106,14 +106,0 @@\n-    @ParameterizedTest\n-    @ValueSource(classes = {\n-            Long.class,\n-            Object.class,\n-            Util.class,\n-            Test.class,\n-            CopyOnWriteArrayList.class,\n-            AtomicReferenceFieldUpdater.class\n-    })\n-    void testInternalNameHash(Class<?> type) {\n-        var cd = type.describeConstable().orElseThrow();\n-        assertEquals(ConstantUtils.binaryToInternal(type.getName()).hashCode(), Util.internalNameHash(cd.descriptorString()));\n-    }\n-\n","filename":"test\/jdk\/jdk\/classfile\/UtilTest.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:-UseFastUnorderedTimeStamps -agentlib:jdwp=transport=dt_socket,server=y,address=any,onjcmd=y\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:-UseFastUnorderedTimeStamps -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=0\n@@ -125,1 +125,1 @@\n-            Events.assertField(e, \"options\").equal(\"transport=dt_socket,server=y,address=any,onjcmd=y\");\n+            Events.assertField(e, \"options\").equal(\"transport=dt_socket,server=y,suspend=n,address=0\");\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestAgentEvent.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,2 @@\n-                \"jdk.graal.compiler.management\");\n+                \"jdk.graal.compiler.management\",\n+                \"jdk.jsobject\");\n","filename":"test\/jdk\/jdk\/modules\/etc\/UpgradeableModules.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8336665\n+ * @summary Verify that generateCRLs method does not throw ClassCastException.\n+ *          It should throw CRLException instead.\n+ * @library \/test\/lib\n+ *\/\n+import java.security.NoSuchProviderException;\n+import java.security.cert.*;\n+import java.io.ByteArrayInputStream;\n+import java.util.Base64;\n+\n+import jdk.test.lib.Utils;\n+\n+public class UnexpectedCCE {\n+    static CertificateFactory cf = null;\n+\n+    public static void main(String[] av ) throws CertificateException,\n+           NoSuchProviderException {\n+\n+        \/\/ Fuzzed data input stream looks like an x509.OIDName\n+        \/\/ in the CertificateIssuerExtension. A CRLException is thrown\n+        \/\/ because an X500Name is expected.\n+        byte[] encoded_1 = Base64.getDecoder().decode(\"\"\"\n+            MIIBljCCAVMCAQEwCwYHKoZIzjgEAwUAMC0xEzARBgoJkiaJk\/IsZAEZEwNjb20xFjA\\\n+            UBgoJkiaJjvIsZAEZEwZ0ZXN0Q0EXDTAzMDcxNTE2MjAwNVoXDTAzMDcyMDE2MjAwNV\\\n+            owgdIwUwIBBBcNMDMwNzE1MTYyMDAzWjA\/MD0GA1UdHQEB\/wQzMDGILzETMBEGCgmSJ\\\n+            omT8ixkARkMA2NvbTEYMBYGCgmSJomT8ixkARkTCGNlcnRzUlVTMBICAQMXDTAzMDcx\\\n+            NTE2MjAwNFowUwIBAhcNMDMwNzE1MTYyMDA0WjA\/MD0GA1UdIQEB\/wQzMDEwGAYDVQQ\\\n+            DExEwDyqGMDEUMgAwgDAuRQA1MRYGCgmSJomT8ixkARkTCG15VGVzdENBMBICAQEXDT\\\n+            AzMDcxNTE2MjAwNFqgHzAdMA8GA1UdHAEB\/wQFMAOEAf8wCgYDVR0UAwACAQIwCwYHK\\\n+            oZIzjgEAwUAAzAAMC0CFBaZDryEEOr8Cw7sOAAAAKaDgtHcAhUAkUenJpwYZgS6IPjy\\\n+            AjZG+RfHdO4=\"\"\");\n+\n+        \/\/ Fuzzed data input stream looks like an x509.X400Address\n+        \/\/ in the CertificateIssuerExtension. A CRLException is thrown\n+        \/\/ because an X500Name is expected.\n+        byte[] encoded_2 = Base64.getDecoder().decode(\"\"\"\n+            MIIBljCCAVMCAQEwCwYHKoZIzjgEAwUAMC0xEzARBgoJkiaJk\/IsZAEZEwNjb20xFjA\\\n+            UBgoJkiaJk\/IsZAEZEwZ0ZXN0J0EXDTAzMDcxNTE2MjAwNVoXDTAzMDcyMDE2MjAwNV\\\n+            owgdIwUwIBBBcNMDMwNzE1MTYyMDA0WjA\/MD0GA1UdHQEB\/wQzMDGkLzETMBEGCgmSJ\\\n+            omT8ixkARkTA2NvbTEYMBYGCgmSJomT8ixkARkTCGNlcnRzUlVTMBICAQMXDTAzMDcx\\\n+            NTE2MjAwNFowUwIBAhcNMDMwNzE1MTYyMDA0WjA\/MD0GA1UdHQEB\/wQzMDGjLzETMBE\\\n+            GCgmSJomT8ixkARkTA2NvGG0wMRYGCgmSJomT8ixkARkTCG15VGVzdENBMBICAQEXDT\\\n+            AzMDcxNTE2MjAwNVqgHzAdMGAGA1UdHAEB\/wQFMAOEAf8wCgYDVR0UBAMCAQIwCwYHK\\\n+            oZIzjgEAwUAAzAAMC0CFBaZDryEEOr8Cw7sJa07gqaDgtHcAhUAkUenJpwYZgS6IPjy\\\n+            AjZG+RfHdO4=\"\"\");\n+\n+        cf = CertificateFactory.getInstance(\"X.509\", \"SUN\");\n+\n+        run(encoded_1);\n+        run(encoded_2);\n+    }\n+\n+    private static void run(byte[] buf) {\n+        Utils.runAndCheckException(\n+                () -> cf.generateCRLs(new ByteArrayInputStream(buf)),\n+                CRLException.class);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/x509\/X509CRLImpl\/UnexpectedCCE.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -88,7 +88,0 @@\n-    \/\/ Flag for supporting JDK backward compatible IDs, such as \"EST\".\n-    static final boolean USE_OLDMAPPING;\n-    static {\n-      String oldmapping = System.getProperty(\"sun.timezone.ids.oldmapping\", \"false\").toLowerCase(Locale.ROOT);\n-      USE_OLDMAPPING = (oldmapping.equals(\"yes\") || oldmapping.equals(\"true\"));\n-    }\n-\n@@ -656,12 +649,0 @@\n-        \/*\n-         * If old JDK compatibility is specified, get the old alias\n-         * name.\n-         *\/\n-        if (USE_OLDMAPPING) {\n-            String compatibleID = TzIDOldMapping.MAP.get(ID);\n-            if (compatibleID != null) {\n-                givenID = ID;\n-                ID = compatibleID;\n-            }\n-        }\n-\n@@ -845,4 +826,2 @@\n-                 if (!USE_OLDMAPPING) {\n-                     \/\/ Replace old mappings from `jdk11_backward`\n-                     aliases.putAll(conflictingIDs);\n-                 }\n+                 \/\/ Replace old mappings from `jdk11_backward`\n+                 aliases.putAll(conflictingIDs);\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/ZoneInfoOld.java","additions":2,"deletions":23,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,269 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8335912\n+ * @summary test extract jar files overwrite existing files behavior\n+ * @library \/test\/lib\n+ * @modules jdk.jartool\n+ * @build jdk.test.lib.Platform\n+ *        jdk.test.lib.util.FileUtils\n+ * @run junit\/othervm ExtractFilesTest\n+ *\/\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.api.TestInstance.Lifecycle;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.Stream;\n+\n+import jdk.test.lib.util.FileUtils;\n+\n+ @TestInstance(Lifecycle.PER_CLASS)\n+ public class ExtractFilesTest {\n+    private static final ToolProvider JAR_TOOL = ToolProvider.findFirst(\"jar\")\n+        .orElseThrow(() ->\n+            new RuntimeException(\"jar tool not found\")\n+        );\n+\n+    private final String nl = System.lineSeparator();\n+    private final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    private final PrintStream out = new PrintStream(baos);\n+\n+    @BeforeAll\n+    public void setupJar() throws IOException {\n+        mkdir(\"test1 test2\");\n+        echo(\"testfile1\", \"test1\/testfile1\");\n+        echo(\"testfile2\", \"test2\/testfile2\");\n+        jar(\"cf test.jar -C test1 . -C test2 .\");\n+        rm(\"test1 test2\");\n+    }\n+\n+    @AfterAll\n+    public void cleanup() {\n+        rm(\"test.jar\");\n+    }\n+\n+    \/**\n+     * Regular clean extract with expected output.\n+     *\/\n+    @Test\n+    public void testExtract() throws IOException {\n+        jar(\"xvf test.jar\");\n+        println();\n+        String output = \"  created: META-INF\/\" + nl +\n+                \" inflated: META-INF\/MANIFEST.MF\" + nl +\n+                \" inflated: testfile1\" + nl +\n+                \" inflated: testfile2\" + nl;\n+        rm(\"META-INF testfile1 testfile2\");\n+        assertOutputContains(output);\n+    }\n+\n+    \/**\n+     * Extract should overwrite existing file as default behavior.\n+     *\/\n+    @Test\n+    public void testOverwrite() throws IOException {\n+        touch(\"testfile1\");\n+        jar(\"xvf test.jar\");\n+        println();\n+        String output = \"  created: META-INF\/\" + nl +\n+                \" inflated: META-INF\/MANIFEST.MF\" + nl +\n+                \" inflated: testfile1\" + nl +\n+                \" inflated: testfile2\" + nl;\n+        Assertions.assertEquals(\"testfile1\", cat(\"testfile1\"));\n+        rm(\"META-INF testfile1 testfile2\");\n+        assertOutputContains(output);\n+    }\n+\n+    \/**\n+     * Extract with legacy style option `k` should preserve existing files.\n+     *\/\n+    @Test\n+    public void testKeptOldFile() throws IOException {\n+        touch(\"testfile1\");\n+        jar(\"xkvf test.jar\");\n+        println();\n+        String output = \"  created: META-INF\/\" + nl +\n+                \" inflated: META-INF\/MANIFEST.MF\" + nl +\n+                \"  skipped: testfile1 exists\" + nl +\n+                \" inflated: testfile2\" + nl;\n+        Assertions.assertEquals(\"\", cat(\"testfile1\"));\n+        Assertions.assertEquals(\"testfile2\", cat(\"testfile2\"));\n+        rm(\"META-INF testfile1 testfile2\");\n+        assertOutputContains(output);\n+    }\n+\n+    \/**\n+     * Extract with gnu style -k should preserve existing files.\n+     *\/\n+    @Test\n+    public void testGnuOptionsKeptOldFile() throws IOException {\n+        touch(\"testfile1 testfile2\");\n+        jar(\"-x -k -v -f test.jar\");\n+        println();\n+        String output = \"  created: META-INF\/\" + nl +\n+                \" inflated: META-INF\/MANIFEST.MF\" + nl +\n+                \"  skipped: testfile1 exists\" + nl +\n+                \"  skipped: testfile2 exists\" + nl;\n+        Assertions.assertEquals(\"\", cat(\"testfile1\"));\n+        Assertions.assertEquals(\"\", cat(\"testfile2\"));\n+        rm(\"META-INF testfile1 testfile2\");\n+        assertOutputContains(output);\n+    }\n+\n+    \/**\n+     * Extract with gnu style long option --keep-old-files should preserve existing files.\n+     *\/\n+    @Test\n+    public void testGnuLongOptionsKeptOldFile() throws IOException {\n+        touch(\"testfile2\");\n+        jar(\"-x --keep-old-files -v -f test.jar\");\n+        println();\n+        String output = \"  created: META-INF\/\" + nl +\n+                \" inflated: META-INF\/MANIFEST.MF\" + nl +\n+                \" inflated: testfile1\" + nl +\n+                \"  skipped: testfile2 exists\" + nl;\n+        Assertions.assertEquals(\"testfile1\", cat(\"testfile1\"));\n+        Assertions.assertEquals(\"\", cat(\"testfile2\"));\n+        rm(\"META-INF testfile1 testfile2\");\n+        assertOutputContains(output);\n+    }\n+\n+    \/**\n+     * Test jar will issue warning when use keep option in non-extraction mode.\n+     *\/\n+    @Test\n+    public void testWarningOnInvalidKeepOption() throws IOException {\n+        var err = jar(\"tkf test.jar\");\n+        println();\n+\n+        String output = \"META-INF\/\" + nl +\n+                \"META-INF\/MANIFEST.MF\" + nl +\n+                \"testfile1\" + nl +\n+                \"testfile2\" + nl;\n+\n+        assertOutputContains(output);\n+        Assertions.assertEquals(\"Warning: The --keep-old-files\/-k\/k option is not valid with current usage, will be ignored.\" + nl, err);\n+    }\n+\n+    private void assertOutputContains(String expected) {\n+        Assertions.assertTrue(baos.toString().contains(expected));\n+    }\n+\n+    private Stream<Path> mkpath(String... args) {\n+        return Arrays.stream(args).map(d -> Path.of(\".\", d.split(\"\/\")));\n+    }\n+\n+    private void mkdir(String cmdline) {\n+        System.out.println(\"mkdir -p \" + cmdline);\n+        mkpath(cmdline.split(\" +\")).forEach(p -> {\n+            try {\n+                Files.createDirectories(p);\n+            } catch (IOException x) {\n+                throw new UncheckedIOException(x);\n+            }\n+        });\n+    }\n+\n+    private void touch(String cmdline) {\n+        System.out.println(\"touch \" + cmdline);\n+        mkpath(cmdline.split(\" +\")).forEach(p -> {\n+            try {\n+                Files.createFile(p);\n+            } catch (IOException x) {\n+                throw new UncheckedIOException(x);\n+            }\n+        });\n+    }\n+\n+    private void echo(String text, String path) {\n+        System.out.println(\"echo '\" + text + \"' > \" + path);\n+        try {\n+            var p = Path.of(\".\", path.split(\"\/\"));\n+            Files.writeString(p, text);\n+        } catch (IOException x) {\n+            throw new UncheckedIOException(x);\n+        }\n+    }\n+\n+    private String cat(String path) {\n+        System.out.println(\"cat \" + path);\n+        try {\n+            return Files.readString(Path.of(path));\n+        } catch (IOException x) {\n+            throw new UncheckedIOException(x);\n+        }\n+    }\n+\n+    private void rm(String cmdline) {\n+        System.out.println(\"rm -rf \" + cmdline);\n+        mkpath(cmdline.split(\" +\")).forEach(p -> {\n+            try {\n+                if (Files.isDirectory(p)) {\n+                    FileUtils.deleteFileTreeWithRetry(p);\n+                } else {\n+                    FileUtils.deleteFileIfExistsWithRetry(p);\n+                }\n+            } catch (IOException x) {\n+                throw new UncheckedIOException(x);\n+            }\n+        });\n+    }\n+\n+    private String jar(String cmdline) throws IOException {\n+        System.out.println(\"jar \" + cmdline);\n+        baos.reset();\n+\n+        \/\/ the run method catches IOExceptions, we need to expose them\n+        ByteArrayOutputStream baes = new ByteArrayOutputStream();\n+        PrintStream err = new PrintStream(baes);\n+        PrintStream saveErr = System.err;\n+        System.setErr(err);\n+        try {\n+            int rc = JAR_TOOL.run(out, err, cmdline.split(\" +\"));\n+            if (rc != 0) {\n+                throw new IOException(baes.toString());\n+            }\n+        } finally {\n+            System.setErr(saveErr);\n+        }\n+        return baes.toString();\n+    }\n+\n+    private void println() throws IOException {\n+        System.out.println(new String(baos.toByteArray()));\n+    }\n+}\n","filename":"test\/jdk\/tools\/jar\/ExtractFilesTest.java","additions":269,"deletions":0,"binary":false,"changes":269,"status":"added"},{"patch":"@@ -0,0 +1,517 @@\n+\/*\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.Stream;\n+\n+import jdk.test.lib.util.JarBuilder;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assumptions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8173970\n+ * @summary jar tool should allow extracting to specific directory\n+ * @library \/test\/lib\n+ * @comment The test relies on verification of error messages generated by jar tool, so we use\n+ *          a fixed en_US locale for this test.\n+ * @run junit\/othervm -Duser.language=en -Duser.country=US JarExtractTest\n+ *\/\n+public class JarExtractTest {\n+    private static final ToolProvider JAR_TOOL = ToolProvider.findFirst(\"jar\")\n+            .orElseThrow(() ->\n+                    new RuntimeException(\"jar tool not found\")\n+            );\n+\n+    private static final byte[] FILE_CONTENT = \"Hello world!!!\".getBytes(StandardCharsets.UTF_8);\n+    \/\/ the jar that will get extracted in the tests\n+    private Path testJarPath;\n+    private static Collection<Path> filesToDelete = new ArrayList<>();\n+\n+    @BeforeEach\n+    public void createTestJar() throws Exception {\n+        final String tmpDir = Files.createTempDirectory(\"8173970-\").toString();\n+        testJarPath = Path.of(tmpDir, \"8173970-test.jar\");\n+        final JarBuilder builder = new JarBuilder(testJarPath.toString());\n+        \/\/ d1\n+        \/\/  |--- d2\n+        \/\/  |    |--- d3\n+        \/\/  |    |    |--- f2.txt\n+        \/\/  |\n+        \/\/  |--- d4\n+        \/\/  ...\n+        \/\/  f1.txt\n+\n+        builder.addEntry(\"d1\/\", new byte[0]);\n+        builder.addEntry(\"f1.txt\", FILE_CONTENT);\n+        builder.addEntry(\"d1\/d2\/d3\/f2.txt\", FILE_CONTENT);\n+        builder.addEntry(\"d1\/d4\/\", new byte[0]);\n+        builder.build();\n+    }\n+\n+    @AfterEach\n+    public void cleanup() {\n+        for (final Path p : filesToDelete) {\n+            try {\n+                System.out.println(\"Deleting file\/dir \" + p);\n+                Files.delete(p);\n+            } catch (IOException ioe) {\n+                \/\/ignore\n+                System.err.println(\"ignoring exception: \" + ioe\n+                        + \" that happened when deleting: \" + p);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Creates and returns various relative paths, to which the jar will be extracted in the tests\n+     *\/\n+    static Stream<Arguments> provideRelativeExtractLocations() throws Exception {\n+        \/\/ create some dirs so that they already exist when the jar is being extracted\n+        final String existing1 = \".\" + File.separator + \"8173970-existing-1\";\n+        Files.createDirectories(Path.of(existing1));\n+        final String existing2 = \".\" + File.separator + \"foo\" + File.separator + \"8173970-existing-2\";\n+        Files.createDirectories(Path.of(existing2));\n+        final Path dirOutsideScratchDir = Files.createTempDirectory(Path.of(\"..\"), \"8173970\");\n+        \/\/ we need to explicitly delete this dir after the tests end\n+        filesToDelete.add(dirOutsideScratchDir);\n+        final String existing3 = dirOutsideScratchDir.toString() + File.separator + \"8173970-existing-3\";\n+        Files.createDirectories(Path.of(existing3));\n+\n+        final String anotherDirOutsideScratchDir = \"..\" + File.separator + \"8173970-non-existent\";\n+        filesToDelete.add(Path.of(anotherDirOutsideScratchDir));\n+\n+        final List<Arguments> args = new ArrayList<>();\n+        args.add(Arguments.of(\".\")); \/\/ current dir\n+        \/\/ (explicitly) relative to current dir\n+        args.add(Arguments.of(\".\" + File.separator + \"8173970-extract-1\"));\n+        \/\/ (implicitly) relative to current dir\n+        args.add(Arguments.of(\"8173970-extract-2\"));\n+        \/\/ sibling to current dir\n+        args.add(Arguments.of(anotherDirOutsideScratchDir));\n+        \/\/ some existing dirs\n+        args.add(Arguments.of(existing1));\n+        args.add(Arguments.of(existing2));\n+        args.add(Arguments.of(existing3));\n+        \/\/ a non-existent dir within an existing dir\n+        args.add(Arguments.of(existing1 + File.separator\n+                + \"non-existing\" + File.separator + \"foo\"));\n+        return args.stream();\n+    }\n+\n+    \/**\n+     * Creates and returns various absolute paths, to which the jar will be extracted in the tests\n+     *\/\n+    static Stream<Arguments> provideAbsoluteExtractLocations() throws Exception {\n+        final Stream<Arguments> relative = provideRelativeExtractLocations();\n+        return relative.map((arg) -> {\n+            final String relPath = (String) arg.get()[0];\n+            return Arguments.of(Path.of(relPath).toAbsolutePath().toString());\n+        });\n+    }\n+\n+    \/**\n+     * Creates and returns various normalized paths, to which the jar will be extracted in the tests\n+     *\/\n+    static Stream<Arguments> provideAbsoluteNormalizedExtractLocations() throws Exception {\n+        final Stream<Arguments> relative = provideRelativeExtractLocations();\n+        return relative.map((arg) -> {\n+            final String relPath = (String) arg.get()[0];\n+            return Arguments.of(Path.of(relPath).toAbsolutePath().normalize().toString());\n+        });\n+    }\n+\n+    \/**\n+     * Extracts a jar to various relative paths, using the -C\/--dir option and then\n+     * verifies that the extracted content is at the expected locations with the correct\n+     * content\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"provideRelativeExtractLocations\")\n+    public void testExtractToRelativeDir(final String dest) throws Exception {\n+        testLongFormExtract(dest);\n+        testExtract(dest);\n+    }\n+\n+    \/**\n+     * Extracts a jar to various absolute paths, using the -C\/--dir option and then\n+     * verifies that the extracted content is at the expected locations with the correct\n+     * content\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"provideAbsoluteExtractLocations\")\n+    public void testExtractToAbsoluteDir(final String dest) throws Exception {\n+        testExtract(dest);\n+        testLongFormExtract(dest);\n+    }\n+\n+    \/**\n+     * Extracts a jar to various normalized paths (i.e. no {@code .} or @{code ..} in the path components),\n+     * using the -C\/--dir option and then verifies that the extracted content is at the expected locations\n+     * with the correct content\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"provideAbsoluteNormalizedExtractLocations\")\n+    public void testExtractToAbsoluteNormalizedDir(final String dest) throws Exception {\n+        testExtract(dest);\n+        testLongFormExtract(dest);\n+    }\n+\n+    \/**\n+     * Test that extracting a jar with {@code jar -x -f --dir} works as expected\n+     *\/\n+    @Test\n+    public void testExtractLongFormDir() throws Exception {\n+        final String dest = \"foo-bar\";\n+        System.out.println(\"Extracting \" + testJarPath + \" to \" + dest);\n+        final int exitCode = JAR_TOOL.run(System.out, System.err, \"-x\", \"-f\", testJarPath.toString(),\n+                \"--dir\", dest);\n+        assertEquals(0, exitCode, \"Failed to extract \" + testJarPath + \" to \" + dest);\n+        verifyExtractedContent(dest);\n+    }\n+\n+    \/**\n+     * Verifies that the {@code jar --help} output contains the --dir option\n+     *\/\n+    @Test\n+    public void testHelpOutput() {\n+        final ByteArrayOutputStream outStream = new ByteArrayOutputStream();\n+        final int exitCode = JAR_TOOL.run(new PrintStream(outStream), System.err, \"--help\");\n+        assertEquals(0, exitCode, \"jar --help command failed\");\n+        final String output = outStream.toString();\n+        \/\/ this message is expected to be the one from the jar --help output which is sourced from\n+        \/\/ jar.properties\n+        final String expectedMsg = \"--dir                    Directory into which the jar will be extracted\";\n+        assertTrue(output.contains(expectedMsg), \"jar --help didn't contain --dir option\");\n+    }\n+\n+    \/**\n+     * Tests that {@code jar -x -f} command works fine even when the -C or --dir option\n+     * isn't specified\n+     *\/\n+    @Test\n+    public void testExtractWithoutOutputDir() throws Exception {\n+        final int exitCode = JAR_TOOL.run(System.out, System.err, \"-x\", \"-f\", testJarPath.toString());\n+        assertEquals(0, exitCode, \"Failed to extract \" + testJarPath);\n+        \/\/ the content would have been extracted to current dir\n+        verifyExtractedContent(\".\");\n+    }\n+\n+    \/**\n+     * Tests that {@code jar --extract -f} command works fine even when the -C or --dir option\n+     * isn't specified\n+     *\/\n+    @Test\n+    public void testLongFormExtractWithoutOutputDir() throws Exception {\n+        final int exitCode = JAR_TOOL.run(System.out, System.err, \"--extract\", \"-f\", testJarPath.toString());\n+        assertEquals(0, exitCode, \"Failed to extract \" + testJarPath);\n+        \/\/ the content would have been extracted to current dir\n+        verifyExtractedContent(\".\");\n+    }\n+\n+    \/**\n+     * Tests that when the destination directory specified for jar extract is actually a file\n+     * or one of the path component in the specified destination path is a file, then the\n+     * extraction fails.\n+     *\/\n+    @Test\n+    public void testExtractToNonDirectory() throws Exception {\n+        final String expectedErrMsg = \"could not create directory\";\n+        final Path notADir1 = Files.createTempFile(Path.of(\".\"), \"8173970\", \".txt\");\n+        final Path notADir2 = notADir1.resolve(\"foobar\");\n+        for (final Path dest : List.of(notADir1, notADir2)) {\n+            final String[] args = {\"-x\", \"-f\", testJarPath.toString(), \"-C\", dest.toString()};\n+            final ByteArrayOutputStream err = new ByteArrayOutputStream();\n+            printJarCommand(args);\n+            int exitCode = JAR_TOOL.run(System.out, new PrintStream(err), args);\n+            assertNotEquals(0, exitCode, \"jar extraction was expected to fail but didn't\");\n+            \/\/ verify it did indeed fail due to the right reason\n+            assertTrue(err.toString(StandardCharsets.UTF_8).contains(expectedErrMsg));\n+        }\n+    }\n+\n+    \/**\n+     * Tests that extracting a jar using {@code -P} flag and without any explicit destination\n+     * directory works correctly if the jar contains entries with leading slashes and\/or {@code ..}\n+     * parts preserved.\n+     *\/\n+    @Test\n+    public void testExtractNoDestDirWithPFlag() throws Exception {\n+        \/\/ run this test only on those systems where \"\/tmp\" directory is available and we\n+        \/\/ can write to it\n+        Assumptions.assumeTrue(Files.isDirectory(Path.of(\"\/tmp\")),\n+                \"skipping test, since \/tmp isn't a directory\");\n+        \/\/ try and write into \"\/tmp\"\n+        final Path tmpDir;\n+        try {\n+            tmpDir = Files.createTempDirectory(Path.of(\"\/tmp\"), \"8173970-\").toAbsolutePath();\n+        } catch (IOException ioe) {\n+            Assumptions.abort(\"skipping test, since \/tmp cannot be written to: \" + ioe);\n+            return;\n+        }\n+        final String leadingSlashEntryName = tmpDir.toString() + \"\/foo\/f1.txt\";\n+        \/\/ create a jar which has leading slash (\/) and dot-dot (..) preserved in entry names\n+        final Path jarPath = createJarWithPFlagSemantics(leadingSlashEntryName);\n+        final List<String[]> cmdArgs = new ArrayList<>();\n+        cmdArgs.add(new String[]{\"-xvfP\", jarPath.toString()});\n+        cmdArgs.add(new String[]{\"--extract\", \"-v\", \"-P\", \"-f\", jarPath.toString()});\n+        try {\n+            for (final String[] args : cmdArgs) {\n+                printJarCommand(args);\n+                final int exitCode = JAR_TOOL.run(System.out, System.err, args);\n+                assertEquals(0, exitCode, \"Failed to extract \" + jarPath);\n+                final String dest = \".\";\n+                assertTrue(Files.isDirectory(Path.of(dest)), dest + \" is not a directory\");\n+                final Path d1 = Path.of(dest, \"d1\");\n+                assertTrue(Files.isDirectory(d1), d1 + \" directory is missing or not a directory\");\n+                final Path d2 = Path.of(dest, \"d1\", \"d2\");\n+                assertTrue(Files.isDirectory(d2), d2 + \" directory is missing or not a directory\");\n+                final Path f1 = Path.of(leadingSlashEntryName);\n+                assertTrue(Files.isRegularFile(f1), f1 + \" is missing or not a file\");\n+                assertArrayEquals(FILE_CONTENT, Files.readAllBytes(f1),\n+                        \"Unexpected content in file \" + f1);\n+                final Path f2 = Path.of(\"d1\/d2\/..\/f2.txt\");\n+                assertTrue(Files.isRegularFile(f2), f2 + \" is missing or not a file\");\n+                assertArrayEquals(FILE_CONTENT, Files.readAllBytes(f2),\n+                        \"Unexpected content in file \" + f2);\n+            }\n+        } finally {\n+            \/\/ clean up the file that might have been extracted into \"\/tmp\/....\" directory\n+            Files.deleteIfExists(Path.of(leadingSlashEntryName));\n+        }\n+    }\n+\n+    \/**\n+     * Tests that the {@code -P} option cannot be used during jar extraction when the {@code -C} and\/or\n+     * {@code --dir} option is used\n+     *\/\n+    @Test\n+    public void testExtractWithDirPFlagNotAllowed() throws Exception {\n+        \/\/ this error message is expected to be the one from the jar --help output which is sourced from\n+        \/\/ jar.properties\n+        final String expectedErrMsg = \"You may not specify '-Px' with the '-C' or '--dir' options\";\n+        final String tmpDir = Files.createTempDirectory(Path.of(\".\"), \"8173970-\").toString();\n+        final List<String[]> cmdArgs = new ArrayList<>();\n+        cmdArgs.add(new String[]{\"-x\", \"-f\", testJarPath.toString(), \"-P\", \"-C\", tmpDir});\n+        cmdArgs.add(new String[]{\"-x\", \"-f\", testJarPath.toString(), \"-P\", \"--dir\", tmpDir});\n+        cmdArgs.add(new String[]{\"-x\", \"-f\", testJarPath.toString(), \"-P\", \"-C\", \".\"});\n+        cmdArgs.add(new String[]{\"-x\", \"-f\", testJarPath.toString(), \"-P\", \"--dir\", \".\"});\n+        cmdArgs.add(new String[]{\"-xvfP\", testJarPath.toString(), \"-C\", tmpDir});\n+        cmdArgs.add(new String[]{\"--extract\", \"-f\", testJarPath.toString(), \"-P\", \"-C\", tmpDir});\n+        cmdArgs.add(new String[]{\"--extract\", \"-f\", testJarPath.toString(), \"-P\", \"--dir\", tmpDir});\n+        cmdArgs.add(new String[]{\"--extract\", \"-f\", testJarPath.toString(), \"-P\", \"-C\", \".\"});\n+        cmdArgs.add(new String[]{\"--extract\", \"-f\", testJarPath.toString(), \"-P\", \"--dir\", \".\"});\n+        for (final String[] args : cmdArgs) {\n+            final ByteArrayOutputStream err = new ByteArrayOutputStream();\n+            printJarCommand(args);\n+            int exitCode = JAR_TOOL.run(System.out, new PrintStream(err), args);\n+            assertNotEquals(0, exitCode, \"jar extraction was expected to fail but didn't\");\n+            \/\/ verify it did indeed fail due to the right reason\n+            assertTrue(err.toString(StandardCharsets.UTF_8).contains(expectedErrMsg));\n+        }\n+    }\n+\n+    \/**\n+     * Tests that {@code jar -xvf <jarname> -C <dir>} works fine too\n+     *\/\n+    @Test\n+    public void testLegacyCompatibilityMode() throws Exception {\n+        final String tmpDir = Files.createTempDirectory(Path.of(\".\"), \"8173970-\").toString();\n+        final String[] args = new String[]{\"-xvf\", testJarPath.toString(), \"-C\", tmpDir};\n+        printJarCommand(args);\n+        final int exitCode = JAR_TOOL.run(System.out, System.err, args);\n+        assertEquals(0, exitCode, \"Failed to extract \" + testJarPath);\n+        verifyExtractedContent(tmpDir);\n+    }\n+\n+    \/**\n+     * Tests that when multiple directories are specified for extracting the jar, the jar extraction\n+     * fails\n+     *\/\n+    @Test\n+    public void testExtractFailWithMultipleDir() throws Exception {\n+        \/\/ this error message is expected to be the one from the jar --help output which is sourced from\n+        \/\/ jar.properties\n+        final String expectedErrMsg = \"You may not specify the '-C' or '--dir' option more than once with the '-x' option\";\n+        final String tmpDir = Files.createTempDirectory(Path.of(\".\"), \"8173970-\").toString();\n+        final List<String[]> cmdArgs = new ArrayList<>();\n+        cmdArgs.add(new String[]{\"-x\", \"-f\", testJarPath.toString(), \"-C\", tmpDir, \"-C\", tmpDir});\n+        cmdArgs.add(new String[]{\"-x\", \"-f\", testJarPath.toString(), \"--dir\", tmpDir, \"--dir\", tmpDir});\n+        cmdArgs.add(new String[]{\"-x\", \"-f\", testJarPath.toString(), \"--dir\", tmpDir, \"-C\", tmpDir});\n+        cmdArgs.add(new String[]{\"--extract\", \"-f\", testJarPath.toString(), \"-C\", tmpDir, \"-C\", tmpDir});\n+        cmdArgs.add(new String[]{\"--extract\", \"-f\", testJarPath.toString(), \"--dir\", tmpDir, \"--dir\", tmpDir});\n+        cmdArgs.add(new String[]{\"--extract\", \"-f\", testJarPath.toString(), \"--dir\", tmpDir, \"-C\", tmpDir});\n+        for (final String[] args : cmdArgs) {\n+            final ByteArrayOutputStream err = new ByteArrayOutputStream();\n+            printJarCommand(args);\n+            int exitCode = JAR_TOOL.run(System.out, new PrintStream(err), args);\n+            assertNotEquals(0, exitCode, \"jar extraction was expected to fail but didn't\");\n+            \/\/ verify it did indeed fail due to the right reason\n+            assertTrue(err.toString(StandardCharsets.UTF_8).contains(expectedErrMsg));\n+        }\n+    }\n+\n+    \/**\n+     * Tests that extracting only specific files from a jar, into a specific destination directory,\n+     * works as expected\n+     *\/\n+    @Test\n+    public void testExtractPartialContent() throws Exception {\n+        String tmpDir = Files.createTempDirectory(Path.of(\".\"), \"8173970-\").toString();\n+        String[] cmdArgs = new String[]{\"-x\", \"-f\", testJarPath.toString(), \"--dir\", tmpDir,\n+                \"f1.txt\", \"d1\/d2\/d3\/f2.txt\"};\n+        testExtractPartialContent(tmpDir, cmdArgs);\n+\n+        tmpDir = Files.createTempDirectory(Path.of(\".\"), \"8173970-\").toString();\n+        cmdArgs = new String[]{\"--extract\", \"-f\", testJarPath.toString(), \"--dir\", tmpDir,\n+                \"f1.txt\", \"d1\/d2\/d3\/f2.txt\"};\n+        testExtractPartialContent(tmpDir, cmdArgs);\n+\n+    }\n+\n+    \/**\n+     * Extract to destDir using the passed command arguments and verify the extracted content\n+     *\/\n+    private void testExtractPartialContent(final String destDir, final String[] extractArgs) throws Exception {\n+        printJarCommand(extractArgs);\n+        final int exitCode = JAR_TOOL.run(System.out, System.err, extractArgs);\n+        assertEquals(0, exitCode, \"Failed to extract \" + testJarPath);\n+        \/\/ make sure only the specific files were extracted\n+        final Stream<Path> paths = Files.walk(Path.of(destDir));\n+        \/\/ files\/dirs count expected to be found when the location to which the jar was extracted\n+        \/\/ is walked.\n+        \/\/ 1) The top level dir being walked 2) f1.txt file 3) d1 dir 4) d1\/d2 dir\n+        \/\/ 5) d1\/d2\/d3 dir 6) d1\/d2\/d3\/f2.txt file\n+        final int numExpectedFiles = 6;\n+        assertEquals(numExpectedFiles, paths.count(), \"Unexpected number of files\/dirs in \" + destDir);\n+        final Path f1 = Path.of(destDir, \"f1.txt\");\n+        assertTrue(Files.isRegularFile(f1), f1.toString() + \" wasn't extracted from \" + testJarPath);\n+        assertArrayEquals(FILE_CONTENT, Files.readAllBytes(f1), \"Unexpected content in file \" + f1);\n+        final Path d1 = Path.of(destDir, \"d1\");\n+        assertTrue(Files.isDirectory(d1), d1.toString() + \" wasn't extracted from \" + testJarPath);\n+        assertEquals(2, Files.walk(d1, 1).count(), \"Unexpected number \" +\n+                \"of files\/dirs in \" + d1);\n+        final Path d2 = Path.of(d1.toString(), \"d2\");\n+        assertTrue(Files.isDirectory(d2), d2.toString() + \" wasn't extracted from \" + testJarPath);\n+        assertEquals(2, Files.walk(d2, 1).count(), \"Unexpected number \" +\n+                \"of files\/dirs in \" + d2);\n+        final Path d3 = Path.of(d2.toString(), \"d3\");\n+        assertTrue(Files.isDirectory(d3), d3.toString() + \" wasn't extracted from \" + testJarPath);\n+        assertEquals(2, Files.walk(d3, 1).count(), \"Unexpected number \" +\n+                \"of files\/dirs in \" + d3);\n+        final Path f2 = Path.of(d3.toString(), \"f2.txt\");\n+        assertTrue(Files.isRegularFile(f2), f2.toString() + \" wasn't extracted from \" + testJarPath);\n+        assertArrayEquals(FILE_CONTENT, Files.readAllBytes(f2), \"Unexpected content in file \" + f2);\n+    }\n+\n+    \/**\n+     * Extracts the jar file using {@code jar -x -f <jarfile> -C <dest>} and verifies the extracted content\n+     *\/\n+    private void testExtract(final String dest) throws Exception {\n+        final String[] args = new String[]{\"-x\", \"-f\", testJarPath.toString(), \"-C\", dest};\n+        printJarCommand(args);\n+        final int exitCode = JAR_TOOL.run(System.out, System.err, args);\n+        assertEquals(0, exitCode, \"Failed to extract \" + testJarPath + \" to \" + dest);\n+        verifyExtractedContent(dest);\n+    }\n+\n+    \/**\n+     * Extracts the jar file using {@code jar --extract -f <jarfile> -C <dest>} and verifies the\n+     * extracted content\n+     *\/\n+    private void testLongFormExtract(final String dest) throws Exception {\n+        final String[] args = new String[]{\"--extract\", \"-f\", testJarPath.toString(), \"-C\", dest};\n+        printJarCommand(args);\n+        final int exitCode = JAR_TOOL.run(System.out, System.err, args);\n+        assertEquals(0, exitCode, \"Failed to extract \" + testJarPath + \" to \" + dest);\n+        verifyExtractedContent(dest);\n+    }\n+\n+    \/**\n+     * Verifies that the extracted jar content matches what was present in the original jar\n+     *\/\n+    private void verifyExtractedContent(final String dest) throws IOException {\n+        assertTrue(Files.isDirectory(Path.of(dest)), dest + \" is not a directory\");\n+        final Path d1 = Path.of(dest, \"d1\");\n+        assertTrue(Files.isDirectory(d1), d1 + \" directory is missing or not a directory\");\n+        final Path d2 = Path.of(dest, \"d1\", \"d2\");\n+        assertTrue(Files.isDirectory(d2), d2 + \" directory is missing or not a directory\");\n+        final Path d3 = Path.of(dest, \"d1\", \"d2\", \"d3\");\n+        assertTrue(Files.isDirectory(d3), d3 + \" directory is missing or not a directory\");\n+        final Path d4 = Path.of(dest, \"d1\", \"d4\");\n+        assertTrue(Files.isDirectory(d4), d4 + \" directory is missing or not a directory\");\n+        \/\/ d1\/d4 is expected to be empty directory\n+        final List<Path> d4Children;\n+        try (final Stream<Path> s = Files.walk(d4, 1)) {\n+            d4Children = s.toList();\n+        }\n+        assertEquals(1, d4Children.size(), \"Directory \" + d4\n+                + \" has unexpected files\/dirs: \" + d4Children);\n+        final Path f1 = Path.of(dest, \"f1.txt\");\n+        assertTrue(Files.isRegularFile(f1), f1 + \" is missing or not a file\");\n+        assertArrayEquals(FILE_CONTENT, Files.readAllBytes(f1), \"Unexpected content in file \" + f1);\n+        final Path f2 = Path.of(d3.toString(), \"f2.txt\");\n+        assertTrue(Files.isRegularFile(f2), f2 + \" is missing or not a file\");\n+        assertArrayEquals(FILE_CONTENT, Files.readAllBytes(f2), \"Unexpected content in file \" + f2);\n+    }\n+\n+    \/**\n+     * Creates a jar whose entries have a leading slash and the dot-dot character preserved.\n+     * This is the same as creating a jar using {@code jar -cfP somejar.jar <file1> <file2> ...}\n+     *\/\n+    private static Path createJarWithPFlagSemantics(String leadingSlashEntryName)\n+            throws IOException {\n+        final Path tmpDir = Files.createTempDirectory(Path.of(\".\"), \"8173970-\").toAbsolutePath();\n+        final Path jarPath = tmpDir.resolve(\"8173970-test-withpflag.jar\");\n+        final JarBuilder builder = new JarBuilder(jarPath.toString());\n+        builder.addEntry(\"d1\/\", new byte[0]);\n+        builder.addEntry(\"d1\/d2\/\", new byte[0]);\n+        builder.addEntry(leadingSlashEntryName, FILE_CONTENT);\n+        builder.addEntry(\"d1\/d2\/..\/f2.txt\", FILE_CONTENT);\n+        builder.build();\n+        return jarPath;\n+    }\n+\n+    private static void printJarCommand(final String[] cmdArgs) {\n+        System.out.println(\"Running 'jar \" + String.join(\" \", cmdArgs) + \"'\");\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/tools\/jar\/JarExtractTest.java","additions":517,"deletions":0,"binary":false,"changes":517,"status":"added"},{"patch":"@@ -0,0 +1,228 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8335912\n+ * @summary test extract jar with multpile manifest files\n+ * @library \/test\/lib\n+ * @modules jdk.jartool\n+ * @build jdk.test.lib.Platform\n+ *        jdk.test.lib.util.FileUtils\n+ * @run junit\/othervm MultipleManifestTest\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.api.TestInstance.Lifecycle;\n+\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.jar.Attributes;\n+import java.util.jar.JarFile;\n+import java.util.jar.Manifest;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipOutputStream;\n+\n+import jdk.test.lib.util.FileUtils;\n+\n+@TestInstance(Lifecycle.PER_CLASS)\n+class MultipleManifestTest {\n+    private static final ToolProvider JAR_TOOL = ToolProvider.findFirst(\"jar\")\n+        .orElseThrow(() ->\n+            new RuntimeException(\"jar tool not found\")\n+        );\n+\n+    private final String nl = System.lineSeparator();\n+    private final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    private final PrintStream jarOut = new PrintStream(baos);\n+\n+    static final Path zip = Path.of(\"MultipleManifestTest.jar\");\n+    static final String jdkVendor = System.getProperty(\"java.vendor\");\n+    static final String jdkVersion = System.getProperty(\"java.version\");\n+    static final String MANIFEST1 = \"Manifest-Version: 1.0\"\n+            + System.lineSeparator()\n+            + \"Created-By: \" + jdkVersion + \" (\" + jdkVendor + \")\";\n+    static final String MANIFEST2 = \"Manifest-Version: 2.0\"\n+            + System.lineSeparator()\n+            + \"Created-By: \" + jdkVersion + \" (\" + jdkVendor + \")\";\n+    static final String MANIFEST3 = \"Manifest-Version: 3.0\"\n+            + System.lineSeparator()\n+            + \"Created-By: \" + jdkVersion + \" (\" + jdkVendor + \")\";\n+    private static final String META_INF = \"META-INF\/\";\n+\n+    \/**\n+     * Delete the ZIP file produced by this test\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @AfterAll\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(zip);\n+    }\n+\n+    \/**\n+     * Create a JAR with the Manifest as the 1st, 2nd and 4th entry\n+     *\n+     * @throws IOException if an error occurs\n+     *\/\n+    @BeforeAll\n+    public void writeManifestAsFirstSecondAndFourthEntry() throws IOException {\n+        int locPosA, locPosB, cenPos;\n+        System.out.printf(\"%n%n*****Creating Jar with the Manifest as the 1st, 2nd and 4th entry*****%n%n\");\n+        var out = new ByteArrayOutputStream(1024);\n+        try (var zos = new ZipOutputStream(out)) {\n+            zos.putNextEntry(new ZipEntry(JarFile.MANIFEST_NAME));\n+            zos.write(MANIFEST1.getBytes(StandardCharsets.UTF_8));\n+            zos.closeEntry();\n+            locPosA = out.size();\n+            zos.putNextEntry(new ZipEntry(META_INF + \"AANIFEST.MF\"));\n+            zos.write(MANIFEST2.getBytes(StandardCharsets.UTF_8));\n+            zos.putNextEntry(new ZipEntry(\"entry1.txt\"));\n+            zos.write(\"entry1\".getBytes(StandardCharsets.UTF_8));\n+            zos.closeEntry();\n+            locPosB = out.size();\n+            zos.putNextEntry(new ZipEntry(META_INF + \"BANIFEST.MF\"));\n+            zos.write(MANIFEST3.getBytes(StandardCharsets.UTF_8));\n+            zos.putNextEntry(new ZipEntry(\"entry2.txt\"));\n+            zos.write(\"hello entry2\".getBytes(StandardCharsets.UTF_8));\n+            zos.flush();\n+            cenPos = out.size();\n+        }\n+        var template = out.toByteArray();\n+        \/\/ ISO_8859_1 to keep the 8-bit value\n+        var s = new String(template, StandardCharsets.ISO_8859_1);\n+        \/\/ change META-INF\/AANIFEST.MF to META-INF\/MANIFEST.MF\n+        var loc = s.indexOf(\"AANIFEST.MF\", locPosA);\n+        var cen = s.indexOf(\"AANIFEST.MF\", cenPos);\n+        template[loc] = template[cen] = (byte) 'M';\n+        \/\/ change META-INF\/BANIFEST.MF to META-INF\/MANIFEST.MF\n+        loc = s.indexOf(\"BANIFEST.MF\", locPosB);\n+        cen = s.indexOf(\"BANIFEST.MF\", cenPos);\n+        template[loc] = template[cen] = (byte) 'M';\n+        Files.write(zip, template);\n+    }\n+\n+    @AfterEach\n+    public void removeExtractedFiles() {\n+        rm(\"META-INF entry1.txt entry2.txt\");\n+    }\n+\n+    \/**\n+     * Extract by default should have the last manifest.\n+     *\/\n+    @Test\n+    public void testOverwrite() throws IOException {\n+        jar(\"xvf \" + zip.toString());\n+        println();\n+        Assertions.assertEquals(\"3.0\", getManifestVersion());\n+        String output = \" inflated: META-INF\/MANIFEST.MF\" + nl +\n+                \" inflated: META-INF\/MANIFEST.MF\" + nl +\n+                \" inflated: entry1.txt\" + nl +\n+                \" inflated: META-INF\/MANIFEST.MF\" + nl +\n+                \" inflated: entry2.txt\" + nl;\n+        assertOutputContains(output);\n+    }\n+\n+    \/**\n+     * Extract with k option should have first manifest.\n+     *\/\n+    @Test\n+    public void testKeptOldFile() throws IOException {\n+        jar(\"xkvf \" + zip.toString());\n+        println();\n+        Assertions.assertEquals(\"1.0\", getManifestVersion());\n+        String output = \" inflated: META-INF\/MANIFEST.MF\" + nl +\n+                \"  skipped: META-INF\/MANIFEST.MF exists\" + nl +\n+                \" inflated: entry1.txt\" + nl +\n+                \"  skipped: META-INF\/MANIFEST.MF exists\" + nl +\n+                \" inflated: entry2.txt\" + nl;\n+        assertOutputContains(output);\n+    }\n+\n+    private String getManifestVersion() throws IOException {\n+        try (var is = Files.newInputStream(Path.of(JarFile.MANIFEST_NAME))) {\n+            var manifest = new Manifest(is);\n+            return manifest.getMainAttributes().getValue(Attributes.Name.MANIFEST_VERSION);\n+        }\n+    }\n+\n+    private void jar(String cmdline) throws IOException {\n+        System.out.println(\"jar \" + cmdline);\n+        baos.reset();\n+\n+        \/\/ the run method catches IOExceptions, we need to expose them\n+        ByteArrayOutputStream baes = new ByteArrayOutputStream();\n+        PrintStream err = new PrintStream(baes);\n+        PrintStream saveErr = System.err;\n+        System.setErr(err);\n+        try {\n+            int rc = JAR_TOOL.run(jarOut, err, cmdline.split(\" +\"));\n+            if (rc != 0) {\n+                throw new IOException(baes.toString());\n+            }\n+        } finally {\n+            System.setErr(saveErr);\n+        }\n+    }\n+\n+    private void assertOutputContains(String expected) {\n+        Assertions.assertTrue(baos.toString().contains(expected));\n+    }\n+\n+    private void println() throws IOException {\n+        System.out.println(new String(baos.toByteArray()));\n+    }\n+\n+    private Stream<Path> mkpath(String... args) {\n+        return Arrays.stream(args).map(d -> Path.of(\".\", d.split(\"\/\")));\n+    }\n+\n+    private void rm(String cmdline) {\n+        System.out.println(\"rm -rf \" + cmdline);\n+        mkpath(cmdline.split(\" +\")).forEach(p -> {\n+            try {\n+                if (Files.isDirectory(p)) {\n+                    FileUtils.deleteFileTreeWithRetry(p);\n+                } else {\n+                    FileUtils.deleteFileIfExistsWithRetry(p);\n+                }\n+            } catch (IOException x) {\n+                throw new UncheckedIOException(x);\n+            }\n+        });\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/tools\/jar\/MultipleManifestTest.java","additions":228,"deletions":0,"binary":false,"changes":228,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -382,1 +382,1 @@\n-                    try (var pathStream = Files.walk(root, 0)) {\n+                    try (var pathStream = Files.list(root)) {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TKit.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,5 @@\n+ * @library \/test\/lib\n+ * @library base\n+ * @build SigningBase\n+ * @build SigningCheck\n+ * @build jtreg.SkippedException\n@@ -47,0 +52,5 @@\n+ * @library \/test\/lib\n+ * @library base\n+ * @build SigningBase\n+ * @build SigningCheck\n+ * @build jtreg.SkippedException\n@@ -72,1 +82,2 @@\n-                    \"Mutually exclusive options\"},\n+                    \"Mutually exclusive options\",\n+                    Boolean.FALSE},\n@@ -79,1 +90,2 @@\n-                    \"Mutually exclusive options\"},\n+                    \"Mutually exclusive options\",\n+                    Boolean.FALSE},\n@@ -85,1 +97,2 @@\n-                    \"Option [--mac-installer-sign-identity] is not valid with type\"},\n+                    \"Option [--mac-installer-sign-identity] is not valid with type\",\n+                    Boolean.FALSE},\n@@ -92,1 +105,2 @@\n-                    \"Option [--mac-installer-sign-identity] is not valid with type\"},\n+                    \"Option [--mac-installer-sign-identity] is not valid with type\",\n+                    Boolean.FALSE},\n@@ -107,1 +121,2 @@\n-                    \" was supplied via the \\\"--app-content\\\" parameter.\"},\n+                    \" was supplied via the \\\"--app-content\\\" parameter.\",\n+                    Boolean.TRUE},\n@@ -112,1 +127,2 @@\n-                              String[] removeArgs, String expectedError) {\n+                              String[] removeArgs, String expectedError,\n+                              Boolean checkRequirements) {\n@@ -115,0 +131,4 @@\n+        if (checkRequirements) {\n+            SigningCheck.isXcodeDevToolsInstalled();\n+        }\n+\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningOptionsTest.java","additions":26,"deletions":6,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.io.IOException;\n@@ -92,0 +93,8 @@\n+    public static void isXcodeDevToolsInstalled() {\n+        int code = Executor.of(\"\/usr\/bin\/xcrun\", \"--help\")\n+                .executeWithoutExitCodeCheck().getExitCode();\n+        if (code != 0) {\n+            TKit.throwSkippedException(\"Missing Xcode with command line developer tools\");\n+        }\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/base\/SigningCheck.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8342090 8288590\n+ * @summary Infer::IncorporationBinaryOp::equals can produce side-effects\n+ * @compile NonDeterminismTest.java\n+ * @compile -J-XX:+UnlockExperimentalVMOptions -J-XX:hashCode=2 NonDeterminismTest.java\n+ *\/\n+\n+import java.util.*;\n+import java.lang.foreign.*;\n+import static java.lang.foreign.ValueLayout.*;\n+\n+import static java.util.Arrays.asList;\n+\n+class NonDeterminismTest {\n+    void test1() {\n+        Map<String, MemoryLayout> CANONICAL_LAYOUTS = Map.ofEntries(\n+                \/\/ specified canonical layouts\n+                Map.entry(\"bool\", JAVA_BOOLEAN),\n+                Map.entry(\"char\", JAVA_BYTE),\n+                Map.entry(\"float\", JAVA_FLOAT),\n+                Map.entry(\"long long\", JAVA_LONG),\n+                Map.entry(\"double\", JAVA_DOUBLE),\n+                Map.entry(\"void*\", ADDRESS),\n+                \/\/ JNI types\n+                Map.entry(\"jboolean\", JAVA_BOOLEAN),\n+                Map.entry(\"jchar\", JAVA_CHAR),\n+                Map.entry(\"jbyte\", JAVA_BYTE),\n+                Map.entry(\"jshort\", JAVA_SHORT),\n+                Map.entry(\"jint\", JAVA_INT),\n+                Map.entry(\"jlong\", JAVA_LONG),\n+                Map.entry(\"jfloat\", JAVA_FLOAT),\n+                Map.entry(\"jdouble\", JAVA_DOUBLE)\n+        );\n+    }\n+\n+    class Test2 {\n+        interface I1<T1> {}\n+        interface I2<T1, T2> {}\n+\n+        record R1<T1>(List<T1> T1) implements I1<T1> {}\n+        record R2<T1, T2>(List<T1> T1, List<T2> T2) implements I2<T1, T2> {}\n+\n+        <T1> I1<T1> m1(T1 T1) {\n+            return new R1<>(asList(T1));\n+        }\n+        <T1, T2> I2<T1, T2> m2(T1 T1, T2 T2) {\n+            return new R2<>(asList(T1), asList(T2));\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/inference_non_determinism\/NonDeterminismTest.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -31,1 +31,1 @@\n- * @bug 8262891 8268333 8268896 8269802 8269808 8270151 8269113 8277864 8290709\n+ * @bug 8262891 8268333 8268896 8269802 8269808 8270151 8269113 8277864 8290709 8339296\n@@ -120,0 +120,3 @@\n+        assertEquals(0, nestedSwitchesInArgumentPosition(1));\n+        assertEquals(1, nestedSwitchesInArgumentPosition(new R(1)));\n+        assertEquals(5, nestedSwitchesInArgumentPosition(new R(new R(\"hello\"))));\n@@ -752,0 +755,18 @@\n+    int nestedSwitchesInArgumentPosition(Object o1) {\n+        return id(switch (o1) {\n+            case R(var o2) -> switch (o2) {\n+                case R(String s) -> s;\n+                default -> \"n\";\n+            };\n+            default -> \"\";\n+        });\n+    }\n+\n+    int id(String s) {\n+        return s.length();\n+    }\n+\n+    int id(int i) {\n+        return i;\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Switches.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8284220\n+ * @bug 8284220 8342934\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/type\/AnnotatedTypeToString\/AnnotatedTypeToString.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,4 @@\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.TYPE_USE)\n+@interface B {}\n+\n@@ -44,2 +48,2 @@\n-    @ExpectedToString(\"p.Test.@p.A StaticNested\")\n-    @A StaticNested i;\n+    @ExpectedToString(\"p.Test.@p.A @p.B StaticNested\")\n+    @A @B StaticNested i;\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/type\/AnnotatedTypeToString\/Test.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8339296\n+ * @summary Verify that the UnknownType behaves as an erroneous type\n+ * @library \/tools\/lib\/types\n+ * @modules jdk.compiler\/com.sun.tools.javac.code\n+ *          jdk.compiler\/com.sun.tools.javac.comp\n+ *          jdk.compiler\/com.sun.tools.javac.file\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.tree\n+ * @build TypeHarness\n+ * @run main UnknownTypeTest\n+ *\/\n+\n+import com.sun.tools.javac.code.Type;\n+import com.sun.tools.javac.code.Symtab;\n+import com.sun.tools.javac.code.Type.TypeVar;\n+import com.sun.tools.javac.code.Type.UnionClassType;\n+import com.sun.tools.javac.util.List;\n+import java.util.Objects;\n+\n+public class UnknownTypeTest extends TypeHarness {\n+\n+    private final Type error;\n+    private final Type unknown;\n+    private final Type[] testTypes;\n+    private final Operation[] testOperations;\n+\n+    UnknownTypeTest() {\n+        Symtab syms = Symtab.instance(context);\n+        error = syms.errType;\n+        unknown = syms.unknownType;\n+        testTypes = new Type[] {\n+            syms.objectType,\n+            syms.errType,\n+            syms.unknownType,\n+            new TypeVar(syms.unknownSymbol, syms.objectType, syms.objectType),\n+            types.makeIntersectionType(List.of(syms.annotationType, syms.stringType)),\n+            new UnionClassType((Type.ClassType) syms.annotationType, List.of(syms.stringType)),\n+            syms.intType,\n+            types.makeArrayType(syms.stringType)\n+        };\n+        testOperations = new Operation[] {\n+            types::containedBy,\n+            types::containsType,\n+            types::isAssignable,\n+            types::isCastable,\n+            types::isConvertible,\n+            types::isSameType,\n+            types::isSubtype,\n+            types::isSuperType,\n+            types::isUnconditionallyExact,\n+            (t1, _) -> types.isArray(t1),\n+            (t1, _) -> types.isDerivedRaw(t1),\n+            (t1, _) -> types.isReifiable(t1),\n+            (t1, _) -> types.isUnbounded(t1),\n+            (t1, _) -> types.boxedTypeOrType(t1),\n+            (t1, _) -> types.unboxedType(t1),\n+            (t1, _) -> types.unboxedTypeOrType(t1),\n+        };\n+    }\n+\n+    void test(Type[] testTypes, Operation[] testOperations) {\n+        for (int typeIndex = 0; typeIndex < testTypes.length ; typeIndex++) {\n+            for (int operationIndex = 0; operationIndex < testOperations.length ; operationIndex++) {\n+                Object expected;\n+                Object actual;\n+                expected = testOperations[operationIndex].run(error, testTypes[typeIndex]);\n+                actual = testOperations[operationIndex].run(unknown, testTypes[typeIndex]);\n+                checkEquals(\"Type index: \" + typeIndex + \", operationIndex: \" + operationIndex + \", unknown in the first position\", expected, actual);\n+                expected = testOperations[operationIndex].run(testTypes[typeIndex], error);\n+                actual = testOperations[operationIndex].run(testTypes[typeIndex], unknown);\n+                checkEquals(\"Type index: \" + typeIndex + \", operationIndex: \" + operationIndex + \", unknown in the second position\", expected, actual);\n+            }\n+        }\n+    }\n+\n+    void checkEquals(String message, Object expected, Object actual) {\n+        boolean matches;\n+\n+        if (expected instanceof Type t1 && actual instanceof Type t2) {\n+            matches = types.isSameType(t1, t2);\n+        } else {\n+            matches = Objects.equals(expected, actual);\n+        }\n+\n+        if (!matches) {\n+            throw new AssertionError(\"Unexpected outcome: \" + actual +\n+                                     \", expected: \" + expected +\n+                                     \", for test: \" + message);\n+        }\n+    }\n+\n+    void runTests() {\n+        test(testTypes, testOperations);\n+    }\n+\n+    public static void main(String[] args) {\n+        new UnknownTypeTest().runTests();\n+    }\n+\n+    interface Operation {\n+        public Object run(Type t1, Type t2);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/types\/UnknownTypeTest.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.math;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.math.BigInteger;\n+import java.math.BigDecimal;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 3)\n+public class BigDecimalStripTrailingZeros {\n+\n+    private BigDecimal xsPow, sPow, mPow, lPow, xlPow;\n+\n+    @Setup\n+    public void setup() {\n+        xsPow = new BigDecimal(BigInteger.TEN.pow(1 << 4));\n+        sPow = new BigDecimal(BigInteger.TEN.pow(1 << 5));\n+        mPow = new BigDecimal(BigInteger.TEN.pow(1 << 10));\n+        lPow = new BigDecimal(BigInteger.TEN.pow(1 << 15));\n+        xlPow = new BigDecimal(BigInteger.TEN.pow(1 << 20));\n+    }\n+\n+    \/** Test BigDecimal.stripTrailingZeros() with 10^16  *\/\n+    @Benchmark\n+    @OperationsPerInvocation(1)\n+    public void testXS(Blackhole bh) {\n+        bh.consume(xsPow.stripTrailingZeros());\n+    }\n+\n+    \/** Test BigDecimal.stripTrailingZeros() with 10^32 *\/\n+    @Benchmark\n+    @OperationsPerInvocation(1)\n+    public void testS(Blackhole bh) {\n+        bh.consume(sPow.stripTrailingZeros());\n+    }\n+\n+    \/** Test BigDecimal.stripTrailingZeros() with 10^1024 *\/\n+    @Benchmark\n+    @OperationsPerInvocation(1)\n+    public void testM(Blackhole bh) {\n+        bh.consume(mPow.stripTrailingZeros());\n+    }\n+\n+    \/** Test BigDecimal.stripTrailingZeros() with 10^32_768 *\/\n+    @Benchmark\n+    @OperationsPerInvocation(1)\n+    public void testL(Blackhole bh) {\n+        bh.consume(lPow.stripTrailingZeros());\n+    }\n+\n+    \/** Test BigDecimal.stripTrailingZeros() with 10^1_048_576 *\/\n+    @Benchmark\n+    @OperationsPerInvocation(1)\n+    public void testXL(Blackhole bh) {\n+        bh.consume(xlPow.stripTrailingZeros());\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigDecimalStripTrailingZeros.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.javax.tools;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import javax.tools.JavaCompiler;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.tools.StandardJavaFileManager;\n+import javax.tools.StandardLocation;\n+import javax.tools.ToolProvider;\n+import java.io.IOException;\n+import java.io.File;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 3, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 2, jvmArgs = \"-Xmx1g\")\n+public class JavacNameTable {\n+\n+    private List<JavaSourceFromString> compilationUnits;\n+    private JavaCompiler compiler;\n+    private StandardJavaFileManager fileManager;\n+    private File classDir;\n+\n+    @Setup\n+    public void prepare() throws IOException {\n+\n+        \/\/ Create a source file with lots of names\n+        StringBuilder buf = new StringBuilder();\n+        buf.append(\"class BigSource {\\n\");\n+        for (int i = 0; i < 20000; i++) {\n+            buf.append(String.format(\n+                \/\/\"final String name%05d = \\\"some text #%5d\\\";\\n\", i, i));\n+                \"String name%05d;\\n\", i, i));\n+        }\n+        buf.append(\"}\\n\");\n+        String bigSource = buf.toString();\n+\n+        compiler = ToolProvider.getSystemJavaCompiler();\n+\n+        fileManager = compiler.getStandardFileManager(null, null, null);\n+        classDir = Files.createTempDirectory(\n+          JavacNameTable.class.getName()).toFile();\n+        fileManager.setLocation(StandardLocation.CLASS_OUTPUT,\n+          Collections.singleton(classDir));\n+\n+        compilationUnits = new ArrayList<>();\n+        compilationUnits.add(new JavaSourceFromString(\"BigSource\", bigSource));\n+    }\n+\n+    @TearDown\n+    public void tearDown() {\n+        for (File f : classDir.listFiles()) {\n+            if (f.isFile()) {\n+                f.delete();\n+            } else {\n+                throw new IllegalStateException(\"Unexpected non-file: \" + f);\n+            }\n+        }\n+        classDir.delete();\n+    }\n+\n+    @Benchmark\n+    public Boolean testSharedTable() throws Exception {\n+        return testCompile(null);\n+    }\n+\n+    @Benchmark\n+    public Boolean testUnsharedTable() throws Exception {\n+        return testCompile(\"-XDuseUnsharedTable=true\");\n+    }\n+\n+    @Benchmark\n+    public Boolean testStringTable() throws Exception {\n+        return testCompile(\"-XDuseStringTable=true\");\n+    }\n+\n+    @Benchmark\n+    public Boolean testInternStringTable() throws Exception {\n+        return testCompile(\"-XDinternStringTable=true\");\n+    }\n+\n+    public Boolean testCompile(String flag) throws Exception {\n+        final List<String> options = flag != null ?\n+          Collections.singletonList(flag) : null;\n+        JavaCompiler.CompilationTask task = compiler.getTask(null, fileManager,\n+          null, options, null, compilationUnits);\n+        return task.call();\n+    }\n+\n+    private static class JavaSourceFromString extends SimpleJavaFileObject {\n+\n+        private final String code;\n+\n+        JavaSourceFromString(String name, String code) {\n+            super(URI.create(\"string:\/\/\/\"\n+              + name.replace('.', '\/') + Kind.SOURCE.extension), Kind.SOURCE);\n+            this.code = code;\n+        }\n+\n+        @Override\n+        public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n+            return code;\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/tools\/JavacNameTable.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"}]}