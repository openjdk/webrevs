{"files":[{"patch":"@@ -891,0 +891,6 @@\n+  \/\/ Short-cut calculation if the heap size is fixed (MinHeapSize == MaxHeapSize) and\n+  \/\/ cannot expand or shrink.\n+  if (is_fixed_size_heap()) {\n+    log_debug(gc, ergo, heap)(\"Skip heap resize after full collection.\");\n+    return;\n+  }\n@@ -901,0 +907,7 @@\n+  \/\/ Short-cut calculation if the heap size is fixed (MinHeapSize == MaxHeapSize) and\n+  \/\/ cannot expand or shrink.\n+  if (is_fixed_size_heap()) {\n+    log_trace(gc, ergo, heap)(\"Skip heap resize after young collection.\");\n+    return;\n+  }\n+\n@@ -1215,1 +1228,2 @@\n-  _region_attr() {\n+  _region_attr(),\n+  _fixed_size_heap(MaxHeapSize == MinHeapSize) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -572,0 +572,1 @@\n+  inline bool is_fixed_size_heap() const;\n@@ -1058,0 +1059,4 @@\n+  \/\/ True if the heap size is fixed (MinHeapSize == MaxHeapSize) and\n+  \/\/ thus cannot expand or shrink.\n+  bool _fixed_size_heap;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -323,0 +323,3 @@\n+inline bool G1CollectedHeap::is_fixed_size_heap() const {\n+  return _fixed_size_heap;\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8367754\n+ * @summary Verify fast path before performing heap resize.\n+ * @requires vm.gc.G1\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver gc.g1.TestHeapResizeAfterGC\n+ *\/\n+\n+package gc.g1;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.whitebox.WhiteBox;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class TestHeapResizeAfterGC {\n+\n+  private static OutputAnalyzer run(String maxHeap, String minHeap, String regionSize) throws Exception {\n+    return ProcessTools.executeLimitedTestJava(\n+      \"-XX:+UnlockDiagnosticVMOptions\",\n+      \"-XX:+WhiteBoxAPI\",\n+      \"-Xbootclasspath\/a:.\",\n+      \"-Xmx\" + maxHeap,\n+      \"-Xms\" + minHeap,\n+      \"-XX:G1HeapRegionSize=\" + regionSize,\n+      \"-XX:+UseG1GC\",\n+      \"-XX:MaxTenuringThreshold=1\",\n+      \"-XX:MinHeapFreeRatio=65\",\n+      \"-Xlog:gc+ergo+heap=trace\",\n+      TestHeapResizeAfterGC.Action.class.getName());\n+    }\n+\n+  public static void main(String args[]) throws Exception {\n+    String resizeLogAfterYoungGC = \"Heap resize triggers\";\n+    String resizeLogAfterFullGC = \"Heap resize. Attempt heap\";\n+    String skipResizeLogAfterYoungGC = \"Skip heap resize after young\";\n+    String skipResizeLogAfterFullGC = \"Skip heap resize after full\";\n+\n+    \/\/ Normal path.\n+    OutputAnalyzer out = run(\"120M\",\"50M\",\"1M\");\n+    out.shouldHaveExitValue(0);\n+    out.shouldNotContain(skipResizeLogAfterYoungGC);\n+    out.shouldNotContain(skipResizeLogAfterFullGC);\n+    out.shouldContain(resizeLogAfterYoungGC);\n+    out.shouldContain(resizeLogAfterFullGC);\n+\n+    \/\/ Fast path, MaxHeapSize(103M) and MinHeapSize(101M) will be equal\n+    \/\/ after alignment.\n+    out = run(\"103M\",\"101M\",\"4M\");\n+    out.shouldHaveExitValue(0);\n+    out.shouldContain(skipResizeLogAfterYoungGC);\n+    out.shouldContain(skipResizeLogAfterFullGC);\n+    out.shouldNotContain(resizeLogAfterYoungGC);\n+    out.shouldNotContain(resizeLogAfterFullGC);\n+  }\n+\n+  public static class Action {\n+    private static final WhiteBox wb = WhiteBox.getWhiteBox();\n+    private static final int OBJECT_SIZE = 1024;\n+    private static final int NUM_OBJECTS = 20_000;\n+    public static void main(String [] args) throws Exception {\n+      \/\/ Remove garbage from VM initialization.\n+      wb.fullGC();\n+      List<byte[]> objectList = new ArrayList<>();\n+      for (int i = 0; i < NUM_OBJECTS; i++) {\n+        byte[] obj = new byte[OBJECT_SIZE];\n+        objectList.add(obj);\n+      }\n+      wb.youngGC();\n+      wb.fullGC();\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestHeapResizeAfterGC.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"}]}