{"files":[{"patch":"@@ -49,0 +49,1 @@\n+#include \"gc\/shared\/arraySlicer.hpp\"\n@@ -89,1 +90,1 @@\n-typedef OverflowTaskQueue<ScannerTask, mtGC>           G1ScannerTasksQueue;\n+typedef OverflowTaskQueue<ArraySliceTask, mtGC>        G1ScannerTasksQueue;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-  _task->scan_task_entry(G1TaskQueueEntry::from_oop(cast_to_oop(addr)));\n+  _task->scan_task_entry(ArraySliceTask(cast_to_oop(addr)));\n@@ -117,1 +117,1 @@\n-  return (size_t)lcm(os::vm_allocation_granularity(), sizeof(TaskQueueEntryChunk)) \/ sizeof(G1TaskQueueEntry);\n+  return (size_t)lcm(os::vm_allocation_granularity(), sizeof(TaskQueueEntryChunk)) \/ sizeof(ArraySliceTask);\n@@ -126,1 +126,1 @@\n-  size_t const TaskEntryChunkSizeInVoidStar = sizeof(TaskQueueEntryChunk) \/ sizeof(G1TaskQueueEntry);\n+  size_t const TaskEntryChunkSizeInVoidStar = sizeof(TaskQueueEntryChunk) \/ sizeof(ArraySliceTask);\n@@ -328,1 +328,1 @@\n-bool G1CMMarkStack::par_push_chunk(G1TaskQueueEntry* ptr_arr) {\n+bool G1CMMarkStack::par_push_chunk(ArraySliceTask* ptr_arr) {\n@@ -341,1 +341,1 @@\n-  Copy::conjoint_memory_atomic(ptr_arr, new_chunk->data, EntriesPerChunk * sizeof(G1TaskQueueEntry));\n+  Copy::conjoint_memory_atomic(ptr_arr, new_chunk->data, EntriesPerChunk * sizeof(ArraySliceTask));\n@@ -348,1 +348,1 @@\n-bool G1CMMarkStack::par_pop_chunk(G1TaskQueueEntry* ptr_arr) {\n+bool G1CMMarkStack::par_pop_chunk(ArraySliceTask* ptr_arr) {\n@@ -355,1 +355,1 @@\n-  Copy::conjoint_memory_atomic(cur->data, ptr_arr, EntriesPerChunk * sizeof(G1TaskQueueEntry));\n+  Copy::conjoint_memory_atomic(cur->data, ptr_arr, EntriesPerChunk * sizeof(ArraySliceTask));\n@@ -1968,1 +1968,1 @@\n-  void operator()(G1TaskQueueEntry task_entry) const {\n+  void operator()(ArraySliceTask task_entry) const {\n@@ -1970,1 +1970,1 @@\n-      guarantee(_g1h->is_in_reserved(task_entry.slice()), \"Slice \" PTR_FORMAT \" must be in heap.\", p2i(task_entry.slice()));\n+      guarantee(_g1h->is_in_reserved(task_entry.to_oop()), \"Slice \" PTR_FORMAT \" must be in heap.\", p2i(task_entry.to_oop()));\n@@ -1973,1 +1973,1 @@\n-    guarantee(oopDesc::is_oop(task_entry.obj()),\n+    guarantee(oopDesc::is_oop(task_entry.to_oop()),\n@@ -1975,2 +1975,2 @@\n-              p2i(task_entry.obj()), _phase, _info);\n-    G1HeapRegion* r = _g1h->heap_region_containing(task_entry.obj());\n+              p2i(task_entry.to_oop()), _phase, _info);\n+    G1HeapRegion* r = _g1h->heap_region_containing(task_entry.to_oop());\n@@ -1979,1 +1979,1 @@\n-              p2i(task_entry.obj()), _phase, _info, r->hrm_index());\n+              p2i(task_entry.to_oop()), _phase, _info, r->hrm_index());\n@@ -2312,1 +2312,1 @@\n-  G1TaskQueueEntry buffer[G1CMMarkStack::EntriesPerChunk];\n+  ArraySliceTask buffer[G1CMMarkStack::EntriesPerChunk];\n@@ -2315,1 +2315,1 @@\n-  G1TaskQueueEntry task_entry;\n+  ArraySliceTask task_entry;\n@@ -2321,1 +2321,1 @@\n-    buffer[n] = G1TaskQueueEntry();\n+    buffer[n] = ArraySliceTask();\n@@ -2337,1 +2337,1 @@\n-  G1TaskQueueEntry buffer[G1CMMarkStack::EntriesPerChunk];\n+  ArraySliceTask buffer[G1CMMarkStack::EntriesPerChunk];\n@@ -2345,1 +2345,1 @@\n-    G1TaskQueueEntry task_entry = buffer[i];\n+    ArraySliceTask task_entry = buffer[i];\n@@ -2349,1 +2349,1 @@\n-    assert(task_entry.is_array_slice() || oopDesc::is_oop(task_entry.obj()), \"Element \" PTR_FORMAT \" must be an array slice or oop\", p2i(task_entry.obj()));\n+    assert(task_entry.is_array_slice() || oopDesc::is_oop(task_entry.to_oop()), \"Element \" PTR_FORMAT \" must be an array slice or oop\", p2i(task_entry.to_oop()));\n@@ -2377,1 +2377,1 @@\n-    G1TaskQueueEntry entry;\n+    ArraySliceTask entry;\n@@ -2482,1 +2482,1 @@\n-bool G1ConcurrentMark::try_stealing(uint worker_id, G1TaskQueueEntry& task_entry) {\n+bool G1ConcurrentMark::try_stealing(uint worker_id, ArraySliceTask& task_entry) {\n@@ -2789,1 +2789,1 @@\n-      G1TaskQueueEntry entry;\n+      ArraySliceTask entry;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/shared\/arraySlicer.hpp\"\n@@ -54,36 +55,1 @@\n-\/\/ This is a container class for either an oop or a continuation address for\n-\/\/ mark stack entries. Both are pushed onto the mark stack.\n-class G1TaskQueueEntry {\n-private:\n-  void* _holder;\n-\n-  static const uintptr_t ArraySliceBit = 1;\n-\n-  G1TaskQueueEntry(oop obj) : _holder(obj) {\n-    assert(_holder != nullptr, \"Not allowed to set null task queue element\");\n-  }\n-  G1TaskQueueEntry(HeapWord* addr) : _holder((void*)((uintptr_t)addr | ArraySliceBit)) { }\n-public:\n-\n-  G1TaskQueueEntry() : _holder(nullptr) { }\n-  \/\/ Trivially copyable, for use in GenericTaskQueue.\n-\n-  static G1TaskQueueEntry from_slice(HeapWord* what) { return G1TaskQueueEntry(what); }\n-  static G1TaskQueueEntry from_oop(oop obj) { return G1TaskQueueEntry(obj); }\n-\n-  oop obj() const {\n-    assert(!is_array_slice(), \"Trying to read array slice \" PTR_FORMAT \" as oop\", p2i(_holder));\n-    return cast_to_oop(_holder);\n-  }\n-\n-  HeapWord* slice() const {\n-    assert(is_array_slice(), \"Trying to read oop \" PTR_FORMAT \" as array slice\", p2i(_holder));\n-    return (HeapWord*)((uintptr_t)_holder & ~ArraySliceBit);\n-  }\n-\n-  bool is_oop() const { return !is_array_slice(); }\n-  bool is_array_slice() const { return ((uintptr_t)_holder & ArraySliceBit) != 0; }\n-  bool is_null() const { return _holder == nullptr; }\n-};\n-\n-typedef GenericTaskQueue<G1TaskQueueEntry, mtGC> G1CMTaskQueue;\n+typedef GenericTaskQueue<ArraySliceTask, mtGC>   G1CMTaskQueue;\n@@ -140,1 +106,2 @@\n-    G1TaskQueueEntry data[EntriesPerChunk];\n+    NOT_LP64(void* dummy;) \/\/ To make things align.\n+    ArraySliceTask data[EntriesPerChunk];\n@@ -275,1 +242,1 @@\n-  bool par_push_chunk(G1TaskQueueEntry* buffer);\n+  bool par_push_chunk(ArraySliceTask* buffer);\n@@ -280,1 +247,1 @@\n-  bool par_pop_chunk(G1TaskQueueEntry* buffer);\n+  bool par_pop_chunk(ArraySliceTask* buffer);\n@@ -589,1 +556,1 @@\n-  bool mark_stack_push(G1TaskQueueEntry* arr) {\n+  bool mark_stack_push(ArraySliceTask* arr) {\n@@ -596,1 +563,1 @@\n-  bool mark_stack_pop(G1TaskQueueEntry* arr) {\n+  bool mark_stack_pop(ArraySliceTask* arr) {\n@@ -625,1 +592,1 @@\n-  bool try_stealing(uint worker_id, G1TaskQueueEntry& task_entry);\n+  bool try_stealing(uint worker_id, ArraySliceTask& task_entry);\n@@ -842,1 +809,1 @@\n-  template<bool scan> void process_grey_task_entry(G1TaskQueueEntry task_entry);\n+  template<bool scan> void process_grey_task_entry(ArraySliceTask task_entry);\n@@ -844,0 +811,2 @@\n+  \/\/ Apply the closure on the objArray metadata.\n+  inline void scan_objArray_start(objArrayOop obj);\n@@ -846,1 +815,1 @@\n-  inline size_t scan_objArray(objArrayOop obj, MemRegion mr);\n+  inline size_t scan_objArray(objArrayOop obj, int start, int end);\n@@ -904,1 +873,1 @@\n-  inline void scan_task_entry(G1TaskQueueEntry task_entry);\n+  inline void scan_task_entry(ArraySliceTask task_entry);\n@@ -907,1 +876,1 @@\n-  inline void push(G1TaskQueueEntry task_entry);\n+  inline void push(ArraySliceTask task_entry);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":15,"deletions":46,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"gc\/g1\/g1ConcurrentMarkObjArrayProcessor.inline.hpp\"\n@@ -110,1 +109,1 @@\n-inline void G1CMTask::scan_task_entry(G1TaskQueueEntry task_entry) { process_grey_task_entry<true>(task_entry); }\n+inline void G1CMTask::scan_task_entry(ArraySliceTask task_entry) { process_grey_task_entry<true>(task_entry); }\n@@ -112,2 +111,2 @@\n-inline void G1CMTask::push(G1TaskQueueEntry task_entry) {\n-  assert(task_entry.is_array_slice() || _g1h->is_in_reserved(task_entry.obj()), \"invariant\");\n+inline void G1CMTask::push(ArraySliceTask task_entry) {\n+  assert(task_entry.is_array_slice() || _g1h->is_in_reserved(task_entry.to_oop()), \"invariant\");\n@@ -115,2 +114,2 @@\n-              _g1h->heap_region_containing(task_entry.obj())), \"invariant\");\n-  assert(task_entry.is_array_slice() || _mark_bitmap->is_marked(cast_from_oop<HeapWord*>(task_entry.obj())), \"invariant\");\n+              _g1h->heap_region_containing(task_entry.to_oop())), \"invariant\");\n+  assert(task_entry.is_array_slice() || _mark_bitmap->is_marked(cast_from_oop<HeapWord*>(task_entry.to_oop())), \"invariant\");\n@@ -162,3 +161,3 @@\n-inline void G1CMTask::process_grey_task_entry(G1TaskQueueEntry task_entry) {\n-  assert(scan || (task_entry.is_oop() && task_entry.obj()->is_typeArray()), \"Skipping scan of grey non-typeArray\");\n-  assert(task_entry.is_array_slice() || _mark_bitmap->is_marked(cast_from_oop<HeapWord*>(task_entry.obj())),\n+inline void G1CMTask::process_grey_task_entry(ArraySliceTask task_entry) {\n+  assert(scan || (task_entry.is_oop() && task_entry.to_oop()->is_typeArray()), \"Skipping scan of grey non-typeArray\");\n+  assert(task_entry.is_array_slice() || _mark_bitmap->is_marked(cast_from_oop<HeapWord*>(task_entry.to_oop())),\n@@ -168,0 +167,1 @@\n+    oop obj = task_entry.to_oop();\n@@ -169,1 +169,1 @@\n-      _words_scanned += _objArray_processor.process_slice(task_entry.slice());\n+      _words_scanned += _objArray_processor.process_slice(objArrayOop(obj), task_entry.slice(), task_entry.pow());\n@@ -171,3 +171,2 @@\n-      oop obj = task_entry.obj();\n-      if (G1CMObjArrayProcessor::should_be_sliced(obj)) {\n-        _words_scanned += _objArray_processor.process_obj(obj);\n+      if (obj->is_objArray()) {\n+        _words_scanned += _objArray_processor.process_objArray(objArrayOop(obj));\n@@ -182,3 +181,9 @@\n-inline size_t G1CMTask::scan_objArray(objArrayOop obj, MemRegion mr) {\n-  obj->oop_iterate(_cm_oop_closure, mr);\n-  return mr.word_size();\n+inline void G1CMTask::scan_objArray_start(objArrayOop obj) {\n+  if (Devirtualizer::do_metadata(_cm_oop_closure)) {\n+    Devirtualizer::do_klass(_cm_oop_closure, obj->klass());\n+  }\n+}\n+\n+inline size_t G1CMTask::scan_objArray(objArrayOop obj, int start, int end) {\n+  obj->oop_iterate_range(_cm_oop_closure, start, end);\n+  return (end - start) * (UseCompressedOops ? 2 : 1);\n@@ -264,1 +269,1 @@\n-    G1TaskQueueEntry entry = G1TaskQueueEntry::from_oop(obj);\n+    ArraySliceTask entry(obj);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.inline.hpp","additions":22,"deletions":17,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n+#include \"gc\/g1\/g1ConcurrentMarkObjArrayProcessor.hpp\"\n@@ -28,5 +28,1 @@\n-#include \"gc\/g1\/g1ConcurrentMarkObjArrayProcessor.inline.hpp\"\n-#include \"gc\/g1\/g1HeapRegion.inline.hpp\"\n-#include \"gc\/shared\/gc_globals.hpp\"\n-#include \"memory\/memRegion.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n@@ -34,2 +30,2 @@\n-void G1CMObjArrayProcessor::push_array_slice(HeapWord* what) {\n-  _task->push(G1TaskQueueEntry::from_slice(what));\n+void G1CMObjArrayProcessor::scan_metadata(objArrayOop array) {\n+  _task->scan_objArray_start(array);\n@@ -37,11 +33,2 @@\n-\n-size_t G1CMObjArrayProcessor::process_array_slice(objArrayOop obj, HeapWord* start_from, size_t remaining) {\n-  size_t words_to_scan = MIN2(remaining, (size_t)ObjArrayMarkingStride);\n-\n-  if (remaining > ObjArrayMarkingStride) {\n-    push_array_slice(start_from + ObjArrayMarkingStride);\n-  }\n-\n-  \/\/ Then process current area.\n-  MemRegion mr(start_from, words_to_scan);\n-  return _task->scan_objArray(obj, mr);\n+void G1CMObjArrayProcessor::push_on_queue(ArraySliceTask task) {\n+  _task->push(task);\n@@ -49,32 +36,2 @@\n-\n-size_t G1CMObjArrayProcessor::process_obj(oop obj) {\n-  assert(should_be_sliced(obj), \"Must be an array object %d and large \" SIZE_FORMAT, obj->is_objArray(), obj->size());\n-\n-  return process_array_slice(objArrayOop(obj), cast_from_oop<HeapWord*>(obj), objArrayOop(obj)->size());\n-}\n-\n-size_t G1CMObjArrayProcessor::process_slice(HeapWord* slice) {\n-\n-  \/\/ Find the start address of the objArrayOop.\n-  \/\/ Shortcut the BOT access if the given address is from a humongous object. The BOT\n-  \/\/ slide is fast enough for \"smaller\" objects in non-humongous regions, but is slower\n-  \/\/ than directly using heap region table.\n-  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n-  G1HeapRegion* r = g1h->heap_region_containing(slice);\n-\n-  HeapWord* const start_address = r->is_humongous() ?\n-                                  r->humongous_start_region()->bottom() :\n-                                  r->block_start(slice);\n-\n-  assert(cast_to_oop(start_address)->is_objArray(), \"Address \" PTR_FORMAT \" does not refer to an object array \", p2i(start_address));\n-  assert(start_address < slice,\n-         \"Object start address \" PTR_FORMAT \" must be smaller than decoded address \" PTR_FORMAT,\n-         p2i(start_address),\n-         p2i(slice));\n-\n-  objArrayOop objArray = objArrayOop(cast_to_oop(start_address));\n-\n-  size_t already_scanned = pointer_delta(slice, start_address);\n-  size_t remaining = objArray->size() - already_scanned;\n-\n-  return process_array_slice(objArray, slice, remaining);\n+size_t G1CMObjArrayProcessor::scan_array(objArrayOop array, int start, int end) {\n+  return _task->scan_objArray(array, start, end);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkObjArrayProcessor.cpp","additions":8,"deletions":51,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"gc\/shared\/arraySlicer.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -32,5 +34,1 @@\n-\/\/ Helper class to mark through large objArrays during marking in an efficient way.\n-\/\/ Instead of pushing large object arrays, we push continuations onto the\n-\/\/ mark stack. These continuations are identified by having their LSB set.\n-\/\/ This allows incremental processing of large objects.\n-class G1CMObjArrayProcessor {\n+class G1CMObjArrayProcessor : public ArraySlicer {\n@@ -41,5 +39,0 @@\n-  \/\/ Push the continuation at the given address onto the mark stack.\n-  void push_array_slice(HeapWord* addr);\n-\n-  \/\/ Process (apply the closure) on the given continuation of the given objArray.\n-  size_t process_array_slice(objArrayOop const obj, HeapWord* start_from, size_t remaining);\n@@ -47,3 +40,3 @@\n-  static bool should_be_sliced(oop obj);\n-\n-  G1CMObjArrayProcessor(G1CMTask* task) : _task(task) {\n+  explicit G1CMObjArrayProcessor(G1CMTask* task) :\n+    ArraySlicer((int)ObjArrayMarkingStride, (int)(2 * ObjArrayMarkingStride)),\n+    _task(task) {\n@@ -51,6 +44,3 @@\n-\n-  \/\/ Process the given continuation. Returns the number of words scanned.\n-  size_t process_slice(HeapWord* slice);\n-  \/\/ Start processing the given objArrayOop by scanning the header and pushing its\n-  \/\/ continuation.\n-  size_t process_obj(oop obj);\n+  void scan_metadata(objArrayOop array) override;\n+  void push_on_queue(ArraySliceTask task) override;\n+  size_t scan_array(objArrayOop array, int from, int len) override;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkObjArrayProcessor.hpp","additions":9,"deletions":19,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_G1CONCURRENTMARKOBJARRAYPROCESSOR_INLINE_HPP\n-#define SHARE_GC_G1_G1CONCURRENTMARKOBJARRAYPROCESSOR_INLINE_HPP\n-\n-#include \"gc\/g1\/g1ConcurrentMarkObjArrayProcessor.hpp\"\n-\n-#include \"oops\/oop.inline.hpp\"\n-#include \"oops\/oopsHierarchy.hpp\"\n-#include \"gc\/shared\/gc_globals.hpp\"\n-\n-inline bool G1CMObjArrayProcessor::should_be_sliced(oop obj) {\n-  return obj->is_objArray() && ((objArrayOop)obj)->size() >= 2 * ObjArrayMarkingStride;\n-}\n-\n-#endif \/\/ SHARE_GC_G1_G1CONCURRENTMARKOBJARRAYPROCESSOR_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkObjArrayProcessor.inline.hpp","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -64,1 +64,1 @@\n-  _par_scan_state->push_on_queue(ScannerTask(p));\n+  _par_scan_state->push_on_queue(ArraySliceTask(p));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/shared\/arraySlicer.hpp\"\n@@ -38,1 +39,0 @@\n-#include \"gc\/shared\/partialArrayTaskStepper.inline.hpp\"\n@@ -83,2 +83,0 @@\n-    _partial_objarray_chunk_size(ParGCArrayScanChunk),\n-    _partial_array_stepper(num_workers),\n@@ -172,4 +170,3 @@\n-void G1ParScanThreadState::verify_task(PartialArrayScanTask task) const {\n-  \/\/ Must be in the collection set--it's already been copied.\n-  oop p = task.to_source_array();\n-  assert(_g1h->is_in_cset(p), \"p=\" PTR_FORMAT, p2i(p));\n+void G1ParScanThreadState::verify_task(oop p) const {\n+  \/\/ Must not be in the collection set--it's already been copied.\n+  assert(!_g1h->is_in_cset(p), \"p=\" PTR_FORMAT, p2i(p));\n@@ -178,1 +175,1 @@\n-void G1ParScanThreadState::verify_task(ScannerTask task) const {\n+void G1ParScanThreadState::verify_task(ArraySliceTask task) const {\n@@ -183,2 +180,2 @@\n-  } else if (task.is_partial_array_task()) {\n-    verify_task(task.to_partial_array_task());\n+  } else if (task.is_array_slice()) {\n+    verify_task(task.to_oop());\n@@ -225,19 +222,23 @@\n-MAYBE_INLINE_EVACUATION\n-void G1ParScanThreadState::do_partial_array(PartialArrayScanTask task) {\n-  oop from_obj = task.to_source_array();\n-\n-  assert(_g1h->is_in_reserved(from_obj), \"must be in heap.\");\n-  assert(from_obj->is_objArray(), \"must be obj array\");\n-  assert(from_obj->is_forwarded(), \"must be forwarded\");\n-\n-  oop to_obj = from_obj->forwardee();\n-  assert(from_obj != to_obj, \"should not be chunking self-forwarded objects\");\n-  assert(to_obj->is_objArray(), \"must be obj array\");\n-  objArrayOop to_array = objArrayOop(to_obj);\n-\n-  PartialArrayTaskStepper::Step step\n-    = _partial_array_stepper.next(objArrayOop(from_obj),\n-                                  to_array,\n-                                  _partial_objarray_chunk_size);\n-  for (uint i = 0; i < step._ncreate; ++i) {\n-    push_on_queue(ScannerTask(PartialArrayScanTask(from_obj)));\n+class G1ScavengeArraySlicer : public ArraySlicer {\n+  G1ScanEvacuatedObjClosure& _scanner;\n+  bool _skip_enqueue;\n+  G1ParScanThreadState* _par_scan;\n+  G1CollectedHeap* _g1h;\n+public:\n+  G1ScavengeArraySlicer(G1ScanEvacuatedObjClosure& scanner,\n+                        bool skip_enqueue,\n+                        G1ParScanThreadState* par_scan) :\n+    ArraySlicer(ParGCArrayScanChunk, ParGCArrayScanChunk),\n+    _scanner(scanner),\n+    _skip_enqueue(skip_enqueue),\n+    _par_scan(par_scan),\n+    _g1h(G1CollectedHeap::heap()) {}\n+\n+  void scan_metadata(objArrayOop array) override {\n+    \/\/ TODO: According to old comment not needed, but may be cleaner?\n+    if (Devirtualizer::do_metadata(&_scanner)) {\n+      Devirtualizer::do_klass(&_scanner, array->klass());\n+    }\n+  }\n+  void push_on_queue(ArraySliceTask task) override {\n+    _par_scan->push_on_queue(task);\n@@ -245,0 +246,13 @@\n+  size_t scan_array(objArrayOop array, int start, int end) override {\n+    G1SkipCardEnqueueSetter x(&_scanner, _skip_enqueue);\n+    array->oop_iterate_range(&_scanner, start, end);\n+    return (end - start) * (UseCompressedOops ? 2 : 1);\n+  }\n+};\n+\n+MAYBE_INLINE_EVACUATION\n+void G1ParScanThreadState::do_partial_array(oop obj, int slice, int pow) {\n+  assert(_g1h->is_in_reserved(obj), \"must be in heap.\");\n+  assert(obj->is_objArray(), \"must be obj array\");\n+\n+  objArrayOop array = objArrayOop(obj);\n@@ -246,8 +260,3 @@\n-  G1HeapRegionAttr dest_attr = _g1h->region_attr(to_array);\n-  G1SkipCardEnqueueSetter x(&_scanner, dest_attr.is_new_survivor());\n-  \/\/ Process claimed task.  The length of to_array is not correct, but\n-  \/\/ fortunately the iteration ignores the length field and just relies\n-  \/\/ on start\/end.\n-  to_array->oop_iterate_range(&_scanner,\n-                              step._index,\n-                              step._index + _partial_objarray_chunk_size);\n+  G1HeapRegionAttr dest_attr = _g1h->region_attr(array);\n+  G1ScavengeArraySlicer slicer(_scanner, dest_attr.is_new_survivor(), this);\n+  slicer.process_slice(array, slice, pow);\n@@ -258,21 +267,3 @@\n-                                                  oop from_obj,\n-                                                  oop to_obj) {\n-  assert(from_obj->is_objArray(), \"precondition\");\n-  assert(from_obj->is_forwarded(), \"precondition\");\n-  assert(from_obj->forwardee() == to_obj, \"precondition\");\n-  assert(from_obj != to_obj, \"should not be scanning self-forwarded objects\");\n-  assert(to_obj->is_objArray(), \"precondition\");\n-\n-  objArrayOop to_array = objArrayOop(to_obj);\n-\n-  PartialArrayTaskStepper::Step step\n-    = _partial_array_stepper.start(objArrayOop(from_obj),\n-                                   to_array,\n-                                   _partial_objarray_chunk_size);\n-\n-  \/\/ Push any needed partial scan tasks.  Pushed before processing the\n-  \/\/ initial chunk to allow other workers to steal while we're processing.\n-  for (uint i = 0; i < step._ncreate; ++i) {\n-    push_on_queue(ScannerTask(PartialArrayScanTask(from_obj)));\n-  }\n-\n+                                                  oop obj) {\n+  assert(obj->is_objArray(), \"precondition\");\n+  objArrayOop array = objArrayOop(obj);\n@@ -283,8 +274,4 @@\n-  assert(dest_attr.is_young() == _g1h->heap_region_containing(to_array)->is_survivor(), \"must be\");\n-  G1SkipCardEnqueueSetter x(&_scanner, dest_attr.is_young());\n-  \/\/ Process the initial chunk.  No need to process the type in the\n-  \/\/ klass, as it will already be handled by processing the built-in\n-  \/\/ module. The length of to_array is not correct, but fortunately\n-  \/\/ the iteration ignores that length field and relies on start\/end.\n-  to_array->oop_iterate_range(&_scanner, 0, step._index);\n-}\n+  assert(dest_attr.is_young() == _g1h->heap_region_containing(array)->is_survivor(), \"must be\");\n+  G1ScavengeArraySlicer slicer(_scanner, dest_attr.is_young(), this);\n+  slicer.process_objArray(array);\n+ }\n@@ -293,1 +280,1 @@\n-void G1ParScanThreadState::dispatch_task(ScannerTask task) {\n+void G1ParScanThreadState::dispatch_task(ArraySliceTask task) {\n@@ -300,1 +287,1 @@\n-    do_partial_array(task.to_partial_array_task());\n+    do_partial_array(task.to_oop(), task.slice(), task.pow());\n@@ -309,1 +296,1 @@\n-  ScannerTask task;\n+  ArraySliceTask task;\n@@ -324,1 +311,1 @@\n-  ScannerTask stolen_task;\n+  ArraySliceTask stolen_task;\n@@ -532,1 +519,1 @@\n-        start_partial_objarray(dest_attr, old, obj);\n+        start_partial_objarray(dest_attr, obj);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":58,"deletions":71,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/shared\/arraySlicer.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"gc\/shared\/partialArrayTaskStepper.hpp\"\n@@ -89,3 +89,0 @@\n-  \/\/ Size (in elements) of a partial objArray task chunk.\n-  int _partial_objarray_chunk_size;\n-  PartialArrayTaskStepper _partial_array_stepper;\n@@ -143,2 +140,2 @@\n-  void verify_task(PartialArrayScanTask task) const NOT_DEBUG_RETURN;\n-  void verify_task(ScannerTask task) const NOT_DEBUG_RETURN;\n+  void verify_task(oop task) const NOT_DEBUG_RETURN;\n+  void verify_task(ArraySliceTask task) const NOT_DEBUG_RETURN;\n@@ -146,1 +143,1 @@\n-  void push_on_queue(ScannerTask task);\n+  void push_on_queue(ArraySliceTask task);\n@@ -172,2 +169,2 @@\n-  void do_partial_array(PartialArrayScanTask task);\n-  void start_partial_objarray(G1HeapRegionAttr dest_dir, oop from, oop to);\n+  void do_partial_array(oop obj, int chunk, int pow);\n+  void start_partial_objarray(G1HeapRegionAttr dest_dir, oop obj);\n@@ -195,1 +192,1 @@\n-  void dispatch_task(ScannerTask task);\n+  void dispatch_task(ArraySliceTask task);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-inline void G1ParScanThreadState::push_on_queue(ScannerTask task) {\n+inline void G1ParScanThreadState::push_on_queue(ArraySliceTask task) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -862,1 +862,1 @@\n-      _par_scan_state->push_on_queue(ScannerTask(p));\n+      _par_scan_state->push_on_queue(ArraySliceTask(p));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shared\/arraySlicer.hpp\"\n@@ -228,1 +229,1 @@\n-    ScannerTask task;\n+    ArraySliceTask task;\n@@ -267,14 +268,1 @@\n-template <class T> void PSPromotionManager::process_array_chunk_work(\n-                                                 oop obj,\n-                                                 int start, int end) {\n-  assert(start <= end, \"invariant\");\n-  T* const base      = (T*)objArrayOop(obj)->base();\n-  T* p               = base + start;\n-  T* const chunk_end = base + end;\n-  while (p < chunk_end) {\n-    claim_or_forward_depth(p);\n-    ++p;\n-  }\n-}\n-\n-void PSPromotionManager::process_array_chunk(PartialArrayScanTask task) {\n+void PSPromotionManager::process_array_chunk(ArraySliceTask task) {\n@@ -283,29 +271,4 @@\n-  oop old = task.to_source_array();\n-  assert(old->is_objArray(), \"invariant\");\n-  assert(old->is_forwarded(), \"invariant\");\n-\n-  TASKQUEUE_STATS_ONLY(++_array_chunks_processed);\n-\n-  oop const obj = old->forwardee();\n-\n-  int start;\n-  int const end = arrayOop(old)->length();\n-  if (end > (int) _min_array_size_for_chunking) {\n-    \/\/ we'll chunk more\n-    start = end - _array_chunk_size;\n-    assert(start > 0, \"invariant\");\n-    arrayOop(old)->set_length(start);\n-    push_depth(ScannerTask(PartialArrayScanTask(old)));\n-    TASKQUEUE_STATS_ONLY(++_array_chunk_pushes);\n-  } else {\n-    \/\/ this is the final chunk for this array\n-    start = 0;\n-    int const actual_length = arrayOop(obj)->length();\n-    arrayOop(old)->set_length(actual_length);\n-  }\n-\n-  if (UseCompressedOops) {\n-    process_array_chunk_work<narrowOop>(obj, start, end);\n-  } else {\n-    process_array_chunk_work<oop>(obj, start, end);\n-  }\n+  ParallelGCArraySlicer slicer(this);\n+  oop obj = task.to_oop();\n+  assert(obj->is_objArray(), \"must be object array\");\n+  slicer.process_slice(objArrayOop(obj), task.slice(), task.pow());\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":7,"deletions":44,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/arraySlicer.hpp\"\n@@ -56,0 +57,1 @@\n+  friend class ParallelGCArraySlicer;\n@@ -58,1 +60,1 @@\n-  typedef OverflowTaskQueue<ScannerTask, mtGC>           PSScannerTasksQueue;\n+  typedef OverflowTaskQueue<ArraySliceTask, mtGC>        PSScannerTasksQueue;\n@@ -102,1 +104,1 @@\n-  template <class T> void  process_array_chunk_work(oop obj,\n+  template <class T> void  process_array_chunk_work(objArrayOop obj,\n@@ -104,1 +106,1 @@\n-  void process_array_chunk(PartialArrayScanTask task);\n+  void process_array_chunk(ArraySliceTask task);\n@@ -106,1 +108,1 @@\n-  void push_depth(ScannerTask task);\n+  void push_depth(ArraySliceTask task);\n@@ -127,1 +129,1 @@\n-  static bool steal_depth(int queue_num, ScannerTask& t);\n+  static bool steal_depth(int queue_num, ArraySliceTask& t);\n@@ -162,1 +164,1 @@\n-  inline void process_popped_location_depth(ScannerTask task);\n+  inline void process_popped_location_depth(ArraySliceTask task);\n@@ -172,1 +174,1 @@\n-  TASKQUEUE_STATS_ONLY(inline void record_steal(ScannerTask task);)\n+  TASKQUEUE_STATS_ONLY(inline void record_steal(ArraySliceTask task);)\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-inline void PSPromotionManager::push_depth(ScannerTask task) {\n+inline void PSPromotionManager::push_depth(ArraySliceTask task) {\n@@ -65,1 +65,1 @@\n-    push_depth(ScannerTask(p));\n+    push_depth(ArraySliceTask(p));\n@@ -160,0 +160,39 @@\n+template <class T> void PSPromotionManager::process_array_chunk_work(\n+                                                 objArrayOop obj,\n+                                                 int start, int end) {\n+  assert(start <= end, \"invariant\");\n+  T* const base      = (T*)objArrayOop(obj)->base();\n+  T* p               = base + start;\n+  T* const chunk_end = base + end;\n+  while (p < chunk_end) {\n+    claim_or_forward_depth(p);\n+    ++p;\n+  }\n+}\n+\n+class ParallelGCArraySlicer : public ArraySlicer {\n+  PSPromotionManager* _promotion_manager;\n+public:\n+  explicit ParallelGCArraySlicer(PSPromotionManager* promotion_manager) :\n+          ArraySlicer(promotion_manager->_array_chunk_size,\n+                      promotion_manager->_min_array_size_for_chunking),\n+          _promotion_manager(promotion_manager) {}\n+\n+  void scan_metadata(objArrayOop array) {\n+    \/\/ Nothing to do here.\n+  }\n+  void push_on_queue(ArraySliceTask task) {\n+    _promotion_manager->push_depth(task);\n+    TASKQUEUE_STATS_ONLY(++_promotion_manager->_array_chunk_pushes);\n+  }\n+  size_t scan_array(objArrayOop array, int start, int end) {\n+    if (UseCompressedOops) {\n+      _promotion_manager->process_array_chunk_work<narrowOop>(array, start, end);\n+    } else {\n+      _promotion_manager->process_array_chunk_work<oop>(array, start, end);\n+    }\n+    TASKQUEUE_STATS_ONLY(++_promotion_manager->_array_chunks_processed);\n+    return 0; \/\/ Not used in ParallelGC\n+  }\n+};\n+\n@@ -283,2 +322,2 @@\n-      push_depth(ScannerTask(PartialArrayScanTask(o)));\n-      TASKQUEUE_STATS_ONLY(++_arrays_chunked; ++_array_chunk_pushes);\n+      ParallelGCArraySlicer slicer(this);\n+      slicer.process_objArray(objArrayOop(new_obj));\n@@ -330,2 +369,2 @@\n-inline void PSPromotionManager::process_popped_location_depth(ScannerTask task) {\n-  if (task.is_partial_array_task()) {\n+inline void PSPromotionManager::process_popped_location_depth(ArraySliceTask task) {\n+  if (task.is_array_slice()) {\n@@ -333,1 +372,1 @@\n-    process_array_chunk(task.to_partial_array_task());\n+    process_array_chunk(task);\n@@ -344,1 +383,1 @@\n-inline bool PSPromotionManager::steal_depth(int queue_num, ScannerTask& t) {\n+inline bool PSPromotionManager::steal_depth(int queue_num, ArraySliceTask& t) {\n@@ -349,2 +388,2 @@\n-void PSPromotionManager::record_steal(ScannerTask task) {\n-  if (task.is_partial_array_task()) {\n+void PSPromotionManager::record_steal(ArraySliceTask task) {\n+  if (task.is_array_slice()) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":49,"deletions":10,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -127,1 +127,1 @@\n-    ScannerTask task;\n+    ArraySliceTask task;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2016, 2024, Red Hat, Inc. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/arraySlicer.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"oops\/objArrayOop.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+\n+size_t ArraySlicer::process_objArray(objArrayOop array) {\n+  int len = array->length();\n+\n+  \/\/ Mark objArray klass metadata\n+  scan_metadata(array);\n+\n+  if (len <= _min_array_size_for_slicing) {\n+    return scan_array(array, 0, len);\n+  }\n+\n+  int bits = log2i_graceful(len);\n+  \/\/ Compensate for non-power-of-two arrays, cover the array in excess:\n+  if (len != (1 << bits)) bits++;\n+\n+  \/\/ Only allow full slices on the queue. This frees do_sliced_array() from checking from\/to\n+  \/\/ boundaries against array->length(), touching the array header on every slice.\n+  \/\/\n+  \/\/ To do this, we cut the prefix in full-sized slices, and submit them on the queue.\n+  \/\/ If the array is not divided in slice sizes, then there would be an irregular tail,\n+  \/\/ which we will process separately.\n+\n+  int last_idx = 0;\n+\n+  int slice = 1;\n+  int pow = bits;\n+\n+  \/\/ Handle overflow\n+  if (pow >= 31) {\n+    assert (pow == 31, \"sanity\");\n+    pow--;\n+    slice = 2;\n+    last_idx = (1 << pow);\n+    push_on_queue(ArraySliceTask(array, 1, pow));\n+  }\n+\n+  \/\/ Split out tasks, as suggested in ArraySliceTask docs. Record the last\n+  \/\/ successful right boundary to figure out the irregular tail.\n+  while ((1 << pow) > _array_slice_size &&\n+         (slice * 2 < ArraySliceTask::slice_size())) {\n+    pow--;\n+    int left_slice = slice * 2 - 1;\n+    int right_slice = slice * 2;\n+    int left_slice_end = left_slice * (1 << pow);\n+    if (left_slice_end < len) {\n+      push_on_queue(ArraySliceTask(array, left_slice, pow));\n+      slice = right_slice;\n+      last_idx = left_slice_end;\n+    } else {\n+      slice = left_slice;\n+    }\n+  }\n+\n+  \/\/ Process the irregular tail, if present\n+  int from = last_idx;\n+  if (from < len) {\n+    return scan_array(array, from, len);\n+  }\n+  return 0;\n+}\n+\n+size_t ArraySlicer::process_slice(objArrayOop array, int slice, int pow) {\n+  assert (_array_slice_size > 0, \"sanity\");\n+\n+  \/\/ Split out tasks, as suggested in ArraySliceTask docs. Avoid pushing tasks that\n+  \/\/ are known to start beyond the array.\n+  while ((1 << pow) > _array_slice_size && (slice * 2 < ArraySliceTask::slice_size())) {\n+    pow--;\n+    slice *= 2;\n+    push_on_queue(ArraySliceTask(array, slice - 1, pow));\n+  }\n+\n+  int slice_size = 1 << pow;\n+\n+  int from = (slice - 1) * slice_size;\n+  int to = slice * slice_size;\n+\n+#ifdef ASSERT\n+  int len = array->length();\n+  assert (0 <= from && from < len, \"from is sane: %d\/%d\", from, len);\n+  assert (0 < to && to <= len, \"to is sane: %d\/%d\", to, len);\n+#endif\n+\n+  return scan_array(array, from, to);\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/arraySlicer.cpp","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,270 @@\n+\/*\n+ * Copyright (c) 2016, 2024, Red Hat, Inc. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARE_ARRAYSLICER_HPP\n+#define SHARE_GC_SHARE_ARRAYSLICER_HPP\n+\n+#include \"oops\/oopsHierarchy.hpp\"\n+\n+\/\/ A task queue entry that encodes both regular oops, and the array oops plus sliceing data for\n+\/\/ parallel array processing.\n+\/\/ The design goal is to make the regular oop ops very fast, because that would be the prevailing\n+\/\/ case. On the other hand, it should not block parallel array processing from efficiently dividing\n+\/\/ the array work.\n+\/\/\n+\/\/ The idea is to steal the bits from the 64-bit oop to encode array data, if needed. For the\n+\/\/ proper divide-and-conquer strategies, we want to encode the \"blocking\" data. It turns out, the\n+\/\/ most efficient way to do this is to encode the array block as (slice * 2^pow), where it is assumed\n+\/\/ that the block has the size of 2^pow. This requires for pow to have only 5 bits (2^32) to encode\n+\/\/ all possible arrays.\n+\/\/\n+\/\/    |xx-------oop---------|-pow-|--slice---|\n+\/\/    0                    49     54        64\n+\/\/\n+\/\/ By definition, slice == 0 means \"no slice\", i.e. sliceing starts from 1.\n+\/\/\n+\/\/ This encoding gives a few interesting benefits:\n+\/\/\n+\/\/ a) Encoding\/decoding regular oops is very simple, because the upper bits are zero in that task:\n+\/\/\n+\/\/    |---------oop---------|00000|0000000000| \/\/ no slice data\n+\/\/\n+\/\/    This helps the most ubiquitous path. The initialization amounts to putting the oop into the word\n+\/\/    with zero padding. Testing for \"slicedness\" is testing for zero with slice mask.\n+\/\/\n+\/\/ b) Splitting tasks for divide-and-conquer is possible. Suppose we have slice <C, P> that covers\n+\/\/ interval [ (C-1)*2^P; C*2^P ). We can then split it into two slices:\n+\/\/      <2*C - 1, P-1>, that covers interval [ (2*C - 2)*2^(P-1); (2*C - 1)*2^(P-1) )\n+\/\/      <2*C, P-1>,     that covers interval [ (2*C - 1)*2^(P-1);       2*C*2^(P-1) )\n+\/\/\n+\/\/    Observe that the union of these two intervals is:\n+\/\/      [ (2*C - 2)*2^(P-1); 2*C*2^(P-1) )\n+\/\/\n+\/\/    ...which is the original interval:\n+\/\/      [ (C-1)*2^P; C*2^P )\n+\/\/\n+\/\/ c) The divide-and-conquer strategy could even start with slice <1, round-log2-len(arr)>, and split\n+\/\/    down in the parallel threads, which alleviates the upfront (serial) splitting costs.\n+\/\/\n+\/\/ Encoding limitations caused by current bitscales mean:\n+\/\/    10 bits for slice: max 1024 blocks per array\n+\/\/     5 bits for power: max 2^32 array\n+\/\/    49 bits for   oop: max 512 TB of addressable space\n+\/\/\n+\/\/ Stealing bits from oop trims down the addressable space. Stealing too few bits for slice ID limits\n+\/\/ potential parallelism. Stealing too few bits for pow limits the maximum array size that can be handled.\n+\/\/ In future, these might be rebalanced to favor one degree of freedom against another. For example,\n+\/\/ if\/when Arrays 2.0 bring 2^64-sized arrays, we might need to steal another bit for power. We could regain\n+\/\/ some bits back if slices are counted in ObjArrayMarkingStride units.\n+\/\/\n+\/\/ There is also a fallback version that uses plain fields, when we don't have enough space to steal the\n+\/\/ bits from the native pointer. It is useful to debug the optimized version.\n+\/\/\n+#ifdef _LP64\n+class ArraySliceTask {\n+private:\n+  \/\/ Everything is encoded into this field...\n+  uintptr_t _val;\n+\n+  \/\/ ...with these:\n+  static const uintptr_t OopTag = 0;\n+  static const uintptr_t NarrowOopTag = 1;\n+  static const uintptr_t TagMask = 1;\n+\n+  static const uint8_t slice_bits  = 10;\n+  static const uint8_t pow_bits    = 5;\n+  static const uint8_t oop_bits    = sizeof(uintptr_t)*8 - slice_bits - pow_bits;\n+\n+  static const uint8_t oop_shift   = 0;\n+  static const uint8_t pow_shift   = oop_bits;\n+  static const uint8_t slice_shift = oop_bits + pow_bits;\n+\n+  static const uintptr_t oop_extract_mask       = right_n_bits(oop_bits) - 3;\n+  static const uintptr_t slice_pow_extract_mask = ~right_n_bits(oop_bits);\n+\n+  static const int slice_range_mask = right_n_bits(slice_bits);\n+  static const int pow_range_mask   = right_n_bits(pow_bits);\n+\n+  bool has_tag(uintptr_t val, uintptr_t tag) const {\n+    return (val & TagMask) == tag;\n+  }\n+\n+  inline void* decode(uintptr_t val, uintptr_t tag) const {\n+    STATIC_ASSERT(oop_shift == 0);\n+    assert(has_tag(val, tag), \"precondition\");\n+    return cast_to_oop(val & oop_extract_mask);\n+  }\n+\n+  inline bool decode_is_sliced(uintptr_t val) const {\n+    \/\/ No need to shift for a comparison to zero\n+    return (val & slice_pow_extract_mask) != 0;\n+  }\n+\n+  inline int decode_slice(uintptr_t val) const {\n+    return (int) ((val >> slice_shift) & slice_range_mask);\n+  }\n+\n+  inline int decode_pow(uintptr_t val) const {\n+    return (int) ((val >> pow_shift) & pow_range_mask);\n+  }\n+\n+  inline uintptr_t encode_oop(void* p, uintptr_t tag) const {\n+    STATIC_ASSERT(oop_shift == 0);\n+    return reinterpret_cast<uintptr_t>(p) + tag;\n+  }\n+\n+  inline uintptr_t encode_slice(int slice) const {\n+    return ((uintptr_t) slice) << slice_shift;\n+  }\n+\n+  inline uintptr_t encode_pow(int pow) const {\n+    return ((uintptr_t) pow) << pow_shift;\n+  }\n+\n+public:\n+  ArraySliceTask() : _val(0) {\n+  }\n+  ArraySliceTask(oop o) {\n+    uintptr_t enc = encode_oop(o, OopTag);\n+    assert(decode(enc, OopTag) == o, \"oop encoding should work: \" PTR_FORMAT, p2i(o));\n+    assert(!decode_is_sliced(enc),  \"task should not be sliced\");\n+    _val = enc;\n+  }\n+  ArraySliceTask(oop* o) {\n+    uintptr_t enc = encode_oop(o, OopTag);\n+    assert(decode(enc, OopTag) == o, \"oop encoding should work: \" PTR_FORMAT, p2i(o));\n+    assert(!decode_is_sliced(enc),  \"task should not be sliced\");\n+    _val = enc;\n+  }\n+  ArraySliceTask(narrowOop* o) {\n+    uintptr_t enc = encode_oop(o, NarrowOopTag);\n+    assert(decode(enc, NarrowOopTag) == o, \"oop encoding should work: \" PTR_FORMAT, p2i(o));\n+    assert(!decode_is_sliced(enc),  \"task should not be sliced\");\n+    _val = enc;\n+  }\n+\n+  ArraySliceTask(oop o, int slice, int pow) {\n+    uintptr_t enc_oop = encode_oop(o, OopTag);\n+    uintptr_t enc_slice = encode_slice(slice);\n+    uintptr_t enc_pow = encode_pow(pow);\n+    uintptr_t enc = enc_oop | enc_slice | enc_pow;\n+    assert(decode(enc, OopTag) == o,   \"oop encoding should work: \" PTR_FORMAT, p2i(o));\n+    assert(decode_slice(enc) == slice, \"slice encoding should work: %d\", slice);\n+    assert(decode_pow(enc) == pow,     \"pow encoding should work: %d\", pow);\n+    assert(decode_is_sliced(enc),   \"task should be sliced\");\n+    _val = enc;\n+  }\n+\n+  \/\/ Trivially copyable.\n+\n+public:\n+  bool is_oop_ptr()            const { return !decode_is_sliced(_val) && (_val & NarrowOopTag) == 0; }\n+  bool is_narrow_oop_ptr()     const { return !decode_is_sliced(_val) && (_val & NarrowOopTag) != 0; }\n+  bool is_array_slice()        const { return decode_is_sliced(_val);  }\n+  bool is_oop()                const { return !decode_is_sliced(_val); }\n+  bool is_null()               const { return _val == 0; }\n+\n+  inline oop*       to_oop_ptr()        const { return reinterpret_cast<oop*>(decode(_val, OopTag));   }\n+  inline narrowOop* to_narrow_oop_ptr() const { return reinterpret_cast<narrowOop*>(decode(_val, NarrowOopTag));   }\n+  inline oop        to_oop()            const { return cast_to_oop(decode(_val, OopTag));   }\n+  inline int        slice()             const { return decode_slice(_val); }\n+  inline int        pow()               const { return decode_pow(_val);   }\n+\n+  static int slice_size() {\n+    return nth_bit(slice_bits);\n+  }\n+};\n+#else\n+class ArraySliceTask {\n+private:\n+  static const uint8_t slice_bits  = 10;\n+\n+  void*    _ptr;\n+  uint16_t _slice;\n+  uint16_t _pow;\n+\n+public:\n+  ArraySliceTask() :\n+    _ptr(nullptr), _slice(0), _pow(0) {\n+  }\n+  ArraySliceTask(oop o) :\n+    _ptr(cast_from_oop<void*>(o)),\n+    _slice(0), _pow(0) {\n+    assert(!is_array_slice(),  \"task should not be sliced\");\n+  }\n+  ArraySliceTask(oop* o) :\n+    _ptr(reinterpret_cast<void*>(o)),\n+    _slice(0), _pow(0) {\n+    assert(!is_array_slice(),  \"task should not be sliced\");\n+  }\n+  ArraySliceTask(narrowOop* o) {\n+    ShouldNotReachHere();\n+  }\n+  ArraySliceTask(oop o, int slice, int pow) :\n+    _ptr(cast_from_oop<void*>(o)),\n+    _slice(slice), _pow(pow) {\n+    assert(is_array_slice(),  \"task should be sliced\");\n+  }\n+\n+  \/\/ Trivially copyable.\n+\n+public:\n+  bool is_oop_ptr()            const { return !is_array_slice(); }\n+  bool is_narrow_oop_ptr()     const { return false; }\n+  bool is_array_slice()        const { return _slice != 0;  }\n+  bool is_oop()                const { return !is_array_slice(); }\n+  bool is_null()               const { return _ptr == nullptr; }\n+\n+  inline oop*       to_oop_ptr()        const { return reinterpret_cast<oop*>(_ptr); }\n+  inline narrowOop* to_narrow_oop_ptr() const { ShouldNotReachHere();                }\n+  inline oop        to_oop()            const { return cast_to_oop(_ptr);            }\n+  inline int        slice()             const { return _slice;                       }\n+  inline int        pow()               const { return _pow;                         }\n+\n+  static int slice_size() {\n+    return nth_bit(slice_bits);\n+  }\n+};\n+#endif\n+\n+class ArraySlicer {\n+private:\n+  int _array_slice_size;\n+  int _min_array_size_for_slicing;\n+protected:\n+  ArraySlicer(int array_slice_size, int min_array_size_for_slicing) :\n+    _array_slice_size(array_slice_size),\n+    _min_array_size_for_slicing(min_array_size_for_slicing) {}\n+\n+  virtual void scan_metadata(objArrayOop array) = 0;\n+  virtual void push_on_queue(ArraySliceTask task) = 0;\n+  virtual size_t scan_array(objArrayOop array, int start, int end) = 0;\n+public:\n+\n+  size_t process_objArray(objArrayOop obj);\n+  size_t process_slice(objArrayOop array, int slice, int pow);\n+};\n+\n+#endif \/\/ SHARE_GC_SHARE_ARRAYSLICER_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/arraySlicer.hpp","additions":270,"deletions":0,"binary":false,"changes":270,"status":"added"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/shared\/partialArrayTaskStepper.hpp\"\n-#include \"oops\/arrayOop.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/powerOfTwo.hpp\"\n-\n-static uint compute_task_limit(uint n_workers) {\n-  \/\/ Don't need more than n_workers tasks at a time.  But allowing up to\n-  \/\/ that maximizes available parallelism.\n-  return n_workers;\n-}\n-\n-static uint compute_task_fanout(uint task_limit) {\n-  assert(task_limit > 0, \"precondition\");\n-  \/\/ There is a tradeoff between providing parallelism more quickly and\n-  \/\/ number of enqueued tasks.  A constant fanout may be too slow when\n-  \/\/ parallelism (and so task_limit) is large.  A constant fraction might\n-  \/\/ be overly eager.  Using log2 attempts to balance between those.\n-  uint result = log2i(task_limit);\n-  \/\/ result must be > 0.  result should be > 1 if task_limit > 1, to\n-  \/\/ provide some potentially parallel tasks.  But don't just +1 to\n-  \/\/ avoid otherwise increasing rate of task generation.\n-  if (result < 2) ++result;\n-  return result;\n-}\n-\n-PartialArrayTaskStepper::PartialArrayTaskStepper(uint n_workers) :\n-  _task_limit(compute_task_limit(n_workers)),\n-  _task_fanout(compute_task_fanout(_task_limit))\n-{}\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayTaskStepper.cpp","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHARED_PARTIALARRAYTASKSTEPPER_HPP\n-#define SHARE_GC_SHARED_PARTIALARRAYTASKSTEPPER_HPP\n-\n-#include \"oops\/arrayOop.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-\/\/ Helper for handling PartialArrayTasks.\n-\/\/\n-\/\/ When an array is large, we want to split it up into chunks that can be\n-\/\/ processed in parallel.  Each task (implicitly) represents such a chunk.\n-\/\/ We can enqueue multiple tasks at the same time.  We want to enqueue\n-\/\/ enough tasks to benefit from the available parallelism, while not so many\n-\/\/ as to substantially expand the task queues.\n-\/\/\n-\/\/ A task directly refers to the from-space array.  The from-space array's\n-\/\/ forwarding pointer refers to the associated to-space array, and its\n-\/\/ length is the actual length. The to-space array's length field is used to\n-\/\/ indicate processing progress.  It is the starting index of the next chunk\n-\/\/ to process, or equals the actual length when there are no more chunks to\n-\/\/ be processed.\n-class PartialArrayTaskStepper {\n-public:\n-  PartialArrayTaskStepper(uint n_workers);\n-\n-  struct Step {\n-    int _index;                 \/\/ Array index for the step.\n-    uint _ncreate;              \/\/ Number of new tasks to create.\n-  };\n-\n-  \/\/ Set to's length to the end of the initial chunk, which is the start of\n-  \/\/ the first partial task if the array is large enough to need splitting.\n-  \/\/ Returns a Step with _index being that index and _ncreate being the\n-  \/\/ initial number of partial tasks to enqueue.\n-  inline Step start(arrayOop from, arrayOop to, int chunk_size) const;\n-\n-  \/\/ Increment to's length by chunk_size to claim the next chunk.  Returns a\n-  \/\/ Step with _index being the starting index of the claimed chunk and\n-  \/\/ _ncreate being the number of additional partial tasks to enqueue.\n-  \/\/ precondition: chunk_size must be the same as used to start the task sequence.\n-  inline Step next(arrayOop from, arrayOop to, int chunk_size) const;\n-\n-  class TestSupport;            \/\/ For unit tests\n-\n-private:\n-  \/\/ Limit on the number of partial array tasks to create for a given array.\n-  uint _task_limit;\n-  \/\/ Maximum number of new tasks to create when processing an existing task.\n-  uint _task_fanout;\n-\n-  \/\/ Split start\/next into public part dealing with oops and private\n-  \/\/ impl dealing with lengths and pointers to lengths, for unit testing.\n-  \/\/ length is the actual length obtained from the from-space object.\n-  \/\/ to_length_addr is the address of the to-space object's length value.\n-  inline Step start_impl(int length, int* to_length_addr, int chunk_size) const;\n-  inline Step next_impl(int length, int* to_length_addr, int chunk_size) const;\n-};\n-\n-#endif \/\/ SHARE_GC_SHARED_PARTIALARRAYTASKSTEPPER_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayTaskStepper.hpp","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -1,118 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHARED_PARTIALARRAYTASKSTEPPER_INLINE_HPP\n-#define SHARE_GC_SHARED_PARTIALARRAYTASKSTEPPER_INLINE_HPP\n-\n-#include \"gc\/shared\/partialArrayTaskStepper.hpp\"\n-\n-#include \"oops\/arrayOop.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-\n-PartialArrayTaskStepper::Step\n-PartialArrayTaskStepper::start_impl(int length,\n-                                    int* to_length_addr,\n-                                    int chunk_size) const {\n-  assert(chunk_size > 0, \"precondition\");\n-\n-  int end = length % chunk_size; \/\/ End of initial chunk.\n-  \/\/ Set to's length to end of initial chunk.  Partial tasks use that length\n-  \/\/ field as the start of the next chunk to process.  Must be done before\n-  \/\/ enqueuing partial scan tasks, in case other threads steal any of those\n-  \/\/ tasks.\n-  \/\/\n-  \/\/ The value of end can be 0, either because of a 0-length array or\n-  \/\/ because length is a multiple of the chunk size.  Both of those are\n-  \/\/ relatively rare and handled in the normal course of the iteration, so\n-  \/\/ not worth doing anything special about here.\n-  *to_length_addr = end;\n-\n-  \/\/ If the initial chunk is the complete array, then don't need any partial\n-  \/\/ tasks.  Otherwise, start with just one partial task; see new task\n-  \/\/ calculation in next().\n-  Step result = { end, (length > end) ? 1u : 0u };\n-  return result;\n-}\n-\n-PartialArrayTaskStepper::Step\n-PartialArrayTaskStepper::start(arrayOop from, arrayOop to, int chunk_size) const {\n-  return start_impl(from->length(), to->length_addr(), chunk_size);\n-}\n-\n-PartialArrayTaskStepper::Step\n-PartialArrayTaskStepper::next_impl(int length,\n-                                   int* to_length_addr,\n-                                   int chunk_size) const {\n-  assert(chunk_size > 0, \"precondition\");\n-\n-  \/\/ The start of the next task is in the length field of the to-space object.\n-  \/\/ Atomically increment by the chunk size to claim the associated chunk.\n-  \/\/ Because we limit the number of enqueued tasks to being no more than the\n-  \/\/ number of remaining chunks to process, we can use an atomic add for the\n-  \/\/ claim, rather than a CAS loop.\n-  int start = Atomic::fetch_then_add(to_length_addr,\n-                                     chunk_size,\n-                                     memory_order_relaxed);\n-\n-  assert(start < length, \"invariant: start %d, length %d\", start, length);\n-  assert(((length - start) % chunk_size) == 0,\n-         \"invariant: start %d, length %d, chunk size %d\",\n-         start, length, chunk_size);\n-\n-  \/\/ Determine the number of new tasks to create.\n-  \/\/ Zero-based index for this partial task.  The initial task isn't counted.\n-  uint task_num = (start \/ chunk_size);\n-  \/\/ Number of tasks left to process, including this one.\n-  uint remaining_tasks = (length - start) \/ chunk_size;\n-  assert(remaining_tasks > 0, \"invariant\");\n-  \/\/ Compute number of pending tasks, including this one.  The maximum number\n-  \/\/ of tasks is a function of task_num (N) and _task_fanout (F).\n-  \/\/   1    : current task\n-  \/\/   N    : number of preceding tasks\n-  \/\/   F*N  : maximum created for preceding tasks\n-  \/\/ => F*N - N + 1 : maximum number of tasks\n-  \/\/ => (F-1)*N + 1\n-  assert(_task_limit > 0, \"precondition\");\n-  assert(_task_fanout > 0, \"precondition\");\n-  uint max_pending = (_task_fanout - 1) * task_num + 1;\n-\n-  \/\/ The actual pending may be less than that.  Bound by remaining_tasks to\n-  \/\/ not overrun.  Also bound by _task_limit to avoid spawning an excessive\n-  \/\/ number of tasks for a large array.  The +1 is to replace the current\n-  \/\/ task with a new task when _task_limit limited.  The pending value may\n-  \/\/ not be what's actually in the queues, because of concurrent task\n-  \/\/ processing.  That's okay; we just need to determine the correct number\n-  \/\/ of tasks to add for this task.\n-  uint pending = MIN3(max_pending, remaining_tasks, _task_limit);\n-  uint ncreate = MIN2(_task_fanout, MIN2(remaining_tasks, _task_limit + 1) - pending);\n-  Step result = { start, ncreate };\n-  return result;\n-}\n-\n-PartialArrayTaskStepper::Step\n-PartialArrayTaskStepper::next(arrayOop from, arrayOop to, int chunk_size) const {\n-  return next_impl(from->length(), to->length_addr(), chunk_size);\n-}\n-\n-#endif \/\/ SHARE_GC_SHARED_PARTIALARRAYTASKSTEPPER_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayTaskStepper.inline.hpp","additions":0,"deletions":118,"binary":false,"changes":118,"status":"deleted"},{"patch":"@@ -576,83 +576,0 @@\n-\/\/ Wrapper over an oop that is a partially scanned array.\n-\/\/ Can be converted to a ScannerTask for placement in associated task queues.\n-\/\/ Refers to the partially copied source array oop.\n-class PartialArrayScanTask {\n-  oop _src;\n-\n-public:\n-  explicit PartialArrayScanTask(oop src_array) : _src(src_array) {}\n-  \/\/ Trivially copyable.\n-\n-  oop to_source_array() const { return _src; }\n-};\n-\n-\/\/ Discriminated union over oop*, narrowOop*, and PartialArrayScanTask.\n-\/\/ Uses a low tag in the associated pointer to identify the category.\n-\/\/ Used as a task queue element type.\n-class ScannerTask {\n-  void* _p;\n-\n-  static const uintptr_t OopTag = 0;\n-  static const uintptr_t NarrowOopTag = 1;\n-  static const uintptr_t PartialArrayTag = 2;\n-  static const uintptr_t TagSize = 2;\n-  static const uintptr_t TagAlignment = 1 << TagSize;\n-  static const uintptr_t TagMask = TagAlignment - 1;\n-\n-  static void* encode(void* p, uintptr_t tag) {\n-    assert(is_aligned(p, TagAlignment), \"misaligned: \" PTR_FORMAT, p2i(p));\n-    return static_cast<char*>(p) + tag;\n-  }\n-\n-  uintptr_t raw_value() const {\n-    return reinterpret_cast<uintptr_t>(_p);\n-  }\n-\n-  bool has_tag(uintptr_t tag) const {\n-    return (raw_value() & TagMask) == tag;\n-  }\n-\n-  void* decode(uintptr_t tag) const {\n-    assert(has_tag(tag), \"precondition\");\n-    return static_cast<char*>(_p) - tag;\n-  }\n-\n-public:\n-  ScannerTask() : _p(nullptr) {}\n-\n-  explicit ScannerTask(oop* p) : _p(encode(p, OopTag)) {}\n-\n-  explicit ScannerTask(narrowOop* p) : _p(encode(p, NarrowOopTag)) {}\n-\n-  explicit ScannerTask(PartialArrayScanTask t) :\n-    _p(encode(t.to_source_array(), PartialArrayTag)) {}\n-\n-  \/\/ Trivially copyable.\n-\n-  \/\/ Predicate implementations assume OopTag == 0, others are powers of 2.\n-\n-  bool is_oop_ptr() const {\n-    return (raw_value() & (NarrowOopTag | PartialArrayTag)) == 0;\n-  }\n-\n-  bool is_narrow_oop_ptr() const {\n-    return (raw_value() & NarrowOopTag) != 0;\n-  }\n-\n-  bool is_partial_array_task() const {\n-    return (raw_value() & PartialArrayTag) != 0;\n-  }\n-\n-  oop* to_oop_ptr() const {\n-    return static_cast<oop*>(decode(OopTag));\n-  }\n-\n-  narrowOop* to_narrow_oop_ptr() const {\n-    return static_cast<narrowOop*>(decode(NarrowOopTag));\n-  }\n-\n-  PartialArrayScanTask to_partial_array_task() const {\n-    return PartialArrayScanTask(cast_to_oop(decode(PartialArrayTag)));\n-  }\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/taskqueue.hpp","additions":0,"deletions":83,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -1,87 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/shared\/partialArrayTaskStepper.inline.hpp\"\n-#include \"memory\/allStatic.hpp\"\n-#include \"unittest.hpp\"\n-\n-using Step = PartialArrayTaskStepper::Step;\n-using Stepper = PartialArrayTaskStepper;\n-\n-class PartialArrayTaskStepper::TestSupport : AllStatic {\n-public:\n-  static Step start(const Stepper* stepper,\n-                    int length,\n-                    int* to_length_addr,\n-                    uint chunk_size) {\n-    return stepper->start_impl(length, to_length_addr, chunk_size);\n-  }\n-\n-  static Step next(const Stepper* stepper,\n-                   int length,\n-                   int* to_length_addr,\n-                   uint chunk_size) {\n-    return stepper->next_impl(length, to_length_addr, chunk_size);\n-  }\n-};\n-\n-using StepperSupport = PartialArrayTaskStepper::TestSupport;\n-\n-static int simulate(const Stepper* stepper,\n-                    int length,\n-                    int* to_length_addr,\n-                    uint chunk_size) {\n-  Step init = StepperSupport::start(stepper, length, to_length_addr, chunk_size);\n-  uint queue_count = init._ncreate;\n-  int task = 0;\n-  for ( ; queue_count > 0; ++task) {\n-    --queue_count;\n-    Step step = StepperSupport::next(stepper, length, to_length_addr, chunk_size);\n-    queue_count += step._ncreate;\n-  }\n-  return task;\n-}\n-\n-static void run_test(int length, int chunk_size, uint n_workers) {\n-  const PartialArrayTaskStepper stepper(n_workers);\n-  int to_length;\n-  int tasks = simulate(&stepper, length, &to_length, chunk_size);\n-  ASSERT_EQ(length, to_length);\n-  ASSERT_EQ(tasks, length \/ chunk_size);\n-}\n-\n-TEST(PartialArrayTaskStepperTest, doit) {\n-  for (int chunk_size = 50; chunk_size <= 500; chunk_size += 50) {\n-    for (uint n_workers = 1; n_workers <= 256; n_workers = (n_workers * 3 \/ 2 + 1)) {\n-      for (int length = 0; length <= 1000000; length = (length * 2 + 1)) {\n-        run_test(length, chunk_size, n_workers);\n-      }\n-      \/\/ Ensure we hit boundary cases for length % chunk_size == 0.\n-      for (uint i = 0; i < 2 * n_workers; ++i) {\n-        run_test(i * chunk_size, chunk_size, n_workers);\n-      }\n-    }\n-  }\n-}\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_partialArrayTaskStepper.cpp","additions":0,"deletions":87,"binary":false,"changes":87,"status":"deleted"}]}