{"files":[{"patch":"@@ -42,8 +42,5 @@\n- * The user allocation is preceded by a header and is immediately followed by a (possibly unaligned)\n- *  footer canary:\n- *\n- * +--------------+-------------  ....  ------------------+-----+\n- * |    header    |               user                    | can |\n- * |              |             allocation                | ary |\n- * +--------------+-------------  ....  ------------------+-----+\n- *     16 bytes              user size                      2 byte\n+ * +--------------+-------------  ....  ------------------+\n+ * |    header    |               user                    |\n+ * |              |             allocation                |\n+ * +--------------+-------------  ....  ------------------+\n+ *     16 bytes              user size\n@@ -66,1 +63,1 @@\n- *  ...  |   malloc site table marker        | flags  | unused |     canary      |  ... User payload ....\n+ *  ...  |   malloc site table marker        |  tags  |         unused           |  ... User payload ....\n@@ -73,1 +70,1 @@\n- * |            alt. canary            |           32-bit size             |  ...\n+ * |                                32-bit size                            |  ...\n@@ -78,1 +75,1 @@\n- *  ...  |   malloc site table marker        | flags  | unused |     canary      |  ... User payload ....\n+ *  ...  |   malloc site table marker        |  tags  |          unused          |  ... User payload ....\n@@ -80,8 +77,0 @@\n- *\n- * Notes:\n- * - We have a canary in the two bytes directly preceding the user payload. That allows us to\n- *   catch negative buffer overflows.\n- * - On 32-bit, due to the smaller size_t, we have some bits to spare. So we also have a second\n- *   canary at the very start of the malloc header (generously sized 32 bits).\n- * - The footer canary consists of two bytes. Since the footer location may be unaligned to 16 bits,\n- *   the bytes are stored individually.\n@@ -96,9 +85,1 @@\n-  const uint8_t _unused;\n-  uint16_t _canary;\n-\n-  static const uint16_t _header_canary_live_mark = 0xE99E;\n-  static const uint16_t _header_canary_dead_mark = 0xD99D;\n-  static const uint16_t _footer_canary_live_mark = 0xE88E;\n-  static const uint16_t _footer_canary_dead_mark = 0xD88D;\n-  NOT_LP64(static const uint32_t _header_alt_canary_live_mark = 0xE99EE99E;)\n-  NOT_LP64(static const uint32_t _header_alt_canary_dead_mark = 0xD88DD88D;)\n+  const uint8_t _unused[3];\n@@ -111,6 +92,0 @@\n-  static uint16_t build_footer(uint8_t b1, uint8_t b2) { return (uint16_t)(((uint16_t)b1 << 8) | (uint16_t)b2); }\n-\n-  uint8_t* footer_address() const   { return ((address)this) + sizeof(MallocHeader) + _size; }\n-  uint16_t get_footer() const       { return build_footer(footer_address()[0], footer_address()[1]); }\n-  void set_footer(uint16_t v)       { footer_address()[0] = (uint8_t)(v >> 8); footer_address()[1] = (uint8_t)v; }\n-\n@@ -130,1 +105,1 @@\n-  inline static size_t malloc_overhead() { return sizeof(MallocHeader) + sizeof(uint16_t); }\n+  inline static size_t malloc_overhead() { return sizeof(MallocHeader); }\n@@ -139,9 +114,0 @@\n-  inline void mark_block_as_dead();\n-  inline void revive();\n-\n-\n-  bool is_dead() const { return _canary == _header_canary_dead_mark; }\n-  bool is_live() const { return _canary == _header_canary_live_mark; }\n-\n-  \/\/ Used for debugging purposes only. Check header if it could constitute a valid (live or dead) header.\n-  inline bool looks_valid() const;\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.hpp","additions":10,"deletions":44,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-    _unused(0), _canary(_header_canary_live_mark)\n+    _unused()\n@@ -42,4 +42,0 @@\n-  \/\/ On 32-bit we have some bits more, use them for a second canary\n-  \/\/ guarding the start of the header.\n-  NOT_LP64(_alt_canary = _header_alt_canary_live_mark;)\n-  set_footer(_footer_canary_live_mark); \/\/ set after initializing _size\n@@ -48,15 +44,0 @@\n-inline void MallocHeader::revive() {\n-  assert(_canary == _header_canary_dead_mark, \"must be dead\");\n-  assert(get_footer() == _footer_canary_dead_mark, \"must be dead\");\n-  NOT_LP64(assert(_alt_canary == _header_alt_canary_dead_mark, \"must be dead\"));\n-  _canary = _header_canary_live_mark;\n-  NOT_LP64(_alt_canary = _header_alt_canary_live_mark);\n-  set_footer(_footer_canary_live_mark);\n-}\n-\n-\/\/ The effects of this method must be reversible with MallocHeader::revive()\n-inline void MallocHeader::mark_block_as_dead() {\n-  _canary = _header_canary_dead_mark;\n-  NOT_LP64(_alt_canary = _header_alt_canary_dead_mark);\n-  set_footer(_footer_canary_dead_mark);\n-}\n@@ -119,10 +100,0 @@\n-\n-\/\/ Used for debugging purposes only. Check header if it could constitute a valid (live or dead) header.\n-inline bool MallocHeader::looks_valid() const {\n-  \/\/ Note: we define these restrictions loose enough to also catch moderately corrupted blocks.\n-  \/\/ E.g. we don't check footer canary.\n-  return ( (_canary == _header_canary_live_mark NOT_LP64(&& _alt_canary == _header_alt_canary_live_mark)) ||\n-           (_canary == _header_canary_dead_mark NOT_LP64(&& _alt_canary == _header_alt_canary_dead_mark)) ) &&\n-           _size > 0 && _size < max_reasonable_malloc_size;\n-}\n-\n@@ -133,16 +104,0 @@\n-  \/\/ Check header canary\n-  if (_canary != _header_canary_live_mark) {\n-    *p_corruption = (address)this;\n-    jio_snprintf(msg, msglen, \"header canary broken\");\n-    return false;\n-  }\n-\n-#ifndef _LP64\n-  \/\/ On 32-bit we have a second canary, check that one too.\n-  if (_alt_canary != _header_alt_canary_live_mark) {\n-    *p_corruption = (address)this;\n-    jio_snprintf(msg, msglen, \"header canary broken\");\n-    return false;\n-  }\n-#endif\n-\n@@ -155,8 +110,0 @@\n-\n-  \/\/ Check footer canary\n-  if (get_footer() != _footer_canary_live_mark) {\n-    *p_corruption = footer_address();\n-    jio_snprintf(msg, msglen, \"footer canary broken at \" PTR_FORMAT \" (buffer overflow?)\",\n-                 p2i(footer_address()));\n-    return false;\n-  }\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.inline.hpp","additions":1,"deletions":54,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -210,2 +210,0 @@\n-  header->mark_block_as_dead();\n-\n@@ -221,93 +219,0 @@\n-\n-\/\/ Given a pointer, look for the containing malloc block.\n-\/\/ Print the block. Note that since there is very low risk of memory looking\n-\/\/ accidentally like a valid malloc block header (canaries and all) so this is not\n-\/\/ totally failproof and may give a wrong answer. It is safe in that it will never\n-\/\/ crash, even when encountering unmapped memory.\n-bool MallocTracker::print_pointer_information(const void* p, outputStream* st) {\n-  assert(MemTracker::enabled(), \"NMT not enabled\");\n-\n-#if !INCLUDE_ASAN\n-\n-  address addr = (address)p;\n-\n-  \/\/ Carefully feel your way upwards and try to find a malloc header. Then check if\n-  \/\/ we are within the block.\n-  \/\/ We give preference to found live blocks; but if no live block had been found,\n-  \/\/ but the pointer points into remnants of a dead block, print that instead.\n-  const MallocHeader* likely_dead_block = nullptr;\n-  const MallocHeader* likely_live_block = nullptr;\n-  {\n-    const size_t smallest_possible_alignment = sizeof(void*);\n-    const uint8_t* here = align_down(addr, smallest_possible_alignment);\n-    const uint8_t* const end = here - (0x1000 + sizeof(MallocHeader)); \/\/ stop searching after 4k\n-    for (; here >= end; here -= smallest_possible_alignment) {\n-      \/\/ JDK-8306561: cast to a MallocHeader needs to guarantee it can reside in readable memory\n-      if (!os::is_readable_range(here, here + sizeof(MallocHeader))) {\n-        \/\/ Probably OOB, give up\n-        break;\n-      }\n-      const MallocHeader* const candidate = (const MallocHeader*)here;\n-      if (!candidate->looks_valid()) {\n-        \/\/ This is definitely not a header, go on to the next candidate.\n-        continue;\n-      }\n-\n-      \/\/ fudge factor:\n-      \/\/ We don't report blocks for which p is clearly outside of. That would cause us to return true and possibly prevent\n-      \/\/ subsequent tests of p, see os::print_location(). But if p is just outside of the found block, this may be a\n-      \/\/ narrow oob error and we'd like to know that.\n-      const int fudge = 8;\n-      const address start_block = (address)candidate;\n-      const address start_payload = (address)(candidate + 1);\n-      const address end_payload = start_payload + candidate->size();\n-      const address end_payload_plus_fudge = end_payload + fudge;\n-      if (addr >= start_block && addr < end_payload_plus_fudge) {\n-        \/\/ We found a block the pointer is pointing into, or almost into.\n-        \/\/ If its a live block, we have our info. If its a dead block, we still\n-        \/\/ may be within the borders of a larger live block we have not found yet -\n-        \/\/ continue search.\n-        if (candidate->is_live()) {\n-          likely_live_block = candidate;\n-          break;\n-        } else {\n-          likely_dead_block = candidate;\n-          continue;\n-        }\n-      }\n-    }\n-  }\n-\n-  \/\/ If we've found a reasonable candidate. Print the info.\n-  const MallocHeader* block = likely_live_block != nullptr ? likely_live_block : likely_dead_block;\n-  if (block != nullptr) {\n-    const char* where = nullptr;\n-    const address start_block = (address)block;\n-    const address start_payload = (address)(block + 1);\n-    const address end_payload = start_payload + block->size();\n-    if (addr < start_payload) {\n-      where = \"into header of\";\n-    } else if (addr < end_payload) {\n-      where = \"into\";\n-    } else {\n-      where = \"just outside of\";\n-    }\n-    st->print_cr(PTR_FORMAT \" %s %s malloced block starting at \" PTR_FORMAT \", size \" SIZE_FORMAT \", tag %s\",\n-                 p2i(p), where,\n-                 (block->is_dead() ? \"dead\" : \"live\"),\n-                 p2i(block + 1), \/\/ lets print the payload start, not the header\n-                 block->size(), NMTUtil::tag_to_enum_name(block->mem_tag()));\n-    if (MemTracker::tracking_level() == NMT_detail) {\n-      NativeCallStack ncs;\n-      if (MallocSiteTable::access_stack(ncs, *block)) {\n-        ncs.print_on(st);\n-        st->cr();\n-      }\n-    }\n-    return true;\n-  }\n-\n-#endif \/\/ !INCLUDE_ASAN\n-\n-  return false;\n-}\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.cpp","additions":0,"deletions":95,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -124,3 +124,1 @@\n-  return enabled() &&\n-      (MallocTracker::print_pointer_information(p, out) ||\n-       VirtualMemoryTracker::print_containing_region(p, out));\n+  return enabled() && VirtualMemoryTracker::print_containing_region(p, out);\n","filename":"src\/hotspot\/share\/nmt\/memTracker.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -730,2 +730,0 @@\n-    header->mark_block_as_dead();\n-\n@@ -737,2 +735,0 @@\n-      \/\/ We have however marked it as dead, revert this change.\n-      header->revive();\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,61 +53,0 @@\n-\/\/\/\/\/\/\/\n-\n-static void test_overwrite_front() {\n-  address p = (address) os::malloc(1, mtTest);\n-  *(p - 1) = 'a';\n-  os::free(p);\n-}\n-\n-DEFINE_TEST(test_overwrite_front, \"header canary broken\")\n-\n-\/\/\/\/\/\/\/\n-\n-static void test_overwrite_back() {\n-  address p = (address) os::malloc(1, mtTest);\n-  *(p + 1) = 'a';\n-  os::free(p);\n-}\n-\n-DEFINE_TEST(test_overwrite_back, \"footer canary broken\")\n-\n-\/\/\/\/\/\/\/\n-\n-\/\/ A overwrite farther away from the NMT header; the report should show the hex dump split up\n-\/\/ in two parts, containing both header and corruption site.\n-static void test_overwrite_back_long(size_t distance) {\n-  address p = (address) os::malloc(distance, mtTest);\n-  *(p + distance) = 'a';\n-  os::free(p);\n-}\n-static void test_overwrite_back_long_aligned_distance()   { test_overwrite_back_long(0x2000); }\n-DEFINE_TEST(test_overwrite_back_long_aligned_distance, \"footer canary broken\")\n-static void test_overwrite_back_long_unaligned_distance() { test_overwrite_back_long(0x2001); }\n-DEFINE_TEST(test_overwrite_back_long_unaligned_distance, \"footer canary broken\")\n-\n-\/\/\/\/\/\/\/\n-\n-static void test_double_free() {\n-  address p = (address) os::malloc(1, mtTest);\n-  os::free(p);\n-  \/\/ Now a double free. Note that this is susceptible to concurrency issues should\n-  \/\/ a concurrent thread have done a malloc and gotten the same address after the\n-  \/\/ first free. To decrease chance of this happening, we repeat the double free\n-  \/\/ several times.\n-  for (int i = 0; i < 100; i ++) {\n-    os::free(p);\n-  }\n-}\n-\n-\/\/ What assertion message we will see depends on whether the VM wipes the memory-to-be-freed\n-\/\/ on the first free(), and whether the libc uses the freed memory to store bookkeeping information.\n-\/\/ If the death marker in the header is still intact after the first free, we will recognize this as\n-\/\/ double free; if it got wiped, we should at least see a broken header canary.\n-\/\/ The message would be either\n-\/\/ - \"header canary broken\" or\n-\/\/ - \"header canary dead (double free?)\".\n-\/\/ However, since gtest regex expressions do not support unions (a|b), I search for a reasonable\n-\/\/ subset here.\n-DEFINE_TEST(test_double_free, \"header canary\")\n-\n-\/\/\/\/\/\/\/\n-\n@@ -120,2 +59,0 @@\n-\/\/\/\/\/\/\/\n-\n@@ -128,20 +65,0 @@\n-\/\/\/\/\/\/\/\n-\n-\/\/ Test that we notice block corruption on realloc too\n-static void test_corruption_on_realloc(size_t s1, size_t s2) {\n-  address p1 = (address) os::malloc(s1, mtTest);\n-  *(p1 + s1) = 'a';\n-  address p2 = (address) os::realloc(p1, s2, mtTest);\n-\n-  \/\/ Still here?\n-  tty->print_cr(\"NMT did not detect corruption on os::realloc?\");\n-  \/\/ Note: don't use ASSERT here, that does not work as expected in death tests. Just\n-  \/\/ let the test run its course, it should notice something is amiss.\n-}\n-static void test_corruption_on_realloc_growing()    { test_corruption_on_realloc(0x10, 0x11); }\n-DEFINE_TEST(test_corruption_on_realloc_growing, COMMON_NMT_HEAP_CORRUPTION_MESSAGE_PREFIX);\n-static void test_corruption_on_realloc_shrinking()  { test_corruption_on_realloc(0x11, 0x10); }\n-DEFINE_TEST(test_corruption_on_realloc_shrinking, COMMON_NMT_HEAP_CORRUPTION_MESSAGE_PREFIX);\n-\n-\/\/\/\/\/\/\/\n-\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_buffer_overflow_detection.cpp","additions":0,"deletions":83,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -150,13 +150,0 @@\n-\n-TEST_VM(NMT, HeaderKeepsIntegrityAfterRevival) {\n-  if (!MemTracker::enabled()) {\n-    return;\n-  }\n-  size_t some_size = 16;\n-  void* p = os::malloc(some_size, mtTest);\n-  ASSERT_NOT_NULL(p) << \"Failed to malloc()\";\n-  MallocHeader* hdr = MallocTracker::malloc_header(p);\n-  hdr->mark_block_as_dead();\n-  hdr->revive();\n-  check_expected_malloc_header(p, mtTest, some_size);\n-}\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_cornercases.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -51,65 +51,0 @@\n-static void test_for_live_c_heap_block(size_t sz, ssize_t offset) {\n-  char* c = NEW_C_HEAP_ARRAY(char, sz, mtTest);\n-  LOG_HERE(\"C-block starts \" PTR_FORMAT \", size \" SIZE_FORMAT \".\", p2i(c), sz);\n-  memset(c, 0, sz);\n-  if (MemTracker::enabled()) {\n-    const char* expected_string = \"into live malloced block\";\n-    if (offset < 0) {\n-      expected_string = \"into header of live malloced block\";\n-    } else if ((size_t)offset >= sz) {\n-      expected_string = \"just outside of live malloced block\";\n-    }\n-    test_pointer(c + offset, true, expected_string);\n-  } else {\n-    \/\/ NMT disabled: we should see nothing.\n-    test_pointer(c + offset, false, \"\");\n-  }\n-  FREE_C_HEAP_ARRAY(char, c);\n-}\n-\n-#ifdef LINUX\n-static void test_for_dead_c_heap_block(size_t sz, ssize_t offset) {\n-  if (!MemTracker::enabled()) {\n-    return;\n-  }\n-  char* c = NEW_C_HEAP_ARRAY(char, sz, mtTest);\n-  LOG_HERE(\"C-block starts \" PTR_FORMAT \", size \" SIZE_FORMAT \".\", p2i(c), sz);\n-  memset(c, 0, sz);\n-  \/\/ We cannot just free the allocation to try dead block printing, since the memory\n-  \/\/ may be immediately reused by concurrent code. Instead, we mark the block as dead\n-  \/\/ manually, and revert that before freeing it.\n-  MallocHeader* const hdr = MallocHeader::resolve_checked(c);\n-  hdr->mark_block_as_dead();\n-\n-  const char* expected_string = \"into dead malloced block\";\n-  if (offset < 0) {\n-    expected_string = \"into header of dead malloced block\";\n-  } else if ((size_t)offset >= sz) {\n-    expected_string = \"just outside of dead malloced block\";\n-  }\n-\n-  test_pointer(c + offset, true, expected_string);\n-\n-  hdr->revive();\n-  FREE_C_HEAP_ARRAY(char, c);\n-}\n-#endif\n-\n-TEST_VM(NMT, location_printing_cheap_live_1) { test_for_live_c_heap_block(2 * K, 0); }              \/\/ start of payload\n-TEST_VM(NMT, location_printing_cheap_live_2) { test_for_live_c_heap_block(2 * K, -7); }             \/\/ into header\n-TEST_VM(NMT, location_printing_cheap_live_3) { test_for_live_c_heap_block(2 * K, K + 1); }          \/\/ into payload\n-TEST_VM(NMT, location_printing_cheap_live_4) { test_for_live_c_heap_block(2 * K, K + 2); }          \/\/ into payload (check for even\/odd errors)\n-TEST_VM(NMT, location_printing_cheap_live_5) { test_for_live_c_heap_block(2 * K + 1, 2 * K + 2); }  \/\/ just outside payload\n-TEST_VM(NMT, location_printing_cheap_live_6) { test_for_live_c_heap_block(4, 0); }                  \/\/ into a very small block\n-TEST_VM(NMT, location_printing_cheap_live_7) { test_for_live_c_heap_block(4, 4); }                  \/\/ just outside a very small block\n-\n-#ifdef LINUX\n-TEST_VM(NMT, DISABLED_location_printing_cheap_dead_1) { test_for_dead_c_heap_block(2 * K, 0); }              \/\/ start of payload\n-TEST_VM(NMT, DISABLED_location_printing_cheap_dead_2) { test_for_dead_c_heap_block(2 * K, -7); }             \/\/ into header\n-TEST_VM(NMT, DISABLED_location_printing_cheap_dead_3) { test_for_dead_c_heap_block(2 * K, K + 1); }          \/\/ into payload\n-TEST_VM(NMT, DISABLED_location_printing_cheap_dead_4) { test_for_dead_c_heap_block(2 * K, K + 2); }          \/\/ into payload (check for even\/odd errors)\n-TEST_VM(NMT, DISABLED_location_printing_cheap_dead_5) { test_for_dead_c_heap_block(2 * K + 1, 2 * K + 2); }  \/\/ just outside payload\n-TEST_VM(NMT, DISABLED_location_printing_cheap_dead_6) { test_for_dead_c_heap_block(4, 0); }                  \/\/ into a very small block\n-TEST_VM(NMT, DISABLED_location_printing_cheap_dead_7) { test_for_dead_c_heap_block(4, 4); }                  \/\/ just outside a very small block\n-#endif\n-\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_locationprinting.cpp","additions":0,"deletions":65,"binary":false,"changes":65,"status":"modified"}]}