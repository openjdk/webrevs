{"files":[{"patch":"@@ -7258,0 +7258,52 @@\n+  \/\/ Poly1305, vectorized\n+\n+  \/\/ Vectorizing Poly1305 is quite tricky. We already have a highly-\n+  \/\/ efficient scalar Poly1305 implementation that runs on the core integer\n+  \/\/ unit, but it's highly serialized, so it does not make make good use of\n+  \/\/ the parallelism available.\n+\n+  \/\/ The scalar implementation takes advantage of some particular features\n+  \/\/ of the Poly1305 keys. In particular, certain bits of r, the secret\n+  \/\/ key, are required to be 0. These make it possible to use a full\n+  \/\/ 64-bit-wide multiply-accumulate operation without needing to process\n+  \/\/ carries between partial products,\n+\n+  \/\/ While this works well for a serial implementation, a parallel\n+  \/\/ implementation cannot do this because rather than multiplying by r,\n+  \/\/ each step multiplies by some integer power of r, modulo\n+  \/\/ 2^130-5. Here we process six message blocks in parallel.\n+\n+  \/\/ In order to avoid processing carries between partial products we use a\n+  \/\/ redundant representation, in which each 130-bit integer is encoded\n+  \/\/ either as a 5-digit integer in base 2^26 or as a 3-digit integer in\n+  \/\/ base 2^52, depending on whether we are using a 64- or 32-bit\n+  \/\/ multiply-accumulate.\n+\n+  \/\/ In AArch64 Advanced SIMD, there is no 64-bit multiply-accumulate\n+  \/\/ operation available to us, so we must use 32*32 -> 64-bit operations.\n+\n+  \/\/ In order to achieve maximum performance we'd like to get close to the\n+  \/\/ processor's decode bandwidth, so that every clock cycle does something\n+  \/\/ useful. In a typical high-end AArch64 implementation, the core integer\n+  \/\/ unit has a fast 64-bit multiplier pipeline and the ASIMD unit has a\n+  \/\/ fast(ish) two-way 32-bit multiplier, which may be slower than than the\n+  \/\/ core integer unit's. It is not at all obvious whether it's best to use\n+  \/\/ ASIMD or core instructions.\n+\n+  \/\/ Fortunately, if we have a wide-bandwidth instruction decode, we can do\n+  \/\/ both at the same time, by feeding alternating instructions to the core\n+  \/\/ and the ASIMD units. This also allows us to make good use of all of\n+  \/\/ the available core and ASIMD registers, in parallel.\n+\n+  \/\/ To do this we use generators, which here are a kind of iterator that\n+  \/\/ emits a group of instructions each time it is called. In this case we\n+  \/\/ 4 parallel generators, and by calling them alternately we interleave\n+  \/\/ the ASIMD and the core instructions. We also take care to ensure that\n+  \/\/ each generator finishes at about the same time, to maximize the\n+  \/\/ distance between instructions which generate and consume data.\n+\n+  \/\/ See Goll and Gueron, ‘Vectorization of Poly1305 message\n+  \/\/ authentication code’. 2015 12th Int. Conf. on Information\n+  \/\/ Technology – New Generations, Las Vegas, NV, USA, April 2015,\n+  \/\/ pp. 145–150, doi: 10.1109\/ITNG.2015.28\n+\n@@ -7266,1 +7318,1 @@\n-      _regs[i] = *it++;\n+\t_regs[i] = *it++;\n@@ -7284,2 +7336,2 @@\n-      RegPair r(*it++, *it++);\n-      _reg_pairs[i] = r;\n+\tRegPair r(*it++, *it++);\n+\t_reg_pairs[i] = r;\n@@ -7307,3 +7359,0 @@\n-  auto regs = (RegSet::range(c_rarg0, r28) - r18_tls - rscratch1 - rscratch2 + lr).begin();\n-  auto vregs = (vRegSet::range(v0, v7) + vRegSet::range(v16, v31)).begin();\n-\n@@ -7311,1 +7360,4 @@\n-  const Register input_start = *regs++, length = *regs++, acc_start = *regs++, r_start = *regs++;\n+  const Register input_start = c_rarg0, length = c_rarg1, acc_start = c_rarg2, r_start = c_rarg3;\n+\n+  auto regs = (RegSet::range(c_rarg4, r28) - r18_tls - rscratch1 - rscratch2 + lr).begin();\n+  auto vregs = (vRegSet::range(v0, v7) + vRegSet::range(v16, v31)).begin();\n@@ -7412,48 +7464,45 @@\n-      \/\/ __ poly1305_load(S0, input_start);\n-      \/\/ __ poly1305_load(S1, input_start);\n-\n-      constexpr int COLS = 4;\n-      AsmGenerator gen[COLS];\n-\n-      __ poly1305_step(gen[0], S0, u0, input_start);\n-      __ poly1305_field_multiply(gen[0], u0, S0, R, RR2, regs);\n-\n-      __ poly1305_step(gen[1], S1, u1, input_start);\n-      __ poly1305_field_multiply(gen[1], u1, S1, R, RR2, regs);\n-\n-      __ poly1305_step_vec(gen[2], v_s0, v_u0, zero, input_start);\n-      __ poly1305_field_multiply(gen[2], v_u0, v_s0, r_v, rr_v, zero,\n-                                 vregs.remaining());\n-\n-      __ poly1305_step_vec(gen[3], v_s1, v_u1, zero, input_start);\n-      __ poly1305_field_multiply(gen[3], v_u1, v_s1, r_v, rr_v, zero,\n-                                 vregs.remaining());\n-\n-      AsmGenerator::Iterator it[COLS];\n-      int len[COLS];\n-\n-      int l_max = INT_MIN;\n-      for (int col = 0; col < COLS; col++) {\n-        it[col] = gen[col].iterator();\n-        len[col] = gen[col].length();\n-        l_max = MAX2(l_max, len[col]);\n-      }\n-\n-      int err[COLS];\n-      for (int col = 0; col < COLS; col++) {\n-        err[col] = 0;\n-      }\n-\n-      for (int i = 0; i < l_max; i++) {\n-        for (int col = 0; col < COLS; col++) {\n-          err[col] -= len[col];\n-          if (err[col] < 0) {\n-            err[col] += l_max;\n-            (it[col]++)();\n-          }\n-        }\n-      }\n-\n-      for (int col = 0; col < COLS; col++) {\n-        assert(*(it[col]) == nullptr, \"Make sure all generators are exhausted\");\n-      }\n+\tconstexpr int COLS = 4;\n+\tAsmGenerator gen[COLS];\n+\n+\t__ poly1305_step(gen[0], S0, u0, input_start);\n+\t__ poly1305_field_multiply(gen[0], u0, S0, R, RR2, regs);\n+\n+\t__ poly1305_step(gen[1], S1, u1, input_start);\n+\t__ poly1305_field_multiply(gen[1], u1, S1, R, RR2, regs);\n+\n+\t__ poly1305_step_vec(gen[2], v_s0, v_u0, zero, input_start);\n+\t__ poly1305_field_multiply(gen[2], v_u0, v_s0, r_v, rr_v, zero,\n+\t\t\t\t   vregs.remaining());\n+\n+\t__ poly1305_step_vec(gen[3], v_s1, v_u1, zero, input_start);\n+\t__ poly1305_field_multiply(gen[3], v_u1, v_s1, r_v, rr_v, zero,\n+\t\t\t\t   vregs.remaining());\n+\n+\tAsmGenerator::Iterator it[COLS];\n+\tint len[COLS];\n+\n+\tint l_max = INT_MIN;\n+\tfor (int col = 0; col < COLS; col++) {\n+\t  it[col] = gen[col].iterator();\n+\t  len[col] = gen[col].length();\n+\t  l_max = MAX2(l_max, len[col]);\n+\t}\n+\n+\tint err[COLS];\n+\tfor (int col = 0; col < COLS; col++) {\n+\t  err[col] = 0;\n+\t}\n+\n+\tfor (int i = 0; i < l_max; i++) {\n+\t  for (int col = 0; col < COLS; col++) {\n+\t    err[col] -= len[col];\n+\t    if (err[col] < 0) {\n+\t      err[col] += l_max;\n+\t      (it[col]++)();\n+\t    }\n+\t  }\n+\t}\n+\n+\tfor (int col = 0; col < COLS; col++) {\n+\t  assert(*(it[col]) == nullptr, \"Make sure all generators are exhausted\");\n+\t}\n@@ -7543,1 +7592,1 @@\n-  \/\/ __ reset_last_Java_frame(true);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":105,"deletions":56,"binary":false,"changes":161,"status":"modified"}]}