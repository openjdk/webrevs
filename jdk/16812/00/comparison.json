{"files":[{"patch":"@@ -2574,0 +2574,5 @@\n+  INSN1(ld1, 0b001101010, 0b0000);\n+  INSN2(ld2, 0b001101011, 0b0000);\n+  INSN3(ld3, 0b001101010, 0b0010);\n+  INSN4(ld4, 0b001101011, 0b0010);\n+\n@@ -2732,0 +2737,2 @@\n+  INSN(add, 0, 1, 0b100001);\n+  INSN(sub, 1, 1, 0b100001);\n@@ -2875,1 +2882,3 @@\n-#define INSN(NAME, op1, op2) \\\n+  \/\/ Advanced SIMD vector x indexed element\n+\n+#define INSN(NAME, op1, op2)                                                               \\\n@@ -2892,0 +2901,34 @@\n+#undef INSN\n+\n+\/\/ NB: When using Arrangement T4S, Vm is restricted to v0-v15\n+#define INSN(NAME, opc, upper, U)                                                          \\\n+  void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm, int index) { \\\n+    starti;                                                                                \\\n+    f(0, 31); f(upper, 30); f(U, 29); f(0b01111,28, 24);                                   \\\n+    switch(T) {                                                                            \\\n+      case T4S: {                                                                          \\\n+        f(0b01, 23, 22);                                                                   \\\n+        int H = index >> 2, L = (index >> 1) & 1, M = index & 1;                           \\\n+        f(H, 11); f(L, 21); f(M, 20);                                                      \\\n+        f(Vm->encoding(), 19, 16);                                                         \\\n+        break;                                                                             \\\n+      }                                                                                    \\\n+      case T2D: {                                                                          \\\n+        f(0b10, 23, 22);                                                                   \\\n+        int H = index >> 1, L = index & 1;                                                 \\\n+        f(H, 11); f(L, 21);                                                                \\\n+        rf(Vm, 16);                                                                        \\\n+        break;                                                                             \\\n+      }                                                                                    \\\n+      default:                                                                             \\\n+        ShouldNotReachHere();                                                              \\\n+    }                                                                                      \\\n+    f(opc, 15, 12); f(0, 10);                                                              \\\n+    rf(Vn, 5); rf(Vd, 0);                                                                  \\\n+  }\n+\n+  INSN(umull, 0b1010, false, 1);\n+  INSN(umull2, 0b1010, true, 1);\n+  INSN(umlal, 0b0010, false, 1);\n+  INSN(umlal2, 0b0010, true, 1);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":44,"deletions":1,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -37,0 +37,80 @@\n+class AsmGenerator {\n+public:\n+\n+  class WrapperNode: public ResourceObj {\n+  public:\n+    WrapperNode * _next;\n+    virtual void operator()() = 0;\n+  };\n+\n+  template <typename T>\n+  class LambdaWrapper : public WrapperNode {\n+  public:\n+    T _t;\n+    LambdaWrapper(T t): _t(t) {}\n+    virtual void operator()() {\n+      _t();\n+    }\n+  };\n+\n+  WrapperNode *_holder_list_head, *_last;\n+  int _count;\n+\n+  AsmGenerator()\n+    : _holder_list_head(nullptr), _last(nullptr), _count(0) {}\n+\n+  WrapperNode *last() {\n+    return _last;\n+  }\n+\n+  template<typename T>\n+  WrapperNode *operator<<(T t) {\n+    auto vv = new LambdaWrapper<decltype(t)>(t);\n+    if (_count > 0)\n+      last()->_next = vv;\n+    else\n+      _holder_list_head = vv;\n+    vv->_next = nullptr;\n+    _count++;\n+    _last = vv;\n+    return vv;\n+  }\n+\n+  virtual int length() { return _count; }\n+\n+  struct Iterator {\n+    WrapperNode *_next;\n+    Iterator(AsmGenerator *gen): _next(gen->_holder_list_head) { }\n+    Iterator(): _next(nullptr) { }\n+\n+    Iterator& operator++() {\n+      if (_next)\n+        _next = _next->_next;\n+      return *this;\n+    }\n+\n+    Iterator operator++(int) {\n+      auto result(*this);\n+      operator++();\n+      return result;\n+    }\n+\n+    WrapperNode *operator*() { return _next; }\n+\n+    void operator()() {\n+      if (_next)\n+        (*_next)();\n+    }\n+  };\n+\n+  Iterator iterator() {\n+    return Iterator(this);\n+  }\n+\n+  void gen() {\n+    for (auto it = iterator(); *it; it++) {\n+      it();\n+    }\n+  }\n+};\n+\n@@ -39,0 +119,12 @@\n+class RegPair {\n+public:\n+  Register _lo, _hi;\n+  RegPair() : _lo(noreg), _hi(noreg) { }\n+  RegPair(Register r1, Register r2) : _lo(r1), _hi(r2) { }\n+  RegPair(const RegPair &pair) : _lo(pair._lo), _hi(pair._hi) { }\n+  RegPair& operator=(const RegPair &other) {\n+    _lo = other._lo, _hi = other._hi;\n+    return *this;\n+  };\n+};\n+\n@@ -50,0 +142,1 @@\n+  using Assembler::umull;\n@@ -157,0 +250,1 @@\n+  \/\/ using Assembler::add;\n@@ -158,1 +252,0 @@\n-  using Assembler::str;\n@@ -160,0 +253,1 @@\n+  using Assembler::str;\n@@ -246,0 +340,7 @@\n+  inline void bfc(Register Rd, unsigned lsb, unsigned width) {\n+    bfi(Rd, zr, lsb, width);\n+  }\n+  inline void bfcw(Register Rd, unsigned lsb, unsigned width) {\n+    bfiw(Rd, zr, lsb, width);\n+  }\n+\n@@ -1611,1 +1712,105 @@\n-private:\n+  \/\/ Poly1305\n+\n+  void pack_26(Register dest0, Register dest1, Register dest2, Register src);\n+  void wide_mul(RegPair prod, Register n, Register m);\n+  void wide_madd(RegPair sum, Register n, Register m);\n+  void clear_above(const RegPair d, int shift);\n+  void shifted_add128(const RegPair d, const RegPair s, unsigned int shift,\n+                      Register scratch = rscratch1);\n+  \/\/ Widening multiply s * r -> u\n+  void poly1305_multiply(AsmGenerator &acc,\n+                         const RegPair u[], const Register s[], const Register r[],\n+                         Register RR2, RegSetIterator<Register> scratch);\n+  \/\/ Multiply mod 2**130-5\n+  void poly1305_field_multiply(AsmGenerator &acc,\n+                               const RegPair u[], const Register s[],\n+                               const Register r[],\n+                               Register RR2, RegSetIterator<Register> scratch);\n+  void poly1305_field_multiply(const RegPair u[], const Register s[],\n+                               const Register r[],\n+                               Register RR2, RegSetIterator<Register> scratch) {\n+    AsmGenerator acc;\n+    poly1305_field_multiply(acc, u, s, r, RR2, scratch);\n+    acc.gen();\n+  }\n+\n+  void poly1305_multiply_vec(AsmGenerator &acc,\n+                             const FloatRegister u[], const FloatRegister m[],\n+                             const FloatRegister r[], const FloatRegister rr[]);\n+  void poly1305_multiply(const RegPair u[], const Register s[], const Register r[],\n+                         Register RR2, RegSetIterator<Register> scratch) {\n+    AsmGenerator acc;\n+    poly1305_multiply(acc, u, s, r, RR2, scratch);\n+    acc.gen();\n+  }\n+  void poly1305_multiply_vec(const FloatRegister u[], const FloatRegister m[],\n+                             const FloatRegister r[], const FloatRegister rr[]) {\n+    AsmGenerator acc;\n+    poly1305_multiply_vec(acc, u, m, r, rr);\n+    acc.gen();\n+  }\n+\n+  void poly1305_step_vec(AsmGenerator &acc,\n+                         const FloatRegister s[], const FloatRegister u[],\n+                         const FloatRegister zero, Register input_start);\n+  void poly1305_multiply_vec(AsmGenerator &acc,\n+                           const FloatRegister u_v[],\n+                           AbstractRegSet<FloatRegister> remaining,\n+                           const FloatRegister s_v[],\n+                           const FloatRegister r_v[],\n+                           const FloatRegister rr_v[]);\n+  void poly1305_reduce_vec(AsmGenerator &acc,\n+                           const FloatRegister u[],\n+                           const FloatRegister upper_bits,\n+                           AbstractRegSet<FloatRegister> scratch);\n+  void poly1305_field_multiply (AsmGenerator &acc,\n+                                const FloatRegister u[],\n+                                const FloatRegister s[],\n+                                const FloatRegister r[],\n+                                const FloatRegister rr[],\n+                                const FloatRegister zero,\n+                                AbstractRegSet<FloatRegister> scratch) {\n+    poly1305_multiply_vec(acc, u, s, r, rr);\n+    poly1305_reduce_vec(acc, u, zero, scratch);\n+  }\n+\n+  void poly1305_load(AsmGenerator &acc, const Register s[],\n+                     const Register input_start);\n+  void poly1305_load(const Register s[], const Register input_start) {\n+    AsmGenerator acc;\n+    poly1305_load(acc, s, input_start);\n+    acc.gen();\n+  }\n+  void poly1305_step(AsmGenerator &acc, const Register s[], const RegPair u[], const Register input_start);\n+  void poly1305_step(const Register s[], const RegPair u[], const Register input_start) {\n+    AsmGenerator acc;\n+    poly1305_step(acc, s, u, input_start);\n+    acc.gen();\n+  }\n+  void poly1305_add(const Register dest[], const RegPair src[]);\n+  void poly1305_add(AsmGenerator &acc,\n+                    const Register dest[], const RegPair src[]);\n+\n+  void mov26(FloatRegister d, Register s, int lsb);\n+  void expand26(Register d, Register r);\n+  void split26(const FloatRegister d[], Register s);\n+  void copy_3_to_5_regs(const FloatRegister d[],\n+                        const Register s0, const Register s1, const Register s2);\n+  void copy_3_regs_to_5_elements(const FloatRegister d[],\n+                                 const Register s0, const Register s1, const Register s2);\n+\n+  void poly1305_reduce(AsmGenerator &acc, const RegPair u[], const char *s = nullptr);\n+  void poly1305_reduce(const RegPair u[]) {\n+    AsmGenerator acc;\n+    poly1305_reduce(acc, u, \"redc\");\n+    acc.gen();\n+  }\n+  void poly1305_reduce_step(AsmGenerator &acc,\n+                            FloatRegister d, FloatRegister s, FloatRegister upper_bits, FloatRegister scratch);\n+  void poly1305_fully_reduce(Register dest[], const RegPair u[]);\n+  void poly1305_transfer(const RegPair d[], const FloatRegister s[],\n+                         int lane, FloatRegister vscratch);\n+  void copy_3_regs(const Register dest[], const Register src[]);\n+  void add_3_reg_pairs(const RegPair dest[], const RegPair src[]);\n+\n+ private:\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":207,"deletions":2,"binary":false,"changes":209,"status":"modified"},{"patch":"@@ -0,0 +1,406 @@\n+\/*\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include <sys\/types.h>\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/assembler.hpp\"\n+#include \"asm\/assembler.inline.hpp\"\n+#include \"macroAssembler_aarch64.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+\n+void MacroAssembler::pack_26(Register dest0, Register dest1, Register dest2, Register src) {\n+  ldp(dest0, rscratch1, Address(src, 0));\n+  orr(dest0, dest0, rscratch1, Assembler::LSL, 26);\n+\n+  ldp(dest1, rscratch1, Address(src, 2 * sizeof (jlong)));\n+  orr(dest1, dest1, rscratch1, Assembler::LSL, 26);\n+\n+  ldr(dest2, Address(src, 4 * sizeof (jlong)));\n+}\n+\n+void MacroAssembler::wide_mul(RegPair prod, Register n, Register m) {\n+  mul(prod._lo, n, m);\n+  umulh(prod._hi, n, m);\n+}\n+void MacroAssembler::wide_madd(RegPair sum, Register n, Register m) {\n+  wide_mul(RegPair(rscratch1, rscratch2), n, m);\n+  adds(sum._lo, sum._lo, rscratch1);\n+  adc(sum._hi, sum._hi, rscratch2);\n+}\n+\n+void MacroAssembler::poly1305_transfer(const RegPair u0[],\n+                                       const FloatRegister s[], int index,\n+                                       FloatRegister vscratch) {\n+  shl(vscratch, T2D, s[1], 26);\n+  Assembler::add(vscratch, T2D, s[0], vscratch);\n+  umov(u0[0]._lo, vscratch, D, index);\n+\n+  shl(vscratch, T2D, s[3], 26);\n+  Assembler::add(vscratch, T2D, s[2], vscratch);\n+  umov(u0[1]._lo, vscratch, D, index);\n+\n+  umov(u0[2]._lo, s[4], D, index);\n+}\n+\n+\/\/ Compute d += s >> shift\n+void MacroAssembler::shifted_add128(const RegPair d, const RegPair s, unsigned int shift,\n+                                    Register scratch) {\n+  extr(scratch, s._hi, s._lo, shift);\n+  adds(d._lo, d._lo, scratch);\n+  lsr(scratch, s._hi, shift);\n+  adc(d._hi, d._hi, scratch);\n+}\n+\n+void MacroAssembler::clear_above(const RegPair d, int shift) {\n+  bfc(d._lo, shift, 64-shift);\n+  mov(d._hi, 0);\n+}\n+\n+void MacroAssembler::poly1305_fully_reduce(Register dest[], const RegPair u[]) {\n+  \/\/ Fully reduce modulo 2^130 - 5\n+  adds(u[0]._lo, u[0]._lo, u[1]._lo, LSL, 52);\n+  lsr(u[1]._lo, u[1]._lo, 12);\n+  lsl(rscratch1, u[2]._lo, 40);\n+  adcs(u[1]._lo, u[1]._lo, rscratch1);\n+  lsr(u[2]._lo, u[2]._lo, 24);\n+  adc(u[2]._lo, u[2]._lo, zr);\n+\n+  \/\/ Subtract 2^130 - 5\n+  \/\/ = 0x3_ffffffffffffffff_fffffffffffffffb\n+  mov(rscratch1, 0xfffffffffffffffb); subs(dest[0], u[0]._lo, rscratch1);\n+  mov(rscratch1, 0xffffffffffffffff); sbcs(dest[1], u[1]._lo, rscratch1);\n+  mov(rscratch1, 0x3);                sbcs(dest[2], u[2]._lo, rscratch1);\n+  csel(dest[0], dest[0], u[0]._lo, HS);\n+  csel(dest[1], dest[1], u[1]._lo, HS);\n+  csel(dest[2], dest[2], u[2]._lo, HS);\n+}\n+\n+void MacroAssembler::mov26(FloatRegister d, Register s, int lsb) {\n+  ubfx(rscratch1, s, lsb, 26);\n+  mov(d, S, 0, rscratch1);\n+}\n+void MacroAssembler::expand26(Register d, Register r) {\n+  lsr(d, r, 26);\n+  lsl(d, d, 32);\n+  bfxil(d, r, 0, 26);\n+}\n+\n+void MacroAssembler::split26(const FloatRegister d[], Register s) {\n+  ubfx(rscratch1, s, 0, 26);\n+  mov(d[0], D, 0, rscratch1);\n+  lsr(rscratch1, s, 26);\n+  mov(d[1], D, 0, rscratch1);\n+}\n+\n+void MacroAssembler::copy_3_to_5_regs(const FloatRegister d[],\n+                                 const Register s0, const Register s1, const Register s2) {\n+  split26(&d[0], s0);\n+  split26(&d[2], s1);\n+  mov(d[4], D, 0, s2);\n+}\n+\n+void MacroAssembler::copy_3_regs_to_5_elements(const FloatRegister d[],\n+                                 const Register s0, const Register s1, const Register s2) {\n+  expand26(rscratch2, s0);\n+  mov(d[0], D, 0, rscratch2);\n+  expand26(rscratch2, s1);\n+  mov(d[0], D, 1, rscratch2);\n+  mov(d[1], D, 0, s2);\n+}\n+\n+void MacroAssembler::copy_3_regs(const Register dest[], const Register src[]) {\n+  for (int i = 0; i < 3; i++) {\n+    mov(dest[i], src[i]);\n+  }\n+}\n+\n+void MacroAssembler::add_3_reg_pairs(const RegPair dest[], const RegPair src[]) {\n+  for (int i = 0; i < 3; i++) {\n+    adds(dest[i]._lo, dest[i]._lo, src[i]._lo);\n+    adc(dest[i]._hi, dest[i]._hi, src[i]._hi);\n+  }\n+}\n+\n+void MacroAssembler::poly1305_add(const Register dest[], const RegPair src[]) {\n+  add(dest[0], dest[0], src[0]._lo);\n+  add(dest[1], dest[1], src[1]._lo);\n+  add(dest[2], dest[2], src[2]._lo);\n+}\n+\n+\/\/ Poly1305 Generator functions\n+\/\/\n+\n+\/\/ All of these take an AsmGenerator as their first parameter. They do\n+\/\/ not generate any code, but instead add to the AsmGenerator such\n+\/\/ that, when AsmGenerator.gen() is called later, code is generated.\n+\n+#define _ acc << [=]()\n+\/\/ Widening multiply s * r -> u\n+void MacroAssembler::poly1305_multiply(AsmGenerator &acc,\n+                                       const RegPair u[], const Register s[], const Register r[],\n+                                       Register RR2, RegSetIterator<Register> scratch) {\n+  _ { wide_mul(u[0], s[0], r[0]); };\n+  _ { wide_mul(u[2], s[0], r[2]); };\n+  _ { wide_madd(u[0], s[1], RR2); };\n+  {\n+    Register RS2 = *scratch++;\n+    _ {\n+      \/\/ Compute (S2 << 26) * 5.\n+      lsl(RS2, s[2], 26);\n+      add(RS2, RS2, RS2, LSL, 2);\n+      wide_mul(u[1], RS2, r[2]);\n+      wide_madd(u[0], RS2, r[1]);\n+    };\n+  }\n+  _ { wide_madd(u[1], s[0], r[1]); };\n+  _ { wide_madd(u[2], s[1], r[1]); };\n+  _ { wide_madd(u[1], s[1], r[0]); };\n+  _ { wide_madd(u[2], s[2], r[0]); };\n+}\n+\n+void MacroAssembler::poly1305_reduce(AsmGenerator &acc, const RegPair u[], const char *s) {\n+#define _ acc << [=]()\n+  \/\/ Partial reduction mod 2**130 - 5\n+\n+  \/\/ Assume:\n+  \/\/ u[2] < 0x200000000000_0000000000000000 (i.e. 109 bits)\n+  \/\/ u[1] < 0x200000000000_0000000000000000 (i.e. 109 bits)\n+  \/\/ u[0] < 0x200000000000_0000000000000000 (i.e. 109 bits)\n+\n+  \/\/ This follows from the inputs to the 3x3 multiplication all being\n+  \/\/ < 54 bits long.\n+\n+  \/\/ Add the high part (i.e. everything from bits 52 up) of u1 to u2\n+  _ { shifted_add128(u[2], u[1], 52); };\n+  _ { clear_above(u[1], 52); };                       \/\/ u[1] < 0x10000000000000 (i.e. 52 bits)\n+\n+  \/\/ Add the high part of u0 to u1\n+  _ { shifted_add128(u[1], u[0], 52); };\n+  _ { clear_above(u[0], 52); };                       \/\/ u[0] < 0x10000000000000 (i.e. 52 bits)\n+                                                      \/\/ u[1] < 0x200000000000000 (i.e. 57 bits)\n+\n+  \/\/ Then multiply the high part of u2 by 5 and add it back to u1:u0\n+  _ { extr(rscratch1, u[2]._hi, u[2]._lo, 26);\n+        ubfx(rscratch1, rscratch1, 0, 52);\n+        add(rscratch1, rscratch1, rscratch1, LSL, 2); \/\/ rscratch1 *= 5\n+        add(u[0]._lo, u[0]._lo, rscratch1); };\n+\n+  _ { lsr(rscratch1, u[2]._hi, (26+52) % 64);\n+        add(rscratch1, rscratch1, rscratch1, LSL, 2); \/\/ rscratch1 *= 5\n+        add(u[1]._lo, u[1]._lo, rscratch1); };\n+  _ { clear_above(u[2], 26); };                       \/\/ u[2] < 0x4000000 (i.e. 26 bits)\n+                                                      \/\/ u[1] < 0x200000000000000 (i.e. 57 bits)\n+                                                      \/\/ u[0] < 0x20000000000000 (i.e. 53 bits)\n+\n+  \/\/ u[1] -> u[2]\n+  _ { add(u[2]._lo, u[2]._lo, u[1]._lo, LSR, 52); };  \/\/ u[2] < 0x8000000 (i.e. 27 bits)\n+  _ { bfc(u[1]._lo, 52, 64-52); };                    \/\/ u[1] < 0x10000000000000 (i.e. 52 bits)\n+\n+  \/\/ u[0] -> u1\n+  _ { add(u[1]._lo, u[1]._lo, u[0]._lo, LSR, 52); };\n+  _ { bfc(u[0]._lo, 52, 64-52); };                    \/\/ u[0] < 0x10000000000000 (i.e. 52 bits)\n+                                                      \/\/ u[1] < 0x20000000000000 (i.e. 53 bits)\n+                                                      \/\/ u[2] < 0x4000000 (i.e. 27 bits)\n+}\n+\n+\/\/ Vectorized poly1305.\n+\n+\/\/ We closely follow Goll and Gueron, ‘Vectorization of Poly1305\n+\/\/ message authentication code’. 2015 12th Int. Conf. on Information\n+\/\/ Technology – New Generations, Las Vegas, NV, USA, April 2015,\n+\/\/ pp. 145–150, doi: 10.1109\/ITNG.2015.28\n+\n+void MacroAssembler::poly1305_field_multiply(AsmGenerator &acc,\n+                                             const RegPair u[], const Register s[], const Register r[],\n+                                             Register RR2, RegSetIterator<Register> scratch) {\n+  poly1305_multiply(acc, u, s, r, RR2, scratch);\n+  poly1305_reduce(acc, u, NULL);\n+}\n+\n+\/\/ Widening multiply s * r -> u\n+void MacroAssembler::poly1305_multiply_vec(AsmGenerator &acc,\n+                                           const FloatRegister u[],\n+                                           const FloatRegister s[],\n+                                           const FloatRegister r[],\n+                                           const FloatRegister rr[]) {\n+  \/\/ Five limbs of r and rr (5·r) are packed as 32-bit integers into\n+  \/\/ two 128-bit vectors.\n+\n+  \/\/ \/\/ (h + c) * r, without carry propagation\n+  \/\/ u64 u0 = r0*m0 + 5·r1*m4 + 5·r2*m3 + 5·r3*m2 + 5·r4*m1\n+  \/\/ u64 u1 = r0*m1 +   r1*m0 + 5·r2*m4 + 5·r3*m3 + 5·r4*m2\n+  \/\/ u64 u2 = r0*m2 +   r1*m1 +   r2*m0 + 5·r3*m4 + 5·r4*m3\n+  \/\/ u64 u3 = r0*m3 +   r1*m2 +   r2*m1 +   r3*m0 + 5·r4*m4\n+  \/\/ u64 u4 = r0*m4 +   r1*m3 +   r2*m2 +   r3*m1 +   r4*m0\n+\n+  _ { umull(u[0], T2D, s[0], r[0], 0); };\n+  _ { umull2(u[1], T2D, s[0], r[0], 0); };\n+  _ { umull(u[2], T2D, s[1], r[0], 0); };\n+  _ { umull2(u[3], T2D, s[1], r[0], 0); };\n+  _ { umull(u[4], T2D, s[2], r[0], 0); };\n+\n+  _ { umlal(u[0], T2D, s[2], rr[0], 1); };\n+  _ { umlal(u[1], T2D, s[0],  r[0], 1); };\n+  _ { umlal2(u[2], T2D, s[0],  r[0], 1); };\n+  _ { umlal(u[3], T2D, s[1],  r[0], 1); };\n+  _ { umlal2(u[4], T2D, s[1],  r[0], 1); };\n+\n+  _ { umlal2(u[0], T2D, s[1], rr[0], 2); };\n+  _ { umlal(u[1], T2D, s[2], rr[0], 2); };\n+  _ { umlal(u[2], T2D, s[0],  r[0], 2); };\n+  _ { umlal2(u[3], T2D, s[0],  r[0], 2); };\n+  _ { umlal(u[4], T2D, s[1],  r[0], 2); };\n+\n+  _ { umlal(u[0], T2D, s[1], rr[0], 3); };\n+  _ { umlal2(u[1], T2D, s[1], rr[0], 3); };\n+  _ { umlal(u[2], T2D, s[2], rr[0], 3); };\n+  _ { umlal(u[3], T2D, s[0],  r[0], 3); };\n+  _ { umlal2(u[4], T2D, s[0],  r[0], 3); };\n+\n+  _ { umlal2(u[0], T2D, s[0], rr[1], 0); };\n+  _ { umlal(u[1], T2D, s[1], rr[1], 0); };\n+  _ { umlal2(u[2], T2D, s[1], rr[1], 0); };\n+  _ { umlal(u[3], T2D, s[2], rr[1], 0); };\n+  _ { umlal(u[4], T2D, s[0],  r[1], 0); };\n+}\n+\n+void MacroAssembler::poly1305_step_vec(AsmGenerator &acc,\n+                                       const FloatRegister s[], const FloatRegister u[],\n+                                       const FloatRegister zero, Register input_start) {\n+  FloatRegister scratch1 = u[2], scratch2 = u[3];\n+\n+  _ {\n+    trn1(u[0], T4S, u[0], u[1]);\n+    trn1(u[1], T4S, u[2], u[3]);\n+\n+    \/\/ The incoming sum is packed into u[0], u[1], u[4]\n+    \/\/ u[2] and u[3] are now free\n+\n+    ld2(scratch1, scratch2, D, 0, post(input_start, 2 * wordSize));\n+    ld2(scratch1, scratch2, D, 1, post(input_start, 2 * wordSize));\n+  };\n+\n+  _ { ushr(s[2], T2D, scratch2, 14+26); };\n+  _ { ushr(s[1], T2D, scratch1, 26+26); };\n+  _ { sli(s[1], T2D, scratch2, 12); };\n+  _ {\n+    ushr(scratch2, T2D, scratch2, 14);\n+    sli(s[1], T2D, scratch2, 32);\n+    sli(s[1], T4S, zero, 26);\n+  };\n+  _ { mov(s[0], T16B, scratch1); };\n+\n+  _ {\n+    ushr(scratch1, T2D, scratch1, 26);\n+    sli(s[0], T2D, scratch1, 32);\n+    sli(s[0], T4S, zero, 26);\n+  };\n+\n+  _ { mov(scratch1, T2D, 1 << 24); };\n+  _ { addv(s[2], T2D, s[2], scratch1); };\n+  _ { sli(s[2], T2D, zero, 32); };\n+\n+  _ { addv(s[0], T4S, s[0], u[0]); };\n+  _ { addv(s[1], T4S, s[1], u[1]); };\n+  _ { addv(s[2], T4S, s[2], u[4]); };\n+\n+  for (int i = 0; i <= 2; i++)\n+    _ {\n+      ext(scratch1, T16B, s[i], s[i], 8);\n+      zip1(s[i], T4S, s[i], scratch1);\n+    };\n+}\n+\n+void MacroAssembler::poly1305_multiply_vec(AsmGenerator &acc,\n+                                           const FloatRegister u_v[],\n+                                           AbstractRegSet<FloatRegister> remaining,\n+                                           const FloatRegister s_v[],\n+                                           const FloatRegister r_v[],\n+                                           const FloatRegister rr_v[]) {\n+  poly1305_multiply_vec(acc, u_v, s_v, r_v, rr_v);\n+}\n+\n+void MacroAssembler::poly1305_reduce_step(AsmGenerator &acc,\n+                                          FloatRegister d, FloatRegister s,\n+                                          FloatRegister zero, FloatRegister scratch) {\n+  _ {\n+    ushr(scratch, T2D, s, 26);\n+    Assembler::add(d, T2D, d, scratch); };\n+  _ { sli(s, T2D, zero, 26); };\n+}\n+\n+void MacroAssembler::poly1305_reduce_vec(AsmGenerator &acc,\n+                                         const FloatRegister u[],\n+                                         const FloatRegister zero,\n+                                         AbstractRegSet<FloatRegister> scratch) {\n+\n+  auto r = scratch.begin();\n+  \/\/ Partial reduction mod 2**130 - 5\n+\n+  FloatRegister vtmp2 = *r++;\n+  FloatRegister vtmp3 = *r++;\n+\n+  \/\/ Goll-Guerin reduction\n+  poly1305_reduce_step(acc, u[1], u[0], zero, vtmp2);\n+  poly1305_reduce_step(acc, u[4], u[3], zero, vtmp2);\n+  poly1305_reduce_step(acc, u[2], u[1], zero, vtmp2);\n+  _ {\n+    ushr(vtmp2, T2D, u[4], 26);\n+    shl(vtmp3, T2D, vtmp2, 2);\n+    Assembler::add(vtmp2, T2D, vtmp2, vtmp3); \/\/ vtmp2 == 5 * (u[4] >> 26)\n+    Assembler::add(u[0], T2D, u[0], vtmp2);\n+    sli(u[4], T2D, zero, 26);\n+  };\n+  poly1305_reduce_step(acc, u[3], u[2], zero, vtmp2);\n+  poly1305_reduce_step(acc, u[1], u[0], zero, vtmp2);\n+  poly1305_reduce_step(acc, u[4], u[3], zero, vtmp2);\n+}\n+\n+void MacroAssembler::poly1305_load(AsmGenerator &acc,\n+                                   const Register s[], const Register input_start) {\n+  _ {\n+    ldp(rscratch1, rscratch2, post(input_start, 2 * wordSize));\n+    ubfx(s[0], rscratch1, 0, 52);\n+    extr(s[1], rscratch2, rscratch1, 52);\n+    ubfx(s[1], s[1], 0, 52);\n+    ubfx(s[2], rscratch2, 40, 24);\n+    orr(s[2], s[2], 1 << 24);\n+  };\n+}\n+\n+void MacroAssembler::poly1305_step(AsmGenerator &acc,\n+                                   const Register s[], const RegPair u[], Register input_start) {\n+  poly1305_load(acc, s, input_start);\n+  _ { poly1305_add(s, u); };\n+}\n+\n+void MacroAssembler::poly1305_add(AsmGenerator &acc,\n+                                  const Register dest[], const RegPair src[]) {\n+  _ { poly1305_add(dest, src); };\n+}\n+\n+#undef _\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64_poly1305.cpp","additions":406,"deletions":0,"binary":false,"changes":406,"status":"added"},{"patch":"@@ -195,0 +195,1 @@\n+  int operator<(const FloatRegister r) const  { return _encoding < r._encoding; }\n","filename":"src\/hotspot\/cpu\/aarch64\/register_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -80,0 +81,4 @@\n+typedef __uint128_t u128;\n+typedef uint64_t u64;\n+typedef uint32_t u32;\n+\n@@ -7253,0 +7258,293 @@\n+typedef AbstractRegSet<FloatRegister> vRegSet;\n+\n+template <typename RegType>\n+class Regs {\n+public:\n+  RegType _regs[5];\n+  Regs(RegSetIterator<RegType> &it, int n) {\n+    for (int i = 0; i < n; i++) {\n+      _regs[i] = *it++;\n+    }\n+  }\n+  Regs(RegType R0, RegType R1, RegType R2) {\n+    _regs[0] = R0, _regs[1] = R1, _regs[2] = R2;\n+  }\n+\n+  RegType operator[](int n) { return _regs[n]; }\n+  RegType *operator *() { return _regs; }\n+\n+  operator RegType*() { return _regs; }\n+};\n+\n+class RegPairs {\n+public:\n+  RegPair _reg_pairs[3];\n+  RegPairs(RegSetIterator<Register> &it, int n) {\n+    for (int i = 0; i < n; i++) {\n+      RegPair r(*it++, *it++);\n+      _reg_pairs[i] = r;\n+    }\n+  }\n+  operator RegPair*() { return _reg_pairs; }\n+};\n+\n+typedef Regs<Register> CoreRegs;\n+typedef Regs<FloatRegister> VectorRegs;\n+\n+address generate_poly1305_processBlocks2() {\n+  static constexpr int POLY1305_BLOCK_LENGTH = 16;\n+\n+  __ align(CodeEntryAlignment);\n+  StubCodeMark mark(this, \"StubRoutines\", \"poly1305_processBlocks2\");\n+  address start = __ pc();\n+  Label here;\n+\n+  \/\/ __ set_last_Java_frame(sp, rfp, lr, rscratch1);\n+  __ enter();\n+  RegSet callee_saved = RegSet::range(r19, r28);\n+  __ push(callee_saved, sp);\n+\n+  auto regs = (RegSet::range(c_rarg0, r28) - r18_tls - rscratch1 - rscratch2 + lr).begin();\n+  auto vregs = (vRegSet::range(v0, v7) + vRegSet::range(v16, v31)).begin();\n+\n+  \/\/ Arguments\n+  const Register input_start = *regs++, length = *regs++, acc_start = *regs++, r_start = *regs++;\n+\n+  \/\/ Rn is the key, packed into three registers\n+  CoreRegs R(regs, 3);\n+  __ pack_26(R[0], R[1], R[2], r_start);\n+\n+  \/\/ Sn is to be the sum of Un and the next block of data\n+  CoreRegs S0(regs, 3), S1(regs, 3);\n+\n+  \/\/ Un is the current checksum\n+  RegPairs u0(regs, 3), u1(regs, 3);\n+\n+  Register RR2 = *regs++;\n+  __ lsl(RR2, R[2], 26);\n+  __ add(RR2, RR2, RR2, __ LSL, 2);\n+\n+  int BLOCKS_PER_ITERATION = 6;\n+\n+  \/\/ Just one block?\n+  Label SMALL;\n+  {\n+    Label LARGE;\n+    __ subs(zr, length, POLY1305_BLOCK_LENGTH * BLOCKS_PER_ITERATION * 2);\n+    __ br(__ GT, LARGE);\n+\n+    \/\/ Load the initial state\n+    __ pack_26(u0[0]._lo, u0[1]._lo, u0[2]._lo, acc_start);\n+    __ b(SMALL);\n+\n+    __ bind(LARGE);\n+  }\n+\n+  \/\/ We're going to use R**6\n+  {\n+    \/\/ The low halves of u0 and u1\n+    CoreRegs u0_lo(u0[0]._lo, u0[1]._lo, u0[2]._lo);\n+    CoreRegs u1_lo(u1[0]._lo, u1[1]._lo, u1[2]._lo);\n+\n+    __ poly1305_field_multiply(u0, R, R, RR2, regs);\n+    \/\/ u0_lo = R**2\n+\n+    __ poly1305_field_multiply(u1, u0_lo, R, RR2, regs);\n+    \/\/ u1_lo = R**3\n+\n+    \/\/ RR2 = 5 * (R[2] << 26)\n+    __ copy_3_regs(R, u1_lo);\n+    __ lsl(RR2, R[2], 26);\n+    __ add(RR2, RR2, RR2, __ LSL, 2);\n+\n+    __ poly1305_field_multiply(u1, R, R, RR2, regs);\n+    \/\/ u1_lo = R**6\n+\n+    __ copy_3_regs(R, u1_lo);\n+    __ lsl(RR2, R[2], 26);\n+    __ add(RR2, RR2, RR2, __ LSL, 2);\n+  }\n+\n+  \/\/ Load the initial state\n+  __ pack_26(u0[0]._lo, u0[1]._lo, u0[2]._lo, acc_start);\n+\n+  \/\/ u0 contains the initial state. Clear the others.\n+  for (int i = 0; i < 3; i++) {\n+    __ mov(u0[i]._hi, 0);\n+    __ mov(u1[i]._lo, 0); __ mov(u1[i]._hi, 0);\n+  }\n+\n+  VectorRegs v_u0(vregs, 5);\n+  VectorRegs v_s0(vregs, 3);\n+  VectorRegs v_u1(vregs, 5);\n+  VectorRegs v_s1(vregs, 3);\n+\n+  const FloatRegister zero = *vregs++;\n+\n+  __ movi(zero, __ T16B, 0);\n+\n+  \/\/ rr_v = r_v * 5\n+  VectorRegs r_v(vregs, 2);\n+  VectorRegs rr_v(vregs, 2);\n+  __ copy_3_regs_to_5_elements(r_v, R[0], R[1], R[2]);\n+  {\n+    FloatRegister vtmp = *vregs;\n+    __ shl(vtmp, __ T4S, r_v[0], 2);\n+    __ addv(rr_v[0], __ T4S, r_v[0], vtmp);\n+    __ shl(vtmp, __ T4S, r_v[1], 2);\n+    __ addv(rr_v[1], __ T4S, r_v[1], vtmp);\n+  }\n+\n+  for (int i = 0; i < 5; i++) {\n+    __ movi(v_u0[i], __ T16B, 0);\n+    __ movi(v_u1[i], __ T16B, 0);\n+  }\n+\n+  {\n+    Label DONE, LOOP;\n+\n+    __ subsw(rscratch1, length, POLY1305_BLOCK_LENGTH * BLOCKS_PER_ITERATION * 2);\n+    __ br(Assembler::LT, DONE);\n+\n+    __ align(OptoLoopAlignment);\n+    __ bind(LOOP);\n+    {\n+      \/\/ __ poly1305_load(S0, input_start);\n+      \/\/ __ poly1305_load(S1, input_start);\n+\n+      constexpr int COLS = 4;\n+      AsmGenerator gen[COLS];\n+\n+      __ poly1305_step(gen[0], S0, u0, input_start);\n+      __ poly1305_field_multiply(gen[0], u0, S0, R, RR2, regs);\n+\n+      __ poly1305_step(gen[1], S1, u1, input_start);\n+      __ poly1305_field_multiply(gen[1], u1, S1, R, RR2, regs);\n+\n+      __ poly1305_step_vec(gen[2], v_s0, v_u0, zero, input_start);\n+      __ poly1305_field_multiply(gen[2], v_u0, v_s0, r_v, rr_v, zero,\n+                                 vregs.remaining());\n+\n+      __ poly1305_step_vec(gen[3], v_s1, v_u1, zero, input_start);\n+      __ poly1305_field_multiply(gen[3], v_u1, v_s1, r_v, rr_v, zero,\n+                                 vregs.remaining());\n+\n+      AsmGenerator::Iterator it[COLS];\n+      int len[COLS];\n+\n+      int l_max = INT_MIN;\n+      for (int col = 0; col < COLS; col++) {\n+        it[col] = gen[col].iterator();\n+        len[col] = gen[col].length();\n+        l_max = MAX2(l_max, len[col]);\n+      }\n+\n+      int err[COLS];\n+      for (int col = 0; col < COLS; col++) {\n+        err[col] = 0;\n+      }\n+\n+      for (int i = 0; i < l_max; i++) {\n+        for (int col = 0; col < COLS; col++) {\n+          err[col] -= len[col];\n+          if (err[col] < 0) {\n+            err[col] += l_max;\n+            (it[col]++)();\n+          }\n+        }\n+      }\n+\n+      for (int col = 0; col < COLS; col++) {\n+        assert(*(it[col]) == nullptr, \"Make sure all generators are exhausted\");\n+      }\n+    }\n+\n+    __ subw(length, length, POLY1305_BLOCK_LENGTH * BLOCKS_PER_ITERATION);\n+    __ subsw(rscratch1, length, POLY1305_BLOCK_LENGTH * BLOCKS_PER_ITERATION * 2);\n+    __ br(Assembler::GE, LOOP);\n+\n+    __ bind(DONE);\n+  }\n+\n+  \/\/ Last six parallel blocks\n+  {\n+    \/\/ Load R**1\n+    __ pack_26(R[0], R[1], R[2], r_start);\n+    __ lsl(RR2, R[2], 26);\n+    __ add(RR2, RR2, RR2, __ LSL, 2);\n+\n+    __ poly1305_load(S0, input_start);\n+    __ poly1305_add(S0, u0);\n+    __ poly1305_field_multiply(u0, S0, R, RR2, regs);\n+\n+    __ poly1305_load(S0, input_start);\n+    __ poly1305_add(S0, u0);\n+    __ poly1305_add(S0, u1);\n+    __ poly1305_field_multiply(u0, S0, R, RR2, regs);\n+\n+    __ poly1305_load(S0, input_start);\n+    __ poly1305_add(S0, u0);\n+    __ poly1305_transfer(u1, v_u0, 0, *vregs);\n+    __ poly1305_add(S0, u1);\n+    __ poly1305_field_multiply(u0, S0, R, RR2, regs);\n+\n+    __ poly1305_load(S0, input_start);\n+    __ poly1305_add(S0, u0);\n+    __ poly1305_transfer(u1, v_u0, 1, *vregs);\n+    __ poly1305_add(S0, u1);\n+    __ poly1305_field_multiply(u0, S0, R, RR2, regs);\n+\n+    __ poly1305_load(S0, input_start);\n+    __ poly1305_add(S0, u0);\n+    __ poly1305_transfer(u1, v_u1, 0, *vregs);\n+    __ poly1305_add(S0, u1);\n+    __ poly1305_field_multiply(u0, S0, R, RR2, regs);\n+\n+    __ poly1305_load(S0, input_start);\n+    __ poly1305_add(S0, u0);\n+    __ poly1305_transfer(u1, v_u1, 1, *vregs);\n+    __ poly1305_add(S0, u1);\n+    __ poly1305_field_multiply(u0, S0, R, RR2, regs);\n+\n+    __ subw(length, length, POLY1305_BLOCK_LENGTH * BLOCKS_PER_ITERATION);\n+  }\n+\n+  \/\/ Maybe some last blocks\n+  __ bind(SMALL);\n+  {\n+    Label DONE, LOOP;\n+\n+    __ bind(LOOP);\n+    __ subsw(length, length, POLY1305_BLOCK_LENGTH);\n+    __ br(__ LT, DONE);\n+\n+    __ poly1305_step(S0, u0, input_start);\n+    __ poly1305_field_multiply(u0, S0, R, RR2, regs);\n+\n+    __ b(LOOP);\n+    __ bind(DONE);\n+  }\n+  __ poly1305_fully_reduce(S0, u0);\n+\n+  \/\/ And store it all back\n+  __ ubfiz(rscratch1, S0[0], 0, 26);\n+  __ ubfx(rscratch2, S0[0], 26, 26);\n+  __ stp(rscratch1, rscratch2, Address(acc_start));\n+\n+  __ ubfx(rscratch1, S0[0], 52, 12);\n+  __ bfi(rscratch1, S0[1], 12, 14);\n+  __ ubfx(rscratch2, S0[1], 14, 26);\n+  __ stp(rscratch1, rscratch2, Address(acc_start, 2 * sizeof (jlong)));\n+\n+  __ extr(rscratch1, S0[2], S0[1], 40);\n+  __ str(rscratch1, Address(acc_start, 4 * sizeof (jlong)));\n+\n+  __ pop(callee_saved, sp);\n+  \/\/ __ reset_last_Java_frame(true);\n+  __ leave();\n+  __ ret(lr);\n+\n+  return start;\n+}\n+\n+\n@@ -8402,1 +8700,1 @@\n-      StubRoutines::_poly1305_processBlocks = generate_poly1305_processBlocks();\n+      StubRoutines::_poly1305_processBlocks = generate_poly1305_processBlocks2();\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":299,"deletions":1,"binary":false,"changes":300,"status":"modified"},{"patch":"@@ -187,0 +187,6 @@\n+  RegSetIterator operator++(int) {\n+    auto result(*this);\n+    operator++();\n+    return result;\n+  }\n+\n@@ -191,0 +197,1 @@\n+\n","filename":"src\/hotspot\/share\/asm\/register.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -145,0 +145,80 @@\n+#ifndef PRODUCT\n+\n+typedef __uint128_t u128;\n+typedef uint64_t u64;\n+typedef uint32_t u32;\n+\n+void print128(u128 n) {\n+  u64 n1 = n >> 64; u64 n0 = (u128)(n << 64 >> 64);\n+  printf(\"%016lx%016lx\", (u64)(n >> 64), (u64)(n << 64 >> 64));\n+}\n+\n+int should_print = 1;\n+\n+void print52(u64 x2, u64 x1, u64 x0, const char *s) {\n+  if (! should_print)  return;\n+\n+  u64 over = x2 >> 26;\n+  x2 = x2 << (64-26) >> (64-26);\n+  x0 += over * 5;\n+\n+  u128 x_sum = 0;\n+  x_sum = x_sum\n+    + x0\n+    + ((u128)x1 << 52);\n+\n+  u128 tmp = x_sum >> 64;\n+  tmp += (u128)x2 << 40;\n+\n+  x_sum += (u128)x2 << 104;\n+\n+  u64 top = tmp >> 64;\n+\n+  if (s) {\n+    printf(\"%s: \", s);\n+  }\n+  printf(\"0x%lx:\", (u64)top);\n+  print128(x_sum);\n+  printf(\"\\n\");\n+}\n+\n+bool vreg_is_equal(uint64_t v4,\n+                   uint64_t v3,\n+                   uint64_t v2,\n+                   uint64_t v1,\n+                   uint64_t v0,\n+                   uint64_t x2,\n+                   uint64_t x1,\n+                   uint64_t x0) {\n+  v1 += v0 >> 26; v0 %= 1 <<26;\n+  v4 += v3 >> 26; v3 %= 1 <<26;\n+  v2 += v1 >> 26; v1 %= 1 <<26;\n+  v0 += 5 * (v4 >> 26); v4 %= 1 <<26;\n+  v3 += v2 >> 26; v2 %= 1 <<26;\n+  v1 += v0 >> 26; v0 %= 1 <<26;\n+  v4 += v3 >> 26; v3 %= 1 <<26;\n+\n+  u128 v_sum = 0;\n+  v_sum = v_sum\n+    + v0\n+    + ((u128)v1 << 26)\n+    + ((u128)v2 << 52)\n+    + ((u128)v3 << 78)\n+    + ((u128)v4 << 104);\n+\n+  x1 += x0 >> 52; x0 %= 1ul <<52;\n+  x2 += x1 >> 52; x1 %= 1ul <<52;\n+  x0 += 5 * (x2 >> 26); x2 %= 1 <<26;\n+  x1 += x0 >> 52; x0 %= 1ul <<52;\n+\n+  u128 x_sum = 0;\n+  x_sum = x_sum\n+    + x0\n+    + ((u128)x1 << 52)\n+    + ((u128)x2 << 104);\n+\n+  return x_sum == v_sum && (x2 >> 24) == (v4 >> 24);\n+}\n+\n+#endif \/\/ !PRODUCT\n+\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"}]}