{"files":[{"patch":"@@ -7049,0 +7049,70 @@\n+\n+\/\/\n+\/\/ Efficient LEA-based multiply emulation for immediates not easily handled\n+\/\/ by shift+add. Uses two fast LEAs based on Intel Optimization Manual,\n+\/\/ section \"3.5.1.2 Using LEA\". IMUL latency with register operands is 3 cycles,\n+\/\/ while fast LEA has 1 cycle. So two fast LEAs often outperform IMUL for\n+\/\/ specific constants.\n+\/\/\n+\/\/ The pattern table below lists:\n+\/\/   - First LEA:  BASE = src, INDEX = src, SCALE = s1\n+\/\/   - Second LEA: BASE = (use_src2 ? src : dst), INDEX = dst, SCALE = s2\n+\/\/\n+\/\/ All dst inputs for the second LEA are derived from “terminal” outputs.\n+\/\/\n+void C2_MacroAssembler::imullq_imm(BasicType bt, Register dst, Register src, int32_t imm) {\n+  assert(bt == T_LONG || bt == T_INT, \"Unexpected type\");\n+\n+  if (!VM_Version::supports_fast_2op_lea()) {\n+    imullq(bt, dst, src, imm);\n+    return;\n+  }\n+\n+  \/\/ Descriptor for one LEA pattern entry.\n+  struct LeaPattern {\n+    int32_t imm;\n+    \/\/ First LEA: dst = src + src * scale1\n+    Address::ScaleFactor scale1;\n+\n+    \/\/ Second LEA:\n+    \/\/ If use_src2 == true:\n+    \/\/     dst = src + dst * scale2\n+    \/\/ else:\n+    \/\/     dst = dst + dst * scale2\n+    bool use_src_as_base;\n+    Address::ScaleFactor scale2;\n+  };\n+\n+  static const LeaPattern patterns[] = {\n+    { 11, Address::times_4, true,  Address::times_2 },\n+    { 13, Address::times_2, true,  Address::times_4 },\n+    { 19, Address::times_8, true,  Address::times_2 },\n+    { 21, Address::times_4, true,  Address::times_4 },\n+    { 25, Address::times_4, false, Address::times_4 },\n+    { 27, Address::times_2, false, Address::times_8 },\n+    { 37, Address::times_8, true,  Address::times_4 },\n+    { 41, Address::times_4, true,  Address::times_8 },\n+    { 45, Address::times_4, false, Address::times_8 },\n+    { 73, Address::times_8, true,  Address::times_8 },\n+    { 81, Address::times_8, false, Address::times_8 },\n+  };\n+\n+  \/\/ Lookup table\n+  for (const LeaPattern& p : patterns) {\n+    if (p.imm == imm) {\n+      \/\/ First LEA → dst = src + src * scale1\n+      lealq(bt, dst, Address(src, src, p.scale1));\n+\n+      \/\/ Second LEA\n+      if (p.use_src_as_base) {\n+        lealq(bt, dst, Address(src, dst, p.scale2));\n+      } else {\n+        lealq(bt, dst, Address(dst, dst, p.scale2));\n+      }\n+      return;\n+    }\n+  }\n+\n+  \/\/ Fallback: unsupported imm use IMUL\n+  imullq(bt, dst, src, imm);\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":70,"deletions":0,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -587,0 +587,2 @@\n+  void imullq_imm(BasicType bt, Register dst, Register src, int32_t imm);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -9826,0 +9826,18 @@\n+\n+void MacroAssembler::imullq(BasicType bt, Register dst, Register src, int32_t imm) {\n+  if (bt == T_LONG) {\n+    imulq(dst, src, imm);\n+  } else {\n+    assert(bt == T_INT, \"Unexpected type\");\n+    imull(dst, src, imm);\n+  }\n+}\n+\n+void MacroAssembler::lealq(BasicType bt, Register dst, Address src) {\n+  if (bt == T_LONG) {\n+    leaq(dst, src);\n+  } else {\n+    assert(bt == T_INT, \"Unexpected type\");\n+    leal(dst, src);\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2064,0 +2064,3 @@\n+\n+  void imullq(BasicType bt, Register dst, Register src, int32_t imm);\n+  void lealq(BasicType bt, Register dst, Address src);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -11461,1 +11461,1 @@\n-  effect(KILL cr);\n+  effect(KILL cr, TEMP_DEF dst);\n@@ -11464,1 +11464,1 @@\n-  format %{ \"imull   $dst, $src, $imm\\t# int\" %}\n+  format %{ \"imull_imm  $dst, $src, $imm\\t# int\" %}\n@@ -11466,1 +11466,1 @@\n-    __ imull($dst$$Register, $src$$Register, $imm$$constant);\n+    __ imullq_imm(T_INT, $dst$$Register, $src$$Register, $imm$$constant);\n@@ -11503,1 +11503,1 @@\n-  effect(KILL cr);\n+  effect(KILL cr, TEMP dst);\n@@ -11508,1 +11508,2 @@\n-    __ imull($dst$$Register, $src$$Address, $imm$$constant);\n+    __ movl($dst$$Register, $src$$Address);\n+    __ imullq_imm(T_INT, $dst$$Register, $dst$$Register, $imm$$constant);\n@@ -11555,1 +11556,1 @@\n-  effect(KILL cr);\n+  effect(KILL cr, TEMP_DEF dst);\n@@ -11558,1 +11559,1 @@\n-  format %{ \"imulq   $dst, $src, $imm\\t# long\" %}\n+  format %{ \"imulq_imm  $dst, $src, $imm\\t# long\" %}\n@@ -11560,1 +11561,1 @@\n-    __ imulq($dst$$Register, $src$$Register, $imm$$constant);\n+    __ imullq_imm(T_LONG, $dst$$Register, $src$$Register, $imm$$constant);\n@@ -11597,1 +11598,1 @@\n-  effect(KILL cr);\n+  effect(KILL cr, TEMP dst);\n@@ -11602,1 +11603,2 @@\n-    __ imulq($dst$$Register, $src$$Address, $imm$$constant);\n+    __ movq($dst$$Register, $src$$Address);\n+    __ imullq_imm(T_LONG, $dst$$Register, $dst$$Register, $imm$$constant);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8373480\n+ * @summary Optimize multiplication by constant multiplier using LEA instructions\n+ * @library \/test\/lib \/\n+ * @compile ..\/..\/compiler\/lib\/ir_framework\/TestFramework.java\n+ * @compile ..\/..\/compiler\/lib\/generators\/Generators.java\n+ * @compile ..\/..\/compiler\/lib\/verify\/Verify.java\n+ * @run driver compiler.c2.TestConstantMultiplier\n+ *\/\n+\n+package compiler.c2;\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.IntStream;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.verify.*;\n+import compiler.lib.ir_framework.Test;\n+\n+import compiler.lib.compile_framework.*;\n+import compiler.lib.generators.Generators;\n+\n+import compiler.lib.template_framework.Template;\n+import compiler.lib.template_framework.TemplateToken;\n+import static compiler.lib.template_framework.Template.scope;\n+import static compiler.lib.template_framework.Template.let;\n+\n+import compiler.lib.template_framework.library.TestFrameworkClass;\n+\n+public class TestConstantMultiplier {\n+\n+    public static void main(String[] args) {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        \/\/ Add a java source file.\n+        comp.addJavaSourceCode(\"c2.compiler.ConstantMultiplierTest\", generate(comp));\n+\n+        \/\/ Compile the source file.\n+        comp.compile();\n+\n+        comp.invoke(\"c2.compiler.ConstantMultiplierTest\", \"main\", new Object[] {new String[] {}});\n+    }\n+\n+\n+    \/\/ Generate a source Java file as String\n+    public static String generate(CompileFramework comp) {\n+        var testHeader = Template.make(() -> scope(\n+            \"\"\"\n+                public static Random RANDOM = new Random(1023);\n+\n+            \"\"\"\n+        ));\n+        var testTemplate = Template.make(() -> scope(\n+            IntStream.of(81, 73, 45, 41, 37, 27, 25, 21, 19, 13, 11).mapToObj(\n+                multiplier -> scope(\n+                    let(\"multiplier\", multiplier),\n+                    \"\"\"\n+                        @Test\n+                        @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_MULT_IMM_I, \"1\"})\n+                        private static int testMultBy#{multiplier}I(int num) {\n+                            return num * #{multiplier};\n+                        }\n+\n+                        @Run(test = \"testMultBy#{multiplier}I\")\n+                        private static void runMultBy#{multiplier}II() {\n+                            int multiplicand = RANDOM.nextInt();\n+                            Verify.checkEQ(#{multiplier} * multiplicand, testMultBy#{multiplier}I(multiplicand));\n+                        }\n+\n+                        @Test\n+                        @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_MULT_IMM_L, \"1\"})\n+                        private static long testMultBy#{multiplier}L(long num) {\n+                            return num * #{multiplier};\n+                        }\n+\n+                        @Run(test = \"testMultBy#{multiplier}L\")\n+                        private static void runMultBy#{multiplier}L() {\n+                            long multiplicand = RANDOM.nextInt();\n+                            Verify.checkEQ(#{multiplier} * multiplicand, testMultBy#{multiplier}L(multiplicand));\n+                        }\n+                    \"\"\"\n+            )).toList()\n+        ));\n+\n+        var testClass = Template.make(() -> scope(\n+            testHeader.asToken(),\n+            testTemplate.asToken()\n+        ));\n+\n+        List<TemplateToken> testTemplateTokens = List.of(testClass.asToken());\n+\n+        return TestFrameworkClass.render(\n+            \/\/ package and class name.\n+            \"c2.compiler\", \"ConstantMultiplierTest\",\n+            \/\/ Set of imports.\n+            Set.of(\"java.util.Random\",\"compiler.lib.verify.*\"),\n+            \/\/ classpath, so the Test VM has access to the compiled class files.\n+            comp.getEscapedClassPathOfCompiledClasses(),\n+            \/\/ The list of tests.\n+            testTemplateTokens);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestConstantMultiplier.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -2784,0 +2784,10 @@\n+    public static final String X86_MULT_IMM_I = PREFIX + \"X86_MULT_IMM_I\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_MULT_IMM_I, \"mulI_rReg_imm\");\n+    }\n+\n+    public static final String X86_MULT_IMM_L = PREFIX + \"X86_MULT_IMM_L\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_MULT_IMM_L, \"mulL_rReg_imm\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.lang.invoke.*;\n+import java.util.Random;\n+\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MINUTES)\n+@State(Scope.Thread)\n+@Fork(value = 1, jvmArgs = {\"-XX:LoopUnrollLimit=1\"})\n+public class ConstantMultiplierOptimization {\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static int mul_by_25_I(int a) {\n+       return a * 25;\n+    }\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static int mul_by_27_I(int a) {\n+       return a * 27;\n+    }\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static int mul_by_37_I(int a) {\n+       return a * 37;\n+    }\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static int mul_by_19_I(int a) {\n+       return a * 19;\n+    }\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static int mul_by_13_I(int a) {\n+       return a * 13;\n+    }\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static int mul_by_11_I(int a) {\n+       return a * 11;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static long mul_by_25_L(long a) {\n+       return a * 25;\n+    }\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static long mul_by_27_L(long a) {\n+       return a * 27;\n+    }\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static long mul_by_37_L(long a) {\n+       return a * 37;\n+    }\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static long mul_by_19_L(long a) {\n+       return a * 19;\n+    }\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static long mul_by_13_L(long a) {\n+       return a * 13;\n+    }\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static long mul_by_11_L(long a) {\n+       return a * 11;\n+    }\n+\n+    @Benchmark\n+    public long testConstMultiplierL() {\n+        long res = 0;\n+        for (long i = 0 ; i < 100000000; i++) {\n+            res += mul_by_37_L(i);\n+            res += mul_by_25_L(i);\n+            res += mul_by_27_L(i);\n+            res += mul_by_19_L(i);\n+            res += mul_by_13_L(i);\n+            res += mul_by_11_L(i);\n+        }\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public int testConstMultiplierI() {\n+        int res = 0;\n+        for (int i = 0 ; i < 100000000; i++) {\n+            res += mul_by_37_I(i);\n+            res += mul_by_25_I(i);\n+            res += mul_by_27_I(i);\n+            res += mul_by_19_I(i);\n+            res += mul_by_13_I(i);\n+            res += mul_by_11_I(i);\n+        }\n+        return res;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/ConstantMultiplierOptimization.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"}]}