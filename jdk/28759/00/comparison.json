{"files":[{"patch":"@@ -7049,0 +7049,70 @@\n+\n+\/\/\n+\/\/ Efficient LEA-based multiply emulation for immediates not easily handled\n+\/\/ by shift+add. Uses two fast LEAs based on Intel Optimization Manual,\n+\/\/ section \"3.5.1.2 Using LEA\". IMUL latency with register operands is 3 cycles,\n+\/\/ while fast LEA has 1 cycle. So two fast LEAs often outperform IMUL for\n+\/\/ specific constants.\n+\/\/\n+\/\/ The pattern table below lists:\n+\/\/   - First LEA:  BASE = src, INDEX = src, SCALE = s1\n+\/\/   - Second LEA: BASE = (use_src2 ? src : dst), INDEX = dst, SCALE = s2\n+\/\/\n+\/\/ All dst inputs for the second LEA are derived from “terminal” outputs.\n+\/\/\n+void C2_MacroAssembler::imullq_imm(BasicType bt, Register dst, Register src, int32_t imm) {\n+  assert(bt == T_LONG || bt == T_INT, \"Unexpected type\");\n+\n+  if (!VM_Version::supports_fast_2op_lea()) {\n+    imullq(bt, dst, src, imm);\n+    return;\n+  }\n+\n+  \/\/ Descriptor for one LEA pattern entry.\n+  struct LeaPattern {\n+    int32_t imm;\n+    \/\/ First LEA: dst = src + src * scale1\n+    Address::ScaleFactor scale1;\n+\n+    \/\/ Second LEA:\n+    \/\/ If use_src2 == true:\n+    \/\/     dst = src + dst * scale2\n+    \/\/ else:\n+    \/\/     dst = dst + dst * scale2\n+    bool use_src_as_base;\n+    Address::ScaleFactor scale2;\n+  };\n+\n+  static const LeaPattern patterns[] = {\n+    { 11, Address::times_4, true,  Address::times_2 },\n+    { 13, Address::times_2, true,  Address::times_4 },\n+    { 19, Address::times_8, true,  Address::times_2 },\n+    { 21, Address::times_4, true,  Address::times_4 },\n+    { 25, Address::times_4, false, Address::times_4 },\n+    { 27, Address::times_2, false, Address::times_8 },\n+    { 37, Address::times_8, true,  Address::times_4 },\n+    { 41, Address::times_4, true,  Address::times_8 },\n+    { 45, Address::times_4, false, Address::times_8 },\n+    { 73, Address::times_8, true,  Address::times_8 },\n+    { 81, Address::times_8, false, Address::times_8 },\n+  };\n+\n+  \/\/ Lookup table\n+  for (const LeaPattern& p : patterns) {\n+    if (p.imm == imm) {\n+      \/\/ First LEA → dst = src + src * scale1\n+      lealq(bt, dst, Address(src, src, p.scale1));\n+\n+      \/\/ Second LEA\n+      if (p.use_src_as_base) {\n+        lealq(bt, dst, Address(src, dst, p.scale2));\n+      } else {\n+        lealq(bt, dst, Address(dst, dst, p.scale2));\n+      }\n+      return;\n+    }\n+  }\n+\n+  \/\/ Fallback: unsupported imm use IMUL\n+  imullq(bt, dst, src, imm);\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":70,"deletions":0,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -587,0 +587,2 @@\n+  void imullq_imm(BasicType bt, Register dst, Register src, int32_t imm);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -9826,0 +9826,18 @@\n+\n+void MacroAssembler::imullq(BasicType bt, Register dst, Register src, int32_t imm) {\n+  if (bt == T_LONG) {\n+    imulq(dst, src, imm);\n+  } else {\n+    assert(bt == T_INT, \"Unexpected type\");\n+    imull(dst, src, imm);\n+  }\n+}\n+\n+void MacroAssembler::lealq(BasicType bt, Register dst, Address src) {\n+  if (bt == T_LONG) {\n+    leaq(dst, src);\n+  } else {\n+    assert(bt == T_INT, \"Unexpected type\");\n+    leal(dst, src);\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2064,0 +2064,3 @@\n+\n+  void imullq(BasicType bt, Register dst, Register src, int32_t imm);\n+  void lealq(BasicType bt, Register dst, Address src);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -11461,1 +11461,1 @@\n-  effect(KILL cr);\n+  effect(KILL cr, TEMP_DEF dst);\n@@ -11464,1 +11464,1 @@\n-  format %{ \"imull   $dst, $src, $imm\\t# int\" %}\n+  format %{ \"imull_imm  $dst, $src, $imm\\t# int\" %}\n@@ -11466,1 +11466,1 @@\n-    __ imull($dst$$Register, $src$$Register, $imm$$constant);\n+    __ imullq_imm(T_INT, $dst$$Register, $src$$Register, $imm$$constant);\n@@ -11503,1 +11503,1 @@\n-  effect(KILL cr);\n+  effect(KILL cr, TEMP dst);\n@@ -11508,1 +11508,2 @@\n-    __ imull($dst$$Register, $src$$Address, $imm$$constant);\n+    __ movl($dst$$Register, $src$$Address);\n+    __ imullq_imm(T_INT, $dst$$Register, $dst$$Register, $imm$$constant);\n@@ -11555,1 +11556,1 @@\n-  effect(KILL cr);\n+  effect(KILL cr, TEMP_DEF dst);\n@@ -11558,1 +11559,1 @@\n-  format %{ \"imulq   $dst, $src, $imm\\t# long\" %}\n+  format %{ \"imulq_imm  $dst, $src, $imm\\t# long\" %}\n@@ -11560,1 +11561,1 @@\n-    __ imulq($dst$$Register, $src$$Register, $imm$$constant);\n+    __ imullq_imm(T_LONG, $dst$$Register, $src$$Register, $imm$$constant);\n@@ -11597,1 +11598,1 @@\n-  effect(KILL cr);\n+  effect(KILL cr, TEMP dst);\n@@ -11602,1 +11603,2 @@\n-    __ imulq($dst$$Register, $src$$Address, $imm$$constant);\n+    __ movq($dst$$Register, $src$$Address);\n+    __ imullq_imm(T_LONG, $dst$$Register, $dst$$Register, $imm$$constant);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,309 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.verify.*;\n+import compiler.lib.ir_framework.Test;\n+\n+import java.util.Random;\n+\n+\/*\n+ * @test\n+ * @bug 8373480\n+ * @summary Optimize multiplication by constant multiplier using LEA instructions\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.TestConstantMultiplier\n+ *\/\n+public class TestConstantMultiplier {\n+    private static final Random RANDOM = AbstractInfo.getRandom();\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_MULT_IMM_I, \"1\"})\n+    private static int testMultBy81I(int num) {\n+        return num * 81;\n+    }\n+\n+    @Run(test = \"testMultBy81I\")\n+    private static void runMultBy81II() {\n+        int multiplicand = RANDOM.nextInt();\n+        Verify.checkEQ(81 * multiplicand, testMultBy81I(multiplicand));\n+    }\n+\n+    @Test\n+    @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_MULT_IMM_I, \"1\"})\n+    private static int testMultBy73I(int num) {\n+        return num * 73;\n+    }\n+\n+    @Run(test = \"testMultBy73I\")\n+    private static void runMultBy73II() {\n+        int multiplicand = RANDOM.nextInt();\n+        Verify.checkEQ(73 * multiplicand, testMultBy73I(multiplicand));\n+    }\n+\n+    @Test\n+    @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_MULT_IMM_I, \"1\"})\n+    private static int testMultBy45I(int num) {\n+        return num * 45;\n+    }\n+\n+    @Run(test = \"testMultBy45I\")\n+    private static void runMultBy45II() {\n+        int multiplicand = RANDOM.nextInt();\n+        Verify.checkEQ(45 * multiplicand, testMultBy45I(multiplicand));\n+    }\n+\n+    @Test\n+    @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_MULT_IMM_I, \"1\"})\n+    private static int testMultBy41I(int num) {\n+        return num * 41;\n+    }\n+\n+    @Run(test = \"testMultBy41I\")\n+    private static void runMultBy41II() {\n+        int multiplicand = RANDOM.nextInt();\n+        Verify.checkEQ(41 * multiplicand, testMultBy41I(multiplicand));\n+    }\n+\n+    @Test\n+    @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_MULT_IMM_I, \"1\"})\n+    private static int testMultBy37I(int num) {\n+        return num * 37;\n+    }\n+\n+    @Run(test = \"testMultBy37I\")\n+    private static void runMultBy37II() {\n+        int multiplicand = RANDOM.nextInt();\n+        Verify.checkEQ(37 * multiplicand, testMultBy37I(multiplicand));\n+    }\n+\n+    @Test\n+    @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_MULT_IMM_I, \"1\"})\n+    private static int testMultBy27I(int num) {\n+        return num * 27;\n+    }\n+\n+    @Run(test = \"testMultBy27I\")\n+    private static void runMultBy27II() {\n+        int multiplicand = RANDOM.nextInt();\n+        Verify.checkEQ(27 * multiplicand, testMultBy27I(multiplicand));\n+    }\n+\n+    @Test\n+    @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_MULT_IMM_I, \"1\"})\n+    private static int testMultBy25I(int num) {\n+        return num * 25;\n+    }\n+\n+    @Run(test = \"testMultBy25I\")\n+    private static void runMultBy25II() {\n+        int multiplicand = RANDOM.nextInt();\n+        Verify.checkEQ(25 * multiplicand, testMultBy25I(multiplicand));\n+    }\n+\n+    @Test\n+    @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_MULT_IMM_I, \"1\"})\n+    private static int testMultBy21I(int num) {\n+        return num * 21;\n+    }\n+\n+    @Run(test = \"testMultBy21I\")\n+    private static void runMultBy21II() {\n+        int multiplicand = RANDOM.nextInt();\n+        Verify.checkEQ(21 * multiplicand, testMultBy21I(multiplicand));\n+    }\n+\n+    @Test\n+    @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_MULT_IMM_I, \"1\"})\n+    private static int testMultBy19I(int num) {\n+        return num * 19;\n+    }\n+\n+    @Run(test = \"testMultBy19I\")\n+    private static void runMultBy19II() {\n+        int multiplicand = RANDOM.nextInt();\n+        Verify.checkEQ(19 * multiplicand, testMultBy19I(multiplicand));\n+    }\n+\n+    @Test\n+    @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_MULT_IMM_I, \"1\"})\n+    private static int testMultBy13I(int num) {\n+        return num * 13;\n+    }\n+\n+    @Run(test = \"testMultBy13I\")\n+    private static void runMultBy13I() {\n+        int multiplicand = RANDOM.nextInt();\n+        Verify.checkEQ(13 * multiplicand, testMultBy13I(multiplicand));\n+    }\n+\n+    @Test\n+    @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_MULT_IMM_I, \"1\"})\n+    private static int testMultBy11I(int num) {\n+        return num * 11;\n+    }\n+\n+    @Run(test = \"testMultBy11I\")\n+    private static void runMultBy11I() {\n+        int multiplicand = RANDOM.nextInt();\n+        Verify.checkEQ(11 * multiplicand, testMultBy11I(multiplicand));\n+    }\n+\n+    @Test\n+    @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_MULT_IMM_L, \"1\"})\n+    private static long testMultBy81L(long num) {\n+        return num * 81;\n+    }\n+\n+    @Run(test = \"testMultBy81L\")\n+    private static void runMultBy81L() {\n+        long multiplicand = RANDOM.nextInt();\n+        Verify.checkEQ(81 * multiplicand, testMultBy81L(multiplicand));\n+    }\n+\n+    @Test\n+    @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_MULT_IMM_L, \"1\"})\n+    private static long testMultBy73L(long num) {\n+        return num * 73;\n+    }\n+\n+    @Run(test = \"testMultBy73L\")\n+    private static void runMultBy73L() {\n+        long multiplicand = RANDOM.nextInt();\n+        Verify.checkEQ(73 * multiplicand, testMultBy73L(multiplicand));\n+    }\n+\n+    @Test\n+    @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_MULT_IMM_L, \"1\"})\n+    private static long testMultBy45L(long num) {\n+        return num * 45;\n+    }\n+\n+    @Run(test = \"testMultBy45L\")\n+    private static void runMultBy45L() {\n+        long multiplicand = RANDOM.nextInt();\n+        Verify.checkEQ(45 * multiplicand, testMultBy45L(multiplicand));\n+    }\n+\n+    @Test\n+    @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_MULT_IMM_L, \"1\"})\n+    private static long testMultBy41L(long num) {\n+        return num * 41;\n+    }\n+\n+    @Run(test = \"testMultBy41L\")\n+    private static void runMultBy41L() {\n+        long multiplicand = RANDOM.nextInt();\n+        Verify.checkEQ(41 * multiplicand, testMultBy41L(multiplicand));\n+    }\n+\n+    @Test\n+    @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_MULT_IMM_L, \"1\"})\n+    private static long testMultBy37L(long num) {\n+        return num * 37;\n+    }\n+\n+    @Run(test = \"testMultBy37L\")\n+    private static void runMultBy37L() {\n+        long multiplicand = RANDOM.nextInt();\n+        Verify.checkEQ(37 * multiplicand, testMultBy37L(multiplicand));\n+    }\n+\n+    @Test\n+    @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_MULT_IMM_L, \"1\"})\n+    private static long testMultBy27L(long num) {\n+        return num * 27;\n+    }\n+\n+    @Run(test = \"testMultBy27L\")\n+    private static void runMultBy27L() {\n+        long multiplicand = RANDOM.nextInt();\n+        Verify.checkEQ(27 * multiplicand, testMultBy27L(multiplicand));\n+    }\n+\n+    @Test\n+    @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_MULT_IMM_L, \"1\"})\n+    private static long testMultBy25L(long num) {\n+        return num * 25;\n+    }\n+\n+    @Run(test = \"testMultBy25L\")\n+    private static void runMultBy25L() {\n+        long multiplicand = RANDOM.nextInt();\n+        Verify.checkEQ(25 * multiplicand, testMultBy25L(multiplicand));\n+    }\n+\n+    @Test\n+    @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_MULT_IMM_L, \"1\"})\n+    private static long testMultBy21L(long num) {\n+        return num * 21;\n+    }\n+\n+    @Run(test = \"testMultBy21L\")\n+    private static void runMultBy21L() {\n+        long multiplicand = RANDOM.nextInt();\n+        Verify.checkEQ(21 * multiplicand, testMultBy21L(multiplicand));\n+    }\n+\n+    @Test\n+    @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_MULT_IMM_L, \"1\"})\n+    private static long testMultBy19L(long num) {\n+        return num * 19;\n+    }\n+\n+    @Run(test = \"testMultBy19L\")\n+    private static void runMultBy19L() {\n+        long multiplicand = RANDOM.nextInt();\n+        Verify.checkEQ(19 * multiplicand, testMultBy19L(multiplicand));\n+    }\n+\n+    @Test\n+    @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_MULT_IMM_L, \"1\"})\n+    private static long testMultBy13L(long num) {\n+        return num * 13;\n+    }\n+\n+    @Run(test = \"testMultBy13L\")\n+    private static void runMultBy13L() {\n+        long multiplicand = RANDOM.nextInt();\n+        Verify.checkEQ(13 * multiplicand, testMultBy13L(multiplicand));\n+    }\n+\n+    @Test\n+    @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_MULT_IMM_L, \"1\"})\n+    private static long testMultBy11L(long num) {\n+        return num * 11;\n+    }\n+\n+    @Run(test = \"testMultBy11L\")\n+    private static void runMultBy11L() {\n+        long multiplicand = RANDOM.nextInt();\n+        Verify.checkEQ(11 * multiplicand, testMultBy11L(multiplicand));\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestConstantMultiplier.java","additions":309,"deletions":0,"binary":false,"changes":309,"status":"added"},{"patch":"@@ -2784,0 +2784,10 @@\n+    public static final String X86_MULT_IMM_I = PREFIX + \"X86_MULT_IMM_I\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_MULT_IMM_I, \"mulI_rReg_imm\");\n+    }\n+\n+    public static final String X86_MULT_IMM_L = PREFIX + \"X86_MULT_IMM_L\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_MULT_IMM_L, \"mulL_rReg_imm\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.lang.invoke.*;\n+import java.util.Random;\n+\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MINUTES)\n+@State(Scope.Thread)\n+@Fork(value = 1, jvmArgs = {\"-XX:LoopUnrollLimit=1\"})\n+public class ConstantMultiplierOptimization {\n+\n+    public static int mul_by_25_I(int a) {\n+       return a * 25;\n+    }\n+    public static int mul_by_27_I(int a) {\n+       return a * 27;\n+    }\n+    public static int mul_by_37_I(int a) {\n+       return a * 37;\n+    }\n+    public static int mul_by_19_I(int a) {\n+       return a * 19;\n+    }\n+    public static int mul_by_13_I(int a) {\n+       return a * 13;\n+    }\n+    public static int mul_by_11_I(int a) {\n+       return a * 11;\n+    }\n+\n+    public static long mul_by_25_L(long a) {\n+       return a * 25;\n+    }\n+    public static long mul_by_27_L(long a) {\n+       return a * 27;\n+    }\n+    public static long mul_by_37_L(long a) {\n+       return a * 37;\n+    }\n+    public static long mul_by_19_L(long a) {\n+       return a * 19;\n+    }\n+    public static long mul_by_13_L(long a) {\n+       return a * 13;\n+    }\n+    public static long mul_by_11_L(long a) {\n+       return a * 11;\n+    }\n+\n+    @Benchmark\n+    public long testConstMultiplierL() {\n+        long res = 0;\n+        for (long i = 0 ; i < 100000000; i++) {\n+            res += mul_by_37_L(i);\n+            res += mul_by_25_L(i);\n+            res += mul_by_27_L(i);\n+            res += mul_by_19_L(i);\n+            res += mul_by_13_L(i);\n+            res += mul_by_11_L(i);\n+        }\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public int testConstMultiplierI() {\n+        int res = 0;\n+        for (int i = 0 ; i < 100000000; i++) {\n+            res += mul_by_37_I(i);\n+            res += mul_by_25_I(i);\n+            res += mul_by_27_I(i);\n+            res += mul_by_19_I(i);\n+            res += mul_by_13_I(i);\n+            res += mul_by_11_I(i);\n+        }\n+        return res;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/ConstantMultiplierOptimization.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"}]}