{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -7046,0 +7046,71 @@\n+\n+\/\/\n+\/\/ Efficient LEA-based multiply emulation for immediates not easily handled\n+\/\/ by shift+add. Uses two fast LEAs based on Intel Optimization Manual,\n+\/\/ section \"3.5.1.2 Using LEA\". IMUL latency with register operands is 3 cycles,\n+\/\/ while fast LEA has 1 cycle. So two fast LEAs often outperform IMUL for\n+\/\/ specific constants.\n+\/\/\n+\/\/ The pattern table below lists:\n+\/\/   - First LEA:  BASE = src, INDEX = src, SCALE = s1\n+\/\/   - Second LEA: BASE = (use_src2 ? src : dst), INDEX = dst, SCALE = s2\n+\/\/\n+\/\/ All dst inputs for the second LEA are derived from “terminal” outputs.\n+\/\/\n+void C2_MacroAssembler::imullq_imm(BasicType bt, Register dst, Register src, int32_t imm) {\n+  assert(bt == T_LONG || bt == T_INT, \"Unexpected type\");\n+\n+  if (!VM_Version::supports_fast_2op_lea()) {\n+    imullq(bt, dst, src, imm);\n+    return;\n+  }\n+\n+  \/\/ Descriptor for one LEA pattern entry.\n+  struct LeaPattern {\n+    int32_t imm;\n+    \/\/ First LEA: dst = src + src * scale1\n+    Address::ScaleFactor scale1;\n+\n+    \/\/ Second LEA:\n+    \/\/ If use_src2 == true:\n+    \/\/     dst = src + dst * scale2\n+    \/\/ else:\n+    \/\/     dst = dst + dst * scale2\n+    bool use_src_as_base;\n+    Address::ScaleFactor scale2;\n+  };\n+\n+  static const LeaPattern patterns[] = {\n+    { 11, Address::times_4, true,  Address::times_2 },\n+    { 13, Address::times_2, true,  Address::times_4 },\n+    { 19, Address::times_8, true,  Address::times_2 },\n+    { 21, Address::times_4, true,  Address::times_4 },\n+    { 25, Address::times_4, false, Address::times_4 },\n+    { 27, Address::times_2, false, Address::times_8 },\n+    { 37, Address::times_8, true,  Address::times_4 },\n+    { 41, Address::times_4, true,  Address::times_8 },\n+    { 45, Address::times_4, false, Address::times_8 },\n+    { 73, Address::times_8, true,  Address::times_8 },\n+    { 81, Address::times_8, false, Address::times_8 },\n+  };\n+\n+  \/\/ Lookup table\n+  for (const LeaPattern& p : patterns) {\n+    if (p.imm == imm) {\n+      assert_different_registers(dst, src);\n+      \/\/ First LEA → dst = src + src * scale1\n+      lealq(bt, dst, Address(src, src, p.scale1));\n+\n+      \/\/ Second LEA\n+      if (p.use_src_as_base) {\n+        lealq(bt, dst, Address(src, dst, p.scale2));\n+      } else {\n+        lealq(bt, dst, Address(dst, dst, p.scale2));\n+      }\n+      return;\n+    }\n+  }\n+\n+  \/\/ Fallback: unsupported imm use IMUL\n+  imullq(bt, dst, src, imm);\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":72,"deletions":1,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -587,0 +587,2 @@\n+  void imullq_imm(BasicType bt, Register dst, Register src, int32_t imm);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -10009,0 +10009,18 @@\n+\n+void MacroAssembler::imullq(BasicType bt, Register dst, Register src, int32_t imm) {\n+  if (bt == T_LONG) {\n+    imulq(dst, src, imm);\n+  } else {\n+    assert(bt == T_INT, \"Unexpected type\");\n+    imull(dst, src, imm);\n+  }\n+}\n+\n+void MacroAssembler::lealq(BasicType bt, Register dst, Address src) {\n+  if (bt == T_LONG) {\n+    leaq(dst, src);\n+  } else {\n+    assert(bt == T_INT, \"Unexpected type\");\n+    leal(dst, src);\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -2066,0 +2066,3 @@\n+\n+  void imullq(BasicType bt, Register dst, Register src, int32_t imm);\n+  void lealq(BasicType bt, Register dst, Address src);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -11462,1 +11462,1 @@\n-  effect(KILL cr);\n+  effect(KILL cr, TEMP_DEF dst);\n@@ -11465,1 +11465,1 @@\n-  format %{ \"imull   $dst, $src, $imm\\t# int\" %}\n+  format %{ \"imull_imm  $dst, $src, $imm\\t# int\" %}\n@@ -11467,1 +11467,1 @@\n-    __ imull($dst$$Register, $src$$Register, $imm$$constant);\n+    __ imullq_imm(T_INT, $dst$$Register, $src$$Register, $imm$$constant);\n@@ -11501,1 +11501,1 @@\n-instruct mulI_mem_imm(rRegI dst, memory src, immI imm, rFlagsReg cr)\n+instruct mulI_mem_imm(rRegI dst, memory src, immI imm, rRegI rtmp, rFlagsReg cr)\n@@ -11504,1 +11504,1 @@\n-  effect(KILL cr);\n+  effect(KILL cr, TEMP dst, TEMP rtmp);\n@@ -11509,1 +11509,2 @@\n-    __ imull($dst$$Register, $src$$Address, $imm$$constant);\n+    __ movl($rtmp$$Register, $src$$Address);\n+    __ imullq_imm(T_INT, $dst$$Register, $rtmp$$Register, $imm$$constant);\n@@ -11556,1 +11557,1 @@\n-  effect(KILL cr);\n+  effect(KILL cr, TEMP_DEF dst);\n@@ -11559,1 +11560,1 @@\n-  format %{ \"imulq   $dst, $src, $imm\\t# long\" %}\n+  format %{ \"imulq_imm  $dst, $src, $imm\\t# long\" %}\n@@ -11561,1 +11562,1 @@\n-    __ imulq($dst$$Register, $src$$Register, $imm$$constant);\n+    __ imullq_imm(T_LONG, $dst$$Register, $src$$Register, $imm$$constant);\n@@ -11595,1 +11596,1 @@\n-instruct mulL_mem_imm(rRegL dst, memory src, immL32 imm, rFlagsReg cr)\n+instruct mulL_mem_imm(rRegL dst, memory src, immL32 imm, rRegL rtmp, rFlagsReg cr)\n@@ -11598,1 +11599,1 @@\n-  effect(KILL cr);\n+  effect(KILL cr, TEMP dst, TEMP rtmp);\n@@ -11603,1 +11604,2 @@\n-    __ imulq($dst$$Register, $src$$Address, $imm$$constant);\n+    __ movq($rtmp$$Register, $src$$Address);\n+    __ imullq_imm(T_LONG, $dst$$Register, $rtmp$$Register, $imm$$constant);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":14,"deletions":12,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8373480\n+ * @summary Optimize multiplication by constant multiplier using LEA instructions\n+ * @library \/test\/lib \/\n+ * @compile ..\/..\/compiler\/lib\/ir_framework\/TestFramework.java\n+ * @compile ..\/..\/compiler\/lib\/generators\/Generators.java\n+ * @compile ..\/..\/compiler\/lib\/verify\/Verify.java\n+ * @run driver compiler.c2.TestConstantMultiplier\n+ *\/\n+\n+package compiler.c2;\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.IntStream;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.verify.*;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.compile_framework.*;\n+import compiler.lib.generators.Generators;\n+import compiler.lib.template_framework.Template;\n+import compiler.lib.template_framework.TemplateToken;\n+import compiler.lib.template_framework.library.TestFrameworkClass;\n+\n+import static compiler.lib.template_framework.Template.scope;\n+import static compiler.lib.template_framework.Template.let;\n+\n+public class TestConstantMultiplier {\n+\n+    public static void main(String[] args) {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        \/\/ Add a java source file.\n+        comp.addJavaSourceCode(\"c2.compiler.ConstantMultiplierTest\", generate(comp));\n+\n+        \/\/ Compile the source file.\n+        comp.compile();\n+\n+        comp.invoke(\"c2.compiler.ConstantMultiplierTest\", \"main\", new Object[] {new String[] {}});\n+    }\n+\n+\n+    \/\/ Generate a source Java file as String\n+    public static String generate(CompileFramework comp) {\n+        var testHeader = Template.make(() -> scope(\n+            \"\"\"\n+                public static Random RANDOM = new Random(1023);\n+                public static int [] memI;\n+                public static long [] memL;\n+                public static int ITER = 15000;\n+\n+                static {\n+                    memL = new long[512];\n+                    Generators.G.fill(Generators.G.longs(), memL);\n+                    memI = new int[512];\n+                    Generators.G.fill(Generators.G.ints(), memI);\n+                }\n+\n+            \"\"\"\n+        ));\n+        var testTemplate1 = Template.make(() -> scope(\n+            IntStream.of(81, 73, 45, 41, 37, 27, 25, 21, 19, 13, 11).mapToObj(\n+                multiplier -> scope(\n+                    let(\"multiplier\", multiplier),\n+                    \"\"\"\n+                        @Test\n+                        @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_MULT_IMM_I, \"1\"})\n+                        private static int testMultBy#{multiplier}I(int num) {\n+                            return num * #{multiplier};\n+                        }\n+\n+                        @Run(test = \"testMultBy#{multiplier}I\", mode = RunMode.STANDALONE)\n+                        private static void runMultBy#{multiplier}I() {\n+                            int multiplicand = RANDOM.nextInt();\n+                            int res = 0;\n+                            for (int i = 0; i < ITER; i++) {\n+                                res += testMultBy#{multiplier}I(multiplicand);\n+                            }\n+                            Verify.checkEQ(#{multiplier} * multiplicand * ITER, res);\n+                        }\n+\n+                        @Test\n+                        @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_MULT_IMM_L, \"1\"})\n+                        private static long testMultBy#{multiplier}L(long num) {\n+                            return num * #{multiplier};\n+                        }\n+\n+                        @Run(test = \"testMultBy#{multiplier}L\", mode = RunMode.STANDALONE)\n+                        private static void runMultBy#{multiplier}L() {\n+                            long multiplicand = RANDOM.nextInt();\n+                            long res = 0;\n+                            for (int i = 0; i < ITER; i++) {\n+                                res += testMultBy#{multiplier}L(multiplicand);\n+                            }\n+                            Verify.checkEQ(#{multiplier} * multiplicand * ITER, res);\n+                        }\n+                    \"\"\"\n+            )).toList()\n+        ));\n+\n+        var testTemplate2 = Template.make(() -> scope(\n+            IntStream.of(81, 73, 45, 41, 37, 27, 25, 21, 19, 13, 11).mapToObj(\n+                multiplier -> scope(\n+                    let(\"multiplier\", multiplier),\n+                    \"\"\"\n+                        @Test\n+                        @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_MULT_MEM_IMM_I, \"1\"})\n+                        private static int testMultBy#{multiplier}I_mem(int index) {\n+                            return memI[index] * #{multiplier};\n+                        }\n+\n+                        @Run(test = \"testMultBy#{multiplier}I_mem\", mode = RunMode.STANDALONE)\n+                        private static void runMultBy#{multiplier}I_mem() {\n+                            int index = RANDOM.nextInt(memI.length);\n+                            int res = 0;\n+                            for (int i = 0; i < ITER; i++) {\n+                                res += testMultBy#{multiplier}I_mem(index);\n+                            }\n+                            Verify.checkEQ(#{multiplier} * memI[index] * ITER, res);\n+                        }\n+\n+                        @Test\n+                        @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_MULT_MEM_IMM_L, \"1\"})\n+                        private static long testMultBy#{multiplier}L_mem(int index) {\n+                            return memL[index] * #{multiplier};\n+                        }\n+\n+                        @Run(test = \"testMultBy#{multiplier}L_mem\", mode = RunMode.STANDALONE)\n+                        private static void runMultBy#{multiplier}L_mem() {\n+                            int index = RANDOM.nextInt(memL.length);\n+                            long res = 0;\n+                            for (int i = 0; i < ITER; i++) {\n+                                res += testMultBy#{multiplier}L_mem(index);\n+                            }\n+                            Verify.checkEQ(#{multiplier} * memL[index] * ITER, res);\n+                        }\n+                    \"\"\"\n+            )).toList()\n+        ));\n+\n+        var testClass = Template.make(() -> scope(\n+            testHeader.asToken(),\n+            testTemplate1.asToken(),\n+            testTemplate2.asToken()\n+        ));\n+\n+        List<TemplateToken> testTemplateTokens = List.of(testClass.asToken());\n+\n+        return TestFrameworkClass.render(\n+            \/\/ package and class name.\n+            \"c2.compiler\", \"ConstantMultiplierTest\",\n+            \/\/ Set of imports.\n+            Set.of(\"java.util.Random\",\"compiler.lib.verify.*\", \"compiler.lib.generators.*\"),\n+            \/\/ classpath, so the Test VM has access to the compiled class files.\n+            comp.getEscapedClassPathOfCompiledClasses(),\n+            \/\/ The list of tests.\n+            testTemplateTokens);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestConstantMultiplier.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -2774,0 +2774,20 @@\n+    public static final String X86_MULT_IMM_I = PREFIX + \"X86_MULT_IMM_I\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_MULT_IMM_I, \"mulI_rReg_imm\");\n+    }\n+\n+    public static final String X86_MULT_IMM_L = PREFIX + \"X86_MULT_IMM_L\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_MULT_IMM_L, \"mulL_rReg_imm\");\n+    }\n+\n+    public static final String X86_MULT_MEM_IMM_I = PREFIX + \"X86_MULT_MEM_IMM_I\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_MULT_MEM_IMM_I, \"mulI_mem_imm\");\n+    }\n+\n+    public static final String X86_MULT_MEM_IMM_L = PREFIX + \"X86_MULT_MEM_IMM_L\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_MULT_MEM_IMM_L, \"mulL_mem_imm\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,213 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.lang.invoke.*;\n+import java.util.Random;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MINUTES)\n+@State(Scope.Thread)\n+@Fork(value = 1, jvmArgs = {\"-XX:LoopUnrollLimit=1\"})\n+public class ConstantMultiplierOptimization {\n+\n+    public static int  [] memI;\n+    public static long [] memL;\n+\n+    @Setup\n+    public void BMSetup() {\n+        memI = IntStream.range(0, 1024).toArray();\n+        memL = LongStream.range(0, 1024).toArray();\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static int mul_by_25_I(int a) {\n+       return a * 25;\n+    }\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static int mul_by_27_I(int a) {\n+       return a * 27;\n+    }\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static int mul_by_37_I(int a) {\n+       return a * 37;\n+    }\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static int mul_by_19_I(int a) {\n+       return a * 19;\n+    }\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static int mul_by_13_I(int a) {\n+       return a * 13;\n+    }\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static int mul_by_11_I(int a) {\n+       return a * 11;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static long mul_by_25_L(long a) {\n+       return a * 25;\n+    }\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static long mul_by_27_L(long a) {\n+       return a * 27;\n+    }\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static long mul_by_37_L(long a) {\n+       return a * 37;\n+    }\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static long mul_by_19_L(long a) {\n+       return a * 19;\n+    }\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static long mul_by_13_L(long a) {\n+       return a * 13;\n+    }\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static long mul_by_11_L(long a) {\n+       return a * 11;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static int mul_by_25_I_mem(int index) {\n+       return memI[index] * 25;\n+    }\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static int mul_by_27_I_mem(int index) {\n+       return memI[index] * 27;\n+    }\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static int mul_by_37_I_mem(int index) {\n+       return memI[index] * 37;\n+    }\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static int mul_by_19_I_mem(int index) {\n+       return memI[index] * 19;\n+    }\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static int mul_by_13_I_mem(int index) {\n+       return memI[index] * 13;\n+    }\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static int mul_by_11_I_mem(int index) {\n+       return memI[index] * 11;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static long mul_by_25_L_mem(int index) {\n+       return memL[index] * 25;\n+    }\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static long mul_by_27_L_mem(int index) {\n+       return memL[index] * 27;\n+    }\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static long mul_by_37_L_mem(int index) {\n+       return memL[index] * 37;\n+    }\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static long mul_by_19_L_mem(int index) {\n+       return memL[index] * 19;\n+    }\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static long mul_by_13_L_mem(int index) {\n+       return memL[index] * 13;\n+    }\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static long mul_by_11_L_mem(int index) {\n+       return memL[index] * 11;\n+    }\n+\n+    @Benchmark\n+    public long testConstMultiplierL() {\n+        long res = 0;\n+        for (long i = 0 ; i < 100000000; i++) {\n+            res += mul_by_37_L(i);\n+            res += mul_by_25_L(i);\n+            res += mul_by_27_L(i);\n+            res += mul_by_19_L(i);\n+            res += mul_by_13_L(i);\n+            res += mul_by_11_L(i);\n+        }\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public int testConstMultiplierI() {\n+        int res = 0;\n+        for (int i = 0 ; i < 100000000; i++) {\n+            res += mul_by_37_I(i);\n+            res += mul_by_25_I(i);\n+            res += mul_by_27_I(i);\n+            res += mul_by_19_I(i);\n+            res += mul_by_13_I(i);\n+            res += mul_by_11_I(i);\n+        }\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public long testConstMultiplierL_mem() {\n+        long res = 0;\n+        for (int j = 0; j < memL.length; j += 2) {\n+            res += mul_by_37_L_mem(j);\n+            res += mul_by_25_L_mem(j);\n+            res += mul_by_27_L_mem(j);\n+            res += mul_by_19_L_mem(j);\n+            res += mul_by_13_L_mem(j);\n+            res += mul_by_11_L_mem(j);\n+        }\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public int testConstMultiplierI_mem() {\n+        int res = 0;\n+        for (int j = 0 ; j < memI.length; j += 2) {\n+            res += mul_by_37_I_mem(j);\n+            res += mul_by_25_I_mem(j);\n+            res += mul_by_27_I_mem(j);\n+            res += mul_by_19_I_mem(j);\n+            res += mul_by_13_I_mem(j);\n+            res += mul_by_11_I_mem(j);\n+        }\n+        return res;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/ConstantMultiplierOptimization.java","additions":213,"deletions":0,"binary":false,"changes":213,"status":"added"}]}