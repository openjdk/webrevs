{"files":[{"patch":"@@ -130,0 +130,20 @@\n+bool ParallelCompactData::RegionData::is_clear() {\n+  return (_destination == nullptr) &&\n+         (_source_region == 0) &&\n+         (_partial_obj_addr == nullptr) &&\n+         (_partial_obj_size == 0) &&\n+         (_dc_and_los == 0) &&\n+         (_shadow_state == 0);\n+}\n+\n+#ifdef ASSERT\n+void ParallelCompactData::RegionData::verify_clear() {\n+  assert(_destination == nullptr, \"inv\");\n+  assert(_source_region == 0, \"inv\");\n+  assert(_partial_obj_addr == nullptr, \"inv\");\n+  assert(_partial_obj_size == 0, \"inv\");\n+  assert(_dc_and_los == 0, \"inv\");\n+  assert(_shadow_state == 0, \"inv\");\n+}\n+#endif\n+\n@@ -135,6 +155,2 @@\n-void SplitInfo::record(size_t src_region_idx, size_t partial_obj_size,\n-                       HeapWord* destination)\n-{\n-  assert(src_region_idx != 0, \"invalid src_region_idx\");\n-  assert(partial_obj_size != 0, \"invalid partial_obj_size argument\");\n-  assert(destination != nullptr, \"invalid destination argument\");\n+void SplitInfo::record(size_t split_region_idx, HeapWord* split_point, size_t preceding_live_words) {\n+  assert(split_region_idx != 0, \"precondition\");\n@@ -142,3 +158,2 @@\n-  _src_region_idx = src_region_idx;\n-  _partial_obj_size = partial_obj_size;\n-  _destination = destination;\n+  \/\/ Obj denoted by split_point will be deferred to the next space.\n+  assert(split_point != nullptr, \"precondition\");\n@@ -146,6 +161,0 @@\n-  \/\/ These fields may not be updated below, so make sure they're clear.\n-  assert(_dest_region_addr == nullptr, \"should have been cleared\");\n-  assert(_first_src_addr == nullptr, \"should have been cleared\");\n-\n-  \/\/ Determine the number of destination regions for the partial object.\n-  HeapWord* const last_word = destination + partial_obj_size - 1;\n@@ -153,12 +162,11 @@\n-  HeapWord* const beg_region_addr = sd.region_align_down(destination);\n-  HeapWord* const end_region_addr = sd.region_align_down(last_word);\n-\n-  if (beg_region_addr == end_region_addr) {\n-    \/\/ One destination region.\n-    _destination_count = 1;\n-    if (end_region_addr == destination) {\n-      \/\/ The destination falls on a region boundary, thus the first word of the\n-      \/\/ partial object will be the first word copied to the destination region.\n-      _dest_region_addr = end_region_addr;\n-      _first_src_addr = sd.region_to_addr(src_region_idx);\n-    }\n+\n+  PSParallelCompact::RegionData* split_region_ptr = sd.region(split_region_idx);\n+  assert(preceding_live_words < split_region_ptr->data_size(), \"inv\");\n+\n+  HeapWord* preceding_destination = split_region_ptr->destination();\n+  assert(preceding_destination != nullptr, \"inv\");\n+\n+  \/\/ How many regions does the preceding part occupy\n+  uint preceding_destination_count;\n+  if (preceding_live_words == 0) {\n+    preceding_destination_count = 0;\n@@ -166,8 +174,7 @@\n-    \/\/ Two destination regions.  When copied, the partial object will cross a\n-    \/\/ destination region boundary, so a word somewhere within the partial\n-    \/\/ object will be the first word copied to the second destination region.\n-    _destination_count = 2;\n-    _dest_region_addr = end_region_addr;\n-    const size_t ofs = pointer_delta(end_region_addr, destination);\n-    assert(ofs < _partial_obj_size, \"sanity\");\n-    _first_src_addr = sd.region_to_addr(src_region_idx) + ofs;\n+    \/\/ -1 so that the ending address doesn't fall on the region-boundary\n+    if (sd.region_align_down(preceding_destination) ==\n+        sd.region_align_down(preceding_destination + preceding_live_words - 1)) {\n+      preceding_destination_count = 1;\n+    } else {\n+      preceding_destination_count = 2;\n+    }\n@@ -175,0 +182,6 @@\n+\n+  _split_region_idx = split_region_idx;\n+  _split_point = split_point;\n+  _preceding_live_words = preceding_live_words;\n+  _preceding_destination = preceding_destination;\n+  _preceding_destination_count = preceding_destination_count;\n@@ -179,6 +192,5 @@\n-  _src_region_idx = 0;\n-  _partial_obj_size = 0;\n-  _destination = nullptr;\n-  _destination_count = 0;\n-  _dest_region_addr = nullptr;\n-  _first_src_addr = nullptr;\n+  _split_region_idx = 0;\n+  _split_point = nullptr;\n+  _preceding_live_words = 0;\n+  _preceding_destination = nullptr;\n+  _preceding_destination_count = 0;\n@@ -191,6 +203,5 @@\n-  assert(_src_region_idx == 0, \"not clear\");\n-  assert(_partial_obj_size == 0, \"not clear\");\n-  assert(_destination == nullptr, \"not clear\");\n-  assert(_destination_count == 0, \"not clear\");\n-  assert(_dest_region_addr == nullptr, \"not clear\");\n-  assert(_first_src_addr == nullptr, \"not clear\");\n+  assert(_split_region_idx == 0, \"not clear\");\n+  assert(_split_point == nullptr, \"not clear\");\n+  assert(_preceding_live_words == 0, \"not clear\");\n+  assert(_preceding_destination == nullptr, \"not clear\");\n+  assert(_preceding_destination_count == 0, \"not clear\");\n@@ -299,23 +310,8 @@\n-\/\/ Find the point at which a space can be split and, if necessary, record the\n-\/\/ split point.\n-\/\/\n-\/\/ If the current src region (which overflowed the destination space) doesn't\n-\/\/ have a partial object, the split point is at the beginning of the current src\n-\/\/ region (an \"easy\" split, no extra bookkeeping required).\n-\/\/\n-\/\/ If the current src region has a partial object, the split point is in the\n-\/\/ region where that partial object starts (call it the split_region).  If\n-\/\/ split_region has a partial object, then the split point is just after that\n-\/\/ partial object (a \"hard\" split where we have to record the split data and\n-\/\/ zero the partial_obj_size field).  With a \"hard\" split, we know that the\n-\/\/ partial_obj ends within split_region because the partial object that caused\n-\/\/ the overflow starts in split_region.  If split_region doesn't have a partial\n-\/\/ obj, then the split is at the beginning of split_region (another \"easy\"\n-\/\/ split).\n-HeapWord*\n-ParallelCompactData::summarize_split_space(size_t src_region,\n-                                           SplitInfo& split_info,\n-                                           HeapWord* destination,\n-                                           HeapWord* target_end,\n-                                           HeapWord** target_next)\n-{\n+\/\/ The total live words on src_region would overflow the target space, so find\n+\/\/ the overflowing object and record the split point. The invariant is that an\n+\/\/ obj should not cross space boundary.\n+HeapWord* ParallelCompactData::summarize_split_space(size_t src_region,\n+                                                     SplitInfo& split_info,\n+                                                     HeapWord* const destination,\n+                                                     HeapWord* const target_end,\n+                                                     HeapWord** target_next) {\n@@ -327,2 +323,0 @@\n-  size_t split_region = src_region;\n-  HeapWord* split_destination = destination;\n@@ -332,3 +326,4 @@\n-    \/\/ The split point is just after the partial object (if any) in the\n-    \/\/ src_region that contains the start of the object that overflowed the\n-    \/\/ destination space.\n+    assert(partial_obj_size > 0, \"inv\");\n+    \/\/ The overflowing obj is from a previous region.\n+    \/\/\n+    \/\/ source-regions:\n@@ -336,8 +331,5 @@\n-    \/\/ Find the start of the \"overflow\" object and set split_region to the\n-    \/\/ region containing it.\n-    HeapWord* const overflow_obj = _region_data[src_region].partial_obj_addr();\n-    split_region = addr_to_region_idx(overflow_obj);\n-\n-    \/\/ Clear the source_region field of all destination regions whose first word\n-    \/\/ came from data after the split point (a non-null source_region field\n-    \/\/ implies a region must be filled).\n+    \/\/ ***************\n+    \/\/ |     A|AA    |\n+    \/\/ ***************\n+    \/\/       ^\n+    \/\/       | split-point\n@@ -345,4 +337,1 @@\n-    \/\/ An alternative to the simple loop below:  clear during post_compact(),\n-    \/\/ which uses memcpy instead of individual stores, and is easy to\n-    \/\/ parallelize.  (The downside is that it clears the entire RegionData\n-    \/\/ object as opposed to just one field.)\n+    \/\/ dest-region:\n@@ -350,2 +339,7 @@\n-    \/\/ post_compact() would have to clear the summary data up to the highest\n-    \/\/ address that was written during the summary phase, which would be\n+    \/\/ ********\n+    \/\/ |~~~~A |\n+    \/\/ ********\n+    \/\/       ^^\n+    \/\/       || target-space-end\n+    \/\/       |\n+    \/\/       | destination\n@@ -353,1 +347,1 @@\n-    \/\/         max(top, max(new_top, clear_top))\n+    \/\/ AAA would overflow target-space.\n@@ -355,7 +349,2 @@\n-    \/\/ where clear_top is a new field in SpaceInfo.  Would have to set clear_top\n-    \/\/ to target_end.\n-    const RegionData* const sr = region(split_region);\n-    const size_t beg_idx =\n-      addr_to_region_idx(region_align_up(sr->destination() +\n-                                         sr->partial_obj_size()));\n-    const size_t end_idx = addr_to_region_idx(target_end);\n+    HeapWord* overflowing_obj = _region_data[src_region].partial_obj_addr();\n+    size_t split_region = addr_to_region_idx(overflowing_obj);\n@@ -363,3 +352,8 @@\n-    log_develop_trace(gc, compaction)(\"split:  clearing source_region field in [\" SIZE_FORMAT \", \" SIZE_FORMAT \")\", beg_idx, end_idx);\n-    for (size_t idx = beg_idx; idx < end_idx; ++idx) {\n-      _region_data[idx].set_source_region(0);\n+    \/\/ The number of live words before the overflowing object on this split region\n+    size_t preceding_live_words;\n+    if (is_region_aligned(overflowing_obj)) {\n+      preceding_live_words = 0;\n+    } else {\n+      \/\/ Words accounted by the overflowing object on the split region\n+      size_t overflowing_size = pointer_delta(region_align_up(overflowing_obj), overflowing_obj);\n+      preceding_live_words = region(split_region)->data_size() - overflowing_size;\n@@ -368,4 +362,16 @@\n-    \/\/ Set split_destination and partial_obj_size to reflect the split region.\n-    split_destination = sr->destination();\n-    partial_obj_size = sr->partial_obj_size();\n-  }\n+    split_info.record(split_region, overflowing_obj, preceding_live_words);\n+\n+    HeapWord* src_region_start = region_to_addr(src_region);\n+    HeapWord* new_top = destination - pointer_delta(src_region_start, overflowing_obj);\n+\n+    \/\/ If the overflowing obj was relocated to its original destination,\n+    \/\/ those destination regions would have their source_region set. Now that\n+    \/\/ this overflowing obj is relocated somewhere else, reset the\n+    \/\/ source_region.\n+    {\n+      size_t range_start = addr_to_region_idx(region_align_up(new_top));\n+      size_t range_end = addr_to_region_idx(region_align_up(destination));\n+      for (size_t i = range_start; i < range_end; ++i) {\n+        region(i)->set_source_region(0);\n+      }\n+    }\n@@ -373,4 +379,4 @@\n-  \/\/ The split is recorded only if a partial object extends onto the region.\n-  if (partial_obj_size != 0) {\n-    _region_data[split_region].set_partial_obj_size(0);\n-    split_info.record(split_region, partial_obj_size, split_destination);\n+    \/\/ Update new top of target space\n+    *target_next = new_top;\n+\n+    return overflowing_obj;\n@@ -379,3 +385,5 @@\n-  \/\/ Setup the continuation addresses.\n-  *target_next = split_destination + partial_obj_size;\n-  HeapWord* const source_next = region_to_addr(split_region) + partial_obj_size;\n+  \/\/ Obj-iteration to locate the overflowing obj\n+  HeapWord* region_start = region_to_addr(src_region);\n+  HeapWord* region_end = region_start + RegionSize;\n+  HeapWord* cur_addr = region_start + partial_obj_size;\n+  size_t live_words = partial_obj_size;\n@@ -383,8 +391,5 @@\n-  if (log_develop_is_enabled(Trace, gc, compaction)) {\n-    const char * split_type = partial_obj_size == 0 ? \"easy\" : \"hard\";\n-    log_develop_trace(gc, compaction)(\"%s split:  src=\" PTR_FORMAT \" src_c=\" SIZE_FORMAT \" pos=\" SIZE_FORMAT,\n-                                      split_type, p2i(source_next), split_region, partial_obj_size);\n-    log_develop_trace(gc, compaction)(\"%s split:  dst=\" PTR_FORMAT \" dst_c=\" SIZE_FORMAT \" tn=\" PTR_FORMAT,\n-                                      split_type, p2i(split_destination),\n-                                      addr_to_region_idx(split_destination),\n-                                      p2i(*target_next));\n+  while (true) {\n+    assert(cur_addr < region_end, \"inv\");\n+    cur_addr = PSParallelCompact::mark_bitmap()->find_obj_beg(cur_addr, region_end);\n+    \/\/ There must be an overflowing obj in this region\n+    assert(cur_addr < region_end, \"inv\");\n@@ -392,7 +397,7 @@\n-    if (partial_obj_size != 0) {\n-      HeapWord* const po_beg = split_info.destination();\n-      HeapWord* const po_end = po_beg + split_info.partial_obj_size();\n-      log_develop_trace(gc, compaction)(\"%s split:  po_beg=\" PTR_FORMAT \" \" SIZE_FORMAT \" po_end=\" PTR_FORMAT \" \" SIZE_FORMAT,\n-                                        split_type,\n-                                        p2i(po_beg), addr_to_region_idx(po_beg),\n-                                        p2i(po_end), addr_to_region_idx(po_end));\n+    oop obj = cast_to_oop(cur_addr);\n+    size_t obj_size = obj->size();\n+    if (destination + live_words + obj_size > target_end) {\n+      \/\/ Found the overflowing obj\n+      split_info.record(src_region, cur_addr, live_words);\n+      *target_next = destination + live_words;\n+      return cur_addr;\n@@ -400,1 +405,0 @@\n-  }\n@@ -402,1 +406,3 @@\n-  return source_next;\n+    live_words += obj_size;\n+    cur_addr += obj_size;\n+  }\n@@ -454,2 +460,13 @@\n-  while (cur_region < end_region) {\n-    \/\/ The destination must be set even if the region has no data.\n+  for (\/* empty *\/; cur_region < end_region; cur_region++) {\n+    size_t words = _region_data[cur_region].data_size();\n+\n+    \/\/ Skip empty ones\n+    if (words == 0) {\n+      continue;\n+    }\n+\n+    if (split_info.is_split(cur_region)) {\n+      assert(words > split_info.preceding_live_words(), \"inv\");\n+      words -= split_info.preceding_live_words();\n+    }\n+\n@@ -458,11 +475,9 @@\n-    size_t words = _region_data[cur_region].data_size();\n-    if (words > 0) {\n-      \/\/ If cur_region does not fit entirely into the target space, find a point\n-      \/\/ at which the source space can be 'split' so that part is copied to the\n-      \/\/ target space and the rest is copied elsewhere.\n-      if (dest_addr + words > target_end) {\n-        assert(source_next != nullptr, \"source_next is null when splitting\");\n-        *source_next = summarize_split_space(cur_region, split_info, dest_addr,\n-                                             target_end, target_next);\n-        return false;\n-      }\n+    \/\/ If cur_region does not fit entirely into the target space, find a point\n+    \/\/ at which the source space can be 'split' so that part is copied to the\n+    \/\/ target space and the rest is copied elsewhere.\n+    if (dest_addr + words > target_end) {\n+      assert(source_next != nullptr, \"source_next is null when splitting\");\n+      *source_next = summarize_split_space(cur_region, split_info, dest_addr,\n+                                           target_end, target_next);\n+      return false;\n+    }\n@@ -470,22 +485,3 @@\n-      \/\/ Compute the destination_count for cur_region, and if necessary, update\n-      \/\/ source_region for a destination region.  The source_region field is\n-      \/\/ updated if cur_region is the first (left-most) region to be copied to a\n-      \/\/ destination region.\n-      \/\/\n-      \/\/ The destination_count calculation is a bit subtle.  A region that has\n-      \/\/ data that compacts into itself does not count itself as a destination.\n-      \/\/ This maintains the invariant that a zero count means the region is\n-      \/\/ available and can be claimed and then filled.\n-      uint destination_count = 0;\n-      if (split_info.is_split(cur_region)) {\n-        \/\/ The current region has been split:  the partial object will be copied\n-        \/\/ to one destination space and the remaining data will be copied to\n-        \/\/ another destination space.  Adjust the initial destination_count and,\n-        \/\/ if necessary, set the source_region field if the partial object will\n-        \/\/ cross a destination region boundary.\n-        destination_count = split_info.destination_count();\n-        if (destination_count == 2) {\n-          size_t dest_idx = addr_to_region_idx(split_info.dest_region_addr());\n-          _region_data[dest_idx].set_source_region(cur_region);\n-        }\n-      }\n+    uint destination_count = split_info.is_split(cur_region)\n+                             ? split_info.preceding_destination_count()\n+                             : 0;\n@@ -493,19 +489,3 @@\n-      HeapWord* const last_addr = dest_addr + words - 1;\n-      const size_t dest_region_1 = addr_to_region_idx(dest_addr);\n-      const size_t dest_region_2 = addr_to_region_idx(last_addr);\n-\n-      \/\/ Initially assume that the destination regions will be the same and\n-      \/\/ adjust the value below if necessary.  Under this assumption, if\n-      \/\/ cur_region == dest_region_2, then cur_region will be compacted\n-      \/\/ completely into itself.\n-      destination_count += cur_region == dest_region_2 ? 0 : 1;\n-      if (dest_region_1 != dest_region_2) {\n-        \/\/ Destination regions differ; adjust destination_count.\n-        destination_count += 1;\n-        \/\/ Data from cur_region will be copied to the start of dest_region_2.\n-        _region_data[dest_region_2].set_source_region(cur_region);\n-      } else if (is_region_aligned(dest_addr)) {\n-        \/\/ Data from cur_region will be copied to the start of the destination\n-        \/\/ region.\n-        _region_data[dest_region_1].set_source_region(cur_region);\n-      }\n+    HeapWord* const last_addr = dest_addr + words - 1;\n+    const size_t dest_region_1 = addr_to_region_idx(dest_addr);\n+    const size_t dest_region_2 = addr_to_region_idx(last_addr);\n@@ -513,2 +493,14 @@\n-      _region_data[cur_region].set_destination_count(destination_count);\n-      dest_addr += words;\n+    \/\/ Initially assume that the destination regions will be the same and\n+    \/\/ adjust the value below if necessary.  Under this assumption, if\n+    \/\/ cur_region == dest_region_2, then cur_region will be compacted\n+    \/\/ completely into itself.\n+    destination_count += cur_region == dest_region_2 ? 0 : 1;\n+    if (dest_region_1 != dest_region_2) {\n+      \/\/ Destination regions differ; adjust destination_count.\n+      destination_count += 1;\n+      \/\/ Data from cur_region will be copied to the start of dest_region_2.\n+      _region_data[dest_region_2].set_source_region(cur_region);\n+    } else if (is_region_aligned(dest_addr)) {\n+      \/\/ Data from cur_region will be copied to the start of the destination\n+      \/\/ region.\n+      _region_data[dest_region_1].set_source_region(cur_region);\n@@ -517,1 +509,2 @@\n-    ++cur_region;\n+    _region_data[cur_region].set_destination_count(destination_count);\n+    dest_addr += words;\n@@ -525,6 +518,6 @@\n-void ParallelCompactData::verify_clear()\n-{\n-  const size_t* const beg = (const size_t*) _region_vspace->committed_low_addr();\n-  const size_t* const end = (const size_t*) _region_vspace->committed_high_addr();\n-  for (const size_t* p = beg; p < end; ++p) {\n-    assert(*p == 0, \"not zero\");\n+void ParallelCompactData::verify_clear() {\n+  for (uint cur_idx = 0; cur_idx < region_count(); ++cur_idx) {\n+    if (!region(cur_idx)->is_clear()) {\n+      log_warning(gc)(\"Uncleared Region: %u\", cur_idx);\n+      region(cur_idx)->verify_clear();\n+    }\n@@ -697,0 +690,7 @@\n+#ifdef ASSERT\n+  {\n+    mark_bitmap()->verify_clear();\n+    summary_data().verify_clear();\n+  }\n+#endif\n+\n@@ -883,4 +883,4 @@\n-    HeapWord* dense_prefix_end =\n-      maximum_compaction ? full_region_prefix_end\n-                         : compute_dense_prefix_for_old_space(old_space,\n-                                                              full_region_prefix_end);\n+    HeapWord* dense_prefix_end = maximum_compaction\n+                                 ? full_region_prefix_end\n+                                 : compute_dense_prefix_for_old_space(old_space,\n+                                                                      full_region_prefix_end);\n@@ -894,0 +894,2 @@\n+\n+    \/\/ Compacting objs inn [dense_prefix_end, old_space->top())\n@@ -1553,0 +1555,24 @@\n+    static void forward_objs_in_range(ParCompactionManager* cm,\n+                                      HeapWord* start,\n+                                      HeapWord* end,\n+                                      HeapWord* destination) {\n+      HeapWord* cur_addr = start;\n+      HeapWord* new_addr = destination;\n+\n+      while (cur_addr < end) {\n+        cur_addr = mark_bitmap()->find_obj_beg(cur_addr, end);\n+        if (cur_addr >= end) {\n+          return;\n+        }\n+        assert(mark_bitmap()->is_marked(cur_addr), \"inv\");\n+        oop obj = cast_to_oop(cur_addr);\n+        if (new_addr != cur_addr) {\n+          cm->preserved_marks()->push_if_necessary(obj, obj->mark());\n+          obj->forward_to(cast_to_oop(new_addr));\n+        }\n+        size_t obj_size = obj->size();\n+        new_addr += obj_size;\n+        cur_addr += obj_size;\n+      }\n+    }\n+\n@@ -1564,0 +1590,2 @@\n+        const SplitInfo& split_info = _space_info[SpaceId(id)].split_info();\n+\n@@ -1583,18 +1611,13 @@\n-          HeapWord* cur_addr = region_start + live_words;\n-\n-          HeapWord* destination = region_ptr->destination();\n-          while (cur_addr < region_end) {\n-            cur_addr = mark_bitmap()->find_obj_beg(cur_addr, region_end);\n-            if (cur_addr >= region_end) {\n-              break;\n-            }\n-            assert(mark_bitmap()->is_marked(cur_addr), \"inv\");\n-            HeapWord* new_addr = destination + live_words;\n-            oop obj = cast_to_oop(cur_addr);\n-            if (new_addr != cur_addr) {\n-              cm->preserved_marks()->push_if_necessary(obj, obj->mark());\n-              obj->forward_to(cast_to_oop(new_addr));\n-            }\n-            size_t obj_size = obj->size();\n-            live_words += obj_size;\n-            cur_addr += obj_size;\n+\n+          if (split_info.is_split(cur_region)) {\n+            \/\/ Part 1: will be relocated to space-1\n+            HeapWord* preceding_destination = split_info.preceding_destination();\n+            HeapWord* split_point = split_info.split_point();\n+            forward_objs_in_range(cm, region_start + live_words, split_point, preceding_destination + live_words);\n+\n+            \/\/ Part 2: will be relocated to space-2\n+            HeapWord* destination = region_ptr->destination();\n+            forward_objs_in_range(cm, split_point, region_end, destination);\n+          } else {\n+            HeapWord* destination = region_ptr->destination();\n+            forward_objs_in_range(cm, region_start + live_words, region_end, destination + live_words);\n@@ -1632,0 +1655,1 @@\n+      assert(bump_ptr <= _space_info[bump_ptr_space].new_top(), \"inv\");\n@@ -1638,1 +1662,3 @@\n-      if (cur_addr != bump_ptr) {\n+      if (cur_addr == bump_ptr) {\n+        assert(!obj->is_forwarded(), \"inv\");\n+      } else {\n@@ -1944,6 +1970,3 @@\n-\/\/ next live word.  Unless marked, the word corresponding to beg is assumed to\n-\/\/ be dead.  Callers must either ensure beg does not correspond to the middle of\n-\/\/ an object, or account for those live words in some other way.  Callers must\n-\/\/ also ensure that there are enough live words in the range [beg, end) to skip.\n-HeapWord*\n-PSParallelCompact::skip_live_words(HeapWord* beg, HeapWord* end, size_t count)\n+\/\/ next live word. Callers must also ensure that there are enough live words in\n+\/\/ the range [beg, end) to skip.\n+HeapWord* PSParallelCompact::skip_live_words(HeapWord* beg, HeapWord* end, size_t count)\n@@ -1951,2 +1974,0 @@\n-  assert(count > 0, \"sanity\");\n-\n@@ -1968,0 +1989,39 @@\n+\/\/ On filling a destination region (dest-region), we need to know the location\n+\/\/ of the word that will be at the start of the dest-region after compaction.\n+\/\/ A dest-region can have one or more source regions, but only the first\n+\/\/ source-region contains this location. This location is retrieved by calling\n+\/\/ `first_src_addr` on a dest-region.\n+\/\/ Conversely, a source-region has a dest-region which holds the destination of\n+\/\/ the first live word on this source-region, based on which the destination\n+\/\/ for the rest of live words can be derived.\n+\/\/\n+\/\/ Note:\n+\/\/ There is some complication due to space-boundary-fragmentation (an obj can't\n+\/\/ cross space-boundary) -- a source-region may be split and behave like two\n+\/\/ distinct regions with their own dest-region, as depicted below.\n+\/\/\n+\/\/ source-region: region-n\n+\/\/\n+\/\/ **********************\n+\/\/ |     A|A~~~~B|B     |\n+\/\/ **********************\n+\/\/    n-1     n     n+1\n+\/\/\n+\/\/ AA, BB denote two live objs. ~~~~ denotes unknown number of live objs.\n+\/\/\n+\/\/ Assuming the dest-region for region-n is the final region before\n+\/\/ old-space-end and its first-live-word is the middle of AA, the heap content\n+\/\/ will look like the following after compaction:\n+\/\/\n+\/\/ **************                  *************\n+\/\/      A|A~~~~ |                  |BB    |\n+\/\/ **************                  *************\n+\/\/              ^                  ^\n+\/\/              | old-space-end    | eden-space-start\n+\/\/\n+\/\/ Therefore, in this example, region-n will have two dest-regions, one for\n+\/\/ the final region in old-space and the other for the first region in\n+\/\/ eden-space.\n+\/\/ To handle this special case, we introduce the concept of split-region, whose\n+\/\/ contents are relocated to two spaces. `SplitInfo` captures all necessary\n+\/\/ info about the split, the first part, spliting-point, and the second part.\n@@ -1972,11 +2032,0 @@\n-  assert(summary_data().is_region_aligned(dest_addr), \"not aligned\");\n-\n-  const SplitInfo& split_info = _space_info[src_space_id].split_info();\n-  if (split_info.dest_region_addr() == dest_addr) {\n-    \/\/ The partial object ending at the split point contains the first word to\n-    \/\/ be copied to dest_addr.\n-    return split_info.first_src_addr();\n-  }\n-\n-  const ParallelCompactData& sd = summary_data();\n-  ParMarkBitMap* const bitmap = mark_bitmap();\n@@ -1984,0 +2033,2 @@\n+  const ParallelCompactData& sd = summary_data();\n+  assert(sd.is_region_aligned(dest_addr), \"precondition\");\n@@ -1985,1 +2036,0 @@\n-  assert(sd.is_region_aligned(dest_addr), \"not aligned\");\n@@ -1987,0 +2037,2 @@\n+  assert(src_region_ptr->data_size() > 0, \"src region cannot be empty\");\n+\n@@ -1990,5 +2042,2 @@\n-  assert(dest_addr >= src_region_destination, \"wrong src region\");\n-  assert(src_region_ptr->data_size() > 0, \"src region cannot be empty\");\n-\n-  HeapWord* const src_region_beg = sd.region_to_addr(src_region_idx);\n-  HeapWord* const src_region_end = src_region_beg + RegionSize;\n+  HeapWord* const region_start = sd.region_to_addr(src_region_idx);\n+  HeapWord* const region_end = sd.region_to_addr(src_region_idx) + RegionSize;\n@@ -1996,6 +2045,8 @@\n-  HeapWord* addr = src_region_beg;\n-  if (dest_addr == src_region_destination) {\n-    \/\/ Return the first live word in the source region.\n-    if (partial_obj_size == 0) {\n-      addr = bitmap->find_obj_beg(addr, src_region_end);\n-      assert(addr < src_region_end, \"no objects start in src region\");\n+  \/\/ Identify the actual destination for the first live words on this region,\n+  \/\/ taking split-region into account.\n+  HeapWord* region_start_destination;\n+  const SplitInfo& split_info = _space_info[src_space_id].split_info();\n+  if (split_info.is_split(src_region_idx)) {\n+    \/\/ The second part of this split region; use the recorded split point.\n+    if (dest_addr == src_region_destination) {\n+      return split_info.split_point();\n@@ -2003,1 +2054,3 @@\n-    return addr;\n+    region_start_destination = split_info.preceding_destination();\n+  } else {\n+    region_start_destination = src_region_destination;\n@@ -2006,3 +2059,2 @@\n-  \/\/ Must skip some live data.\n-  size_t words_to_skip = dest_addr - src_region_destination;\n-  assert(src_region_ptr->data_size() > words_to_skip, \"wrong src region\");\n+  \/\/ Calculate the offset to be skipped\n+  size_t words_to_skip = pointer_delta(dest_addr, region_start_destination);\n@@ -2010,9 +2062,6 @@\n-  if (partial_obj_size >= words_to_skip) {\n-    \/\/ All the live words to skip are part of the partial object.\n-    addr += words_to_skip;\n-    if (partial_obj_size == words_to_skip) {\n-      \/\/ Find the first live word past the partial object.\n-      addr = bitmap->find_obj_beg(addr, src_region_end);\n-      assert(addr < src_region_end, \"wrong src region\");\n-    }\n-    return addr;\n+  HeapWord* result;\n+  if (partial_obj_size > words_to_skip) {\n+    result = region_start + words_to_skip;\n+  } else {\n+    words_to_skip -= partial_obj_size;\n+    result = skip_live_words(region_start + partial_obj_size, region_end, words_to_skip);\n@@ -2021,4 +2070,4 @@\n-  \/\/ Skip over the partial object (if any).\n-  if (partial_obj_size != 0) {\n-    words_to_skip -= partial_obj_size;\n-    addr += partial_obj_size;\n+  if (split_info.is_split(src_region_idx)) {\n+    assert(result < split_info.split_point(), \"postcondition\");\n+  } else {\n+    assert(result < region_end, \"postcondition\");\n@@ -2027,4 +2076,1 @@\n-  \/\/ Skip over live words due to objects that start in the region.\n-  addr = skip_live_words(addr, src_region_end, words_to_skip);\n-  assert(addr < src_region_end, \"wrong src region\");\n-  return addr;\n+  return result;\n@@ -2081,2 +2127,0 @@\n-  typedef ParallelCompactData::RegionData RegionData;\n-\n@@ -2084,1 +2128,0 @@\n-  const size_t region_size = ParallelCompactData::RegionSize;\n@@ -2092,2 +2135,2 @@\n-  const RegionData* const top_region_ptr =\n-    sd.addr_to_region_ptr(top_aligned_up);\n+  const RegionData* const top_region_ptr = sd.addr_to_region_ptr(top_aligned_up);\n+\n@@ -2110,1 +2153,1 @@\n-  unsigned int space_id = src_space_id + 1;\n+  uint space_id = src_space_id + 1;\n@@ -2113,28 +2156,24 @@\n-  HeapWord* const destination = closure.destination();\n-\n-  do {\n-    MutableSpace* space = _space_info[space_id].space();\n-    HeapWord* const bottom = space->bottom();\n-    const RegionData* const bottom_cp = sd.addr_to_region_ptr(bottom);\n-\n-    \/\/ Iterate over the spaces that do not compact into themselves.\n-    if (bottom_cp->destination() != bottom) {\n-      HeapWord* const top_aligned_up = sd.region_align_up(space->top());\n-      const RegionData* const top_cp = sd.addr_to_region_ptr(top_aligned_up);\n-\n-      for (const RegionData* src_cp = bottom_cp; src_cp < top_cp; ++src_cp) {\n-        if (src_cp->live_obj_size() > 0) {\n-          \/\/ Found it.\n-          assert(src_cp->destination() == destination,\n-                 \"first live obj in the space must match the destination\");\n-          assert(src_cp->partial_obj_size() == 0,\n-                 \"a space cannot begin with a partial obj\");\n-\n-          src_space_id = SpaceId(space_id);\n-          src_space_top = space->top();\n-          const size_t src_region_idx = sd.region(src_cp);\n-          closure.set_source(sd.region_to_addr(src_region_idx));\n-          return src_region_idx;\n-        } else {\n-          assert(src_cp->data_size() == 0, \"sanity\");\n-        }\n+  for (\/* empty *\/; space_id < last_space_id; ++space_id) {\n+    HeapWord* bottom = _space_info[space_id].space()->bottom();\n+    HeapWord* top = _space_info[space_id].space()->top();\n+    \/\/ Skip empty space\n+    if (bottom == top) {\n+      continue;\n+    }\n+\n+    \/\/ Identify the first region that contains live words in this space\n+    size_t cur_region = sd.addr_to_region_idx(bottom);\n+    size_t end_region = sd.addr_to_region_idx(sd.region_align_up(top));\n+\n+    for (\/* empty *\/ ; cur_region < end_region; ++cur_region) {\n+      RegionData* cur = sd.region(cur_region);\n+      if (cur->live_obj_size() > 0) {\n+        HeapWord* region_start_addr = sd.region_to_addr(cur_region);\n+        HeapWord* region_end_addr = region_start_addr + ParallelCompactData::RegionSize;\n+        HeapWord* first_live_word = mark_bitmap()->find_obj_beg(region_start_addr, region_end_addr);\n+        assert(first_live_word < region_end_addr, \"inv\");\n+\n+        src_space_id = SpaceId(space_id);\n+        src_space_top = top;\n+        closure.set_source(first_live_word);\n+        return cur_region;\n@@ -2143,1 +2182,1 @@\n-  } while (++space_id < last_space_id);\n+  }\n@@ -2145,2 +2184,1 @@\n-  assert(false, \"no source region was found\");\n-  return 0;\n+  ShouldNotReachHere();\n@@ -2153,2 +2191,2 @@\n-  \/\/ Use per-region partial_obj_size to locate the end of the obj, that extends to region_start_addr.\n-  SplitInfo& split_info = _space_info[space_id(region_start_addr)].split_info();\n+  \/\/ Use per-region partial_obj_size to locate the end of the obj, that extends\n+  \/\/ to region_start_addr.\n@@ -2159,4 +2197,0 @@\n-    if (split_info.is_split(region_idx)) {\n-      accumulated_size += split_info.partial_obj_size();\n-      break;\n-    }\n@@ -2172,0 +2206,2 @@\n+\/\/ Use region_idx as the destination region, and evacuate all live objs on its\n+\/\/ source regions to this destination region.\n@@ -2192,0 +2228,18 @@\n+  \/\/ source-region:\n+  \/\/\n+  \/\/ **********\n+  \/\/ |   ~~~  |\n+  \/\/ **********\n+  \/\/      ^\n+  \/\/      |-- closure.source() \/ first_src_addr\n+  \/\/\n+  \/\/\n+  \/\/ ~~~ : live words\n+  \/\/\n+  \/\/ destination-region:\n+  \/\/\n+  \/\/ **********\n+  \/\/ |        |\n+  \/\/ **********\n+  \/\/ ^\n+  \/\/ |-- region-start\n@@ -2193,3 +2247,3 @@\n-    \/\/ The first source word is in the middle of an object; copy the remainder\n-    \/\/ of the object or as much as will fit.  The fact that pointer updates were\n-    \/\/ deferred will be noted when the object header is processed.\n+    \/\/ An object overflows the previous destination region, so this\n+    \/\/ destination region should copy the remainder of the object or as much as\n+    \/\/ will fit.\n@@ -2201,1 +2255,4 @@\n-      if (bitmap->is_marked(obj_start)) {\n+      if (obj_start != closure.source()) {\n+        assert(bitmap->is_marked(obj_start), \"inv\");\n+        \/\/ Found the actual obj-start, try to find the obj-end using either\n+        \/\/ size() if this obj is completely contained in the current region.\n@@ -2206,0 +2263,2 @@\n+        \/\/ This obj extends to next region iff partial_obj_addr of the *next*\n+        \/\/ region is the same as obj-start.\n@@ -2222,2 +2281,1 @@\n-      decrement_destination_counts(cm, src_space_id, src_region_idx,\n-                                   closure.source());\n+      decrement_destination_counts(cm, src_space_id, src_region_idx, closure.source());\n@@ -2228,0 +2286,1 @@\n+    \/\/ Finished copying without using up the current destination-region\n@@ -2230,0 +2289,1 @@\n+      assert(sd.region_align_up(old_src_addr) == end_addr, \"only one region\");\n@@ -2235,2 +2295,1 @@\n-      src_region_idx = next_src_region(closure, src_space_id, src_space_top,\n-                                       end_addr);\n+      src_region_idx = next_src_region(closure, src_space_id, src_space_top, end_addr);\n@@ -2240,0 +2299,1 @@\n+  \/\/ Handle the rest obj-by-obj, where we know obj-start.\n@@ -2244,1 +2304,2 @@\n-    HeapWord* partial_obj_start = (end_addr == src_space_top)\n+    \/\/ To handle the case where the final obj in source region extends to next region.\n+    HeapWord* final_obj_start = (end_addr == src_space_top)\n@@ -2247,1 +2308,1 @@\n-    \/\/ apply closure on objs inside [cur_addr, end_addr)\n+    \/\/ Apply closure on objs inside [cur_addr, end_addr)\n@@ -2254,1 +2315,1 @@\n-      if (partial_obj_start == cur_addr) {\n+      if (final_obj_start == cur_addr) {\n@@ -2265,2 +2326,1 @@\n-      decrement_destination_counts(cm, src_space_id, src_region_idx,\n-                                   closure.source());\n+      decrement_destination_counts(cm, src_space_id, src_region_idx, closure.source());\n@@ -2275,2 +2335,1 @@\n-    src_region_idx = next_src_region(closure, src_space_id, src_space_top,\n-                                     end_addr);\n+    src_region_idx = next_src_region(closure, src_space_id, src_space_top, end_addr);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":383,"deletions":324,"binary":false,"changes":707,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-  bool is_valid() const { return _src_region_idx > 0; }\n+  bool is_valid() const { return _split_region_idx > 0; }\n@@ -122,1 +122,1 @@\n-  inline bool is_split(size_t source_region) const;\n+  inline bool is_split(size_t region_idx) const;\n@@ -124,4 +124,2 @@\n-  \/\/ The index of the split region, the size of the partial object on that\n-  \/\/ region and the destination of the partial object.\n-  size_t    partial_obj_size() const { return _partial_obj_size; }\n-  HeapWord* destination() const      { return _destination; }\n+  \/\/ Obj at the split point doesn't fit the previous space and will be relocated to the next space.\n+  HeapWord* split_point() const { return _split_point; }\n@@ -129,4 +127,2 @@\n-  \/\/ The destination count of the partial object referenced by this split\n-  \/\/ (either 1 or 2).  This must be added to the destination count of the\n-  \/\/ remainder of the source region.\n-  unsigned int destination_count() const { return _destination_count; }\n+  \/\/ Number of live words before the split point on this region.\n+  size_t preceding_live_words() const { return _preceding_live_words; }\n@@ -134,4 +130,7 @@\n-  \/\/ If a word within the partial object will be written to the first word of a\n-  \/\/ destination region, this is the address of the destination region;\n-  \/\/ otherwise this is null.\n-  HeapWord* dest_region_addr() const     { return _dest_region_addr; }\n+  \/\/ A split region has two \"destinations\", living in two spaces. This method\n+  \/\/ returns the first one -- destination for the first live word on\n+  \/\/ this split region.\n+  HeapWord* preceding_destination() const {\n+    assert(_preceding_destination != nullptr, \"inv\");\n+    return _preceding_destination;\n+  }\n@@ -139,4 +138,2 @@\n-  \/\/ If a word within the partial object will be written to the first word of a\n-  \/\/ destination region, this is the address of that word within the partial\n-  \/\/ object; otherwise this is null.\n-  HeapWord* first_src_addr() const       { return _first_src_addr; }\n+  \/\/ Number of regions the preceding live words are relocated into.\n+  uint preceding_destination_count() const { return _preceding_destination_count; }\n@@ -144,3 +141,1 @@\n-  \/\/ Record the data necessary to split the region src_region_idx.\n-  void record(size_t src_region_idx, size_t partial_obj_size,\n-              HeapWord* destination);\n+  void record(size_t split_region_idx, HeapWord* split_point, size_t preceding_live_words);\n@@ -153,6 +148,5 @@\n-  size_t       _src_region_idx;\n-  size_t       _partial_obj_size;\n-  HeapWord*    _destination;\n-  unsigned int _destination_count;\n-  HeapWord*    _dest_region_addr;\n-  HeapWord*    _first_src_addr;\n+  size_t       _split_region_idx;\n+  HeapWord*    _split_point;\n+  size_t       _preceding_live_words;\n+  HeapWord*    _preceding_destination;\n+  uint         _preceding_destination_count;\n@@ -163,1 +157,1 @@\n-  return _src_region_idx == region_idx && is_valid();\n+  return _split_region_idx == region_idx && is_valid();\n@@ -218,1 +212,7 @@\n-    \/\/ Destination address of the region.\n+    \/\/ Destination for the first live word in this region.\n+    \/\/ Therefore, the new addr for every live obj on this region can be calculated as:\n+    \/\/\n+    \/\/ new_addr := _destination + live_words_offset(old_addr);\n+    \/\/\n+    \/\/ where, live_words_offset is the number of live words accumulated from\n+    \/\/ region-start to old_addr.\n@@ -221,1 +221,3 @@\n-    \/\/ The first region containing data destined for this region.\n+    \/\/ A destination region can have multiple source regions; only the first\n+    \/\/ one is recorded. Since all live objs are slided down, subsequent source\n+    \/\/ regions can be found via plain heap-region iteration.\n@@ -316,1 +318,0 @@\n-\n@@ -319,0 +320,4 @@\n+    bool is_clear();\n+\n+    void verify_clear() NOT_DEBUG_RETURN;\n+\n@@ -876,1 +881,4 @@\n-  void      set_source(HeapWord* addr) { _source = addr; }\n+  void      set_source(HeapWord* addr) {\n+    assert(addr != nullptr, \"precondition\");\n+    _source = addr;\n+  }\n@@ -905,3 +913,2 @@\n-  assert(dest_addr < new_top, \"sanity\");\n-\n-  return MIN2(pointer_delta(new_top, dest_addr), ParallelCompactData::RegionSize);\n+  return MIN2(pointer_delta(new_top, dest_addr),\n+              ParallelCompactData::RegionSize);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":42,"deletions":35,"binary":false,"changes":77,"status":"modified"}]}