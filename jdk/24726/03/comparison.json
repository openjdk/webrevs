{"files":[{"patch":"@@ -0,0 +1,361 @@\n+\/*\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal;\n+\n+import static jdk.jfr.internal.util.Bytecode.classDesc;\n+\n+import java.lang.classfile.Annotation;\n+import java.lang.classfile.AnnotationElement;\n+import java.lang.classfile.AnnotationValue;\n+import java.lang.classfile.Attribute;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.FieldModel;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.lang.constant.ConstantDescs;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Name;\n+import jdk.jfr.Registered;\n+import jdk.jfr.SettingControl;\n+import jdk.jfr.SettingDefinition;\n+import jdk.jfr.internal.util.Bytecode;\n+import jdk.jfr.internal.util.ImplicitFields;\n+import jdk.jfr.internal.util.Bytecode.FieldDesc;\n+import jdk.jfr.internal.util.Bytecode.MethodDesc;\n+import jdk.jfr.internal.util.Bytecode.SettingDesc;\n+import jdk.jfr.internal.util.Utils;\n+\n+final class ClassInspector {\n+    private static final ClassDesc TYPE_SETTING_DEFINITION = Bytecode.classDesc(SettingDefinition.class);\n+    private static final ClassDesc ANNOTATION_REGISTERED = classDesc(Registered.class);\n+    private static final ClassDesc ANNOTATION_NAME = classDesc(Name.class);\n+    private static final ClassDesc ANNOTATION_ENABLED = classDesc(Enabled.class);\n+    private static final ClassDesc ANNOTATION_REMOVE_FIELDS = classDesc(RemoveFields.class);\n+\n+    private final ClassModel classModel;\n+    private final Class<?> superClass;\n+    private final boolean isJDK;\n+    private final ImplicitFields implicitFields;\n+    private final List<SettingDesc> settingsDescs = new ArrayList<>();\n+    private final List<FieldDesc> fieldDescs = new ArrayList<>();\n+    private final String className;\n+\n+    ClassInspector(Class<?> superClass, byte[] bytes, boolean isJDK) {\n+        this.superClass = superClass;\n+        this.classModel = ClassFile.of().parse(bytes);\n+        this.isJDK = isJDK;\n+        this.className = classModel.thisClass().asInternalName().replace(\"\/\", \".\");\n+        this.implicitFields = determineImplicitFields();\n+    }\n+\n+    String getClassName() {\n+        return className;\n+    }\n+\n+    MethodDesc findStaticCommitMethod() {\n+        if (!isJDK) {\n+            return null;\n+        }\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"(\");\n+        for (FieldDesc field : fieldDescs) {\n+            sb.append(field.type().descriptorString());\n+        }\n+        sb.append(\")V\");\n+        MethodDesc m = MethodDesc.of(\"commit\", sb.toString());\n+        for (MethodModel method : classModel.methods()) {\n+            if (m.matches(method)) {\n+                return m;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    String getEventName() {\n+        String name = annotationValue(ANNOTATION_NAME, String.class);\n+        return name == null ? getClassName() : name;\n+    }\n+\n+    boolean isRegistered() {\n+        Boolean result = annotationValue(ANNOTATION_REGISTERED, Boolean.class);\n+        if (result != null) {\n+            return result.booleanValue();\n+        }\n+        if (superClass != null) {\n+            Registered r = superClass.getAnnotation(Registered.class);\n+            if (r != null) {\n+                return r.value();\n+            }\n+        }\n+        return true;\n+    }\n+\n+    boolean isEnabled() {\n+        Boolean result = annotationValue(ANNOTATION_ENABLED, Boolean.class);\n+        if (result != null) {\n+            return result.booleanValue();\n+        }\n+        if (superClass != null) {\n+            Enabled e = superClass.getAnnotation(Enabled.class);\n+            if (e != null) {\n+                return e.value();\n+            }\n+        }\n+        return true;\n+    }\n+\n+    boolean hasStaticMethod(MethodDesc method) {\n+        for (MethodModel m : classModel.methods()) {\n+            if (Modifier.isStatic(m.flags().flagsMask())) {\n+                return method.matches(m);\n+            }\n+        }\n+        return false;\n+    }\n+\n+    static boolean isValidField(int access, ClassDesc classDesc) {\n+        String className = classDesc.packageName();\n+        if (!className.isEmpty()) {\n+            className = className + \".\";\n+        }\n+        className += classDesc.displayName();\n+        return isValidField(access, className);\n+    }\n+\n+    static boolean isValidField(int access, String className) {\n+        if (Modifier.isTransient(access) || Modifier.isStatic(access)) {\n+            return false;\n+        }\n+        return Type.isValidJavaFieldType(className);\n+    }\n+\n+    List<SettingDesc> getSettings() {\n+        return settingsDescs;\n+    }\n+\n+    List<FieldDesc> getFields() {\n+        return fieldDescs;\n+    }\n+\n+    boolean hasDuration() {\n+        return implicitFields.hasDuration();\n+    }\n+\n+    boolean hasStackTrace() {\n+        return implicitFields.hasStackTrace();\n+    }\n+\n+    boolean hasEventThread() {\n+        return implicitFields.hasEventThread();\n+    }\n+\n+    ClassDesc getClassDesc() {\n+        return classModel.thisClass().asSymbol();\n+    }\n+\n+    ClassModel getClassModel() {\n+        return classModel;\n+    }\n+\n+    boolean isJDK() {\n+        return isJDK;\n+    }\n+\n+    private ImplicitFields determineImplicitFields() {\n+        if (isJDK) {\n+            Class<?> eventClass = MirrorEvents.find(isJDK, getClassName());\n+            if (eventClass != null) {\n+                return new ImplicitFields(eventClass);\n+            }\n+        }\n+        ImplicitFields ifs = new ImplicitFields(superClass);\n+        String[] value = annotationValue(ANNOTATION_REMOVE_FIELDS, String[].class);\n+        if (value != null) {\n+            ifs.removeFields(value);\n+        }\n+        return ifs;\n+    }\n+\n+    private List<AnnotationValue> getAnnotationValues(ClassDesc classDesc) {\n+        List<AnnotationValue> list = new ArrayList<>();\n+        for (Attribute<?> attribute: classModel.attributes()) {\n+            if (attribute instanceof RuntimeVisibleAnnotationsAttribute rvaa) {\n+                for (Annotation a : rvaa.annotations()) {\n+                    if (a.classSymbol().equals(classDesc) && a.elements().size() == 1) {\n+                        AnnotationElement ae = a.elements().getFirst();\n+                        if (ae.name().equalsString(\"value\")) {\n+                            list.add(ae.value());\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return list;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    \/\/ Only supports String, String[] and Boolean values\n+    private <T> T annotationValue(ClassDesc classDesc, Class<T> type) {\n+        for (AnnotationValue a : getAnnotationValues(classDesc)) {\n+            if (a instanceof AnnotationValue.OfBoolean ofb && type.equals(Boolean.class)) {\n+                Boolean b = ofb.booleanValue();\n+                return (T) b;\n+            }\n+            if (a instanceof AnnotationValue.OfString ofs && type.equals(String.class)) {\n+                String s = ofs.stringValue();\n+                return (T) s;\n+            }\n+            if (a instanceof AnnotationValue.OfArray ofa && type.equals(String[].class)) {\n+                List<AnnotationValue> list = ofa.values();\n+                String[] array = new String[list.size()];\n+                int index = 0;\n+                for (AnnotationValue av : list) {\n+                    var avs = (AnnotationValue.OfString) av;\n+                    array[index++] = avs.stringValue();\n+                }\n+                return (T) array;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    void buildSettings() {\n+        Set<String> foundMethods = new HashSet<>();\n+        buildClassSettings(foundMethods);\n+        buildSuperClassSettings(foundMethods);\n+    }\n+\n+    private void buildClassSettings(Set<String> foundMethods) {\n+        for (MethodModel m : classModel.methods()) {\n+            for (Attribute<?> attribute : m.attributes()) {\n+                if (attribute instanceof RuntimeVisibleAnnotationsAttribute rvaa) {\n+                    for (Annotation a : rvaa.annotations()) {\n+                        \/\/ We can't really validate the method at this\n+                        \/\/ stage. We would need to check that the parameter\n+                        \/\/ is an instance of SettingControl.\n+                        if (a.classSymbol().equals(TYPE_SETTING_DEFINITION)) {\n+                            String name = m.methodName().stringValue();\n+                            \/\/ Use @Name if it exists\n+                            for (Annotation nameCandidate : rvaa.annotations()) {\n+                                if (nameCandidate.className().equalsString(ANNOTATION_NAME.descriptorString())) {\n+                                    if (nameCandidate.elements().size() == 1) {\n+                                        AnnotationElement ae = nameCandidate.elements().getFirst();\n+                                        if (ae.name().equalsString(\"value\")) {\n+                                            if (ae.value() instanceof AnnotationValue.OfString s) {\n+                                                name = Utils.validJavaIdentifier(s.stringValue(), name);\n+                                            }\n+                                        }\n+                                    }\n+                                }\n+                            }\n+                            \/\/ Add setting if method returns boolean and has one parameter\n+                            MethodTypeDesc mtd = m.methodTypeSymbol();\n+                            if (ConstantDescs.CD_boolean.equals(mtd.returnType())) {\n+                                if (mtd.parameterList().size() == 1) {\n+                                    ClassDesc type = mtd.parameterList().getFirst();\n+                                    if (type.isClassOrInterface()) {\n+                                        String methodName = m.methodName().stringValue();\n+                                        foundMethods.add(methodName);\n+                                        settingsDescs.add(new SettingDesc(type, methodName));\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void buildSuperClassSettings(Set<String> foundMethods) {\n+        for (Class<?> c = superClass; jdk.internal.event.Event.class != c; c = c.getSuperclass()) {\n+            for (java.lang.reflect.Method method : c.getDeclaredMethods()) {\n+                if (!foundMethods.contains(method.getName())) {\n+                    buildSettingsMethod(foundMethods, method);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void buildSettingsMethod(Set<String> foundMethods, java.lang.reflect.Method method) {\n+        \/\/ Skip private methods in base classes\n+        if (!Modifier.isPrivate(method.getModifiers())) {\n+            if (method.getReturnType().equals(Boolean.TYPE)) {\n+                if (method.getParameterCount() == 1) {\n+                    Class<?> type = method.getParameters()[0].getType();\n+                    if (SettingControl.class.isAssignableFrom(type)) {\n+                        ClassDesc paramType = Bytecode.classDesc(type);\n+                        foundMethods.add(method.getName());\n+                        settingsDescs.add(new SettingDesc(paramType, method.getName()));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    void buildFields() {\n+        Set<String> foundFields = new HashSet<>();\n+        \/\/ These two fields are added by native as 'transient' so they will be\n+        \/\/ ignored by the loop below.\n+        \/\/ The benefit of adding them manually is that we can\n+        \/\/ control in which order they occur and we can add @Name, @Description\n+        \/\/ in Java, instead of in native. It also means code for adding implicit\n+        \/\/ fields for native can be reused by Java.\n+        fieldDescs.add(ImplicitFields.FIELD_START_TIME);\n+        if (implicitFields.hasDuration()) {\n+            fieldDescs.add(ImplicitFields.FIELD_DURATION);\n+        }\n+        for (FieldModel field : classModel.fields()) {\n+            if (!foundFields.contains(field.fieldName().stringValue()) && isValidField(field.flags().flagsMask(), field.fieldTypeSymbol())) {\n+                fieldDescs.add(FieldDesc.of(field.fieldTypeSymbol(), field.fieldName().stringValue()));\n+                foundFields.add(field.fieldName().stringValue());\n+            }\n+        }\n+        for (Class<?> c = superClass; jdk.internal.event.Event.class != c; c = c.getSuperclass()) {\n+            for (Field field : c.getDeclaredFields()) {\n+                \/\/ Skip private fields in base classes\n+                if (!Modifier.isPrivate(field.getModifiers())) {\n+                    if (isValidField(field.getModifiers(), field.getType().getName())) {\n+                        String fieldName = field.getName();\n+                        if (!foundFields.contains(fieldName)) {\n+                            fieldDescs.add(FieldDesc.of(field.getType(), fieldName));\n+                            foundFields.add(fieldName);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/ClassInspector.java","additions":361,"deletions":0,"binary":false,"changes":361,"status":"added"},{"patch":"@@ -28,11 +28,5 @@\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.MethodTypeDesc;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Modifier;\n-import java.util.ArrayList;\n-import java.util.HashSet;\n-import java.util.LinkedHashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.function.Consumer;\n+import static jdk.jfr.internal.util.Bytecode.classDesc;\n+import static jdk.jfr.internal.util.Bytecode.getfield;\n+import static jdk.jfr.internal.util.Bytecode.invokestatic;\n+import static jdk.jfr.internal.util.Bytecode.invokevirtual;\n+import static jdk.jfr.internal.util.Bytecode.putfield;\n@@ -40,3 +34,1 @@\n-import java.lang.classfile.Annotation;\n-import java.lang.classfile.AnnotationElement;\n-import java.lang.classfile.AnnotationValue;\n+import java.lang.classfile.ClassBuilder;\n@@ -44,1 +36,0 @@\n-import java.lang.classfile.ClassModel;\n@@ -51,0 +42,1 @@\n+import java.lang.classfile.MethodTransform;\n@@ -52,4 +44,5 @@\n-import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n-import jdk.jfr.internal.event.EventConfiguration;\n-import jdk.jfr.internal.event.EventWriter;\n-import jdk.jfr.Enabled;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n@@ -57,2 +50,0 @@\n-import jdk.jfr.Name;\n-import jdk.jfr.Registered;\n@@ -60,2 +51,2 @@\n-import jdk.jfr.SettingDefinition;\n-import jdk.jfr.internal.util.Utils;\n+import jdk.jfr.internal.event.EventConfiguration;\n+import jdk.jfr.internal.event.EventWriter;\n@@ -63,1 +54,0 @@\n-import jdk.jfr.internal.util.ImplicitFields;\n@@ -66,5 +56,2 @@\n-import static jdk.jfr.internal.util.Bytecode.invokevirtual;\n-import static jdk.jfr.internal.util.Bytecode.invokestatic;\n-import static jdk.jfr.internal.util.Bytecode.getfield;\n-import static jdk.jfr.internal.util.Bytecode.putfield;\n-import static jdk.jfr.internal.util.Bytecode.classDesc;\n+import jdk.jfr.internal.util.Bytecode.SettingDesc;\n+import jdk.jfr.internal.util.ImplicitFields;\n@@ -77,0 +64,1 @@\n+    private static final FieldDesc FIELD_EVENT_CONFIGURATION = FieldDesc.of(Object.class, \"eventConfiguration\");\n@@ -78,10 +66,0 @@\n-    private record SettingDesc(ClassDesc paramType, String methodName) {\n-    }\n-\n-    private static final FieldDesc FIELD_DURATION = FieldDesc.of(long.class, ImplicitFields.DURATION);\n-    private static final FieldDesc FIELD_EVENT_CONFIGURATION = FieldDesc.of(Object.class, \"eventConfiguration\");;\n-    private static final FieldDesc FIELD_START_TIME = FieldDesc.of(long.class, ImplicitFields.START_TIME);\n-    private static final ClassDesc ANNOTATION_ENABLED = classDesc(Enabled.class);\n-    private static final ClassDesc ANNOTATION_NAME = classDesc(Name.class);\n-    private static final ClassDesc ANNOTATION_REGISTERED = classDesc(Registered.class);\n-    private static final ClassDesc ANNOTATION_REMOVE_FIELDS = classDesc(RemoveFields.class);\n@@ -89,1 +67,1 @@\n-    private static final ClassDesc TYPE_ISE = Bytecode.classDesc(IllegalStateException.class);\n+    private static final ClassDesc TYPE_ISE = classDesc(IllegalStateException.class);\n@@ -91,2 +69,2 @@\n-    private static final ClassDesc TYPE_OBJECT = Bytecode.classDesc(Object.class);\n-    private static final ClassDesc TYPE_SETTING_DEFINITION = Bytecode.classDesc(SettingDefinition.class);\n+    private static final ClassDesc TYPE_OBJECT = classDesc(Object.class);\n+\n@@ -107,8 +85,1 @@\n-    private final ClassModel classModel;\n-    private final List<SettingDesc> settingDescs;\n-    private final List<FieldDesc> fieldDescs;;\n-    private final String eventName;\n-    private final String className;\n-    private final Class<?> superClass;\n-    private final boolean untypedEventConfiguration;\n-    private final MethodDesc staticCommitMethod;\n+    private final ClassInspector inspector;\n@@ -116,0 +87,3 @@\n+    private final ClassDesc eventClassDesc;\n+    private final MethodDesc staticCommitMethod;\n+    private final boolean untypedEventConfiguration;\n@@ -117,3 +91,0 @@\n-    private final boolean isJDK;\n-    private final Map<MethodDesc, Consumer<CodeBuilder>> methodUpdates = new LinkedHashMap<>();\n-    private final ImplicitFields implicitFields;\n@@ -121,1 +92,16 @@\n-    EventInstrumentation(Class<?> superClass, byte[] bytes, long id, boolean isJDK, boolean guardEventConfiguration) {\n+    \/**\n+     * Creates an EventInstrumentation object.\n+     *\n+     * @param inspector               class inspector\n+     * @param id                      the event type ID to use\n+     * @param guardEventConfiguration guard against event configuration being null.\n+     *                                Needed when instrumentation is added before\n+     *                                registration (bytesForEagerInstrumentation)\n+     *\/\n+    EventInstrumentation(ClassInspector inspector, long id, boolean guardEventConfiguration) {\n+        inspector.buildFields();\n+        if (!inspector.isJDK()) {\n+            \/\/ Only user-defined events have custom settings.\n+            inspector.buildSettings();\n+        }\n+        this.inspector = inspector;\n@@ -123,16 +109,0 @@\n-        this.superClass = superClass;\n-        this.isJDK = isJDK;\n-        this.classModel = createClassModel(bytes);\n-        this.className = classModel.thisClass().asInternalName().replace(\"\/\", \".\");\n-        String name = annotationValue(classModel, ANNOTATION_NAME, String.class);\n-        this.eventName = name == null ? className : name;\n-        this.implicitFields = determineImplicitFields();\n-        this.settingDescs = buildSettingDescs(superClass, classModel);\n-        this.fieldDescs = buildFieldDescs(superClass, classModel);\n-        this.staticCommitMethod = isJDK ? findStaticCommitMethod(classModel, fieldDescs) : null;\n-        this.untypedEventConfiguration = hasUntypedConfiguration();\n-        \/\/ Corner case when we are forced to generate bytecode\n-        \/\/ (bytesForEagerInstrumentation)\n-        \/\/ We can't reference EventConfiguration::isEnabled() before event class has\n-        \/\/ been registered,\n-        \/\/ so we add a guard against a null reference.\n@@ -140,0 +110,3 @@\n+        this.eventClassDesc = inspector.getClassDesc();\n+        this.staticCommitMethod = inspector.findStaticCommitMethod();\n+        this.untypedEventConfiguration = hasUntypedConfiguration();\n@@ -142,13 +115,2 @@\n-    private ImplicitFields determineImplicitFields() {\n-        if (isJDK) {\n-            Class<?> eventClass = MirrorEvents.find(isJDK, className);\n-            if (eventClass != null) {\n-                return new ImplicitFields(eventClass);\n-            }\n-        }\n-        ImplicitFields ifs = new ImplicitFields(superClass);\n-        String[] value = annotationValue(classModel, ANNOTATION_REMOVE_FIELDS, String[].class);\n-        if (value != null) {\n-            ifs.removeFields(value);\n-        }\n-        return ifs;\n+    byte[] buildInstrumented() {\n+        return ClassFile.of().transformClass(inspector.getClassModel(), this::transform);\n@@ -157,13 +119,5 @@\n-    static MethodDesc findStaticCommitMethod(ClassModel classModel, List<FieldDesc> fields) {\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(\"(\");\n-        for (FieldDesc field : fields) {\n-            sb.append(field.type().descriptorString());\n-        }\n-        sb.append(\")V\");\n-        MethodDesc m = MethodDesc.of(\"commit\", sb.toString());\n-        for (MethodModel method : classModel.methods()) {\n-            String d = method.methodTypeSymbol().descriptorString();\n-            if (method.methodName().equalsString(\"commit\") && m.descriptor().descriptorString().equals(d)) {\n-                return m;\n-            }\n+    private void transform(ClassBuilder clb, ClassElement cle) {\n+        if (cle instanceof MethodModel method && instrumentable(method) instanceof Consumer<CodeBuilder> modification) {\n+            clb.transformMethod(method, MethodTransform.transformingCode((codeBuilder, _) -> modification.accept(codeBuilder)));\n+        } else {\n+            clb.with(cle);\n@@ -171,1 +125,0 @@\n-        return null;\n@@ -174,5 +127,3 @@\n-    private boolean hasUntypedConfiguration() {\n-        for (FieldModel f : classModel.fields()) {\n-            if (f.fieldName().equalsString(FIELD_EVENT_CONFIGURATION.name())) {\n-                return f.fieldType().equalsString(TYPE_OBJECT.descriptorString());\n-            }\n+    private Consumer<CodeBuilder> instrumentable(MethodModel method) {\n+        if (isMethod(method, METHOD_IS_ENABLED)) {\n+            return this::methodIsEnabled;\n@@ -180,15 +131,2 @@\n-        throw new InternalError(\"Class missing configuration field\");\n-    }\n-\n-    public String getClassName() {\n-        return classModel.thisClass().asInternalName().replace(\"\/\", \".\");\n-    }\n-\n-    private ClassModel createClassModel(byte[] bytes) {\n-        return ClassFile.of().parse(bytes);\n-    }\n-\n-    boolean isRegistered() {\n-        Boolean result = annotationValue(classModel, ANNOTATION_REGISTERED, Boolean.class);\n-        if (result != null) {\n-            return result.booleanValue();\n+        if (isMethod(method, METHOD_BEGIN)) {\n+            return this::methodBegin;\n@@ -196,5 +134,2 @@\n-        if (superClass != null) {\n-            Registered r = superClass.getAnnotation(Registered.class);\n-            if (r != null) {\n-                return r.value();\n-            }\n+        if (isMethod(method, METHOD_END)) {\n+            return this::methodEnd;\n@@ -202,7 +137,2 @@\n-        return true;\n-    }\n-\n-    boolean isEnabled() {\n-        Boolean result = annotationValue(classModel, ANNOTATION_ENABLED, Boolean.class);\n-        if (result != null) {\n-            return result.booleanValue();\n+        if (isMethod(method, METHOD_EVENT_SHOULD_COMMIT)) {\n+            return this::methodShouldCommit;\n@@ -210,5 +140,2 @@\n-        if (superClass != null) {\n-            Enabled e = superClass.getAnnotation(Enabled.class);\n-            if (e != null) {\n-                return e.value();\n-            }\n+        if (staticCommitMethod == null && isMethod(method, METHOD_COMMIT)) {\n+            return this::methodCommit;\n@@ -216,36 +143,3 @@\n-        return true;\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    \/\/ Only supports String, String[] and Boolean values\n-    private static <T> T annotationValue(ClassModel classModel, ClassDesc classDesc, Class<T> type) {\n-        String typeDescriptor = classDesc.descriptorString();\n-        for (ClassElement ce : classModel) {\n-            if (ce instanceof RuntimeVisibleAnnotationsAttribute rvaa) {\n-                for (Annotation a : rvaa.annotations()) {\n-                    if (a.className().equalsString(typeDescriptor)) {\n-                        if (a.elements().size() == 1) {\n-                            AnnotationElement ae = a.elements().getFirst();\n-                            if (ae.name().equalsString(\"value\")) {\n-                                if (ae.value() instanceof AnnotationValue.OfBoolean ofb && type.equals(Boolean.class)) {\n-                                    Boolean b = ofb.booleanValue();\n-                                    return (T)b;\n-                                }\n-                                if (ae.value() instanceof AnnotationValue.OfString ofs && type.equals(String.class)) {\n-                                    String s = ofs.stringValue();\n-                                    return (T)s;\n-                                }\n-                                if (ae.value() instanceof AnnotationValue.OfArray ofa && type.equals(String[].class)) {\n-                                    List<AnnotationValue> list = ofa.values();\n-                                    String[] array = new String[list.size()];\n-                                    int index = 0;\n-                                    for (AnnotationValue av : list) {\n-                                        var avs = (AnnotationValue.OfString)av;\n-                                        array[index++] = avs.stringValue();\n-                                    }\n-                                    return (T)array;\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n+        if (inspector.isJDK() && isStatic(method)) {\n+            if (isMethod(method, METHOD_ENABLED)) {\n+                return this::methodEnabledStatic;\n@@ -253,44 +147,2 @@\n-        }\n-        return null;\n-    }\n-\n-    private static List<SettingDesc> buildSettingDescs(Class<?> superClass, ClassModel classModel) {\n-        Set<String> methodSet = new HashSet<>();\n-        List<SettingDesc> settingDescs = new ArrayList<>();\n-        for (MethodModel m : classModel.methods()) {\n-            for (var me : m) {\n-                if (me instanceof RuntimeVisibleAnnotationsAttribute rvaa) {\n-                    for (Annotation a : rvaa.annotations()) {\n-                        \/\/ We can't really validate the method at this\n-                        \/\/ stage. We would need to check that the parameter\n-                        \/\/ is an instance of SettingControl.\n-                        if (a.className().equalsString(TYPE_SETTING_DEFINITION.descriptorString())) {\n-                            String name = m.methodName().stringValue();\n-                            \/\/ Use @Name if it exists\n-                            for (Annotation nameCandidate : rvaa.annotations()) {\n-                                if (nameCandidate.className().equalsString(ANNOTATION_NAME.descriptorString())) {\n-                                    if (nameCandidate.elements().size() == 1) {\n-                                        AnnotationElement ae = nameCandidate.elements().getFirst();\n-                                        if (ae.name().equalsString(\"value\")) {\n-                                            if (ae.value() instanceof AnnotationValue.OfString s) {\n-                                                name = Utils.validJavaIdentifier(s.stringValue(), name);\n-                                            }\n-                                        }\n-                                    }\n-                                }\n-                            }\n-                            \/\/ Add setting if method returns boolean and has one parameter\n-                            MethodTypeDesc mtd = m.methodTypeSymbol();\n-                            if (\"Z\".equals(mtd.returnType().descriptorString())) {\n-                                if (mtd.parameterList().size() == 1) {\n-                                    ClassDesc type = mtd.parameterList().getFirst();\n-                                    if (type.isClassOrInterface()) {\n-                                        String methodName = m.methodName().stringValue();\n-                                        methodSet.add(methodName);\n-                                        settingDescs.add(new SettingDesc(type, methodName));\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n+            if (isMethod(method, METHOD_SHOULD_COMMIT_LONG)) {\n+                return this::methodShouldCommitStatic;\n@@ -298,18 +150,5 @@\n-        }\n-        for (Class<?> c = superClass; jdk.internal.event.Event.class != c; c = c.getSuperclass()) {\n-            for (java.lang.reflect.Method method : c.getDeclaredMethods()) {\n-                if (!methodSet.contains(method.getName())) {\n-                    \/\/ skip private method in base classes\n-                    if (!Modifier.isPrivate(method.getModifiers())) {\n-                        if (method.getReturnType().equals(Boolean.TYPE)) {\n-                            if (method.getParameterCount() == 1) {\n-                                Class<?> type = method.getParameters()[0].getType();\n-                                if (SettingControl.class.isAssignableFrom(type)) {\n-                                    ClassDesc paramType = Bytecode.classDesc(type);\n-                                    methodSet.add(method.getName());\n-                                    settingDescs.add(new SettingDesc(paramType, method.getName()));\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n+            if (isMethod(method, METHOD_TIME_STAMP)) {\n+                return this::methodTimestamp;\n+            }\n+            if (staticCommitMethod != null && isMethod(method, staticCommitMethod)) {\n+                return this::methodCommit;\n@@ -318,1 +157,1 @@\n-        return settingDescs;\n+        return null;\n@@ -321,19 +160,5 @@\n-    private List<FieldDesc> buildFieldDescs(Class<?> superClass, ClassModel classModel) {\n-        Set<String> fieldSet = new HashSet<>();\n-        List<FieldDesc> fieldDescs = new ArrayList<>(classModel.fields().size());\n-        \/\/ These two fields are added by native as 'transient' so they will be\n-        \/\/ ignored by the loop below.\n-        \/\/ The benefit of adding them manually is that we can\n-        \/\/ control in which order they occur and we can add @Name, @Description\n-        \/\/ in Java, instead of in native. It also means code for adding implicit\n-        \/\/ fields for native can be reused by Java.\n-        fieldDescs.add(FIELD_START_TIME);\n-        if (implicitFields.hasDuration()) {\n-            fieldDescs.add(FIELD_DURATION);\n-        }\n-        for (FieldModel field : classModel.fields()) {\n-            if (!fieldSet.contains(field.fieldName().stringValue()) && isValidField(field.flags().flagsMask(), field.fieldTypeSymbol())) {\n-                FieldDesc fi = FieldDesc.of(field.fieldTypeSymbol(), field.fieldName().stringValue());\n-                fieldDescs.add(fi);\n-                fieldSet.add(field.fieldName().stringValue());\n-            }\n+    private void methodIsEnabled(CodeBuilder codeBuilder) {\n+        Label nullLabel = codeBuilder.newLabel();\n+        if (guardEventConfiguration) {\n+            getEventConfiguration(codeBuilder);\n+            codeBuilder.ifnull(nullLabel);\n@@ -341,13 +166,7 @@\n-        for (Class<?> c = superClass; jdk.internal.event.Event.class != c; c = c.getSuperclass()) {\n-            for (Field field : c.getDeclaredFields()) {\n-                \/\/ skip private field in base classes\n-                if (!Modifier.isPrivate(field.getModifiers())) {\n-                    if (isValidField(field.getModifiers(), field.getType().getName())) {\n-                        String fieldName = field.getName();\n-                        if (!fieldSet.contains(fieldName)) {\n-                            fieldDescs.add(FieldDesc.of(field.getType(), fieldName));\n-                            fieldSet.add(fieldName);\n-                        }\n-                    }\n-                }\n-            }\n+        getEventConfiguration(codeBuilder);\n+        invokevirtual(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_IS_ENABLED);\n+        codeBuilder.ireturn();\n+        if (guardEventConfiguration) {\n+            codeBuilder.labelBinding(nullLabel);\n+            codeBuilder.iconst_0();\n+            codeBuilder.ireturn();\n@@ -355,1 +174,0 @@\n-        return fieldDescs;\n@@ -358,4 +176,8 @@\n-    public static boolean isValidField(int access, ClassDesc classDesc) {\n-        String className = classDesc.packageName();\n-        if (!className.isEmpty()) {\n-            className = className + \".\";\n+    private void methodBegin(CodeBuilder codeBuilder) {\n+        if (!inspector.hasDuration()) {\n+            throwMissingDuration(codeBuilder, \"begin\");\n+        } else {\n+            codeBuilder.aload(0);\n+            invokestatic(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_TIME_STAMP);\n+            putfield(codeBuilder, eventClassDesc, ImplicitFields.FIELD_START_TIME);\n+            codeBuilder.return_();\n@@ -363,2 +185,0 @@\n-        className += classDesc.displayName();\n-        return isValidField(access, className);\n@@ -367,3 +187,10 @@\n-    public static boolean isValidField(int access, String className) {\n-        if (Modifier.isTransient(access) || Modifier.isStatic(access)) {\n-            return false;\n+    private void methodEnd(CodeBuilder codeBuilder) {\n+        if (!inspector.hasDuration()) {\n+            throwMissingDuration(codeBuilder, \"end\");\n+        } else {\n+            codeBuilder.aload(0);\n+            codeBuilder.aload(0);\n+            getfield(codeBuilder, eventClassDesc, ImplicitFields.FIELD_START_TIME);\n+            invokestatic(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_DURATION);\n+            putfield(codeBuilder, eventClassDesc, ImplicitFields.FIELD_DURATION);\n+            codeBuilder.return_();\n@@ -371,6 +198,0 @@\n-        return Type.isValidJavaFieldType(className);\n-    }\n-\n-    public byte[] buildInstrumented() {\n-        makeInstrumented();\n-        return toByteArray();\n@@ -379,50 +200,40 @@\n-    byte[] toByteArray() {\n-        return ClassFile.of().build(classModel.thisClass().asSymbol(), classBuilder -> {\n-            for (ClassElement ce : classModel) {\n-                boolean updated = false;\n-                if (ce instanceof MethodModel method) {\n-                    Consumer<CodeBuilder> methodUpdate = findMethodUpdate(method);\n-                    if (methodUpdate != null) {\n-                        classBuilder.withMethod(method.methodName().stringValue(), method.methodTypeSymbol(), method.flags().flagsMask(), methodBuilder -> {\n-                            methodBuilder.withCode(methodUpdate);\n-                        });\n-                        updated = true;\n-                    }\n-                }\n-                if (!updated) {\n-                    classBuilder.with(ce);\n-                }\n-            }\n-        });\n-    }\n-\n-    public byte[] buildUninstrumented() {\n-        makeUninstrumented();\n-        return toByteArray();\n-    }\n-\n-    private void throwMissingDuration(CodeBuilder codeBuilder, String method) {\n-        String message = \"Cannot use method \" + method + \" when event lacks duration field\";\n-        Bytecode.throwException(codeBuilder, TYPE_ISE, message);\n-    }\n-\n-    private void makeInstrumented() {\n-        \/\/ MyEvent#isEnabled()\n-        updateEnabledMethod(METHOD_IS_ENABLED);\n-\n-        \/\/ MyEvent#begin()\n-        updateMethod(METHOD_BEGIN, codeBuilder -> {\n-            if (!implicitFields.hasDuration()) {\n-                throwMissingDuration(codeBuilder, \"begin\");\n-            } else {\n-                codeBuilder.aload(0);\n-                invokestatic(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_TIME_STAMP);\n-                putfield(codeBuilder, getEventClassDesc(), FIELD_START_TIME);\n-                codeBuilder.return_();\n-            }\n-        });\n-\n-        \/\/ MyEvent#end()\n-        updateMethod(METHOD_END, codeBuilder -> {\n-            if (!implicitFields.hasDuration()) {\n-                throwMissingDuration(codeBuilder, \"end\");\n+    private void methodShouldCommit(CodeBuilder codeBuilder) {\n+        Label fail = codeBuilder.newLabel();\n+        if (guardEventConfiguration) {\n+            getEventConfiguration(codeBuilder);\n+            codeBuilder.ifnull(fail);\n+        }\n+        \/\/ if (!eventConfiguration.shouldCommit(duration) goto fail;\n+        getEventConfiguration(codeBuilder);\n+        codeBuilder.aload(0);\n+        getfield(codeBuilder, eventClassDesc, ImplicitFields.FIELD_DURATION);\n+        invokevirtual(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT);\n+        codeBuilder.ifeq(fail);\n+        List<SettingDesc> settingDescs = inspector.getSettings();\n+        for (int index = 0; index < settingDescs.size(); index++) {\n+            SettingDesc sd = settingDescs.get(index);\n+            \/\/ if (!settingsMethod(eventConfiguration.settingX)) goto fail;\n+            codeBuilder.aload(0);\n+            getEventConfiguration(codeBuilder);\n+            codeBuilder.loadConstant(index);\n+            invokevirtual(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_EVENT_CONFIGURATION_GET_SETTING);\n+            MethodTypeDesc mdesc = MethodTypeDesc.ofDescriptor(\"(\" + sd.paramType().descriptorString() + \")Z\");\n+            codeBuilder.checkcast(sd.paramType());\n+            codeBuilder.invokevirtual(eventClassDesc, sd.methodName(), mdesc);\n+            codeBuilder.ifeq(fail);\n+        }\n+        \/\/ return true\n+        codeBuilder.iconst_1();\n+        codeBuilder.ireturn();\n+        \/\/ return false\n+        codeBuilder.labelBinding(fail);\n+        codeBuilder.iconst_0();\n+        codeBuilder.ireturn();\n+    }\n+\n+    private void methodCommit(CodeBuilder codeBuilder) {\n+        Label excluded = codeBuilder.newLabel();\n+        Label end = codeBuilder.newLabel();\n+        codeBuilder.trying(blockCodeBuilder -> {\n+            if (staticCommitMethod != null) {\n+                updateStaticCommit(blockCodeBuilder, excluded);\n@@ -430,6 +241,1 @@\n-                codeBuilder.aload(0);\n-                codeBuilder.aload(0);\n-                getfield(codeBuilder, getEventClassDesc(), FIELD_START_TIME);\n-                invokestatic(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_DURATION);\n-                putfield(codeBuilder, getEventClassDesc(), FIELD_DURATION);\n-                codeBuilder.return_();\n+                updateInstanceCommit(blockCodeBuilder, end, excluded);\n@@ -437,41 +243,3 @@\n-        });\n-\n-        \/\/ MyEvent#commit() or static MyEvent#commit(...)\n-        MethodDesc m = staticCommitMethod == null ? METHOD_COMMIT : staticCommitMethod;\n-        updateMethod(m, codeBuilder -> {\n-            Label excluded = codeBuilder.newLabel();\n-            Label end = codeBuilder.newLabel();\n-            codeBuilder.trying(blockCodeBuilder -> {\n-                if (staticCommitMethod != null) {\n-                    updateStaticCommit(blockCodeBuilder, excluded);\n-                } else {\n-                    updateInstanceCommit(blockCodeBuilder, end, excluded);\n-                }\n-                \/\/ stack: [integer]\n-                \/\/ notified -> restart event write attempt\n-                blockCodeBuilder.ifeq(blockCodeBuilder.startLabel());\n-                \/\/ stack: []\n-                blockCodeBuilder.goto_(end);\n-            }, catchBuilder -> {\n-                catchBuilder.catchingAll(catchAllHandler -> {\n-                    getEventWriter(catchAllHandler);\n-                    \/\/ stack: [ex] [EW]\n-                    catchAllHandler.dup();\n-                    \/\/ stack: [ex] [EW] [EW]\n-                    Label rethrow = catchAllHandler.newLabel();\n-                    catchAllHandler.ifnull(rethrow);\n-                    \/\/ stack: [ex] [EW]\n-                    catchAllHandler.dup();\n-                    \/\/ stack: [ex] [EW] [EW]\n-                    invokevirtual(catchAllHandler, TYPE_EVENT_WRITER, METHOD_RESET);\n-                    catchAllHandler.labelBinding(rethrow);\n-                    \/\/ stack:[ex] [EW]\n-                    catchAllHandler.pop();\n-                    \/\/ stack:[ex]\n-                    catchAllHandler.athrow();\n-                });\n-            });\n-            codeBuilder.labelBinding(excluded);\n-            \/\/ stack: [EW]\n-            codeBuilder.pop();\n-            codeBuilder.labelBinding(end);\n+            \/\/ stack: [integer]\n+            \/\/ notified -> restart event write attempt\n+            blockCodeBuilder.ifeq(blockCodeBuilder.startLabel());\n@@ -479,1 +247,19 @@\n-            codeBuilder.return_();\n+            blockCodeBuilder.goto_(end);\n+        }, catchBuilder -> {\n+            catchBuilder.catchingAll(catchAllHandler -> {\n+                getEventWriter(catchAllHandler);\n+                \/\/ stack: [ex] [EW]\n+                catchAllHandler.dup();\n+                \/\/ stack: [ex] [EW] [EW]\n+                Label rethrow = catchAllHandler.newLabel();\n+                catchAllHandler.ifnull(rethrow);\n+                \/\/ stack: [ex] [EW]\n+                catchAllHandler.dup();\n+                \/\/ stack: [ex] [EW] [EW]\n+                invokevirtual(catchAllHandler, TYPE_EVENT_WRITER, METHOD_RESET);\n+                catchAllHandler.labelBinding(rethrow);\n+                \/\/ stack:[ex] [EW]\n+                catchAllHandler.pop();\n+                \/\/ stack:[ex]\n+                catchAllHandler.athrow();\n+            });\n@@ -481,0 +267,7 @@\n+        codeBuilder.labelBinding(excluded);\n+        \/\/ stack: [EW]\n+        codeBuilder.pop();\n+        codeBuilder.labelBinding(end);\n+        \/\/ stack: []\n+        codeBuilder.return_();\n+    }\n@@ -482,8 +275,3 @@\n-        \/\/ MyEvent#shouldCommit()\n-        updateMethod(METHOD_EVENT_SHOULD_COMMIT, codeBuilder -> {\n-            Label fail = codeBuilder.newLabel();\n-            if (guardEventConfiguration) {\n-                getEventConfiguration(codeBuilder);\n-                codeBuilder.ifnull(fail);\n-            }\n-            \/\/ if (!eventConfiguration.shouldCommit(duration) goto fail;\n+    private void methodEnabledStatic(CodeBuilder codeBuilder) {\n+        Label nullLabel = codeBuilder.newLabel();\n+        if (guardEventConfiguration) {\n@@ -491,21 +279,7 @@\n-            codeBuilder.aload(0);\n-            getfield(codeBuilder, getEventClassDesc(), FIELD_DURATION);\n-            invokevirtual(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT);\n-            codeBuilder.ifeq(fail);\n-            for (int index = 0; index < settingDescs.size(); index++) {\n-                SettingDesc sd = settingDescs.get(index);\n-                \/\/ if (!settingsMethod(eventConfiguration.settingX)) goto fail;\n-                codeBuilder.aload(0);\n-                getEventConfiguration(codeBuilder);\n-                codeBuilder.loadConstant(index);\n-                invokevirtual(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_EVENT_CONFIGURATION_GET_SETTING);\n-                MethodTypeDesc mdesc = MethodTypeDesc.ofDescriptor(\"(\" + sd.paramType().descriptorString() + \")Z\");\n-                codeBuilder.checkcast(sd.paramType());\n-                codeBuilder.invokevirtual(getEventClassDesc(), sd.methodName(), mdesc);\n-                codeBuilder.ifeq(fail);\n-            }\n-            \/\/ return true\n-            codeBuilder.iconst_1();\n-            codeBuilder.ireturn();\n-            \/\/ return false\n-            codeBuilder.labelBinding(fail);\n+            codeBuilder.ifnull(nullLabel);\n+        }\n+        getEventConfiguration(codeBuilder);\n+        invokevirtual(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_IS_ENABLED);\n+        codeBuilder.ireturn();\n+        if (guardEventConfiguration) {\n+            codeBuilder.labelBinding(nullLabel);\n@@ -514,1 +288,2 @@\n-        });\n+        }\n+    }\n@@ -516,4 +291,4 @@\n-        if (isJDK) {\n-            if (hasStaticMethod(METHOD_ENABLED)) {\n-                updateEnabledMethod(METHOD_ENABLED);\n-            }\n+    private void methodTimestamp(CodeBuilder codeBuilder) {\n+        invokestatic(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_TIME_STAMP);\n+        codeBuilder.lreturn();\n+    }\n@@ -521,22 +296,6 @@\n-            updateIfStaticMethodExists(METHOD_SHOULD_COMMIT_LONG, codeBuilder -> {\n-                Label fail = codeBuilder.newLabel();\n-                if (guardEventConfiguration) {\n-                    \/\/ if (eventConfiguration == null) goto fail;\n-                    getEventConfiguration(codeBuilder);\n-                    codeBuilder.ifnull(fail);\n-                }\n-                \/\/ return eventConfiguration.shouldCommit(duration);\n-                getEventConfiguration(codeBuilder);\n-                codeBuilder.lload(0);\n-                codeBuilder.invokevirtual(TYPE_EVENT_CONFIGURATION, METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT.name(), METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT.descriptor());\n-                codeBuilder.ireturn();\n-                \/\/ fail:\n-                codeBuilder.labelBinding(fail);\n-                \/\/ return false\n-                codeBuilder.iconst_0();\n-                codeBuilder.ireturn();\n-            });\n-            updateIfStaticMethodExists(METHOD_TIME_STAMP, codeBuilder -> {\n-                invokestatic(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_TIME_STAMP);\n-                codeBuilder.lreturn();\n-            });\n+    private void methodShouldCommitStatic(CodeBuilder codeBuilder) {\n+        Label fail = codeBuilder.newLabel();\n+        if (guardEventConfiguration) {\n+            \/\/ if (eventConfiguration == null) goto fail;\n+            getEventConfiguration(codeBuilder);\n+            codeBuilder.ifnull(fail);\n@@ -544,0 +303,15 @@\n+        \/\/ return eventConfiguration.shouldCommit(duration);\n+        getEventConfiguration(codeBuilder);\n+        codeBuilder.lload(0);\n+        codeBuilder.invokevirtual(TYPE_EVENT_CONFIGURATION, METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT.name(), METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT.descriptor());\n+        codeBuilder.ireturn();\n+        \/\/ fail:\n+        codeBuilder.labelBinding(fail);\n+        \/\/ return false\n+        codeBuilder.iconst_0();\n+        codeBuilder.ireturn();\n+    }\n+\n+    private void throwMissingDuration(CodeBuilder codeBuilder, String method) {\n+        String message = \"Cannot use method \" + method + \" when event lacks duration field\";\n+        Bytecode.throwException(codeBuilder, TYPE_ISE, message);\n@@ -546,1 +320,1 @@\n-    void updateStaticCommit(BlockCodeBuilder blockCodeBuilder, Label excluded) {\n+    private void updateStaticCommit(BlockCodeBuilder blockCodeBuilder, Label excluded) {\n@@ -579,1 +353,1 @@\n-        if (implicitFields.hasDuration()) {\n+        if (inspector.hasDuration()) {\n@@ -591,1 +365,1 @@\n-        if (implicitFields.hasEventThread()) {\n+        if (inspector.hasEventThread()) {\n@@ -598,1 +372,1 @@\n-        if (implicitFields.hasStackTrace()) {\n+        if (inspector.hasStackTrace()) {\n@@ -606,0 +380,1 @@\n+        List<FieldDesc> fieldDescs = inspector.getFields();\n@@ -625,1 +400,1 @@\n-    void updateInstanceCommit(BlockCodeBuilder blockCodeBuilder, Label end, Label excluded) {\n+    private void updateInstanceCommit(BlockCodeBuilder blockCodeBuilder, Label end, Label excluded) {\n@@ -630,1 +405,1 @@\n-        invokevirtual(blockCodeBuilder, getEventClassDesc(), METHOD_IS_ENABLED);\n+        invokevirtual(blockCodeBuilder, eventClassDesc, METHOD_IS_ENABLED);\n@@ -637,1 +412,1 @@\n-        getfield(blockCodeBuilder, getEventClassDesc(), FIELD_START_TIME);\n+        getfield(blockCodeBuilder, eventClassDesc, ImplicitFields.FIELD_START_TIME);\n@@ -657,1 +432,1 @@\n-        getfield(blockCodeBuilder, getEventClassDesc(), FIELD_DURATION);\n+        getfield(blockCodeBuilder, eventClassDesc, ImplicitFields.FIELD_DURATION);\n@@ -665,1 +440,1 @@\n-        putfield(blockCodeBuilder, getEventClassDesc(), FIELD_DURATION);\n+        putfield(blockCodeBuilder, eventClassDesc, ImplicitFields.FIELD_DURATION);\n@@ -669,1 +444,1 @@\n-        invokevirtual(blockCodeBuilder, getEventClassDesc(), METHOD_EVENT_SHOULD_COMMIT);\n+        invokevirtual(blockCodeBuilder, eventClassDesc, METHOD_EVENT_SHOULD_COMMIT);\n@@ -690,1 +465,1 @@\n-        if (implicitFields.hasDuration()) {\n+        if (inspector.hasDuration()) {\n@@ -696,1 +471,1 @@\n-            getfield(blockCodeBuilder, getEventClassDesc(), FIELD_DURATION);\n+            getfield(blockCodeBuilder, eventClassDesc, ImplicitFields.FIELD_DURATION);\n@@ -702,1 +477,1 @@\n-        if (implicitFields.hasEventThread()) {\n+        if (inspector.hasEventThread()) {\n@@ -709,1 +484,1 @@\n-        if (implicitFields.hasStackTrace()) {\n+        if (inspector.hasStackTrace()) {\n@@ -716,0 +491,1 @@\n+        List<FieldDesc> fieldDescs = inspector.getFields();\n@@ -722,1 +498,1 @@\n-            getfield(blockCodeBuilder, getEventClassDesc(), field);\n+            getfield(blockCodeBuilder, eventClassDesc, field);\n@@ -734,22 +510,2 @@\n-    private void updateEnabledMethod(MethodDesc method) {\n-        updateMethod(method, codeBuilder -> {\n-            Label nullLabel = codeBuilder.newLabel();\n-            if (guardEventConfiguration) {\n-                getEventConfiguration(codeBuilder);\n-                codeBuilder.ifnull(nullLabel);\n-            }\n-            getEventConfiguration(codeBuilder);\n-            invokevirtual(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_IS_ENABLED);\n-            codeBuilder.ireturn();\n-            if (guardEventConfiguration) {\n-                codeBuilder.labelBinding(nullLabel);\n-                codeBuilder.iconst_0();\n-                codeBuilder.ireturn();\n-            }\n-        });\n-    }\n-\n-    private void updateIfStaticMethodExists(MethodDesc method, Consumer<CodeBuilder> code) {\n-        if (hasStaticMethod(method)) {\n-            updateMethod(method, code);\n-        }\n+    private static boolean isStatic(MethodModel method) {\n+        return (method.flags().flagsMask() & ClassFile.ACC_STATIC) != 0;\n@@ -758,7 +514,2 @@\n-    private boolean hasStaticMethod(MethodDesc method) {\n-        for (MethodModel m : classModel.methods()) {\n-            if (m.methodName().equalsString(method.name()) && m.methodTypeSymbol().equals(method.descriptor())) {\n-                return Modifier.isStatic(m.flags().flagsMask());\n-            }\n-        }\n-        return false;\n+    private static boolean isMethod(MethodModel m, MethodDesc desc) {\n+        return desc.matches(m);\n@@ -767,1 +518,1 @@\n-    private void getEventWriter(CodeBuilder codeBuilder) {\n+    private static void getEventWriter(CodeBuilder codeBuilder) {\n@@ -773,1 +524,1 @@\n-            codeBuilder.getstatic(getEventClassDesc(), FIELD_EVENT_CONFIGURATION.name(), TYPE_OBJECT);\n+            codeBuilder.getstatic(eventClassDesc, FIELD_EVENT_CONFIGURATION.name(), TYPE_OBJECT);\n@@ -776,1 +527,1 @@\n-            codeBuilder.getstatic(getEventClassDesc(), FIELD_EVENT_CONFIGURATION.name(), TYPE_EVENT_CONFIGURATION);\n+            codeBuilder.getstatic(eventClassDesc, FIELD_EVENT_CONFIGURATION.name(), TYPE_EVENT_CONFIGURATION);\n@@ -780,6 +531,5 @@\n-    private void makeUninstrumented() {\n-        updateExistingWithReturnFalse(METHOD_EVENT_SHOULD_COMMIT);\n-        updateExistingWithReturnFalse(METHOD_IS_ENABLED);\n-        updateExistingWithEmptyVoidMethod(METHOD_COMMIT);\n-        if (staticCommitMethod != null) {\n-            updateExistingWithEmptyVoidMethod(staticCommitMethod);\n+    private boolean hasUntypedConfiguration() {\n+        for (FieldModel f : inspector.getClassModel().fields()) {\n+            if (f.fieldName().equalsString(FIELD_EVENT_CONFIGURATION.name())) {\n+                return f.fieldType().equalsString(TYPE_OBJECT.descriptorString());\n+            }\n@@ -787,32 +537,1 @@\n-        updateExistingWithEmptyVoidMethod(METHOD_BEGIN);\n-        updateExistingWithEmptyVoidMethod(METHOD_END);\n-    }\n-\n-    private final void updateExistingWithEmptyVoidMethod(MethodDesc voidMethod) {\n-        updateMethod(voidMethod, codeBuilder -> {\n-            codeBuilder.return_();\n-        });\n-    }\n-\n-    private final void updateExistingWithReturnFalse(MethodDesc voidMethod) {\n-        updateMethod(voidMethod, codeBuilder -> {\n-            codeBuilder.iconst_0();\n-            codeBuilder.ireturn();\n-        });\n-    }\n-\n-    private Consumer<CodeBuilder> findMethodUpdate(MethodModel mm) {\n-        MethodDesc m = MethodDesc.of(mm.methodName().stringValue(), mm.methodType().stringValue());\n-        return methodUpdates.get(m);\n-    }\n-\n-    private void updateMethod(MethodDesc method, Consumer<CodeBuilder> codeBuilder) {\n-        methodUpdates.put(method, codeBuilder);\n-    }\n-\n-    private ClassDesc getEventClassDesc() {\n-        return classModel.thisClass().asSymbol();\n-    }\n-\n-    public String getEventName() {\n-        return eventName;\n+        throw new InternalError(\"Class missing configuration field\");\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventInstrumentation.java","additions":239,"deletions":520,"binary":false,"changes":759,"status":"modified"},{"patch":"@@ -75,1 +75,2 @@\n-                EventInstrumentation ei = new EventInstrumentation(clazz.getSuperclass(), oldBytes, traceId, jdkClass, false);\n+                ClassInspector c = new ClassInspector(clazz.getSuperclass(), oldBytes, jdkClass);\n+                EventInstrumentation ei = new EventInstrumentation(c, traceId, false);\n@@ -108,3 +109,3 @@\n-            EventInstrumentation ei = new EventInstrumentation(superClass, oldBytes, traceId, bootClassLoader, true);\n-            eventName = ei.getEventName();\n-            if (!JVMSupport.shouldInstrument(bootClassLoader,  ei.getEventName())) {\n+            ClassInspector c = new ClassInspector(superClass, oldBytes, bootClassLoader);\n+            eventName = c.getEventName();\n+            if (!JVMSupport.shouldInstrument(bootClassLoader,  c.getEventName())) {\n@@ -121,1 +122,1 @@\n-                if (!mr.isEnabled(ei.getEventName()) && !ei.isEnabled() || !ei.isRegistered()) {\n+                if (!mr.isEnabled(c.getEventName()) && !c.isEnabled() || !c.isRegistered()) {\n@@ -126,1 +127,1 @@\n-            Logger.log(LogTag.JFR_SYSTEM, LogLevel.INFO, \"Adding \" + (forceInstrumentation ? \"forced \" : \"\") + \"instrumentation for event type \" + eventName + \" during initial class load\");\n+            EventInstrumentation ei = new EventInstrumentation(c, traceId, true);\n@@ -128,1 +129,2 @@\n-            Bytecode.log(ei.getClassName() + \"(\" + traceId + \")\", bytes);\n+            Logger.log(LogTag.JFR_SYSTEM, LogLevel.INFO, \"Adding \" + (forceInstrumentation ? \"forced \" : \"\") + \"instrumentation for event type \" + eventName + \" during initial class load\");\n+            Bytecode.log(c.getClassName() + \"(\" + traceId + \")\", bytes);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVMUpcalls.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.lang.classfile.MethodModel;\n@@ -77,0 +78,6 @@\n+\n+        public boolean matches(MethodModel m) {\n+            return this.descriptor().equals(m.methodTypeSymbol()) && m.methodName().equalsString(this.name());\n+        }\n+    }\n+    public record SettingDesc(ClassDesc paramType, String methodName) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/Bytecode.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import jdk.jfr.internal.util.Bytecode.FieldDesc;\n@@ -40,0 +41,2 @@\n+    public static final FieldDesc FIELD_DURATION = FieldDesc.of(long.class, DURATION);\n+    public static final FieldDesc FIELD_START_TIME = FieldDesc.of(long.class, START_TIME);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/ImplicitFields.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}