{"files":[{"patch":"@@ -89,2 +89,2 @@\n-typedef OverflowTaskQueue<ScannerTask, mtGC>           G1ScannerTasksQueue;\n-typedef GenericTaskQueueSet<G1ScannerTasksQueue, mtGC> G1ScannerTasksQueueSet;\n+typedef PartialArraySupportTaskQueue<ScannerTask, mtGC>            G1ScannerTasksQueue;\n+typedef PartialArraySupportTaskQueueSet<G1ScannerTasksQueue, mtGC> G1ScannerTasksQueueSet;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"gc\/shared\/partialArrayProcessor.inline.hpp\"\n@@ -86,2 +87,1 @@\n-    _partial_array_state_allocator(pas_allocator),\n-    _partial_array_stepper(num_workers, ParGCArrayScanChunk),\n+    _partial_array_processor(num_workers, ParGCArrayScanChunk, pas_allocator, _task_queue),\n@@ -117,0 +117,2 @@\n+  _partial_array_processor.set_partial_array_state_allocator_index(worker_id);\n+\n@@ -228,0 +230,11 @@\n+void inline G1ParScanThreadState::process_array_chunk(objArrayOop array, int begin, int end) {\n+  \/\/ Skip the card enqueue iff the object (to_array) is in survivor region.\n+  \/\/ However, G1HeapRegion::is_survivor() is too expensive here.\n+  \/\/ Instead, we use dest_attr.is_young() because the two values are always\n+  \/\/ equal: successfully allocated young regions must be survivor regions.\n+  G1HeapRegionAttr dest_attr = _g1h->region_attr(array);\n+  G1SkipCardEnqueueSetter x(&_scanner, dest_attr.is_new_survivor());\n+  \/\/ Process claimed task.\n+  array->oop_iterate_range(&_scanner, begin, end);\n+}\n+\n@@ -241,1 +254,3 @@\n-  objArrayOop to_array = objArrayOop(to_obj);\n+  auto push_func = [&] (PartialArrayState* state) {\n+    push_on_queue(ScannerTask(state));\n+  };\n@@ -243,10 +258,3 @@\n-  \/\/ Claim a chunk and get number of additional tasks to enqueue.\n-  PartialArrayTaskStepper::Step step = _partial_array_stepper.next(state);\n-  \/\/ Push any additional partial scan tasks needed.  Pushed before processing\n-  \/\/ the claimed chunk to allow other workers to steal while we're processing.\n-  if (step._ncreate > 0) {\n-    state->add_references(step._ncreate);\n-    for (uint i = 0; i < step._ncreate; ++i) {\n-      push_on_queue(ScannerTask(state));\n-    }\n-  }\n+  auto process_func = [&] (objArrayOop from_array, objArrayOop to_array, uint begin, uint end) {\n+    process_array_chunk(to_array, begin, end);\n+  };\n@@ -254,8 +262,1 @@\n-  G1HeapRegionAttr dest_attr = _g1h->region_attr(to_array);\n-  G1SkipCardEnqueueSetter x(&_scanner, dest_attr.is_new_survivor());\n-  \/\/ Process claimed task.\n-  to_array->oop_iterate_range(&_scanner,\n-                              checked_cast<int>(step._index),\n-                              checked_cast<int>(step._index + _partial_array_stepper.chunk_size()));\n-  \/\/ Release reference to the state, now that we're done with it.\n-  _partial_array_state_allocator->release(_worker_id, state);\n+  _partial_array_processor.process_array_chunk(state, push_func, process_func);\n@@ -273,23 +274,3 @@\n-  objArrayOop to_array = objArrayOop(to_obj);\n-\n-  size_t array_length = to_array->length();\n-  PartialArrayTaskStepper::Step step = _partial_array_stepper.start(array_length);\n-\n-  \/\/ Push any needed partial scan tasks.  Pushed before processing the\n-  \/\/ initial chunk to allow other workers to steal while we're processing.\n-  if (step._ncreate > 0) {\n-    assert(step._index < array_length, \"invariant\");\n-    assert(((array_length - step._index) % _partial_array_stepper.chunk_size()) == 0,\n-           \"invariant\");\n-    PartialArrayState* state =\n-      _partial_array_state_allocator->allocate(_worker_id,\n-                                               from_obj, to_obj,\n-                                               step._index,\n-                                               array_length,\n-                                               step._ncreate);\n-    for (uint i = 0; i < step._ncreate; ++i) {\n-      push_on_queue(ScannerTask(state));\n-    }\n-  } else {\n-    assert(step._index == array_length, \"invariant\");\n-  }\n+  auto push_func = [&] (PartialArrayState* state) {\n+    push_on_queue(ScannerTask(state));\n+  };\n@@ -297,10 +278,5 @@\n-  \/\/ Skip the card enqueue iff the object (to_array) is in survivor region.\n-  \/\/ However, G1HeapRegion::is_survivor() is too expensive here.\n-  \/\/ Instead, we use dest_attr.is_young() because the two values are always\n-  \/\/ equal: successfully allocated young regions must be survivor regions.\n-  assert(dest_attr.is_young() == _g1h->heap_region_containing(to_array)->is_survivor(), \"must be\");\n-  G1SkipCardEnqueueSetter x(&_scanner, dest_attr.is_young());\n-  \/\/ Process the initial chunk.  No need to process the type in the\n-  \/\/ klass, as it will already be handled by processing the built-in\n-  \/\/ module.\n-  to_array->oop_iterate_range(&_scanner, 0, checked_cast<int>(step._index));\n+  auto process_func = [&] (objArrayOop from_array, objArrayOop to_array, int begin, int end) {\n+    process_array_chunk(to_array, begin, end);\n+  };\n+\n+  _partial_array_processor.start(objArrayOop(from_obj), objArrayOop(to_obj), push_func, process_func);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":30,"deletions":54,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/shared\/partialArrayProcessor.hpp\"\n@@ -90,2 +91,1 @@\n-  PartialArrayStateAllocator* _partial_array_state_allocator;\n-  PartialArrayTaskStepper _partial_array_stepper;\n+  PartialArrayProcessor<G1ScannerTasksQueue>  _partial_array_processor;\n@@ -224,0 +224,1 @@\n+  void process_array_chunk(objArrayOop array, int begin, int end);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"gc\/shared\/partialArrayTaskStepper.inline.hpp\"\n+#include \"gc\/shared\/partialArrayProcessor.inline.hpp\"\n@@ -78,1 +78,2 @@\n-    _manager_array[i]._partial_array_state_allocator_index = i;\n+    _manager_array[i]._partial_array_processor.set_partial_array_state_allocator(_partial_array_state_allocator);\n+    _manager_array[i]._partial_array_processor.set_partial_array_state_allocator_index(i);\n@@ -125,1 +126,1 @@\n-  TASKQUEUE_STATS_ONLY(print_taskqueue_stats());\n+  TASKQUEUE_STATS_ONLY(stack_array_depth()->print_and_reset_taskqueue_stats(\"Oop Queue\");)\n@@ -148,40 +149,0 @@\n-#if TASKQUEUE_STATS\n-void\n-PSPromotionManager::print_local_stats(outputStream* const out, uint i) const {\n-  #define FMT \" \" SIZE_FORMAT_W(10)\n-  out->print_cr(\"%3u\" FMT FMT FMT FMT,\n-                i, _array_chunk_pushes, _array_chunk_steals,\n-                _arrays_chunked, _array_chunks_processed);\n-  #undef FMT\n-}\n-\n-static const char* const pm_stats_hdr[] = {\n-  \"    ----partial array----     arrays      array\",\n-  \"thr       push      steal    chunked     chunks\",\n-  \"--- ---------- ---------- ---------- ----------\"\n-};\n-\n-void PSPromotionManager::print_taskqueue_stats() {\n-  if (!log_is_enabled(Trace, gc, task, stats)) {\n-    return;\n-  }\n-  Log(gc, task, stats) log;\n-  ResourceMark rm;\n-  LogStream ls(log.trace());\n-\n-  stack_array_depth()->print_taskqueue_stats(&ls, \"Oop Queue\");\n-\n-  const uint hlines = sizeof(pm_stats_hdr) \/ sizeof(pm_stats_hdr[0]);\n-  for (uint i = 0; i < hlines; ++i) ls.print_cr(\"%s\", pm_stats_hdr[i]);\n-  for (uint i = 0; i < ParallelGCThreads; ++i) {\n-    manager_array(i)->print_local_stats(&ls, i);\n-  }\n-}\n-\n-void PSPromotionManager::reset_stats() {\n-  claimed_stack_depth()->stats.reset();\n-  _array_chunk_pushes = _array_chunk_steals = 0;\n-  _arrays_chunked = _array_chunks_processed = 0;\n-}\n-#endif \/\/ TASKQUEUE_STATS\n-\n@@ -190,1 +151,1 @@\n-  : _partial_array_stepper(ParallelGCThreads, ParGCArrayScanChunk)\n+  : _partial_array_processor(ParallelGCThreads, ParGCArrayScanChunk, &_claimed_stack_depth)\n@@ -201,3 +162,0 @@\n-  \/\/ Initialize to a bad value; fixed by initialize().\n-  _partial_array_state_allocator_index = UINT_MAX;\n-\n@@ -227,2 +185,0 @@\n-\n-  TASKQUEUE_STATS_ONLY(reset_stats());\n@@ -286,1 +242,1 @@\n-                                                 oop obj,\n+                                                 objArrayOop obj,\n@@ -289,1 +245,1 @@\n-  T* const base      = (T*)objArrayOop(obj)->base();\n+  T* const base      = (T*)obj->base();\n@@ -299,9 +255,9 @@\n-  TASKQUEUE_STATS_ONLY(++_array_chunks_processed);\n-\n-  \/\/ Claim a chunk.  Push additional tasks before processing the claimed\n-  \/\/ chunk to allow other workers to steal while we're processing.\n-  PartialArrayTaskStepper::Step step = _partial_array_stepper.next(state);\n-  if (step._ncreate > 0) {\n-    state->add_references(step._ncreate);\n-    for (uint i = 0; i < step._ncreate; ++i) {\n-      push_depth(ScannerTask(state));\n+  auto push_func = [&] (PartialArrayState* state) {\n+    push_depth(ScannerTask(state));\n+  };\n+\n+  auto proc_func = [&] (objArrayOop from_array, objArrayOop to_array, int start, int end) {\n+    if (UseCompressedOops) {\n+      process_array_chunk_work<narrowOop>(to_array, start, end);\n+    } else {\n+      process_array_chunk_work<oop>(to_array, start, end);\n@@ -309,12 +265,3 @@\n-    TASKQUEUE_STATS_ONLY(_array_chunk_pushes += step._ncreate);\n-  }\n-  int start = checked_cast<int>(step._index);\n-  int end = checked_cast<int>(step._index + _partial_array_stepper.chunk_size());\n-  assert(start < end, \"invariant\");\n-  if (UseCompressedOops) {\n-    process_array_chunk_work<narrowOop>(state->destination(), start, end);\n-  } else {\n-    process_array_chunk_work<oop>(state->destination(), start, end);\n-  }\n-  \/\/ Release reference to state, now that we're done with it.\n-  _partial_array_state_allocator->release(_partial_array_state_allocator_index, state);\n+  };\n+\n+  _partial_array_processor.process_array_chunk(state, push_func, proc_func);\n@@ -329,13 +276,9 @@\n-  size_t array_length = objArrayOop(new_obj)->length();\n-  PartialArrayTaskStepper::Step step = _partial_array_stepper.start(array_length);\n-\n-  if (step._ncreate > 0) {\n-    TASKQUEUE_STATS_ONLY(++_arrays_chunked);\n-    PartialArrayState* state =\n-      _partial_array_state_allocator->allocate(_partial_array_state_allocator_index,\n-                                               old_obj, new_obj,\n-                                               step._index,\n-                                               array_length,\n-                                               step._ncreate);\n-    for (uint i = 0; i < step._ncreate; ++i) {\n-      push_depth(ScannerTask(state));\n+  auto push_func = [&] (PartialArrayState* state) {\n+    push_depth(ScannerTask(state));\n+  };\n+\n+  auto proc_func = [&] (objArrayOop from_array, objArrayOop to_array, int start, int end) {\n+    if (UseCompressedOops) {\n+      process_array_chunk_work<narrowOop>(to_array, start, end);\n+    } else {\n+      process_array_chunk_work<oop>(to_array, start, end);\n@@ -343,7 +286,3 @@\n-    TASKQUEUE_STATS_ONLY(_array_chunk_pushes += step._ncreate);\n-  }\n-  if (UseCompressedOops) {\n-    process_array_chunk_work<narrowOop>(new_obj, 0, checked_cast<int>(step._index));\n-  } else {\n-    process_array_chunk_work<oop>(new_obj, 0, checked_cast<int>(step._index));\n-  }\n+  };\n+\n+  _partial_array_processor.start(objArrayOop(old_obj), objArrayOop(new_obj), push_func, proc_func);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":31,"deletions":92,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"gc\/shared\/partialArrayTaskStepper.hpp\"\n+#include \"gc\/shared\/partialArrayProcessor.hpp\"\n@@ -61,2 +61,2 @@\n-  typedef OverflowTaskQueue<ScannerTask, mtGC>           PSScannerTasksQueue;\n-  typedef GenericTaskQueueSet<PSScannerTasksQueue, mtGC> PSScannerTasksQueueSet;\n+  typedef PartialArraySupportTaskQueue<ScannerTask, mtGC>            PSScannerTasksQueue;\n+  typedef PartialArraySupportTaskQueueSet<PSScannerTasksQueue, mtGC> PSScannerTasksQueueSet;\n@@ -70,12 +70,0 @@\n-#if TASKQUEUE_STATS\n-  size_t                              _array_chunk_pushes;\n-  size_t                              _array_chunk_steals;\n-  size_t                              _arrays_chunked;\n-  size_t                              _array_chunks_processed;\n-\n-  void print_local_stats(outputStream* const out, uint i) const;\n-  static void print_taskqueue_stats();\n-\n-  void reset_stats();\n-#endif \/\/ TASKQUEUE_STATS\n-\n@@ -92,2 +80,1 @@\n-  PartialArrayTaskStepper             _partial_array_stepper;\n-  uint                                _partial_array_state_allocator_index;\n+  PartialArrayProcessor<PSScannerTasksQueue>  _partial_array_processor;\n@@ -107,1 +94,1 @@\n-  template <class T> void  process_array_chunk_work(oop obj,\n+  template <class T> void  process_array_chunk_work(objArrayOop obj,\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":5,"deletions":18,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -343,1 +343,1 @@\n-    ++_array_chunk_steals;\n+     _claimed_stack_depth.record_array_chunk_steal();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_PARTIALARRAYPROCESSOR_HPP\n+#define SHARE_GC_SHARED_PARTIALARRAYPROCESSOR_HPP\n+\n+#include \"gc\/shared\/partialArrayTaskStepper.hpp\"\n+#include \"oops\/objArrayOop.hpp\"\n+\n+class PartialArrayStateAllocator;\n+class PartialArrayState;\n+\n+template <typename T>\n+class PartialArrayProcessor {\n+private:\n+  PartialArrayTaskStepper           _partial_array_stepper;\n+  PartialArrayStateAllocator*       _partial_array_state_allocator;\n+  uint                              _partial_array_state_allocator_index;\n+  T* const                          _queue;\n+public:\n+  PartialArrayProcessor(uint n_workers, size_t chunk_size, PartialArrayStateAllocator* allocator, T* q);\n+  PartialArrayProcessor(uint n_workers, size_t chunk_size, T* q);\n+\n+  void set_partial_array_state_allocator(PartialArrayStateAllocator* alloc);\n+  void set_partial_array_state_allocator_index(uint i);\n+\n+  template <typename PUSH_FUNC, typename PROC_FUNC>\n+  void start(objArrayOop from_array, objArrayOop to_array, PUSH_FUNC& pushf, PROC_FUNC& procf);\n+\n+  template <typename PUSH_FUNC, typename PROC_FUNC>\n+  void process_array_chunk(PartialArrayState* state, PUSH_FUNC& pushf, PROC_FUNC& procf);\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_PARTIALARRAYPROCESSOR_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayProcessor.hpp","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_PARTIALARRAYPROCESSOR_INLINE_HPP\n+#define SHARE_GC_SHARED_PARTIALARRAYPROCESSOR_INLINE_HPP\n+\n+#include \"gc\/shared\/partialArrayProcessor.hpp\"\n+#include \"gc\/shared\/partialArrayState.hpp\"\n+#include \"gc\/shared\/partialArrayTaskStepper.inline.hpp\"\n+#include \"utilities\/checkedCast.hpp\"\n+\n+template <typename T>\n+void PartialArrayProcessor<T>::set_partial_array_state_allocator(PartialArrayStateAllocator* alloc) {\n+  assert(_partial_array_state_allocator == nullptr, \"Set PartialArrayStateAllocator twice\");\n+  _partial_array_state_allocator = alloc;\n+}\n+template <typename T>\n+void PartialArrayProcessor<T>::set_partial_array_state_allocator_index(uint i) {\n+  assert(_partial_array_state_allocator_index == UINT_MAX, \"Set PartialArrayStateAllocator index twice\");\n+  _partial_array_state_allocator_index = i;\n+}\n+\n+template <typename T>\n+PartialArrayProcessor<T>::PartialArrayProcessor(uint n_workers, size_t chunk_size, PartialArrayStateAllocator* allocator, T* q) :\n+  _partial_array_stepper(n_workers, chunk_size),\n+  _partial_array_state_allocator(allocator),\n+  _partial_array_state_allocator_index(UINT_MAX),\n+  _queue(q) { }\n+\n+template <typename T>\n+PartialArrayProcessor<T>::PartialArrayProcessor(uint n_workers, size_t chunk_size, T* q) :\n+  _partial_array_stepper(n_workers, chunk_size),\n+  _partial_array_state_allocator(nullptr),\n+  _partial_array_state_allocator_index(UINT_MAX),\n+  _queue(q) { }\n+\n+template <typename T>\n+template <typename PUSH_FUNC, typename PROC_FUNC>\n+void PartialArrayProcessor<T>::start(objArrayOop from_array, objArrayOop to_array, PUSH_FUNC& pushf, PROC_FUNC& procf) {\n+  size_t array_length = from_array->length();\n+  PartialArrayTaskStepper::Step step = _partial_array_stepper.start(array_length);\n+  if (step._ncreate > 0) {\n+    assert(_partial_array_state_allocator != nullptr, \"PartialArrayStateAllocator not initialized\");\n+    TASKQUEUE_STATS_ONLY(_queue->record_arrays_chunked());\n+    PartialArrayState* state =\n+    _partial_array_state_allocator->allocate(_partial_array_state_allocator_index,\n+                                             from_array, to_array,\n+                                             step._index,\n+                                             array_length,\n+                                             step._ncreate);\n+    for (uint i = 0; i < step._ncreate; ++i) {\n+      pushf(state);\n+    }\n+    TASKQUEUE_STATS_ONLY(_queue->record_array_chunk_pushes(step._ncreate));\n+  }\n+\n+  procf(from_array, to_array, 0, checked_cast<int>(step._index));\n+}\n+\n+template <typename T>\n+template <typename PUSH_FUNC, typename PROC_FUNC>\n+void PartialArrayProcessor<T>::process_array_chunk(PartialArrayState* state, PUSH_FUNC& pushf, PROC_FUNC& procf) {\n+  TASKQUEUE_STATS_ONLY(_queue->record_array_chunks_processed());\n+\n+  \/\/ Claim a chunk.  Push additional tasks before processing the claimed\n+  \/\/ chunk to allow other workers to steal while we're processing.\n+  PartialArrayTaskStepper::Step step = _partial_array_stepper.next(state);\n+  if (step._ncreate > 0) {\n+    state->add_references(step._ncreate);\n+    for (uint i = 0; i < step._ncreate; ++i) {\n+      pushf(state);\n+    }\n+    TASKQUEUE_STATS_ONLY(_queue->record_array_chunk_pushes(step._ncreate));\n+  }\n+  int start = checked_cast<int>(step._index);\n+  int end = checked_cast<int>(step._index + _partial_array_stepper.chunk_size());\n+  assert(start < end, \"invariant\");\n+  procf(objArrayOop(state->source()), objArrayOop(state->destination()), start, end);\n+\n+  \/\/ Release reference to state, now that we're done with it.\n+  _partial_array_state_allocator->release(_partial_array_state_allocator_index, state);\n+}\n+#endif \/\/ SHARE_GC_SHARED_PARTIALARRAYPROCESSOR_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayProcessor.inline.hpp","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -294,0 +294,1 @@\n+  TASKQUEUE_STATS_ONLY(virtual void reset_stats() { stats.reset(); })\n@@ -512,1 +513,1 @@\n-  void print_taskqueue_stats(outputStream* const st, const char* label);\n+  virtual void print_taskqueue_stats(outputStream* const st, const char* label);\n@@ -551,0 +552,44 @@\n+#if TASKQUEUE_STATS\n+\/\/ PartialArraySupportTaskQueue and PartialArraySupportTaskQueueSet\n+\/\/ support collecting and reporting array chunking statistics.\n+template<class E, MemTag MT, unsigned int N = TASKQUEUE_SIZE>\n+class PartialArraySupportTaskQueue: public OverflowTaskQueue<E, MT, N> {\n+  size_t                        _array_chunk_pushes;\n+  size_t                        _array_chunk_steals;\n+  size_t                        _arrays_chunked;\n+  size_t                        _array_chunks_processed;\n+public:\n+  PartialArraySupportTaskQueue();\n+\n+  void reset_stats() override;\n+  void print_array_chunk_stats(outputStream* const st, uint i);\n+\n+  void record_array_chunk_steal()  { ++_array_chunk_steals; }\n+  void record_array_chunk_pushes(size_t n) { _array_chunk_pushes += n; }\n+  void record_arrays_chunked() { ++_arrays_chunked; }\n+  void record_array_chunks_processed() { ++_array_chunks_processed; }\n+private:\n+  void reset_array_stats();\n+};\n+\n+\n+template<class T, MemTag MT>\n+class PartialArraySupportTaskQueueSet: public GenericTaskQueueSet<T, MT> {\n+public:\n+  using GenericTaskQueueSet<T, MT>::size;\n+  using GenericTaskQueueSet<T, MT>::queue;\n+\n+  PartialArraySupportTaskQueueSet(uint n);\n+\n+  void print_taskqueue_stats(outputStream* const st, const char* label) override;\n+private:\n+  static void print_taskqueue_array_stats_hdr(outputStream* const st);\n+};\n+#else\n+template<class E, MemTag MT, unsigned int N = TASKQUEUE_SIZE>\n+using PartialArraySupportTaskQueue = OverflowTaskQueue<E, MT, N>;\n+\n+template<class T, MemTag MT>\n+using PartialArraySupportTaskQueueSet = GenericTaskQueueSet<T, MT>;\n+#endif \/\/ TASKQUEUE_STATS\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/taskqueue.hpp","additions":46,"deletions":1,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-    queue(i)->stats.reset();\n+    queue(i)->reset_stats();\n@@ -408,0 +408,44 @@\n+#if TASKQUEUE_STATS\n+template<class E, MemTag MT, unsigned int N>\n+PartialArraySupportTaskQueue<E, MT, N>::PartialArraySupportTaskQueue() :\n+  OverflowTaskQueue<E, MT, N>() {\n+  TASKQUEUE_STATS_ONLY(reset_array_stats());\n+}\n+\n+template<class E, MemTag MT, unsigned int N>\n+void PartialArraySupportTaskQueue<E, MT, N>::reset_stats() {\n+  OverflowTaskQueue<E, MT, N>::reset_stats();\n+  reset_array_stats();\n+}\n+\n+template<class E, MemTag MT, unsigned int N>\n+void PartialArraySupportTaskQueue<E, MT, N>::reset_array_stats() {\n+  _array_chunk_pushes = 0;\n+  _array_chunk_steals = 0;\n+  _arrays_chunked = 0;\n+  _array_chunks_processed = 0;\n+}\n+\n+template<class E, MemTag MT, unsigned int N>\n+void PartialArraySupportTaskQueue<E, MT, N>::print_array_chunk_stats(outputStream* const st, uint i) {\n+#define FMT \" \" SIZE_FORMAT_W(10)\n+  st->print_cr(\"%3u\" FMT FMT FMT FMT,\n+                i, _array_chunk_pushes, _array_chunk_steals,\n+                _arrays_chunked, _array_chunks_processed);\n+#undef FMT\n+}\n+\n+template<class T, MemTag MT>\n+PartialArraySupportTaskQueueSet<T, MT>::PartialArraySupportTaskQueueSet(uint n) :\n+  GenericTaskQueueSet<T, MT>(n) { }\n+\n+template<class T, MemTag MT>\n+void PartialArraySupportTaskQueueSet<T, MT>::print_taskqueue_array_stats_hdr(outputStream* const st) {\n+  static const char* const pm_stats_hdr[] = {\n+    \"    ----partial array----     arrays      array\",\n+    \"thr       push      steal    chunked     chunks\",\n+    \"--- ---------- ---------- ---------- ----------\"\n+  };\n+  const uint hlines = sizeof(pm_stats_hdr) \/ sizeof(pm_stats_hdr[0]);\n+  for (uint i = 0; i < hlines; ++i) st->print_cr(\"%s\", pm_stats_hdr[i]);\n+}\n@@ -409,0 +453,10 @@\n+template<class T, MemTag MT>\n+void PartialArraySupportTaskQueueSet<T, MT>::print_taskqueue_stats(outputStream* const st, const char* label) {\n+  GenericTaskQueueSet<T, MT>::print_taskqueue_stats(st, label);\n+  uint n = size();\n+  print_taskqueue_array_stats_hdr(st);\n+  for (uint i = 0; i < n; ++i) {\n+    queue(i)->print_array_chunk_stats(st, i);\n+  }\n+}\n+#endif \/\/ TASKQUEUE_STATS\n","filename":"src\/hotspot\/share\/gc\/shared\/taskqueue.inline.hpp","additions":55,"deletions":1,"binary":false,"changes":56,"status":"modified"}]}