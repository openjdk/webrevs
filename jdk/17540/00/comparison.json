{"files":[{"patch":"@@ -53,1 +53,0 @@\n-  _periodic_task(this),\n@@ -60,18 +59,0 @@\n-  _periodic_task.enroll();\n-  if (ShenandoahPacing) {\n-    _periodic_pacer_notify_task.enroll();\n-  }\n-}\n-\n-ShenandoahControlThread::~ShenandoahControlThread() {\n-  \/\/ This is here so that super is called.\n-}\n-\n-void ShenandoahPeriodicTask::task() {\n-  _thread->handle_force_counters_update();\n-  _thread->handle_counters_update();\n-}\n-\n-void ShenandoahPeriodicPacerNotify::task() {\n-  assert(ShenandoahPacing, \"Should not be here otherwise\");\n-  ShenandoahHeap::heap()->pacer()->notify_waiters();\n@@ -198,1 +179,1 @@\n-      set_forced_counters_update(true);\n+      heap->set_forced_counters_update(true);\n@@ -239,1 +220,1 @@\n-        Universe::heap()->update_capacity_and_used_at_gc();\n+        heap->update_capacity_and_used_at_gc();\n@@ -242,1 +223,1 @@\n-        Universe::heap()->record_whole_heap_examined_timestamp();\n+        heap->record_whole_heap_examined_timestamp();\n@@ -247,2 +228,2 @@\n-      handle_force_counters_update();\n-      set_forced_counters_update(false);\n+      heap->handle_force_counters_update();\n+      heap->set_forced_counters_update(false);\n@@ -584,14 +565,0 @@\n-void ShenandoahControlThread::handle_counters_update() {\n-  if (_do_counters_update.is_set()) {\n-    _do_counters_update.unset();\n-    ShenandoahHeap::heap()->monitoring_support()->update_counters();\n-  }\n-}\n-\n-void ShenandoahControlThread::handle_force_counters_update() {\n-  if (_force_counters_update.is_set()) {\n-    _do_counters_update.unset(); \/\/ reset these too, we do update now!\n-    ShenandoahHeap::heap()->monitoring_support()->update_counters();\n-  }\n-}\n-\n@@ -600,6 +567,0 @@\n-\n-  \/\/ Update monitoring counters when we took a new region. This amortizes the\n-  \/\/ update costs on slow path.\n-  if (_do_counters_update.is_unset()) {\n-    _do_counters_update.set();\n-  }\n@@ -617,4 +578,0 @@\n-void ShenandoahControlThread::set_forced_counters_update(bool value) {\n-  _force_counters_update.set_cond(value);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":5,"deletions":48,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"runtime\/task.hpp\"\n@@ -37,19 +36,0 @@\n-\/\/ Periodic task is useful for doing asynchronous things that do not require (heap) locks,\n-\/\/ or synchronization with other parts of collector. These could run even when ShenandoahConcurrentThread\n-\/\/ is busy driving the GC cycle.\n-class ShenandoahPeriodicTask : public PeriodicTask {\n-private:\n-  ShenandoahControlThread* _thread;\n-public:\n-  ShenandoahPeriodicTask(ShenandoahControlThread* thread) :\n-          PeriodicTask(100), _thread(thread) {}\n-  virtual void task();\n-};\n-\n-\/\/ Periodic task to notify blocked paced waiters.\n-class ShenandoahPeriodicPacerNotify : public PeriodicTask {\n-public:\n-  ShenandoahPeriodicPacerNotify() : PeriodicTask(PeriodicTask::min_interval) {}\n-  virtual void task();\n-};\n-\n@@ -72,2 +52,0 @@\n-  ShenandoahPeriodicTask _periodic_task;\n-  ShenandoahPeriodicPacerNotify _periodic_pacer_notify_task;\n@@ -84,2 +62,0 @@\n-  ShenandoahSharedFlag _do_counters_update;\n-  ShenandoahSharedFlag _force_counters_update;\n@@ -122,1 +98,0 @@\n-  ~ShenandoahControlThread();\n@@ -135,4 +110,0 @@\n-  void handle_counters_update();\n-  void handle_force_counters_update();\n-  void set_forced_counters_update(bool value);\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.hpp","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -435,2 +435,0 @@\n-  } else {\n-    _pacer = nullptr;\n@@ -785,1 +783,1 @@\n-    control_thread()->notify_heap_changed();\n+    notify_heap_changed();\n@@ -789,0 +787,16 @@\n+void ShenandoahHeap::notify_heap_changed() {\n+  \/\/ Update monitoring counters when we took a new region. This amortizes the\n+  \/\/ update costs on slow path.\n+  monitoring_support()->notify_heap_changed();\n+\n+  control_thread()->notify_heap_changed();\n+}\n+\n+void ShenandoahHeap::set_forced_counters_update(bool value) {\n+  monitoring_support()->set_forced_counters_update(value);\n+}\n+\n+void ShenandoahHeap::handle_force_counters_update() {\n+  monitoring_support()->handle_force_counters_update();\n+}\n+\n@@ -918,1 +932,1 @@\n-    control_thread()->notify_heap_changed();\n+    notify_heap_changed();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -210,0 +210,9 @@\n+\/\/ ---------- Periodic Tasks\n+\/\/\n+private:\n+  void notify_heap_changed();\n+\n+public:\n+  void set_forced_counters_update(bool value);\n+  void handle_force_counters_update();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  virtual void update_all() {\n+  void update_all() override {\n@@ -49,1 +49,1 @@\n-  ShenandoahGenerationCounters(ShenandoahHeap* heap) :\n+  explicit ShenandoahGenerationCounters(ShenandoahHeap* heap) :\n@@ -54,1 +54,1 @@\n-  virtual void update_all() {\n+  void update_all() override {\n@@ -61,1 +61,2 @@\n-        _full_counters(nullptr)\n+        _full_counters(nullptr),\n+        _counters_update(this)\n@@ -74,0 +75,2 @@\n+\n+  _counters_update.enroll();\n@@ -106,0 +109,41 @@\n+\n+void ShenandoahMonitoringSupport::notify_heap_changed() {\n+  _counters_update.notify_heap_changed();\n+}\n+\n+void ShenandoahMonitoringSupport::set_forced_counters_update(bool value) {\n+  _counters_update.set_forced_counters_update(value);\n+}\n+\n+void ShenandoahMonitoringSupport::handle_force_counters_update() {\n+  _counters_update.handle_force_counters_update();\n+}\n+\n+void ShenandoahPeriodicCountersUpdate::task() {\n+  handle_force_counters_update();\n+  handle_counters_update();\n+}\n+\n+void ShenandoahPeriodicCountersUpdate::handle_counters_update() {\n+  if (_do_counters_update.is_set()) {\n+    _do_counters_update.unset();\n+    _monitoring_support->update_counters();\n+  }\n+}\n+\n+void ShenandoahPeriodicCountersUpdate::handle_force_counters_update() {\n+  if (_force_counters_update.is_set()) {\n+    _do_counters_update.unset(); \/\/ reset these too, we do update now!\n+    _monitoring_support->update_counters();\n+  }\n+}\n+\n+void ShenandoahPeriodicCountersUpdate::notify_heap_changed() {\n+  if (_do_counters_update.is_unset()) {\n+    _do_counters_update.set();\n+  }\n+}\n+\n+void ShenandoahPeriodicCountersUpdate::set_forced_counters_update(bool value) {\n+  _force_counters_update.set_cond(value);\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMonitoringSupport.cpp","additions":48,"deletions":4,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shenandoah\/shenandoahSharedVariables.hpp\"\n@@ -29,0 +30,1 @@\n+#include \"runtime\/task.hpp\"\n@@ -35,0 +37,20 @@\n+class ShenandoahMonitoringSupport;\n+\n+class ShenandoahPeriodicCountersUpdate : public PeriodicTask {\n+private:\n+  ShenandoahSharedFlag _do_counters_update;\n+  ShenandoahSharedFlag _force_counters_update;\n+  ShenandoahMonitoringSupport* _monitoring_support;\n+\n+public:\n+  explicit ShenandoahPeriodicCountersUpdate(ShenandoahMonitoringSupport* monitoring_support) :\n+    PeriodicTask(100),\n+    _monitoring_support(monitoring_support) { }\n+\n+  void task() override;\n+\n+  void handle_counters_update();\n+  void handle_force_counters_update();\n+  void set_forced_counters_update(bool value);\n+  void notify_heap_changed();\n+};\n@@ -47,0 +69,1 @@\n+  ShenandoahPeriodicCountersUpdate _counters_update;\n@@ -49,6 +72,11 @@\n- ShenandoahMonitoringSupport(ShenandoahHeap* heap);\n- CollectorCounters* stw_collection_counters();\n- CollectorCounters* full_stw_collection_counters();\n- CollectorCounters* concurrent_collection_counters();\n- CollectorCounters* partial_collection_counters();\n- void update_counters();\n+  explicit ShenandoahMonitoringSupport(ShenandoahHeap* heap);\n+  CollectorCounters* stw_collection_counters();\n+  CollectorCounters* full_stw_collection_counters();\n+  CollectorCounters* concurrent_collection_counters();\n+  CollectorCounters* partial_collection_counters();\n+\n+  void notify_heap_changed();\n+  void set_forced_counters_update(bool value);\n+  void handle_force_counters_update();\n+\n+  void update_counters();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMonitoringSupport.hpp","additions":34,"deletions":6,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -341,0 +341,5 @@\n+\n+void ShenandoahPeriodicPacerNotify::task() {\n+  assert(ShenandoahPacing, \"Should not be here otherwise\");\n+  _pacer->notify_waiters();\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPacer.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/task.hpp\"\n@@ -34,0 +35,15 @@\n+class ShenandoahPacer;\n+\n+\n+\/\/ Periodic task to notify blocked paced waiters.\n+class ShenandoahPeriodicPacerNotify : public PeriodicTask {\n+public:\n+  explicit ShenandoahPeriodicPacerNotify(ShenandoahPacer* pacer) :\n+    PeriodicTask(PeriodicTask::min_interval),\n+    _pacer(pacer) { }\n+\n+  void task() override;\n+private:\n+  ShenandoahPacer* _pacer;\n+};\n+\n@@ -51,0 +67,1 @@\n+  ShenandoahPeriodicPacerNotify _notify_waiters;\n@@ -72,0 +89,1 @@\n+          _notify_waiters(this),\n@@ -75,1 +93,3 @@\n-          _progress(PACING_PROGRESS_UNINIT) {}\n+          _progress(PACING_PROGRESS_UNINIT) {\n+    _notify_waiters.enroll();\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPacer.hpp","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"}]}