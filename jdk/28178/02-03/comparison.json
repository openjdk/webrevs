{"files":[{"patch":"@@ -28,1 +28,1 @@\n- * @run testng java.net.http\/jdk.internal.net.http.RawChannelTest\n+ * @run testng\/othervm java.net.http\/jdk.internal.net.http.RawChannelTest\n@@ -30,0 +30,5 @@\n+\/\/ use\n+\/\/     @run testng\/othervm -Dseed=6434511950803022575\n+\/\/          java.net.http\/jdk.internal.net.http.RawChannelTest\n+\/\/ to reproduce a failure with a particular seed (e.g. 6434511950803022575)\n+\/\/ if this test is observed failing with that seed\n","filename":"test\/jdk\/java\/net\/httpclient\/whitebox\/RawChannelTestDriver.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -62,0 +62,14 @@\n+    \/\/ can't use jdk.test.lib when injected in java.net.httpclient\n+    \/\/ Seed can be specified on the @run line with -Dseed=<seed>\n+    private static class RandomFactory {\n+        private static long getSeed() {\n+            long seed = Long.getLong(\"seed\", new Random().nextLong());\n+            System.out.println(\"Seed from RandomFactory = \"+seed+\"L\");\n+            return seed;\n+        }\n+        public static Random getRandom() {\n+            return new Random(getSeed());\n+        }\n+    }\n+\n+    private static final Random RANDOM = RandomFactory.getRandom();\n@@ -115,0 +129,45 @@\n+            chan.registerEvent(new RawChannel.RawEvent() {\n+\n+                private final ByteBuffer reusableBuffer = ByteBuffer.allocate(32768);\n+\n+                @Override\n+                public int interestOps() {\n+                    return SelectionKey.OP_WRITE;\n+                }\n+\n+                @Override\n+                public void handle() {\n+                    int i = writeHandles.incrementAndGet();\n+                    print(\"OP_WRITE #%s\", i);\n+                    if (i > 3) { \/\/ Fill up the send buffer not more than 3 times\n+                        try {\n+                            chan.shutdownOutput();\n+                            outputCompleted.complete(null);\n+                        } catch (IOException e) {\n+                            outputCompleted.completeExceptionally(e);\n+                            e.printStackTrace();\n+                            closeChannel(chan);\n+                        }\n+                        return;\n+                    }\n+                    long total = 0;\n+                    try {\n+                        long n;\n+                        do {\n+                            ByteBuffer[] array = {reusableBuffer.slice()};\n+                            n = chan.write(array, 0, 1);\n+                            total += n;\n+                        } while (n > 0);\n+                        print(\"OP_WRITE clogged SNDBUF with %s bytes\", total);\n+                        clientWritten.addAndGet(total);\n+                        chan.registerEvent(this);\n+                        writeStall.countDown(); \/\/ signal send buffer is full\n+                    } catch (IOException e) {\n+                        print(\"OP_RIGHT failed: \" + e);\n+                        outputCompleted.completeExceptionally(e);\n+                        closeChannel(chan);\n+                        throw new UncheckedIOException(e);\n+                    }\n+                }\n+            });\n+\n@@ -161,45 +220,0 @@\n-            chan.registerEvent(new RawChannel.RawEvent() {\n-\n-                private final ByteBuffer reusableBuffer = ByteBuffer.allocate(32768);\n-\n-                @Override\n-                public int interestOps() {\n-                    return SelectionKey.OP_WRITE;\n-                }\n-\n-                @Override\n-                public void handle() {\n-                    int i = writeHandles.incrementAndGet();\n-                    print(\"OP_WRITE #%s\", i);\n-                    if (i > 3) { \/\/ Fill up the send buffer not more than 3 times\n-                        try {\n-                            chan.shutdownOutput();\n-                            outputCompleted.complete(null);\n-                        } catch (IOException e) {\n-                            outputCompleted.completeExceptionally(e);\n-                            e.printStackTrace();\n-                            closeChannel(chan);\n-                        }\n-                        return;\n-                    }\n-                    long total = 0;\n-                    try {\n-                        long n;\n-                        do {\n-                            ByteBuffer[] array = {reusableBuffer.slice()};\n-                            n = chan.write(array, 0, 1);\n-                            total += n;\n-                        } while (n > 0);\n-                        print(\"OP_WRITE clogged SNDBUF with %s bytes\", total);\n-                        clientWritten.addAndGet(total);\n-                        chan.registerEvent(this);\n-                        writeStall.countDown(); \/\/ signal send buffer is full\n-                    } catch (IOException e) {\n-                        print(\"OP_RIGHT failed: \" + e);\n-                        outputCompleted.completeExceptionally(e);\n-                        closeChannel(chan);\n-                        throw new UncheckedIOException(e);\n-                    }\n-                }\n-            });\n-\n@@ -406,1 +420,3 @@\n-        return new byte[new Random().nextInt(1 + bound)];\n+        \/\/ bound must be > 1; No need to check it,\n+        \/\/ nextInt will throw IllegalArgumentException if needed\n+        return new byte[RANDOM.nextInt(1, bound + 1)];\n","filename":"test\/jdk\/java\/net\/httpclient\/whitebox\/java.net.http\/jdk\/internal\/net\/http\/RawChannelTest.java","additions":62,"deletions":46,"binary":false,"changes":108,"status":"modified"}]}