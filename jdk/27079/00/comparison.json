{"files":[{"patch":"@@ -113,0 +113,1 @@\n+    public static final int ERROR_CANT_RESOLVE_FILENAME = 1921;\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsConstants.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -466,0 +466,13 @@\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == this)\n+            return true;\n+        return obj instanceof WindowsFileAttributes other\n+            && isSameFile(this, other);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return volSerialNumber + fileIndexHigh + fileIndexLow;\n+    }\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileAttributes.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.concurrent.atomic.AtomicLong;\n@@ -421,0 +422,80 @@\n+    \/\/ contains file attributes and its handle\n+    \/\/ the attributes' key is valid as long as the handle remains open\n+    private record AttrsAndHandle(WindowsFileAttributes attrs, long handle) {}\n+\n+    \/\/ find the attributes of the last accessible link in the chain\n+    private AttrsAndHandle lastFileAttrs(WindowsPath path)\n+        throws IOException, WindowsException\n+    {\n+        var fileAttrs = new HashSet<WindowsFileAttributes>();\n+        WindowsFileAttributes lastFileAttrs = null;\n+        long handle = 0L;\n+        while (path != null) {\n+            long h = 0L;\n+            try {\n+                h = path.openForReadAttributeAccess(false);\n+            } catch (WindowsException x) {\n+                if (x.lastError() != ERROR_FILE_NOT_FOUND &&\n+                    x.lastError() != ERROR_PATH_NOT_FOUND)\n+                    throw x;\n+                break;\n+            }\n+\n+            WindowsFileAttributes attrs = WindowsFileAttributes.readAttributes(h);\n+            if (attrs == null || !attrs.isSymbolicLink()) {\n+                CloseHandle(h);\n+                break;\n+            }\n+\n+            if (!fileAttrs.add(attrs)) {\n+                CloseHandle(h);\n+                if (handle != 0L)\n+                    CloseHandle(handle);\n+                throw new FileSystemLoopException(\"Looping symbolic link\");\n+            }\n+\n+            lastFileAttrs = attrs;\n+            if (handle != 0L)\n+                CloseHandle(handle);\n+            handle = h;\n+\n+            String target = WindowsLinkSupport.readLink(path);\n+            path = WindowsPath.parse(path.getFileSystem(), target);\n+        }\n+\n+        return lastFileAttrs == null\n+            ? null : new AttrsAndHandle(lastFileAttrs, handle);\n+    }\n+\n+    \/\/ find the key by following links\n+    private AttrsAndHandle fileAttrs(WindowsPath file)\n+        throws WindowsException\n+    {\n+        long h = 0L;\n+        try {\n+            h = file.openForReadAttributeAccess(true);\n+        } catch (WindowsException x) {\n+            if (x.lastError() != ERROR_FILE_NOT_FOUND &&\n+                x.lastError() != ERROR_PATH_NOT_FOUND &&\n+                x.lastError() != ERROR_CANT_RESOLVE_FILENAME)\n+                throw x;\n+        }\n+\n+        if (h != 0L) {\n+            WindowsFileAttributes attrs = null;\n+            try {\n+                attrs = WindowsFileAttributes.readAttributes(h);\n+            } catch (WindowsException x) {\n+                CloseHandle(h);\n+                throw x;\n+            }\n+\n+            if (attrs != null)\n+                return new AttrsAndHandle(attrs, h);\n+\n+            CloseHandle(h);\n+        }\n+\n+        return null;\n+    }\n+\n@@ -423,0 +504,1 @@\n+        \/\/ toWindowsPath verifies its argument is a non-null WindowsPath\n@@ -432,14 +514,1 @@\n-        \/\/ open both files and see if they are the same\n-        long h1 = 0L;\n-        try {\n-            h1 = file1.openForReadAttributeAccess(true);\n-        } catch (WindowsException x) {\n-            if (x.lastError() != ERROR_FILE_NOT_FOUND &&\n-                x.lastError() != ERROR_PATH_NOT_FOUND)\n-                x.rethrowAsIOException(file1);\n-        }\n-\n-        \/\/ if file1 does not exist, it cannot equal file2\n-        if (h1 == 0L)\n-            return false;\n-\n+        AttrsAndHandle ah1 = null;\n@@ -447,21 +516,6 @@\n-            WindowsFileAttributes attrs1 = null;\n-            try {\n-                attrs1 = WindowsFileAttributes.readAttributes(h1);\n-            } catch (WindowsException x) {\n-                x.rethrowAsIOException(file1);\n-            }\n-            long h2 = 0L;\n-            try {\n-                h2 = file2.openForReadAttributeAccess(true);\n-            } catch (WindowsException x) {\n-                if (x.lastError() != ERROR_FILE_NOT_FOUND &&\n-                    x.lastError() != ERROR_PATH_NOT_FOUND)\n-                    x.rethrowAsIOException(file2);\n-            }\n-\n-            \/\/ if file2 does not exist, it cannot equal file1, which does\n-            if (h2 == 0L)\n-                return false;\n-\n-            try {\n-                WindowsFileAttributes attrs2 = null;\n+            ah1 = fileAttrs(file1);\n+            if (ah1 == null)\n+                ah1 = lastFileAttrs(file1);\n+            if (ah1 != null) {\n+                WindowsFileAttributes attrs = ah1.attrs();\n+                AttrsAndHandle ah2 = null;\n@@ -469,3 +523,10 @@\n-                    attrs2 = WindowsFileAttributes.readAttributes(h2);\n-                } catch (WindowsException x) {\n-                    x.rethrowAsIOException(file2);\n+                     ah2 = fileAttrs(file2);\n+                     if (ah2 == null)\n+                         ah2 = lastFileAttrs(file2);\n+                     if (ah2 != null)\n+                         return ah1.attrs().equals(ah2.attrs());\n+                } catch (WindowsException y) {\n+                    y.rethrowAsIOException(file2);\n+                } finally {\n+                    if (ah2 != null)\n+                        CloseHandle(ah2.handle());\n@@ -473,3 +534,0 @@\n-                return WindowsFileAttributes.isSameFile(attrs1, attrs2);\n-            } finally {\n-                CloseHandle(h2);\n@@ -477,0 +535,2 @@\n+        } catch (WindowsException x) {\n+            x.rethrowAsIOException(file1);\n@@ -478,1 +538,2 @@\n-            CloseHandle(h1);\n+            if (ah1 != null)\n+                CloseHandle(ah1.handle());\n@@ -480,0 +541,2 @@\n+\n+        return false;\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileSystemProvider.java","additions":105,"deletions":42,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 8154364 8366254\n+ * @bug 8154364 8365626 8366254\n@@ -27,1 +27,0 @@\n- * @requires (os.family != \"windows\")\n@@ -53,0 +52,1 @@\n+import org.junit.jupiter.api.condition.EnabledIf;\n@@ -69,0 +69,2 @@\n+    private boolean supportsSymbolicLinks;\n+\n@@ -78,0 +80,6 @@\n+\n+        supportsSymbolicLinks = TestUtil.supportsSymbolicLinks(home);\n+    }\n+\n+    private boolean supportsSymbolicLinks() {\n+        return supportsSymbolicLinks;\n@@ -206,1 +214,0 @@\n-        Files.createSymbolicLink(c, a);\n@@ -208,1 +215,4 @@\n-        list.add(Arguments.of(true, a, c));\n+        if (supportsSymbolicLinks) {\n+            Files.createSymbolicLink(c, a);\n+            list.add(Arguments.of(true, a, c));\n+        }\n@@ -223,1 +233,0 @@\n-        Files.createSymbolicLink(c, a);\n@@ -229,1 +238,4 @@\n-        list.add(Arguments.of(false, a, c));\n+        if (supportsSymbolicLinks) {\n+            list.add(Arguments.of(false, a, c));\n+            Files.createSymbolicLink(c, a);\n+        }\n@@ -271,0 +283,1 @@\n+    @EnabledIf(\"supportsSymbolicLinks\")\n@@ -313,0 +326,1 @@\n+    @EnabledIf(\"supportsSymbolicLinks\")\n@@ -350,0 +364,1 @@\n+    @EnabledIf(\"supportsSymbolicLinks\")\n@@ -385,0 +400,1 @@\n+    @EnabledIf(\"supportsSymbolicLinks\")\n@@ -422,0 +438,1 @@\n+    @EnabledIf(\"supportsSymbolicLinks\")\n@@ -452,0 +469,1 @@\n+    @EnabledIf(\"supportsSymbolicLinks\")\n","filename":"test\/jdk\/java\/nio\/file\/Files\/IsSameFile.java","additions":24,"deletions":6,"binary":false,"changes":30,"status":"modified"}]}