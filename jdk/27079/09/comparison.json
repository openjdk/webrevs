{"files":[{"patch":"@@ -113,0 +113,1 @@\n+    public static final int ERROR_CANT_RESOLVE_FILENAME = 1921;\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsConstants.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -421,8 +421,19 @@\n-    @Override\n-    public boolean isSameFile(Path obj1, Path obj2) throws IOException {\n-        WindowsPath file1 = WindowsPath.toWindowsPath(obj1);\n-        if (file1.equals(obj2))\n-            return true;\n-        if (obj2 == null)\n-            throw new NullPointerException();\n-        if (!(obj2 instanceof WindowsPath))\n+    \/**\n+     * Contains the attributes of a given file system entry and the open\n+     * handle from which they were obtained. The handle must remain open\n+     * until the volume serial number and file index of the attributes\n+     * are no longer needed for comparison with other attributes.\n+     *\n+     * @param attrs  the file system entry attributes\n+     * @param handle the open Windows file handle\n+     *\/\n+    private record EntryAttributes(WindowsFileAttributes attrs, long handle) {\n+        public boolean equals(Object obj) {\n+            if (obj == this)\n+                return true;\n+            if (obj instanceof EntryAttributes other) {\n+                WindowsFileAttributes oattrs = other.attrs();\n+                return oattrs.volSerialNumber() == attrs.volSerialNumber() &&\n+                       oattrs.fileIndexHigh()   == attrs.fileIndexHigh() &&\n+                       oattrs.fileIndexLow()    == attrs.fileIndexLow();\n+            }\n@@ -430,1 +441,7 @@\n-        WindowsPath file2 = (WindowsPath)obj2;\n+        }\n+\n+        public int hashCode() {\n+            return attrs.volSerialNumber() +\n+                   attrs.fileIndexHigh() + attrs.fileIndexLow();\n+        }\n+    }\n@@ -432,2 +449,12 @@\n-        \/\/ open both files and see if they are the same\n-        long h1 = 0L;\n+    \/**\n+     * Returns the attributes of the file located by the given path if it is a\n+     * symbolic link. The handle contained in the returned value must be closed\n+     * once the attributes are no longer needed.\n+     *\n+     * @param path the file system path to examine\n+     * @return the attributes and handle or null if no link is found\n+     *\/\n+    private EntryAttributes linkAttributes(WindowsPath path)\n+        throws WindowsException\n+    {\n+        long h = INVALID_HANDLE_VALUE;\n@@ -435,1 +462,1 @@\n-            h1 = file1.openForReadAttributeAccess(true);\n+            h = path.openForReadAttributeAccess(false);\n@@ -439,1 +466,2 @@\n-                x.rethrowAsIOException(file1);\n+                throw x;\n+            return null;\n@@ -442,4 +470,1 @@\n-        \/\/ if file1 does not exist, it cannot equal file2\n-        if (h1 == 0L)\n-            return false;\n-\n+        WindowsFileAttributes attrs = null;\n@@ -447,13 +472,5 @@\n-            WindowsFileAttributes attrs1 = null;\n-            try {\n-                attrs1 = WindowsFileAttributes.readAttributes(h1);\n-            } catch (WindowsException x) {\n-                x.rethrowAsIOException(file1);\n-            }\n-            long h2 = 0L;\n-            try {\n-                h2 = file2.openForReadAttributeAccess(true);\n-            } catch (WindowsException x) {\n-                if (x.lastError() != ERROR_FILE_NOT_FOUND &&\n-                    x.lastError() != ERROR_PATH_NOT_FOUND)\n-                    x.rethrowAsIOException(file2);\n+            attrs = WindowsFileAttributes.readAttributes(h);\n+        } finally {\n+            if (attrs == null || !attrs.isSymbolicLink()) {\n+                CloseHandle(h);\n+                return null;\n@@ -461,0 +478,1 @@\n+        }\n@@ -462,3 +480,2 @@\n-            \/\/ if file2 does not exist, it cannot equal file1, which does\n-            if (h2 == 0L)\n-                return false;\n+        return new EntryAttributes(attrs, h);\n+    }\n@@ -466,6 +483,26 @@\n-            try {\n-                WindowsFileAttributes attrs2 = null;\n-                try {\n-                    attrs2 = WindowsFileAttributes.readAttributes(h2);\n-                } catch (WindowsException x) {\n-                    x.rethrowAsIOException(file2);\n+    \/**\n+     * Returns the attributes of the last symbolic link encountered in the\n+     * specified path. Links are not resolved in the path taken as a whole,\n+     * but rather the first link is followed, then its target, and so on,\n+     * until no more links are encountered.  The handle contained in the\n+     * returned value must be closed once the attributes are no longer needed.\n+     *\n+     * @param path the file system path to examine\n+     * @return the attributes and handle or null if no links are found\n+     * @throws FileSystemLoopException if a symbolic link cycle is encountered\n+     *\/\n+    private EntryAttributes lastLinkAttributes(WindowsPath path)\n+        throws IOException, WindowsException\n+    {\n+        var linkAttrs = new LinkedHashSet<EntryAttributes>();\n+        try {\n+            while (path != null) {\n+                EntryAttributes linkAttr = linkAttributes(path);\n+                if (linkAttr == null)\n+                    break;\n+\n+                if (!linkAttrs.add(linkAttr)) {\n+                    \/\/ the element was not added to the set so close its handle\n+                    \/\/ here as it would not be closed in the finally block\n+                    CloseHandle(linkAttr.handle());\n+                    throw new FileSystemLoopException(path.toString());\n@@ -473,3 +510,3 @@\n-                return WindowsFileAttributes.isSameFile(attrs1, attrs2);\n-            } finally {\n-                CloseHandle(h2);\n+\n+                String target = WindowsLinkSupport.readLink(path, linkAttr.handle());\n+                path = WindowsPath.parse(path.getFileSystem(), target);\n@@ -477,0 +514,3 @@\n+\n+            if (!linkAttrs.isEmpty())\n+                return linkAttrs.removeLast();\n@@ -478,1 +518,1 @@\n-            CloseHandle(h1);\n+            linkAttrs.stream().forEach(la -> CloseHandle(la.handle()));\n@@ -480,0 +520,73 @@\n+\n+        return null;\n+    }\n+\n+    \/**\n+     * Returns the attributes of the file located by the supplied parameter\n+     * with all symbolic links in its path resolved. If the file located by\n+     * the resolved path does not exist, then null is returned. The handle\n+     * contained in the returned value must be closed once the attributes\n+     * are no longer needed.\n+     *\n+     * @param path the file system path to examine\n+     * @return the attributes and handle or null if the real path does not exist\n+     *\/\n+    private EntryAttributes realPathAttributes(WindowsPath path)\n+        throws WindowsException\n+    {\n+        long h;\n+        try {\n+            h = path.openForReadAttributeAccess(true);\n+        } catch (WindowsException x) {\n+            if (x.lastError() == ERROR_FILE_NOT_FOUND ||\n+                x.lastError() == ERROR_PATH_NOT_FOUND ||\n+                x.lastError() == ERROR_CANT_RESOLVE_FILENAME)\n+                return null;\n+\n+            throw x;\n+        }\n+\n+        WindowsFileAttributes attrs = null;\n+        try {\n+            attrs = WindowsFileAttributes.readAttributes(h);\n+        } catch (WindowsException x) {\n+            CloseHandle(h);\n+            throw x;\n+        }\n+\n+        return new EntryAttributes(attrs, h);\n+    }\n+\n+    @Override\n+    public boolean isSameFile(Path obj1, Path obj2) throws IOException {\n+        \/\/ toWindowsPath verifies its argument is a non-null WindowsPath\n+        WindowsPath file1 = WindowsPath.toWindowsPath(obj1);\n+        if (file1.equals(obj2))\n+            return true;\n+        if (obj2 == null)\n+            throw new NullPointerException();\n+        if (!(obj2 instanceof WindowsPath file2))\n+            return false;\n+\n+        EntryAttributes attrs1 = null;\n+        EntryAttributes attrs2 = null;\n+        WindowsPath pathForException = file1;\n+        try {\n+            if ((attrs1 = realPathAttributes(file1)) != null ||\n+                (attrs1 = lastLinkAttributes(file1)) != null) {\n+                pathForException = file2;\n+                if ((attrs2 = realPathAttributes(file2)) != null ||\n+                    (attrs2 = lastLinkAttributes(file2)) != null)\n+                    return attrs1.equals(attrs2);\n+            }\n+        } catch (WindowsException x) {\n+            x.rethrowAsIOException(pathForException);\n+        } finally {\n+            if (attrs1 != null) {\n+                CloseHandle(attrs1.handle());\n+                if (attrs2 != null)\n+                    CloseHandle(attrs2.handle());\n+            }\n+        }\n+\n+        return false;\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileSystemProvider.java","additions":156,"deletions":43,"binary":false,"changes":199,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-            return readLinkImpl(path, handle);\n+            return readLink(path, handle);\n@@ -292,3 +292,1 @@\n-    private static String readLinkImpl(WindowsPath path, long handle)\n-        throws IOException\n-    {\n+    static String readLink(WindowsPath path, long handle) throws IOException {\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsLinkSupport.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 8154364 8366254\n+ * @bug 8154364 8365626 8366254\n@@ -27,1 +27,0 @@\n- * @requires (os.family != \"windows\")\n@@ -53,0 +52,1 @@\n+import org.junit.jupiter.api.condition.EnabledIf;\n@@ -69,0 +69,2 @@\n+    private boolean supportsSymbolicLinks;\n+\n@@ -78,0 +80,6 @@\n+\n+        supportsSymbolicLinks = TestUtil.supportsSymbolicLinks(home);\n+    }\n+\n+    private boolean supportsSymbolicLinks() {\n+        return supportsSymbolicLinks;\n@@ -206,1 +214,0 @@\n-        Files.createSymbolicLink(c, a);\n@@ -208,1 +215,4 @@\n-        list.add(Arguments.of(true, a, c));\n+        if (supportsSymbolicLinks) {\n+            Files.createSymbolicLink(c, a);\n+            list.add(Arguments.of(true, a, c));\n+        }\n@@ -223,1 +233,0 @@\n-        Files.createSymbolicLink(c, a);\n@@ -229,1 +238,4 @@\n-        list.add(Arguments.of(false, a, c));\n+        if (supportsSymbolicLinks) {\n+            list.add(Arguments.of(false, a, c));\n+            Files.createSymbolicLink(c, a);\n+        }\n@@ -271,0 +283,1 @@\n+    @EnabledIf(\"supportsSymbolicLinks\")\n@@ -313,0 +326,1 @@\n+    @EnabledIf(\"supportsSymbolicLinks\")\n@@ -350,0 +364,1 @@\n+    @EnabledIf(\"supportsSymbolicLinks\")\n@@ -385,0 +400,1 @@\n+    @EnabledIf(\"supportsSymbolicLinks\")\n@@ -422,0 +438,1 @@\n+    @EnabledIf(\"supportsSymbolicLinks\")\n@@ -452,0 +469,1 @@\n+    @EnabledIf(\"supportsSymbolicLinks\")\n","filename":"test\/jdk\/java\/nio\/file\/Files\/IsSameFile.java","additions":24,"deletions":6,"binary":false,"changes":30,"status":"modified"}]}