{"files":[{"patch":"@@ -113,0 +113,1 @@\n+    public static final int ERROR_CANT_RESOLVE_FILENAME = 1921;\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsConstants.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -421,8 +421,19 @@\n-    @Override\n-    public boolean isSameFile(Path obj1, Path obj2) throws IOException {\n-        WindowsPath file1 = WindowsPath.toWindowsPath(obj1);\n-        if (file1.equals(obj2))\n-            return true;\n-        if (obj2 == null)\n-            throw new NullPointerException();\n-        if (!(obj2 instanceof WindowsPath))\n+    \/**\n+     * Contains the attributes of a given file system entry and the open\n+     * handle from which they were obtained. The handle must remain open\n+     * until the volume serial number and file index of the attributes\n+     * are no longer needed for comparison with other attributes.\n+     *\n+     * @param attrs  the file system entry attributes\n+     * @param handle the open Windows file handle\n+     *\/\n+    private record EntryAttributes(WindowsFileAttributes attrs, long handle) {\n+        public boolean equals(Object obj) {\n+            if (obj == this)\n+                return true;\n+            if (obj instanceof EntryAttributes other) {\n+                WindowsFileAttributes oattrs = other.attrs();\n+                return oattrs.volSerialNumber() == attrs.volSerialNumber() &&\n+                       oattrs.fileIndexHigh()   == attrs.fileIndexHigh() &&\n+                       oattrs.fileIndexLow()    == attrs.fileIndexLow();\n+            }\n@@ -430,1 +441,1 @@\n-        WindowsPath file2 = (WindowsPath)obj2;\n+        }\n@@ -432,2 +443,22 @@\n-        \/\/ open both files and see if they are the same\n-        long h1 = 0L;\n+        public int hashCode() {\n+            return attrs.volSerialNumber() +\n+                   attrs.fileIndexHigh() + attrs.fileIndexLow();\n+        }\n+    }\n+\n+    \/**\n+     * Returns the attributes of the last symbolic link encountered in the\n+     * specified path. Links are not resolved in the path taken as a whole,\n+     * but rather then first link is followed, then its target, and so on,\n+     * until no more links are encountered.  The handle contained in the\n+     * returned value must be closed once the attributes are no longer needed.\n+     *\n+     * @param path the file system path to examine\n+     * @return the attributes and handle or null if no links are found\n+     * @throws FileSystemLoopException if a symbolic link cycle is encountered\n+     *\/\n+    private EntryAttributes lastLinkAttributes(WindowsPath path)\n+        throws IOException, WindowsException\n+    {\n+        var linkAttrs = new HashSet<EntryAttributes>();\n+        EntryAttributes lastLinkAttributes = null;\n@@ -435,5 +466,33 @@\n-            h1 = file1.openForReadAttributeAccess(true);\n-        } catch (WindowsException x) {\n-            if (x.lastError() != ERROR_FILE_NOT_FOUND &&\n-                x.lastError() != ERROR_PATH_NOT_FOUND)\n-                x.rethrowAsIOException(file1);\n+            while (path != null) {\n+                long h;\n+                try {\n+                    h = path.openForReadAttributeAccess(false);\n+                } catch (WindowsException x) {\n+                    if (x.lastError() != ERROR_FILE_NOT_FOUND &&\n+                        x.lastError() != ERROR_PATH_NOT_FOUND)\n+                        throw x;\n+                    break;\n+                }\n+\n+                WindowsFileAttributes attrs = WindowsFileAttributes.readAttributes(h);\n+                if (!attrs.isSymbolicLink())\n+                    break;\n+\n+                EntryAttributes linkAttr = new EntryAttributes(attrs, h);\n+                if (!linkAttrs.add(linkAttr))\n+                    throw new FileSystemLoopException(path.toString());\n+\n+                lastLinkAttributes = linkAttr;\n+\n+                String target = WindowsLinkSupport.readLink(path, h);\n+                path = WindowsPath.parse(path.getFileSystem(), target);\n+            }\n+        } catch (IOException|WindowsException e) {\n+            if (lastLinkAttributes != null) {\n+                CloseHandle(lastLinkAttributes.handle());\n+                throw e;\n+            }\n+        } finally {\n+            linkAttrs.remove(lastLinkAttributes);\n+            for (EntryAttributes la : linkAttrs)\n+                CloseHandle(la.handle());\n@@ -442,3 +501,2 @@\n-        \/\/ if file1 does not exist, it cannot equal file2\n-        if (h1 == 0L)\n-            return false;\n+        return lastLinkAttributes;\n+    }\n@@ -446,0 +504,14 @@\n+    \/**\n+     * Returns the attributes of the file located by the supplied parameter\n+     * with all symbolic links in its path resolved. If the file located by\n+     * the resolved path does not exist, then null is returned. The handle\n+     * contained in the returned value must be closed once the attributes\n+     * are no longer needed.\n+     *\n+     * @param path the file system path to examine\n+     * @return the attributes and handle or null if the real path does not exist\n+     *\/\n+    private EntryAttributes realPathAttributes(WindowsPath path)\n+        throws WindowsException\n+    {\n+        long h = INVALID_HANDLE_VALUE;\n@@ -447,7 +519,10 @@\n-            WindowsFileAttributes attrs1 = null;\n-            try {\n-                attrs1 = WindowsFileAttributes.readAttributes(h1);\n-            } catch (WindowsException x) {\n-                x.rethrowAsIOException(file1);\n-            }\n-            long h2 = 0L;\n+            h = path.openForReadAttributeAccess(true);\n+        } catch (WindowsException x) {\n+            if (x.lastError() != ERROR_FILE_NOT_FOUND &&\n+                x.lastError() != ERROR_PATH_NOT_FOUND &&\n+                x.lastError() != ERROR_CANT_RESOLVE_FILENAME)\n+                throw x;\n+        }\n+\n+        if (h != INVALID_HANDLE_VALUE) {\n+            WindowsFileAttributes attrs = null;\n@@ -455,1 +530,1 @@\n-                h2 = file2.openForReadAttributeAccess(true);\n+                attrs = WindowsFileAttributes.readAttributes(h);\n@@ -457,3 +532,2 @@\n-                if (x.lastError() != ERROR_FILE_NOT_FOUND &&\n-                    x.lastError() != ERROR_PATH_NOT_FOUND)\n-                    x.rethrowAsIOException(file2);\n+                CloseHandle(h);\n+                throw x;\n@@ -462,3 +536,2 @@\n-            \/\/ if file2 does not exist, it cannot equal file1, which does\n-            if (h2 == 0L)\n-                return false;\n+            return new EntryAttributes(attrs, h);\n+        }\n@@ -466,2 +539,22 @@\n-            try {\n-                WindowsFileAttributes attrs2 = null;\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean isSameFile(Path obj1, Path obj2) throws IOException {\n+        \/\/ toWindowsPath verifies its argument is a non-null WindowsPath\n+        WindowsPath file1 = WindowsPath.toWindowsPath(obj1);\n+        if (file1.equals(obj2))\n+            return true;\n+        if (obj2 == null)\n+            throw new NullPointerException();\n+        if (!(obj2 instanceof WindowsPath file2))\n+            return false;\n+\n+        EntryAttributes attrs1 = null;\n+        try {\n+            attrs1 = realPathAttributes(file1);\n+            if (attrs1 == null)\n+                attrs1 = lastLinkAttributes(file1);\n+            if (attrs1 != null) {\n+                WindowsFileAttributes attrs = attrs1.attrs();\n+                EntryAttributes attrs2 = null;\n@@ -469,3 +562,10 @@\n-                    attrs2 = WindowsFileAttributes.readAttributes(h2);\n-                } catch (WindowsException x) {\n-                    x.rethrowAsIOException(file2);\n+                     attrs2 = realPathAttributes(file2);\n+                     if (attrs2 == null)\n+                         attrs2 = lastLinkAttributes(file2);\n+                     if (attrs2 != null)\n+                         return attrs1.equals(attrs2);\n+                } catch (WindowsException y) {\n+                    y.rethrowAsIOException(file2);\n+                } finally {\n+                    if (attrs2 != null)\n+                        CloseHandle(attrs2.handle());\n@@ -473,3 +573,0 @@\n-                return WindowsFileAttributes.isSameFile(attrs1, attrs2);\n-            } finally {\n-                CloseHandle(h2);\n@@ -477,0 +574,2 @@\n+        } catch (WindowsException x) {\n+            x.rethrowAsIOException(file1);\n@@ -478,1 +577,2 @@\n-            CloseHandle(h1);\n+            if (attrs1 != null)\n+                CloseHandle(attrs1.handle());\n@@ -480,0 +580,2 @@\n+\n+        return false;\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileSystemProvider.java","additions":144,"deletions":42,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-            return readLinkImpl(path, handle);\n+            return readLink(path, handle);\n@@ -292,3 +292,1 @@\n-    private static String readLinkImpl(WindowsPath path, long handle)\n-        throws IOException\n-    {\n+    static String readLink(WindowsPath path, long handle) throws IOException {\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsLinkSupport.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 8154364 8366254\n+ * @bug 8154364 8365626 8366254\n@@ -27,1 +27,0 @@\n- * @requires (os.family != \"windows\")\n@@ -53,0 +52,1 @@\n+import org.junit.jupiter.api.condition.EnabledIf;\n@@ -69,0 +69,2 @@\n+    private boolean supportsSymbolicLinks;\n+\n@@ -78,0 +80,6 @@\n+\n+        supportsSymbolicLinks = TestUtil.supportsSymbolicLinks(home);\n+    }\n+\n+    private boolean supportsSymbolicLinks() {\n+        return supportsSymbolicLinks;\n@@ -206,1 +214,0 @@\n-        Files.createSymbolicLink(c, a);\n@@ -208,1 +215,4 @@\n-        list.add(Arguments.of(true, a, c));\n+        if (supportsSymbolicLinks) {\n+            Files.createSymbolicLink(c, a);\n+            list.add(Arguments.of(true, a, c));\n+        }\n@@ -223,1 +233,0 @@\n-        Files.createSymbolicLink(c, a);\n@@ -229,1 +238,4 @@\n-        list.add(Arguments.of(false, a, c));\n+        if (supportsSymbolicLinks) {\n+            list.add(Arguments.of(false, a, c));\n+            Files.createSymbolicLink(c, a);\n+        }\n@@ -271,0 +283,1 @@\n+    @EnabledIf(\"supportsSymbolicLinks\")\n@@ -313,0 +326,1 @@\n+    @EnabledIf(\"supportsSymbolicLinks\")\n@@ -350,0 +364,1 @@\n+    @EnabledIf(\"supportsSymbolicLinks\")\n@@ -385,0 +400,1 @@\n+    @EnabledIf(\"supportsSymbolicLinks\")\n@@ -422,0 +438,1 @@\n+    @EnabledIf(\"supportsSymbolicLinks\")\n@@ -452,0 +469,1 @@\n+    @EnabledIf(\"supportsSymbolicLinks\")\n","filename":"test\/jdk\/java\/nio\/file\/Files\/IsSameFile.java","additions":24,"deletions":6,"binary":false,"changes":30,"status":"modified"}]}