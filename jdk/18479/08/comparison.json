{"files":[{"patch":"@@ -59,0 +59,2 @@\n+#define ZIP64_EXTMAXLEN 32    \/\/ Maximum Zip64 extra field length\n+\n@@ -141,0 +143,6 @@\n+\/*\n+ * Macros for getting Extensible Data Fields\n+ *\/\n+#define ZIPEXT_HDR(b) SH(b, 0)      \/* Header ID *\/\n+#define ZIPEXT_SIZ(b) SH(b, 2)      \/* Data Size *\/\n+\n","filename":"src\/java.base\/share\/native\/libjli\/manifest_info.h","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -143,0 +143,82 @@\n+\/*\n+ * Reads size and offset fields from a zip64 extended information extra field.\n+ *\n+ * If one of the corresponding central directory fields is too small to hold the\n+ * required data, the information will be in the zip64 extended information\n+ * record.\n+ *\n+ * The disk number field is only used to validate the size of the zip64 extended\n+ * information record.\n+ *\n+ * See APPNOTE.TXT 4.5.3.\n+ *\/\n+static jboolean\n+read_zip64_ext(Byte *p, jlong *cenlen, jlong *censiz, jlong *cenoff,\n+               unsigned short cendsk) {\n+  short headerId = ZIPEXT_HDR(p);\n+  if (headerId != ZIP64_EXTID) {\n+    return JNI_FALSE;\n+  }\n+  short headerSize = ZIPEXT_SIZ(p);\n+  short expectedSize =\n+      (*cenlen == ZIP64_MAGICVAL ? 8 : 0) +\n+      (*censiz == ZIP64_MAGICVAL ? 8 : 0) +\n+      (*cenoff == ZIP64_MAGICVAL ? 8 : 0) +\n+      (cendsk == ZIP64_MAGICCOUNT ? 4 : 0);\n+  if (headerSize != expectedSize) {\n+    return JNI_FALSE;\n+  }\n+  jlong offset = 4;\n+  if (*cenlen == ZIP64_MAGICVAL) {\n+    *cenlen = LL(p, offset);\n+    offset += 8;\n+  }\n+  if (*censiz == ZIP64_MAGICVAL) {\n+    *censiz = LL(p, offset);\n+    offset += 8;\n+  }\n+  if (*cenoff == ZIP64_MAGICVAL) {\n+    *cenoff = LL(p, offset);\n+  }\n+  return JNI_TRUE;\n+}\n+\n+\/*\n+ * Validates the associated LOC headers for a CEN entry, with support for\n+ * reading the LOC offset using the zip64 extended information extra field.\n+ *\/\n+static jboolean\n+validate_lochdr(int fd, jlong censtart, jlong base_offset, Byte *cenhdr) {\n+  Byte lochdr[LOCHDR];\n+  jlong cenlen = CENLEN(cenhdr);\n+  jlong censiz = CENSIZ(cenhdr);\n+  jlong cenoff = CENOFF(cenhdr);\n+  jlong cenext = CENEXT(cenhdr);\n+  \/\/ cenoff is the only value stored in the zip64 extended info that is used\n+  \/\/ below, so if it fits in 32 bits we don't need to read the extra fields.\n+  if (cenoff == ZIP64_MAGICVAL && cenext > 0) {\n+    Byte p[ZIP64_EXTMAXLEN];\n+    \/\/ The extra fields start after the fixed-size central directory\n+    \/\/ header and the variable-length file name.\n+    jlong start = censtart + CENHDR + CENNAM(cenhdr);\n+    jlong offset = 0;\n+    \/\/ Scan the extra fields for zip64 extra info, see APPNOTE.TXT 4.5\n+    while (offset < cenext) {\n+      if (!readAt(fd, start + offset, ZIP64_EXTMAXLEN, p)) {\n+        return JNI_FALSE;\n+      }\n+      short headerId = ZIPEXT_HDR(p);\n+      short headerSize = ZIPEXT_SIZ(p);\n+      if (headerId == ZIP64_EXTID) {\n+        if (!read_zip64_ext(p, &cenlen, &censiz, &cenoff, CENDSK(cenhdr))) {\n+          return JNI_FALSE;\n+        }\n+        break;\n+      }\n+      offset += 4 + headerSize;\n+    }\n+  }\n+  return readAt(fd, base_offset + cenoff, LOCHDR, lochdr)\n+      && LOCSIG_AT(lochdr)\n+      && CENNAM(cenhdr) == LOCNAM(lochdr);\n+}\n@@ -153,1 +235,0 @@\n-    Byte lochdr[LOCHDR];\n@@ -164,3 +245,1 @@\n-          && readAt(fd, base_offset + CENOFF(cenhdr), LOCHDR, lochdr)\n-          && LOCSIG_AT(lochdr)\n-          && CENNAM(cenhdr) == LOCNAM(lochdr)));\n+          && validate_lochdr(fd, censtart, base_offset, cenhdr)));\n@@ -421,1 +500,27 @@\n-            if (JLI_Lseek(fd, base_offset + CENOFF(p), SEEK_SET) < (jlong)0) {\n+            jlong cenlen = CENLEN(p);\n+            jlong censiz = CENSIZ(p);\n+            jlong cenoff = CENOFF(p);\n+            jlong cenext = CENEXT(p);\n+            if ((cenlen == ZIP64_MAGICVAL\n+                  || censiz == ZIP64_MAGICVAL\n+                  || cenoff == ZIP64_MAGICVAL)\n+                && cenext > 0) {\n+              \/\/ The extra fields start after the fixed-size central directory\n+              \/\/ header and the variable-length file name.\n+              Byte *base = p + CENHDR + CENNAM(p);\n+              jlong offset = 0;\n+              \/\/ Scan the extra fields for zip64 extra info, see APPNOTE.TXT 4.5\n+              while (offset < cenext) {\n+                short headerId = ZIPEXT_HDR(base + offset);\n+                short headerSize = ZIPEXT_SIZ(base + offset);\n+                if (headerId == ZIP64_EXTID) {\n+                  if (!read_zip64_ext(base + offset, &cenlen, &censiz, &cenoff, CENDSK(p))) {\n+                    free(buffer);\n+                    return (-1);\n+                  }\n+                  break;\n+                }\n+                offset += 4 + headerSize;\n+              }\n+            }\n+            if (JLI_Lseek(fd, base_offset + cenoff, SEEK_SET) < (jlong)0) {\n@@ -433,3 +538,3 @@\n-            entry->isize = CENLEN(p);\n-            entry->csize = CENSIZ(p);\n-            entry->offset = base_offset + CENOFF(p) + LOCHDR +\n+            entry->isize = cenlen;\n+            entry->csize = censiz;\n+            entry->offset = base_offset + cenoff + LOCHDR +\n","filename":"src\/java.base\/share\/native\/libjli\/parse_manifest.c","additions":113,"deletions":8,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2024 Alphabet LLC. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @requires vm.bits == 64\n+ * @bug 8328995\n+ * @summary Test java.util.zip behavior with >4GB offsets\n+ * @library \/test\/lib\n+ * @run main\/othervm -Xmx6g Zip64Offsets\n+ *\/\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.zip.CRC32;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipOutputStream;\n+\n+public class Zip64Offsets {\n+    public static class Main {\n+        public static void main(String[] args) {\n+            System.out.print(\"Main\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        test();\n+    }\n+\n+    static void test() throws Throwable {\n+        Path zipPath = Path.of(\"Zip64Offsets-tmp.zip\");\n+        Files.deleteIfExists(zipPath);\n+\n+        try (OutputStream os = Files.newOutputStream(zipPath);\n+                BufferedOutputStream bos = new BufferedOutputStream(os);\n+                ZipOutputStream zos = new ZipOutputStream(bos)) {\n+\n+            \/\/ Write >4GB of zip data\n+            byte[] gb = new byte[1 << 30];\n+            for (int i = 0; i < 6; i++) {\n+                writeEntry(zos, Integer.toString(i), gb);\n+            }\n+\n+            for (Class<?> clazz : List.of(Zip64Offsets.class, Main.class)) {\n+                String baseName = clazz.getName() + \".class\";\n+                byte[] bytes = clazz.getResourceAsStream(baseName).readAllBytes();\n+                writeEntry(zos, baseName, bytes);\n+            }\n+\n+            \/\/ Put the manifest at the end, to ensure that \"java -jar\" supports >4GB offsets\n+            writeEntry(\n+                    zos,\n+                    \"META-INF\/MANIFEST.MF\",\n+                    (\"Manifest-Version: 1.0\\nMain-Class: \" + Main.class.getName() + \"\\n\")\n+                            .getBytes(UTF_8));\n+        }\n+\n+        checkCanRead(zipPath);\n+    }\n+\n+    private static void writeEntry(ZipOutputStream zos, String name, byte[] bytes)\n+            throws IOException {\n+        ZipEntry ze = new ZipEntry(name);\n+        ze.setMethod(ZipEntry.STORED);\n+        ze.setSize(bytes.length);\n+        CRC32 crc = new CRC32();\n+        crc.update(bytes);\n+        ze.setCrc(crc.getValue());\n+        zos.putNextEntry(ze);\n+        zos.write(bytes);\n+        zos.closeEntry();\n+    }\n+\n+    static void checkCanRead(Path zipPath) throws Exception {\n+        \/\/ Check java -jar\n+        OutputAnalyzer a = ProcessTools.executeTestJava(\"-jar\", zipPath.getFileName().toString());\n+        a.shouldHaveExitValue(0);\n+        a.stdoutShouldMatch(\"\\\\AMain\\\\Z\");\n+        a.stderrShouldMatch(\"\\\\A\\\\Z\");\n+    }\n+}\n","filename":"test\/jdk\/tools\/launcher\/Zip64Offsets.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"}]}