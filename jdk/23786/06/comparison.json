{"files":[{"patch":"@@ -170,1 +170,1 @@\n-  const NativeCallStack& stack)\n+  const NativeCallStack& stack, void* old_base)\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -284,1 +284,1 @@\n-    const NativeCallStack& stack);\n+    const NativeCallStack& stack, void* old_base = nullptr);\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,855 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ record pattern of allocations of memory calls:\n+\/\/\n+\/\/ NMTRecordMemoryAllocations=0x7FFFFFFF .\/build\/macosx-aarch64-server-release\/xcode\/build\/jdk\/bin\/java -XX:+UnlockDiagnosticVMOptions -XX:NativeMemoryTracking=summary -jar build\/macosx-aarch64-server-release\/images\/jdk\/demo\/jfc\/J2Ddemo\/J2Ddemo.jar\n+\/\/\n+\/\/ OR record pattern of allocations of virtual memory calls:\n+\/\/\n+\/\/ NMTRecordVirtualMemoryAllocations=0x7FFFFFFF .\/build\/macosx-aarch64-server-release\/xcode\/build\/jdk\/bin\/java -XX:+UnlockDiagnosticVMOptions -XX:NativeMemoryTracking=summary -jar build\/macosx-aarch64-server-release\/images\/jdk\/demo\/jfc\/J2Ddemo\/J2Ddemo.jar\n+\/\/\n+\/\/ this will produce 3 files:\n+\/\/\n+\/\/ #1 hs_nmt_pid22770_allocs_record.log (is the chronological record of the the desired operations)\n+\/\/ OR\n+\/\/ #1 hs_nmt_pid22770_virtual_allocs_record.log (is the chronological record of the desired operations)\n+\/\/ #2 hs_nmt_pid22770_info_record.log (is the record of default NMT memory overhead and the NMT state)\n+\/\/ #3 hs_nmt_pid22770_threads_record.log (is the record of thread names that can be retrieved later when processing)\n+\/\/\n+\/\/ then to actually run the benchmark:\n+\/\/\n+\/\/ NMTBenchmarkRecordedPID=22770 .\/build\/macosx-aarch64-server-release\/xcode\/build\/jdk\/bin\/java -XX:+UnlockDiagnosticVMOptions -XX:NativeMemoryTracking=summary\n+\n+#include \"jvm.h\"\n+#include \"nmt\/nmtCommon.hpp\"\n+#include \"nmt\/mallocHeader.hpp\"\n+#include \"nmt\/mallocHeader.inline.hpp\"\n+#include \"nmt\/memLogRecorder.hpp\"\n+#include \"nmt\/memReporter.hpp\"\n+#include \"nmt\/memTracker.hpp\"\n+#include \"nmt\/memTracker.hpp\"\n+#include \"nmt\/virtualMemoryTracker.hpp\"\n+#include \"runtime\/arguments.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/nativeCallStack.hpp\"\n+#include \"utilities\/vmError.hpp\"\n+\n+#if defined(LINUX) || defined(__APPLE__)\n+\n+#include <locale.h>\n+#include <string.h>\n+#include <errno.h>\n+\n+#if defined(LINUX)\n+#include <malloc.h>\n+#elif defined(__APPLE__)\n+#include <malloc\/malloc.h>\n+#endif\n+\n+#if defined(LINUX) || defined(__APPLE__)\n+#include <pthread.h>\n+#include <sys\/mman.h>\n+#include <unistd.h>\n+#endif\n+\n+#define LD_FORMAT \"%'ld\"\n+\n+static void* raw_realloc(void* old, size_t s)   { ALLOW_C_FUNCTION(::realloc, return ::realloc(old, s);) }\n+#if defined(LINUX)\n+  static size_t raw_malloc_size(void* ptr)   { ALLOW_C_FUNCTION(::malloc_usable_size, return ::malloc_usable_size(ptr);) }\n+#elif defined(_WIN64)\n+  static size_t raw_malloc_size(void* ptr)   { ALLOW_C_FUNCTION(::_msize, return ::_msize(ptr);) }\n+#elif defined(__APPLE__)\n+  static size_t raw_malloc_size(void* ptr)   { ALLOW_C_FUNCTION(::malloc_size, return ::malloc_size(ptr);) }\n+#endif\n+\n+#define NMT_HEADER_SIZE 16\n+\n+bool NMTRecorder_Locker::_safe_to_use = false;\n+NMT_MemoryLogRecorder NMT_MemoryLogRecorder::_recorder;\n+NMT_VirtualMemoryLogRecorder NMT_VirtualMemoryLogRecorder::_recorder;\n+\n+void NMT_LogRecorder::initialize() {\n+  char* NMTRecordMemoryAllocations = getenv(\"NMTRecordMemoryAllocations\");\n+  if (NMTRecordMemoryAllocations != nullptr) {\n+    long count = atol(NMTRecordMemoryAllocations);\n+    if (count == 0) {\n+      count = strtol(NMTRecordMemoryAllocations, nullptr, 16);\n+    }\n+    NMT_MemoryLogRecorder::initialize(count);\n+  }\n+  char* NMTRecordVirtualMemoryAllocations = getenv(\"NMTRecordVirtualMemoryAllocations\");\n+  if (NMTRecordVirtualMemoryAllocations != nullptr) {\n+    long count = atol(NMTRecordVirtualMemoryAllocations);\n+    if (count == 0) {\n+      count = strtol(NMTRecordVirtualMemoryAllocations, nullptr, 16);\n+    }\n+    NMT_VirtualMemoryLogRecorder::initialize(count);\n+  }\n+}\n+\n+void NMT_LogRecorder::finish() {\n+  if (!NMT_MemoryLogRecorder::instance()->done()) {\n+    NMT_MemoryLogRecorder::instance()->finish();\n+  }\n+  if (!NMT_VirtualMemoryLogRecorder::instance()->done()) {\n+    NMT_VirtualMemoryLogRecorder::instance()->finish();\n+  }\n+}\n+\n+void NMT_LogRecorder::replay() {\n+  char* NMTBenchmarkRecordedPID = getenv(\"NMTBenchmarkRecordedPID\");\n+  if (NMTBenchmarkRecordedPID != nullptr) {\n+    int pid = atoi(NMTBenchmarkRecordedPID);\n+    NMT_MemoryLogRecorder::instance()->replay(pid);\n+    NMT_VirtualMemoryLogRecorder::instance()->replay(pid);\n+    os::exit(0);\n+  }\n+}\n+\n+void NMT_LogRecorder::init() {\n+  _threads_names_size = 1;\n+  _threads_names = (thread_name_info*)raw_realloc(_threads_names, _threads_names_size*sizeof(thread_name_info));\n+  _done = true;\n+  _count = 0;\n+}\n+\n+void NMT_LogRecorder::get_thread_name(char* buf) {\n+#if defined(__APPLE__)\n+  if (pthread_main_np()) {\n+    strcpy(buf, \"main\");\n+  } else {\n+    pthread_getname_np(pthread_self(), buf, MAXTHREADNAMESIZE);\n+  }\n+#elif defined(LINUX)\n+  pthread_getname_np(pthread_self(), buf, MAXTHREADNAMESIZE);\n+#elif defined(_WIN64)\n+  \/\/ TODO: NMT_LogRecorder::thread_name\n+#endif\n+}\n+\n+\/\/ first time we see a new thread id, we add it\n+\/\/ second time we see a thread we get its name\n+void NMT_LogRecorder::logThreadName() {\n+  {\n+    bool found = false;\n+    long int tid = os::current_thread_id();\n+    for (size_t i = 0; i < _threads_names_size; i++) {\n+      if (_threads_names[i].thread == tid) {\n+        found = true;\n+        if (_threads_names[i].name[0] == 0) {\n+          NMT_LogRecorder::get_thread_name(_threads_names[i].name);\n+          \/\/ fprintf(stderr, \" got name for thread %6ld:%lx [%s]\\n\", tid, tid, _threads_names[i].name);\n+        }\n+        break;\n+      }\n+    }\n+    if (!found) {\n+      \/\/ fprintf(stderr, \" added:%6ld:%lx [%6zu]\\n\", tid, tid, _threads_names_size);\n+      size_t i = _threads_names_size-1;\n+      _threads_names[i].thread = tid;\n+      _threads_names[i].name[0] = 0;\n+      _threads_names_size++;\n+      _threads_names = (thread_name_info*)raw_realloc(_threads_names, _threads_names_size*sizeof(thread_name_info));\n+    }\n+  }\n+}\n+\n+#define IS_FREE(e)           ((e->requested == 0) && (e->old == nullptr))\n+#define IS_REALLOC(e)        ((e->requested  > 0) && (e->old != nullptr))\n+#define IS_MALLOC(e)         ((e->requested  > 0) && (e->old == nullptr))\n+\n+#define ALLOCS_LOG_FILE \"hs_nmt_pid%p_allocs_record.log\"\n+#define THREADS_LOG_FILE \"hs_nmt_pid%p_threads_record.log\"\n+#define INFO_LOG_FILE \"hs_nmt_pid%p_info_record.log\"\n+#define BENCHMARK_LOG_FILE \"hs_nmt_pid%p_benchmark.log\"\n+#define VALLOCS_LOG_FILE \"hs_nmt_pid%p_virtual_allocs_record.log\"\n+\n+static int _prepare_log_file(const char* pattern, const char* default_pattern) {\n+  int fd = -1;\n+  if (ErrorFileToStdout) {\n+    fd = STDOUT_FILENO;\n+  } else if (ErrorFileToStderr) {\n+    fd = STDERR_FILENO;\n+  } else {\n+    static char name_buffer[O_BUFLEN];\n+    fd = VMError::prepare_log_file(pattern, default_pattern, true, name_buffer, sizeof(name_buffer));\n+    if (fd == -1) {\n+      int e = errno;\n+      tty->print(\"Can't open memory [%s]. Error: \", pattern?pattern:\"null\");\n+      tty->print_raw_cr(os::strerror(e));\n+      tty->print_cr(\"NMT memory recorder report will be written to console.\");\n+      \/\/ See notes in VMError::report_and_die about hard coding tty to 1\n+      fd = 1;\n+    }\n+  }\n+  return fd;\n+}\n+\n+#define IS_VALID_FD(fd) (fd > STDERR_FILENO)\n+\n+static void _write_and_check(int fd, const void *buf, size_t count) {\n+  if (!IS_VALID_FD(fd)) {\n+    fprintf(stderr, \"write_and_check(%d) ERROR\\n\", fd);\n+    \/\/assert(false, \"fd: %d\", fd);\n+  }\n+  errno = 0;\n+  ssize_t written = (ssize_t)::write(fd, buf, count);\n+  if ((long)written != (long)count) {\n+    int e = errno;\n+    fprintf(stderr, \"write_and_check(%d) ERROR:[%s]\\n\", fd, os::strerror(e));\n+    \/\/assert((long)written != (long)count, \"written != count [%ld,%ld]\", (long)written, (long)count);\n+  }\n+}\n+\n+static int _close_and_check(int fd) {\n+  if (!IS_VALID_FD(fd)) {\n+    fprintf(stderr, \"close_and_check(%d) ERROR\\n\", fd);\n+    return fd;\n+  }\n+  if (fd > STDERR_FILENO) {\n+    errno = 0;\n+    int status = close(fd);\n+    if (status != 0) {\n+      int e = errno;\n+      fprintf(stderr, \"ERROR:[%s]\\n\", os::strerror(e));\n+      assert(status != 0, \"close(%d) returned %d\", fd, status);\n+      return fd;\n+    } else {\n+      return -1;\n+    }\n+  } else {\n+    return fd;\n+  }\n+}\n+\n+static bool _create_file_path_with_pid(const char *path, const char *file, char* file_path, int pid) {\n+  char *tmp_path = NEW_C_HEAP_ARRAY(char, JVM_MAXPATHLEN, mtNMT);\n+  strcpy(tmp_path, path);\n+  strcat(tmp_path, os::file_separator());\n+  strcat(tmp_path, file);\n+  if (!Arguments::copy_expand_pid(tmp_path, strlen(tmp_path), file_path, JVM_MAXPATHLEN, pid)) {\n+    FREE_C_HEAP_ARRAY(char, tmp_path);\n+    return false;\n+  } else {\n+    FREE_C_HEAP_ARRAY(char, tmp_path);\n+    return true;\n+  }\n+}\n+\n+typedef struct file_info {\n+  void*   ptr;\n+  size_t  size;\n+  int     fd;\n+} file_info;\n+\n+static file_info _open_file_and_read(const char* pattern, const char* path, int pid) {\n+  file_info info = { nullptr, 0, -1 };\n+\n+  char *file_path = NEW_C_HEAP_ARRAY(char, JVM_MAXPATHLEN, mtNMT);\n+  if (!_create_file_path_with_pid(path, pattern, file_path, pid)) {\n+    tty->print(\"Can't construct path [%s:%s:%d].\", pattern, path, pid);\n+    return info;\n+  }\n+\n+  info.fd = os::open(file_path, O_RDONLY, 0);\n+  if (info.fd == -1) {\n+    int e = errno;\n+    tty->print(\"Can't open file [%s].\", file_path);\n+    tty->print_raw_cr(os::strerror(e));\n+    return info;\n+  }\n+\n+  struct stat file_info;\n+  ::fstat(info.fd, &file_info);\n+  info.size = file_info.st_size;\n+  ::lseek(info.fd, 0, SEEK_SET);\n+\n+#if !defined(_WIN64)\n+  info.ptr = ::mmap(nullptr, info.size, PROT_READ, MAP_PRIVATE, info.fd, 0);\n+  assert(info.ptr != MAP_FAILED, \"info.ptr != MAP_FAILED\");\n+#endif\n+\n+  FREE_C_HEAP_ARRAY(char, file_path);\n+\n+  return info;\n+}\n+\n+void NMT_MemoryLogRecorder::initialize(long int limit) {\n+  \/\/ fprintf(stderr, \"> NMT_MemoryLogRecorder::initialize(%ld, %ld)\\n\", limit, sizeof(Entry));\n+  NMT_MemoryLogRecorder *recorder = NMT_MemoryLogRecorder::instance();\n+  recorder->init();\n+  NMTRecorder_Locker locker;\n+  {\n+    recorder->_limit = limit;\n+    if (recorder->_limit > 0) {\n+      recorder->_log_fd = _prepare_log_file(nullptr, ALLOCS_LOG_FILE);\n+      recorder->_done = false;\n+    } else {\n+      recorder->_done = true;\n+    }\n+  }\n+}\n+\n+void NMT_MemoryLogRecorder::finish(void) {\n+  NMT_MemoryLogRecorder *recorder = NMT_MemoryLogRecorder::instance();\n+  \/\/ fprintf(stderr, \"NMT_MemoryLogRecorder::finish() %p\\n\", NMT_MemoryLogRecorder::instance());\n+  if (!recorder->done()) {\n+    NMTRecorder_Locker locker;\n+\n+    volatile int log_fd = recorder->_log_fd;\n+    recorder->_log_fd = -1;\n+    \/\/ fprintf(stderr, \" log_fd:%d\\n\", log_fd);\n+    log_fd = _close_and_check(log_fd);\n+    \/\/ fprintf(stderr, \" log_fd:%d\\n\", log_fd);\n+\n+    int threads_fd = _prepare_log_file(nullptr, THREADS_LOG_FILE);\n+    \/\/ fprintf(stderr, \" threads_fd:%d\\n\", threads_fd);\n+    if (threads_fd != -1) {\n+      _write_and_check(threads_fd, recorder->_threads_names, (recorder->_threads_names_size-1)*sizeof(thread_name_info));\n+      threads_fd = _close_and_check(threads_fd);\n+      \/\/ fprintf(stderr, \" threads_fd:%d\\n\", threads_fd);\n+    }\n+\n+    int info_fd = _prepare_log_file(nullptr, INFO_LOG_FILE);\n+    \/\/ fprintf(stderr, \" info_fd:%d\\n\", info_fd);\n+    if (info_fd != -1) {\n+      size_t level = NMTUtil::parse_tracking_level(NativeMemoryTracking);\n+      _write_and_check(info_fd, &level, sizeof(level));\n+      size_t overhead = MemTracker::overhead_per_malloc();\n+      _write_and_check(info_fd, &overhead, sizeof(overhead));\n+      info_fd = _close_and_check(info_fd);\n+      \/\/ fprintf(stderr, \" info_fd:%d\\n\", info_fd);\n+    }\n+\n+    recorder->_done = true;\n+  }\n+  os::exit(0);\n+}\n+\n+void NMT_MemoryLogRecorder::replay(const int pid) {\n+  \/\/ fprintf(stderr, \"NMT_MemoryLogRecorder::replay(%d)\\n\", pid);\n+  static const char *path = \".\";\n+  NMT_MemoryLogRecorder *recorder = NMT_MemoryLogRecorder::instance();\n+  NMTRecorder_Locker locker;\n+\n+  file_info log_fi = _open_file_and_read(INFO_LOG_FILE, path, pid);\n+  if (log_fi.fd == -1) {\n+    return;\n+  }\n+  size_t* status_file_bytes = (size_t*)log_fi.ptr;\n+  NMT_TrackingLevel recorded_nmt_level = (NMT_TrackingLevel)status_file_bytes[0];\n+  \/\/ compare the recorded and current levels of NMT and flag if different\n+  bool timeOnly = NMTUtil::parse_tracking_level(NativeMemoryTracking) != recorded_nmt_level;\n+  if (timeOnly) {\n+    tty->print(\"\\n\\nNativeMemoryTracking mismatch [%s != %s].\\n\", NMTUtil::tracking_level_to_string(recorded_nmt_level), NMTUtil::tracking_level_to_string(NMTUtil::parse_tracking_level(NativeMemoryTracking)));\n+    tty->print(\"(Can not be used for memory usage comparison)\\n\");\n+  }\n+\n+  \/\/ open records file for reading the memory allocations to \"play back\"\n+  file_info records_fi = _open_file_and_read(ALLOCS_LOG_FILE, path, pid);\n+  if (records_fi.fd == -1) {\n+    return;\n+  }\n+  Entry* records_file_entries = (Entry*)records_fi.ptr;\n+  long int count = (long int)(records_fi.size \/ sizeof(Entry));\n+  long int size_pointers = (long int)(count * sizeof(address));\n+  address *pointers = nullptr;\n+#if !defined(_WIN64)\n+  pointers = (address*)::mmap(nullptr, size_pointers, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);\n+  assert(pointers != MAP_FAILED, \"pointers != MAP_FAILED\");\n+#endif\n+\n+  \/\/ open benchmark file for writing the final results\n+  char *benchmark_file_path = NEW_C_HEAP_ARRAY(char, JVM_MAXPATHLEN, mtNMT);\n+  if (!_create_file_path_with_pid(path, BENCHMARK_LOG_FILE, benchmark_file_path, pid)) {\n+    tty->print(\"Can't construct benchmark_file_path [%s].\", benchmark_file_path);\n+    os::exit(-1);\n+  }\n+  int benchmark_log_fd = _prepare_log_file(nullptr, BENCHMARK_LOG_FILE);\n+  if (benchmark_log_fd == -1) {\n+    tty->print(\"Can't open [%s].\", benchmark_file_path);\n+    os::exit(-1);\n+  }\n+\n+  long int countFree = 0;\n+  long int countMalloc = 0;\n+  long int countRealloc = 0;\n+  long int nanoseconds = 0;\n+  long int requestedTotal = 0;\n+  long int actualTotal = 0;\n+  long int headers = 0;\n+  for (off_t i = 0; i < count; i++) {\n+    Entry *e = &records_file_entries[i];\n+    MemTag mem_tag = NMTUtil::index_to_tag((int)e->mem_tag);\n+    int frameCount;\n+    for (frameCount = 0; frameCount < NMT_TrackingStackDepth; frameCount++) {\n+      if (e->stack[frameCount] == 0) {\n+        break;\n+      }\n+    }\n+    NativeCallStack stack = NativeCallStack::empty_stack();\n+    if (frameCount > 0) {\n+      stack = NativeCallStack(e->stack, frameCount);\n+    }\n+    long int requested = 0;\n+    long int actual = 0;\n+    pointers[i] = nullptr;\n+    long int start = 0;\n+    long int end = 0;\n+    {\n+      if (IS_REALLOC(e)) {\n+        \/\/ the recorded \"realloc\" was captured in a different process,\n+        \/\/ so find the corresponding \"malloc\" or \"realloc\" in this process\n+        for (off_t j = i-1; j >= 0; j--) {\n+          Entry *p = &records_file_entries[j];\n+          if (e->old == p->ptr) {\n+            countRealloc++;\n+            address ptr = pointers[j];\n+            requested -= (long int)p->requested;\n+            actual -= (long int)p->actual;\n+            start = os::javaTimeNanos();\n+            {\n+              ptr = (address)os::realloc(ptr, e->requested, mem_tag, stack);\n+            }\n+            end = os::javaTimeNanos();\n+            requested += (long int)e->requested;\n+            actual += (long int)e->actual;\n+            pointers[i] = ptr;\n+            pointers[j] = nullptr;\n+            break;\n+          }\n+          if (mem_tag == mtNone) {\n+            fprintf(stderr, \"REALLOC?\\n\");\n+          }\n+        }\n+      } else if (IS_MALLOC(e)) {\n+          countMalloc++;\n+          address ptr = nullptr;\n+          start = os::javaTimeNanos();\n+          {\n+            ptr = (address)os::malloc(e->requested, mem_tag, stack);\n+          }\n+          end = os::javaTimeNanos();\n+          requested = (long int)e->requested;\n+          actual = (long int)e->actual;\n+          pointers[i] = ptr;\n+          if (mem_tag == mtNone) {\n+            fprintf(stderr, \"MALLOC?\\n\");\n+          }\n+      } else if (IS_FREE(e)) {\n+        \/\/ the recorded \"free\" was captured in a different process,\n+        \/\/ so find the corresponding \"malloc\" or \"realloc\" in this process\n+        for (off_t j = i-1; j >= 0; j--) {\n+          Entry *p = &records_file_entries[j];\n+          if ((e->old == p->ptr) || (e->ptr == p->ptr)) {\n+            countFree++;\n+            mem_tag = NMTUtil::index_to_tag((int)p->mem_tag);\n+            void* ptr = pointers[j];\n+            requested -= (long int)p->requested;\n+            actual -= (long int)p->actual;\n+            start = os::javaTimeNanos();\n+            {\n+              os::free(ptr);\n+            }\n+            end = os::javaTimeNanos();\n+            pointers[i] = nullptr;\n+            pointers[j] = nullptr;\n+            break;\n+          }\n+        }\n+        if (mem_tag == mtNone) {\n+          fprintf(stderr, \"FREE?\\n\");\n+        }\n+      } else {\n+        fprintf(stderr, \"HUH?\\n\");\n+        os::exit(-1);\n+      }\n+      requestedTotal += requested;\n+      actualTotal += actual;\n+\n+      if (IS_FREE(e)) {\n+        if (mem_tag != mtNone) {\n+          headers--;\n+        }\n+      } else if IS_MALLOC(e) {\n+        headers++;\n+      }\n+    }\n+    long int duration = (start > 0) ? (end - start) : 0;\n+    nanoseconds += duration;\n+\n+    \/\/ write final results into its own log file that we can later parse it using 3rd party tool\n+    \/\/ where we can do histograms and go into custom details\n+    _write_and_check(benchmark_log_fd, &duration, sizeof(duration));\n+    _write_and_check(benchmark_log_fd, &requested, sizeof(requested));\n+    _write_and_check(benchmark_log_fd, &actual, sizeof(actual));\n+    char type = (IS_MALLOC(e) * 1) | (IS_REALLOC(e) * 2) | (IS_FREE(e) * 4);\n+    _write_and_check(benchmark_log_fd, &type, sizeof(type));\n+    \/\/ fprintf(stderr, \" %9ld:%9ld:%9ld %d:%d:%d\\n\", requested, actual, duration, IS_MALLOC(e), IS_REALLOC(e), IS_FREE(e));\n+  }\n+\n+  \/\/ present the results\n+  setlocale(LC_NUMERIC, \"\");\n+  setlocale(LC_ALL, \"\");\n+  long int overhead_NMT = 0;\n+  if (MemTracker::enabled()) {\n+    overhead_NMT = (long int)(headers * MemTracker::overhead_per_malloc());\n+  }\n+  long int overhead_malloc = actualTotal - requestedTotal - overhead_NMT;\n+  double overheadPercentage_malloc = 100.0 * (double)overhead_malloc \/ (double)requestedTotal;\n+  fprintf(stderr, \"\\n\\n\\nmalloc summary [recorded NMT mode \\\"%s\\\"]:\\n\\n\", NMTUtil::tracking_level_to_string(recorded_nmt_level));\n+  fprintf(stderr, \"time:\" LD_FORMAT \"[ns]\\n\", nanoseconds);\n+  if (!timeOnly) {\n+    double overheadPercentage_NMT = 100.0 * (double)overhead_NMT \/ (double)requestedTotal;\n+    fprintf(stderr, \"[samples:\" LD_FORMAT \"] [NMT headers:\" LD_FORMAT \"]\\n\", count, headers);\n+    fprintf(stderr, \"[malloc#:\" LD_FORMAT \"] [realloc#:\" LD_FORMAT \"] [free#:\" LD_FORMAT \"]\\n\", countMalloc, countRealloc, countFree);\n+    fprintf(stderr, \"memory requested:\" LD_FORMAT \" bytes, allocated:\" LD_FORMAT \" bytes\\n\", requestedTotal, actualTotal);\n+    fprintf(stderr, \"malloc overhead:\" LD_FORMAT \" bytes [%2.2f%%], NMT headers overhead:\" LD_FORMAT \" bytes [%2.2f%%]\\n\", overhead_malloc, overheadPercentage_malloc, overhead_NMT, overheadPercentage_NMT);\n+    fprintf(stderr, \"\\n\");\n+  }\n+\n+  \/\/ clean up\n+  _close_and_check(log_fi.fd);\n+  _close_and_check(records_fi.fd);\n+  _close_and_check(benchmark_log_fd);\n+  FREE_C_HEAP_ARRAY(char, benchmark_file_path);\n+\n+  for (off_t i = 0; i < count; i++) {\n+    if (pointers[i] != nullptr) {\n+      os::free(pointers[i]);\n+      pointers[i] = nullptr;\n+    }\n+  }\n+#if !defined(_WIN64)\n+  munmap((void*)pointers, size_pointers);\n+#endif\n+\n+  os::exit(0);\n+}\n+\n+void NMT_MemoryLogRecorder::_record(MemTag mem_tag, size_t requested, address ptr, address old, const NativeCallStack *stack) {\n+  NMT_MemoryLogRecorder *recorder = NMT_MemoryLogRecorder::instance();\n+  if (!recorder->done()) {\n+    NMTRecorder_Locker locker;\n+    volatile long int count = recorder->_count++;\n+    if (count < recorder->_limit) {\n+      Entry entry;\n+      entry.time = count;\n+      if (MemTracker::is_initialized()) {\n+        entry.time = os::javaTimeNanos();\n+      }\n+      entry.thread = os::current_thread_id();\n+      entry.ptr = ptr;\n+      entry.old = old;\n+      \/\/ fprintf(stderr, \"record %p:%zu:%p\\n\", ptr, requested, old);fflush(stderr);\n+      entry.requested = requested;\n+      entry.actual = 0;\n+      if (entry.requested > 0) {\n+        entry.actual = raw_malloc_size(ptr);\n+      }\n+\n+      entry.mem_tag = (long int)mem_tag;\n+      if ((MemTracker::is_initialized()) && (stack != nullptr)) {\n+        \/\/ recording stack frames will make sure that the hashtables\n+        \/\/ are used, so they get benchmarked as well\n+        for (int i = 0; i < NMT_TrackingStackDepth; i++) {\n+          entry.stack[i] = stack->get_frame(i);\n+        }\n+      }\n+\n+      if (recorder->_log_fd != -1) {\n+        _write_and_check(recorder->_log_fd, &entry, sizeof(Entry));\n+      }\n+\n+      recorder->logThreadName();\n+    } else {\n+      recorder->finish();\n+    }\n+  }\n+}\n+\n+void NMT_MemoryLogRecorder::record_free(void *ptr) {\n+  NMT_MemoryLogRecorder *recorder = NMT_MemoryLogRecorder::instance();\n+  if (!recorder->done()) {\n+    address resolved_ptr = (address)ptr;\n+    if (MemTracker::enabled()) {\n+      resolved_ptr = (address)ptr - NMT_HEADER_SIZE;\n+    }\n+    NMT_MemoryLogRecorder::_record(mtNone, 0, resolved_ptr, nullptr, nullptr);\n+  }\n+}\n+\n+void NMT_MemoryLogRecorder::record_malloc(MemTag mem_tag, size_t requested, void* ptr, const NativeCallStack *stack, void* old) {\n+  NMT_MemoryLogRecorder *recorder = NMT_MemoryLogRecorder::instance();\n+  if (!recorder->done()) {\n+    address resolved_ptr = (address)old;\n+    if (old != nullptr) {\n+      if (MemTracker::enabled()) {\n+        resolved_ptr = (address)old - NMT_HEADER_SIZE;\n+      }\n+    }\n+    NMT_MemoryLogRecorder::_record(mem_tag, requested, (address)ptr, resolved_ptr, stack);\n+  }\n+}\n+\n+void NMT_MemoryLogRecorder::print(Entry *e) {\n+  if (e == nullptr) {\n+    fprintf(stderr, \"nullptr\\n\");\n+  } else {\n+    if (IS_FREE(e)) {\n+      fprintf(stderr, \"           FREE: \");\n+    } else if (IS_REALLOC(e)) {\n+      fprintf(stderr, \"        REALLOC: \");\n+    } else if (IS_MALLOC(e)) {\n+      fprintf(stderr, \"         MALLOC: \");\n+    }\n+    fprintf(stderr, \"time:%15ld, thread:%6ld, ptr:%14p, old:%14p, requested:%8ld, actual:%8ld, mem_tag:%s\\n\", e->time, e->thread, e->ptr, e->old, e->requested, e->actual, NMTUtil::tag_to_name(NMTUtil::index_to_tag((int)e->mem_tag)));\n+  }\n+}\n+\n+\/\/static inline const char* type_to_name(NMT_VirtualMemoryLogRecorder::Type type) {\n+\/\/  switch (type) {\n+\/\/    case NMT_VirtualMemoryLogRecorder::Type::RESERVE: return \"RESERVE\"; break;\n+\/\/    case NMT_VirtualMemoryLogRecorder::Type::RELEASE: return \"RELEASE\"; break;\n+\/\/    case NMT_VirtualMemoryLogRecorder::Type::UNCOMMIT: return \"UNCOMMIT\"; break;\n+\/\/    case NMT_VirtualMemoryLogRecorder::Type::RESERVE_AND_COMMIT: return \"RESERVE_AND_COMMIT\"; break;\n+\/\/    case NMT_VirtualMemoryLogRecorder::Type::COMMIT: return \"COMMIT\"; break;\n+\/\/    case NMT_VirtualMemoryLogRecorder::Type::SPLIT_RESERVED: return \"SPLIT_RESERVED\"; break;\n+\/\/    case NMT_VirtualMemoryLogRecorder::Type::TAG: return \"TAG\"; break;\n+\/\/    default: break;\n+\/\/  }\n+\/\/}\n+\n+void NMT_VirtualMemoryLogRecorder::initialize(long int limit) {\n+  \/\/ fprintf(stderr, \"> NMT_VirtualMemoryLogRecorder::initialize(%ld, %ld)\\n\", limit, sizeof(Entry));\n+  NMTRecorder_Locker locker;\n+  NMT_VirtualMemoryLogRecorder *recorder = NMT_VirtualMemoryLogRecorder::instance();\n+  recorder->init();\n+  {\n+    recorder->_limit = limit;\n+    if (recorder->_limit > 0) {\n+      recorder->_log_fd = _prepare_log_file(nullptr, VALLOCS_LOG_FILE);\n+      recorder->_done = false;\n+    } else {\n+      recorder->_done = true;\n+    }\n+  }\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::finish(void) {\n+  NMTRecorder_Locker locker;\n+  NMT_VirtualMemoryLogRecorder *recorder = NMT_VirtualMemoryLogRecorder::instance();\n+  if (!recorder->done()) {\n+      volatile int log_fd = recorder->_log_fd;\n+      recorder->_log_fd = -1;\n+      \/\/ fprintf(stderr, \" log_fd:%d\\n\", log_fd);\n+      log_fd = _close_and_check(log_fd);\n+  }\n+\n+  int info_fd = _prepare_log_file(nullptr, INFO_LOG_FILE);\n+  if (info_fd != -1) {\n+    size_t mode = NMTUtil::parse_tracking_level(NativeMemoryTracking);\n+    _write_and_check(info_fd, &mode, sizeof(mode));\n+    size_t overhead = MemTracker::overhead_per_malloc();\n+    _write_and_check(info_fd, &overhead, sizeof(overhead));\n+    info_fd = _close_and_check(info_fd);\n+  }\n+\n+  recorder->_done = true;\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::replay(const int pid) {\n+  \/\/ fprintf(stderr, \"NMT_VirtualMemoryLogRecorder::replay(%d)\\n\", pid);\n+  static const char *path = \".\";\n+\n+  \/\/ open records file for reading the virtual memory allocations to \"play back\"\n+  file_info records_fi = _open_file_and_read(VALLOCS_LOG_FILE, path, pid);\n+  if (records_fi.fd == -1) {\n+    return;\n+  }\n+  Entry* records_file_entries = (Entry*)records_fi.ptr;\n+  long int count = (long int)(records_fi.size \/ sizeof(Entry));\n+\n+  long int total = 0;\n+  for (off_t i = 0; i < count; i++) {\n+    Entry *e = &records_file_entries[i];\n+\n+    MemTag mem_tag = NMTUtil::index_to_tag((int)e->mem_tag);\n+    int frameCount;\n+    for (frameCount = 0; frameCount < NMT_TrackingStackDepth; frameCount++) {\n+      if (e->stack[frameCount] == 0) {\n+        break;\n+      }\n+    }\n+    NativeCallStack stack = NativeCallStack::empty_stack();\n+    if (frameCount > 0) {\n+      stack = NativeCallStack(e->stack, frameCount);\n+    }\n+\n+    \/\/VirtualMemoryTracker::initialize(NMTUtil::parse_tracking_level(NativeMemoryTracking));\n+    long int start = os::javaTimeNanos();\n+    {\n+      switch (e->type) {\n+        case NMT_VirtualMemoryLogRecorder::Type::RESERVE:\n+          \/\/ fprintf(stderr, \"[record_virtual_memory_reserve(%p, %ld, %p, %hhu)\\n\", e->ptr, e->size, &stack, mem_tag);fflush(stderr);\n+          MemTracker::record_virtual_memory_reserve(e->ptr, e->size, stack, mem_tag);\n+          \/\/ fprintf(stderr, \"]\\n\");fflush(stderr);\n+          break;\n+        case NMT_VirtualMemoryLogRecorder::Type::RELEASE:\n+          \/\/ fprintf(stderr, \"[record_virtual_memory_release(%p, %ld)\\n\", e->ptr, e->size);fflush(stderr);\n+          MemTracker::record_virtual_memory_release(e->ptr, e->size);\n+          \/\/ fprintf(stderr, \"]\\n\");fflush(stderr);\n+          break;\n+        case NMT_VirtualMemoryLogRecorder::Type::UNCOMMIT:\n+          \/\/ fprintf(stderr, \"<record_virtual_memory_uncommit(%p, %ld)\\n\", e->ptr, e->size);fflush(stderr);\n+          MemTracker::record_virtual_memory_uncommit(e->ptr, e->size);\n+          \/\/ fprintf(stderr, \">\\n\");fflush(stderr);\n+          break;\n+        case NMT_VirtualMemoryLogRecorder::Type::RESERVE_AND_COMMIT:\n+          \/\/ fprintf(stderr, \"[MemTracker::record_virtual_memory_reserve_and_commit\\n\");\n+          MemTracker::record_virtual_memory_reserve_and_commit(e->ptr, e->size, stack, mem_tag);\n+          \/\/ fprintf(stderr, \"]\\n\");fflush(stderr);\n+          break;\n+        case NMT_VirtualMemoryLogRecorder::Type::COMMIT:\n+          \/\/ fprintf(stderr, \"[record_virtual_memory_commit(%p, %ld, %p)\\n\", e->ptr, e->size, &stack);fflush(stderr);\n+          MemTracker::record_virtual_memory_commit(e->ptr, e->size, stack);\n+          \/\/ fprintf(stderr, \"]\\n\");fflush(stderr);\n+          break;\n+        case NMT_VirtualMemoryLogRecorder::Type::SPLIT_RESERVED:\n+          \/\/ fprintf(stderr, \"[MemTracker::record_virtual_memory_split_reserved\\n\");\n+          MemTracker::record_virtual_memory_split_reserved(e->ptr, e->size, e->size_split, mem_tag, NMTUtil::index_to_tag((int)e->mem_tag_split));\n+          \/\/ fprintf(stderr, \"]\\n\");fflush(stderr);\n+          break;\n+        case NMT_VirtualMemoryLogRecorder::Type::TAG:\n+          \/\/ fprintf(stderr, \"[record_virtual_memory_type(%p, %ld, %p)\\n\", e->ptr, e->size, &stack);fflush(stderr);\n+          MemTracker::record_virtual_memory_tag(e->ptr, e->size, mem_tag);\n+          \/\/ fprintf(stderr, \"]\\n\");fflush(stderr);\n+          break;\n+        default:\n+          fprintf(stderr, \"HUH?\\n\");\n+          os::exit(-1);\n+          break;\n+      }\n+    }\n+    long int end = os::javaTimeNanos();\n+    long int duration = (start > 0) ? (end - start) : 0;\n+    total += duration;\n+  }\n+  fprintf(stderr, \"\\n\\n\\nVirtualMemoryTracker summary:\\n\\n\\n\");\n+  fprintf(stderr, \"time:\" LD_FORMAT \"[ns] [samples:\" LD_FORMAT \"]\\n\", total, count);\n+\/\/    if (count > 0) {\n+\/\/      nullStream bench_null;\n+\/\/      total = 0;\n+\/\/      for (off_t l = 0; l < 1; l++) {\n+\/\/        long int start = os::javaTimeNanos();\n+\/\/        VirtualMemoryTracker::Instance::print_self(tty);\n+\/\/        long int end = os::javaTimeNanos();\n+\/\/        long int duration = (start > 0) ? (end - start) : 0;\n+\/\/        total += duration;\n+\/\/      }\n+\/\/    }\n+\n+  _close_and_check(records_fi.fd);\n+\n+  os::exit(0);\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::_record(NMT_VirtualMemoryLogRecorder::Type type, MemTag mem_tag, MemTag mem_tag_split, size_t size, size_t size_split, address ptr, const NativeCallStack *stack) {\n+\/\/  fprintf(stderr, \"NMT_VirtualMemoryLogRecorder::record (%s, %hhu, %hhu, %ld, %ld, %p, %p)\\n\",\n+\/\/          type_to_name(type), mem_tag, mem_tag_split, size, size_split, ptr, stack);fflush(stderr);\n+  NMT_VirtualMemoryLogRecorder *recorder = NMT_VirtualMemoryLogRecorder::instance();\n+  if (!recorder->done()) {\n+    NMTRecorder_Locker locker;\n+    volatile long int count = recorder->_count++;\n+    if (count < recorder->_limit) {\n+      Entry entry;\n+      entry.type = type;\n+      entry.time = count;\n+      if (MemTracker::is_initialized())\n+      {\n+        entry.time = os::javaTimeNanos();\n+      }\n+      entry.thread = os::current_thread_id();\n+      entry.ptr = ptr;\n+      entry.mem_tag = (long int)mem_tag;\n+      entry.mem_tag_split = (long int)mem_tag_split;\n+      entry.size = size;\n+      entry.size_split = size_split;\n+      if ((MemTracker::is_initialized()) && (stack != nullptr)) {\n+        \/\/ the only use of frames is for benchmarking -\n+        \/\/ the NMT code uses a hashtable to store these values,\n+        \/\/ so preserving these will make sure that the hashtables\n+        \/\/ are used when ran with this data\n+        for (int i = 0; i < NMT_TrackingStackDepth; i++) {\n+          entry.stack[i] = stack->get_frame(i);\n+        }\n+      }\n+      \/\/ fprintf(stderr, \"recorder->_log_fd: %d\\n\", recorder->_log_fd);\n+      if (recorder->_log_fd != -1) {\n+        _write_and_check(recorder->_log_fd, &entry, sizeof(Entry));\n+      }\n+    } else {\n+      recorder->finish();\n+    }\n+  }\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::record_virtual_memory_reserve(void* addr, size_t size, const NativeCallStack& stack, MemTag mem_tag) {\n+  NMT_VirtualMemoryLogRecorder::_record(Type::RESERVE, mem_tag, mtNone, size, 0, (address)addr, &stack);\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::record_virtual_memory_release(address addr, size_t size) {\n+  NMT_VirtualMemoryLogRecorder::_record(Type::RELEASE, mtNone, mtNone, size, 0, (address)addr, nullptr);\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::record_virtual_memory_uncommit(address addr, size_t size) {\n+  NMT_VirtualMemoryLogRecorder::_record(Type::UNCOMMIT, mtNone, mtNone, size, 0, (address)addr, nullptr);\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::record_virtual_memory_reserve_and_commit(void* addr, size_t size, const NativeCallStack& stack, MemTag mem_tag) {\n+  NMT_VirtualMemoryLogRecorder::_record(Type::RESERVE_AND_COMMIT, mem_tag, mtNone, size, 0, (address)addr, &stack);\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::record_virtual_memory_commit(void* addr, size_t size, const NativeCallStack& stack) {\n+  NMT_VirtualMemoryLogRecorder::_record(Type::COMMIT, mtNone, mtNone, size, 0, (address)addr, &stack);\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::record_virtual_memory_split_reserved(void* addr, size_t size, size_t split, MemTag mem_tag, MemTag split_mem_tag) {\n+  NMT_VirtualMemoryLogRecorder::_record(Type::SPLIT_RESERVED, mem_tag, split_mem_tag, size, split, (address)addr, nullptr);\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::record_virtual_memory_tag(void* addr, size_t size, MemTag mem_tag) {\n+  NMT_VirtualMemoryLogRecorder::_record(Type::TAG, mem_tag, mtNone, size, 0, (address)addr, nullptr);\n+}\n+\n+#else\n+\n+\/\/ TODO: Windows impl\n+\n+#endif \/\/ if defined(LINUX) || defined(__APPLE__)\n","filename":"src\/hotspot\/share\/nmt\/memLogRecorder.cpp","additions":855,"deletions":0,"binary":false,"changes":855,"status":"added"},{"patch":"@@ -0,0 +1,212 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_NMT_MEMLOGRECORDER_HPP\n+#define SHARE_NMT_MEMLOGRECORDER_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"nmt\/nmtCommon.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/java.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+\/\/ see MemTracker::NmtVirtualMemoryLocker\n+class NMTRecorder_Locker: StackObj {\n+  static bool _safe_to_use;\n+  ConditionalMutexLocker _cml;\n+public:\n+  NMTRecorder_Locker(): _cml(NMTRecorder_lock, _safe_to_use, Mutex::_no_safepoint_check_flag) {\n+  }\n+  ~NMTRecorder_Locker() {\n+  }\n+  static inline bool is_safe_to_use() {\n+    return _safe_to_use;\n+  }\n+  static inline void set_safe_to_use() {\n+    _safe_to_use = true;\n+  }\n+};\n+\n+#if defined(LINUX) || defined(__APPLE__)\n+\n+#if defined(LINUX)\n+#define MAXTHREADNAMESIZE 256\n+#endif\n+\n+class NMT_LogRecorder : public StackObj {\n+protected:\n+  long int _limit  = 0;\n+  long int _count  = 0;\n+  int _log_fd;\n+  volatile bool _done = true;\n+\n+protected:\n+  volatile size_t _threads_names_size = 0;\n+  typedef struct thread_name_info {\n+    char name[MAXTHREADNAMESIZE];\n+    long int thread;\n+  } thread_name_info;\n+  thread_name_info *_threads_names = nullptr;\n+\n+public:\n+  static void initialize();\n+  static void finish();\n+  static void replay();\n+  static void logThreadName(const char* name);\n+\n+public:\n+  void init();\n+  void get_thread_name(char* buf);\n+  bool done() {\n+    return _done;\n+  }\n+  void logThreadName();\n+};\n+\n+class NMT_MemoryLogRecorder : public NMT_LogRecorder {\n+\n+private:\n+  static NMT_MemoryLogRecorder _recorder;\n+\n+private:\n+    struct Entry {\n+    long int time;\n+    long int thread;\n+    address ptr;\n+    address old;\n+    address stack[NMT_TrackingStackDepth];\n+    long int requested;\n+    long int actual;\n+    long int mem_tag;\n+  };\n+\n+public:\n+  static NMT_MemoryLogRecorder* instance() {\n+    return &_recorder;\n+  };\n+  static void initialize(long int count);\n+  static bool initialized() {\n+    return false;\n+  }\n+  static void print(Entry *e);\n+  static void finish(void);\n+  static void replay(const int pid);\n+  static void record_free(void *ptr);\n+  static void record_malloc(MemTag mem_tag, size_t requested, void* ptr, const NativeCallStack *stack, void* old = nullptr);\n+  static void printActualSizesFor(const char* list);\n+\n+private:\n+  static void _record(MemTag mem_tag, size_t requested, address ptr, address old, const NativeCallStack *stack);\n+};\n+\n+class NMT_VirtualMemoryLogRecorder : public NMT_LogRecorder {\n+\n+private:\n+  static NMT_VirtualMemoryLogRecorder _recorder;\n+\n+private:\n+  struct Entry {\n+    long int time;\n+    long int thread;\n+    address ptr;\n+    address stack[NMT_TrackingStackDepth];\n+    long int mem_tag;\n+    long int mem_tag_split;\n+    size_t size;\n+    size_t size_split;\n+    int type;\n+  };\n+\n+public:\n+  enum Type {\n+    RESERVE,\n+    RELEASE,\n+    UNCOMMIT,\n+    RESERVE_AND_COMMIT,\n+    COMMIT,\n+    SPLIT_RESERVED,\n+    TAG\n+  };\n+\n+public:\n+  static NMT_VirtualMemoryLogRecorder* instance() {\n+    return &_recorder;\n+  };\n+  static void initialize(long int count);\n+  static void finish(void);\n+  static void replay(const int pid);\n+  static void record_virtual_memory_reserve(void* addr, size_t size, const NativeCallStack& stack, MemTag mem_tag = mtNone);\n+  static void record_virtual_memory_release(address addr, size_t size);\n+  static void record_virtual_memory_uncommit(address addr, size_t size);\n+  static void record_virtual_memory_reserve_and_commit(void* addr, size_t size, const NativeCallStack& stack, MemTag mem_tag = mtNone);\n+  static void record_virtual_memory_commit(void* addr, size_t size, const NativeCallStack& stack);\n+  static void record_virtual_memory_split_reserved(void* addr, size_t size, size_t split, MemTag flag, MemTag mem_tag_split);\n+  static void record_virtual_memory_tag(void* addr, size_t size, MemTag mem_tag);\n+\n+private:\n+  static void _record(NMT_VirtualMemoryLogRecorder::Type type, MemTag mem_tag, MemTag mem_tag_split, size_t size, size_t size_split, address ptr, const NativeCallStack *stack);\n+};\n+\n+#else \/\/ defined(LINUX) || defined(__APPLE__)\n+\n+class NMT_LogRecorder : public StackObj {\n+public:\n+  static void initialize() { \/\/ TODO\n+  }\n+  static void finish() { \/\/ TODO\n+  }\n+  static void replay() { \/\/ TODO\n+  }\n+};\n+\n+class NMT_MemoryLogRecorder : public NMT_LogRecorder {\n+public:\n+  static void record_free(void *ptr) { \/\/ TODO\n+  }\n+  static void record_malloc(MemTag mem_tag, size_t requested, void* ptr, const NativeCallStack *stack, void* old = nullptr) { \/\/ TODO\n+  }\n+};\n+\n+class NMT_VirtualMemoryLogRecorder : public NMT_LogRecorder {\n+public:\n+  static void record_virtual_memory_reserve(void* addr, size_t size, const NativeCallStack& stack, MemTag mem_tag = mtNone) { \/\/ TODO\n+  }\n+  static void record_virtual_memory_release(address addr, size_t size) { \/\/ TODO\n+  }\n+  static void record_virtual_memory_uncommit(address addr, size_t size) { \/\/ TODO\n+  }\n+  static void record_virtual_memory_reserve_and_commit(void* addr, size_t size, const NativeCallStack& stack, MemTag mem_tag = mtNone) { \/\/ TODO\n+  }\n+  static void record_virtual_memory_commit(void* addr, size_t size, const NativeCallStack& stack) { \/\/ TODO\n+  }\n+  static void record_virtual_memory_split_reserved(void* addr, size_t size, size_t split, MemTag flag, MemTag mem_tag_split) { \/\/ TODO\n+  }\n+  static void record_virtual_memory_tag(void* addr, size_t size, MemTag mem_tag) { \/\/ TODO\n+  }\n+};\n+\n+#endif \/\/ defined(LINUX) || defined(__APPLE__)\n+\n+#endif \/\/ SHARE_NMT_MEMLOGRECORDER_HPP\n","filename":"src\/hotspot\/share\/nmt\/memLogRecorder.hpp","additions":212,"deletions":0,"binary":false,"changes":212,"status":"added"},{"patch":"@@ -57,0 +57,2 @@\n+  NMT_LogRecorder::initialize();\n+\n@@ -97,0 +99,2 @@\n+\n+  NMT_LogRecorder::replay();\n","filename":"src\/hotspot\/share\/nmt\/memTracker.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"nmt\/memLogRecorder.hpp\"\n@@ -85,1 +86,1 @@\n-    const NativeCallStack& stack) {\n+    const NativeCallStack& stack, void* old_base = nullptr) {\n@@ -87,0 +88,1 @@\n+    void* ptr = mem_base;\n@@ -88,1 +90,1 @@\n-      return MallocTracker::record_malloc(mem_base, size, mem_tag, stack);\n+      ptr = MallocTracker::record_malloc(mem_base, size, mem_tag, stack, old_base);\n@@ -90,1 +92,2 @@\n-    return mem_base;\n+    NMT_MemoryLogRecorder::record_malloc(mem_tag, size, mem_base, &stack, old_base);\n+    return ptr;\n@@ -97,0 +100,1 @@\n+    NMT_MemoryLogRecorder::record_free(memblock);\n@@ -136,0 +140,1 @@\n+      NMT_VirtualMemoryLogRecorder::record_virtual_memory_reserve((address)addr, size, stack, mem_tag);\n@@ -144,0 +149,1 @@\n+      NMT_VirtualMemoryLogRecorder::record_virtual_memory_release((address)addr, size);\n@@ -152,0 +158,1 @@\n+      NMT_VirtualMemoryLogRecorder::record_virtual_memory_uncommit((address)addr, size);\n@@ -163,0 +170,2 @@\n+      NMT_VirtualMemoryLogRecorder::record_virtual_memory_reserve((address)addr, size, stack, mem_tag);\n+      NMT_VirtualMemoryLogRecorder::record_virtual_memory_commit((address)addr, size, stack);\n@@ -173,0 +182,1 @@\n+      NMT_VirtualMemoryLogRecorder::record_virtual_memory_commit((address)addr, size, stack);\n@@ -221,0 +231,1 @@\n+      NMT_VirtualMemoryLogRecorder::record_virtual_memory_split_reserved((address)addr, size, split, mem_tag, split_tag);\n@@ -234,0 +245,1 @@\n+      NMT_VirtualMemoryLogRecorder::record_virtual_memory_tag((address)addr, size, mem_tag);\n","filename":"src\/hotspot\/share\/nmt\/memTracker.hpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3941,1 +3941,1 @@\n-                                char* buf, size_t buflen) {\n+                                char* buf, size_t buflen, int pid) {\n@@ -3957,1 +3957,4 @@\n-        int ret = jio_snprintf(b, buf_sz, \"%d\", os::current_process_id());\n+        if (pid == 0) {\n+           pid = os::current_process_id();\n+         }\n+         int ret = jio_snprintf(b, buf_sz, \"%d\", pid);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -515,1 +515,1 @@\n-  static bool copy_expand_pid(const char* src, size_t srclen, char* buf, size_t buflen);\n+  static bool copy_expand_pid(const char* src, size_t srclen, char* buf, size_t buflen, int pid = 0);\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -153,0 +153,1 @@\n+Mutex*   NMTRecorder_lock             = nullptr;\n@@ -292,0 +293,1 @@\n+\n@@ -352,0 +354,2 @@\n+  MUTEX_DEFN(NMTRecorder_lock               , PaddedMutex , nosafepoint);\n+\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -121,0 +121,1 @@\n+\n@@ -159,0 +160,1 @@\n+extern Mutex*   NMTRecorder_lock;\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -737,1 +737,1 @@\n-    void* const new_inner_ptr = MemTracker::record_malloc(new_outer_ptr, size, mem_tag, stack);\n+    void* const new_inner_ptr = MemTracker::record_malloc(new_outer_ptr, size, mem_tag, stack, memblock);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+#include \"nmt\/memLogRecorder.hpp\"\n@@ -560,0 +561,1 @@\n+  NMTRecorder_Locker::set_safe_to_use();\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"nmt\/memLogRecorder.hpp\"\n@@ -574,0 +575,1 @@\n+  NMT_LogRecorder::finish();\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1844,0 +1844,1 @@\n+  NMT_LogRecorder::finish();\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}