{"files":[{"patch":"@@ -76,1 +76,1 @@\n-    _page->finalize_reset_for_in_place_relocation();\n+    _page->reset_livemap();\n","filename":"src\/hotspot\/share\/gc\/z\/zForwarding.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,5 +60,2 @@\n-  \/\/ Only copy type and memory layouts. Let the rest be lazily reconstructed when needed.\n-  return new ZPage(_type, _virtual, _physical);\n-}\n-\n-ZPage* ZPage::clone_limited_promote_flipped() const {\n+  \/\/ Only copy type and memory layouts, and also update _top. Let the rest be\n+  \/\/ lazily reconstructed when needed.\n@@ -66,2 +63,0 @@\n-\n-  \/\/ The page is still filled with the same objects, need to retain the top pointer.\n@@ -86,11 +81,4 @@\n-void ZPage::remset_clear() {\n-  _remembered_set.clear_all();\n-}\n-\n-void ZPage::verify_remset_after_reset(ZPageAge prev_age, ZPageResetType type) {\n-  \/\/ Young-to-old reset\n-  if (prev_age != ZPageAge::old) {\n-    verify_remset_cleared_previous();\n-    verify_remset_cleared_current();\n-    return;\n-  }\n+void ZPage::remset_initialize() {\n+  \/\/ Remsets should only be initialized once and only for old pages.\n+  assert(!_remembered_set.is_initialized(), \"Should not be initialized\");\n+  assert(is_old(), \"Only old pages need a remset\");\n@@ -98,12 +86,2 @@\n-  \/\/ Old-to-old reset\n-  switch (type) {\n-  case ZPageResetType::InPlaceRelocation:\n-    \/\/ Relocation failed and page is being compacted in-place.\n-    \/\/ The remset bits are flipped each young mark start, so\n-    \/\/ the verification code below needs to use the right remset.\n-    if (ZGeneration::old()->active_remset_is_current()) {\n-      verify_remset_cleared_previous();\n-    } else {\n-      verify_remset_cleared_current();\n-    }\n-    break;\n+  _remembered_set.initialize(size());\n+}\n@@ -111,3 +89,2 @@\n-  case ZPageResetType::FlipAging:\n-    fatal(\"Should not have called this for old-to-old flipping\");\n-    break;\n+void ZPage::remset_initialize_or_verify_cleared() {\n+  assert(is_old(), \"Only old pages need a remset\");\n@@ -115,2 +92,1 @@\n-  case ZPageResetType::Allocation:\n-    verify_remset_cleared_previous();\n+  if (_remembered_set.is_initialized()) {\n@@ -118,8 +94,3 @@\n-    break;\n-  };\n-}\n-\n-void ZPage::reset_remembered_set() {\n-  if (is_young()) {\n-    \/\/ Remset not needed\n-    return;\n+    verify_remset_cleared_previous();\n+  } else {\n+    remset_initialize();\n@@ -127,0 +98,1 @@\n+}\n@@ -128,6 +100,2 @@\n-  \/\/ Clearing of remsets is done when freeing a page, so this code only\n-  \/\/ needs to ensure the remset is initialized the first time a page\n-  \/\/ becomes old.\n-  if (!_remembered_set.is_initialized()) {\n-    _remembered_set.initialize(size());\n-  }\n+void ZPage::remset_clear() {\n+  _remembered_set.clear_all();\n@@ -136,2 +104,1 @@\n-void ZPage::reset(ZPageAge age, ZPageResetType type) {\n-  const ZPageAge prev_age = _age;\n+void ZPage::reset(ZPageAge age) {\n@@ -146,14 +113,0 @@\n-\n-  \/\/ Flip aged pages are still filled with the same objects, need to retain the top pointer.\n-  if (type != ZPageResetType::FlipAging) {\n-    _top = to_zoffset_end(start());\n-  }\n-\n-  reset_remembered_set();\n-  verify_remset_after_reset(prev_age, type);\n-\n-  if (type != ZPageResetType::InPlaceRelocation || (prev_age != ZPageAge::old && age == ZPageAge::old)) {\n-    \/\/ Promoted in-place relocations reset the live map,\n-    \/\/ because they clone the page.\n-    _livemap.reset();\n-  }\n@@ -162,2 +115,1 @@\n-void ZPage::finalize_reset_for_in_place_relocation() {\n-  \/\/ Now we're done iterating over the livemaps\n+void ZPage::reset_livemap() {\n@@ -167,0 +119,4 @@\n+void ZPage::reset_top_for_allocation() {\n+  _top = to_zoffset_end(start());\n+}\n+\n@@ -264,1 +220,1 @@\n- _remembered_set.clear_current();\n+  _remembered_set.clear_current();\n@@ -268,1 +224,1 @@\n- _remembered_set.clear_previous();\n+  _remembered_set.clear_previous();\n","filename":"src\/hotspot\/share\/gc\/z\/zPage.cpp","additions":25,"deletions":69,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -39,10 +39,0 @@\n-enum class ZPageResetType {\n-  \/\/ Normal allocation path\n-  Allocation,\n-  \/\/ Relocation failed and started to relocate in-place\n-  InPlaceRelocation,\n-  \/\/ Page was not selected for relocation, all objects\n-  \/\/ stayed, but the page aged.\n-  FlipAging,\n-};\n-\n@@ -83,1 +73,0 @@\n-  void reset_remembered_set();\n@@ -87,2 +76,0 @@\n-  void verify_remset_after_reset(ZPageAge prev_age, ZPageResetType type);\n-\n@@ -93,1 +80,0 @@\n-  ZPage* clone_limited_promote_flipped() const;\n@@ -129,4 +115,3 @@\n-  void reset(ZPageAge age, ZPageResetType type);\n-\n-  void finalize_reset_for_in_place_relocation();\n-\n+  void reset(ZPageAge age);\n+  void reset_livemap();\n+  void reset_top_for_allocation();\n@@ -173,0 +158,2 @@\n+  void remset_initialize();\n+  void remset_initialize_or_verify_cleared();\n","filename":"src\/hotspot\/share\/gc\/z\/zPage.hpp","additions":5,"deletions":18,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -732,1 +732,6 @@\n-  page->reset(age, ZPageResetType::Allocation);\n+  page->reset(age);\n+  page->reset_top_for_allocation();\n+  page->reset_livemap();\n+  if (age == ZPageAge::old) {\n+    page->remset_initialize_or_verify_cleared();\n+  }\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -846,1 +846,17 @@\n-    to_page->reset(to_age, ZPageResetType::InPlaceRelocation);\n+\n+    \/\/ Reset page for in-place relocation\n+    to_page->reset(to_age);\n+    to_page->reset_top_for_allocation();\n+    if (promotion) {\n+      to_page->remset_initialize();\n+    }\n+\n+    \/\/ Verify that the inactive remset is clear when resetting the page for\n+    \/\/ in-place relocation.\n+    if (from_page->age() == ZPageAge::old) {\n+      if (ZGeneration::old()->active_remset_is_current()) {\n+        to_page->verify_remset_cleared_previous();\n+      } else {\n+        to_page->verify_remset_cleared_current();\n+      }\n+    }\n@@ -1273,2 +1289,8 @@\n-      ZPage* const new_page = promotion ? prev_page->clone_limited_promote_flipped() : prev_page;\n-      new_page->reset(to_age, ZPageResetType::FlipAging);\n+      ZPage* const new_page = promotion ? prev_page->clone_limited() : prev_page;\n+\n+      \/\/ Reset page for flip aging\n+      new_page->reset(to_age);\n+      new_page->reset_livemap();\n+      if (promotion) {\n+        new_page->remset_initialize();\n+      }\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.cpp","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -228,1 +228,1 @@\n-    page.reset(ZPageAge::eden, ZPageResetType::Allocation);\n+    page.reset(ZPageAge::eden);\n","filename":"test\/hotspot\/gtest\/gc\/z\/test_zForwarding.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}