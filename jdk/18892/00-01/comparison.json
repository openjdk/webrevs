{"files":[{"patch":"@@ -24,4 +24,0 @@\n-package compiler.loopopts.superword;\n-\n-import java.lang.foreign.*;\n-\n@@ -34,0 +30,2 @@\n+ * @modules java.base\/jdk.internal.misc\n+ * @modules java.base\/jdk.internal.util\n@@ -36,1 +34,0 @@\n- * @run main                 compiler.loopopts.superword.TestMemorySegmentMainLoopAlignment\n@@ -39,0 +36,6 @@\n+package compiler.loopopts.superword;\n+\n+import java.lang.foreign.*;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.util.Preconditions;\n+\n@@ -41,0 +44,2 @@\n+    static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+    static long RANGE = 6400;\n@@ -47,0 +52,5 @@\n+    \/\/ Type definition for the lambda\n+    interface MemoryUnsafeOp {\n+        int apply(long base, long offset, int i);\n+    }\n+\n@@ -51,1 +61,6 @@\n-            test(ms, 0, TestMemorySegmentMainLoopAlignment::memorySegmentGet);\n+            test1(ms, 0, TestMemorySegmentMainLoopAlignment::memorySegmentGet);\n+        }\n+        \/\/ Allocate some raw memory:\n+        long base = UNSAFE.allocateMemory(6400);\n+        for (int i = 0; i < 10_000; i++) {\n+            test2(base, 0, TestMemorySegmentMainLoopAlignment::memoryUnsafeGet);\n@@ -62,1 +77,1 @@\n-    static int test(MemorySegment a, long offset, MSOp f) {\n+    static int test1(MemorySegment a, long offset, MSOp f) {\n@@ -75,0 +90,25 @@\n+\n+    \/\/ Somehow, it is necessary to pass this as a lambda\n+    static int memoryUnsafeGet(long base, long o, int i) {\n+        long index = o + i * 4L;\n+        \/\/ checkIndex -> CastLL: index >= 0.\n+        \/\/ Together with the info about i (known range for phi), this CastLL floats up to\n+        \/\/ the offset. Then we get adr = CastX2P(base + CastLL(offset)), where the CastLL\n+        \/\/ is pinned between the pre and main loop.\n+        Preconditions.checkIndex(index, RANGE, null);\n+        return UNSAFE.getInt(base + index);\n+    }\n+\n+    static int test2(long base, long offset, MemoryUnsafeOp f) {\n+        \/\/ Constant size array size allows a known range for the array access\/loop iv i.\n+        int size = 16;\n+        int[] res = new int[size];\n+        int sum = 0;\n+        for (int i = 0; i < size; i++) {\n+            \/\/ With inlining, this eventually becomes:\n+            \/\/ sum += LoadI(unsafe) + LoadI(array)\n+            \/\/ and we attempt vectorization.\n+            sum += f.apply(base, offset, i) + res[i];\n+        }\n+        return sum;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegmentMainLoopAlignment.java","additions":47,"deletions":7,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -1,84 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.loopopts.superword;\n-\n-import jdk.internal.misc.Unsafe;\n-import jdk.internal.util.Preconditions;\n-\n-\/*\n- * @test\n- * @bug 8330819\n- * @summary Case where VPointer finds an \"adr\" CastX2P, which contains a CastLL,\n- *          that has a ctrl after the pre-loop. This value cannot be used in the\n- *          pre-loop limit for main-loop adjustment.\n- * @modules java.base\/jdk.internal.misc\n- * @modules java.base\/jdk.internal.util\n- * @library \/test\/lib \/\n- * @run main\/othervm -Xbatch compiler.loopopts.superword.TestMemorySegmentMainLoopAlignmentUnsafe\n- * @run main                 compiler.loopopts.superword.TestMemorySegmentMainLoopAlignmentUnsafe\n- *\/\n-\n-public class TestMemorySegmentMainLoopAlignmentUnsafe {\n-    static final Unsafe UNSAFE = Unsafe.getUnsafe();\n-\n-    static long RANGE = 6400;\n-\n-    \/\/ Type definition for the lambda\n-    interface MemoryUnsafeOp {\n-        int apply(long base, long offset, int i);\n-    }\n-\n-    public static void main(String[] args) {\n-        \/\/ Allocate some raw memory:\n-        long base = UNSAFE.allocateMemory(6400);\n-        for (int i = 0; i < 10_000; i++) {\n-            test(base, 0, TestMemorySegmentMainLoopAlignmentUnsafe::memoryUnsafeGet);\n-        }\n-    }\n-\n-    \/\/ Somehow, it is necessary to pass this as a lambda\n-    static int memoryUnsafeGet(long base, long o, int i) {\n-        long index = o + i * 4L;\n-        \/\/ checkIndex -> CastLL: index >= 0.\n-        \/\/ Together with the info about i (known range for phi), this CastLL floats up to\n-        \/\/ the offset. Then we get adr = CastX2P(base + CastLL(offset)), where the CastLL\n-        \/\/ is pinned between the pre and main loop.\n-        Preconditions.checkIndex(index, RANGE, null);\n-        return UNSAFE.getInt(base + index);\n-    }\n-\n-    static int test(long base, long offset, MemoryUnsafeOp f) {\n-        \/\/ Constant size array size allows a known range for the array access\/loop iv i.\n-        int size = 16;\n-        int[] res = new int[size];\n-        int sum = 0;\n-        for (int i = 0; i < size; i++) {\n-            \/\/ With inlining, this eventually becomes:\n-            \/\/ sum += LoadI(unsafe) + LoadI(array)\n-            \/\/ and we attempt vectorization.\n-            sum += f.apply(base, offset, i) + res[i];\n-        }\n-        return sum;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegmentMainLoopAlignmentUnsafe.java","additions":0,"deletions":84,"binary":false,"changes":84,"status":"deleted"}]}