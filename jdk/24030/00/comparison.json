{"files":[{"patch":"@@ -2293,4 +2293,0 @@\n-            public Stream<ScheduledExecutorService> virtualThreadDelayedTaskSchedulers() {\n-                return VirtualThread.delayedTaskSchedulers();\n-            }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import java.util.Arrays;\n@@ -41,1 +40,0 @@\n-import java.util.stream.Stream;\n@@ -69,1 +67,0 @@\n-    private static final ScheduledExecutorService[] DELAYED_TASK_SCHEDULERS = createDelayedTaskSchedulers();\n@@ -196,7 +193,0 @@\n-    \/**\n-     * Returns a stream of the delayed task schedulers used to support timed operations.\n-     *\/\n-    static Stream<ScheduledExecutorService> delayedTaskSchedulers() {\n-        return Arrays.stream(DELAYED_TASK_SCHEDULERS);\n-    }\n-\n@@ -570,0 +560,1 @@\n+                long timeout = this.timeout;\n@@ -571,1 +562,1 @@\n-                timeoutTask = schedule(this::unpark, timeout, NANOSECONDS);\n+                timeoutTask = schedule(this::parkTimeoutExpired, timeout, NANOSECONDS);\n@@ -621,0 +612,1 @@\n+                long timeout = this.timeout;\n@@ -893,1 +885,13 @@\n-     * Invoked by timer thread when wait timeout for virtual thread has expired.\n+     * Invoked by FJP worker thread or STPE thread when park timeout expires.\n+     *\/\n+    private void parkTimeoutExpired() {\n+        assert !VirtualThread.currentThread().isVirtual();\n+        if (!getAndSetParkPermit(true)\n+                && (state() == TIMED_PARKED)\n+                && compareAndSetState(TIMED_PARKED, UNPARKED)) {\n+            lazySubmitRunContinuation();\n+        }\n+    }\n+\n+    \/**\n+     * Invoked by FJP worker thread or STPE thread when wait timeout expires.\n@@ -916,1 +920,1 @@\n-                submitRunContinuation();\n+                lazySubmitRunContinuation();\n@@ -1447,4 +1451,6 @@\n-    private static Future<?> schedule(Runnable command, long delay, TimeUnit unit) {\n-        long tid = Thread.currentThread().threadId();\n-        int index = (int) tid & (DELAYED_TASK_SCHEDULERS.length - 1);\n-        return DELAYED_TASK_SCHEDULERS[index].schedule(command, delay, unit);\n+    private Future<?> schedule(Runnable command, long delay, TimeUnit unit) {\n+        if (scheduler instanceof ForkJoinPool pool) {\n+            return pool.schedule(command, delay, unit);\n+        } else {\n+            return DelayedTaskSchedulers.schedule(command, delay, unit);\n+        }\n@@ -1454,1 +1460,3 @@\n-     * Creates the ScheduledThreadPoolExecutors used to execute delayed tasks.\n+     * Supports scheduling a runnable task to run after a delay. It uses a number\n+     * of ScheduledThreadPoolExecutor instances to reduce contention on the delayed\n+     * work queue used. This class is used when using a custom scheduler.\n@@ -1456,12 +1464,7 @@\n-    private static ScheduledExecutorService[] createDelayedTaskSchedulers() {\n-        String propName = \"jdk.virtualThreadScheduler.timerQueues\";\n-        String propValue = System.getProperty(propName);\n-        int queueCount;\n-        if (propValue != null) {\n-            queueCount = Integer.parseInt(propValue);\n-            if (queueCount != Integer.highestOneBit(queueCount)) {\n-                throw new RuntimeException(\"Value of \" + propName + \" must be power of 2\");\n-            }\n-        } else {\n-            int ncpus = Runtime.getRuntime().availableProcessors();\n-            queueCount = Math.max(Integer.highestOneBit(ncpus \/ 4), 1);\n+    private static class DelayedTaskSchedulers {\n+        private static final ScheduledExecutorService[] INSTANCE = createDelayedTaskSchedulers();\n+\n+        static Future<?> schedule(Runnable command, long delay, TimeUnit unit) {\n+            long tid = Thread.currentThread().threadId();\n+            int index = (int) tid & (INSTANCE.length - 1);\n+            return INSTANCE[index].schedule(command, delay, unit);\n@@ -1469,10 +1472,26 @@\n-        var schedulers = new ScheduledExecutorService[queueCount];\n-        for (int i = 0; i < queueCount; i++) {\n-            ScheduledThreadPoolExecutor stpe = (ScheduledThreadPoolExecutor)\n-                Executors.newScheduledThreadPool(1, task -> {\n-                    Thread t = InnocuousThread.newThread(\"VirtualThread-unparker\", task);\n-                    t.setDaemon(true);\n-                    return t;\n-                });\n-            stpe.setRemoveOnCancelPolicy(true);\n-            schedulers[i] = stpe;\n+\n+        private static ScheduledExecutorService[] createDelayedTaskSchedulers() {\n+            String propName = \"jdk.virtualThreadScheduler.timerQueues\";\n+            String propValue = System.getProperty(propName);\n+            int queueCount;\n+            if (propValue != null) {\n+                queueCount = Integer.parseInt(propValue);\n+                if (queueCount != Integer.highestOneBit(queueCount)) {\n+                    throw new RuntimeException(\"Value of \" + propName + \" must be power of 2\");\n+                }\n+            } else {\n+                int ncpus = Runtime.getRuntime().availableProcessors();\n+                queueCount = Math.max(Integer.highestOneBit(ncpus \/ 4), 1);\n+            }\n+            var schedulers = new ScheduledExecutorService[queueCount];\n+            for (int i = 0; i < queueCount; i++) {\n+                ScheduledThreadPoolExecutor stpe = (ScheduledThreadPoolExecutor)\n+                    Executors.newScheduledThreadPool(1, task -> {\n+                        Thread t = InnocuousThread.newThread(\"VirtualThread-unparker\", task);\n+                        t.setDaemon(true);\n+                        return t;\n+                    });\n+                stpe.setRemoveOnCancelPolicy(true);\n+                schedulers[i] = stpe;\n+            }\n+            return schedulers;\n@@ -1480,1 +1499,0 @@\n-        return schedulers;\n@@ -1517,1 +1535,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":61,"deletions":43,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,0 @@\n-import java.util.concurrent.ScheduledExecutorService;\n@@ -589,5 +588,0 @@\n-    \/**\n-     * Returns a stream of the delayed task schedulers used for virtual threads.\n-     *\/\n-    Stream<ScheduledExecutorService> virtualThreadDelayedTaskSchedulers();\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,13 +53,0 @@\n-        \/\/ break\n-        sb.append(System.lineSeparator());\n-\n-        \/\/ delayed task schedulers\n-        sb.append(\"Delayed task schedulers:\").append(System.lineSeparator());\n-        var delayedTaskSchedulers = JLA.virtualThreadDelayedTaskSchedulers().toList();\n-        IntStream.range(0, delayedTaskSchedulers.size())\n-                .forEach(i -> sb.append('[')\n-                                .append(i)\n-                                .append(\"] \")\n-                                .append(delayedTaskSchedulers.get(i))\n-                                .append(System.lineSeparator()));\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/JcmdVThreadCommands.java","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-        \/\/ ensure default scheduler and timeout schedulers are initialized\n+        \/\/ ensure default scheduler is initialized\n@@ -66,3 +66,1 @@\n-                .shouldContain(Objects.toIdentityString(defaultScheduler()))\n-                .shouldContain(\"Delayed task schedulers:\")\n-                .shouldContain(\"[0] \" + ScheduledThreadPoolExecutor.class.getName());\n+                .shouldContain(Objects.toIdentityString(defaultScheduler()));\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/thread\/VThreadCommandsTest.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.LockSupport;\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 5, time = 10, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 10, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+public class VirtualThreadParking {\n+\n+    @Param({\"100\", \"1000\", \"10000\"})\n+    int threadCount;\n+\n+    \/**\n+     * Starts N threads that time-park, main thread unparks.\n+     *\/\n+    @Benchmark\n+    public void timedParkAndUnpark1() throws Exception {\n+        var threads = new Thread[threadCount];\n+        var unparked = new boolean[threadCount];\n+        for (int i = 0; i < threadCount; i++) {\n+            threads[i] = Thread.ofVirtual().start(() -> {\n+                LockSupport.parkNanos(Long.MAX_VALUE);\n+            });\n+        }\n+        int remaining = threadCount;\n+        while (remaining > 0) {\n+            for (int i = 0; i < threadCount; i++) {\n+                if (!unparked[i]) {\n+                    Thread t = threads[i];\n+                    if (t.getState() == Thread.State.TIMED_WAITING) {\n+                        LockSupport.unpark(t);\n+                        unparked[i] = true;\n+                        remaining--;\n+                    }\n+                }\n+            }\n+            if (remaining > 0) {\n+                Thread.yield();\n+            }\n+        }\n+        for (Thread t : threads) {\n+            t.join();\n+        }\n+    }\n+\n+    \/**\n+     * Starts N threads that time-park, start another N threads to unpark.\n+     *\/\n+    @Benchmark\n+    public void timedParkAndUnpark2() throws Exception {\n+        var threads = new Thread[threadCount * 2];\n+        for (int i = 0; i < threadCount; i++) {\n+            threads[i] = Thread.ofVirtual().start(() -> {\n+                LockSupport.parkNanos(Long.MAX_VALUE);\n+            });\n+        }\n+        for (int i = 0; i < threadCount; i++) {\n+            Thread thread1 = threads[i];\n+            Thread thread2 = Thread.ofVirtual().start(() -> {\n+                while (thread1.getState() != Thread.State.TIMED_WAITING) {\n+                    Thread.yield();\n+                }\n+                LockSupport.unpark(thread1);\n+            });\n+            threads[threadCount + i] = thread2;\n+        }\n+        for (Thread t : threads) {\n+            t.join();\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/VirtualThreadParking.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 5, time = 10, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 10, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n+\/\/@OutputTimeUnit(TimeUnit.SECONDS)\n+public class VirtualThreadSleep {\n+\n+    @Param({\"1000\", \"10000\", \"100000\"})\n+    int threadCount;\n+\n+    @Benchmark\n+    public void sleep10() throws Exception {\n+        var threads = new Thread[threadCount];\n+        for (int i = 0; i < threadCount; i++) {\n+            threads[i] = Thread.ofVirtual().start(() -> {\n+                try {\n+                    Thread.sleep(10);\n+                } catch (InterruptedException e) { }\n+            });\n+        }\n+        for (Thread t : threads) {\n+            t.join();\n+        }\n+    }\n+\n+    @Benchmark\n+    public void sleep10x10() throws Exception {\n+        var threads = new Thread[threadCount];\n+        for (int i = 0; i < threadCount; i++) {\n+            threads[i] = Thread.ofVirtual().start(() -> {\n+                try {\n+                    for (int k = 0; k < 10; k++) {\n+                        Thread.sleep(10);\n+                    }\n+                } catch (InterruptedException e) { }\n+            });\n+        }\n+        for (Thread t : threads) {\n+            t.join();\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/VirtualThreadSleep.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util.concurrent;\n+\n+import java.util.*;\n+import java.util.concurrent.*;\n+import java.util.function.Supplier;\n+import org.openjdk.jmh.annotations.*;\n+\n+\/**\n+ * Benchmark to compare delayed task scheduling with ScheduledThreadPoolExcutor and ForkJoinPool.\n+ *\/\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@Fork(value = 3)\n+@Warmup(iterations = 5, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 5, timeUnit = TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+public class DelayedTasks {\n+\n+    private Supplier<ScheduledExecutorService> stpeSupplier;\n+    private Supplier<ScheduledExecutorService> fjpSupplier;\n+\n+    @Setup\n+    public void setup() {\n+        stpeSupplier = () -> {\n+            ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);\n+            ((ScheduledThreadPoolExecutor) executor).setRemoveOnCancelPolicy(true);\n+            return executor;\n+        };\n+        int nprocs = Runtime.getRuntime().availableProcessors();\n+        fjpSupplier = () -> new ForkJoinPool(nprocs);\n+    }\n+\n+    @Param({\"100\", \"1000\", \"10000\"})\n+    int delayedTasks;\n+\n+    \/\/ delayed tasks cancelled by main thread\n+    private void mainThreadCancels(Supplier<ScheduledExecutorService> supplier) {\n+        try (ScheduledExecutorService ses = supplier.get()) {\n+            var futures = new ScheduledFuture[delayedTasks];\n+            for (int i = 0; i < delayedTasks; i++) {\n+                futures[i] = ses.schedule(() -> { }, 30L, TimeUnit.MINUTES);\n+            }\n+            for (ScheduledFuture<?> f : futures) {\n+                f.cancel(false);\n+            }\n+        }\n+    }\n+\n+    \/\/ delayed tasks cancelled by virtual threads\n+    private void virtualThreadCancels(Supplier<ScheduledExecutorService> supplier) throws Exception {\n+        try (ScheduledExecutorService ses = supplier.get()) {\n+            var futures = new ScheduledFuture[delayedTasks];\n+            var threads = new Thread[delayedTasks];\n+            for (int i = 0; i < delayedTasks; i++) {\n+                ScheduledFuture<?> future = ses.schedule(() -> { }, 30L, TimeUnit.MINUTES);\n+                futures[i] = future;\n+                threads[i] = Thread.ofVirtual().start(() -> future.cancel(false));\n+            }\n+            for (Thread t : threads) {\n+                t.join();\n+            }\n+        }\n+    }\n+\n+    \/\/ delayed task executes\n+    private void delayedTaskExecutes(Supplier<ScheduledExecutorService> supplier) throws Exception {\n+        try (ScheduledExecutorService ses = supplier.get()) {\n+            var futures = new ScheduledFuture[delayedTasks];\n+            for (int i = 0; i < delayedTasks; i++) {\n+                futures[i] = ses.schedule(() -> { }, 10L, TimeUnit.MILLISECONDS);\n+            }\n+            for (ScheduledFuture<?> f : futures) {\n+                f.get();\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void spteMainThreadCancels() {\n+        mainThreadCancels(stpeSupplier);\n+    }\n+\n+    @Benchmark\n+    public void spteVirtualThreadCancels() throws Exception {\n+        virtualThreadCancels(stpeSupplier);\n+    }\n+\n+    @Benchmark\n+    public void spteDelayedTaskExecutes() throws Exception {\n+        delayedTaskExecutes(stpeSupplier);\n+    }\n+\n+    @Benchmark\n+    public void fjpMainThreadCancels() {\n+        mainThreadCancels(fjpSupplier);\n+    }\n+\n+    @Benchmark\n+    public void fjpVirtualThreadCancels() throws Exception {\n+        virtualThreadCancels(fjpSupplier);\n+    }\n+\n+    @Benchmark\n+    public void fjpDelayedTaskExecutes() throws Exception {\n+        delayedTaskExecutes(fjpSupplier);\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/concurrent\/DelayedTasks.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"}]}