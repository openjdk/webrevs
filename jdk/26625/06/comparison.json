{"files":[{"patch":"@@ -128,1 +128,2 @@\n-if [ -d \"$TOPLEVEL_DIR\/.git\" ] ; then\n+# Git worktrees use a '.git' file rather than directory, so test both.\n+if [ -d \"$TOPLEVEL_DIR\/.git\" -o -f \"$TOPLEVEL_DIR\/.git\" ] ; then\n","filename":"bin\/idea.sh","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -75,1 +75,0 @@\n-<\/ul><\/li>\n@@ -77,3 +76,2 @@\n-id=\"toc-testing-ahead-of-time-optimizations\">### Testing Ahead-of-time\n-Optimizations<\/a>\n-<ul>\n+id=\"toc-testing-ahead-of-time-optimizations\">Testing Ahead-of-time\n+Optimizations<\/a><\/li>\n@@ -438,0 +436,3 @@\n+<h4 id=\"aot_jdk\">AOT_JDK<\/h4>\n+<p>See <a href=\"#testing-ahead-of-time-optimizations\">Testing\n+Ahead-of-time optimizations<\/a>.<\/p>\n@@ -559,0 +560,6 @@\n+<h4 id=\"test_jdk\">TEST_JDK<\/h4>\n+<p>The path to the JDK that will be used to run the benchmarks.<\/p>\n+<p>Defaults to <code>build\/&lt;CONF-NAME&gt;\/jdk<\/code>.<\/p>\n+<h4 id=\"benchmarks_jar\">BENCHMARKS_JAR<\/h4>\n+<p>The path to the JAR containing the benchmarks.<\/p>\n+<p>Defaults to <code>test\/micro\/benchmarks.jar<\/code>.<\/p>\n@@ -604,2 +611,2 @@\n-<h2 id=\"testing-ahead-of-time-optimizations\">### Testing Ahead-of-time\n-Optimizations<\/h2>\n+<h3 id=\"testing-ahead-of-time-optimizations\">Testing Ahead-of-time\n+Optimizations<\/h3>\n","filename":"doc\/testing.html","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -370,0 +370,4 @@\n+#### AOT_JDK\n+\n+See [Testing Ahead-of-time optimizations](#testing-ahead-of-time-optimizations).\n+\n@@ -548,0 +552,12 @@\n+#### TEST_JDK\n+\n+The path to the JDK that will be used to run the benchmarks.\n+\n+Defaults to `build\/<CONF-NAME>\/jdk`.\n+\n+#### BENCHMARKS_JAR\n+\n+The path to the JAR containing the benchmarks.\n+\n+Defaults to `test\/micro\/benchmarks.jar`.\n+\n@@ -615,1 +631,1 @@\n--------------------------------------------------------------------------------\n+\n","filename":"doc\/testing.md","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-THIS_SNIPPET := modules\/$(MODULE)\/Java.gmk\n+THIS_SNIPPET := $(call GetModuleSnippetName, Java)\n@@ -118,0 +118,1 @@\n+    TARGET_RELEASE := $(TARGET_RELEASE), \\\n","filename":"make\/CompileJavaModules.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -187,1 +187,1 @@\n-THIS_SNIPPET := modules\/$(MODULE)\/Jmod.gmk\n+THIS_SNIPPET := $(call GetModuleSnippetName, Jmod)\n","filename":"make\/CreateJmods.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -273,0 +273,1 @@\n+# These variables are read by SetupCopyDebuginfo\n","filename":"make\/Images.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1410,1 +1410,1 @@\n-CLEAN_PHASES := gensrc java native include\n+CLEAN_PHASES += gensrc java native include\n","filename":"make\/Main.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-PHASE_MAKEDIRS := $(TOPDIR)\/make\n+PHASE_MAKEDIRS += $(TOPDIR)\/make\n","filename":"make\/MainSupport.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+include Modules.gmk\n@@ -40,2 +41,4 @@\n-# Define the snippet for MakeSnippetStart\/End\n-THIS_SNIPPET := modules\/$(MODULE)\/$(MAKEFILE_PREFIX).gmk\n+################################################################################\n+# Include module specific build settings\n+\n+THIS_SNIPPET := $(call GetModuleSnippetName, $(MAKEFILE_PREFIX))\n@@ -43,1 +46,2 @@\n-include MakeSnippetStart.gmk\n+ifneq ($(wildcard $(THIS_SNIPPET)), )\n+  include MakeSnippetStart.gmk\n@@ -45,2 +49,2 @@\n-# Include the file being wrapped.\n-include $(THIS_SNIPPET)\n+  # Include the file being wrapped.\n+  include $(THIS_SNIPPET)\n@@ -48,1 +52,2 @@\n-include MakeSnippetEnd.gmk\n+  include MakeSnippetEnd.gmk\n+endif\n","filename":"make\/ModuleWrapper.gmk","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1246,1 +1246,1 @@\n-      $(TR) -cs '[a-z][A-Z][0-9]\\n' '[_*1000]')) \\\n+      $(TR) -cs '[a-z][A-Z][0-9]\\n' '_')) \\\n@@ -1326,1 +1326,1 @@\n-\t      $(TR) -cs '[a-z][A-Z][0-9]\\n' '[_*1000]')) \\\n+\t      $(TR) -cs '[a-z][A-Z][0-9]\\n' '_')) \\\n@@ -1328,1 +1328,1 @@\n-\t  $(eval NAME_PATTERN := $(shell $(ECHO) $(test) | $(TR) -c '\\n' '[_*1000]')) \\\n+\t  $(eval NAME_PATTERN := $(shell $(ECHO) $(test) | $(TR) -c '\\n' '_')) \\\n","filename":"make\/RunTests.gmk","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-    INCLUDES := compileproperties propertiesparser, \\\n+    INCLUDES := compileproperties flagsgenerator propertiesparser, \\\n","filename":"make\/ToolsLangtools.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -398,1 +398,1 @@\n-  OLDEST_BOOT_JDK=`$ECHO $DEFAULT_ACCEPTABLE_BOOT_VERSIONS \\\n+  OLDEST_BOOT_JDK_VERSION=`$ECHO $DEFAULT_ACCEPTABLE_BOOT_VERSIONS \\\n@@ -400,3 +400,1 @@\n-  # -Xlint:-options is added to avoid \"warning: [options] system modules path not set in conjunction with -source\"\n-  BOOT_JDK_SOURCETARGET=\"-source $OLDEST_BOOT_JDK -target $OLDEST_BOOT_JDK -Xlint:-options\"\n-  AC_SUBST(BOOT_JDK_SOURCETARGET)\n+  AC_SUBST(OLDEST_BOOT_JDK_VERSION)\n","filename":"make\/autoconf\/boot-jdk.m4","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -516,0 +516,4 @@\n+  if JVM_FEATURES_IS_ACTIVE(jfr) && ! JVM_FEATURES_IS_ACTIVE(services); then\n+    AC_MSG_ERROR([Specified JVM feature 'jfr' requires feature 'services' for variant '$variant'])\n+  fi\n+\n","filename":"make\/autoconf\/jvm-features.m4","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -396,3 +396,2 @@\n-# When compiling Java source to be run by the boot jdk\n-# use these extra flags, eg -source 6 -target 6\n-BOOT_JDK_SOURCETARGET := @BOOT_JDK_SOURCETARGET@\n+# The oldest supported boot jdk version\n+OLDEST_BOOT_JDK_VERSION := @OLDEST_BOOT_JDK_VERSION@\n","filename":"make\/autoconf\/spec.gmk.template","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -41,1 +41,4 @@\n-TARGET_RELEASE_BOOTJDK := $(BOOT_JDK_SOURCETARGET)\n+# -Xlint:-options is added to avoid the warning\n+# \"system modules path not set in conjunction with -source\"\n+TARGET_RELEASE_BOOTJDK := -source $(OLDEST_BOOT_JDK_VERSION) \\\n+    -target $(OLDEST_BOOT_JDK_VERSION) -Xlint:-options\n@@ -43,2 +46,4 @@\n-# Create classes that can be used in (or be a part of) the new jdk we're building\n-TARGET_RELEASE_NEWJDK := -source $(JDK_SOURCE_TARGET_VERSION) -target $(JDK_SOURCE_TARGET_VERSION)\n+# Create classes that can be used in (or be a part of) the new jdk we're\n+# building\n+TARGET_RELEASE_NEWJDK := -source $(JDK_SOURCE_TARGET_VERSION) \\\n+    -target $(JDK_SOURCE_TARGET_VERSION)\n@@ -181,0 +186,4 @@\n+  ifeq ($$($1_LOG_ACTION), )\n+    $1_LOG_ACTION := Compiling\n+  endif\n+\n@@ -475,1 +484,1 @@\n-\t\t$$(call LogWarn, Compiling up to $$(words $$($1_SRCS)) files for $1)\n+\t\t$$(call LogWarn, $$($1_LOG_ACTION) up to $$(words $$($1_SRCS)) files for $1)\n","filename":"make\/common\/JavaCompilation.gmk","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-    $(UPGRADEABLE_PLATFORM_MODULES)\n+    $(UPGRADEABLE_PLATFORM_MODULES) $(CUSTOM_UPGRADEABLE_PLATFORM_MODULES)\n@@ -219,1 +219,1 @@\n-  $(DEPS_$(strip $1))\n+  $(filter-out $(IMPORT_MODULES), $(DEPS_$(strip $1)))\n@@ -257,1 +257,2 @@\n-    $(sort $(filter-out $(MODULES_FILTER), $(UPGRADEABLE_PLATFORM_MODULES)))\n+    $(sort $(filter-out $(MODULES_FILTER), \\\n+    $(UPGRADEABLE_PLATFORM_MODULES) $(CUSTOM_UPGRADEABLE_PLATFORM_MODULES)))\n@@ -319,0 +320,13 @@\n+################################################################################\n+# Get a full snippet path for the current module and a given base name.\n+#\n+# Param 1 - The base name of the snippet file to include\n+GetModuleSnippetName = \\\n+  $(if $(CUSTOM_MODULE_MAKE_ROOT), \\\n+    $(if $(wildcard $(CUSTOM_MODULE_MAKE_ROOT)\/$(MODULE)\/$(strip $1).gmk), \\\n+      $(CUSTOM_MODULE_MAKE_ROOT)\/$(MODULE)\/$(strip $1).gmk, \\\n+      $(wildcard modules\/$(MODULE)\/$(strip $1).gmk) \\\n+    ), \\\n+    $(wildcard modules\/$(MODULE)\/$(strip $1).gmk) \\\n+  )\n+\n","filename":"make\/common\/Modules.gmk","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -15,0 +15,1 @@\n+\t\t\t\"oracle.oracle-java\",\n@@ -20,0 +21,4 @@\n+\n+\t\t\/\/ Java extension\n+\t\t\"jdk.project.jdkhome\": \"{{OUTPUTDIR}}\/jdk\",\n+\t\t\"jdk.java.onSave.organizeImports\": false, \/\/ prevents unnecessary changes\n","filename":"make\/ide\/vscode\/hotspot\/template-workspace.jsonc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package flagsgenerator;\n+\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.util.JavacTask;\n+import com.sun.source.util.TreePath;\n+import com.sun.source.util.Trees;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.util.ElementFilter;\n+import javax.tools.ToolProvider;\n+\n+public class FlagsGenerator {\n+    public static void main(String... args) throws IOException {\n+        var compiler = ToolProvider.getSystemJavaCompiler();\n+\n+        try (var fm = compiler.getStandardFileManager(null, null, null)) {\n+            JavacTask task = (JavacTask) compiler.getTask(null, null, d -> {}, null, null, fm.getJavaFileObjects(args[0]));\n+            Trees trees = Trees.instance(task);\n+            CompilationUnitTree cut = task.parse().iterator().next();\n+\n+            task.analyze();\n+\n+            TypeElement clazz = (TypeElement) trees.getElement(new TreePath(new TreePath(cut), cut.getTypeDecls().get(0)));\n+            Map<Integer, List<String>> flag2Names = new TreeMap<>();\n+            Map<FlagTarget, Map<Integer, List<String>>> target2FlagBit2Fields = new EnumMap<>(FlagTarget.class);\n+            Map<String, String> customToString = new HashMap<>();\n+            Set<String> noToString = new HashSet<>();\n+\n+            for (VariableElement field : ElementFilter.fieldsIn(clazz.getEnclosedElements())) {\n+                String flagName = field.getSimpleName().toString();\n+                for (AnnotationMirror am : field.getAnnotationMirrors()) {\n+                    switch (am.getAnnotationType().toString()) {\n+                        case \"com.sun.tools.javac.code.Flags.Use\" -> {\n+                            long flagValue = ((Number) field.getConstantValue()).longValue();\n+                            int flagBit = 63 - Long.numberOfLeadingZeros(flagValue);\n+\n+                            flag2Names.computeIfAbsent(flagBit, _ -> new ArrayList<>())\n+                                      .add(flagName);\n+\n+                            List<?> originalTargets = (List<?>) valueOfValueAttribute(am);\n+                            originalTargets.stream()\n+                                           .map(value -> FlagTarget.valueOf(value.toString()))\n+                                           .forEach(target -> target2FlagBit2Fields.computeIfAbsent(target, _ -> new HashMap<>())\n+                                                                                   .computeIfAbsent(flagBit, _ -> new ArrayList<>())\n+                                                                                   .add(flagName));\n+                        }\n+                        case \"com.sun.tools.javac.code.Flags.CustomToStringValue\" -> {\n+                            customToString.put(flagName, (String) valueOfValueAttribute(am));\n+                        }\n+                        case \"com.sun.tools.javac.code.Flags.NoToStringValue\" -> {\n+                            noToString.add(flagName);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            \/\/verify there are no flag overlaps:\n+            for (Entry<FlagTarget, Map<Integer, List<String>>> targetAndFlag : target2FlagBit2Fields.entrySet()) {\n+                for (Entry<Integer, List<String>> flagAndFields : targetAndFlag.getValue().entrySet()) {\n+                    if (flagAndFields.getValue().size() > 1) {\n+                        throw new AssertionError(\"duplicate flag for target: \" + targetAndFlag.getKey() +\n+                                                 \", flag: \" + flagAndFields.getKey() +\n+                                                 \", flags fields: \" + flagAndFields.getValue());\n+                    }\n+                }\n+            }\n+\n+            try (PrintWriter out = new PrintWriter(Files.newBufferedWriter(Paths.get(args[1])))) {\n+                out.println(\"\"\"\n+                            package com.sun.tools.javac.code;\n+\n+                            public enum FlagsEnum {\n+                            \"\"\");\n+                for (Entry<Integer, List<String>> e : flag2Names.entrySet()) {\n+                    String constantName = e.getValue().stream().collect(Collectors.joining(\"_OR_\"));\n+                    String toString = e.getValue()\n+                                       .stream()\n+                                       .filter(n -> !noToString.contains(n))\n+                                       .map(n -> customToString.getOrDefault(n, n.toLowerCase(Locale.US)))\n+                                       .collect(Collectors.joining(\" or \"));\n+                    out.println(\"    \" + constantName + \"(1L<<\" + e.getKey() + \", \\\"\" + toString + \"\\\"),\");\n+                }\n+                out.println(\"\"\"\n+                                ;\n+\n+                                private final long value;\n+                                private final String toString;\n+                                private FlagsEnum(long value, String toString) {\n+                                    this.value = value;\n+                                    this.toString = toString;\n+                                }\n+                                public long value() {\n+                                    return value;\n+                                }\n+                                public String toString() {\n+                                    return toString;\n+                                }\n+                            }\n+                            \"\"\");\n+            }\n+        }\n+    }\n+\n+    private static Object valueOfValueAttribute(AnnotationMirror am) {\n+        return am.getElementValues()\n+                 .values()\n+                 .iterator()\n+                 .next()\n+                 .getValue();\n+    }\n+\n+    private enum FlagTarget {\n+        BLOCK,\n+        CLASS,\n+        METHOD,\n+        MODULE,\n+        PACKAGE,\n+        TYPE_VAR,\n+        VARIABLE;\n+    }\n+}\n","filename":"make\/langtools\/tools\/flagsgenerator\/FlagsGenerator.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-        FLAG(\"flag\", \"Flag\", \"com.sun.tools.javac.code.Flags\"),\n+        FLAG(\"flag\", \"FlagsEnum\", \"com.sun.tools.javac.code\"),\n","filename":"make\/langtools\/tools\/propertiesparser\/parser\/MessageType.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,5 +44,0 @@\n-################################################################################\n-#\n-# Compile properties files into enum-like classes using the propertiesparser tool\n-#\n-\n@@ -55,0 +50,5 @@\n+################################################################################\n+#\n+# Compile properties files into enum-like classes using the propertiesparser tool\n+#\n+\n@@ -79,0 +79,23 @@\n+#\n+# Generate FlagsEnum from Flags constants\n+#\n+\n+TOOL_FLAGSGENERATOR_CMD := $(JAVA_SMALL) -cp $(BUILDTOOLS_OUTPUTDIR)\/langtools_tools_classes \\\n+    flagsgenerator.FlagsGenerator\n+\n+FLAGS_SRC := \\\n+    $(MODULE_SRC)\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java\n+\n+FLAGS_OUT := \\\n+    $(SUPPORT_OUTPUTDIR)\/gensrc\/$(MODULE)\/com\/sun\/tools\/javac\/code\/FlagsEnum.java\n+\n+$(eval $(call SetupExecute, FLAGSGENERATOR, \\\n+    WARN := Generating FlagsEnum, \\\n+    DEPS := $(FLAGS_SRC) $(BUILD_TOOLS_LANGTOOLS), \\\n+    OUTPUT_FILE := $(FLAGS_OUT), \\\n+    COMMAND := $(TOOL_FLAGSGENERATOR_CMD) $(FLAGS_SRC) $(FLAGS_OUT), \\\n+))\n+\n+TARGETS += $(FLAGSGENERATOR)\n+\n+################################################################################\n","filename":"make\/modules\/jdk.compiler\/Gensrc.gmk","additions":28,"deletions":5,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+TARGET_RELEASE := $(TARGET_RELEASE_BOOTJDK)\n+\n","filename":"make\/modules\/jdk.internal.vm.ci\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-  ## Build libwixhelper\n+  ## Build libmsica\n@@ -127,1 +127,1 @@\n-  # Build Wix custom action helper\n+  # Build MSI custom action library\n@@ -129,2 +129,2 @@\n-  $(eval $(call SetupJdkLibrary, BUILD_LIBWIXHELPER, \\\n-      NAME := wixhelper, \\\n+  $(eval $(call SetupJdkLibrary, BUILD_LIBMSICA, \\\n+      NAME := msica, \\\n@@ -132,1 +132,1 @@\n-      SYMBOLS_DIR := $(SUPPORT_OUTPUTDIR)\/native\/$(MODULE)\/libwixhelper, \\\n+      SYMBOLS_DIR := $(SUPPORT_OUTPUTDIR)\/native\/$(MODULE)\/libmsica, \\\n@@ -142,1 +142,1 @@\n-  TARGETS += $(BUILD_LIBWIXHELPER)\n+  TARGETS += $(BUILD_LIBMSICA)\n","filename":"make\/modules\/jdk.jpackage\/Lib.gmk","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -65,1 +65,2 @@\n-      exelauncher.c libFDLeaker.c exeFDLeakTester.c\n+      exelauncher.c libFDLeaker.c exeFDLeakTester.c \\\n+      libChangeSignalDisposition.c exePrintSignalDisposition.c\n","filename":"make\/test\/JtregNativeJdk.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -16284,32 +16284,0 @@\n-instruct cmpFastLock(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp, iRegPNoSp tmp2, iRegPNoSp tmp3)\n-%{\n-  predicate(LockingMode != LM_LIGHTWEIGHT);\n-  match(Set cr (FastLock object box));\n-  effect(TEMP tmp, TEMP tmp2, TEMP tmp3);\n-\n-  ins_cost(5 * INSN_COST);\n-  format %{ \"fastlock $object,$box\\t! kills $tmp,$tmp2,$tmp3\" %}\n-\n-  ins_encode %{\n-    __ fast_lock($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register, $tmp3$$Register);\n-  %}\n-\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct cmpFastUnlock(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp, iRegPNoSp tmp2)\n-%{\n-  predicate(LockingMode != LM_LIGHTWEIGHT);\n-  match(Set cr (FastUnlock object box));\n-  effect(TEMP tmp, TEMP tmp2);\n-\n-  ins_cost(5 * INSN_COST);\n-  format %{ \"fastunlock $object,$box\\t! kills $tmp, $tmp2\" %}\n-\n-  ins_encode %{\n-    __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register);\n-  %}\n-\n-  ins_pipe(pipe_serial);\n-%}\n-\n@@ -16318,1 +16286,0 @@\n-  predicate(LockingMode == LM_LIGHTWEIGHT);\n@@ -16334,1 +16301,0 @@\n-  predicate(LockingMode == LM_LIGHTWEIGHT);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":0,"deletions":34,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -413,5 +413,1 @@\n-    if (LockingMode == LM_MONITOR) {\n-      __ b(*stub->entry());\n-    } else {\n-      __ unlock_object(r5, r4, r0, r6, *stub->entry());\n-    }\n+    __ unlock_object(r5, r4, r0, r6, *stub->entry());\n@@ -2487,7 +2483,1 @@\n-  if (LockingMode == LM_MONITOR) {\n-    if (op->info() != nullptr) {\n-      add_debug_info_for_null_check_here(op->info());\n-      __ null_check(obj, -1);\n-    }\n-    __ b(*op->stub()->entry());\n-  } else if (op->code() == lir_lock) {\n+  if (op->code() == lir_lock) {\n@@ -2826,1 +2816,1 @@\n-  __ lea(dest->as_register_lo(), as_Address(addr->as_address_ptr()));\n+  __ lea(dest->as_pointer_register(), as_Address(addr->as_address_ptr()));\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -984,1 +984,1 @@\n-      LIR_Opr addr = new_pointer_register();\n+      LIR_Opr addr = new_register(T_ADDRESS);\n@@ -1061,1 +1061,1 @@\n-      LIR_Opr addr = new_pointer_register();\n+      LIR_Opr addr = new_register(T_ADDRESS);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -63,2 +63,0 @@\n-  const int aligned_mask = BytesPerWord -1;\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n@@ -75,49 +73,2 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lightweight_lock(disp_hdr, obj, hdr, temp, rscratch2, slow_case);\n-  } else if (LockingMode == LM_LEGACY) {\n-\n-    if (DiagnoseSyncOnValueBasedClasses != 0) {\n-      load_klass(hdr, obj);\n-      ldrb(hdr, Address(hdr, Klass::misc_flags_offset()));\n-      tst(hdr, KlassFlags::_misc_is_value_based_class);\n-      br(Assembler::NE, slow_case);\n-    }\n-\n-    Label done;\n-    \/\/ Load object header\n-    ldr(hdr, Address(obj, hdr_offset));\n-    \/\/ and mark it as unlocked\n-    orr(hdr, hdr, markWord::unlocked_value);\n-    \/\/ save unlocked object header into the displaced header location on the stack\n-    str(hdr, Address(disp_hdr, 0));\n-    \/\/ test if object header is still the same (i.e. unlocked), and if so, store the\n-    \/\/ displaced header address in the object header - if it is not the same, get the\n-    \/\/ object header instead\n-    lea(rscratch2, Address(obj, hdr_offset));\n-    cmpxchgptr(hdr, disp_hdr, rscratch2, rscratch1, done, \/*fallthough*\/nullptr);\n-    \/\/ if the object header was the same, we're done\n-    \/\/ if the object header was not the same, it is now in the hdr register\n-    \/\/ => test if it is a stack pointer into the same stack (recursive locking), i.e.:\n-    \/\/\n-    \/\/ 1) (hdr & aligned_mask) == 0\n-    \/\/ 2) sp <= hdr\n-    \/\/ 3) hdr <= sp + page_size\n-    \/\/\n-    \/\/ these 3 tests can be done by evaluating the following expression:\n-    \/\/\n-    \/\/ (hdr - sp) & (aligned_mask - page_size)\n-    \/\/\n-    \/\/ assuming both the stack pointer and page_size have their least\n-    \/\/ significant 2 bits cleared and page_size is a power of 2\n-    mov(rscratch1, sp);\n-    sub(hdr, hdr, rscratch1);\n-    ands(hdr, hdr, aligned_mask - (int)os::vm_page_size());\n-    \/\/ for recursive locking, the result is zero => save it in the displaced header\n-    \/\/ location (null in the displaced hdr location indicates recursive locking)\n-    str(hdr, Address(disp_hdr, 0));\n-    \/\/ otherwise we don't care about the result and handle locking via runtime call\n-    cbnz(hdr, slow_case);\n-    \/\/ done\n-    bind(done);\n-    inc_held_monitor_count(rscratch1);\n-  }\n+  lightweight_lock(disp_hdr, obj, hdr, temp, rscratch2, slow_case);\n+\n@@ -129,2 +80,0 @@\n-  const int aligned_mask = BytesPerWord -1;\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n@@ -132,9 +81,0 @@\n-  Label done;\n-\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    \/\/ load displaced header\n-    ldr(hdr, Address(disp_hdr, 0));\n-    \/\/ if the loaded hdr is null we had recursive locking\n-    \/\/ if we had recursive locking, we are done\n-    cbz(hdr, done);\n-  }\n@@ -146,18 +86,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lightweight_unlock(obj, hdr, temp, rscratch2, slow_case);\n-  } else if (LockingMode == LM_LEGACY) {\n-    \/\/ test if object header is pointing to the displaced header, and if so, restore\n-    \/\/ the displaced header in the object - if the object header is not pointing to\n-    \/\/ the displaced header, get the object header instead\n-    \/\/ if the object header was not pointing to the displaced header,\n-    \/\/ we do unlocking via runtime call\n-    if (hdr_offset) {\n-      lea(rscratch1, Address(obj, hdr_offset));\n-      cmpxchgptr(disp_hdr, hdr, rscratch1, rscratch2, done, &slow_case);\n-    } else {\n-      cmpxchgptr(disp_hdr, hdr, obj, rscratch2, done, &slow_case);\n-    }\n-    \/\/ done\n-    bind(done);\n-    dec_held_monitor_count(rscratch1);\n-  }\n+  lightweight_unlock(obj, hdr, temp, rscratch2, slow_case);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":3,"deletions":80,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -150,206 +150,0 @@\n-void C2_MacroAssembler::fast_lock(Register objectReg, Register boxReg, Register tmpReg,\n-                                  Register tmp2Reg, Register tmp3Reg) {\n-  Register oop = objectReg;\n-  Register box = boxReg;\n-  Register disp_hdr = tmpReg;\n-  Register tmp = tmp2Reg;\n-  Label cont;\n-  Label object_has_monitor;\n-  Label count, no_count;\n-\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"lightweight locking should use fast_lock_lightweight\");\n-  assert_different_registers(oop, box, tmp, disp_hdr, rscratch2);\n-\n-  \/\/ Load markWord from object into displaced_header.\n-  ldr(disp_hdr, Address(oop, oopDesc::mark_offset_in_bytes()));\n-\n-  if (DiagnoseSyncOnValueBasedClasses != 0) {\n-    load_klass(tmp, oop);\n-    ldrb(tmp, Address(tmp, Klass::misc_flags_offset()));\n-    tst(tmp, KlassFlags::_misc_is_value_based_class);\n-    br(Assembler::NE, cont);\n-  }\n-\n-  \/\/ Check for existing monitor\n-  tbnz(disp_hdr, exact_log2(markWord::monitor_value), object_has_monitor);\n-\n-  if (LockingMode == LM_MONITOR) {\n-    tst(oop, oop); \/\/ Set NE to indicate 'failure' -> take slow-path. We know that oop != 0.\n-    b(cont);\n-  } else {\n-    assert(LockingMode == LM_LEGACY, \"must be\");\n-    \/\/ Set tmp to be (markWord of object | UNLOCK_VALUE).\n-    orr(tmp, disp_hdr, markWord::unlocked_value);\n-\n-    \/\/ Initialize the box. (Must happen before we update the object mark!)\n-    str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-    \/\/ Compare object markWord with an unlocked value (tmp) and if\n-    \/\/ equal exchange the stack address of our box with object markWord.\n-    \/\/ On failure disp_hdr contains the possibly locked markWord.\n-    cmpxchg(oop, tmp, box, Assembler::xword, \/*acquire*\/ true,\n-            \/*release*\/ true, \/*weak*\/ false, disp_hdr);\n-    br(Assembler::EQ, cont);\n-\n-    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-    \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n-    \/\/ object, will have now locked it will continue at label cont\n-\n-    \/\/ Check if the owner is self by comparing the value in the\n-    \/\/ markWord of object (disp_hdr) with the stack pointer.\n-    mov(rscratch1, sp);\n-    sub(disp_hdr, disp_hdr, rscratch1);\n-    mov(tmp, (address) (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n-    \/\/ If condition is true we are cont and hence we can store 0 as the\n-    \/\/ displaced header in the box, which indicates that it is a recursive lock.\n-    ands(tmp\/*==0?*\/, disp_hdr, tmp);   \/\/ Sets flags for result\n-    str(tmp\/*==0, perhaps*\/, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-    b(cont);\n-  }\n-\n-  \/\/ Handle existing monitor.\n-  bind(object_has_monitor);\n-\n-  \/\/ Try to CAS owner (no owner => current thread's _monitor_owner_id).\n-  ldr(rscratch2, Address(rthread, JavaThread::monitor_owner_id_offset()));\n-  add(tmp, disp_hdr, (in_bytes(ObjectMonitor::owner_offset())-markWord::monitor_value));\n-  cmpxchg(tmp, zr, rscratch2, Assembler::xword, \/*acquire*\/ true,\n-          \/*release*\/ true, \/*weak*\/ false, tmp3Reg); \/\/ Sets flags for result\n-\n-  \/\/ Store a non-null value into the box to avoid looking like a re-entrant\n-  \/\/ lock. The fast-path monitor unlock code checks for\n-  \/\/ markWord::monitor_value so use markWord::unused_mark which has the\n-  \/\/ relevant bit set, and also matches ObjectSynchronizer::enter.\n-  mov(tmp, (address)markWord::unused_mark().value());\n-  str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-  br(Assembler::EQ, cont); \/\/ CAS success means locking succeeded\n-\n-  cmp(tmp3Reg, rscratch2);\n-  br(Assembler::NE, cont); \/\/ Check for recursive locking\n-\n-  \/\/ Recursive lock case\n-  increment(Address(disp_hdr, in_bytes(ObjectMonitor::recursions_offset()) - markWord::monitor_value), 1);\n-  \/\/ flag == EQ still from the cmp above, checking if this is a reentrant lock\n-\n-  bind(cont);\n-  \/\/ flag == EQ indicates success\n-  \/\/ flag == NE indicates failure\n-  br(Assembler::NE, no_count);\n-\n-  bind(count);\n-  if (LockingMode == LM_LEGACY) {\n-    inc_held_monitor_count(rscratch1);\n-  }\n-\n-  bind(no_count);\n-}\n-\n-void C2_MacroAssembler::fast_unlock(Register objectReg, Register boxReg, Register tmpReg,\n-                                    Register tmp2Reg) {\n-  Register oop = objectReg;\n-  Register box = boxReg;\n-  Register disp_hdr = tmpReg;\n-  Register owner_addr = tmpReg;\n-  Register tmp = tmp2Reg;\n-  Label cont;\n-  Label object_has_monitor;\n-  Label count, no_count;\n-  Label unlocked;\n-\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"lightweight locking should use fast_unlock_lightweight\");\n-  assert_different_registers(oop, box, tmp, disp_hdr);\n-\n-  if (LockingMode == LM_LEGACY) {\n-    \/\/ Find the lock address and load the displaced header from the stack.\n-    ldr(disp_hdr, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-    \/\/ If the displaced header is 0, we have a recursive unlock.\n-    cmp(disp_hdr, zr);\n-    br(Assembler::EQ, cont);\n-  }\n-\n-  \/\/ Handle existing monitor.\n-  ldr(tmp, Address(oop, oopDesc::mark_offset_in_bytes()));\n-  tbnz(tmp, exact_log2(markWord::monitor_value), object_has_monitor);\n-\n-  if (LockingMode == LM_MONITOR) {\n-    tst(oop, oop); \/\/ Set NE to indicate 'failure' -> take slow-path. We know that oop != 0.\n-    b(cont);\n-  } else {\n-    assert(LockingMode == LM_LEGACY, \"must be\");\n-    \/\/ Check if it is still a light weight lock, this is is true if we\n-    \/\/ see the stack address of the basicLock in the markWord of the\n-    \/\/ object.\n-\n-    cmpxchg(oop, box, disp_hdr, Assembler::xword, \/*acquire*\/ false,\n-            \/*release*\/ true, \/*weak*\/ false, tmp);\n-    b(cont);\n-  }\n-\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-  \/\/ Handle existing monitor.\n-  bind(object_has_monitor);\n-  STATIC_ASSERT(markWord::monitor_value <= INT_MAX);\n-  add(tmp, tmp, -(int)markWord::monitor_value); \/\/ monitor\n-\n-  ldr(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n-\n-  Label notRecursive;\n-  cbz(disp_hdr, notRecursive);\n-\n-  \/\/ Recursive lock\n-  sub(disp_hdr, disp_hdr, 1u);\n-  str(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n-  cmp(disp_hdr, disp_hdr); \/\/ Sets flags for result\n-  b(cont);\n-\n-  bind(notRecursive);\n-\n-  \/\/ Compute owner address.\n-  lea(owner_addr, Address(tmp, ObjectMonitor::owner_offset()));\n-\n-  \/\/ Set owner to null.\n-  \/\/ Release to satisfy the JMM\n-  stlr(zr, owner_addr);\n-  \/\/ We need a full fence after clearing owner to avoid stranding.\n-  \/\/ StoreLoad achieves this.\n-  membar(StoreLoad);\n-\n-  \/\/ Check if the entry_list is empty.\n-  ldr(rscratch1, Address(tmp, ObjectMonitor::entry_list_offset()));\n-  cmp(rscratch1, zr);\n-  br(Assembler::EQ, cont);     \/\/ If so we are done.\n-\n-  \/\/ Check if there is a successor.\n-  ldr(rscratch1, Address(tmp, ObjectMonitor::succ_offset()));\n-  cmp(rscratch1, zr);\n-  br(Assembler::NE, unlocked); \/\/ If so we are done.\n-\n-  \/\/ Save the monitor pointer in the current thread, so we can try to\n-  \/\/ reacquire the lock in SharedRuntime::monitor_exit_helper().\n-  str(tmp, Address(rthread, JavaThread::unlocked_inflated_monitor_offset()));\n-\n-  cmp(zr, rthread); \/\/ Set Flag to NE => slow path\n-  b(cont);\n-\n-  bind(unlocked);\n-  cmp(zr, zr); \/\/ Set Flag to EQ => fast path\n-\n-  \/\/ Intentional fall-through\n-\n-  bind(cont);\n-  \/\/ flag == EQ indicates success\n-  \/\/ flag == NE indicates failure\n-  br(Assembler::NE, no_count);\n-\n-  bind(count);\n-  if (LockingMode == LM_LEGACY) {\n-    dec_held_monitor_count(rscratch1);\n-  }\n-\n-  bind(no_count);\n-}\n-\n@@ -358,1 +152,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n@@ -515,1 +308,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":0,"deletions":208,"binary":false,"changes":208,"status":"modified"},{"patch":"@@ -54,3 +54,0 @@\n-  \/\/ Code used by cmpFastLock and cmpFastUnlock mach instructions in .ad file.\n-  void fast_lock(Register object, Register box, Register tmp, Register tmp2, Register tmp3);\n-  void fast_unlock(Register object, Register box, Register tmp, Register tmp2);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -694,34 +694,0 @@\n-  if (LockingMode == LM_MONITOR) {\n-    call_VM_preemptable(noreg,\n-            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n-            lock_reg);\n-  } else {\n-    Label count, done;\n-\n-    const Register swap_reg = r0;\n-    const Register tmp = c_rarg2;\n-    const Register obj_reg = c_rarg3; \/\/ Will contain the oop\n-    const Register tmp2 = c_rarg4;\n-    const Register tmp3 = c_rarg5;\n-\n-    const int obj_offset = in_bytes(BasicObjectLock::obj_offset());\n-    const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n-    const int mark_offset = lock_offset +\n-                            BasicLock::displaced_header_offset_in_bytes();\n-\n-    Label slow_case;\n-\n-    \/\/ Load object pointer into obj_reg %c_rarg3\n-    ldr(obj_reg, Address(lock_reg, obj_offset));\n-\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      lightweight_lock(lock_reg, obj_reg, tmp, tmp2, tmp3, slow_case);\n-      b(done);\n-    } else if (LockingMode == LM_LEGACY) {\n-\n-      if (DiagnoseSyncOnValueBasedClasses != 0) {\n-        load_klass(tmp, obj_reg);\n-        ldrb(tmp, Address(tmp, Klass::misc_flags_offset()));\n-        tst(tmp, KlassFlags::_misc_is_value_based_class);\n-        br(Assembler::NE, slow_case);\n-      }\n@@ -729,55 +695,4 @@\n-      \/\/ Load (object->mark() | 1) into swap_reg\n-      ldr(rscratch1, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-      orr(swap_reg, rscratch1, 1);\n-\n-      \/\/ Save (object->mark() | 1) into BasicLock's displaced header\n-      str(swap_reg, Address(lock_reg, mark_offset));\n-\n-      assert(lock_offset == 0,\n-             \"displached header must be first word in BasicObjectLock\");\n-\n-      Label fail;\n-      cmpxchg_obj_header(swap_reg, lock_reg, obj_reg, rscratch1, count, \/*fallthrough*\/nullptr);\n-\n-      \/\/ Fast check for recursive lock.\n-      \/\/\n-      \/\/ Can apply the optimization only if this is a stack lock\n-      \/\/ allocated in this thread. For efficiency, we can focus on\n-      \/\/ recently allocated stack locks (instead of reading the stack\n-      \/\/ base and checking whether 'mark' points inside the current\n-      \/\/ thread stack):\n-      \/\/  1) (mark & 7) == 0, and\n-      \/\/  2) sp <= mark < mark + os::pagesize()\n-      \/\/\n-      \/\/ Warning: sp + os::pagesize can overflow the stack base. We must\n-      \/\/ neither apply the optimization for an inflated lock allocated\n-      \/\/ just above the thread stack (this is why condition 1 matters)\n-      \/\/ nor apply the optimization if the stack lock is inside the stack\n-      \/\/ of another thread. The latter is avoided even in case of overflow\n-      \/\/ because we have guard pages at the end of all stacks. Hence, if\n-      \/\/ we go over the stack base and hit the stack of another thread,\n-      \/\/ this should not be in a writeable area that could contain a\n-      \/\/ stack lock allocated by that thread. As a consequence, a stack\n-      \/\/ lock less than page size away from sp is guaranteed to be\n-      \/\/ owned by the current thread.\n-      \/\/\n-      \/\/ These 3 tests can be done by evaluating the following\n-      \/\/ expression: ((mark - sp) & (7 - os::vm_page_size())),\n-      \/\/ assuming both stack pointer and pagesize have their\n-      \/\/ least significant 3 bits clear.\n-      \/\/ NOTE: the mark is in swap_reg %r0 as the result of cmpxchg\n-      \/\/ NOTE2: aarch64 does not like to subtract sp from rn so take a\n-      \/\/ copy\n-      mov(rscratch1, sp);\n-      sub(swap_reg, swap_reg, rscratch1);\n-      ands(swap_reg, swap_reg, (uint64_t)(7 - (int)os::vm_page_size()));\n-\n-      \/\/ Save the test result, for recursive case, the result is zero\n-      str(swap_reg, Address(lock_reg, mark_offset));\n-      br(Assembler::NE, slow_case);\n-\n-      bind(count);\n-      inc_held_monitor_count(rscratch1);\n-      b(done);\n-    }\n-    bind(slow_case);\n+  const Register tmp = c_rarg2;\n+  const Register obj_reg = c_rarg3; \/\/ Will contain the oop\n+  const Register tmp2 = c_rarg4;\n+  const Register tmp3 = c_rarg5;\n@@ -785,4 +700,2 @@\n-    \/\/ Call the runtime routine for slow case\n-    call_VM_preemptable(noreg,\n-            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n-            lock_reg);\n+  \/\/ Load object pointer into obj_reg %c_rarg3\n+  ldr(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset()));\n@@ -790,2 +703,12 @@\n-    bind(done);\n-  }\n+  Label slow_case, done;\n+  lightweight_lock(lock_reg, obj_reg, tmp, tmp2, tmp3, slow_case);\n+  b(done);\n+\n+  bind(slow_case);\n+\n+  \/\/ Call the runtime routine for slow case\n+  call_VM_preemptable(noreg,\n+          CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n+          lock_reg);\n+\n+  bind(done);\n@@ -810,20 +733,4 @@\n-  if (LockingMode == LM_MONITOR) {\n-    call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), lock_reg);\n-  } else {\n-    Label count, done;\n-\n-    const Register swap_reg   = r0;\n-    const Register header_reg = c_rarg2;  \/\/ Will contain the old oopMark\n-    const Register obj_reg    = c_rarg3;  \/\/ Will contain the oop\n-    const Register tmp_reg    = c_rarg4;  \/\/ Temporary used by lightweight_unlock\n-\n-    save_bcp(); \/\/ Save in case of exception\n-\n-    if (LockingMode != LM_LIGHTWEIGHT) {\n-      \/\/ Convert from BasicObjectLock structure to object and BasicLock\n-      \/\/ structure Store the BasicLock address into %r0\n-      lea(swap_reg, Address(lock_reg, BasicObjectLock::lock_offset()));\n-    }\n-\n-    \/\/ Load oop into obj_reg(%c_rarg3)\n-    ldr(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset()));\n+  const Register swap_reg   = r0;\n+  const Register header_reg = c_rarg2;  \/\/ Will contain the old oopMark\n+  const Register obj_reg    = c_rarg3;  \/\/ Will contain the oop\n+  const Register tmp_reg    = c_rarg4;  \/\/ Temporary used by lightweight_unlock\n@@ -831,2 +738,1 @@\n-    \/\/ Free entry\n-    str(zr, Address(lock_reg, BasicObjectLock::obj_offset()));\n+  save_bcp(); \/\/ Save in case of exception\n@@ -834,8 +740,2 @@\n-    Label slow_case;\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      lightweight_unlock(obj_reg, header_reg, swap_reg, tmp_reg, slow_case);\n-      b(done);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ Load the old header from BasicLock structure\n-      ldr(header_reg, Address(swap_reg,\n-                              BasicLock::displaced_header_offset_in_bytes()));\n+  \/\/ Load oop into obj_reg(%c_rarg3)\n+  ldr(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset()));\n@@ -843,2 +743,2 @@\n-      \/\/ Test for recursion\n-      cbz(header_reg, count);\n+  \/\/ Free entry\n+  str(zr, Address(lock_reg, BasicObjectLock::obj_offset()));\n@@ -846,7 +746,3 @@\n-      \/\/ Atomic swap back the old header\n-      cmpxchg_obj_header(swap_reg, header_reg, obj_reg, rscratch1, count, &slow_case);\n-\n-      bind(count);\n-      dec_held_monitor_count(rscratch1);\n-      b(done);\n-    }\n+  Label slow_case, done;\n+  lightweight_unlock(obj_reg, header_reg, swap_reg, tmp_reg, slow_case);\n+  b(done);\n@@ -854,7 +750,6 @@\n-    bind(slow_case);\n-    \/\/ Call the runtime routine for slow case.\n-    str(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset())); \/\/ restore obj\n-    call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), lock_reg);\n-    bind(done);\n-    restore_bcp();\n-  }\n+  bind(slow_case);\n+  \/\/ Call the runtime routine for slow case.\n+  str(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset())); \/\/ restore obj\n+  call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), lock_reg);\n+  bind(done);\n+  restore_bcp();\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":36,"deletions":141,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -7100,1 +7100,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n@@ -7160,1 +7159,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1724,1 +1724,1 @@\n-  if (LockingMode != LM_LEGACY && method->is_object_wait0()) {\n+  if (method->is_object_wait0()) {\n@@ -1779,38 +1779,1 @@\n-    if (LockingMode == LM_MONITOR) {\n-      __ b(slow_path_lock);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ Load (object->mark() | 1) into swap_reg %r0\n-      __ ldr(rscratch1, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-      __ orr(swap_reg, rscratch1, 1);\n-\n-      \/\/ Save (object->mark() | 1) into BasicLock's displaced header\n-      __ str(swap_reg, Address(lock_reg, mark_word_offset));\n-\n-      \/\/ src -> dest iff dest == r0 else r0 <- dest\n-      __ cmpxchg_obj_header(r0, lock_reg, obj_reg, rscratch1, count, \/*fallthrough*\/nullptr);\n-\n-      \/\/ Hmm should this move to the slow path code area???\n-\n-      \/\/ Test if the oopMark is an obvious stack pointer, i.e.,\n-      \/\/  1) (mark & 3) == 0, and\n-      \/\/  2) sp <= mark < mark + os::pagesize()\n-      \/\/ These 3 tests can be done by evaluating the following\n-      \/\/ expression: ((mark - sp) & (3 - os::vm_page_size())),\n-      \/\/ assuming both stack pointer and pagesize have their\n-      \/\/ least significant 2 bits clear.\n-      \/\/ NOTE: the oopMark is in swap_reg %r0 as the result of cmpxchg\n-\n-      __ sub(swap_reg, sp, swap_reg);\n-      __ neg(swap_reg, swap_reg);\n-      __ ands(swap_reg, swap_reg, 3 - (int)os::vm_page_size());\n-\n-      \/\/ Save the test result, for recursive case, the result is zero\n-      __ str(swap_reg, Address(lock_reg, mark_word_offset));\n-      __ br(Assembler::NE, slow_path_lock);\n-\n-      __ bind(count);\n-      __ inc_held_monitor_count(rscratch1);\n-    } else {\n-      assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-      __ lightweight_lock(lock_reg, obj_reg, swap_reg, tmp, lock_tmp, slow_path_lock);\n-    }\n+    __ lightweight_lock(lock_reg, obj_reg, swap_reg, tmp, lock_tmp, slow_path_lock);\n@@ -1891,1 +1854,1 @@\n-  if (LockingMode != LM_LEGACY && method->is_object_wait0()) {\n+  if (method->is_object_wait0()) {\n@@ -1920,12 +1883,0 @@\n-    Label done, not_recursive;\n-\n-    if (LockingMode == LM_LEGACY) {\n-      \/\/ Simple recursive lock?\n-      __ ldr(rscratch1, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));\n-      __ cbnz(rscratch1, not_recursive);\n-      __ dec_held_monitor_count(rscratch1);\n-      __ b(done);\n-    }\n-\n-    __ bind(not_recursive);\n-\n@@ -1937,17 +1888,1 @@\n-    if (LockingMode == LM_MONITOR) {\n-      __ b(slow_path_unlock);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ get address of the stack lock\n-      __ lea(r0, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));\n-      \/\/  get old displaced header\n-      __ ldr(old_hdr, Address(r0, 0));\n-\n-      \/\/ Atomic swap old header if oop still contains the stack lock\n-      Label count;\n-      __ cmpxchg_obj_header(r0, old_hdr, obj_reg, rscratch1, count, &slow_path_unlock);\n-      __ bind(count);\n-      __ dec_held_monitor_count(rscratch1);\n-    } else {\n-      assert(LockingMode == LM_LIGHTWEIGHT, \"\");\n-      __ lightweight_unlock(obj_reg, old_hdr, swap_reg, lock_tmp, slow_path_unlock);\n-    }\n+    __ lightweight_unlock(obj_reg, old_hdr, swap_reg, lock_tmp, slow_path_unlock);\n@@ -1960,2 +1895,0 @@\n-\n-    __ bind(done);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":4,"deletions":71,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -1481,16 +1481,11 @@\n-  if (LockingMode != LM_LEGACY) {\n-    \/\/ Check preemption for Object.wait()\n-    Label not_preempted;\n-    __ ldr(rscratch1, Address(rthread, JavaThread::preempt_alternate_return_offset()));\n-    __ cbz(rscratch1, not_preempted);\n-    __ str(zr, Address(rthread, JavaThread::preempt_alternate_return_offset()));\n-    __ br(rscratch1);\n-    __ bind(native_return);\n-    __ restore_after_resume(true \/* is_native *\/);\n-    \/\/ reload result_handler\n-    __ ldr(result_handler, Address(rfp, frame::interpreter_frame_result_handler_offset*wordSize));\n-    __ bind(not_preempted);\n-  } else {\n-    \/\/ any pc will do so just use this one for LM_LEGACY to keep code together.\n-    __ bind(native_return);\n-  }\n+  \/\/ Check preemption for Object.wait()\n+  Label not_preempted;\n+  __ ldr(rscratch1, Address(rthread, JavaThread::preempt_alternate_return_offset()));\n+  __ cbz(rscratch1, not_preempted);\n+  __ str(zr, Address(rthread, JavaThread::preempt_alternate_return_offset()));\n+  __ br(rscratch1);\n+  __ bind(native_return);\n+  __ restore_after_resume(true \/* is_native *\/);\n+  \/\/ reload result_handler\n+  __ ldr(result_handler, Address(rfp, frame::interpreter_frame_result_handler_offset*wordSize));\n+  __ bind(not_preempted);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":11,"deletions":16,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"utilities\/ostream.hpp\"\n@@ -53,0 +54,2 @@\n+const char* VM_Version::_features_names[MAX_CPU_FEATURES] = { nullptr };\n+\n@@ -63,0 +66,5 @@\n+#define SET_CPU_FEATURE_NAME(id, name, bit) \\\n+  _features_names[bit] = XSTR(name);\n+  CPU_FEATURE_FLAGS(SET_CPU_FEATURE_NAME)\n+#undef SET_CPU_FEATURE_NAME\n+\n@@ -197,1 +205,1 @@\n-    _features |= CPU_A53MAC;\n+    set_feature(CPU_A53MAC);\n@@ -237,1 +245,1 @@\n-  if (_features & (CPU_FP | CPU_ASIMD)) {\n+  if (supports_feature(CPU_FP) || supports_feature(CPU_ASIMD)) {\n@@ -400,1 +408,1 @@\n-  if (_features & CPU_ASIMD) {\n+  if (supports_feature(CPU_ASIMD)) {\n@@ -411,1 +419,1 @@\n-  if (_features & CPU_ASIMD) {\n+  if (supports_feature(CPU_ASIMD)) {\n@@ -422,1 +430,1 @@\n-  if (_features & CPU_ASIMD) {\n+  if (supports_feature(CPU_ASIMD)) {\n@@ -623,2 +631,2 @@\n-    _features &= ~CPU_SVE2;\n-    _features &= ~CPU_SVEBITPERM;\n+    clear_feature(CPU_SVE2);\n+    clear_feature(CPU_SVEBITPERM);\n@@ -627,1 +635,1 @@\n-    _features &= ~CPU_SVE;\n+    clear_feature(CPU_SVE);\n@@ -631,2 +639,2 @@\n-  char buf[512];\n-  int buf_used_len = os::snprintf_checked(buf, sizeof(buf), \"0x%02x:0x%x:0x%03x:%d\", _cpu, _variant, _model, _revision);\n+  stringStream ss(512);\n+  ss.print(\"0x%02x:0x%x:0x%03x:%d\", _cpu, _variant, _model, _revision);\n@@ -634,1 +642,1 @@\n-    os::snprintf_checked(buf + buf_used_len, sizeof(buf) - buf_used_len, \"(0x%03x)\", _model2);\n+    ss.print(\"(0x%03x)\", _model2);\n@@ -636,7 +644,3 @@\n-  size_t features_offset = strnlen(buf, sizeof(buf));\n-#define ADD_FEATURE_IF_SUPPORTED(id, name, bit)                 \\\n-  do {                                                          \\\n-    if (VM_Version::supports_##name()) strcat(buf, \", \" #name); \\\n-  } while(0);\n-  CPU_FEATURE_FLAGS(ADD_FEATURE_IF_SUPPORTED)\n-#undef ADD_FEATURE_IF_SUPPORTED\n+  ss.print(\", \");\n+  int features_offset = (int)ss.size();\n+  insert_features_names(_features, ss);\n@@ -644,1 +648,3 @@\n-  _cpu_info_string = os::strdup(buf);\n+  _cpu_info_string = ss.as_string(true);\n+  _features_string = _cpu_info_string + features_offset;\n+}\n@@ -646,3 +652,11 @@\n-  _features_string = extract_features_string(_cpu_info_string,\n-                                             strnlen(_cpu_info_string, sizeof(buf)),\n-                                             features_offset);\n+void VM_Version::insert_features_names(uint64_t features, stringStream& ss) {\n+  int i = 0;\n+  ss.join([&]() {\n+    while (i < MAX_CPU_FEATURES) {\n+      if (supports_feature((VM_Version::Feature_Flag)i)) {\n+        return _features_names[i++];\n+      }\n+      i += 1;\n+    }\n+    return (const char*)nullptr;\n+  }, \", \");\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":36,"deletions":22,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -33,0 +33,4 @@\n+class stringStream;\n+\n+#define BIT_MASK(flag) (1ULL<<(flag))\n+\n@@ -69,0 +73,2 @@\n+  static void insert_features_names(uint64_t features, stringStream& ss);\n+\n@@ -142,1 +148,1 @@\n-#define DECLARE_CPU_FEATURE_FLAG(id, name, bit) CPU_##id = (1 << bit),\n+#define DECLARE_CPU_FEATURE_FLAG(id, name, bit) CPU_##id = bit,\n@@ -145,0 +151,1 @@\n+    MAX_CPU_FEATURES\n@@ -147,0 +154,4 @@\n+  STATIC_ASSERT(sizeof(_features) * BitsPerByte >= MAX_CPU_FEATURES);\n+\n+  static const char* _features_names[MAX_CPU_FEATURES];\n+\n@@ -149,1 +160,1 @@\n-  static bool supports_##name() { return (_features & CPU_##id) != 0; };\n+  static bool supports_##name() { return supports_feature(CPU_##id); }\n@@ -153,0 +164,10 @@\n+  static void set_feature(Feature_Flag flag) {\n+    _features |= BIT_MASK(flag);\n+  }\n+  static void clear_feature(Feature_Flag flag) {\n+    _features &= (~BIT_MASK(flag));\n+  }\n+  static bool supports_feature(Feature_Flag flag) {\n+    return (_features & BIT_MASK(flag)) != 0;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -342,5 +342,1 @@\n-    if (LockingMode == LM_MONITOR) {\n-      __ j(*stub->entry());\n-    } else {\n-      __ unlock_object(x15, x14, x10, x16, *stub->entry());\n-    }\n+    __ unlock_object(x15, x14, x10, x16, *stub->entry());\n@@ -1500,7 +1496,1 @@\n-  if (LockingMode == LM_MONITOR) {\n-    if (op->info() != nullptr) {\n-      add_debug_info_for_null_check_here(op->info());\n-      __ null_check(obj, -1);\n-    }\n-    __ j(*op->stub()->entry());\n-  } else if (op->code() == lir_lock) {\n+  if (op->code() == lir_lock) {\n@@ -1834,1 +1824,1 @@\n-  Register dst = dest->as_register_lo();\n+  Register dst = dest->as_pointer_register();\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -840,1 +840,1 @@\n-      LIR_Opr addr = new_pointer_register();\n+      LIR_Opr addr = new_register(T_ADDRESS);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRGenerator_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,2 +52,0 @@\n-  const int aligned_mask = BytesPerWord - 1;\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n@@ -64,50 +62,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lightweight_lock(disp_hdr, obj, hdr, temp, t1, slow_case);\n-  } else if (LockingMode == LM_LEGACY) {\n-\n-    if (DiagnoseSyncOnValueBasedClasses != 0) {\n-      load_klass(hdr, obj);\n-      lbu(hdr, Address(hdr, Klass::misc_flags_offset()));\n-      test_bit(temp, hdr, exact_log2(KlassFlags::_misc_is_value_based_class));\n-      bnez(temp, slow_case, \/* is_far *\/ true);\n-    }\n-\n-    Label done;\n-    \/\/ Load object header\n-    ld(hdr, Address(obj, hdr_offset));\n-    \/\/ and mark it as unlocked\n-    ori(hdr, hdr, markWord::unlocked_value);\n-    \/\/ save unlocked object header into the displaced header location on the stack\n-    sd(hdr, Address(disp_hdr, 0));\n-    \/\/ test if object header is still the same (i.e. unlocked), and if so, store the\n-    \/\/ displaced header address in the object header - if it is not the same, get the\n-    \/\/ object header instead\n-    la(temp, Address(obj, hdr_offset));\n-    \/\/ if the object header was the same, we're done\n-    cmpxchgptr(hdr, disp_hdr, temp, t1, done, \/*fallthough*\/nullptr);\n-    \/\/ if the object header was not the same, it is now in the hdr register\n-    \/\/ => test if it is a stack pointer into the same stack (recursive locking), i.e.:\n-    \/\/\n-    \/\/ 1) (hdr & aligned_mask) == 0\n-    \/\/ 2) sp <= hdr\n-    \/\/ 3) hdr <= sp + page_size\n-    \/\/\n-    \/\/ these 3 tests can be done by evaluating the following expression:\n-    \/\/\n-    \/\/ (hdr -sp) & (aligned_mask - page_size)\n-    \/\/\n-    \/\/ assuming both the stack pointer and page_size have their least\n-    \/\/ significant 2 bits cleared and page_size is a power of 2\n-    sub(hdr, hdr, sp);\n-    mv(temp, aligned_mask - (int)os::vm_page_size());\n-    andr(hdr, hdr, temp);\n-    \/\/ for recursive locking, the result is zero => save it in the displaced header\n-    \/\/ location (null in the displaced hdr location indicates recursive locking)\n-    sd(hdr, Address(disp_hdr, 0));\n-    \/\/ otherwise we don't care about the result and handle locking via runtime call\n-    bnez(hdr, slow_case, \/* is_far *\/ true);\n-\n-    \/\/ done\n-    bind(done);\n-    inc_held_monitor_count(t0);\n-  }\n+  lightweight_lock(disp_hdr, obj, hdr, temp, t1, slow_case);\n@@ -119,2 +68,0 @@\n-  const int aligned_mask = BytesPerWord - 1;\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n@@ -122,9 +69,0 @@\n-  Label done;\n-\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    \/\/ load displaced header\n-    ld(hdr, Address(disp_hdr, 0));\n-    \/\/ if the loaded hdr is null we had recursive locking\n-    \/\/ if we had recursive locking, we are done\n-    beqz(hdr, done);\n-  }\n@@ -136,19 +74,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lightweight_unlock(obj, hdr, temp, t1, slow_case);\n-  } else if (LockingMode == LM_LEGACY) {\n-    \/\/ test if object header is pointing to the displaced header, and if so, restore\n-    \/\/ the displaced header in the object - if the object header is not pointing to\n-    \/\/ the displaced header, get the object header instead\n-    \/\/ if the object header was not pointing to the displaced header,\n-    \/\/ we do unlocking via runtime call\n-    if (hdr_offset) {\n-      la(temp, Address(obj, hdr_offset));\n-      cmpxchgptr(disp_hdr, hdr, temp, t1, done, &slow_case);\n-    } else {\n-      cmpxchgptr(disp_hdr, hdr, obj, t1, done, &slow_case);\n-    }\n-\n-    \/\/ done\n-    bind(done);\n-    dec_held_monitor_count(t0);\n-  }\n+  lightweight_unlock(obj, hdr, temp, t1, slow_case);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":2,"deletions":82,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -46,228 +46,0 @@\n-void C2_MacroAssembler::fast_lock(Register objectReg, Register boxReg,\n-                                  Register tmp1Reg, Register tmp2Reg, Register tmp3Reg, Register tmp4Reg) {\n-  \/\/ Use cr register to indicate the fast_lock result: zero for success; non-zero for failure.\n-  Register flag = t1;\n-  Register oop = objectReg;\n-  Register box = boxReg;\n-  Register disp_hdr = tmp1Reg;\n-  Register tmp = tmp2Reg;\n-  Label object_has_monitor;\n-  \/\/ Finish fast lock successfully. MUST branch to with flag == 0\n-  Label locked;\n-  \/\/ Finish fast lock unsuccessfully. slow_path MUST branch to with flag != 0\n-  Label slow_path;\n-\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"lightweight locking should use fast_lock_lightweight\");\n-  assert_different_registers(oop, box, tmp, disp_hdr, flag, tmp3Reg, t0);\n-\n-  mv(flag, 1);\n-\n-  \/\/ Load markWord from object into displaced_header.\n-  ld(disp_hdr, Address(oop, oopDesc::mark_offset_in_bytes()));\n-\n-  if (DiagnoseSyncOnValueBasedClasses != 0) {\n-    load_klass(tmp, oop);\n-    lbu(tmp, Address(tmp, Klass::misc_flags_offset()));\n-    test_bit(tmp, tmp, exact_log2(KlassFlags::_misc_is_value_based_class));\n-    bnez(tmp, slow_path);\n-  }\n-\n-  \/\/ Check for existing monitor\n-  test_bit(tmp, disp_hdr, exact_log2(markWord::monitor_value));\n-  bnez(tmp, object_has_monitor);\n-\n-  if (LockingMode == LM_MONITOR) {\n-    j(slow_path);\n-  } else {\n-    assert(LockingMode == LM_LEGACY, \"must be\");\n-    \/\/ Set tmp to be (markWord of object | UNLOCK_VALUE).\n-    ori(tmp, disp_hdr, markWord::unlocked_value);\n-\n-    \/\/ Initialize the box. (Must happen before we update the object mark!)\n-    sd(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-    \/\/ Compare object markWord with an unlocked value (tmp) and if\n-    \/\/ equal exchange the stack address of our box with object markWord.\n-    \/\/ On failure disp_hdr contains the possibly locked markWord.\n-    cmpxchg(\/*memory address*\/oop, \/*expected value*\/tmp, \/*new value*\/box, Assembler::int64,\n-            Assembler::aq, Assembler::rl, \/*result*\/disp_hdr);\n-    beq(disp_hdr, tmp, locked);\n-\n-    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-    \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n-    \/\/ object, will have now locked it will continue at label locked\n-    \/\/ We did not see an unlocked object so try the fast recursive case.\n-\n-    \/\/ Check if the owner is self by comparing the value in the\n-    \/\/ markWord of object (disp_hdr) with the stack pointer.\n-    sub(disp_hdr, disp_hdr, sp);\n-    mv(tmp, (intptr_t) (~(os::vm_page_size()-1) | (uintptr_t)markWord::lock_mask_in_place));\n-    \/\/ If (mark & lock_mask) == 0 and mark - sp < page_size, we are stack-locking and goto label\n-    \/\/ locked, hence we can store 0 as the displaced header in the box, which indicates that it\n-    \/\/ is a recursive lock.\n-    andr(tmp\/*==0?*\/, disp_hdr, tmp);\n-    sd(tmp\/*==0, perhaps*\/, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-    beqz(tmp, locked);\n-    j(slow_path);\n-  }\n-\n-  \/\/ Handle existing monitor.\n-  bind(object_has_monitor);\n-\n-  \/\/ Try to CAS owner (no owner => current thread's _monitor_owner_id).\n-  add(tmp, disp_hdr, (in_bytes(ObjectMonitor::owner_offset()) - markWord::monitor_value));\n-  Register tid = tmp4Reg;\n-  ld(tid, Address(xthread, JavaThread::monitor_owner_id_offset()));\n-  cmpxchg(\/*memory address*\/tmp, \/*expected value*\/zr, \/*new value*\/tid, Assembler::int64,\n-          Assembler::aq, Assembler::rl, \/*result*\/tmp3Reg); \/\/ cas succeeds if tmp3Reg == zr(expected)\n-\n-  \/\/ Store a non-null value into the box to avoid looking like a re-entrant\n-  \/\/ lock. The fast-path monitor unlock code checks for\n-  \/\/ markWord::monitor_value so use markWord::unused_mark which has the\n-  \/\/ relevant bit set, and also matches ObjectSynchronizer::slow_enter.\n-  mv(tmp, (address)markWord::unused_mark().value());\n-  sd(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-  beqz(tmp3Reg, locked); \/\/ CAS success means locking succeeded\n-\n-  bne(tmp3Reg, tid, slow_path); \/\/ Check for recursive locking\n-\n-  \/\/ Recursive lock case\n-  increment(Address(disp_hdr, in_bytes(ObjectMonitor::recursions_offset()) - markWord::monitor_value), 1, tmp2Reg, tmp3Reg);\n-\n-  bind(locked);\n-  mv(flag, zr);\n-  if (LockingMode == LM_LEGACY) {\n-    inc_held_monitor_count(t0);\n-  }\n-\n-#ifdef ASSERT\n-  \/\/ Check that locked label is reached with flag == 0.\n-  Label flag_correct;\n-  beqz(flag, flag_correct);\n-  stop(\"Fast Lock Flag != 0\");\n-#endif\n-\n-  bind(slow_path);\n-#ifdef ASSERT\n-  \/\/ Check that slow_path label is reached with flag != 0.\n-  bnez(flag, flag_correct);\n-  stop(\"Fast Lock Flag == 0\");\n-  bind(flag_correct);\n-#endif\n-  \/\/ C2 uses the value of flag (0 vs !0) to determine the continuation.\n-}\n-\n-void C2_MacroAssembler::fast_unlock(Register objectReg, Register boxReg,\n-                                    Register tmp1Reg, Register tmp2Reg) {\n-  \/\/ Use cr register to indicate the fast_unlock result: zero for success; non-zero for failure.\n-  Register flag = t1;\n-  Register oop = objectReg;\n-  Register box = boxReg;\n-  Register disp_hdr = tmp1Reg;\n-  Register owner_addr = tmp1Reg;\n-  Register tmp = tmp2Reg;\n-  Label object_has_monitor;\n-  \/\/ Finish fast lock successfully. MUST branch to with flag == 0\n-  Label unlocked;\n-  \/\/ Finish fast lock unsuccessfully. slow_path MUST branch to with flag != 0\n-  Label slow_path;\n-\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"lightweight locking should use fast_unlock_lightweight\");\n-  assert_different_registers(oop, box, tmp, disp_hdr, flag, t0);\n-\n-  mv(flag, 1);\n-\n-  if (LockingMode == LM_LEGACY) {\n-    \/\/ Find the lock address and load the displaced header from the stack.\n-    ld(disp_hdr, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-    \/\/ If the displaced header is 0, we have a recursive unlock.\n-    beqz(disp_hdr, unlocked);\n-  }\n-\n-  \/\/ Handle existing monitor.\n-  ld(tmp, Address(oop, oopDesc::mark_offset_in_bytes()));\n-  test_bit(t0, tmp, exact_log2(markWord::monitor_value));\n-  bnez(t0, object_has_monitor);\n-\n-  if (LockingMode == LM_MONITOR) {\n-    j(slow_path);\n-  } else {\n-    assert(LockingMode == LM_LEGACY, \"must be\");\n-    \/\/ Check if it is still a light weight lock, this is true if we\n-    \/\/ see the stack address of the basicLock in the markWord of the\n-    \/\/ object.\n-\n-    cmpxchg(\/*memory address*\/oop, \/*expected value*\/box, \/*new value*\/disp_hdr, Assembler::int64,\n-            Assembler::relaxed, Assembler::rl, \/*result*\/tmp);\n-    beq(box, tmp, unlocked); \/\/ box == tmp if cas succeeds\n-    j(slow_path);\n-  }\n-\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-  \/\/ Handle existing monitor.\n-  bind(object_has_monitor);\n-  subi(tmp, tmp, (int)markWord::monitor_value); \/\/ monitor\n-  ld(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n-\n-  Label notRecursive;\n-  beqz(disp_hdr, notRecursive); \/\/ Will be 0 if not recursive.\n-\n-  \/\/ Recursive lock\n-  subi(disp_hdr, disp_hdr, 1);\n-  sd(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n-  j(unlocked);\n-\n-  bind(notRecursive);\n-  \/\/ Compute owner address.\n-  la(owner_addr, Address(tmp, ObjectMonitor::owner_offset()));\n-\n-  \/\/ Set owner to null.\n-  \/\/ Release to satisfy the JMM\n-  membar(MacroAssembler::LoadStore | MacroAssembler::StoreStore);\n-  sd(zr, Address(owner_addr));\n-  \/\/ We need a full fence after clearing owner to avoid stranding.\n-  \/\/ StoreLoad achieves this.\n-  membar(StoreLoad);\n-\n-  \/\/ Check if the entry_list is empty.\n-  ld(t0, Address(tmp, ObjectMonitor::entry_list_offset()));\n-  beqz(t0, unlocked); \/\/ If so we are done.\n-\n-  \/\/ Check if there is a successor.\n-  ld(t0, Address(tmp, ObjectMonitor::succ_offset()));\n-  bnez(t0, unlocked); \/\/ If so we are done.\n-\n-  \/\/ Save the monitor pointer in the current thread, so we can try to\n-  \/\/ reacquire the lock in SharedRuntime::monitor_exit_helper().\n-  sd(tmp, Address(xthread, JavaThread::unlocked_inflated_monitor_offset()));\n-\n-  mv(flag, 1);\n-  j(slow_path);\n-\n-  bind(unlocked);\n-  mv(flag, zr);\n-  if (LockingMode == LM_LEGACY) {\n-    dec_held_monitor_count(t0);\n-  }\n-\n-#ifdef ASSERT\n-  \/\/ Check that unlocked label is reached with flag == 0.\n-  Label flag_correct;\n-  beqz(flag, flag_correct);\n-  stop(\"Fast Lock Flag != 0\");\n-#endif\n-\n-  bind(slow_path);\n-#ifdef ASSERT\n-  \/\/ Check that slow_path label is reached with flag != 0.\n-  bnez(flag, flag_correct);\n-  stop(\"Fast Lock Flag == 0\");\n-  bind(flag_correct);\n-#endif\n-  \/\/ C2 uses the value of flag (0 vs !0) to determine the continuation.\n-}\n-\n@@ -279,1 +51,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n@@ -442,1 +213,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":0,"deletions":230,"binary":false,"changes":230,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,5 +52,0 @@\n-  \/\/ Code used by cmpFastLock and cmpFastUnlock mach instructions in .ad file.\n-  void fast_lock(Register object, Register box,\n-                 Register tmp1, Register tmp2, Register tmp3, Register tmp4);\n-  void fast_unlock(Register object, Register box, Register tmp1, Register tmp2);\n-\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -736,34 +736,0 @@\n-  if (LockingMode == LM_MONITOR) {\n-    call_VM_preemptable(noreg,\n-            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n-            lock_reg);\n-  } else {\n-    Label count, done;\n-\n-    const Register swap_reg = x10;\n-    const Register tmp = c_rarg2;\n-    const Register obj_reg = c_rarg3; \/\/ Will contain the oop\n-    const Register tmp2 = c_rarg4;\n-    const Register tmp3 = c_rarg5;\n-\n-    const int obj_offset = in_bytes(BasicObjectLock::obj_offset());\n-    const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n-    const int mark_offset = lock_offset +\n-                            BasicLock::displaced_header_offset_in_bytes();\n-\n-    Label slow_case;\n-\n-    \/\/ Load object pointer into obj_reg c_rarg3\n-    ld(obj_reg, Address(lock_reg, obj_offset));\n-\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      lightweight_lock(lock_reg, obj_reg, tmp, tmp2, tmp3, slow_case);\n-      j(done);\n-    } else if (LockingMode == LM_LEGACY) {\n-\n-      if (DiagnoseSyncOnValueBasedClasses != 0) {\n-        load_klass(tmp, obj_reg);\n-        lbu(tmp, Address(tmp, Klass::misc_flags_offset()));\n-        test_bit(tmp, tmp, exact_log2(KlassFlags::_misc_is_value_based_class));\n-        bnez(tmp, slow_case);\n-      }\n@@ -771,33 +737,4 @@\n-      \/\/ Load (object->mark() | 1) into swap_reg\n-      ld(t0, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-      ori(swap_reg, t0, 1);\n-\n-      \/\/ Save (object->mark() | 1) into BasicLock's displaced header\n-      sd(swap_reg, Address(lock_reg, mark_offset));\n-\n-      assert(lock_offset == 0,\n-             \"displached header must be first word in BasicObjectLock\");\n-\n-      cmpxchg_obj_header(swap_reg, lock_reg, obj_reg, tmp, count, \/*fallthrough*\/nullptr);\n-\n-      \/\/ Test if the oopMark is an obvious stack pointer, i.e.,\n-      \/\/  1) (mark & 7) == 0, and\n-      \/\/  2) sp <= mark < mark + os::pagesize()\n-      \/\/\n-      \/\/ These 3 tests can be done by evaluating the following\n-      \/\/ expression: ((mark - sp) & (7 - os::vm_page_size())),\n-      \/\/ assuming both stack pointer and pagesize have their\n-      \/\/ least significant 3 bits clear.\n-      \/\/ NOTE: the oopMark is in swap_reg x10 as the result of cmpxchg\n-      sub(swap_reg, swap_reg, sp);\n-      mv(t0, (int64_t)(7 - (int)os::vm_page_size()));\n-      andr(swap_reg, swap_reg, t0);\n-\n-      \/\/ Save the test result, for recursive case, the result is zero\n-      sd(swap_reg, Address(lock_reg, mark_offset));\n-      bnez(swap_reg, slow_case);\n-\n-      bind(count);\n-      inc_held_monitor_count(t0);\n-      j(done);\n-    }\n+  const Register tmp = c_rarg2;\n+  const Register obj_reg = c_rarg3; \/\/ Will contain the oop\n+  const Register tmp2 = c_rarg4;\n+  const Register tmp3 = c_rarg5;\n@@ -805,1 +742,2 @@\n-    bind(slow_case);\n+  \/\/ Load object pointer into obj_reg (c_rarg3)\n+  ld(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset()));\n@@ -807,4 +745,3 @@\n-    \/\/ Call the runtime routine for slow case\n-    call_VM_preemptable(noreg,\n-            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n-            lock_reg);\n+  Label done, slow_case;\n+  lightweight_lock(lock_reg, obj_reg, tmp, tmp2, tmp3, slow_case);\n+  j(done);\n@@ -812,2 +749,7 @@\n-    bind(done);\n-  }\n+  bind(slow_case);\n+  \/\/ Call the runtime routine for slow case\n+  call_VM_preemptable(noreg,\n+          CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n+          lock_reg);\n+\n+  bind(done);\n@@ -832,9 +774,4 @@\n-  if (LockingMode == LM_MONITOR) {\n-    call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), lock_reg);\n-  } else {\n-    Label count, done;\n-\n-    const Register swap_reg   = x10;\n-    const Register header_reg = c_rarg2;  \/\/ Will contain the old oopMark\n-    const Register obj_reg    = c_rarg3;  \/\/ Will contain the oop\n-    const Register tmp_reg    = c_rarg4;  \/\/ Temporary used by lightweight_unlock\n+  const Register swap_reg   = x10;\n+  const Register header_reg = c_rarg2;  \/\/ Will contain the old oopMark\n+  const Register obj_reg    = c_rarg3;  \/\/ Will contain the oop\n+  const Register tmp_reg    = c_rarg4;  \/\/ Temporary used by lightweight_unlock\n@@ -842,1 +779,1 @@\n-    save_bcp(); \/\/ Save in case of exception\n+  save_bcp(); \/\/ Save in case of exception\n@@ -844,23 +781,2 @@\n-    if (LockingMode != LM_LIGHTWEIGHT) {\n-      \/\/ Convert from BasicObjectLock structure to object and BasicLock\n-      \/\/ structure Store the BasicLock address into x10\n-      la(swap_reg, Address(lock_reg, BasicObjectLock::lock_offset()));\n-    }\n-\n-    \/\/ Load oop into obj_reg(c_rarg3)\n-    ld(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset()));\n-\n-    \/\/ Free entry\n-    sd(zr, Address(lock_reg, BasicObjectLock::obj_offset()));\n-\n-    Label slow_case;\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      lightweight_unlock(obj_reg, header_reg, swap_reg, tmp_reg, slow_case);\n-      j(done);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ Load the old header from BasicLock structure\n-      ld(header_reg, Address(swap_reg,\n-                             BasicLock::displaced_header_offset_in_bytes()));\n-\n-      \/\/ Test for recursion\n-      beqz(header_reg, count);\n+  \/\/ Load oop into obj_reg (c_rarg3)\n+  ld(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset()));\n@@ -868,2 +784,2 @@\n-      \/\/ Atomic swap back the old header\n-      cmpxchg_obj_header(swap_reg, header_reg, obj_reg, tmp_reg, count, &slow_case);\n+  \/\/ Free entry\n+  sd(zr, Address(lock_reg, BasicObjectLock::obj_offset()));\n@@ -871,4 +787,3 @@\n-      bind(count);\n-      dec_held_monitor_count(t0);\n-      j(done);\n-    }\n+  Label done, slow_case;\n+  lightweight_unlock(obj_reg, header_reg, swap_reg, tmp_reg, slow_case);\n+  j(done);\n@@ -876,4 +791,4 @@\n-    bind(slow_case);\n-    \/\/ Call the runtime routine for slow case.\n-    sd(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset())); \/\/ restore obj\n-    call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), lock_reg);\n+  bind(slow_case);\n+  \/\/ Call the runtime routine for slow case.\n+  sd(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset())); \/\/ restore obj\n+  call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), lock_reg);\n@@ -881,3 +796,2 @@\n-    bind(done);\n-    restore_bcp();\n-  }\n+  bind(done);\n+  restore_bcp();\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":34,"deletions":120,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -6424,1 +6424,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n@@ -6484,1 +6483,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -11024,35 +11024,0 @@\n-instruct cmpFastLock(rFlagsReg cr, iRegP object, iRegP box,\n-                     iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, iRegPNoSp tmp4)\n-%{\n-  predicate(LockingMode != LM_LIGHTWEIGHT);\n-  match(Set cr (FastLock object box));\n-  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4);\n-\n-  ins_cost(10 * DEFAULT_COST);\n-  format %{ \"fastlock $object,$box\\t! kills $tmp1,$tmp2,$tmp3,$tmp4 #@cmpFastLock\" %}\n-\n-  ins_encode %{\n-    __ fast_lock($object$$Register, $box$$Register,\n-                 $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register);\n-  %}\n-\n-  ins_pipe(pipe_serial);\n-%}\n-\n-\/\/ using t1 as the 'flag' register to bridge the BoolNode producers and consumers\n-instruct cmpFastUnlock(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp1, iRegPNoSp tmp2)\n-%{\n-  predicate(LockingMode != LM_LIGHTWEIGHT);\n-  match(Set cr (FastUnlock object box));\n-  effect(TEMP tmp1, TEMP tmp2);\n-\n-  ins_cost(10 * DEFAULT_COST);\n-  format %{ \"fastunlock $object,$box\\t! kills $tmp1, $tmp2, #@cmpFastUnlock\" %}\n-\n-  ins_encode %{\n-    __ fast_unlock($object$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register);\n-  %}\n-\n-  ins_pipe(pipe_serial);\n-%}\n-\n@@ -11062,1 +11027,0 @@\n-  predicate(LockingMode == LM_LIGHTWEIGHT);\n@@ -11077,0 +11041,1 @@\n+\/\/ using t1 as the 'flag' register to bridge the BoolNode producers and consumers\n@@ -11080,1 +11045,0 @@\n-  predicate(LockingMode == LM_LIGHTWEIGHT);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":2,"deletions":38,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1640,1 +1640,1 @@\n-  if (LockingMode != LM_LEGACY && method->is_object_wait0()) {\n+  if (method->is_object_wait0()) {\n@@ -1682,2 +1682,0 @@\n-    Label count;\n-\n@@ -1696,36 +1694,1 @@\n-    if (LockingMode == LM_MONITOR) {\n-      __ j(slow_path_lock);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ Load (object->mark() | 1) into swap_reg % x10\n-      __ ld(t0, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-      __ ori(swap_reg, t0, 1);\n-\n-      \/\/ Save (object->mark() | 1) into BasicLock's displaced header\n-      __ sd(swap_reg, Address(lock_reg, mark_word_offset));\n-\n-      \/\/ src -> dest if dest == x10 else x10 <- dest\n-      __ cmpxchg_obj_header(x10, lock_reg, obj_reg, lock_tmp, count, \/*fallthrough*\/nullptr);\n-\n-      \/\/ Test if the oopMark is an obvious stack pointer, i.e.,\n-      \/\/  1) (mark & 3) == 0, and\n-      \/\/  2) sp <= mark < mark + os::pagesize()\n-      \/\/ These 3 tests can be done by evaluating the following\n-      \/\/ expression: ((mark - sp) & (3 - os::vm_page_size())),\n-      \/\/ assuming both stack pointer and pagesize have their\n-      \/\/ least significant 2 bits clear.\n-      \/\/ NOTE: the oopMark is in swap_reg % 10 as the result of cmpxchg\n-\n-      __ sub(swap_reg, swap_reg, sp);\n-      __ mv(t0, 3 - (int)os::vm_page_size());\n-      __ andr(swap_reg, swap_reg, t0);\n-\n-      \/\/ Save the test result, for recursive case, the result is zero\n-      __ sd(swap_reg, Address(lock_reg, mark_word_offset));\n-      __ bnez(swap_reg, slow_path_lock);\n-\n-      __ bind(count);\n-      __ inc_held_monitor_count(t0);\n-    } else {\n-      assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-      __ lightweight_lock(lock_reg, obj_reg, swap_reg, tmp, lock_tmp, slow_path_lock);\n-    }\n+    __ lightweight_lock(lock_reg, obj_reg, swap_reg, tmp, lock_tmp, slow_path_lock);\n@@ -1792,1 +1755,1 @@\n-  if (LockingMode != LM_LEGACY && method->is_object_wait0()) {\n+  if (method->is_object_wait0()) {\n@@ -1821,12 +1784,0 @@\n-    Label done, not_recursive;\n-\n-    if (LockingMode == LM_LEGACY) {\n-      \/\/ Simple recursive lock?\n-      __ ld(t0, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));\n-      __ bnez(t0, not_recursive);\n-      __ dec_held_monitor_count(t0);\n-      __ j(done);\n-    }\n-\n-    __ bind(not_recursive);\n-\n@@ -1838,17 +1789,1 @@\n-    if (LockingMode == LM_MONITOR) {\n-      __ j(slow_path_unlock);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ get address of the stack lock\n-      __ la(x10, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));\n-      \/\/  get old displaced header\n-      __ ld(old_hdr, Address(x10, 0));\n-\n-      \/\/ Atomic swap old header if oop still contains the stack lock\n-      Label count;\n-      __ cmpxchg_obj_header(x10, old_hdr, obj_reg, lock_tmp, count, &slow_path_unlock);\n-      __ bind(count);\n-      __ dec_held_monitor_count(t0);\n-    } else {\n-      assert(LockingMode == LM_LIGHTWEIGHT, \"\");\n-      __ lightweight_unlock(obj_reg, old_hdr, swap_reg, lock_tmp, slow_path_unlock);\n-    }\n+    __ lightweight_unlock(obj_reg, old_hdr, swap_reg, lock_tmp, slow_path_unlock);\n@@ -1861,2 +1796,0 @@\n-\n-    __ bind(done);\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":4,"deletions":71,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -1256,16 +1256,11 @@\n-  if (LockingMode != LM_LEGACY) {\n-    \/\/ Check preemption for Object.wait()\n-    Label not_preempted;\n-    __ ld(t1, Address(xthread, JavaThread::preempt_alternate_return_offset()));\n-    __ beqz(t1, not_preempted);\n-    __ sd(zr, Address(xthread, JavaThread::preempt_alternate_return_offset()));\n-    __ jr(t1);\n-    __ bind(native_return);\n-    __ restore_after_resume(true \/* is_native *\/);\n-    \/\/ reload result_handler\n-    __ ld(result_handler, Address(fp, frame::interpreter_frame_result_handler_offset * wordSize));\n-    __ bind(not_preempted);\n-  } else {\n-    \/\/ any pc will do so just use this one for LM_LEGACY to keep code together.\n-    __ bind(native_return);\n-  }\n+  \/\/ Check preemption for Object.wait()\n+  Label not_preempted;\n+  __ ld(t1, Address(xthread, JavaThread::preempt_alternate_return_offset()));\n+  __ beqz(t1, not_preempted);\n+  __ sd(zr, Address(xthread, JavaThread::preempt_alternate_return_offset()));\n+  __ jr(t1);\n+  __ bind(native_return);\n+  __ restore_after_resume(true \/* is_native *\/);\n+  \/\/ reload result_handler\n+  __ ld(result_handler, Address(fp, frame::interpreter_frame_result_handler_offset * wordSize));\n+  __ bind(not_preempted);\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":11,"deletions":16,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -416,5 +416,1 @@\n-    if (LockingMode == LM_MONITOR) {\n-      __ jmp(*stub->entry());\n-    } else {\n-      __ unlock_object(rdi, rsi, rax, *stub->entry());\n-    }\n+    __ unlock_object(rdi, rsi, rax, *stub->entry());\n@@ -2736,7 +2732,1 @@\n-  if (LockingMode == LM_MONITOR) {\n-    if (op->info() != nullptr) {\n-      add_debug_info_for_null_check_here(op->info());\n-      __ null_check(obj);\n-    }\n-    __ jmp(*op->stub()->entry());\n-  } else if (op->code() == lir_lock) {\n+  if (op->code() == lir_lock) {\n@@ -2744,1 +2734,1 @@\n-    Register tmp = LockingMode == LM_LIGHTWEIGHT ? op->scratch_opr()->as_register() : noreg;\n+    Register tmp = op->scratch_opr()->as_register();\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -292,1 +292,1 @@\n-  LIR_Opr tmp = LockingMode == LM_LIGHTWEIGHT ? new_register(T_ADDRESS) : LIR_OprFact::illegalOpr;\n+  LIR_Opr tmp = new_register(T_ADDRESS);\n@@ -964,1 +964,1 @@\n-      LIR_Opr addr = new_pointer_register();\n+      LIR_Opr addr = new_register(T_ADDRESS);\n@@ -1103,1 +1103,1 @@\n-  LIR_Opr ptr_addr_a = new_pointer_register();\n+  LIR_Opr ptr_addr_a = new_register(T_ADDRESS);\n@@ -1106,1 +1106,1 @@\n-  LIR_Opr ptr_addr_b = new_pointer_register();\n+  LIR_Opr ptr_addr_b = new_register(T_ADDRESS);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-  const int aligned_mask = BytesPerWord -1;\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n@@ -58,48 +56,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lightweight_lock(disp_hdr, obj, hdr, tmp, slow_case);\n-  } else  if (LockingMode == LM_LEGACY) {\n-    Label done;\n-\n-    if (DiagnoseSyncOnValueBasedClasses != 0) {\n-      load_klass(hdr, obj, rscratch1);\n-      testb(Address(hdr, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n-      jcc(Assembler::notZero, slow_case);\n-    }\n-\n-    \/\/ Load object header\n-    movptr(hdr, Address(obj, hdr_offset));\n-    \/\/ and mark it as unlocked\n-    orptr(hdr, markWord::unlocked_value);\n-    \/\/ save unlocked object header into the displaced header location on the stack\n-    movptr(Address(disp_hdr, 0), hdr);\n-    \/\/ test if object header is still the same (i.e. unlocked), and if so, store the\n-    \/\/ displaced header address in the object header - if it is not the same, get the\n-    \/\/ object header instead\n-    MacroAssembler::lock(); \/\/ must be immediately before cmpxchg!\n-    cmpxchgptr(disp_hdr, Address(obj, hdr_offset));\n-    \/\/ if the object header was the same, we're done\n-    jcc(Assembler::equal, done);\n-    \/\/ if the object header was not the same, it is now in the hdr register\n-    \/\/ => test if it is a stack pointer into the same stack (recursive locking), i.e.:\n-    \/\/\n-    \/\/ 1) (hdr & aligned_mask) == 0\n-    \/\/ 2) rsp <= hdr\n-    \/\/ 3) hdr <= rsp + page_size\n-    \/\/\n-    \/\/ these 3 tests can be done by evaluating the following expression:\n-    \/\/\n-    \/\/ (hdr - rsp) & (aligned_mask - page_size)\n-    \/\/\n-    \/\/ assuming both the stack pointer and page_size have their least\n-    \/\/ significant 2 bits cleared and page_size is a power of 2\n-    subptr(hdr, rsp);\n-    andptr(hdr, aligned_mask - (int)os::vm_page_size());\n-    \/\/ for recursive locking, the result is zero => save it in the displaced header\n-    \/\/ location (null in the displaced hdr location indicates recursive locking)\n-    movptr(Address(disp_hdr, 0), hdr);\n-    \/\/ otherwise we don't care about the result and handle locking via runtime call\n-    jcc(Assembler::notZero, slow_case);\n-    \/\/ done\n-    bind(done);\n-    inc_held_monitor_count();\n-  }\n+  lightweight_lock(disp_hdr, obj, hdr, tmp, slow_case);\n@@ -111,2 +62,0 @@\n-  const int aligned_mask = BytesPerWord -1;\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n@@ -115,10 +64,0 @@\n-  Label done;\n-\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    \/\/ load displaced header\n-    movptr(hdr, Address(disp_hdr, 0));\n-    \/\/ if the loaded hdr is null we had recursive locking\n-    testptr(hdr, hdr);\n-    \/\/ if we had recursive locking, we are done\n-    jcc(Assembler::zero, done);\n-  }\n@@ -130,15 +69,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lightweight_unlock(obj, disp_hdr, hdr, slow_case);\n-  } else if (LockingMode == LM_LEGACY) {\n-    \/\/ test if object header is pointing to the displaced header, and if so, restore\n-    \/\/ the displaced header in the object - if the object header is not pointing to\n-    \/\/ the displaced header, get the object header instead\n-    MacroAssembler::lock(); \/\/ must be immediately before cmpxchg!\n-    cmpxchgptr(hdr, Address(obj, hdr_offset));\n-    \/\/ if the object header was not pointing to the displaced header,\n-    \/\/ we do unlocking via runtime call\n-    jcc(Assembler::notEqual, slow_case);\n-    \/\/ done\n-    bind(done);\n-    dec_held_monitor_count();\n-  }\n+  lightweight_unlock(obj, disp_hdr, hdr, slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":2,"deletions":77,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -222,235 +222,3 @@\n-\/\/ box: on-stack box address (displaced header location) - KILLED\n-\/\/ rax,: tmp -- KILLED\n-\/\/ scr: tmp -- KILLED\n-void C2_MacroAssembler::fast_lock(Register objReg, Register boxReg, Register tmpReg,\n-                                 Register scrReg, Register cx1Reg, Register cx2Reg, Register thread,\n-                                 Metadata* method_data) {\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"lightweight locking should use fast_lock_lightweight\");\n-  \/\/ Ensure the register assignments are disjoint\n-  assert(tmpReg == rax, \"\");\n-  assert(cx1Reg == noreg, \"\");\n-  assert(cx2Reg == noreg, \"\");\n-  assert_different_registers(objReg, boxReg, tmpReg, scrReg);\n-\n-  \/\/ Possible cases that we'll encounter in fast_lock\n-  \/\/ ------------------------------------------------\n-  \/\/ * Inflated\n-  \/\/    -- unlocked\n-  \/\/    -- Locked\n-  \/\/       = by self\n-  \/\/       = by other\n-  \/\/ * neutral\n-  \/\/ * stack-locked\n-  \/\/    -- by self\n-  \/\/       = sp-proximity test hits\n-  \/\/       = sp-proximity test generates false-negative\n-  \/\/    -- by other\n-  \/\/\n-\n-  Label IsInflated, DONE_LABEL, NO_COUNT, COUNT;\n-\n-  if (DiagnoseSyncOnValueBasedClasses != 0) {\n-    load_klass(tmpReg, objReg, scrReg);\n-    testb(Address(tmpReg, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n-    jcc(Assembler::notZero, DONE_LABEL);\n-  }\n-\n-  movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));          \/\/ [FETCH]\n-  testptr(tmpReg, markWord::monitor_value); \/\/ inflated vs stack-locked|neutral\n-  jcc(Assembler::notZero, IsInflated);\n-\n-  if (LockingMode == LM_MONITOR) {\n-    \/\/ Clear ZF so that we take the slow path at the DONE label. objReg is known to be not 0.\n-    testptr(objReg, objReg);\n-  } else {\n-    assert(LockingMode == LM_LEGACY, \"must be\");\n-    \/\/ Attempt stack-locking ...\n-    orptr (tmpReg, markWord::unlocked_value);\n-    movptr(Address(boxReg, 0), tmpReg);          \/\/ Anticipate successful CAS\n-    lock();\n-    cmpxchgptr(boxReg, Address(objReg, oopDesc::mark_offset_in_bytes()));      \/\/ Updates tmpReg\n-    jcc(Assembler::equal, COUNT);           \/\/ Success\n-\n-    \/\/ Recursive locking.\n-    \/\/ The object is stack-locked: markword contains stack pointer to BasicLock.\n-    \/\/ Locked by current thread if difference with current SP is less than one page.\n-    subptr(tmpReg, rsp);\n-    \/\/ Next instruction set ZFlag == 1 (Success) if difference is less then one page.\n-    andptr(tmpReg, (int32_t) (7 - (int)os::vm_page_size()) );\n-    movptr(Address(boxReg, 0), tmpReg);\n-  }\n-  jmp(DONE_LABEL);\n-\n-  bind(IsInflated);\n-  \/\/ The object is inflated. tmpReg contains pointer to ObjectMonitor* + markWord::monitor_value\n-\n-  \/\/ Unconditionally set box->_displaced_header = markWord::unused_mark().\n-  \/\/ Without cast to int32_t this style of movptr will destroy r10 which is typically obj.\n-  movptr(Address(boxReg, 0), checked_cast<int32_t>(markWord::unused_mark().value()));\n-\n-  \/\/ It's inflated and we use scrReg for ObjectMonitor* in this section.\n-  movptr(boxReg, Address(r15_thread, JavaThread::monitor_owner_id_offset()));\n-  movq(scrReg, tmpReg);\n-  xorq(tmpReg, tmpReg);\n-  lock();\n-  cmpxchgptr(boxReg, Address(scrReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n-\n-  \/\/ Propagate ICC.ZF from CAS above into DONE_LABEL.\n-  jccb(Assembler::equal, COUNT);    \/\/ CAS above succeeded; propagate ZF = 1 (success)\n-\n-  cmpptr(boxReg, rax);                \/\/ Check if we are already the owner (recursive lock)\n-  jccb(Assembler::notEqual, NO_COUNT);    \/\/ If not recursive, ZF = 0 at this point (fail)\n-  incq(Address(scrReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n-  xorq(rax, rax); \/\/ Set ZF = 1 (success) for recursive lock, denoting locking success\n-  bind(DONE_LABEL);\n-\n-  \/\/ ZFlag == 1 count in fast path\n-  \/\/ ZFlag == 0 count in slow path\n-  jccb(Assembler::notZero, NO_COUNT); \/\/ jump if ZFlag == 0\n-\n-  bind(COUNT);\n-  if (LockingMode == LM_LEGACY) {\n-    \/\/ Count monitors in fast path\n-    increment(Address(thread, JavaThread::held_monitor_count_offset()));\n-  }\n-  xorl(tmpReg, tmpReg); \/\/ Set ZF == 1\n-\n-  bind(NO_COUNT);\n-\n-  \/\/ At NO_COUNT the icc ZFlag is set as follows ...\n-  \/\/ fast_unlock uses the same protocol.\n-  \/\/ ZFlag == 1 -> Success\n-  \/\/ ZFlag == 0 -> Failure - force control through the slow path\n-}\n-\n-\/\/ obj: object to unlock\n-\/\/ box: box address (displaced header location), killed.  Must be EAX.\n-\/\/ tmp: killed, cannot be obj nor box.\n-\/\/\n-\/\/ Some commentary on balanced locking:\n-\/\/\n-\/\/ fast_lock and fast_unlock are emitted only for provably balanced lock sites.\n-\/\/ Methods that don't have provably balanced locking are forced to run in the\n-\/\/ interpreter - such methods won't be compiled to use fast_lock and fast_unlock.\n-\/\/ The interpreter provides two properties:\n-\/\/ I1:  At return-time the interpreter automatically and quietly unlocks any\n-\/\/      objects acquired the current activation (frame).  Recall that the\n-\/\/      interpreter maintains an on-stack list of locks currently held by\n-\/\/      a frame.\n-\/\/ I2:  If a method attempts to unlock an object that is not held by the\n-\/\/      the frame the interpreter throws IMSX.\n-\/\/\n-\/\/ Lets say A(), which has provably balanced locking, acquires O and then calls B().\n-\/\/ B() doesn't have provably balanced locking so it runs in the interpreter.\n-\/\/ Control returns to A() and A() unlocks O.  By I1 and I2, above, we know that O\n-\/\/ is still locked by A().\n-\/\/\n-\/\/ The only other source of unbalanced locking would be JNI.  The \"Java Native Interface:\n-\/\/ Programmer's Guide and Specification\" claims that an object locked by jni_monitorenter\n-\/\/ should not be unlocked by \"normal\" java-level locking and vice-versa.  The specification\n-\/\/ doesn't specify what will occur if a program engages in such mixed-mode locking, however.\n-\/\/ Arguably given that the spec legislates the JNI case as undefined our implementation\n-\/\/ could reasonably *avoid* checking owner in fast_unlock().\n-\/\/ In the interest of performance we elide m->Owner==Self check in unlock.\n-\/\/ A perfectly viable alternative is to elide the owner check except when\n-\/\/ Xcheck:jni is enabled.\n-\n-void C2_MacroAssembler::fast_unlock(Register objReg, Register boxReg, Register tmpReg) {\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"lightweight locking should use fast_unlock_lightweight\");\n-  assert(boxReg == rax, \"\");\n-  assert_different_registers(objReg, boxReg, tmpReg);\n-\n-  Label DONE_LABEL, Stacked, COUNT, NO_COUNT;\n-\n-  if (LockingMode == LM_LEGACY) {\n-    cmpptr(Address(boxReg, 0), NULL_WORD);                            \/\/ Examine the displaced header\n-    jcc   (Assembler::zero, COUNT);                                   \/\/ 0 indicates recursive stack-lock\n-  }\n-  movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));   \/\/ Examine the object's markword\n-  if (LockingMode != LM_MONITOR) {\n-    testptr(tmpReg, markWord::monitor_value);                         \/\/ Inflated?\n-    jcc(Assembler::zero, Stacked);\n-  }\n-\n-  \/\/ It's inflated.\n-\n-  \/\/ Despite our balanced locking property we still check that m->_owner == Self\n-  \/\/ as java routines or native JNI code called by this thread might\n-  \/\/ have released the lock.\n-  \/\/\n-  \/\/ If there's no contention try a 1-0 exit.  That is, exit without\n-  \/\/ a costly MEMBAR or CAS.  See synchronizer.cpp for details on how\n-  \/\/ we detect and recover from the race that the 1-0 exit admits.\n-  \/\/\n-  \/\/ Conceptually fast_unlock() must execute a STST|LDST \"release\" barrier\n-  \/\/ before it STs null into _owner, releasing the lock.  Updates\n-  \/\/ to data protected by the critical section must be visible before\n-  \/\/ we drop the lock (and thus before any other thread could acquire\n-  \/\/ the lock and observe the fields protected by the lock).\n-  \/\/ IA32's memory-model is SPO, so STs are ordered with respect to\n-  \/\/ each other and there's no need for an explicit barrier (fence).\n-  \/\/ See also http:\/\/gee.cs.oswego.edu\/dl\/jmm\/cookbook.html.\n-  Label LSuccess, LNotRecursive;\n-\n-  cmpptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 0);\n-  jccb(Assembler::equal, LNotRecursive);\n-\n-  \/\/ Recursive inflated unlock\n-  decrement(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n-  jmpb(LSuccess);\n-\n-  bind(LNotRecursive);\n-\n-  \/\/ Set owner to null.\n-  \/\/ Release to satisfy the JMM\n-  movptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), NULL_WORD);\n-  \/\/ We need a full fence after clearing owner to avoid stranding.\n-  \/\/ StoreLoad achieves this.\n-  membar(StoreLoad);\n-\n-  \/\/ Check if the entry_list is empty.\n-  cmpptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(entry_list)), NULL_WORD);\n-  jccb(Assembler::zero, LSuccess);    \/\/ If so we are done.\n-\n-  \/\/ Check if there is a successor.\n-  cmpptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), NULL_WORD);\n-  jccb(Assembler::notZero, LSuccess); \/\/ If so we are done.\n-\n-  \/\/ Save the monitor pointer in the current thread, so we can try to\n-  \/\/ reacquire the lock in SharedRuntime::monitor_exit_helper().\n-  andptr(tmpReg, ~(int32_t)markWord::monitor_value);\n-  movptr(Address(r15_thread, JavaThread::unlocked_inflated_monitor_offset()), tmpReg);\n-\n-  orl   (boxReg, 1);                      \/\/ set ICC.ZF=0 to indicate failure\n-  jmpb  (DONE_LABEL);\n-\n-  bind  (LSuccess);\n-  testl (boxReg, 0);                      \/\/ set ICC.ZF=1 to indicate success\n-  jmpb  (DONE_LABEL);\n-\n-  if (LockingMode == LM_LEGACY) {\n-    bind  (Stacked);\n-    movptr(tmpReg, Address (boxReg, 0));      \/\/ re-fetch\n-    lock();\n-    cmpxchgptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes())); \/\/ Uses RAX which is box\n-    \/\/ Intentional fall-thru into DONE_LABEL\n-  }\n-\n-  bind(DONE_LABEL);\n-\n-  \/\/ ZFlag == 1 count in fast path\n-  \/\/ ZFlag == 0 count in slow path\n-  jccb(Assembler::notZero, NO_COUNT);\n-\n-  bind(COUNT);\n-\n-  if (LockingMode == LM_LEGACY) {\n-    \/\/ Count monitors in fast path\n-    decrementq(Address(r15_thread, JavaThread::held_monitor_count_offset()));\n-  }\n-\n-  xorl(tmpReg, tmpReg); \/\/ Set ZF == 1\n-\n-  bind(NO_COUNT);\n-}\n-\n+\/\/ box: on-stack box address -- KILLED\n+\/\/ rax: tmp -- KILLED\n+\/\/ t  : tmp -- KILLED\n@@ -459,1 +227,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n@@ -619,0 +386,32 @@\n+\/\/ obj: object to lock\n+\/\/ rax: tmp -- KILLED\n+\/\/ t  : tmp - cannot be obj nor rax -- KILLED\n+\/\/\n+\/\/ Some commentary on balanced locking:\n+\/\/\n+\/\/ fast_lock and fast_unlock are emitted only for provably balanced lock sites.\n+\/\/ Methods that don't have provably balanced locking are forced to run in the\n+\/\/ interpreter - such methods won't be compiled to use fast_lock and fast_unlock.\n+\/\/ The interpreter provides two properties:\n+\/\/ I1:  At return-time the interpreter automatically and quietly unlocks any\n+\/\/      objects acquired in the current activation (frame).  Recall that the\n+\/\/      interpreter maintains an on-stack list of locks currently held by\n+\/\/      a frame.\n+\/\/ I2:  If a method attempts to unlock an object that is not held by the\n+\/\/      frame the interpreter throws IMSX.\n+\/\/\n+\/\/ Lets say A(), which has provably balanced locking, acquires O and then calls B().\n+\/\/ B() doesn't have provably balanced locking so it runs in the interpreter.\n+\/\/ Control returns to A() and A() unlocks O.  By I1 and I2, above, we know that O\n+\/\/ is still locked by A().\n+\/\/\n+\/\/ The only other source of unbalanced locking would be JNI.  The \"Java Native Interface\n+\/\/ Specification\" states that an object locked by JNI's MonitorEnter should not be\n+\/\/ unlocked by \"normal\" java-level locking and vice-versa.  The specification doesn't\n+\/\/ specify what will occur if a program engages in such mixed-mode locking, however.\n+\/\/ Arguably given that the spec legislates the JNI case as undefined our implementation\n+\/\/ could reasonably *avoid* checking owner in fast_unlock().\n+\/\/ In the interest of performance we elide m->Owner==Self check in unlock.\n+\/\/ A perfectly viable alternative is to elide the owner check except when\n+\/\/ Xcheck:jni is enabled.\n+\n@@ -620,1 +419,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":35,"deletions":237,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -37,6 +37,1 @@\n-  \/\/ See full description in macroAssembler_x86.cpp.\n-  void fast_lock(Register obj, Register box, Register tmp,\n-                 Register scr, Register cx1, Register cx2, Register thread,\n-                 Metadata* method_data);\n-  void fast_unlock(Register obj, Register box, Register tmp);\n-\n+  \/\/ See full description in c2_MacroAssembler_x86.cpp.\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1027,28 +1027,1 @@\n-  if (LockingMode == LM_MONITOR) {\n-    call_VM_preemptable(noreg,\n-            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n-            lock_reg);\n-  } else {\n-    Label count_locking, done, slow_case;\n-\n-    const Register swap_reg = rax; \/\/ Must use rax for cmpxchg instruction\n-    const Register tmp_reg = rbx;\n-    const Register obj_reg = c_rarg3; \/\/ Will contain the oop\n-    const Register rklass_decode_tmp = rscratch1;\n-\n-    const int obj_offset = in_bytes(BasicObjectLock::obj_offset());\n-    const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n-    const int mark_offset = lock_offset +\n-                            BasicLock::displaced_header_offset_in_bytes();\n-\n-    \/\/ Load object pointer into obj_reg\n-    movptr(obj_reg, Address(lock_reg, obj_offset));\n-\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      lightweight_lock(lock_reg, obj_reg, swap_reg, tmp_reg, slow_case);\n-    } else if (LockingMode == LM_LEGACY) {\n-      if (DiagnoseSyncOnValueBasedClasses != 0) {\n-        load_klass(tmp_reg, obj_reg, rklass_decode_tmp);\n-        testb(Address(tmp_reg, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n-        jcc(Assembler::notZero, slow_case);\n-      }\n+  Label done, slow_case;\n@@ -1056,56 +1029,3 @@\n-      \/\/ Load immediate 1 into swap_reg %rax\n-      movl(swap_reg, 1);\n-\n-      \/\/ Load (object->mark() | 1) into swap_reg %rax\n-      orptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-\n-      \/\/ Save (object->mark() | 1) into BasicLock's displaced header\n-      movptr(Address(lock_reg, mark_offset), swap_reg);\n-\n-      assert(lock_offset == 0,\n-             \"displaced header must be first word in BasicObjectLock\");\n-\n-      lock();\n-      cmpxchgptr(lock_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-      jcc(Assembler::zero, count_locking);\n-\n-      const int zero_bits = 7;\n-\n-      \/\/ Fast check for recursive lock.\n-      \/\/\n-      \/\/ Can apply the optimization only if this is a stack lock\n-      \/\/ allocated in this thread. For efficiency, we can focus on\n-      \/\/ recently allocated stack locks (instead of reading the stack\n-      \/\/ base and checking whether 'mark' points inside the current\n-      \/\/ thread stack):\n-      \/\/  1) (mark & zero_bits) == 0, and\n-      \/\/  2) rsp <= mark < mark + os::pagesize()\n-      \/\/\n-      \/\/ Warning: rsp + os::pagesize can overflow the stack base. We must\n-      \/\/ neither apply the optimization for an inflated lock allocated\n-      \/\/ just above the thread stack (this is why condition 1 matters)\n-      \/\/ nor apply the optimization if the stack lock is inside the stack\n-      \/\/ of another thread. The latter is avoided even in case of overflow\n-      \/\/ because we have guard pages at the end of all stacks. Hence, if\n-      \/\/ we go over the stack base and hit the stack of another thread,\n-      \/\/ this should not be in a writeable area that could contain a\n-      \/\/ stack lock allocated by that thread. As a consequence, a stack\n-      \/\/ lock less than page size away from rsp is guaranteed to be\n-      \/\/ owned by the current thread.\n-      \/\/\n-      \/\/ These 3 tests can be done by evaluating the following\n-      \/\/ expression: ((mark - rsp) & (zero_bits - os::vm_page_size())),\n-      \/\/ assuming both stack pointer and pagesize have their\n-      \/\/ least significant bits clear.\n-      \/\/ NOTE: the mark is in swap_reg %rax as the result of cmpxchg\n-      subptr(swap_reg, rsp);\n-      andptr(swap_reg, zero_bits - (int)os::vm_page_size());\n-\n-      \/\/ Save the test result, for recursive case, the result is zero\n-      movptr(Address(lock_reg, mark_offset), swap_reg);\n-      jcc(Assembler::notZero, slow_case);\n-\n-      bind(count_locking);\n-      inc_held_monitor_count();\n-    }\n-    jmp(done);\n+  const Register swap_reg = rax; \/\/ Must use rax for cmpxchg instruction\n+  const Register tmp_reg = rbx;\n+  const Register obj_reg = c_rarg3; \/\/ Will contain the oop\n@@ -1113,1 +1033,2 @@\n-    bind(slow_case);\n+  \/\/ Load object pointer into obj_reg\n+  movptr(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset()));\n@@ -1115,6 +1036,10 @@\n-    \/\/ Call the runtime routine for slow case\n-    call_VM_preemptable(noreg,\n-            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n-            lock_reg);\n-    bind(done);\n-  }\n+  lightweight_lock(lock_reg, obj_reg, swap_reg, tmp_reg, slow_case);\n+  jmp(done);\n+\n+  bind(slow_case);\n+\n+  \/\/ Call the runtime routine for slow case\n+  call_VM_preemptable(noreg,\n+          CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n+          lock_reg);\n+  bind(done);\n@@ -1139,4 +1064,1 @@\n-  if (LockingMode == LM_MONITOR) {\n-    call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), lock_reg);\n-  } else {\n-    Label count_locking, done, slow_case;\n+  Label done, slow_case;\n@@ -1144,3 +1066,3 @@\n-    const Register swap_reg   = rax;  \/\/ Must use rax for cmpxchg instruction\n-    const Register header_reg = c_rarg2;  \/\/ Will contain the old oopMark\n-    const Register obj_reg    = c_rarg3;  \/\/ Will contain the oop\n+  const Register swap_reg   = rax;  \/\/ Must use rax for cmpxchg instruction\n+  const Register header_reg = c_rarg2;  \/\/ Will contain the old oopMark\n+  const Register obj_reg    = c_rarg3;  \/\/ Will contain the oop\n@@ -1148,7 +1070,1 @@\n-    save_bcp(); \/\/ Save in case of exception\n-\n-    if (LockingMode != LM_LIGHTWEIGHT) {\n-      \/\/ Convert from BasicObjectLock structure to object and BasicLock\n-      \/\/ structure Store the BasicLock address into %rax\n-      lea(swap_reg, Address(lock_reg, BasicObjectLock::lock_offset()));\n-    }\n+  save_bcp(); \/\/ Save in case of exception\n@@ -1156,2 +1072,2 @@\n-    \/\/ Load oop into obj_reg(%c_rarg3)\n-    movptr(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset()));\n+  \/\/ Load oop into obj_reg(%c_rarg3)\n+  movptr(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset()));\n@@ -1159,2 +1075,2 @@\n-    \/\/ Free entry\n-    movptr(Address(lock_reg, BasicObjectLock::obj_offset()), NULL_WORD);\n+  \/\/ Free entry\n+  movptr(Address(lock_reg, BasicObjectLock::obj_offset()), NULL_WORD);\n@@ -1162,24 +1078,2 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      lightweight_unlock(obj_reg, swap_reg, header_reg, slow_case);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ Load the old header from BasicLock structure\n-      movptr(header_reg, Address(swap_reg,\n-                                 BasicLock::displaced_header_offset_in_bytes()));\n-\n-      \/\/ Test for recursion\n-      testptr(header_reg, header_reg);\n-\n-      \/\/ zero for recursive case\n-      jcc(Assembler::zero, count_locking);\n-\n-      \/\/ Atomic swap back the old header\n-      lock();\n-      cmpxchgptr(header_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-\n-      \/\/ zero for simple unlock of a stack-lock case\n-      jcc(Assembler::notZero, slow_case);\n-\n-      bind(count_locking);\n-      dec_held_monitor_count();\n-    }\n-    jmp(done);\n+  lightweight_unlock(obj_reg, swap_reg, header_reg, slow_case);\n+  jmp(done);\n@@ -1187,4 +1081,4 @@\n-    bind(slow_case);\n-    \/\/ Call the runtime routine for slow case.\n-    movptr(Address(lock_reg, BasicObjectLock::obj_offset()), obj_reg); \/\/ restore obj\n-    call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), lock_reg);\n+  bind(slow_case);\n+  \/\/ Call the runtime routine for slow case.\n+  movptr(Address(lock_reg, BasicObjectLock::obj_offset()), obj_reg); \/\/ restore obj\n+  call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), lock_reg);\n@@ -1192,1 +1086,1 @@\n-    bind(done);\n+  bind(done);\n@@ -1194,2 +1088,1 @@\n-    restore_bcp();\n-  }\n+  restore_bcp();\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":33,"deletions":140,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-        __ jccb(Assembler::equal, L_ok);\n+        __ jcc(Assembler::equal, L_ok);\n@@ -157,1 +157,1 @@\n-        __ jccb(Assembler::notZero, L_ok);\n+        __ jcc(Assembler::notZero, L_ok);\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,11 +62,4 @@\n-\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    if (!UseObjectMonitorTable) {\n-      \/\/ check if monitor\n-      __ testptr(result, markWord::monitor_value);\n-      __ jcc(Assembler::notZero, slowCase);\n-    }\n-  } else {\n-    \/\/ check if locked\n-    __ testptr(result, markWord::unlocked_value);\n-    __ jcc(Assembler::zero, slowCase);\n+  if (!UseObjectMonitorTable) {\n+    \/\/ check if monitor\n+    __ testptr(result, markWord::monitor_value);\n+    __ jcc(Assembler::notZero, slowCase);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86.cpp","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2136,1 +2136,1 @@\n-  if (LockingMode != LM_LEGACY && method->is_object_wait0()) {\n+  if (method->is_object_wait0()) {\n@@ -2177,1 +2177,0 @@\n-  const Register old_hdr  = r13;  \/\/ value of old header at unlock time\n@@ -2183,4 +2182,0 @@\n-    Label count_mon;\n-\n-    const int mark_word_offset = BasicLock::displaced_header_offset_in_bytes();\n-\n@@ -2197,41 +2192,1 @@\n-    if (LockingMode == LM_MONITOR) {\n-      __ jmp(slow_path_lock);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ Load immediate 1 into swap_reg %rax\n-      __ movl(swap_reg, 1);\n-\n-      \/\/ Load (object->mark() | 1) into swap_reg %rax\n-      __ orptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-\n-      \/\/ Save (object->mark() | 1) into BasicLock's displaced header\n-      __ movptr(Address(lock_reg, mark_word_offset), swap_reg);\n-\n-      \/\/ src -> dest iff dest == rax else rax <- dest\n-      __ lock();\n-      __ cmpxchgptr(lock_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-      __ jcc(Assembler::equal, count_mon);\n-\n-      \/\/ Hmm should this move to the slow path code area???\n-\n-      \/\/ Test if the oopMark is an obvious stack pointer, i.e.,\n-      \/\/  1) (mark & 3) == 0, and\n-      \/\/  2) rsp <= mark < mark + os::pagesize()\n-      \/\/ These 3 tests can be done by evaluating the following\n-      \/\/ expression: ((mark - rsp) & (3 - os::vm_page_size())),\n-      \/\/ assuming both stack pointer and pagesize have their\n-      \/\/ least significant 2 bits clear.\n-      \/\/ NOTE: the oopMark is in swap_reg %rax as the result of cmpxchg\n-\n-      __ subptr(swap_reg, rsp);\n-      __ andptr(swap_reg, 3 - (int)os::vm_page_size());\n-\n-      \/\/ Save the test result, for recursive case, the result is zero\n-      __ movptr(Address(lock_reg, mark_word_offset), swap_reg);\n-      __ jcc(Assembler::notEqual, slow_path_lock);\n-\n-      __ bind(count_mon);\n-      __ inc_held_monitor_count();\n-    } else {\n-      assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-      __ lightweight_lock(lock_reg, obj_reg, swap_reg, rscratch1, slow_path_lock);\n-    }\n+    __ lightweight_lock(lock_reg, obj_reg, swap_reg, rscratch1, slow_path_lock);\n@@ -2325,1 +2280,1 @@\n-  if (LockingMode != LM_LEGACY && method->is_object_wait0()) {\n+  if (method->is_object_wait0()) {\n@@ -2357,10 +2312,0 @@\n-    if (LockingMode == LM_LEGACY) {\n-      Label not_recur;\n-      \/\/ Simple recursive lock?\n-      __ cmpptr(Address(rsp, lock_slot_offset * VMRegImpl::stack_slot_size), NULL_WORD);\n-      __ jcc(Assembler::notEqual, not_recur);\n-      __ dec_held_monitor_count();\n-      __ jmpb(fast_done);\n-      __ bind(not_recur);\n-    }\n-\n@@ -2372,17 +2317,1 @@\n-    if (LockingMode == LM_MONITOR) {\n-      __ jmp(slow_path_unlock);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ get address of the stack lock\n-      __ lea(rax, Address(rsp, lock_slot_offset * VMRegImpl::stack_slot_size));\n-      \/\/  get old displaced header\n-      __ movptr(old_hdr, Address(rax, 0));\n-\n-      \/\/ Atomic swap old header if oop still contains the stack lock\n-      __ lock();\n-      __ cmpxchgptr(old_hdr, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-      __ jcc(Assembler::notEqual, slow_path_unlock);\n-      __ dec_held_monitor_count();\n-    } else {\n-      assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-      __ lightweight_unlock(obj_reg, swap_reg, lock_reg, slow_path_unlock);\n-    }\n+    __ lightweight_unlock(obj_reg, swap_reg, lock_reg, slow_path_unlock);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":4,"deletions":75,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-* Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+* Copyright (C) 2021, Tencent. All rights reserved.\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_exp.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-* Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+* Copyright (C) 2021, Tencent. All rights reserved.\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_log.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-* Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+* Copyright (C) 2021, Tencent. All rights reserved.\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_pow.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1020,15 +1020,10 @@\n-  if (LockingMode != LM_LEGACY) {\n-    \/\/ Check preemption for Object.wait()\n-    Label not_preempted;\n-    __ movptr(rscratch1, Address(r15_thread, JavaThread::preempt_alternate_return_offset()));\n-    __ cmpptr(rscratch1, NULL_WORD);\n-    __ jccb(Assembler::equal, not_preempted);\n-    __ movptr(Address(r15_thread, JavaThread::preempt_alternate_return_offset()), NULL_WORD);\n-    __ jmp(rscratch1);\n-    __ bind(native_return);\n-    __ restore_after_resume(true \/* is_native *\/);\n-    __ bind(not_preempted);\n-  } else {\n-    \/\/ any pc will do so just use this one for LM_LEGACY to keep code together.\n-    __ bind(native_return);\n-  }\n+  \/\/ Check preemption for Object.wait()\n+  Label not_preempted;\n+  __ movptr(rscratch1, Address(r15_thread, JavaThread::preempt_alternate_return_offset()));\n+  __ cmpptr(rscratch1, NULL_WORD);\n+  __ jccb(Assembler::equal, not_preempted);\n+  __ movptr(Address(r15_thread, JavaThread::preempt_alternate_return_offset()), NULL_WORD);\n+  __ jmp(rscratch1);\n+  __ bind(native_return);\n+  __ restore_after_resume(true \/* is_native *\/);\n+  __ bind(not_preempted);\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":10,"deletions":15,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"utilities\/ostream.hpp\"\n@@ -1100,7 +1101,7 @@\n-  char buf[2048];\n-  size_t cpu_info_size = jio_snprintf(\n-              buf, sizeof(buf),\n-              \"(%u cores per cpu, %u threads per core) family %d model %d stepping %d microcode 0x%x\",\n-              cores_per_cpu(), threads_per_core(),\n-              cpu_family(), _model, _stepping, os::cpu_microcode_revision());\n-  assert(cpu_info_size > 0, \"not enough temporary space allocated\");\n+  stringStream ss(2048);\n+  ss.print(\"(%u cores per cpu, %u threads per core) family %d model %d stepping %d microcode 0x%x\",\n+           cores_per_cpu(), threads_per_core(),\n+           cpu_family(), _model, _stepping, os::cpu_microcode_revision());\n+  ss.print(\", \");\n+  int features_offset = (int)ss.size();\n+  insert_features_names(_features, ss);\n@@ -1108,7 +1109,2 @@\n-  insert_features_names(_features, buf + cpu_info_size, sizeof(buf) - cpu_info_size);\n-\n-  _cpu_info_string = os::strdup(buf);\n-\n-  _features_string = extract_features_string(_cpu_info_string,\n-                                             strnlen(_cpu_info_string, sizeof(buf)),\n-                                             cpu_info_size);\n+  _cpu_info_string = ss.as_string(true);\n+  _features_string = _cpu_info_string + features_offset;\n@@ -3269,7 +3265,8 @@\n-void VM_Version::insert_features_names(VM_Version::VM_Features features, char* buf, size_t buflen) {\n-  for (int i = 0; i < MAX_CPU_FEATURES; i++) {\n-    if (features.supports_feature((VM_Version::Feature_Flag)i)) {\n-      int res = jio_snprintf(buf, buflen, \", %s\", _features_names[i]);\n-      assert(res > 0, \"not enough temporary space allocated\");\n-      buf += res;\n-      buflen -= res;\n+void VM_Version::insert_features_names(VM_Version::VM_Features features, stringStream& ss) {\n+  int i = 0;\n+  ss.join([&]() {\n+    while (i < MAX_CPU_FEATURES) {\n+      if (_features.supports_feature((VM_Version::Feature_Flag)i)) {\n+        return _features_names[i++];\n+      }\n+      i += 1;\n@@ -3277,1 +3274,2 @@\n-  }\n+    return (const char*)nullptr;\n+  }, \", \");\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":20,"deletions":22,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+class stringStream;\n+\n@@ -925,1 +927,1 @@\n-  static void insert_features_names(VM_Version::VM_Features features, char* buf, size_t buflen);\n+  static void insert_features_names(VM_Version::VM_Features features, stringStream& ss);\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -14076,25 +14076,0 @@\n-instruct cmpFastLock(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rRegP scr) %{\n-  predicate(LockingMode != LM_LIGHTWEIGHT);\n-  match(Set cr (FastLock object box));\n-  effect(TEMP tmp, TEMP scr, USE_KILL box);\n-  ins_cost(300);\n-  format %{ \"fastlock $object,$box\\t! kills $box,$tmp,$scr\" %}\n-  ins_encode %{\n-    __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,\n-                 $scr$$Register, noreg, noreg, r15_thread, nullptr);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct cmpFastUnlock(rFlagsReg cr, rRegP object, rax_RegP box, rRegP tmp) %{\n-  predicate(LockingMode != LM_LIGHTWEIGHT);\n-  match(Set cr (FastUnlock object box));\n-  effect(TEMP tmp, USE_KILL box);\n-  ins_cost(300);\n-  format %{ \"fastunlock $object,$box\\t! kills $box,$tmp\" %}\n-  ins_encode %{\n-    __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -14102,1 +14077,0 @@\n-  predicate(LockingMode == LM_LIGHTWEIGHT);\n@@ -14114,1 +14088,0 @@\n-  predicate(LockingMode == LM_LIGHTWEIGHT);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":0,"deletions":27,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+  \/\/ VM expects i2c entry to be always filled. The rest can be unset.\n@@ -60,2 +61,2 @@\n-                            CAST_FROM_FN_PTR(address,zero_null_code_stub),\n-                            CAST_FROM_FN_PTR(address,zero_null_code_stub),\n+                            nullptr,\n+                            nullptr,\n@@ -63,1 +64,0 @@\n-  return;\n","filename":"src\/hotspot\/cpu\/zero\/sharedRuntime_zero.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2346,2 +2346,1 @@\n-  \/\/ appropriate file descriptors (e.g. as we do in closeDescriptors in\n-  \/\/ UNIXProcess.c), and this in turn might:\n+  \/\/ appropriate file descriptors, and this in turn might:\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2254,2 +2254,1 @@\n-  \/\/ appropriate file descriptors (e.g. as we do in closeDescriptors in\n-  \/\/ UNIXProcess.c), and this in turn might:\n+  \/\/ appropriate file descriptors, and this in turn might:\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4875,3 +4875,2 @@\n-  \/\/ might fork and exec without closing all appropriate file descriptors\n-  \/\/ (e.g. as we do in closeDescriptors in UNIXProcess.c), and this in\n-  \/\/ turn might:\n+  \/\/ might fork and exec without closing all appropriate file descriptors,\n+  \/\/ and this in turn might:\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3300,2 +3300,6 @@\n-  JOBOBJECT_EXTENDED_LIMIT_INFORMATION jeli = {};\n-  BOOL res = QueryInformationJobObject(nullptr, JobObjectExtendedLimitInformation, &jeli, sizeof(jeli), nullptr);\n+  BOOL is_in_job_object = false;\n+  BOOL res = IsProcessInJob(GetCurrentProcess(), nullptr, &is_in_job_object);\n+  if (!res) {\n+    char buf[512];\n+    size_t buf_len = os::lasterror(buf, sizeof(buf));\n+    warning(\"Attempt to determine whether the process is running in a job failed for commit limit: %s\", buf_len != 0 ? buf : \"<unknown error>\");\n@@ -3303,0 +3307,11 @@\n+    \/\/ Conservatively assume no limit when there was an error calling IsProcessInJob.\n+    return SIZE_MAX;\n+  }\n+\n+  if (!is_in_job_object) {\n+    \/\/ Not limited by a Job Object\n+    return SIZE_MAX;\n+  }\n+\n+  JOBOBJECT_EXTENDED_LIMIT_INFORMATION jeli = {};\n+  res = QueryInformationJobObject(nullptr, JobObjectExtendedLimitInformation, &jeli, sizeof(jeli), nullptr);\n@@ -3306,1 +3321,1 @@\n-    warning(\"Attempt to query job object information failed: %s\", buf_len != 0 ? buf : \"<unknown error>\");\n+    warning(\"Attempt to query job object information failed for commit limit: %s\", buf_len != 0 ? buf : \"<unknown error>\");\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -70,1 +70,2 @@\n-  _features = CPU_FP | CPU_ASIMD;\n+  set_feature(CPU_FP);\n+  set_feature(CPU_ASIMD);\n@@ -78,1 +79,4 @@\n-  _features |= CPU_AES | CPU_PMULL | CPU_SHA1 | CPU_SHA2;\n+  set_feature(CPU_AES);\n+  set_feature(CPU_PMULL);\n+  set_feature(CPU_SHA1);\n+  set_feature(CPU_SHA2);\n@@ -81,1 +85,1 @@\n-    _features |= CPU_CRC32;\n+    set_feature(CPU_CRC32);\n@@ -85,1 +89,1 @@\n-    _features |= CPU_LSE;\n+    set_feature(CPU_LSE);\n@@ -89,1 +93,1 @@\n-    _features |= CPU_SHA512;\n+    set_feature(CPU_SHA512);\n@@ -93,1 +97,1 @@\n-    _features |= CPU_SHA3;\n+    set_feature(CPU_SHA3);\n@@ -96,1 +100,1 @@\n-    _features |= CPU_SB;\n+    set_feature(CPU_SB);\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/vm_version_bsd_aarch64.cpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -120,16 +120,16 @@\n-  static_assert(CPU_FP      == HWCAP_FP,      \"Flag CPU_FP must follow Linux HWCAP\");\n-  static_assert(CPU_ASIMD   == HWCAP_ASIMD,   \"Flag CPU_ASIMD must follow Linux HWCAP\");\n-  static_assert(CPU_EVTSTRM == HWCAP_EVTSTRM, \"Flag CPU_EVTSTRM must follow Linux HWCAP\");\n-  static_assert(CPU_AES     == HWCAP_AES,     \"Flag CPU_AES must follow Linux HWCAP\");\n-  static_assert(CPU_PMULL   == HWCAP_PMULL,   \"Flag CPU_PMULL must follow Linux HWCAP\");\n-  static_assert(CPU_SHA1    == HWCAP_SHA1,    \"Flag CPU_SHA1 must follow Linux HWCAP\");\n-  static_assert(CPU_SHA2    == HWCAP_SHA2,    \"Flag CPU_SHA2 must follow Linux HWCAP\");\n-  static_assert(CPU_CRC32   == HWCAP_CRC32,   \"Flag CPU_CRC32 must follow Linux HWCAP\");\n-  static_assert(CPU_LSE     == HWCAP_ATOMICS, \"Flag CPU_LSE must follow Linux HWCAP\");\n-  static_assert(CPU_DCPOP   == HWCAP_DCPOP,   \"Flag CPU_DCPOP must follow Linux HWCAP\");\n-  static_assert(CPU_SHA3    == HWCAP_SHA3,    \"Flag CPU_SHA3 must follow Linux HWCAP\");\n-  static_assert(CPU_SHA512  == HWCAP_SHA512,  \"Flag CPU_SHA512 must follow Linux HWCAP\");\n-  static_assert(CPU_SVE     == HWCAP_SVE,     \"Flag CPU_SVE must follow Linux HWCAP\");\n-  static_assert(CPU_PACA    == HWCAP_PACA,    \"Flag CPU_PACA must follow Linux HWCAP\");\n-  static_assert(CPU_FPHP    == HWCAP_FPHP,    \"Flag CPU_FPHP must follow Linux HWCAP\");\n-  static_assert(CPU_ASIMDHP == HWCAP_ASIMDHP, \"Flag CPU_ASIMDHP must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_FP)      == HWCAP_FP,      \"Flag CPU_FP must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_ASIMD)   == HWCAP_ASIMD,   \"Flag CPU_ASIMD must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_EVTSTRM) == HWCAP_EVTSTRM, \"Flag CPU_EVTSTRM must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_AES)     == HWCAP_AES,     \"Flag CPU_AES must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_PMULL)   == HWCAP_PMULL,   \"Flag CPU_PMULL must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_SHA1)    == HWCAP_SHA1,    \"Flag CPU_SHA1 must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_SHA2)    == HWCAP_SHA2,    \"Flag CPU_SHA2 must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_CRC32)   == HWCAP_CRC32,   \"Flag CPU_CRC32 must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_LSE)     == HWCAP_ATOMICS, \"Flag CPU_LSE must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_DCPOP)   == HWCAP_DCPOP,   \"Flag CPU_DCPOP must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_SHA3)    == HWCAP_SHA3,    \"Flag CPU_SHA3 must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_SHA512)  == HWCAP_SHA512,  \"Flag CPU_SHA512 must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_SVE)     == HWCAP_SVE,     \"Flag CPU_SVE must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_PACA)    == HWCAP_PACA,    \"Flag CPU_PACA must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_FPHP)    == HWCAP_FPHP,    \"Flag CPU_FPHP must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_ASIMDHP) == HWCAP_ASIMDHP, \"Flag CPU_ASIMDHP must follow Linux HWCAP\");\n@@ -155,2 +155,6 @@\n-  if (auxv2 & HWCAP2_SVE2) _features |= CPU_SVE2;\n-  if (auxv2 & HWCAP2_SVEBITPERM) _features |= CPU_SVEBITPERM;\n+  if (auxv2 & HWCAP2_SVE2) {\n+    set_feature(CPU_SVE2);\n+  }\n+  if (auxv2 & HWCAP2_SVEBITPERM) {\n+    set_feature(CPU_SVEBITPERM);\n+  }\n@@ -190,1 +194,1 @@\n-            guarantee(_features & CPU_DCPOP, \"dcpop availability should be consistent\");\n+            guarantee(supports_feature(CPU_DCPOP), \"dcpop availability should be consistent\");\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/vm_version_linux_aarch64.cpp","additions":23,"deletions":19,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -212,2 +212,10 @@\n-  Unimplemented();\n-  return nullptr;\n+  assert(ucVoid != nullptr, \"invariant\");\n+  const ucontext_t* uc = (const ucontext_t*)ucVoid;\n+  assert(os::Posix::ucontext_is_interpreter(uc), \"invariant\");\n+#if (FP_REG_NUM == 11)\n+  assert(Rbcp == R7, \"expected FP=R11, Rbcp=R7\");\n+  return (intptr_t*)uc->uc_mcontext.arm_r7;\n+#else\n+  assert(Rbcp == R11, \"expected FP=R7, Rbcp=R11\");\n+  return (intptr_t*)uc->uc_mcontext.arm_fp; \/\/ r11\n+#endif\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/os_linux_arm.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"utilities\/resizeableResourceHash.hpp\"\n+#include \"utilities\/resizableHashTable.hpp\"\n@@ -544,1 +544,1 @@\n-  typedef ResizeableResourceHashtable<address, Offsets, AnyObj::C_HEAP, mtCompiler> SharedTrampolineRequests;\n+  typedef ResizeableHashTable<address, Offsets, AnyObj::C_HEAP, mtCompiler> SharedTrampolineRequests;\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -50,1 +50,1 @@\n-using ClassesTable = ResourceHashtable<Klass*, bool, TABLE_SIZE, AnyObj::C_HEAP, mtClassShared>;\n+using ClassesTable = HashTable<Klass*, bool, TABLE_SIZE, AnyObj::C_HEAP, mtClassShared>;\n","filename":"src\/hotspot\/share\/cds\/aotArtifactFinder.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"utilities\/hashTable.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -72,1 +72,1 @@\n-  using ClassesTable = ResourceHashtable<InstanceKlass*, bool, TABLE_SIZE, AnyObj::C_HEAP, mtClassShared>;\n+  using ClassesTable = HashTable<InstanceKlass*, bool, TABLE_SIZE, AnyObj::C_HEAP, mtClassShared>;\n","filename":"src\/hotspot\/share\/cds\/aotClassLinker.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"utilities\/hashTable.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -56,1 +56,1 @@\n-  using ClassesTable = ResourceHashtable<InstanceKlass*, bool, TABLE_SIZE, AnyObj::C_HEAP, mtClassShared> ;\n+  using ClassesTable = HashTable<InstanceKlass*, bool, TABLE_SIZE, AnyObj::C_HEAP, mtClassShared> ;\n","filename":"src\/hotspot\/share\/cds\/aotConstantPoolResolver.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -95,1 +95,1 @@\n-class KeepAliveObjectsTable : public ResourceHashtable<oop, bool,\n+class KeepAliveObjectsTable : public HashTable<oop, bool,\n","filename":"src\/hotspot\/share\/cds\/aotReferenceObjSupport.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,2 +39,2 @@\n-#include \"utilities\/resizeableResourceHash.hpp\"\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n+#include \"utilities\/resizableHashTable.hpp\"\n@@ -232,2 +232,2 @@\n-  ResizeableResourceHashtable<address, SourceObjInfo, AnyObj::C_HEAP, mtClassShared> _src_obj_table;\n-  ResizeableResourceHashtable<address, address, AnyObj::C_HEAP, mtClassShared> _buffered_to_src_table;\n+  ResizeableHashTable<address, SourceObjInfo, AnyObj::C_HEAP, mtClassShared> _src_obj_table;\n+  ResizeableHashTable<address, address, AnyObj::C_HEAP, mtClassShared> _buffered_to_src_table;\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -351,1 +351,1 @@\n-  ResourceHashtable<uintptr_t, bool>* _table;\n+  HashTable<uintptr_t, bool>* _table;\n@@ -354,1 +354,1 @@\n-  VerifyLoadedHeapEmbeddedPointers(ResourceHashtable<uintptr_t, bool>* table) : _table(table) {}\n+  VerifyLoadedHeapEmbeddedPointers(HashTable<uintptr_t, bool>* table) : _table(table) {}\n@@ -414,1 +414,1 @@\n-  ResourceHashtable<uintptr_t, bool> table;\n+  HashTable<uintptr_t, bool> table;\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-typedef ResourceHashtable<\n+typedef HashTable<\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"utilities\/hashTable.hpp\"\n@@ -36,1 +37,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -155,1 +155,1 @@\n-  typedef ResizeableResourceHashtable<size_t, oop,\n+  typedef ResizeableHashTable<size_t, oop,\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -646,2 +646,11 @@\n-    if (is_dumping_preimage_static_archive() || is_dumping_final_static_archive()) {\n-      \/\/ Don't tweak execution mode\n+    if (is_dumping_preimage_static_archive()) {\n+      \/\/ Don't tweak execution mode during AOT training run\n+    } else if (is_dumping_final_static_archive()) {\n+      if (Arguments::mode() == Arguments::_comp) {\n+        \/\/ AOT assembly phase submits the non-blocking compilation requests\n+        \/\/ for methods collected during training run, then waits for all compilations\n+        \/\/ to complete. With -Xcomp, we block for each compilation request, which is\n+        \/\/ counter-productive. Switching back to mixed mode improves testing time\n+        \/\/ with AOT and -Xcomp.\n+        Arguments::set_mode_flags(Arguments::_mixed);\n+      }\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -50,1 +50,1 @@\n-  ResourceHashtable<oop, StaticFieldInfo,\n+  HashTable<oop, StaticFieldInfo,\n@@ -82,1 +82,1 @@\n-  \/\/ For ResourceHashtable::iterate()\n+  \/\/ For HashTable::iterate()\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"utilities\/resizeableResourceHash.hpp\"\n+#include \"utilities\/resizableHashTable.hpp\"\n@@ -80,1 +80,1 @@\n-  typedef ResizeableResourceHashtable<int, InstanceKlass*,\n+  typedef ResizeableHashTable<int, InstanceKlass*,\n","filename":"src\/hotspot\/share\/cds\/classListParser.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-class ClassListWriter::IDTable : public ResourceHashtable<\n+class ClassListWriter::IDTable : public HashTable<\n","filename":"src\/hotspot\/share\/cds\/classListWriter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -243,1 +243,1 @@\n-using DumpTimeSharedClassTableBaseType = ResourceHashtable<\n+using DumpTimeSharedClassTableBaseType = HashTable<\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -370,1 +370,1 @@\n-class MetaspaceObjToOopHandleTable: public ResourceHashtable<MetaspaceObj*, OopHandle,\n+class MetaspaceObjToOopHandleTable: public HashTable<MetaspaceObj*, OopHandle,\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -205,1 +205,1 @@\n-  typedef ResizeableResourceHashtable<oop, CachedOopInfo,\n+  typedef ResizeableHashTable<oop, CachedOopInfo,\n@@ -212,1 +212,1 @@\n-    : public ResourceHashtable<Klass*, KlassSubGraphInfo,\n+    : public HashTable<Klass*, KlassSubGraphInfo,\n@@ -267,1 +267,1 @@\n-  typedef ResizeableResourceHashtable<oop, bool,\n+  typedef ResizeableHashTable<oop, bool,\n@@ -471,1 +471,1 @@\n-  public ResizeableResourceHashtable<oop, bool,\n+  public ResizeableHashTable<oop, bool,\n@@ -478,1 +478,1 @@\n-    ResizeableResourceHashtable<oop, bool,\n+    ResizeableHashTable<oop, bool,\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -252,1 +252,1 @@\n-  : public ResourceHashtable<LambdaProxyClassKey,\n+  : public HashTable<LambdaProxyClassKey,\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -100,0 +100,1 @@\n+#include \"utilities\/hashTable.hpp\"\n@@ -102,1 +103,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -181,1 +181,1 @@\n-  ResizeableResourceHashtable<InstanceKlass*, bool,\n+  ResizeableHashTable<InstanceKlass*, bool,\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -37,1 +37,1 @@\n-using RegeneratedObjTable = ResourceHashtable<address, address, 15889, AnyObj::C_HEAP, mtClassShared>;\n+using RegeneratedObjTable = HashTable<address, address, 15889, AnyObj::C_HEAP, mtClassShared>;\n","filename":"src\/hotspot\/share\/cds\/regeneratedClasses.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,2 +33,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n-\n+#include \"utilities\/hashTable.hpp\"\n@@ -128,1 +127,1 @@\n-  typedef ResourceHashtable<BytecodeCPEntry, u2,\n+  typedef HashTable<BytecodeCPEntry, u2,\n","filename":"src\/hotspot\/share\/classfile\/bytecodeAssembler.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -84,0 +84,1 @@\n+#include \"utilities\/hashTable.hpp\"\n@@ -86,1 +87,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -785,1 +785,1 @@\n-using NameSigHashtable = ResourceHashtable<NameSigHash, int,\n+using NameSigHashtable = HashTable<NameSigHash, int,\n@@ -852,1 +852,1 @@\n-    ResourceHashtable<Symbol*, int>* interface_names = new ResourceHashtable<Symbol*, int>();\n+    HashTable<Symbol*, int>* interface_names = new HashTable<Symbol*, int>();\n@@ -2025,1 +2025,1 @@\n-  typedef ResourceHashtable<LocalVariableTableElement, LocalVariableTableElement*,\n+  typedef HashTable<LocalVariableTableElement, LocalVariableTableElement*,\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-\n@@ -35,2 +34,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n-\n+#include \"utilities\/hashTable.hpp\"\n@@ -108,1 +106,1 @@\n-  typedef ResourceHashtable<oop, ClassLoaderStats,\n+  typedef HashTable<oop, ClassLoaderStats,\n","filename":"src\/hotspot\/share\/classfile\/classLoaderStats.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1902,14 +1902,10 @@\n-oop java_lang_Thread::async_get_stack_trace(oop java_thread, TRAPS) {\n-  ThreadsListHandle tlh(JavaThread::current());\n-  JavaThread* thread;\n-  bool is_virtual = java_lang_VirtualThread::is_instance(java_thread);\n-  if (is_virtual) {\n-    oop carrier_thread = java_lang_VirtualThread::carrier_thread(java_thread);\n-    if (carrier_thread == nullptr) {\n-      return nullptr;\n-    }\n-    thread = java_lang_Thread::thread(carrier_thread);\n-  } else {\n-    thread = java_lang_Thread::thread(java_thread);\n-  }\n-  if (thread == nullptr) {\n+\/\/ Obtain stack trace for platform or mounted virtual thread.\n+\/\/ If jthread is a virtual thread and it has been unmounted (or remounted to different carrier) the method returns null.\n+\/\/ The caller (java.lang.VirtualThread) handles returned nulls via retry.\n+oop java_lang_Thread::async_get_stack_trace(jobject jthread, TRAPS) {\n+  ThreadsListHandle tlh(THREAD);\n+  JavaThread* java_thread = nullptr;\n+  oop thread_oop;\n+\n+  bool has_java_thread = tlh.cv_internal_thread_to_JavaThread(jthread, &java_thread, &thread_oop);\n+  if (!has_java_thread) {\n@@ -1921,1 +1917,1 @@\n-    const Handle _java_thread;\n+    const Handle _thread_h;\n@@ -1927,2 +1923,2 @@\n-    GetStackTraceHandshakeClosure(Handle java_thread) :\n-        HandshakeClosure(\"GetStackTraceHandshakeClosure\"), _java_thread(java_thread), _depth(0), _retry_handshake(false),\n+    GetStackTraceHandshakeClosure(Handle thread_h) :\n+        HandshakeClosure(\"GetStackTraceHandshakeClosure\"), _thread_h(thread_h), _depth(0), _retry_handshake(false),\n@@ -1950,1 +1946,1 @@\n-      JavaThread* thread = JavaThread::cast(th);\n+      JavaThread* java_thread = JavaThread::cast(th);\n@@ -1952,1 +1948,1 @@\n-      if (!thread->has_last_Java_frame()) {\n+      if (!java_thread->has_last_Java_frame()) {\n@@ -1957,5 +1953,6 @@\n-      if (java_lang_VirtualThread::is_instance(_java_thread())) {\n-        \/\/ if (thread->vthread() != _java_thread()) \/\/ We might be inside a System.executeOnCarrierThread\n-        const ContinuationEntry* ce = thread->vthread_continuation();\n-        if (ce == nullptr || ce->cont_oop(thread) != java_lang_VirtualThread::continuation(_java_thread())) {\n-          return; \/\/ not mounted\n+      if (java_lang_VirtualThread::is_instance(_thread_h())) {\n+        \/\/ Ensure _thread_h is still mounted to java_thread.\n+        const ContinuationEntry* ce = java_thread->vthread_continuation();\n+        if (ce == nullptr || ce->cont_oop(java_thread) != java_lang_VirtualThread::continuation(_thread_h())) {\n+          \/\/ Target thread has been unmounted.\n+          return;\n@@ -1964,1 +1961,1 @@\n-        carrier = (thread->vthread_continuation() != nullptr);\n+        carrier = (java_thread->vthread_continuation() != nullptr);\n@@ -1976,1 +1973,1 @@\n-      for (vframeStream vfst(thread, false, false, carrier); \/\/ we don't process frames as we don't care about oops\n+      for (vframeStream vfst(java_thread, false, false, carrier); \/\/ we don't process frames as we don't care about oops\n@@ -1997,1 +1994,1 @@\n-  GetStackTraceHandshakeClosure gsthc(Handle(THREAD, java_thread));\n+  GetStackTraceHandshakeClosure gsthc(Handle(THREAD, thread_oop));\n@@ -1999,1 +1996,1 @@\n-   Handshake::execute(&gsthc, &tlh, thread);\n+   Handshake::execute(&gsthc, &tlh, java_thread);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":25,"deletions":28,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -466,1 +466,1 @@\n-  static oop async_get_stack_trace(oop java_thread, TRAPS);\n+  static oop async_get_stack_trace(jobject jthread, TRAPS);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -150,1 +150,1 @@\n-using InternalLoaderConstraintTable = ResourceHashtable<SymbolHandle, ConstraintSet, 107, AnyObj::C_HEAP, mtClass, SymbolHandle::compute_hash>;\n+using InternalLoaderConstraintTable = HashTable<SymbolHandle, ConstraintSet, 107, AnyObj::C_HEAP, mtClass, SymbolHandle::compute_hash>;\n","filename":"src\/hotspot\/share\/classfile\/loaderConstraints.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"utilities\/hashTable.hpp\"\n@@ -50,1 +51,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -406,1 +406,1 @@\n-typedef ResourceHashtable<\n+typedef HashTable<\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"utilities\/hashTable.hpp\"\n@@ -36,1 +37,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -236,1 +236,1 @@\n-  ResourceHashtable<SymbolHandle, ModuleEntry*, 109, AnyObj::C_HEAP, mtModule,\n+  HashTable<SymbolHandle, ModuleEntry*, 109, AnyObj::C_HEAP, mtModule,\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"utilities\/hashTable.hpp\"\n@@ -43,1 +44,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -215,1 +215,1 @@\n-typedef ResourceHashtable<\n+typedef HashTable<\n","filename":"src\/hotspot\/share\/classfile\/packageEntry.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"utilities\/hashTable.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -236,1 +236,1 @@\n-  ResourceHashtable<SymbolHandle, PackageEntry*, 109, AnyObj::C_HEAP, mtModule,\n+  HashTable<SymbolHandle, PackageEntry*, 109, AnyObj::C_HEAP, mtModule,\n","filename":"src\/hotspot\/share\/classfile\/packageEntry.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -52,1 +52,1 @@\n-using InternalPlaceholderTable = ResourceHashtable<PlaceholderKey, PlaceholderEntry, _placeholder_table_size, AnyObj::C_HEAP, mtClass,\n+using InternalPlaceholderTable = HashTable<PlaceholderKey, PlaceholderEntry, _placeholder_table_size, AnyObj::C_HEAP, mtClass,\n","filename":"src\/hotspot\/share\/classfile\/placeholders.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -56,1 +56,1 @@\n-using InternalResolutionErrorTable = ResourceHashtable<ResolutionErrorKey, ResolutionErrorEntry*, 107, AnyObj::C_HEAP, mtClass,\n+using InternalResolutionErrorTable = HashTable<ResolutionErrorKey, ResolutionErrorEntry*, 107, AnyObj::C_HEAP, mtClass,\n","filename":"src\/hotspot\/share\/classfile\/resolutionErrors.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-#include \"utilities\/resizeableResourceHash.hpp\"\n+#include \"utilities\/resizableHashTable.hpp\"\n@@ -813,1 +813,1 @@\n-  ResizeableResourceHashtable<oop, bool, AnyObj::C_HEAP, mtInternal,\n+  ResizeableHashTable<oop, bool, AnyObj::C_HEAP, mtInternal,\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-using InvokeMethodIntrinsicTable = ResourceHashtable<InvokeMethodKey, Method*, 139, AnyObj::C_HEAP, mtClass,\n+using InvokeMethodIntrinsicTable = HashTable<InvokeMethodKey, Method*, 139, AnyObj::C_HEAP, mtClass,\n@@ -117,1 +117,1 @@\n-using InvokeMethodTypeTable = ResourceHashtable<SymbolHandle, OopHandle, 139, AnyObj::C_HEAP, mtClass, SymbolHandle::compute_hash>;\n+using InvokeMethodTypeTable = HashTable<SymbolHandle, OopHandle, 139, AnyObj::C_HEAP, mtClass, SymbolHandle::compute_hash>;\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+\n@@ -77,1 +78,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -448,1 +449,1 @@\n-class UnregisteredClassesTable : public ResourceHashtable<\n+class UnregisteredClassesTable : public HashTable<\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -273,1 +273,1 @@\n-typedef ResourceHashtable<int, sig_as_verification_types*, 1007>\n+typedef HashTable<int, sig_as_verification_types*, 1007>\n","filename":"src\/hotspot\/share\/classfile\/verifier.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -802,1 +802,1 @@\n-bool AOTCodeCache::store_code_blob(CodeBlob& blob, AOTCodeEntry::Kind entry_kind, uint id, const char* name, int entry_offset_count, int* entry_offsets) {\n+bool AOTCodeCache::store_code_blob(CodeBlob& blob, AOTCodeEntry::Kind entry_kind, uint id, const char* name) {\n@@ -886,12 +886,0 @@\n-  \/\/ Write entries offsets\n-  n = cache->write_bytes(&entry_offset_count, sizeof(int));\n-  if (n != sizeof(int)) {\n-    return false;\n-  }\n-  for (int i = 0; i < entry_offset_count; i++) {\n-    uint32_t off = (uint32_t)entry_offsets[i];\n-    n = cache->write_bytes(&off, sizeof(uint32_t));\n-    if (n != sizeof(uint32_t)) {\n-      return false;\n-    }\n-  }\n@@ -906,1 +894,1 @@\n-bool AOTCodeCache::store_code_blob(CodeBlob& blob, AOTCodeEntry::Kind entry_kind, BlobId id, int entry_offset_count, int* entry_offsets) {\n+bool AOTCodeCache::store_code_blob(CodeBlob& blob, AOTCodeEntry::Kind entry_kind, BlobId id) {\n@@ -909,1 +897,1 @@\n-  return store_code_blob(blob, entry_kind, (uint)id, StubInfo::name(id), entry_offset_count, entry_offsets);\n+  return store_code_blob(blob, entry_kind, (uint)id, StubInfo::name(id));\n@@ -912,1 +900,1 @@\n-CodeBlob* AOTCodeCache::load_code_blob(AOTCodeEntry::Kind entry_kind, uint id, const char* name, int entry_offset_count, int* entry_offsets) {\n+CodeBlob* AOTCodeCache::load_code_blob(AOTCodeEntry::Kind entry_kind, uint id, const char* name) {\n@@ -932,1 +920,1 @@\n-  CodeBlob* blob = reader.compile_code_blob(name, entry_offset_count, entry_offsets);\n+  CodeBlob* blob = reader.compile_code_blob(name);\n@@ -939,1 +927,1 @@\n-CodeBlob* AOTCodeCache::load_code_blob(AOTCodeEntry::Kind entry_kind, BlobId id, int entry_offset_count, int* entry_offsets) {\n+CodeBlob* AOTCodeCache::load_code_blob(AOTCodeEntry::Kind entry_kind, BlobId id) {\n@@ -942,1 +930,1 @@\n-  return load_code_blob(entry_kind, (uint)id, StubInfo::name(id), entry_offset_count, entry_offsets);\n+  return load_code_blob(entry_kind, (uint)id, StubInfo::name(id));\n@@ -945,1 +933,1 @@\n-CodeBlob* AOTCodeReader::compile_code_blob(const char* name, int entry_offset_count, int* entry_offsets) {\n+CodeBlob* AOTCodeReader::compile_code_blob(const char* name) {\n@@ -992,15 +980,0 @@\n-  \/\/ Read entries offsets\n-  offset = read_position();\n-  int stored_count = *(int*)addr(offset);\n-  assert(stored_count == entry_offset_count, \"entry offset count mismatch, count in AOT code cache=%d, expected=%d\", stored_count, entry_offset_count);\n-  offset += sizeof(int);\n-  set_read_position(offset);\n-  for (int i = 0; i < stored_count; i++) {\n-    uint32_t off = *(uint32_t*)addr(offset);\n-    offset += sizeof(uint32_t);\n-    const char* entry_name = (_entry->kind() == AOTCodeEntry::Adapter) ? AdapterHandlerEntry::entry_name(i) : \"\";\n-    log_trace(aot, codecache, stubs)(\"Reading adapter '%s:%s' (0x%x) offset: 0x%x from AOT Code Cache\",\n-                                      stored_name, entry_name, _entry->id(), off);\n-    entry_offsets[i] = off;\n-  }\n-\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":8,"deletions":35,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -335,3 +335,1 @@\n-                              uint id, const char* name,\n-                              int entry_offset_count = 0,\n-                              int* entry_offsets = nullptr) NOT_CDS_RETURN_(false);\n+                              uint id, const char* name) NOT_CDS_RETURN_(false);\n@@ -340,3 +338,1 @@\n-                                  uint id, const char* name,\n-                                  int entry_offset_count = 0,\n-                                  int* entry_offsets = nullptr) NOT_CDS_RETURN_(nullptr);\n+                                  uint id, const char* name) NOT_CDS_RETURN_(nullptr);\n@@ -347,3 +343,1 @@\n-                              BlobId id,\n-                              int entry_offset_count = 0,\n-                              int* entry_offsets = nullptr) NOT_CDS_RETURN_(false);\n+                              BlobId id) NOT_CDS_RETURN_(false);\n@@ -352,3 +346,1 @@\n-                                  BlobId id,\n-                                  int entry_offset_count = 0,\n-                                  int* entry_offsets = nullptr) NOT_CDS_RETURN_(nullptr);\n+                                  BlobId id) NOT_CDS_RETURN_(nullptr);\n@@ -417,1 +409,1 @@\n-  CodeBlob* compile_code_blob(const char* name, int entry_offset_count, int* entry_offsets);\n+  CodeBlob* compile_code_blob(const char* name);\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.hpp","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -392,2 +392,2 @@\n-BufferBlob::BufferBlob(const char* name, CodeBlobKind kind, int size)\n-: RuntimeBlob(name, kind, size, sizeof(BufferBlob))\n+BufferBlob::BufferBlob(const char* name, CodeBlobKind kind, int size, uint16_t header_size)\n+: RuntimeBlob(name, kind, size, header_size)\n@@ -416,2 +416,2 @@\n-BufferBlob::BufferBlob(const char* name, CodeBlobKind kind, CodeBuffer* cb, int size)\n-  : RuntimeBlob(name, kind, cb, size, sizeof(BufferBlob), CodeOffsets::frame_never_safe, 0, nullptr)\n+BufferBlob::BufferBlob(const char* name, CodeBlobKind kind, CodeBuffer* cb, int size, uint16_t header_size)\n+  : RuntimeBlob(name, kind, cb, size, header_size, CodeOffsets::frame_never_safe, 0, nullptr)\n@@ -449,2 +449,12 @@\n-AdapterBlob::AdapterBlob(int size, CodeBuffer* cb) :\n-  BufferBlob(\"I2C\/C2I adapters\", CodeBlobKind::Adapter, cb, size) {\n+AdapterBlob::AdapterBlob(int size, CodeBuffer* cb, int entry_offset[AdapterBlob::ENTRY_COUNT]) :\n+  BufferBlob(\"I2C\/C2I adapters\", CodeBlobKind::Adapter, cb, size, sizeof(AdapterBlob)) {\n+  assert(entry_offset[0] == 0, \"sanity check\");\n+  for (int i = 1; i < AdapterBlob::ENTRY_COUNT; i++) {\n+    \/\/ The entry is within the adapter blob or unset.\n+    assert((entry_offset[i] > 0 && entry_offset[i] < cb->insts()->size()) ||\n+           (entry_offset[i] == -1),\n+           \"invalid entry offset[%d] = 0x%x\", i, entry_offset[i]);\n+  }\n+  _c2i_offset = entry_offset[1];\n+  _c2i_unverified_offset = entry_offset[2];\n+  _c2i_no_clinit_check_offset = entry_offset[3];\n@@ -454,1 +464,1 @@\n-AdapterBlob* AdapterBlob::create(CodeBuffer* cb) {\n+AdapterBlob* AdapterBlob::create(CodeBuffer* cb, int entry_offset[AdapterBlob::ENTRY_COUNT]) {\n@@ -463,1 +473,1 @@\n-    blob = new (size) AdapterBlob(size, cb);\n+    blob = new (size) AdapterBlob(size, cb, entry_offset);\n@@ -471,0 +481,7 @@\n+void AdapterBlob::get_offsets(int entry_offset[ENTRY_COUNT]) {\n+  entry_offset[0] = 0;\n+  entry_offset[1] = _c2i_offset;\n+  entry_offset[2] = _c2i_unverified_offset;\n+  entry_offset[3] = _c2i_no_clinit_check_offset;\n+}\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":25,"deletions":8,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -375,2 +375,2 @@\n-  BufferBlob(const char* name, CodeBlobKind kind, int size);\n-  BufferBlob(const char* name, CodeBlobKind kind, CodeBuffer* cb, int size);\n+  BufferBlob(const char* name, CodeBlobKind kind, int size, uint16_t header_size = sizeof(BufferBlob));\n+  BufferBlob(const char* name, CodeBlobKind kind, CodeBuffer* cb, int size, uint16_t header_size = sizeof(BufferBlob));\n@@ -407,0 +407,2 @@\n+public:\n+  static const int ENTRY_COUNT = 4;\n@@ -408,2 +410,5 @@\n-  AdapterBlob(int size, CodeBuffer* cb);\n-\n+  AdapterBlob(int size, CodeBuffer* cb, int entry_offset[ENTRY_COUNT]);\n+  \/\/ _i2c_offset is always 0 so no need to store it\n+  int _c2i_offset;\n+  int _c2i_unverified_offset;\n+  int _c2i_no_clinit_check_offset;\n@@ -412,1 +417,2 @@\n-  static AdapterBlob* create(CodeBuffer* cb);\n+  static AdapterBlob* create(CodeBuffer* cb, int entry_offset[ENTRY_COUNT]);\n+  void get_offsets(int entry_offset[ENTRY_COUNT]);\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1188,1 +1188,1 @@\n-  typedef ResourceHashtable<DependencySignature, int, 11027,\n+  typedef HashTable<DependencySignature, int, 11027,\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -407,1 +407,1 @@\n-void CompilationPolicy::print_counters(const char* prefix, Method* m) {\n+void CompilationPolicy::print_counters_on(outputStream* st, const char* prefix, Method* m) {\n@@ -419,6 +419,5 @@\n-  tty->print(\" %stotal=%d,%d %smdo=%d(%d),%d(%d)\", prefix,\n-      invocation_count, backedge_count, prefix,\n-      mdo_invocations, mdo_invocations_start,\n-      mdo_backedges, mdo_backedges_start);\n-  tty->print(\" %smax levels=%d,%d\", prefix,\n-      m->highest_comp_level(), m->highest_osr_comp_level());\n+  st->print(\" %stotal=%d,%d %smdo=%d(%d),%d(%d)\", prefix,\n+    invocation_count, backedge_count, prefix,\n+    mdo_invocations, mdo_invocations_start,\n+    mdo_backedges, mdo_backedges_start);\n+  st->print(\" %smax levels=%d,%d\", prefix, m->highest_comp_level(), m->highest_osr_comp_level());\n@@ -427,1 +426,1 @@\n-void CompilationPolicy::print_training_data(const char* prefix, Method* method) {\n+void CompilationPolicy::print_training_data_on(outputStream* st,  const char* prefix, Method* method) {\n@@ -429,1 +428,1 @@\n-  tty->print(\" %smtd: \", prefix);\n+  st->print(\" %smtd: \", prefix);\n@@ -432,1 +431,1 @@\n-    tty->print(\"null\");\n+    st->print(\"null\");\n@@ -435,1 +434,1 @@\n-    tty->print(\"mdo=\");\n+    st->print(\"mdo=\");\n@@ -437,1 +436,1 @@\n-      tty->print(\"null\");\n+      st->print(\"null\");\n@@ -443,1 +442,1 @@\n-      tty->print(\"%d(%d), %d(%d)\", mdo_invocations, mdo_invocations_start, mdo_backedges, mdo_backedges_start);\n+      st->print(\"%d(%d), %d(%d)\", mdo_invocations, mdo_invocations_start, mdo_backedges, mdo_backedges_start);\n@@ -446,1 +445,1 @@\n-    tty->print(\", deps=\");\n+    st->print(\", deps=\");\n@@ -448,1 +447,1 @@\n-      tty->print(\"null\");\n+      st->print(\"null\");\n@@ -450,1 +449,1 @@\n-      tty->print(\"%d\", ctd->init_deps_left());\n+      st->print(\"%d\", ctd->init_deps_left());\n@@ -456,1 +455,1 @@\n-void CompilationPolicy::print_event(EventType type, Method* m, Method* im, int bci, CompLevel level) {\n+void CompilationPolicy::print_event_on(outputStream *st, EventType type, Method* m, Method* im, int bci, CompLevel level) {\n@@ -459,2 +458,1 @@\n-  ttyLocker tty_lock;\n-  tty->print(\"%lf: [\", os::elapsedTime());\n+  st->print(\"%lf: [\", os::elapsedTime());\n@@ -464,1 +462,1 @@\n-    tty->print(\"call\");\n+    st->print(\"call\");\n@@ -467,1 +465,1 @@\n-    tty->print(\"loop\");\n+    st->print(\"loop\");\n@@ -470,1 +468,1 @@\n-    tty->print(\"compile\");\n+    st->print(\"compile\");\n@@ -473,1 +471,1 @@\n-    tty->print(\"force-compile\");\n+    st->print(\"force-compile\");\n@@ -476,1 +474,1 @@\n-    tty->print(\"remove-from-queue\");\n+    st->print(\"remove-from-queue\");\n@@ -479,1 +477,1 @@\n-    tty->print(\"update-in-queue\");\n+    st->print(\"update-in-queue\");\n@@ -482,1 +480,1 @@\n-    tty->print(\"reprofile\");\n+    st->print(\"reprofile\");\n@@ -485,1 +483,1 @@\n-    tty->print(\"make-not-entrant\");\n+    st->print(\"make-not-entrant\");\n@@ -488,1 +486,1 @@\n-    tty->print(\"unknown\");\n+    st->print(\"unknown\");\n@@ -491,1 +489,1 @@\n-  tty->print(\" level=%d \", level);\n+  st->print(\" level=%d \", level);\n@@ -495,1 +493,1 @@\n-  tty->print(\"[%s\", method_name);\n+  st->print(\"[%s\", method_name);\n@@ -498,1 +496,1 @@\n-    tty->print(\" [%s]] \", inlinee_name);\n+    st->print(\" [%s]] \", inlinee_name);\n@@ -500,3 +498,3 @@\n-  else tty->print(\"] \");\n-  tty->print(\"@%d queues=%d,%d\", bci, CompileBroker::queue_size(CompLevel_full_profile),\n-                                      CompileBroker::queue_size(CompLevel_full_optimization));\n+  else st->print(\"] \");\n+  st->print(\"@%d queues=%d,%d\", bci, CompileBroker::queue_size(CompLevel_full_profile),\n+                                     CompileBroker::queue_size(CompLevel_full_optimization));\n@@ -504,3 +502,3 @@\n-  tty->print(\" rate=\");\n-  if (m->prev_time() == 0) tty->print(\"n\/a\");\n-  else tty->print(\"%f\", m->rate());\n+  st->print(\" rate=\");\n+  if (m->prev_time() == 0) st->print(\"n\/a\");\n+  else st->print(\"%f\", m->rate());\n@@ -508,2 +506,2 @@\n-  tty->print(\" k=%.2lf,%.2lf\", threshold_scale(CompLevel_full_profile, Tier3LoadFeedback),\n-                               threshold_scale(CompLevel_full_optimization, Tier4LoadFeedback));\n+  st->print(\" k=%.2lf,%.2lf\", threshold_scale(CompLevel_full_profile, Tier3LoadFeedback),\n+                              threshold_scale(CompLevel_full_optimization, Tier4LoadFeedback));\n@@ -512,1 +510,1 @@\n-    print_counters(\"\", m);\n+    print_counters_on(st, \"\", m);\n@@ -514,1 +512,1 @@\n-      print_counters(\"inlinee \", im);\n+      print_counters_on(st, \"inlinee \", im);\n@@ -516,1 +514,1 @@\n-    tty->print(\" compilable=\");\n+    st->print(\" compilable=\");\n@@ -519,1 +517,1 @@\n-      tty->print(\"c1\");\n+      st->print(\"c1\");\n@@ -523,2 +521,2 @@\n-      if (need_comma) tty->print(\",\");\n-      tty->print(\"c1-osr\");\n+      if (need_comma) st->print(\",\");\n+      st->print(\"c1-osr\");\n@@ -528,2 +526,2 @@\n-      if (need_comma) tty->print(\",\");\n-      tty->print(\"c2\");\n+      if (need_comma) st->print(\",\");\n+      st->print(\"c2\");\n@@ -533,2 +531,2 @@\n-      if (need_comma) tty->print(\",\");\n-      tty->print(\"c2-osr\");\n+      if (need_comma) st->print(\",\");\n+      st->print(\"c2-osr\");\n@@ -536,1 +534,1 @@\n-    tty->print(\" status=\");\n+    st->print(\" status=\");\n@@ -538,3 +536,4 @@\n-      tty->print(\"in-queue\");\n-    } else tty->print(\"idle\");\n-    print_training_data(\"\", m);\n+      st->print(\"in-queue\");\n+    } else st->print(\"idle\");\n+\n+    print_training_data_on(st, \"\", m);\n@@ -542,1 +541,1 @@\n-      print_training_data(\"inlinee \", im);\n+      print_training_data_on(st, \"inlinee \", im);\n@@ -545,1 +544,9 @@\n-  tty->print_cr(\"]\");\n+  st->print_cr(\"]\");\n+\n+}\n+\n+void CompilationPolicy::print_event(EventType type, Method* m, Method* im, int bci, CompLevel level) {\n+  stringStream s;\n+  print_event_on(&s, type, m, im, bci, level);\n+  ResourceMark rm;\n+  tty->print(\"%s\", s.as_string());\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":62,"deletions":55,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -290,2 +290,2 @@\n-  static void print_counters(const char* prefix, Method* m);\n-  static void print_training_data(const char* prefix, Method* method);\n+  static void print_counters_on(outputStream* st, const char* prefix, Method* m);\n+  static void print_training_data_on(outputStream* st, const char* prefix, Method* method);\n@@ -321,0 +321,1 @@\n+  static void print_event_on(outputStream *st, EventType type, Method* m, Method* im, int bci, CompLevel level);\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -374,0 +374,1 @@\n+    CompileTask* next = current->next();\n@@ -382,1 +383,1 @@\n-    current = current->next();\n+    current = next;\n@@ -507,0 +508,2 @@\n+  task->set_next(nullptr);\n+  task->set_prev(nullptr);\n@@ -1731,6 +1734,9 @@\n-  if (!task->is_complete() && is_compilation_disabled_forever()) {\n-    \/\/ Task is not complete, and we are exiting for compilation shutdown.\n-    \/\/ The task can still be executed by some compiler thread, therefore\n-    \/\/ we cannot delete it. This will leave task allocated, which leaks it.\n-    \/\/ At this (degraded) point, it is less risky to abandon the task,\n-    \/\/ rather than attempting a more complicated deletion protocol.\n+  if (!task->is_complete()) {\n+    \/\/ Task is not complete, likely because we are exiting for compilation\n+    \/\/ shutdown. The task can still be reached through the queue, or executed\n+    \/\/ by some compiler thread. There is no coordination with either MCQ lock\n+    \/\/ holders or compilers, therefore we cannot delete the task.\n+    \/\/\n+    \/\/ This will leave task allocated, which leaks it. At this (degraded) point,\n+    \/\/ it is less risky to abandon the task, rather than attempting a more\n+    \/\/ complicated deletion protocol.\n@@ -1742,0 +1748,2 @@\n+    assert(task->next() == nullptr && task->prev() == nullptr,\n+           \"Completed task should not be in the queue\");\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+  _prev = nullptr;\n","filename":"src\/hotspot\/share\/compiler\/compileTask.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -104,1 +104,2 @@\n-  CompileTask*         _next, *_prev;\n+  CompileTask*         _next;\n+  CompileTask*         _prev;\n","filename":"src\/hotspot\/share\/compiler\/compileTask.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+\n@@ -43,1 +44,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -192,1 +193,1 @@\n-  typedef ResourceHashtable<\n+  typedef HashTable<\n","filename":"src\/hotspot\/share\/compiler\/disassembler.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -775,1 +775,1 @@\n-  abandon_collection_set(collection_set());\n+  abandon_collection_set();\n@@ -851,3 +851,0 @@\n-  const bool do_clear_all_soft_refs = clear_all_soft_refs ||\n-      soft_ref_policy()->should_clear_all_soft_refs();\n-\n@@ -856,1 +853,1 @@\n-  G1FullCollector collector(this, do_clear_all_soft_refs, do_maximal_compaction, gc_mark.tracer());\n+  G1FullCollector collector(this, clear_all_soft_refs, do_maximal_compaction, gc_mark.tracer());\n@@ -989,3 +986,0 @@\n-  assert(!soft_ref_policy()->should_clear_all_soft_refs(),\n-         \"Flag should have been handled and cleared prior to this point\");\n-\n@@ -2794,1 +2788,1 @@\n-void G1CollectedHeap::abandon_collection_set(G1CollectionSet* collection_set) {\n+void G1CollectedHeap::abandon_collection_set() {\n@@ -2798,2 +2792,6 @@\n-  collection_set->clear();\n-  collection_set->stop_incremental_building();\n+  collection_set()->clear();\n+  collection_set()->stop_incremental_building();\n+\n+  collection_set()->abandon_all_candidates();\n+\n+  young_regions_cset_group()->clear();\n@@ -2806,6 +2804,0 @@\n-void G1CollectedHeap::set_region_short_lived_locked(G1HeapRegion* hr) {\n-  _eden.add(hr);\n-  _policy->set_region_eden(hr);\n-  young_regions_cset_group()->add(hr);\n-}\n-\n@@ -2960,2 +2952,3 @@\n-      set_region_short_lived_locked(new_alloc_region);\n-      G1HeapRegionPrinter::alloc(new_alloc_region);\n+      new_alloc_region->set_eden();\n+      _eden.add(new_alloc_region);\n+      _policy->set_region_eden(new_alloc_region);\n@@ -2963,0 +2956,3 @@\n+      \/\/ Install the group cardset.\n+      young_regions_cset_group()->add(new_alloc_region);\n+      G1HeapRegionPrinter::alloc(new_alloc_region);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":15,"deletions":19,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -807,1 +807,1 @@\n-  void abandon_collection_set(G1CollectionSet* collection_set);\n+  void abandon_collection_set();\n@@ -1217,1 +1217,0 @@\n-  void set_region_short_lived_locked(G1HeapRegion* hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    assert(!hr->is_eden(), \"should not already be set\");\n+    assert(hr->is_eden(), \"must be\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EdenRegions.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -249,2 +249,0 @@\n-  _heap->young_regions_cset_group()->clear();\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+    _should_clear_soft_refs(clear_soft),\n@@ -50,1 +51,0 @@\n-    _soft_refs(clear_soft, _g1h->soft_ref_policy()),\n@@ -57,4 +57,0 @@\n-bool G1FullGCScope::should_clear_soft_refs() {\n-  return _soft_refs.should_clear();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCScope.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+  bool                    _should_clear_soft_refs;\n@@ -57,1 +58,0 @@\n-  ClearedAllSoftRefs      _soft_refs;\n@@ -68,1 +68,1 @@\n-  bool should_clear_soft_refs();\n+  bool should_clear_soft_refs() const { return _should_clear_soft_refs; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCScope.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -511,1 +511,0 @@\n-  const GrowableArray<G1HeapRegion*>* survivor_regions = _g1h->survivor()->regions();\n@@ -513,4 +512,2 @@\n-  for (GrowableArrayIterator<G1HeapRegion*> it = survivor_regions->begin();\n-       it != survivor_regions->end();\n-       ++it) {\n-    survivor_regions_evac_time += predict_region_copy_time_ms(*it, _g1h->collector_state()->in_young_only_phase());\n+  for (G1HeapRegion* r : _g1h->survivor()->regions()) {\n+    survivor_regions_evac_time += predict_region_copy_time_ms(r, _g1h->collector_state()->in_young_only_phase());\n@@ -577,1 +574,0 @@\n-  _collection_set->abandon_all_candidates();\n@@ -1465,5 +1461,2 @@\n-  for (GrowableArrayIterator<G1HeapRegion*> it = survivors->regions()->begin();\n-       it != survivors->regions()->end();\n-       ++it) {\n-    G1HeapRegion* curr = *it;\n-    set_region_survivor(curr);\n+  for (G1HeapRegion* r : survivors->regions()) {\n+    set_region_survivor(r);\n@@ -1474,1 +1467,1 @@\n-    _collection_set->add_survivor_regions(curr);\n+    _collection_set->add_survivor_regions(r);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -124,1 +124,0 @@\n-    hr->set_eden();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -989,2 +989,1 @@\n-  \/\/ table. This is in addition to being the HG1eapRegionClosure to iterate over\n-  \/\/ all region's remembered sets.\n+  \/\/ table.\n@@ -995,1 +994,1 @@\n-  class G1MergeCardSetClosure : public G1HeapRegionClosure {\n+  class G1MergeCardSetClosure {\n@@ -1042,1 +1041,0 @@\n-\n@@ -1074,32 +1072,0 @@\n-    \/\/ Helper to merge the cards in the card set for the given region onto the card\n-    \/\/ table.\n-    \/\/\n-    \/\/ Called directly for humongous starts regions because we should not add\n-    \/\/ humongous eager reclaim candidates to the \"all\" list of regions to\n-    \/\/ clear the card table by default as we do not know yet whether this region\n-    \/\/ will be reclaimed (and reused).\n-    \/\/ If the humongous region contains dirty cards, g1 will scan them\n-    \/\/ because dumping the remembered set entries onto the card table will add\n-    \/\/ the humongous region to the \"dirty\" region list to scan. Then scanning\n-    \/\/ either clears the card during scan (if there is only an initial evacuation\n-    \/\/ pass) or the \"dirty\" list will be merged with the \"all\" list later otherwise.\n-    \/\/ (And there is no problem either way if the region does not contain dirty\n-    \/\/ cards).\n-    void merge_card_set_for_region(G1HeapRegion* r) {\n-      assert(r->in_collection_set() || r->is_starts_humongous(), \"must be\");\n-\n-      G1HeapRegionRemSet* rem_set = r->rem_set();\n-      if (!rem_set->is_empty()) {\n-        rem_set->iterate_for_merge(*this);\n-      }\n-    }\n-\n-    virtual bool do_heap_region(G1HeapRegion* r) {\n-      assert(r->in_collection_set(), \"must be\");\n-\n-      _scan_state->add_all_dirty_region(r->hrm_index());\n-      merge_card_set_for_region(r);\n-\n-      return false;\n-    }\n-\n@@ -1192,2 +1158,1 @@\n-        _cl.merge_card_set_for_region(r);\n-\n+        r->rem_set()->iterate_for_merge(_cl);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":3,"deletions":38,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-  _regions(new (mtGC) GrowableArray<G1HeapRegion*>(8, mtGC)),\n+  _regions(8, mtGC),\n@@ -37,1 +37,1 @@\n-  _regions->append(hr);\n+  _regions.append(hr);\n@@ -42,1 +42,1 @@\n-  return (uint)_regions->length();\n+  return (uint)_regions.length();\n@@ -50,5 +50,2 @@\n-  for (GrowableArrayIterator<G1HeapRegion*> it = _regions->begin();\n-       it != _regions->end();\n-       ++it) {\n-    G1HeapRegion* hr = *it;\n-    hr->set_eden_pre_gc();\n+  for (G1HeapRegion* r : _regions) {\n+    r->set_eden_pre_gc();\n@@ -60,1 +57,1 @@\n-  _regions->clear();\n+  _regions.clear();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SurvivorRegions.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -35,0 +36,1 @@\n+\/\/ Set of current survivor regions.\n@@ -36,4 +38,3 @@\n-private:\n-  GrowableArray<G1HeapRegion*>* _regions;\n-  volatile size_t             _used_bytes;\n-  G1RegionsOnNodes            _regions_on_node;\n+  GrowableArray<G1HeapRegion*> _regions;\n+  volatile size_t _used_bytes;\n+  G1RegionsOnNodes _regions_on_node;\n@@ -53,1 +54,1 @@\n-  const GrowableArray<G1HeapRegion*>* regions() const {\n+  const GrowableArray<G1HeapRegion*>& regions() const {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SurvivorRegions.hpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -53,1 +53,3 @@\n-  g1h->do_full_collection(false \/* clear_all_soft_refs *\/,\n+  bool clear_all_soft_refs = _gc_cause == GCCause::_metadata_GC_clear_soft_refs ||\n+                             _gc_cause == GCCause::_wb_full_gc;\n+  g1h->do_full_collection(clear_all_soft_refs \/* clear_all_soft_refs *\/,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -313,5 +313,7 @@\n-      \/\/ If certain conditions hold, try allocating from the old gen.\n-      if (!is_tlab && !should_alloc_in_eden(size)) {\n-        result = old_gen()->cas_allocate_noexpand(size);\n-        if (result != nullptr) {\n-          return result;\n+      \/\/ Try allocating from the old gen for non-TLAB in certain scenarios.\n+      if (!is_tlab) {\n+        if (!should_alloc_in_eden(size) || _is_heap_almost_full) {\n+          result = old_gen()->cas_allocate_noexpand(size);\n+          if (result != nullptr) {\n+            return result;\n+          }\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -688,0 +688,3 @@\n+  \/\/ Need to clear claim bits for the next full-gc (marking and adjust-pointers).\n+  ClassLoaderDataGraph::clear_claimed_marks();\n+\n@@ -1291,3 +1294,0 @@\n-\n-    \/\/ Need to clear claim bits for the next mark.\n-    ClassLoaderDataGraph::clear_claimed_marks();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -284,9 +284,0 @@\n-\/\/ Return true if any of the following is true:\n-\/\/ . the allocation won't fit into the current young gen heap\n-\/\/ . heap memory is tight\n-bool SerialHeap::should_try_older_generation_allocation(size_t word_size) const {\n-  size_t young_capacity = _young_gen->capacity_before_gc();\n-  return    (word_size > heap_word_size(young_capacity))\n-         || _is_heap_almost_full;\n-}\n-\n@@ -311,6 +302,3 @@\n-  \/\/ Loop until the allocation is satisfied, or unsatisfied after GC.\n-  for (uint try_count = 1; \/* return or throw *\/; try_count += 1) {\n-    \/\/ First allocation attempt is lock-free.\n-    DefNewGeneration *young = _young_gen;\n-    if (young->should_allocate(size, is_tlab)) {\n-      result = young->par_allocate(size);\n+  for (uint try_count = 1; \/* break *\/; try_count++) {\n+    if (_young_gen->should_allocate(size, is_tlab)) {\n+      result = _young_gen->par_allocate(size);\n@@ -318,2 +306,11 @@\n-        assert(is_in_reserved(result), \"result not in heap\");\n-        return result;\n+        break;\n+      }\n+    }\n+    \/\/ Try old-gen allocation for non-TLAB.\n+    if (!is_tlab) {\n+      \/\/ If it's too large for young-gen or heap is too full.\n+      if (size > heap_word_size(_young_gen->capacity_before_gc()) || _is_heap_almost_full) {\n+        result = _old_gen->par_allocate(size);\n+        if (result != nullptr) {\n+          break;\n+        }\n@@ -325,12 +322,0 @@\n-      log_trace(gc, alloc)(\"SerialHeap::mem_allocate_work: attempting locked slow path allocation\");\n-      \/\/ Note that only large objects get a shot at being\n-      \/\/ allocated in later generations.\n-      bool first_only = !should_try_older_generation_allocation(size);\n-\n-      result = attempt_allocation(size, is_tlab, first_only);\n-      if (result != nullptr) {\n-        assert(is_in_reserved(result), \"result not in heap\");\n-        return result;\n-      }\n-\n-      \/\/ Read the gc count while the heap lock is held.\n@@ -344,4 +329,1 @@\n-\n-      assert(result == nullptr || is_in_reserved(result),\n-             \"result not in heap\");\n-      return result;\n+      break;\n@@ -357,0 +339,3 @@\n+\n+  assert(result == nullptr || is_in_reserved(result), \"postcondition\");\n+  return result;\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":18,"deletions":33,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -232,4 +232,0 @@\n-  \/\/ Return true if an allocation should be attempted in the older generation\n-  \/\/ if it fails in the younger generation.  Return false, otherwise.\n-  bool should_try_older_generation_allocation(size_t word_size) const;\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -129,0 +129,2 @@\n+  \/\/ Multi-threaded version.\n+  inline HeapWord* par_allocate(size_t word_size);\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,0 +60,8 @@\n+HeapWord* TenuredGeneration::par_allocate(size_t word_size) {\n+  HeapWord* res = _the_space->par_allocate(word_size);\n+  if (res != nullptr) {\n+    _bts->update_for_block(res, res + word_size);\n+  }\n+  return res;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.inline.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -65,5 +65,0 @@\n-VM_GC_Operation::~VM_GC_Operation() {\n-  CollectedHeap* ch = Universe::heap();\n-  ch->soft_ref_policy()->set_all_soft_refs_clear(false);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -120,2 +120,2 @@\n-                  uint full_gc_count_before = 0,\n-                  bool full = false) : VM_Heap_Sync_Operation() {\n+                  uint full_gc_count_before,\n+                  bool full) : VM_Heap_Sync_Operation() {\n@@ -129,8 +129,0 @@\n-    \/\/ In ParallelScavengeHeap::mem_allocate() collections can be\n-    \/\/ executed within a loop and _all_soft_refs_clear can be set\n-    \/\/ true after they have been cleared by a collection and another\n-    \/\/ collection started so that _all_soft_refs_clear can be true\n-    \/\/ when this collection is started.  Don't assert that\n-    \/\/ _all_soft_refs_clear have to be false here even though\n-    \/\/ mutators have run.  Soft refs will be cleared again in this\n-    \/\/ collection.\n@@ -138,1 +130,0 @@\n-  ~VM_GC_Operation();\n@@ -159,2 +150,2 @@\n-                          uint full_gc_count_before = 0,\n-                          bool full = false) :\n+                          uint full_gc_count_before,\n+                          bool full) :\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.hpp","additions":4,"deletions":13,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-#include \"memory\/allocation.hpp\"\n-\n@@ -36,7 +34,0 @@\n-  \/\/ Set to true by the GC if the just-completed gc cleared all\n-  \/\/ softrefs.  This is set to true whenever a gc clears all softrefs, and\n-  \/\/ set to false each time gc returns to the mutator.  For example, in the\n-  \/\/ ParallelScavengeHeap case the latter would be done toward the end of\n-  \/\/ mem_allocate() where it returns op.result()\n-  bool _all_soft_refs_clear;\n-\n@@ -45,2 +36,1 @@\n-    _should_clear_all_soft_refs(false),\n-    _all_soft_refs_clear(false) {}\n+    _should_clear_all_soft_refs(false) {}\n@@ -50,26 +40,0 @@\n-\n-  bool all_soft_refs_clear() { return _all_soft_refs_clear; }\n-  void set_all_soft_refs_clear(bool v) { _all_soft_refs_clear = v; }\n-\n-  \/\/ Called by the GC after Soft Refs have been cleared to indicate\n-  \/\/ that the request in _should_clear_all_soft_refs has been fulfilled.\n-  void cleared_all_soft_refs() {\n-    _all_soft_refs_clear = true;\n-  }\n-};\n-\n-class ClearedAllSoftRefs : public StackObj {\n-  bool           _clear_all_soft_refs;\n-  SoftRefPolicy* _soft_ref_policy;\n- public:\n-  ClearedAllSoftRefs(bool clear_all_soft_refs, SoftRefPolicy* soft_ref_policy) :\n-    _clear_all_soft_refs(clear_all_soft_refs),\n-    _soft_ref_policy(soft_ref_policy) {}\n-\n-  ~ClearedAllSoftRefs() {\n-    if (_clear_all_soft_refs) {\n-      _soft_ref_policy->cleared_all_soft_refs();\n-    }\n-  }\n-\n-  bool should_clear() { return _clear_all_soft_refs; }\n","filename":"src\/hotspot\/share\/gc\/shared\/softRefPolicy.hpp","additions":1,"deletions":37,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2022, Tencent. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2022, Tencent. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2022, Tencent. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-  _paced_time(0),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,2 +61,0 @@\n-  double _paced_time;\n-\n@@ -240,12 +238,0 @@\n-  static void add_paced_time(Thread* thread, double v) {\n-    data(thread)->_paced_time += v;\n-  }\n-\n-  static double paced_time(Thread* thread) {\n-    return data(thread)->_paced_time;\n-  }\n-\n-  static void reset_paced_time(Thread* thread) {\n-    data(thread)->_paced_time = 0;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.hpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -728,2 +728,2 @@\n-      \/\/ finishing, we don't want it to have fewer workers than the old generation.\n-      young_workers = MAX2(old_workers, young_workers);\n+      \/\/ finishing, we ideally don't want it to have fewer workers than the old generation.\n+      young_workers = clamp(MAX2(old_workers, young_workers), 1u, ZYoungGCThreads);\n","filename":"src\/hotspot\/share\/gc\/z\/zDirector.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include \"utilities\/hashTable.hpp\"\n@@ -55,1 +56,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -519,1 +519,1 @@\n-typedef ResourceHashtable<volatile zpointer*, bool, 1009, AnyObj::C_HEAP, mtGC> ZStoreBarrierBufferTable;\n+typedef HashTable<volatile zpointer*, bool, 1009, AnyObj::C_HEAP, mtGC> ZStoreBarrierBufferTable;\n","filename":"src\/hotspot\/share\/gc\/z\/zVerify.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -602,10 +602,0 @@\n-\n-\/* Differs from JVM_GetClassModifiers in treatment of inner classes.\n-   This returns the access flags for the class as specified in the\n-   class file rather than searching the InnerClasses attribute (if\n-   present) to find the source-level access flags. Only the values of\n-   the low 13 bits (i.e., a mask of 0x1FFF) are guaranteed to be\n-   valid. *\/\n-JNIEXPORT jint JNICALL\n-JVM_GetClassAccessFlags(JNIEnv *env, jclass cls);\n-\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"asm\/macroAssembler.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"interpreter\/interp_masm.hpp\"\n@@ -33,1 +33,0 @@\n-#include \"interpreter\/interp_masm.hpp\"\n@@ -40,1 +39,0 @@\n-#include \"oops\/methodData.hpp\"\n@@ -42,0 +40,1 @@\n+#include \"oops\/methodData.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"interpreter\/bytecodeStream.hpp\"\n@@ -27,0 +26,1 @@\n+#include \"interpreter\/bytecodeStream.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeStream.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"interpreter\/bytecodes.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"interpreter\/bytecodes.hpp\"\n@@ -34,1 +34,0 @@\n-#include \"oops\/methodData.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"oops\/methodData.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"runtime\/signature.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"runtime\/signature.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeUtils.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"asm\/macroAssembler.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"interpreter\/interp_masm.hpp\"\n@@ -30,1 +30,0 @@\n-#include \"interpreter\/interp_masm.hpp\"\n@@ -35,1 +34,0 @@\n-#include \"oops\/methodData.hpp\"\n@@ -37,0 +35,1 @@\n+#include \"oops\/methodData.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/interpreter.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-#include \"oops\/methodData.hpp\"\n@@ -51,0 +50,1 @@\n+#include \"oops\/methodData.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"interpreter\/interp_masm.hpp\"\n@@ -27,1 +28,0 @@\n-#include \"interpreter\/interp_masm.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"interpreter\/interp_masm.hpp\"\n@@ -28,1 +29,0 @@\n-#include \"interpreter\/interp_masm.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"interpreter\/zero\/bytecodeInterpreter.inline.hpp\"\n@@ -35,0 +34,1 @@\n+#include \"interpreter\/zero\/bytecodeInterpreter.inline.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"bytecodeInterpreter_zero.inline.hpp\"\n@@ -45,2 +46,0 @@\n-# include \"bytecodeInterpreter_zero.inline.hpp\"\n-\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.inline.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-\/\/ # include \"interpreter\/interp_masm.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/zero\/zeroInterpreterGenerator.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -51,8 +51,0 @@\n-const unsigned int initial_size = 431;\n-\n-static JfrCHeapTraceIdSet* c_heap_allocate_set(int size = initial_size) {\n-  return new JfrCHeapTraceIdSet(size);\n-}\n-\n-static JfrCHeapTraceIdSet* unloaded_thread_id_set = nullptr;\n-\n@@ -69,8 +61,2 @@\n-static bool has_thread_exited(traceid tid) {\n-  assert(tid != 0, \"invariant\");\n-  if (unloaded_thread_id_set == nullptr) {\n-    return false;\n-  }\n-  ThreadIdExclusiveAccess lock;\n-  return unloaded_thread_id_set->contains(tid);\n-}\n+static const unsigned initial_set_size = 512;\n+static JfrCHeapTraceIdSet* unloaded_thread_id_set = nullptr;\n@@ -81,1 +67,1 @@\n-    unloaded_thread_id_set = c_heap_allocate_set();\n+    unloaded_thread_id_set = new (mtTracing) JfrCHeapTraceIdSet(initial_set_size);\n@@ -196,6 +182,0 @@\n-static JfrResourceAreaTraceIdSet* id_set = nullptr;\n-\n-static void prepare_for_resolution() {\n-  id_set = new JfrResourceAreaTraceIdSet(initial_size);\n-}\n-\n@@ -216,0 +196,2 @@\n+static JfrResourceAreaTraceIdSet* resolution_set = nullptr;\n+\n@@ -223,1 +205,1 @@\n-    prepare_for_resolution();\n+    resolution_set = new JfrResourceAreaTraceIdSet(initial_set_size);\n@@ -225,0 +207,1 @@\n+\n@@ -317,2 +300,2 @@\n-  assert(id_set != nullptr, \"invariant\");\n-  return !id_set->add(method_id);\n+  assert(resolution_set != nullptr, \"invariant\");\n+  return !resolution_set->add(method_id);\n@@ -359,1 +342,1 @@\n-  if (sample->is_virtual_thread() || has_thread_exited(sample->thread_id())) {\n+  if (sample->is_virtual_thread() || sample->thread_exited()) {\n@@ -375,1 +358,1 @@\n-  int _count;\n+  unsigned _count;\n@@ -381,1 +364,1 @@\n-  int count() const { return _count; }\n+  unsigned count() const { return _count; }\n@@ -397,2 +380,1 @@\n-  const int64_t count_offset = writer.reserve(sizeof(u4)); \/\/ Don't know how many yet\n-\n+  writer.write_count(_stacktrace_id_set->size());\n@@ -402,1 +384,0 @@\n-  writer.write_count(lpstw.count(), count_offset);\n@@ -425,0 +406,10 @@\n+static void check_if_thread_exited(const ObjectSample* sample) {\n+  assert(sample != nullptr, \"invariant\");\n+  if (sample->thread_exited() || unloaded_thread_id_set == nullptr) {\n+    return;\n+  }\n+  if (unloaded_thread_id_set->contains(sample->thread_id())) {\n+    sample->set_thread_exited();\n+  }\n+}\n+\n@@ -434,0 +425,1 @@\n+    check_if_thread_exited(sample);\n@@ -440,0 +432,7 @@\n+static void delete_unloaded_thread_id_set() {\n+  if (unloaded_thread_id_set != nullptr) {\n+    delete unloaded_thread_id_set;\n+    unloaded_thread_id_set = nullptr;\n+  }\n+}\n+\n@@ -445,0 +444,1 @@\n+  ThreadIdExclusiveAccess lock;\n@@ -446,0 +446,1 @@\n+  delete_unloaded_thread_id_set();\n@@ -448,3 +449,6 @@\n-static inline unsigned int set_size() {\n-  const unsigned int queue_size = static_cast<unsigned int>(JfrOptionSet::old_object_queue_size());\n-  return queue_size > initial_size ? queue_size : initial_size;\n+static inline unsigned stacktrace_id_set_size() {\n+  unsigned queue_size = static_cast<unsigned>(JfrOptionSet::old_object_queue_size());\n+  if (!is_power_of_2(queue_size)) {\n+    queue_size = next_power_of_2(queue_size);\n+  }\n+  return queue_size > initial_set_size ? queue_size : initial_set_size;\n@@ -459,1 +463,3 @@\n-    _stacktrace_id_set = new JfrResourceAreaTraceIdSet(set_size());\n+    const unsigned stacktrace_set_size = stacktrace_id_set_size();\n+    assert(is_power_of_2(stacktrace_set_size), \"invariant\");\n+    _stacktrace_id_set = new JfrResourceAreaTraceIdSet(stacktrace_set_size);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/objectSampleCheckpoint.cpp","additions":42,"deletions":36,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+  mutable bool _thread_exited;\n@@ -85,1 +86,2 @@\n-                   _virtual_thread(false) {}\n+                   _virtual_thread(false),\n+                   _thread_exited(false) {}\n@@ -228,0 +230,9 @@\n+  bool thread_exited() const {\n+    return _thread_exited;\n+  }\n+\n+  void set_thread_exited() const {\n+    assert(!_thread_exited, \"invariant\");\n+    _thread_exited = true;\n+  }\n+\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/sampling\/objectSample.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-void JfrMetadataEvent::write(JfrChunkWriter& chunkwriter) {\n+size_t JfrMetadataEvent::write(JfrChunkWriter& chunkwriter) {\n@@ -71,1 +71,1 @@\n-    return;\n+    return 0;\n@@ -90,0 +90,1 @@\n+  return 1;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrMetadataEvent.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-  static void write(JfrChunkWriter& writer);\n+  static size_t write(JfrChunkWriter& writer);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrMetadataEvent.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1051,2 +1051,0 @@\n-  KlassUsedPredicate _klass_used_predicate;\n-  MethodUsedPredicate _method_used_predicate;\n@@ -1058,2 +1056,0 @@\n-    _klass_used_predicate(current_epoch()),\n-    _method_used_predicate(current_epoch()),\n@@ -1063,1 +1059,1 @@\n-    if (_method_used_predicate(klass)) {\n+    if (klass->is_instance_klass()) {\n@@ -1078,1 +1074,1 @@\n-    return _klass_used_predicate(klass) ? _klass_cb(klass) : true;\n+    return _klass_cb(klass);\n@@ -1283,1 +1279,1 @@\n-    _artifacts = new JfrArtifactSet(class_unload);\n+    _artifacts = new JfrArtifactSet(class_unload, previous_epoch());\n@@ -1285,1 +1281,1 @@\n-    _artifacts->initialize(class_unload);\n+    _artifacts->initialize(class_unload, previous_epoch());\n@@ -1287,0 +1283,1 @@\n+  assert(current_epoch() || _leakp_writer != nullptr, \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -32,6 +32,10 @@\n-JfrArtifactSet::JfrArtifactSet(bool class_unload) : _symbol_table(nullptr),\n-                                                    _klass_list(nullptr),\n-                                                    _total_count(0),\n-                                                    _class_unload(class_unload) {\n-  initialize(class_unload);\n-  assert(_klass_list != nullptr, \"invariant\");\n+JfrArtifactSet::JfrArtifactSet(bool class_unload, bool previous_epoch) : _symbol_table(nullptr),\n+                                                                         _klass_set(nullptr),\n+                                                                         _klass_loader_set(nullptr),\n+                                                                         _klass_loader_leakp_set(nullptr),\n+                                                                         _total_count(0),\n+                                                                         _class_unload(class_unload) {\n+  initialize(class_unload, previous_epoch);\n+  assert(!previous_epoch || _klass_loader_leakp_set != nullptr, \"invariant\");\n+  assert(_klass_loader_set != nullptr, \"invariant\");\n+  assert(_klass_set != nullptr, \"invariant\");\n@@ -40,2 +44,3 @@\n-static const size_t initial_klass_list_size = 4096;\n-const int initial_klass_loader_set_size = 64;\n+static unsigned initial_klass_set_size = 4096;\n+static unsigned initial_klass_loader_set_size = 64;\n+static unsigned initial_klass_loader_leakp_set_size = 64;\n@@ -43,1 +48,1 @@\n-void JfrArtifactSet::initialize(bool class_unload) {\n+void JfrArtifactSet::initialize(bool class_unload, bool previous_epoch) {\n@@ -53,3 +58,5 @@\n-  _klass_loader_leakp_set = new GrowableArray<const Klass*>(initial_klass_loader_set_size);\n-  _klass_loader_set = new GrowableArray<const Klass*>(initial_klass_loader_set_size);\n-  _klass_list = new GrowableArray<const Klass*>(initial_klass_list_size);\n+  if (previous_epoch) {\n+    _klass_loader_leakp_set = new JfrKlassSet(initial_klass_loader_leakp_set_size);\n+  }\n+  _klass_loader_set = new JfrKlassSet(initial_klass_loader_set_size);\n+  _klass_set = new JfrKlassSet(initial_klass_set_size);\n@@ -96,5 +103,1 @@\n-  return _klass_list->is_nonempty();\n-}\n-\n-int JfrArtifactSet::entries() const {\n-  return _klass_list->length();\n+  return _klass_set->is_nonempty();\n@@ -102,2 +105,1 @@\n-\n-static inline bool not_in_set(GrowableArray<const Klass*>* set, const Klass* k) {\n+static inline bool not_in_set(JfrArtifactSet::JfrKlassSet* set, const Klass* k) {\n@@ -106,1 +108,1 @@\n-  return !JfrMutablePredicate<const Klass*, compare_klasses>::test(set, k);\n+  return set->add(k);\n@@ -119,2 +121,2 @@\n-  assert(_klass_list != nullptr, \"invariant\");\n-  _klass_list->append(k);\n+  assert(_klass_set != nullptr, \"invariant\");\n+  _klass_set->add(k);\n@@ -124,0 +126,4 @@\n+  assert(_klass_set != nullptr, \"invariant\");\n+  initial_klass_set_size = MAX2(initial_klass_set_size, _klass_set->table_size());\n+  assert(_klass_loader_set != nullptr, \"invariant\");\n+  initial_klass_loader_set_size = MAX2(initial_klass_loader_set_size, _klass_loader_set->table_size());\n@@ -130,0 +136,2 @@\n+  assert(_klass_loader_leakp_set != nullptr, \"invariant\");\n+  initial_klass_loader_leakp_set_size = MAX2(initial_klass_loader_leakp_set_size, _klass_loader_leakp_set->table_size());\n@@ -131,1 +139,0 @@\n-\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.cpp","additions":30,"deletions":23,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"jfr\/utilities\/jfrSet.hpp\"\n@@ -34,3 +35,0 @@\n-template <typename T>\n-class GrowableArray;\n-\n@@ -138,21 +136,0 @@\n-class KlassUsedPredicate {\n-  bool _current_epoch;\n- public:\n-  KlassUsedPredicate(bool current_epoch) : _current_epoch(current_epoch) {}\n-  bool operator()(const Klass* klass) {\n-    return _current_epoch ? USED_THIS_EPOCH(klass) : USED_PREVIOUS_EPOCH(klass);\n-  }\n-};\n-\n-class MethodUsedPredicate {\n-  bool _current_epoch;\n-public:\n-  MethodUsedPredicate(bool current_epoch) : _current_epoch(current_epoch) {}\n-  bool operator()(const Klass* klass) {\n-    if (!klass->is_instance_klass()) {\n-      return false;\n-    }\n-    return _current_epoch ? USED_THIS_EPOCH(klass) : USED_PREVIOUS_EPOCH(klass);\n-  }\n-};\n-\n@@ -206,0 +183,26 @@\n+ public:\n+  class JfrArtifactSetConfig : public AllStatic {\n+   public:\n+    typedef const Klass* KEY_TYPE;\n+\n+    constexpr static AnyObj::allocation_type alloc_type() {\n+      return AnyObj::RESOURCE_AREA;\n+    }\n+\n+    constexpr static MemTag memory_tag() {\n+      return mtInternal;\n+    }\n+\n+    \/\/ Knuth multiplicative hashing.\n+    static uint32_t hash(const KEY_TYPE& k) {\n+      const uint32_t v = static_cast<uint32_t>(JfrTraceId::load_raw(k));\n+      return v * UINT32_C(2654435761);\n+    }\n+\n+    static bool cmp(const KEY_TYPE& lhs, const KEY_TYPE& rhs) {\n+      return lhs == rhs;\n+    }\n+  };\n+\n+  typedef JfrSet<JfrArtifactSetConfig> JfrKlassSet;\n+\n@@ -208,3 +211,3 @@\n-  GrowableArray<const Klass*>* _klass_list;\n-  GrowableArray<const Klass*>* _klass_loader_set;\n-  GrowableArray<const Klass*>* _klass_loader_leakp_set;\n+  JfrKlassSet* _klass_set;\n+  JfrKlassSet* _klass_loader_set;\n+  JfrKlassSet* _klass_loader_leakp_set;\n@@ -215,1 +218,1 @@\n-  JfrArtifactSet(bool class_unload);\n+  JfrArtifactSet(bool class_unload, bool previous_epoch);\n@@ -219,1 +222,1 @@\n-  void initialize(bool class_unload);\n+  void initialize(bool class_unload, bool previous_epoch);\n@@ -234,1 +237,0 @@\n-  int entries() const;\n@@ -257,1 +259,1 @@\n-    if (iterate(functor, _klass_list)) {\n+    if (iterate(functor, _klass_set)) {\n@@ -264,6 +266,4 @@\n-  bool iterate(Functor& functor, GrowableArray<const Klass*>* list) const {\n-    assert(list != nullptr, \"invariant\");\n-    for (int i = 0; i < list->length(); ++i) {\n-      if (!functor(list->at(i))) {\n-        return false;\n-      }\n+  bool iterate(Functor& functor, JfrKlassSet* set) const {\n+    assert(set != nullptr, \"invariant\");\n+    if (set->is_nonempty()) {\n+      set->iterate(functor);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.hpp","additions":37,"deletions":37,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -370,0 +370,1 @@\n+  size_t _elements;\n@@ -371,1 +372,1 @@\n-  MetadataEvent(JfrChunkWriter& cw) : _cw(cw) {}\n+  MetadataEvent(JfrChunkWriter& cw) : _cw(cw), _elements(0) {}\n@@ -373,1 +374,1 @@\n-    JfrMetadataEvent::write(_cw);\n+    _elements = JfrMetadataEvent::write(_cw);\n@@ -376,1 +377,1 @@\n-  size_t elements() const { return 1; }\n+  size_t elements() const { return _elements; }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-static const int initial_size = 1009;\n+static const int initial_size = 1024;\n@@ -36,1 +36,1 @@\n-  return new JfrCHeapTraceIdSet(size);\n+  return new (mtTracing) JfrCHeapTraceIdSet(size);\n@@ -71,7 +71,0 @@\n-static bool is_nonempty_set(u1 epoch) {\n-  if (epoch == 0) {\n-    return _unload_set_epoch_0 != nullptr && _unload_set_epoch_0->is_nonempty();\n-  }\n-  return _unload_set_epoch_1 != nullptr && _unload_set_epoch_1->is_nonempty();\n-}\n-\n@@ -80,3 +73,1 @@\n-  if (is_nonempty_set(JfrTraceIdEpoch::previous())) {\n-    get_unload_set_previous_epoch()->clear();\n-  }\n+  get_unload_set_previous_epoch()->clear();\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrKlassUnloading.cpp","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"utilities\/resizeableResourceHash.hpp\"\n+#include \"utilities\/resizableHashTable.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrClassFilterClosure.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-         bool (*EQUALS)(K const&, K const&)> class ResizeableResourceHashtable;\n+         bool (*EQUALS)(K const&, K const&)> class ResizeableHashTable;\n@@ -51,1 +51,1 @@\n-typedef ResizeableResourceHashtable<traceid, jclass,\n+typedef ResizeableHashTable<traceid, jclass,\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrClassFilterClosure.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-#include \"utilities\/resizeableResourceHash.hpp\"\n+#include \"utilities\/resizableHashTable.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrMethodTracer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"jfr\/utilities\/jfrAllocation.hpp\"\n+#include \"memory\/allocation.hpp\"\n@@ -30,1 +30,0 @@\n-#include \"utilities\/resizeableResourceHash.hpp\"\n@@ -32,2 +31,2 @@\n-template <typename AllocPolicy = JfrCHeapObj, AnyObj::allocation_type AllocType = AnyObj::C_HEAP, MemTag memtag = mtTracing>\n-class ConfigTraceID : public AllStatic {\n+template <typename K, AnyObj::allocation_type AllocType = AnyObj::C_HEAP, MemTag memtag = mtTracing>\n+class JfrSetConfig : public AllStatic {\n@@ -35,2 +34,1 @@\n-  typedef AllocPolicy STORAGE;\n-  typedef traceid TYPE;\n+  typedef K KEY_TYPE;\n@@ -47,3 +45,3 @@\n-  static uint32_t hash(const TYPE& id) {\n-    const uint32_t v = static_cast<uint32_t>(id);\n-    return v * UINT32_C(2654435761);\n+  static uint32_t hash(const KEY_TYPE& key) {\n+    const uint32_t k = static_cast<uint32_t>(key);\n+    return k * UINT32_C(2654435761);\n@@ -52,1 +50,1 @@\n-  static bool cmp(const TYPE& lhs, const TYPE& rhs) {\n+  static bool cmp(const KEY_TYPE& lhs, const KEY_TYPE& rhs) {\n@@ -57,2 +55,0 @@\n-constexpr static unsigned int MAX_TABLE_SIZE = 0x3fffffff;\n-\n@@ -60,7 +56,16 @@\n-class JfrSet : public CONFIG::STORAGE {\n- public:\n-  typedef typename CONFIG::TYPE TYPE;\n-  typedef ResizeableResourceHashtable<TYPE, TYPE, CONFIG::alloc_type(), CONFIG::memory_tag(), CONFIG::hash, CONFIG::cmp> HashMap;\n-\n-  constexpr static bool is_cheap() {\n-    return CONFIG::alloc_type() == AnyObj::C_HEAP;\n+class JfrSetStorage : public AnyObj {\n+  typedef typename CONFIG::KEY_TYPE K;\n+ protected:\n+  K* _table;\n+  unsigned _table_size;\n+  unsigned _elements;\n+\n+  static K* alloc_table(unsigned table_size) {\n+    K* table;\n+    if (CONFIG::alloc_type() == C_HEAP) {\n+      table = NEW_C_HEAP_ARRAY(K, table_size, CONFIG::memory_tag());\n+    } else {\n+      table = NEW_RESOURCE_ARRAY(K, table_size);\n+    }\n+    memset(table, 0, table_size * sizeof(K));\n+    return table;\n@@ -69,2 +74,4 @@\n-  JfrSet(unsigned int initial_size, unsigned int max_size = MAX_TABLE_SIZE) :\n-    _map(is_cheap() ? new (CONFIG::memory_tag()) HashMap(initial_size, max_size) : new HashMap(initial_size, max_size)) {}\n+  JfrSetStorage(unsigned table_size) :\n+    _table(alloc_table(table_size)),\n+    _table_size(table_size),\n+    _elements(0) {}\n@@ -72,3 +79,3 @@\n-  ~JfrSet() {\n-    if (is_cheap()) {\n-      delete _map;\n+  ~JfrSetStorage() {\n+    if (CONFIG::alloc_type() == C_HEAP) {\n+      FREE_C_HEAP_ARRAY(K, _table);\n@@ -78,4 +85,10 @@\n-  bool add(const TYPE& k) {\n-    bool inserted;\n-    _map->put_if_absent(k, &inserted);\n-    return inserted;\n+ public:\n+  template <typename Functor>\n+  void iterate(Functor& functor) {\n+    assert(is_nonempty(), \"invariant\");\n+    for (unsigned i = 0; i < _table_size; ++i) {\n+      K k = _table[i];\n+      if (k != 0) {\n+        functor(k);\n+      }\n+    }\n@@ -84,2 +97,2 @@\n-  bool remove(const TYPE& k) {\n-    return _map->remove(k);\n+  unsigned table_size() const {\n+    return _table_size;\n@@ -88,2 +101,2 @@\n-  bool contains(const TYPE& k) const {\n-    return _map->contains(k);\n+  unsigned size() const {\n+    return _elements;\n@@ -92,2 +105,2 @@\n-  bool is_empty() const {\n-    return _map->number_of_entries() == 0;\n+  bool is_nonempty() const {\n+    return _elements > 0;\n@@ -96,2 +109,2 @@\n-  bool is_nonempty() const {\n-    return !is_empty();\n+  void clear() {\n+    memset(_table, 0, _table_size * sizeof(K));\n@@ -99,0 +112,1 @@\n+};\n@@ -100,2 +114,11 @@\n-  int size() const {\n-    return _map->number_of_entries();\n+template <typename CONFIG>\n+class JfrSet : public JfrSetStorage<CONFIG> {\n+  typedef typename CONFIG::KEY_TYPE K;\n+  static_assert(sizeof(K) > 1, \"invalid size of CONFIG::KEY_TYPE\");\n+ private:\n+  static const constexpr unsigned max_initial_size = 1 << 30;\n+  unsigned _table_mask;\n+  unsigned _resize_threshold; \/\/ 0.5 load factor\n+\n+  uint32_t slot_idx(const uint32_t hash) const {\n+    return hash & _table_mask;\n@@ -104,3 +127,23 @@\n-  void clear() {\n-    if (is_nonempty()) {\n-      _map->unlink(this);\n+  void resize() {\n+    assert(this->_elements == _resize_threshold, \"invariant\");\n+    K* const old_table = this->_table;\n+    assert(old_table != nullptr, \"invariant\");\n+    const unsigned old_table_size = this->table_size();\n+    guarantee(old_table_size <= max_initial_size, \"overflow\");\n+    this->_table_size = old_table_size << 1;\n+    this->_table = JfrSetStorage<CONFIG>::alloc_table(this->_table_size);\n+    _table_mask = this->_table_size - 1;\n+    _resize_threshold = old_table_size;\n+    for (unsigned i = 0; i < old_table_size; ++i) {\n+      const K k = old_table[i];\n+      if (k != 0) {\n+        uint32_t idx = slot_idx(CONFIG::hash(k));\n+        do {\n+          K v = this->_table[idx];\n+          if (v == 0) {\n+            this->_table[idx] = k;\n+            break;\n+          }\n+          idx = slot_idx(idx + 1);\n+        } while (true);\n+      }\n@@ -108,1 +151,5 @@\n-    assert(is_empty(), \"invariant\");\n+    if (CONFIG::alloc_type() == AnyObj::C_HEAP) {\n+      FREE_C_HEAP_ARRAY(K, old_table);\n+    }\n+    assert(_table_mask + 1 == this->_table_size, \"invariant\");\n+    assert(_resize_threshold << 1 == this->_table_size, \"invariant\");\n@@ -111,3 +158,18 @@\n-  \/\/ Callback for node deletion, used by clear().\n-  bool do_entry(const TYPE& k, const TYPE& v) {\n-    return true;\n+  K* find_slot(K const& k) const {\n+    uint32_t idx = slot_idx(CONFIG::hash(k));\n+    assert(idx < this->table_size(), \"invariant\");\n+    K* result = nullptr;\n+    while (true) {\n+      K v = this->_table[idx];\n+      if (v == 0) {\n+        result = &this->_table[idx];\n+        break;\n+      }\n+      if (CONFIG::cmp(v, k)) {\n+        result = reinterpret_cast<K*>(p2i(&this->_table[idx]) | 1);\n+        break;\n+      }\n+      idx = slot_idx(idx + 1);\n+    }\n+    assert(result != nullptr, \"invariant\");\n+    return result;\n@@ -116,2 +178,29 @@\n- private:\n-  HashMap* _map;\n+ public:\n+  JfrSet(unsigned size) :\n+    JfrSetStorage<CONFIG>(size),\n+    _table_mask(size - 1),\n+    _resize_threshold(size >> 1) {\n+    assert(size >= 2, \"invariant\");\n+    assert(size % 2 == 0, \"invariant\");\n+    assert(size <= max_initial_size, \"avoid overflow in resize\");\n+  }\n+\n+  bool contains(K const& k) const {\n+    K* const slot = find_slot(k);\n+    return p2i(slot) & 1;\n+  }\n+\n+  bool add(K const& k) {\n+    K* const slot = find_slot(k);\n+    if (p2i(slot) & 1) {\n+      \/\/ Already exists.\n+      return false;\n+    }\n+    assert(*slot == 0, \"invariant\");\n+    *slot = k;\n+    if (++this->_elements == _resize_threshold) {\n+      resize();\n+    }\n+    assert(this->_elements < _resize_threshold, \"invariant\");\n+    return true;\n+  }\n@@ -120,2 +209,2 @@\n-typedef JfrSet<ConfigTraceID<> > JfrCHeapTraceIdSet;\n-typedef JfrSet<ConfigTraceID<ResourceObj, AnyObj::RESOURCE_AREA> > JfrResourceAreaTraceIdSet;\n+typedef JfrSet<JfrSetConfig<traceid> > JfrCHeapTraceIdSet;\n+typedef JfrSet<JfrSetConfig<traceid, AnyObj::RESOURCE_AREA> > JfrResourceAreaTraceIdSet;\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrSet.hpp","additions":138,"deletions":49,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -440,2 +440,2 @@\n-  ResourceHashtable<jlong, JVMCIObject> longs;\n-  ResourceHashtable<const char*, JVMCIObject,\n+  HashTable<jlong, JVMCIObject> longs;\n+  HashTable<const char*, JVMCIObject,\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"runtime\/os.inline.hpp\"\n@@ -34,0 +33,1 @@\n+#include \"runtime\/os.inline.hpp\"\n@@ -35,1 +35,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -69,1 +69,1 @@\n-  using AsyncLogMap = ResourceHashtable<LogFileStreamOutput*,\n+  using AsyncLogMap = HashTable<LogFileStreamOutput*,\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,3 +45,4 @@\n- * |+16                | <size_t:user_size>   | User data size |\n- * |+sizeof(uintptr_t) | <tag>                | Tag word       |\n- * |+sizeof(uintptr_t) | <tag2>               | Tag word       |\n+ * |+GUARD_SIZE        | <size_t:user_size>   | User data size |\n+ * |+sizeof(size_t)    | <tag>                | Tag word       |\n+ * |+sizeof(void*)     | <tag2>               | Tag word       |\n+ * |+sizeof(void*)     | <pad bytes>          | Padding        |\n@@ -55,0 +56,2 @@\n+ *  - padding is inserted as-needed by the compiler to ensure\n+ *    the user data is aligned on a 16-byte boundary\n@@ -135,0 +138,5 @@\n+   *\n+   * NB: the size and placement of the GuardHeader must be such that the\n+   * user-ptr is maximally aligned i.e. 16-byte alignment for x86 ABI for\n+   * stack alignment and use of vector (xmm) instructions. We use alignas\n+   * to achieve this.\n@@ -136,1 +144,1 @@\n-  class GuardHeader : Guard {\n+  class alignas(16) GuardHeader : Guard {\n@@ -139,2 +147,0 @@\n-    \/\/ Take care in modifying fields here, will effect alignment\n-    \/\/ e.g. x86 ABI 16 byte stack alignment\n","filename":"src\/hotspot\/share\/memory\/guardedMemory.hpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"utilities\/resizeableResourceHash.hpp\"\n+#include \"utilities\/resizableHashTable.hpp\"\n@@ -377,1 +377,1 @@\n-  ResizeableResourceHashtable<address, bool, AnyObj::C_HEAP,\n+  ResizeableHashTable<address, bool, AnyObj::C_HEAP,\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -218,1 +218,1 @@\n-    site->commit_memory(rgn->committed_size());\n+    site->commit_memory(VirtualMemoryTracker::Instance::committed_size(rgn));\n","filename":"src\/hotspot\/share\/nmt\/memBaseline.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -425,1 +425,1 @@\n-  bool all_committed = reserved_rgn->size() == reserved_rgn->committed_size();\n+  bool all_committed = reserved_rgn->size() == VirtualMemoryTracker::Instance::committed_size(reserved_rgn);\n","filename":"src\/hotspot\/share\/nmt\/memReporter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-  VMATree::TreapNode* prev = nullptr;\n+  const VMATree::TNode* prev = nullptr;\n@@ -69,2 +69,2 @@\n-  VMATree::TreapNode* broken_start = nullptr;\n-  VMATree::TreapNode* broken_end = nullptr;\n+  const VMATree::TNode* broken_start = nullptr;\n+  const VMATree::TNode* broken_end = nullptr;\n@@ -72,1 +72,1 @@\n-  file->_tree.visit_in_order([&](VMATree::TreapNode* current) {\n+  file->_tree.visit_in_order([&](const VMATree::TNode* current) {\n","filename":"src\/hotspot\/share\/nmt\/memoryFileTracker.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -44,1 +44,1 @@\n-  mutable ResourceHashtable<address, const char*, 293, AnyObj::C_HEAP, mtNMT> _cache;\n+  mutable HashTable<address, const char*, 293, AnyObj::C_HEAP, mtNMT> _cache;\n","filename":"src\/hotspot\/share\/nmt\/nativeCallStackPrinter.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,447 +0,0 @@\n-\/*\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_NMT_NMTTREAP_HPP\n-#define SHARE_NMT_NMTTREAP_HPP\n-\n-#include \"runtime\/os.hpp\"\n-#include \"utilities\/debug.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n-#include \"utilities\/macros.hpp\"\n-#include \"utilities\/powerOfTwo.hpp\"\n-#include <type_traits>\n-\n-\/\/ A Treap is a self-balanced binary tree where each node is equipped with a\n-\/\/ priority. It adds the invariant that the priority of a parent P is strictly larger\n-\/\/ larger than the priority of its children. When priorities are randomly\n-\/\/ assigned the tree is balanced.\n-\/\/ All operations are defined through merge and split, which are each other's inverse.\n-\/\/ merge(left_treap, right_treap) => treap where left_treap <= right_treap\n-\/\/ split(treap, key) => (left_treap, right_treap)  where left_treap <= right_treap\n-\/\/ Recursion is used in these, but the depth of the call stack is the depth of\n-\/\/ the tree which is O(log n) so we are safe from stack overflow.\n-\/\/ TreapNode has LEQ nodes on the left, GT nodes on the right.\n-\/\/\n-\/\/ COMPARATOR must have a static function `cmp(a,b)` which returns:\n-\/\/     - an int < 0 when a < b\n-\/\/     - an int == 0 when a == b\n-\/\/     - an int > 0 when a > b\n-\/\/ ALLOCATOR must check for oom and exit, as Treap currently does not handle the allocation\n-\/\/ failing.\n-\n-template<typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-class Treap {\n-  friend class NMTVMATreeTest;\n-  friend class NMTTreapTest;\n-  friend class VMTWithVMATreeTest;\n-public:\n-  class TreapNode {\n-    friend Treap;\n-    uint64_t _priority;\n-    const K _key;\n-    V _value;\n-\n-    TreapNode* _left;\n-    TreapNode* _right;\n-\n-  public:\n-    TreapNode(const K& k, uint64_t p) : _priority(p), _key(k), _left(nullptr), _right(nullptr) {}\n-\n-    TreapNode(const K& k, const V& v, uint64_t p)\n-      : _priority(p),\n-        _key(k),\n-        _value(v),\n-        _left(nullptr),\n-        _right(nullptr) {\n-    }\n-\n-    const K& key() const { return _key; }\n-    V& val() { return _value; }\n-\n-    TreapNode* left() const { return _left; }\n-    TreapNode* right() const { return _right; }\n-  };\n-\n-private:\n-  ALLOCATOR _allocator;\n-  TreapNode* _root;\n-\n-  \/\/ A random number\n-  static constexpr const uint64_t _initial_seed = 0xC8DD2114AE0543A3;\n-  uint64_t _prng_seed;\n-  int _node_count;\n-\n-  uint64_t prng_next() {\n-    uint64_t first_half = os::next_random(_prng_seed);\n-    uint64_t second_half = os::next_random(_prng_seed >> 32);\n-    _prng_seed = first_half | (second_half << 32);\n-    return _prng_seed;\n-  }\n-\n-  struct node_pair {\n-    TreapNode* left;\n-    TreapNode* right;\n-  };\n-\n-  enum SplitMode {\n-    LT, \/\/ <\n-    LEQ \/\/ <=\n-  };\n-\n-  \/\/ Split tree at head into two trees, SplitMode decides where EQ values go.\n-  \/\/ We have SplitMode because it makes remove() trivial to implement.\n-  static node_pair split(TreapNode* head, const K& key, SplitMode mode = LEQ DEBUG_ONLY(COMMA int recur_count = 0)) {\n-    assert(recur_count < 200, \"Call-stack depth should never exceed 200\");\n-\n-    if (head == nullptr) {\n-      return {nullptr, nullptr};\n-    }\n-    if ((COMPARATOR::cmp(head->_key, key) <= 0 && mode == LEQ) || (COMPARATOR::cmp(head->_key, key) < 0 && mode == LT)) {\n-      node_pair p = split(head->_right, key, mode DEBUG_ONLY(COMMA recur_count + 1));\n-      head->_right = p.left;\n-      return node_pair{head, p.right};\n-    } else {\n-      node_pair p = split(head->_left, key, mode DEBUG_ONLY(COMMA recur_count + 1));\n-      head->_left = p.right;\n-      return node_pair{p.left, head};\n-    }\n-  }\n-\n-  \/\/ Invariant: left is a treap whose keys are LEQ to the keys in right.\n-  static TreapNode* merge(TreapNode* left, TreapNode* right DEBUG_ONLY(COMMA int recur_count = 0)) {\n-    assert(recur_count < 200, \"Call-stack depth should never exceed 200\");\n-\n-    if (left == nullptr) return right;\n-    if (right == nullptr) return left;\n-\n-    if (left->_priority > right->_priority) {\n-      \/\/ We need\n-      \/\/      LEFT\n-      \/\/         |\n-      \/\/         RIGHT\n-      \/\/ for the invariant re: priorities to hold.\n-      left->_right = merge(left->_right, right DEBUG_ONLY(COMMA recur_count + 1));\n-      return left;\n-    } else {\n-      \/\/ We need\n-      \/\/         RIGHT\n-      \/\/         |\n-      \/\/      LEFT\n-      \/\/ for the invariant re: priorities to hold.\n-      right->_left = merge(left, right->_left DEBUG_ONLY(COMMA recur_count + 1));\n-      return right;\n-    }\n-  }\n-\n-  static TreapNode* find(TreapNode* node, const K& k DEBUG_ONLY(COMMA int recur_count = 0)) {\n-    if (node == nullptr) {\n-      return nullptr;\n-    }\n-\n-    int key_cmp_k = COMPARATOR::cmp(node->key(), k);\n-\n-    if (key_cmp_k == 0) { \/\/ key EQ k\n-      return node;\n-    }\n-\n-    if (key_cmp_k < 0) { \/\/ key LT k\n-      return find(node->right(), k DEBUG_ONLY(COMMA recur_count + 1));\n-    } else { \/\/ key GT k\n-      return find(node->left(), k DEBUG_ONLY(COMMA recur_count + 1));\n-    }\n-  }\n-\n-#ifdef ASSERT\n-  void verify_self() {\n-    \/\/ A balanced binary search tree should have a depth on the order of log(N).\n-    \/\/ We take the ceiling of log_2(N + 1) * 3 as our maximum bound.\n-    \/\/ For comparison, a RB-tree has a proven max depth of log_2(N + 1) * 2.\n-    const int expected_maximum_depth = ceil(log2i(this->_node_count+1) * 3);\n-    \/\/ Find the maximum depth through DFS and ensure that the priority invariant holds.\n-    int maximum_depth_found = 0;\n-\n-    struct DFS {\n-      int depth;\n-      uint64_t parent_prio;\n-      TreapNode* n;\n-    };\n-    GrowableArrayCHeap<DFS, mtNMT> to_visit;\n-    constexpr const uint64_t positive_infinity = 0xFFFFFFFFFFFFFFFF;\n-\n-    to_visit.push({0, positive_infinity, this->_root});\n-    while (!to_visit.is_empty()) {\n-      DFS head = to_visit.pop();\n-      if (head.n == nullptr) continue;\n-      maximum_depth_found = MAX2(maximum_depth_found, head.depth);\n-\n-      assert(head.parent_prio >= head.n->_priority, \"broken priority invariant\");\n-\n-      to_visit.push({head.depth + 1, head.n->_priority, head.n->left()});\n-      to_visit.push({head.depth + 1, head.n->_priority, head.n->right()});\n-    }\n-    assert(maximum_depth_found - expected_maximum_depth <= 3,\n-           \"depth unexpectedly large for treap of node count %d, was: %d, expected between %d and %d\",\n-           _node_count, maximum_depth_found, expected_maximum_depth - 3, expected_maximum_depth);\n-\n-    \/\/ Visit everything in order, see that the key ordering is monotonically increasing.\n-    TreapNode* last_seen = nullptr;\n-    bool failed = false;\n-    int seen_count = 0;\n-    this->visit_in_order([&](TreapNode* node) {\n-      seen_count++;\n-      if (last_seen == nullptr) {\n-        last_seen = node;\n-        return true;\n-      }\n-      if (COMPARATOR::cmp(last_seen->key(), node->key()) > 0) {\n-        failed = false;\n-      }\n-      last_seen = node;\n-      return true;\n-    });\n-    assert(seen_count == _node_count, \"the number of visited nodes do not match with the number of stored nodes\");\n-    assert(!failed, \"keys was not monotonically strongly increasing when visiting in order\");\n-  }\n-#endif \/\/ ASSERT\n-\n-public:\n-  NONCOPYABLE(Treap);\n-\n-  Treap()\n-  : _allocator(),\n-    _root(nullptr),\n-    _prng_seed(_initial_seed),\n-    _node_count(0) {\n-    static_assert(std::is_trivially_destructible<K>::value, \"must be\");\n-  }\n-\n-  ~Treap() {\n-    this->remove_all();\n-  }\n-\n-  int size() {\n-    return _node_count;\n-  }\n-\n-  void upsert(const K& k, const V& v) {\n-    TreapNode* found = find(_root, k);\n-    if (found != nullptr) {\n-      \/\/ Already exists, update value.\n-      found->_value = v;\n-      return;\n-    }\n-    _node_count++;\n-    \/\/ Doesn't exist, make node\n-    void* node_place = _allocator.allocate(sizeof(TreapNode));\n-    uint64_t prio = prng_next();\n-    TreapNode* node = new (node_place) TreapNode(k, v, prio);\n-\n-    \/\/ (LEQ_k, GT_k)\n-    node_pair split_up = split(this->_root, k);\n-    \/\/ merge(merge(LEQ_k, EQ_k), GT_k)\n-    this->_root = merge(merge(split_up.left, node), split_up.right);\n-  }\n-\n-  void remove(const K& k) {\n-    \/\/ (LEQ_k, GT_k)\n-    node_pair first_split = split(this->_root, k, LEQ);\n-    \/\/ (LT_k, GEQ_k) == (LT_k, EQ_k) since it's from LEQ_k and keys are unique.\n-    node_pair second_split = split(first_split.left, k, LT);\n-\n-    if (second_split.right != nullptr) {\n-      \/\/ The key k existed, we delete it.\n-      _node_count--;\n-      second_split.right->_value.~V();\n-      _allocator.free(second_split.right);\n-    }\n-    \/\/ Merge together everything\n-    _root = merge(second_split.left, first_split.right);\n-  }\n-\n-  \/\/ Delete all nodes.\n-  void remove_all() {\n-    _node_count = 0;\n-    GrowableArrayCHeap<TreapNode*, mtNMT> to_delete;\n-    to_delete.push(_root);\n-\n-    while (!to_delete.is_empty()) {\n-      TreapNode* head = to_delete.pop();\n-      if (head == nullptr) continue;\n-      to_delete.push(head->_left);\n-      to_delete.push(head->_right);\n-      head->_value.~V();\n-      _allocator.free(head);\n-    }\n-    _root = nullptr;\n-  }\n-\n-  TreapNode* closest_leq(const K& key) {\n-    TreapNode* candidate = nullptr;\n-    TreapNode* pos = _root;\n-    while (pos != nullptr) {\n-      int cmp_r = COMPARATOR::cmp(pos->key(), key);\n-      if (cmp_r == 0) { \/\/ Exact match\n-        candidate = pos;\n-        break; \/\/ Can't become better than that.\n-      }\n-      if (cmp_r < 0) {\n-        \/\/ Found a match, try to find a better one.\n-        candidate = pos;\n-        pos = pos->_right;\n-      } else if (cmp_r > 0) {\n-        pos = pos->_left;\n-      }\n-    }\n-    return candidate;\n-  }\n-\n-  struct FindResult {\n-    FindResult(TreapNode* node, bool new_node) : node(node), new_node(new_node) {}\n-    TreapNode* const node;\n-    bool const new_node;\n-  };\n-\n-  \/\/ Finds the node for the given k in the tree or inserts a new node with the default constructed value.\n-  FindResult find(const K& k) {\n-    if (TreapNode* found = find(_root, k)) {\n-      return FindResult(found, false);\n-    }\n-    _node_count++;\n-    \/\/ Doesn't exist, make node\n-    void* node_place = _allocator.allocate(sizeof(TreapNode));\n-    uint64_t prio = prng_next();\n-    TreapNode* node = new (node_place) TreapNode(k, prio);\n-\n-    \/\/ (LEQ_k, GT_k)\n-    node_pair split_up = split(this->_root, k);\n-    \/\/ merge(merge(LEQ_k, EQ_k), GT_k)\n-    this->_root = merge(merge(split_up.left, node), split_up.right);\n-    return FindResult(node, true);\n-  }\n-\n-  TreapNode* closest_gt(const K& key) {\n-    TreapNode* candidate = nullptr;\n-    TreapNode* pos = _root;\n-    while (pos != nullptr) {\n-      int cmp_r = COMPARATOR::cmp(pos->key(), key);\n-      if (cmp_r > 0) {\n-        \/\/ Found a match, try to find a better one.\n-        candidate = pos;\n-        pos = pos->_left;\n-      } else if (cmp_r <= 0) {\n-        pos = pos->_right;\n-      }\n-    }\n-    return candidate;\n-  }\n-\n-  struct Range {\n-    TreapNode* start;\n-    TreapNode* end;\n-    Range(TreapNode* start, TreapNode* end)\n-    : start(start), end(end) {}\n-  };\n-\n-  \/\/ Return the range [start, end)\n-  \/\/ where start->key() <= addr < end->key().\n-  \/\/ Failure to find the range leads to start and\/or end being null.\n-  Range find_enclosing_range(K addr) {\n-    TreapNode* start = closest_leq(addr);\n-    TreapNode* end = closest_gt(addr);\n-    return Range(start, end);\n-  }\n-\n-  \/\/ Visit all TreapNodes in ascending key order.\n-  template<typename F>\n-  void visit_in_order(F f) const {\n-    GrowableArrayCHeap<TreapNode*, mtNMT> to_visit;\n-    TreapNode* head = _root;\n-    while (!to_visit.is_empty() || head != nullptr) {\n-      while (head != nullptr) {\n-        to_visit.push(head);\n-        head = head->left();\n-      }\n-      head = to_visit.pop();\n-      if (!f(head)) {\n-        return;\n-      }\n-      head = head->right();\n-    }\n-  }\n-\n-  \/\/ Visit all TreapNodes in ascending order whose keys are in range [from, to).\n-  template<typename F>\n-  void visit_range_in_order(const K& from, const K& to, F f) {\n-    assert(COMPARATOR::cmp(from, to) <= 0, \"from must be less or equal to to\");\n-    GrowableArrayCHeap<TreapNode*, mtNMT> to_visit;\n-    TreapNode* head = _root;\n-    while (!to_visit.is_empty() || head != nullptr) {\n-      while (head != nullptr) {\n-        int cmp_from = COMPARATOR::cmp(head->key(), from);\n-        to_visit.push(head);\n-        if (cmp_from >= 0) {\n-          head = head->left();\n-        } else {\n-          \/\/ We've reached a node which is strictly less than from\n-          \/\/ We don't need to visit any further to the left.\n-          break;\n-        }\n-      }\n-      head = to_visit.pop();\n-      const int cmp_from = COMPARATOR::cmp(head->key(), from);\n-      const int cmp_to = COMPARATOR::cmp(head->key(), to);\n-      if (cmp_from >= 0 && cmp_to < 0) {\n-        if (!f(head)) {\n-          return;\n-        }\n-      }\n-      if (cmp_to < 0) {\n-        head = head->right();\n-      } else {\n-        head = nullptr;\n-      }\n-    }\n-  }\n-};\n-\n-class TreapCHeapAllocator {\n-public:\n-  void* allocate(size_t sz) {\n-    void* allocation = os::malloc(sz, mtNMT);\n-    if (allocation == nullptr) {\n-      vm_exit_out_of_memory(sz, OOM_MALLOC_ERROR, \"treap failed allocation\");\n-    }\n-    return allocation;\n-  }\n-\n-  void free(void* ptr) {\n-    os::free(ptr);\n-  }\n-};\n-\n-template<typename K, typename V, typename COMPARATOR>\n-using TreapCHeap = Treap<K, V, COMPARATOR, TreapCHeapAllocator>;\n-\n-#endif \/\/SHARE_NMT_NMTTREAP_HPP\n","filename":"src\/hotspot\/share\/nmt\/nmtTreap.hpp","additions":0,"deletions":447,"binary":false,"changes":447,"status":"deleted"},{"patch":"@@ -51,2 +51,2 @@\n-  visit_in_order([&](Node* node) {\n-    NodeHelper curr(node);\n+  visit_in_order([&](const Node* node) {\n+    NodeHelper curr(const_cast<Node*>(node));\n","filename":"src\/hotspot\/share\/nmt\/regionsTree.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  using Node = VMATree::TreapNode;\n+  using Node = VMATree::TNode;\n","filename":"src\/hotspot\/share\/nmt\/regionsTree.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,2 +55,2 @@\n-  visit_in_order([&](Node* node) {\n-    NodeHelper curr(node);\n+  visit_in_order([&](const Node* node) {\n+    NodeHelper curr(const_cast<Node*>(node));\n","filename":"src\/hotspot\/share\/nmt\/regionsTree.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -222,2 +222,1 @@\n-size_t ReservedMemoryRegion::committed_size() const {\n-  size_t committed = 0;\n+size_t VirtualMemoryTracker::committed_size(const ReservedMemoryRegion* rmr) {\n@@ -225,1 +224,1 @@\n-  VirtualMemoryTracker::Instance::tree()->visit_committed_regions(*this, [&](CommittedMemoryRegion& crgn) {\n+  tree()->visit_committed_regions(*rmr, [&](CommittedMemoryRegion& crgn) {\n@@ -232,4 +231,14 @@\n-address ReservedMemoryRegion::thread_stack_uncommitted_bottom() const {\n-  address bottom = base();\n-  address top = base() + size();\n-  VirtualMemoryTracker::Instance::tree()->visit_committed_regions(*this, [&](CommittedMemoryRegion& crgn) {\n+size_t VirtualMemoryTracker::Instance::committed_size(const ReservedMemoryRegion* rmr) {\n+  assert(_tracker != nullptr, \"Sanity check\");\n+  return _tracker->committed_size(rmr);\n+}\n+\n+address VirtualMemoryTracker::Instance::thread_stack_uncommitted_bottom(const ReservedMemoryRegion* rmr) {\n+  assert(_tracker != nullptr, \"Sanity check\");\n+  return _tracker->thread_stack_uncommitted_bottom(rmr);\n+}\n+\n+address VirtualMemoryTracker::thread_stack_uncommitted_bottom(const ReservedMemoryRegion* rmr) {\n+  address bottom = rmr->base();\n+  address top = rmr->end();\n+    tree()->visit_committed_regions(*rmr, [&](CommittedMemoryRegion& crgn) {\n@@ -294,1 +303,1 @@\n-      address stack_bottom = rgn->thread_stack_uncommitted_bottom();\n+      address stack_bottom = VirtualMemoryTracker::Instance::thread_stack_uncommitted_bottom(rgn);\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.cpp","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -333,6 +333,0 @@\n-  \/\/ uncommitted thread stack bottom, above guard pages if there is any.\n-  address thread_stack_uncommitted_bottom() const;\n-\n-  size_t committed_size() const;\n-\n-\n@@ -385,0 +379,3 @@\n+  size_t committed_size(const ReservedMemoryRegion* rmr);\n+  address thread_stack_uncommitted_bottom(const ReservedMemoryRegion* rmr);\n+\n@@ -407,0 +404,3 @@\n+    static size_t committed_size(const ReservedMemoryRegion* rmr);\n+    \/\/ uncommitted thread stack bottom, above guard pages if there is any.\n+    static address thread_stack_uncommitted_bottom(const ReservedMemoryRegion* rmr);\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -207,1 +207,1 @@\n-void VMATree::update_region(TreapNode* n1, TreapNode* n2, const RequestInfo& req, SummaryDiff& diff) {\n+void VMATree::update_region(TNode* n1, TNode* n2, const RequestInfo& req, SummaryDiff& diff) {\n@@ -264,2 +264,2 @@\n-  VMATreap::Range rA = _tree.find_enclosing_range(_A);\n-  VMATreap::Range rB = _tree.find_enclosing_range(_B);\n+  VMARBTree::Range rA = _tree.find_enclosing_range(_A);\n+  VMARBTree::Range rB = _tree.find_enclosing_range(_B);\n@@ -323,9 +323,9 @@\n-  TreapNode* X = rA.start;\n-  TreapNode* Y = rA.end;\n-  TreapNode* W = rB.start;\n-  TreapNode* U = rB.end;\n-  TreapNode nA{_A, stA, 0}; \/\/ the node that represents A\n-  TreapNode nB{_B, stB, 0}; \/\/ the node that represents B\n-  TreapNode* A = &nA;\n-  TreapNode* B = &nB;\n-  auto upsert_if= [&](TreapNode* node) {\n+  TNode* X = rA.start;\n+  TNode* Y = rA.end;\n+  TNode* W = rB.start;\n+  TNode* U = rB.end;\n+  TNode nA{_A, stA}; \/\/ the node that represents A\n+  TNode nB{_B, stB}; \/\/ the node that represents B\n+  TNode* A = &nA;\n+  TNode* B = &nB;\n+  auto upsert_if= [&](TNode* node) {\n@@ -337,1 +337,1 @@\n-  auto update = [&](TreapNode* n1, TreapNode* n2) {\n+  auto update = [&](TNode* n1, TNode* n2) {\n@@ -340,1 +340,1 @@\n-  auto remove_if = [&](TreapNode* node) -> bool{\n+  auto remove_if = [&](TNode* node) -> bool{\n@@ -350,2 +350,2 @@\n-    TreapNode* prev = nullptr;\n-    _tree.visit_range_in_order(_A + 1, _B + 1, [&](TreapNode* curr) {\n+    TNode* prev = nullptr;\n+    _tree.visit_range_in_order(_A + 1, _B + 1, [&](TNode* curr) {\n@@ -365,1 +365,1 @@\n-  auto update_A = [&](TreapNode* T) {\n+  auto update_A = [&](TNode* T) {\n@@ -653,1 +653,1 @@\n-  visit_in_order([&](TreapNode* current) {\n+  visit_in_order([&](const TNode* current) {\n@@ -663,1 +663,1 @@\n-  auto pos = [](TreapNode* n) { return n->key(); };\n+  auto pos = [](TNode* n) { return n->key(); };\n@@ -667,1 +667,1 @@\n-  VMATreap::Range range(nullptr, nullptr);\n+  VMARBTree::Range range(nullptr, nullptr);\n","filename":"src\/hotspot\/share\/nmt\/vmatree.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"nmt\/nmtTreap.hpp\"\n@@ -35,0 +34,1 @@\n+#include \"utilities\/rbTree.inline.hpp\"\n@@ -196,2 +196,2 @@\n-  using VMATreap = TreapCHeap<position, IntervalChange, PositionComparator>;\n-  using TreapNode = VMATreap::TreapNode;\n+  using VMARBTree = RBTreeCHeap<position, IntervalChange, PositionComparator, mtNMT>;\n+  using TNode = RBNode<position, IntervalChange>;\n@@ -200,1 +200,1 @@\n-  VMATreap _tree;\n+  VMARBTree _tree;\n@@ -202,1 +202,1 @@\n-  static IntervalState& in_state(TreapNode* node) {\n+  static IntervalState& in_state(TNode* node) {\n@@ -206,1 +206,5 @@\n-  static IntervalState& out_state(TreapNode* node) {\n+  static IntervalState& out_state(TNode* node) {\n+    return node->val().out;\n+  }\n+\n+  static const IntervalState& out_state(const TNode* node) {\n@@ -284,1 +288,1 @@\n-  void update_region(TreapNode* n1, TreapNode* n2, const RequestInfo& req, SummaryDiff& diff);\n+  void update_region(TNode* n1, TNode* n2, const RequestInfo& req, SummaryDiff& diff);\n@@ -328,1 +332,1 @@\n-  VMATreap& tree() { return _tree; }\n+  VMARBTree& tree() { return _tree; }\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"utilities\/hashTable.hpp\"\n@@ -41,1 +42,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -875,1 +875,1 @@\n-    ResourceHashtable<const Symbol*, u2, 256, AnyObj::C_HEAP, mtSymbol, Symbol::compute_hash> _table;\n+    HashTable<const Symbol*, u2, 256, AnyObj::C_HEAP, mtSymbol, Symbol::compute_hash> _table;\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1119,1 +1119,1 @@\n-using InitializationErrorTable = ResourceHashtable<const InstanceKlass*, OopHandle, 107, AnyObj::C_HEAP, mtClass>;\n+using InitializationErrorTable = HashTable<const InstanceKlass*, OopHandle, 107, AnyObj::C_HEAP, mtClass>;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-#include \"utilities\/resizeableResourceHash.hpp\"\n+#include \"utilities\/resizableHashTable.hpp\"\n@@ -176,1 +176,1 @@\n-    ResizeableResourceHashtable<const Key*, TrainingData*,\n+    ResizeableHashTable<const Key*, TrainingData*,\n@@ -232,1 +232,1 @@\n-    ResizeableResourceHashtable<TrainingData*, bool> _visited;\n+    ResizeableHashTable<TrainingData*, bool> _visited;\n","filename":"src\/hotspot\/share\/oops\/trainingData.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -93,0 +93,6 @@\n+  \/\/ If there was an error generating the blob then UseCompiler will\n+  \/\/ have been unset and we need to skip the remaining initialization\n+  if (!UseCompiler) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+#include \"utilities\/hashTable.hpp\"\n@@ -91,1 +92,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -2152,1 +2152,1 @@\n-    igvn.reset_from_gvn(initial_gvn());\n+    igvn.reset();\n@@ -2313,2 +2313,1 @@\n-  \/\/ Initialize IterGVN with types and values from parse-time GVN\n-  PhaseIterGVN igvn(initial_gvn());\n+  PhaseIterGVN igvn;\n@@ -2383,1 +2382,1 @@\n-    igvn.reset_from_gvn(initial_gvn());\n+    igvn.reset();\n@@ -2790,1 +2789,1 @@\n-static uint eval_operand(Node* n, ResourceHashtable<Node*,uint>& eval_map) {\n+static uint eval_operand(Node* n, HashTable<Node*,uint>& eval_map) {\n@@ -2798,1 +2797,1 @@\n-                          ResourceHashtable<Node*,uint>& eval_map) {\n+                          HashTable<Node*,uint>& eval_map) {\n@@ -2822,1 +2821,1 @@\n-  ResourceHashtable<Node*,uint> eval_map;\n+  HashTable<Node*,uint> eval_map;\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1985,1 +1985,1 @@\n-        \/\/ Use 107 as best guess which is the first resize value in ResizeableResourceHashtable::large_table_sizes.\n+        \/\/ Use 107 as best guess which is the first resize value in ResizeableHashTable::large_table_sizes.\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n","filename":"src\/hotspot\/share\/opto\/mempointer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n-typedef ResizeableResourceHashtable<Node*, Node*, AnyObj::RESOURCE_AREA, mtCompiler> OrigToNewHashtable;\n+typedef ResizeableHashTable<Node*, Node*, AnyObj::RESOURCE_AREA, mtCompiler> OrigToNewHashtable;\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -810,3 +810,3 @@\n-\/\/ Initialize with previous PhaseGVN info from Parser\n-PhaseIterGVN::PhaseIterGVN(PhaseGVN* gvn) : _delay_transform(false),\n-                                            _worklist(*C->igvn_worklist())\n+\/\/ Initialize from scratch\n+PhaseIterGVN::PhaseIterGVN() : _delay_transform(false),\n+                               _worklist(*C->igvn_worklist())\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -462,1 +462,1 @@\n-  PhaseIterGVN(PhaseGVN* gvn); \/\/ Used after Parser\n+  PhaseIterGVN();\n@@ -464,8 +464,4 @@\n-  \/\/ Reset IGVN from GVN: call deconstructor, and placement new.\n-  \/\/ Achieves the same as the following (but without move constructors):\n-  \/\/ igvn = PhaseIterGVN(gvn);\n-  void reset_from_gvn(PhaseGVN* gvn) {\n-    if (this != gvn) {\n-      this->~PhaseIterGVN();\n-      ::new (static_cast<void*>(this)) PhaseIterGVN(gvn);\n-    }\n+  \/\/ Reset IGVN: call deconstructor, and placement new.\n+  void reset() {\n+    this->~PhaseIterGVN();\n+    ::new (static_cast<void*>(this)) PhaseIterGVN();\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -49,1 +49,4 @@\n-  _root.dump(tty, -1);\n+  \/\/ using stringStream prevents interleaving with multiple compile threads\n+  stringStream ss;\n+  _root.dump(&ss, -1);\n+  tty->print_raw(ss.freeze());\n@@ -71,2 +74,1 @@\n-  auto find_result = _children.find(bci);\n-  IPInlineSite& child = find_result.node->val();\n+  RBTreeCHeap<int, IPInlineSite, Cmp, mtCompiler>::Cursor cursor = _children.cursor(bci);\n@@ -74,4 +76,2 @@\n-  if (find_result.new_node) {\n-    assert(callee != nullptr, \"an inline call is missing in the chain up to the root\");\n-    child.set_source(callee, bci);\n-  } else { \/\/ We already saw a call at this site before\n+  if (cursor.found()) { \/\/ We already saw a call at this site before\n+    IPInlineSite& child = cursor.node()->val();\n@@ -83,0 +83,1 @@\n+    return child;\n@@ -85,1 +86,7 @@\n-  return child;\n+  assert(callee != nullptr, \"an inline call is missing in the chain up to the root\");\n+\n+  RBNode<int, IPInlineSite>* node = _children.allocate_node(bci);\n+  _children.insert_at_cursor(node, cursor);\n+  node->val().set_source(callee, bci);\n+\n+  return node->val();\n","filename":"src\/hotspot\/share\/opto\/printinlining.cpp","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"nmt\/nmtTreap.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"utilities\/rbTree.inline.hpp\"\n@@ -80,1 +80,1 @@\n-    TreapCHeap<int, IPInlineSite, Cmp> _children;\n+    RBTreeCHeap<int, IPInlineSite, Cmp, mtCompiler> _children;\n","filename":"src\/hotspot\/share\/opto\/printinlining.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  ResourceHashtable<\/* Node::_idx*\/ int, VTransformNode* \/* or null*\/> _idx_to_vtnode;\n+  HashTable<\/* Node::_idx*\/ int, VTransformNode* \/* or null*\/> _idx_to_vtnode;\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-    _igvn.reset_from_gvn(C->initial_gvn());\n+    _igvn.reset();\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -204,1 +204,1 @@\n-  using KillerTable = ResourceHashtable<\n+  using KillerTable = HashTable<\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2948,1 +2948,1 @@\n-  oop trace = java_lang_Thread::async_get_stack_trace(JNIHandles::resolve(jthread), THREAD);\n+  oop trace = java_lang_Thread::async_get_stack_trace(jthread, THREAD);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"utilities\/resizeableResourceHash.hpp\"\n+#include \"utilities\/resizableHashTable.hpp\"\n@@ -68,1 +68,1 @@\n-ResizeableResourceHashtable <JvmtiTagMapKey, jlong,\n+ResizeableHashTable <JvmtiTagMapKey, jlong,\n@@ -71,1 +71,1 @@\n-                              JvmtiTagMapKey::equals> ResizableResourceHT;\n+                              JvmtiTagMapKey::equals> ResizableHT;\n@@ -75,1 +75,1 @@\n-  ResizableResourceHT _table;\n+  ResizableHT _table;\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -483,1 +483,3 @@\n-static jlong find_field_offset(jclass clazz, jstring name, TRAPS) {\n+\/\/ Finds the object field offset of a field with the matching name, or an error code\n+\/\/ Error code -1 is not found, -2 is static field\n+static jlong find_known_instance_field_offset(jclass clazz, jstring name, TRAPS) {\n@@ -492,1 +494,1 @@\n-  jint offset = -1;\n+  jint offset = -1; \/\/ Not found\n@@ -496,1 +498,5 @@\n-      offset = fs.offset();\n+      if (!fs.access_flags().is_static()) {\n+        offset = fs.offset();\n+      } else {\n+        offset = -2; \/\/ A static field\n+      }\n@@ -501,1 +507,1 @@\n-    THROW_0(vmSymbols::java_lang_InternalError());\n+    return offset; \/\/ Error code\n@@ -530,2 +536,2 @@\n-UNSAFE_ENTRY(jlong, Unsafe_ObjectFieldOffset1(JNIEnv *env, jobject unsafe, jclass c, jstring name)) {\n-  return find_field_offset(c, name, THREAD);\n+UNSAFE_ENTRY(jlong, Unsafe_KnownObjectFieldOffset0(JNIEnv *env, jobject unsafe, jclass c, jstring name)) {\n+  return find_known_instance_field_offset(c, name, THREAD);\n@@ -885,1 +891,1 @@\n-    {CC \"objectFieldOffset1\", CC \"(\" CLS LANG \"String;)J\", FN_PTR(Unsafe_ObjectFieldOffset1)},\n+    {CC \"knownObjectFieldOffset0\", CC \"(\" CLS LANG \"String;)J\", FN_PTR(Unsafe_KnownObjectFieldOffset0)},\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1505,6 +1505,0 @@\n-#if INCLUDE_G1GC\n-  if (UseG1GC) {\n-    \/\/ Needs to be cleared explicitly for G1 GC.\n-    Universe::heap()->soft_ref_policy()->set_should_clear_all_soft_refs(false);\n-  }\n-#endif \/\/ INCLUDE_G1GC\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -328,13 +328,0 @@\n-const char* Abstract_VM_Version::extract_features_string(const char* cpu_info_string,\n-                                                         size_t cpu_info_string_len,\n-                                                         size_t features_offset) {\n-  assert(features_offset <= cpu_info_string_len, \"\");\n-  if (features_offset < cpu_info_string_len) {\n-    assert(cpu_info_string[features_offset + 0] == ',', \"\");\n-    assert(cpu_info_string[features_offset + 1] == ' ', \"\");\n-    return cpu_info_string + features_offset + 2; \/\/ skip initial \", \"\n-  } else {\n-    return \"\"; \/\/ empty\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -135,3 +135,0 @@\n-  static const char* extract_features_string(const char* cpu_info_string,\n-                                             size_t cpu_info_string_len,\n-                                             size_t features_offset);\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"memory\/allStatic.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"memory\/allStatic.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -2453,1 +2453,1 @@\n-using AdapterHandlerTable = ResourceHashtable<AdapterFingerPrint*, AdapterHandlerEntry*, 293,\n+using AdapterHandlerTable = HashTable<AdapterFingerPrint*, AdapterHandlerEntry*, 293,\n@@ -2772,1 +2772,1 @@\n-  int offsets[AdapterHandlerEntry::ENTRIES_COUNT];\n+  int offsets[AdapterBlob::ENTRY_COUNT];\n@@ -2775,1 +2775,1 @@\n-  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::Adapter, id, name, AdapterHandlerEntry::ENTRIES_COUNT, offsets);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::Adapter, id, name);\n@@ -2778,0 +2778,1 @@\n+    adapter_blob->get_offsets(offsets);\n@@ -2780,1 +2781,6 @@\n-    handler->set_entry_points(i2c_entry, i2c_entry + offsets[1], i2c_entry + offsets[2], i2c_entry + offsets[3]);\n+    handler->set_entry_points(\n+      i2c_entry,\n+      (offsets[1] != -1) ? (i2c_entry + offsets[1]) : nullptr,\n+      (offsets[2] != -1) ? (i2c_entry + offsets[2]) : nullptr,\n+      (offsets[3] != -1) ? (i2c_entry + offsets[3]) : nullptr\n+    );\n@@ -2840,1 +2846,12 @@\n-  adapter_blob = AdapterBlob::create(&buffer);\n+  int entry_offset[AdapterBlob::ENTRY_COUNT];\n+  assert(AdapterBlob::ENTRY_COUNT == 4, \"sanity\");\n+  address i2c_entry = handler->get_i2c_entry();\n+  entry_offset[0] = 0; \/\/ i2c_entry offset\n+  entry_offset[1] = (handler->get_c2i_entry() != nullptr) ?\n+                    (handler->get_c2i_entry() - i2c_entry) : -1;\n+  entry_offset[2] = (handler->get_c2i_unverified_entry() != nullptr) ?\n+                    (handler->get_c2i_unverified_entry() - i2c_entry) : -1;\n+  entry_offset[3] = (handler->get_c2i_no_clinit_check_entry() != nullptr) ?\n+                    (handler->get_c2i_no_clinit_check_entry() - i2c_entry) : -1;\n+\n+  adapter_blob = AdapterBlob::create(&buffer, entry_offset);\n@@ -2851,8 +2868,1 @@\n-    int entry_offset[AdapterHandlerEntry::ENTRIES_COUNT];\n-    assert(AdapterHandlerEntry::ENTRIES_COUNT == 4, \"sanity\");\n-    address i2c_entry = handler->get_i2c_entry();\n-    entry_offset[0] = 0; \/\/ i2c_entry offset\n-    entry_offset[1] = handler->get_c2i_entry() - i2c_entry;\n-    entry_offset[2] = handler->get_c2i_unverified_entry() - i2c_entry;\n-    entry_offset[3] = handler->get_c2i_no_clinit_check_entry() - i2c_entry;\n-    bool success = AOTCodeCache::store_code_blob(*adapter_blob, AOTCodeEntry::Adapter, id, name, AdapterHandlerEntry::ENTRIES_COUNT, entry_offset);\n+    bool success = AOTCodeCache::store_code_blob(*adapter_blob, AOTCodeEntry::Adapter, id, name);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":24,"deletions":14,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -184,0 +184,11 @@\n+    \/\/ The compiler blob may be created late by a C2 compiler thread\n+    \/\/ rather than during normal initialization by the initial thread.\n+    \/\/ In that case we can tolerate an allocation failure because the\n+    \/\/ compiler will have been shut down and we have no need of the\n+    \/\/ blob.\n+    if (Thread::current()->is_Compiler_thread()) {\n+      assert(blob_id == BlobId::stubgen_compiler_id, \"sanity\");\n+      assert(DelayCompilerStubsGeneration, \"sanity\");\n+      log_warning(stubs)(\"%s\\t not generated:\\t no space left in CodeCache\", buffer_name);\n+      return nullptr;\n+    }\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"utilities\/hashTable.hpp\"\n@@ -44,1 +45,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -194,1 +194,1 @@\n-  \/\/ ResourceHashtable SIZE is specified at compile time so we\n+  \/\/ HashTable SIZE is specified at compile time so we\n@@ -196,1 +196,1 @@\n-  typedef ResourceHashtable<void *, int, 1031,\n+  typedef HashTable<void *, int, 1031,\n@@ -202,1 +202,1 @@\n-  \/\/ ResourceHashtable is passed to various functions and populated in\n+  \/\/ HashTable is passed to various functions and populated in\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -294,1 +294,1 @@\n-  \/\/ ResourceHashtable SIZE is specified at compile time so we\n+  \/\/ HashTable SIZE is specified at compile time so we\n@@ -296,1 +296,1 @@\n-  typedef ResourceHashtable<int64_t, ObjectMonitorLinkedList*, 1031, AnyObj::C_HEAP, mtThread,\n+  typedef HashTable<int64_t, ObjectMonitorLinkedList*, 1031, AnyObj::C_HEAP, mtThread,\n@@ -329,1 +329,1 @@\n-  \/\/ ResourceHashtable is passed to various functions and populated in\n+  \/\/ HashTable is passed to various functions and populated in\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -834,1 +834,1 @@\n-  \/\/ ResourceHashtable SIZE is specified at compile time so we\n+  \/\/ HashTable SIZE is specified at compile time so we\n@@ -844,1 +844,1 @@\n-  typedef ResourceHashtable<InstanceKlass*, DumperClassCacheTableEntry*,\n+  typedef HashTable<InstanceKlass*, DumperClassCacheTableEntry*,\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1335,1 +1335,1 @@\n-\/\/ Default hash\/equals functions used by ResourceHashtable\n+\/\/ Default hash\/equals functions used by HashTable\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,380 @@\n+\/*\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_HASHTABLE_HPP\n+#define SHARE_UTILITIES_HASHTABLE_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/numberSeq.hpp\"\n+#include \"utilities\/tableStatistics.hpp\"\n+\n+#include <type_traits>\n+\n+template<typename K, typename V>\n+class HashTableNode : public AnyObj {\n+public:\n+  unsigned _hash;\n+  K _key;\n+  V _value;\n+  HashTableNode* _next;\n+\n+  HashTableNode(unsigned hash, K const& key, V const& value,\n+                        HashTableNode* next = nullptr) :\n+    _hash(hash), _key(key), _value(value), _next(next) {}\n+\n+  \/\/ Create a node with a default-constructed value.\n+  HashTableNode(unsigned hash, K const& key,\n+                        HashTableNode* next = nullptr) :\n+    _hash(hash), _key(key), _value(), _next(next) {}\n+};\n+\n+template<\n+    class STORAGE,\n+    typename K, typename V,\n+    AnyObj::allocation_type ALLOC_TYPE,\n+    MemTag MEM_TAG,\n+    unsigned (*HASH)  (K const&),\n+    bool     (*EQUALS)(K const&, K const&)\n+    >\n+class HashTableBase : public STORAGE {\n+  static_assert(ALLOC_TYPE == AnyObj::C_HEAP || std::is_trivially_destructible<K>::value,\n+                \"Destructor for K is only called with C_HEAP\");\n+  static_assert(ALLOC_TYPE == AnyObj::C_HEAP || std::is_trivially_destructible<V>::value,\n+                \"Destructor for V is only called with C_HEAP\");\n+  using Node = HashTableNode<K, V>;\n+ private:\n+  int _number_of_entries;\n+\n+  Node** bucket_at(unsigned index) {\n+    Node** t = table();\n+    return &t[index];\n+  }\n+\n+  const Node* const* bucket_at(unsigned index) const {\n+    Node** t = table();\n+    return &t[index];\n+  }\n+\n+  \/\/ Returns a pointer to where the node where the value would reside if\n+  \/\/ it's in the table.\n+  Node** lookup_node(unsigned hash, K const& key) {\n+    unsigned index = hash % table_size();\n+    Node** ptr = bucket_at(index);\n+    while (*ptr != nullptr) {\n+      Node* node = *ptr;\n+      if (node->_hash == hash && EQUALS(key, node->_key)) {\n+        break;\n+      }\n+      ptr = &(node->_next);\n+    }\n+    return ptr;\n+  }\n+\n+  Node const** lookup_node(unsigned hash, K const& key) const {\n+    return const_cast<Node const**>(\n+        const_cast<HashTableBase*>(this)->lookup_node(hash, key));\n+  }\n+\n+ protected:\n+  Node** table() const { return STORAGE::table(); }\n+\n+  HashTableBase() : STORAGE(), _number_of_entries(0) {}\n+  HashTableBase(unsigned size) : STORAGE(size), _number_of_entries(0) {}\n+  NONCOPYABLE(HashTableBase);\n+\n+  ~HashTableBase() {\n+    if (ALLOC_TYPE == AnyObj::C_HEAP) {\n+      Node* const* bucket = table();\n+      const unsigned sz = table_size();\n+      while (bucket < bucket_at(sz)) {\n+        Node* node = *bucket;\n+        while (node != nullptr) {\n+          Node* cur = node;\n+          node = node->_next;\n+          delete cur;\n+        }\n+        ++bucket;\n+      }\n+    }\n+  }\n+\n+ public:\n+  unsigned table_size() const { return STORAGE::table_size(); }\n+  int number_of_entries() const { return _number_of_entries; }\n+\n+  bool contains(K const& key) const {\n+    return get(key) != nullptr;\n+  }\n+\n+  V* get(K const& key) const {\n+    unsigned hv = HASH(key);\n+    Node const** ptr = lookup_node(hv, key);\n+    if (*ptr != nullptr) {\n+      return const_cast<V*>(&(*ptr)->_value);\n+    } else {\n+      return nullptr;\n+    }\n+  }\n+\n+ \/**\n+  * Inserts a value in the front of the table, assuming that\n+  * the entry is absent.\n+  * The table must be locked for the get or test that the entry\n+  * is absent, and for this operation.\n+  * This is a faster variant of put_if_absent because it adds to the\n+  * head of the bucket, and doesn't search the bucket.\n+  * @return: true: a new item is always added\n+  *\/\n+  bool put_when_absent(K const& key, V const& value) {\n+    unsigned hv = HASH(key);\n+    unsigned index = hv % table_size();\n+    assert(*lookup_node(hv, key) == nullptr, \"use put_if_absent\");\n+    Node** ptr = bucket_at(index);\n+    if (ALLOC_TYPE == AnyObj::C_HEAP) {\n+      *ptr = new (MEM_TAG) Node(hv, key, value, *ptr);\n+    } else {\n+      *ptr = new Node(hv, key, value, *ptr);\n+    }\n+    _number_of_entries ++;\n+    return true;\n+  }\n+\n+ \/**\n+  * Inserts or replaces a value in the table.\n+  * @return: true:  if a new item is added\n+  *          false: if the item already existed and the value is updated\n+  *\/\n+  bool put(K const& key, V const& value) {\n+    unsigned hv = HASH(key);\n+    Node** ptr = lookup_node(hv, key);\n+    if (*ptr != nullptr) {\n+      (*ptr)->_value = value;\n+      return false;\n+    } else {\n+      if (ALLOC_TYPE == AnyObj::C_HEAP) {\n+        *ptr = new (MEM_TAG) Node(hv, key, value);\n+      } else {\n+        *ptr = new Node(hv, key, value);\n+      }\n+      _number_of_entries ++;\n+      return true;\n+    }\n+  }\n+\n+  \/\/ Look up the key.\n+  \/\/ If an entry for the key exists, leave map unchanged and return a pointer to its value.\n+  \/\/ If no entry for the key exists, create a new entry from key and a default-created value\n+  \/\/  and return a pointer to the value.\n+  \/\/ *p_created is true if entry was created, false if entry pre-existed.\n+  V* put_if_absent(K const& key, bool* p_created) {\n+    unsigned hv = HASH(key);\n+    Node** ptr = lookup_node(hv, key);\n+    if (*ptr == nullptr) {\n+      if (ALLOC_TYPE == AnyObj::C_HEAP) {\n+        *ptr = new (MEM_TAG) Node(hv, key);\n+      } else {\n+        *ptr = new Node(hv, key);\n+      }\n+      *p_created = true;\n+      _number_of_entries ++;\n+    } else {\n+      *p_created = false;\n+    }\n+    return &(*ptr)->_value;\n+  }\n+\n+  \/\/ Look up the key.\n+  \/\/ If an entry for the key exists, leave map unchanged and return a pointer to its value.\n+  \/\/ If no entry for the key exists, create a new entry from key and value and return a\n+  \/\/  pointer to the value.\n+  \/\/ *p_created is true if entry was created, false if entry pre-existed.\n+  V* put_if_absent(K const& key, V const& value, bool* p_created) {\n+    unsigned hv = HASH(key);\n+    Node** ptr = lookup_node(hv, key);\n+    if (*ptr == nullptr) {\n+      if (ALLOC_TYPE == AnyObj::C_HEAP) {\n+        *ptr = new (MEM_TAG) Node(hv, key, value);\n+      } else {\n+        *ptr = new Node(hv, key, value);\n+      }\n+      *p_created = true;\n+      _number_of_entries ++;\n+    } else {\n+      *p_created = false;\n+    }\n+    return &(*ptr)->_value;\n+  }\n+\n+  template<typename Function>\n+  bool remove(K const& key, Function function) {\n+    unsigned hv = HASH(key);\n+    Node** ptr = lookup_node(hv, key);\n+\n+    Node* node = *ptr;\n+    if (node != nullptr) {\n+      *ptr = node->_next;\n+      function(node->_key, node->_value);\n+      if (ALLOC_TYPE == AnyObj::C_HEAP) {\n+        delete node;\n+      }\n+      _number_of_entries --;\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  bool remove(K const& key) {\n+    auto dummy = [&] (K& k, V& v) { };\n+    return remove(key, dummy);\n+  }\n+\n+  \/\/ ITER contains bool do_entry(K const&, V const&), which will be\n+  \/\/ called for each entry in the table.  If do_entry() returns false,\n+  \/\/ the iteration is cancelled.\n+  template<class ITER>\n+  void iterate(ITER* iter) const {\n+    auto function = [&] (K& k, V& v) {\n+      return iter->do_entry(k, v);\n+    };\n+    iterate(function);\n+  }\n+\n+  template<typename Function>\n+  void iterate(Function function) const { \/\/ lambda enabled API\n+    Node* const* bucket = table();\n+    const unsigned sz = table_size();\n+    int cnt = _number_of_entries;\n+\n+    while (cnt > 0 && bucket < bucket_at(sz)) {\n+      Node* node = *bucket;\n+      while (node != nullptr) {\n+        bool cont = function(node->_key, node->_value);\n+        if (!cont) { return; }\n+        node = node->_next;\n+        --cnt;\n+      }\n+      ++bucket;\n+    }\n+  }\n+\n+  \/\/ same as above, but unconditionally iterate all entries\n+  template<typename Function>\n+  void iterate_all(Function function) const { \/\/ lambda enabled API\n+    auto wrapper = [&] (K& k, V& v) {\n+      function(k, v);\n+      return true;\n+    };\n+    iterate(wrapper);\n+  }\n+\n+  \/\/ ITER contains bool do_entry(K const&, V const&), which will be\n+  \/\/ called for each entry in the table.  If do_entry() returns true,\n+  \/\/ the entry is deleted.\n+  template<class ITER>\n+  void unlink(ITER* iter) {\n+    const unsigned sz = table_size();\n+    for (unsigned index = 0; index < sz; index++) {\n+      Node** ptr = bucket_at(index);\n+      while (*ptr != nullptr) {\n+        Node* node = *ptr;\n+        \/\/ do_entry must clean up the key and value in Node.\n+        bool clean = iter->do_entry(node->_key, node->_value);\n+        if (clean) {\n+          *ptr = node->_next;\n+          if (ALLOC_TYPE == AnyObj::C_HEAP) {\n+            delete node;\n+          }\n+          _number_of_entries --;\n+        } else {\n+          ptr = &(node->_next);\n+        }\n+      }\n+    }\n+  }\n+\n+  template<typename Function>\n+  TableStatistics statistics_calculate(Function size_function) const {\n+    NumberSeq summary;\n+    size_t literal_bytes = 0;\n+    Node* const* bucket = table();\n+    const unsigned sz = table_size();\n+    while (bucket < bucket_at(sz)) {\n+      Node* node = *bucket;\n+      int count = 0;\n+      while (node != nullptr) {\n+        literal_bytes += size_function(node->_key, node->_value);\n+        count++;\n+        node = node->_next;\n+      }\n+      summary.add((double)count);\n+      ++bucket;\n+    }\n+    return TableStatistics(summary, literal_bytes, sizeof(Node*), sizeof(Node));\n+  }\n+\n+  \/\/ This method calculates the \"shallow\" size. If you want the recursive size, use statistics_calculate.\n+  size_t mem_size() const {\n+    return sizeof(*this) +\n+      table_size() * sizeof(Node*) +\n+      number_of_entries() * sizeof(Node);\n+  }\n+};\n+\n+template<unsigned TABLE_SIZE, typename K, typename V>\n+class FixedHashTableStorage : public AnyObj {\n+  using Node = HashTableNode<K, V>;\n+\n+  Node* _table[TABLE_SIZE];\n+protected:\n+  FixedHashTableStorage() { memset(_table, 0, sizeof(_table)); }\n+  ~FixedHashTableStorage() = default;\n+\n+  constexpr unsigned table_size() const {\n+    return TABLE_SIZE;\n+  }\n+\n+  Node** table() const {\n+    return const_cast<Node**>(_table);\n+  }\n+};\n+\n+template<\n+    typename K, typename V,\n+    unsigned SIZE = 256,\n+    AnyObj::allocation_type ALLOC_TYPE = AnyObj::RESOURCE_AREA,\n+    MemTag MEM_TAG = mtInternal,\n+    unsigned (*HASH)  (K const&)           = primitive_hash<K>,\n+    bool     (*EQUALS)(K const&, K const&) = primitive_equals<K>\n+    >\n+class HashTable : public HashTableBase<\n+  FixedHashTableStorage<SIZE, K, V>,\n+    K, V, ALLOC_TYPE, MEM_TAG, HASH, EQUALS> {\n+  NONCOPYABLE(HashTable);\n+public:\n+  HashTable() : HashTableBase<FixedHashTableStorage<SIZE, K, V>,\n+                                              K, V, ALLOC_TYPE, MEM_TAG, HASH, EQUALS>() {}\n+};\n+\n+#endif \/\/ SHARE_UTILITIES_HASHTABLE_HPP\n","filename":"src\/hotspot\/share\/utilities\/hashTable.hpp","additions":380,"deletions":0,"binary":false,"changes":380,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/hashTable.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/nativeCallStack.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"utilities\/resizeableResourceHash.hpp\"\n+#include \"utilities\/resizableHashTable.hpp\"\n@@ -55,1 +55,1 @@\n-  typedef ResizeableResourceHashtable<uintptr_t, CHeapBitMap*, AnyObj::C_HEAP, MT,\n+  typedef ResizeableHashTable<uintptr_t, CHeapBitMap*, AnyObj::C_HEAP, MT,\n","filename":"src\/hotspot\/share\/utilities\/objectBitSet.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,2 +55,2 @@\n-  \/\/ destructors for ResourceHashtable base deletes nodes, and\n-  \/\/ ResizeableResourceHashtableStorage deletes the table.\n+  \/\/ destructors for HashTable base deletes nodes, and\n+  \/\/ ResizeableHashTableStorage deletes the table.\n","filename":"src\/hotspot\/share\/utilities\/objectBitSet.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -168,0 +168,14 @@\n+\n+   \/\/ Append strings returned by gen, separating each with separator.\n+   \/\/ Stops when gen returns null.\n+   template <typename Generator>\n+   void join(Generator gen, const char* separator) {\n+     bool first = true;\n+     const char* str = gen();\n+     while (str != nullptr) {\n+       const char* sep = first ? \"\" : separator;\n+       print(\"%s%s\", sep, str);\n+       first = false;\n+       str = gen();\n+     }\n+   }\n","filename":"src\/hotspot\/share\/utilities\/ostream.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -170,0 +170,1 @@\n+  friend class NMTVMATreeTest;\n@@ -407,0 +408,1 @@\n+  \/\/ If f returns `true` the iteration continues, otherwise it is stopped at the current node.\n@@ -410,0 +412,3 @@\n+  template <typename F>\n+  void visit_in_order(F f);\n+\n@@ -411,0 +416,1 @@\n+  \/\/ If f returns `true` the iteration continues, otherwise it is stopped at the current node.\n@@ -414,0 +420,3 @@\n+  template <typename F>\n+  void visit_range_in_order(const K &from, const K &to, F f);\n+\n@@ -460,0 +469,6 @@\n+  RBNode<K, V>* allocate_node(const K& key) {\n+    void* node_place = _allocator.allocate(sizeof(RBNode<K, V>));\n+    assert(node_place != nullptr, \"rb-tree allocator must exit on failure\");\n+    return new (node_place) RBNode<K, V>(key);\n+  }\n+\n","filename":"src\/hotspot\/share\/utilities\/rbTree.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-  if (_left != nullptr) { \/\/ right subtree exists\n+  if (_left != nullptr) { \/\/ left subtree exists\n@@ -602,1 +602,15 @@\n-    f(node);\n+    if (!f(node)) {\n+      return;\n+    }\n+    node = node->next();\n+  }\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+template <typename F>\n+inline void AbstractRBTree<K, NodeType, COMPARATOR>::visit_in_order(F f) {\n+  NodeType* node = leftmost();\n+  while (node != nullptr) {\n+    if (!f(node)) {\n+      return;\n+    }\n@@ -621,1 +635,24 @@\n-    f(start);\n+    if (!f(start)) {\n+      return;\n+    }\n+    start = start->next();\n+  }\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+template <typename F>\n+inline void AbstractRBTree<K, NodeType, COMPARATOR>::visit_range_in_order(const K& from, const K& to, F f) {\n+  assert_key_leq(from, to);\n+  if (_root == nullptr) {\n+    return;\n+  }\n+\n+  Cursor cursor_start = cursor(from);\n+  Cursor cursor_end = cursor(to);\n+  NodeType* start = cursor_start.found() ? cursor_start.node() : next(cursor_start).node();\n+  NodeType* end = next(cursor_end).node();\n+\n+  while (start != end) {\n+    if (!f(start)) {\n+      return;\n+    }\n","filename":"src\/hotspot\/share\/utilities\/rbTree.inline.hpp","additions":40,"deletions":3,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_RESIZEABLEHASHTABLE_HPP\n+#define SHARE_UTILITIES_RESIZEABLEHASHTABLE_HPP\n+\n+#include \"utilities\/hashTable.hpp\"\n+\n+template<\n+    typename K, typename V,\n+    AnyObj::allocation_type ALLOC_TYPE,\n+    MemTag MEM_TAG>\n+class ResizeableHashTableStorage : public AnyObj {\n+  using Node = HashTableNode<K, V>;\n+\n+protected:\n+  unsigned _table_size;\n+  Node** _table;\n+\n+  ResizeableHashTableStorage(unsigned table_size) {\n+    _table_size = table_size;\n+    _table = alloc_table(table_size);\n+  }\n+\n+  ~ResizeableHashTableStorage() {\n+    if (ALLOC_TYPE == C_HEAP) {\n+      FREE_C_HEAP_ARRAY(Node*, _table);\n+    }\n+  }\n+\n+  Node** alloc_table(unsigned table_size) {\n+    Node** table;\n+    if (ALLOC_TYPE == C_HEAP) {\n+      table = NEW_C_HEAP_ARRAY(Node*, table_size, MEM_TAG);\n+    } else {\n+      table = NEW_RESOURCE_ARRAY(Node*, table_size);\n+    }\n+    memset(table, 0, table_size * sizeof(Node*));\n+    return table;\n+  }\n+\n+  unsigned table_size() const {\n+    return _table_size;\n+  }\n+\n+  Node** table() const {\n+    return _table;\n+  }\n+};\n+\n+template<\n+    typename K, typename V,\n+    AnyObj::allocation_type ALLOC_TYPE = AnyObj::RESOURCE_AREA,\n+    MemTag MEM_TAG = mtInternal,\n+    unsigned (*HASH)  (K const&)           = primitive_hash<K>,\n+    bool     (*EQUALS)(K const&, K const&) = primitive_equals<K>\n+    >\n+class ResizeableHashTable : public HashTableBase<\n+    ResizeableHashTableStorage<K, V, ALLOC_TYPE, MEM_TAG>,\n+    K, V, ALLOC_TYPE, MEM_TAG, HASH, EQUALS> {\n+  unsigned _max_size;\n+\n+  using BASE = HashTableBase<ResizeableHashTableStorage<K, V, ALLOC_TYPE, MEM_TAG>,\n+                                     K, V, ALLOC_TYPE, MEM_TAG, HASH, EQUALS>;\n+  using Node = HashTableNode<K, V>;\n+  NONCOPYABLE(ResizeableHashTable);\n+\n+  \/\/ Calculate next \"good\" hashtable size based on requested count\n+  int calculate_resize(bool use_large_table_sizes) const {\n+    const int resize_factor = 2;     \/\/ by how much we will resize using current number of entries\n+\n+    \/\/ possible hashmap sizes - odd primes that roughly double in size.\n+    \/\/ To avoid excessive resizing the odd primes from 4801-76831 and\n+    \/\/ 76831-307261 have been removed.\n+    const int large_table_sizes[] =  { 107, 1009, 2017, 4049, 5051, 10103, 20201,\n+                                       40423, 76831, 307261, 614563, 1228891, 2457733,\n+                                       4915219, 9830479, 19660831, 39321619, 78643219 };\n+    const int large_array_size = sizeof(large_table_sizes)\/sizeof(int);\n+\n+    int requested = resize_factor * BASE::number_of_entries();\n+    int start_at = use_large_table_sizes ? 8 : 0;\n+    int newsize;\n+    for (int i = start_at; i < large_array_size; i++) {\n+      newsize = large_table_sizes[i];\n+      if (newsize >= requested) {\n+        return newsize;\n+      }\n+    }\n+    return requested; \/\/ greater than a size in the table\n+  }\n+\n+public:\n+  ResizeableHashTable(unsigned size, unsigned max_size)\n+  : BASE(size), _max_size(max_size) {\n+    assert(size <= 0x3fffffff && max_size <= 0x3fffffff, \"avoid overflow in resize\");\n+  }\n+\n+  bool maybe_grow(int load_factor = 8, bool use_large_table_sizes = false) {\n+    unsigned old_size = BASE::_table_size;\n+    if (old_size >= _max_size) {\n+      return false;\n+    }\n+    if (BASE::number_of_entries() \/ int(old_size) > load_factor) {\n+      unsigned new_size = MIN2<unsigned>(calculate_resize(use_large_table_sizes), _max_size);\n+      resize(new_size);\n+      return true;\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  void resize(unsigned new_size) {\n+    Node** old_table = BASE::_table;\n+    Node** new_table = BASE::alloc_table(new_size);\n+\n+    Node* const* bucket = old_table;\n+    while (bucket < &old_table[BASE::_table_size]) {\n+      Node* node = *bucket;\n+      while (node != nullptr) {\n+        Node* next = node->_next;\n+        unsigned hash = node->_hash;\n+        unsigned index = hash % new_size;\n+\n+        node->_next = new_table[index];\n+        new_table[index] = node;\n+\n+        node = next;\n+      }\n+      ++bucket;\n+    }\n+\n+    if (ALLOC_TYPE == AnyObj::C_HEAP) {\n+      FREE_C_HEAP_ARRAY(Node*, old_table);\n+    }\n+    BASE::_table = new_table;\n+    BASE::_table_size = new_size;\n+  }\n+\n+#ifdef ASSERT\n+  int verify() {\n+    Node** table = BASE::_table;\n+    \/\/ Return max bucket size.  If hashcode is broken, this will be\n+    \/\/ too high.\n+    int max_bucket_size = 0;\n+    int index = 0;\n+    Node* const* bucket = table;\n+    while (bucket < &table[BASE::_table_size]) {\n+      int count = 0;\n+      Node* node = *bucket;\n+      while (node != nullptr) {\n+        count++;\n+        node = node->_next;\n+      }\n+      max_bucket_size = MAX2(count, max_bucket_size);\n+      ++bucket;\n+    }\n+    return max_bucket_size;\n+  }\n+#endif \/\/ ASSERT\n+};\n+\n+#endif \/\/ SHARE_UTILITIES_RESIZABLEHASHTABLE_HPP\n","filename":"src\/hotspot\/share\/utilities\/resizableHashTable.hpp","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"},{"patch":"@@ -1,183 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_UTILITIES_RESIZEABLERESOURCEHASH_HPP\n-#define SHARE_UTILITIES_RESIZEABLERESOURCEHASH_HPP\n-\n-#include \"utilities\/resourceHash.hpp\"\n-\n-template<\n-    typename K, typename V,\n-    AnyObj::allocation_type ALLOC_TYPE,\n-    MemTag MEM_TAG>\n-class ResizeableResourceHashtableStorage : public AnyObj {\n-  using Node = ResourceHashtableNode<K, V>;\n-\n-protected:\n-  unsigned _table_size;\n-  Node** _table;\n-\n-  ResizeableResourceHashtableStorage(unsigned table_size) {\n-    _table_size = table_size;\n-    _table = alloc_table(table_size);\n-  }\n-\n-  ~ResizeableResourceHashtableStorage() {\n-    if (ALLOC_TYPE == C_HEAP) {\n-      FREE_C_HEAP_ARRAY(Node*, _table);\n-    }\n-  }\n-\n-  Node** alloc_table(unsigned table_size) {\n-    Node** table;\n-    if (ALLOC_TYPE == C_HEAP) {\n-      table = NEW_C_HEAP_ARRAY(Node*, table_size, MEM_TAG);\n-    } else {\n-      table = NEW_RESOURCE_ARRAY(Node*, table_size);\n-    }\n-    memset(table, 0, table_size * sizeof(Node*));\n-    return table;\n-  }\n-\n-  unsigned table_size() const {\n-    return _table_size;\n-  }\n-\n-  Node** table() const {\n-    return _table;\n-  }\n-};\n-\n-template<\n-    typename K, typename V,\n-    AnyObj::allocation_type ALLOC_TYPE = AnyObj::RESOURCE_AREA,\n-    MemTag MEM_TAG = mtInternal,\n-    unsigned (*HASH)  (K const&)           = primitive_hash<K>,\n-    bool     (*EQUALS)(K const&, K const&) = primitive_equals<K>\n-    >\n-class ResizeableResourceHashtable : public ResourceHashtableBase<\n-    ResizeableResourceHashtableStorage<K, V, ALLOC_TYPE, MEM_TAG>,\n-    K, V, ALLOC_TYPE, MEM_TAG, HASH, EQUALS> {\n-  unsigned _max_size;\n-\n-  using BASE = ResourceHashtableBase<ResizeableResourceHashtableStorage<K, V, ALLOC_TYPE, MEM_TAG>,\n-                                     K, V, ALLOC_TYPE, MEM_TAG, HASH, EQUALS>;\n-  using Node = ResourceHashtableNode<K, V>;\n-  NONCOPYABLE(ResizeableResourceHashtable);\n-\n-  \/\/ Calculate next \"good\" hashtable size based on requested count\n-  int calculate_resize(bool use_large_table_sizes) const {\n-    const int resize_factor = 2;     \/\/ by how much we will resize using current number of entries\n-\n-    \/\/ possible hashmap sizes - odd primes that roughly double in size.\n-    \/\/ To avoid excessive resizing the odd primes from 4801-76831 and\n-    \/\/ 76831-307261 have been removed.\n-    const int large_table_sizes[] =  { 107, 1009, 2017, 4049, 5051, 10103, 20201,\n-                                       40423, 76831, 307261, 614563, 1228891, 2457733,\n-                                       4915219, 9830479, 19660831, 39321619, 78643219 };\n-    const int large_array_size = sizeof(large_table_sizes)\/sizeof(int);\n-\n-    int requested = resize_factor * BASE::number_of_entries();\n-    int start_at = use_large_table_sizes ? 8 : 0;\n-    int newsize;\n-    for (int i = start_at; i < large_array_size; i++) {\n-      newsize = large_table_sizes[i];\n-      if (newsize >= requested) {\n-        return newsize;\n-      }\n-    }\n-    return requested; \/\/ greater than a size in the table\n-  }\n-\n-public:\n-  ResizeableResourceHashtable(unsigned size, unsigned max_size)\n-  : BASE(size), _max_size(max_size) {\n-    assert(size <= 0x3fffffff && max_size <= 0x3fffffff, \"avoid overflow in resize\");\n-  }\n-\n-  bool maybe_grow(int load_factor = 8, bool use_large_table_sizes = false) {\n-    unsigned old_size = BASE::_table_size;\n-    if (old_size >= _max_size) {\n-      return false;\n-    }\n-    if (BASE::number_of_entries() \/ int(old_size) > load_factor) {\n-      unsigned new_size = MIN2<unsigned>(calculate_resize(use_large_table_sizes), _max_size);\n-      resize(new_size);\n-      return true;\n-    } else {\n-      return false;\n-    }\n-  }\n-\n-  void resize(unsigned new_size) {\n-    Node** old_table = BASE::_table;\n-    Node** new_table = BASE::alloc_table(new_size);\n-\n-    Node* const* bucket = old_table;\n-    while (bucket < &old_table[BASE::_table_size]) {\n-      Node* node = *bucket;\n-      while (node != nullptr) {\n-        Node* next = node->_next;\n-        unsigned hash = node->_hash;\n-        unsigned index = hash % new_size;\n-\n-        node->_next = new_table[index];\n-        new_table[index] = node;\n-\n-        node = next;\n-      }\n-      ++bucket;\n-    }\n-\n-    if (ALLOC_TYPE == AnyObj::C_HEAP) {\n-      FREE_C_HEAP_ARRAY(Node*, old_table);\n-    }\n-    BASE::_table = new_table;\n-    BASE::_table_size = new_size;\n-  }\n-\n-#ifdef ASSERT\n-  int verify() {\n-    Node** table = BASE::_table;\n-    \/\/ Return max bucket size.  If hashcode is broken, this will be\n-    \/\/ too high.\n-    int max_bucket_size = 0;\n-    int index = 0;\n-    Node* const* bucket = table;\n-    while (bucket < &table[BASE::_table_size]) {\n-      int count = 0;\n-      Node* node = *bucket;\n-      while (node != nullptr) {\n-        count++;\n-        node = node->_next;\n-      }\n-      max_bucket_size = MAX2(count, max_bucket_size);\n-      ++bucket;\n-    }\n-    return max_bucket_size;\n-  }\n-#endif \/\/ ASSERT\n-};\n-\n-#endif \/\/ SHARE_UTILITIES_RESIZEABLERESOURCEHASH_HPP\n","filename":"src\/hotspot\/share\/utilities\/resizeableResourceHash.hpp","additions":0,"deletions":183,"binary":false,"changes":183,"status":"deleted"},{"patch":"@@ -1,380 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_UTILITIES_RESOURCEHASH_HPP\n-#define SHARE_UTILITIES_RESOURCEHASH_HPP\n-\n-#include \"memory\/allocation.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/numberSeq.hpp\"\n-#include \"utilities\/tableStatistics.hpp\"\n-\n-#include <type_traits>\n-\n-template<typename K, typename V>\n-class ResourceHashtableNode : public AnyObj {\n-public:\n-  unsigned _hash;\n-  K _key;\n-  V _value;\n-  ResourceHashtableNode* _next;\n-\n-  ResourceHashtableNode(unsigned hash, K const& key, V const& value,\n-                        ResourceHashtableNode* next = nullptr) :\n-    _hash(hash), _key(key), _value(value), _next(next) {}\n-\n-  \/\/ Create a node with a default-constructed value.\n-  ResourceHashtableNode(unsigned hash, K const& key,\n-                        ResourceHashtableNode* next = nullptr) :\n-    _hash(hash), _key(key), _value(), _next(next) {}\n-};\n-\n-template<\n-    class STORAGE,\n-    typename K, typename V,\n-    AnyObj::allocation_type ALLOC_TYPE,\n-    MemTag MEM_TAG,\n-    unsigned (*HASH)  (K const&),\n-    bool     (*EQUALS)(K const&, K const&)\n-    >\n-class ResourceHashtableBase : public STORAGE {\n-  static_assert(ALLOC_TYPE == AnyObj::C_HEAP || std::is_trivially_destructible<K>::value,\n-                \"Destructor for K is only called with C_HEAP\");\n-  static_assert(ALLOC_TYPE == AnyObj::C_HEAP || std::is_trivially_destructible<V>::value,\n-                \"Destructor for V is only called with C_HEAP\");\n-  using Node = ResourceHashtableNode<K, V>;\n- private:\n-  int _number_of_entries;\n-\n-  Node** bucket_at(unsigned index) {\n-    Node** t = table();\n-    return &t[index];\n-  }\n-\n-  const Node* const* bucket_at(unsigned index) const {\n-    Node** t = table();\n-    return &t[index];\n-  }\n-\n-  \/\/ Returns a pointer to where the node where the value would reside if\n-  \/\/ it's in the table.\n-  Node** lookup_node(unsigned hash, K const& key) {\n-    unsigned index = hash % table_size();\n-    Node** ptr = bucket_at(index);\n-    while (*ptr != nullptr) {\n-      Node* node = *ptr;\n-      if (node->_hash == hash && EQUALS(key, node->_key)) {\n-        break;\n-      }\n-      ptr = &(node->_next);\n-    }\n-    return ptr;\n-  }\n-\n-  Node const** lookup_node(unsigned hash, K const& key) const {\n-    return const_cast<Node const**>(\n-        const_cast<ResourceHashtableBase*>(this)->lookup_node(hash, key));\n-  }\n-\n- protected:\n-  Node** table() const { return STORAGE::table(); }\n-\n-  ResourceHashtableBase() : STORAGE(), _number_of_entries(0) {}\n-  ResourceHashtableBase(unsigned size) : STORAGE(size), _number_of_entries(0) {}\n-  NONCOPYABLE(ResourceHashtableBase);\n-\n-  ~ResourceHashtableBase() {\n-    if (ALLOC_TYPE == AnyObj::C_HEAP) {\n-      Node* const* bucket = table();\n-      const unsigned sz = table_size();\n-      while (bucket < bucket_at(sz)) {\n-        Node* node = *bucket;\n-        while (node != nullptr) {\n-          Node* cur = node;\n-          node = node->_next;\n-          delete cur;\n-        }\n-        ++bucket;\n-      }\n-    }\n-  }\n-\n- public:\n-  unsigned table_size() const { return STORAGE::table_size(); }\n-  int number_of_entries() const { return _number_of_entries; }\n-\n-  bool contains(K const& key) const {\n-    return get(key) != nullptr;\n-  }\n-\n-  V* get(K const& key) const {\n-    unsigned hv = HASH(key);\n-    Node const** ptr = lookup_node(hv, key);\n-    if (*ptr != nullptr) {\n-      return const_cast<V*>(&(*ptr)->_value);\n-    } else {\n-      return nullptr;\n-    }\n-  }\n-\n- \/**\n-  * Inserts a value in the front of the table, assuming that\n-  * the entry is absent.\n-  * The table must be locked for the get or test that the entry\n-  * is absent, and for this operation.\n-  * This is a faster variant of put_if_absent because it adds to the\n-  * head of the bucket, and doesn't search the bucket.\n-  * @return: true: a new item is always added\n-  *\/\n-  bool put_when_absent(K const& key, V const& value) {\n-    unsigned hv = HASH(key);\n-    unsigned index = hv % table_size();\n-    assert(*lookup_node(hv, key) == nullptr, \"use put_if_absent\");\n-    Node** ptr = bucket_at(index);\n-    if (ALLOC_TYPE == AnyObj::C_HEAP) {\n-      *ptr = new (MEM_TAG) Node(hv, key, value, *ptr);\n-    } else {\n-      *ptr = new Node(hv, key, value, *ptr);\n-    }\n-    _number_of_entries ++;\n-    return true;\n-  }\n-\n- \/**\n-  * Inserts or replaces a value in the table.\n-  * @return: true:  if a new item is added\n-  *          false: if the item already existed and the value is updated\n-  *\/\n-  bool put(K const& key, V const& value) {\n-    unsigned hv = HASH(key);\n-    Node** ptr = lookup_node(hv, key);\n-    if (*ptr != nullptr) {\n-      (*ptr)->_value = value;\n-      return false;\n-    } else {\n-      if (ALLOC_TYPE == AnyObj::C_HEAP) {\n-        *ptr = new (MEM_TAG) Node(hv, key, value);\n-      } else {\n-        *ptr = new Node(hv, key, value);\n-      }\n-      _number_of_entries ++;\n-      return true;\n-    }\n-  }\n-\n-  \/\/ Look up the key.\n-  \/\/ If an entry for the key exists, leave map unchanged and return a pointer to its value.\n-  \/\/ If no entry for the key exists, create a new entry from key and a default-created value\n-  \/\/  and return a pointer to the value.\n-  \/\/ *p_created is true if entry was created, false if entry pre-existed.\n-  V* put_if_absent(K const& key, bool* p_created) {\n-    unsigned hv = HASH(key);\n-    Node** ptr = lookup_node(hv, key);\n-    if (*ptr == nullptr) {\n-      if (ALLOC_TYPE == AnyObj::C_HEAP) {\n-        *ptr = new (MEM_TAG) Node(hv, key);\n-      } else {\n-        *ptr = new Node(hv, key);\n-      }\n-      *p_created = true;\n-      _number_of_entries ++;\n-    } else {\n-      *p_created = false;\n-    }\n-    return &(*ptr)->_value;\n-  }\n-\n-  \/\/ Look up the key.\n-  \/\/ If an entry for the key exists, leave map unchanged and return a pointer to its value.\n-  \/\/ If no entry for the key exists, create a new entry from key and value and return a\n-  \/\/  pointer to the value.\n-  \/\/ *p_created is true if entry was created, false if entry pre-existed.\n-  V* put_if_absent(K const& key, V const& value, bool* p_created) {\n-    unsigned hv = HASH(key);\n-    Node** ptr = lookup_node(hv, key);\n-    if (*ptr == nullptr) {\n-      if (ALLOC_TYPE == AnyObj::C_HEAP) {\n-        *ptr = new (MEM_TAG) Node(hv, key, value);\n-      } else {\n-        *ptr = new Node(hv, key, value);\n-      }\n-      *p_created = true;\n-      _number_of_entries ++;\n-    } else {\n-      *p_created = false;\n-    }\n-    return &(*ptr)->_value;\n-  }\n-\n-  template<typename Function>\n-  bool remove(K const& key, Function function) {\n-    unsigned hv = HASH(key);\n-    Node** ptr = lookup_node(hv, key);\n-\n-    Node* node = *ptr;\n-    if (node != nullptr) {\n-      *ptr = node->_next;\n-      function(node->_key, node->_value);\n-      if (ALLOC_TYPE == AnyObj::C_HEAP) {\n-        delete node;\n-      }\n-      _number_of_entries --;\n-      return true;\n-    }\n-    return false;\n-  }\n-\n-  bool remove(K const& key) {\n-    auto dummy = [&] (K& k, V& v) { };\n-    return remove(key, dummy);\n-  }\n-\n-  \/\/ ITER contains bool do_entry(K const&, V const&), which will be\n-  \/\/ called for each entry in the table.  If do_entry() returns false,\n-  \/\/ the iteration is cancelled.\n-  template<class ITER>\n-  void iterate(ITER* iter) const {\n-    auto function = [&] (K& k, V& v) {\n-      return iter->do_entry(k, v);\n-    };\n-    iterate(function);\n-  }\n-\n-  template<typename Function>\n-  void iterate(Function function) const { \/\/ lambda enabled API\n-    Node* const* bucket = table();\n-    const unsigned sz = table_size();\n-    int cnt = _number_of_entries;\n-\n-    while (cnt > 0 && bucket < bucket_at(sz)) {\n-      Node* node = *bucket;\n-      while (node != nullptr) {\n-        bool cont = function(node->_key, node->_value);\n-        if (!cont) { return; }\n-        node = node->_next;\n-        --cnt;\n-      }\n-      ++bucket;\n-    }\n-  }\n-\n-  \/\/ same as above, but unconditionally iterate all entries\n-  template<typename Function>\n-  void iterate_all(Function function) const { \/\/ lambda enabled API\n-    auto wrapper = [&] (K& k, V& v) {\n-      function(k, v);\n-      return true;\n-    };\n-    iterate(wrapper);\n-  }\n-\n-  \/\/ ITER contains bool do_entry(K const&, V const&), which will be\n-  \/\/ called for each entry in the table.  If do_entry() returns true,\n-  \/\/ the entry is deleted.\n-  template<class ITER>\n-  void unlink(ITER* iter) {\n-    const unsigned sz = table_size();\n-    for (unsigned index = 0; index < sz; index++) {\n-      Node** ptr = bucket_at(index);\n-      while (*ptr != nullptr) {\n-        Node* node = *ptr;\n-        \/\/ do_entry must clean up the key and value in Node.\n-        bool clean = iter->do_entry(node->_key, node->_value);\n-        if (clean) {\n-          *ptr = node->_next;\n-          if (ALLOC_TYPE == AnyObj::C_HEAP) {\n-            delete node;\n-          }\n-          _number_of_entries --;\n-        } else {\n-          ptr = &(node->_next);\n-        }\n-      }\n-    }\n-  }\n-\n-  template<typename Function>\n-  TableStatistics statistics_calculate(Function size_function) const {\n-    NumberSeq summary;\n-    size_t literal_bytes = 0;\n-    Node* const* bucket = table();\n-    const unsigned sz = table_size();\n-    while (bucket < bucket_at(sz)) {\n-      Node* node = *bucket;\n-      int count = 0;\n-      while (node != nullptr) {\n-        literal_bytes += size_function(node->_key, node->_value);\n-        count++;\n-        node = node->_next;\n-      }\n-      summary.add((double)count);\n-      ++bucket;\n-    }\n-    return TableStatistics(summary, literal_bytes, sizeof(Node*), sizeof(Node));\n-  }\n-\n-  \/\/ This method calculates the \"shallow\" size. If you want the recursive size, use statistics_calculate.\n-  size_t mem_size() const {\n-    return sizeof(*this) +\n-      table_size() * sizeof(Node*) +\n-      number_of_entries() * sizeof(Node);\n-  }\n-};\n-\n-template<unsigned TABLE_SIZE, typename K, typename V>\n-class FixedResourceHashtableStorage : public AnyObj {\n-  using Node = ResourceHashtableNode<K, V>;\n-\n-  Node* _table[TABLE_SIZE];\n-protected:\n-  FixedResourceHashtableStorage() { memset(_table, 0, sizeof(_table)); }\n-  ~FixedResourceHashtableStorage() = default;\n-\n-  constexpr unsigned table_size() const {\n-    return TABLE_SIZE;\n-  }\n-\n-  Node** table() const {\n-    return const_cast<Node**>(_table);\n-  }\n-};\n-\n-template<\n-    typename K, typename V,\n-    unsigned SIZE = 256,\n-    AnyObj::allocation_type ALLOC_TYPE = AnyObj::RESOURCE_AREA,\n-    MemTag MEM_TAG = mtInternal,\n-    unsigned (*HASH)  (K const&)           = primitive_hash<K>,\n-    bool     (*EQUALS)(K const&, K const&) = primitive_equals<K>\n-    >\n-class ResourceHashtable : public ResourceHashtableBase<\n-  FixedResourceHashtableStorage<SIZE, K, V>,\n-    K, V, ALLOC_TYPE, MEM_TAG, HASH, EQUALS> {\n-  NONCOPYABLE(ResourceHashtable);\n-public:\n-  ResourceHashtable() : ResourceHashtableBase<FixedResourceHashtableStorage<SIZE, K, V>,\n-                                              K, V, ALLOC_TYPE, MEM_TAG, HASH, EQUALS>() {}\n-};\n-\n-#endif \/\/ SHARE_UTILITIES_RESOURCEHASH_HPP\n","filename":"src\/hotspot\/share\/utilities\/resourceHash.hpp","additions":0,"deletions":380,"binary":false,"changes":380,"status":"deleted"},{"patch":"@@ -479,0 +479,3 @@\n+                \/\/ Add to the cache, to enable the fast path, next time.\n+                checkCacheLoad();\n+                addToCache(classValue, updated);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassValue.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.vm.annotation.Stable;\n+\n@@ -454,2 +456,4 @@\n-            pio4lo=  0x1.1a62633145c07p-55, \/\/ 3.06161699786838301793e-17\n-            T[] = {\n+            pio4lo=  0x1.1a62633145c07p-55; \/\/ 3.06161699786838301793e-17\n+        @Stable\n+        private static final double[]\n+            T = {\n@@ -549,0 +553,1 @@\n+        @Stable\n@@ -563,0 +568,1 @@\n+        @Stable\n@@ -810,0 +816,1 @@\n+        @Stable\n@@ -812,0 +819,1 @@\n+        @Stable\n@@ -1235,0 +1243,1 @@\n+        @Stable\n@@ -1242,0 +1251,1 @@\n+        @Stable\n@@ -1249,0 +1259,1 @@\n+        @Stable\n@@ -2248,6 +2259,2 @@\n-                final double BP[]    = {1.0,\n-                                       1.5};\n-                final double DP_H[]  = {0.0,\n-                                        0x1.2b80_34p-1};        \/\/ 5.84962487220764160156e-01\n-                final double DP_L[]  = {0.0,\n-                                        0x1.cfde_b43c_fd006p-27};\/\/ 1.35003920212974897128e-08\n+                final double DP_H    = 0x1.2b80_34p-1;           \/\/ 5.84962487220764160156e-01\n+                final double DP_L    = 0x1.cfde_b43c_fd006p-27;  \/\/ 1.35003920212974897128e-08\n@@ -2262,2 +2269,4 @@\n-                u = x_abs - BP[k];               \/\/ BP[0]=1.0, BP[1]=1.5\n-                v = 1.0 \/ (x_abs + BP[k]);\n+\n+                double BP_k = 1.0 + 0.5*k; \/\/ BP[0]=1.0, BP[1]=1.5\n+                u = x_abs - BP_k;\n+                v = 1.0 \/ (x_abs + BP_k);\n@@ -2270,1 +2279,1 @@\n-                t_l = x_abs - (t_h - BP[k]);\n+                t_l = x_abs - (t_h - BP_k);\n@@ -2288,1 +2297,1 @@\n-                z_l = CP_L * p_h + p_l * CP + DP_L[k];\n+                z_l = CP_L * p_h + p_l * CP + DP_L*k;\n@@ -2291,1 +2300,1 @@\n-                t1 = (((z_h + z_l) + DP_H[k]) + t);\n+                t1 = (((z_h + z_l) + DP_H*k) + t);\n@@ -2293,1 +2302,1 @@\n-                t2 = z_l - (((t1 - t) - DP_H[k]) - z_h);\n+                t2 = z_l - (((t1 - t) - DP_H*k) - z_h);\n@@ -2433,1 +2442,0 @@\n-        private static final double[] half = {0.5, -0.5,};\n@@ -2438,2 +2446,3 @@\n-        private static final double[] ln2HI   ={  0x1.62e42feep-1,         \/\/  6.93147180369123816490e-01\n-                                                 -0x1.62e42feep-1};        \/\/ -6.93147180369123816490e-01\n+        private static final double ln2HI   =     0x1.62e42feep-1;         \/\/  6.93147180369123816490e-01\n+\n+        @Stable\n@@ -2481,1 +2490,1 @@\n-                    hi = x - ln2HI[xsb];\n+                    hi = x - ln2HI*(1 - 2*xsb); \/* +\/- ln2HI *\/\n@@ -2485,1 +2494,1 @@\n-                    k  = (int)(invln2 * x + half[xsb]);\n+                    k  = (int)(invln2 * x + 0.5 * (1 - 2*xsb) \/* +\/- 0.5 *\/  );\n@@ -2487,1 +2496,1 @@\n-                    hi = x - t*ln2HI[0];    \/* t*ln2HI is exact here *\/\n+                    hi = x - t*ln2HI;    \/* t*ln2HI is exact here *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/FdLibm.java","additions":30,"deletions":21,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -178,0 +178,5 @@\n+     * <p>\n+     * The location where a block of code merges back to its parent block, as\n+     * represented by the {@link #breakLabel()}, is expected to be reachable,\n+     * either from this block or the parent block.  The built code may be\n+     * malformed if there is no executable code at that location.\n@@ -328,0 +333,5 @@\n+     * <p>\n+     * The order of catch blocks is significant.  When an exception is thrown\n+     * by the try block, the first catch block whose exception type is {@linkplain\n+     * Class#isAssignableFrom(Class) the same class as or a superclass of} the\n+     * class of exception thrown is branched to (JVMS {@jvms 2.10}).\n@@ -346,0 +356,4 @@\n+         * @apiNote\n+         * If the type of exception to catch is already handled by previous\n+         * catch blocks, this block will never be executed.\n+         *\n@@ -350,3 +364,2 @@\n-         * @throws IllegalArgumentException if an existing catch block catches\n-         *         an exception of the given type or {@code exceptionType}\n-         *         represents a primitive type\n+         * @throws IllegalArgumentException if {@code exceptionType} represents\n+         *         a primitive type\n@@ -370,0 +383,4 @@\n+         * @apiNote\n+         * If every type of exception to catch is already handled by previous\n+         * catch blocks, this block will never be executed.\n+         *\n@@ -374,2 +391,2 @@\n-         * @throws IllegalArgumentException if an existing catch block catches\n-         *         one or more exceptions of the given types\n+         * @throws IllegalArgumentException if any exception type represents a\n+         *         primitive type\n@@ -390,0 +407,4 @@\n+         * @apiNote\n+         * Since this block intercepts all exceptions, all subsequent catch\n+         * blocks will never be executed.\n+         *\n@@ -392,2 +413,0 @@\n-         * @throws IllegalArgumentException if an existing catch block catches\n-         *         all exceptions\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeBuilder.java","additions":26,"deletions":7,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -42,2 +42,4 @@\n- * table entries.  Delivered as a {@link CodeElement} when traversing the\n- * contents of a {@link CodeModel}.\n+ * table entries.  The order of exception table entries is significant: when an\n+ * exception is thrown in a method, execution branches to the first matching\n+ * exception handler if such a handler exists (JVMS {@jvms 2.10}). Delivered as\n+ * a {@link CodeElement} when traversing the contents of a {@link CodeModel}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/ExceptionCatch.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,70 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.lang.constant;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-\n-import static java.lang.constant.ConstantDescs.BSM_INVOKE;\n-import static java.lang.constant.ConstantDescs.CD_MethodHandle;\n-import static java.util.Objects.requireNonNull;\n-\n-\/**\n- * A <a href=\"package-summary.html#nominal\">nominal descriptor<\/a> for a\n- * {@link MethodHandle} constant that performs a {@link MethodHandle#asType(MethodType)}\n- * adaptation on another {@link MethodHandle}.\n- *\/\n-final class AsTypeMethodHandleDesc extends DynamicConstantDesc<MethodHandle>\n-        implements MethodHandleDesc {\n-\n-    private final MethodHandleDesc underlying;\n-    private final MethodTypeDesc type;\n-\n-    AsTypeMethodHandleDesc(MethodHandleDesc underlying, MethodTypeDesc type) {\n-        super(BSM_INVOKE, ConstantDescs.DEFAULT_NAME, CD_MethodHandle,\n-              ConstantDescs.MHD_METHODHANDLE_ASTYPE, underlying, type);\n-        this.underlying = requireNonNull(underlying);\n-        this.type = requireNonNull(type);\n-    }\n-\n-    @Override\n-    public MethodTypeDesc invocationType() {\n-        return type;\n-    }\n-\n-    @Override\n-    public MethodHandle resolveConstantDesc(MethodHandles.Lookup lookup)\n-            throws ReflectiveOperationException {\n-        MethodHandle handle = underlying.resolveConstantDesc(lookup);\n-        MethodType methodType = type.resolveConstantDesc(lookup);\n-        return handle.asType(methodType);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return  String.format(\"%s.asType%s\", underlying.toString(), type.displayDescriptor());\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/AsTypeMethodHandleDesc.java","additions":0,"deletions":70,"binary":false,"changes":70,"status":"deleted"},{"patch":"@@ -47,1 +47,0 @@\n-import static java.lang.constant.DirectMethodHandleDesc.*;\n@@ -341,3 +340,0 @@\n-    static final DirectMethodHandleDesc MHD_METHODHANDLE_ASTYPE\n-            = MethodHandleDesc.ofMethod(Kind.VIRTUAL, CD_MethodHandle, \"asType\",\n-                                        MethodTypeDesc.of(CD_MethodHandle, CD_MethodType));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantDescs.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import jdk.internal.constant.AsTypeMethodHandleDesc;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/MethodHandleDesc.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -559,0 +559,4 @@\n+        \/\/ If the responseMessage is already set then return it\n+        if (responseMessage != null) {\n+            return responseMessage;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/net\/HttpURLConnection.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,0 @@\n-import java.net.URI;\n-import java.net.CookieStore;\n-import java.net.HttpCookie;\n-import java.net.URISyntaxException;\n@@ -75,0 +71,1 @@\n+    @Override\n@@ -112,0 +109,1 @@\n+    @Override\n@@ -130,1 +128,1 @@\n-        return cookies;\n+        return Collections.unmodifiableList(cookies);\n@@ -136,0 +134,1 @@\n+    @Override\n@@ -159,0 +158,1 @@\n+    @Override\n@@ -168,1 +168,1 @@\n-                if (cookies == null || cookies.size() == 0) {\n+                if (cookies == null || cookies.isEmpty()) {\n@@ -179,1 +179,1 @@\n-        return uris;\n+        return Collections.unmodifiableList(uris);\n@@ -186,0 +186,1 @@\n+    @Override\n@@ -207,0 +208,1 @@\n+    @Override\n","filename":"src\/java.base\/share\/classes\/java\/net\/InMemoryCookieStore.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.internal.misc.InnocuousThread;\n@@ -203,2 +204,3 @@\n-    private static final class CleaningThread extends Thread {\n-        public CleaningThread() {}\n+\n+    private static final class CleaningRunnable implements Runnable {\n+        public CleaningRunnable() {}\n@@ -237,1 +239,1 @@\n-    private static CleaningThread cleaningThread = null;\n+    private static Thread cleaningThread;\n@@ -244,1 +246,1 @@\n-            cleaningThread = new CleaningThread();\n+            cleaningThread = InnocuousThread.newThread(new CleaningRunnable());\n","filename":"src\/java.base\/share\/classes\/java\/nio\/BufferCleaner.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,1 +100,7 @@\n-    \/\/ ## Override bulk get methods for better performance\n+    @Override\n+    CharBuffer getArray(int index, char[] dst, int dstOffset, int length) {\n+        \/\/ Note: the variable \"offset\" is defined and set in the superclass\n+        int srcOffset = offset + index;\n+        str.getChars(srcOffset, srcOffset + length, dst, dstOffset);\n+        return this;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/nio\/StringCharBuffer.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -953,2 +953,5 @@\n-    private $Type$Buffer getArray(int index, $type$[] dst, int offset, int length) {\n-        if (\n+    \/\/\n+    \/\/ This method does not perform bounds checking which it expects\n+    \/\/ will have been done by the caller\n+    \/\/\n+    $Type$Buffer getArray(int index, $type$[] dst, int offset, int length) {\n@@ -956,1 +959,1 @@\n-            isAddressable() &&\n+        assert isAddressable();\n@@ -958,1 +961,1 @@\n-            ((long)length << $LG_BYTES_PER_VALUE$) > Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {\n+        if (((long)length << $LG_BYTES_PER_VALUE$) > Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {\n@@ -1119,0 +1122,4 @@\n+    \/\/\n+    \/\/ This method does not perform bounds checking which it expects\n+    \/\/ will have been done by the caller\n+    \/\/\n@@ -1153,3 +1160,7 @@\n-            int posMax = pos + n;\n-            for (int i = pos, j = srcPos; i < posMax; i++, j++)\n-                put(i, src.get(j));\n+            if (this.hb != null && src instanceof StringCharBuffer scb) {\n+                scb.getArray(srcPos, this.hb, pos, n);\n+            } else {\n+                int posMax = pos + n;\n+                for (int i = pos, j = srcPos; i < posMax; i++, j++)\n+                    put(i, src.get(j));\n+            }\n@@ -1345,0 +1356,4 @@\n+    \/\/\n+    \/\/ This method does not perform bounds checking which it expects\n+    \/\/ will have been done by the caller\n+    \/\/\n","filename":"src\/java.base\/share\/classes\/java\/nio\/X-Buffer.java.template","additions":22,"deletions":7,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import jdk.internal.util.ArraysSupport;\n@@ -156,1 +157,1 @@\n-            char[] data = new char[count + 100];\n+            char[] data = new char[ArraysSupport.newLength(count, 1, count)];\n","filename":"src\/java.base\/share\/classes\/java\/text\/DigitList.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -406,0 +406,3 @@\n+            if (Modifier.isStatic(modifiers))\n+                throw new IllegalArgumentException(\"Must not be a static field\");\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicIntegerFieldUpdater.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -401,0 +401,3 @@\n+            if (Modifier.isStatic(modifiers))\n+                throw new IllegalArgumentException(\"Must not be a static field\");\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicLongFieldUpdater.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -366,0 +366,3 @@\n+            if (Modifier.isStatic(modifiers))\n+                throw new IllegalArgumentException(\"Must not be a static field\");\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicReferenceFieldUpdater.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.lang.classfile.constantpool.ClassEntry;\n@@ -31,1 +32,1 @@\n-import java.lang.constant.ConstantDesc;\n+import java.util.ArrayList;\n@@ -42,1 +43,0 @@\n-    final Set<ConstantDesc> catchTypes;\n@@ -49,1 +49,0 @@\n-        this.catchTypes = new HashSet<>();\n@@ -62,3 +61,8 @@\n-        if (catchBlock == null) {\n-            if (tryBlock.reachable()) {\n-                b.branch(Opcode.GOTO, tryCatchEnd);\n+        \/\/ nullable list of CP entries - null means catching all (0)\n+        List<ClassEntry> entries = new ArrayList<>(Math.max(1, exceptionTypes.size()));\n+        if (exceptionTypes.isEmpty()) {\n+            entries.add(null);\n+        } else {\n+            for (var exceptionType : exceptionTypes) {\n+                var entry = b.constantPool().classEntry(exceptionType); \/\/ throws IAE\n+                entries.add(entry);\n@@ -67,0 +71,1 @@\n+        \/\/ End validation\n@@ -68,3 +73,3 @@\n-        for (var exceptionType : exceptionTypes) {\n-            if (!catchTypes.add(exceptionType)) {\n-                throw new IllegalArgumentException(\"Existing catch block catches exception of type: \" + exceptionType);\n+        if (catchBlock == null) {\n+            if (tryBlock.reachable()) {\n+                b.branch(Opcode.GOTO, tryCatchEnd);\n@@ -85,7 +90,3 @@\n-        if (exceptionTypes.isEmpty()) {\n-            catchBlock.exceptionCatchAll(tryStart, tryEnd, catchBlock.startLabel());\n-        }\n-        else {\n-            for (var exceptionType : exceptionTypes) {\n-                catchBlock.exceptionCatch(tryStart, tryEnd, catchBlock.startLabel(), exceptionType);\n-            }\n+        for (var entry : entries) {\n+            \/\/ This accepts null for catching all\n+            catchBlock.exceptionCatch(tryStart, tryEnd, catchBlock.startLabel(), entry);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CatchBuilderImpl.java","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.constant;\n+\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+\n+import static java.lang.constant.ConstantDescs.BSM_INVOKE;\n+import static java.lang.constant.ConstantDescs.CD_MethodHandle;\n+import static java.util.Objects.requireNonNull;\n+\n+\/**\n+ * A <a href=\"package-summary.html#nominal\">nominal descriptor<\/a> for a\n+ * {@link MethodHandle} constant that performs a {@link MethodHandle#asType(MethodType)}\n+ * adaptation on another {@link MethodHandle}.\n+ *\/\n+public final class AsTypeMethodHandleDesc extends DynamicConstantDesc<MethodHandle>\n+        implements MethodHandleDesc {\n+\n+    private static final DirectMethodHandleDesc MHD_METHODHANDLE_ASTYPE\n+            = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.VIRTUAL, CD_MethodHandle, \"asType\",\n+                                        MethodTypeDesc.of(CD_MethodHandle, ConstantDescs.CD_MethodType));\n+\n+    private final MethodHandleDesc underlying;\n+    private final MethodTypeDesc type;\n+\n+    public AsTypeMethodHandleDesc(MethodHandleDesc underlying, MethodTypeDesc type) {\n+        super(BSM_INVOKE, ConstantDescs.DEFAULT_NAME, CD_MethodHandle,\n+              MHD_METHODHANDLE_ASTYPE, underlying, type);\n+        this.underlying = requireNonNull(underlying);\n+        this.type = requireNonNull(type);\n+    }\n+\n+    @Override\n+    public MethodTypeDesc invocationType() {\n+        return type;\n+    }\n+\n+    @Override\n+    public MethodHandle resolveConstantDesc(MethodHandles.Lookup lookup)\n+            throws ReflectiveOperationException {\n+        MethodHandle handle = underlying.resolveConstantDesc(lookup);\n+        MethodType methodType = type.resolveConstantDesc(lookup);\n+        return handle.asType(methodType);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return  String.format(\"%s.asType%s\", underlying.toString(), type.displayDescriptor());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/AsTypeMethodHandleDesc.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import java.io.InputStream;\n-import java.io.UncheckedIOException;\n@@ -34,2 +32,0 @@\n-import java.nio.file.attribute.BasicFileAttributes;\n-import java.nio.file.attribute.FileTime;\n@@ -37,0 +33,1 @@\n+import java.nio.file.attribute.BasicFileAttributes;\n@@ -38,0 +35,1 @@\n+import java.util.Arrays;\n@@ -45,1 +43,3 @@\n-import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n@@ -48,0 +48,25 @@\n+ * A view over the entries of a jimage file with a unified namespace suitable\n+ * for file system use. The jimage entries (resources, module and package\n+ * information) are mapped into a unified hierarchy of named nodes, which serve\n+ * as the underlying structure for {@code JrtFileSystem} and other utilities.\n+ *\n+ * <p>Entries in jimage are expressed as one of three {@link Node} types;\n+ * resource nodes, directory nodes and link nodes.\n+ *\n+ * <p>When remapping jimage entries, jimage location names (e.g. {@code\n+ * \"\/java.base\/java\/lang\/Integer.class\"}) are prefixed with {@code \"\/modules\"}\n+ * to form the names of resource nodes. This aligns with the naming of module\n+ * entries in jimage (e.g. \"\/modules\/java.base\/java\/lang\"), which appear as\n+ * directory nodes in {@code ImageReader}.\n+ *\n+ * <p>Package entries (e.g. {@code \"\/packages\/java.lang\"} appear as directory\n+ * nodes containing link nodes, which resolve back to the root directory of the\n+ * module in which that package exists (e.g. {@code \"\/modules\/java.base\"}).\n+ * Unlike other nodes, the jimage file does not contain explicit entries for\n+ * link nodes, and their existence is derived only from the contents of the\n+ * parent directory.\n+ *\n+ * <p>While similar to {@code BasicImageReader}, this class is not a conceptual\n+ * subtype of it, and deliberately hides types such as {@code ImageLocation} to\n+ * give a focused API based only on nodes.\n+ *\n@@ -63,0 +88,4 @@\n+    \/**\n+     * Opens an image reader for a jimage file at the specified path, using the\n+     * given byte order.\n+     *\/\n@@ -70,0 +99,4 @@\n+    \/**\n+     * Opens an image reader for a jimage file at the specified path, using the\n+     * platform native byte order.\n+     *\/\n@@ -95,7 +128,7 @@\n-    \/\/ directory management interface\n-    public Directory getRootDirectory() throws IOException {\n-        ensureOpen();\n-        return reader.getRootDirectory();\n-    }\n-\n-\n+    \/**\n+     * Finds the node with the given name.\n+     *\n+     * @param name a node name of the form {@code \"\/modules\/<module>\/...} or\n+     *     {@code \"\/packages\/<package>\/...}.\n+     * @return a node representing a resource, directory or symbolic link.\n+     *\/\n@@ -107,0 +140,8 @@\n+    \/**\n+     * Returns a copy of the content of a resource node. The buffer returned by\n+     * this method is not cached by the node, and each call returns a new array\n+     * instance.\n+     *\n+     * @throws IOException if the content cannot be returned (including if the\n+     * given node is not a resource node).\n+     *\/\n@@ -112,10 +153,7 @@\n-    public byte[] getResource(Resource rs) throws IOException {\n-        ensureOpen();\n-        return reader.getResource(rs);\n-    }\n-\n-    public ImageHeader getHeader() {\n-        requireOpen();\n-        return reader.getHeader();\n-    }\n-\n+    \/**\n+     * Releases a (possibly cached) {@link ByteBuffer} obtained via\n+     * {@link #getResourceBuffer(Node)}.\n+     *\n+     * <p>Note that no testing is performed to check whether the buffer about\n+     * to be released actually came from a call to {@code getResourceBuffer()}.\n+     *\/\n@@ -126,57 +164,6 @@\n-    public String getName() {\n-        requireOpen();\n-        return reader.getName();\n-    }\n-\n-    public ByteOrder getByteOrder() {\n-        requireOpen();\n-        return reader.getByteOrder();\n-    }\n-\n-    public Path getImagePath() {\n-        requireOpen();\n-        return reader.getImagePath();\n-    }\n-\n-    public ImageStringsReader getStrings() {\n-        requireOpen();\n-        return reader.getStrings();\n-    }\n-\n-    public ImageLocation findLocation(String mn, String rn) {\n-        requireOpen();\n-        return reader.findLocation(mn, rn);\n-    }\n-\n-    public boolean verifyLocation(String mn, String rn) {\n-        requireOpen();\n-        return reader.verifyLocation(mn, rn);\n-    }\n-\n-    public ImageLocation findLocation(String name) {\n-        requireOpen();\n-        return reader.findLocation(name);\n-    }\n-\n-    public String[] getEntryNames() {\n-        requireOpen();\n-        return reader.getEntryNames();\n-    }\n-\n-    public String[] getModuleNames() {\n-        requireOpen();\n-        int off = \"\/modules\/\".length();\n-        return reader.findNode(\"\/modules\")\n-                     .getChildren()\n-                     .stream()\n-                     .map(Node::getNameString)\n-                     .map(s -> s.substring(off, s.length()))\n-                     .toArray(String[]::new);\n-    }\n-\n-    public long[] getAttributes(int offset) {\n-        requireOpen();\n-        return reader.getAttributes(offset);\n-    }\n-\n-    public String getString(int offset) {\n+    \/**\n+     * Returns the content of a resource node in a possibly cached byte buffer.\n+     * Callers of this method must call {@link #releaseByteBuffer(ByteBuffer)}\n+     * when they are finished with it.\n+     *\/\n+    public ByteBuffer getResourceBuffer(Node node) {\n@@ -184,21 +171,4 @@\n-        return reader.getString(offset);\n-    }\n-\n-    public byte[] getResource(String name) {\n-        requireOpen();\n-        return reader.getResource(name);\n-    }\n-\n-    public byte[] getResource(ImageLocation loc) {\n-        requireOpen();\n-        return reader.getResource(loc);\n-    }\n-\n-    public ByteBuffer getResourceBuffer(ImageLocation loc) {\n-        requireOpen();\n-        return reader.getResourceBuffer(loc);\n-    }\n-\n-    public InputStream getResourceStream(ImageLocation loc) {\n-        requireOpen();\n-        return reader.getResourceStream(loc);\n+        if (!node.isResource()) {\n+            throw new IllegalArgumentException(\"Not a resource node: \" + node);\n+        }\n+        return reader.getResourceBuffer(node.getLocation());\n@@ -208,3 +178,7 @@\n-        static final int SIZE_OF_OFFSET = Integer.BYTES;\n-\n-        static final Map<Path, SharedImageReader> OPEN_FILES = new HashMap<>();\n+        private static final Map<Path, SharedImageReader> OPEN_FILES = new HashMap<>();\n+        private static final String MODULES_ROOT = \"\/modules\";\n+        private static final String PACKAGES_ROOT = \"\/packages\";\n+        \/\/ There are >30,000 nodes in a complete jimage tree, and even relatively\n+        \/\/ common tasks (e.g. starting up javac) load somewhere in the region of\n+        \/\/ 1000 classes. Thus, an initial capacity of 2000 is a reasonable guess.\n+        private static final int INITIAL_NODE_CACHE_CAPACITY = 2000;\n@@ -213,1 +187,1 @@\n-        final Set<ImageReader> openers;\n+        private final Set<ImageReader> openers = new HashSet<>();\n@@ -215,1 +189,1 @@\n-        \/\/ attributes of the .jimage file. jimage file does not contain\n+        \/\/ Attributes of the jimage file. The jimage file does not contain\n@@ -218,6 +192,1 @@\n-        \/\/ Iniitalized lazily, see {@link #imageFileAttributes()}.\n-        BasicFileAttributes imageFileAttributes;\n-\n-        \/\/ directory management implementation\n-        final HashMap<String, Node> nodes;\n-        volatile Directory rootDir;\n+        private final BasicFileAttributes imageFileAttributes;\n@@ -225,2 +194,5 @@\n-        Directory packagesDir;\n-        Directory modulesDir;\n+        \/\/ Cache of all user visible nodes, guarded by synchronizing 'this' instance.\n+        private final Map<String, Node> nodes;\n+        \/\/ Used to classify ImageLocation instances without string comparison.\n+        private final int modulesStringOffset;\n+        private final int packagesStringOffset;\n@@ -230,2 +202,30 @@\n-            this.openers = new HashSet<>();\n-            this.nodes = new HashMap<>();\n+            this.imageFileAttributes = Files.readAttributes(imagePath, BasicFileAttributes.class);\n+            this.nodes = new HashMap<>(INITIAL_NODE_CACHE_CAPACITY);\n+            \/\/ Pick stable jimage names from which to extract string offsets (we cannot\n+            \/\/ use \"\/modules\" or \"\/packages\", since those have a module offset of zero).\n+            this.modulesStringOffset = getModuleOffset(\"\/modules\/java.base\");\n+            this.packagesStringOffset = getModuleOffset(\"\/packages\/java.lang\");\n+\n+            \/\/ Node creation is very lazy, so we can just make the top-level directories\n+            \/\/ now without the risk of triggering the building of lots of other nodes.\n+            Directory packages = newDirectory(PACKAGES_ROOT);\n+            nodes.put(packages.getName(), packages);\n+            Directory modules = newDirectory(MODULES_ROOT);\n+            nodes.put(modules.getName(), modules);\n+\n+            Directory root = newDirectory(\"\/\");\n+            root.setChildren(Arrays.asList(packages, modules));\n+            nodes.put(root.getName(), root);\n+        }\n+\n+        \/**\n+         * Returns the offset of the string denoting the leading \"module\" segment in\n+         * the given path (e.g. {@code <module>\/<path>}). We can't just pass in the\n+         * {@code \/<module>} string here because that has a module offset of zero.\n+         *\/\n+        private int getModuleOffset(String path) {\n+            ImageLocation location = findLocation(path);\n+            assert location != null : \"Cannot find expected jimage location: \" + path;\n+            int offset = location.getModuleOffset();\n+            assert offset != 0 : \"Invalid module offset for jimage location: \" + path;\n+            return offset;\n@@ -234,1 +234,1 @@\n-        public static ImageReader open(Path imagePath, ByteOrder byteOrder) throws IOException {\n+        private static ImageReader open(Path imagePath, ByteOrder byteOrder) throws IOException {\n@@ -267,1 +267,0 @@\n-                    rootDir = null;\n@@ -276,17 +275,0 @@\n-        void addOpener(ImageReader reader) {\n-            synchronized (OPEN_FILES) {\n-                openers.add(reader);\n-            }\n-        }\n-\n-        boolean removeOpener(ImageReader reader) {\n-            synchronized (OPEN_FILES) {\n-                return openers.remove(reader);\n-            }\n-        }\n-\n-        \/\/ directory management interface\n-        Directory getRootDirectory() {\n-            return buildRootDirectory();\n-        }\n-\n@@ -294,1 +276,11 @@\n-         * Lazily build a node from a name.\n+         * Returns a node with the given name, or null if no resource or directory of\n+         * that name exists.\n+         *\n+         * <p>This is the only public API by which anything outside this class can access\n+         * {@code Node} instances either directly, or by resolving symbolic links.\n+         *\n+         * <p>Note also that there is no reentrant calling back to this method from within\n+         * the node handling code.\n+         *\n+         * @param name an absolute, {@code \/}-separated path string, prefixed with either\n+         *     \"\/modules\" or \"\/packages\".\n@@ -296,16 +288,9 @@\n-        synchronized Node buildNode(String name) {\n-            Node n;\n-            boolean isPackages = name.startsWith(\"\/packages\");\n-            boolean isModules = !isPackages && name.startsWith(\"\/modules\");\n-\n-            if (!(isModules || isPackages)) {\n-                return null;\n-            }\n-\n-            ImageLocation loc = findLocation(name);\n-\n-            if (loc != null) { \/\/ A sub tree node\n-                if (isPackages) {\n-                    n = handlePackages(name, loc);\n-                } else { \/\/ modules sub tree\n-                    n = handleModulesSubTree(name, loc);\n+        synchronized Node findNode(String name) {\n+            Node node = nodes.get(name);\n+            if (node == null) {\n+                \/\/ We cannot get the root paths (\"\/modules\" or \"\/packages\") here\n+                \/\/ because those nodes are already in the nodes cache.\n+                if (name.startsWith(MODULES_ROOT + \"\/\")) {\n+                    node = buildModulesNode(name);\n+                } else if (name.startsWith(PACKAGES_ROOT + \"\/\")) {\n+                    node = buildPackagesNode(name);\n@@ -313,7 +298,2 @@\n-            } else { \/\/ Asking for a resource? \/modules\/java.base\/java\/lang\/Object.class\n-                if (isModules) {\n-                    n = handleResource(name);\n-                } else {\n-                    \/\/ Possibly ask for \/packages\/java.lang\/java.base\n-                    \/\/ although \/packages\/java.base not created\n-                    n = handleModuleLink(name);\n+                if (node != null) {\n+                    nodes.put(node.getName(), node);\n@@ -321,0 +301,4 @@\n+            } else if (!node.isCompleted()) {\n+                \/\/ Only directories can be incomplete.\n+                assert node instanceof Directory : \"Invalid incomplete node: \" + node;\n+                completeDirectory((Directory) node);\n@@ -322,22 +306,2 @@\n-            return n;\n-        }\n-\n-        synchronized Directory buildRootDirectory() {\n-            Directory root = rootDir; \/\/ volatile read\n-            if (root != null) {\n-                return root;\n-            }\n-\n-            root = newDirectory(null, \"\/\");\n-            root.setIsRootDir();\n-\n-            \/\/ \/packages dir\n-            packagesDir = newDirectory(root, \"\/packages\");\n-            packagesDir.setIsPackagesDir();\n-\n-            \/\/ \/modules dir\n-            modulesDir = newDirectory(root, \"\/modules\");\n-            modulesDir.setIsModulesDir();\n-\n-            root.setCompleted(true);\n-            return rootDir = root;\n+            assert node == null || node.isCompleted() : \"Incomplete node: \" + node;\n+            return node;\n@@ -347,1 +311,4 @@\n-         * To visit sub tree resources.\n+         * Builds a node in the \"\/modules\/...\" namespace.\n+         *\n+         * <p>Called by {@link #findNode(String)} if a {@code \/modules\/...} node\n+         * is not present in the cache.\n@@ -349,37 +316,9 @@\n-        interface LocationVisitor {\n-            void visit(ImageLocation loc);\n-        }\n-\n-        void visitLocation(ImageLocation loc, LocationVisitor visitor) {\n-            byte[] offsets = getResource(loc);\n-            ByteBuffer buffer = ByteBuffer.wrap(offsets);\n-            buffer.order(getByteOrder());\n-            IntBuffer intBuffer = buffer.asIntBuffer();\n-            for (int i = 0; i < offsets.length \/ SIZE_OF_OFFSET; i++) {\n-                int offset = intBuffer.get(i);\n-                ImageLocation pkgLoc = getLocation(offset);\n-                visitor.visit(pkgLoc);\n-            }\n-        }\n-\n-        void visitPackageLocation(ImageLocation loc) {\n-            \/\/ Retrieve package name\n-            String pkgName = getBaseExt(loc);\n-            \/\/ Content is array of offsets in Strings table\n-            byte[] stringsOffsets = getResource(loc);\n-            ByteBuffer buffer = ByteBuffer.wrap(stringsOffsets);\n-            buffer.order(getByteOrder());\n-            IntBuffer intBuffer = buffer.asIntBuffer();\n-            \/\/ For each module, create a link node.\n-            for (int i = 0; i < stringsOffsets.length \/ SIZE_OF_OFFSET; i++) {\n-                \/\/ skip empty state, useless.\n-                intBuffer.get(i);\n-                i++;\n-                int offset = intBuffer.get(i);\n-                String moduleName = getString(offset);\n-                Node targetNode = findNode(\"\/modules\/\" + moduleName);\n-                if (targetNode != null) {\n-                    String pkgDirName = packagesDir.getName() + \"\/\" + pkgName;\n-                    Directory pkgDir = (Directory) nodes.get(pkgDirName);\n-                    newLinkNode(pkgDir, pkgDir.getName() + \"\/\" + moduleName, targetNode);\n-                }\n+        private Node buildModulesNode(String name) {\n+            assert name.startsWith(MODULES_ROOT + \"\/\") : \"Invalid module node name: \" + name;\n+            \/\/ Returns null for non-directory resources, since the jimage name does not\n+            \/\/ start with \"\/modules\" (e.g. \"\/java.base\/java\/lang\/Object.class\").\n+            ImageLocation loc = findLocation(name);\n+            if (loc != null) {\n+                assert name.equals(loc.getFullName()) : \"Mismatched location for directory: \" + name;\n+                assert isModulesSubdirectory(loc) : \"Invalid modules directory: \" + name;\n+                return completeModuleDirectory(newDirectory(name), loc);\n@@ -387,0 +326,5 @@\n+            \/\/ Now try the non-prefixed resource name, but be careful to avoid false\n+            \/\/ positives for names like \"\/modules\/modules\/xxx\" which could return a\n+            \/\/ location of a directory entry.\n+            loc = findLocation(name.substring(MODULES_ROOT.length()));\n+            return loc != null && isResource(loc) ? newResource(name, loc) : null;\n@@ -389,10 +333,17 @@\n-        Node handlePackages(String name, ImageLocation loc) {\n-            long size = loc.getUncompressedSize();\n-            Node n = null;\n-            \/\/ Only possibilities are \/packages, \/packages\/package\/module\n-            if (name.equals(\"\/packages\")) {\n-                visitLocation(loc, (childloc) -> {\n-                    findNode(childloc.getFullName());\n-                });\n-                packagesDir.setCompleted(true);\n-                n = packagesDir;\n+        \/**\n+         * Builds a node in the \"\/packages\/...\" namespace.\n+         *\n+         * <p>Called by {@link #findNode(String)} if a {@code \/packages\/...} node\n+         * is not present in the cache.\n+         *\/\n+        private Node buildPackagesNode(String name) {\n+            \/\/ There are only locations for the root \"\/packages\" or \"\/packages\/xxx\"\n+            \/\/ directories, but not the symbolic links below them (the links can be\n+            \/\/ entirely derived from the name information in the parent directory).\n+            \/\/ However, unlike resources this means that we do not have a constant\n+            \/\/ time lookup for link nodes when creating them.\n+            int packageStart = PACKAGES_ROOT.length() + 1;\n+            int packageEnd = name.indexOf('\/', packageStart);\n+            if (packageEnd == -1) {\n+                ImageLocation loc = findLocation(name);\n+                return loc != null ? completePackageDirectory(newDirectory(name), loc) : null;\n@@ -400,45 +351,13 @@\n-                if (size != 0) { \/\/ children are offsets to module in StringsTable\n-                    String pkgName = getBaseExt(loc);\n-                    Directory pkgDir = newDirectory(packagesDir, packagesDir.getName() + \"\/\" + pkgName);\n-                    visitPackageLocation(loc);\n-                    pkgDir.setCompleted(true);\n-                    n = pkgDir;\n-                } else { \/\/ Link to module\n-                    String pkgName = loc.getParent();\n-                    String modName = getBaseExt(loc);\n-                    Node targetNode = findNode(\"\/modules\/\" + modName);\n-                    if (targetNode != null) {\n-                        String pkgDirName = packagesDir.getName() + \"\/\" + pkgName;\n-                        Directory pkgDir = (Directory) nodes.get(pkgDirName);\n-                        Node linkNode = newLinkNode(pkgDir, pkgDir.getName() + \"\/\" + modName, targetNode);\n-                        n = linkNode;\n-                    }\n-                }\n-            }\n-            return n;\n-        }\n-\n-        \/\/ Asking for \/packages\/package\/module although\n-        \/\/ \/packages\/<pkg>\/ not yet created, need to create it\n-        \/\/ prior to return the link to module node.\n-        Node handleModuleLink(String name) {\n-            \/\/ eg: unresolved \/packages\/package\/module\n-            \/\/ Build \/packages\/package node\n-            Node ret = null;\n-            String radical = \"\/packages\/\";\n-            String path = name;\n-            if (path.startsWith(radical)) {\n-                int start = radical.length();\n-                int pkgEnd = path.indexOf('\/', start);\n-                if (pkgEnd != -1) {\n-                    String pkg = path.substring(start, pkgEnd);\n-                    String pkgPath = radical + pkg;\n-                    Node n = findNode(pkgPath);\n-                    \/\/ If not found means that this is a symbolic link such as:\n-                    \/\/ \/packages\/java.util\/java.base\/java\/util\/Vector.class\n-                    \/\/ and will be done by a retry of the filesystem\n-                    for (Node child : n.getChildren()) {\n-                        if (child.name.equals(name)) {\n-                            ret = child;\n-                            break;\n-                        }\n+                \/\/ We cannot assume that the parent directory exists for a link node, since\n+                \/\/ the given name is untrusted and could reference a non-existent link.\n+                \/\/ However, if the parent directory is present, we can conclude that the\n+                \/\/ given name was not a valid link (or else it would already be cached).\n+                String dirName = name.substring(0, packageEnd);\n+                if (!nodes.containsKey(dirName)) {\n+                    ImageLocation loc = findLocation(dirName);\n+                    \/\/ If the parent location doesn't exist, the link node cannot exist.\n+                    if (loc != null) {\n+                        nodes.put(dirName, completePackageDirectory(newDirectory(dirName), loc));\n+                        \/\/ When the parent is created its child nodes are created and cached,\n+                        \/\/ but this can still return null if given name wasn't a valid link.\n+                        return nodes.get(name);\n@@ -448,23 +367,1 @@\n-            return ret;\n-        }\n-\n-        Node handleModulesSubTree(String name, ImageLocation loc) {\n-            Node n;\n-            assert (name.equals(loc.getFullName()));\n-            Directory dir = makeDirectories(name);\n-            visitLocation(loc, (childloc) -> {\n-                String path = childloc.getFullName();\n-                if (path.startsWith(\"\/modules\")) { \/\/ a package\n-                    makeDirectories(path);\n-                } else { \/\/ a resource\n-                    makeDirectories(childloc.buildName(true, true, false));\n-                    \/\/ if we have already created a resource for this name previously, then don't\n-                    \/\/ recreate it\n-                    if (!nodes.containsKey(childloc.getFullName(true))) {\n-                        newResource(dir, childloc);\n-                    }\n-                }\n-            });\n-            dir.setCompleted(true);\n-            n = dir;\n-            return n;\n+            return null;\n@@ -473,21 +370,16 @@\n-        Node handleResource(String name) {\n-            Node n = null;\n-            if (!name.startsWith(\"\/modules\/\")) {\n-                return null;\n-            }\n-            \/\/ Make sure that the thing that follows \"\/modules\/\" is a module name.\n-            int moduleEndIndex = name.indexOf('\/', \"\/modules\/\".length());\n-            if (moduleEndIndex == -1) {\n-                return null;\n-            }\n-            ImageLocation moduleLoc = findLocation(name.substring(0, moduleEndIndex));\n-            if (moduleLoc == null || moduleLoc.getModuleOffset() == 0) {\n-                return null;\n-            }\n-\n-            String locationPath = name.substring(\"\/modules\".length());\n-            ImageLocation resourceLoc = findLocation(locationPath);\n-            if (resourceLoc != null) {\n-                Directory dir = makeDirectories(resourceLoc.buildName(true, true, false));\n-                Resource res = newResource(dir, resourceLoc);\n-                n = res;\n+        \/** Completes a directory by ensuring its child list is populated correctly. *\/\n+        private void completeDirectory(Directory dir) {\n+            String name = dir.getName();\n+            \/\/ Since the node exists, we can assert that its name starts with\n+            \/\/ either \"\/modules\" or \"\/packages\", making differentiation easy.\n+            \/\/ It also means that the name is valid, so it must yield a location.\n+            assert name.startsWith(MODULES_ROOT) || name.startsWith(PACKAGES_ROOT);\n+            ImageLocation loc = findLocation(name);\n+            assert loc != null && name.equals(loc.getFullName()) : \"Invalid location for name: \" + name;\n+            \/\/ We cannot use 'isXxxSubdirectory()' methods here since we could\n+            \/\/ be given a top-level directory (for which that test doesn't work).\n+            \/\/ The string MUST start \"\/modules\" or \"\/packages\" here.\n+            if (name.charAt(1) == 'm') {\n+                completeModuleDirectory(dir, loc);\n+            } else {\n+                completePackageDirectory(dir, loc);\n@@ -495,1 +387,1 @@\n-            return n;\n+            assert dir.isCompleted() : \"Directory must be complete by now: \" + dir;\n@@ -498,7 +390,19 @@\n-        String getBaseExt(ImageLocation loc) {\n-            String base = loc.getBase();\n-            String ext = loc.getExtension();\n-            if (ext != null && !ext.isEmpty()) {\n-                base = base + \".\" + ext;\n-            }\n-            return base;\n+        \/**\n+         * Completes a modules directory by setting the list of child nodes.\n+         *\n+         * <p>The given directory can be the top level {@code \/modules} directory,\n+         * so it is NOT safe to use {@code isModulesSubdirectory(loc)} here.\n+         *\/\n+        private Directory completeModuleDirectory(Directory dir, ImageLocation loc) {\n+            assert dir.getName().equals(loc.getFullName()) : \"Mismatched location for directory: \" + dir;\n+            List<Node> children = createChildNodes(loc, childLoc -> {\n+                if (isModulesSubdirectory(childLoc)) {\n+                    return nodes.computeIfAbsent(childLoc.getFullName(), this::newDirectory);\n+                } else {\n+                    \/\/ Add \"\/modules\" prefix to image location paths to get node names.\n+                    String resourceName = childLoc.getFullName(true);\n+                    return nodes.computeIfAbsent(resourceName, n -> newResource(n, childLoc));\n+                }\n+            });\n+            dir.setChildren(children);\n+            return dir;\n@@ -507,5 +411,29 @@\n-        synchronized Node findNode(String name) {\n-            buildRootDirectory();\n-            Node n = nodes.get(name);\n-            if (n == null || !n.isCompleted()) {\n-                n = buildNode(name);\n+        \/**\n+         * Completes a package directory by setting the list of child nodes.\n+         *\n+         * <p>The given directory can be the top level {@code \/packages} directory,\n+         * so it is NOT safe to use {@code isPackagesSubdirectory(loc)} here.\n+         *\/\n+        private Directory completePackageDirectory(Directory dir, ImageLocation loc) {\n+            assert dir.getName().equals(loc.getFullName()) : \"Mismatched location for directory: \" + dir;\n+            \/\/ The only directories in the \"\/packages\" namespace are \"\/packages\" or\n+            \/\/ \"\/packages\/<package>\". However, unlike \"\/modules\" directories, the\n+            \/\/ location offsets mean different things.\n+            List<Node> children;\n+            if (dir.getName().equals(PACKAGES_ROOT)) {\n+                \/\/ Top-level directory just contains a list of subdirectories.\n+                children = createChildNodes(loc, c -> nodes.computeIfAbsent(c.getFullName(), this::newDirectory));\n+            } else {\n+                \/\/ A package directory's content is array of offset PAIRS in the\n+                \/\/ Strings table, but we only need the 2nd value of each pair.\n+                IntBuffer intBuffer = getOffsetBuffer(loc);\n+                int offsetCount = intBuffer.capacity();\n+                assert (offsetCount & 0x1) == 0 : \"Offset count must be even: \" + offsetCount;\n+                children = new ArrayList<>(offsetCount \/ 2);\n+                \/\/ Iterate the 2nd offset in each pair (odd indices).\n+                for (int i = 1; i < offsetCount; i += 2) {\n+                    String moduleName = getString(intBuffer.get(i));\n+                    children.add(nodes.computeIfAbsent(\n+                            dir.getName() + \"\/\" + moduleName,\n+                            n -> newLinkNode(n, MODULES_ROOT + \"\/\" + moduleName)));\n+                }\n@@ -513,1 +441,3 @@\n-            return n;\n+            \/\/ This only happens once and \"completes\" the directory.\n+            dir.setChildren(children);\n+            return dir;\n@@ -517,1 +447,4 @@\n-         * Returns the file attributes of the image file.\n+         * Creates the list of child nodes for a {@code Directory} based on a given\n+         *\n+         * <p>Note: This cannot be used for package subdirectories as they have\n+         * child offsets stored differently to other directories.\n@@ -519,10 +452,6 @@\n-        BasicFileAttributes imageFileAttributes() {\n-            BasicFileAttributes attrs = imageFileAttributes;\n-            if (attrs == null) {\n-                try {\n-                    Path file = getImagePath();\n-                    attrs = Files.readAttributes(file, BasicFileAttributes.class);\n-                } catch (IOException ioe) {\n-                    throw new UncheckedIOException(ioe);\n-                }\n-                imageFileAttributes = attrs;\n+        private List<Node> createChildNodes(ImageLocation loc, Function<ImageLocation, Node> newChildFn) {\n+            IntBuffer offsets = getOffsetBuffer(loc);\n+            int childCount = offsets.capacity();\n+            List<Node> children = new ArrayList<>(childCount);\n+            for (int i = 0; i < childCount; i++) {\n+                children.add(newChildFn.apply(getLocation(offsets.get(i))));\n@@ -530,1 +459,1 @@\n-            return attrs;\n+            return children;\n@@ -533,4 +462,7 @@\n-        Directory newDirectory(Directory parent, String name) {\n-            Directory dir = Directory.create(parent, name, imageFileAttributes());\n-            nodes.put(dir.getName(), dir);\n-            return dir;\n+        \/** Helper to extract the integer offset buffer from a directory location. *\/\n+        private IntBuffer getOffsetBuffer(ImageLocation dir) {\n+            assert !isResource(dir) : \"Not a directory: \" + dir.getFullName();\n+            byte[] offsets = getResource(dir);\n+            ByteBuffer buffer = ByteBuffer.wrap(offsets);\n+            buffer.order(getByteOrder());\n+            return buffer.asIntBuffer();\n@@ -539,4 +471,12 @@\n-        Resource newResource(Directory parent, ImageLocation loc) {\n-            Resource res = Resource.create(parent, loc, imageFileAttributes());\n-            nodes.put(res.getName(), res);\n-            return res;\n+        \/**\n+         * Efficiently determines if an image location is a resource.\n+         *\n+         * <p>A resource must have a valid module associated with it, so its\n+         * module offset must be non-zero, and not equal to the offsets for\n+         * \"\/modules\/...\" or \"\/packages\/...\" entries.\n+         *\/\n+        private boolean isResource(ImageLocation loc) {\n+            int moduleOffset = loc.getModuleOffset();\n+            return moduleOffset != 0\n+                    && moduleOffset != modulesStringOffset\n+                    && moduleOffset != packagesStringOffset;\n@@ -545,4 +485,10 @@\n-        LinkNode newLinkNode(Directory dir, String name, Node link) {\n-            LinkNode linkNode = LinkNode.create(dir, name, link);\n-            nodes.put(linkNode.getName(), linkNode);\n-            return linkNode;\n+        \/**\n+         * Determines if an image location is a directory in the {@code \/modules}\n+         * namespace (if so, the location name is the node name).\n+         *\n+         * <p>In jimage, every {@code ImageLocation} under {@code \/modules\/} is a\n+         * directory and has the same value for {@code getModule()}, and {@code\n+         * getModuleOffset()}.\n+         *\/\n+        private boolean isModulesSubdirectory(ImageLocation loc) {\n+            return loc.getModuleOffset() == modulesStringOffset;\n@@ -551,9 +497,8 @@\n-        Directory makeDirectories(String parent) {\n-            Directory last = rootDir;\n-            for (int offset = parent.indexOf('\/', 1);\n-                    offset != -1;\n-                    offset = parent.indexOf('\/', offset + 1)) {\n-                String dir = parent.substring(0, offset);\n-                last = makeDirectory(dir, last);\n-            }\n-            return makeDirectory(parent, last);\n+        \/**\n+         * Creates an \"incomplete\" directory node with no child nodes set.\n+         * Directories need to be \"completed\" before they are returned by\n+         * {@link #findNode(String)}.\n+         *\/\n+        private Directory newDirectory(String name) {\n+            return new Directory(name, imageFileAttributes);\n+        }\n@@ -561,0 +506,8 @@\n+        \/**\n+         * Creates a new resource from an image location. This is the only case\n+         * where the image location name does not match the requested node name.\n+         * In image files, resource locations are NOT prefixed by {@code \/modules}.\n+         *\/\n+        private Resource newResource(String name, ImageLocation loc) {\n+            assert name.equals(loc.getFullName(true)) : \"Mismatched location for resource: \" + name;\n+            return new Resource(name, loc, imageFileAttributes);\n@@ -563,6 +516,8 @@\n-        Directory makeDirectory(String dir, Directory last) {\n-            Directory nextDir = (Directory) nodes.get(dir);\n-            if (nextDir == null) {\n-                nextDir = newDirectory(last, dir);\n-            }\n-            return nextDir;\n+        \/**\n+         * Creates a new link node pointing at the given target name.\n+         *\n+         * <p>Note that target node is resolved each time {@code resolve()} is called,\n+         * so if a link node is retained after its reader is closed, it will fail.\n+         *\/\n+        private LinkNode newLinkNode(String name, String targetName) {\n+            return new LinkNode(name, () -> findNode(targetName), imageFileAttributes);\n@@ -571,1 +526,3 @@\n-        byte[] getResource(Node node) throws IOException {\n+        \/** Returns the content of a resource node. *\/\n+        private byte[] getResource(Node node) throws IOException {\n+            \/\/ We could have been given a non-resource node here.\n@@ -577,4 +534,0 @@\n-\n-        byte[] getResource(Resource rs) throws IOException {\n-            return super.getResource(rs.getLocation());\n-        }\n@@ -583,3 +536,13 @@\n-    \/\/ jimage file does not store directory structure. We build nodes\n-    \/\/ using the \"path\" strings found in the jimage file.\n-    \/\/ Node can be a directory or a resource\n+    \/**\n+     * A directory, resource or symbolic link.\n+     *\n+     * <h3 id=\"node_equality\">Node Equality<\/h3>\n+     *\n+     * Nodes are identified solely by their name, and it is not valid to attempt\n+     * to compare nodes from different reader instances. Different readers may\n+     * produce nodes with the same names, but different contents.\n+     *\n+     * <p>Furthermore, since a {@link ImageReader} provides \"perfect\" caching of\n+     * nodes, equality of nodes from the same reader is equivalent to instance\n+     * identity.\n+     *\/\n@@ -587,5 +550,0 @@\n-        private static final int ROOT_DIR = 0b0000_0000_0000_0001;\n-        private static final int PACKAGES_DIR = 0b0000_0000_0000_0010;\n-        private static final int MODULES_DIR = 0b0000_0000_0000_0100;\n-\n-        private int flags;\n@@ -594,6 +552,0 @@\n-        private boolean completed;\n-\n-        protected Node(String name, BasicFileAttributes fileAttrs) {\n-            this.name = Objects.requireNonNull(name);\n-            this.fileAttrs = Objects.requireNonNull(fileAttrs);\n-        }\n@@ -602,1 +554,2 @@\n-         * A node is completed when all its direct children have been built.\n+         * Creates an abstract {@code Node}, which is either a resource, directory\n+         * or symbolic link.\n@@ -604,1 +557,2 @@\n-         * @return\n+         * <p>This constructor is only non-private so it can be used by the\n+         * {@code ExplodedImage} class, and must not be used otherwise.\n@@ -606,22 +560,3 @@\n-        public boolean isCompleted() {\n-            return completed;\n-        }\n-\n-        public void setCompleted(boolean completed) {\n-            this.completed = completed;\n-        }\n-\n-        public final void setIsRootDir() {\n-            flags |= ROOT_DIR;\n-        }\n-\n-        public final boolean isRootDir() {\n-            return (flags & ROOT_DIR) != 0;\n-        }\n-\n-        public final void setIsPackagesDir() {\n-            flags |= PACKAGES_DIR;\n-        }\n-\n-        public final boolean isPackagesDir() {\n-            return (flags & PACKAGES_DIR) != 0;\n+        protected Node(String name, BasicFileAttributes fileAttrs) {\n+            this.name = Objects.requireNonNull(name);\n+            this.fileAttrs = Objects.requireNonNull(fileAttrs);\n@@ -630,2 +565,4 @@\n-        public final void setIsModulesDir() {\n-            flags |= MODULES_DIR;\n+        \/\/ A node is completed when all its direct children have been built.\n+        \/\/ As such, non-directory nodes are always complete.\n+        boolean isCompleted() {\n+            return true;\n@@ -634,2 +571,3 @@\n-        public final boolean isModulesDir() {\n-            return (flags & MODULES_DIR) != 0;\n+        \/\/ Only resources can return a location.\n+        ImageLocation getLocation() {\n+            throw new IllegalStateException(\"not a resource: \" + getName());\n@@ -638,0 +576,8 @@\n+        \/**\n+         * Returns the name of this node (e.g. {@code\n+         * \"\/modules\/java.base\/java\/lang\/Object.class\"} or {@code\n+         * \"\/packages\/java.lang\"}).\n+         *\n+         * <p>Note that for resource nodes this is NOT the underlying jimage\n+         * resource name (it is prefixed with {@code \"\/modules\"}).\n+         *\/\n@@ -642,0 +588,4 @@\n+        \/**\n+         * Returns file attributes for this node. The value returned may be the\n+         * same for all nodes, and should not be relied upon for accuracy.\n+         *\/\n@@ -646,1 +596,4 @@\n-        \/\/ resolve this Node (if this is a soft link, get underlying Node)\n+        \/**\n+         * Resolves a symbolic link to its target node. If this code is not a\n+         * symbolic link, then it resolves to itself.\n+         *\/\n@@ -651,0 +604,4 @@\n+        \/**\n+         * Resolves a symbolic link to its target node. If this code is not a\n+         * symbolic link, then it resolves to itself.\n+         *\/\n@@ -655,1 +612,1 @@\n-        \/\/ is this a soft link Node?\n+        \/** Returns whether this node is a symbolic link. *\/\n@@ -660,0 +617,5 @@\n+        \/**\n+         * Returns whether this node is a directory. Directory nodes can have\n+         * {@link #getChildNames()} invoked to get the fully qualified names\n+         * of any child nodes.\n+         *\/\n@@ -664,4 +626,5 @@\n-        public List<Node> getChildren() {\n-            throw new IllegalArgumentException(\"not a directory: \" + getNameString());\n-        }\n-\n+        \/**\n+         * Returns whether this node is a resource. Resource nodes can have\n+         * their contents obtained via {@link ImageReader#getResource(Node)}\n+         * or {@link ImageReader#getResourceBuffer(Node)}.\n+         *\/\n@@ -672,2 +635,8 @@\n-        public ImageLocation getLocation() {\n-            throw new IllegalArgumentException(\"not a resource: \" + getNameString());\n+        \/**\n+         * Returns the fully qualified names of any child nodes for a directory.\n+         *\n+         * <p>By default, this method throws {@link IllegalStateException} and\n+         * is overridden for directories.\n+         *\/\n+        public Stream<String> getChildNames() {\n+            throw new IllegalStateException(\"not a directory: \" + getName());\n@@ -676,0 +645,4 @@\n+        \/**\n+         * Returns the uncompressed size of this node's content. If this node is\n+         * not a resource, this method returns zero.\n+         *\/\n@@ -680,0 +653,4 @@\n+        \/**\n+         * Returns the compressed size of this node's content. If this node is\n+         * not a resource, this method returns zero.\n+         *\/\n@@ -684,0 +661,4 @@\n+        \/**\n+         * Returns the extension string of a resource node. If this node is not\n+         * a resource, this method returns null.\n+         *\/\n@@ -688,20 +669,0 @@\n-        public long contentOffset() {\n-            return 0L;\n-        }\n-\n-        public final FileTime creationTime() {\n-            return fileAttrs.creationTime();\n-        }\n-\n-        public final FileTime lastAccessTime() {\n-            return fileAttrs.lastAccessTime();\n-        }\n-\n-        public final FileTime lastModifiedTime() {\n-            return fileAttrs.lastModifiedTime();\n-        }\n-\n-        public final String getNameString() {\n-            return name;\n-        }\n-\n@@ -710,1 +671,1 @@\n-            return getNameString();\n+            return getName();\n@@ -713,0 +674,1 @@\n+        \/** See <a href=\"#node_equality\">Node Equality<\/a>. *\/\n@@ -718,0 +680,1 @@\n+        \/** See <a href=\"#node_equality\">Node Equality<\/a>. *\/\n@@ -732,3 +695,26 @@\n-    \/\/ directory node - directory has full path name without '\/' at end.\n-    static final class Directory extends Node {\n-        private final List<Node> children;\n+    \/**\n+     * Directory node (referenced from a full path, without a trailing '\/').\n+     *\n+     * <p>Directory nodes have two distinct states:\n+     * <ul>\n+     *     <li>Incomplete: The child list has not been set.\n+     *     <li>Complete: The child list has been set.\n+     * <\/ul>\n+     *\n+     * <p>When a directory node is returned by {@link ImageReader#findNode(String)}\n+     * it is always complete, but this DOES NOT mean that its child nodes are\n+     * complete yet.\n+     *\n+     * <p>To avoid users being able to access incomplete child nodes, the\n+     * {@code Node} API offers only a way to obtain child node names, forcing\n+     * callers to invoke {@code findNode()} if they need to access the child\n+     * node itself.\n+     *\n+     * <p>This approach allows directories to be implemented lazily with respect\n+     * to child nodes, while retaining efficiency when child nodes are accessed\n+     * (since any incomplete nodes will be created and placed in the node cache\n+     * when the parent was first returned to the user).\n+     *\/\n+    private static final class Directory extends Node {\n+        \/\/ Monotonic reference, will be set to the unmodifiable child list exactly once.\n+        private List<Node> children = null;\n@@ -738,1 +724,0 @@\n-            children = new ArrayList<>();\n@@ -741,6 +726,3 @@\n-        static Directory create(Directory parent, String name, BasicFileAttributes fileAttrs) {\n-            Directory d = new Directory(name, fileAttrs);\n-            if (parent != null) {\n-                parent.addChild(d);\n-            }\n-            return d;\n+        @Override\n+        boolean isCompleted() {\n+            return children != null;\n@@ -755,17 +737,3 @@\n-        public List<Node> getChildren() {\n-            return Collections.unmodifiableList(children);\n-        }\n-\n-        void addChild(Node node) {\n-            assert !children.contains(node) : \"Child \" + node + \" already added\";\n-            children.add(node);\n-        }\n-\n-        public void walk(Consumer<? super Node> consumer) {\n-            consumer.accept(this);\n-            for (Node child : children) {\n-                if (child.isDirectory()) {\n-                    ((Directory)child).walk(consumer);\n-                } else {\n-                    consumer.accept(child);\n-                }\n+        public Stream<String> getChildNames() {\n+            if (children != null) {\n+                return children.stream().map(Node::getName);\n@@ -773,6 +741,21 @@\n-        }\n-    }\n-\n-    \/\/ \"resource\" is .class or any other resource (compressed\/uncompressed) in a jimage.\n-    \/\/ full path of the resource is the \"name\" of the resource.\n-    static class Resource extends Node {\n+            throw new IllegalStateException(\"Cannot get child nodes of an incomplete directory: \" + getName());\n+        }\n+\n+        private void setChildren(List<Node> children) {\n+            assert this.children == null : this + \": Cannot set child nodes twice!\";\n+            this.children = Collections.unmodifiableList(children);\n+        }\n+    }\n+    \/**\n+     * Resource node (e.g. a \".class\" entry, or any other data resource).\n+     *\n+     * <p>Resources are leaf nodes referencing an underlying image location. They\n+     * are lightweight, and do not cache their contents.\n+     *\n+     * <p>Unlike directories (where the node name matches the jimage path for the\n+     * corresponding {@code ImageLocation}), resource node names are NOT the same\n+     * as the corresponding jimage path. The difference is that node names for\n+     * resources are prefixed with \"\/modules\", which is missing from the\n+     * equivalent jimage path.\n+     *\/\n+    private static class Resource extends Node {\n@@ -781,2 +764,2 @@\n-        private Resource(ImageLocation loc, BasicFileAttributes fileAttrs) {\n-            super(loc.getFullName(true), fileAttrs);\n+        private Resource(String name, ImageLocation loc, BasicFileAttributes fileAttrs) {\n+            super(name, fileAttrs);\n@@ -786,6 +769,0 @@\n-        static Resource create(Directory parent, ImageLocation loc, BasicFileAttributes fileAttrs) {\n-            Resource rs = new Resource(loc, fileAttrs);\n-            parent.addChild(rs);\n-            return rs;\n-        }\n-\n@@ -793,2 +770,2 @@\n-        public boolean isCompleted() {\n-            return true;\n+        ImageLocation getLocation() {\n+            return loc;\n@@ -802,5 +779,0 @@\n-        @Override\n-        public ImageLocation getLocation() {\n-            return loc;\n-        }\n-\n@@ -821,5 +793,0 @@\n-\n-        @Override\n-        public long contentOffset() {\n-            return loc.getContentOffset();\n-        }\n@@ -828,3 +795,10 @@\n-    \/\/ represents a soft link to another Node\n-    static class LinkNode extends Node {\n-        private final Node link;\n+    \/**\n+     * Link node (a symbolic link to a top-level modules directory).\n+     *\n+     * <p>Link nodes resolve their target by invoking a given supplier, and do\n+     * not cache the result. Since nodes are cached by the {@code ImageReader},\n+     * this means that only the first call to {@link #resolveLink(boolean)}\n+     * could do any significant work.\n+     *\/\n+    private static class LinkNode extends Node {\n+        private final Supplier<Node> link;\n@@ -832,2 +806,2 @@\n-        private LinkNode(String name, Node link) {\n-            super(name, link.getFileAttributes());\n+        private LinkNode(String name, Supplier<Node> link, BasicFileAttributes fileAttrs) {\n+            super(name, fileAttrs);\n@@ -837,11 +811,0 @@\n-        static LinkNode create(Directory parent, String name, Node link) {\n-            LinkNode ln = new LinkNode(name, link);\n-            parent.addChild(ln);\n-            return ln;\n-        }\n-\n-        @Override\n-        public boolean isCompleted() {\n-            return true;\n-        }\n-\n@@ -850,1 +813,3 @@\n-            return (recursive && link instanceof LinkNode) ? ((LinkNode)link).resolveLink(true) : link;\n+            \/\/ No need to use or propagate the recursive flag, since the target\n+            \/\/ cannot possibly be a link node (links only point to directories).\n+            return link.get();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageReader.java","additions":482,"deletions":517,"binary":false,"changes":999,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-        public List<Node> getChildren() {\n+        public Stream<String> getChildNames() {\n@@ -124,1 +124,1 @@\n-                throw new IllegalArgumentException(\"not a directory: \" + getNameString());\n+                throw new IllegalArgumentException(\"not a directory: \" + getName());\n@@ -141,1 +141,1 @@\n-            return children;\n+            return children.stream().map(Node::getName);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/ExplodedImage.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-        return node.creationTime();\n+        return node.getFileAttributes().creationTime();\n@@ -72,1 +72,1 @@\n-        return node.lastAccessTime();\n+        return node.getFileAttributes().lastAccessTime();\n@@ -77,1 +77,1 @@\n-        return node.lastModifiedTime();\n+        return node.getFileAttributes().lastModifiedTime();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/JrtFileAttributes.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-import java.util.ArrayList;\n@@ -67,1 +66,0 @@\n-import static java.util.stream.Collectors.toList;\n@@ -228,4 +226,3 @@\n-            return node.getChildren()\n-                       .stream()\n-                       .map(child -> (Path)(path.resolve(new JrtPath(this, child.getNameString()).getFileName())))\n-                       .iterator();\n+            return node.getChildNames()\n+                    .map(child -> (Path) (path.resolve(new JrtPath(this, child).getFileName())))\n+                    .iterator();\n@@ -233,8 +230,9 @@\n-        return node.getChildren()\n-                   .stream()\n-                   .map(child -> (Path)(path.resolve(new JrtPath(this, child.getNameString()).getFileName())))\n-                   .filter(p ->  { try { return filter.accept(p);\n-                                   } catch (IOException x) {}\n-                                   return false;\n-                                  })\n-                   .iterator();\n+        return node.getChildNames()\n+                .map(child -> (Path) (path.resolve(new JrtPath(this, child).getFileName())))\n+                .filter(p -> {\n+                    try {\n+                        return filter.accept(p);\n+                    } catch (IOException x) {}\n+                    return false;\n+                })\n+                .iterator();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/JrtFileSystem.java","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-            image.getRootDirectory();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/SystemImage.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1072,0 +1072,3 @@\n+     *\n+     * @throws NullPointerException if the field is {@code null}\n+     * @throws IllegalArgumentException if the field is static\n@@ -1083,2 +1086,8 @@\n-     * Reports the location of the field with a given name in the storage\n-     * allocation of its class.\n+     * (For compile-time known instance fields in JDK code only) Reports the\n+     * location of the field with a given name in the storage allocation of its\n+     * class.\n+     * <p>\n+     * This API is used to avoid creating reflective Objects in Java code at\n+     * startup.  This should not be used to find fields in non-trusted code.\n+     * Use the {@link #objectFieldOffset(Field) Field}-accepting version for\n+     * arbitrary fields instead.\n@@ -1087,3 +1096,1 @@\n-     * @throws InternalError if there is no field named {@code name} declared\n-     *         in class {@code c}, i.e., if {@code c.getDeclaredField(name)}\n-     *         would throw {@code java.lang.NoSuchFieldException}.\n+     * @throws InternalError if the presumably known field couldn't be found\n@@ -1098,1 +1105,10 @@\n-        return objectFieldOffset1(c, name);\n+        long result = knownObjectFieldOffset0(c, name);\n+        if (result < 0) {\n+            String type = switch ((int) result) {\n+                case -2 -> \"a static field\";\n+                case -1 -> \"not found\";\n+                default -> \"unknown\";\n+            };\n+            throw new InternalError(\"Field %s.%s %s\".formatted(c.getTypeName(), name, type));\n+        }\n+        return result;\n@@ -1116,0 +1132,3 @@\n+     *\n+     * @throws NullPointerException if the field is {@code null}\n+     * @throws IllegalArgumentException if the field is not static\n@@ -1135,0 +1154,3 @@\n+     *\n+     * @throws NullPointerException if the field is {@code null}\n+     * @throws IllegalArgumentException if the field is not static\n@@ -3851,4 +3873,4 @@\n-    private native long objectFieldOffset0(Field f);\n-    private native long objectFieldOffset1(Class<?> c, String name);\n-    private native long staticFieldOffset0(Field f);\n-    private native Object staticFieldBase0(Field f);\n+    private native long objectFieldOffset0(Field f); \/\/ throws IAE\n+    private native long knownObjectFieldOffset0(Class<?> c, String name); \/\/ error code: -1 not found, -2 static\n+    private native long staticFieldOffset0(Field f); \/\/ throws IAE\n+    private native Object staticFieldBase0(Field f); \/\/ throws IAE\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":32,"deletions":10,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-import java.net.URLConnection;\n@@ -57,1 +56,0 @@\n-import jdk.internal.jimage.ImageLocation;\n@@ -213,1 +211,1 @@\n-     * Parses the module-info.class of all module in the runtime image and\n+     * Parses the {@code module-info.class} of all modules in the runtime image and\n@@ -222,5 +220,0 @@\n-        ImageReader reader = SystemImage.reader();\n-        for (String mn : reader.getModuleNames()) {\n-            ImageLocation loc = reader.findLocation(mn, \"module-info.class\");\n-            ModuleInfo.Attributes attrs\n-                = ModuleInfo.read(reader.getResourceBuffer(loc), null);\n@@ -228,1 +221,2 @@\n-            nameToAttributes.put(mn, attrs);\n+        allModuleAttributes().forEach(attrs -> {\n+            nameToAttributes.put(attrs.descriptor().name(), attrs);\n@@ -235,1 +229,1 @@\n-        }\n+        });\n@@ -256,0 +250,34 @@\n+    \/**\n+     * Parses the {@code module-info.class} of all modules in the runtime image and\n+     * returns a stream of {@link ModuleInfo.Attributes Attributes} for them. The\n+     * returned attributes are in no specific order.\n+     *\/\n+    private static Stream<ModuleInfo.Attributes> allModuleAttributes() {\n+        \/\/ System-wide image reader.\n+        ImageReader reader = SystemImage.reader();\n+        try {\n+            return reader.findNode(\"\/modules\")\n+                    .getChildNames()\n+                    .map(mn -> readModuleAttributes(reader, mn));\n+        } catch (IOException e) {\n+            throw new Error(\"Error reading root \/modules entry\", e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the module's \"module-info\", returning a holder for its class file\n+     * attributes. Every module is required to have a valid {@code module-info.class}.\n+     *\/\n+    private static ModuleInfo.Attributes readModuleAttributes(ImageReader reader, String moduleName) {\n+        Exception err = null;\n+        try {\n+            ImageReader.Node node = reader.findNode(moduleName + \"\/module-info.class\");\n+            if (node != null && node.isResource()) {\n+                return ModuleInfo.read(reader.getResourceBuffer(node), null);\n+            }\n+        } catch (IOException | UncheckedIOException e) {\n+            err = e;\n+        }\n+        throw new Error(\"Missing or invalid module-info.class for module: \" + moduleName, err);\n+    }\n+\n@@ -385,17 +413,0 @@\n-        \/**\n-         * Returns the ImageLocation for the given resource, {@code null}\n-         * if not found.\n-         *\/\n-        private ImageLocation findImageLocation(String name) throws IOException {\n-            Objects.requireNonNull(name);\n-            if (closed)\n-                throw new IOException(\"ModuleReader is closed\");\n-            ImageReader imageReader = SystemImage.reader();\n-            if (imageReader != null) {\n-                return imageReader.findLocation(module, name);\n-            } else {\n-                \/\/ not an images build\n-                return null;\n-            }\n-        }\n-\n@@ -406,2 +417,2 @@\n-        private boolean containsImageLocation(String name) throws IOException {\n-            Objects.requireNonNull(name);\n+        private boolean containsResource(String resourcePath) throws IOException {\n+            Objects.requireNonNull(resourcePath);\n@@ -412,1 +423,2 @@\n-                return imageReader.verifyLocation(module, name);\n+                ImageReader.Node node = imageReader.findNode(\"\/modules\" + resourcePath);\n+                return node != null && node.isResource();\n@@ -421,2 +433,4 @@\n-            if (containsImageLocation(name)) {\n-                URI u = JNUA.create(\"jrt\", \"\/\" + module + \"\/\" + name);\n+            Objects.requireNonNull(name);\n+            String resourcePath = \"\/\" + module + \"\/\" + name;\n+            if (containsResource(resourcePath)) {\n+                URI u = JNUA.create(\"jrt\", resourcePath);\n@@ -445,0 +459,14 @@\n+        \/**\n+         * Returns the node for the given resource if found. If the name references\n+         * a non-resource node, then {@code null} is returned.\n+         *\/\n+        private ImageReader.Node findResource(ImageReader reader, String name) throws IOException {\n+            Objects.requireNonNull(name);\n+            if (closed) {\n+                throw new IOException(\"ModuleReader is closed\");\n+            }\n+            String nodeName = \"\/modules\/\" + module + \"\/\" + name;\n+            ImageReader.Node node = reader.findNode(nodeName);\n+            return (node != null && node.isResource()) ? node : null;\n+        }\n+\n@@ -447,6 +475,3 @@\n-            ImageLocation location = findImageLocation(name);\n-            if (location != null) {\n-                return Optional.of(SystemImage.reader().getResourceBuffer(location));\n-            } else {\n-                return Optional.empty();\n-            }\n+            ImageReader reader = SystemImage.reader();\n+            return Optional.ofNullable(findResource(reader, name))\n+                    .map(reader::getResourceBuffer);\n@@ -484,1 +509,1 @@\n-        Iterator<ImageReader.Node> iterator;\n+        Iterator<String> iterator;\n@@ -505,2 +530,2 @@\n-                    ImageReader.Node node = iterator.next();\n-                    String name = node.getName();\n+                    String name = iterator.next();\n+                    ImageReader.Node node = SystemImage.reader().findNode(name);\n@@ -508,4 +533,1 @@\n-                        \/\/ build node\n-                        ImageReader.Node dir = SystemImage.reader().findNode(name);\n-                        assert dir.isDirectory();\n-                        stack.push(dir);\n+                        stack.push(node);\n@@ -523,1 +545,1 @@\n-                    iterator = dir.getChildren().iterator();\n+                    iterator = dir.getChildNames().iterator();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/SystemModuleFinders.java","additions":69,"deletions":47,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -157,1 +157,0 @@\n-        java.desktop, \/\/ for ScopedValue\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1083,0 +1083,5 @@\n+                    if (sa.length > 2)\n+                        responseMessage = String.join(\" \", Arrays.copyOfRange(sa, 2, sa.length));\n+                    if (logger.isLoggable(PlatformLogger.Level.FINE)) {\n+                        logger.fine(\"response message received \" + responseMessage);\n+                    }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/HttpURLConnection.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.util.Objects;\n@@ -302,0 +303,1 @@\n+        Objects.requireNonNull(task, \"task\");\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AsynchronousChannelGroupImpl.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,0 @@\n-import java.nio.charset.CharsetDecoder;\n-import java.nio.charset.CharsetEncoder;\n@@ -35,2 +33,1 @@\n-import sun.nio.cs.DoubleByte;\n-import sun.nio.cs.Surrogate;\n+\n@@ -358,6 +355,0 @@\n-        @SuppressWarnings(\"this-escape\")\n-        private byte[] repl = replacement();\n-        protected void implReplaceWith(byte[] newReplacement) {\n-            repl = newReplacement;\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/HKSCS.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -375,1 +375,1 @@\n-       Closing pipe fds here is redundant, since closeDescriptors()\n+       Closing pipe fds here is redundant, since markDescriptorsCloseOnExec()\n@@ -429,0 +429,5 @@\n+    \/\/ Children should be started with default signal disposition for SIGPIPE\n+    if (signal(SIGPIPE, SIG_DFL) == SIG_ERR) {\n+        goto WhyCantJohnnyExec;\n+    }\n+\n","filename":"src\/java.base\/unix\/native\/libjava\/childproc.c","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,0 @@\n-    public static final int IO_REPARSE_TAG_SYMLINK              = 0xA000000C;\n@@ -77,0 +76,2 @@\n+    public static final int IO_REPARSE_TAG_MOUNT_POINT          = 0xA0000003;\n+    public static final int IO_REPARSE_TAG_SYMLINK              = 0xA000000C;\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsConstants.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -415,0 +415,4 @@\n+    boolean isDirectoryJunction() {\n+        return reparseTag == IO_REPARSE_TAG_MOUNT_POINT;\n+    }\n+\n@@ -426,4 +430,2 @@\n-        \/\/ ignore FILE_ATTRIBUTE_DIRECTORY attribute if file is a sym link\n-        if (isSymbolicLink())\n-            return false;\n-        return ((fileAttrs & FILE_ATTRIBUTE_DIRECTORY) != 0);\n+        return ((fileAttrs & FILE_ATTRIBUTE_DIRECTORY) != 0 &&\n+                (fileAttrs & FILE_ATTRIBUTE_REPARSE_POINT) == 0);\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileAttributes.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -246,1 +246,2 @@\n-             if (attrs.isDirectory() || attrs.isDirectoryLink()) {\n+             if (attrs.isDirectory() || attrs.isDirectoryLink() ||\n+                 attrs.isDirectoryJunction()) {\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileSystemProvider.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -160,0 +160,3 @@\n+                        \"alt BACK_SPACE\", null,\n+                        \"ctrl W\", null,\n+                        \"alt DELETE\", null,\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaKeyBindings.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.awt.Color;\n@@ -32,0 +33,2 @@\n+import java.awt.Insets;\n+import java.awt.Rectangle;\n@@ -39,0 +42,2 @@\n+import javax.swing.ButtonModel;\n+import javax.swing.Icon;\n@@ -40,0 +45,1 @@\n+import javax.swing.JMenu;\n@@ -44,0 +50,2 @@\n+import sun.swing.MenuItemLayoutHelper;\n+import sun.swing.SwingUtilities2;\n@@ -64,0 +72,4 @@\n+    private static Color disabledForeground;\n+    private static Color acceleratorSelectionForeground;\n+    private static Color acceleratorForeground;\n+\n@@ -140,0 +152,122 @@\n+    public static void applyInsets(Rectangle rect, Insets insets) {\n+        if (insets != null) {\n+            rect.x += insets.left;\n+            rect.y += insets.top;\n+            rect.width -= (insets.right + rect.x);\n+            rect.height -= (insets.bottom + rect.y);\n+        }\n+    }\n+\n+    public static void paintCheckIcon(Graphics g, MenuItemLayoutHelper lh,\n+                               MenuItemLayoutHelper.LayoutResult lr,\n+                               Color holdc, Color foreground) {\n+        if (lh.getCheckIcon() != null) {\n+            ButtonModel model = lh.getMenuItem().getModel();\n+            if (model.isArmed() || (lh.getMenuItem() instanceof JMenu\n+                    && model.isSelected())) {\n+                g.setColor(foreground);\n+            } else {\n+                g.setColor(holdc);\n+            }\n+            if (lh.useCheckAndArrow()) {\n+                lh.getCheckIcon().paintIcon(lh.getMenuItem(), g,\n+                        lr.getCheckRect().x, lr.getCheckRect().y);\n+            }\n+            g.setColor(holdc);\n+        }\n+    }\n+\n+    public static void paintIcon(Graphics g, MenuItemLayoutHelper lh,\n+                          MenuItemLayoutHelper.LayoutResult lr, Color holdc) {\n+        if (lh.getIcon() != null) {\n+            Icon icon;\n+            ButtonModel model = lh.getMenuItem().getModel();\n+            if (!model.isEnabled()) {\n+                icon = lh.getMenuItem().getDisabledIcon();\n+            } else if (model.isPressed() && model.isArmed()) {\n+                icon = lh.getMenuItem().getPressedIcon();\n+                if (icon == null) {\n+                    \/\/ Use default icon\n+                    icon = lh.getMenuItem().getIcon();\n+                }\n+            } else {\n+                icon = lh.getMenuItem().getIcon();\n+            }\n+\n+            if (icon != null) {\n+                icon.paintIcon(lh.getMenuItem(), g, lr.getIconRect().x,\n+                        lr.getIconRect().y);\n+                g.setColor(holdc);\n+            }\n+        }\n+    }\n+\n+\n+    public static void paintAccText(Graphics g, MenuItemLayoutHelper lh,\n+                             MenuItemLayoutHelper.LayoutResult lr) {\n+        if (!lh.getAccText().isEmpty()) {\n+            ButtonModel model = lh.getMenuItem().getModel();\n+            g.setFont(lh.getAccFontMetrics().getFont());\n+            if (!model.isEnabled()) {\n+\n+                \/\/ paint the accText disabled\n+                if (disabledForeground != null) {\n+                    g.setColor(disabledForeground);\n+                    SwingUtilities2.drawString(lh.getMenuItem(), g,\n+                            lh.getAccText(), lr.getAccRect().x,\n+                            lr.getAccRect().y + lh.getAccFontMetrics().getAscent());\n+                } else {\n+                    g.setColor(lh.getMenuItem().getBackground().brighter());\n+                    SwingUtilities2.drawString(lh.getMenuItem(), g,\n+                            lh.getAccText(), lr.getAccRect().x,\n+                            lr.getAccRect().y + lh.getAccFontMetrics().getAscent());\n+                    g.setColor(lh.getMenuItem().getBackground().darker());\n+                    SwingUtilities2.drawString(lh.getMenuItem(), g,\n+                            lh.getAccText(), lr.getAccRect().x - 1,\n+                            lr.getAccRect().y + lh.getFontMetrics().getAscent() - 1);\n+                }\n+            } else {\n+\n+                \/\/ paint the accText normally\n+                if (model.isArmed()\n+                        || (lh.getMenuItem() instanceof JMenu\n+                        && model.isSelected())) {\n+                    g.setColor(acceleratorSelectionForeground);\n+                } else {\n+                    g.setColor(acceleratorForeground);\n+                }\n+                SwingUtilities2.drawString(lh.getMenuItem(), g, lh.getAccText(),\n+                        lr.getAccRect().x, lr.getAccRect().y +\n+                                lh.getAccFontMetrics().getAscent());\n+            }\n+        }\n+    }\n+\n+    public static void setDisabledForeground(Color disabledFg) {\n+        disabledForeground = disabledFg;\n+    }\n+\n+    public static void setAcceleratorSelectionForeground(Color acceleratorSelectionFg) {\n+        acceleratorSelectionForeground = acceleratorSelectionFg;\n+    }\n+\n+    public static void setAcceleratorForeground(Color acceleratorFg) {\n+        acceleratorForeground = acceleratorFg;\n+    }\n+\n+    public static void paintArrowIcon(Graphics g, MenuItemLayoutHelper lh,\n+                               MenuItemLayoutHelper.LayoutResult lr,\n+                               Color foreground) {\n+        if (lh.getArrowIcon() != null) {\n+            ButtonModel model = lh.getMenuItem().getModel();\n+            if (model.isArmed() || (lh.getMenuItem() instanceof JMenu\n+                    && model.isSelected())) {\n+                g.setColor(foreground);\n+            }\n+            if (lh.useCheckAndArrow()) {\n+                lh.getArrowIcon().paintIcon(lh.getMenuItem(), g,\n+                        lr.getArrowRect().x, lr.getArrowRect().y);\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/SwingUtilities3.java","additions":135,"deletions":1,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-import java.awt.event.*;\n+import java.awt.event.ActionEvent;\n@@ -377,1 +377,1 @@\n-        private final int MOVE_RESIZE_INCREMENT = 10;\n+        private static final int MOVE_RESIZE_INCREMENT = 10;\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicDesktopPaneUI.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,12 @@\n-import java.awt.*;\n-import java.awt.event.*;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics;\n+import java.awt.Insets;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.InputEvent;\n+import java.awt.event.MouseEvent;\n@@ -33,3 +43,23 @@\n-import javax.swing.*;\n-import javax.swing.event.*;\n-import javax.swing.plaf.*;\n+import javax.swing.ButtonModel;\n+import javax.swing.Icon;\n+import javax.swing.InputMap;\n+import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JComponent;\n+import javax.swing.JMenu;\n+import javax.swing.JMenuItem;\n+import javax.swing.JRadioButtonMenuItem;\n+import javax.swing.KeyStroke;\n+import javax.swing.LookAndFeel;\n+import javax.swing.MenuElement;\n+import javax.swing.MenuSelectionManager;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.event.MenuDragMouseEvent;\n+import javax.swing.event.MenuDragMouseListener;\n+import javax.swing.event.MenuKeyListener;\n+\n+import javax.swing.event.MouseInputListener;\n+import javax.swing.plaf.ComponentInputMapUIResource;\n+import javax.swing.plaf.ComponentUI;\n+import javax.swing.plaf.MenuItemUI;\n+import javax.swing.plaf.UIResource;\n@@ -38,1 +68,6 @@\n-import sun.swing.*;\n+import com.sun.java.swing.SwingUtilities3;\n+import sun.swing.MenuItemCheckIconFactory;\n+import sun.swing.MenuItemLayoutHelper;\n+import sun.swing.SwingUtilities2;\n+import sun.swing.UIAction;\n+\n@@ -673,21 +708,1 @@\n-        if (lh.getIcon() != null) {\n-            Icon icon;\n-            ButtonModel model = lh.getMenuItem().getModel();\n-            if (!model.isEnabled()) {\n-                icon = lh.getMenuItem().getDisabledIcon();\n-            } else if (model.isPressed() && model.isArmed()) {\n-                icon = lh.getMenuItem().getPressedIcon();\n-                if (icon == null) {\n-                    \/\/ Use default icon\n-                    icon = lh.getMenuItem().getIcon();\n-                }\n-            } else {\n-                icon = lh.getMenuItem().getIcon();\n-            }\n-\n-            if (icon != null) {\n-                icon.paintIcon(lh.getMenuItem(), g, lr.getIconRect().x,\n-                        lr.getIconRect().y);\n-                g.setColor(holdc);\n-            }\n-        }\n+        SwingUtilities3.paintIcon(g, lh, lr, holdc);\n@@ -699,14 +714,1 @@\n-        if (lh.getCheckIcon() != null) {\n-            ButtonModel model = lh.getMenuItem().getModel();\n-            if (model.isArmed() || (lh.getMenuItem() instanceof JMenu\n-                    && model.isSelected())) {\n-                g.setColor(foreground);\n-            } else {\n-                g.setColor(holdc);\n-            }\n-            if (lh.useCheckAndArrow()) {\n-                lh.getCheckIcon().paintIcon(lh.getMenuItem(), g,\n-                        lr.getCheckRect().x, lr.getCheckRect().y);\n-            }\n-            g.setColor(holdc);\n-        }\n+        SwingUtilities3.paintCheckIcon(g, lh, lr, holdc, foreground);\n@@ -717,34 +719,5 @@\n-        if (!lh.getAccText().isEmpty()) {\n-            ButtonModel model = lh.getMenuItem().getModel();\n-            g.setFont(lh.getAccFontMetrics().getFont());\n-            if (!model.isEnabled()) {\n-                \/\/ *** paint the accText disabled\n-                if (disabledForeground != null) {\n-                    g.setColor(disabledForeground);\n-                    SwingUtilities2.drawString(lh.getMenuItem(), g,\n-                        lh.getAccText(), lr.getAccRect().x,\n-                        lr.getAccRect().y + lh.getAccFontMetrics().getAscent());\n-                } else {\n-                    g.setColor(lh.getMenuItem().getBackground().brighter());\n-                    SwingUtilities2.drawString(lh.getMenuItem(), g,\n-                        lh.getAccText(), lr.getAccRect().x,\n-                        lr.getAccRect().y + lh.getAccFontMetrics().getAscent());\n-                    g.setColor(lh.getMenuItem().getBackground().darker());\n-                    SwingUtilities2.drawString(lh.getMenuItem(), g,\n-                        lh.getAccText(), lr.getAccRect().x - 1,\n-                        lr.getAccRect().y + lh.getFontMetrics().getAscent() - 1);\n-                }\n-            } else {\n-                \/\/ *** paint the accText normally\n-                if (model.isArmed()\n-                        || (lh.getMenuItem() instanceof JMenu\n-                        && model.isSelected())) {\n-                    g.setColor(acceleratorSelectionForeground);\n-                } else {\n-                    g.setColor(acceleratorForeground);\n-                }\n-                SwingUtilities2.drawString(lh.getMenuItem(), g, lh.getAccText(),\n-                        lr.getAccRect().x, lr.getAccRect().y +\n-                        lh.getAccFontMetrics().getAscent());\n-            }\n-        }\n+        SwingUtilities3.setDisabledForeground(disabledForeground);\n+        SwingUtilities3.setAcceleratorSelectionForeground(\n+                        acceleratorSelectionForeground);\n+        SwingUtilities3.setAcceleratorForeground(acceleratorForeground);\n+        SwingUtilities3.paintAccText(g, lh, lr);\n@@ -769,11 +742,1 @@\n-        if (lh.getArrowIcon() != null) {\n-            ButtonModel model = lh.getMenuItem().getModel();\n-            if (model.isArmed() || (lh.getMenuItem() instanceof JMenu\n-                                && model.isSelected())) {\n-                g.setColor(foreground);\n-            }\n-            if (lh.useCheckAndArrow()) {\n-                lh.getArrowIcon().paintIcon(lh.getMenuItem(), g,\n-                        lr.getArrowRect().x, lr.getArrowRect().y);\n-            }\n-        }\n+        SwingUtilities3.paintArrowIcon(g, lh, lr, foreground);\n@@ -783,6 +746,1 @@\n-        if(insets != null) {\n-            rect.x += insets.left;\n-            rect.y += insets.top;\n-            rect.width -= (insets.right + rect.x);\n-            rect.height -= (insets.bottom + rect.y);\n-        }\n+        SwingUtilities3.applyInsets(rect, insets);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicMenuItemUI.java","additions":51,"deletions":93,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.ref.WeakReference;\n@@ -230,1 +231,1 @@\n-            if (mark.unused) {\n+            if (mark.get() == null) {\n@@ -245,1 +246,1 @@\n-            if (mark.unused) {\n+            if (mark.get() == null) {\n@@ -281,1 +282,1 @@\n-            if (mark.unused) {\n+            if (mark.get() == null) {\n@@ -306,1 +307,1 @@\n-            if(ref.rec.unused) {\n+            if(ref.rec.get() == null) {\n@@ -326,1 +327,1 @@\n-    static final class PosRec {\n+    static final class PosRec extends WeakReference<StickyPosition> {\n@@ -328,1 +329,2 @@\n-        PosRec(int offset) {\n+        PosRec(int offset, StickyPosition position) {\n+            super(position);\n@@ -333,1 +335,0 @@\n-        boolean unused;\n@@ -336,6 +337,0 @@\n-    \/**\n-     * This really wants to be a weak reference but\n-     * in 1.1 we don't have a 100% pure solution for\n-     * this... so this class tries to hack a solution\n-     * to causing the marks to be collected.\n-     *\/\n@@ -345,1 +340,1 @@\n-            rec = new PosRec(offset);\n+            rec = new PosRec(offset, this);\n@@ -353,7 +348,0 @@\n-        @SuppressWarnings(\"removal\")\n-        protected void finalize() throws Throwable {\n-            \/\/ schedule the record to be removed later\n-            \/\/ on another thread.\n-            rec.unused = true;\n-        }\n-\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/StringContent.java","additions":9,"deletions":21,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-\/*-\n+\/*\n@@ -31,2 +31,11 @@\n-import java.io.*;\n-import java.awt.image.*;\n+import java.awt.image.ImageConsumer;\n+import java.awt.image.IndexColorModel;\n+import java.io.BufferedInputStream;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static java.lang.Math.multiplyExact;\n@@ -53,0 +62,2 @@\n+    private static final int MAX_XBM_SIZE = 16384;\n+    private static final int HEADER_SCAN_LIMIT = 100;\n@@ -75,4 +86,0 @@\n-        char[] nm = new char[80];\n-        int c;\n-        int i = 0;\n-        int state = 0;\n@@ -83,1 +90,2 @@\n-        boolean start = true;\n+        int n = 0;\n+        int state = 0;\n@@ -86,20 +94,29 @@\n-        while (!aborted && (c = input.read()) != -1) {\n-            if ('a' <= c && c <= 'z' ||\n-                    'A' <= c && c <= 'Z' ||\n-                    '0' <= c && c <= '9' || c == '#' || c == '_') {\n-                if (i < 78)\n-                    nm[i++] = (char) c;\n-            } else if (i > 0) {\n-                int nc = i;\n-                i = 0;\n-                if (start) {\n-                    if (nc != 7 ||\n-                        nm[0] != '#' ||\n-                        nm[1] != 'd' ||\n-                        nm[2] != 'e' ||\n-                        nm[3] != 'f' ||\n-                        nm[4] != 'i' ||\n-                        nm[5] != 'n' ||\n-                        nm[6] != 'e')\n-                    {\n-                        error(\"Not an XBM file\");\n+\n+        String matchRegex = \"(0[xX])?[0-9a-fA-F]+[\\\\s+]?[,|};]\";\n+        String replaceRegex = \"(0[xX])|,|[\\\\s+]|[};]\";\n+\n+        String line;\n+        int lineNum = 0;\n+\n+        try (BufferedReader br = new BufferedReader(new InputStreamReader(input))) {\n+            \/\/ loop to process XBM header - width, height and create raster\n+            while (!aborted && (line = br.readLine()) != null\n+                    && lineNum <= HEADER_SCAN_LIMIT) {\n+                lineNum++;\n+                \/\/ process #define stmts\n+                if (line.trim().startsWith(\"#define\")) {\n+                    String[] token = line.split(\"\\\\s+\");\n+                    if (token.length != 3) {\n+                        error(\"Error while parsing define statement\");\n+                    }\n+                    try {\n+                        if (!token[2].isBlank() && state == 0) {\n+                            W = Integer.parseInt(token[2]);\n+                            state = 1; \/\/ after width is set\n+                        } else if (!token[2].isBlank() && state == 1) {\n+                            H = Integer.parseInt(token[2]);\n+                            state = 2; \/\/ after height is set\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        \/\/ parseInt() can throw NFE\n+                        error(\"Error while parsing width or height.\");\n@@ -107,1 +124,0 @@\n-                    start = false;\n@@ -109,17 +125,4 @@\n-                if (nm[nc - 1] == 'h')\n-                    state = 1;  \/* expecting width *\/\n-                else if (nm[nc - 1] == 't' && nc > 1 && nm[nc - 2] == 'h')\n-                    state = 2;  \/* expecting height *\/\n-                else if (nc > 2 && state < 0 && nm[0] == '0' && nm[1] == 'x') {\n-                    int n = 0;\n-                    for (int p = 2; p < nc; p++) {\n-                        c = nm[p];\n-                        if ('0' <= c && c <= '9')\n-                            c = c - '0';\n-                        else if ('A' <= c && c <= 'Z')\n-                            c = c - 'A' + 10;\n-                        else if ('a' <= c && c <= 'z')\n-                            c = c - 'a' + 10;\n-                        else\n-                            c = 0;\n-                        n = n * 16 + c;\n+\n+                if (state == 2) {\n+                    if (W <= 0 || H <= 0) {\n+                        error(\"Invalid values for width or height.\");\n@@ -127,8 +130,3 @@\n-                    for (int mask = 1; mask <= 0x80; mask <<= 1) {\n-                        if (x < W) {\n-                            if ((n & mask) != 0)\n-                                raster[x] = 1;\n-                            else\n-                                raster[x] = 0;\n-                        }\n-                        x++;\n+                    if (multiplyExact(W, H) > MAX_XBM_SIZE) {\n+                        error(\"Large XBM file size.\"\n+                                + \" Maximum allowed size: \" + MAX_XBM_SIZE);\n@@ -136,3 +134,36 @@\n-                    if (x >= W) {\n-                        if (setPixels(0, y, W, 1, model, raster, 0, W) <= 0) {\n-                            return;\n+                    model = new IndexColorModel(8, 2, XbmColormap,\n+                            0, false, 0);\n+                    setDimensions(W, H);\n+                    setColorModel(model);\n+                    setHints(XbmHints);\n+                    headerComplete();\n+                    raster = new byte[W];\n+                    state = 3;\n+                    break;\n+                }\n+            }\n+\n+            if (state != 3) {\n+                error(\"Width or Height of XBM file not defined\");\n+            }\n+\n+            \/\/ loop to process image data\n+            while (!aborted && (line = br.readLine()) != null) {\n+                lineNum++;\n+\n+                if (line.contains(\"[]\")) {\n+                    Matcher matcher = Pattern.compile(matchRegex).matcher(line);\n+                    while (matcher.find()) {\n+                        if (y >= H) {\n+                            error(\"Scan size of XBM file exceeds\"\n+                                    + \" the defined width x height\");\n+                        }\n+\n+                        int startIndex = matcher.start();\n+                        int endIndex = matcher.end();\n+                        String hexByte = line.substring(startIndex, endIndex);\n+\n+                        if (!(hexByte.startsWith(\"0x\")\n+                                || hexByte.startsWith(\"0X\"))) {\n+                            error(\"Invalid hexadecimal number at Ln#:\" + lineNum\n+                                    + \" Col#:\" + (startIndex + 1));\n@@ -140,3 +171,4 @@\n-                        x = 0;\n-                        if (y++ >= H) {\n-                            break;\n+                        hexByte = hexByte.replaceAll(replaceRegex, \"\");\n+                        if (hexByte.length() != 2) {\n+                            error(\"Invalid hexadecimal number at Ln#:\" + lineNum\n+                                    + \" Col#:\" + (startIndex + 1));\n@@ -144,9 +176,15 @@\n-                    }\n-                } else {\n-                    int n = 0;\n-                    for (int p = 0; p < nc; p++)\n-                        if ('0' <= (c = nm[p]) && c <= '9')\n-                            n = n * 10 + c - '0';\n-                        else {\n-                            n = -1;\n-                            break;\n+\n+                        try {\n+                            n = Integer.parseInt(hexByte, 16);\n+                        } catch (NumberFormatException nfe) {\n+                            error(\"Error parsing hexadecimal at Ln#:\" + lineNum\n+                                    + \" Col#:\" + (startIndex + 1));\n+                        }\n+                        for (int mask = 1; mask <= 0x80; mask <<= 1) {\n+                            if (x < W) {\n+                                if ((n & mask) != 0)\n+                                    raster[x] = 1;\n+                                else\n+                                    raster[x] = 0;\n+                            }\n+                            x++;\n@@ -154,16 +192,8 @@\n-                    if (n > 0 && state > 0) {\n-                        if (state == 1)\n-                            W = n;\n-                        else\n-                            H = n;\n-                        if (W == 0 || H == 0)\n-                            state = 0;\n-                        else {\n-                            model = new IndexColorModel(8, 2, XbmColormap,\n-                                                        0, false, 0);\n-                            setDimensions(W, H);\n-                            setColorModel(model);\n-                            setHints(XbmHints);\n-                            headerComplete();\n-                            raster = new byte[W];\n-                            state = -1;\n+\n+                        if (x >= W) {\n+                            int result = setPixels(0, y, W, 1, model, raster, 0, W);\n+                            if (result <= 0) {\n+                                error(\"Unexpected error occurred during setPixel()\");\n+                            }\n+                            x = 0;\n+                            y++;\n@@ -174,0 +204,1 @@\n+            imageComplete(ImageConsumer.STATICIMAGEDONE, true);\n@@ -175,2 +206,0 @@\n-        input.close();\n-        imageComplete(ImageConsumer.STATICIMAGEDONE, true);\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/XbmImageDecoder.java","additions":117,"deletions":88,"binary":false,"changes":205,"status":"modified"},{"patch":"@@ -103,5 +103,5 @@\n-    private Reference<AccelSurface> validSrcDataRef = new WeakReference<>(null);\n-    private Reference<AccelSurface> validDstDataRef = new WeakReference<>(null);\n-    private Reference<Region> validClipRef = new WeakReference<>(null);\n-    private Reference<Composite> validCompRef = new WeakReference<>(null);\n-    private Reference<Paint> validPaintRef = new WeakReference<>(null);\n+    private Reference<AccelSurface> validSrcDataRef = null;\n+    private Reference<AccelSurface> validDstDataRef = null;\n+    private Reference<Region> validClipRef = null;\n+    private Reference<Composite> validCompRef = null;\n+    private Reference<Paint> validPaintRef = null;\n@@ -216,1 +216,1 @@\n-        } else if (validPaintRef.get() != paint) {\n+        } else if (stateChanged(validPaintRef, paint)) {\n@@ -223,5 +223,3 @@\n-        final AccelSurface validatedSrcData = validSrcDataRef.get();\n-        final AccelSurface validatedDstData = validDstDataRef.get();\n-        if ((currentContext != this) ||\n-            (srcData != validatedSrcData) ||\n-            (dstData != validatedDstData))\n+        final boolean srcChanged = stateChanged(validSrcDataRef, srcData);\n+        final boolean dstChanged = stateChanged(validDstDataRef, dstData);\n+        if ((currentContext != this) || srcChanged || dstChanged)\n@@ -229,1 +227,1 @@\n-            if (dstData != validatedDstData) {\n+            if (dstChanged) {\n@@ -246,2 +244,2 @@\n-            validSrcDataRef = new WeakReference<>(srcData);\n-            validDstDataRef = new WeakReference<>(dstData);\n+            validSrcDataRef = wrapState(srcData);\n+            validDstDataRef = wrapState(dstData);\n@@ -251,2 +249,2 @@\n-        final Region validatedClip = validClipRef.get();\n-        if ((clip != validatedClip) || updateClip) {\n+        final Region validatedClip = validClipRef == null ? null : validClipRef.get();\n+        if (stateChanged(validClipRef, clip) || updateClip) {\n@@ -267,1 +265,1 @@\n-            validClipRef = new WeakReference<>(clip);\n+            validClipRef = wrapState(clip);\n@@ -273,1 +271,1 @@\n-        if ((comp != validCompRef.get()) || (flags != validatedFlags)) {\n+        if (stateChanged(validCompRef, comp) || (flags != validatedFlags)) {\n@@ -282,1 +280,1 @@\n-            validCompRef = new WeakReference<>(comp);\n+            validCompRef = wrapState(comp);\n@@ -316,1 +314,1 @@\n-            validPaintRef = new WeakReference<>(paint);\n+            validPaintRef = wrapState(paint);\n@@ -324,0 +322,12 @@\n+    private static <T> boolean stateChanged(Reference<T> ref, T obj) {\n+        \/\/ null ref means \"true\" null object\n+        if (ref == null) return obj != null;\n+        T old = ref.get();\n+        \/\/ null ref value means the object was GC'ed, return true in that case\n+        return old == null || old != obj;\n+    }\n+\n+    private static <T> Reference<T> wrapState(T obj) {\n+        return obj == null ? null : new WeakReference<>(obj);\n+    }\n+\n@@ -437,5 +447,5 @@\n-        validSrcDataRef.clear();\n-        validDstDataRef.clear();\n-        validCompRef.clear();\n-        validClipRef.clear();\n-        validPaintRef.clear();\n+        validSrcDataRef = null;\n+        validDstDataRef = null;\n+        validCompRef = null;\n+        validClipRef = null;\n+        validPaintRef = null;\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/pipe\/BufferedContext.java","additions":35,"deletions":25,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import javax.swing.Icon;\n@@ -76,0 +77,18 @@\n+\n+    \/**\n+     * Paint MenuItem.\n+     *\/\n+    protected void paintMenuItem(Graphics g, JComponent c,\n+                                 Icon checkIcon, Icon arrowIcon,\n+                                 Color background, Color foreground,\n+                                 int defaultTextIconGap) {\n+        if (WindowsMenuItemUI.isVistaPainting()) {\n+            WindowsMenuItemUI.paintMenuItem(accessor, g, c, checkIcon,\n+                    arrowIcon, background, foreground, defaultTextIconGap,\n+                    menuItem, getPropertyPrefix());\n+            return;\n+        }\n+        super.paintMenuItem(g, c, checkIcon, arrowIcon, background,\n+                foreground, defaultTextIconGap);\n+    }\n+\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsCheckBoxMenuItemUI.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -883,0 +883,1 @@\n+\n@@ -906,6 +907,2 @@\n-                            Skin skin;\n-                            skin =  xp.getSkin(c, backgroundPart);\n-                            skin.paintSkin(g, x, y,\n-                                getIconWidth(), getIconHeight(), backgroundState);\n-                            if (icon == null) {\n-                                skin = xp.getSkin(c, part);\n+                            Skin skin = xp.getSkin(c, part);\n+                            if (icon == null || icon.getIconHeight() <= 16) {\n@@ -913,0 +910,2 @@\n+                            } else {\n+                                skin.paintSkin(g, x + OFFSET, y + icon.getIconHeight() \/ 2, state);\n@@ -918,1 +917,2 @@\n-                    icon.paintIcon(c, g, x + OFFSET, y + OFFSET);\n+                    icon.paintIcon(c, g, x + VistaMenuItemCheckIconFactory.getIconWidth(),\n+                                   y + OFFSET);\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsIconFactory.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.awt.Font;\n@@ -31,0 +32,1 @@\n+import java.awt.Insets;\n@@ -34,0 +36,1 @@\n+import java.util.Enumeration;\n@@ -35,0 +38,2 @@\n+import javax.swing.AbstractButton;\n+import javax.swing.ButtonGroup;\n@@ -36,0 +41,2 @@\n+import javax.swing.DefaultButtonModel;\n+import javax.swing.Icon;\n@@ -44,0 +51,1 @@\n+import com.sun.java.swing.SwingUtilities3;\n@@ -62,0 +70,3 @@\n+    private static Color disabledForeground;\n+    private static Color acceleratorSelectionForeground;\n+    private static Color acceleratorForeground;\n@@ -126,0 +137,21 @@\n+    protected void installDefaults() {\n+        super.installDefaults();\n+        String prefix = getPropertyPrefix();\n+\n+        if (acceleratorSelectionForeground == null ||\n+                acceleratorSelectionForeground instanceof UIResource) {\n+            acceleratorSelectionForeground =\n+                    UIManager.getColor(prefix + \".acceleratorSelectionForeground\");\n+        }\n+        if (acceleratorForeground == null ||\n+                acceleratorForeground instanceof UIResource) {\n+            acceleratorForeground =\n+                    UIManager.getColor(prefix + \".acceleratorForeground\");\n+        }\n+        if (disabledForeground == null ||\n+                disabledForeground instanceof UIResource) {\n+            disabledForeground =\n+                    UIManager.getColor(prefix + \".disabledForeground\");\n+        }\n+    }\n+\n@@ -138,0 +170,108 @@\n+    private static void applyInsets(Rectangle rect, Insets insets) {\n+        SwingUtilities3.applyInsets(rect, insets);\n+    }\n+\n+    private static void paintCheckIcon(Graphics g, MenuItemLayoutHelper lh,\n+                                MenuItemLayoutHelper.LayoutResult lr,\n+                                Color holdc, Color foreground) {\n+        SwingUtilities3.paintCheckIcon(g, lh, lr, holdc, foreground);\n+    }\n+\n+    private static void paintIcon(Graphics g, MenuItemLayoutHelper lh,\n+                           MenuItemLayoutHelper.LayoutResult lr, Color holdc) {\n+        SwingUtilities3.paintIcon(g, lh, lr, holdc);\n+    }\n+\n+    private static void paintAccText(Graphics g, MenuItemLayoutHelper lh,\n+                              MenuItemLayoutHelper.LayoutResult lr) {\n+        SwingUtilities3.setDisabledForeground(disabledForeground);\n+        SwingUtilities3.setAcceleratorSelectionForeground(\n+                        acceleratorSelectionForeground);\n+        SwingUtilities3.setAcceleratorForeground(acceleratorForeground);\n+        SwingUtilities3.paintAccText(g, lh, lr);\n+    }\n+\n+    private static void paintArrowIcon(Graphics g, MenuItemLayoutHelper lh,\n+                                MenuItemLayoutHelper.LayoutResult lr,\n+                                Color foreground) {\n+        SwingUtilities3.paintArrowIcon(g, lh, lr, foreground);\n+    }\n+\n+    protected void paintMenuItem(Graphics g, JComponent c,\n+                                 Icon checkIcon, Icon arrowIcon,\n+                                 Color background, Color foreground,\n+                                 int defaultTextIconGap) {\n+        if (WindowsMenuItemUI.isVistaPainting()) {\n+            WindowsMenuItemUI.paintMenuItem(accessor, g, c, checkIcon,\n+                                            arrowIcon, background, foreground,\n+                                            defaultTextIconGap, menuItem,\n+                                            getPropertyPrefix());\n+            return;\n+        }\n+        super.paintMenuItem(g, c, checkIcon, arrowIcon, background,\n+                foreground, defaultTextIconGap);\n+    }\n+\n+    static void paintMenuItem(WindowsMenuItemUIAccessor accessor, Graphics g,\n+                              JComponent c, Icon checkIcon, Icon arrowIcon,\n+                              Color background, Color foreground,\n+                              int defaultTextIconGap, JMenuItem menuItem, String prefix) {\n+        \/\/ Save original graphics font and color\n+        Font holdf = g.getFont();\n+        Color holdc = g.getColor();\n+\n+        JMenuItem mi = (JMenuItem) c;\n+        g.setFont(mi.getFont());\n+\n+        Rectangle viewRect = new Rectangle(0, 0, mi.getWidth(), mi.getHeight());\n+        applyInsets(viewRect, mi.getInsets());\n+\n+        String acceleratorDelimiter =\n+                UIManager.getString(\"MenuItem.acceleratorDelimiter\");\n+        if (acceleratorDelimiter == null) { acceleratorDelimiter = \"+\"; }\n+        Font acceleratorFont = UIManager.getFont(\"MenuItem.acceleratorFont\");\n+        if (acceleratorFont == null) {\n+            acceleratorFont = UIManager.getFont(\"MenuItem.font\");\n+        }\n+\n+        MenuItemLayoutHelper lh = new MenuItemLayoutHelper(mi, checkIcon,\n+                arrowIcon, viewRect, defaultTextIconGap, acceleratorDelimiter,\n+                mi.getComponentOrientation().isLeftToRight(), mi.getFont(),\n+                acceleratorFont, MenuItemLayoutHelper.useCheckAndArrow(menuItem),\n+                prefix);\n+        MenuItemLayoutHelper.LayoutResult lr = lh.layoutMenuItem();\n+\n+        paintBackground(accessor, g, mi, background);\n+        paintCheckIcon(g, lh, lr, holdc, foreground);\n+        paintIcon(g, lh, lr, holdc);\n+\n+        if (lh.getCheckIcon() != null && lh.useCheckAndArrow()) {\n+            Rectangle rect = lr.getTextRect();\n+\n+            rect.x += lh.getAfterCheckIconGap();\n+\n+            lr.setTextRect(rect);\n+        }\n+        if (!lh.getText().isEmpty()) {\n+            if (lh.getHtmlView() != null) {\n+                \/\/ Text is HTML\n+                lh.getHtmlView().paint(g, lr.getTextRect());\n+            } else {\n+                \/\/ Text isn't HTML\n+                paintText(accessor, g, lh.getMenuItem(),\n+                          lr.getTextRect(), lh.getText());\n+            }\n+        }\n+        if (lh.getCheckIcon() != null && lh.useCheckAndArrow()) {\n+            Rectangle rect = lr.getAccRect();\n+            rect.x += lh.getAfterCheckIconGap();\n+            lr.setAccRect(rect);\n+        }\n+        paintAccText(g, lh, lr);\n+        paintArrowIcon(g, lh, lr, foreground);\n+\n+        \/\/ Restore original graphics font and color\n+        g.setColor(holdc);\n+        g.setFont(holdf);\n+    }\n+\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsMenuItemUI.java","additions":141,"deletions":1,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,0 +133,19 @@\n+    \/**\n+     * Paint MenuItem.\n+     *\/\n+    protected void paintMenuItem(Graphics g, JComponent c,\n+                              Icon checkIcon, Icon arrowIcon,\n+                              Color background, Color foreground,\n+                              int defaultTextIconGap) {\n+        if (WindowsMenuItemUI.isVistaPainting()) {\n+            WindowsMenuItemUI.paintMenuItem(accessor, g, c, checkIcon, arrowIcon,\n+                                            background, foreground,\n+                                            defaultTextIconGap, menuItem,\n+                                            getPropertyPrefix());\n+            return;\n+        }\n+        super.paintMenuItem(g, c, checkIcon, arrowIcon, background,\n+                                   foreground, defaultTextIconGap);\n+    }\n+\n+\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsMenuUI.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import javax.swing.Icon;\n@@ -77,0 +78,17 @@\n+    \/**\n+     * Paint MenuItem.\n+     *\/\n+    protected void paintMenuItem(Graphics g, JComponent c,\n+                                 Icon checkIcon, Icon arrowIcon,\n+                                 Color background, Color foreground,\n+                                 int defaultTextIconGap) {\n+        if (WindowsMenuItemUI.isVistaPainting()) {\n+            WindowsMenuItemUI.paintMenuItem(accessor, g, c, checkIcon,\n+                    arrowIcon, background, foreground, defaultTextIconGap,\n+                    menuItem, getPropertyPrefix());\n+            return;\n+        }\n+        super.paintMenuItem(g, c, checkIcon, arrowIcon, background,\n+                foreground, defaultTextIconGap);\n+    }\n+\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsRadioButtonMenuItemUI.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n@@ -38,1 +40,0 @@\n-import com.sun.tools.javac.util.StringUtils;\n@@ -54,1 +55,1 @@\n-        for (Flag flag : asFlagSet(flags)) {\n+        for (FlagsEnum flag : asFlagSet(flags)) {\n@@ -62,4 +63,4 @@\n-    public static EnumSet<Flag> asFlagSet(long flags) {\n-        EnumSet<Flag> flagSet = EnumSet.noneOf(Flag.class);\n-        for (Flag flag : Flag.values()) {\n-            if ((flags & flag.value) != 0) {\n+    public static EnumSet<FlagsEnum> asFlagSet(long flags) {\n+        EnumSet<FlagsEnum> flagSet = EnumSet.noneOf(FlagsEnum.class);\n+        for (FlagsEnum flag : FlagsEnum.values()) {\n+            if ((flags & flag.value()) != 0) {\n@@ -67,1 +68,1 @@\n-                flags &= ~flag.value;\n+                flags &= ~flag.value();\n@@ -76,0 +77,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.VARIABLE})\n@@ -77,0 +79,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.VARIABLE})\n@@ -78,0 +81,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.VARIABLE})\n@@ -79,0 +83,1 @@\n+    @Use({FlagTarget.BLOCK, FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.VARIABLE})\n@@ -80,0 +85,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.VARIABLE})\n@@ -81,0 +87,1 @@\n+    @Use({FlagTarget.METHOD})\n@@ -82,0 +89,1 @@\n+    @Use({FlagTarget.VARIABLE})\n@@ -83,0 +91,1 @@\n+    @Use({FlagTarget.VARIABLE})\n@@ -84,0 +93,1 @@\n+    @Use({FlagTarget.METHOD})\n@@ -85,0 +95,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -86,0 +97,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD})\n@@ -87,0 +99,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD})\n@@ -90,0 +103,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.VARIABLE})\n@@ -93,0 +107,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -97,0 +112,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.VARIABLE})\n@@ -100,0 +116,1 @@\n+    @Use({FlagTarget.MODULE, FlagTarget.VARIABLE})\n@@ -102,0 +119,1 @@\n+    @NotFlag\n@@ -108,4 +126,12 @@\n-    public static final int ACC_SUPER    = 0x0020;\n-    public static final int ACC_BRIDGE   = 0x0040;\n-    public static final int ACC_VARARGS  = 0x0080;\n-    public static final int ACC_MODULE   = 0x8000;\n+    @Use({FlagTarget.CLASS})\n+    @NoToStringValue\n+    public static final int ACC_SUPER    = 1<<5;\n+    @Use({FlagTarget.METHOD})\n+    @NoToStringValue\n+    public static final int ACC_BRIDGE   = 1<<6;\n+    @Use({FlagTarget.METHOD})\n+    @NoToStringValue\n+    public static final int ACC_VARARGS  = 1<<7;\n+    @Use({FlagTarget.CLASS})\n+    @NoToStringValue\n+    public static final int ACC_MODULE   = 1<<15;\n@@ -119,0 +145,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.MODULE, FlagTarget.PACKAGE, FlagTarget.TYPE_VAR, FlagTarget.VARIABLE})\n@@ -124,0 +151,1 @@\n+    @Use({FlagTarget.VARIABLE})\n@@ -128,0 +156,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -133,0 +162,1 @@\n+    @Use({FlagTarget.METHOD})\n@@ -137,1 +167,2 @@\n-    public static final int FROM_SOURCE      = 1<<21; \/\/ClassSymbols\n+    @Use({FlagTarget.CLASS})\n+    public static final int FROM_SOURCE      = 1<<21;\n@@ -146,0 +177,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.VARIABLE})\n@@ -151,0 +183,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.PACKAGE})\n@@ -156,0 +189,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -160,0 +194,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -165,0 +200,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -175,0 +211,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD})\n@@ -180,0 +217,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -184,1 +222,2 @@\n-    public static final int ANONCONSTR   = 1<<29; \/\/non-class members\n+    @Use({FlagTarget.METHOD})\n+    public static final int ANONCONSTR   = 1<<29;\n@@ -189,1 +228,2 @@\n-    public static final int SUPER_OWNER_ATTRIBUTED = 1<<29; \/\/ClassSymbols\n+    @Use({FlagTarget.CLASS})\n+    public static final int SUPER_OWNER_ATTRIBUTED = 1<<29;\n@@ -194,0 +234,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.TYPE_VAR})\n@@ -198,0 +239,1 @@\n+    @Use({FlagTarget.METHOD})\n@@ -202,0 +244,1 @@\n+    @Use({FlagTarget.VARIABLE})\n@@ -206,0 +249,1 @@\n+    @Use({FlagTarget.METHOD, FlagTarget.VARIABLE})\n@@ -211,0 +255,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -215,0 +260,1 @@\n+    @Use({FlagTarget.METHOD})\n@@ -221,0 +267,1 @@\n+    @Use({FlagTarget.METHOD})\n@@ -226,0 +273,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -231,0 +279,1 @@\n+    @Use({FlagTarget.VARIABLE})\n@@ -237,0 +286,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.TYPE_VAR})\n@@ -242,0 +292,1 @@\n+    @Use({FlagTarget.VARIABLE})\n@@ -248,0 +299,1 @@\n+    @Use({FlagTarget.METHOD, FlagTarget.VARIABLE})\n@@ -253,0 +305,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD})\n@@ -259,0 +312,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -264,0 +318,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -269,0 +324,1 @@\n+    @Use({FlagTarget.METHOD})\n@@ -274,0 +330,1 @@\n+    @Use({FlagTarget.METHOD})\n@@ -279,0 +336,1 @@\n+    @Use({FlagTarget.TYPE_VAR})\n@@ -284,0 +342,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -289,1 +348,2 @@\n-    public static final long LAMBDA_METHOD = 1L<<49; \/\/MethodSymbols only\n+    @Use({FlagTarget.METHOD})\n+    public static final long LAMBDA_METHOD = 1L<<49;\n@@ -294,1 +354,2 @@\n-    public static final long LOCAL_CAPTURE_FIELD = 1L<<49; \/\/VarSymbols only\n+    @Use({FlagTarget.VARIABLE})\n+    public static final long LOCAL_CAPTURE_FIELD = 1L<<49;\n@@ -299,0 +360,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -304,0 +366,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -309,1 +372,2 @@\n-    public static final long AUTOMATIC_MODULE = 1L<<52; \/\/ModuleSymbols only\n+    @Use({FlagTarget.MODULE})\n+    public static final long AUTOMATIC_MODULE = 1L<<52;\n@@ -314,1 +378,2 @@\n-    public static final long HAS_RESOURCE = 1L<<52; \/\/PackageSymbols only\n+    @Use({FlagTarget.PACKAGE})\n+    public static final long HAS_RESOURCE = 1L<<52;\n@@ -319,1 +384,2 @@\n-    public static final long NAME_FILLED = 1L<<52; \/\/ParamSymbols only\n+    @Use({FlagTarget.VARIABLE}) \/\/ParamSymbols only\n+    public static final long NAME_FILLED = 1L<<52;\n@@ -324,1 +390,2 @@\n-    public static final long SYSTEM_MODULE = 1L<<53; \/\/ModuleSymbols only\n+    @Use({FlagTarget.MODULE})\n+    public static final long SYSTEM_MODULE = 1L<<53;\n@@ -329,1 +396,2 @@\n-    public static final long VALUE_BASED = 1L<<53; \/\/ClassSymbols only\n+    @Use({FlagTarget.CLASS})\n+    public static final long VALUE_BASED = 1L<<53;\n@@ -334,0 +402,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.MODULE, FlagTarget.PACKAGE, FlagTarget.TYPE_VAR, FlagTarget.VARIABLE})\n@@ -339,0 +408,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.MODULE, FlagTarget.PACKAGE, FlagTarget.TYPE_VAR, FlagTarget.VARIABLE})\n@@ -344,0 +414,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.MODULE, FlagTarget.PACKAGE, FlagTarget.TYPE_VAR, FlagTarget.VARIABLE})\n@@ -349,0 +420,1 @@\n+    @Use({FlagTarget.METHOD})\n@@ -355,1 +427,2 @@\n-    public static final long BODY_ONLY_FINALIZE = 1L<<17; \/\/blocks only\n+    @Use({FlagTarget.BLOCK})\n+    public static final long BODY_ONLY_FINALIZE = 1L<<17;\n@@ -360,0 +433,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.MODULE, FlagTarget.PACKAGE, FlagTarget.TYPE_VAR, FlagTarget.VARIABLE})\n@@ -365,0 +439,1 @@\n+    @Use({FlagTarget.VARIABLE})\n@@ -370,0 +445,1 @@\n+    @Use({FlagTarget.VARIABLE})\n@@ -376,1 +452,2 @@\n-    public static final long RECORD = 1L<<61; \/\/ ClassSymbols, MethodSymbols and VarSymbols\n+    @Use({FlagTarget.CLASS, FlagTarget.VARIABLE, FlagTarget.METHOD})\n+    public static final long RECORD = 1L<<61;\n@@ -381,1 +458,2 @@\n-    public static final long COMPACT_RECORD_CONSTRUCTOR = 1L<<51; \/\/ MethodSymbols only\n+    @Use({FlagTarget.METHOD})\n+    public static final long COMPACT_RECORD_CONSTRUCTOR = 1L<<51;\n@@ -386,1 +464,2 @@\n-    public static final long UNINITIALIZED_FIELD= 1L<<51; \/\/ VarSymbols only\n+    @Use({FlagTarget.VARIABLE})\n+    public static final long UNINITIALIZED_FIELD= 1L<<51;\n@@ -391,1 +470,2 @@\n-    public static final int GENERATED_MEMBER = 1<<24; \/\/ MethodSymbols and VarSymbols\n+    @Use({FlagTarget.METHOD, FlagTarget.VARIABLE})\n+    public static final int GENERATED_MEMBER = 1<<24;\n@@ -396,1 +476,2 @@\n-    public static final long RESTRICTED = 1L<<62; \/\/ MethodSymbols\n+    @Use({FlagTarget.METHOD})\n+    public static final long RESTRICTED = 1L<<62;\n@@ -401,1 +482,2 @@\n-    public static final long REQUIRES_IDENTITY = 1L<<62; \/\/ VarSymbols (parameters)\n+    @Use({FlagTarget.VARIABLE}) \/\/ParamSymbols only\n+    public static final long REQUIRES_IDENTITY = 1L<<62;\n@@ -406,1 +488,2 @@\n-    public static final long FIELD_INIT_TYPE_ANNOTATIONS_QUEUED = 1L<<53; \/\/ VarSymbols\n+    @Use({FlagTarget.VARIABLE})\n+    public static final long FIELD_INIT_TYPE_ANNOTATIONS_QUEUED = 1L<<53;\n@@ -411,0 +494,2 @@\n+    @Use({FlagTarget.CLASS})\n+    @CustomToStringValue(\"non-sealed\")\n@@ -425,0 +510,1 @@\n+    @NotFlag\n@@ -441,0 +527,1 @@\n+    @NotFlag\n@@ -494,0 +581,24 @@\n+    public enum FlagTarget {\n+        \/** This flag can appear the JCBlock.\n+         *\/\n+        BLOCK,\n+        \/** This flag can appear on ClassSymbols.\n+         *\/\n+        CLASS,\n+        \/** This flag can appear on ModuleSymbols.\n+         *\/\n+        MODULE,\n+        \/** This flag can appear on PackageSymbols.\n+         *\/\n+        PACKAGE,\n+        \/** This flag can appear on TypeVarSymbols.\n+         *\/\n+        TYPE_VAR,\n+        \/** This flag can appear on MethodSymbols.\n+         *\/\n+        METHOD,\n+        \/** This flag can appear on VarSymbols, includes\n+         *  including ParamSymbol, and BindingSymbol.\n+         *\/\n+        VARIABLE;\n+    }\n@@ -495,76 +606,4 @@\n-    public enum Flag {\n-        PUBLIC(Flags.PUBLIC),\n-        PRIVATE(Flags.PRIVATE),\n-        PROTECTED(Flags.PROTECTED),\n-        STATIC(Flags.STATIC),\n-        FINAL(Flags.FINAL),\n-        SYNCHRONIZED(Flags.SYNCHRONIZED),\n-        VOLATILE(Flags.VOLATILE),\n-        TRANSIENT(Flags.TRANSIENT),\n-        NATIVE(Flags.NATIVE),\n-        INTERFACE(Flags.INTERFACE),\n-        ABSTRACT(Flags.ABSTRACT),\n-        DEFAULT(Flags.DEFAULT),\n-        STRICTFP(Flags.STRICTFP),\n-        BRIDGE(Flags.BRIDGE),\n-        SYNTHETIC(Flags.SYNTHETIC),\n-        ANNOTATION(Flags.ANNOTATION),\n-        DEPRECATED(Flags.DEPRECATED),\n-        HASINIT(Flags.HASINIT),\n-        IMPLICIT_CLASS(Flags.IMPLICIT_CLASS),\n-        BLOCK(Flags.BLOCK),\n-        FROM_SOURCE(Flags.FROM_SOURCE),\n-        ENUM(Flags.ENUM),\n-        MANDATED(Flags.MANDATED),\n-        NOOUTERTHIS(Flags.NOOUTERTHIS),\n-        EXISTS(Flags.EXISTS),\n-        COMPOUND(Flags.COMPOUND),\n-        CLASS_SEEN(Flags.CLASS_SEEN),\n-        SOURCE_SEEN(Flags.SOURCE_SEEN),\n-        LOCKED(Flags.LOCKED),\n-        UNATTRIBUTED(Flags.UNATTRIBUTED),\n-        ANONCONSTR(Flags.ANONCONSTR),\n-        ACYCLIC(Flags.ACYCLIC),\n-        PARAMETER(Flags.PARAMETER),\n-        VARARGS(Flags.VARARGS),\n-        ACYCLIC_ANN(Flags.ACYCLIC_ANN),\n-        GENERATEDCONSTR(Flags.GENERATEDCONSTR),\n-        HYPOTHETICAL(Flags.HYPOTHETICAL),\n-        PROPRIETARY(Flags.PROPRIETARY),\n-        UNION(Flags.UNION),\n-        EFFECTIVELY_FINAL(Flags.EFFECTIVELY_FINAL),\n-        CLASH(Flags.CLASH),\n-        AUXILIARY(Flags.AUXILIARY),\n-        NOT_IN_PROFILE(Flags.NOT_IN_PROFILE),\n-        BAD_OVERRIDE(Flags.BAD_OVERRIDE),\n-        SIGNATURE_POLYMORPHIC(Flags.SIGNATURE_POLYMORPHIC),\n-        THROWS(Flags.THROWS),\n-        LAMBDA_METHOD(Flags.LAMBDA_METHOD),\n-        TYPE_TRANSLATED(Flags.TYPE_TRANSLATED),\n-        MODULE(Flags.MODULE),\n-        AUTOMATIC_MODULE(Flags.AUTOMATIC_MODULE),\n-        SYSTEM_MODULE(Flags.SYSTEM_MODULE),\n-        DEPRECATED_ANNOTATION(Flags.DEPRECATED_ANNOTATION),\n-        DEPRECATED_REMOVAL(Flags.DEPRECATED_REMOVAL),\n-        HAS_RESOURCE(Flags.HAS_RESOURCE),\n-        SEALED(Flags.SEALED),\n-        ANONCONSTR_BASED(Flags.ANONCONSTR_BASED),\n-        NAME_FILLED(Flags.NAME_FILLED),\n-        PREVIEW_API(Flags.PREVIEW_API),\n-        PREVIEW_REFLECTIVE(Flags.PREVIEW_REFLECTIVE),\n-        MATCH_BINDING(Flags.MATCH_BINDING),\n-        MATCH_BINDING_TO_OUTER(Flags.MATCH_BINDING_TO_OUTER),\n-        RECORD(Flags.RECORD),\n-        RECOVERABLE(Flags.RECOVERABLE),\n-        RESTRICTED(Flags.RESTRICTED),\n-        NON_SEALED(Flags.NON_SEALED) {\n-            @Override\n-            public String toString() {\n-                return \"non-sealed\";\n-            }\n-        };\n-\n-        Flag(long flag) {\n-            this.value = flag;\n-            this.lowercaseName = StringUtils.toLowerCase(name());\n-        }\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface Use {\n+        public FlagTarget[] value();\n+    }\n@@ -572,4 +611,2 @@\n-        @Override\n-        public String toString() {\n-            return lowercaseName;\n-        }\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface NotFlag {}\n@@ -577,2 +614,3 @@\n-        final long value;\n-        final String lowercaseName;\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface CustomToStringValue {\n+        public String value();\n@@ -581,0 +619,3 @@\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface NoToStringValue {\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":152,"deletions":111,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -531,8 +531,9 @@\n-        Attribute.Array values = (Attribute.Array)suppressWarnings.member(names.value);\n-        for (Attribute value : values.values) {\n-            Optional.of(value)\n-              .filter(val -> val instanceof Attribute.Constant)\n-              .map(val -> (String) ((Attribute.Constant) val).value)\n-              .flatMap(LintCategory::get)\n-              .filter(lc -> lc.annotationSuppression)\n-              .ifPresent(result::add);\n+        if (suppressWarnings.member(names.value) instanceof Attribute.Array values) {\n+            for (Attribute value : values.values) {\n+                Optional.of(value)\n+                  .filter(val -> val instanceof Attribute.Constant)\n+                  .map(val -> (String) ((Attribute.Constant) val).value)\n+                  .flatMap(LintCategory::get)\n+                  .filter(lc -> lc.annotationSuppression)\n+                  .ifPresent(result::add);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -243,1 +243,1 @@\n-            if (oldTree.clazz.hasTag(TYPEAPPLY)) {\n+            if (oldTree.clazz.hasTag(TYPEAPPLY) && !oldTree.type.isErroneous()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Analyzer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-import com.sun.tools.javac.code.Flags.Flag;\n+import com.sun.tools.javac.code.FlagsEnum;\n@@ -828,1 +828,1 @@\n-                        log.error(tree.pos(), Errors.ModNotAllowedHere(EnumSet.of(Flag.STATIC)));\n+                        log.error(tree.pos(), Errors.ModNotAllowedHere(EnumSet.of(FlagsEnum.STATIC)));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -131,0 +131,1 @@\n+        ensureEntered(\"getAllModuleElements\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacElements.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.function.LongFunction;\n@@ -33,1 +34,0 @@\n-import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;\n@@ -51,1 +51,2 @@\n-     * @param features bits specifying CPU features\n+     * @param bitMaskSupplier supplier to get the bit mask for the corresponding VM constant\n+     * @param featuresSupplier supplier to get the bits specifying CPU features\n@@ -60,1 +61,2 @@\n-                    long features,\n+                    LongFunction<Long> bitMaskSupplier,\n+                    LongFunction<Long> featuresSupplier,\n@@ -65,1 +67,1 @@\n-            long bitMask = e.getValue();\n+            long bitMask = bitMaskSupplier.apply(e.getValue());\n@@ -71,1 +73,1 @@\n-                    if ((features & bitMask) != 0) {\n+                    if ((featuresSupplier.apply(e.getValue()) & bitMask) != 0) {\n@@ -85,53 +87,0 @@\n-    \/**\n-     * Converts CPU features bit map into enum constants.\n-     *\n-     * @param <CPUFeatureType> CPU feature enum type\n-     * @param enumType the class of {@code CPUFeatureType}\n-     * @param constants VM constants. Each entry whose key starts with {@code \"VM_Version::CPU_\"}\n-     *            specifies a CPU feature and its value is a mask for a bit in {@code features}\n-     * @param featuresBitMapAddress pointer to {@code VM_Features::_features_bitmap} field of {@code VM_Version::_features}\n-     * @param featuresBitMapSize size of feature bit map in bytes\n-     * @param renaming maps from VM feature names to enum constant names where the two differ\n-     * @throws IllegalArgumentException if any VM CPU feature constant cannot be converted to an\n-     *             enum value\n-     * @return the set of converted values\n-     *\/\n-    static <CPUFeatureType extends Enum<CPUFeatureType>> EnumSet<CPUFeatureType> convertFeatures(\n-                    Class<CPUFeatureType> enumType,\n-                    Map<String, Long> constants,\n-                    long featuresBitMapAddress,\n-                    long featuresBitMapSize,\n-                    Map<String, String> renaming) {\n-        EnumSet<CPUFeatureType> outFeatures = EnumSet.noneOf(enumType);\n-        List<String> missing = new ArrayList<>();\n-\n-        for (Entry<String, Long> e : constants.entrySet()) {\n-            String key = e.getKey();\n-            long bitIndex = e.getValue();\n-            if (key.startsWith(\"VM_Version::CPU_\")) {\n-                String name = key.substring(\"VM_Version::CPU_\".length());\n-                try {\n-                    final long featuresElementShiftCount = 6; \/\/ log (# of bits per long)\n-                    final long featuresElementMask = (1L << featuresElementShiftCount) - 1;\n-\n-                    CPUFeatureType feature = Enum.valueOf(enumType, renaming.getOrDefault(name, name));\n-\n-                    long featureIndex = bitIndex >>> featuresElementShiftCount;\n-                    long featureBitMask = 1L << (bitIndex & featuresElementMask);\n-                    assert featureIndex < featuresBitMapSize;\n-\n-                    long featuresElement = UNSAFE.getLong(featuresBitMapAddress + featureIndex * Long.BYTES);\n-\n-                    if ((featuresElement & featureBitMask) != 0) {\n-                        outFeatures.add(feature);\n-                    }\n-                } catch (IllegalArgumentException iae) {\n-                    missing.add(name);\n-                }\n-            }\n-        }\n-        if (!missing.isEmpty()) {\n-            throw new JVMCIError(\"Missing CPU feature constants: %s\", missing);\n-        }\n-        return outFeatures;\n-    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIBackendFactory.java","additions":7,"deletions":58,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -189,1 +189,4 @@\n-                            result.getCompiler();\n+                            \/\/ EagerJVMCI only applies to JVMCI when used by the CompileBroker.\n+                            if (result.getCompilerToVM().isCompilerThread()) {\n+                                result.getCompiler();\n+                            }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-        return HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, config.vmVersionFeatures, emptyMap());\n+        return HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, idx -> 1L << idx, _ -> config.vmVersionFeatures, emptyMap());\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/aarch64\/AArch64HotSpotJVMCIBackendFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+\n+import jdk.internal.misc.Unsafe;\n@@ -53,5 +55,9 @@\n-        EnumSet<CPUFeature> features = HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class,\n-                                                                                  constants,\n-                                                                                  featuresBitMapAddress,\n-                                                                                  config.vmFeaturesFeaturesSize,\n-                                                                                  renaming);\n+        EnumSet<CPUFeature> features = HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, idx -> {\n+            final long featuresElementShiftCount = 6; \/\/ log (# of bits per long)\n+            final long featuresElementMask = (1L << featuresElementShiftCount) - 1;\n+            return 1L << (idx & featuresElementMask);\n+        }, idx -> {\n+            final long featuresElementShiftCount = 6; \/\/ log (# of bits per long)\n+            long featureIndex = idx >>> featuresElementShiftCount;\n+            return Unsafe.getUnsafe().getLong(featuresBitMapAddress + featureIndex * Long.BYTES);\n+        }, renaming);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/amd64\/AMD64HotSpotJVMCIBackendFactory.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-        return HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, config.vmVersionFeatures, emptyMap());\n+        return HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, mask -> mask, _ -> config.vmVersionFeatures, emptyMap());\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/riscv64\/RISCV64HotSpotJVMCIBackendFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include <fcntl.h>\n@@ -51,0 +52,15 @@\n+static int\n+markCloseOnExec(int fd)\n+{\n+    const int flags = fcntl(fd, F_GETFD);\n+    if (flags < 0) {\n+        return -1;\n+    }\n+    if ((flags & FD_CLOEXEC) == 0) {\n+        if (fcntl(fd, F_SETFD, flags | FD_CLOEXEC) < 0) {\n+            return -1;\n+        }\n+    }\n+    return 0;\n+}\n+\n@@ -60,5 +76,4 @@\n-\/\/ Closes every file descriptor that is listed as a directory\n-\/\/ entry in \"\/proc\/self\/fd\" (or its equivalent). Standard\n-\/\/ input\/output\/error file descriptors will not be closed\n-\/\/ by this function. This function returns 0 on failure\n-\/\/ and 1 on success.\n+\/\/ Marks all file descriptors found in \/proc\/self\/fd with the\n+\/\/ FD_CLOEXEC flag to ensure they are automatically closed\n+\/\/ upon execution of a new program via exec(). This function\n+\/\/ returns -1 on failure and 0 on success.\n@@ -66,1 +81,1 @@\n-closeDescriptors(void)\n+markDescriptorsCloseOnExec(void)\n@@ -70,18 +85,1 @@\n-    \/* leave out standard input\/output\/error descriptors *\/\n-    int from_fd = STDERR_FILENO + 1;\n-\n-    \/* We're trying to close all file descriptors, but opendir() might\n-     * itself be implemented using a file descriptor, and we certainly\n-     * don't want to close that while it's in use.  We assume that if\n-     * opendir() is implemented using a file descriptor, then it uses\n-     * the lowest numbered file descriptor, just like open().  So\n-     * before calling opendir(), we close a couple explicitly, so that\n-     * opendir() can then use these lowest numbered closed file\n-     * descriptors afresh.\n-     *\n-     * WARNING: We are not allowed to return with a failure until after\n-     * these two closes are done. forkedChildProcess() relies on this. *\/\n-\n-    close(from_fd);          \/* for possible use by opendir() *\/\n-    close(from_fd + 1);      \/* another one for good luck *\/\n-    from_fd += 2; \/* leave out the 2 we just closed, which the opendir() may use *\/\n+    const int from_fd = STDERR_FILENO;\n@@ -90,2 +88,1 @@\n-    \/* set FD_DIR for AIX which does not understand '\/proc\/self' - it\n-     * requires the real process ID *\/\n+    \/* AIX does not understand '\/proc\/self' - it requires the real process ID *\/\n@@ -98,1 +95,1 @@\n-                       \" file descriptors to close for process %d\",\n+                       \" file descriptors to mark or close for process %d\",\n@@ -100,1 +97,1 @@\n-        return 0; \/\/ failure\n+        return -1; \/\/ failure\n@@ -103,0 +100,2 @@\n+    int dir_fd = dirfd(dp);\n+\n@@ -107,3 +106,5 @@\n-        const long fd = strtol(dirp->d_name, NULL, 10);\n-        if (fd <= INT_MAX && fd >= from_fd) {\n-            (void)close((int)fd);\n+        int fd = strtol(dirp->d_name, NULL, 10);\n+        if (fd <= INT_MAX && fd > from_fd && fd != dir_fd) {\n+            if (markCloseOnExec(fd) == -1) {\n+                (void)close((int)fd);\n+            }\n@@ -115,1 +116,1 @@\n-    return 1; \/\/ success\n+    return 0; \/\/ success\n@@ -118,3 +119,4 @@\n-\/\/ Does necessary housekeeping of a forked child process\n-\/\/ (like closing copied file descriptors) before\n-\/\/ execing the child process. This function never returns.\n+\/\/ Performs necessary housekeeping in the forked child process,\n+\/\/ such as marking copied file descriptors (except standard input\/output\/error)\n+\/\/ with FD_CLOEXEC to ensure they are closed during exec().\n+\/\/ This function never returns.\n@@ -124,3 +126,4 @@\n-    \/* Close all file descriptors that have been copied over\n-     * from the parent process due to fork(). *\/\n-    if (closeDescriptors() == 0) { \/* failed,  close the old way *\/\n+    \/* Mark all file descriptors (except standard input\/output\/error)\n+     * copied from the parent process with FD_CLOEXEC, so they are\n+     * closed automatically upon exec(). *\/\n+    if (markDescriptorsCloseOnExec() < 0) { \/* failed,  close the old way *\/\n@@ -134,4 +137,2 @@\n-        \/* Leave out standard input\/output\/error file descriptors. Also,\n-         * leave out STDERR_FILENO +1 and +2 since closeDescriptors()\n-         * already closed them, even when returning an error. *\/\n-        rlim_t i = STDERR_FILENO + 3;\n+        \/* leave out standard input\/output\/error file descriptors *\/\n+        rlim_t i = STDERR_FILENO + 1;\n@@ -140,1 +141,1 @@\n-                       \" %d file descriptors sequentially\", (max_fd - i + 1)));\n+                       \" %d file descriptors sequentially\", (max_fd - i)));\n","filename":"src\/jdk.jdwp.agent\/unix\/native\/libjdwp\/exec_md.c","additions":44,"deletions":43,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/Contextual.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"enabled\">false<\/setting>\n@@ -41,1 +41,1 @@\n-      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"enabled\">false<\/setting>\n@@ -765,1 +765,1 @@\n-      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"enabled\">false<\/setting>\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,4 +27,4 @@\n-import jdk.jpackage.internal.model.LinuxPackage;\n-import jdk.jpackage.internal.model.LinuxLauncher;\n-import jdk.jpackage.internal.model.Package;\n-import jdk.jpackage.internal.model.Launcher;\n+import static jdk.jpackage.internal.ApplicationImageUtils.createLauncherIconResource;\n+import static jdk.jpackage.internal.model.LauncherShortcut.toRequest;\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n+\n@@ -48,1 +48,0 @@\n-import static jdk.jpackage.internal.ApplicationImageUtils.createLauncherIconResource;\n@@ -50,0 +49,4 @@\n+import jdk.jpackage.internal.model.LauncherShortcut;\n+import jdk.jpackage.internal.model.LinuxLauncher;\n+import jdk.jpackage.internal.model.LinuxPackage;\n+import jdk.jpackage.internal.model.Package;\n@@ -53,1 +56,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n@@ -80,1 +82,1 @@\n-        boolean withDesktopFile = !associations.isEmpty() || launcher.shortcut().orElse(false);\n+        boolean withDesktopFile = !associations.isEmpty() || toRequest(launcher.shortcut()).orElse(false);\n@@ -135,1 +137,1 @@\n-                return l.shortcut().orElse(true);\n+                return toRequest(l.shortcut()).orElse(true);\n@@ -228,0 +230,3 @@\n+\n+        var installedLayout = pkg.asInstalledPackageApplicationLayout().orElseThrow();\n+\n@@ -235,2 +240,18 @@\n-                pkg.asInstalledPackageApplicationLayout().orElseThrow().launchersDirectory().resolve(\n-                        launcher.executableNameWithSuffix()).toString()));\n+                installedLayout.launchersDirectory().resolve(launcher.executableNameWithSuffix()).toString()));\n+        data.put(\"STARTUP_DIRECTORY\", launcher.shortcut()\n+                .flatMap(LauncherShortcut::startupDirectory)\n+                .map(startupDirectory -> {\n+                    switch (startupDirectory) {\n+                        case DEFAULT -> {\n+                            return (Path)null;\n+                        }\n+                        case APP_DIR -> {\n+                            return installedLayout.appDirectory();\n+                        }\n+                        default -> {\n+                            throw new AssertionError();\n+                        }\n+                    }\n+                }).map(str -> {\n+                    return \"Path=\" + str;\n+                }).orElse(null));\n@@ -484,1 +505,1 @@\n-    private final Launcher launcher;\n+    private final LinuxLauncher launcher;\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/DesktopIntegration.java","additions":32,"deletions":11,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import static jdk.jpackage.internal.FromParams.findLauncherShortcut;\n@@ -33,1 +34,0 @@\n-import static jdk.jpackage.internal.StandardBundlerParam.SHORTCUT_HINT;\n@@ -40,2 +40,0 @@\n-import java.util.Optional;\n-import java.util.stream.Stream;\n@@ -54,0 +52,1 @@\n+\n@@ -56,3 +55,1 @@\n-            final var shortcut = Stream.of(SHORTCUT_HINT, LINUX_SHORTCUT_HINT).map(param -> {\n-                return param.findIn(launcherParams);\n-            }).filter(Optional::isPresent).map(Optional::get).findFirst();\n+            final var shortcut = findLauncherShortcut(LINUX_SHORTCUT_HINT, params, launcherParams);\n@@ -115,6 +112,2 @@\n-    private static final BundlerParamInfo<Boolean> LINUX_SHORTCUT_HINT = new BundlerParamInfo<>(\n-            Arguments.CLIOptions.LINUX_SHORTCUT_HINT.getId(),\n-            Boolean.class,\n-            params -> false,\n-            (s, p) -> (s == null || \"null\".equalsIgnoreCase(s)) ? false : Boolean.valueOf(s)\n-    );\n+    private static final BundlerParamInfo<String> LINUX_SHORTCUT_HINT = createStringBundlerParam(\n+            Arguments.CLIOptions.LINUX_SHORTCUT_HINT.getId());\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxFromParams.java","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.util.HashMap;\n@@ -39,3 +40,5 @@\n-        return shortcut().map(v -> {\n-            return Map.of(\"shortcut\", Boolean.toString(v));\n-        }).orElseGet(Map::of);\n+        Map<String, String> map = new HashMap<>();\n+        shortcut().ifPresent(shortcut -> {\n+            shortcut.store(SHORTCUT_ID, map::put);\n+        });\n+        return map;\n@@ -55,0 +58,2 @@\n+\n+    public static final String SHORTCUT_ID = \"linux-shortcut\";\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/model\/LinuxLauncher.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-     * Gets the start menu shortcut setting of this application launcher.\n+     * Gets the start menu shortcut of this application launcher.\n@@ -37,8 +37,4 @@\n-     * Returns <code>true<\/code> if this application launcher was requested to have\n-     * the start menu shortcut.\n-     * <p>\n-     * Returns <code>false<\/code> if this application launcher was requested not to\n-     * have the start menu shortcut.\n-     * <p>\n-     * Returns an empty {@link Optional} instance if there was no request about the\n-     * start menu shortcut for this application launcher.\n+     * Returns a non-empty {@link Optional} instance if a request about the start\n+     * menu shortcut for this application launcher was made and an empty\n+     * {@link Optional} instance if there was no request about the start menu\n+     * shortcut for this application launcher.\n@@ -46,1 +42,1 @@\n-     * @return the start menu shortcut setting of this application launcher\n+     * @return the start menu shortcut of this application launcher\n@@ -48,1 +44,1 @@\n-    Optional<Boolean> shortcut();\n+    Optional<LauncherShortcut> shortcut();\n@@ -53,1 +49,1 @@\n-    record Stub(Optional<Boolean> shortcut) implements LinuxLauncherMixin {\n+    record Stub(Optional<LauncherShortcut> shortcut) implements LinuxLauncherMixin {\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/model\/LinuxLauncherMixin.java","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -5,0 +5,1 @@\n+STARTUP_DIRECTORY\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/resources\/template.desktop","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,2 +39,0 @@\n-import static jdk.jpackage.internal.StandardBundlerParam.MENU_HINT;\n-import static jdk.jpackage.internal.StandardBundlerParam.SHORTCUT_HINT;\n@@ -138,1 +136,1 @@\n-            Arguments.putUnlessNull(bundleParams, SHORTCUT_HINT.getID(),\n+            Arguments.putUnlessNull(bundleParams, CLIOptions.WIN_SHORTCUT_HINT.getId(),\n@@ -140,1 +138,1 @@\n-            Arguments.putUnlessNull(bundleParams, MENU_HINT.getID(),\n+            Arguments.putUnlessNull(bundleParams, CLIOptions.WIN_MENU_HINT.getId(),\n@@ -147,1 +145,1 @@\n-            Arguments.putUnlessNull(bundleParams, SHORTCUT_HINT.getID(),\n+            Arguments.putUnlessNull(bundleParams, CLIOptions.LINUX_SHORTCUT_HINT.getId(),\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AddLauncherArguments.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.Objects;\n@@ -351,3 +352,2 @@\n-        WIN_MENU_HINT (\"win-menu\", OptionCategories.PLATFORM_WIN, () -> {\n-            setOptionValue(\"win-menu\", true);\n-        }),\n+        WIN_MENU_HINT (\"win-menu\", OptionCategories.PLATFORM_WIN,\n+                createArgumentWithOptionalValueAction(\"win-menu\")),\n@@ -357,4 +357,2 @@\n-        WIN_SHORTCUT_HINT (\"win-shortcut\",\n-                OptionCategories.PLATFORM_WIN, () -> {\n-            setOptionValue(\"win-shortcut\", true);\n-        }),\n+        WIN_SHORTCUT_HINT (\"win-shortcut\", OptionCategories.PLATFORM_WIN,\n+                createArgumentWithOptionalValueAction(\"win-shortcut\")),\n@@ -399,4 +397,2 @@\n-        LINUX_SHORTCUT_HINT (\"linux-shortcut\",\n-                OptionCategories.PLATFORM_LINUX, () -> {\n-            setOptionValue(\"linux-shortcut\", true);\n-        }),\n+        LINUX_SHORTCUT_HINT (\"linux-shortcut\", OptionCategories.PLATFORM_LINUX,\n+                createArgumentWithOptionalValueAction(\"linux-shortcut\")),\n@@ -481,0 +477,5 @@\n+        private static void prevArg() {\n+            Objects.checkIndex(context().pos, context().argList.size());\n+            context().pos--;\n+        }\n+\n@@ -484,0 +485,18 @@\n+\n+        private static Runnable createArgumentWithOptionalValueAction(String option) {\n+            Objects.requireNonNull(option);\n+            return () -> {\n+                nextArg();\n+                if (hasNextArg()) {\n+                    var value = getArg();\n+                    if (value.startsWith(\"-\")) {\n+                        prevArg();\n+                        setOptionValue(option, true);\n+                    } else {\n+                        setOptionValue(option, value);\n+                    }\n+                } else {\n+                    setOptionValue(option, true);\n+                }\n+            };\n+        }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Arguments.java","additions":30,"deletions":11,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import static jdk.jpackage.internal.Arguments.CLIOptions.LINUX_SHORTCUT_HINT;\n+import static jdk.jpackage.internal.Arguments.CLIOptions.WIN_MENU_HINT;\n+import static jdk.jpackage.internal.Arguments.CLIOptions.WIN_SHORTCUT_HINT;\n@@ -52,0 +55,1 @@\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n@@ -66,0 +70,2 @@\n+import jdk.jpackage.internal.model.LauncherShortcut;\n+import jdk.jpackage.internal.model.LauncherShortcutStartupDirectory;\n@@ -67,0 +73,1 @@\n+import jdk.jpackage.internal.model.ParseUtils;\n@@ -168,0 +175,28 @@\n+    static Optional<LauncherShortcut> findLauncherShortcut(\n+            BundlerParamInfo<String> shortcutParam,\n+            Map<String, ? super Object> mainParams,\n+            Map<String, ? super Object> launcherParams) {\n+\n+        Optional<String> launcherValue;\n+        if (launcherParams == mainParams) {\n+            \/\/ The main launcher\n+            launcherValue = Optional.empty();\n+        } else {\n+            launcherValue = shortcutParam.findIn(launcherParams);\n+        }\n+\n+        return launcherValue.map(ParseUtils::parseLauncherShortcutForAddLauncher).or(() -> {\n+            return Optional.ofNullable(mainParams.get(shortcutParam.getID())).map(toFunction(value -> {\n+                if (value instanceof Boolean) {\n+                    return new LauncherShortcut(LauncherShortcutStartupDirectory.DEFAULT);\n+                } else {\n+                    try {\n+                        return ParseUtils.parseLauncherShortcutForMainLauncher((String)value);\n+                    } catch (IllegalArgumentException ex) {\n+                        throw I18N.buildConfigException(\"error.invalid-option-value\", value, \"--\" + shortcutParam.getID()).create();\n+                    }\n+                }\n+            }));\n+        });\n+    }\n+\n@@ -198,2 +233,3 @@\n-        return AddLauncherArguments.merge(mainParams, launcherParams, ICON.getID(), ADD_LAUNCHERS\n-                .getID(), FILE_ASSOCIATIONS.getID());\n+        return AddLauncherArguments.merge(mainParams, launcherParams, ICON.getID(),\n+                ADD_LAUNCHERS.getID(), FILE_ASSOCIATIONS.getID(), WIN_MENU_HINT.getId(),\n+                WIN_SHORTCUT_HINT.getId(), LINUX_SHORTCUT_HINT.getId());\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/FromParams.java","additions":38,"deletions":2,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -310,18 +310,0 @@\n-    static final BundlerParamInfo<Boolean> SHORTCUT_HINT  =\n-            new BundlerParamInfo<>(\n-                    \"shortcut-hint\", \/\/ not directly related to a CLI option\n-                    Boolean.class,\n-                    params -> true,  \/\/ defaults to true\n-                    (s, p) -> (s == null || \"null\".equalsIgnoreCase(s)) ?\n-                            true : Boolean.valueOf(s)\n-            );\n-\n-    static final BundlerParamInfo<Boolean> MENU_HINT  =\n-            new BundlerParamInfo<>(\n-                    \"menu-hint\", \/\/ not directly related to a CLI option\n-                    Boolean.class,\n-                    params -> true,  \/\/ defaults to true\n-                    (s, p) -> (s == null || \"null\".equalsIgnoreCase(s)) ?\n-                            true : Boolean.valueOf(s)\n-            );\n-\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/StandardBundlerParam.java","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.BiConsumer;\n+\n+\/**\n+ * A shortcut to launch an application launcher.\n+ *\/\n+public record LauncherShortcut(Optional<LauncherShortcutStartupDirectory> startupDirectory) {\n+\n+    public LauncherShortcut {\n+        Objects.requireNonNull(startupDirectory);\n+    }\n+\n+    public LauncherShortcut(LauncherShortcutStartupDirectory startupDirectory) {\n+        this(Optional.of(startupDirectory));\n+    }\n+\n+    public LauncherShortcut() {\n+        this(Optional.empty());\n+    }\n+\n+    void store(String propertyName, BiConsumer<String, String> sink) {\n+        Objects.requireNonNull(propertyName);\n+        Objects.requireNonNull(sink);\n+        if (startupDirectory.isEmpty()) {\n+            sink.accept(propertyName, Boolean.FALSE.toString());\n+        } else {\n+            startupDirectory.ifPresent(v -> {\n+                sink.accept(propertyName, v.asStringValue());\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Converts the given shortcut into a shortcut request.\n+     * <p>\n+     * Returns <code>true<\/code> if shortcut was explicitly requested.\n+     * <p>\n+     * Returns <code>false<\/code> if no shortcut was explicitly requested.\n+     * <p>\n+     * Returns an empty {@link Optional} instance if there was no shortcut request.\n+     *\n+     * @return shortcut request\n+     *\/\n+    public static Optional<Boolean> toRequest(Optional<LauncherShortcut> shortcut) {\n+        return shortcut.map(v -> v.startupDirectory().isPresent());\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/LauncherShortcut.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.util.Objects;\n+\n+\/**\n+ * The directory in which to run an application launcher when it is started from\n+ * a shortcut.\n+ *\/\n+public enum LauncherShortcutStartupDirectory {\n+\n+    \/**\n+     * Platform-specific default value.\n+     * <p>\n+     * On Windows, it indicates that the startup directory should be the package's\n+     * installation directory.\n+     * <p>\n+     * On Linux, it indicates that a shortcut doesn't have the startup directory\n+     * configured explicitly.\n+     *\/\n+    DEFAULT(\"true\"),\n+\n+    \/**\n+     * The 'app' directory in the installed application app image. This is the\n+     * directory that is referenced with {@link ApplicationLayout#appDirectory()}\n+     * method.\n+     *\/\n+    APP_DIR(\"app-dir\");\n+\n+    LauncherShortcutStartupDirectory(String stringValue) {\n+        this.stringValue = Objects.requireNonNull(stringValue);\n+    }\n+\n+    public String asStringValue() {\n+        return stringValue;\n+    }\n+\n+    private final String stringValue;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/LauncherShortcutStartupDirectory.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Collection of functions to create instances of types defined in this package from strings.\n+ *\/\n+public final class ParseUtils {\n+\n+    private ParseUtils() {\n+    }\n+\n+    public static LauncherShortcut parseLauncherShortcutForMainLauncher(String str) {\n+        return parse(str, LauncherShortcutStartupDirectory.APP_DIR).map(LauncherShortcut::new).orElseThrow(IllegalArgumentException::new);\n+    }\n+\n+    public static LauncherShortcut parseLauncherShortcutForAddLauncher(String str) {\n+        return parse(str, LauncherShortcutStartupDirectory.values()).map(LauncherShortcut::new).orElseGet(() -> {\n+            if (Boolean.valueOf(str)) {\n+                return new LauncherShortcut(LauncherShortcutStartupDirectory.DEFAULT);\n+            } else {\n+                return new LauncherShortcut();\n+            }\n+        });\n+    }\n+\n+    private static Optional<LauncherShortcutStartupDirectory> parse(String str, LauncherShortcutStartupDirectory... recognizedValues) {\n+        Objects.requireNonNull(str);\n+        return Stream.of(recognizedValues).filter(v -> {\n+            return str.equals(v.asStringValue());\n+        }).findFirst();\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/ParseUtils.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -85,0 +85,2 @@\n+error.invalid-option-value=Invalid value \"{0}\" of option {1}\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/MainResources.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import static java.util.stream.Collectors.toSet;\n@@ -34,1 +33,1 @@\n-import static jdk.jpackage.internal.StandardBundlerParam.MENU_HINT;\n+import static jdk.jpackage.internal.FromParams.findLauncherShortcut;\n@@ -36,1 +35,0 @@\n-import static jdk.jpackage.internal.StandardBundlerParam.SHORTCUT_HINT;\n@@ -39,2 +37,0 @@\n-import static jdk.jpackage.internal.model.WinLauncherMixin.WinShortcut.WIN_SHORTCUT_DESKTOP;\n-import static jdk.jpackage.internal.model.WinLauncherMixin.WinShortcut.WIN_SHORTCUT_START_MENU;\n@@ -44,1 +40,0 @@\n-import java.util.List;\n@@ -66,3 +61,1 @@\n-            final var shortcuts = Map.of(WIN_SHORTCUT_DESKTOP, List.of(SHORTCUT_HINT,\n-                WIN_SHORTCUT_HINT), WIN_SHORTCUT_START_MENU, List.of(MENU_HINT,\n-                        WIN_MENU_HINT)).entrySet().stream().filter(e -> {\n+            final var startMenuShortcut = findLauncherShortcut(WIN_MENU_HINT, params, launcherParams);\n@@ -70,1 +63,1 @@\n-                    final var shortcutParams = e.getValue();\n+            final var desktopShortcut = findLauncherShortcut(WIN_SHORTCUT_HINT, params, launcherParams);\n@@ -72,6 +65,1 @@\n-                    return shortcutParams.get(0).findIn(launcherParams).orElseGet(() -> {\n-                        return shortcutParams.get(1).findIn(launcherParams).orElse(false);\n-                    });\n-                }).map(Map.Entry::getKey).collect(toSet());\n-\n-            return WinLauncher.create(launcher, new WinLauncherMixin.Stub(isConsole, shortcuts));\n+            return WinLauncher.create(launcher, new WinLauncherMixin.Stub(isConsole, startMenuShortcut, desktopShortcut));\n@@ -120,1 +108,1 @@\n-    private static final BundlerParamInfo<Boolean> WIN_MENU_HINT = createBooleanBundlerParam(\n+    private static final BundlerParamInfo<String> WIN_MENU_HINT = createStringBundlerParam(\n@@ -123,1 +111,1 @@\n-    private static final BundlerParamInfo<Boolean> WIN_SHORTCUT_HINT = createBooleanBundlerParam(\n+    private static final BundlerParamInfo<String> WIN_SHORTCUT_HINT = createStringBundlerParam(\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinFromParams.java","additions":6,"deletions":18,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -28,6 +28,3 @@\n-import jdk.jpackage.internal.model.WinLauncher;\n-import jdk.jpackage.internal.model.WinMsiPackage;\n-import jdk.jpackage.internal.model.Launcher;\n-import jdk.jpackage.internal.model.DottedVersion;\n-import jdk.jpackage.internal.model.ApplicationLayout;\n-import jdk.jpackage.internal.util.PathGroup;\n+import static java.util.stream.Collectors.toMap;\n+import static jdk.jpackage.internal.util.CollectionUtils.toCollection;\n+\n@@ -53,1 +50,0 @@\n-import static java.util.stream.Collectors.toMap;\n@@ -63,2 +59,0 @@\n-import static jdk.jpackage.internal.util.CollectionUtils.toCollection;\n-import jdk.jpackage.internal.model.WinLauncherMixin.WinShortcut;\n@@ -67,0 +61,2 @@\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.model.DottedVersion;\n@@ -68,0 +64,5 @@\n+import jdk.jpackage.internal.model.Launcher;\n+import jdk.jpackage.internal.model.LauncherShortcut;\n+import jdk.jpackage.internal.model.WinLauncher;\n+import jdk.jpackage.internal.model.WinMsiPackage;\n+import jdk.jpackage.internal.util.PathGroup;\n@@ -69,1 +70,0 @@\n-import jdk.jpackage.internal.util.XmlUtils;\n@@ -71,1 +71,1 @@\n-import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+import jdk.jpackage.internal.util.XmlUtils;\n@@ -355,1 +355,1 @@\n-    };\n+    }\n@@ -472,1 +472,15 @@\n-                    String componentId = addShortcutComponent(xml, launcherPath, folder);\n+                    var workDirectory = folder.shortcut(launcher).startupDirectory().map(v -> {\n+                        switch (v) {\n+                            case DEFAULT -> {\n+                                return INSTALLDIR;\n+                            }\n+                            case APP_DIR -> {\n+                                return installedAppImage.appDirectory();\n+                            }\n+                            default -> {\n+                                throw new AssertionError();\n+                            }\n+                        }\n+                    }).orElseThrow();\n+\n+                    String componentId = addShortcutComponent(xml, launcherPath, folder, workDirectory);\n@@ -502,1 +516,1 @@\n-            ShortcutsFolder folder) throws XMLStreamException, IOException {\n+            ShortcutsFolder folder, Path shortcutWorkDir) throws XMLStreamException, IOException {\n@@ -509,0 +523,4 @@\n+        if (!INSTALLDIR.equals(shortcutWorkDir.getName(0))) {\n+            throw throwInvalidPathException(shortcutWorkDir);\n+        }\n+\n@@ -515,1 +533,1 @@\n-            xml.writeAttribute(\"WorkingDirectory\", INSTALLDIR.toString());\n+            xml.writeAttribute(\"WorkingDirectory\", Id.Folder.of(shortcutWorkDir));\n@@ -517,2 +535,1 @@\n-            xml.writeAttribute(\"Target\", String.format(\"[#%s]\",\n-                    Component.File.idOf(launcherPath)));\n+            xml.writeAttribute(\"Target\", String.format(\"[#%s]\", Id.File.of(launcherPath)));\n@@ -909,1 +926,1 @@\n-        ProgramMenu(PROGRAM_MENU_PATH, WinShortcut.WIN_SHORTCUT_START_MENU,\n+        ProgramMenu(PROGRAM_MENU_PATH, WinLauncher::startMenuShortcut,\n@@ -911,1 +928,1 @@\n-        Desktop(DESKTOP_PATH, WinShortcut.WIN_SHORTCUT_DESKTOP,\n+        Desktop(DESKTOP_PATH, WinLauncher::desktopShortcut,\n@@ -914,1 +931,1 @@\n-        private ShortcutsFolder(Path root, WinShortcut shortcutId,\n+        private ShortcutsFolder(Path root, Function<WinLauncher, Optional<LauncherShortcut>> shortcut,\n@@ -917,1 +934,1 @@\n-            this.shortcutId = shortcutId;\n+            this.shortcut = shortcut;\n@@ -930,1 +947,5 @@\n-            return launcher.shortcuts().contains(shortcutId);\n+            return LauncherShortcut.toRequest(shortcut.apply(launcher)).orElse(false);\n+        }\n+\n+        LauncherShortcut shortcut(WinLauncher launcher) {\n+            return shortcut.apply(launcher).orElseThrow();\n@@ -950,1 +971,1 @@\n-        private final WinShortcut shortcutId;\n+        private final Function<WinLauncher, Optional<LauncherShortcut>> shortcut;\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixAppImageFragmentBuilder.java","additions":44,"deletions":23,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-            String fname = \"wixhelper.dll\"; \/\/ CA dll\n+            String fname = \"msica.dll\"; \/\/ CA dll\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixUiFragmentBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import static java.util.stream.Collectors.toMap;\n-\n@@ -30,0 +28,1 @@\n+import java.util.HashMap;\n@@ -50,1 +49,8 @@\n-        return shortcuts().stream().collect(toMap(WinShortcut::name, v -> Boolean.toString(true)));\n+        Map<String, String> map = new HashMap<>();\n+        desktopShortcut().ifPresent(shortcut -> {\n+            shortcut.store(SHORTCUT_DESKTOP_ID, map::put);\n+        });\n+        startMenuShortcut().ifPresent(shortcut -> {\n+            shortcut.store(SHORTCUT_START_MENU_ID, map::put);\n+        });\n+        return map;\n@@ -56,0 +62,3 @@\n+\n+    public static final String SHORTCUT_START_MENU_ID = \"win-menu\";\n+    public static final String SHORTCUT_DESKTOP_ID = \"win-shortcut\";\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/model\/WinLauncher.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.util.Set;\n+import java.util.Optional;\n@@ -33,19 +33,26 @@\n-    enum WinShortcut {\n-        WIN_SHORTCUT_DESKTOP(\"shortcut\"),\n-        WIN_SHORTCUT_START_MENU(\"menu\"),\n-        ;\n-\n-        WinShortcut(String name) {\n-            this.name = name;\n-        }\n-\n-        public String getName() {\n-            return name;\n-        }\n-\n-        private final String name;\n-    }\n-\n-    Set<WinShortcut> shortcuts();\n-\n-    record Stub(boolean isConsole, Set<WinShortcut> shortcuts) implements WinLauncherMixin {\n+    \/**\n+     * Gets the start menu shortcut of this application launcher.\n+     * <p>\n+     * Returns a non-empty {@link Optional} instance if a request about the start\n+     * menu shortcut for this application launcher was made and an empty\n+     * {@link Optional} instance if there was no request about the start menu\n+     * shortcut for this application launcher.\n+     *\n+     * @return the start menu shortcut of this application launcher\n+     *\/\n+    Optional<LauncherShortcut> startMenuShortcut();\n+\n+    \/**\n+     * Gets the desktop shortcut of this application launcher.\n+     * <p>\n+     * Returns a non-empty {@link Optional} instance if a request about the desktop\n+     * shortcut for this application launcher was made and an empty {@link Optional}\n+     * instance if there was no request about the desktop shortcut for this\n+     * application launcher.\n+     *\n+     * @return the start menu shortcut of this application launcher\n+     *\/\n+    Optional<LauncherShortcut> desktopShortcut();\n+\n+    record Stub(boolean isConsole, Optional<LauncherShortcut> startMenuShortcut,\n+            Optional<LauncherShortcut> desktopShortcut) implements WinLauncherMixin {\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/model\/WinLauncherMixin.java","additions":27,"deletions":20,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-    <Binary Id=\"JpCaDll\" SourceFile=\"wixhelper.dll\"\/>\n+    <Binary Id=\"JpCaDll\" SourceFile=\"msica.dll\"\/>\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/main.wxs","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"","filename":"src\/jdk.jpackage\/windows\/native\/libmsica\/Version.cpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.jpackage\/windows\/native\/libwixhelper\/Version.cpp","status":"renamed"},{"patch":"","filename":"src\/jdk.jpackage\/windows\/native\/libmsica\/Version.h","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.jpackage\/windows\/native\/libwixhelper\/Version.h","status":"renamed"},{"patch":"","filename":"src\/jdk.jpackage\/windows\/native\/libmsica\/libmsica.cpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.jpackage\/windows\/native\/libwixhelper\/libwixhelper.cpp","status":"renamed"},{"patch":"@@ -1,364 +0,0 @@\n-\/*\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"memory\/resourceArea.hpp\"\n-#include \"nmt\/nmtTreap.hpp\"\n-#include \"nmt\/virtualMemoryTracker.hpp\"\n-#include \"runtime\/os.hpp\"\n-#include \"unittest.hpp\"\n-class NMTTreapTest : public testing::Test {\n-public:\n-  struct Cmp {\n-    static int cmp(int a, int b) {\n-      return a - b;\n-    }\n-  };\n-\n-  struct CmpInverse {\n-    static int cmp(int a, int b) {\n-      return b - a;\n-    }\n-  };\n-\n-  struct FCmp {\n-    static int cmp(float a, float b) {\n-      if (a < b) return -1;\n-      if (a == b) return 0;\n-      return 1;\n-    }\n-  };\n-\n-#ifdef ASSERT\n-  template<typename K, typename V, typename CMP, typename ALLOC>\n-  void verify_it(Treap<K, V, CMP, ALLOC>& t) {\n-    t.verify_self();\n-  }\n-#endif \/\/ ASSERT\n-\n-public:\n-  void inserting_duplicates_results_in_one_value() {\n-    constexpr const int up_to = 10;\n-    GrowableArrayCHeap<int, mtTest> nums_seen(up_to, up_to, 0);\n-    TreapCHeap<int, int, Cmp> treap;\n-\n-    for (int i = 0; i < up_to; i++) {\n-      treap.upsert(i, i);\n-      treap.upsert(i, i);\n-      treap.upsert(i, i);\n-      treap.upsert(i, i);\n-      treap.upsert(i, i);\n-    }\n-\n-    treap.visit_in_order([&](TreapCHeap<int, int, Cmp>::TreapNode* node) {\n-      nums_seen.at(node->key())++;\n-      return true;\n-    });\n-    for (int i = 0; i < up_to; i++) {\n-      EXPECT_EQ(1, nums_seen.at(i));\n-    }\n-  }\n-\n-  void treap_ought_not_leak() {\n-    struct LeakCheckedAllocator {\n-      int allocations;\n-\n-      LeakCheckedAllocator()\n-        : allocations(0) {\n-      }\n-\n-      void* allocate(size_t sz) {\n-        void* allocation = os::malloc(sz, mtTest);\n-        if (allocation == nullptr) {\n-          vm_exit_out_of_memory(sz, OOM_MALLOC_ERROR, \"treap failed allocation\");\n-        }\n-        ++allocations;\n-        return allocation;\n-      }\n-\n-      void free(void* ptr) {\n-        --allocations;\n-        os::free(ptr);\n-      }\n-    };\n-\n-    constexpr const int up_to = 10;\n-    {\n-      Treap<int, int, Cmp, LeakCheckedAllocator> treap;\n-      for (int i = 0; i < up_to; i++) {\n-        treap.upsert(i, i);\n-      }\n-      EXPECT_EQ(up_to, treap._allocator.allocations);\n-      for (int i = 0; i < up_to; i++) {\n-        treap.remove(i);\n-      }\n-      EXPECT_EQ(0, treap._allocator.allocations);\n-      EXPECT_EQ(nullptr, treap._root);\n-    }\n-\n-    {\n-      Treap<int, int, Cmp, LeakCheckedAllocator> treap;\n-      for (int i = 0; i < up_to; i++) {\n-        treap.upsert(i, i);\n-      }\n-      treap.remove_all();\n-      EXPECT_EQ(0, treap._allocator.allocations);\n-      EXPECT_EQ(nullptr, treap._root);\n-    }\n-  }\n-\n-  void test_find() {\n-    struct Empty {};\n-    TreapCHeap<float, Empty, FCmp> treap;\n-    using Node = TreapCHeap<float, Empty, FCmp>::TreapNode;\n-\n-    Node* n = nullptr;\n-    auto test = [&](float f) {\n-      EXPECT_EQ(nullptr, treap.find(treap._root, f));\n-      treap.upsert(f, Empty{});\n-      Node* n = treap.find(treap._root, f);\n-      EXPECT_NE(nullptr, n);\n-      EXPECT_EQ(f, n->key());\n-    };\n-\n-    test(1.0f);\n-    test(5.0f);\n-    test(0.0f);\n-  }\n-};\n-\n-TEST_VM_F(NMTTreapTest, InsertingDuplicatesResultsInOneValue) {\n-  this->inserting_duplicates_results_in_one_value();\n-}\n-\n-TEST_VM_F(NMTTreapTest, TreapOughtNotLeak) {\n-  this->treap_ought_not_leak();\n-}\n-\n-TEST_VM_F(NMTTreapTest, TestVisitors) {\n-  { \/\/ Tests with 'default' ordering (ascending)\n-    TreapCHeap<int, int, Cmp> treap;\n-    using Node = TreapCHeap<int, int, Cmp>::TreapNode;\n-\n-    treap.visit_range_in_order(0, 100, [&](Node* x) {\n-      EXPECT_TRUE(false) << \"Empty treap has no nodes to visit\";\n-      return true;\n-    });\n-\n-    \/\/ Single-element set\n-    treap.upsert(1, 0);\n-    int count = 0;\n-    treap.visit_range_in_order(0, 100, [&](Node* x) {\n-      count++;\n-      return true;\n-    });\n-    EXPECT_EQ(1, count);\n-\n-    count = 0;\n-    treap.visit_in_order([&](Node* x) {\n-      count++;\n-      return true;\n-    });\n-    EXPECT_EQ(1, count);\n-\n-    \/\/ Add an element outside of the range that should not be visited on the right side and\n-    \/\/ one on the left side.\n-    treap.upsert(101, 0);\n-    treap.upsert(-1, 0);\n-    count = 0;\n-    treap.visit_range_in_order(0, 100, [&](Node* x) {\n-      count++;\n-      return true;\n-    });\n-    EXPECT_EQ(1, count);\n-\n-    count = 0;\n-    treap.visit_in_order([&](Node* x) {\n-      count++;\n-      return true;\n-    });\n-    EXPECT_EQ(3, count);\n-\n-    \/\/ Visiting empty range [0, 0) == {}\n-    treap.upsert(0, 0); \/\/ This node should not be visited.\n-    treap.visit_range_in_order(0, 0, [&](Node* x) {\n-      EXPECT_TRUE(false) << \"Empty visiting range should not visit any node\";\n-      return true;\n-    });\n-\n-    treap.remove_all();\n-    for (int i = 0; i < 11; i++) {\n-      treap.upsert(i, 0);\n-    }\n-\n-    ResourceMark rm;\n-    GrowableArray<int> seen;\n-    treap.visit_range_in_order(0, 10, [&](Node* x) {\n-      seen.push(x->key());\n-      return true;\n-    });\n-    EXPECT_EQ(10, seen.length());\n-    for (int i = 0; i < 10; i++) {\n-      EXPECT_EQ(i, seen.at(i));\n-    }\n-\n-    seen.clear();\n-    treap.visit_in_order([&](Node* x) {\n-      seen.push(x->key());\n-      return true;\n-    });\n-    EXPECT_EQ(11, seen.length());\n-    for (int i = 0; i < 10; i++) {\n-      EXPECT_EQ(i, seen.at(i));\n-    }\n-\n-    seen.clear();\n-    treap.visit_range_in_order(10, 12, [&](Node* x) {\n-      seen.push(x->key());\n-      return true;\n-    });\n-    EXPECT_EQ(1, seen.length());\n-    EXPECT_EQ(10, seen.at(0));\n-  }\n-  { \/\/ Test with descending ordering\n-    TreapCHeap<int, int, CmpInverse> treap;\n-    using Node = TreapCHeap<int, int, CmpInverse>::TreapNode;\n-\n-    for (int i = 0; i < 10; i++) {\n-      treap.upsert(i, 0);\n-    }\n-    ResourceMark rm;\n-    GrowableArray<int> seen;\n-    treap.visit_range_in_order(9, -1, [&](Node* x) {\n-      seen.push(x->key());\n-      return true;\n-    });\n-    EXPECT_EQ(10, seen.length());\n-    for (int i = 0; i < 10; i++) {\n-      EXPECT_EQ(10-i-1, seen.at(i));\n-    }\n-    seen.clear();\n-\n-    treap.visit_in_order([&](Node* x) {\n-      seen.push(x->key());\n-      return true;\n-    });\n-    EXPECT_EQ(10, seen.length());\n-    for (int i = 0; i < 10; i++) {\n-      EXPECT_EQ(10 - i - 1, seen.at(i));\n-    }\n-  }\n-}\n-\n-TEST_VM_F(NMTTreapTest, TestFind) {\n-  test_find();\n-}\n-\n-TEST_VM_F(NMTTreapTest, TestClosestLeq) {\n-  using Node = TreapCHeap<int, int, Cmp>::TreapNode;\n-  {\n-    TreapCHeap<int, int, Cmp> treap;\n-    Node* n = treap.closest_leq(0);\n-    EXPECT_EQ(nullptr, n);\n-\n-    treap.upsert(0, 0);\n-    n = treap.closest_leq(0);\n-    EXPECT_EQ(0, n->key());\n-\n-    treap.upsert(-1, -1);\n-    n = treap.closest_leq(0);\n-    EXPECT_EQ(0, n->key());\n-\n-    treap.upsert(6, 0);\n-    n = treap.closest_leq(6);\n-    EXPECT_EQ(6, n->key());\n-\n-    n = treap.closest_leq(-2);\n-    EXPECT_EQ(nullptr, n);\n-  }\n-}\n-\n-#ifdef ASSERT\n-\n-TEST_VM_F(NMTTreapTest, VerifyItThroughStressTest) {\n-  { \/\/ Repeatedly verify a treap of moderate size\n-    TreapCHeap<int, int, Cmp> treap;\n-    constexpr const int ten_thousand = 10000;\n-    for (int i = 0; i < ten_thousand; i++) {\n-      int r = os::random();\n-      if (r % 2 == 0) {\n-        treap.upsert(i, i);\n-      } else {\n-        treap.remove(i);\n-      }\n-      if (i % 100 == 0) {\n-        verify_it(treap);\n-      }\n-    }\n-    for (int i = 0; i < ten_thousand; i++) {\n-      int r = os::random();\n-      if (r % 2 == 0) {\n-        treap.upsert(i, i);\n-      } else {\n-        treap.remove(i);\n-      }\n-      if (i % 100 == 0) {\n-        verify_it(treap);\n-      }\n-    }\n-  }\n-  { \/\/ Make a very large treap and verify at the end\n-  struct Nothing {};\n-    TreapCHeap<int, Nothing, Cmp> treap;\n-    constexpr const int one_hundred_thousand = 100000;\n-    for (int i = 0; i < one_hundred_thousand; i++) {\n-      treap.upsert(i, Nothing());\n-    }\n-    verify_it(treap);\n-  }\n-}\n-struct NTD {\n-  static bool has_run_destructor;\n-  ~NTD() {\n-    has_run_destructor = true;\n-  }\n-};\n-\n-bool NTD::has_run_destructor = false;\n-\n-TEST_VM_F(NMTTreapTest, ValueDestructorsAreRun) {\n-  TreapCHeap<int, NTD, Cmp> treap;\n-  NTD ntd;\n-  treap.upsert(0, ntd);\n-  treap.remove(0);\n-  EXPECT_TRUE(NTD::has_run_destructor);\n-  NTD::has_run_destructor = false;\n-  {\n-    TreapCHeap<int, NTD, Cmp> treap;\n-    NTD ntd;\n-    treap.upsert(0, ntd);\n-  }\n-  EXPECT_TRUE(NTD::has_run_destructor);\n-}\n-\n-#endif \/\/ ASSERT\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_treap.cpp","additions":0,"deletions":364,"binary":false,"changes":364,"status":"deleted"},{"patch":"@@ -34,1 +34,1 @@\n-using TNode = Tree::TreapNode;\n+using TNode = Tree::TNode;\n@@ -57,2 +57,2 @@\n-  VMATree::TreapNode* treap_root(VMATree& tree) {\n-    return tree._tree._root;\n+  VMATree::TNode* rbtree_root(VMATree& tree) {\n+    return static_cast<VMATree::TNode*>(tree._tree._root);\n@@ -61,1 +61,1 @@\n-  VMATree::VMATreap& treap(VMATree& tree) {\n+  VMATree::VMARBTree& rbtree(VMATree& tree) {\n@@ -65,2 +65,2 @@\n-  VMATree::TreapNode* find(VMATree::VMATreap& treap, const VMATree::position key) {\n-    return treap.find(treap._root, key);\n+  VMATree::TNode* find(VMATree::VMARBTree& rbtree, const VMATree::position key) {\n+    return rbtree.find_node(key);\n@@ -74,1 +74,1 @@\n-  VMATree::StateType in_type_of(VMATree::TreapNode* x) {\n+  VMATree::StateType in_type_of(VMATree::TNode* x) {\n@@ -78,1 +78,1 @@\n-  VMATree::StateType out_type_of(VMATree::TreapNode* x) {\n+  VMATree::StateType out_type_of(VMATree::TNode* x) {\n@@ -84,1 +84,1 @@\n-    treap(tree).visit_in_order([&](TNode* x) {\n+    rbtree(tree).visit_in_order([&](TNode* x) {\n@@ -126,1 +126,1 @@\n-    EXPECT_EQ(nullptr, treap_root(tree));\n+    EXPECT_EQ(nullptr, rbtree_root(tree));\n@@ -133,1 +133,1 @@\n-    EXPECT_EQ(nullptr, treap_root(tree));\n+    EXPECT_EQ(nullptr, rbtree_root(tree));\n@@ -143,1 +143,1 @@\n-    treap(tree).visit_in_order([&](TNode* x) {\n+    rbtree(tree).visit_in_order([&](TNode* x) {\n@@ -169,1 +169,1 @@\n-    treap(tree).visit_in_order([&](TNode* x) {\n+    rbtree(tree).visit_in_order([&](TNode* x) {\n@@ -202,1 +202,1 @@\n-    VMATree::TreapNode n1{upd.req.A, {}, 0}, n2{upd.req.B, {}, 0};\n+    VMATree::TNode n1{upd.req.A, {}}, n2{upd.req.B, {}};\n@@ -267,1 +267,1 @@\n-    using Node = VMATree::TreapNode;\n+    using Node = VMATree::TNode;\n@@ -277,1 +277,1 @@\n-      VMATree::VMATreap::Range r = tree.tree().find_enclosing_range(et.nodes[i]);\n+      VMATree::VMARBTree::Range r = tree.tree().find_enclosing_range(et.nodes[i]);\n@@ -357,1 +357,1 @@\n-  VMATree::VMATreap::Range r = tree.tree().find_enclosing_range(110);\n+  VMATree::VMARBTree::Range r = tree.tree().find_enclosing_range(110);\n@@ -372,1 +372,1 @@\n-  tree.visit_in_order([&](TNode* node) {\n+  tree.visit_in_order([&](const TNode* node) {\n@@ -413,1 +413,1 @@\n-    treap(tree).visit_in_order([&](TNode* x) {\n+    rbtree(tree).visit_in_order([&](const TNode* x) {\n@@ -415,1 +415,1 @@\n-      if (x->key() == 0) {\n+      if (x->key() == 0UL) {\n@@ -441,1 +441,1 @@\n-    EXPECT_EQ(nullptr, treap_root(tree));\n+    EXPECT_EQ(nullptr, rbtree_root(tree));\n@@ -451,1 +451,1 @@\n-    treap(tree).visit_range_in_order(0, 99999, [&](TNode* x) {\n+    rbtree(tree).visit_range_in_order(0, 99999, [&](TNode* x) {\n@@ -466,1 +466,1 @@\n-    EXPECT_EQ(nullptr, treap_root(tree));\n+    EXPECT_EQ(nullptr, rbtree_root(tree));\n@@ -468,1 +468,1 @@\n-    EXPECT_EQ(nullptr, treap_root(tree));\n+    EXPECT_EQ(nullptr, rbtree_root(tree));\n@@ -486,1 +486,1 @@\n-    int len = sizeof(expected) \/ sizeof(testrange);\n+    size_t len = sizeof(expected) \/ sizeof(testrange);\n@@ -488,1 +488,1 @@\n-    for (int i = 0; i < len; i++) {\n+    for (size_t i = 0; i < len; i++) {\n@@ -493,1 +493,1 @@\n-      VMATree::VMATreap::Range found = tree.tree().find_enclosing_range(expect.from);\n+      VMATree::VMARBTree::Range found = tree.tree().find_enclosing_range(expect.from);\n@@ -996,2 +996,2 @@\n-        VMATree::VMATreap& treap = this->treap(tree);\n-        VMATree::TreapNode* startn = find(treap, start * page_size);\n+        VMATree::VMARBTree& rbtree = this->rbtree(tree);\n+        VMATree::TNode* startn = find(rbtree, start * page_size);\n@@ -999,1 +999,1 @@\n-        VMATree::TreapNode* endn = find(treap, (end * page_size) + page_size);\n+        VMATree::TNode* endn = find(rbtree, (end * page_size) + page_size);\n","filename":"test\/hotspot\/gtest\/nmt\/test_vmatree.cpp","additions":30,"deletions":30,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -46,1 +46,6 @@\n-    ReservedMemoryRegion rmr_found = VirtualMemoryTracker::Instance::tree()->find_reserved_region(stack_end);\n+    ReservedMemoryRegion rmr_found;\n+    {\n+      MemTracker::NmtVirtualMemoryLocker vml;\n+      rmr_found = VirtualMemoryTracker::Instance::tree()->find_reserved_region(stack_end);\n+    }\n+\n@@ -50,0 +55,1 @@\n+\n@@ -57,12 +63,14 @@\n-    VirtualMemoryTracker::Instance::tree()->visit_committed_regions(rmr_found, [&](const CommittedMemoryRegion& cmr) {\n-      if (cmr.base() + cmr.size() == stack_top) {\n-        EXPECT_TRUE(cmr.size() <= stack_size);\n-        found_stack_top = true;\n-      }\n-      if(i_addr < stack_top && i_addr >= cmr.base()) {\n-        found_i_addr = true;\n-      }\n-      i++;\n-      return true;\n-    });\n-\n+    {\n+      MemTracker::NmtVirtualMemoryLocker vml;\n+      VirtualMemoryTracker::Instance::tree()->visit_committed_regions(rmr_found, [&](const CommittedMemoryRegion& cmr) {\n+        if (cmr.base() + cmr.size() == stack_top) {\n+          EXPECT_TRUE(cmr.size() <= stack_size);\n+          found_stack_top = true;\n+        }\n+        if (i_addr < stack_top && i_addr >= cmr.base()) {\n+          found_i_addr = true;\n+        }\n+        i++;\n+        return true;\n+      });\n+    }\n","filename":"test\/hotspot\/gtest\/runtime\/test_committed_virtualmemory.cpp","additions":21,"deletions":13,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/hashTable.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -209,1 +209,1 @@\n-  ResourceHashtable<char*, unsigned> ht;\n+  HashTable<char*, unsigned> ht;\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_reserve_between.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-#define check(rmr, regions) check_inner((rmr), (regions), ARRAY_SIZE(regions), __FILE__, __LINE__)\n+#define check(vmt, rmr, regions) check_inner((vmt), (rmr), (regions), ARRAY_SIZE(regions), __FILE__, __LINE__)\n@@ -55,1 +55,1 @@\n-#define check_empty(rmr)                              \\\n+#define check_empty(vmt, rmr)                              \\\n@@ -57,1 +57,1 @@\n-    check_inner((rmr), nullptr, 0, __FILE__, __LINE__);  \\\n+    check_inner((vmt), (rmr), nullptr, 0, __FILE__, __LINE__);  \\\n@@ -60,1 +60,1 @@\n-static void diagnostic_print(const ReservedMemoryRegion& rmr) {\n+static void diagnostic_print(VirtualMemoryTracker& vmt, const ReservedMemoryRegion& rmr) {\n@@ -68,1 +68,1 @@\n-static void check_inner(const ReservedMemoryRegion& rmr, R* regions, size_t regions_size, const char* file, int line) {\n+static void check_inner(VirtualMemoryTracker& vmt, const ReservedMemoryRegion& rmr, R* regions, size_t regions_size, const char* file, int line) {\n@@ -73,1 +73,1 @@\n-  diagnostic_print(rmr);\n+  diagnostic_print(vmt, rmr);\n@@ -77,1 +77,1 @@\n-  VirtualMemoryTracker::Instance::tree()->visit_committed_regions(rmr, [&](CommittedMemoryRegion& region) {\n+  vmt.tree()->visit_committed_regions(rmr, [&](CommittedMemoryRegion& region) {\n@@ -87,1 +87,1 @@\n-  EXPECT_EQ(size, rmr.committed_size()) << WHERE;\n+  EXPECT_EQ(size, vmt.committed_size(&rmr)) << WHERE;\n@@ -93,0 +93,2 @@\n+    VirtualMemoryTracker vmt(true);\n+    RegionsTree* rtree = vmt.tree();\n@@ -94,1 +96,1 @@\n-    ReservedSpace rs = MemoryReserver::reserve(size, mtTest);\n+    const address addr = (address)0x0000A000;\n@@ -96,1 +98,1 @@\n-    address addr = (address)rs.base();\n+    vmt.add_reserved_region(addr, size, CALLER_PC, mtTest);\n@@ -105,3 +107,0 @@\n-    RegionsTree* rtree = VirtualMemoryTracker::Instance::tree();\n-    MemTracker::NmtVirtualMemoryLocker nvml;\n-\n@@ -121,1 +120,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -127,1 +126,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -133,1 +132,1 @@\n-      check(rmr, r);\n+      check(vmt,rmr, r);\n@@ -138,1 +137,1 @@\n-    ASSERT_EQ(rmr.committed_size(), 0u);\n+    ASSERT_EQ(vmt.committed_size(&rmr), 0u);\n@@ -146,1 +145,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -153,1 +152,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -161,1 +160,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -166,3 +165,1 @@\n-    ASSERT_EQ(rmr.committed_size(), 0u);\n-\n-    rtree->tree().remove_all();\n+    ASSERT_EQ(vmt.committed_size(&rmr), 0u);\n@@ -172,0 +169,2 @@\n+    VirtualMemoryTracker vmt(true);\n+    RegionsTree* rtree = vmt.tree();\n@@ -173,6 +172,1 @@\n-    ReservedSpace rs = MemoryReserver::reserve(size, mtTest);\n-\n-    RegionsTree* rtree = VirtualMemoryTracker::Instance::tree();\n-    MemTracker::NmtVirtualMemoryLocker nvml;\n-\n-    address addr = (address)rs.base();\n+    const address addr = (address)0x0000A000;\n@@ -180,0 +174,1 @@\n+    vmt.add_reserved_region(addr, size, CALLER_PC, mtTest);\n@@ -202,1 +197,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -208,1 +203,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -213,1 +208,1 @@\n-    ASSERT_EQ(rmr.committed_size(), 4 * cs);\n+    ASSERT_EQ(vmt.committed_size(&rmr), 4 * cs);\n@@ -218,1 +213,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -223,1 +218,1 @@\n-    ASSERT_EQ(rmr.committed_size(), 0u);\n+    ASSERT_EQ(vmt.committed_size(&rmr), 0u);\n@@ -233,1 +228,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -241,1 +236,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -247,1 +242,1 @@\n-    ASSERT_EQ(rmr.committed_size(), 4 * cs);\n+    ASSERT_EQ(vmt.committed_size(&rmr), 4 * cs);\n@@ -254,1 +249,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -261,0 +256,2 @@\n+    VirtualMemoryTracker vmt(true);\n+    RegionsTree* rtree = vmt.tree();\n@@ -262,4 +259,1 @@\n-    ReservedSpace rs = MemoryReserver::reserve(size, mtTest);\n-\n-    RegionsTree* rtree = VirtualMemoryTracker::Instance::tree();\n-    MemTracker::NmtVirtualMemoryLocker nvml;\n+    const address addr = (address)0x0000A000;\n@@ -267,1 +261,1 @@\n-    address addr = (address)rs.base();\n+    vmt.add_reserved_region(addr, size, CALLER_PC, mtTest);\n@@ -290,1 +284,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -296,1 +290,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -302,1 +296,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -308,1 +302,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -314,1 +308,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -320,1 +314,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -326,1 +320,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -332,1 +326,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -337,1 +331,1 @@\n-    ASSERT_EQ(rmr.committed_size(), 0u);\n+    ASSERT_EQ(vmt.committed_size(&rmr), 0u);\n@@ -348,1 +342,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -355,1 +349,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -362,1 +356,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -367,1 +361,1 @@\n-    ASSERT_EQ(rmr.committed_size(), 0u);\n+    ASSERT_EQ(vmt.committed_size(&rmr), 0u);\n@@ -374,1 +368,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -380,1 +374,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -387,1 +381,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -393,1 +387,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -400,1 +394,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -406,1 +400,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -412,1 +406,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -420,1 +414,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -438,0 +432,2 @@\n+    VirtualMemoryTracker vmt(true);\n+    RegionsTree* rtree = vmt.tree();\n@@ -439,6 +435,1 @@\n-    ReservedSpace rs = MemoryReserver::reserve(size, mtTest);\n-\n-    RegionsTree* rtree = VirtualMemoryTracker::Instance::tree();\n-    MemTracker::NmtVirtualMemoryLocker nvml;\n-\n-    address addr = (address)rs.base();\n+    const address addr = (address)0x0000A000;\n@@ -446,0 +437,1 @@\n+    vmt.add_reserved_region(addr, size, CALLER_PC, mtTest);\n@@ -464,1 +456,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -468,1 +460,1 @@\n-      check_empty(rmr);\n+      check_empty(vmt, rmr);\n@@ -480,1 +472,1 @@\n-        check(rmr, r);\n+        check(vmt, rmr, r);\n@@ -490,1 +482,1 @@\n-        check(rmr, r);\n+        check(vmt, rmr, r);\n@@ -500,1 +492,1 @@\n-        check(rmr, r);\n+        check(vmt, rmr, r);\n@@ -504,1 +496,1 @@\n-      check_empty(rmr);\n+      check_empty(vmt, rmr);\n@@ -510,1 +502,1 @@\n-      check_empty(rmr);\n+      check_empty(vmt, rmr);\n@@ -518,1 +510,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -521,1 +513,1 @@\n-      check_empty(rmr);\n+      check_empty(vmt, rmr);\n@@ -528,1 +520,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -531,1 +523,1 @@\n-      check_empty(rmr);\n+      check_empty(vmt, rmr);\n@@ -538,1 +530,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -541,1 +533,1 @@\n-      check_empty(rmr);\n+      check_empty(vmt, rmr);\n@@ -548,1 +540,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -551,1 +543,1 @@\n-      check_empty(rmr);\n+      check_empty(vmt, rmr);\n@@ -558,1 +550,1 @@\n-      check(rmr, r);\n+      check(vmt, rmr, r);\n@@ -561,1 +553,1 @@\n-      check_empty(rmr);\n+      check_empty(vmt, rmr);\n","filename":"test\/hotspot\/gtest\/runtime\/test_virtualMemoryTracker.cpp","additions":79,"deletions":87,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -0,0 +1,476 @@\n+\/*\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"nmt\/nmtCommon.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/symbolHandle.hpp\"\n+#include \"unittest.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n+\n+class CommonHashTableTest : public ::testing::Test {\n+ protected:\n+  typedef void* K;\n+  typedef uintx V;\n+  const static MemTag MEM_TAG = mtInternal;\n+\n+  static unsigned identity_hash(const K& k) {\n+    return (unsigned) (uintptr_t) k;\n+  }\n+\n+  static unsigned bad_hash(const K& k) {\n+    return 1;\n+  }\n+\n+  static void* as_K(uintptr_t val) {\n+    return (void*) val;\n+  }\n+\n+  class EqualityTestIter {\n+   public:\n+\n+    bool do_entry(K const& k, V const& v) {\n+      if ((uintptr_t) k != (uintptr_t) v) {\n+        EXPECT_EQ((uintptr_t) k, (uintptr_t) v);\n+        return false;\n+      } else {\n+        return true; \/\/ continue iteration\n+      }\n+    }\n+  };\n+\n+  class DeleterTestIter {\n+    int _val;\n+   public:\n+    DeleterTestIter(int i) : _val(i) {}\n+\n+    bool do_entry(K const& k, V const& v) {\n+      if ((uintptr_t) k == (uintptr_t) _val) {\n+        \/\/ Delete me!\n+        return true;\n+      } else {\n+        return false; \/\/ continue iteration\n+      }\n+    }\n+  };\n+\n+};\n+\n+class SmallHashTableTest : public CommonHashTableTest {\n+ protected:\n+\n+  template<\n+  unsigned (*HASH) (K const&) = primitive_hash<K>,\n+  bool (*EQUALS)(K const&, K const&) = primitive_equals<K>,\n+  unsigned SIZE = 256,\n+  AnyObj::allocation_type ALLOC_TYPE = AnyObj::RESOURCE_AREA\n+  >\n+  class Runner : public AllStatic {\n+   public:\n+\n+    static void test(V step) {\n+      EqualityTestIter et;\n+      HashTable<K, V, SIZE, ALLOC_TYPE, MEM_TAG, HASH, EQUALS> rh;\n+\n+      ASSERT_FALSE(rh.contains(as_K(step)));\n+\n+      ASSERT_TRUE(rh.put(as_K(step), step));\n+      ASSERT_TRUE(rh.contains(as_K(step)));\n+\n+      ASSERT_FALSE(rh.put(as_K(step), step));\n+\n+      ASSERT_TRUE(rh.put(as_K(2 * step), 2 * step));\n+      ASSERT_TRUE(rh.put(as_K(3 * step), 3 * step));\n+      ASSERT_TRUE(rh.put(as_K(4 * step), 4 * step));\n+      ASSERT_TRUE(rh.put(as_K(5 * step), 5 * step));\n+\n+      ASSERT_FALSE(rh.remove(as_K(0x0)));\n+\n+      rh.iterate(&et);\n+      if (::testing::Test::HasFailure()) {\n+        return;\n+      }\n+\n+      ASSERT_TRUE(rh.remove(as_K(step)));\n+      ASSERT_FALSE(rh.contains(as_K(step)));\n+      rh.iterate(&et);\n+\n+\n+      \/\/ Test put_if_absent(key) (creating a default-created value)\n+      bool created = false;\n+      V* v = rh.put_if_absent(as_K(step), &created);\n+      ASSERT_TRUE(rh.contains(as_K(step)));\n+      ASSERT_TRUE(created);\n+      *v = (V)step;\n+\n+      \/\/ Calling this function a second time should yield the same value pointer\n+      V* v2 = rh.put_if_absent(as_K(step), &created);\n+      ASSERT_EQ(v, v2);\n+      ASSERT_EQ(*v2, *v);\n+      ASSERT_FALSE(created);\n+\n+      ASSERT_TRUE(rh.remove(as_K(step)));\n+      ASSERT_FALSE(rh.contains(as_K(step)));\n+      rh.iterate(&et);\n+\n+      \/\/ Test put_if_absent(key, value)\n+      v = rh.put_if_absent(as_K(step), step, &created);\n+      ASSERT_EQ(*v, step);\n+      ASSERT_TRUE(rh.contains(as_K(step)));\n+      ASSERT_TRUE(created);\n+\n+      v2 = rh.put_if_absent(as_K(step), step, &created);\n+      \/\/ Calling this function a second time should yield the same value pointer\n+      ASSERT_EQ(v, v2);\n+      ASSERT_EQ(*v2, (V)step);\n+      ASSERT_FALSE(created);\n+\n+      ASSERT_TRUE(rh.remove(as_K(step)));\n+      ASSERT_FALSE(rh.contains(as_K(step)));\n+      rh.iterate(&et);\n+\n+\n+    }\n+  };\n+};\n+\n+TEST_VM_F(SmallHashTableTest, default) {\n+  ResourceMark rm;\n+  Runner<>::test(0x1);\n+}\n+\n+TEST_VM_F(SmallHashTableTest, default_shifted) {\n+  ResourceMark rm;\n+  Runner<>::test(0x10);\n+}\n+\n+TEST_VM_F(SmallHashTableTest, bad_hash) {\n+  ResourceMark rm;\n+  Runner<bad_hash>::test(0x1);\n+}\n+\n+TEST_VM_F(SmallHashTableTest, bad_hash_shifted) {\n+  ResourceMark rm;\n+  Runner<bad_hash>::test(0x10);\n+}\n+\n+TEST_VM_F(SmallHashTableTest, identity_hash) {\n+  ResourceMark rm;\n+  Runner<identity_hash>::test(0x1);\n+}\n+\n+TEST_VM_F(SmallHashTableTest, identity_hash_shifted) {\n+  ResourceMark rm;\n+  Runner<identity_hash>::test(0x10);\n+}\n+\n+TEST_VM_F(SmallHashTableTest, primitive_hash_no_rm) {\n+  Runner<primitive_hash<K>, primitive_equals<K>, 512, AnyObj::C_HEAP>::test(0x1);\n+}\n+\n+TEST_VM_F(SmallHashTableTest, primitive_hash_no_rm_shifted) {\n+  Runner<primitive_hash<K>, primitive_equals<K>, 512, AnyObj::C_HEAP>::test(0x10);\n+}\n+\n+TEST_VM_F(SmallHashTableTest, bad_hash_no_rm) {\n+  Runner<bad_hash, primitive_equals<K>, 512, AnyObj::C_HEAP>::test(0x1);\n+}\n+\n+TEST_VM_F(SmallHashTableTest, bad_hash_no_rm_shifted) {\n+  Runner<bad_hash, primitive_equals<K>, 512, AnyObj::C_HEAP>::test(0x10);\n+}\n+\n+TEST_VM_F(SmallHashTableTest, identity_hash_no_rm) {\n+  Runner<identity_hash, primitive_equals<K>, 1, AnyObj::C_HEAP>::test(0x1);\n+}\n+\n+TEST_VM_F(SmallHashTableTest, identity_hash_no_rm_shifted) {\n+  Runner<identity_hash, primitive_equals<K>, 1, AnyObj::C_HEAP>::test(0x10);\n+}\n+\n+class GenericHashTableTest : public CommonHashTableTest {\n+ protected:\n+\n+  template<\n+  unsigned (*HASH) (K const&) = primitive_hash<K>,\n+  bool (*EQUALS)(K const&, K const&) = primitive_equals<K>,\n+  unsigned SIZE = 256,\n+  AnyObj::allocation_type ALLOC_TYPE = AnyObj::RESOURCE_AREA\n+  >\n+  class Runner : public AllStatic {\n+   public:\n+\n+    static void test(unsigned num_elements = SIZE) {\n+      EqualityTestIter et;\n+      HashTable<K, V, SIZE, ALLOC_TYPE, MEM_TAG, HASH, EQUALS> rh;\n+\n+      for (uintptr_t i = 0; i < num_elements; ++i) {\n+        ASSERT_TRUE(rh.put(as_K(i), i));\n+      }\n+\n+      rh.iterate(&et);\n+      if (::testing::Test::HasFailure()) {\n+        return;\n+      }\n+\n+      for (uintptr_t i = num_elements; i > 0; --i) {\n+        uintptr_t index = i - 1;\n+        ASSERT_TRUE((rh.remove(as_K(index))));\n+      }\n+\n+      rh.iterate(&et);\n+      if (::testing::Test::HasFailure()) {\n+        return;\n+      }\n+      for (uintptr_t i = num_elements; i > 0; --i) {\n+        uintptr_t index = i - 1;\n+        ASSERT_FALSE(rh.remove(as_K(index)));\n+      }\n+      rh.iterate(&et);\n+\n+      \/\/ Add more entries in and then delete one.\n+      for (uintptr_t i = 10; i > 0; --i) {\n+        uintptr_t index = i - 1;\n+        ASSERT_TRUE(rh.put(as_K(index), index));\n+      }\n+      DeleterTestIter dt(5);\n+      rh.unlink(&dt);\n+      ASSERT_FALSE(rh.get(as_K(5)));\n+    }\n+  };\n+};\n+\n+TEST_VM_F(GenericHashTableTest, default) {\n+  ResourceMark rm;\n+  Runner<>::test();\n+}\n+\n+TEST_VM_F(GenericHashTableTest, bad_hash) {\n+  ResourceMark rm;\n+  Runner<bad_hash>::test();\n+}\n+\n+TEST_VM_F(GenericHashTableTest, identity_hash) {\n+  ResourceMark rm;\n+  Runner<identity_hash>::test();\n+}\n+\n+TEST_VM_F(GenericHashTableTest, primitive_hash_no_rm) {\n+  Runner<primitive_hash<K>, primitive_equals<K>, 512, AnyObj::C_HEAP>::test();\n+}\n+\n+TEST_VM_F(GenericHashTableTest, bad_hash_no_rm) {\n+  Runner<bad_hash, primitive_equals<K>, 512, AnyObj::C_HEAP>::test();\n+}\n+\n+TEST_VM_F(GenericHashTableTest, identity_hash_no_rm) {\n+  Runner<identity_hash, primitive_equals<K>, 1, AnyObj::C_HEAP>::test(512);\n+}\n+\n+\/\/ Simple HashTable whose key is a SymbolHandle and value is an int\n+\/\/ This test is to show that the SymbolHandle will correctly handle the refcounting\n+\/\/ in the table.\n+class SimpleHashTableDeleteTest : public ::testing::Test {\n+ public:\n+    HashTable<SymbolHandle, int, 107, AnyObj::C_HEAP, mtTest, SymbolHandle::compute_hash> _simple_test_table;\n+\n+    class SimpleDeleter : public StackObj {\n+      public:\n+        bool do_entry(SymbolHandle& key, int value) {\n+          return true;\n+        }\n+    };\n+};\n+\n+TEST_VM_F(SimpleHashTableDeleteTest, simple_remove) {\n+  TempNewSymbol t = SymbolTable::new_symbol(\"abcdefg_simple\");\n+  Symbol* s = t;\n+  int s_orig_count = s->refcount();\n+  _simple_test_table.put(s, 55);\n+  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount should be incremented in table\";\n+\n+  \/\/ Deleting this value from a hashtable\n+  _simple_test_table.remove(s);\n+  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be same as start\";\n+}\n+\n+TEST_VM_F(SimpleHashTableDeleteTest, simple_delete) {\n+  TempNewSymbol t = SymbolTable::new_symbol(\"abcdefg_simple\");\n+  Symbol* s = t;\n+  int s_orig_count = s->refcount();\n+  _simple_test_table.put(s, 66);\n+  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount should be incremented in table\";\n+\n+  \/\/ Use unlink to remove the matching (or all) values from the table.\n+  SimpleDeleter deleter;\n+  _simple_test_table.unlink(&deleter);\n+  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be same as start\";\n+}\n+\n+\/\/ More complicated HashTable with SymbolHandle in the key. Since the *same* Symbol is part\n+\/\/ of the value, it's not necessary to manipulate the refcount of the key, but you must in the value.\n+\/\/ Luckily SymbolHandle does this.\n+class HashTableDeleteTest : public ::testing::Test {\n+ public:\n+    class TestValue : public CHeapObj<mtTest> {\n+        SymbolHandle _s;\n+      public:\n+        \/\/ Never have ctors and dtors fix refcounts without copy ctors and assignment operators!\n+        \/\/ Unless it's declared and used as a CHeapObj with\n+        \/\/ NONCOPYABLE(TestValue)\n+\n+        \/\/ Using SymbolHandle deals with refcount manipulation so this class doesn't have to\n+        \/\/ have dtors, copy ctors and assignment operators to do so.\n+        TestValue(Symbol* name) : _s(name) { }\n+        \/\/ Symbol* s() const { return _s; }  \/\/ needed for conversion from TempNewSymbol to SymbolHandle member\n+    };\n+\n+    \/\/ HashTable whose value is a *copy* of TestValue.\n+    HashTable<Symbol*, TestValue, 107, AnyObj::C_HEAP, mtTest> _test_table;\n+\n+    class Deleter : public StackObj {\n+      public:\n+        bool do_entry(Symbol*& key, TestValue& value) {\n+          \/\/ Since we didn't increment the key, we shouldn't decrement it.\n+          \/\/ Calling delete on the hashtable Node which contains value will\n+          \/\/ decrement the refcount.  That's actually best since the whole\n+          \/\/ entry will be gone at once.\n+          return true;\n+        }\n+    };\n+\n+    \/\/ HashTable whose value is a pointer to TestValue.\n+    HashTable<Symbol*, TestValue*, 107, AnyObj::C_HEAP, mtTest> _ptr_test_table;\n+\n+    class PtrDeleter : public StackObj {\n+      public:\n+        bool do_entry(Symbol*& key, TestValue*& value) {\n+          \/\/ If the hashtable value is a pointer, need to delete it from here.\n+          \/\/ This will also potentially make the refcount of the Key = 0, but the\n+          \/\/ next thing that happens is that the hashtable node is deleted so this is ok.\n+          delete value;\n+          return true;\n+        }\n+    };\n+};\n+\n+\n+TEST_VM_F(HashTableDeleteTest, value_remove) {\n+  TempNewSymbol s = SymbolTable::new_symbol(\"abcdefg\");\n+  int s_orig_count = s->refcount();\n+  {\n+    TestValue tv(s);\n+    \/\/ Since TestValue contains the pointer to the key, it will handle the\n+    \/\/ refcounting.\n+    _test_table.put(s, tv);\n+    ASSERT_EQ(s->refcount(), s_orig_count + 2) << \"refcount incremented by copy\";\n+  }\n+  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount incremented in table\";\n+\n+  \/\/ Deleting this value from a hashtable calls the destructor!\n+  _test_table.remove(s);\n+  \/\/ Removal should make the refcount be the original refcount.\n+  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be as we started\";\n+}\n+\n+TEST_VM_F(HashTableDeleteTest, value_delete) {\n+  TempNewSymbol d = SymbolTable::new_symbol(\"defghijklmnop\");\n+  int d_orig_count = d->refcount();\n+  {\n+    TestValue tv(d);\n+    \/\/ Same as above, but the do_entry does nothing because the value is deleted when the\n+    \/\/ hashtable node is deleted.\n+    _test_table.put(d, tv);\n+    ASSERT_EQ(d->refcount(), d_orig_count + 2) << \"refcount incremented by copy\";\n+  }\n+  ASSERT_EQ(d->refcount(), d_orig_count + 1) << \"refcount incremented in table\";\n+  Deleter deleter;\n+  _test_table.unlink(&deleter);\n+  ASSERT_EQ(d->refcount(), d_orig_count) << \"refcount should be as we started\";\n+}\n+\n+TEST_VM_F(HashTableDeleteTest, check_delete_ptr) {\n+  TempNewSymbol s = SymbolTable::new_symbol(\"abcdefg_ptr\");\n+  int s_orig_count = s->refcount();\n+  {\n+    TestValue* tv = new TestValue(s);\n+    \/\/ Again since TestValue contains the pointer to the key Symbol, it will\n+    \/\/ handle the refcounting.\n+    _ptr_test_table.put(s, tv);\n+    ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount incremented by allocation\";\n+  }\n+  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount incremented in table\";\n+\n+  \/\/ Deleting this pointer value from a hashtable must call the destructor in the\n+  \/\/ do_entry function.\n+  PtrDeleter deleter;\n+  _ptr_test_table.unlink(&deleter);\n+  \/\/ Removal should make the refcount be the original refcount.\n+  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be as we started\";\n+}\n+\n+class HashTablePrintTest : public ::testing::Test {\n+ public:\n+    class TestValue {\n+      int _i;\n+      int _j;\n+      int _k;\n+     public:\n+      TestValue(int i) : _i(i), _j(i+1), _k(i+2) {}\n+    };\n+    HashTable<int, TestValue*, 30, AnyObj::C_HEAP, mtTest> _test_table;\n+\n+    class TableDeleter {\n+     public:\n+      bool do_entry(int& key, TestValue*& val) {\n+        delete val;\n+        return true;\n+      }\n+    };\n+};\n+\n+TEST_VM_F(HashTablePrintTest, print_test) {\n+  for (int i = 0; i < 300; i++) {\n+    TestValue* tv = new TestValue(i);\n+    _test_table.put(i, tv);  \/\/ all the entries can be the same.\n+  }\n+  auto printer = [&] (int& key, TestValue*& val) {\n+    return sizeof(*val);\n+  };\n+  TableStatistics ts = _test_table.statistics_calculate(printer);\n+  ResourceMark rm;\n+  stringStream st;\n+  ts.print(&st, \"TestTable\");\n+  \/\/ Verify output in string\n+  const char* strings[] = {\n+      \"Number of buckets\", \"Number of entries\", \"300\", \"Number of literals\", \"Average bucket size\", \"Maximum bucket size\" };\n+  for (const auto& str : strings) {\n+    ASSERT_THAT(st.base(), testing::HasSubstr(str));\n+  }\n+  \/\/ Cleanup: need to delete pointers in entries\n+  TableDeleter deleter;\n+  _test_table.unlink(&deleter);\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_hashtable.cpp","additions":476,"deletions":0,"binary":false,"changes":476,"status":"added"},{"patch":"@@ -132,0 +132,1 @@\n+      return true;\n@@ -213,0 +214,1 @@\n+        return true;\n@@ -220,0 +222,1 @@\n+        return true;\n@@ -226,0 +229,1 @@\n+        return true;\n@@ -228,0 +232,5 @@\n+      rbtree.visit_in_order([&](const Node* x) {\n+        count++;\n+        return true;\n+      });\n+      EXPECT_EQ(2, count);\n@@ -236,0 +245,1 @@\n+        return true;\n@@ -238,0 +248,5 @@\n+      rbtree.visit_range_in_order(0, 100, [&](const Node* x) {\n+        count++;\n+        return true;\n+      });\n+      EXPECT_EQ(2, count);\n@@ -242,0 +257,1 @@\n+        return true;\n@@ -244,0 +260,5 @@\n+      rbtree.visit_in_order([&](const Node* x) {\n+        count++;\n+        return true;\n+      });\n+      EXPECT_EQ(6, count);\n@@ -249,0 +270,1 @@\n+        return true;\n@@ -251,0 +273,28 @@\n+      rbtree.visit_range_in_order(0, 0, [&](const Node* x) {\n+        count++;\n+        return true;\n+      });\n+      EXPECT_EQ(2, count);\n+\n+      \/\/ Test exiting visit early\n+      rbtree.remove_all();\n+      for (int i = 0; i < 11; i++) {\n+        rbtree.upsert(i, 0);\n+      }\n+\n+      count = 0;\n+      rbtree_const.visit_in_order([&](const Node* x) {\n+        if (x->key() >= 6) return false;\n+        count++;\n+        return true;\n+      });\n+      EXPECT_EQ(6, count);\n+\n+      count = 0;\n+      rbtree_const.visit_range_in_order(6, 10, [&](const Node* x) {\n+        if (x->key() >= 6) return false;\n+        count++;\n+        return true;\n+      });\n+\n+      EXPECT_EQ(0, count);\n@@ -261,0 +311,1 @@\n+        return true;\n@@ -270,0 +321,1 @@\n+        return true;\n@@ -279,0 +331,1 @@\n+        return true;\n@@ -295,0 +348,1 @@\n+        return true;\n@@ -304,0 +358,1 @@\n+        return true;\n@@ -323,2 +378,4 @@\n-      rbtree.visit_range_in_order(test_case[0], test_case[1], [&](const Node* x) {\n-        FAIL() << \"Range should not visit nodes\";\n+      bool visited = false;\n+      rbtree.visit_range_in_order(test_case[0], test_case[1], [&](const Node* x) -> bool {\n+        visited = true;\n+        return true;\n@@ -326,0 +383,1 @@\n+      EXPECT_FALSE(visited);\n@@ -518,0 +576,1 @@\n+      return true;\n","filename":"test\/hotspot\/gtest\/utilities\/test_rbtree.cpp","additions":61,"deletions":2,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -1,476 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"classfile\/symbolTable.hpp\"\n-#include \"nmt\/nmtCommon.hpp\"\n-#include \"memory\/allocation.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"oops\/symbolHandle.hpp\"\n-#include \"unittest.hpp\"\n-#include \"utilities\/debug.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/resourceHash.hpp\"\n-\n-class CommonResourceHashtableTest : public ::testing::Test {\n- protected:\n-  typedef void* K;\n-  typedef uintx V;\n-  const static MemTag MEM_TAG = mtInternal;\n-\n-  static unsigned identity_hash(const K& k) {\n-    return (unsigned) (uintptr_t) k;\n-  }\n-\n-  static unsigned bad_hash(const K& k) {\n-    return 1;\n-  }\n-\n-  static void* as_K(uintptr_t val) {\n-    return (void*) val;\n-  }\n-\n-  class EqualityTestIter {\n-   public:\n-\n-    bool do_entry(K const& k, V const& v) {\n-      if ((uintptr_t) k != (uintptr_t) v) {\n-        EXPECT_EQ((uintptr_t) k, (uintptr_t) v);\n-        return false;\n-      } else {\n-        return true; \/\/ continue iteration\n-      }\n-    }\n-  };\n-\n-  class DeleterTestIter {\n-    int _val;\n-   public:\n-    DeleterTestIter(int i) : _val(i) {}\n-\n-    bool do_entry(K const& k, V const& v) {\n-      if ((uintptr_t) k == (uintptr_t) _val) {\n-        \/\/ Delete me!\n-        return true;\n-      } else {\n-        return false; \/\/ continue iteration\n-      }\n-    }\n-  };\n-\n-};\n-\n-class SmallResourceHashtableTest : public CommonResourceHashtableTest {\n- protected:\n-\n-  template<\n-  unsigned (*HASH) (K const&) = primitive_hash<K>,\n-  bool (*EQUALS)(K const&, K const&) = primitive_equals<K>,\n-  unsigned SIZE = 256,\n-  AnyObj::allocation_type ALLOC_TYPE = AnyObj::RESOURCE_AREA\n-  >\n-  class Runner : public AllStatic {\n-   public:\n-\n-    static void test(V step) {\n-      EqualityTestIter et;\n-      ResourceHashtable<K, V, SIZE, ALLOC_TYPE, MEM_TAG, HASH, EQUALS> rh;\n-\n-      ASSERT_FALSE(rh.contains(as_K(step)));\n-\n-      ASSERT_TRUE(rh.put(as_K(step), step));\n-      ASSERT_TRUE(rh.contains(as_K(step)));\n-\n-      ASSERT_FALSE(rh.put(as_K(step), step));\n-\n-      ASSERT_TRUE(rh.put(as_K(2 * step), 2 * step));\n-      ASSERT_TRUE(rh.put(as_K(3 * step), 3 * step));\n-      ASSERT_TRUE(rh.put(as_K(4 * step), 4 * step));\n-      ASSERT_TRUE(rh.put(as_K(5 * step), 5 * step));\n-\n-      ASSERT_FALSE(rh.remove(as_K(0x0)));\n-\n-      rh.iterate(&et);\n-      if (::testing::Test::HasFailure()) {\n-        return;\n-      }\n-\n-      ASSERT_TRUE(rh.remove(as_K(step)));\n-      ASSERT_FALSE(rh.contains(as_K(step)));\n-      rh.iterate(&et);\n-\n-\n-      \/\/ Test put_if_absent(key) (creating a default-created value)\n-      bool created = false;\n-      V* v = rh.put_if_absent(as_K(step), &created);\n-      ASSERT_TRUE(rh.contains(as_K(step)));\n-      ASSERT_TRUE(created);\n-      *v = (V)step;\n-\n-      \/\/ Calling this function a second time should yield the same value pointer\n-      V* v2 = rh.put_if_absent(as_K(step), &created);\n-      ASSERT_EQ(v, v2);\n-      ASSERT_EQ(*v2, *v);\n-      ASSERT_FALSE(created);\n-\n-      ASSERT_TRUE(rh.remove(as_K(step)));\n-      ASSERT_FALSE(rh.contains(as_K(step)));\n-      rh.iterate(&et);\n-\n-      \/\/ Test put_if_absent(key, value)\n-      v = rh.put_if_absent(as_K(step), step, &created);\n-      ASSERT_EQ(*v, step);\n-      ASSERT_TRUE(rh.contains(as_K(step)));\n-      ASSERT_TRUE(created);\n-\n-      v2 = rh.put_if_absent(as_K(step), step, &created);\n-      \/\/ Calling this function a second time should yield the same value pointer\n-      ASSERT_EQ(v, v2);\n-      ASSERT_EQ(*v2, (V)step);\n-      ASSERT_FALSE(created);\n-\n-      ASSERT_TRUE(rh.remove(as_K(step)));\n-      ASSERT_FALSE(rh.contains(as_K(step)));\n-      rh.iterate(&et);\n-\n-\n-    }\n-  };\n-};\n-\n-TEST_VM_F(SmallResourceHashtableTest, default) {\n-  ResourceMark rm;\n-  Runner<>::test(0x1);\n-}\n-\n-TEST_VM_F(SmallResourceHashtableTest, default_shifted) {\n-  ResourceMark rm;\n-  Runner<>::test(0x10);\n-}\n-\n-TEST_VM_F(SmallResourceHashtableTest, bad_hash) {\n-  ResourceMark rm;\n-  Runner<bad_hash>::test(0x1);\n-}\n-\n-TEST_VM_F(SmallResourceHashtableTest, bad_hash_shifted) {\n-  ResourceMark rm;\n-  Runner<bad_hash>::test(0x10);\n-}\n-\n-TEST_VM_F(SmallResourceHashtableTest, identity_hash) {\n-  ResourceMark rm;\n-  Runner<identity_hash>::test(0x1);\n-}\n-\n-TEST_VM_F(SmallResourceHashtableTest, identity_hash_shifted) {\n-  ResourceMark rm;\n-  Runner<identity_hash>::test(0x10);\n-}\n-\n-TEST_VM_F(SmallResourceHashtableTest, primitive_hash_no_rm) {\n-  Runner<primitive_hash<K>, primitive_equals<K>, 512, AnyObj::C_HEAP>::test(0x1);\n-}\n-\n-TEST_VM_F(SmallResourceHashtableTest, primitive_hash_no_rm_shifted) {\n-  Runner<primitive_hash<K>, primitive_equals<K>, 512, AnyObj::C_HEAP>::test(0x10);\n-}\n-\n-TEST_VM_F(SmallResourceHashtableTest, bad_hash_no_rm) {\n-  Runner<bad_hash, primitive_equals<K>, 512, AnyObj::C_HEAP>::test(0x1);\n-}\n-\n-TEST_VM_F(SmallResourceHashtableTest, bad_hash_no_rm_shifted) {\n-  Runner<bad_hash, primitive_equals<K>, 512, AnyObj::C_HEAP>::test(0x10);\n-}\n-\n-TEST_VM_F(SmallResourceHashtableTest, identity_hash_no_rm) {\n-  Runner<identity_hash, primitive_equals<K>, 1, AnyObj::C_HEAP>::test(0x1);\n-}\n-\n-TEST_VM_F(SmallResourceHashtableTest, identity_hash_no_rm_shifted) {\n-  Runner<identity_hash, primitive_equals<K>, 1, AnyObj::C_HEAP>::test(0x10);\n-}\n-\n-class GenericResourceHashtableTest : public CommonResourceHashtableTest {\n- protected:\n-\n-  template<\n-  unsigned (*HASH) (K const&) = primitive_hash<K>,\n-  bool (*EQUALS)(K const&, K const&) = primitive_equals<K>,\n-  unsigned SIZE = 256,\n-  AnyObj::allocation_type ALLOC_TYPE = AnyObj::RESOURCE_AREA\n-  >\n-  class Runner : public AllStatic {\n-   public:\n-\n-    static void test(unsigned num_elements = SIZE) {\n-      EqualityTestIter et;\n-      ResourceHashtable<K, V, SIZE, ALLOC_TYPE, MEM_TAG, HASH, EQUALS> rh;\n-\n-      for (uintptr_t i = 0; i < num_elements; ++i) {\n-        ASSERT_TRUE(rh.put(as_K(i), i));\n-      }\n-\n-      rh.iterate(&et);\n-      if (::testing::Test::HasFailure()) {\n-        return;\n-      }\n-\n-      for (uintptr_t i = num_elements; i > 0; --i) {\n-        uintptr_t index = i - 1;\n-        ASSERT_TRUE((rh.remove(as_K(index))));\n-      }\n-\n-      rh.iterate(&et);\n-      if (::testing::Test::HasFailure()) {\n-        return;\n-      }\n-      for (uintptr_t i = num_elements; i > 0; --i) {\n-        uintptr_t index = i - 1;\n-        ASSERT_FALSE(rh.remove(as_K(index)));\n-      }\n-      rh.iterate(&et);\n-\n-      \/\/ Add more entries in and then delete one.\n-      for (uintptr_t i = 10; i > 0; --i) {\n-        uintptr_t index = i - 1;\n-        ASSERT_TRUE(rh.put(as_K(index), index));\n-      }\n-      DeleterTestIter dt(5);\n-      rh.unlink(&dt);\n-      ASSERT_FALSE(rh.get(as_K(5)));\n-    }\n-  };\n-};\n-\n-TEST_VM_F(GenericResourceHashtableTest, default) {\n-  ResourceMark rm;\n-  Runner<>::test();\n-}\n-\n-TEST_VM_F(GenericResourceHashtableTest, bad_hash) {\n-  ResourceMark rm;\n-  Runner<bad_hash>::test();\n-}\n-\n-TEST_VM_F(GenericResourceHashtableTest, identity_hash) {\n-  ResourceMark rm;\n-  Runner<identity_hash>::test();\n-}\n-\n-TEST_VM_F(GenericResourceHashtableTest, primitive_hash_no_rm) {\n-  Runner<primitive_hash<K>, primitive_equals<K>, 512, AnyObj::C_HEAP>::test();\n-}\n-\n-TEST_VM_F(GenericResourceHashtableTest, bad_hash_no_rm) {\n-  Runner<bad_hash, primitive_equals<K>, 512, AnyObj::C_HEAP>::test();\n-}\n-\n-TEST_VM_F(GenericResourceHashtableTest, identity_hash_no_rm) {\n-  Runner<identity_hash, primitive_equals<K>, 1, AnyObj::C_HEAP>::test(512);\n-}\n-\n-\/\/ Simple ResourceHashtable whose key is a SymbolHandle and value is an int\n-\/\/ This test is to show that the SymbolHandle will correctly handle the refcounting\n-\/\/ in the table.\n-class SimpleResourceHashtableDeleteTest : public ::testing::Test {\n- public:\n-    ResourceHashtable<SymbolHandle, int, 107, AnyObj::C_HEAP, mtTest, SymbolHandle::compute_hash> _simple_test_table;\n-\n-    class SimpleDeleter : public StackObj {\n-      public:\n-        bool do_entry(SymbolHandle& key, int value) {\n-          return true;\n-        }\n-    };\n-};\n-\n-TEST_VM_F(SimpleResourceHashtableDeleteTest, simple_remove) {\n-  TempNewSymbol t = SymbolTable::new_symbol(\"abcdefg_simple\");\n-  Symbol* s = t;\n-  int s_orig_count = s->refcount();\n-  _simple_test_table.put(s, 55);\n-  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount should be incremented in table\";\n-\n-  \/\/ Deleting this value from a hashtable\n-  _simple_test_table.remove(s);\n-  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be same as start\";\n-}\n-\n-TEST_VM_F(SimpleResourceHashtableDeleteTest, simple_delete) {\n-  TempNewSymbol t = SymbolTable::new_symbol(\"abcdefg_simple\");\n-  Symbol* s = t;\n-  int s_orig_count = s->refcount();\n-  _simple_test_table.put(s, 66);\n-  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount should be incremented in table\";\n-\n-  \/\/ Use unlink to remove the matching (or all) values from the table.\n-  SimpleDeleter deleter;\n-  _simple_test_table.unlink(&deleter);\n-  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be same as start\";\n-}\n-\n-\/\/ More complicated ResourceHashtable with SymbolHandle in the key. Since the *same* Symbol is part\n-\/\/ of the value, it's not necessary to manipulate the refcount of the key, but you must in the value.\n-\/\/ Luckily SymbolHandle does this.\n-class ResourceHashtableDeleteTest : public ::testing::Test {\n- public:\n-    class TestValue : public CHeapObj<mtTest> {\n-        SymbolHandle _s;\n-      public:\n-        \/\/ Never have ctors and dtors fix refcounts without copy ctors and assignment operators!\n-        \/\/ Unless it's declared and used as a CHeapObj with\n-        \/\/ NONCOPYABLE(TestValue)\n-\n-        \/\/ Using SymbolHandle deals with refcount manipulation so this class doesn't have to\n-        \/\/ have dtors, copy ctors and assignment operators to do so.\n-        TestValue(Symbol* name) : _s(name) { }\n-        \/\/ Symbol* s() const { return _s; }  \/\/ needed for conversion from TempNewSymbol to SymbolHandle member\n-    };\n-\n-    \/\/ ResourceHashtable whose value is a *copy* of TestValue.\n-    ResourceHashtable<Symbol*, TestValue, 107, AnyObj::C_HEAP, mtTest> _test_table;\n-\n-    class Deleter : public StackObj {\n-      public:\n-        bool do_entry(Symbol*& key, TestValue& value) {\n-          \/\/ Since we didn't increment the key, we shouldn't decrement it.\n-          \/\/ Calling delete on the hashtable Node which contains value will\n-          \/\/ decrement the refcount.  That's actually best since the whole\n-          \/\/ entry will be gone at once.\n-          return true;\n-        }\n-    };\n-\n-    \/\/ ResourceHashtable whose value is a pointer to TestValue.\n-    ResourceHashtable<Symbol*, TestValue*, 107, AnyObj::C_HEAP, mtTest> _ptr_test_table;\n-\n-    class PtrDeleter : public StackObj {\n-      public:\n-        bool do_entry(Symbol*& key, TestValue*& value) {\n-          \/\/ If the hashtable value is a pointer, need to delete it from here.\n-          \/\/ This will also potentially make the refcount of the Key = 0, but the\n-          \/\/ next thing that happens is that the hashtable node is deleted so this is ok.\n-          delete value;\n-          return true;\n-        }\n-    };\n-};\n-\n-\n-TEST_VM_F(ResourceHashtableDeleteTest, value_remove) {\n-  TempNewSymbol s = SymbolTable::new_symbol(\"abcdefg\");\n-  int s_orig_count = s->refcount();\n-  {\n-    TestValue tv(s);\n-    \/\/ Since TestValue contains the pointer to the key, it will handle the\n-    \/\/ refcounting.\n-    _test_table.put(s, tv);\n-    ASSERT_EQ(s->refcount(), s_orig_count + 2) << \"refcount incremented by copy\";\n-  }\n-  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount incremented in table\";\n-\n-  \/\/ Deleting this value from a hashtable calls the destructor!\n-  _test_table.remove(s);\n-  \/\/ Removal should make the refcount be the original refcount.\n-  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be as we started\";\n-}\n-\n-TEST_VM_F(ResourceHashtableDeleteTest, value_delete) {\n-  TempNewSymbol d = SymbolTable::new_symbol(\"defghijklmnop\");\n-  int d_orig_count = d->refcount();\n-  {\n-    TestValue tv(d);\n-    \/\/ Same as above, but the do_entry does nothing because the value is deleted when the\n-    \/\/ hashtable node is deleted.\n-    _test_table.put(d, tv);\n-    ASSERT_EQ(d->refcount(), d_orig_count + 2) << \"refcount incremented by copy\";\n-  }\n-  ASSERT_EQ(d->refcount(), d_orig_count + 1) << \"refcount incremented in table\";\n-  Deleter deleter;\n-  _test_table.unlink(&deleter);\n-  ASSERT_EQ(d->refcount(), d_orig_count) << \"refcount should be as we started\";\n-}\n-\n-TEST_VM_F(ResourceHashtableDeleteTest, check_delete_ptr) {\n-  TempNewSymbol s = SymbolTable::new_symbol(\"abcdefg_ptr\");\n-  int s_orig_count = s->refcount();\n-  {\n-    TestValue* tv = new TestValue(s);\n-    \/\/ Again since TestValue contains the pointer to the key Symbol, it will\n-    \/\/ handle the refcounting.\n-    _ptr_test_table.put(s, tv);\n-    ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount incremented by allocation\";\n-  }\n-  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount incremented in table\";\n-\n-  \/\/ Deleting this pointer value from a hashtable must call the destructor in the\n-  \/\/ do_entry function.\n-  PtrDeleter deleter;\n-  _ptr_test_table.unlink(&deleter);\n-  \/\/ Removal should make the refcount be the original refcount.\n-  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be as we started\";\n-}\n-\n-class ResourceHashtablePrintTest : public ::testing::Test {\n- public:\n-    class TestValue {\n-      int _i;\n-      int _j;\n-      int _k;\n-     public:\n-      TestValue(int i) : _i(i), _j(i+1), _k(i+2) {}\n-    };\n-    ResourceHashtable<int, TestValue*, 30, AnyObj::C_HEAP, mtTest> _test_table;\n-\n-    class TableDeleter {\n-     public:\n-      bool do_entry(int& key, TestValue*& val) {\n-        delete val;\n-        return true;\n-      }\n-    };\n-};\n-\n-TEST_VM_F(ResourceHashtablePrintTest, print_test) {\n-  for (int i = 0; i < 300; i++) {\n-    TestValue* tv = new TestValue(i);\n-    _test_table.put(i, tv);  \/\/ all the entries can be the same.\n-  }\n-  auto printer = [&] (int& key, TestValue*& val) {\n-    return sizeof(*val);\n-  };\n-  TableStatistics ts = _test_table.statistics_calculate(printer);\n-  ResourceMark rm;\n-  stringStream st;\n-  ts.print(&st, \"TestTable\");\n-  \/\/ Verify output in string\n-  const char* strings[] = {\n-      \"Number of buckets\", \"Number of entries\", \"300\", \"Number of literals\", \"Average bucket size\", \"Maximum bucket size\" };\n-  for (const auto& str : strings) {\n-    ASSERT_THAT(st.base(), testing::HasSubstr(str));\n-  }\n-  \/\/ Cleanup: need to delete pointers in entries\n-  TableDeleter deleter;\n-  _test_table.unlink(&deleter);\n-}\n","filename":"test\/hotspot\/gtest\/utilities\/test_resourceHash.cpp","additions":0,"deletions":476,"binary":false,"changes":476,"status":"deleted"},{"patch":"@@ -78,3 +78,0 @@\n-compiler\/ciReplay\/TestInliningProtectionDomain.java 8349191 generic-all\n-compiler\/ciReplay\/TestIncrementalInlining.java 8349191 generic-all\n-\n@@ -103,0 +100,1 @@\n+runtime\/cds\/DeterministicDump.java 8363986 macosx-x64,macosx-aarch64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2021, Tencent. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestIllegalArrayCopyBeforeInfiniteLoop.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2021, Tencent. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestNegArrayLengthAsIndex1.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2021, Tencent. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestNegArrayLengthAsIndex2.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2021, Tencent. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestNegativeArrayCopyAfterLoop.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2021, Tencent. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/TestRangeCheckEliminated.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-  * Copyright (c) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+  * Copyright (c) 2022, Tencent. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestDuplicateSimpleLoopBackedge.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2022, Tencent. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr6865031\/Test.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2022, Tencent. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestAutoVectorization2DArray.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2021, Tencent. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/TestConflictInlineCommands.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2021, Tencent. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/debug\/TraceIterativeGVN.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8359235\n+ * @summary Test C1 stack2reg after fixing incorrect use of T_LONG in intrinsic\n+ * @requires vm.debug == true & vm.compiler1.enabled\n+ * @run main\/othervm -XX:TieredStopAtLevel=1\n+ *                   -XX:C1MaxInlineSize=200\n+ *                   -XX:CompileThreshold=10\n+ *                   -XX:CompileCommand=compileonly,java.lang.invoke.LambdaFormEditor::putInCache\n+ *                   compiler.intrinsics.TestStack2RegSlotMismatch\n+ *\/\n+package compiler.intrinsics;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class TestStack2RegSlotMismatch {\n+    public static int target(int x, int y) {\n+        return x + y;\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        MethodHandle mh = MethodHandles.lookup().findStatic(\n+            TestStack2RegSlotMismatch.class,\n+            \"target\",\n+            MethodType.methodType(int.class, int.class, int.class)\n+        );\n+        List<Object> argsList = new ArrayList<>();\n+        int j = 0;\n+\n+        for (int i = 0; i < 50; i++) {\n+            mh = MethodHandles.dropArguments(mh, 0, int.class);\n+            argsList.add(0);\n+            argsList.add(1);\n+            argsList.add(2);\n+            Object result = mh.invokeWithArguments(argsList);\n+            j += (int) result;\n+            argsList.remove(argsList.size() - 1);\n+            argsList.remove(argsList.size() - 1);\n+            if (i % 5 == 0) {\n+                Thread.sleep(1000);\n+            }\n+        }\n+\n+        if (j == 150) {\n+            System.out.println(\"passed\");\n+        } else {\n+            throw new Exception(\"TestStack2RegSlotMismatch Error\");\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestStack2RegSlotMismatch.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2021, Tencent. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/math\/TestPow0Dot5Opt.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2021, Tencent. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/math\/TestPow2Opt.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2021, Tencent. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/cli\/TestUseSHA3IntrinsicsOptionOnSupportedCPU.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2021, Tencent. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/cli\/TestUseSHA3IntrinsicsOptionOnUnsupportedCPU.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2020 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2020, Tencent. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/errors\/TestInvalidTieredStopAtLevel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2021, Tencent. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestLoopEndNodeEliminate.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2021, Tencent. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestLoopPredicateDep.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2021, Tencent. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestSkeletonPredicateNegation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1066,1 +1066,1 @@\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"rvv\", \"true\"})\n+        applyIfCPUFeature = {\"avx2\", \"true\"})\n@@ -1068,0 +1068,8 @@\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.LOAD_VECTOR_L, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.ADD_VI, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.ADD_VL, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"rvv\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n@@ -1178,1 +1186,1 @@\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"rvv\", \"true\"})\n+        applyIfCPUFeature = {\"avx2\", \"true\"})\n@@ -1180,0 +1188,8 @@\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.LOAD_VECTOR_L, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.ADD_VI, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.ADD_VL, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"rvv\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAlignVector.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-        applyIfAnd = {\"SuperWordReductions\", \"true\",\"UsePopCountInstruction\", \"true\"},\n+        applyIfAnd = {\"SuperWordReductions\", \"true\", \"UsePopCountInstruction\", \"true\"},\n@@ -169,1 +169,1 @@\n-        applyIfAnd = {\"SuperWordReductions\", \"true\",\"UsePopCountInstruction\", \"true\"},\n+        applyIfAnd = {\"SuperWordReductions\", \"true\", \"UsePopCountInstruction\", \"true\", \"MaxVectorSize\", \">=32\"},\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestGeneralizedReductions.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2021, Tencent. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/oracle\/TestInvalidCompileCommand.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (c) 2022, Tencent. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/print\/TestTraceOptoParse.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2021, Tencent. All rights reserved.\n@@ -53,1 +53,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/regalloc\/TestGCMRecalcPressureNodes.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2020 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2020, Tencent. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/TestMisalignedUnsafeAccess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2021, 2022, THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2021, 2022, Tencent. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestIntrinsicBailOut.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2021, Tencent. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorErgonomics.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2021, Tencent. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorReinterpretTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2022, Tencent. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestMemoryWithCgroupV1.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (C) 2025 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2025, Tencent. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestG1CompressedOops.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -150,0 +150,1 @@\n+        System.out.println(\"Running to breakpoint: \" + args[0]);\n@@ -160,0 +161,4 @@\n+            \/\/ Make sure that the marker we use to find the expected log message is printed\n+            \/\/ before we release whitebox control, i.e. before the expected garbage collection\n+            \/\/ can start.\n+            System.out.println(TestCodeCacheUnloadDuringConcCycle.AFTER_FIRST_CYCLE_MARKER);\n@@ -162,1 +167,0 @@\n-        System.out.println(TestCodeCacheUnloadDuringConcCycle.AFTER_FIRST_CYCLE_MARKER);\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestCodeCacheUnloadDuringConcCycle.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+ * @comment Asan changes memory layout and we get a different coops mode\n+ * @requires !vm.asan\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/UseCompressedOops.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2022, Tencent. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/FillerObjectLoadTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -260,0 +260,10 @@\n+\n+        \/\/ Training run with -XX:+PrintTieredEvents (see JDK-8362530).\n+        printTestCase(\"Training run with -XX:+PrintTieredEvents\");\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \"-XX:AOTMode=record\",\n+            \"-XX:+PrintTieredEvents\",\n+            \"-XX:AOTConfiguration=\" + aotConfigFile,\n+            \"-cp\", appJar, helloClass);\n+        out = CDSTestUtils.executeAndLog(pb, \"train-with-tiered-events\");\n+        out.shouldHaveExitValue(0);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotFlags\/AOTFlags.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+                    \"share\/interpreter\",\n","filename":"test\/hotspot\/jtreg\/sources\/TestIncludesAreSorted.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,2 @@\n+ * @comment Do not run with asan enabled because asan has issues with ulimit\n+ * @requires !vm.asan\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/Allocate\/alloc001\/alloc001.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,24 +0,0 @@\n-<?xml version=\"1.0\" standalone=\"no\"?>\n-<!DOCTYPE document PUBLIC \"-\/\/mkrishna mohan\/\/DTD\/\/music pub\/\/EN\/\"\n-\t\t\"http:\/\/sc11152338.us.oracle.com:8080\/xmlsqe\/jaxp\/web\/testfiles\/JAXPREP\/publishers.dtd\">\n-<document>\n-\tPublishers of the Music of New York Women Composers\n-\t<title>The Publishers <![CDATA[<?xml>]]> <\/title>\n-\t<!--This is a comment -->\n-\t<publisher>\n-\t\t<name>ACA<\/name>\n-\t\t<email>info@composers.com <\/email>\n-\t\t<homepage>http:\/\/www.composers.com\/<\/homepage>\n-\t\t<address>\n-\t\t\t<street>170 West 74th St.<\/street>\n-\t\t\t<city>NY<\/city>\n-\t\t\t<state>NY<\/state>\n-\t\t\t<zip>10023<\/zip>\n-\t\t<\/address>\n-\t\t<voice>212-362-8900<\/voice>\n-\t\t<fax>212-874-8605<\/fax>\n-\t\t<!--This comment is for LexicalHandler -->\n-\t\t&familytree;\n-\t<\/publisher>\n-<\/document>\n-\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/functional\/javax\/xml\/transform\/xmlfiles\/lexical.xml","additions":0,"deletions":24,"binary":false,"changes":24,"status":"deleted"},{"patch":"@@ -1,21 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n-<!DOCTYPE document PUBLIC \"-\/\/mkrishna mohan\/\/DTD\/\/music pub\/\/EN\/\" \"http:\/\/sc11152338.us.oracle.com:8080\/xmlsqe\/jaxp\/web\/testfiles\/publishers.dtd\">\n-<document>\n-\tPublishers of the Music of New York Women Composers\n-\t<title>The Publishers <\/title>\n-\t<publisher>\n-\t\t<name>ACA<\/name>\n-\t\t<email>info@composers.com <\/email>\n-\t\t<homepage>http:\/\/www.composers.com\/<\/homepage>\n-\t\t<address>\n-\t\t\t<street>170 West 74th St.<\/street>\n-\t\t\t<city>NY<\/city>\n-\t\t\t<state>NY<\/state>\n-\t\t\t<zip>10023<\/zip>\n-\t\t<\/address>\n-\t\t<voice>212-362-8900<\/voice>\n-\t\t<fax>212-874-8605<\/fax>\n-\t\t<!-- This comment is for LexicalHandler -->\n-\t\t\n-\t<\/publisher>\n-<\/document>\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/functional\/javax\/xml\/transform\/xmlfiles\/out\/doctypeGF.out","additions":0,"deletions":21,"binary":false,"changes":21,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-<?xml version=\"1.0\" standalone=\"no\"?>\n-<!DOCTYPE document PUBLIC \"-\/\/mkrishna mohan\/\/DTD\/\/music pub\/\/EN\/\"\n-\t\t\"http:\/\/sc11152338.us.oracle.com:8080\/xmlsqe\/jaxp\/web\/testfiles\/JAXPREP\/publishers.dtd\">\n-<document>\n-\tPublishers of the Music of New York Women Composers\n-\t<title>The Publishers <\/title>\n-\t<publisher>\n-\t\t<name>ACA<\/name>\n-\t\t<email>info@composers.com <\/email>\n-\t\t<homepage>http:\/\/www.composers.com\/<\/homepage>\n-\t\t<address>\n-\t\t\t<street>170 West 74th St.<\/street>\n-\t\t\t<city>NY<\/city>\n-\t\t\t<state>NY<\/state>\n-\t\t\t<zip>10023<\/zip>\n-\t\t<\/address>\n-\t\t<voice>212-362-8900<\/voice>\n-\t\t<fax>212-874-8605<\/fax>\n-\t\t<!-- This comment is for LexicalHandler -->\n-\t\t&familytree;\n-\t<\/publisher>\n-<\/document>\n-\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/functional\/javax\/xml\/transform\/xmlfiles\/publish2.xml","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-In unparsedEntityDecl... name:logo publicId:null systemId:http:\/\/sc11152338.us.oracle.com:8080\/xmlsqe\/jaxp\/web\/testfiles\/JAXPREP\/images\/tool.gif notationName:gif\n-In notationDecl... name:gif publicId:null systemId:http:\/\/sardinia\/\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/functional\/org\/xml\/sax\/xmlfiles\/out\/DTDHandlerGF.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -155,2 +155,0 @@\n-java\/awt\/Mixing\/AWT_Mixing\/HierarchyBoundsListenerMixingTest.java 8049405 macosx-all\n-java\/awt\/Mixing\/AWT_Mixing\/OpaqueOverlapping.java 8294264 windows-x64\n@@ -158,2 +156,0 @@\n-java\/awt\/Mixing\/AWT_Mixing\/JMenuBarOverlapping.java 8159451 linux-all,windows-all,macosx-all\n-java\/awt\/Mixing\/AWT_Mixing\/JSplitPaneOverlapping.java 6986109 generic-all\n@@ -161,30 +157,0 @@\n-java\/awt\/Mixing\/AWT_Mixing\/MixingPanelsResizing.java 8049405 generic-all\n-java\/awt\/Mixing\/AWT_Mixing\/JComboBoxOverlapping.java 8049405 macosx-all\n-java\/awt\/Mixing\/AWT_Mixing\/JPopupMenuOverlapping.java 8049405 macosx-all\n-java\/awt\/Mixing\/AWT_Mixing\/JButtonInGlassPaneOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JButtonOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JColorChooserOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JEditorPaneInGlassPaneOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JEditorPaneOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JLabelInGlassPaneOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JLabelOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JListInGlassPaneOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JListOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JPanelInGlassPaneOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JPanelOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JProgressBarInGlassPaneOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JProgressBarOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JScrollBarInGlassPaneOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JScrollBarOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JSliderInGlassPaneOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JSliderOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JSpinnerInGlassPaneOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JSpinnerOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JTableInGlassPaneOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JTableOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JTextAreaInGlassPaneOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JTextAreaOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JTextFieldInGlassPaneOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JTextFieldOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JToggleButtonInGlassPaneOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JToggleButtonOverlapping.java 8158801 windows-all\n@@ -618,2 +584,0 @@\n-java\/rmi\/transport\/checkLeaseInfoLeak\/CheckLeaseLeak.java       7191877 generic-all\n-\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Graphics2D;\n+import java.awt.GraphicsEnvironment;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.VolatileImage;\n+import java.lang.ref.WeakReference;\n+\n+import jtreg.SkippedException;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 8364434\n+ * @summary Check that garbage-collecting Color before accelerated painting is complete does not cause artifacts.\n+ * @requires (os.family != \"linux\")\n+ * @library \/test\/lib\n+ * @run main\/othervm -Xms16m -Xmx16m WeakColorTest\n+ *\/\n+\n+public class WeakColorTest {\n+    public static void main(String[] args) throws Exception {\n+        BufferedImage bi = new BufferedImage(100, 100, BufferedImage.TYPE_INT_RGB); \/\/ This image is full-black.\n+        VolatileImage image = GraphicsEnvironment.getLocalGraphicsEnvironment()\n+                .getDefaultScreenDevice().getDefaultConfiguration().createCompatibleVolatileImage(100, 100);\n+        Graphics2D g = image.createGraphics();\n+\n+        \/\/ Create a new Color - we want it to be collected later.\n+        g.setColor(new Color(255, 0, 0));\n+        WeakReference<Color> color = new WeakReference<>(g.getColor());\n+\n+        g.fillRect(0, 0, 100, 100);\n+\n+        \/\/ Change color to prevent Graphics from keeping our Color alive.\n+        g.setColor(Color.BLACK);\n+\n+        \/\/ Force Color to be GC'ed.\n+        final int MAX_ITERATIONS = 1000, ARRAY_SIZE = 1000000;\n+        WeakReference<Object[]> array = null;\n+        for (int i = 0;; i++) {\n+            System.gc();\n+            if (color.get() == null) {\n+                System.out.println(\"Color collected at: \" + i);\n+                break;\n+            } else if (i >= MAX_ITERATIONS) {\n+                throw new SkippedException(\"Color was not collected after \" + MAX_ITERATIONS + \" iterations\");\n+            }\n+            Object[] a = new Object[ARRAY_SIZE];\n+            a[0] = array;\n+            array = new WeakReference<>(a);\n+        }\n+\n+        \/\/ Do a blit. If it succeeds, the resulting image will be full-black.\n+        g.drawImage(bi, 0, 0, null);\n+        g.dispose();\n+\n+        \/\/ We expect black. If it's red, then the blit must have failed.\n+        int actualColor = image.getSnapshot().getRGB(50, 50);\n+        if ((actualColor & 0xFFFFFF) != 0) throw new Error(\"Wrong color: 0x\" + Integer.toHexString(actualColor));\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/ColorClass\/WeakColorTest.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,1 @@\n+import java.awt.Component;\n@@ -26,0 +27,2 @@\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n@@ -29,0 +32,2 @@\n+import java.awt.event.WindowEvent;\n+import java.awt.event.WindowFocusListener;\n@@ -30,0 +35,4 @@\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.swing.FocusManager;\n@@ -109,0 +118,6 @@\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        f.addFocusListener(new FocusAdapter() {\n+            @Override public void focusGained(FocusEvent e) {\n+                latch.countDown();\n+            }\n+        });\n@@ -115,2 +130,14 @@\n-                        testedComponent.setBounds(0, 0, testedComponent.getPreferredSize().width, testedComponent.getPreferredSize().height + 20);\n-                        ancestorLoc = f.getLocationOnScreen();\n+                        testedComponent.setBounds(0, 0,\n+                                testedComponent.getPreferredSize().width,\n+                                testedComponent.getPreferredSize().height + 20);\n+                        boolean focus = f.requestFocusInWindow();\n+                        if (!focus) {\n+                            Component focusOwner =\n+                                    FocusManager.getCurrentManager()\n+                                            .getFocusOwner();\n+                            if (focusOwner == f) {\n+                                \/\/frame already had focus.\n+                                latch.countDown();\n+                            }\n+                        }\n+\n@@ -126,14 +153,11 @@\n-\n-            \/* this is a workaround for certain jtreg(?) focus issue:\n-               tests fail starting after failing mixing tests but always pass alone.\n-             *\/\n-            Util.waitForIdle(robot);\n-            ancestorLoc.translate(isOel7orLater() ? 5 : f.getWidth() \/ 2 - 15, 2);\n-            robot.mouseMove(ancestorLoc.x, ancestorLoc.y);\n-            Util.waitForIdle(robot);\n-            robot.mousePress(InputEvent.BUTTON1_MASK);\n-            robot.delay(50);\n-            robot.mouseRelease(InputEvent.BUTTON1_MASK);\n-            Util.waitForIdle(robot);\n-\n-            clickAndBlink(robot, lLoc);\n+            try {\n+                boolean await = latch.await(50, TimeUnit.MILLISECONDS);\n+                if (!await) {\n+                    throw new RuntimeException(\n+                            \"Ancestor frame didn't receive \" +\n+                                    \"focus\");\n+                }\n+                clickAndBlink(robot, lLoc);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n","filename":"test\/jdk\/java\/awt\/Mixing\/AWT_Mixing\/GlassPaneOverlappingTestBase.java","additions":41,"deletions":17,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n- * @run main JMenuBarOverlapping\n+ * @run main\/timeout=180 JMenuBarOverlapping\n","filename":"test\/jdk\/java\/awt\/Mixing\/AWT_Mixing\/JMenuBarOverlapping.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,0 +77,1 @@\n+                frame.setVisible(false);\n","filename":"test\/jdk\/java\/awt\/Mixing\/AWT_Mixing\/JPopupMenuOverlapping.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,0 +73,2 @@\n+        currentAwtControl.setForeground(Color.white);\n+        currentAwtControl.setBackground(Color.white);\n","filename":"test\/jdk\/java\/awt\/Mixing\/AWT_Mixing\/JSplitPaneOverlapping.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,1 @@\n+    static final int TOLERANCE_MACOSX = 15;\n@@ -118,0 +119,1 @@\n+\n@@ -123,0 +125,1 @@\n+\n@@ -160,1 +163,2 @@\n-                if (!c.equals(jbColor)) {\n+                System.out.println(\"Color picked for jbutton: \" + c);\n+                if (!isAlmostEqualColor(c, jbColor)) {\n@@ -166,1 +170,2 @@\n-                if (!c.equals(awtColor)) {\n+                System.out.println(\"Color picked for awtButton: \" + c);\n+                if (!isAlmostEqualColor(c, awtColor)) {\n@@ -172,1 +177,2 @@\n-                if (!c.equals(jb2Color)) {\n+                System.out.println(\"Color picked for jbutton2: \" + c);\n+                if (!isAlmostEqualColor(c, jb2Color)) {\n@@ -178,1 +184,2 @@\n-                if (!c.equals(awt2Color)) {\n+                System.out.println(\"Color picked for awtButton2: \" + c);\n+                if (!isAlmostEqualColor(c, awt2Color)) {\n@@ -224,0 +231,8 @@\n+        try {\n+            UIManager.setLookAndFeel(\n+                    UIManager.getCrossPlatformLookAndFeelClassName());\n+        }\n+        catch (Exception e) {\n+            throw  new RuntimeException(e);\n+        }\n+\n@@ -301,0 +316,11 @@\n+    private static boolean isAlmostEqualColor(Color color, Color refColor) {\n+        System.out.println(\"Comparing color: \" + color + \" with reference \" +\n+                \"color: \" + refColor);\n+        return color.equals(refColor) ||\n+               Math.abs(color.getRed() - refColor.getRed()) <\n+                       TOLERANCE_MACOSX &&\n+               Math.abs(color.getGreen() - refColor.getGreen()) <\n+                       TOLERANCE_MACOSX &&\n+               Math.abs(color.getBlue() - refColor.getBlue()) <\n+                       TOLERANCE_MACOSX;\n+    }\n","filename":"test\/jdk\/java\/awt\/Mixing\/AWT_Mixing\/MixingPanelsResizing.java","additions":31,"deletions":5,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -379,4 +379,3 @@\n-        if ((component instanceof java.awt.Scrollbar) || isMac && (component instanceof java.awt.Button)) {\n-            return false;\n-        }\n-        return true;\n+        return !(component == null ||\n+                (component instanceof java.awt.Scrollbar) ||\n+                (isMac && (component instanceof java.awt.Button)));\n","filename":"test\/jdk\/java\/awt\/Mixing\/AWT_Mixing\/OverlappingTestBase.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,4 +24,15 @@\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.util.regex.*;\n-import javax.swing.*;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.swing.JComponent;\n+import javax.swing.JFrame;\n+import javax.swing.SpringLayout;\n+\n@@ -144,10 +155,18 @@\n-        if( ancestor != null ) {\n-            Point ancestorLoc = ancestor.getLocationOnScreen();\n-            ancestorLoc.translate(isOel7orLater() ? 5 :\n-                                             ancestor.getWidth() \/ 2 - 15, 2);\n-            robot.mouseMove(ancestorLoc.x, ancestorLoc.y);\n-            Util.waitForIdle(robot);\n-            robot.mousePress(InputEvent.BUTTON1_MASK);\n-            robot.delay(50);\n-            robot.mouseRelease(InputEvent.BUTTON1_MASK);\n-            Util.waitForIdle(robot);\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        if (ancestor != null) {\n+            ancestor.addFocusListener(new FocusAdapter() {\n+                @Override public void focusGained(FocusEvent e) {\n+                    latch.countDown();\n+                }\n+            });\n+            ancestor.requestFocus();\n+        }\n+        try {\n+            boolean await = latch.await(50, TimeUnit.MILLISECONDS);\n+            if (!await) {\n+                throw new RuntimeException(\"Ancestor frame didn't receive \" +\n+                        \"focus\");\n+            }\n+            clickAndBlink(robot, lLoc);\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n@@ -155,3 +174,0 @@\n-\n-        clickAndBlink(robot, lLoc);\n-        Util.waitForIdle(robot);\n","filename":"test\/jdk\/java\/awt\/Mixing\/AWT_Mixing\/SimpleOverlappingTestBase.java","additions":34,"deletions":18,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run main LocaleFamilyNames\n+ * @run main\/othervm\/timeout=360 LocaleFamilyNames\n@@ -36,0 +36,1 @@\n+        System.out.println(\"Start time: \" + java.time.LocalDateTime.now());\n@@ -38,1 +39,0 @@\n-\n@@ -40,1 +40,0 @@\n-\n@@ -43,0 +42,3 @@\n+        System.out.println(\"Number of fonts: \" + all_fonts.length);\n+        System.out.println(\"Number of locales: \" + all_locales.length);\n+\n@@ -49,1 +51,0 @@\n-\n@@ -52,0 +53,2 @@\n+        System.out.println(\"Number of font families: \" + all_families.size());\n+        System.out.println(\"Time after preparing the font families HashSet: \" + java.time.LocalDateTime.now());\n","filename":"test\/jdk\/java\/awt\/font\/FontNames\/LocaleFamilyNames.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8361748\n+ * @summary Tests XBM image size limits and if XBMImageDecoder.produceImage()\n+ *          throws appropriate error when parsing invalid XBM image data.\n+ * @run main XBMDecoderTest\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.PrintStream;\n+import javax.swing.ImageIcon;\n+\n+public class XBMDecoderTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        String dir = System.getProperty(\"test.src\");\n+        PrintStream originalErr = System.err;\n+        boolean validCase;\n+\n+        File currentDir = new File(dir);\n+        File[] files = currentDir.listFiles((File d, String s)\n+                                            -> s.endsWith(\".xbm\"));\n+\n+        for (File file : files) {\n+            String fileName = file.getName();\n+            validCase = fileName.startsWith(\"valid\");\n+\n+            System.out.println(\"--- Testing \" + fileName + \" ---\");\n+            try (FileInputStream fis = new FileInputStream(file);\n+                 ByteArrayOutputStream errContent = new ByteArrayOutputStream()) {\n+                System.setErr(new PrintStream(errContent));\n+\n+                ImageIcon icon = new ImageIcon(fis.readAllBytes());\n+                boolean isErrEmpty = errContent.toString().isEmpty();\n+                if (!isErrEmpty) {\n+                    System.out.println(\"Expected ImageFormatException occurred.\");\n+                    System.out.print(errContent);\n+                }\n+\n+                if (validCase && !isErrEmpty) {\n+                    throw new RuntimeException(\"Test failed: Error stream not empty\");\n+                } else if (!validCase && isErrEmpty) {\n+                    throw new RuntimeException(\"Test failed: ImageFormatException\"\n+                            + \" expected but not thrown\");\n+                }\n+                System.out.println(\"PASSED\\n\");\n+            } finally {\n+                System.setErr(originalErr);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/image\/XBMDecoder\/XBMDecoderTest.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+#define k_ht 3\n+h` k[] = { 01x0, 42222222222236319330::\n","filename":"test\/jdk\/java\/awt\/image\/XBMDecoder\/invalid.xbm","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+#define k_wt 16\n+#define k_ht  1\n+k[] = { 0x10, 1234567890};\n","filename":"test\/jdk\/java\/awt\/image\/XBMDecoder\/invalid_hex.xbm","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+#define k_wt 16\n+#define k_ht  0\n+k[] = { 0x10, 0x12};\n","filename":"test\/jdk\/java\/awt\/image\/XBMDecoder\/invalid_ht.xbm","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+#define test_width 16\n+#define test_height 3\n+#define ht_x 1\n+#define ht_y 2\n+static unsigned char test_bits[] = {\n+0x13, 0x11, 0x15, 0x00, 0xAB, 0xcd };\n","filename":"test\/jdk\/java\/awt\/image\/XBMDecoder\/valid.xbm","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+#define test_width 16\n+#define test_height 2\n+static unsigned char test_bits[] = { 0x13, 0x11,\n+ 0xAB, 0xff };\n","filename":"test\/jdk\/java\/awt\/image\/XBMDecoder\/valid_hex.xbm","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=posix_spawn\n+ * @bug 8364611\n+ * @summary Check that childs start with SIG_DFL as SIGPIPE disposition\n+ * @requires os.family != \"windows\"\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -Djdk.lang.Process.launchMechanism=posix_spawn -agentlib:ChangeSignalDisposition TestChildSignalDisposition\n+ *\/\n+\n+\/**\n+ * @test id=fork\n+ * @bug 8364611\n+ * @summary Check that childs start with SIG_DFL as SIGPIPE disposition\n+ * @requires os.family != \"windows\"\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -Djdk.lang.Process.launchMechanism=fork -agentlib:ChangeSignalDisposition TestChildSignalDisposition\n+ *\/\n+\n+\/**\n+ * @test id=vfork\n+ * @bug 8364611\n+ * @summary Check that childs start with SIG_DFL as SIGPIPE disposition\n+ * @requires os.family == \"linux\"\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -Djdk.lang.Process.launchMechanism=vfork -agentlib:ChangeSignalDisposition TestChildSignalDisposition\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+public class TestChildSignalDisposition {\n+    \/\/ This test has two native parts:\n+    \/\/ - a library injected into the JVM with -agentlib changes signal disposition of the VM process for SIGPIPE to\n+    \/\/   SIG_IGN\n+    \/\/ - a small native executable that prints out, in its main function, all signal handler dispositions, to be executed\n+    \/\/   as a child process.\n+    \/\/\n+    \/\/ What should happen: In child process, SIGPIPE should be set to default.\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createNativeTestProcessBuilder(\"PrintSignalDisposition\");\n+        OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+        output.shouldHaveExitValue(0);\n+        output.shouldNotMatch(\"SIGPIPE: +ignore\");\n+        output.shouldNotMatch(\"SIGPIPE: +block\");\n+        output.shouldMatch(\"SIGPIPE: +default\");\n+        output.reportDiagnosticSummary();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/childSignalDisposition\/TestChildSignalDisposition.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <errno.h>\n+#include \"jvmti.h\"\n+#include <signal.h>\n+#include <stdio.h>\n+#include <unistd.h>\n+\n+static const struct { int sig; const char* name; } signals[] = {\n+    { SIGABRT, \"SIGABRT\" }, { SIGALRM, \"SIGALRM\" }, { SIGBUS, \"SIGBUS\" }, { SIGCHLD, \"SIGCHLD\" }, { SIGCONT, \"SIGCONT\" },\n+    { SIGFPE, \"SIGFPE\" }, { SIGHUP, \"SIGHUP\" }, { SIGILL, \"SIGILL\" }, { SIGINT, \"SIGINT\" }, { SIGKILL, \"SIGKILL\" },\n+    { SIGPIPE, \"SIGPIPE\" }, { SIGQUIT, \"SIGQUIT\" }, { SIGSEGV, \"SIGSEGV\" }, { SIGSTOP, \"SIGSTOP\" }, { SIGTERM, \"SIGTERM\" },\n+    { SIGTSTP, \"SIGTSTP\" }, { SIGTTIN, \"SIGTTIN\" }, { SIGTTOU, \"SIGTTOU\" }, { SIGUSR1, \"SIGUSR1\" }, { SIGUSR2, \"SIGUSR2\" },\n+#ifdef SIGPOLL\n+    { SIGPOLL, \"SIGPOLL\" },\n+#endif\n+    { SIGPROF, \"SIGPROF\" }, { SIGSYS, \"SIGSYS\" }, { SIGTRAP, \"SIGTRAP\" }, { SIGURG, \"SIGURG\" }, { SIGVTALRM, \"SIGVTALRM\" },\n+    { SIGXCPU, \"SIGXCPU\" }, { SIGXFSZ, \"SIGXFSZ\" }, { -1, NULL }\n+};\n+\n+int main(int argc, char** argv) {\n+\n+    printf(\"PID: %d\\n\", getpid());\n+\n+    sigset_t current_mask;\n+    sigemptyset(&current_mask);\n+    if (sigprocmask(SIG_BLOCK \/* ignored *\/, NULL, &current_mask) != 0) {\n+        printf(\"sigprocmask %d\\n\", errno);\n+        return -1;\n+    }\n+\n+    for (int n = 0; signals[n].sig != -1; n++) {\n+        printf(\"%s: \", signals[n].name);\n+        if (sigismember(&current_mask, signals[n].sig)) {\n+            printf(\"blocked \");\n+        }\n+        struct sigaction act;\n+        if (sigaction(signals[n].sig, NULL, &act) != 0) {\n+            printf(\"sigaction %d\\n\", errno);\n+            printf(\"\\n\");\n+            continue;\n+        }\n+        const void* const handler = (act.sa_flags & SA_SIGINFO ?\n+                                    (void*)act.sa_sigaction : (void*)act.sa_handler);\n+        if (handler == (void*)SIG_DFL) {\n+            printf(\"default \");\n+        } else if (handler == (void*)SIG_IGN) {\n+            printf(\"ignore \");\n+        } else if (handler == (void*)SIG_HOLD) {\n+            printf(\"hold \");\n+        } else {\n+            printf(\"%p \", handler);\n+        }\n+        printf(\"%X\\n\", act.sa_flags);\n+    }\n+\n+    return 0;\n+}\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/childSignalDisposition\/exePrintSignalDisposition.c","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <errno.h>\n+#include \"jvmti.h\"\n+#include <signal.h>\n+#include <stdio.h>\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+\n+  if (signal(SIGPIPE, SIG_IGN) != SIG_ERR) {\n+    printf(\"changed signal disposition for SIGPIPE to SIG_IGN\\n\");\n+  } else {\n+    printf(\"FAILED to change signal disposition for SIGPIPE to SIG_IGN (%d)\\n\", errno);\n+    return JNI_ERR;\n+  }\n+\n+  return JNI_OK;\n+}\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/childSignalDisposition\/libChangeSignalDisposition.c","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8139688\n+ * @bug 8139688 8362376\n@@ -90,0 +90,4 @@\n+\n+            \/\/ Test values near 0.5*ln*(2) and 1.5*ln(2) to check refactoring\n+            {0.34657359027997275,                  1.4142135623730951},\n+            {1.0397207708399183,                   2.828427124746191},\n","filename":"test\/jdk\/java\/lang\/StrictMath\/ExpTests.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8136874\n+ * @bug 8136874 8362376\n@@ -286,0 +286,15 @@\n+            \/\/ Check refactoring, abs(y) < 2^31, x < sqrt(3\/2), x < sqrt(3)\n+            {1.2, \/\/ x < sqrt(3\/2)\n+             5.0,\n+             2.4883199999999994\n+            },\n+\n+            {1.4142135623730951, \/\/ sqrt(3\/2) < x < sqrt(3)\n+             5.0,\n+             5.656854249492382\n+            },\n+\n+            {2.23606797749979, \/\/ x > sqrt(3)\n+             5.0,\n+             55.901699437494756\n+            },\n","filename":"test\/jdk\/java\/lang\/StrictMath\/PowTests.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2021, Tencent. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ParkWithFixedThreadPool.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,3 +26,1 @@\n- * @bug 8351045 8351996\n- * @enablePreview\n- * @comment Remove preview if ScopedValue is finalized\n+ * @bug 8351045 8351996 8358535\n@@ -30,0 +28,1 @@\n+ * @modules java.base\/java.lang:+open\n@@ -36,0 +35,1 @@\n+import java.lang.invoke.MethodHandle;\n@@ -37,0 +37,1 @@\n+import java.lang.invoke.MethodType;\n@@ -42,1 +43,0 @@\n-import java.util.Iterator;\n@@ -52,1 +52,0 @@\n-import org.junit.jupiter.api.RepeatedTest;\n@@ -54,1 +53,0 @@\n-import org.junit.jupiter.api.Timeout;\n@@ -482,0 +480,63 @@\n+\n+    \/\/ ClassValue cache invalidated and not reinstated when another\n+    \/\/ unrelated entry is removed\n+    @Test\n+    public void testCacheRefresh() throws Throwable {\n+        \/\/ Setup\n+        var lookup = MethodHandles.privateLookupIn(ClassValue.class, MethodHandles.lookup());\n+        var classValueEntryClass = Class.forName(\"java.lang.ClassValue$Entry\");\n+        MethodHandle getCacheCarefully = lookup.findStatic(ClassValue.class, \"getCacheCarefully\",\n+                MethodType.methodType(classValueEntryClass.arrayType(), Class.class));\n+        var classValueMapClass = Class.forName(\"java.lang.ClassValue$ClassValueMap\");\n+        MethodHandle probeHomeLocation = lookup.findStatic(classValueMapClass, \"probeHomeLocation\",\n+                MethodType.methodType(classValueEntryClass, classValueEntryClass.arrayType(), ClassValue.class));\n+        MethodHandle match = lookup.findVirtual(ClassValue.class, \"match\",\n+                MethodType.methodType(boolean.class, classValueEntryClass));\n+\n+        \/\/ Work\n+        ClassValue<?> clv = new ClassValue<>() {\n+            @Override\n+            protected String computeValue(Class<?> type) {\n+                return \"\";\n+            }\n+        };\n+        \/\/ A class that shouldn't have arbitrary values stuffing the cache\n+        var cleanClass = clv.getClass();\n+        clv.get(cleanClass); \/\/ create cache on clean class\n+        assertTrue(checkDirectCacheMatch(\n+                getCacheCarefully,\n+                probeHomeLocation,\n+                match,\n+                clv,\n+                cleanClass\n+        ));\n+        clv.get(int.class);\n+        clv.remove(int.class); \/\/ invalidate cache on clean class\n+        assertFalse(checkDirectCacheMatch(\n+                getCacheCarefully,\n+                probeHomeLocation,\n+                match,\n+                clv,\n+                cleanClass\n+        ));\n+        clv.get(cleanClass);\n+        assertTrue(checkDirectCacheMatch(\n+                getCacheCarefully,\n+                probeHomeLocation,\n+                match,\n+                clv,\n+                cleanClass\n+        ));\n+    }\n+\n+    private static boolean checkDirectCacheMatch(\n+            MethodHandle getCacheCarefully,\n+            MethodHandle probeHomeLocation,\n+            MethodHandle match,\n+            ClassValue<?> clv,\n+            Class<?> cl\n+    ) throws Throwable {\n+        Object cache = getCacheCarefully.invoke(cl);\n+        Object entry = probeHomeLocation.invoke(cache, clv);\n+        return (boolean) match.invoke(clv, entry);\n+    }\n","filename":"test\/jdk\/java\/lang\/invoke\/ClassValueTest.java","additions":67,"deletions":6,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.CookieManager;\n+import java.net.CookieStore;\n+import java.net.HttpCookie;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+\/*\n+ * @test\n+ * @bug 8365086\n+ * @summary verify that the implementation of java.net.CookieStore works\n+ *          as expected\n+ * @run junit CookieStoreTest\n+ *\/\n+class CookieStoreTest {\n+\n+    \/\/ neither the scheme, host nor the port matters in this test\n+    private static final URI COOKIE_TEST_URI = URI.create(\"https:\/\/127.0.0.1:12345\");\n+\n+    static List<Arguments> cookieStores() {\n+        final List<Arguments> params = new ArrayList<>();\n+        \/\/ empty CookieStore\n+        params.add(Arguments.of(new CookieManager().getCookieStore(), true));\n+\n+        final CookieStore cookieStore = new CookieManager().getCookieStore();\n+        cookieStore.add(COOKIE_TEST_URI, new HttpCookie(\"foo\", \"bar\"));\n+        \/\/ non-empty CookieStore\n+        params.add(Arguments.of(cookieStore, false));\n+\n+        return params;\n+    }\n+\n+    \/*\n+     * Verify that the List returned by CookieStore.getURIs() is immutable.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"cookieStores\")\n+    void testImmutableGetURIs(final CookieStore cookieStore, final boolean expectEmpty) {\n+        final List<URI> uris = cookieStore.getURIs();\n+        assertNotNull(uris, \"CookieStore.getURIs() returned null\");\n+        assertEquals(expectEmpty, uris.isEmpty(), \"CookieStore.getURIs() returned: \" + uris);\n+        assertImmutableList(uris, COOKIE_TEST_URI);\n+    }\n+\n+    \/*\n+     * Verify that the List returned by CookieStore.getCookies() is immutable.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"cookieStores\")\n+    void testImmutableGetCookies(final CookieStore cookieStore, final boolean expectEmpty) {\n+        final List<HttpCookie> cookies = cookieStore.getCookies();\n+        assertNotNull(cookies, \"CookieStore.getCookies() returned null\");\n+        assertEquals(expectEmpty, cookies.isEmpty(), \"CookieStore.getCookies() returned: \" + cookies);\n+        assertImmutableList(cookies, new HttpCookie(\"hello\", \"world\"));\n+    }\n+\n+    \/*\n+     * Verify that the List returned by CookieStore.get(URI) is immutable.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"cookieStores\")\n+    void testImmutableGetCookiesForURI(final CookieStore cookieStore, final boolean expectEmpty) {\n+        final List<HttpCookie> cookies = cookieStore.get(COOKIE_TEST_URI);\n+        assertNotNull(cookies, \"CookieStore.get(URI) returned null\");\n+        assertEquals(expectEmpty, cookies.isEmpty(), \"CookieStore.get(URI) returned: \" + cookies);\n+        assertImmutableList(cookies, new HttpCookie(\"hello\", \"world\"));\n+    }\n+\n+    \/*\n+     * Verifies that the attempt to modify the contents of the list will fail\n+     * due to the list being immutable.\n+     *\/\n+    private static <T> void assertImmutableList(final List<T> list, T elementToAddOrRemove) {\n+        \/\/ the list is expected to be immutable, so each of these operations must fail\n+        assertThrows(UnsupportedOperationException.class, () -> list.add(elementToAddOrRemove));\n+        assertThrows(UnsupportedOperationException.class, () -> list.remove(elementToAddOrRemove));\n+        assertThrows(UnsupportedOperationException.class, list::clear);\n+        \/\/ even try the replace operation when the list isn't empty\n+        if (!list.isEmpty()) {\n+            assertThrows(UnsupportedOperationException.class, () -> list.set(0, elementToAddOrRemove));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/CookieStoreTest.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test that Response Message gets set even if a non 100 response\n+ *          gets return when Expect Continue is set\n+ * @bug 8352502\n+ * @library \/test\/lib\n+ * @run junit\/othervm -Djdk.internal.httpclient.debug=true\n+ *                    -Djdk.httpclient.HttpClient.log=all\n+ *                    HttpUrlConnectionExpectContinueResponseMessageTest\n+ *\/\n+\n+import jdk.test.lib.net.URIBuilder;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.net.HttpURLConnection;\n+import java.net.Socket;\n+import java.net.ServerSocket;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URL;\n+import java.util.StringTokenizer;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n+public class HttpUrlConnectionExpectContinueResponseMessageTest {\n+    class Control {\n+        volatile ServerSocket serverSocket = null;\n+        volatile boolean stop = false;\n+        volatile String response = null;\n+        volatile Socket acceptingSocket = null;\n+        volatile String testPath = null;\n+    }\n+\n+    private Thread serverThread = null;\n+    private volatile Control control;\n+    static final Logger logger;\n+\n+    static {\n+        logger = Logger.getLogger(\"sun.net.www.protocol.http.HttpURLConnection\");\n+        logger.setLevel(Level.ALL);\n+        Logger.getLogger(\"\").getHandlers()[0].setLevel(Level.ALL);\n+    }\n+\n+    public Object[][] args() {\n+        return new Object[][]{\n+                \/\/ Expected Status Code, Status Line, Expected responseMessage\n+                { 404, \"HTTP\/1.1 404 Not Found\", \"Not Found\" },\n+                { 405, \"HTTP\/1.1 405 Method Not Allowed\", \"Method Not Allowed\" },\n+                { 401, \"HTTP\/1.1 401 Unauthorized\", \"Unauthorized\"}\n+        };\n+    }\n+\n+    @BeforeAll\n+    public void startServerSocket() throws Exception {\n+        Control control = this.control = new Control();\n+\n+        control.serverSocket = new ServerSocket();\n+        control.serverSocket.setReuseAddress(true);\n+        control.serverSocket.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+        Runnable runnable = () -> {\n+            while (!control.stop) {\n+                try {\n+                    Socket socket = control.serverSocket.accept();\n+                    String path = getPath(socket);\n+\n+                    OutputStream outputStream;\n+                    if (path.equals(control.testPath)) {\n+                        control.acceptingSocket = socket;\n+                        outputStream = control.acceptingSocket.getOutputStream();\n+\n+                        \/\/ send a wrong response and then shutdown\n+                        outputStream.write(control.response.getBytes());\n+                        outputStream.flush();\n+                        control.acceptingSocket.shutdownOutput();\n+                    } else {\n+                        \/\/ stray request showed up, return 500 and close socket\n+                        outputStream = socket.getOutputStream();\n+                        outputStream.write(\"HTTP\/1.1 500 Internal Server Error\\r\\n\".getBytes());\n+                        outputStream.write(\"Connection: close\\r\\n\".getBytes());\n+                        outputStream.write(\"Content-Length: 0\\r\\n\".getBytes());\n+                        outputStream.write(\"\\r\\n\".getBytes());\n+                        outputStream.flush();\n+                        socket.close();\n+                    }\n+                } catch (Exception e) {\n+                    \/\/ Any exceptions will be ignored\n+                }\n+            }\n+        };\n+        serverThread = new Thread(runnable);\n+        serverThread.start();\n+    }\n+\n+    private static String getPath(Socket socket) throws IOException {\n+        InputStream inputStream = socket.getInputStream();\n+        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n+\n+        StringBuilder reqBuilder = new StringBuilder();\n+        String line = null;\n+        while (!(line = reader.readLine()).isEmpty()) {\n+            reqBuilder.append(line + \"\\r\\n\");\n+        }\n+        String req = reqBuilder.toString();\n+        StringTokenizer tokenizer = new StringTokenizer(req);\n+        String method = tokenizer.nextToken();\n+        String path = tokenizer.nextToken();\n+        return path;\n+    }\n+\n+    @AfterAll\n+    public void stopServerSocket() throws Exception {\n+        Control control = this.control;\n+        control.stop = true;\n+        control.serverSocket.close();\n+        serverThread.join();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"args\")\n+    public void test(int expectedCode, String statusLine, String expectedMessage) throws Exception {\n+        String body = \"Testing: \" + expectedCode;\n+        Control control = this.control;\n+        control.response = statusLine + \"\\r\\n\"\n+                + \"Content-Length: 0\\r\\n\"\n+                + \"\\r\\n\";\n+        control.testPath = \"\/ContinueResponseMessageTest\/\" + expectedCode;\n+\n+        URL url = URIBuilder.newBuilder()\n+                .scheme(\"http\")\n+                .loopback()\n+                .port(control.serverSocket.getLocalPort())\n+                .path(control.testPath)\n+                .toURL();\n+\n+        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n+        connection.setDoOutput(true);\n+        connection.setRequestMethod(\"POST\");\n+        connection.setRequestProperty(\"Connection\", \"Close\");\n+        connection.setRequestProperty(\"Expect\", \"100-Continue\");\n+\n+        try {\n+            connection.setFixedLengthStreamingMode(body.getBytes().length);\n+            OutputStream outputStream = connection.getOutputStream();\n+            outputStream.write(body.getBytes());\n+            outputStream.close();\n+        } catch (Exception ex) {\n+            \/\/ server returning 4xx responses can result in exceptions\n+            \/\/ but we can just swallow them\n+        }\n+\n+        int responseCode = connection.getResponseCode();\n+        String responseMessage = connection.getResponseMessage();\n+        assertTrue(responseCode == expectedCode,\n+                String.format(\"Expected %s response, instead received %s\", expectedCode, responseCode));\n+        assertTrue(expectedMessage.equals(responseMessage),\n+                String.format(\"Expected Response Message  %s, instead received %s\",\n+                        expectedMessage, responseMessage));\n+        control.acceptingSocket.close();\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/HttpURLConnection\/HttpUrlConnectionExpectContinueResponseMessageTest.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -47,0 +47,1 @@\n+import java.util.concurrent.ExecutorService;\n@@ -55,0 +56,2 @@\n+    private static final String HELLO = \"Hello\";\n+\n@@ -68,1 +71,2 @@\n-        server.setExecutor(Executors.newThreadPerTaskExecutor(factory));\n+        final ExecutorService serverExecutor = Executors.newThreadPerTaskExecutor(factory);\n+        server.setExecutor(serverExecutor);\n@@ -70,4 +74,11 @@\n-            byte[] response = \"Hello\".getBytes(\"UTF-8\");\n-            e.sendResponseHeaders(200, response.length);\n-            try (OutputStream out = e.getResponseBody()) {\n-                out.write(response);\n+            try {\n+                byte[] response = HELLO.getBytes(\"UTF-8\");\n+                e.sendResponseHeaders(200, response.length);\n+                try (OutputStream out = e.getResponseBody()) {\n+                    out.write(response);\n+                }\n+            } catch (Throwable t) {\n+                System.err.println(\"failed to handle request \" + e.getRequestURI()\n+                        + \" due to: \" + t);\n+                t.printStackTrace();\n+                throw t; \/\/ let it propagate\n@@ -88,5 +99,11 @@\n-        try {\n-            factory = Thread.ofVirtual().name(\"fetcher-\", 0).factory();\n-            try (var executor = Executors.newThreadPerTaskExecutor(factory)) {\n-                for (int i = 1; i <= requests; i++) {\n-                    executor.submit(() -> fetch(url)).get();\n+        try (serverExecutor) {\n+            try {\n+                factory = Thread.ofVirtual().name(\"fetcher-\", 0).factory();\n+                try (var executor = Executors.newThreadPerTaskExecutor(factory)) {\n+                    for (int i = 1; i <= requests; i++) {\n+                        final String actual = executor.submit(() -> fetch(url)).get();\n+                        if (!HELLO.equals(actual)) {\n+                            throw new RuntimeException(\"unexpected response: \\\"\" + actual\n+                                    + \"\\\" for request \" + i);\n+                        }\n+                    }\n@@ -94,0 +111,2 @@\n+            } finally {\n+                server.stop(1);\n@@ -95,2 +114,0 @@\n-        } finally {\n-            server.stop(1);\n","filename":"test\/jdk\/java\/net\/vthread\/HttpALot.java","additions":31,"deletions":14,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- * @bug 8343110 8361299\n+ * @bug 8343110 8361299 8364345\n@@ -48,1 +48,1 @@\n- * @summary tests the CharBuffer implementations behaving as CharSequence in various states (position, limit, offset)\n+ * @summary Tests CharBuffer implementations of CharSequence\n@@ -64,0 +64,4 @@\n+    \/**\n+     * Randomly adjusts the position and limit such that the position will be in the\n+     * first 1\/4th and the limit in the last half.\n+     *\/\n@@ -66,2 +70,2 @@\n-        int start = RAND.nextInt(mid - 3); \/\/ from 0 to mid\n-        int end = RAND.nextInt(mid + 3, cb.capacity()); \/\/ from mid to capacity\n+        int start = RAND.nextInt(mid >> 1); \/\/ from 0 to 1\/4\n+        int end = RAND.nextInt(mid + 1, cb.capacity()); \/\/ from mid to capacity\n@@ -73,0 +77,9 @@\n+    \/**\n+     * Generates random content to use for populating <i>cb<\/i> then calling through\n+     * to {@code addCases(String, char[], CharBuffer, List)}\n+     *\n+     * @param type  String description of the type of CharBuffer under test.\n+     * @param cb    CharBuffer instance to populate as base of creating cases.\n+     * @param cases The {@code List} to populate with the cases for use from\n+     *              {@link #charBufferArguments()}.\n+     *\/\n@@ -81,0 +94,12 @@\n+    \/**\n+     * Adds 4 cases to <i>cases<\/i>.\n+     * <ul>\n+     * <li>Full use of cb<\/li>.\n+     * <li>A duplicate of <i>cb<\/i> with a randomized position and limit. See\n+     * {@code randomizeRange(CharBuffer)}\n+     * <li>\n+     * <li>A {@link CharBuffer#slice() sliced} copy of randomized range.<\/li>\n+     * <li>A {@link CharBuffer#slice() sliced} copy of randomized range with a\n+     * randomized position and limit.<\/li>\n+     * <\/ul>\n+     *\/\n@@ -86,2 +111,4 @@\n-        cases.add(Arguments.of(rndRange, buf, rndRange.position(), rndRange.limit(), type + \"  at \" + rndRange.position() + \" through \" + rndRange.limit()));\n-        cases.add(Arguments.of(rndRange.slice(), buf, rndRange.position(), rndRange.limit(), type + \" sliced at \" + rndRange.position() + \" through \" + rndRange.limit()));\n+        cases.add(Arguments.of(rndRange, buf, rndRange.position(), rndRange.limit(),\n+                type + \" at \" + rndRange.position() + \" through \" + rndRange.limit()));\n+        cases.add(Arguments.of(rndRange.slice(), buf, rndRange.position(), rndRange.limit(),\n+                type + \" sliced at \" + rndRange.position() + \" through \" + rndRange.limit()));\n@@ -90,1 +117,6 @@\n-        cases.add(Arguments.of(rndSlicedRange, buf, rndRange.position() + rndSlicedRange.position(), rndRange.position() + rndSlicedRange.limit(), type + \" sliced at \" + rndRange.position() + \" with position \" + rndSlicedRange.position() + \" and limit \" + rndSlicedRange.limit()));\n+        cases.add(Arguments.of(rndSlicedRange,\n+                               buf,\n+                               rndRange.position() + rndSlicedRange.position(),\n+                               rndRange.position() + rndSlicedRange.limit(),\n+                               type + \" sliced at \" + rndRange.position() + \" with position \" +\n+                               rndSlicedRange.position() + \" and limit \" + rndSlicedRange.limit()));\n@@ -93,0 +125,33 @@\n+    \/**\n+     * Returns a {@code List} of {@link Arguments}, with each entry representing a\n+     * test case scenario.\n+     * <ul>\n+     *   <li>CharBuffer - the instance to be tested<\/li>\n+     *   <li>char[] - the data expected to be backing the current state of the CharBuffer<\/li>\n+     *   <li>int start - index (inclusive) into char[] where the CharBuffer should be positioned<\/li>\n+     *   <li>int stop - index (exclusive) into char[] where the CharBuffer should be limited<\/li>\n+     *   <li>String - description of the test scenario<\/li>\n+     * <\/ul>\n+     *\n+     * Generates the following sets of arguments\/test cases.\n+     * <ul>\n+     *   <li>See {@code populateAndAddCases(String, CharBuffer, List)} for the\n+     *       following types:\n+     *     <ul>\n+     *       <li>HeapCharBuffer<\/i>\n+     *       <li>HeapByteBuffer Big Endian<\/i>\n+     *       <li>HeapByteBuffer Little Endian<\/i>\n+     *       <li>DirectByteBuffer Big Endian<\/i>\n+     *       <li>DirectByteBuffer Little Endian<\/i>\n+     *     <\/ul>\n+     *   <\/li>\n+     *   <li>Randomly generated content into {@link CharBuffer#wrap(CharSequence)\n+     *       StringCharBuffer} - see {@code addCases(String, char[], CharBuffer, List)}.\n+     *     <ul>\n+     *       <li>StringCharBuffer wrapping a {@code CharBuffer} created from\n+     *           {@link CharBuffer#wrap(char[])}<\/li>\n+     *       <li>StringCharBuffer wrapping a {@code String}<\/li>\n+     *     <\/ul>\n+     *   <\/li>\n+     * <\/ul>\n+     *\/\n@@ -97,4 +162,8 @@\n-        populateAndAddCases(\"BEHeapByteBuffer\", ByteBuffer.allocate(SIZE*2).order(ByteOrder.BIG_ENDIAN).asCharBuffer(), args);\n-        populateAndAddCases(\"LEHeapByteBuffer\", ByteBuffer.allocate(SIZE*2).order(ByteOrder.LITTLE_ENDIAN).asCharBuffer(), args);\n-        populateAndAddCases(\"BEDirectByteBuffer\", ByteBuffer.allocateDirect(SIZE*2).order(ByteOrder.BIG_ENDIAN).asCharBuffer(), args);\n-        populateAndAddCases(\"LEDirectByteBuffer\", ByteBuffer.allocateDirect(SIZE*2).order(ByteOrder.LITTLE_ENDIAN).asCharBuffer(), args);\n+        populateAndAddCases(\"HeapByteBuffer BE\",\n+                ByteBuffer.allocate(SIZE * 2).order(ByteOrder.BIG_ENDIAN).asCharBuffer(), args);\n+        populateAndAddCases(\"HeapByteBuffer LE\",\n+                ByteBuffer.allocate(SIZE * 2).order(ByteOrder.LITTLE_ENDIAN).asCharBuffer(), args);\n+        populateAndAddCases(\"DirectByteBuffer BE\",\n+                ByteBuffer.allocateDirect(SIZE * 2).order(ByteOrder.BIG_ENDIAN).asCharBuffer(), args);\n+        populateAndAddCases(\"DirectByteBuffer LE\",\n+                ByteBuffer.allocateDirect(SIZE * 2).order(ByteOrder.LITTLE_ENDIAN).asCharBuffer(), args);\n@@ -108,75 +177,0 @@\n-        \/\/ nothing magic about 1273, it is just larger than 1k and an odd number - eliminating any alignment assumptions\n-        char[] buf = new char[1273];\n-        for (int i = 0; i < buf.length; ++i) {\n-            buf[i] = (char) i;\n-        }\n-        String stringBuf = new String(buf);\n-\n-        \/\/ nothing magic about 7, it is simply an odd number to advance - making sure no expectations of alignment\n-        \/\/ comparing to 29 results in 5 loops (0, 7, 14, 21, 28), giving decent coverage of offset and limits\n-        for (int i = 0; i < 29; i += 7) {\n-            CharBuffer buffer = CharBuffer.wrap(buf, i, buf.length - i);\n-            args.add(Arguments.of(buffer, buf, i, buf.length, \"HeapCharBuffer index \" + i + \" to end\"));\n-            args.add(Arguments.of(buffer.slice(), buf, i, buf.length, \"HeapCharBuffer slice \" + i + \" to end\"));\n-\n-            args.add(Arguments.of(CharBuffer.wrap(new String(buf, i, buf.length - i)), buf, i, buf.length,\n-                    \"StringCharBuffer index \" + i + \" to end\"));\n-            buffer = CharBuffer.wrap(stringBuf);\n-            buffer.position(i);\n-            args.add(Arguments.of(buffer.slice(), buf, i, buf.length, \"StringCharBuffer slice \" + i + \" to end\"));\n-\n-            CharBuffer lehbbAsCB = ByteBuffer.allocate(buf.length * 2)\n-                                             .order(ByteOrder.LITTLE_ENDIAN)\n-                                             .asCharBuffer()\n-                                             .put(buf)\n-                                             .position(i);\n-            args.add(Arguments.of(lehbbAsCB, buf, i, buf.length, \"LE HeapByteBuffer as CharBuffer index \" + i + \" to end\"));\n-\n-            CharBuffer behbdAsCB = ByteBuffer.allocateDirect(buf.length * 2)\n-                                             .order(ByteOrder.BIG_ENDIAN)\n-                                             .asCharBuffer()\n-                                             .put(buf)\n-                                             .position(i);\n-            args.add(Arguments.of(behbdAsCB, buf, i, buf.length,\n-                    \"BE DirectByteBuffer as CharBuffer index \" + i + \" to end\"));\n-\n-            if (i > 0) {\n-                buffer = CharBuffer.wrap(buf, 1, buf.length - 1).slice();\n-                buffer.position(i - 1);\n-                args.add(Arguments.of(buffer, buf, i, buf.length,\n-                        \"HeapCharBuffer slice\/offset 1 index \" + (i - 1) + \" to end\"));\n-\n-                int end = buf.length - i;\n-\n-                buffer = CharBuffer.wrap(buf, i, buf.length - (2 * i));\n-                args.add(Arguments.of(buffer, buf, i, end, \"HeapCharBuffer index \" + i + \" to \" + end));\n-                args.add(Arguments.of(buffer.slice(), buf, i, end, \"HeapCharBuffer slice \" + i + \" to \" + end));\n-\n-                args.add(Arguments.of(CharBuffer.wrap(new String(buf, i, buf.length - (2 * i))), buf, i, end,\n-                        \"StringCharBuffer index \" + i + \" to \" + end));\n-                buffer = CharBuffer.wrap(stringBuf);\n-                buffer.position(i);\n-                buffer.limit(end);\n-                args.add(Arguments.of(buffer.slice(), buf, i, end, \"StringCharBuffer slice \" + i + \" to \" + end));\n-\n-                CharBuffer behbbAsCB = ByteBuffer.allocate(buf.length * 2)\n-                                                 .order(ByteOrder.BIG_ENDIAN)\n-                                                 .asCharBuffer()\n-                                                 .put(buf)\n-                                                 .position(1)\n-                                                 .slice()\n-                                                 .position(i - 1)\n-                                                 .limit(end - 1);\n-                args.add(Arguments.of(behbbAsCB, buf, i, buf.length - i, \"BE HeapByteBuffer as CharBuffer index \" + i + \" to \" + end));\n-\n-                CharBuffer ledbbAsCB = ByteBuffer.allocateDirect(buf.length * 2)\n-                                                 .order(ByteOrder.LITTLE_ENDIAN)\n-                                                 .asCharBuffer()\n-                                                 .put(buf)\n-                                                 .position(1)\n-                                                 .slice()\n-                                                 .position(i - 1)\n-                                                 .limit(end - 1);\n-                args.add(Arguments.of(ledbbAsCB, buf, i, buf.length - i, \"LE DirectByteBuffer as CharBuffer index \" + i + \" to \" + end));\n-            }\n-        }\n@@ -227,1 +221,1 @@\n-    void testGetCharsNegativeSourceBeg(CharSequence actual, char[] expected, int start, int stop, String description) {\n+    void testGetCharsNegativeSrcBegin(CharSequence actual, char[] expected, int start, int stop, String description) {\n@@ -234,1 +228,1 @@\n-    void testGetCharsNegativeSourceEnd(CharSequence actual, char[] expected, int start, int stop, String description) {\n+    void testGetCharsNegativeSrcEnd(CharSequence actual, char[] expected, int start, int stop, String description) {\n@@ -241,1 +235,1 @@\n-    void testGetCharsSourceEndBeforeBeg(CharSequence actual, char[] expected, int start, int stop, String description) {\n+    void testGetCharsSrcEndBeforeBegin(CharSequence actual, char[] expected, int start, int stop, String description) {\n@@ -248,1 +242,1 @@\n-    void testGetCharsNegativeDestBeg(CharSequence actual, char[] expected, int start, int stop, String description) {\n+    void testGetCharsNegativeDstBegin(CharSequence actual, char[] expected, int start, int stop, String description) {\n@@ -255,1 +249,1 @@\n-    void testGetCharsDestBegOOB(CharSequence actual, char[] expected, int start, int stop, String description) {\n+    void testGetCharsDstBeginOOB(CharSequence actual, char[] expected, int start, int stop, String description) {\n@@ -262,1 +256,1 @@\n-    void testGetCharsDestLengthOOB(CharSequence actual, char[] expected, int start, int stop, String description) {\n+    void testGetCharsDstLengthOOB(CharSequence actual, char[] expected, int start, int stop, String description) {\n","filename":"test\/jdk\/java\/nio\/Buffer\/CharBufferAsCharSequenceTest.java","additions":86,"deletions":92,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4607272\n+ * @bug 4607272 8364761\n@@ -28,1 +28,1 @@\n- * @run main AsExecutor\n+ * @run junit AsExecutor\n@@ -31,0 +31,1 @@\n+import java.io.IOException;\n@@ -32,0 +33,2 @@\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -36,0 +39,8 @@\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n@@ -38,0 +49,6 @@\n+    private static ThreadFactory factory;\n+\n+    @BeforeAll\n+    public static void createThreadFactory() {\n+         factory = Executors.defaultThreadFactory();\n+    }\n@@ -39,9 +56,10 @@\n-    public static void main(String[] args) throws Exception {\n-        \/\/ create channel groups\n-        ThreadFactory factory = Executors.defaultThreadFactory();\n-        AsynchronousChannelGroup group1 = AsynchronousChannelGroup\n-            .withFixedThreadPool(5, factory);\n-        AsynchronousChannelGroup group2 = AsynchronousChannelGroup\n-            .withCachedThreadPool(Executors.newCachedThreadPool(factory), 0);\n-        AsynchronousChannelGroup group3 = AsynchronousChannelGroup\n-            .withThreadPool(Executors.newFixedThreadPool(10, factory));\n+    private static Stream<Arguments> channelGroups() throws IOException {\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(AsynchronousChannelGroup\n+            .withFixedThreadPool(5, factory)));\n+        list.add(Arguments.of(AsynchronousChannelGroup\n+            .withCachedThreadPool(Executors.newCachedThreadPool(factory), 0)));\n+        list.add(Arguments.of(AsynchronousChannelGroup\n+            .withThreadPool(Executors.newFixedThreadPool(10, factory))));\n+        return list.stream();\n+    }\n@@ -49,0 +67,5 @@\n+    @ParameterizedTest\n+    @MethodSource(\"channelGroups\")\n+    public void simpleTask(AsynchronousChannelGroup group)\n+        throws InterruptedException\n+    {\n@@ -50,4 +73,8 @@\n-            \/\/ execute simple tasks\n-            testSimpleTask(group1);\n-            testSimpleTask(group2);\n-            testSimpleTask(group3);\n+            Executor executor = (Executor)group;\n+            final CountDownLatch latch = new CountDownLatch(1);\n+            executor.execute(new Runnable() {\n+                    public void run() {\n+                        latch.countDown();\n+                    }\n+                });\n+            latch.await();\n@@ -55,3 +82,1 @@\n-            group1.shutdown();\n-            group2.shutdown();\n-            group3.shutdown();\n+            group.shutdown();\n@@ -61,1 +86,3 @@\n-    static void testSimpleTask(AsynchronousChannelGroup group) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"channelGroups\")\n+    public void nullTask(AsynchronousChannelGroup group) {\n@@ -63,7 +90,6 @@\n-        final CountDownLatch latch = new CountDownLatch(1);\n-        executor.execute(new Runnable() {\n-            public void run() {\n-                latch.countDown();\n-            }\n-        });\n-        latch.await();\n+        try {\n+            assertThrows(NullPointerException.class,\n+                         () -> executor.execute(null));\n+        } finally {\n+            group.shutdown();\n+        }\n","filename":"test\/jdk\/java\/nio\/channels\/AsynchronousChannelGroup\/AsExecutor.java","additions":53,"deletions":27,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 4313887 6838333\n+ * @bug 4313887 6838333 8364277\n@@ -27,1 +27,4 @@\n- * @library ..\/..\n+ * @library ..\/.. \/test\/lib\n+ * @build jdk.test.lib.Platform\n+ *        jdk.test.lib.util.FileUtils\n+ * @run main\/othervm --enable-native-access=ALL-UNNAMED Basic\n@@ -36,0 +39,3 @@\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.util.FileUtils;\n+\n@@ -100,0 +106,11 @@\n+    static void checkAttributesOfJunction(Path junction)\n+        throws IOException\n+    {\n+        BasicFileAttributes attrs =\n+            Files.readAttributes(junction, BasicFileAttributes.class, LinkOption.NOFOLLOW_LINKS);\n+        check(!attrs.isSymbolicLink(), \"is a link\");\n+        check(!attrs.isDirectory(), \"is a directory\");\n+        check(!attrs.isRegularFile(), \"is not a regular file\");\n+        check(attrs.isOther(), \"is other\");\n+    }\n+\n@@ -117,4 +134,11 @@\n-        } catch (UnsupportedOperationException x) {\n-            return;\n-        } catch (IOException x) {\n-            return;\n+            checkAttributesOfLink(link);\n+        } catch (IOException | UnsupportedOperationException x) {\n+            if (!Platform.isWindows())\n+                return;\n+        }\n+\n+        \/\/ NTFS junctions are Windows-only\n+        if (Platform.isWindows()) {\n+            Path junction = dir.resolve(\"junction\");\n+            FileUtils.createWinDirectoryJunction(junction, dir);\n+            checkAttributesOfJunction(junction);\n@@ -122,1 +146,0 @@\n-        checkAttributesOfLink(link);\n","filename":"test\/jdk\/java\/nio\/file\/attribute\/BasicFileAttributeView\/Basic.java","additions":31,"deletions":8,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,2 +57,0 @@\n-import sun.rmi.transport.*;\n-import sun.rmi.*;\n@@ -63,0 +61,1 @@\n+import sun.rmi.transport.*;\n@@ -105,2 +104,0 @@\n-                                        \" -Djava.security.policy=\" +\n-                                        TestParams.defaultPolicy +\n@@ -131,2 +128,2 @@\n-        \/* numLeft should be 2 - if 11 there is a problem. *\/\n-        if (numLeft > 2) {\n+        \/* numLeft should be 4 - if 11 there is a problem. *\/\n+        if (numLeft > 4) {\n@@ -159,37 +156,32 @@\n-            f = (Field) java.security.AccessController.doPrivileged\n-                (new java.security.PrivilegedExceptionAction() {\n-                    public Object run() throws Exception {\n-\n-                        ObjID dgcID = new ObjID(DGC_ID);\n-\n-                        \/*\n-                         * Construct an ObjectEndpoint containing DGC's\n-                         * ObjID.\n-                         *\/\n-                        Class oeClass =\n-                            Class.forName(\"sun.rmi.transport.ObjectEndpoint\");\n-                        Class[] constrParams =\n-                            new Class[]{ ObjID.class, Transport.class };\n-                        Constructor oeConstructor =\n-                            oeClass.getDeclaredConstructor(constrParams);\n-                        oeConstructor.setAccessible(true);\n-                        Object oe =\n-                            oeConstructor.newInstance(\n-                                new Object[]{ dgcID, null });\n-\n-                        \/*\n-                         * Get Target that contains DGCImpl in ObjectTable\n-                         *\/\n-                        Class objTableClass =\n-                            Class.forName(\"sun.rmi.transport.ObjectTable\");\n-                        Class getTargetParams[] = new Class[] { oeClass };\n-                        Method objTableGetTarget =\n-                            objTableClass.getDeclaredMethod(\"getTarget\",\n-                                                            getTargetParams);\n-                        objTableGetTarget.setAccessible(true);\n-                        Target dgcTarget = (Target)\n-                            objTableGetTarget.invoke(null, new Object[]{ oe });\n-\n-                        \/* get the DGCImpl from its Target *\/\n-                        Method targetGetImpl =\n-                            dgcTarget.getClass().getDeclaredMethod\n+            ObjID dgcID = new ObjID(DGC_ID);\n+            \/*\n+             * Construct an ObjectEndpoint containing DGC's\n+             * ObjID.\n+             *\/\n+            Class oeClass =\n+                    Class.forName(\"sun.rmi.transport.ObjectEndpoint\");\n+            Class[] constrParams =\n+                    new Class[]{ ObjID.class, Transport.class };\n+            Constructor oeConstructor =\n+                    oeClass.getDeclaredConstructor(constrParams);\n+            oeConstructor.setAccessible(true);\n+            Object oe =\n+                    oeConstructor.newInstance(\n+                            new Object[]{ dgcID, null });\n+\n+            \/*\n+             * Get Target that contains DGCImpl in ObjectTable\n+             *\/\n+            Class objTableClass =\n+                    Class.forName(\"sun.rmi.transport.ObjectTable\");\n+            Class getTargetParams[] = new Class[] { oeClass };\n+            Method objTableGetTarget =\n+                    objTableClass.getDeclaredMethod(\"getTarget\",\n+                            getTargetParams);\n+            objTableGetTarget.setAccessible(true);\n+            Target dgcTarget = (Target)\n+                    objTableGetTarget.invoke(null, new Object[]{ oe });\n+\n+            \/* get the DGCImpl from its Target *\/\n+            Method targetGetImpl =\n+                    dgcTarget.getClass().getDeclaredMethod\n@@ -197,3 +189,3 @@\n-                        targetGetImpl.setAccessible(true);\n-                        dgcImpl[0] =\n-                            (Remote) targetGetImpl.invoke(dgcTarget, null);\n+            targetGetImpl.setAccessible(true);\n+            dgcImpl[0] =\n+                    (Remote) targetGetImpl.invoke(dgcTarget, null);\n@@ -201,3 +193,3 @@\n-                        \/* Get the lease table from the DGCImpl. *\/\n-                        Field reflectedLeaseTable =\n-                            dgcImpl[0].getClass().getDeclaredField\n+            \/* Get the lease table from the DGCImpl. *\/\n+            Field reflectedLeaseTable =\n+                    dgcImpl[0].getClass().getDeclaredField\n@@ -205,1 +197,3 @@\n-                        reflectedLeaseTable.setAccessible(true);\n+            reflectedLeaseTable.setAccessible(true);\n+\n+            f = reflectedLeaseTable;\n@@ -207,3 +201,0 @@\n-                        return reflectedLeaseTable;\n-                    }\n-            });\n@@ -220,3 +211,0 @@\n-            if (e instanceof java.security.PrivilegedActionException)\n-                e = ((java.security.PrivilegedActionException) e).\n-                    getException();\n","filename":"test\/jdk\/java\/rmi\/transport\/checkLeaseInfoLeak\/CheckLeaseLeak.java","additions":45,"deletions":57,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-        TestLibrary.suggestSecurityManager(\"java.rmi.RMISecurityManager\");\n","filename":"test\/jdk\/java\/rmi\/transport\/checkLeaseInfoLeak\/LeaseLeakClient.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+    static volatile int q;\n@@ -88,0 +89,10 @@\n+        } catch (IllegalArgumentException success) {}\n+    }\n+\n+    \/**\n+     * construction with static field throws IllegalArgumentException\n+     *\/\n+    public void testConstructor4() {\n+        try {\n+            updaterFor(\"q\");\n+            shouldThrow();\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/AtomicIntegerFieldUpdaterTest.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+    static volatile long q;\n@@ -91,0 +92,10 @@\n+    \/**\n+     * construction with static field throws IllegalArgumentException\n+     *\/\n+    public void testConstructor4() {\n+        try {\n+            updaterFor(\"q\");\n+            shouldThrow();\n+        } catch (IllegalArgumentException success) {}\n+    }\n+\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/AtomicLongFieldUpdaterTest.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+    static volatile Item q;\n@@ -103,0 +104,11 @@\n+    \/**\n+     * construction with static field throws IllegalArgumentException\n+     *\/\n+    public void testConstructor5() {\n+        try {\n+            updaterFor(\"q\");\n+            shouldThrow();\n+        } catch (IllegalArgumentException success) {}\n+    }\n+\n+\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/AtomicReferenceFieldUpdaterTest.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2022, Tencent. All rights reserved.\n@@ -143,1 +143,0 @@\n-\n","filename":"test\/jdk\/javax\/net\/ssl\/DTLS\/DTLSNamedGroups.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2022, Tencent. All rights reserved.\n@@ -137,1 +137,0 @@\n-\n","filename":"test\/jdk\/javax\/net\/ssl\/DTLS\/DTLSSignatureSchemes.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2022, Tencent. All rights reserved.\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLException\/CheckSSLHandshakeException.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2022, Tencent. All rights reserved.\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLException\/CheckSSLKeyException.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2022, Tencent. All rights reserved.\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLException\/CheckSSLPeerUnverifiedException.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2022, Tencent. All rights reserved.\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLException\/CheckSSLProtocolException.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2022, Tencent. All rights reserved.\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLParameters\/NamedGroups.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2022, Tencent. All rights reserved.\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLParameters\/NamedGroupsSpec.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2022, Tencent. All rights reserved.\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLParameters\/SignatureSchemes.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2022, Tencent. All rights reserved.\n@@ -251,1 +251,0 @@\n-\n","filename":"test\/jdk\/javax\/net\/ssl\/ServerName\/EndingDotHostname.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2022, Tencent. All rights reserved.\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/SSLExampleCert.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2022, Tencent. All rights reserved.\n@@ -58,1 +58,0 @@\n-\n","filename":"test\/jdk\/javax\/security\/auth\/callback\/PasswordCallback\/CheckCleanerBound.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2022, Tencent. All rights reserved.\n@@ -52,1 +52,0 @@\n-\n","filename":"test\/jdk\/javax\/security\/auth\/callback\/PasswordCallback\/PasswordCleanup.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8348760\n+ * @summary Verify if RadioButtonMenuItem bullet and\n+ *          JCheckboxMenuItem checkmark is shown if\n+ *          JRadioButtonMenuItem and JCheckboxMenuItem\n+ *          is rendered with ImageIcon in WindowsLookAndFeel\n+ * @requires (os.family == \"windows\")\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual TestRadioAndCheckMenuItemWithIcon\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Graphics;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.KeyEvent;\n+import java.awt.image.BufferedImage;\n+\n+import javax.swing.AbstractButton;\n+import javax.swing.ButtonGroup;\n+import javax.swing.ImageIcon;\n+import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JFrame;\n+import javax.swing.JMenu;\n+import javax.swing.JMenuBar;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JRadioButtonMenuItem;\n+import javax.swing.KeyStroke;\n+import javax.swing.UIManager;\n+\n+public class TestRadioAndCheckMenuItemWithIcon {\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+        A top level Menu will be shown.\n+\n+        Clicking on the Menu will show a\n+        JRadioButtonMenuItem group with 3 radiobutton menuitems\n+        and a JCheckBoxMenuItem group with 3 checkbox menuitems.\n+\n+        First radiobutton menuitem is selected with imageicon of a red square.\n+        Second radiobutton menuitem is unselected with imageicon.\n+        Third radiobutton menuItem is unselected without imageicon.\n+\n+        First checkbox menuitem is selected with imageicon.\n+        Second checkbox menuitem is unselected with imageicon.\n+        Third checkbox menuItem is unselected without imageicon.\n+\n+        Verify that for first JRadioButtonMenuItem with imageicon,\n+        a bullet is shown alongside the imageicon and\n+        for first JCheckBoxMenuItem with imageicon\n+        a checkmark is shown alongside the imageicon.\n+\n+        If bullet and checkmark is shown, test passes else fails.\"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n+        PassFailJFrame.builder()\n+                .title(\"JRadioButtonMenuItem Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(60)\n+                .testUI(TestRadioAndCheckMenuItemWithIcon::doTest)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static JFrame doTest() {\n+        BufferedImage img = new BufferedImage(16, 16, BufferedImage.TYPE_INT_ARGB);\n+        Graphics g = img.getGraphics();\n+        g.setColor(Color.red);\n+        g.fillRect(0, 0, img.getWidth(), img.getHeight());\n+        g.dispose();\n+\n+        BufferedImage img2 = new BufferedImage(64, 64, BufferedImage.TYPE_INT_ARGB);\n+        Graphics g2 = img2.getGraphics();\n+        g2.setColor(Color.red);\n+        g2.fillRect(0, 0, img2.getWidth(), img2.getHeight());\n+        g2.dispose();\n+\n+        JFrame frame = new JFrame(\"RadioButtonWithImageIcon\");\n+        ImageIcon imageIcon1 = new ImageIcon(img);\n+        ImageIcon imageIcon2 = new ImageIcon(img2);\n+        AbstractButton button1;\n+        JRadioButtonMenuItem m1 = new JRadioButtonMenuItem(\"JRadioButtonMenuItem 1\",\n+                imageIcon1);\n+        m1.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F4, ActionEvent.ALT_MASK|ActionEvent.CTRL_MASK|ActionEvent.SHIFT_MASK));\n+        button1 = m1;\n+        button1.setSelected(true);\n+        AbstractButton button2 = new JRadioButtonMenuItem(\"JRadioButtonMenuItem 2\", imageIcon2);\n+        AbstractButton button3 = new JRadioButtonMenuItem(\"JRadioButtonMenuItem 3\");\n+\n+        ButtonGroup buttonGroup = new ButtonGroup();\n+        buttonGroup.add(button1);\n+        buttonGroup.add(button2);\n+        buttonGroup.add(button3);\n+\n+        AbstractButton check1 = new JCheckBoxMenuItem(\"JCheckBoxMenuItem 1\",\n+                imageIcon1);\n+        check1.setSelected(true);\n+        AbstractButton check2 = new JCheckBoxMenuItem(\"JCheckBoxMenuItem 2\", imageIcon1);\n+        JCheckBoxMenuItem c3;\n+        AbstractButton check3 = c3 = new JCheckBoxMenuItem(\"JCheckBoxMenuItem 3\");\n+        c3.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F5, ActionEvent.ALT_MASK|ActionEvent.CTRL_MASK|ActionEvent.SHIFT_MASK));\n+\n+        JMenu topLevel = new JMenu(\"Menu\");\n+\n+        topLevel.add(button1);\n+        topLevel.add(button2);\n+        topLevel.add(button3);\n+\n+        topLevel.addSeparator();\n+\n+        topLevel.add(check1);\n+        topLevel.add(check2);\n+        topLevel.add(check3);\n+\n+        AbstractButton menuitem1 = new JMenuItem(\"MenuItem1\");\n+        AbstractButton menuitem2 = new JMenuItem(\"MenuItem2\", imageIcon1);\n+        topLevel.addSeparator();\n+        topLevel.add(menuitem1);\n+        topLevel.add(menuitem2);\n+\n+        JMenuBar menuBar = new JMenuBar();\n+        menuBar.add(topLevel);\n+\n+        frame.setJMenuBar(menuBar);\n+        frame.setSize(300, 300);\n+        return frame;\n+\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JMenuItem\/TestRadioAndCheckMenuItemWithIcon.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 8358813\n+ * @summary Password fields' InputMap should not include any word-related action.\n+ *\n+ * @run main PasswordFieldInputMapWordTest\n+ *\/\n+\n+import java.util.Collection;\n+import java.util.Set;\n+\n+import javax.swing.InputMap;\n+import javax.swing.JComponent;\n+import javax.swing.JPasswordField;\n+import javax.swing.KeyStroke;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.UnsupportedLookAndFeelException;\n+import javax.swing.text.DefaultEditorKit;\n+\n+public class PasswordFieldInputMapWordTest {\n+    public static void main(String[] args) throws Exception {\n+        for (UIManager.LookAndFeelInfo laf :\n+                UIManager.getInstalledLookAndFeels()) {\n+            System.out.println(\"Testing LAF: \" + laf.getClassName());\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (setLookAndFeel(laf)) {\n+                    runTest();\n+                }\n+            });\n+        }\n+    }\n+\n+    private static boolean setLookAndFeel(UIManager.LookAndFeelInfo laf) {\n+        try {\n+            UIManager.setLookAndFeel(laf.getClassName());\n+            return true;\n+        } catch (UnsupportedLookAndFeelException e) {\n+            System.err.println(\"Skipping unsupported look and feel:\");\n+            e.printStackTrace();\n+            return false;\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static int[] inputMapConditions = new int[] {\n+            JComponent.WHEN_IN_FOCUSED_WINDOW,\n+            JComponent.WHEN_FOCUSED,\n+            JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT\n+    };\n+\n+    \/**\n+     * These are all the actions with \"word\" in their field name.\n+     *\/\n+    static Collection<String> wordActions = Set.of(\n+            DefaultEditorKit.deleteNextWordAction,\n+            DefaultEditorKit.deletePrevWordAction,\n+            DefaultEditorKit.beginWordAction,\n+            DefaultEditorKit.endWordAction,\n+            DefaultEditorKit.selectionBeginWordAction,\n+            DefaultEditorKit.selectionEndWordAction,\n+            DefaultEditorKit.previousWordAction,\n+            DefaultEditorKit.nextWordAction,\n+            DefaultEditorKit.selectionPreviousWordAction,\n+            DefaultEditorKit.selectionNextWordAction\n+    );\n+\n+    private static void runTest() {\n+        JPasswordField field = new JPasswordField();\n+\n+        boolean testPassed = true;\n+        for (int condition : inputMapConditions) {\n+            InputMap inputMap = field.getInputMap(condition);\n+            if (inputMap.allKeys() == null) {\n+                continue;\n+            }\n+            for (KeyStroke keyStroke : inputMap.allKeys()) {\n+                Object actionBinding = inputMap.get(keyStroke);\n+                if (wordActions.contains(actionBinding)) {\n+                    if (testPassed) {\n+                        System.err.println(\"The following inputs\/actions should not be available in a JPasswordField:\");\n+                    }\n+                    System.err.println(inputMap.get(keyStroke) + \" (try typing \" + keyStroke + \")\");\n+                    testPassed = false;\n+                }\n+            }\n+        }\n+\n+        if (!testPassed) {\n+            throw new RuntimeException(\"One or more input\/action binding was observed for a JPasswordField.\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JPasswordField\/PasswordFieldInputMapWordTest.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.swing.text.BadLocationException;\n+import javax.swing.text.Position;\n+import javax.swing.text.StringContent;\n+\n+\/*\n+ * @test\n+ * @summary test that StringContent Position APIs behave as expected.\n+ *\/\n+\n+public class StringContentPositionTest {\n+\n+    static final int SIZE = 20;\n+    static final String TEXT = \"hello\";\n+    static final int LEN = TEXT.length();\n+    static final StringContent SC = new StringContent();\n+\n+    public static void main(String[] args) throws BadLocationException {\n+\n+        for (int i = 0; i < 1000; i++) {\n+            test();\n+            System.gc();\n+        }\n+    }\n+\n+    static void test() throws BadLocationException {\n+\n+        Position[] positions = new Position[SIZE];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            SC.insertString(0, TEXT);\n+            positions[i] = SC.createPosition(LEN);\n+        }\n+        for (int i = 0; i < SIZE; i++) {\n+           int expected = ((SIZE - i) * LEN);\n+           if (positions[i].getOffset() != expected) {\n+               throw new RuntimeException(\"insert: Bad offset i=\" + i + \" off=\" + positions[i].getOffset());\n+           }\n+        }\n+        SC.remove(0, SIZE * LEN);\n+        for (int i = 0; i < SIZE; i++) {\n+            if (positions[i].getOffset() != 0) {\n+               throw new RuntimeException(\"remove: Bad offset i=\" + i + \" off=\" + positions[i].getOffset());\n+            }\n+        }\n+     }\n+}\n","filename":"test\/jdk\/javax\/swing\/text\/AbstractDocument\/StringContentPositionTest.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8361638\n@@ -40,0 +41,1 @@\n+import static java.lang.constant.ConstantDescs.*;\n@@ -50,0 +52,1 @@\n+import java.util.Collections;\n@@ -53,5 +56,0 @@\n-import static java.lang.constant.ConstantDescs.CD_Double;\n-import static java.lang.constant.ConstantDescs.CD_Integer;\n-import static java.lang.constant.ConstantDescs.CD_Object;\n-import static java.lang.constant.ConstantDescs.CD_String;\n-\n@@ -64,0 +62,24 @@\n+    @Test\n+    void testExceptionalContracts() throws Throwable {\n+        generateTryCatchMethod(catchBuilder -> {\n+            Consumer<CodeBuilder.BlockCodeBuilder> handler = tb -> tb.pop().aconst_null().areturn();\n+            assertThrows(NullPointerException.class, () -> catchBuilder.catching(CD_NPE, null));\n+            assertThrows(NullPointerException.class, () -> catchBuilder.catchingMulti(null, handler));\n+            assertThrows(NullPointerException.class, () -> catchBuilder.catchingMulti(List.of(), null));\n+            assertThrows(NullPointerException.class, () -> catchBuilder.catchingMulti(Collections.singletonList(null), null));\n+            assertThrows(NullPointerException.class, () -> catchBuilder.catchingAll(null));\n+            catchBuilder.catchingMulti(List.of(CD_IOOBE, CD_NPE), tb -> {\n+                tb.invokevirtual(CD_Object, \"toString\", MTD_String);\n+                tb.astore(1);\n+            });\n+            catchBuilder.catchingAll(tb -> tb.pop().loadConstant(\"all\").areturn());\n+            assertThrows(IllegalArgumentException.class, () -> catchBuilder.catching(CD_int, handler));\n+            assertDoesNotThrow(() -> catchBuilder.catching(CD_NPE, handler));\n+            assertDoesNotThrow(() -> catchBuilder.catching(null, handler));\n+            assertDoesNotThrow(() -> catchBuilder.catchingMulti(List.of(), handler));\n+            assertDoesNotThrow(() -> catchBuilder.catchingMulti(List.of(CD_Exception, CD_IOOBE), handler));\n+            assertThrows(IllegalArgumentException.class, () -> catchBuilder.catchingMulti(List.of(CD_long, CD_Throwable), handler));\n+            assertDoesNotThrow(() -> catchBuilder.catchingAll(handler));\n+        });\n+    }\n+\n","filename":"test\/jdk\/jdk\/classfile\/BuilderTryCatchTest.java","additions":28,"deletions":6,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,279 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.jimage.ImageReader;\n+import jdk.internal.jimage.ImageReader.Node;\n+import jdk.test.lib.compiler.InMemoryJavaCompiler;\n+import jdk.test.lib.util.JarBuilder;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import org.opentest4j.TestSkippedException;\n+import tests.Helper;\n+import tests.JImageGenerator;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.api.Assumptions.assumeTrue;\n+import static org.junit.jupiter.api.TestInstance.Lifecycle.PER_CLASS;\n+\n+\/*\n+ * @test\n+ * @summary Tests for ImageReader.\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @library \/test\/jdk\/tools\/lib\n+ *          \/test\/lib\n+ * @build tests.*\n+ * @run junit\/othervm ImageReaderTest\n+ *\/\n+\n+\/\/\/ Using PER_CLASS lifecycle means the (expensive) image file is only build once.\n+\/\/\/ There is no mutable test instance state to worry about.\n+@TestInstance(PER_CLASS)\n+public class ImageReaderTest {\n+\n+    private static final Map<String, List<String>> IMAGE_ENTRIES = Map.of(\n+            \"modfoo\", Arrays.asList(\n+                    \"com.foo.Alpha\",\n+                    \"com.foo.Beta\",\n+                    \"com.foo.bar.Gamma\"),\n+            \"modbar\", Arrays.asList(\n+                    \"com.bar.One\",\n+                    \"com.bar.Two\"));\n+    private final Path image = buildJImage(IMAGE_ENTRIES);\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"\/\",\n+            \"\/modules\",\n+            \"\/modules\/modfoo\",\n+            \"\/modules\/modbar\",\n+            \"\/modules\/modfoo\/com\",\n+            \"\/modules\/modfoo\/com\/foo\",\n+            \"\/modules\/modfoo\/com\/foo\/bar\"})\n+    public void testModuleDirectories_expected(String name) throws IOException {\n+        try (ImageReader reader = ImageReader.open(image)) {\n+            assertDir(reader, name);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"\",\n+            \"\/\/\",\n+            \"\/modules\/\",\n+            \"\/modules\/unknown\",\n+            \"\/modules\/modbar\/\",\n+            \"\/modules\/modfoo\/\/com\",\n+            \"\/modules\/modfoo\/com\/\"})\n+    public void testModuleNodes_absent(String name) throws IOException {\n+        try (ImageReader reader = ImageReader.open(image)) {\n+            assertAbsent(reader, name);\n+        }\n+    }\n+\n+    @Test\n+    public void testModuleResources() throws IOException {\n+        try (ImageReader reader = ImageReader.open(image)) {\n+            assertNode(reader, \"\/modules\/modfoo\/com\/foo\/Alpha.class\");\n+            assertNode(reader, \"\/modules\/modbar\/com\/bar\/One.class\");\n+\n+            ImageClassLoader loader = new ImageClassLoader(reader, IMAGE_ENTRIES.keySet());\n+            assertEquals(\"Class: com.foo.Alpha\", loader.loadAndGetToString(\"modfoo\", \"com.foo.Alpha\"));\n+            assertEquals(\"Class: com.foo.Beta\", loader.loadAndGetToString(\"modfoo\", \"com.foo.Beta\"));\n+            assertEquals(\"Class: com.foo.bar.Gamma\", loader.loadAndGetToString(\"modfoo\", \"com.foo.bar.Gamma\"));\n+            assertEquals(\"Class: com.bar.One\", loader.loadAndGetToString(\"modbar\", \"com.bar.One\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testPackageDirectories() throws IOException {\n+        try (ImageReader reader = ImageReader.open(image)) {\n+            Node root = assertDir(reader, \"\/packages\");\n+            Set<String> pkgNames = root.getChildNames().collect(Collectors.toSet());\n+            assertTrue(pkgNames.contains(\"\/packages\/com\"));\n+            assertTrue(pkgNames.contains(\"\/packages\/com.foo\"));\n+            assertTrue(pkgNames.contains(\"\/packages\/com.bar\"));\n+\n+            \/\/ Even though no classes exist directly in the \"com\" package, it still\n+            \/\/ creates a directory with links back to all the modules which contain it.\n+            Set<String> comLinks = assertDir(reader, \"\/packages\/com\").getChildNames().collect(Collectors.toSet());\n+            assertTrue(comLinks.contains(\"\/packages\/com\/modfoo\"));\n+            assertTrue(comLinks.contains(\"\/packages\/com\/modbar\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testPackageLinks() throws IOException {\n+        try (ImageReader reader = ImageReader.open(image)) {\n+            Node moduleFoo = assertDir(reader, \"\/modules\/modfoo\");\n+            Node moduleBar = assertDir(reader, \"\/modules\/modbar\");\n+            assertSame(assertLink(reader, \"\/packages\/com.foo\/modfoo\").resolveLink(), moduleFoo);\n+            assertSame(assertLink(reader, \"\/packages\/com.bar\/modbar\").resolveLink(), moduleBar);\n+        }\n+    }\n+\n+    private static ImageReader.Node assertNode(ImageReader reader, String name) throws IOException {\n+        ImageReader.Node node = reader.findNode(name);\n+        assertNotNull(node, \"Could not find node: \" + name);\n+        return node;\n+    }\n+\n+    private static ImageReader.Node assertDir(ImageReader reader, String name) throws IOException {\n+        ImageReader.Node dir = assertNode(reader, name);\n+        assertTrue(dir.isDirectory(), \"Node was not a directory: \" + name);\n+        return dir;\n+    }\n+\n+    private static ImageReader.Node assertLink(ImageReader reader, String name) throws IOException {\n+        ImageReader.Node link = assertNode(reader, name);\n+        assertTrue(link.isLink(), \"Node was not a symbolic link: \" + name);\n+        return link;\n+    }\n+\n+    private static void assertAbsent(ImageReader reader, String name) throws IOException {\n+        assertNull(reader.findNode(name), \"Should not be able to find node: \" + name);\n+    }\n+\n+    \/\/\/ Builds a jimage file with the specified class entries. The classes in the built\n+    \/\/\/ image can be loaded and executed to return their names via `toString()` to confirm\n+    \/\/\/ the correct bytes were returned.\n+    public static Path buildJImage(Map<String, List<String>> entries) {\n+        Helper helper = getHelper();\n+        Path outDir = helper.createNewImageDir(\"test\");\n+        JImageGenerator.JLinkTask jlink = JImageGenerator.getJLinkTask()\n+                .modulePath(helper.defaultModulePath())\n+                .output(outDir);\n+\n+        Path jarDir = helper.getJarDir();\n+        entries.forEach((module, classes) -> {\n+            JarBuilder jar = new JarBuilder(jarDir.resolve(module + \".jar\").toString());\n+            String moduleInfo = \"module \" + module + \" {}\";\n+            jar.addEntry(\"module-info.class\", InMemoryJavaCompiler.compile(\"module-info\", moduleInfo));\n+\n+            classes.forEach(fqn -> {\n+                int lastDot = fqn.lastIndexOf('.');\n+                String pkg = fqn.substring(0, lastDot);\n+                String cls = fqn.substring(lastDot + 1);\n+\n+                String path = fqn.replace('.', '\/') + \".class\";\n+                String source = String.format(\n+                        \"\"\"\n+                        package %s;\n+                        public class %s {\n+                            public String toString() {\n+                                return \"Class: %s\";\n+                            }\n+                        }\n+                        \"\"\", pkg, cls, fqn);\n+                jar.addEntry(path, InMemoryJavaCompiler.compile(fqn, source));\n+            });\n+            try {\n+                jar.build();\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+            jlink.addMods(module);\n+        });\n+        return jlink.call().assertSuccess().resolve(\"lib\", \"modules\");\n+    }\n+\n+    \/\/\/  Returns the helper for building JAR and jimage files.\n+    private static Helper getHelper() {\n+        try {\n+            Helper helper = Helper.newHelper();\n+            if (helper == null) {\n+                throw new TestSkippedException(\"Cannot create test helper (exploded image?)\");\n+            }\n+            return helper;\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/\/\/ Loads and performs actions on classes stored in a given `ImageReader`.\n+    private static class ImageClassLoader extends ClassLoader {\n+        private final ImageReader reader;\n+        private final Set<String> testModules;\n+\n+        private ImageClassLoader(ImageReader reader, Set<String> testModules) {\n+            this.reader = reader;\n+            this.testModules = testModules;\n+        }\n+\n+        @FunctionalInterface\n+        public interface ClassAction<R, T extends Exception> {\n+            R call(Class<?> cls) throws T;\n+        }\n+\n+        String loadAndGetToString(String module, String fqn) {\n+            return loadAndCall(module, fqn, c -> c.getDeclaredConstructor().newInstance().toString());\n+        }\n+\n+        <R> R loadAndCall(String module, String fqn, ClassAction<R, ?> action) {\n+            Class<?> cls = findClass(module, fqn);\n+            assertNotNull(cls, \"Could not load class: \" + module + \"\/\" + fqn);\n+            try {\n+                return action.call(cls);\n+            } catch (Exception e) {\n+                fail(\"Class loading failed\", e);\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        protected Class<?> findClass(String module, String fqn) {\n+            assumeTrue(testModules.contains(module), \"Can only load classes in modules: \" + testModules);\n+            String name = \"\/modules\/\" + module + \"\/\" + fqn.replace('.', '\/') + \".class\";\n+            Class<?> cls = findLoadedClass(fqn);\n+            if (cls == null) {\n+                try {\n+                    ImageReader.Node node = reader.findNode(name);\n+                    if (node != null && node.isResource()) {\n+                        byte[] classBytes = reader.getResource(node);\n+                        cls = defineClass(fqn, classBytes, 0, classBytes.length);\n+                        resolveClass(cls);\n+                        return cls;\n+                    }\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+            return null;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/jimage\/ImageReaderTest.java","additions":279,"deletions":0,"binary":false,"changes":279,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,3 @@\n+import static java.nio.ByteOrder.BIG_ENDIAN;\n+import static java.nio.ByteOrder.LITTLE_ENDIAN;\n+\n@@ -336,19 +339,6 @@\n-        ImageReader nativeReader = ImageReader.open(imageFile);\n-        Assert.assertEquals(nativeReader.getByteOrder(), ByteOrder.nativeOrder());\n-\n-        try {\n-            ImageReader leReader = ImageReader.open(imageFile, ByteOrder.LITTLE_ENDIAN);\n-            Assert.assertEquals(leReader.getByteOrder(), ByteOrder.LITTLE_ENDIAN);\n-            leReader.close();\n-        } catch (IOException io) {\n-            \/\/ IOException expected if LITTLE_ENDIAN not the nativeOrder()\n-            Assert.assertNotEquals(ByteOrder.nativeOrder(), ByteOrder.LITTLE_ENDIAN);\n-        }\n-\n-        try {\n-            ImageReader beReader = ImageReader.open(imageFile, ByteOrder.BIG_ENDIAN);\n-            Assert.assertEquals(beReader.getByteOrder(), ByteOrder.BIG_ENDIAN);\n-            beReader.close();\n-        } catch (IOException io) {\n-            \/\/ IOException expected if LITTLE_ENDIAN not the nativeOrder()\n-            Assert.assertNotEquals(ByteOrder.nativeOrder(), ByteOrder.BIG_ENDIAN);\n+        \/\/ Will be opened with native byte order.\n+        try (ImageReader nativeReader = ImageReader.open(imageFile)) {\n+            \/\/ Just ensure something works as expected.\n+            Assert.assertNotNull(nativeReader.findNode(\"\/\"));\n+        } catch (IOException expected) {\n+            Assert.fail(\"Reader should be openable with native byte order.\");\n@@ -357,1 +347,3 @@\n-        nativeReader.close();\n+        \/\/ Reader should not be openable with the wrong byte order.\n+        ByteOrder otherOrder = ByteOrder.nativeOrder() == BIG_ENDIAN ? LITTLE_ENDIAN : BIG_ENDIAN;\n+        Assert.assertThrows(IOException.class, () -> ImageReader.open(imageFile, otherOrder));\n@@ -359,1 +351,0 @@\n-    \/\/ main method to run standalone from jtreg\n@@ -361,1 +352,2 @@\n-    @Test(enabled=false)\n+    \/\/ main method to run standalone from jtreg\n+    @Test(enabled = false)\n","filename":"test\/jdk\/jdk\/internal\/jimage\/JImageReadTest.java","additions":15,"deletions":23,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Field;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static jdk.internal.misc.Unsafe.getUnsafe;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/*\n+ * @test\n+ * @bug 8361300\n+ * @summary Verify Unsafe memory address computation method contracts,\n+ *          exposed via sun.misc.Unsafe\n+ * @modules java.base\/jdk.internal.misc\n+ * @run junit AddressComputationContractTest\n+ *\/\n+public class AddressComputationContractTest {\n+\n+    int instanceField;\n+    static int staticField;\n+\n+    private static final Field INSTANCE_FIELD;\n+    private static final Field STATIC_FIELD;\n+\n+    static {\n+        try {\n+            INSTANCE_FIELD = AddressComputationContractTest.class.getDeclaredField(\"instanceField\");\n+            STATIC_FIELD = AddressComputationContractTest.class.getDeclaredField(\"staticField\");\n+        } catch (ReflectiveOperationException ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        }\n+    }\n+\n+    @Test\n+    void objectFieldOffset() {\n+        assertDoesNotThrow(() -> getUnsafe().objectFieldOffset(INSTANCE_FIELD));\n+        assertThrows(NullPointerException.class, () -> getUnsafe().objectFieldOffset(null));\n+        assertThrows(IllegalArgumentException.class, () -> getUnsafe().objectFieldOffset(STATIC_FIELD));\n+    }\n+\n+    @Test\n+    void knownObjectFieldOffset() {\n+        assertDoesNotThrow(() -> getUnsafe().objectFieldOffset(AddressComputationContractTest.class, \"instanceField\"));\n+        assertThrows(NullPointerException.class, () -> getUnsafe().objectFieldOffset(null, \"instanceField\"));\n+        assertThrows(NullPointerException.class, () -> getUnsafe().objectFieldOffset(AddressComputationContractTest.class, null));\n+        \/\/ Two conventional failure cases, not necessarily complete\n+        var dneMsg = assertThrows(InternalError.class, () -> getUnsafe().objectFieldOffset(AddressComputationContractTest.class, \"doesNotExist\")).getMessage();\n+        assertTrue(dneMsg.contains(\"AddressComputationContractTest.doesNotExist\") && dneMsg.contains(\"not found\"), dneMsg);\n+        var staticMsg = assertThrows(InternalError.class, () -> getUnsafe().objectFieldOffset(AddressComputationContractTest.class, \"staticField\")).getMessage();\n+        assertTrue(staticMsg.contains(\"AddressComputationContractTest.staticField\") && staticMsg.contains(\"static field\"), staticMsg);\n+    }\n+\n+    @Test\n+    void staticFieldOffset() {\n+        assertDoesNotThrow(() -> getUnsafe().staticFieldOffset(STATIC_FIELD));\n+        assertThrows(NullPointerException.class, () -> getUnsafe().staticFieldOffset(null));\n+        assertThrows(IllegalArgumentException.class, () -> getUnsafe().staticFieldOffset(INSTANCE_FIELD));\n+    }\n+\n+    @Test\n+    void staticFieldBase() {\n+        assertDoesNotThrow(() -> getUnsafe().staticFieldBase(STATIC_FIELD));\n+        assertThrows(NullPointerException.class, () -> getUnsafe().staticFieldBase(null));\n+        assertThrows(IllegalArgumentException.class, () -> getUnsafe().staticFieldBase(INSTANCE_FIELD));\n+    }\n+\n+    @Test\n+    void arrayBaseOffset() {\n+        assertDoesNotThrow(() -> getUnsafe().arrayBaseOffset(int[].class));\n+        assertThrows(NullPointerException.class, () -> getUnsafe().arrayBaseOffset(null));\n+        \/\/ Caused by VM trying to throw java.lang.InvalidClassException (there's one in java.io instead)\n+        assertThrows(NoClassDefFoundError.class, () -> getUnsafe().arrayBaseOffset(AddressComputationContractTest.class));\n+    }\n+\n+    @Test\n+    void arrayIndexScale() {\n+        assertDoesNotThrow(() -> getUnsafe().arrayIndexScale(int[].class));\n+        assertThrows(NullPointerException.class, () -> getUnsafe().arrayIndexScale(null));\n+        \/\/ Caused by VM trying to throw java.lang.InvalidClassException (there's one in java.io instead)\n+        assertThrows(NoClassDefFoundError.class, () -> getUnsafe().arrayIndexScale(AddressComputationContractTest.class));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/misc\/Unsafe\/AddressComputationContractTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2020, 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2020, 2022, Tencent. All rights reserved.\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/GetFreeSwapSpaceSize.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2020, 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2020, 2022, Tencent. All rights reserved.\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestGetFreeSwapSpaceSize.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.jfr.StackTrace;\n@@ -41,0 +42,1 @@\n+    @StackTrace(false)\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/streaming\/TestFilledChunks.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-    @Period(\"10 s\")\n+    @Period(\"2 s\")\n@@ -68,1 +68,1 @@\n-        CountDownLatch zebraLatch = new CountDownLatch(3);\n+        CountDownLatch zebraLatch = new CountDownLatch(2);\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/streaming\/TestStartMultiChunk.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+ * @comment Asan changes memory layout and we get a different coops mode\n+ * @requires !vm.asan\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/configuration\/TestGCHeapConfigurationEventWith32BitOops.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+ * @comment Asan changes memory layout and we get a different coops mode\n+ * @requires !vm.asan\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/configuration\/TestGCHeapConfigurationEventWithZeroBasedOops.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.lang.management.ThreadMXBean;\n@@ -74,1 +75,1 @@\n-     * Counting the events that are emitted for a given throttle in a given time.\n+     * Counting the events that are emitted for a given throttle in a given (CPU) time.\n@@ -86,2 +87,0 @@\n-            var bean = ManagementFactory.getThreadMXBean();\n-\n@@ -90,5 +89,1 @@\n-            long startThreadCpuTime = bean.getCurrentThreadCpuTime();\n-\n-            wasteCPU(timeMs);\n-\n-            long spendCPUTime = bean.getCurrentThreadCpuTime() - startThreadCpuTime;\n+            long spendCPUTime = wasteCPU(timeMs);\n@@ -102,1 +97,0 @@\n-\n@@ -107,2 +101,3 @@\n-    private static void wasteCPU(int durationMs) {\n-        long start = System.currentTimeMillis();\n+    private static long wasteCPU(int durationMs) {\n+        ThreadMXBean bean = ManagementFactory.getThreadMXBean();\n+        long start = bean.getCurrentThreadCpuTime();\n@@ -110,1 +105,1 @@\n-        while (System.currentTimeMillis() - start < durationMs) {\n+        while (bean.getCurrentThreadCpuTime() - start < durationMs * 1_000_000) {\n@@ -115,0 +110,1 @@\n+        return bean.getCurrentThreadCpuTime() - start;\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/TestCPUTimeSampleThrottling.java","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    static final int RUN_TIME_MS = 10000;\n+    static final int RUN_TIME_MS = 5000;\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/StressJavaMonitorEvents.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -146,2 +146,0 @@\n-        Asserts.assertGT((long) re.getValue(\"elements\"), 0L, \"No elements\");\n-        Asserts.assertGT((long) re.getValue(\"size\"), 0L, \"Empty size\");\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestFlush.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import jdk.jfr.StackTrace;\n@@ -48,0 +49,1 @@\n+    @StackTrace(false)\n@@ -95,1 +97,1 @@\n-        Thread.sleep(1000);\n+        Thread.sleep(100);\n","filename":"test\/jdk\/jdk\/jfr\/jmx\/streaming\/TestMaxSize.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-    private static List<RecordedEvent> recordWithPolicy(String filename, Consumer<RemoteRecordingStream> policy) throws Exception {\n+    private static List<RecordedEvent> recordWithPolicy(String filename, boolean awaitEvents, Consumer<RemoteRecordingStream> policy) throws Exception {\n@@ -114,1 +114,3 @@\n-            latch1.await();\n+            if (awaitEvents) {\n+                latch1.await();\n+            }\n@@ -121,1 +123,3 @@\n-            latch2.await();\n+            if (awaitEvents) {\n+                latch2.await();\n+            }\n@@ -132,1 +136,1 @@\n-        var events = recordWithPolicy(\"max-size.jfr\", rs -> {\n+        var events = recordWithPolicy(\"max-size.jfr\", false, rs -> {\n@@ -143,1 +147,1 @@\n-        var events = recordWithPolicy(\"max-age.jfr\", rs -> {\n+        var events = recordWithPolicy(\"max-age.jfr\", false, rs -> {\n@@ -154,1 +158,1 @@\n-        var events = recordWithPolicy(\"no-policy.jfr\", rs -> {\n+        var events = recordWithPolicy(\"no-policy.jfr\", true, rs -> {\n","filename":"test\/jdk\/jdk\/jfr\/jmx\/streaming\/TestRemoteDump.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-             .with(\"cutoff\", \"infinity\")\n+             .with(\"cutoff\", \"2 s\")\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestWaste.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -77,7 +77,0 @@\n-    private static void testDefault() throws Exception {\n-        System.out.println(\"testDefault\");\n-        launchUnary(null);\n-        launchBinary(null, null);\n-        launchTernary(null, null, null);\n-    }\n-\n@@ -102,1 +95,0 @@\n-        testDefault();\n","filename":"test\/jdk\/jdk\/jfr\/startupargs\/TestMultipleStartupRecordings.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,229 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import sun.nio.cs.ArrayEncoder;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.CharsetEncoder;\n+import java.nio.charset.CoderResult;\n+import java.nio.charset.CodingErrorAction;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8364365\n+ * @summary Verifies `CodingErrorAction.REPLACE` behaviour of all available\n+ *          character set encoders while encoding a Latin-1 character\n+ * @modules java.base\/jdk.internal.access\n+ *          java.base\/sun.nio.cs\n+ * @run junit TestEncoderReplaceLatin1\n+ *\/\n+\n+class TestEncoderReplaceLatin1 {\n+\n+    static Collection<Charset> charsets() {\n+        return Charset.availableCharsets().values();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"charsets\")\n+    void testEncoderReplace(Charset charset) {\n+\n+        \/\/ Create an encoder\n+        CharsetEncoder encoder = createEncoder(charset);\n+        if (encoder == null) {\n+            return;\n+        }\n+\n+        \/\/ Find an unmappable character to test the `REPLACE` action.\n+        char[] unmappable = findUnmappable(encoder);\n+        if (unmappable == null) {\n+            return;\n+        }\n+\n+        \/\/ Configure the `REPLACE` action\n+        byte[] replacement = findCustomReplacement(encoder, new byte[]{(byte) unmappable[0]});\n+        if (replacement == null) {\n+            return;\n+        }\n+        encoder.onUnmappableCharacter(CodingErrorAction.REPLACE).replaceWith(replacement);\n+\n+        \/\/ Verify the replacement\n+        System.err.println(\"Verifying replacement... \" + Map.of(\n+                \"unmappable\", TestEncoderReplaceLatin1.prettyPrintChars(unmappable),\n+                \"replacement\", TestEncoderReplaceLatin1.prettyPrintBytes(replacement)));\n+        testCharsetEncoderReplace(encoder, unmappable, replacement);\n+        testArrayEncoderLatin1Replace(encoder, unmappable[0], replacement);\n+\n+    }\n+\n+    private static CharsetEncoder createEncoder(Charset charset) {\n+        try {\n+            return charset.newEncoder();\n+        } catch (UnsupportedOperationException _) {\n+            System.err.println(\"Could not create the character encoder!\");\n+        }\n+        return null;\n+    }\n+\n+    private static char[] findUnmappable(CharsetEncoder encoder) {\n+        char[] unmappable1 = {0};\n+        for (char c = 0; c < 0xFF; c++) {\n+            unmappable1[0] = c;\n+            boolean unmappable = !encoder.canEncode(c);\n+            if (unmappable) {\n+                return unmappable1;\n+            }\n+        }\n+        System.err.println(\"Could not find an unmappable character!\");\n+        return null;\n+    }\n+\n+    \/**\n+     * Finds a {@linkplain CharsetEncoder#replacement() replacement} which is\n+     * different from the given unmappable and the default one.\n+     *\/\n+    static byte[] findCustomReplacement(CharsetEncoder encoder, byte[] unmappable) {\n+\n+        \/\/ Obtain the default replacement\n+        byte[] replacementD = encoder.replacement();\n+\n+        \/\/ Try to find a single-byte replacement\n+        byte[] replacement1 = {0};\n+        for (int i = 0; i < 0xFF; i++) {\n+            \/\/ Skip if the replacement is equal to the unmappable.\n+            \/\/ They need to be distinct to be able to determine whether the replacement has occurred.\n+            if (unmappable[0] == i) {\n+                continue;\n+            }\n+            replacement1[0] = (byte) i;\n+            \/\/ Skip the default value, since we're verifying if a custom one works\n+            if (replacement1[0] == replacementD[0]) {\n+                continue;\n+            }\n+            if (encoder.isLegalReplacement(replacement1)) {\n+                return replacement1;\n+            }\n+        }\n+\n+        \/\/ Try to find a double-byte replacement\n+        byte[] replacement2 = {0, 0};\n+        for (int i = 0; i < 0xFF; i++) {\n+            \/\/ Skip if the replacement is equal to the unmappable.\n+            \/\/ They need to be distinct to be able to determine whether the replacement has occurred.\n+            if (unmappable[0] == i) {\n+                continue;\n+            }\n+            replacement2[0] = (byte) i;\n+            for (int j = 0; j < 0xFF; j++) {\n+                \/\/ Skip if the replacement is equal to the unmappable.\n+                \/\/ They need to be distinct to be able to determine whether the replacement has occurred.\n+                if (unmappable.length > 1 && unmappable[1] == j) {\n+                    continue;\n+                }\n+                replacement2[1] = (byte) j;\n+                \/\/ Skip the default value, since we're verifying if a custom one works\n+                if (replacementD.length > 1 && replacement2[1] == replacementD[1]) {\n+                    continue;\n+                }\n+                if (encoder.isLegalReplacement(replacement2)) {\n+                    return replacement2;\n+                }\n+            }\n+        }\n+\n+        System.err.println(\"Could not find a replacement!\");\n+        return null;\n+\n+    }\n+\n+    \/**\n+     * Verifies {@linkplain CoderResult#isUnmappable() unmappable} character\n+     * {@linkplain CodingErrorAction#REPLACE replacement} using {@link\n+     * CharsetEncoder#encode(CharBuffer, ByteBuffer, boolean)\n+     * CharsetEncoder::encode}.\n+     *\/\n+    static void testCharsetEncoderReplace(CharsetEncoder encoder, char[] unmappable, byte[] replacement) {\n+        CharBuffer charBuffer = CharBuffer.wrap(unmappable);\n+        ByteBuffer byteBuffer = ByteBuffer.allocate(replacement.length);\n+        CoderResult coderResult = encoder.encode(charBuffer, byteBuffer, true);\n+        assertArrayEquals(replacement, byteBuffer.array(), () -> {\n+            Object context = Map.of(\n+                    \"coderResult\", coderResult,\n+                    \"byteBuffer.position()\", byteBuffer.position(),\n+                    \"byteBuffer.array()\", prettyPrintBytes(byteBuffer.array()),\n+                    \"unmappable\", prettyPrintChars(unmappable),\n+                    \"replacement\", prettyPrintBytes(replacement));\n+            return \"Unexpected `CharsetEncoder::encode` output! \" + context;\n+        });\n+    }\n+\n+    \/**\n+     * Verifies {@linkplain CoderResult#isUnmappable() unmappable} character\n+     * {@linkplain CodingErrorAction#REPLACE replacement} using {@link\n+     * ArrayEncoder#encodeFromLatin1(byte[], int, int, byte[])\n+     * ArrayEncoder::encodeFromLatin1}.\n+     *\/\n+    private static void testArrayEncoderLatin1Replace(CharsetEncoder encoder, char unmappable, byte[] replacement) {\n+        if (!(encoder instanceof ArrayEncoder arrayEncoder)) {\n+            System.err.println(\"Encoder is not of type `ArrayEncoder`, skipping the `ArrayEncoder::encodeFromLatin1` test.\");\n+            return;\n+        }\n+        byte[] sa = {(byte) unmappable};\n+        byte[] da = new byte[replacement.length];\n+        int dp = arrayEncoder.encodeFromLatin1(sa, 0, 1, da);\n+        assertTrue(dp == replacement.length && Arrays.equals(da, replacement), () -> {\n+            Object context = Map.of(\n+                    \"dp\", dp,\n+                    \"da\", prettyPrintBytes(da),\n+                    \"sa\", prettyPrintBytes(sa),\n+                    \"unmappable\", prettyPrintChars(new char[]{unmappable}),\n+                    \"replacement\", prettyPrintBytes(replacement));\n+            return \"Unexpected `ArrayEncoder::encodeFromLatin1` output! \" + context;\n+        });\n+    }\n+\n+    static String prettyPrintChars(char[] cs) {\n+        return IntStream.range(0, cs.length)\n+                .mapToObj(i -> String.format(\"U+%04X\", (int) cs[i]))\n+                .collect(Collectors.joining(\", \", \"[\", \"]\"));\n+    }\n+\n+    static String prettyPrintBytes(byte[] bs) {\n+        return IntStream.range(0, bs.length)\n+                .mapToObj(i -> String.format(\"0x%02X\", bs[i] & 0xFF))\n+                .collect(Collectors.joining(\", \", \"[\", \"]\"));\n+    }\n+\n+}\n","filename":"test\/jdk\/sun\/nio\/cs\/TestEncoderReplaceLatin1.java","additions":229,"deletions":0,"binary":false,"changes":229,"status":"added"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import sun.nio.cs.ArrayEncoder;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.CharsetEncoder;\n+import java.nio.charset.CoderResult;\n+import java.nio.charset.CodingErrorAction;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8364365\n+ * @summary Verifies `CodingErrorAction.REPLACE` behaviour of all available\n+ *          character set encoders while encoding a UTF-16 character\n+ * @modules java.base\/jdk.internal.access\n+ *          java.base\/sun.nio.cs\n+ * @build TestEncoderReplaceLatin1\n+ * @run junit\/timeout=10 TestEncoderReplaceUTF16\n+ * @run junit\/timeout=10\/othervm -XX:-CompactStrings TestEncoderReplaceUTF16\n+ *\/\n+\n+class TestEncoderReplaceUTF16 {\n+\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n+    \/**\n+     * Character sets known to be absent of non-Latin-1 {@linkplain CoderResult#isUnmappable() unmappable} characters.\n+     *\/\n+    private static final Set<String> CHARSETS_WITHOUT_UNMAPPABLE = Set.of(\n+            \"CESU-8\",\n+            \"EUC-JP\",\n+            \"GB18030\",\n+            \"ISO-2022-JP\",\n+            \"ISO-2022-JP-2\",\n+            \"ISO-2022-KR\",\n+            \"ISO-8859-1\",\n+            \"US-ASCII\",\n+            \"UTF-16\",\n+            \"UTF-16BE\",\n+            \"UTF-16LE\",\n+            \"UTF-32\",\n+            \"UTF-32BE\",\n+            \"UTF-32LE\",\n+            \"UTF-8\",\n+            \"x-euc-jp-linux\",\n+            \"x-EUC-TW\",\n+            \"x-eucJP-Open\",\n+            \"x-IBM29626C\",\n+            \"x-IBM33722\",\n+            \"x-IBM964\",\n+            \"x-ISCII91\",\n+            \"x-ISO-2022-CN-CNS\",\n+            \"x-ISO-2022-CN-GB\",\n+            \"x-MS932_0213\",\n+            \"x-SJIS_0213\",\n+            \"x-UTF-16LE-BOM\",\n+            \"X-UTF-32BE-BOM\",\n+            \"X-UTF-32LE-BOM\",\n+            \"x-windows-50220\",\n+            \"x-windows-50221\",\n+            \"x-windows-iso2022jp\");\n+\n+    @ParameterizedTest\n+    @MethodSource(\"TestEncoderReplaceLatin1#charsets\")\n+    void testEncoderReplace(Charset charset) {\n+\n+        \/\/ Create an encoder\n+        CharsetEncoder encoder = createEncoder(charset);\n+        if (encoder == null) {\n+            return;\n+        }\n+\n+        \/\/ Find an unmappable character to test the `REPLACE` action.\n+        char[] unmappable = findUnmappableNonLatin1(encoder);\n+        if (unmappable == null) {\n+            return;\n+        }\n+\n+        \/\/ Configure the `REPLACE` action\n+        byte[] unmappableUTF16Bytes = utf16Bytes(unmappable);\n+        byte[] replacement = TestEncoderReplaceLatin1.findCustomReplacement(encoder, unmappableUTF16Bytes);\n+        if (replacement == null) {\n+            return;\n+        }\n+        encoder.onUnmappableCharacter(CodingErrorAction.REPLACE).replaceWith(replacement);\n+\n+        \/\/ Verify the replacement\n+        System.err.println(\"Verifying replacement... \" + Map.of(\n+                \"unmappable\", TestEncoderReplaceLatin1.prettyPrintChars(unmappable),\n+                \"unmappableUTF16Bytes\", TestEncoderReplaceLatin1.prettyPrintBytes(unmappableUTF16Bytes),\n+                \"replacement\", TestEncoderReplaceLatin1.prettyPrintBytes(replacement)));\n+        TestEncoderReplaceLatin1.testCharsetEncoderReplace(encoder, unmappable, replacement);\n+        testArrayEncoderUTF16Replace(encoder, unmappableUTF16Bytes, replacement);\n+\n+    }\n+\n+    private static CharsetEncoder createEncoder(Charset charset) {\n+        try {\n+            return charset.newEncoder();\n+        } catch (UnsupportedOperationException _) {\n+            System.err.println(\"Could not create the character encoder!\");\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Finds an {@linkplain CoderResult#isUnmappable() unmappable} non-Latin-1 {@code char[]} for the given encoder.\n+     *\/\n+    private static char[] findUnmappableNonLatin1(CharsetEncoder encoder) {\n+\n+        \/\/ Fast-path for characters sets known to be absent of unmappable non-Latin-1 characters\n+        if (CHARSETS_WITHOUT_UNMAPPABLE.contains(encoder.charset().name())) {\n+            System.err.println(\"Character set is known to be absent of unmappable non-Latin-1 characters!\");\n+            return null;\n+        }\n+\n+        \/\/ Try to find a single-`char` unmappable\n+        for (int i = 0xFF; i <= 0xFFFF; i++) {\n+            char c = (char) i;\n+            \/\/ Skip the surrogate, as a single dangling surrogate `char` should\n+            \/\/ trigger a \"malformed\" error, instead of \"unmappable\"\n+            if (Character.isSurrogate(c)) {\n+                continue;\n+            }\n+            boolean unmappable = !encoder.canEncode(c);\n+            if (unmappable) {\n+                return new char[]{c};\n+            }\n+        }\n+\n+        \/\/ Try to find a double-`char` (i.e., surrogate pair) unmappable\n+        int[] nonBmpRange = {0x10000, 0x10FFFF};\n+        for (int i = nonBmpRange[0]; i < nonBmpRange[1]; i++) {\n+            char[] cs = Character.toChars(i);\n+            if (!encoder.canEncode(new String(cs)))\n+                return cs;\n+        }\n+\n+        System.err.println(\"Could not find an unmappable character!\");\n+        return null;\n+    }\n+\n+    private static byte[] utf16Bytes(char[] cs) {\n+        int sl = cs.length;\n+        byte[] sa = new byte[sl << 1];\n+        for (int i = 0; i < sl; i++) {\n+            JLA.uncheckedPutCharUTF16(sa, i, cs[i]);\n+        }\n+        return sa;\n+    }\n+\n+    \/**\n+     * Verifies {@linkplain CoderResult#isUnmappable() unmappable} character\n+     * {@linkplain CodingErrorAction#REPLACE replacement} using {@link\n+     * ArrayEncoder#encodeFromUTF16(byte[], int, int, byte[])\n+     * ArrayEncoder::encodeFromUTF16}.\n+     *\/\n+    private static void testArrayEncoderUTF16Replace(CharsetEncoder encoder, byte[] unmappableUTF16Bytes, byte[] replacement) {\n+        if (!(encoder instanceof ArrayEncoder arrayEncoder)) {\n+            System.err.println(\"Encoder is not of type `ArrayEncoder`, skipping the `ArrayEncoder::encodeFromUTF16` test.\");\n+            return;\n+        }\n+        byte[] da = new byte[replacement.length];\n+        int dp = arrayEncoder.encodeFromUTF16(unmappableUTF16Bytes, 0, unmappableUTF16Bytes.length >>> 1, da);\n+        assertTrue(dp == replacement.length && Arrays.equals(da, replacement), () -> {\n+            Object context = Map.of(\n+                    \"dp\", dp,\n+                    \"da\", TestEncoderReplaceLatin1.prettyPrintBytes(da),\n+                    \"unmappableUTF16Bytes\", TestEncoderReplaceLatin1.prettyPrintBytes(unmappableUTF16Bytes),\n+                    \"replacement\", TestEncoderReplaceLatin1.prettyPrintBytes(replacement));\n+            return \"Unexpected `ArrayEncoder::encodeFromUTF16` output! \" + context;\n+        });\n+    }\n+\n+}\n","filename":"test\/jdk\/sun\/nio\/cs\/TestEncoderReplaceUTF16.java","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2024, THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2024, Tencent. All rights reserved.\n","filename":"test\/jdk\/sun\/security\/ec\/ECDHKeyAgreementParamValidation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2022, Tencent. All rights reserved.\n@@ -62,1 +62,0 @@\n-\n","filename":"test\/jdk\/sun\/security\/jgss\/GssContextCleanup.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2022, Tencent. All rights reserved.\n@@ -69,1 +69,0 @@\n-\n","filename":"test\/jdk\/sun\/security\/jgss\/GssNameCleanup.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (C) 2021, 2024 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2021, 2024, Tencent. All rights reserved.\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/SigAlgosExtTestWithTLS12.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2021, Tencent. All rights reserved.\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/SigAlgosExtTestWithTLS13.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -165,6 +165,1 @@\n-            if (doSleep) {\n-                launcher.addVMArgs(Utils.getTestJavaOpts());\n-            } else {\n-                \/\/ Don't allow use of SerialGC. See JDK-8313655.\n-                launcher.addVMArgs(Utils.getFilteredTestJavaOpts(\"-XX:\\\\+UseSerialGC\"));\n-            }\n+            launcher.addVMArgs(Utils.getTestJavaOpts());\n","filename":"test\/jdk\/sun\/tools\/jhsdb\/JShellHeapDumpTest.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -71,2 +71,2 @@\n-            final List<ImageReader.Node> children = parent.getChildren();\n-            if (children == null || children.isEmpty()) {\n+            final List<String> childNames = parent.getChildNames().toList();\n+            if (childNames.isEmpty()) {\n@@ -77,2 +77,2 @@\n-            for (final ImageReader.Node child : children) {\n-                final boolean unique = uniqueChildren.add(child);\n+            for (final String childName : childNames) {\n+                final boolean unique = uniqueChildren.add(reader.findNode(childName));\n@@ -81,1 +81,1 @@\n-                            + child + \" under \" + parent + \" from image \" + imagePath);\n+                            + childName + \" under \" + parent + \" from image \" + imagePath);\n","filename":"test\/jdk\/tools\/jimage\/ImageReaderDuplicateChildNodesTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n@@ -27,0 +29,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -29,0 +33,1 @@\n+import java.util.Optional;\n@@ -35,1 +40,16 @@\n-        lines.forEach(System.out::println);\n+        Optional.ofNullable(System.getProperty(\"jpackage.test.appOutput\")).map(Path::of).ifPresentOrElse(outputFilePath -> {\n+            Optional.ofNullable(outputFilePath.getParent()).ifPresent(dir -> {\n+                try {\n+                    Files.createDirectories(dir);\n+                } catch (IOException ex) {\n+                    throw new UncheckedIOException(ex);\n+                }\n+            });\n+            try {\n+                Files.write(outputFilePath, lines);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }, () -> {\n+            lines.forEach(System.out::println);\n+        });\n@@ -48,1 +68,1 @@\n-            } else if (arg.startsWith(PRINT_MODULES)) {\n+            } else if (arg.equals(PRINT_MODULES)) {\n@@ -53,0 +73,2 @@\n+            } else if (arg.equals(PRINT_WORK_DIR)) {\n+                lines.add(\"$CD=\" + Path.of(\"\").toAbsolutePath());\n@@ -61,3 +83,4 @@\n-    private final static String PRINT_ENV_VAR = \"--print-env-var=\";\n-    private final static String PRINT_SYS_PROP = \"--print-sys-prop=\";\n-    private final static String PRINT_MODULES = \"--print-modules\";\n+    private static final String PRINT_ENV_VAR = \"--print-env-var=\";\n+    private static final String PRINT_SYS_PROP = \"--print-sys-prop=\";\n+    private static final String PRINT_MODULES = \"--print-modules\";\n+    private static final String PRINT_WORK_DIR = \"--print-workdir\";\n","filename":"test\/jdk\/tools\/jpackage\/apps\/PrintEnv.java","additions":28,"deletions":5,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+#!\/bin\/bash\n+\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+\n+#\n+# Filters output produced by running jpackage test(s).\n+#\n+\n+set -eu\n+set -o pipefail\n+\n+\n+sed_inplace_option=-i\n+sed_version_string=$(sed --version 2>&1 | head -1 || true)\n+if [ \"${sed_version_string#sed (GNU sed)}\" != \"$sed_version_string\" ]; then\n+  # GNU sed, the default\n+  :\n+elif [ \"${sed_version_string#sed: illegal option}\" != \"$sed_version_string\" ]; then\n+  # Macos sed\n+  sed_inplace_option=\"-i ''\"\n+else\n+  echo 'WARNING: Unknown sed variant, assume it is GNU compatible'\n+fi\n+\n+\n+filterFile () {\n+  local expressions=(\n+      # Strip leading log message timestamp `[19:33:44.713] `\n+      -e 's\/^\\[[0-9]\\{2\\}:[0-9]\\{2\\}:[0-9]\\{2\\}\\.[0-9]\\{3\\}\\] \/\/'\n+\n+      # Strip log message timestamps `[19:33:44.713]`\n+      -e 's\/\\[[0-9]\\{2\\}:[0-9]\\{2\\}:[0-9]\\{2\\}\\.[0-9]\\{3\\}\\]\/\/g'\n+\n+      # Convert variable part of R\/O directory path timestamp `#2025-07-24T16:38:13.3589878Z`\n+      -e 's\/#[0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}T[0-9]\\{2\\}:[0-9]\\{2\\}:[0-9]\\{2\\}\\.[0-9]\\{1,\\}Z\/#<ts>Z\/'\n+\n+      # Strip variable part of temporary directory name `jdk.jpackage5060841750457404688`\n+      -e 's|\\([\\\/]\\)jdk\\.jpackage[0-9]\\{1,\\}\\b|\\1jdk.jpackage|g'\n+\n+      # Convert PID value `[PID: 131561]`\n+      -e 's\/\\[PID: [0-9]\\{1,\\}\\]\/[PID: <pid>]\/'\n+\n+      # Strip a warning message `Windows Defender may prevent jpackage from functioning`\n+      -e '\/Windows Defender may prevent jpackage from functioning\/d'\n+\n+      # Convert variable part of test output directory `out-6268`\n+      -e 's|\\bout-[0-9]\\{1,\\}\\b|out-N|g'\n+\n+      # Convert variable part of test summary `[       OK ] IconTest(AppImage, ResourceDirIcon, DefaultIcon).test; checks=39`\n+      -e 's\/^\\(.*\\bchecks=\\)[0-9]\\{1,\\}\\(\\r\\{0,1\\}\\)$\/\\1N\\2\/'\n+\n+      # Convert variable part of ldd output `libdl.so.2 => \/lib64\/libdl.so.2 (0x00007fbf63c81000)`\n+      -e 's\/(0x[[:xdigit:]]\\{1,\\})$\/(0xHEX)\/'\n+\n+      # Convert variable part of rpmbuild output `Executing(%build): \/bin\/sh -e \/var\/tmp\/rpm-tmp.CMO6a9`\n+      -e 's|\/rpm-tmp\\...*$|\/rpm-tmp.V|'\n+\n+      # Convert variable part of stack trace entry `at jdk.jpackage.test.JPackageCommand.execute(JPackageCommand.java:863)`\n+      -e 's\/^\\(.*\\b\\.java:\\)[0-9]\\{1,\\}\\()\\r\\{0,1\\}\\)$\/\\1N\\2\/'\n+  )\n+\n+  sed $sed_inplace_option \"$1\" \"${expressions[@]}\"\n+}\n+\n+\n+for f in \"$@\"; do\n+  filterFile \"$f\"\n+done\n","filename":"test\/jdk\/tools\/jpackage\/clean_test_output.sh","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -25,2 +25,4 @@\n-import static java.util.stream.Collectors.toMap;\n-import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+import static jdk.jpackage.test.LauncherShortcut.LINUX_SHORTCUT;\n+import static jdk.jpackage.test.LauncherShortcut.WIN_DESKTOP_SHORTCUT;\n+import static jdk.jpackage.test.LauncherShortcut.WIN_START_MENU_SHORTCUT;\n@@ -33,0 +35,3 @@\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n@@ -37,0 +42,2 @@\n+import java.util.Properties;\n+import java.util.Set;\n@@ -38,4 +45,0 @@\n-import java.util.function.Supplier;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-import java.util.stream.Stream;\n@@ -43,0 +46,3 @@\n+import jdk.jpackage.internal.util.function.ThrowingConsumer;\n+import jdk.jpackage.test.LauncherShortcut.StartupDirectory;\n+import jdk.jpackage.test.LauncherVerifier.Action;\n@@ -44,1 +50,1 @@\n-public class AdditionalLauncher {\n+public final class AdditionalLauncher {\n@@ -47,2 +53,1 @@\n-        this.name = name;\n-        this.rawProperties = new ArrayList<>();\n+        this.name = Objects.requireNonNull(name);\n@@ -52,1 +57,15 @@\n-    public final AdditionalLauncher setDefaultArguments(String... v) {\n+    public String name() {\n+        return name;\n+    }\n+\n+    public AdditionalLauncher withVerifyActions(Action... actions) {\n+        verifyActions.addAll(List.of(actions));\n+        return this;\n+    }\n+\n+    public AdditionalLauncher withoutVerifyActions(Action... actions) {\n+        verifyActions.removeAll(List.of(actions));\n+        return this;\n+    }\n+\n+    public AdditionalLauncher setDefaultArguments(String... v) {\n@@ -57,1 +76,1 @@\n-    public final AdditionalLauncher addDefaultArguments(String... v) {\n+    public AdditionalLauncher addDefaultArguments(String... v) {\n@@ -66,1 +85,1 @@\n-    public final AdditionalLauncher setJavaOptions(String... v) {\n+    public AdditionalLauncher setJavaOptions(String... v) {\n@@ -71,1 +90,1 @@\n-    public final AdditionalLauncher addJavaOptions(String... v) {\n+    public AdditionalLauncher addJavaOptions(String... v) {\n@@ -80,2 +99,2 @@\n-    public final AdditionalLauncher setVerifyUninstalled(boolean value) {\n-        verifyUninstalled = value;\n+    public AdditionalLauncher setProperty(String name, Object value) {\n+        rawProperties.put(Objects.requireNonNull(name), Objects.requireNonNull(value.toString()));\n@@ -85,17 +104,7 @@\n-    public final AdditionalLauncher setLauncherAsService() {\n-        return addRawProperties(LAUNCHER_AS_SERVICE);\n-    }\n-\n-    public final AdditionalLauncher addRawProperties(\n-            Map.Entry<String, String> v) {\n-        return addRawProperties(List.of(v));\n-    }\n-\n-    public final AdditionalLauncher addRawProperties(\n-            Map.Entry<String, String> v, Map.Entry<String, String> v2) {\n-        return addRawProperties(List.of(v, v2));\n-    }\n-\n-    public final AdditionalLauncher addRawProperties(\n-            Collection<Map.Entry<String, String>> v) {\n-        rawProperties.addAll(v);\n+    public AdditionalLauncher setShortcuts(boolean menu, boolean desktop) {\n+        if (TKit.isLinux()) {\n+            setShortcut(LINUX_SHORTCUT, desktop);\n+        } else if (TKit.isWindows()) {\n+            setShortcut(WIN_DESKTOP_SHORTCUT, desktop);\n+            setShortcut(WIN_START_MENU_SHORTCUT, menu);\n+        }\n@@ -105,5 +114,7 @@\n-    public final String getRawPropertyValue(\n-            String key, Supplier<String> getDefault) {\n-        return rawProperties.stream()\n-                .filter(item -> item.getKey().equals(key))\n-                .map(e -> e.getValue()).findAny().orElseGet(getDefault);\n+    public AdditionalLauncher setShortcut(LauncherShortcut shortcut, StartupDirectory value) {\n+        if (value != null) {\n+            setProperty(shortcut.propertyName(), value.asStringValue());\n+        } else {\n+            setProperty(shortcut.propertyName(), false);\n+        }\n+        return this;\n@@ -112,3 +123,7 @@\n-    private String getDesciption(JPackageCommand cmd) {\n-        return getRawPropertyValue(\"description\", () -> cmd.getArgumentValue(\n-                \"--description\", unused -> cmd.name()));\n+    public AdditionalLauncher setShortcut(LauncherShortcut shortcut, boolean value) {\n+        if (value) {\n+            setShortcut(shortcut, StartupDirectory.DEFAULT);\n+        } else {\n+            setShortcut(shortcut, null);\n+        }\n+        return this;\n@@ -117,3 +132,2 @@\n-    public final AdditionalLauncher setShortcuts(boolean menu, boolean shortcut) {\n-        withMenuShortcut = menu;\n-        withShortcut = shortcut;\n+    public AdditionalLauncher removeShortcut(LauncherShortcut shortcut) {\n+        rawProperties.remove(shortcut.propertyName());\n@@ -123,2 +137,2 @@\n-    public final AdditionalLauncher setIcon(Path iconPath) {\n-        if (iconPath == NO_ICON) {\n+    public AdditionalLauncher setIcon(Path iconPath) {\n+        if (iconPath.equals(NO_ICON)) {\n@@ -132,1 +146,1 @@\n-    public final AdditionalLauncher setNoIcon() {\n+    public AdditionalLauncher setNoIcon() {\n@@ -137,2 +151,2 @@\n-    public final AdditionalLauncher setPersistenceHandler(\n-            ThrowingBiConsumer<Path, List<Map.Entry<String, String>>> handler) {\n+    public AdditionalLauncher setPersistenceHandler(\n+            ThrowingBiConsumer<Path, Collection<Map.Entry<String, String>>> handler) {\n@@ -147,1 +161,1 @@\n-    public final void applyTo(JPackageCommand cmd) {\n+    public void applyTo(JPackageCommand cmd) {\n@@ -149,1 +163,1 @@\n-        cmd.addVerifyAction(this::verify);\n+        cmd.addVerifyAction(createVerifierAsConsumer());\n@@ -152,1 +166,1 @@\n-    public final void applyTo(PackageTest test) {\n+    public void applyTo(PackageTest test) {\n@@ -154,4 +168,1 @@\n-        test.addInstallVerifier(this::verify);\n-        if (verifyUninstalled) {\n-            test.addUninstallVerifier(this::verifyUninstalled);\n-        }\n+        test.addInstallVerifier(createVerifierAsConsumer());\n@@ -161,1 +172,14 @@\n-        test.addInstallVerifier(this::verifyUninstalled);\n+        test.addInstallVerifier(cmd -> {\n+            createVerifier().verify(cmd, LauncherVerifier.Action.VERIFY_UNINSTALLED);\n+        });\n+    }\n+\n+    private LauncherVerifier createVerifier() {\n+        return new LauncherVerifier(name, Optional.ofNullable(javaOptions),\n+                Optional.ofNullable(defaultArguments), Optional.ofNullable(icon), rawProperties);\n+    }\n+\n+    private ThrowingConsumer<JPackageCommand> createVerifierAsConsumer() {\n+        return cmd -> {\n+            createVerifier().verify(cmd, verifyActions.stream().sorted(Comparator.comparing(Action::ordinal)).toArray(Action[]::new));\n+        };\n@@ -182,2 +206,3 @@\n-                shell[0] = toFunction(PropertyFile::new).apply(\n-                        propertiesFilePath);\n+                shell[0] = toSupplier(() -> {\n+                    return new PropertyFile(propertiesFilePath);\n+                }).get();\n@@ -186,1 +211,1 @@\n-        return Optional.of(shell[0]).get();\n+        return Objects.requireNonNull(shell[0]);\n@@ -194,1 +219,1 @@\n-        List<Map.Entry<String, String>> properties = new ArrayList<>();\n+        Map<String, String> properties = new HashMap<>();\n@@ -196,2 +221,1 @@\n-            properties.add(Map.entry(\"arguments\",\n-                    JPackageCommand.escapeAndJoin(defaultArguments)));\n+            properties.put(\"arguments\", JPackageCommand.escapeAndJoin(defaultArguments));\n@@ -201,2 +225,1 @@\n-            properties.add(Map.entry(\"java-options\",\n-                    JPackageCommand.escapeAndJoin(javaOptions)));\n+            properties.put(\"java-options\", JPackageCommand.escapeAndJoin(javaOptions));\n@@ -207,1 +230,1 @@\n-            if (icon == NO_ICON) {\n+            if (icon.equals(NO_ICON)) {\n@@ -212,79 +235,1 @@\n-            properties.add(Map.entry(\"icon\", iconPath));\n-        }\n-\n-        if (withShortcut != null) {\n-            if (TKit.isLinux()) {\n-                properties.add(Map.entry(\"linux-shortcut\", withShortcut.toString()));\n-            } else if (TKit.isWindows()) {\n-                properties.add(Map.entry(\"win-shortcut\", withShortcut.toString()));\n-            }\n-        }\n-\n-        if (TKit.isWindows() && withMenuShortcut != null)  {\n-            properties.add(Map.entry(\"win-menu\", withMenuShortcut.toString()));\n-        }\n-\n-        properties.addAll(rawProperties);\n-\n-        createFileHandler.accept(propsFile, properties);\n-    }\n-\n-    private static Path iconInResourceDir(JPackageCommand cmd,\n-            String launcherName) {\n-        Path resourceDir = cmd.getArgumentValue(\"--resource-dir\", () -> null,\n-                Path::of);\n-        if (resourceDir != null) {\n-            Path icon = resourceDir.resolve(\n-                    Optional.ofNullable(launcherName).orElseGet(() -> cmd.name())\n-                    + TKit.ICON_SUFFIX);\n-            if (Files.exists(icon)) {\n-                return icon;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    private void verifyIcon(JPackageCommand cmd) throws IOException {\n-        var verifier = new LauncherIconVerifier().setLauncherName(name);\n-\n-        if (TKit.isOSX()) {\n-            \/\/ On Mac should be no icon files for additional launchers.\n-            verifier.applyTo(cmd);\n-            return;\n-        }\n-\n-        boolean withLinuxDesktopFile = false;\n-\n-        final Path effectiveIcon = Optional.ofNullable(icon).orElseGet(\n-                () -> iconInResourceDir(cmd, name));\n-        while (effectiveIcon != NO_ICON) {\n-            if (effectiveIcon != null) {\n-                withLinuxDesktopFile = Boolean.FALSE != withShortcut;\n-                verifier.setExpectedIcon(effectiveIcon);\n-                break;\n-            }\n-\n-            Path customMainLauncherIcon = cmd.getArgumentValue(\"--icon\",\n-                    () -> iconInResourceDir(cmd, null), Path::of);\n-            if (customMainLauncherIcon != null) {\n-                withLinuxDesktopFile = Boolean.FALSE != withShortcut;\n-                verifier.setExpectedIcon(customMainLauncherIcon);\n-                break;\n-            }\n-\n-            verifier.setExpectedDefaultIcon();\n-            break;\n-        }\n-\n-        if (TKit.isLinux() && !cmd.isImagePackageType()) {\n-            if (effectiveIcon != NO_ICON && !withLinuxDesktopFile) {\n-                withLinuxDesktopFile = (Boolean.FALSE != withShortcut) &&\n-                        Stream.of(\"--linux-shortcut\").anyMatch(cmd::hasArgument);\n-                verifier.setExpectedDefaultIcon();\n-            }\n-            Path desktopFile = LinuxHelper.getDesktopFile(cmd, name);\n-            if (withLinuxDesktopFile) {\n-                TKit.assertFileExists(desktopFile);\n-            } else {\n-                TKit.assertPathExists(desktopFile, false);\n-            }\n+            properties.put(\"icon\", iconPath);\n@@ -293,2 +238,1 @@\n-        verifier.applyTo(cmd);\n-    }\n+        properties.putAll(rawProperties);\n@@ -296,93 +240,1 @@\n-    private void verifyShortcuts(JPackageCommand cmd) throws IOException {\n-        if (TKit.isLinux() && !cmd.isImagePackageType()\n-                && withShortcut != null) {\n-            Path desktopFile = LinuxHelper.getDesktopFile(cmd, name);\n-            if (withShortcut) {\n-                TKit.assertFileExists(desktopFile);\n-            } else {\n-                TKit.assertPathExists(desktopFile, false);\n-            }\n-        }\n-    }\n-\n-    private void verifyDescription(JPackageCommand cmd) throws IOException {\n-        if (TKit.isWindows()) {\n-            String expectedDescription = getDesciption(cmd);\n-            Path launcherPath = cmd.appLauncherPath(name);\n-            String actualDescription =\n-                    WindowsHelper.getExecutableDesciption(launcherPath);\n-            TKit.assertEquals(expectedDescription, actualDescription,\n-                    String.format(\"Check file description of [%s]\", launcherPath));\n-        } else if (TKit.isLinux() && !cmd.isImagePackageType()) {\n-            String expectedDescription = getDesciption(cmd);\n-            Path desktopFile = LinuxHelper.getDesktopFile(cmd, name);\n-            if (Files.exists(desktopFile)) {\n-                TKit.assertTextStream(\"Comment=\" + expectedDescription)\n-                        .label(String.format(\"[%s] file\", desktopFile))\n-                        .predicate(String::equals)\n-                        .apply(Files.readAllLines(desktopFile));\n-            }\n-        }\n-    }\n-\n-    private void verifyInstalled(JPackageCommand cmd, boolean installed) throws IOException {\n-        if (TKit.isLinux() && !cmd.isImagePackageType() && !cmd.\n-                isPackageUnpacked(String.format(\n-                        \"Not verifying package and system .desktop files for [%s] launcher\",\n-                        cmd.appLauncherPath(name)))) {\n-            Path packageDesktopFile = LinuxHelper.getDesktopFile(cmd, name);\n-            Path systemDesktopFile = LinuxHelper.getSystemDesktopFilesFolder().\n-                    resolve(packageDesktopFile.getFileName());\n-            if (Files.exists(packageDesktopFile) && installed) {\n-                TKit.assertFileExists(systemDesktopFile);\n-                TKit.assertStringListEquals(Files.readAllLines(\n-                        packageDesktopFile),\n-                        Files.readAllLines(systemDesktopFile), String.format(\n-                        \"Check [%s] and [%s] files are equal\",\n-                        packageDesktopFile,\n-                        systemDesktopFile));\n-            } else {\n-                TKit.assertPathExists(packageDesktopFile, false);\n-                TKit.assertPathExists(systemDesktopFile, false);\n-            }\n-        }\n-    }\n-\n-    protected void verifyUninstalled(JPackageCommand cmd) throws IOException {\n-        verifyInstalled(cmd, false);\n-        Path launcherPath = cmd.appLauncherPath(name);\n-        TKit.assertPathExists(launcherPath, false);\n-    }\n-\n-    protected void verify(JPackageCommand cmd) throws IOException {\n-        verifyIcon(cmd);\n-        verifyShortcuts(cmd);\n-        verifyDescription(cmd);\n-        verifyInstalled(cmd, true);\n-\n-        Path launcherPath = cmd.appLauncherPath(name);\n-\n-        TKit.assertExecutableFileExists(launcherPath);\n-\n-        if (!cmd.canRunLauncher(String.format(\n-                \"Not running %s launcher\", launcherPath))) {\n-            return;\n-        }\n-\n-        var appVerifier = HelloApp.assertApp(launcherPath)\n-                .addDefaultArguments(Optional\n-                        .ofNullable(defaultArguments)\n-                        .orElseGet(() -> List.of(cmd.getAllArgumentValues(\"--arguments\"))))\n-                .addJavaOptions(Optional\n-                        .ofNullable(javaOptions)\n-                        .orElseGet(() -> List.of(cmd.getAllArgumentValues(\n-                        \"--java-options\"))).stream().map(\n-                        str -> resolveVariables(cmd, str)).toList());\n-\n-        if (!rawProperties.contains(LAUNCHER_AS_SERVICE)) {\n-            appVerifier.executeAndVerifyOutput();\n-        } else if (!cmd.isPackageUnpacked(String.format(\n-                \"Not verifying contents of test output file for [%s] launcher\",\n-                launcherPath))) {\n-            appVerifier.verifyOutput();\n-        }\n+        createFileHandler.accept(propsFile, properties.entrySet());\n@@ -393,12 +245,3 @@\n-        PropertyFile(Path path) throws IOException {\n-            data = Files.readAllLines(path).stream().map(str -> {\n-                return str.split(\"=\", 2);\n-            }).collect(toMap(tokens -> tokens[0], tokens -> {\n-                if (tokens.length == 1) {\n-                    return \"\";\n-                } else {\n-                    return tokens[1];\n-                }\n-            }, (oldValue, newValue) -> {\n-                return newValue;\n-            }));\n+        PropertyFile(Map<String, String> data) {\n+            this.data = new Properties();\n+            this.data.putAll(data);\n@@ -407,3 +250,5 @@\n-        public boolean isPropertySet(String name) {\n-            Objects.requireNonNull(name);\n-            return data.containsKey(name);\n+        PropertyFile(Path path) throws IOException {\n+            data = new Properties();\n+            try (var reader = Files.newBufferedReader(path)) {\n+                data.load(reader);\n+            }\n@@ -412,1 +257,1 @@\n-        public Optional<String> getPropertyValue(String name) {\n+        public Optional<String> findProperty(String name) {\n@@ -414,1 +259,1 @@\n-            return Optional.of(data.get(name));\n+            return Optional.ofNullable(data.getProperty(name));\n@@ -417,3 +262,2 @@\n-        public Optional<Boolean> getPropertyBooleanValue(String name) {\n-            Objects.requireNonNull(name);\n-            return Optional.ofNullable(data.get(name)).map(Boolean::parseBoolean);\n+        public Optional<Boolean> findBooleanProperty(String name) {\n+            return findProperty(name).map(Boolean::parseBoolean);\n@@ -422,1 +266,1 @@\n-        private final Map<String, String> data;\n+        private final Properties data;\n@@ -425,12 +269,0 @@\n-    private static String resolveVariables(JPackageCommand cmd, String str) {\n-        var map = Stream.of(JPackageCommand.Macro.values()).collect(toMap(x -> {\n-            return String.format(\"$%s\", x.name());\n-        }, cmd::macroValue));\n-        for (var e : map.entrySet()) {\n-            str = str.replaceAll(Pattern.quote(e.getKey()),\n-                    Matcher.quoteReplacement(e.getValue().toString()));\n-        }\n-        return str;\n-    }\n-\n-    private boolean verifyUninstalled;\n@@ -441,8 +273,5 @@\n-    private final List<Map.Entry<String, String>> rawProperties;\n-    private BiConsumer<Path, List<Map.Entry<String, String>>> createFileHandler;\n-    private Boolean withMenuShortcut;\n-    private Boolean withShortcut;\n-\n-    private static final Path NO_ICON = Path.of(\"\");\n-    private static final Map.Entry<String, String> LAUNCHER_AS_SERVICE = Map.entry(\n-            \"launcher-as-service\", \"true\");\n+    private final Map<String, String> rawProperties = new HashMap<>();\n+    private BiConsumer<Path, Collection<Map.Entry<String, String>>> createFileHandler;\n+    private final Set<Action> verifyActions = new HashSet<>(Action.VERIFY_DEFAULTS);\n+\n+    static final Path NO_ICON = Path.of(\"\");\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/AdditionalLauncher.java","additions":109,"deletions":280,"binary":false,"changes":389,"status":"modified"},{"patch":"@@ -25,0 +25,4 @@\n+import static java.util.stream.Collectors.toMap;\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+\n@@ -28,0 +32,1 @@\n+import java.util.HashMap;\n@@ -29,0 +34,1 @@\n+import java.util.Objects;\n@@ -30,0 +36,1 @@\n+import java.util.stream.Stream;\n@@ -34,1 +41,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n@@ -36,0 +42,2 @@\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n@@ -38,1 +46,1 @@\n-        String version, boolean macSigned, boolean macAppStore) {\n+        String version, boolean macSigned, boolean macAppStore, Map<String, Map<String, String>> launchers) {\n@@ -47,0 +55,9 @@\n+    public AppImageFile {\n+        Objects.requireNonNull(mainLauncherName);\n+        Objects.requireNonNull(mainLauncherClassName);\n+        Objects.requireNonNull(version);\n+        if (!launchers.containsKey(mainLauncherName)) {\n+            throw new IllegalArgumentException();\n+        }\n+    }\n+\n@@ -48,1 +65,7 @@\n-        this(mainLauncherName, mainLauncherClassName, \"1.0\", false, false);\n+        this(mainLauncherName, mainLauncherClassName, \"1.0\", false, false, Map.of(mainLauncherName, Map.of()));\n+    }\n+\n+    public Map<String, Map<String, String>> addLaunchers() {\n+        return launchers.entrySet().stream().filter(e -> {\n+            return !e.getKey().equals(mainLauncherName);\n+        }).collect(toMap(Map.Entry::getKey, Map.Entry::getValue));\n@@ -76,0 +99,12 @@\n+\n+            for (var al : addLaunchers().keySet().stream().sorted().toList()) {\n+                xml.writeStartElement(\"add-launcher\");\n+                xml.writeAttribute(\"name\", al);\n+                var props = launchers.get(al);\n+                for (var prop : props.keySet().stream().sorted().toList()) {\n+                    xml.writeStartElement(prop);\n+                    xml.writeCharacters(props.get(prop));\n+                    xml.writeEndElement();\n+                }\n+                xml.writeEndElement();\n+            }\n@@ -102,0 +137,26 @@\n+            var addLaunchers = XmlUtils.queryNodes(doc, xPath, \"\/jpackage-state\/add-launcher\").map(Element.class::cast).map(toFunction(addLauncher -> {\n+                Map<String, String> launcherProps = new HashMap<>();\n+\n+                \/\/ @name and @service attributes.\n+                XmlUtils.toStream(addLauncher.getAttributes()).forEach(attr -> {\n+                    launcherProps.put(attr.getNodeName(), attr.getNodeValue());\n+                });\n+\n+                \/\/ Extra properties.\n+                XmlUtils.queryNodes(addLauncher, xPath, \"*[count(*) = 0]\").map(Element.class::cast).forEach(e -> {\n+                    launcherProps.put(e.getNodeName(), e.getTextContent());\n+                });\n+\n+                return launcherProps;\n+            }));\n+\n+            var mainLauncherProperties = Map.of(\"name\", mainLauncherName);\n+\n+            var launchers = Stream.concat(Stream.of(mainLauncherProperties), addLaunchers).collect(toMap(attrs -> {\n+                return Objects.requireNonNull(attrs.get(\"name\"));\n+            }, attrs -> {\n+                Map<String, String> copy = new HashMap<>(attrs);\n+                copy.remove(\"name\");\n+                return Map.copyOf(copy);\n+            }));\n+\n@@ -103,1 +164,1 @@\n-                    version, macSigned, macAppStore);\n+                    version, macSigned, macAppStore, launchers);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/AppImageFile.java","additions":65,"deletions":4,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+        verifyMutable();\n@@ -43,2 +44,1 @@\n-        args.add(v);\n-        return thiz();\n+        return addArguments(v);\n@@ -48,0 +48,1 @@\n+        verifyMutable();\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/CommandArguments.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -223,1 +223,1 @@\n-                            .getPropertyBooleanValue(\"launcher-as-service\").orElse(false);\n+                            .findBooleanProperty(\"launcher-as-service\").orElse(false);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/ConfigFilesStasher.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-    public JPackageCommand(JPackageCommand cmd) {\n+    private JPackageCommand(JPackageCommand cmd, boolean immutable) {\n@@ -84,1 +84,1 @@\n-        immutable = cmd.immutable;\n+        this.immutable = immutable;\n@@ -93,0 +93,1 @@\n+        unpackedPackageDirectory = cmd.unpackedPackageDirectory;\n@@ -96,3 +97,5 @@\n-        JPackageCommand reply = new JPackageCommand(this);\n-        reply.immutable = true;\n-        return reply;\n+        return new JPackageCommand(this, true);\n+    }\n+\n+    JPackageCommand createMutableCopy() {\n+        return new JPackageCommand(this, false);\n@@ -319,1 +322,0 @@\n-        verifyMutable();\n@@ -325,1 +327,0 @@\n-        verifyMutable();\n@@ -487,1 +488,1 @@\n-        return getArgumentValue(UNPACKED_PATH_ARGNAME, () -> null, Path::of);\n+        return unpackedPackageDirectory;\n@@ -665,1 +666,1 @@\n-        return hasArgument(UNPACKED_PATH_ARGNAME);\n+        return unpackedPackageDirectory != null;\n@@ -794,5 +795,0 @@\n-    public JPackageCommand executeVerifyActions() {\n-        verifyActions.run();\n-        return this;\n-    }\n-\n@@ -823,0 +819,1 @@\n+        verifyMutable();\n@@ -862,1 +859,1 @@\n-        final var copy = new JPackageCommand(this).adjustArgumentsBeforeExecution();\n+        final var copy = createMutableCopy().adjustArgumentsBeforeExecution();\n@@ -879,1 +876,1 @@\n-            executeVerifyActions();\n+            verifyActions.run();\n@@ -887,1 +884,1 @@\n-        HelloApp.executeLauncherAndVerifyOutput(this);\n+        LauncherVerifier.executeMainLauncherAndVerifyOutput(this);\n@@ -1049,0 +1046,1 @@\n+        verifyMutable();\n@@ -1062,1 +1060,1 @@\n-        MAIN_LAUNCHER(cmd -> {\n+        NO_MAIN_LAUNCHER_IN_RUNTIME(cmd -> {\n@@ -1065,2 +1063,0 @@\n-            } else {\n-                TKit.assertExecutableFileExists(cmd.appLauncherPath());\n@@ -1069,1 +1065,1 @@\n-        MAIN_LAUNCHER_CFG_FILE(cmd -> {\n+        NO_MAIN_LAUNCHER_CFG_FILE_IN_RUNTIME(cmd -> {\n@@ -1072,2 +1068,5 @@\n-            } else {\n-                TKit.assertFileExists(cmd.appLauncherCfgPath(null));\n+            }\n+        }),\n+        MAIN_LAUNCHER_FILES(cmd -> {\n+            if (!cmd.isRuntime()) {\n+                new LauncherVerifier(cmd).verify(cmd, LauncherVerifier.Action.VERIFY_INSTALLED);\n@@ -1100,1 +1099,1 @@\n-            var copy = new JPackageCommand(cmd);\n+            var copy = cmd.createMutableCopy();\n@@ -1114,0 +1113,1 @@\n+        verifyMutable();\n@@ -1160,3 +1160,2 @@\n-            if (TKit.isOSX()) {\n-                final Path rootDir = isImagePackageType() ? outputBundle() :\n-                        pathToUnpackedPackageFile(appInstallationDirectory());\n+            final Path rootDir = isImagePackageType() ? outputBundle() :\n+                pathToUnpackedPackageFile(appInstallationDirectory());\n@@ -1164,1 +1163,1 @@\n-                AppImageFile aif = AppImageFile.load(rootDir);\n+            final AppImageFile aif = AppImageFile.load(rootDir);\n@@ -1166,0 +1165,1 @@\n+            if (TKit.isOSX()) {\n@@ -1176,0 +1176,5 @@\n+\n+            TKit.assertStringListEquals(\n+                    addLauncherNames().stream().sorted().toList(),\n+                    aif.addLaunchers().keySet().stream().sorted().toList(),\n+                    \"Check additional launcher names\");\n@@ -1257,0 +1262,1 @@\n+        verifyMutable();\n@@ -1258,5 +1264,1 @@\n-        if (path != null) {\n-            setArgumentValue(UNPACKED_PATH_ARGNAME, path);\n-        } else {\n-            removeArgumentWithValue(UNPACKED_PATH_ARGNAME);\n-        }\n+        unpackedPackageDirectory = path;\n@@ -1267,0 +1269,1 @@\n+        verifyMutable();\n@@ -1289,0 +1292,1 @@\n+        verifyMutable();\n@@ -1472,0 +1476,1 @@\n+    private Path unpackedPackageDirectory;\n@@ -1499,2 +1504,0 @@\n-    private static final String UNPACKED_PATH_ARGNAME = \"jpt-unpacked-folder\";\n-\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":38,"deletions":35,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -25,0 +25,7 @@\n+import static jdk.jpackage.internal.util.function.ThrowingBiConsumer.toBiConsumer;\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+import static jdk.jpackage.test.AdditionalLauncher.forEachAdditionalLauncher;\n+import static jdk.jpackage.test.PackageType.LINUX;\n+import static jdk.jpackage.test.PackageType.MAC_PKG;\n+import static jdk.jpackage.test.PackageType.WINDOWS;\n+\n@@ -30,0 +37,1 @@\n+import java.util.Collection;\n@@ -39,2 +47,0 @@\n-import jdk.jpackage.internal.util.function.ThrowingBiConsumer;\n-import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n@@ -42,3 +48,2 @@\n-import static jdk.jpackage.test.PackageType.LINUX;\n-import static jdk.jpackage.test.PackageType.MAC_PKG;\n-import static jdk.jpackage.test.PackageType.WINDOWS;\n+import jdk.jpackage.test.AdditionalLauncher.PropertyFile;\n+import jdk.jpackage.test.LauncherVerifier.Action;\n@@ -114,0 +119,1 @@\n+        pkg.addInstallVerifier(this::verifyLauncherExecuted);\n@@ -130,1 +136,0 @@\n-\n@@ -191,17 +196,5 @@\n-        AdditionalLauncher.forEachAdditionalLauncher(cmd,\n-                ThrowingBiConsumer.toBiConsumer(\n-                        (launcherName, propFilePath) -> {\n-                            if (Files.readAllLines(propFilePath).stream().anyMatch(\n-                                    line -> {\n-                                        if (line.startsWith(\n-                                                \"launcher-as-service=\")) {\n-                                            return Boolean.parseBoolean(\n-                                                    line.substring(\n-                                                            \"launcher-as-service=\".length()));\n-                                        } else {\n-                                            return false;\n-                                        }\n-                                    })) {\n-                                launcherNames.add(launcherName);\n-                            }\n-                        }));\n+        forEachAdditionalLauncher(cmd, toBiConsumer((launcherName, propFilePath) -> {\n+            if (new PropertyFile(propFilePath).findBooleanProperty(\"launcher-as-service\").orElse(false)) {\n+                launcherNames.add(launcherName);\n+            }\n+        }));\n@@ -240,15 +233,0 @@\n-        pkg.addInstallVerifier(cmd -> {\n-            if (canVerifyInstall(cmd)) {\n-                delayInstallVerify();\n-                Path outputFilePath = appOutputFilePathVerify(cmd);\n-                HelloApp.assertApp(cmd.appLauncherPath())\n-                        .addParam(\"jpackage.test.appOutput\",\n-                                outputFilePath.toString())\n-                        .addDefaultArguments(expectedValue)\n-                        .verifyOutput();\n-                deleteOutputFile(outputFilePath);\n-            }\n-        });\n-        pkg.addInstallVerifier(cmd -> {\n-            verify(cmd, launcherName);\n-        });\n@@ -258,13 +236,3 @@\n-        AdditionalLauncher al = new AdditionalLauncher(launcherName) {\n-            @Override\n-            protected void verify(JPackageCommand cmd) throws IOException {\n-                if (canVerifyInstall(cmd)) {\n-                    delayInstallVerify();\n-                    super.verify(cmd);\n-                    deleteOutputFile(appOutputFilePathVerify(cmd));\n-                }\n-                LauncherAsServiceVerifier.verify(cmd, launcherName);\n-            }\n-        }.setLauncherAsService()\n-                .addJavaOptions(\"-Djpackage.test.appOutput=\"\n-                        + appOutputFilePathInitialize().toString())\n+        var al = new AdditionalLauncher(launcherName)\n+                .setProperty(\"launcher-as-service\", true)\n+                .addJavaOptions(\"-Djpackage.test.appOutput=\" + appOutputFilePathInitialize().toString())\n@@ -272,1 +240,2 @@\n-                .addDefaultArguments(expectedValue);\n+                .addDefaultArguments(expectedValue)\n+                .withoutVerifyActions(Action.EXECUTE_LAUNCHER);\n@@ -279,0 +248,12 @@\n+    private void verifyLauncherExecuted(JPackageCommand cmd) throws IOException {\n+        if (canVerifyInstall(cmd)) {\n+            delayInstallVerify();\n+            Path outputFilePath = appOutputFilePathVerify(cmd);\n+            HelloApp.assertApp(cmd.appLauncherPath())\n+                    .addParam(\"jpackage.test.appOutput\", outputFilePath.toString())\n+                    .addDefaultArguments(expectedValue)\n+                    .verifyOutput();\n+            deleteOutputFile(outputFilePath);\n+        }\n+    }\n+\n@@ -294,2 +275,1 @@\n-    private static void verify(JPackageCommand cmd, String launcherName) throws\n-            IOException {\n+    private static void verify(JPackageCommand cmd, String launcherName) throws IOException {\n@@ -373,2 +353,5 @@\n-    static final Set<PackageType> SUPPORTED_PACKAGES = Stream.of(LINUX, WINDOWS,\n-            Set.of(MAC_PKG)).flatMap(x -> x.stream()).collect(Collectors.toSet());\n+    static final Set<PackageType> SUPPORTED_PACKAGES = Stream.of(\n+            LINUX,\n+            WINDOWS,\n+            Set.of(MAC_PKG)\n+    ).flatMap(Collection::stream).collect(Collectors.toSet());\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherAsServiceVerifier.java","additions":39,"deletions":56,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -49,0 +49,5 @@\n+    public LauncherIconVerifier verifyFileInAppImageOnly(boolean v) {\n+        verifyFileInAppImageOnly = true;\n+        return this;\n+    }\n+\n@@ -65,2 +70,3 @@\n-            WinExecutableIconVerifier.verifyLauncherIcon(cmd, launcherName,\n-                    expectedIcon, expectedDefault);\n+            if (!verifyFileInAppImageOnly) {\n+                WinExecutableIconVerifier.verifyLauncherIcon(cmd, launcherName, expectedIcon, expectedDefault);\n+            }\n@@ -73,4 +79,6 @@\n-            TKit.assertTrue(-1 == Files.mismatch(expectedIcon, iconPath),\n-                    String.format(\n-                    \"Check icon file [%s] of %s launcher is a copy of source icon file [%s]\",\n-                    iconPath, label, expectedIcon));\n+            if (!verifyFileInAppImageOnly) {\n+                TKit.assertTrue(-1 == Files.mismatch(expectedIcon, iconPath),\n+                        String.format(\n+                        \"Check icon file [%s] of %s launcher is a copy of source icon file [%s]\",\n+                        iconPath, label, expectedIcon));\n+            }\n@@ -83,0 +91,1 @@\n+    private boolean verifyFileInAppImageOnly;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherIconVerifier.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,175 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import static java.util.stream.Collectors.toMap;\n+import static jdk.jpackage.test.AdditionalLauncher.getAdditionalLauncherProperties;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+import jdk.jpackage.test.AdditionalLauncher.PropertyFile;\n+\n+public enum LauncherShortcut {\n+\n+    LINUX_SHORTCUT(\"linux-shortcut\"),\n+\n+    WIN_DESKTOP_SHORTCUT(\"win-shortcut\"),\n+\n+    WIN_START_MENU_SHORTCUT(\"win-menu\");\n+\n+    public enum StartupDirectory {\n+        DEFAULT(\"true\"),\n+        APP_DIR(\"app-dir\"),\n+        ;\n+\n+        StartupDirectory(String stringValue) {\n+            this.stringValue = Objects.requireNonNull(stringValue);\n+        }\n+\n+        public String asStringValue() {\n+            return stringValue;\n+        }\n+\n+        \/**\n+         * Returns shortcut startup directory or an empty {@link Optional} instance if\n+         * the value of the {@code str} parameter evaluates to {@code false}.\n+         *\n+         * @param str the value of a shortcut startup directory\n+         * @return shortcut startup directory or an empty {@link Optional} instance\n+         * @throws IllegalArgumentException if the value of the {@code str} parameter is\n+         *                                  unrecognized\n+         *\/\n+        static Optional<StartupDirectory> parse(String str) {\n+            Objects.requireNonNull(str);\n+            return Optional.ofNullable(VALUE_MAP.get(str)).or(() -> {\n+                if (Boolean.TRUE.toString().equals(str)) {\n+                    return Optional.of(StartupDirectory.DEFAULT);\n+                } else if (Boolean.FALSE.toString().equals(str)) {\n+                    return Optional.empty();\n+                } else {\n+                    throw new IllegalArgumentException(String.format(\n+                            \"Unrecognized launcher shortcut startup directory: [%s]\", str));\n+                }\n+            });\n+        }\n+\n+        private final String stringValue;\n+\n+        private static final Map<String, StartupDirectory> VALUE_MAP =\n+                Stream.of(values()).collect(toMap(StartupDirectory::asStringValue, x -> x));\n+    }\n+\n+    LauncherShortcut(String propertyName) {\n+        this.propertyName = Objects.requireNonNull(propertyName);\n+    }\n+\n+    public String propertyName() {\n+        return propertyName;\n+    }\n+\n+    public String appImageFilePropertyName() {\n+        return propertyName;\n+    }\n+\n+    public String optionName() {\n+        return \"--\" + propertyName;\n+    }\n+\n+    Optional<StartupDirectory> expectShortcut(JPackageCommand cmd, Optional<AppImageFile> predefinedAppImage, String launcherName) {\n+        Objects.requireNonNull(predefinedAppImage);\n+\n+        final var name = Optional.ofNullable(launcherName).orElseGet(cmd::name);\n+\n+        if (name.equals(cmd.name())) {\n+            return findMainLauncherShortcut(cmd);\n+        } else {\n+            String[] propertyName = new String[1];\n+            return findAddLauncherShortcut(cmd, predefinedAppImage.map(appImage -> {\n+                propertyName[0] = appImageFilePropertyName();\n+                return new PropertyFile(appImage.addLaunchers().get(launcherName));\n+            }).orElseGet(() -> {\n+                propertyName[0] = this.propertyName;\n+                return getAdditionalLauncherProperties(cmd, launcherName);\n+            })::findProperty, propertyName[0]);\n+        }\n+    }\n+\n+\n+    public interface InvokeShortcutSpec {\n+        String launcherName();\n+        LauncherShortcut shortcut();\n+        Optional<Path> expectedWorkDirectory();\n+        List<String> commandLine();\n+\n+        default Executor.Result execute() {\n+            return HelloApp.configureAndExecute(0, Executor.of(commandLine()).dumpOutput());\n+        }\n+\n+        record Stub(\n+                String launcherName,\n+                LauncherShortcut shortcut,\n+                Optional<Path> expectedWorkDirectory,\n+                List<String> commandLine) implements InvokeShortcutSpec {\n+\n+            public Stub {\n+                Objects.requireNonNull(launcherName);\n+                Objects.requireNonNull(shortcut);\n+                Objects.requireNonNull(expectedWorkDirectory);\n+                Objects.requireNonNull(commandLine);\n+            }\n+        }\n+    }\n+\n+\n+    private Optional<StartupDirectory> findMainLauncherShortcut(JPackageCommand cmd) {\n+        if (cmd.hasArgument(optionName())) {\n+            var value = Optional.ofNullable(cmd.getArgumentValue(optionName())).filter(optionValue -> {\n+                return !optionValue.startsWith(\"-\");\n+            });\n+            if (value.isPresent()) {\n+                return value.flatMap(StartupDirectory::parse);\n+            } else {\n+                return Optional.of(StartupDirectory.DEFAULT);\n+            }\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private Optional<StartupDirectory> findAddLauncherShortcut(JPackageCommand cmd,\n+            Function<String, Optional<String>> addlauncherProperties, String propertyName) {\n+        var explicit = addlauncherProperties.apply(propertyName);\n+        if (explicit.isPresent()) {\n+            return explicit.flatMap(StartupDirectory::parse);\n+        } else {\n+            return findMainLauncherShortcut(cmd);\n+        }\n+    }\n+\n+    private final String propertyName;\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherShortcut.java","additions":175,"deletions":0,"binary":false,"changes":175,"status":"added"},{"patch":"@@ -0,0 +1,370 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import static java.util.stream.Collectors.toMap;\n+import static jdk.jpackage.test.AdditionalLauncher.NO_ICON;\n+import static jdk.jpackage.test.LauncherShortcut.LINUX_SHORTCUT;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.BiConsumer;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.util.function.ThrowingBiConsumer;\n+import jdk.jpackage.test.AdditionalLauncher.PropertyFile;\n+import jdk.jpackage.test.LauncherShortcut.StartupDirectory;\n+\n+public final class LauncherVerifier {\n+\n+    LauncherVerifier(JPackageCommand cmd) {\n+        name = cmd.name();\n+        javaOptions = Optional.empty();\n+        arguments = Optional.empty();\n+        icon = Optional.empty();\n+        properties = Optional.empty();\n+    }\n+\n+    LauncherVerifier(String name,\n+            Optional<List<String>> javaOptions,\n+            Optional<List<String>> arguments,\n+            Optional<Path> icon,\n+            Map<String, String> properties) {\n+        this.name = Objects.requireNonNull(name);\n+        this.javaOptions = javaOptions.map(List::copyOf);\n+        this.arguments = arguments.map(List::copyOf);\n+        this.icon = icon;\n+        this.properties = Optional.of(new PropertyFile(properties));\n+    }\n+\n+    static void executeMainLauncherAndVerifyOutput(JPackageCommand cmd) {\n+        new LauncherVerifier(cmd).verify(cmd, Action.EXECUTE_LAUNCHER);\n+    }\n+\n+\n+    public enum Action {\n+        VERIFY_ICON(LauncherVerifier::verifyIcon),\n+        VERIFY_DESCRIPTION(LauncherVerifier::verifyDescription),\n+        VERIFY_INSTALLED((verifier, cmd) -> {\n+            verifier.verifyInstalled(cmd, true);\n+        }),\n+        VERIFY_UNINSTALLED((verifier, cmd) -> {\n+            verifier.verifyInstalled(cmd, false);\n+        }),\n+        VERIFY_APP_IMAGE_FILE((verifier, cmd) -> {\n+            if (cmd.isImagePackageType()) {\n+                verifier.verifyInAppImageFile(cmd);\n+            }\n+        }),\n+        EXECUTE_LAUNCHER(LauncherVerifier::executeLauncher),\n+        ;\n+\n+        Action(ThrowingBiConsumer<LauncherVerifier, JPackageCommand> action) {\n+            this.action = ThrowingBiConsumer.toBiConsumer(action);\n+        }\n+\n+        private void apply(LauncherVerifier verifier, JPackageCommand cmd) {\n+            action.accept(verifier, cmd);\n+        }\n+\n+        private final BiConsumer<LauncherVerifier, JPackageCommand> action;\n+\n+        static final List<Action> VERIFY_APP_IMAGE = List.of(\n+                VERIFY_ICON, VERIFY_DESCRIPTION, VERIFY_INSTALLED, VERIFY_APP_IMAGE_FILE\n+        );\n+\n+        static final List<Action> VERIFY_DEFAULTS = Stream.concat(\n+                VERIFY_APP_IMAGE.stream(), Stream.of(EXECUTE_LAUNCHER)\n+        ).toList();\n+    }\n+\n+\n+    void verify(JPackageCommand cmd, Action... actions) {\n+        verify(cmd, List.of(actions));\n+    }\n+\n+    void verify(JPackageCommand cmd, Iterable<Action> actions) {\n+        Objects.requireNonNull(cmd);\n+        for (var a : actions) {\n+            a.apply(this, cmd);\n+        }\n+    }\n+\n+    private boolean isMainLauncher() {\n+        return properties.isEmpty();\n+    }\n+\n+    private Optional<String> findProperty(String key) {\n+        return properties.flatMap(v -> {\n+            return v.findProperty(key);\n+        });\n+    }\n+\n+    private String getDescription(JPackageCommand cmd) {\n+        return findProperty(\"description\").orElseGet(() -> {\n+            return cmd.getArgumentValue(\"--description\", cmd::name);\n+        });\n+    }\n+\n+    private List<String> getArguments(JPackageCommand cmd) {\n+        return getStringArrayProperty(cmd, \"--arguments\", arguments);\n+    }\n+\n+    private List<String> getJavaOptions(JPackageCommand cmd) {\n+        return getStringArrayProperty(cmd, \"--java-options\", javaOptions);\n+    }\n+\n+    private List<String> getStringArrayProperty(JPackageCommand cmd, String optionName, Optional<List<String>> items) {\n+        Objects.requireNonNull(cmd);\n+        Objects.requireNonNull(optionName);\n+        Objects.requireNonNull(items);\n+        if (isMainLauncher()) {\n+            return List.of(cmd.getAllArgumentValues(optionName));\n+        } else {\n+            return items.orElseGet(() -> {\n+                return List.of(cmd.getAllArgumentValues(optionName));\n+            });\n+        }\n+    }\n+\n+    private boolean explicitlyNoShortcut(LauncherShortcut shortcut) {\n+        var explicit = findProperty(shortcut.propertyName());\n+        if (explicit.isPresent()) {\n+            return explicit.flatMap(StartupDirectory::parse).isEmpty();\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    private static boolean explicitShortcutForMainLauncher(JPackageCommand cmd, LauncherShortcut shortcut) {\n+        return cmd.hasArgument(shortcut.optionName());\n+    }\n+\n+    private void verifyIcon(JPackageCommand cmd) throws IOException {\n+        initIconVerifier(cmd).applyTo(cmd);\n+    }\n+\n+    private LauncherIconVerifier initIconVerifier(JPackageCommand cmd) {\n+        var verifier = new LauncherIconVerifier().setLauncherName(name);\n+\n+        var mainLauncherIcon = Optional.ofNullable(cmd.getArgumentValue(\"--icon\")).map(Path::of).or(() -> {\n+            return iconInResourceDir(cmd, cmd.name());\n+        });\n+\n+        if (TKit.isOSX()) {\n+            \/\/ There should be no icon files on Mac for additional launchers,\n+            \/\/ and always an icon file for the main launcher.\n+            if (isMainLauncher()) {\n+                mainLauncherIcon.ifPresentOrElse(verifier::setExpectedIcon, verifier::setExpectedDefaultIcon);\n+            }\n+            return verifier;\n+        }\n+\n+        if (isMainLauncher()) {\n+            mainLauncherIcon.ifPresentOrElse(verifier::setExpectedIcon, verifier::setExpectedDefaultIcon);\n+        } else {\n+            icon.ifPresentOrElse(icon -> {\n+                if (!NO_ICON.equals(icon)) {\n+                    verifier.setExpectedIcon(icon);\n+                }\n+            }, () -> {\n+                \/\/ No \"icon\" property in the property file\n+                iconInResourceDir(cmd, name).ifPresentOrElse(verifier::setExpectedIcon, () -> {\n+                    \/\/ No icon for this additional launcher in the resource directory.\n+                    mainLauncherIcon.ifPresentOrElse(verifier::setExpectedIcon, verifier::setExpectedDefaultIcon);\n+                });\n+            });\n+        }\n+\n+        return verifier;\n+    }\n+\n+    private static boolean withLinuxMainLauncherDesktopFile(JPackageCommand cmd) {\n+        if (!TKit.isLinux() || cmd.isImagePackageType()) {\n+            return false;\n+        }\n+\n+        return explicitShortcutForMainLauncher(cmd, LINUX_SHORTCUT)\n+                || cmd.hasArgument(\"--icon\")\n+                || cmd.hasArgument(\"--file-associations\")\n+                || iconInResourceDir(cmd, cmd.name()).isPresent();\n+    }\n+\n+    private boolean withLinuxDesktopFile(JPackageCommand cmd) {\n+        if (!TKit.isLinux() || cmd.isImagePackageType()) {\n+            return false;\n+        }\n+\n+        if (isMainLauncher()) {\n+            return withLinuxMainLauncherDesktopFile(cmd);\n+        } else if (explicitlyNoShortcut(LINUX_SHORTCUT) || icon.map(icon -> {\n+            return icon.equals(NO_ICON);\n+        }).orElse(false)) {\n+            return false;\n+        } else if (iconInResourceDir(cmd, name).isPresent() || icon.map(icon -> {\n+            return !icon.equals(NO_ICON);\n+        }).orElse(false)) {\n+            return true;\n+        } else if (findProperty(LINUX_SHORTCUT.propertyName()).flatMap(StartupDirectory::parse).isPresent()) {\n+            return true;\n+        } else {\n+            return withLinuxMainLauncherDesktopFile(cmd.createMutableCopy().removeArgument(\"--file-associations\"));\n+        }\n+    }\n+\n+    private void verifyDescription(JPackageCommand cmd) throws IOException {\n+        if (TKit.isWindows()) {\n+            String expectedDescription = getDescription(cmd);\n+            Path launcherPath = cmd.appLauncherPath(name);\n+            String actualDescription =\n+                    WindowsHelper.getExecutableDescription(launcherPath);\n+            TKit.assertEquals(expectedDescription, actualDescription,\n+                    String.format(\"Check file description of [%s]\", launcherPath));\n+        } else if (TKit.isLinux() && !cmd.isImagePackageType()) {\n+            String expectedDescription = getDescription(cmd);\n+            Path desktopFile = LinuxHelper.getDesktopFile(cmd, name);\n+            if (Files.exists(desktopFile)) {\n+                TKit.assertTextStream(\"Comment=\" + expectedDescription)\n+                        .label(String.format(\"[%s] file\", desktopFile))\n+                        .predicate(String::equals)\n+                        .apply(Files.readAllLines(desktopFile));\n+            }\n+        }\n+    }\n+\n+    private void verifyInstalled(JPackageCommand cmd, boolean installed) throws IOException {\n+        var launcherPath = cmd.appLauncherPath(name);\n+        var launcherCfgFilePath = cmd.appLauncherCfgPath(name);\n+        if (installed) {\n+            TKit.assertExecutableFileExists(launcherPath);\n+            TKit.assertFileExists(launcherCfgFilePath);\n+        } else {\n+            TKit.assertPathExists(launcherPath, false);\n+            TKit.assertPathExists(launcherCfgFilePath, false);\n+        }\n+\n+        if (TKit.isLinux() && !cmd.isImagePackageType()) {\n+            final var packageDesktopFile = LinuxHelper.getDesktopFile(cmd, name);\n+            final var withLinuxDesktopFile = withLinuxDesktopFile(cmd) && installed;\n+            if (withLinuxDesktopFile) {\n+                TKit.assertFileExists(packageDesktopFile);\n+            } else {\n+                TKit.assertPathExists(packageDesktopFile, false);\n+            }\n+        }\n+\n+        if (installed) {\n+            initIconVerifier(cmd).verifyFileInAppImageOnly(true).applyTo(cmd);\n+        }\n+    }\n+\n+    private void verifyInAppImageFile(JPackageCommand cmd) {\n+        cmd.verifyIsOfType(PackageType.IMAGE);\n+        if (!isMainLauncher()) {\n+            Stream<LauncherShortcut> shortcuts;\n+            if (TKit.isWindows()) {\n+                shortcuts = Stream.of(LauncherShortcut.WIN_DESKTOP_SHORTCUT, LauncherShortcut.WIN_START_MENU_SHORTCUT);\n+            } else if (TKit.isLinux()) {\n+                shortcuts = Stream.of(LauncherShortcut.LINUX_SHORTCUT);\n+            } else {\n+                shortcuts = Stream.of();\n+            }\n+\n+            var aif = AppImageFile.load(cmd.outputBundle());\n+            var aifFileName = AppImageFile.getPathInAppImage(Path.of(\"\")).getFileName();\n+\n+            var aifProps = Objects.requireNonNull(aif.addLaunchers().get(name));\n+\n+            shortcuts.forEach(shortcut -> {\n+                var recordedShortcut = aifProps.get(shortcut.appImageFilePropertyName());\n+                properties.flatMap(props -> {\n+                    return props.findProperty(shortcut.propertyName());\n+                }).ifPresentOrElse(expectedShortcut -> {\n+                    TKit.assertNotNull(recordedShortcut, String.format(\n+                            \"Check shortcut [%s] of launcher [%s] is recorded in %s file\",\n+                            shortcut, name, aifFileName));\n+                    TKit.assertEquals(\n+                            StartupDirectory.parse(expectedShortcut),\n+                            StartupDirectory.parse(recordedShortcut),\n+                            String.format(\"Check the value of shortcut [%s] of launcher [%s] recorded in %s file\",\n+                                    shortcut, name, aifFileName));\n+                }, () -> {\n+                    TKit.assertNull(recordedShortcut, String.format(\n+                            \"Check shortcut [%s] of launcher [%s] is NOT recorded in %s file\",\n+                            shortcut, name, aifFileName));\n+                });\n+            });\n+        }\n+    }\n+\n+    private void executeLauncher(JPackageCommand cmd) throws IOException {\n+        Path launcherPath = cmd.appLauncherPath(name);\n+\n+        if (!cmd.canRunLauncher(String.format(\"Not running [%s] launcher\", launcherPath))) {\n+            return;\n+        }\n+\n+        var appVerifier = HelloApp.assertApp(launcherPath)\n+                .addDefaultArguments(getArguments(cmd))\n+                .addJavaOptions(getJavaOptions(cmd).stream().map(str -> {\n+                    return resolveVariables(cmd, str);\n+                }).toList());\n+\n+        appVerifier.executeAndVerifyOutput();\n+    }\n+\n+    private static String resolveVariables(JPackageCommand cmd, String str) {\n+        var map = Stream.of(JPackageCommand.Macro.values()).collect(toMap(x -> {\n+            return String.format(\"$%s\", x.name());\n+        }, cmd::macroValue));\n+        for (var e : map.entrySet()) {\n+            str = str.replaceAll(Pattern.quote(e.getKey()),\n+                    Matcher.quoteReplacement(e.getValue().toString()));\n+        }\n+        return str;\n+    }\n+\n+    private static Optional<Path> iconInResourceDir(JPackageCommand cmd, String launcherName) {\n+        Objects.requireNonNull(launcherName);\n+        return Optional.ofNullable(cmd.getArgumentValue(\"--resource-dir\")).map(Path::of).map(resourceDir -> {\n+            Path icon = resourceDir.resolve(launcherName + TKit.ICON_SUFFIX);\n+            if (Files.exists(icon)) {\n+                return icon;\n+            } else {\n+                return null;\n+            }\n+        });\n+    }\n+\n+    private final String name;\n+    private final Optional<List<String>> javaOptions;\n+    private final Optional<List<String>> arguments;\n+    private final Optional<Path> icon;\n+    private final Optional<PropertyFile> properties;\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherVerifier.java","additions":370,"deletions":0,"binary":false,"changes":370,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+import java.io.UncheckedIOException;\n@@ -32,0 +33,1 @@\n+import java.util.Collection;\n@@ -36,0 +38,1 @@\n+import java.util.Objects;\n@@ -39,0 +42,1 @@\n+import java.util.function.Predicate;\n@@ -45,0 +49,1 @@\n+import jdk.jpackage.test.LauncherShortcut.InvokeShortcutSpec;\n@@ -311,2 +316,2 @@\n-        String packageName = LinuxHelper.getPackageName(cmd);\n-        long packageSize = LinuxHelper.getInstalledPackageSizeKB(cmd);\n+        String packageName = getPackageName(cmd);\n+        long packageSize = getInstalledPackageSizeKB(cmd);\n@@ -333,1 +338,1 @@\n-        List<String> prerequisites = LinuxHelper.getPrerequisitePackages(cmd);\n+        List<String> prerequisites = getPrerequisitePackages(cmd);\n@@ -343,1 +348,1 @@\n-                    \"Not cheking %s required packages of [%s] package\",\n+                    \"Not checking %s required packages of [%s] package\",\n@@ -348,2 +353,17 @@\n-    static void addBundleDesktopIntegrationVerifier(PackageTest test,\n-            boolean integrated) {\n+    public static Collection<? extends InvokeShortcutSpec> getInvokeShortcutSpecs(JPackageCommand cmd) {\n+        cmd.verifyIsOfType(PackageType.LINUX);\n+\n+        final var desktopFiles = getDesktopFiles(cmd);\n+        final var predefinedAppImage = Optional.ofNullable(cmd.getArgumentValue(\"--app-image\")).map(Path::of).map(AppImageFile::load);\n+\n+        return desktopFiles.stream().map(desktopFile -> {\n+            var systemDesktopFile = getSystemDesktopFilesFolder().resolve(desktopFile.getFileName());\n+            return new InvokeShortcutSpec.Stub(\n+                    launcherNameFromDesktopFile(cmd, predefinedAppImage, desktopFile),\n+                    LauncherShortcut.LINUX_SHORTCUT,\n+                    new DesktopFile(systemDesktopFile, false).findQuotedValue(\"Path\").map(Path::of),\n+                    List.of(\"gtk-launch\", PathUtils.replaceSuffix(systemDesktopFile.getFileName(), \"\").toString()));\n+        }).toList();\n+    }\n+\n+    static void addBundleDesktopIntegrationVerifier(PackageTest test, boolean integrated) {\n@@ -395,14 +415,5 @@\n-            \/\/ Verify .desktop files.\n-            try (var files = Files.list(cmd.appLayout().desktopIntegrationDirectory())) {\n-                List<Path> desktopFiles = files\n-                        .filter(path -> path.getFileName().toString().endsWith(\".desktop\"))\n-                        .toList();\n-                if (!integrated) {\n-                    TKit.assertStringListEquals(List.of(),\n-                            desktopFiles.stream().map(Path::toString).collect(\n-                                    Collectors.toList()),\n-                            \"Check there are no .desktop files in the package\");\n-                }\n-                for (var desktopFile : desktopFiles) {\n-                    verifyDesktopFile(cmd, desktopFile);\n-                }\n+            if (!integrated) {\n+                TKit.assertStringListEquals(\n+                        List.of(),\n+                        getDesktopFiles(cmd).stream().map(Path::toString).toList(),\n+                        \"Check there are no .desktop files in the package\");\n@@ -413,3 +424,8 @@\n-    private static void verifyDesktopFile(JPackageCommand cmd, Path desktopFile)\n-            throws IOException {\n-        TKit.trace(String.format(\"Check [%s] file BEGIN\", desktopFile));\n+    static void verifyDesktopFiles(JPackageCommand cmd, boolean installed) {\n+        final var desktopFiles = getDesktopFiles(cmd);\n+        try {\n+            if (installed) {\n+                var predefinedAppImage = Optional.ofNullable(cmd.getArgumentValue(\"--app-image\")).map(Path::of).map(AppImageFile::load);\n+                for (var desktopFile : desktopFiles) {\n+                    verifyDesktopFile(cmd, predefinedAppImage, desktopFile);\n+                }\n@@ -417,6 +433,18 @@\n-        var launcherName = Stream.of(List.of(cmd.name()), cmd.addLauncherNames()).flatMap(List::stream).filter(name -> {\n-            return getDesktopFile(cmd, name).equals(desktopFile);\n-        }).findAny();\n-        if (!cmd.hasArgument(\"--app-image\")) {\n-            TKit.assertTrue(launcherName.isPresent(),\n-                    \"Check the desktop file corresponds to one of app launchers\");\n+                if (!cmd.isPackageUnpacked(\"Not verifying system .desktop files\")) {\n+                    for (var desktopFile : desktopFiles) {\n+                        Path systemDesktopFile = getSystemDesktopFilesFolder().resolve(desktopFile.getFileName());\n+                            TKit.assertFileExists(systemDesktopFile);\n+                            TKit.assertStringListEquals(\n+                                    Files.readAllLines(desktopFile),\n+                                    Files.readAllLines(systemDesktopFile),\n+                                    String.format(\"Check [%s] and [%s] files are equal\", desktopFile, systemDesktopFile));\n+                    }\n+                }\n+            } else {\n+                for (var desktopFile : getDesktopFiles(cmd)) {\n+                    Path systemDesktopFile = getSystemDesktopFilesFolder().resolve(desktopFile.getFileName());\n+                    TKit.assertPathExists(systemDesktopFile, false);\n+                }\n+            }\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n@@ -424,0 +452,1 @@\n+    }\n@@ -425,2 +454,7 @@\n-        List<String> lines = Files.readAllLines(desktopFile);\n-        TKit.assertEquals(\"[Desktop Entry]\", lines.get(0), \"Check file header\");\n+    private static Collection<Path> getDesktopFiles(JPackageCommand cmd) {\n+        var unpackedDir = cmd.appLayout().desktopIntegrationDirectory();\n+        var packageDir = cmd.pathToPackageFile(unpackedDir);\n+        return getPackageFiles(cmd).filter(path -> {\n+            return packageDir.equals(path.getParent()) && path.getFileName().toString().endsWith(\".desktop\");\n+        }).map(Path::getFileName).map(unpackedDir::resolve).toList();\n+    }\n@@ -428,11 +462,14 @@\n-        Map<String, String> data = lines.stream()\n-        .skip(1)\n-        .peek(str -> TKit.assertTextStream(\"=\").predicate(String::contains).apply(List.of(str)))\n-        .map(str -> {\n-            String components[] = str.split(\"=(?=.+)\");\n-            if (components.length == 1) {\n-                return Map.entry(str.substring(0, str.length() - 1), \"\");\n-            }\n-            return Map.entry(components[0], components[1]);\n-        }).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (a, b) -> {\n-            TKit.assertUnexpected(\"Multiple values of the same key\");\n+    private static String launcherNameFromDesktopFile(JPackageCommand cmd, Optional<AppImageFile> predefinedAppImage, Path desktopFile) {\n+        Objects.requireNonNull(cmd);\n+        Objects.requireNonNull(predefinedAppImage);\n+        Objects.requireNonNull(desktopFile);\n+\n+        return predefinedAppImage.map(v -> {\n+            return v.launchers().keySet().stream();\n+        }).orElseGet(() -> {\n+            return Stream.concat(Stream.of(cmd.name()), cmd.addLauncherNames().stream());\n+        }).filter(name-> {\n+            return getDesktopFile(cmd, name).equals(desktopFile);\n+        }).findAny().orElseThrow(() -> {\n+            TKit.assertUnexpected(String.format(\"Failed to find launcher corresponding to [%s] file\", desktopFile));\n+            \/\/ Unreachable\n@@ -440,1 +477,13 @@\n-        }));\n+        });\n+    }\n+\n+    private static void verifyDesktopFile(JPackageCommand cmd, Optional<AppImageFile> predefinedAppImage, Path desktopFile) throws IOException {\n+        Objects.requireNonNull(cmd);\n+        Objects.requireNonNull(predefinedAppImage);\n+        Objects.requireNonNull(desktopFile);\n+\n+        TKit.trace(String.format(\"Check [%s] file BEGIN\", desktopFile));\n+\n+        var launcherName = launcherNameFromDesktopFile(cmd, predefinedAppImage, desktopFile);\n+\n+        var data = new DesktopFile(desktopFile, true);\n@@ -450,1 +499,1 @@\n-            TKit.assertEquals(e.getValue(), data.get(key), String.format(\n+            TKit.assertEquals(e.getValue(), data.find(key).orElseThrow(), String.format(\n@@ -454,8 +503,1 @@\n-        \/\/ Verify the value of `Exec` key is escaped if required\n-        String launcherPath = data.get(\"Exec\");\n-        if (Pattern.compile(\"\\\\s\").matcher(launcherPath).find()) {\n-            TKit.assertTrue(launcherPath.startsWith(\"\\\"\")\n-                    && launcherPath.endsWith(\"\\\"\"),\n-                    \"Check path to the launcher is enclosed in double quotes\");\n-            launcherPath = launcherPath.substring(1, launcherPath.length() - 1);\n-        }\n+        String launcherPath = data.findQuotedValue(\"Exec\").orElseThrow();\n@@ -463,7 +505,26 @@\n-        if (launcherName.isPresent()) {\n-            TKit.assertEquals(launcherPath, cmd.pathToPackageFile(\n-                    cmd.appLauncherPath(launcherName.get())).toString(),\n-                    String.format(\n-                            \"Check the value of [Exec] key references [%s] app launcher\",\n-                            launcherName.get()));\n-        }\n+        TKit.assertEquals(\n+                launcherPath,\n+                cmd.pathToPackageFile(cmd.appLauncherPath(launcherName)).toString(),\n+                String.format(\"Check the value of [Exec] key references [%s] app launcher\", launcherName));\n+\n+        var appLayout = cmd.appLayout();\n+\n+        LauncherShortcut.LINUX_SHORTCUT.expectShortcut(cmd, predefinedAppImage, launcherName).map(shortcutWorkDirType -> {\n+            switch (shortcutWorkDirType) {\n+                case DEFAULT -> {\n+                    return (Path)null;\n+                }\n+                case APP_DIR -> {\n+                    return cmd.pathToPackageFile(appLayout.appDirectory());\n+                }\n+                default -> {\n+                    throw new AssertionError();\n+                }\n+            }\n+        }).map(Path::toString).ifPresentOrElse(shortcutWorkDir -> {\n+            var actualShortcutWorkDir = data.find(\"Path\");\n+            TKit.assertTrue(actualShortcutWorkDir.isPresent(), \"Check [Path] key exists\");\n+            TKit.assertEquals(actualShortcutWorkDir.get(), shortcutWorkDir, \"Check the value of [Path] key\");\n+        }, () -> {\n+            TKit.assertTrue(data.find(\"Path\").isEmpty(), \"Check there is no [Path] key\");\n+        });\n@@ -474,2 +535,3 @@\n-            var path = e.getKey().getValue().or(() -> Optional.of(data.get(\n-                    e.getKey().getKey()))).map(Path::of).get();\n+            var path = e.getKey().getValue().or(() -> {\n+                return data.findQuotedValue(e.getKey().getKey());\n+            }).map(Path::of).get();\n@@ -477,1 +539,1 @@\n-            Path expectedDir = cmd.pathToPackageFile(e.getValue().apply(cmd.appLayout()));\n+            Path expectedDir = cmd.pathToPackageFile(e.getValue().apply(appLayout));\n@@ -764,0 +826,56 @@\n+\n+    private static final class DesktopFile {\n+        DesktopFile(Path path, boolean verify) {\n+            try {\n+                List<String> lines = Files.readAllLines(path);\n+                if (verify) {\n+                    TKit.assertEquals(\"[Desktop Entry]\", lines.getFirst(), \"Check file header\");\n+                }\n+\n+                var stream = lines.stream().skip(1).filter(Predicate.not(String::isEmpty));\n+                if (verify) {\n+                    stream = stream.peek(str -> {\n+                        TKit.assertTextStream(\"=\").predicate(String::contains).apply(List.of(str));\n+                    });\n+                }\n+\n+                data = stream.map(str -> {\n+                    String components[] = str.split(\"=(?=.+)\");\n+                    if (components.length == 1) {\n+                        return Map.entry(str.substring(0, str.length() - 1), \"\");\n+                    } else {\n+                        return Map.entry(components[0], components[1]);\n+                    }\n+                }).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+\n+        Set<String> keySet() {\n+            return data.keySet();\n+        }\n+\n+        Optional<String> find(String property) {\n+            return Optional.ofNullable(data.get(Objects.requireNonNull(property)));\n+        }\n+\n+        Optional<String> findQuotedValue(String property) {\n+            return find(property).map(value -> {\n+                if (Pattern.compile(\"\\\\s\").matcher(value).find()) {\n+                    boolean quotesMatched = value.startsWith(\"\\\"\") && value.endsWith(\"\\\"\");\n+                    if (!quotesMatched) {\n+                        TKit.assertTrue(quotesMatched,\n+                                String.format(\"Check the value of key [%s] is enclosed in double quotes\", property));\n+                    }\n+                    return value.substring(1, value.length() - 1);\n+                } else {\n+                    return value;\n+                }\n+            });\n+        }\n+\n+        private final Map<String, String> data;\n+    }\n+\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LinuxHelper.java","additions":180,"deletions":62,"binary":false,"changes":242,"status":"modified"},{"patch":"@@ -0,0 +1,377 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+\n+final class MsiDatabase {\n+\n+    static MsiDatabase load(Path msiFile, Path idtFileOutputDir, Set<Table> tableNames) {\n+        try {\n+            Files.createDirectories(idtFileOutputDir);\n+\n+            var orderedTableNames = tableNames.stream().sorted().toList();\n+\n+            Executor.of(\"cscript.exe\", \"\/\/Nologo\")\n+                    .addArgument(TKit.TEST_SRC_ROOT.resolve(\"resources\/msi-export.js\"))\n+                    .addArgument(msiFile)\n+                    .addArgument(idtFileOutputDir)\n+                    .addArguments(orderedTableNames.stream().map(Table::tableName).toList())\n+                    .dumpOutput()\n+                    .execute(0);\n+\n+            var tables = orderedTableNames.stream().map(tableName -> {\n+                return Map.entry(tableName, idtFileOutputDir.resolve(tableName + \".idt\"));\n+            }).filter(e -> {\n+                return Files.exists(e.getValue());\n+            }).collect(Collectors.toMap(Map.Entry::getKey, e -> {\n+                return MsiTable.loadFromTextArchiveFile(e.getValue());\n+            }));\n+\n+            return new MsiDatabase(tables);\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n+    }\n+\n+\n+    enum Table {\n+        COMPONENT(\"Component\"),\n+        DIRECTORY(\"Directory\"),\n+        FILE(\"File\"),\n+        PROPERTY(\"Property\"),\n+        SHORTCUT(\"Shortcut\"),\n+        ;\n+\n+        Table(String name) {\n+            this.tableName = Objects.requireNonNull(name);\n+        }\n+\n+        String tableName() {\n+            return tableName;\n+        }\n+\n+        private final String tableName;\n+\n+        static final Set<Table> FIND_PROPERTY_REQUIRED_TABLES = Set.of(PROPERTY);\n+        static final Set<Table> LIST_SHORTCUTS_REQUIRED_TABLES = Set.of(COMPONENT, DIRECTORY, FILE, SHORTCUT);\n+    }\n+\n+\n+    private MsiDatabase(Map<Table, MsiTable> tables) {\n+        this.tables = Map.copyOf(tables);\n+    }\n+\n+    Set<Table> tableNames() {\n+        return tables.keySet();\n+    }\n+\n+    MsiDatabase append(MsiDatabase other) {\n+        Map<Table, MsiTable> newTables = new HashMap<>(tables);\n+        newTables.putAll(other.tables);\n+        return new MsiDatabase(newTables);\n+    }\n+\n+    Optional<String> findProperty(String propertyName) {\n+        Objects.requireNonNull(propertyName);\n+        return tables.get(Table.PROPERTY).findRow(\"Property\", propertyName).map(row -> {\n+            return row.apply(\"Value\");\n+        });\n+    }\n+\n+    Collection<Shortcut> listShortcuts() {\n+        var shortcuts = tables.get(Table.SHORTCUT);\n+        if (shortcuts == null) {\n+            return List.of();\n+        }\n+        return IntStream.range(0, shortcuts.rowCount()).mapToObj(i -> {\n+            var row = shortcuts.row(i);\n+            var shortcutPath = directoryPath(row.apply(\"Directory_\")).resolve(fileNameFromFieldValue(row.apply(\"Name\")));\n+            var workDir = directoryPath(row.apply(\"WkDir\"));\n+            var shortcutTarget = Path.of(expandFormattedString(row.apply(\"Target\")));\n+            return new Shortcut(shortcutPath, shortcutTarget, workDir);\n+        }).toList();\n+    }\n+\n+    record Shortcut(Path path, Path target, Path workDir) {\n+\n+        Shortcut {\n+            Objects.requireNonNull(path);\n+            Objects.requireNonNull(target);\n+            Objects.requireNonNull(workDir);\n+        }\n+\n+        void assertEquals(Shortcut expected) {\n+            TKit.assertEquals(expected.path, path, \"Check the shortcut path\");\n+            TKit.assertEquals(expected.target, target, \"Check the shortcut target\");\n+            TKit.assertEquals(expected.workDir, workDir, \"Check the shortcut work directory\");\n+        }\n+    }\n+\n+    private Path directoryPath(String directoryId) {\n+        var table = tables.get(Table.DIRECTORY);\n+        Path result = null;\n+        for (var row = table.findRow(\"Directory\", directoryId);\n+                row.isPresent();\n+                directoryId = row.get().apply(\"Directory_Parent\"), row = table.findRow(\"Directory\", directoryId)) {\n+\n+            Path pathComponent;\n+            if (DIRECTORY_PROPERTIES.contains(directoryId)) {\n+                pathComponent = Path.of(directoryId);\n+                directoryId = null;\n+            } else {\n+                pathComponent = fileNameFromFieldValue(row.get().apply(\"DefaultDir\"));\n+            }\n+\n+            if (result != null) {\n+                result = pathComponent.resolve(result);\n+            } else {\n+                result = pathComponent;\n+            }\n+\n+            if (directoryId == null) {\n+                break;\n+            }\n+        }\n+\n+        return Objects.requireNonNull(result);\n+    }\n+\n+    private String expandFormattedString(String str) {\n+        return expandFormattedString(str, token -> {\n+            if (token.charAt(0) == '#') {\n+                var filekey = token.substring(1);\n+                var fileRow = tables.get(Table.FILE).findRow(\"File\", filekey).orElseThrow();\n+\n+                var component = fileRow.apply(\"Component_\");\n+                var componentRow = tables.get(Table.COMPONENT).findRow(\"Component\", component).orElseThrow();\n+\n+                var fileName = fileNameFromFieldValue(fileRow.apply(\"FileName\"));\n+                var filePath = directoryPath(componentRow.apply(\"Directory_\"));\n+\n+                return filePath.resolve(fileName).toString();\n+            } else {\n+                throw new UnsupportedOperationException(String.format(\n+                        \"Unrecognized token [%s] in formatted string [%s]\", token, str));\n+            }\n+        });\n+    }\n+\n+    private static Path fileNameFromFieldValue(String fieldValue) {\n+        var pipeIdx = fieldValue.indexOf('|');\n+        if (pipeIdx < 0) {\n+            return Path.of(fieldValue);\n+        } else {\n+            return Path.of(fieldValue.substring(pipeIdx + 1));\n+        }\n+    }\n+\n+    private static String expandFormattedString(String str, Function<String, String> callback) {\n+        \/\/ Naive implementation of https:\/\/learn.microsoft.com\/en-us\/windows\/win32\/msi\/formatted\n+        \/\/  - No recursive property expansion.\n+        \/\/  - No curly brakes ({}) handling.\n+\n+        Objects.requireNonNull(str);\n+        Objects.requireNonNull(callback);\n+        var sb = new StringBuffer();\n+        var m = FORMATTED_STRING_TOKEN.matcher(str);\n+        while (m.find()) {\n+            var token = m.group();\n+            token = token.substring(1, token.length() - 1);\n+            if (token.equals(\"~\")) {\n+                m.appendReplacement(sb, \"\\0\");\n+            } else {\n+                var replacement = Matcher.quoteReplacement(callback.apply(token));\n+                m.appendReplacement(sb, replacement);\n+            }\n+        }\n+        m.appendTail(sb);\n+        return sb.toString();\n+    }\n+\n+\n+    private record MsiTable(Map<String, List<String>> columns) {\n+\n+        MsiTable {\n+            Objects.requireNonNull(columns);\n+            if (columns.isEmpty()) {\n+                throw new IllegalArgumentException(\"Table should have columns\");\n+            }\n+        }\n+\n+        Optional<Function<String, String>> findRow(String columnName, String fieldValue) {\n+            Objects.requireNonNull(columnName);\n+            Objects.requireNonNull(fieldValue);\n+            var column = columns.get(columnName);\n+            for (int i = 0; i != column.size(); i++) {\n+                if (fieldValue.equals(column.get(i))) {\n+                    return Optional.of(row(i));\n+                }\n+            }\n+            return Optional.empty();\n+        }\n+\n+        \/**\n+         * Loads a table from a text archive file.\n+         * @param idtFile path to the input text archive file\n+         * @return the table\n+         *\/\n+        static MsiTable loadFromTextArchiveFile(Path idtFile) {\n+\n+            var header = IdtFileHeader.loadFromTextArchiveFile(idtFile);\n+\n+            Map<String, List<String>> columns = new HashMap<>();\n+            header.columns.forEach(column -> {\n+                columns.put(column, new ArrayList<>());\n+            });\n+\n+            try {\n+                var lines = Files.readAllLines(idtFile, header.charset()).toArray(String[]::new);\n+                for (int i = 3; i != lines.length; i++) {\n+                    var line = lines[i];\n+                    var row = line.split(\"\\t\", -1);\n+                    if (row.length != header.columns().size()) {\n+                        throw new IllegalArgumentException(String.format(\n+                                \"Expected %d columns. Actual is %d in line %d in [%s] file\",\n+                                header.columns().size(), row.length, i, idtFile));\n+                    }\n+                    for (int j = 0; j != row.length; j++) {\n+                        var field = row[j];\n+                        \/\/ https:\/\/learn.microsoft.com\/en-us\/windows\/win32\/msi\/archive-file-format\n+                        field = field.replace((char)21, (char)0);\n+                        field = field.replace((char)27, '\\b');\n+                        field = field.replace((char)16, '\\t');\n+                        field = field.replace((char)25, '\\n');\n+                        field = field.replace((char)24, '\\f');\n+                        field = field.replace((char)17, '\\r');\n+                        columns.get(header.columns.get(j)).add(field);\n+                    }\n+                }\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+\n+            return new MsiTable(columns);\n+        }\n+\n+        int columnCount() {\n+            return columns.size();\n+        }\n+\n+        int rowCount() {\n+            return columns.values().stream().findAny().orElseThrow().size();\n+        }\n+\n+        Function<String, String> row(int rowIndex) {\n+            return columnName -> {\n+                var column = Objects.requireNonNull(columns.get(Objects.requireNonNull(columnName)));\n+                return column.get(rowIndex);\n+            };\n+        }\n+    }\n+\n+\n+    private record IdtFileHeader(Charset charset, List<String> columns) {\n+\n+        IdtFileHeader {\n+            Objects.requireNonNull(charset);\n+            columns.forEach(Objects::requireNonNull);\n+            if (columns.isEmpty()) {\n+                throw new IllegalArgumentException(\"Table should have columns\");\n+            }\n+        }\n+\n+        \/**\n+         * Loads a table header from a text archive (.idt) file.\n+         * @see <a href=\"https:\/\/learn.microsoft.com\/en-us\/windows\/win32\/msi\/archive-file-format\">https:\/\/learn.microsoft.com\/en-us\/windows\/win32\/msi\/archive-file-format<\/a>\n+         * @see <a href=\"https:\/\/learn.microsoft.com\/en-us\/windows\/win32\/msi\/ascii-data-in-text-archive-files\">https:\/\/learn.microsoft.com\/en-us\/windows\/win32\/msi\/ascii-data-in-text-archive-files<\/a>\n+         * @param path path to the input text archive file\n+         * @return the table header\n+         *\/\n+        static IdtFileHeader loadFromTextArchiveFile(Path idtFile) {\n+            var charset = StandardCharsets.US_ASCII;\n+            try (var stream = Files.lines(idtFile, charset)) {\n+                var headerLines = stream.limit(3).toList();\n+                if (headerLines.size() != 3) {\n+                    throw new IllegalArgumentException(String.format(\n+                            \"[%s] file should have at least three text lines\", idtFile));\n+                }\n+\n+                var columns = headerLines.get(0).split(\"\\t\");\n+\n+                var header = headerLines.get(2).split(\"\\t\", 4);\n+                if (header.length == 3) {\n+                    if (Pattern.matches(\"^[1-9]\\\\d+$\", header[0])) {\n+                        charset = Charset.forName(header[0]);\n+                    } else {\n+                        throw new IllegalArgumentException(String.format(\n+                                \"Unexpected charset name [%s] in [%s] file\", header[0], idtFile));\n+                    }\n+                } else if (header.length != 2) {\n+                    throw new IllegalArgumentException(String.format(\n+                            \"Unexpected number of fields (%d) in the 3rd line of [%s] file\",\n+                            header.length, idtFile));\n+                }\n+\n+                return new IdtFileHeader(charset, List.of(columns));\n+\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+    }\n+\n+\n+    private final Map<Table, MsiTable> tables;\n+\n+    \/\/ https:\/\/learn.microsoft.com\/en-us\/windows\/win32\/msi\/formatted\n+    private static final Pattern FORMATTED_STRING_TOKEN = Pattern.compile(\"\\\\[[^\\\\]]+\\\\]\");\n+\n+    \/\/ https:\/\/learn.microsoft.com\/en-us\/windows\/win32\/msi\/property-reference#system-folder-properties\n+    private final Set<String> DIRECTORY_PROPERTIES = Set.of(\n+            \"DesktopFolder\",\n+            \"LocalAppDataFolder\",\n+            \"ProgramFiles64Folder\",\n+            \"ProgramMenuFolder\"\n+    );\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MsiDatabase.java","additions":377,"deletions":0,"binary":false,"changes":377,"status":"added"},{"patch":"@@ -33,0 +33,1 @@\n+import static jdk.jpackage.test.PackageType.WIN_MSI;\n@@ -38,0 +39,1 @@\n+import java.time.Duration;\n@@ -273,2 +275,1 @@\n-        \/\/ Setup test app to have valid jpackage command line before\n-        \/\/ running check of type of environment.\n+        \/\/ Setup test app to have valid jpackage command line before running the check.\n@@ -299,1 +300,1 @@\n-                TKit.waitForFileCreated(appOutput, 7);\n+                TKit.waitForFileCreated(appOutput, Duration.ofSeconds(7), Duration.ofSeconds(3));\n@@ -301,5 +302,1 @@\n-                \/\/ Wait a little bit after file has been created to\n-                \/\/ make sure there are no pending writes into it.\n-                Thread.sleep(3000);\n-                HelloApp.verifyOutputFile(appOutput, expectedArgs,\n-                        Collections.emptyMap());\n+                HelloApp.verifyOutputFile(appOutput, expectedArgs, Map.of());\n@@ -363,1 +360,1 @@\n-        addInstallVerifier(HelloApp::executeLauncherAndVerifyOutput);\n+        addInstallVerifier(LauncherVerifier::executeMainLauncherAndVerifyOutput);\n@@ -368,4 +365,3 @@\n-        addInitializer(\n-                cmd -> new HelloApp(JavaAppDesc.parse(javaAppDesc)).addTo(cmd),\n-                \"HelloApp\");\n-        return this;\n+        return addInitializer(cmd -> {\n+            new HelloApp(JavaAppDesc.parse(javaAppDesc)).addTo(cmd);\n+        }, \"HelloApp\");\n@@ -614,5 +610,1 @@\n-                    if (unpackNotSupported()) {\n-                        return ActionAction.SKIP;\n-                    }\n-\n-                    if (installFailed()) {\n+                    if (unpackNotSupported() || installFailed()) {\n@@ -756,0 +748,2 @@\n+                } else if (isOfType(cmd, WIN_MSI)) {\n+                    WinShortcutVerifier.verifyBundleShortcuts(cmd);\n@@ -777,6 +771,5 @@\n-                    \/\/ Check main launcher\n-                    WindowsHelper.verifyDesktopIntegration(cmd, null);\n-                    \/\/ Check additional launchers\n-                    cmd.addLauncherNames().forEach(name -> {\n-                        WindowsHelper.verifyDesktopIntegration(cmd, name);\n-                    });\n+                    WindowsHelper.verifyDeployedDesktopIntegration(cmd, true);\n+                }\n+\n+                if (isOfType(cmd, LINUX)) {\n+                    LinuxHelper.verifyDesktopFiles(cmd, true);\n@@ -859,6 +852,5 @@\n-                    \/\/ Check main launcher\n-                    WindowsHelper.verifyDesktopIntegration(cmd, null);\n-                    \/\/ Check additional launchers\n-                    cmd.addLauncherNames().forEach(name -> {\n-                        WindowsHelper.verifyDesktopIntegration(cmd, name);\n-                    });\n+                    WindowsHelper.verifyDeployedDesktopIntegration(cmd, false);\n+                }\n+\n+                if (isOfType(cmd, LINUX)) {\n+                    LinuxHelper.verifyDesktopFiles(cmd, false);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/PackageTest.java","additions":22,"deletions":30,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+import java.time.Duration;\n+import java.time.Instant;\n@@ -600,2 +602,8 @@\n-    static void waitForFileCreated(Path fileToWaitFor,\n-            long timeoutSeconds) throws IOException {\n+    public static void waitForFileCreated(Path fileToWaitFor,\n+            Duration timeout, Duration afterCreatedTimeout) throws IOException {\n+        waitForFileCreated(fileToWaitFor, timeout);\n+        \/\/ Wait after the file has been created to ensure it is fully written.\n+        ThrowingConsumer.<Duration>toConsumer(Thread::sleep).accept(afterCreatedTimeout);\n+    }\n+\n+    private static void waitForFileCreated(Path fileToWaitFor, Duration timeout) throws IOException {\n@@ -611,1 +619,1 @@\n-        long waitUntil = System.currentTimeMillis() + timeoutSeconds * 1000;\n+        var waitUntil = Instant.now().plus(timeout);\n@@ -613,3 +621,3 @@\n-            long timeout = waitUntil - System.currentTimeMillis();\n-            assertTrue(timeout > 0, String.format(\n-                    \"Check timeout value %d is positive\", timeout));\n+            var remainderTimeout = Instant.now().until(waitUntil);\n+            assertTrue(remainderTimeout.isPositive(), String.format(\n+                    \"Check timeout value %dms is positive\", remainderTimeout.toMillis()));\n@@ -617,2 +625,3 @@\n-            WatchKey key = ThrowingSupplier.toSupplier(() -> ws.poll(timeout,\n-                    TimeUnit.MILLISECONDS)).get();\n+            WatchKey key = ThrowingSupplier.toSupplier(() -> {\n+                return ws.poll(remainderTimeout.toMillis(), TimeUnit.MILLISECONDS);\n+            }).get();\n@@ -620,1 +629,1 @@\n-                if (fileToWaitFor.toFile().exists()) {\n+                if (Files.exists(fileToWaitFor)) {\n@@ -626,1 +635,1 @@\n-                assertUnexpected(String.format(\"Timeout expired\", timeout));\n+                assertUnexpected(String.format(\"Timeout %dms expired\", remainderTimeout.toMillis()));\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TKit.java","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,293 @@\n+\/*\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static jdk.jpackage.test.LauncherShortcut.WIN_DESKTOP_SHORTCUT;\n+import static jdk.jpackage.test.LauncherShortcut.WIN_START_MENU_SHORTCUT;\n+import static jdk.jpackage.test.WindowsHelper.getInstallationSubDirectory;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.util.PathUtils;\n+import jdk.jpackage.test.LauncherShortcut.InvokeShortcutSpec;\n+import jdk.jpackage.test.LauncherShortcut.StartupDirectory;\n+import jdk.jpackage.test.MsiDatabase.Shortcut;\n+import jdk.jpackage.test.WindowsHelper.SpecialFolder;\n+\n+\n+public final class WinShortcutVerifier {\n+\n+    static void verifyBundleShortcuts(JPackageCommand cmd) {\n+        cmd.verifyIsOfType(PackageType.WIN_MSI);\n+\n+        if (Stream.of(\"--win-menu\", \"--win-shortcut\").noneMatch(cmd::hasArgument) && cmd.addLauncherNames().isEmpty()) {\n+            return;\n+        }\n+\n+        var actualShortcuts = WindowsHelper.getMsiShortcuts(cmd).stream().collect(groupingBy(shortcut -> {\n+            return PathUtils.replaceSuffix(shortcut.target().getFileName(), \"\").toString();\n+        }));\n+\n+        var expectedShortcuts = expectShortcuts(cmd);\n+\n+        var launcherNames = expectedShortcuts.keySet().stream().sorted().toList();\n+\n+        TKit.assertStringListEquals(\n+                launcherNames,\n+                actualShortcuts.keySet().stream().sorted().toList(),\n+                \"Check the list of launchers with shortcuts\");\n+\n+        Function<Collection<Shortcut>, List<Shortcut>> sorter = shortcuts -> {\n+            return shortcuts.stream().sorted(SHORTCUT_COMPARATOR).toList();\n+        };\n+\n+        for (var name : launcherNames) {\n+            var actualLauncherShortcuts = sorter.apply(actualShortcuts.get(name));\n+            var expectedLauncherShortcuts = sorter.apply(expectedShortcuts.get(name));\n+\n+            TKit.assertEquals(expectedLauncherShortcuts.size(), actualLauncherShortcuts.size(),\n+                    String.format(\"Check the number of shortcuts of launcher [%s]\", name));\n+\n+            for (int i = 0; i != expectedLauncherShortcuts.size(); i++) {\n+                TKit.trace(String.format(\"Verify shortcut #%d of launcher [%s]\", i + 1, name));\n+                actualLauncherShortcuts.get(i).assertEquals(expectedLauncherShortcuts.get(i));\n+                TKit.trace(\"Done\");\n+            }\n+        }\n+    }\n+\n+    static void verifyDeployedShortcuts(JPackageCommand cmd, boolean installed) {\n+        cmd.verifyIsOfType(PackageType.WINDOWS);\n+\n+        verifyDeployedShortcutsInternal(cmd, installed);\n+        var copyCmd = cmd.createMutableCopy();\n+        if (copyCmd.hasArgument(\"--win-per-user-install\")) {\n+            copyCmd.removeArgument(\"--win-per-user-install\");\n+        } else {\n+            copyCmd.addArgument(\"--win-per-user-install\");\n+        }\n+        verifyDeployedShortcutsInternal(copyCmd, false);\n+    }\n+\n+    public static Collection<? extends InvokeShortcutSpec> getInvokeShortcutSpecs(JPackageCommand cmd) {\n+        return expectShortcuts(cmd).entrySet().stream().map(e -> {\n+            return e.getValue().stream().map(shortcut -> {\n+                return convert(cmd, e.getKey(), shortcut);\n+            });\n+        }).flatMap(x -> x).toList();\n+    }\n+\n+    private static void verifyDeployedShortcutsInternal(JPackageCommand cmd, boolean installed) {\n+\n+        var expectedShortcuts = expectShortcuts(cmd).values().stream().flatMap(Collection::stream).toList();\n+\n+        var isUserLocalInstall = WindowsHelper.isUserLocalInstall(cmd);\n+\n+        expectedShortcuts.stream().map(Shortcut::path).sorted().map(path -> {\n+            return resolvePath(path, !isUserLocalInstall);\n+        }).map(path -> {\n+            return PathUtils.addSuffix(path, \".lnk\");\n+        }).forEach(path -> {\n+            if (installed) {\n+                TKit.assertFileExists(path);\n+            } else {\n+                TKit.assertPathExists(path, false);\n+            }\n+        });\n+\n+        if (!installed) {\n+            expectedShortcuts.stream().map(Shortcut::path).filter(path -> {\n+                return Stream.of(ShortcutType.COMMON_START_MENU, ShortcutType.USER_START_MENU).anyMatch(type -> {\n+                    return path.startsWith(Path.of(type.rootFolder().getMsiPropertyName()));\n+                });\n+            }).map(Path::getParent).distinct().map(unresolvedShortcutDir -> {\n+                return resolvePath(unresolvedShortcutDir, !isUserLocalInstall);\n+            }).forEach(shortcutDir -> {\n+                if (Files.isDirectory(shortcutDir)) {\n+                    TKit.assertDirectoryNotEmpty(shortcutDir);\n+                } else {\n+                    TKit.assertPathExists(shortcutDir, false);\n+                }\n+            });\n+        }\n+    }\n+\n+    private enum ShortcutType {\n+        COMMON_START_MENU(SpecialFolder.COMMON_START_MENU_PROGRAMS),\n+        USER_START_MENU(SpecialFolder.USER_START_MENU_PROGRAMS),\n+        COMMON_DESKTOP(SpecialFolder.COMMON_DESKTOP),\n+        USER_DESKTOP(SpecialFolder.USER_DESKTOP),\n+        ;\n+\n+        ShortcutType(SpecialFolder rootFolder) {\n+            this.rootFolder = Objects.requireNonNull(rootFolder);\n+        }\n+\n+        SpecialFolder rootFolder() {\n+            return rootFolder;\n+        }\n+\n+        private final SpecialFolder rootFolder;\n+    }\n+\n+    private static Path resolvePath(Path path, boolean allUsers) {\n+        var root = path.getName(0);\n+        var resolvedRoot = SpecialFolder.findMsiProperty(root.toString(), allUsers).orElseThrow().getPath();\n+        return resolvedRoot.resolve(root.relativize(path));\n+    }\n+\n+    private static Shortcut createLauncherShortcutSpec(JPackageCommand cmd, String launcherName,\n+            SpecialFolder installRoot, Path workDir, ShortcutType type) {\n+\n+        var name = Optional.ofNullable(launcherName).orElseGet(cmd::name);\n+\n+        var appLayout = ApplicationLayout.windowsAppImage().resolveAt(\n+                Path.of(installRoot.getMsiPropertyName()).resolve(getInstallationSubDirectory(cmd)));\n+\n+        Path path;\n+        switch (type) {\n+            case COMMON_START_MENU, USER_START_MENU -> {\n+                path = Path.of(cmd.getArgumentValue(\"--win-menu-group\", () -> \"Unknown\"), name);\n+            }\n+            default -> {\n+                path = Path.of(name);\n+            }\n+        }\n+\n+        return new Shortcut(\n+                Path.of(type.rootFolder().getMsiPropertyName()).resolve(path),\n+                appLayout.launchersDirectory().resolve(name + \".exe\"),\n+                workDir);\n+    }\n+\n+    private static Collection<Shortcut> expectLauncherShortcuts(JPackageCommand cmd,\n+            Optional<AppImageFile> predefinedAppImage, String launcherName) {\n+        Objects.requireNonNull(cmd);\n+        Objects.requireNonNull(predefinedAppImage);\n+\n+        final List<Shortcut> shortcuts = new ArrayList<>();\n+\n+        final var winMenu = WIN_START_MENU_SHORTCUT.expectShortcut(cmd, predefinedAppImage, launcherName);\n+        final var desktop = WIN_DESKTOP_SHORTCUT.expectShortcut(cmd, predefinedAppImage, launcherName);\n+\n+        final var isUserLocalInstall = WindowsHelper.isUserLocalInstall(cmd);\n+\n+        final SpecialFolder installRoot;\n+        if (isUserLocalInstall) {\n+            installRoot = SpecialFolder.LOCAL_APPLICATION_DATA;\n+        } else {\n+            installRoot = SpecialFolder.PROGRAM_FILES;\n+        }\n+\n+        final var installDir = Path.of(installRoot.getMsiPropertyName()).resolve(getInstallationSubDirectory(cmd));\n+\n+        final Function<StartupDirectory, Path> workDir = startupDirectory -> {\n+            switch (startupDirectory) {\n+                case DEFAULT -> {\n+                    return installDir;\n+                }\n+                case APP_DIR -> {\n+                    return ApplicationLayout.windowsAppImage().resolveAt(installDir).appDirectory();\n+                }\n+                default -> {\n+                    throw new IllegalArgumentException();\n+                }\n+            }\n+        };\n+\n+        if (winMenu.isPresent()) {\n+            ShortcutType type;\n+            if (isUserLocalInstall) {\n+                type = ShortcutType.USER_START_MENU;\n+            } else {\n+                type = ShortcutType.COMMON_START_MENU;\n+            }\n+            shortcuts.add(createLauncherShortcutSpec(cmd, launcherName, installRoot, winMenu.map(workDir).orElseThrow(), type));\n+        }\n+\n+        if (desktop.isPresent()) {\n+            ShortcutType type;\n+            if (isUserLocalInstall) {\n+                type = ShortcutType.USER_DESKTOP;\n+            } else {\n+                type = ShortcutType.COMMON_DESKTOP;\n+            }\n+            shortcuts.add(createLauncherShortcutSpec(cmd, launcherName, installRoot, desktop.map(workDir).orElseThrow(), type));\n+        }\n+\n+        return shortcuts;\n+    }\n+\n+    private static Map<String, Collection<Shortcut>> expectShortcuts(JPackageCommand cmd) {\n+        Map<String, Collection<Shortcut>> expectedShortcuts = new HashMap<>();\n+\n+        var predefinedAppImage = Optional.ofNullable(cmd.getArgumentValue(\"--app-image\")).map(Path::of).map(AppImageFile::load);\n+\n+        predefinedAppImage.map(v -> {\n+            return v.launchers().keySet().stream();\n+        }).orElseGet(() -> {\n+            return Stream.concat(Stream.of(cmd.name()), cmd.addLauncherNames().stream());\n+        }).forEach(launcherName -> {\n+            var shortcuts = expectLauncherShortcuts(cmd, predefinedAppImage, launcherName);\n+            if (!shortcuts.isEmpty()) {\n+                expectedShortcuts.put(launcherName, shortcuts);\n+            }\n+        });\n+\n+        return expectedShortcuts;\n+    }\n+\n+    private static InvokeShortcutSpec convert(JPackageCommand cmd, String launcherName, Shortcut shortcut) {\n+        LauncherShortcut launcherShortcut;\n+        if (Stream.of(ShortcutType.COMMON_START_MENU, ShortcutType.USER_START_MENU).anyMatch(type -> {\n+            return shortcut.path().startsWith(Path.of(type.rootFolder().getMsiPropertyName()));\n+        })) {\n+            launcherShortcut = WIN_START_MENU_SHORTCUT;\n+        } else {\n+            launcherShortcut = WIN_DESKTOP_SHORTCUT;\n+        }\n+\n+        var isUserLocalInstall = WindowsHelper.isUserLocalInstall(cmd);\n+        return new InvokeShortcutSpec.Stub(\n+                launcherName,\n+                launcherShortcut,\n+                Optional.of(resolvePath(shortcut.workDir(), !isUserLocalInstall)),\n+                List.of(\"cmd\", \"\/c\", \"start\", \"\/wait\", PathUtils.addSuffix(resolvePath(shortcut.path(), !isUserLocalInstall), \".lnk\").toString()));\n+    }\n+\n+\n+    private static final Comparator<Shortcut> SHORTCUT_COMPARATOR = Comparator.comparing(Shortcut::target)\n+            .thenComparing(Comparator.comparing(Shortcut::path))\n+            .thenComparing(Comparator.comparing(Shortcut::workDir));\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/WinShortcutVerifier.java","additions":293,"deletions":0,"binary":false,"changes":293,"status":"added"},{"patch":"@@ -29,0 +29,2 @@\n+import java.io.UncheckedIOException;\n+import java.lang.ref.SoftReference;\n@@ -32,0 +34,3 @@\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.HashMap;\n@@ -37,0 +42,1 @@\n+import java.util.Properties;\n@@ -41,1 +47,0 @@\n-import java.util.stream.Collectors;\n@@ -66,1 +71,1 @@\n-    private static Path getInstallationSubDirectory(JPackageCommand cmd) {\n+    static Path getInstallationSubDirectory(JPackageCommand cmd) {\n@@ -266,3 +271,3 @@\n-    static void verifyDesktopIntegration(JPackageCommand cmd,\n-            String launcherName) {\n-        new DesktopIntegrationVerifier(cmd, launcherName);\n+    static void verifyDeployedDesktopIntegration(JPackageCommand cmd, boolean installed) {\n+        WinShortcutVerifier.verifyDeployedShortcuts(cmd, installed);\n+        DesktopIntegrationVerifier.verify(cmd, installed);\n@@ -273,6 +278,1 @@\n-        return Executor.of(\"cscript.exe\", \"\/\/Nologo\")\n-        .addArgument(TKit.TEST_SRC_ROOT.resolve(\"resources\/query-msi-property.js\"))\n-        .addArgument(cmd.outputBundle())\n-        .addArgument(propertyName)\n-        .dumpOutput()\n-        .executeAndGetOutput().stream().collect(Collectors.joining(\"\\n\"));\n+        return MsiDatabaseCache.INSTANCE.findProperty(cmd.outputBundle(), propertyName).orElseThrow();\n@@ -281,1 +281,6 @@\n-    public static String getExecutableDesciption(Path pathToExeFile) {\n+    static Collection<MsiDatabase.Shortcut> getMsiShortcuts(JPackageCommand cmd) {\n+        cmd.verifyIsOfType(PackageType.WIN_MSI);\n+        return MsiDatabaseCache.INSTANCE.listShortcuts(cmd.outputBundle());\n+    }\n+\n+    public static String getExecutableDescription(Path pathToExeFile) {\n@@ -389,1 +394,1 @@\n-    private static boolean isUserLocalInstall(JPackageCommand cmd) {\n+    static boolean isUserLocalInstall(JPackageCommand cmd) {\n@@ -397,0 +402,1 @@\n+\n@@ -399,1 +405,1 @@\n-        DesktopIntegrationVerifier(JPackageCommand cmd, String launcherName) {\n+        static void verify(JPackageCommand cmd, boolean installed) {\n@@ -401,90 +407,2 @@\n-\n-            name = Optional.ofNullable(launcherName).orElseGet(cmd::name);\n-\n-            isUserLocalInstall = isUserLocalInstall(cmd);\n-\n-            appInstalled = cmd.appLauncherPath(launcherName).toFile().exists();\n-\n-            desktopShortcutPath = Path.of(name + \".lnk\");\n-\n-            startMenuShortcutPath = Path.of(cmd.getArgumentValue(\n-                    \"--win-menu-group\", () -> \"Unknown\"), name + \".lnk\");\n-\n-            if (name.equals(cmd.name())) {\n-                isWinMenu = cmd.hasArgument(\"--win-menu\");\n-                isDesktop = cmd.hasArgument(\"--win-shortcut\");\n-            } else {\n-                var props = AdditionalLauncher.getAdditionalLauncherProperties(cmd,\n-                        launcherName);\n-                isWinMenu = props.getPropertyBooleanValue(\"win-menu\").orElseGet(\n-                        () -> cmd.hasArgument(\"--win-menu\"));\n-                isDesktop = props.getPropertyBooleanValue(\"win-shortcut\").orElseGet(\n-                        () -> cmd.hasArgument(\"--win-shortcut\"));\n-            }\n-\n-            verifyStartMenuShortcut();\n-\n-            verifyDesktopShortcut();\n-\n-            Stream.of(cmd.getAllArgumentValues(\"--file-associations\")).map(\n-                    Path::of).forEach(this::verifyFileAssociationsRegistry);\n-        }\n-\n-        private void verifyDesktopShortcut() {\n-            if (isDesktop) {\n-                if (isUserLocalInstall) {\n-                    verifyUserLocalDesktopShortcut(appInstalled);\n-                    verifySystemDesktopShortcut(false);\n-                } else {\n-                    verifySystemDesktopShortcut(appInstalled);\n-                    verifyUserLocalDesktopShortcut(false);\n-                }\n-            } else {\n-                verifySystemDesktopShortcut(false);\n-                verifyUserLocalDesktopShortcut(false);\n-            }\n-        }\n-\n-        private void verifyShortcut(Path path, boolean exists) {\n-            if (exists) {\n-                TKit.assertFileExists(path);\n-            } else {\n-                TKit.assertPathExists(path, false);\n-            }\n-        }\n-\n-        private void verifySystemDesktopShortcut(boolean exists) {\n-            Path dir = SpecialFolder.COMMON_DESKTOP.getPath();\n-            verifyShortcut(dir.resolve(desktopShortcutPath), exists);\n-        }\n-\n-        private void verifyUserLocalDesktopShortcut(boolean exists) {\n-            Path dir = SpecialFolder.USER_DESKTOP.getPath();\n-            verifyShortcut(dir.resolve(desktopShortcutPath), exists);\n-        }\n-\n-        private void verifyStartMenuShortcut() {\n-            if (isWinMenu) {\n-                if (isUserLocalInstall) {\n-                    verifyUserLocalStartMenuShortcut(appInstalled);\n-                    verifySystemStartMenuShortcut(false);\n-                } else {\n-                    verifySystemStartMenuShortcut(appInstalled);\n-                    verifyUserLocalStartMenuShortcut(false);\n-                }\n-            } else {\n-                verifySystemStartMenuShortcut(false);\n-                verifyUserLocalStartMenuShortcut(false);\n-            }\n-        }\n-\n-        private void verifyStartMenuShortcut(Path shortcutsRoot, boolean exists) {\n-            Path shortcutPath = shortcutsRoot.resolve(startMenuShortcutPath);\n-            verifyShortcut(shortcutPath, exists);\n-            if (!exists) {\n-                final var parentDir = shortcutPath.getParent();\n-                if (Files.isDirectory(parentDir)) {\n-                    TKit.assertDirectoryNotEmpty(parentDir);\n-                } else {\n-                    TKit.assertPathExists(parentDir, false);\n-                }\n+            for (var faFile : cmd.getAllArgumentValues(\"--file-associations\")) {\n+                verifyFileAssociationsRegistry(Path.of(faFile), installed);\n@@ -494,2 +412,1 @@\n-        private void verifySystemStartMenuShortcut(boolean exists) {\n-            verifyStartMenuShortcut(SpecialFolder.COMMON_START_MENU_PROGRAMS.getPath(), exists);\n+        private static void verifyFileAssociationsRegistry(Path faFile, boolean installed) {\n@@ -497,1 +414,3 @@\n-        }\n+            TKit.trace(String.format(\n+                    \"Get file association properties from [%s] file\",\n+                    faFile));\n@@ -499,3 +418,1 @@\n-        private void verifyUserLocalStartMenuShortcut(boolean exists) {\n-            verifyStartMenuShortcut(SpecialFolder.USER_START_MENU_PROGRAMS.getPath(), exists);\n-        }\n+            var faProps = new Properties();\n@@ -503,16 +420,4 @@\n-        private void verifyFileAssociationsRegistry(Path faFile) {\n-            try {\n-                TKit.trace(String.format(\n-                        \"Get file association properties from [%s] file\",\n-                        faFile));\n-                Map<String, String> faProps = Files.readAllLines(faFile).stream().filter(\n-                        line -> line.trim().startsWith(\"extension=\") || line.trim().startsWith(\n-                        \"mime-type=\")).map(\n-                                line -> {\n-                                    String[] keyValue = line.trim().split(\"=\", 2);\n-                                    return Map.entry(keyValue[0], keyValue[1]);\n-                                }).collect(Collectors.toMap(\n-                                entry -> entry.getKey(),\n-                                entry -> entry.getValue()));\n-                String suffix = faProps.get(\"extension\");\n-                String contentType = faProps.get(\"mime-type\");\n+            try (var reader = Files.newBufferedReader(faFile)) {\n+                faProps.load(reader);\n+                String suffix = faProps.getProperty(\"extension\");\n+                String contentType = faProps.getProperty(\"mime-type\");\n@@ -525,1 +430,2 @@\n-                verifyFileAssociations(appInstalled, \".\" + suffix, contentType);\n+                verifyFileAssociations(installed, \".\" + suffix, contentType);\n+\n@@ -527,1 +433,1 @@\n-                throw new RuntimeException(ex);\n+                throw new UncheckedIOException(ex);\n@@ -531,1 +437,1 @@\n-        private void verifyFileAssociations(boolean exists, String suffix,\n+        private static void verifyFileAssociations(boolean exists, String suffix,\n@@ -552,8 +458,0 @@\n-\n-        private final Path desktopShortcutPath;\n-        private final Path startMenuShortcutPath;\n-        private final boolean isUserLocalInstall;\n-        private final boolean appInstalled;\n-        private final boolean isWinMenu;\n-        private final boolean isDesktop;\n-        private final String name;\n@@ -562,0 +460,1 @@\n+\n@@ -614,1 +513,6 @@\n-        CommonPrograms;\n+        CommonPrograms,\n+\n+        ProgramFiles,\n+\n+        LocalApplicationData,\n+        ;\n@@ -639,9 +543,30 @@\n-    private enum SpecialFolder {\n-        COMMON_START_MENU_PROGRAMS(SYSTEM_SHELL_FOLDERS_REGKEY, \"Common Programs\", SpecialFolderDotNet.CommonPrograms),\n-        USER_START_MENU_PROGRAMS(USER_SHELL_FOLDERS_REGKEY, \"Programs\", SpecialFolderDotNet.Programs),\n-\n-        COMMON_DESKTOP(SYSTEM_SHELL_FOLDERS_REGKEY, \"Common Desktop\", SpecialFolderDotNet.CommonDesktop),\n-        USER_DESKTOP(USER_SHELL_FOLDERS_REGKEY, \"Desktop\", SpecialFolderDotNet.Desktop);\n-\n-        SpecialFolder(String keyPath, String valueName) {\n-            reg = new RegValuePath(keyPath, valueName);\n+    enum SpecialFolder {\n+        COMMON_START_MENU_PROGRAMS(\n+                SYSTEM_SHELL_FOLDERS_REGKEY,\n+                \"Common Programs\",\n+                \"ProgramMenuFolder\",\n+                SpecialFolderDotNet.CommonPrograms),\n+        USER_START_MENU_PROGRAMS(\n+                USER_SHELL_FOLDERS_REGKEY,\n+                \"Programs\",\n+                \"ProgramMenuFolder\",\n+                SpecialFolderDotNet.Programs),\n+\n+        COMMON_DESKTOP(\n+                SYSTEM_SHELL_FOLDERS_REGKEY,\n+                \"Common Desktop\",\n+                \"DesktopFolder\",\n+                SpecialFolderDotNet.CommonDesktop),\n+        USER_DESKTOP(\n+                USER_SHELL_FOLDERS_REGKEY,\n+                \"Desktop\",\n+                \"DesktopFolder\",\n+                SpecialFolderDotNet.Desktop),\n+\n+        PROGRAM_FILES(\"ProgramFiles64Folder\", SpecialFolderDotNet.ProgramFiles),\n+\n+        LOCAL_APPLICATION_DATA(\"LocalAppDataFolder\", SpecialFolderDotNet.LocalApplicationData),\n+        ;\n+\n+        SpecialFolder(String keyPath, String valueName, String msiPropertyName) {\n+            reg = Optional.of(new RegValuePath(keyPath, valueName));\n@@ -649,0 +574,1 @@\n+            this.msiPropertyName = Objects.requireNonNull(msiPropertyName);\n@@ -651,2 +577,2 @@\n-        SpecialFolder(String keyPath, String valueName, SpecialFolderDotNet alt) {\n-            reg = new RegValuePath(keyPath, valueName);\n+        SpecialFolder(String keyPath, String valueName, String msiPropertyName, SpecialFolderDotNet alt) {\n+            reg = Optional.of(new RegValuePath(keyPath, valueName));\n@@ -654,0 +580,27 @@\n+            this.msiPropertyName = Objects.requireNonNull(msiPropertyName);\n+        }\n+\n+        SpecialFolder(String msiPropertyName, SpecialFolderDotNet alt) {\n+            reg = Optional.empty();\n+            this.alt = Optional.of(alt);\n+            this.msiPropertyName = Objects.requireNonNull(msiPropertyName);\n+        }\n+\n+        static Optional<SpecialFolder> findMsiProperty(String pathComponent, boolean allUsers) {\n+            Objects.requireNonNull(pathComponent);\n+            String regPath;\n+            if (allUsers) {\n+                regPath = SYSTEM_SHELL_FOLDERS_REGKEY;\n+            } else {\n+                regPath = USER_SHELL_FOLDERS_REGKEY;\n+            }\n+            return Stream.of(values())\n+                    .filter(v -> v.msiPropertyName.equals(pathComponent))\n+                    .filter(v -> {\n+                        return v.reg.map(r -> r.keyPath().equals(regPath)).orElse(true);\n+                    })\n+                    .findFirst();\n+        }\n+\n+        String getMsiPropertyName() {\n+            return msiPropertyName;\n@@ -657,1 +610,1 @@\n-            return CACHE.computeIfAbsent(this, k -> reg.findValue().map(Path::of).orElseGet(() -> {\n+            return CACHE.computeIfAbsent(this, k -> reg.flatMap(RegValuePath::findValue).map(Path::of).orElseGet(() -> {\n@@ -664,1 +617,1 @@\n-        private final RegValuePath reg;\n+        private final Optional<RegValuePath> reg;\n@@ -666,0 +619,2 @@\n+        \/\/ One of \"System Folder Properties\" from https:\/\/learn.microsoft.com\/en-us\/windows\/win32\/msi\/property-reference\n+        private final String msiPropertyName;\n@@ -696,0 +651,57 @@\n+\n+    private static final class MsiDatabaseCache {\n+\n+        Optional<String> findProperty(Path msiPath, String propertyName) {\n+            return ensureTables(msiPath, MsiDatabase.Table.FIND_PROPERTY_REQUIRED_TABLES).findProperty(propertyName);\n+        }\n+\n+        Collection<MsiDatabase.Shortcut> listShortcuts(Path msiPath) {\n+            return ensureTables(msiPath, MsiDatabase.Table.LIST_SHORTCUTS_REQUIRED_TABLES).listShortcuts();\n+        }\n+\n+        MsiDatabase ensureTables(Path msiPath, Set<MsiDatabase.Table> tableNames) {\n+            Objects.requireNonNull(msiPath);\n+            try {\n+                synchronized (items) {\n+                    var value = Optional.ofNullable(items.get(msiPath)).map(SoftReference::get).orElse(null);\n+                    if (value != null) {\n+                        var lastModifiedTime = Files.getLastModifiedTime(msiPath).toInstant();\n+                        if (lastModifiedTime.isAfter(value.timestamp())) {\n+                            value = null;\n+                        } else {\n+                            tableNames = Comm.compare(value.db().tableNames(), tableNames).unique2();\n+                        }\n+                    }\n+\n+                    if (!tableNames.isEmpty()) {\n+                        var idtOutputDir = TKit.createTempDirectory(\"msi-db\");\n+                        var db = MsiDatabase.load(msiPath, idtOutputDir, tableNames);\n+                        if (value != null) {\n+                            value = new MsiDatabaseWithTimestamp(db.append(value.db()), value.timestamp());\n+                        } else {\n+                            value = new MsiDatabaseWithTimestamp(db, Files.getLastModifiedTime(msiPath).toInstant());\n+                        }\n+                        items.put(msiPath, new SoftReference<>(value));\n+                    }\n+\n+                    return value.db();\n+                }\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+\n+        private record MsiDatabaseWithTimestamp(MsiDatabase db, Instant timestamp) {\n+\n+            MsiDatabaseWithTimestamp {\n+                Objects.requireNonNull(db);\n+                Objects.requireNonNull(timestamp);\n+            }\n+        }\n+\n+        private final Map<Path, SoftReference<MsiDatabaseWithTimestamp>> items = new HashMap<>();\n+\n+        static final MsiDatabaseCache INSTANCE = new MsiDatabaseCache();\n+    }\n+\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/WindowsHelper.java","additions":163,"deletions":151,"binary":false,"changes":314,"status":"modified"},{"patch":"@@ -63,2 +63,2 @@\n-        createAdditionalLauncher(\"launcherB\").addRawProperties(Map.entry(\n-                \"description\", \"Foo\")).applyTo(pkg);\n+        createAdditionalLauncher(\"launcherB\").setProperty(\n+                \"description\", \"Foo\").applyTo(pkg);\n@@ -71,2 +71,2 @@\n-        createAdditionalLauncher(\"launcherB\").addRawProperties(Map.entry(\n-                \"description\", \"Bar\")).applyTo(pkg2);\n+        createAdditionalLauncher(\"launcherB\").setProperty(\n+                \"description\", \"Bar\").applyTo(pkg2);\n@@ -91,1 +91,1 @@\n-    private final static Path GOLDEN_ICON = TKit.TEST_SRC_ROOT.resolve(Path.of(\n+    private static final Path GOLDEN_ICON = TKit.TEST_SRC_ROOT.resolve(Path.of(\n","filename":"test\/jdk\/tools\/jpackage\/linux\/UpgradeTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+function readMsi(msiPath, callback) {\n+  var installer = new ActiveXObject('WindowsInstaller.Installer')\n+  var database = installer.OpenDatabase(msiPath, 0 \/* msiOpenDatabaseModeReadOnly *\/)\n+\n+  return callback(database)\n+}\n+\n+\n+function exportTables(db, outputDir, requestedTableNames) {\n+  var tables = {}\n+\n+  var view = db.OpenView(\"SELECT `Name` FROM _Tables\")\n+  view.Execute()\n+\n+  try {\n+    while (true) {\n+      var record = view.Fetch()\n+      if (!record) {\n+          break\n+      }\n+\n+      var name = record.StringData(1)\n+\n+      if (requestedTableNames.hasOwnProperty(name)) {\n+        tables[name] = name\n+      }\n+    }\n+  } finally {\n+    view.Close()\n+  }\n+\n+  var fso = new ActiveXObject(\"Scripting.FileSystemObject\")\n+  for (var table in tables) {\n+    var idtFileName = table + \".idt\"\n+    var idtFile = outputDir + \"\/\" + idtFileName\n+    if (fso.FileExists(idtFile)) {\n+      WScript.Echo(\"Delete [\" + idtFile + \"]\")\n+      fso.DeleteFile(idtFile)\n+    }\n+    WScript.Echo(\"Export table [\" + table + \"] in [\" + idtFile + \"] file\")\n+    db.Export(table, fso.GetFolder(outputDir).Path, idtFileName)\n+  }\n+}\n+\n+\n+(function () {\n+  var msi = WScript.arguments(0)\n+  var outputDir = WScript.arguments(1)\n+  var tables = {}\n+  for (var i = 0; i !== WScript.arguments.Count(); i++) {\n+    tables[WScript.arguments(i)] = true\n+  }\n+\n+  readMsi(msi, function (db) {\n+    exportTables(db, outputDir, tables)\n+  })\n+})()\n","filename":"test\/jdk\/tools\/jpackage\/resources\/msi-export.js","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-function readMsi(msiPath, callback) {\n-    var installer = new ActiveXObject('WindowsInstaller.Installer')\n-    var database = installer.OpenDatabase(msiPath, 0 \/* msiOpenDatabaseModeReadOnly *\/)\n-\n-    return callback(database)\n-}\n-\n-\n-function queryAllProperties(db) {\n-    var reply = {}\n-\n-    var view = db.OpenView(\"SELECT `Property`, `Value` FROM Property\")\n-    view.Execute()\n-\n-    try {\n-        while(true) {\n-            var record = view.Fetch()\n-            if (!record) {\n-                break\n-            }\n-\n-            var name = record.StringData(1)\n-            var value = record.StringData(2)\n-\n-            reply[name] = value\n-        }\n-    } finally {\n-        view.Close()\n-    }\n-\n-    return reply\n-}\n-\n-\n-(function () {\n-    var msi = WScript.arguments(0)\n-    var propName = WScript.arguments(1)\n-\n-    var props = readMsi(msi, queryAllProperties)\n-    WScript.Echo(props[propName])\n-})()\n","filename":"test\/jdk\/tools\/jpackage\/resources\/query-msi-property.js","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -24,1 +24,1 @@\n-import java.nio.file.Path;\n+import java.io.IOException;\n@@ -26,2 +26,12 @@\n-import jdk.jpackage.test.PackageTest;\n-import jdk.jpackage.test.FileAssociations;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import jdk.internal.util.OperatingSystem;\n@@ -29,1 +39,2 @@\n-import jdk.jpackage.test.TKit;\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.ParameterSupplier;\n@@ -31,0 +42,13 @@\n+import jdk.jpackage.test.FileAssociations;\n+import jdk.jpackage.test.HelloApp;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.JavaAppDesc;\n+import jdk.jpackage.test.LauncherShortcut;\n+import jdk.jpackage.test.LauncherShortcut.InvokeShortcutSpec;\n+import jdk.jpackage.test.LauncherShortcut.StartupDirectory;\n+import jdk.jpackage.test.LauncherVerifier.Action;\n+import jdk.jpackage.test.LinuxHelper;\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.RunnablePackageTest;\n+import jdk.jpackage.test.TKit;\n+import jdk.jpackage.test.WinShortcutVerifier;\n@@ -47,0 +71,2 @@\n+ * @requires (os.family != \"mac\")\n+ * @requires (jpackage.test.SQETest != null)\n@@ -50,0 +76,14 @@\n+ *  --jpt-run=AddLShortcutTest.test\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary jpackage with --add-launcher\n+ * @key jpackagePlatformPackage\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @build jdk.jpackage.test.*\n+ * @requires (os.family != \"mac\")\n+ * @requires (jpackage.test.SQETest == null)\n+ * @compile -Xlint:all -Werror AddLShortcutTest.java\n+ * @run main\/othervm\/timeout=1080 -Xmx512m\n+ *  jdk.jpackage.test.Main\n@@ -55,1 +95,1 @@\n-    @Test\n+    @Test(ifNotOS = OperatingSystem.MACOS)\n@@ -63,0 +103,2 @@\n+        final var packageName = MethodHandles.lookup().lookupClass().getSimpleName();\n+\n@@ -72,0 +114,5 @@\n+\n+            cmd.setArgumentValue(\"--name\", packageName);\n+\n+            var addLauncherApp = TKit.TEST_SRC_ROOT.resolve(\"apps\/PrintEnv.java\");\n+            HelloApp.createBundle(JavaAppDesc.parse(addLauncherApp + \"*another.jar:Welcome\"), cmd.inputDir());\n@@ -74,3 +121,1 @@\n-        new FileAssociations(\n-                MethodHandles.lookup().lookupClass().getSimpleName()).applyTo(\n-                packageTest);\n+        new FileAssociations(packageName).applyTo(packageTest);\n@@ -101,2 +146,2 @@\n-        new AdditionalLauncher(\"Launcher5\")\n-                .setDefaultArguments()\n+        var launcher5 = new AdditionalLauncher(\"Launcher5\")\n+                .setDefaultArguments(\"--print-workdir\")\n@@ -104,2 +149,7 @@\n-                .setShortcuts(false, true)\n-                .applyTo(packageTest);\n+                .setShortcut(LauncherShortcut.LINUX_SHORTCUT, StartupDirectory.APP_DIR)\n+                .setShortcut(LauncherShortcut.WIN_DESKTOP_SHORTCUT, StartupDirectory.APP_DIR)\n+                .setShortcut(LauncherShortcut.WIN_START_MENU_SHORTCUT, null)\n+                .setProperty(\"main-jar\", \"another.jar\")\n+                .setProperty(\"main-class\", \"Welcome\");\n+\n+        new ShortcutStartupDirectoryVerifier(packageName).add(launcher5).applyTo(packageTest);\n@@ -110,0 +160,362 @@\n+    @Test(ifNotOS = OperatingSystem.MACOS)\n+    @ParameterSupplier(ifOS = OperatingSystem.LINUX, value = \"testShortcutStartupDirectoryLinux\")\n+    @ParameterSupplier(ifOS = OperatingSystem.WINDOWS, value = \"testShortcutStartupDirectoryWindows\")\n+    public void testStartupDirectory(LauncherShortcutStartupDirectoryConfig... cfgs) {\n+\n+        var test = new PackageTest().addInitializer(cmd -> {\n+            cmd.setArgumentValue(\"--name\", \"AddLShortcutDirTest\");\n+        }).addInitializer(JPackageCommand::setFakeRuntime).addHelloAppInitializer(null);\n+\n+        test.addInitializer(cfgs[0]::applyToMainLauncher);\n+        for (var i = 1; i != cfgs.length; ++i) {\n+            var al = new AdditionalLauncher(\"launcher-\" + i);\n+            cfgs[i].applyToAdditionalLauncher(al);\n+            al.withoutVerifyActions(Action.EXECUTE_LAUNCHER).applyTo(test);\n+        }\n+\n+        test.run(RunnablePackageTest.Action.CREATE_AND_UNPACK);\n+    }\n+\n+    @Test(ifNotOS = OperatingSystem.MACOS)\n+    @ParameterSupplier(ifOS = OperatingSystem.LINUX, value = \"testShortcutStartupDirectoryLinux\")\n+    @ParameterSupplier(ifOS = OperatingSystem.WINDOWS, value = \"testShortcutStartupDirectoryWindows\")\n+    public void testStartupDirectory2(LauncherShortcutStartupDirectoryConfig... cfgs) {\n+\n+        \/\/\n+        \/\/ Launcher shortcuts in the predefined app image.\n+        \/\/\n+        \/\/ Shortcut configuration for the main launcher is not supported when building an app image.\n+        \/\/ However, shortcut configuration for additional launchers is supported.\n+        \/\/ The test configures shortcuts for additional launchers in the app image building jpackage command\n+        \/\/ and applies shortcut configuration to the main launcher in the native packaging jpackage command.\n+        \/\/\n+\n+        Path[] predefinedAppImage = new Path[1];\n+\n+        new PackageTest().addRunOnceInitializer(() -> {\n+            var cmd = JPackageCommand.helloAppImage()\n+                    .setArgumentValue(\"--name\", \"foo\")\n+                    .setFakeRuntime();\n+\n+            for (var i = 1; i != cfgs.length; ++i) {\n+                var al = new AdditionalLauncher(\"launcher-\" + i);\n+                cfgs[i].applyToAdditionalLauncher(al);\n+                al.withoutVerifyActions(Action.EXECUTE_LAUNCHER).applyTo(cmd);\n+            }\n+\n+            cmd.execute();\n+\n+            predefinedAppImage[0] = cmd.outputBundle();\n+        }).addInitializer(cmd -> {\n+            cfgs[0].applyToMainLauncher(cmd);\n+            cmd.removeArgumentWithValue(\"--input\");\n+            cmd.setArgumentValue(\"--name\", \"AddLShortcutDir2Test\");\n+            cmd.addArguments(\"--app-image\", predefinedAppImage[0]);\n+        }).run(RunnablePackageTest.Action.CREATE_AND_UNPACK);\n+    }\n+\n+    @Test(ifNotOS = OperatingSystem.MACOS)\n+    @Parameter(value = \"DEFAULT\")\n+    @Parameter(value = \"APP_DIR\")\n+    public void testLastArg(StartupDirectory startupDirectory) {\n+        final List<String> shortcutArgs = new ArrayList<>();\n+        if (TKit.isLinux()) {\n+            shortcutArgs.add(\"--linux-shortcut\");\n+        } else if (TKit.isWindows()) {\n+            shortcutArgs.add(\"--win-shortcut\");\n+        } else {\n+            TKit.assertUnexpected(\"Unsupported platform\");\n+        }\n+\n+        if (startupDirectory == StartupDirectory.APP_DIR) {\n+            shortcutArgs.add(startupDirectory.asStringValue());\n+        }\n+\n+        Path[] predefinedAppImage = new Path[1];\n+\n+        new PackageTest().addRunOnceInitializer(() -> {\n+            var cmd = JPackageCommand.helloAppImage()\n+                    .setArgumentValue(\"--name\", \"foo\")\n+                    .setFakeRuntime();\n+\n+            cmd.execute();\n+\n+            predefinedAppImage[0] = cmd.outputBundle();\n+        }).addInitializer(cmd -> {\n+            cmd.removeArgumentWithValue(\"--input\");\n+            cmd.setArgumentValue(\"--name\", \"AddLShortcutDir3Test\");\n+            cmd.addArguments(\"--app-image\", predefinedAppImage[0]);\n+            cmd.ignoreDefaultVerbose(true);\n+        }).addInitializer(cmd -> {\n+            cmd.addArguments(shortcutArgs);\n+        }).addBundleVerifier(cmd -> {\n+            TKit.assertEquals(shortcutArgs.getLast(), cmd.getAllArguments().getLast(),\n+                    \"Check the last argument of jpackage command line\");\n+        }).run(RunnablePackageTest.Action.CREATE_AND_UNPACK);\n+    }\n+\n+    public static Collection<Object[]> testShortcutStartupDirectoryLinux() {\n+        return testShortcutStartupDirectory(LauncherShortcut.LINUX_SHORTCUT);\n+    }\n+\n+    public static Collection<Object[]> testShortcutStartupDirectoryWindows() {\n+        return testShortcutStartupDirectory(LauncherShortcut.WIN_DESKTOP_SHORTCUT, LauncherShortcut.WIN_START_MENU_SHORTCUT);\n+    }\n+\n+    @Test(ifNotOS = OperatingSystem.MACOS)\n+    @Parameter(value = \"DEFAULT\")\n+    @Parameter(value = \"APP_DIR\")\n+    public void testInvokeShortcuts(StartupDirectory startupDirectory) {\n+\n+        var testApp = TKit.TEST_SRC_ROOT.resolve(\"apps\/PrintEnv.java\");\n+\n+        var name = \"AddLShortcutRunTest\";\n+\n+        var test = new PackageTest().addInitializer(cmd -> {\n+            cmd.setArgumentValue(\"--name\", name);\n+        }).addInitializer(cmd -> {\n+            cmd.addArguments(\"--arguments\", \"--print-workdir\");\n+        }).addInitializer(JPackageCommand::ignoreFakeRuntime).addHelloAppInitializer(testApp + \"*Hello\");\n+\n+        new ShortcutStartupDirectoryVerifier(name).add(\"a\", startupDirectory).applyTo(test);\n+\n+        test.run();\n+    }\n+\n+\n+    private static final class ShortcutStartupDirectoryVerifier {\n+\n+        ShortcutStartupDirectoryVerifier(String packageName) {\n+            this.packageName = Objects.requireNonNull(packageName);\n+        }\n+\n+        void applyTo(PackageTest test) {\n+            verifiers.values().forEach(verifier -> {\n+                verifier.applyTo(test);\n+            });\n+            test.addInstallVerifier(cmd -> {\n+                if (!cmd.isPackageUnpacked(\"Not invoking launcher shortcuts\")) {\n+                    Collection<? extends InvokeShortcutSpec> invokeShortcutSpecs;\n+                    if (TKit.isLinux()) {\n+                        invokeShortcutSpecs = LinuxHelper.getInvokeShortcutSpecs(cmd);\n+                    } else if (TKit.isWindows()) {\n+                        invokeShortcutSpecs = WinShortcutVerifier.getInvokeShortcutSpecs(cmd);\n+                    } else {\n+                        throw new UnsupportedOperationException();\n+                    }\n+\n+                    var invokeShortcutSpecsMap = invokeShortcutSpecs.stream().collect(Collectors.groupingBy(InvokeShortcutSpec::launcherName));\n+\n+                    for (var e : verifiers.entrySet()) {\n+                        e.getValue().verify(invokeShortcutSpecsMap.get(e.getKey()));\n+                    }\n+                }\n+            });\n+        }\n+\n+        ShortcutStartupDirectoryVerifier add(String launcherName, StartupDirectory startupDirectory) {\n+            return add(new AdditionalLauncher(launcherName)\n+                    .setShortcut(shortcut(), Objects.requireNonNull(Objects.requireNonNull(startupDirectory))));\n+        }\n+\n+        ShortcutStartupDirectoryVerifier add(AdditionalLauncher addLauncher) {\n+            var launcherVerifier = new LauncherVerifier(addLauncher);\n+            verifiers.put(launcherVerifier.launcherName(), launcherVerifier);\n+            return this;\n+        }\n+\n+\n+        private final class LauncherVerifier {\n+\n+            private LauncherVerifier(AdditionalLauncher addLauncher) {\n+                this.addLauncher = Objects.requireNonNull(addLauncher);\n+            }\n+\n+            private String launcherName() {\n+                return addLauncher.name();\n+            }\n+\n+            private void applyTo(PackageTest test) {\n+                addLauncher.addJavaOptions(String.format(\"-Djpackage.test.appOutput=${%s}\/%s\",\n+                        outputDirVarName(), expectedOutputFilename()));\n+                addLauncher.withoutVerifyActions(Action.EXECUTE_LAUNCHER).applyTo(test);\n+            }\n+\n+            private void verify(Collection<? extends InvokeShortcutSpec> invokeShortcutSpecs) throws IOException {\n+                Objects.requireNonNull(invokeShortcutSpecs);\n+                if (invokeShortcutSpecs.isEmpty()) {\n+                    throw new IllegalArgumentException();\n+                }\n+\n+                TKit.trace(String.format(\"Verify shortcut [%s]\", launcherName()));\n+\n+                var expectedOutputFile = Path.of(System.getenv(outputDirVarName())).resolve(expectedOutputFilename());\n+\n+                TKit.deleteIfExists(expectedOutputFile);\n+\n+                var invokeShortcutSpec = invokeShortcutSpecs.stream().filter(v -> {\n+                    return launcherName().equals(v.launcherName());\n+                }).findAny().orElseThrow();\n+\n+                invokeShortcutSpec.execute();\n+\n+                \/\/ On Linux, \"gtk-launch\" is used to launch a .desktop file. It is async and there is no\n+                \/\/ way to make it wait for exit of a process it triggers.\n+                TKit.waitForFileCreated(expectedOutputFile, Duration.ofSeconds(10), Duration.ofSeconds(3));\n+\n+                TKit.assertFileExists(expectedOutputFile);\n+                var actualStr = Files.readAllLines(expectedOutputFile).getFirst();\n+\n+                var outputPrefix = \"$CD=\";\n+\n+                TKit.assertTrue(actualStr.startsWith(outputPrefix), \"Check output starts with '\" + outputPrefix+ \"' string\");\n+\n+                invokeShortcutSpec.expectedWorkDirectory().ifPresent(expectedWorkDirectory -> {\n+                    TKit.assertEquals(\n+                            expectedWorkDirectory,\n+                            Path.of(actualStr.substring(outputPrefix.length())),\n+                            String.format(\"Check work directory of %s of launcher [%s]\",\n+                                    invokeShortcutSpec.shortcut().propertyName(),\n+                                    invokeShortcutSpec.launcherName()));\n+                });\n+            }\n+\n+            private String expectedOutputFilename() {\n+                return String.format(\"%s-%s.out\", packageName, launcherName());\n+            }\n+\n+            private final AdditionalLauncher addLauncher;\n+        }\n+\n+\n+        private static String outputDirVarName() {\n+            if (TKit.isLinux()) {\n+                return \"HOME\";\n+            } else if (TKit.isWindows()) {\n+                return \"LOCALAPPDATA\";\n+            } else {\n+                throw new UnsupportedOperationException();\n+            }\n+        }\n+\n+        private static LauncherShortcut shortcut() {\n+            if (TKit.isLinux()) {\n+                return LauncherShortcut.LINUX_SHORTCUT;\n+            } else if (TKit.isWindows()) {\n+                return LauncherShortcut.WIN_DESKTOP_SHORTCUT;\n+            } else {\n+                throw new UnsupportedOperationException();\n+            }\n+        }\n+\n+        private final String packageName;\n+        \/\/ Keep the order\n+        private final Map<String, LauncherVerifier> verifiers = new LinkedHashMap<>();\n+    }\n+\n+\n+    private static Collection<Object[]> testShortcutStartupDirectory(LauncherShortcut... shortcuts) {\n+        List<List<LauncherShortcutStartupDirectoryConfig>> items = new ArrayList<>();\n+\n+        for (var shortcut : shortcuts) {\n+            List<LauncherShortcutStartupDirectoryConfig> mainLauncherVariants = new ArrayList<>();\n+            for (var valueSetter : StartupDirectoryValueSetter.MAIN_LAUNCHER_VALUES) {\n+                mainLauncherVariants.add(new LauncherShortcutStartupDirectoryConfig(shortcut, valueSetter));\n+            }\n+            mainLauncherVariants.stream().map(List::of).forEach(items::add);\n+            mainLauncherVariants.add(new LauncherShortcutStartupDirectoryConfig(shortcut));\n+\n+            List<LauncherShortcutStartupDirectoryConfig> addLauncherVariants = new ArrayList<>();\n+            addLauncherVariants.add(new LauncherShortcutStartupDirectoryConfig(shortcut));\n+            for (var valueSetter : StartupDirectoryValueSetter.ADD_LAUNCHER_VALUES) {\n+                addLauncherVariants.add(new LauncherShortcutStartupDirectoryConfig(shortcut, valueSetter));\n+            }\n+\n+            for (var mainLauncherVariant : mainLauncherVariants) {\n+                for (var addLauncherVariant : addLauncherVariants) {\n+                    if (mainLauncherVariant.valueSetter().isPresent() || addLauncherVariant.valueSetter().isPresent()) {\n+                        items.add(List.of(mainLauncherVariant, addLauncherVariant));\n+                    }\n+                }\n+            }\n+        }\n+\n+        return items.stream().map(List::toArray).toList();\n+    }\n+\n+\n+    private enum StartupDirectoryValueSetter {\n+        DEFAULT(\"\"),\n+        TRUE(\"true\"),\n+        FALSE(\"false\"),\n+        ;\n+\n+        StartupDirectoryValueSetter(String value) {\n+            this.value = Objects.requireNonNull(value);\n+        }\n+\n+        void applyToMainLauncher(LauncherShortcut shortcut, JPackageCommand cmd) {\n+            switch (this) {\n+                case TRUE, FALSE -> {\n+                    throw new UnsupportedOperationException();\n+                }\n+                case DEFAULT -> {\n+                    cmd.addArgument(shortcut.optionName());\n+                }\n+                default -> {\n+                    cmd.addArguments(shortcut.optionName(), value);\n+                }\n+            }\n+        }\n+\n+        void applyToAdditionalLauncher(LauncherShortcut shortcut, AdditionalLauncher addLauncher) {\n+            addLauncher.setProperty(shortcut.propertyName(), value);\n+        }\n+\n+        private final String value;\n+\n+        static final List<StartupDirectoryValueSetter> MAIN_LAUNCHER_VALUES = List.of(\n+                StartupDirectoryValueSetter.DEFAULT\n+        );\n+\n+        static final List<StartupDirectoryValueSetter> ADD_LAUNCHER_VALUES = List.of(\n+                StartupDirectoryValueSetter.TRUE,\n+                StartupDirectoryValueSetter.FALSE\n+        );\n+    }\n+\n+\n+    record LauncherShortcutStartupDirectoryConfig(LauncherShortcut shortcut, Optional<StartupDirectoryValueSetter> valueSetter) {\n+\n+        LauncherShortcutStartupDirectoryConfig {\n+            Objects.requireNonNull(shortcut);\n+            Objects.requireNonNull(valueSetter);\n+        }\n+\n+        LauncherShortcutStartupDirectoryConfig(LauncherShortcut shortcut, StartupDirectoryValueSetter valueSetter) {\n+            this(shortcut, Optional.of(valueSetter));\n+        }\n+\n+        LauncherShortcutStartupDirectoryConfig(LauncherShortcut shortcut) {\n+            this(shortcut, Optional.empty());\n+        }\n+\n+        void applyToMainLauncher(JPackageCommand target) {\n+            valueSetter.ifPresent(valueSetter -> {\n+                valueSetter.applyToMainLauncher(shortcut, target);\n+            });\n+        }\n+\n+        void applyToAdditionalLauncher(AdditionalLauncher target) {\n+            valueSetter.ifPresent(valueSetter -> {\n+                valueSetter.applyToAdditionalLauncher(shortcut, target);\n+            });\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return shortcut + \"=\" + valueSetter.map(Object::toString).orElse(\"\");\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/tools\/jpackage\/share\/AddLShortcutTest.java","additions":424,"deletions":12,"binary":false,"changes":436,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-                .addRawProperties(Map.entry(\"description\", \"Baz2 Description\"))\n+                .setProperty(\"description\", \"Baz2 Description\")\n@@ -97,1 +97,1 @@\n-                .addRawProperties(Map.entry(\"description\", \"foo Description\"))\n+                .setProperty(\"description\", \"foo Description\")\n@@ -102,1 +102,1 @@\n-                .addRawProperties(Map.entry(\"description\", \"Bar Description\"))\n+                .setProperty(\"description\", \"Bar Description\")\n@@ -197,2 +197,2 @@\n-        .addRawProperties(Map.entry(\"module\", expectedMod))\n-        .addRawProperties(Map.entry(\"main-jar\", \"\"))\n+        .setProperty(\"module\", expectedMod)\n+        .setProperty(\"main-jar\", \"\")\n@@ -207,2 +207,2 @@\n-        .addRawProperties(Map.entry(\"main-class\", nonModularAppDesc.className()))\n-        .addRawProperties(Map.entry(\"main-jar\", nonModularAppDesc.jarFileName()))\n+        .setProperty(\"main-class\", nonModularAppDesc.className())\n+        .setProperty(\"main-jar\", nonModularAppDesc.jarFileName())\n","filename":"test\/jdk\/tools\/jpackage\/share\/AddLauncherTest.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -579,0 +579,3 @@\n+        invalidShortcut(testCases::add, \"--win-menu\");\n+        invalidShortcut(testCases::add, \"--win-shortcut\");\n+\n@@ -645,0 +648,2 @@\n+        invalidShortcut(testCases::add, \"--linux-shortcut\");\n+\n@@ -700,0 +705,7 @@\n+    private static void invalidShortcut(Consumer<TestSpec> accumulator, String shortcutOption) {\n+        Objects.requireNonNull(shortcutOption);\n+        Stream.of(\"true\", \"false\", \"\").map(value -> {\n+            return testSpec().nativeType().addArgs(shortcutOption, value).error(\"error.invalid-option-value\", value, shortcutOption).create();\n+        }).forEach(accumulator);\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/share\/ErrorTest.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.jpackage.internal.util.function.ThrowingConsumer;\n@@ -31,1 +32,0 @@\n-import jdk.jpackage.test.PackageTest;\n@@ -33,1 +33,0 @@\n-import jdk.jpackage.internal.util.function.ThrowingConsumer;\n@@ -36,0 +35,1 @@\n+import jdk.jpackage.test.LauncherVerifier.Action;\n@@ -37,0 +37,1 @@\n+import jdk.jpackage.test.PackageTest;\n@@ -68,1 +69,1 @@\n-        new PackageTest().configureHelloApp().addInstallVerifier(cmd -> {\n+        new PackageTest().addHelloAppInitializer(null).addInstallVerifier(cmd -> {\n@@ -147,4 +148,1 @@\n-        new AdditionalLauncher(name) {\n-            @Override\n-            protected void verify(JPackageCommand cmd) {}\n-        }.setDefaultArguments(name).applyTo(cmd);\n+        new AdditionalLauncher(name).setDefaultArguments(name).withoutVerifyActions(Action.EXECUTE_LAUNCHER).applyTo(cmd);\n","filename":"test\/jdk\/tools\/jpackage\/share\/PerUserCfgTest.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -129,2 +129,2 @@\n-        Java [12:08:38.180 libwixhelper.cpp:120 (FindRelatedProductsEx)] TRACE: Entering FindRelatedProductsEx\n-        Java [12:08:38.185 libwixhelper.cpp:85 (`anonymous-namespace'::findInstalledPackages)] TRACE: Found {D88EEA02-56CC-34AD-8216-C2CC244FA898} product\n+        Java [12:08:38.180 libmsica.cpp:120 (FindRelatedProductsEx)] TRACE: Entering FindRelatedProductsEx\n+        Java [12:08:38.185 libmsica.cpp:85 (`anonymous-namespace'::findInstalledPackages)] TRACE: Found {D88EEA02-56CC-34AD-8216-C2CC244FA898} product\n@@ -134,1 +134,1 @@\n-        Java [12:08:38.190 libwixhelper.cpp:0 (FindRelatedProductsEx)] TRACE: Exiting FindRelatedProductsEx (entered at libwixhelper.cpp:120)\n+        Java [12:08:38.190 libmsica.cpp:0 (FindRelatedProductsEx)] TRACE: Exiting FindRelatedProductsEx (entered at libmsica.cpp:120)\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinLongVersionTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+ * @comment VM fails to launch with minimum allowed stack size of 136k when asan is enabled\n+ * @requires !vm.asan\n","filename":"test\/jdk\/tools\/launcher\/TooSmallStackSize.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -300,1 +300,0 @@\n-                elements.getModuleElement(\"java.base\");\n","filename":"test\/jdk\/tools\/sincechecker\/SinceChecker.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8349132\n+ * @bug 8349132 8364987\n@@ -142,0 +142,39 @@\n+    @Test \/\/JDK-8364987:\n+    public void testNoCrashErroneousTypes(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          public class Test {\n+                              void t() {\n+                                  L<Object> l = new L<Test>();\n+                              }\n+                              static class L<T> { }\n+                          }\n+                          \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        var out = new JavacTask(tb)\n+            .options(\"-XDfind=diamond\",\n+                     \"-XDshould-stop.at=FLOW\",\n+                     \"-XDrawDiagnostics\")\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run(Task.Expect.FAIL)\n+            .writeAll()\n+            .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        var expectedOut = List.of(\n+            \"Test.java:3:23: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: Test.L<Test>, Test.L<java.lang.Object>)\",\n+            \"1 error\"\n+        );\n+\n+        if (!Objects.equals(expectedOut, out)) {\n+            throw new AssertionError(\"Incorrect Output, expected: \" + expectedOut +\n+                                      \", actual: \" + out);\n+\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/analyzer\/Diamond.java","additions":40,"deletions":1,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import com.sun.tools.javac.code.Flags.Flag;\n+import com.sun.tools.javac.code.FlagsEnum;\n@@ -306,1 +306,1 @@\n-        if (o instanceof Flag)\n+        if (o instanceof FlagsEnum)\n","filename":"test\/langtools\/tools\/javac\/diags\/ArgTypeCompilerFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +27,1 @@\n- * @bug 8211138\n+ * @bug 8211138 8362885\n@@ -30,1 +31,2 @@\n- * @run main FlagsTest\n+ * @compile FlagsTest.java\n+ * @run main\/manual FlagsTest\n@@ -33,0 +35,3 @@\n+import com.sun.tools.javac.code.Flags.FlagTarget;\n+import com.sun.tools.javac.code.Flags.NotFlag;\n+import com.sun.tools.javac.code.Flags.Use;\n@@ -34,1 +39,4 @@\n-import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n@@ -37,1 +45,19 @@\n-    public static void main(String[] args) throws IllegalAccessException {\n+\n+    private static final int U2_SIZE = 16;\n+\n+    public static void main(String[] args) throws Throwable {\n+        findFreeFlags();\n+    }\n+\n+    private static void findFreeFlags() throws Throwable {\n+        Map<FlagTarget, Map<Long, List<Field>>> target2Flag2Fields = computeTarget2Flag2Fields();\n+\n+        for (FlagTarget target : FlagTarget.values()) {\n+            long freeFlags = ~collectFlags(target2Flag2Fields, target);\n+\n+            printFreeFlags(target.name(), freeFlags);\n+        }\n+    }\n+\n+    private static Map<FlagTarget, Map<Long, List<Field>>> computeTarget2Flag2Fields() throws Throwable {\n+        Map<FlagTarget, Map<Long, List<Field>>> target2Flag2Fields = new HashMap<>();\n@@ -39,1 +65,1 @@\n-            if (!Modifier.isStatic(f.getModifiers())) {\n+            if (f.isAnnotationPresent(NotFlag.class)) {\n@@ -42,5 +68,13 @@\n-            long flag = ((Number) f.get(null)).longValue();\n-            try {\n-                Flags.asFlagSet(flag);\n-            } catch (AssertionError e) {\n-                throw new AssertionError(\"missing Flags enum constant for: \" + f.getName(), e);\n+\n+            Use use = f.getAnnotation(Use.class);\n+\n+            if (use == null) {\n+                throw new AssertionError(\"No @Use and no @NotFlag for: \" + f.getName());\n+            }\n+\n+            long flagValue = ((Number) f.get(null)).longValue();\n+\n+            for (FlagTarget target : use.value()) {\n+                target2Flag2Fields.computeIfAbsent(target, _ -> new HashMap<>())\n+                        .computeIfAbsent(flagValue, _ -> new ArrayList<>())\n+                        .add(f);\n@@ -49,0 +83,23 @@\n+        return target2Flag2Fields;\n+    }\n+\n+    private static void printFreeFlags(String comment, long freeFlags) {\n+            System.err.print(\"free flags for \" + comment + \": \");\n+            for (int bit = U2_SIZE; bit < Long.SIZE; bit++) { \/\/lowest 16 bits are used in classfiles, never suggest adding anything there\n+                if ((freeFlags & (1L << bit)) != 0) {\n+                    System.err.print(\"1L<<\" + bit + \" \");\n+                }\n+            }\n+            System.err.println();\n+    }\n+\n+    private static long collectFlags(Map<FlagTarget, Map<Long, List<Field>>> target2Flag2Fields, FlagTarget... forTargets) {\n+        long flags = 0;\n+\n+        for (FlagTarget target : forTargets) {\n+            for (long used : target2Flag2Fields.get(target).keySet()) {\n+                flags |= used;\n+            }\n+        }\n+\n+        return flags;\n","filename":"test\/langtools\/tools\/javac\/flags\/FlagsTest.java","additions":67,"deletions":10,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8341342\n+ * @summary Test Elements methods programmatically\n+ * @modules jdk.compiler\n+ * @run junit TestElementsProgrammatic\n+ *\/\n+\n+import com.sun.source.util.JavacTask;\n+import java.net.URI;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.tools.ToolProvider;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/**\n+ * Programmatically test workings of various methods of Elements.\n+ *\/\n+public class TestElementsProgrammatic {\n+\n+    private final JavaCompiler systemCompiler = ToolProvider.getSystemJavaCompiler();\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void automaticallyEnter(Consumer<JavacTask> verify) {\n+        \/\/make sure the get{All,}{Module,Package,Type}Element{s,} methods will automatically enter:\n+        JavaFileObject input =\n+                SimpleJavaFileObject.forSource(URI.create(\"mem:\/\/Test.java\"), \"\");\n+        List<JavaFileObject> inputs = List.of(input);\n+        JavacTask task = (JavacTask) systemCompiler.getTask(null, null, null, null, null, inputs);\n+        verify.accept(task);\n+    }\n+\n+    private static List<Consumer<JavacTask>> automaticallyEnter() {\n+        return List.of(\n+            task -> assertFalse(task.getElements().getAllModuleElements().isEmpty()),\n+            task -> assertNotNull(task.getElements().getModuleElement(\"java.base\")),\n+            task -> assertNotNull(task.getElements().getPackageElement(\"java.lang\")),\n+            task -> assertFalse(task.getElements().getAllPackageElements(\"java.lang\").isEmpty()),\n+            task -> assertNotNull(task.getElements().getTypeElement(\"java.lang.Object\")),\n+            task -> assertFalse(task.getElements().getAllTypeElements(\"java.lang.Object\").isEmpty())\n+        );\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/util\/elements\/TestElementsProgrammatic.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8270139 8361445\n+ * @bug 8270139 8361445 8365314\n@@ -227,0 +227,24 @@\n+    @Test \/\/JDK-8365314\n+    public void testSuppressWarningsMissingAttribute() throws Exception {\n+        String code = \"\"\"\n+                      @SuppressWarnings\n+                      public class Test {\n+                      }\n+                      \"\"\";\n+        Path curPath = Path.of(\".\");\n+        List<String> actual = new JavacTask(tb)\n+                .options(\"-XDrawDiagnostics\", \"-XDdev\")\n+                .sources(code)\n+                .outdir(curPath)\n+                .run(Expect.FAIL)\n+                .getOutputLines(OutputKind.DIRECT);\n+\n+        List<String> expected = List.of(\n+                \"Test.java:1:1: compiler.err.annotation.missing.default.value: java.lang.SuppressWarnings, value\",\n+                \"1 error\"\n+        );\n+\n+        if (!Objects.equals(actual, expected)) {\n+            error(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/recovery\/AnnotationRecovery.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.io.File;\n@@ -36,0 +37,1 @@\n+import java.nio.file.LinkOption;\n@@ -67,0 +69,8 @@\n+    @SuppressWarnings(\"restricted\")\n+    private static void loadNativeLib() {\n+        if (!nativeLibLoaded) {\n+            System.loadLibrary(\"FileUtils\");\n+            nativeLibLoaded = true;\n+        }\n+    }\n+\n@@ -395,1 +405,0 @@\n-    @SuppressWarnings(\"restricted\")\n@@ -398,5 +407,2 @@\n-            if (!nativeLibLoaded) {\n-                System.loadLibrary(\"FileUtils\");\n-                nativeLibLoaded = true;\n-            }\n-            return getWinProcessHandleCount();\n+            loadNativeLib();\n+            return getWinProcessHandleCount0();\n@@ -446,1 +452,17 @@\n-    private static native long getWinProcessHandleCount();\n+    \/\/ Create a directory junction with the specified target\n+    public static boolean createWinDirectoryJunction(Path junction, Path target)\n+        throws IOException\n+    {\n+        assert IS_WINDOWS;\n+\n+        \/\/ Convert \"target\" to its real path\n+        target = target.toRealPath();\n+\n+        \/\/ Create a directory junction\n+        loadNativeLib();\n+        return createWinDirectoryJunction0(junction.toString(), target.toString());\n+    }\n+\n+    private static native long getWinProcessHandleCount0();\n+    private static native boolean createWinDirectoryJunction0(String junction,\n+        String target) throws IOException;\n","filename":"test\/lib\/jdk\/test\/lib\/util\/FileUtils.java","additions":29,"deletions":7,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+#include \"jni_util.h\"\n+#include <string.h>\n@@ -31,0 +33,8 @@\n+#include <fileapi.h>\n+#include <handleapi.h>\n+#include <ioapiset.h>\n+#include <winioctl.h>\n+#include <errhandlingapi.h>\n+\n+\/\/ Based on Microsoft documentation\n+#define MAX_REPARSE_BUFFER_SIZE 16384\n@@ -32,1 +42,31 @@\n-JNIEXPORT jlong JNICALL Java_jdk_test_lib_util_FileUtils_getWinProcessHandleCount(JNIEnv *env)\n+\/\/ Unavailable in standard header files:\n+\/\/ copied from Microsoft documentation\n+typedef struct _REPARSE_DATA_BUFFER {\n+    ULONG  ReparseTag;\n+    USHORT ReparseDataLength;\n+    USHORT Reserved;\n+    union {\n+        struct {\n+            USHORT SubstituteNameOffset;\n+            USHORT SubstituteNameLength;\n+            USHORT PrintNameOffset;\n+            USHORT PrintNameLength;\n+            ULONG  Flags;\n+            WCHAR  PathBuffer[1];\n+        } SymbolicLinkReparseBuffer;\n+        struct {\n+            USHORT SubstituteNameOffset;\n+            USHORT SubstituteNameLength;\n+            USHORT PrintNameOffset;\n+            USHORT PrintNameLength;\n+            WCHAR  PathBuffer[1];\n+        } MountPointReparseBuffer;\n+        struct {\n+            UCHAR DataBuffer[1];\n+        } GenericReparseBuffer;\n+    } DUMMYUNIONNAME;\n+} REPARSE_DATA_BUFFER, * PREPARSE_DATA_BUFFER;\n+\n+JNIEXPORT jlong JNICALL\n+Java_jdk_test_lib_util_FileUtils_getWinProcessHandleCount0\n+    (JNIEnv* env)\n@@ -43,0 +83,114 @@\n+void throwIOExceptionWithLastError(JNIEnv* env) {\n+#define BUFSIZE 256\n+    DWORD errval;\n+    WCHAR buf[BUFSIZE];\n+\n+    if ((errval = GetLastError()) != 0) {\n+        jsize n = FormatMessageW(\n+            FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\n+            NULL, errval, 0, buf, BUFSIZE, NULL);\n+\n+        jclass ioExceptionClass = (*env)->FindClass(env, \"java\/io\/IOException\");\n+        (*env)->ThrowNew(env, ioExceptionClass, (const char*) buf);\n+    }\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_jdk_test_lib_util_FileUtils_createWinDirectoryJunction0\n+    (JNIEnv* env, jclass unused, jstring sjunction, jstring starget)\n+{\n+    BOOL error = FALSE;\n+\n+    const jshort bpc = sizeof(wchar_t); \/\/ bytes per character\n+    HANDLE hJunction = INVALID_HANDLE_VALUE;\n+\n+    const jchar* junction = (*env)->GetStringChars(env, sjunction, NULL);\n+    const jchar* target   = (*env)->GetStringChars(env, starget, NULL);\n+    if (junction == NULL || target == NULL) {\n+        jclass npeClass = (*env)->FindClass(env, \"java\/lang\/NullPointerException\");\n+        (*env)->ThrowNew(env, npeClass, NULL);\n+        error = TRUE;\n+    }\n+\n+    USHORT wlen = (USHORT)0;\n+    USHORT blen = (USHORT)0;\n+    void* lpInBuffer = NULL;\n+    if (!error) {\n+        wlen = (USHORT)wcslen(target);\n+        blen = (USHORT)(wlen * sizeof(wchar_t));\n+        lpInBuffer = calloc(MAX_REPARSE_BUFFER_SIZE, sizeof(char));\n+        if (lpInBuffer == NULL) {\n+            jclass oomeClass = (*env)->FindClass(env, \"java\/lang\/OutOfMemoryError\");\n+            (*env)->ThrowNew(env, oomeClass, NULL);\n+            error = TRUE;\n+        }\n+    }\n+\n+    if (!error) {\n+        if (CreateDirectoryW(junction, NULL) == 0) {\n+            throwIOExceptionWithLastError(env);\n+            error = TRUE;\n+        }\n+    }\n+\n+    if (!error) {\n+        hJunction = CreateFileW(junction, GENERIC_READ | GENERIC_WRITE,\n+                                FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,\n+                                OPEN_EXISTING,\n+                                FILE_FLAG_OPEN_REPARSE_POINT\n+                                | FILE_FLAG_BACKUP_SEMANTICS, NULL);\n+        if (hJunction == INVALID_HANDLE_VALUE) {\n+            throwIOExceptionWithLastError(env);\n+            error = TRUE;\n+        }\n+    }\n+\n+    if (!error) {\n+        PREPARSE_DATA_BUFFER reparseBuffer = (PREPARSE_DATA_BUFFER)lpInBuffer;\n+        reparseBuffer->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;\n+        reparseBuffer->Reserved = 0;\n+        WCHAR* prefix = L\"\\\\??\\\\\";\n+        USHORT prefixLength = (USHORT)(bpc * wcslen(prefix));\n+        reparseBuffer->MountPointReparseBuffer.SubstituteNameOffset = 0;\n+        reparseBuffer->MountPointReparseBuffer.SubstituteNameLength =\n+            prefixLength + blen;\n+        reparseBuffer->MountPointReparseBuffer.PrintNameOffset =\n+            prefixLength + blen + sizeof(WCHAR);\n+        reparseBuffer->MountPointReparseBuffer.PrintNameLength = blen;\n+        memcpy(&reparseBuffer->MountPointReparseBuffer.PathBuffer,\n+               prefix, prefixLength);\n+        memcpy(&reparseBuffer->MountPointReparseBuffer.PathBuffer[prefixLength\/bpc],\n+               target, blen);\n+        memcpy(&reparseBuffer->MountPointReparseBuffer.PathBuffer[prefixLength\/bpc + blen\/bpc + 1],\n+               target, blen);\n+        reparseBuffer->ReparseDataLength =\n+            (USHORT)(sizeof(reparseBuffer->MountPointReparseBuffer) +\n+                     prefixLength + bpc*blen + bpc);\n+        DWORD nInBufferSize = FIELD_OFFSET(REPARSE_DATA_BUFFER,\n+            MountPointReparseBuffer) + reparseBuffer->ReparseDataLength;\n+        BOOL result = DeviceIoControl(hJunction, FSCTL_SET_REPARSE_POINT,\n+                                      lpInBuffer, nInBufferSize,\n+                                      NULL, 0, NULL, NULL);\n+        if (result == 0) {\n+            throwIOExceptionWithLastError(env);\n+            error = TRUE;\n+        }\n+    }\n+\n+    if (junction != NULL) {\n+        (*env)->ReleaseStringChars(env, sjunction, junction);\n+        if (target != NULL) {\n+            (*env)->ReleaseStringChars(env, starget, target);\n+            if (lpInBuffer != NULL) {\n+                free(lpInBuffer);\n+                if (hJunction != INVALID_HANDLE_VALUE) {\n+                    \/\/ Ignore any error in CloseHandle\n+                    CloseHandle(hJunction);\n+                }\n+            }\n+        }\n+    }\n+\n+    return error ? JNI_FALSE : JNI_TRUE;\n+}\n+\n","filename":"test\/lib\/jdk\/test\/lib\/util\/libFileUtils.c","additions":156,"deletions":2,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.nio;\n+\n+import java.nio.CharBuffer;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+\/**\n+ * Benchmark for bulk get methods of a {@code CharBuffer} created from a\n+ * {@code CharSequence}.\n+ *\/\n+\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Fork(1)\n+public class StringCharBufferBulkTransfer {\n+    private static final int LENGTH = 16384;\n+\n+    char[] buf = new char[LENGTH];\n+    CharBuffer cb = CharBuffer.wrap(new String(buf));\n+    char[] dst = new char[LENGTH];\n+    CharBuffer cbw = CharBuffer.allocate(LENGTH);\n+\n+    @Benchmark\n+    public void absoluteBulkGet() {\n+        cb.get(0, dst, 0, dst.length);\n+    }\n+\n+    @Benchmark\n+    public void relativeBulkGet() {\n+        cb.get(dst, 0, dst.length);\n+        cb.position(0);\n+    }\n+\n+    @Benchmark\n+    public void getChars() {\n+        cb.getChars(0, LENGTH, dst, 0);\n+    }\n+\n+    @Benchmark\n+    public void absoluteBulkPut() {\n+        cbw.put(0, cb, 0, dst.length);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/nio\/StringCharBufferBulkTransfer.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2022, Tencent. All rights reserved.\n@@ -197,1 +197,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/Signatures.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -198,1 +198,1 @@\n-            count += node.getChildren().stream().mapToLong(n -> {\n+            count += node.getChildNames().mapToLong(n -> {\n@@ -200,1 +200,1 @@\n-                    return countAllNodes(reader, reader.findNode(n.getName()));\n+                    return countAllNodes(reader, reader.findNode(n));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/internal\/jrtfs\/ImageReaderBenchmark.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2022, Tencent. All rights reserved.\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/AutoVectorization2DArray.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2021, Tencent. All rights reserved.\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/LoopUnroll.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}