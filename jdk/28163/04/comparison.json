{"files":[{"patch":"@@ -35,0 +35,1 @@\n+        jdk.jpackage,\n","filename":"src\/jdk.internal.opt\/share\/classes\/module-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.util.Optional;\n-\n-public class LinuxAppBundler extends AppImageBundler {\n-    public LinuxAppBundler() {\n-        setAppImageSupplier((params, output) -> {\n-            \/\/ Order is important!\n-            var app = LinuxFromParams.APPLICATION.fetchFrom(params);\n-            var env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n-            LinuxPackagingPipeline.build(Optional.empty())\n-                    .excludeDirFromCopying(output.getParent())\n-                    .create().execute(BuildEnv.withAppImageDir(env, output), app);\n-        });\n-    }\n-}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxAppBundler.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static java.util.stream.Collectors.toMap;\n+import static jdk.jpackage.internal.LinuxFromOptions.createLinuxApplication;\n+import static jdk.jpackage.internal.LinuxPackagingPipeline.APPLICATION_LAYOUT;\n+import static jdk.jpackage.internal.cli.StandardBundlingOperation.CREATE_LINUX_APP_IMAGE;\n+import static jdk.jpackage.internal.cli.StandardBundlingOperation.CREATE_LINUX_DEB;\n+import static jdk.jpackage.internal.cli.StandardBundlingOperation.CREATE_LINUX_RPM;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.cli.Options;\n+import jdk.jpackage.internal.cli.StandardBundlingOperation;\n+import jdk.jpackage.internal.model.BundlingOperationDescriptor;\n+import jdk.jpackage.internal.model.LinuxPackage;\n+import jdk.jpackage.internal.model.PackageType;\n+import jdk.jpackage.internal.util.Result;\n+\n+public class LinuxBundlingEnvironment extends DefaultBundlingEnvironment {\n+\n+    public LinuxBundlingEnvironment() {\n+        super(build()\n+                .defaultOperation(() -> {\n+                    return LazyLoad.SYS_ENV.value().map(LinuxSystemEnvironment::nativePackageType).map(DESCRIPTORS::get);\n+                })\n+                .bundler(CREATE_LINUX_APP_IMAGE, LinuxBundlingEnvironment::createAppImage)\n+                .bundler(CREATE_LINUX_DEB, LazyLoad::debSysEnv, LinuxBundlingEnvironment::createDebPackage)\n+                .bundler(CREATE_LINUX_RPM, LazyLoad::rpmSysEnv, LinuxBundlingEnvironment::createRpmPackage));\n+    }\n+\n+    private static void createDebPackage(Options options, LinuxDebSystemEnvironment sysEnv) {\n+\n+        createNativePackage(options,\n+                LinuxFromOptions::createLinuxDebPackage,\n+                buildEnv()::create,\n+                LinuxBundlingEnvironment::buildPipeline,\n+                (env, pkg, outputDir) -> {\n+                    return new LinuxDebPackager(env, pkg, outputDir, sysEnv);\n+                });\n+    }\n+\n+    private static void createRpmPackage(Options options, LinuxRpmSystemEnvironment sysEnv) {\n+\n+        createNativePackage(options,\n+                LinuxFromOptions::createLinuxRpmPackage,\n+                buildEnv()::create,\n+                LinuxBundlingEnvironment::buildPipeline,\n+                (env, pkg, outputDir) -> {\n+                    return new LinuxRpmPackager(env, pkg, outputDir, sysEnv);\n+                });\n+    }\n+\n+    private static void createAppImage(Options options) {\n+\n+        final var app = createLinuxApplication(options);\n+\n+        createApplicationImage(options, app, LinuxPackagingPipeline.build(Optional.empty()));\n+    }\n+\n+    private static PackagingPipeline.Builder buildPipeline(LinuxPackage pkg) {\n+        return LinuxPackagingPipeline.build(Optional.of(pkg));\n+    }\n+\n+    private static BuildEnvFromOptions buildEnv() {\n+        return new BuildEnvFromOptions().predefinedAppImageLayout(APPLICATION_LAYOUT);\n+    }\n+\n+    private static final class LazyLoad {\n+\n+        static Result<LinuxDebSystemEnvironment> debSysEnv() {\n+            return DEB_SYS_ENV;\n+        }\n+\n+        static Result<LinuxRpmSystemEnvironment> rpmSysEnv() {\n+            return RPM_SYS_ENV;\n+        }\n+\n+        private static final Result<LinuxSystemEnvironment> SYS_ENV = LinuxSystemEnvironment.create();\n+\n+        private static final Result<LinuxDebSystemEnvironment> DEB_SYS_ENV = LinuxDebSystemEnvironment.create(SYS_ENV);\n+\n+        private static final Result<LinuxRpmSystemEnvironment> RPM_SYS_ENV = LinuxRpmSystemEnvironment.create(SYS_ENV);\n+    }\n+\n+    private static final Map<PackageType, BundlingOperationDescriptor> DESCRIPTORS = Stream.of(\n+            CREATE_LINUX_DEB,\n+            CREATE_LINUX_RPM\n+    ).collect(toMap(StandardBundlingOperation::packageType, StandardBundlingOperation::descriptor));\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxBundlingEnvironment.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -1,79 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.nio.file.Path;\n-import java.util.Map;\n-import java.util.Optional;\n-import jdk.jpackage.internal.model.LinuxDebPackage;\n-import jdk.jpackage.internal.model.PackagerException;\n-import jdk.jpackage.internal.model.StandardPackageType;\n-import jdk.jpackage.internal.util.Result;\n-\n-public class LinuxDebBundler extends LinuxPackageBundler {\n-\n-    public LinuxDebBundler() {\n-        super(LinuxFromParams.DEB_PACKAGE);\n-    }\n-\n-    @Override\n-    public String getName() {\n-        return I18N.getString(\"deb.bundler.name\");\n-    }\n-\n-    @Override\n-    public String getID() {\n-        return \"deb\";\n-    }\n-\n-    @Override\n-    public Path execute(Map<String, ? super Object> params, Path outputParentDir) throws PackagerException {\n-\n-        var pkg = LinuxFromParams.DEB_PACKAGE.fetchFrom(params);\n-\n-        return Packager.<LinuxDebPackage>build().outputDir(outputParentDir)\n-                .pkg(pkg)\n-                .env(BuildEnvFromParams.BUILD_ENV.fetchFrom(params))\n-                .pipelineBuilderMutatorFactory((env, _, outputDir) -> {\n-                    return new LinuxDebPackager(env, pkg, outputDir, sysEnv.orElseThrow());\n-                }).execute(LinuxPackagingPipeline.build(Optional.of(pkg)));\n-    }\n-\n-    @Override\n-    protected Result<LinuxDebSystemEnvironment> sysEnv() {\n-        return sysEnv;\n-    }\n-\n-    @Override\n-    public boolean isDefault() {\n-        return sysEnv.value()\n-                .map(LinuxSystemEnvironment::nativePackageType)\n-                .map(StandardPackageType.LINUX_DEB::equals)\n-                .orElse(false);\n-    }\n-\n-    private final Result<LinuxDebSystemEnvironment> sysEnv = LinuxDebSystemEnvironment.create(SYS_ENV);\n-}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxDebBundler.java","additions":0,"deletions":79,"binary":false,"changes":79,"status":"deleted"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.FromOptions.buildApplicationBuilder;\n+import static jdk.jpackage.internal.FromOptions.createPackageBuilder;\n+import static jdk.jpackage.internal.LinuxPackagingPipeline.APPLICATION_LAYOUT;\n+import static jdk.jpackage.internal.cli.StandardOption.LINUX_APP_CATEGORY;\n+import static jdk.jpackage.internal.cli.StandardOption.LINUX_DEB_MAINTAINER_EMAIL;\n+import static jdk.jpackage.internal.cli.StandardOption.LINUX_MENU_GROUP;\n+import static jdk.jpackage.internal.cli.StandardOption.LINUX_PACKAGE_DEPENDENCIES;\n+import static jdk.jpackage.internal.cli.StandardOption.LINUX_PACKAGE_NAME;\n+import static jdk.jpackage.internal.cli.StandardOption.LINUX_RELEASE;\n+import static jdk.jpackage.internal.cli.StandardOption.LINUX_RPM_LICENSE_TYPE;\n+import static jdk.jpackage.internal.cli.StandardOption.LINUX_SHORTCUT_HINT;\n+import static jdk.jpackage.internal.model.StandardPackageType.LINUX_DEB;\n+import static jdk.jpackage.internal.model.StandardPackageType.LINUX_RPM;\n+\n+import jdk.jpackage.internal.cli.Options;\n+import jdk.jpackage.internal.model.Launcher;\n+import jdk.jpackage.internal.model.LinuxApplication;\n+import jdk.jpackage.internal.model.LinuxDebPackage;\n+import jdk.jpackage.internal.model.LinuxLauncher;\n+import jdk.jpackage.internal.model.LinuxLauncherMixin;\n+import jdk.jpackage.internal.model.LinuxRpmPackage;\n+import jdk.jpackage.internal.model.StandardPackageType;\n+\n+final class LinuxFromOptions {\n+\n+    static LinuxApplication createLinuxApplication(Options options) {\n+\n+        final var launcherFromOptions = new LauncherFromOptions().faWithDefaultDescription();\n+\n+        final var appBuilder = buildApplicationBuilder().create(options, launcherOptions -> {\n+\n+            final var launcher = launcherFromOptions.create(launcherOptions);\n+\n+            final var shortcut = LINUX_SHORTCUT_HINT.findIn(launcherOptions);\n+\n+            return LinuxLauncher.create(launcher, new LinuxLauncherMixin.Stub(shortcut));\n+\n+        }, (LinuxLauncher linuxLauncher, Launcher launcher) -> {\n+            return LinuxLauncher.create(launcher, linuxLauncher);\n+        }, APPLICATION_LAYOUT);\n+\n+        appBuilder.launchers().map(LinuxPackagingPipeline::normalizeShortcuts).ifPresent(appBuilder::launchers);\n+\n+        return LinuxApplication.create(appBuilder.create());\n+    }\n+\n+    static LinuxRpmPackage createLinuxRpmPackage(Options options) {\n+\n+        final var superPkgBuilder = createLinuxPackageBuilder(options, LINUX_RPM);\n+\n+        final var pkgBuilder = new LinuxRpmPackageBuilder(superPkgBuilder);\n+\n+        LINUX_RPM_LICENSE_TYPE.ifPresentIn(options, pkgBuilder::licenseType);\n+\n+        return pkgBuilder.create();\n+    }\n+\n+    static LinuxDebPackage createLinuxDebPackage(Options options) {\n+\n+        final var superPkgBuilder = createLinuxPackageBuilder(options, LINUX_DEB);\n+\n+        final var pkgBuilder = new LinuxDebPackageBuilder(superPkgBuilder);\n+\n+        LINUX_DEB_MAINTAINER_EMAIL.ifPresentIn(options, pkgBuilder::maintainerEmail);\n+\n+        final var pkg = pkgBuilder.create();\n+\n+        \/\/ Show warning if license file is missing\n+        if (pkg.licenseFile().isEmpty()) {\n+            Log.verbose(I18N.getString(\"message.debs-like-licenses\"));\n+        }\n+\n+        return pkg;\n+    }\n+\n+    private static LinuxPackageBuilder createLinuxPackageBuilder(Options options, StandardPackageType type) {\n+\n+        final var app = createLinuxApplication(options);\n+\n+        final var superPkgBuilder = createPackageBuilder(options, app, type);\n+\n+        final var pkgBuilder = new LinuxPackageBuilder(superPkgBuilder);\n+\n+        LINUX_PACKAGE_DEPENDENCIES.ifPresentIn(options, pkgBuilder::additionalDependencies);\n+        LINUX_APP_CATEGORY.ifPresentIn(options, pkgBuilder::category);\n+        LINUX_MENU_GROUP.ifPresentIn(options, pkgBuilder::menuGroupName);\n+        LINUX_RELEASE.ifPresentIn(options, pkgBuilder::release);\n+        LINUX_PACKAGE_NAME.ifPresentIn(options, pkgBuilder::literalName);\n+\n+        return pkgBuilder;\n+    }\n+\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxFromOptions.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -1,146 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import static jdk.jpackage.internal.BundlerParamInfo.createStringBundlerParam;\n-import static jdk.jpackage.internal.FromParams.createApplicationBuilder;\n-import static jdk.jpackage.internal.FromParams.createApplicationBundlerParam;\n-import static jdk.jpackage.internal.FromParams.createPackageBuilder;\n-import static jdk.jpackage.internal.FromParams.createPackageBundlerParam;\n-import static jdk.jpackage.internal.FromParams.findLauncherShortcut;\n-import static jdk.jpackage.internal.LinuxPackagingPipeline.APPLICATION_LAYOUT;\n-import static jdk.jpackage.internal.model.StandardPackageType.LINUX_DEB;\n-import static jdk.jpackage.internal.model.StandardPackageType.LINUX_RPM;\n-import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n-\n-import java.io.IOException;\n-import java.util.Map;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.LinuxApplication;\n-import jdk.jpackage.internal.model.LinuxDebPackage;\n-import jdk.jpackage.internal.model.LinuxLauncher;\n-import jdk.jpackage.internal.model.LinuxLauncherMixin;\n-import jdk.jpackage.internal.model.LinuxRpmPackage;\n-import jdk.jpackage.internal.model.Launcher;\n-import jdk.jpackage.internal.model.StandardPackageType;\n-\n-final class LinuxFromParams {\n-\n-    private static LinuxApplication createLinuxApplication(\n-            Map<String, ? super Object> params) throws ConfigException, IOException {\n-        final var launcherFromParams = new LauncherFromParams();\n-\n-        final var app = createApplicationBuilder(params, toFunction(launcherParams -> {\n-            final var launcher = launcherFromParams.create(launcherParams);\n-            final var shortcut = findLauncherShortcut(LINUX_SHORTCUT_HINT, params, launcherParams);\n-            return LinuxLauncher.create(launcher, new LinuxLauncherMixin.Stub(shortcut));\n-        }), (LinuxLauncher linuxLauncher, Launcher launcher) -> {\n-            return LinuxLauncher.create(launcher, linuxLauncher);\n-        }, APPLICATION_LAYOUT).create();\n-        return LinuxApplication.create(app);\n-    }\n-\n-    private static LinuxPackageBuilder createLinuxPackageBuilder(\n-            Map<String, ? super Object> params, StandardPackageType type) throws ConfigException, IOException {\n-\n-        final var app = APPLICATION.fetchFrom(params);\n-\n-        final var superPkgBuilder = createPackageBuilder(params, app, type);\n-\n-        final var pkgBuilder = new LinuxPackageBuilder(superPkgBuilder);\n-\n-        LINUX_PACKAGE_DEPENDENCIES.copyInto(params, pkgBuilder::additionalDependencies);\n-        LINUX_CATEGORY.copyInto(params, pkgBuilder::category);\n-        LINUX_MENU_GROUP.copyInto(params, pkgBuilder::menuGroupName);\n-        RELEASE.copyInto(params, pkgBuilder::release);\n-        LINUX_PACKAGE_NAME.copyInto(params, pkgBuilder::literalName);\n-\n-        return pkgBuilder;\n-    }\n-\n-    private static LinuxRpmPackage createLinuxRpmPackage(\n-            Map<String, ? super Object> params) throws ConfigException, IOException {\n-\n-        final var superPkgBuilder = createLinuxPackageBuilder(params, LINUX_RPM);\n-\n-        final var pkgBuilder = new LinuxRpmPackageBuilder(superPkgBuilder);\n-\n-        LICENSE_TYPE.copyInto(params, pkgBuilder::licenseType);\n-\n-        return pkgBuilder.create();\n-    }\n-\n-    private static LinuxDebPackage createLinuxDebPackage(\n-            Map<String, ? super Object> params) throws ConfigException, IOException {\n-\n-        final var superPkgBuilder = createLinuxPackageBuilder(params, LINUX_DEB);\n-\n-        final var pkgBuilder = new LinuxDebPackageBuilder(superPkgBuilder);\n-\n-        MAINTAINER_EMAIL.copyInto(params, pkgBuilder::maintainerEmail);\n-\n-        final var pkg = pkgBuilder.create();\n-\n-        \/\/ Show warning if license file is missing\n-        if (pkg.licenseFile().isEmpty()) {\n-            Log.verbose(I18N.getString(\"message.debs-like-licenses\"));\n-        }\n-\n-        return pkg;\n-    }\n-\n-    static final BundlerParamInfo<LinuxApplication> APPLICATION = createApplicationBundlerParam(\n-            LinuxFromParams::createLinuxApplication);\n-\n-    static final BundlerParamInfo<LinuxRpmPackage> RPM_PACKAGE = createPackageBundlerParam(\n-            LinuxFromParams::createLinuxRpmPackage);\n-\n-    static final BundlerParamInfo<LinuxDebPackage> DEB_PACKAGE = createPackageBundlerParam(\n-            LinuxFromParams::createLinuxDebPackage);\n-\n-    private static final BundlerParamInfo<String> LINUX_SHORTCUT_HINT = createStringBundlerParam(\n-            Arguments.CLIOptions.LINUX_SHORTCUT_HINT.getId());\n-\n-    private static final BundlerParamInfo<String> LINUX_CATEGORY = createStringBundlerParam(\n-            Arguments.CLIOptions.LINUX_CATEGORY.getId());\n-\n-    private static final BundlerParamInfo<String> LINUX_PACKAGE_DEPENDENCIES = createStringBundlerParam(\n-            Arguments.CLIOptions.LINUX_PACKAGE_DEPENDENCIES.getId());\n-\n-    private static final BundlerParamInfo<String> LINUX_MENU_GROUP = createStringBundlerParam(\n-            Arguments.CLIOptions.LINUX_MENU_GROUP.getId());\n-\n-    private static final BundlerParamInfo<String> RELEASE = createStringBundlerParam(\n-            Arguments.CLIOptions.RELEASE.getId());\n-\n-    private static final BundlerParamInfo<String> LINUX_PACKAGE_NAME = createStringBundlerParam(\n-            Arguments.CLIOptions.LINUX_BUNDLE_NAME.getId());\n-\n-    private static final BundlerParamInfo<String> LICENSE_TYPE = createStringBundlerParam(\n-            Arguments.CLIOptions.LINUX_RPM_LICENSE_TYPE.getId());\n-\n-    private static final BundlerParamInfo<String> MAINTAINER_EMAIL = createStringBundlerParam(\n-            Arguments.CLIOptions.LINUX_DEB_MAINTAINER.getId());\n-}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxFromParams.java","additions":0,"deletions":146,"binary":false,"changes":146,"status":"deleted"},{"patch":"@@ -1,88 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import java.util.Map;\n-import java.util.Objects;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.LinuxPackage;\n-import jdk.jpackage.internal.util.Result;\n-\n-abstract class LinuxPackageBundler extends AbstractBundler {\n-\n-    LinuxPackageBundler(BundlerParamInfo<? extends LinuxPackage> pkgParam) {\n-        this.pkgParam = Objects.requireNonNull(pkgParam);\n-    }\n-\n-    @Override\n-    public final boolean validate(Map<String, ? super Object> params)\n-            throws ConfigException {\n-\n-        \/\/ Order is important!\n-        pkgParam.fetchFrom(params);\n-        BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n-\n-        LinuxSystemEnvironment sysEnv;\n-        try {\n-            sysEnv = sysEnv().orElseThrow();\n-        } catch (RuntimeException ex) {\n-            throw ConfigException.rethrowConfigException(ex);\n-        }\n-\n-        if (!isDefault()) {\n-            Log.verbose(I18N.format(\n-                    \"message.not-default-bundler-no-dependencies-lookup\",\n-                    getName()));\n-        } else if (!sysEnv.soLookupAvailable()) {\n-            final String advice;\n-            if (\"deb\".equals(getID())) {\n-                advice = \"message.deb-ldd-not-available.advice\";\n-            } else {\n-                advice = \"message.rpm-ldd-not-available.advice\";\n-            }\n-            \/\/ Let user know package dependencies will not be generated.\n-            Log.error(String.format(\"%s\\n%s\", I18N.getString(\n-                    \"message.ldd-not-available\"), I18N.getString(advice)));\n-        }\n-\n-        return true;\n-    }\n-\n-    @Override\n-    public final String getBundleType() {\n-        return \"INSTALLER\";\n-    }\n-\n-    @Override\n-    public boolean supported(boolean runtimeInstaller) {\n-        return sysEnv().hasValue();\n-    }\n-\n-    protected abstract Result<? extends LinuxSystemEnvironment> sysEnv();\n-\n-    private final BundlerParamInfo<? extends LinuxPackage> pkgParam;\n-\n-    static final Result<LinuxSystemEnvironment> SYS_ENV = LinuxSystemEnvironment.create();\n-}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxPackageBundler.java","additions":0,"deletions":88,"binary":false,"changes":88,"status":"deleted"},{"patch":"@@ -43,1 +43,0 @@\n-import jdk.jpackage.internal.model.PackagerException;\n@@ -98,1 +97,1 @@\n-    private void buildConfigFiles() throws PackagerException, IOException {\n+    private void buildConfigFiles() throws IOException {\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxPackager.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import static jdk.jpackage.internal.ApplicationBuilder.normalizeLauncherProperty;\n@@ -39,0 +40,1 @@\n+import jdk.jpackage.internal.model.ApplicationLaunchers;\n@@ -41,0 +43,3 @@\n+import jdk.jpackage.internal.model.LauncherShortcut;\n+import jdk.jpackage.internal.model.LinuxLauncher;\n+import jdk.jpackage.internal.model.LinuxLauncherMixin;\n@@ -67,0 +72,11 @@\n+    static ApplicationLaunchers normalizeShortcuts(ApplicationLaunchers appLaunchers) {\n+        return normalizeLauncherProperty(appLaunchers, launcher -> {\n+            \/\/ Return \"true\" if shortcut is not configured for the launcher.\n+            return launcher.shortcut().isEmpty();\n+        }, (LinuxLauncher launcher) -> {\n+            return launcher.shortcut().flatMap(LauncherShortcut::startupDirectory);\n+        }, (launcher, shortcut) -> {\n+            return LinuxLauncher.create(launcher, new LinuxLauncherMixin.Stub(Optional.of(new LauncherShortcut(shortcut))));\n+        });\n+    }\n+\n@@ -93,0 +109,9 @@\n+    private static final ApplicationLayout LINUX_APPLICATION_LAYOUT = ApplicationLayout.build()\n+            .launchersDirectory(\"bin\")\n+            .appDirectory(\"lib\/app\")\n+            .runtimeDirectory(\"lib\/runtime\")\n+            .desktopIntegrationDirectory(\"lib\")\n+            .appModsDirectory(\"lib\/app\/mods\")\n+            .contentDirectory(\"lib\")\n+            .create();\n+\n@@ -94,1 +119,1 @@\n-            ApplicationLayoutUtils.PLATFORM_APPLICATION_LAYOUT, Path.of(\"lib\/libapplauncher.so\"));\n+            LINUX_APPLICATION_LAYOUT, Path.of(\"lib\/libapplauncher.so\"));\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxPackagingPipeline.java","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.nio.file.Path;\n-import java.util.Map;\n-import java.util.Optional;\n-import jdk.jpackage.internal.model.LinuxRpmPackage;\n-import jdk.jpackage.internal.model.PackagerException;\n-import jdk.jpackage.internal.model.StandardPackageType;\n-import jdk.jpackage.internal.util.Result;\n-\n-\n-public class LinuxRpmBundler extends LinuxPackageBundler {\n-\n-    public LinuxRpmBundler() {\n-        super(LinuxFromParams.RPM_PACKAGE);\n-    }\n-\n-    @Override\n-    public String getName() {\n-        return I18N.getString(\"rpm.bundler.name\");\n-    }\n-\n-    @Override\n-    public String getID() {\n-        return \"rpm\";\n-    }\n-\n-    @Override\n-    public Path execute(Map<String, ? super Object> params, Path outputParentDir) throws PackagerException {\n-\n-        var pkg = LinuxFromParams.RPM_PACKAGE.fetchFrom(params);\n-\n-        return Packager.<LinuxRpmPackage>build().outputDir(outputParentDir)\n-                .pkg(pkg)\n-                .env(BuildEnvFromParams.BUILD_ENV.fetchFrom(params))\n-                .pipelineBuilderMutatorFactory((env, _, outputDir) -> {\n-                    return new LinuxRpmPackager(env, pkg, outputDir, sysEnv.orElseThrow());\n-                }).execute(LinuxPackagingPipeline.build(Optional.of(pkg)));\n-    }\n-\n-    @Override\n-    protected Result<LinuxRpmSystemEnvironment> sysEnv() {\n-        return sysEnv;\n-    }\n-\n-    @Override\n-    public boolean isDefault() {\n-        return sysEnv.value()\n-                .map(LinuxSystemEnvironment::nativePackageType)\n-                .map(StandardPackageType.LINUX_RPM::equals)\n-                .orElse(false);\n-    }\n-\n-    private final Result<LinuxRpmSystemEnvironment> sysEnv = LinuxRpmSystemEnvironment.create(SYS_ENV);\n-}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxRpmBundler.java","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -27,0 +27,2 @@\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.LINUX_LAUNCHER_SHORTCUT;\n+\n@@ -42,1 +44,1 @@\n-            shortcut.store(SHORTCUT_ID, map::put);\n+            shortcut.store(LINUX_LAUNCHER_SHORTCUT.getName(), map::put);\n@@ -58,2 +60,0 @@\n-\n-    public static final String SHORTCUT_ID = \"linux-shortcut\";\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/model\/LinuxLauncher.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,4 +26,0 @@\n-app.bundler.name=Linux Application Image\n-deb.bundler.name=DEB Bundle\n-rpm.bundler.name=RPM Bundle\n-\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/resources\/LinuxResources.properties","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,5 +26,2 @@\n-provides jdk.jpackage.internal.Bundler with\n-    jdk.jpackage.internal.LinuxAppBundler,\n-    jdk.jpackage.internal.LinuxDebBundler,\n-    jdk.jpackage.internal.LinuxRpmBundler;\n-\n+provides jdk.jpackage.internal.cli.CliBundlingEnvironment with\n+    jdk.jpackage.internal.LinuxBundlingEnvironment;\n","filename":"src\/jdk.jpackage\/linux\/classes\/module-info.java.extra","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,81 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import static jdk.jpackage.internal.StandardBundlerParam.OUTPUT_DIR;\n-import static jdk.jpackage.internal.StandardBundlerParam.SIGN_BUNDLE;\n-\n-import java.util.Map;\n-import java.util.Optional;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.util.function.ExceptionBox;\n-\n-public class MacAppBundler extends AppImageBundler {\n-     public MacAppBundler() {\n-         setAppImageSupplier((params, output) -> {\n-\n-             \/\/ Order is important!\n-             final var app = MacFromParams.APPLICATION.fetchFrom(params);\n-             final BuildEnv env;\n-\n-             if (StandardBundlerParam.hasPredefinedAppImage(params)) {\n-                 env = MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n-                 final var pkg = MacPackagingPipeline.createSignAppImagePackage(app, env);\n-                 MacPackagingPipeline.build(Optional.of(pkg)).create().execute(env, pkg, output);\n-             } else {\n-                 env = BuildEnv.withAppImageDir(MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params), output);\n-                 MacPackagingPipeline.build(Optional.empty())\n-                         .excludeDirFromCopying(output.getParent())\n-                         .excludeDirFromCopying(OUTPUT_DIR.fetchFrom(params)).create().execute(env, app);\n-             }\n-\n-         });\n-         setParamsValidator(MacAppBundler::doValidate);\n-    }\n-\n-    private static void doValidate(Map<String, ? super Object> params)\n-            throws ConfigException {\n-\n-        try {\n-            MacFromParams.APPLICATION.fetchFrom(params);\n-        } catch (ExceptionBox ex) {\n-            if (ex.getCause() instanceof ConfigException cfgEx) {\n-                throw cfgEx;\n-            } else {\n-                throw ex;\n-            }\n-        }\n-\n-        if (StandardBundlerParam.hasPredefinedAppImage(params)) {\n-            if (!Optional.ofNullable(\n-                    SIGN_BUNDLE.fetchFrom(params)).orElse(Boolean.FALSE)) {\n-                throw new ConfigException(\n-                        I18N.getString(\"error.app-image.mac-sign.required\"),\n-                        null);\n-            }\n-        }\n-    }\n-}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacAppBundler.java","additions":0,"deletions":81,"binary":false,"changes":81,"status":"deleted"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import static jdk.jpackage.internal.AppImageFile.getBooleanExtraFieldValue;\n-\n-import jdk.jpackage.internal.model.ExternalApplication;\n-import jdk.jpackage.internal.model.MacApplication.ExtraAppImageFileField;\n-\n-record MacAppImageFileExtras(boolean signed, boolean appStore) {\n-\n-    MacAppImageFileExtras(ExternalApplication app) {\n-        this(getBooleanExtraFieldValue(ExtraAppImageFileField.SIGNED.fieldName(), app),\n-                getBooleanExtraFieldValue(ExtraAppImageFileField.APP_STORE.fieldName(), app));\n-    }\n-}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacAppImageFileExtras.java","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE;\n-\n-import java.util.Map;\n-import jdk.jpackage.internal.model.ConfigException;\n-\n-public abstract class MacBaseInstallerBundler extends AbstractBundler {\n-\n-    public MacBaseInstallerBundler() {\n-        appImageBundler = new MacAppBundler();\n-    }\n-\n-    protected void validateAppImageAndBundeler(\n-            Map<String, ? super Object> params) throws ConfigException {\n-        if (PREDEFINED_APP_IMAGE.fetchFrom(params) == null) {\n-            appImageBundler.validate(params);\n-        }\n-    }\n-\n-    @Override\n-    public String getBundleType() {\n-        return \"INSTALLER\";\n-    }\n-\n-    private final Bundler appImageBundler;\n-}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacBaseInstallerBundler.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import jdk.jpackage.internal.model.MacPackage;\n-\n-final class MacBuildEnvFromParams {\n-\n-    static final BundlerParamInfo<BuildEnv> BUILD_ENV = BundlerParamInfo.createBundlerParam(BuildEnv.class, params -> {\n-        return BuildEnvFromParams.create(params, MacPackagingPipeline.APPLICATION_LAYOUT::resolveAt, MacPackage::guessRuntimeLayout);\n-    });\n-}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacBuildEnvFromParams.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.MacFromOptions.createMacApplication;\n+import static jdk.jpackage.internal.MacPackagingPipeline.APPLICATION_LAYOUT;\n+import static jdk.jpackage.internal.MacPackagingPipeline.createSignAppImagePackage;\n+import static jdk.jpackage.internal.cli.StandardBundlingOperation.CREATE_MAC_APP_IMAGE;\n+import static jdk.jpackage.internal.cli.StandardBundlingOperation.CREATE_MAC_DMG;\n+import static jdk.jpackage.internal.cli.StandardBundlingOperation.CREATE_MAC_PKG;\n+import static jdk.jpackage.internal.cli.StandardBundlingOperation.SIGN_MAC_APP_IMAGE;\n+\n+import java.util.Optional;\n+import jdk.jpackage.internal.cli.Options;\n+import jdk.jpackage.internal.model.MacPackage;\n+import jdk.jpackage.internal.model.Package;\n+import jdk.jpackage.internal.util.Result;\n+\n+public class MacBundlingEnvironment extends DefaultBundlingEnvironment {\n+\n+    public MacBundlingEnvironment() {\n+        super(build()\n+                .defaultOperation(CREATE_MAC_DMG)\n+                .bundler(SIGN_MAC_APP_IMAGE, MacBundlingEnvironment::signAppImage)\n+                .bundler(CREATE_MAC_APP_IMAGE, MacBundlingEnvironment::createAppImage)\n+                .bundler(CREATE_MAC_DMG, LazyLoad::dmgSysEnv, MacBundlingEnvironment::createDmdPackage)\n+                .bundler(CREATE_MAC_PKG, MacBundlingEnvironment::createPkgPackage));\n+    }\n+\n+    private static void createDmdPackage(Options options, MacDmgSystemEnvironment sysEnv) {\n+        createNativePackage(options,\n+                MacFromOptions::createMacDmgPackage,\n+                buildEnv()::create,\n+                MacBundlingEnvironment::buildPipeline,\n+                (env, pkg, outputDir) -> {\n+                    Log.verbose(I18N.format(\"message.building-dmg\", pkg.app().name()));\n+                    return new MacDmgPackager(env, pkg, outputDir, sysEnv);\n+                });\n+    }\n+\n+    private static void createPkgPackage(Options options) {\n+        createNativePackage(options,\n+                MacFromOptions::createMacPkgPackage,\n+                buildEnv()::create,\n+                MacBundlingEnvironment::buildPipeline,\n+                (env, pkg, outputDir) -> {\n+                    Log.verbose(I18N.format(\"message.building-pkg\", pkg.app().name()));\n+                    return new MacPkgPackager(env, pkg, outputDir);\n+                });\n+    }\n+\n+    private static void signAppImage(Options options) {\n+\n+        final var app = createMacApplication(options);\n+\n+        final var env = buildEnv().create(options, app);\n+\n+        final var pkg = createSignAppImagePackage(app, env);\n+\n+        buildPipeline(pkg).create().execute(env, pkg, env.appImageDir());\n+    }\n+\n+    private static void createAppImage(Options options) {\n+\n+        final var app = createMacApplication(options);\n+\n+        createApplicationImage(options, app, MacPackagingPipeline.build(Optional.empty()));\n+    }\n+\n+    private static PackagingPipeline.Builder buildPipeline(Package pkg) {\n+        return MacPackagingPipeline.build(Optional.of(pkg));\n+    }\n+\n+    private static BuildEnvFromOptions buildEnv() {\n+        return new BuildEnvFromOptions()\n+                .predefinedAppImageLayout(APPLICATION_LAYOUT)\n+                .predefinedRuntimeImageLayout(MacPackage::guessRuntimeLayout);\n+    }\n+\n+    private static final class LazyLoad {\n+\n+        static Result<MacDmgSystemEnvironment> dmgSysEnv() {\n+            return DMG_SYS_ENV;\n+        }\n+\n+        private static final Result<MacDmgSystemEnvironment> DMG_SYS_ENV = MacDmgSystemEnvironment.create();\n+    }\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacBundlingEnvironment.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -1,98 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.nio.file.Path;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.MacDmgPackage;\n-import jdk.jpackage.internal.model.PackagerException;\n-import jdk.jpackage.internal.util.Result;\n-\n-public class MacDmgBundler extends MacBaseInstallerBundler {\n-\n-    @Override\n-    public String getName() {\n-        return I18N.getString(\"dmg.bundler.name\");\n-    }\n-\n-    @Override\n-    public String getID() {\n-        return \"dmg\";\n-    }\n-\n-    @Override\n-    public boolean validate(Map<String, ? super Object> params)\n-            throws ConfigException {\n-        try {\n-            Objects.requireNonNull(params);\n-\n-            MacFromParams.DMG_PACKAGE.fetchFrom(params);\n-\n-            \/\/run basic validation to ensure requirements are met\n-            \/\/we are not interested in return code, only possible exception\n-            validateAppImageAndBundeler(params);\n-\n-            return true;\n-        } catch (RuntimeException re) {\n-            if (re.getCause() instanceof ConfigException) {\n-                throw (ConfigException) re.getCause();\n-            } else {\n-                throw new ConfigException(re);\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public Path execute(Map<String, ? super Object> params,\n-            Path outputParentDir) throws PackagerException {\n-\n-        var pkg = MacFromParams.DMG_PACKAGE.fetchFrom(params);\n-\n-        Log.verbose(I18N.format(\"message.building-dmg\", pkg.app().name()));\n-\n-        return Packager.<MacDmgPackage>build().outputDir(outputParentDir)\n-                .pkg(pkg)\n-                .env(MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params))\n-                .pipelineBuilderMutatorFactory((env, _, outputDir) -> {\n-                    return new MacDmgPackager(env, pkg, outputDir, sysEnv.orElseThrow());\n-                }).execute(MacPackagingPipeline.build(Optional.of(pkg)));\n-    }\n-\n-    @Override\n-    public boolean supported(boolean runtimeInstaller) {\n-        return sysEnv.hasValue();\n-    }\n-\n-    @Override\n-    public boolean isDefault() {\n-        return true;\n-    }\n-\n-    private final Result<MacDmgSystemEnvironment> sysEnv = MacDmgSystemEnvironment.create();\n-}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgBundler.java","additions":0,"deletions":98,"binary":false,"changes":98,"status":"deleted"},{"patch":"@@ -0,0 +1,331 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.FromOptions.buildApplicationBuilder;\n+import static jdk.jpackage.internal.FromOptions.createPackageBuilder;\n+import static jdk.jpackage.internal.MacPackagingPipeline.APPLICATION_LAYOUT;\n+import static jdk.jpackage.internal.MacRuntimeValidator.validateRuntimeHasJliLib;\n+import static jdk.jpackage.internal.MacRuntimeValidator.validateRuntimeHasNoBinDir;\n+import static jdk.jpackage.internal.cli.StandardBundlingOperation.SIGN_MAC_APP_IMAGE;\n+import static jdk.jpackage.internal.cli.StandardOption.ICON;\n+import static jdk.jpackage.internal.cli.StandardOption.APPCLASS;\n+import static jdk.jpackage.internal.cli.StandardOption.MAC_APP_CATEGORY;\n+import static jdk.jpackage.internal.cli.StandardOption.MAC_APP_IMAGE_SIGN_IDENTITY;\n+import static jdk.jpackage.internal.cli.StandardOption.MAC_APP_STORE;\n+import static jdk.jpackage.internal.cli.StandardOption.MAC_BUNDLE_IDENTIFIER;\n+import static jdk.jpackage.internal.cli.StandardOption.MAC_BUNDLE_NAME;\n+import static jdk.jpackage.internal.cli.StandardOption.MAC_BUNDLE_SIGNING_PREFIX;\n+import static jdk.jpackage.internal.cli.StandardOption.MAC_DMG_CONTENT;\n+import static jdk.jpackage.internal.cli.StandardOption.MAC_ENTITLEMENTS;\n+import static jdk.jpackage.internal.cli.StandardOption.MAC_INSTALLER_SIGN_IDENTITY;\n+import static jdk.jpackage.internal.cli.StandardOption.MAC_SIGN;\n+import static jdk.jpackage.internal.cli.StandardOption.MAC_SIGNING_KEYCHAIN;\n+import static jdk.jpackage.internal.cli.StandardOption.MAC_SIGNING_KEY_NAME;\n+import static jdk.jpackage.internal.cli.StandardOption.PREDEFINED_APP_IMAGE;\n+import static jdk.jpackage.internal.cli.StandardOption.PREDEFINED_RUNTIME_IMAGE;\n+import static jdk.jpackage.internal.model.MacPackage.RUNTIME_BUNDLE_LAYOUT;\n+import static jdk.jpackage.internal.model.StandardPackageType.MAC_DMG;\n+import static jdk.jpackage.internal.model.StandardPackageType.MAC_PKG;\n+import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+import jdk.jpackage.internal.ApplicationBuilder.MainLauncherStartupInfo;\n+import jdk.jpackage.internal.SigningIdentityBuilder.ExpiredCertificateException;\n+import jdk.jpackage.internal.SigningIdentityBuilder.StandardCertificateSelector;\n+import jdk.jpackage.internal.cli.Options;\n+import jdk.jpackage.internal.cli.StandardFaOption;\n+import jdk.jpackage.internal.model.ApplicationLaunchers;\n+import jdk.jpackage.internal.model.ExternalApplication;\n+import jdk.jpackage.internal.model.FileAssociation;\n+import jdk.jpackage.internal.model.Launcher;\n+import jdk.jpackage.internal.model.MacApplication;\n+import jdk.jpackage.internal.model.MacDmgPackage;\n+import jdk.jpackage.internal.model.MacFileAssociation;\n+import jdk.jpackage.internal.model.MacLauncher;\n+import jdk.jpackage.internal.model.MacPackage;\n+import jdk.jpackage.internal.model.MacPkgPackage;\n+import jdk.jpackage.internal.model.PackageType;\n+import jdk.jpackage.internal.model.RuntimeLayout;\n+import jdk.jpackage.internal.util.Result;\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n+\n+\n+final class MacFromOptions {\n+\n+    static MacApplication createMacApplication(Options options) {\n+        return createMacApplicationInternal(options).app();\n+    }\n+\n+    static MacDmgPackage createMacDmgPackage(Options options) {\n+\n+        final var app = createMacApplicationInternal(options);\n+\n+        final var superPkgBuilder = createMacPackageBuilder(options, app, MAC_DMG);\n+\n+        final var pkgBuilder = new MacDmgPackageBuilder(superPkgBuilder);\n+\n+        MAC_DMG_CONTENT.ifPresentIn(options, pkgBuilder::dmgContent);\n+\n+        return pkgBuilder.create();\n+    }\n+\n+    static MacPkgPackage createMacPkgPackage(Options options) {\n+\n+        \/\/\n+        \/\/ One of \"MacSignTest.testExpiredCertificate\" test cases expects\n+        \/\/ two error messages about expired certificates in the output: one for\n+        \/\/ certificate for signing an app image, another certificate for signing a PKG.\n+        \/\/ So creation of a PKG package is a bit messy.\n+        \/\/\n+\n+        final boolean sign = MAC_SIGN.findIn(options).orElse(false);\n+        final boolean appStore = MAC_APP_STORE.findIn(options).orElse(false);\n+\n+        final var appResult = Result.create(() -> createMacApplicationInternal(options));\n+\n+        final Optional<MacPkgPackageBuilder> pkgBuilder;\n+        if (appResult.hasValue()) {\n+            final var superPkgBuilder = createMacPackageBuilder(options, appResult.orElseThrow(), MAC_PKG);\n+            pkgBuilder = Optional.of(new MacPkgPackageBuilder(superPkgBuilder));\n+        } else {\n+            \/\/ Failed to create an app. Is it because of the expired certificate?\n+            rethrowIfNotExpiredCertificateException(appResult);\n+            \/\/ Yes, the certificate for signing the app image has expired.\n+            \/\/ Keep going, try to create a signing config for the package.\n+            pkgBuilder = Optional.empty();\n+        }\n+\n+        if (sign) {\n+            final var signingIdentityBuilder = createSigningIdentityBuilder(options);\n+            MAC_INSTALLER_SIGN_IDENTITY.ifPresentIn(options, signingIdentityBuilder::signingIdentity);\n+            MAC_SIGNING_KEY_NAME.findIn(options).ifPresent(userName -> {\n+                final StandardCertificateSelector domain;\n+                if (appStore) {\n+                    domain = StandardCertificateSelector.APP_STORE_PKG_INSTALLER;\n+                } else {\n+                    domain = StandardCertificateSelector.PKG_INSTALLER;\n+                }\n+\n+                signingIdentityBuilder.certificateSelector(StandardCertificateSelector.create(userName, domain));\n+            });\n+\n+            if (pkgBuilder.isPresent()) {\n+                pkgBuilder.orElseThrow().signingBuilder(signingIdentityBuilder);\n+            } else {\n+                \/\/\n+                \/\/ The certificate for signing the app image has expired. Can not create a\n+                \/\/ package because there is no app.\n+                \/\/ Try to create a signing config for the package and see if the certificate for\n+                \/\/ signing the package is also expired.\n+                \/\/\n+\n+                final var expiredAppCertException = appResult.firstError().orElseThrow();\n+\n+                final var pkgSignConfigResult = Result.create(signingIdentityBuilder::create);\n+                try {\n+                    rethrowIfNotExpiredCertificateException(pkgSignConfigResult);\n+                    \/\/ The certificate for the package signing config is also expired!\n+                } catch (RuntimeException ex) {\n+                    \/\/ Some error occurred trying to configure the signing config for the package.\n+                    \/\/ Ignore it, bail out with the first error.\n+                    rethrowUnchecked(expiredAppCertException);\n+                }\n+\n+                Log.error(pkgSignConfigResult.firstError().orElseThrow().getMessage());\n+                rethrowUnchecked(expiredAppCertException);\n+            }\n+        }\n+\n+        return pkgBuilder.orElseThrow().create();\n+    }\n+\n+    private record ApplicationWithDetails(MacApplication app, Optional<ExternalApplication> externalApp) {\n+        ApplicationWithDetails {\n+            Objects.requireNonNull(app);\n+            Objects.requireNonNull(externalApp);\n+        }\n+    }\n+\n+    private static ApplicationWithDetails createMacApplicationInternal(Options options) {\n+\n+        final var predefinedRuntimeLayout = PREDEFINED_RUNTIME_IMAGE.findIn(options)\n+                .map(MacPackage::guessRuntimeLayout);\n+\n+        predefinedRuntimeLayout.ifPresent(layout -> {\n+            validateRuntimeHasJliLib(layout);\n+            if (MAC_APP_STORE.containsIn(options)) {\n+                validateRuntimeHasNoBinDir(layout);\n+            }\n+        });\n+\n+        final var launcherFromOptions = new LauncherFromOptions().faMapper(MacFromOptions::createMacFa);\n+\n+        final var superAppBuilder = buildApplicationBuilder()\n+                .runtimeLayout(RUNTIME_BUNDLE_LAYOUT)\n+                .predefinedRuntimeLayout(predefinedRuntimeLayout.map(RuntimeLayout::unresolve).orElse(null))\n+                .create(options, launcherOptions -> {\n+                    var launcher = launcherFromOptions.create(launcherOptions);\n+                    return MacLauncher.create(launcher);\n+                }, (MacLauncher _, Launcher launcher) -> {\n+                    return MacLauncher.create(launcher);\n+                }, APPLICATION_LAYOUT);\n+\n+        if (PREDEFINED_APP_IMAGE.containsIn(options)) {\n+            \/\/ Set the main launcher start up info.\n+            \/\/ AppImageFile assumes the main launcher start up info is available when\n+            \/\/ it is constructed from Application instance.\n+            \/\/ This happens when jpackage signs predefined app image.\n+            final var appImageFileOptions = superAppBuilder.externalApplication().orElseThrow().extra();\n+            final var mainLauncherStartupInfo = new MainLauncherStartupInfo(APPCLASS.getFrom(appImageFileOptions));\n+            final var launchers = superAppBuilder.launchers().orElseThrow();\n+            final var mainLauncher = ApplicationBuilder.overrideLauncherStartupInfo(launchers.mainLauncher(), mainLauncherStartupInfo);\n+            superAppBuilder.launchers(new ApplicationLaunchers(MacLauncher.create(mainLauncher), launchers.additionalLaunchers()));\n+        }\n+\n+        final var app = superAppBuilder.create();\n+\n+        final var appBuilder = new MacApplicationBuilder(app);\n+\n+        PREDEFINED_APP_IMAGE.findIn(options)\n+                .map(MacBundle::new)\n+                .map(MacBundle::infoPlistFile)\n+                .ifPresent(appBuilder::externalInfoPlistFile);\n+\n+        ICON.ifPresentIn(options, appBuilder::icon);\n+        MAC_BUNDLE_NAME.ifPresentIn(options, appBuilder::bundleName);\n+        MAC_BUNDLE_IDENTIFIER.ifPresentIn(options, appBuilder::bundleIdentifier);\n+        MAC_APP_CATEGORY.ifPresentIn(options, appBuilder::category);\n+\n+        final boolean sign;\n+        final boolean appStore;\n+\n+        if (PREDEFINED_APP_IMAGE.containsIn(options) && OptionUtils.bundlingOperation(options) != SIGN_MAC_APP_IMAGE) {\n+            final var appImageFileOptions = superAppBuilder.externalApplication().orElseThrow().extra();\n+            sign = MAC_SIGN.getFrom(appImageFileOptions);\n+            appStore = MAC_APP_STORE.getFrom(appImageFileOptions);\n+        } else {\n+            sign = MAC_SIGN.getFrom(options);\n+            appStore = MAC_APP_STORE.getFrom(options);\n+        }\n+\n+        appBuilder.appStore(appStore);\n+\n+        if (sign) {\n+            final var signingIdentityBuilder = createSigningIdentityBuilder(options);\n+            MAC_APP_IMAGE_SIGN_IDENTITY.ifPresentIn(options, signingIdentityBuilder::signingIdentity);\n+            MAC_SIGNING_KEY_NAME.findIn(options).ifPresent(userName -> {\n+                final StandardCertificateSelector domain;\n+                if (appStore) {\n+                    domain = StandardCertificateSelector.APP_STORE_APP_IMAGE;\n+                } else {\n+                    domain = StandardCertificateSelector.APP_IMAGE;\n+                }\n+\n+                signingIdentityBuilder.certificateSelector(StandardCertificateSelector.create(userName, domain));\n+            });\n+\n+            final var signingBuilder = new AppImageSigningConfigBuilder(signingIdentityBuilder);\n+            if (appStore) {\n+                signingBuilder.entitlementsResourceName(\"sandbox.plist\");\n+            }\n+\n+            app.mainLauncher().flatMap(Launcher::startupInfo).ifPresentOrElse(\n+                signingBuilder::signingIdentifierPrefix,\n+                () -> {\n+                    \/\/ Runtime installer does not have the main launcher, use\n+                    \/\/ 'bundleIdentifier' as the prefix by default.\n+                    var bundleIdentifier = appBuilder.create().bundleIdentifier();\n+                    signingBuilder.signingIdentifierPrefix(bundleIdentifier + \".\");\n+                });\n+            MAC_BUNDLE_SIGNING_PREFIX.ifPresentIn(options, signingBuilder::signingIdentifierPrefix);\n+\n+            MAC_ENTITLEMENTS.ifPresentIn(options, signingBuilder::entitlements);\n+\n+            appBuilder.signingBuilder(signingBuilder);\n+        }\n+\n+        return new ApplicationWithDetails(appBuilder.create(), superAppBuilder.externalApplication());\n+    }\n+\n+    private static MacPackageBuilder createMacPackageBuilder(Options options, ApplicationWithDetails app, PackageType type) {\n+\n+        final var builder = new MacPackageBuilder(createPackageBuilder(options, app.app(), type));\n+\n+        app.externalApp()\n+                .map(ExternalApplication::extra)\n+                .flatMap(MAC_SIGN::findIn)\n+                .ifPresent(builder::predefinedAppImageSigned);\n+\n+        PREDEFINED_RUNTIME_IMAGE.findIn(options)\n+                .map(MacBundle::new)\n+                .filter(MacBundle::isValid)\n+                .map(MacBundle::isSigned)\n+                .ifPresent(builder::predefinedAppImageSigned);\n+\n+        return builder;\n+    }\n+\n+    private static void rethrowIfNotExpiredCertificateException(Result<?> result) {\n+        final var ex = result.firstError().orElseThrow();\n+\n+        if (ex instanceof ExpiredCertificateException) {\n+            return;\n+        }\n+\n+        if (ex instanceof ExceptionBox box) {\n+            if (box.getCause() instanceof Exception cause) {\n+                rethrowIfNotExpiredCertificateException(Result.ofError(cause));\n+            }\n+        }\n+\n+        rethrowUnchecked(ex);\n+    }\n+\n+    private static SigningIdentityBuilder createSigningIdentityBuilder(Options options) {\n+        final var builder = new SigningIdentityBuilder();\n+        MAC_SIGNING_KEYCHAIN.findIn(options).map(Path::toString).ifPresent(builder::keychain);\n+        return builder;\n+    }\n+\n+    private static MacFileAssociation createMacFa(Options options, FileAssociation fa) {\n+\n+        final var builder = new MacFileAssociationBuilder();\n+\n+        StandardFaOption.MAC_CFBUNDLETYPEROLE.ifPresentIn(options, builder::cfBundleTypeRole);\n+        StandardFaOption.MAC_LSHANDLERRANK.ifPresentIn(options, builder::lsHandlerRank);\n+        StandardFaOption.MAC_NSSTORETYPEKEY.ifPresentIn(options, builder::nsPersistentStoreTypeKey);\n+        StandardFaOption.MAC_NSDOCUMENTCLASS.ifPresentIn(options, builder::nsDocumentClass);\n+        StandardFaOption.MAC_LSTYPEISPACKAGE.ifPresentIn(options, builder::lsTypeIsPackage);\n+        StandardFaOption.MAC_LSDOCINPLACE.ifPresentIn(options, builder::lsSupportsOpeningDocumentsInPlace);\n+        StandardFaOption.MAC_UIDOCBROWSER.ifPresentIn(options, builder::uiSupportsDocumentBrowser);\n+        StandardFaOption.MAC_NSEXPORTABLETYPES.ifPresentIn(options, builder::nsExportableTypes);\n+        StandardFaOption.MAC_UTTYPECONFORMSTO.ifPresentIn(options, builder::utTypeConformsTo);\n+\n+        return builder.create(fa);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacFromOptions.java","additions":331,"deletions":0,"binary":false,"changes":331,"status":"added"},{"patch":"@@ -1,384 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import static jdk.jpackage.internal.BundlerParamInfo.createBooleanBundlerParam;\n-import static jdk.jpackage.internal.BundlerParamInfo.createPathBundlerParam;\n-import static jdk.jpackage.internal.BundlerParamInfo.createStringBundlerParam;\n-import static jdk.jpackage.internal.FromParams.createApplicationBuilder;\n-import static jdk.jpackage.internal.FromParams.createApplicationBundlerParam;\n-import static jdk.jpackage.internal.FromParams.createPackageBuilder;\n-import static jdk.jpackage.internal.FromParams.createPackageBundlerParam;\n-import static jdk.jpackage.internal.MacPackagingPipeline.APPLICATION_LAYOUT;\n-import static jdk.jpackage.internal.MacRuntimeValidator.validateRuntimeHasJliLib;\n-import static jdk.jpackage.internal.MacRuntimeValidator.validateRuntimeHasNoBinDir;\n-import static jdk.jpackage.internal.StandardBundlerParam.DMG_CONTENT;\n-import static jdk.jpackage.internal.StandardBundlerParam.ICON;\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE;\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE_FILE;\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_RUNTIME_IMAGE;\n-import static jdk.jpackage.internal.StandardBundlerParam.SIGN_BUNDLE;\n-import static jdk.jpackage.internal.StandardBundlerParam.hasPredefinedAppImage;\n-import static jdk.jpackage.internal.model.MacPackage.RUNTIME_BUNDLE_LAYOUT;\n-import static jdk.jpackage.internal.model.StandardPackageType.MAC_DMG;\n-import static jdk.jpackage.internal.model.StandardPackageType.MAC_PKG;\n-import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n-\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.Callable;\n-import java.util.function.Predicate;\n-import jdk.jpackage.internal.ApplicationBuilder.MainLauncherStartupInfo;\n-import jdk.jpackage.internal.SigningIdentityBuilder.ExpiredCertificateException;\n-import jdk.jpackage.internal.SigningIdentityBuilder.StandardCertificateSelector;\n-import jdk.jpackage.internal.model.ApplicationLaunchers;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.FileAssociation;\n-import jdk.jpackage.internal.model.Launcher;\n-import jdk.jpackage.internal.model.MacApplication;\n-import jdk.jpackage.internal.model.MacDmgPackage;\n-import jdk.jpackage.internal.model.MacFileAssociation;\n-import jdk.jpackage.internal.model.MacLauncher;\n-import jdk.jpackage.internal.model.MacPackage;\n-import jdk.jpackage.internal.model.MacPkgPackage;\n-import jdk.jpackage.internal.model.PackageType;\n-import jdk.jpackage.internal.model.RuntimeLayout;\n-import jdk.jpackage.internal.util.function.ExceptionBox;\n-\n-\n-final class MacFromParams {\n-\n-    private static MacApplication createMacApplication(\n-            Map<String, ? super Object> params) throws ConfigException, IOException {\n-\n-        final var predefinedRuntimeLayout = PREDEFINED_RUNTIME_IMAGE.findIn(params)\n-                .map(MacPackage::guessRuntimeLayout);\n-\n-        if (predefinedRuntimeLayout.isPresent()) {\n-            validateRuntimeHasJliLib(predefinedRuntimeLayout.orElseThrow());\n-            if (APP_STORE.findIn(params).orElse(false)) {\n-                validateRuntimeHasNoBinDir(predefinedRuntimeLayout.orElseThrow());\n-            }\n-        }\n-\n-        final var launcherFromParams = new LauncherFromParams(Optional.of(MacFromParams::createMacFa));\n-\n-        final var superAppBuilder = createApplicationBuilder(params, toFunction(launcherParams -> {\n-            var launcher = launcherFromParams.create(launcherParams);\n-            return MacLauncher.create(launcher);\n-        }), (MacLauncher _, Launcher launcher) -> {\n-            return MacLauncher.create(launcher);\n-        }, APPLICATION_LAYOUT, RUNTIME_BUNDLE_LAYOUT, predefinedRuntimeLayout.map(RuntimeLayout::unresolve));\n-\n-        if (hasPredefinedAppImage(params)) {\n-            \/\/ Set the main launcher start up info.\n-            \/\/ AppImageFile assumes the main launcher start up info is available when\n-            \/\/ it is constructed from Application instance.\n-            \/\/ This happens when jpackage signs predefined app image.\n-            final var mainLauncherStartupInfo = new MainLauncherStartupInfo(superAppBuilder.mainLauncherClassName().orElseThrow());\n-            final var launchers = superAppBuilder.launchers().orElseThrow();\n-            final var mainLauncher = ApplicationBuilder.overrideLauncherStartupInfo(launchers.mainLauncher(), mainLauncherStartupInfo);\n-            superAppBuilder.launchers(new ApplicationLaunchers(MacLauncher.create(mainLauncher), launchers.additionalLaunchers()));\n-        }\n-\n-        final var app = superAppBuilder.create();\n-\n-        final var appBuilder = new MacApplicationBuilder(app);\n-\n-        if (hasPredefinedAppImage(params)) {\n-            appBuilder.externalInfoPlistFile(PREDEFINED_APP_IMAGE.findIn(params).map(MacBundle::new).orElseThrow().infoPlistFile());\n-        }\n-\n-        ICON.copyInto(params, appBuilder::icon);\n-        MAC_CF_BUNDLE_NAME.copyInto(params, appBuilder::bundleName);\n-        MAC_CF_BUNDLE_IDENTIFIER.copyInto(params, appBuilder::bundleIdentifier);\n-        APP_CATEGORY.copyInto(params, appBuilder::category);\n-\n-        final boolean sign;\n-        final boolean appStore;\n-\n-        if (hasPredefinedAppImage(params) && PACKAGE_TYPE.findIn(params).filter(Predicate.isEqual(\"app-image\")).isEmpty()) {\n-            final var appImageFileExtras = new MacAppImageFileExtras(superAppBuilder.externalApplication().orElseThrow());\n-            sign = appImageFileExtras.signed();\n-            appStore = appImageFileExtras.appStore();\n-        } else {\n-            sign = SIGN_BUNDLE.findIn(params).orElse(false);\n-            appStore = APP_STORE.findIn(params).orElse(false);\n-        }\n-\n-        appBuilder.appStore(appStore);\n-\n-        if (sign) {\n-            final var signingIdentityBuilder = createSigningIdentityBuilder(params);\n-            APP_IMAGE_SIGN_IDENTITY.copyInto(params, signingIdentityBuilder::signingIdentity);\n-            SIGNING_KEY_USER.findIn(params).ifPresent(userName -> {\n-                final StandardCertificateSelector domain;\n-                if (appStore) {\n-                    domain = StandardCertificateSelector.APP_STORE_APP_IMAGE;\n-                } else {\n-                    domain = StandardCertificateSelector.APP_IMAGE;\n-                }\n-\n-                signingIdentityBuilder.certificateSelector(StandardCertificateSelector.create(userName, domain));\n-            });\n-\n-            final var signingBuilder = new AppImageSigningConfigBuilder(signingIdentityBuilder);\n-            if (appStore) {\n-                signingBuilder.entitlementsResourceName(\"sandbox.plist\");\n-            }\n-\n-            final var bundleIdentifier = appBuilder.create().bundleIdentifier();\n-            app.mainLauncher().flatMap(Launcher::startupInfo).ifPresentOrElse(\n-                signingBuilder::signingIdentifierPrefix,\n-                () -> {\n-                    \/\/ Runtime installer does not have main launcher, so use\n-                    \/\/ 'bundleIdentifier' as prefix by default.\n-                    signingBuilder.signingIdentifierPrefix(\n-                        bundleIdentifier + \".\");\n-                });\n-            SIGN_IDENTIFIER_PREFIX.copyInto(params, signingBuilder::signingIdentifierPrefix);\n-\n-            ENTITLEMENTS.copyInto(params, signingBuilder::entitlements);\n-\n-            appBuilder.signingBuilder(signingBuilder);\n-        }\n-\n-        return appBuilder.create();\n-    }\n-\n-    private static MacPackageBuilder createMacPackageBuilder(\n-            Map<String, ? super Object> params, MacApplication app,\n-            PackageType type) throws ConfigException {\n-        final var builder = new MacPackageBuilder(createPackageBuilder(params, app, type));\n-\n-        PREDEFINED_APP_IMAGE_FILE.findIn(params)\n-                .map(MacAppImageFileExtras::new)\n-                .map(MacAppImageFileExtras::signed)\n-                .ifPresent(builder::predefinedAppImageSigned);\n-\n-        PREDEFINED_RUNTIME_IMAGE.findIn(params)\n-                .map(MacBundle::new)\n-                .filter(MacBundle::isValid)\n-                .map(MacBundle::isSigned)\n-                .ifPresent(builder::predefinedAppImageSigned);\n-\n-        return builder;\n-    }\n-\n-    private static MacDmgPackage createMacDmgPackage(\n-            Map<String, ? super Object> params) throws ConfigException, IOException {\n-\n-        final var app = APPLICATION.fetchFrom(params);\n-\n-        final var superPkgBuilder = createMacPackageBuilder(params, app, MAC_DMG);\n-\n-        final var pkgBuilder = new MacDmgPackageBuilder(superPkgBuilder);\n-\n-        DMG_CONTENT.copyInto(params, pkgBuilder::dmgContent);\n-\n-        return pkgBuilder.create();\n-    }\n-\n-    private record WithExpiredCertificateException<T>(Optional<T> obj, Optional<ExpiredCertificateException> certEx) {\n-        WithExpiredCertificateException {\n-            if (obj.isEmpty() == certEx.isEmpty()) {\n-                throw new IllegalArgumentException();\n-            }\n-        }\n-\n-        static <U> WithExpiredCertificateException<U> of(Callable<U> callable) {\n-            try {\n-                return new WithExpiredCertificateException<>(Optional.of(callable.call()), Optional.empty());\n-            } catch (ExpiredCertificateException ex) {\n-                return new WithExpiredCertificateException<>(Optional.empty(), Optional.of(ex));\n-            } catch (ExceptionBox ex) {\n-                if (ex.getCause() instanceof ExpiredCertificateException certEx) {\n-                    return new WithExpiredCertificateException<>(Optional.empty(), Optional.of(certEx));\n-                }\n-                throw ex;\n-            } catch (RuntimeException ex) {\n-                throw ex;\n-            } catch (Throwable t) {\n-                throw ExceptionBox.rethrowUnchecked(t);\n-            }\n-        }\n-    }\n-\n-    private static MacPkgPackage createMacPkgPackage(\n-            Map<String, ? super Object> params) throws ConfigException, IOException {\n-\n-        \/\/ This is over complicated to make \"MacSignTest.testExpiredCertificate\" test pass.\n-\n-        final boolean sign = SIGN_BUNDLE.findIn(params).orElse(false);\n-        final boolean appStore = APP_STORE.findIn(params).orElse(false);\n-\n-        final var appOrExpiredCertEx = WithExpiredCertificateException.of(() -> {\n-            return APPLICATION.fetchFrom(params);\n-        });\n-\n-        final Optional<MacPkgPackageBuilder> pkgBuilder;\n-        if (appOrExpiredCertEx.obj().isPresent()) {\n-            final var superPkgBuilder = createMacPackageBuilder(params, appOrExpiredCertEx.obj().orElseThrow(), MAC_PKG);\n-            pkgBuilder = Optional.of(new MacPkgPackageBuilder(superPkgBuilder));\n-        } else {\n-            pkgBuilder = Optional.empty();\n-        }\n-\n-        if (sign) {\n-            final var signingIdentityBuilder = createSigningIdentityBuilder(params);\n-            INSTALLER_SIGN_IDENTITY.copyInto(params, signingIdentityBuilder::signingIdentity);\n-            SIGNING_KEY_USER.findIn(params).ifPresent(userName -> {\n-                final StandardCertificateSelector domain;\n-                if (appStore) {\n-                    domain = StandardCertificateSelector.APP_STORE_PKG_INSTALLER;\n-                } else {\n-                    domain = StandardCertificateSelector.PKG_INSTALLER;\n-                }\n-\n-                signingIdentityBuilder.certificateSelector(StandardCertificateSelector.create(userName, domain));\n-            });\n-\n-            if (pkgBuilder.isPresent()) {\n-                pkgBuilder.orElseThrow().signingBuilder(signingIdentityBuilder);\n-            } else {\n-                final var expiredPkgCert = WithExpiredCertificateException.of(() -> {\n-                    return signingIdentityBuilder.create();\n-                }).certEx();\n-                expiredPkgCert.map(ConfigException::getMessage).ifPresent(Log::error);\n-                throw appOrExpiredCertEx.certEx().orElseThrow();\n-            }\n-        }\n-\n-        return pkgBuilder.orElseThrow().create();\n-    }\n-\n-    private static SigningIdentityBuilder createSigningIdentityBuilder(Map<String, ? super Object> params) {\n-        final var builder = new SigningIdentityBuilder();\n-        SIGNING_KEYCHAIN.copyInto(params, builder::keychain);\n-        return builder;\n-    }\n-\n-    private static MacFileAssociation createMacFa(FileAssociation fa, Map<String, ? super Object> params) {\n-\n-        final var builder = new MacFileAssociationBuilder();\n-\n-        FA_MAC_CFBUNDLETYPEROLE.copyInto(params, builder::cfBundleTypeRole);\n-        FA_MAC_LSHANDLERRANK.copyInto(params, builder::lsHandlerRank);\n-        FA_MAC_NSSTORETYPEKEY.copyInto(params, builder::nsPersistentStoreTypeKey);\n-        FA_MAC_NSDOCUMENTCLASS.copyInto(params, builder::nsDocumentClass);\n-        FA_MAC_LSTYPEISPACKAGE.copyInto(params, builder::lsTypeIsPackage);\n-        FA_MAC_LSDOCINPLACE.copyInto(params, builder::lsSupportsOpeningDocumentsInPlace);\n-        FA_MAC_UIDOCBROWSER.copyInto(params, builder::uiSupportsDocumentBrowser);\n-        FA_MAC_NSEXPORTABLETYPES.copyInto(params, builder::nsExportableTypes);\n-        FA_MAC_UTTYPECONFORMSTO.copyInto(params, builder::utTypeConformsTo);\n-\n-        return toFunction(builder::create).apply(fa);\n-    }\n-\n-    static final BundlerParamInfo<MacApplication> APPLICATION = createApplicationBundlerParam(\n-            MacFromParams::createMacApplication);\n-\n-    static final BundlerParamInfo<MacDmgPackage> DMG_PACKAGE = createPackageBundlerParam(\n-            MacFromParams::createMacDmgPackage);\n-\n-    static final BundlerParamInfo<MacPkgPackage> PKG_PACKAGE = createPackageBundlerParam(\n-            MacFromParams::createMacPkgPackage);\n-\n-    private static final BundlerParamInfo<String> MAC_CF_BUNDLE_NAME = createStringBundlerParam(\n-            Arguments.CLIOptions.MAC_BUNDLE_NAME.getId());\n-\n-    private static final BundlerParamInfo<String> APP_CATEGORY = createStringBundlerParam(\n-            Arguments.CLIOptions.MAC_CATEGORY.getId());\n-\n-    private static final BundlerParamInfo<Path> ENTITLEMENTS = createPathBundlerParam(\n-            Arguments.CLIOptions.MAC_ENTITLEMENTS.getId());\n-\n-    private static final BundlerParamInfo<String> MAC_CF_BUNDLE_IDENTIFIER = createStringBundlerParam(\n-            Arguments.CLIOptions.MAC_BUNDLE_IDENTIFIER.getId());\n-\n-    private static final BundlerParamInfo<String> SIGN_IDENTIFIER_PREFIX = createStringBundlerParam(\n-            Arguments.CLIOptions.MAC_BUNDLE_SIGNING_PREFIX.getId());\n-\n-    private static final BundlerParamInfo<String> APP_IMAGE_SIGN_IDENTITY = createStringBundlerParam(\n-            Arguments.CLIOptions.MAC_APP_IMAGE_SIGN_IDENTITY.getId());\n-\n-    private static final BundlerParamInfo<String> INSTALLER_SIGN_IDENTITY = createStringBundlerParam(\n-            Arguments.CLIOptions.MAC_INSTALLER_SIGN_IDENTITY.getId());\n-\n-    private static final BundlerParamInfo<String> SIGNING_KEY_USER = createStringBundlerParam(\n-            Arguments.CLIOptions.MAC_SIGNING_KEY_NAME.getId());\n-\n-    private static final BundlerParamInfo<String> SIGNING_KEYCHAIN = createStringBundlerParam(\n-            Arguments.CLIOptions.MAC_SIGNING_KEYCHAIN.getId());\n-\n-    private static final BundlerParamInfo<String> PACKAGE_TYPE = createStringBundlerParam(\n-            Arguments.CLIOptions.PACKAGE_TYPE.getId());\n-\n-    private static final BundlerParamInfo<Boolean> APP_STORE = createBooleanBundlerParam(\n-            Arguments.CLIOptions.MAC_APP_STORE.getId());\n-\n-    private static final BundlerParamInfo<String> FA_MAC_CFBUNDLETYPEROLE = createStringBundlerParam(\n-            Arguments.MAC_CFBUNDLETYPEROLE);\n-\n-    private static final BundlerParamInfo<String> FA_MAC_LSHANDLERRANK = createStringBundlerParam(\n-            Arguments.MAC_LSHANDLERRANK);\n-\n-    private static final BundlerParamInfo<String> FA_MAC_NSSTORETYPEKEY = createStringBundlerParam(\n-            Arguments.MAC_NSSTORETYPEKEY);\n-\n-    private static final BundlerParamInfo<String> FA_MAC_NSDOCUMENTCLASS = createStringBundlerParam(\n-            Arguments.MAC_NSDOCUMENTCLASS);\n-\n-    private static final BundlerParamInfo<Boolean> FA_MAC_LSTYPEISPACKAGE = createBooleanBundlerParam(\n-            Arguments.MAC_LSTYPEISPACKAGE);\n-\n-    private static final BundlerParamInfo<Boolean> FA_MAC_LSDOCINPLACE = createBooleanBundlerParam(\n-            Arguments.MAC_LSDOCINPLACE);\n-\n-    private static final BundlerParamInfo<Boolean> FA_MAC_UIDOCBROWSER = createBooleanBundlerParam(\n-            Arguments.MAC_UIDOCBROWSER);\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static final BundlerParamInfo<List<String>> FA_MAC_NSEXPORTABLETYPES =\n-            new BundlerParamInfo<>(\n-                    Arguments.MAC_NSEXPORTABLETYPES,\n-                    (Class<List<String>>) (Object) List.class,\n-                    null,\n-                    (s, p) -> Arrays.asList(s.split(\"(,|\\\\s)+\"))\n-            );\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static final BundlerParamInfo<List<String>> FA_MAC_UTTYPECONFORMSTO =\n-            new BundlerParamInfo<>(\n-                    Arguments.MAC_UTTYPECONFORMSTO,\n-                    (Class<List<String>>) (Object) List.class,\n-                    null,\n-                    (s, p) -> Arrays.asList(s.split(\"(,|\\\\s)+\"))\n-            );\n-}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacFromParams.java","additions":0,"deletions":384,"binary":false,"changes":384,"status":"deleted"},{"patch":"@@ -78,1 +78,0 @@\n-import jdk.jpackage.internal.model.PackagerException;\n@@ -271,1 +270,1 @@\n-                public void execute(AppImageBuildEnv<MacApplication, T> env) throws IOException, PackagerException {\n+                public void execute(AppImageBuildEnv<MacApplication, T> env) throws IOException {\n@@ -598,1 +597,1 @@\n-        public void execute(TaskAction taskAction) throws IOException, PackagerException {\n+        public void execute(TaskAction taskAction) throws IOException {\n@@ -603,0 +602,9 @@\n+    private static final ApplicationLayout MAC_APPLICATION_LAYOUT = ApplicationLayout.build()\n+            .launchersDirectory(\"Contents\/MacOS\")\n+            .appDirectory(\"Contents\/app\")\n+            .runtimeDirectory(\"Contents\/runtime\/Contents\/Home\")\n+            .desktopIntegrationDirectory(\"Contents\/Resources\")\n+            .appModsDirectory(\"Contents\/app\/mods\")\n+            .contentDirectory(\"Contents\")\n+            .create();\n+\n@@ -604,1 +612,1 @@\n-            ApplicationLayoutUtils.PLATFORM_APPLICATION_LAYOUT, Path.of(\"Contents\/runtime\"));\n+            MAC_APPLICATION_LAYOUT, Path.of(\"Contents\/runtime\"));\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPackagingPipeline.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1,99 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.nio.file.Path;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.MacPkgPackage;\n-import jdk.jpackage.internal.model.PackagerException;\n-\n-public class MacPkgBundler extends MacBaseInstallerBundler {\n-\n-    @Override\n-    public String getName() {\n-        return I18N.getString(\"pkg.bundler.name\");\n-    }\n-\n-    @Override\n-    public String getID() {\n-        return \"pkg\";\n-    }\n-\n-    @Override\n-    public boolean validate(Map<String, ? super Object> params)\n-            throws ConfigException {\n-        try {\n-            Objects.requireNonNull(params);\n-\n-            final var pkg = MacFromParams.PKG_PACKAGE.fetchFrom(params);\n-\n-            \/\/ run basic validation to ensure requirements are met\n-            \/\/ we are not interested in return code, only possible exception\n-            validateAppImageAndBundeler(params);\n-\n-            \/\/ hdiutil is always available so there's no need\n-            \/\/ to test for availability.\n-\n-            return true;\n-        } catch (RuntimeException re) {\n-            if (re.getCause() instanceof ConfigException) {\n-                throw (ConfigException) re.getCause();\n-            } else {\n-                throw new ConfigException(re);\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public Path execute(Map<String, ? super Object> params,\n-            Path outputParentDir) throws PackagerException {\n-\n-        var pkg = MacFromParams.PKG_PACKAGE.fetchFrom(params);\n-\n-        Log.verbose(I18N.format(\"message.building-pkg\", pkg.app().name()));\n-\n-        return Packager.<MacPkgPackage>build().outputDir(outputParentDir)\n-                .pkg(pkg)\n-                .env(MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params))\n-                .pipelineBuilderMutatorFactory((env, _, outputDir) -> {\n-                    return new MacPkgPackager(env, pkg, outputDir);\n-                }).execute(MacPackagingPipeline.build(Optional.of(pkg)));\n-    }\n-\n-    @Override\n-    public boolean supported(boolean runtimeInstaller) {\n-        return true;\n-    }\n-\n-    @Override\n-    public boolean isDefault() {\n-        return false;\n-    }\n-\n-}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPkgBundler.java","additions":0,"deletions":99,"binary":false,"changes":99,"status":"deleted"},{"patch":"@@ -28,1 +28,4 @@\n-import static java.util.stream.Collectors.toMap;\n+import static java.util.stream.Collectors.toUnmodifiableMap;\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.MAC_APP_STORE;\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.MAC_MAIN_CLASS;\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.MAC_SIGNED;\n@@ -32,0 +35,1 @@\n+import java.util.Optional;\n@@ -35,0 +39,1 @@\n+import jdk.jpackage.internal.cli.OptionValue;\n@@ -79,1 +84,8 @@\n-        return Stream.of(ExtraAppImageFileField.values()).collect(toMap(ExtraAppImageFileField::fieldName, x -> x.asString(this)));\n+        return Stream.of(ExtraAppImageFileField.values()).map(field -> {\n+            return field.findStringValue(this).map(value -> {\n+                return Map.entry(field.fieldName(), value);\n+            });\n+        })\n+        .filter(Optional::isPresent)\n+        .map(Optional::get)\n+        .collect(toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));\n@@ -87,2 +99,10 @@\n-        SIGNED(\"signed\", app -> Boolean.toString(app.sign())),\n-        APP_STORE(\"app-store\", app -> Boolean.toString(app.appStore()));\n+        SIGNED(MAC_SIGNED, app -> {\n+            return Optional.of(Boolean.toString(app.sign()));\n+        }),\n+        APP_STORE(MAC_APP_STORE, app -> {\n+            return Optional.of(Boolean.toString(app.appStore()));\n+        }),\n+        APP_CLASS(MAC_MAIN_CLASS, app -> {\n+            return app.mainLauncher().flatMap(Launcher::startupInfo).map(LauncherStartupInfo::qualifiedClassName);\n+        }),\n+        ;\n@@ -90,2 +110,2 @@\n-        ExtraAppImageFileField(String fieldName, Function<MacApplication, String> getter) {\n-            this.fieldName = fieldName;\n+        ExtraAppImageFileField(OptionValue<?> option, Function<MacApplication, Optional<String>> getter) {\n+            this.fieldName = option.getName();\n@@ -95,1 +115,1 @@\n-        public String fieldName() {\n+        String fieldName() {\n@@ -99,1 +119,1 @@\n-        String asString(MacApplication app) {\n+        Optional<String> findStringValue(MacApplication app) {\n@@ -104,1 +124,1 @@\n-        private final Function<MacApplication, String> getter;\n+        private final Function<MacApplication, Optional<String>> getter;\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/model\/MacApplication.java","additions":29,"deletions":9,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -26,6 +26,0 @@\n-\n-app.bundler.name=Mac Application Image\n-store.bundler.name=Mac App Store Ready Bundler\n-dmg.bundler.name=Mac DMG Package\n-pkg.bundler.name=Mac PKG Package\n-\n@@ -63,1 +57,0 @@\n-\n@@ -73,1 +66,0 @@\n-message.building-bundle=Building Mac App Store Package for {0}.\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/MacResources.properties","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,5 +26,2 @@\n-provides jdk.jpackage.internal.Bundler with\n-    jdk.jpackage.internal.MacAppBundler,\n-    jdk.jpackage.internal.MacDmgBundler,\n-    jdk.jpackage.internal.MacPkgBundler;\n-\n+provides jdk.jpackage.internal.cli.CliBundlingEnvironment with\n+    jdk.jpackage.internal.MacBundlingEnvironment;\n\\ No newline at end of file\n","filename":"src\/jdk.jpackage\/macosx\/classes\/module-info.java.extra","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.util.Map;\n-import jdk.jpackage.internal.util.FileUtils;\n-\n-\n-\/**\n- * AbstractBundler\n- *\n- * This is the base class all bundlers extend from.\n- * It contains methods and parameters common to all bundlers.\n- * The concrete implementations are in the platform specific bundlers.\n- *\/\n-abstract class AbstractBundler implements Bundler {\n-\n-    @Override\n-    public String toString() {\n-        return getName();\n-    }\n-\n-    @Override\n-    public void cleanup(Map<String, ? super Object> params) {\n-        try {\n-            FileUtils.deleteRecursive(\n-                    StandardBundlerParam.TEMP_ROOT.fetchFrom(params));\n-        } catch (IOException e) {\n-            Log.verbose(e.getMessage());\n-        }\n-    }\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AbstractBundler.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -1,212 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.nio.file.Path;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.List;\n-import java.util.Optional;\n-\n-import jdk.internal.util.OperatingSystem;\n-\n-import jdk.jpackage.internal.Arguments.CLIOptions;\n-import static jdk.jpackage.internal.StandardBundlerParam.LAUNCHER_DATA;\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;\n-\n-\/*\n- * AddLauncherArguments\n- *\n- * Processes a add-launcher properties file to create the Map of\n- * bundle params applicable to the add-launcher:\n- *\n- * BundlerParams p = (new AddLauncherArguments(file)).getLauncherMap();\n- *\n- * A add-launcher is another executable program generated by either the\n- * create-app-image mode or the create-installer mode.\n- * The add-launcher may be the same program with different configuration,\n- * or a completely different program created from the same files.\n- *\n- * There may be multiple add-launchers, each created by using the\n- * command line arg \"--add-launcher <file path>\n- *\n- * The add-launcher properties file may have any of:\n- *\n- * appVersion\n- * description\n- * module\n- * main-jar\n- * main-class\n- * icon\n- * arguments\n- * java-options\n- * launcher-as-service\n- * win-console\n- * win-shortcut\n- * win-menu\n- * linux-app-category\n- * linux-shortcut\n- *\n- *\/\n-class AddLauncherArguments {\n-\n-    private final String name;\n-    private final String filename;\n-    private Map<String, String> allArgs;\n-    private Map<String, ? super Object> bundleParams;\n-\n-    AddLauncherArguments(String name, String filename) {\n-        this.name = name;\n-        this.filename = filename;\n-    }\n-\n-    private void initLauncherMap() {\n-        if (bundleParams != null) {\n-            return;\n-        }\n-\n-        allArgs = Arguments.getPropertiesFromFile(filename);\n-        allArgs.put(CLIOptions.NAME.getId(), name);\n-\n-        bundleParams = new HashMap<>();\n-        String mainJar = getOptionValue(CLIOptions.MAIN_JAR);\n-        String mainClass = getOptionValue(CLIOptions.APPCLASS);\n-        String module = getOptionValue(CLIOptions.MODULE);\n-\n-        if (module != null && mainClass != null) {\n-            Arguments.putUnlessNull(bundleParams, CLIOptions.MODULE.getId(),\n-                    module + \"\/\" + mainClass);\n-        } else if (module != null) {\n-            Arguments.putUnlessNull(bundleParams, CLIOptions.MODULE.getId(),\n-                    module);\n-        } else {\n-            Arguments.putUnlessNull(bundleParams, CLIOptions.MAIN_JAR.getId(),\n-                    mainJar);\n-            Arguments.putUnlessNull(bundleParams, CLIOptions.APPCLASS.getId(),\n-                    mainClass);\n-        }\n-\n-        Arguments.putUnlessNull(bundleParams, CLIOptions.NAME.getId(),\n-                getOptionValue(CLIOptions.NAME));\n-\n-        Arguments.putUnlessNull(bundleParams, CLIOptions.VERSION.getId(),\n-                getOptionValue(CLIOptions.VERSION));\n-\n-        Arguments.putUnlessNull(bundleParams, CLIOptions.DESCRIPTION.getId(),\n-                getOptionValue(CLIOptions.DESCRIPTION));\n-\n-        Arguments.putUnlessNull(bundleParams, CLIOptions.RELEASE.getId(),\n-                getOptionValue(CLIOptions.RELEASE));\n-\n-        Arguments.putUnlessNull(bundleParams, CLIOptions.ICON.getId(),\n-                Optional.ofNullable(getOptionValue(CLIOptions.ICON)).map(\n-                        Path::of).orElse(null));\n-\n-        Arguments.putUnlessNull(bundleParams,\n-                CLIOptions.LAUNCHER_AS_SERVICE.getId(), getOptionValue(\n-                CLIOptions.LAUNCHER_AS_SERVICE));\n-\n-        if (OperatingSystem.isWindows()) {\n-            Arguments.putUnlessNull(bundleParams,\n-                    CLIOptions.WIN_CONSOLE_HINT.getId(),\n-                    getOptionValue(CLIOptions.WIN_CONSOLE_HINT));\n-            Arguments.putUnlessNull(bundleParams, CLIOptions.WIN_SHORTCUT_HINT.getId(),\n-                    getOptionValue(CLIOptions.WIN_SHORTCUT_HINT));\n-            Arguments.putUnlessNull(bundleParams, CLIOptions.WIN_MENU_HINT.getId(),\n-                    getOptionValue(CLIOptions.WIN_MENU_HINT));\n-        }\n-\n-        if (OperatingSystem.isLinux()) {\n-            Arguments.putUnlessNull(bundleParams, CLIOptions.LINUX_CATEGORY.getId(),\n-                    getOptionValue(CLIOptions.LINUX_CATEGORY));\n-            Arguments.putUnlessNull(bundleParams, CLIOptions.LINUX_SHORTCUT_HINT.getId(),\n-                    getOptionValue(CLIOptions.LINUX_SHORTCUT_HINT));\n-        }\n-\n-        \/\/ \"arguments\" and \"java-options\" even if value is null:\n-        if (allArgs.containsKey(CLIOptions.ARGUMENTS.getId())) {\n-            String argumentStr = getOptionValue(CLIOptions.ARGUMENTS);\n-            bundleParams.put(CLIOptions.ARGUMENTS.getId(),\n-                    Arguments.getArgumentList(argumentStr));\n-        }\n-\n-        if (allArgs.containsKey(CLIOptions.JAVA_OPTIONS.getId())) {\n-            String jvmargsStr = getOptionValue(CLIOptions.JAVA_OPTIONS);\n-            bundleParams.put(CLIOptions.JAVA_OPTIONS.getId(),\n-                    Arguments.getArgumentList(jvmargsStr));\n-        }\n-    }\n-\n-    private String getOptionValue(CLIOptions option) {\n-        if (option == null || allArgs == null) {\n-            return null;\n-        }\n-\n-        String id = option.getId();\n-\n-        if (allArgs.containsKey(id)) {\n-            return allArgs.get(id);\n-        }\n-\n-        return null;\n-    }\n-\n-    Map<String, ? super Object> getLauncherMap() {\n-        initLauncherMap();\n-        return bundleParams;\n-    }\n-\n-    static Map<String, ? super Object> merge(\n-            Map<String, ? super Object> original,\n-            Map<String, ? super Object> additional, String... exclude) {\n-        Map<String, ? super Object> tmp = new HashMap<>(original);\n-        List.of(exclude).forEach(tmp::remove);\n-\n-        \/\/ remove LauncherData from map so it will be re-computed\n-        tmp.remove(LAUNCHER_DATA.getID());\n-        \/\/ remove \"application-name\" so it will be re-computed\n-        tmp.remove(APP_NAME.getID());\n-\n-        if (additional.containsKey(CLIOptions.MODULE.getId())) {\n-            tmp.remove(CLIOptions.MAIN_JAR.getId());\n-            tmp.remove(CLIOptions.APPCLASS.getId());\n-        } else if (additional.containsKey(CLIOptions.MAIN_JAR.getId())) {\n-            tmp.remove(CLIOptions.MODULE.getId());\n-        }\n-        if (additional.containsKey(CLIOptions.ARGUMENTS.getId())) {\n-            \/\/ if add launcher properties file contains \"arguments\", even with\n-            \/\/ null value, disregard the \"arguments\" from command line\n-            tmp.remove(CLIOptions.ARGUMENTS.getId());\n-        }\n-        if (additional.containsKey(CLIOptions.JAVA_OPTIONS.getId())) {\n-            \/\/ same thing for java-options\n-            tmp.remove(CLIOptions.JAVA_OPTIONS.getId());\n-        }\n-        tmp.putAll(additional);\n-        return tmp;\n-    }\n-\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AddLauncherArguments.java","additions":0,"deletions":212,"binary":false,"changes":212,"status":"deleted"},{"patch":"@@ -1,168 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;\n-import static jdk.jpackage.internal.StandardBundlerParam.LAUNCHER_DATA;\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE;\n-\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.text.MessageFormat;\n-import java.util.Map;\n-import java.util.Objects;\n-import jdk.internal.util.OperatingSystem;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.PackagerException;\n-\n-\n-class AppImageBundler extends AbstractBundler {\n-\n-    @Override\n-    public final String getName() {\n-        return I18N.getString(\"app.bundler.name\");\n-    }\n-\n-    @Override\n-    public final String getID() {\n-        return \"app\";\n-    }\n-\n-    @Override\n-    public final String getBundleType() {\n-        return \"IMAGE\";\n-    }\n-\n-    @Override\n-    public final boolean validate(Map<String, ? super Object> params)\n-            throws ConfigException {\n-        try {\n-            Objects.requireNonNull(params);\n-\n-            if (!params.containsKey(PREDEFINED_APP_IMAGE.getID())\n-                    && !StandardBundlerParam.isRuntimeInstaller(params)) {\n-                LAUNCHER_DATA.fetchFrom(params);\n-            }\n-\n-            if (paramsValidator != null) {\n-                paramsValidator.validate(params);\n-            }\n-        } catch (RuntimeException re) {\n-            if (re.getCause() instanceof ConfigException) {\n-                throw (ConfigException) re.getCause();\n-            } else {\n-                throw new ConfigException(re);\n-            }\n-        }\n-\n-        return true;\n-    }\n-\n-    @Override\n-    public final Path execute(Map<String, ? super Object> params,\n-            Path outputParentDir) throws PackagerException {\n-\n-        final var predefinedAppImage = PREDEFINED_APP_IMAGE.fetchFrom(params);\n-\n-        try {\n-            if (predefinedAppImage == null) {\n-                Path rootDirectory = createRoot(params, outputParentDir);\n-                appImageSupplier.prepareApplicationFiles(params, rootDirectory);\n-                return rootDirectory;\n-            } else {\n-                appImageSupplier.prepareApplicationFiles(params, predefinedAppImage);\n-                return predefinedAppImage;\n-            }\n-        } catch (PackagerException pe) {\n-            throw pe;\n-        } catch (RuntimeException|IOException ex) {\n-            Log.verbose(ex);\n-            throw new PackagerException(ex);\n-        }\n-    }\n-\n-    @Override\n-    public final boolean supported(boolean runtimeInstaller) {\n-        return true;\n-    }\n-\n-    @Override\n-    public final boolean isDefault() {\n-        return false;\n-    }\n-\n-    @FunctionalInterface\n-    static interface AppImageSupplier {\n-\n-        void prepareApplicationFiles(Map<String, ? super Object> params,\n-                Path root) throws PackagerException, IOException;\n-    }\n-\n-    final AppImageBundler setAppImageSupplier(AppImageSupplier v) {\n-        appImageSupplier = v;\n-        return this;\n-    }\n-\n-    final AppImageBundler setParamsValidator(ParamsValidator v) {\n-        paramsValidator = v;\n-        return this;\n-    }\n-\n-    @FunctionalInterface\n-    interface ParamsValidator {\n-        void validate(Map<String, ? super Object> params) throws ConfigException;\n-    }\n-\n-    private Path createRoot(Map<String, ? super Object> params,\n-            Path outputDirectory) throws PackagerException, IOException {\n-\n-        IOUtils.writableOutputDir(outputDirectory);\n-\n-        String imageName = APP_NAME.fetchFrom(params);\n-        if (OperatingSystem.isMacOS()) {\n-            imageName = imageName + \".app\";\n-        }\n-\n-        Log.verbose(MessageFormat.format(\n-                I18N.getString(\"message.creating-app-bundle\"),\n-                imageName, outputDirectory.toAbsolutePath()));\n-\n-        \/\/ Create directory structure\n-        Path rootDirectory = outputDirectory.resolve(imageName);\n-        if (Files.exists(rootDirectory)) {\n-            throw new PackagerException(\"error.root-exists\",\n-                    rootDirectory.toAbsolutePath().toString());\n-        }\n-\n-        Files.createDirectories(rootDirectory);\n-\n-        return rootDirectory;\n-    }\n-\n-    private ParamsValidator paramsValidator;\n-    private AppImageSupplier appImageSupplier;\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AppImageBundler.java","additions":0,"deletions":168,"binary":false,"changes":168,"status":"deleted"},{"patch":"@@ -28,2 +28,5 @@\n-import static java.util.stream.Collectors.toMap;\n-import static java.util.stream.Collectors.toSet;\n+import static java.util.stream.Collectors.toUnmodifiableMap;\n+import static java.util.stream.Collectors.toUnmodifiableSet;\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.APP_VERSION;\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.LAUNCHER_AS_SERVICE;\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.LAUNCHER_NAME;\n@@ -36,0 +39,1 @@\n+import java.util.ArrayList;\n@@ -39,0 +43,1 @@\n+import java.util.NoSuchElementException;\n@@ -40,1 +45,0 @@\n-import java.util.Optional;\n@@ -43,0 +47,2 @@\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n@@ -47,0 +53,5 @@\n+import jdk.jpackage.internal.cli.OptionValue;\n+import jdk.jpackage.internal.cli.Options;\n+import jdk.jpackage.internal.cli.StandardAppImageFileOption.AppImageFileOptionScope;\n+import jdk.jpackage.internal.cli.StandardAppImageFileOption.InvalidOptionValueException;\n+import jdk.jpackage.internal.cli.StandardAppImageFileOption.MissingMandatoryOptionException;\n@@ -49,1 +60,0 @@\n-import jdk.jpackage.internal.model.ConfigException;\n@@ -51,0 +61,1 @@\n+import jdk.jpackage.internal.model.JPackageException;\n@@ -53,0 +64,1 @@\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n@@ -59,1 +71,1 @@\n-final class AppImageFile implements ExternalApplication {\n+final class AppImageFile {\n@@ -62,1 +74,3 @@\n-        this(new ApplicationData(app));\n+        appVersion = Objects.requireNonNull(app.version());\n+        extra = Objects.requireNonNull(app.extraAppImageFileData());\n+        launcherInfos = app.launchers().stream().map(LauncherInfo::new).toList();\n@@ -65,39 +79,13 @@\n-    private AppImageFile(ApplicationData app) {\n-\n-        appVersion = app.version();\n-        launcherName = app.mainLauncherName();\n-        mainClass = app.mainLauncherMainClassName();\n-        extra = app.extra;\n-        creatorVersion = getVersion();\n-        creatorPlatform = getPlatform();\n-        addLauncherInfos = app.additionalLaunchers;\n-    }\n-\n-    @Override\n-    public List<LauncherInfo> getAddLaunchers() {\n-        return addLauncherInfos;\n-    }\n-\n-    @Override\n-    public String getAppVersion() {\n-        return appVersion;\n-    }\n-\n-    @Override\n-    public String getAppName() {\n-        return launcherName;\n-    }\n-\n-    @Override\n-    public String getLauncherName() {\n-        return launcherName;\n-    }\n-\n-    @Override\n-    public String getMainClass() {\n-        return mainClass;\n-    }\n-\n-    @Override\n-    public Map<String, String> getExtra() {\n-        return extra;\n+    \/**\n+     * Writes the values captured in this instance into the application image info\n+     * file in the given application layout.\n+     * <p>\n+     * It is an equivalent to calling\n+     * {@link #save(ApplicationLayout, OperatingSystem)} method with\n+     * {@code OperatingSystem.current()} for the second parameter.\n+     *\n+     * @param appLayout the application layout\n+     * @throws IOException if an I\/O error occurs when writing\n+     *\/\n+    void save(ApplicationLayout appLayout) throws IOException {\n+        save(appLayout, OperatingSystem.current());\n@@ -107,2 +95,6 @@\n-     * Saves file with application image info in application image using values\n-     * from this instance.\n+     * Writes the values captured in this instance into the application image info\n+     * file in the given application layout.\n+     *\n+     * @param appLayout the application layout\n+     * @param os the target OS\n+     * @throws IOException if an I\/O error occurs when writing\n@@ -110,1 +102,1 @@\n-    void save(ApplicationLayout appLayout) throws IOException {\n+    void save(ApplicationLayout appLayout, OperatingSystem os) throws IOException {\n@@ -113,2 +105,2 @@\n-            xml.writeAttribute(\"version\", creatorVersion);\n-            xml.writeAttribute(\"platform\", creatorPlatform);\n+            xml.writeAttribute(\"version\", getVersion());\n+            xml.writeAttribute(\"platform\", getPlatform(os));\n@@ -120,8 +112,0 @@\n-            xml.writeStartElement(\"main-launcher\");\n-            xml.writeCharacters(launcherName);\n-            xml.writeEndElement();\n-\n-            xml.writeStartElement(\"main-class\");\n-            xml.writeCharacters(mainClass);\n-            xml.writeEndElement();\n-\n@@ -134,10 +118,4 @@\n-            for (var li : addLauncherInfos) {\n-                xml.writeStartElement(\"add-launcher\");\n-                xml.writeAttribute(\"name\", li.name());\n-                xml.writeAttribute(\"service\", Boolean.toString(li.service()));\n-                for (var extraKey : li.extra().keySet().stream().sorted().toList()) {\n-                    xml.writeStartElement(extraKey);\n-                    xml.writeCharacters(li.extra().get(extraKey));\n-                    xml.writeEndElement();\n-                }\n-                xml.writeEndElement();\n+            launcherInfos.getFirst().save(xml, \"main-launcher\");\n+\n+            for (var li : launcherInfos.subList(1, launcherInfos.size())) {\n+                li.save(xml, \"add-launcher\");\n@@ -149,2 +127,3 @@\n-     * Returns path to application image info file.\n-     * @param appLayout - application layout\n+     * Returns the path to the application image info file in the given application layout.\n+     *\n+     * @param appLayout the application layout\n@@ -157,3 +136,18 @@\n-     * Loads application image info from application image.\n-     * @param appImageDir - path at which to resolve the given application layout\n-     * @param appLayout - application layout\n+     * Loads application image info from the specified application layout.\n+     * <p>\n+     * It is an equivalent to calling\n+     * {@link #load(ApplicationLayout, OperatingSystem)} method with\n+     * {@code OperatingSystem.current()} for the second parameter.\n+     *\n+     * @param appLayout the application layout\n+     *\/\n+    static ExternalApplication load(ApplicationLayout appLayout) {\n+        return load(appLayout, OperatingSystem.current());\n+    }\n+\n+    \/**\n+     * Loads application image info from the specified application layout and OS.\n+     *\n+     * @param appLayout the application layout\n+     * @param os        the OS defining extra properties of the application and\n+     *                  additional launchers\n@@ -161,2 +155,8 @@\n-    static AppImageFile load(Path appImageDir, ApplicationLayout appLayout) throws ConfigException, IOException {\n-        var srcFilePath = getPathInAppImage(appLayout.resolveAt(appImageDir));\n+    static ExternalApplication load(ApplicationLayout appLayout, OperatingSystem os) {\n+        Objects.requireNonNull(appLayout);\n+        Objects.requireNonNull(os);\n+\n+        final var appImageDir = appLayout.rootDirectory();\n+        final var appImageFilePath = getPathInAppImage(appLayout);\n+        final var relativeAppImageFilePath = appImageDir.relativize(appImageFilePath);\n+\n@@ -164,1 +164,1 @@\n-            final Document doc = XmlUtils.initDocumentBuilder().parse(Files.newInputStream(srcFilePath));\n+            final Document doc = XmlUtils.initDocumentBuilder().parse(Files.newInputStream(appImageFilePath));\n@@ -169,1 +169,1 @@\n-                    Node::getNodeValue).map(getPlatform()::equals).orElse(false);\n+                    Node::getNodeValue).map(getPlatform(os)::equals).orElse(false);\n@@ -180,6 +180,7 @@\n-            final AppImageProperties props;\n-            try {\n-                props = AppImageProperties.main(doc, xPath);\n-            } catch (IllegalArgumentException ex) {\n-                throw new InvalidAppImageFileException(ex);\n-            }\n+            final var appOptions = AppImageFileOptionScope.APP.parse(appImageFilePath, AppImageProperties.main(doc, xPath), os);\n+\n+            final var mainLauncherOptions = LauncherElement.MAIN.readAll(doc, xPath).stream().reduce((_, second) -> {\n+                return second;\n+            }).map(launcherProps -> {\n+                return AppImageFileOptionScope.LAUNCHER.parse(appImageFilePath, launcherProps, os);\n+            }).orElseThrow(InvalidAppImageFileException::new);\n@@ -187,7 +188,2 @@\n-            final var additionalLaunchers = AppImageProperties.launchers(doc, xPath).stream().map(launcherProps -> {\n-                try {\n-                    return new LauncherInfo(launcherProps.get(\"name\"),\n-                            launcherProps.find(\"service\").map(Boolean::parseBoolean).orElse(false), launcherProps.getExtra());\n-                } catch (IllegalArgumentException ex) {\n-                    throw new InvalidAppImageFileException(ex);\n-                }\n+            final var addLauncherOptions = LauncherElement.ADDITIONAL.readAll(doc, xPath).stream().map(launcherProps -> {\n+                return AppImageFileOptionScope.LAUNCHER.parse(appImageFilePath, launcherProps, os);\n@@ -196,2 +192,5 @@\n-            return new AppImageFile(new ApplicationData(props.get(\"app-version\"), props.get(\"main-launcher\"),\n-                    props.get(\"main-class\"), props.getExtra(), additionalLaunchers));\n+            try {\n+                return ExternalApplication.create(Options.concat(appOptions, mainLauncherOptions), addLauncherOptions, os);\n+            } catch (NoSuchElementException ex) {\n+                throw new InvalidAppImageFileException(ex);\n+            }\n@@ -201,1 +200,1 @@\n-            throw new RuntimeException(ex);\n+            throw ExceptionBox.rethrowUnchecked(ex);\n@@ -203,2 +202,2 @@\n-            \/\/ Exception reading input XML (probably malformed XML)\n-            throw new IOException(ex);\n+            \/\/ Malformed input XML\n+            throw new JPackageException(I18N.format(\"error.malformed-app-image-file\", relativeAppImageFilePath, appImageDir), ex);\n@@ -206,2 +205,3 @@\n-            throw I18N.buildConfigException(\"error.foreign-app-image\", appImageDir).create();\n-        } catch (InvalidAppImageFileException ex) {\n+            \/\/ Don't save the original exception as its error message is redundant.\n+            throw new JPackageException(I18N.format(\"error.missing-app-image-file\", relativeAppImageFilePath, appImageDir));\n+        } catch (InvalidAppImageFileException|InvalidOptionValueException|MissingMandatoryOptionException ex) {\n@@ -209,1 +209,3 @@\n-            throw I18N.buildConfigException(\"error.invalid-app-image\", appImageDir, srcFilePath).create();\n+            throw new JPackageException(I18N.format(\"error.invalid-app-image-file\", relativeAppImageFilePath, appImageDir), ex);\n+        } catch (IOException ex) {\n+            throw new JPackageException(I18N.format(\"error.reading-app-image-file\", relativeAppImageFilePath, appImageDir), ex);\n@@ -213,6 +215,0 @@\n-    static boolean getBooleanExtraFieldValue(String fieldId, ExternalApplication appImageFile) {\n-        Objects.requireNonNull(fieldId);\n-        Objects.requireNonNull(appImageFile);\n-        return Optional.ofNullable(appImageFile.getExtra().get(fieldId)).map(Boolean::parseBoolean).orElse(false);\n-    }\n-\n@@ -223,2 +219,2 @@\n-    static String getPlatform() {\n-        return PLATFORM_LABELS.get(OperatingSystem.current());\n+    static String getPlatform(OperatingSystem os) {\n+        return Objects.requireNonNull(PLATFORM_LABELS.get(Objects.requireNonNull(os)));\n@@ -227,0 +223,1 @@\n+\n@@ -228,4 +225,0 @@\n-        private AppImageProperties(Map<String, String> data, Set<String> stdKeys) {\n-            this.data = data;\n-            this.stdKeys = stdKeys;\n-        }\n@@ -233,3 +226,2 @@\n-        static AppImageProperties main(Document xml, XPath xPath) throws XPathExpressionException {\n-            final var data = queryProperties(xml.getDocumentElement(), xPath, MAIN_PROPERTIES_XPATH_QUERY);\n-            return new AppImageProperties(data, MAIN_ELEMENT_NAMES);\n+        static Map<String, String> main(Document xml, XPath xPath) throws XPathExpressionException {\n+            return queryProperties(xml.getDocumentElement(), xPath, MAIN_PROPERTIES_XPATH_QUERY);\n@@ -238,3 +230,3 @@\n-        static AppImageProperties launcher(Element addLauncherNode, XPath xPath) throws XPathExpressionException {\n-            final var attrData = XmlUtils.toStream(addLauncherNode.getAttributes())\n-                    .collect(toMap(Node::getNodeName, Node::getNodeValue));\n+        static Map<String, String> launcher(Element launcherNode, XPath xPath) throws XPathExpressionException {\n+            final var attrData = XmlUtils.toStream(launcherNode.getAttributes())\n+                    .collect(toUnmodifiableMap(Node::getNodeName, Node::getNodeValue));\n@@ -242,1 +234,1 @@\n-            final var extraData = queryProperties(addLauncherNode, xPath, LAUNCHER_PROPERTIES_XPATH_QUERY);\n+            final var extraData = queryProperties(launcherNode, xPath, LAUNCHER_PROPERTIES_XPATH_QUERY);\n@@ -247,22 +239,1 @@\n-            return new AppImageProperties(data, LAUNCHER_ATTR_NAMES);\n-        }\n-\n-        static List<AppImageProperties> launchers(Document xml, XPath xPath) throws XPathExpressionException {\n-            return XmlUtils.queryNodes(xml, xPath, \"\/jpackage-state\/add-launcher\")\n-                    .map(Element.class::cast).map(toFunction(e -> {\n-                        return launcher(e, xPath);\n-                    })).toList();\n-        }\n-\n-        String get(String name) {\n-            return find(name).orElseThrow(InvalidAppImageFileException::new);\n-        }\n-\n-        Optional<String> find(String name) {\n-            return Optional.ofNullable(data.get(name));\n-        }\n-\n-        Map<String, String> getExtra() {\n-            Map<String, String> extra = new HashMap<>(data);\n-            stdKeys.forEach(extra::remove);\n-            return extra;\n+            return data;\n@@ -275,1 +246,1 @@\n-                    .collect(toMap(Node::getNodeName, selectedElement -> {\n+                    .collect(toUnmodifiableMap(Node::getNodeName, selectedElement -> {\n@@ -288,4 +259,3 @@\n-        private final Map<String, String> data;\n-        private final Set<String> stdKeys;\n-\n-        private static final Set<String> LAUNCHER_ATTR_NAMES = Set.of(\"name\", \"service\");\n+        private static final Set<String> LAUNCHER_ATTR_NAMES = Stream.of(\n+                LAUNCHER_NAME\n+        ).map(OptionValue::getName).collect(toUnmodifiableSet());\n@@ -294,1 +264,3 @@\n-        private static final Set<String> MAIN_ELEMENT_NAMES = Set.of(\"app-version\", \"main-launcher\", \"main-class\");\n+        private static final Set<String> MAIN_ELEMENT_NAMES = Stream.of(\n+                APP_VERSION\n+        ).map(OptionValue::getName).collect(toUnmodifiableSet());\n@@ -304,1 +276,1 @@\n-                            Stream.of(\"add-launcher\")).collect(toSet())));\n+                            Stream.of(\"main-launcher\", \"add-launcher\")).collect(toUnmodifiableSet())));\n@@ -308,2 +280,0 @@\n-    private record ApplicationData(String version, String mainLauncherName, String mainLauncherMainClassName,\n-            Map<String, String> extra, List<LauncherInfo> additionalLaunchers) {\n@@ -311,6 +281,3 @@\n-        ApplicationData {\n-            Objects.requireNonNull(version);\n-            Objects.requireNonNull(mainLauncherName);\n-            Objects.requireNonNull(mainLauncherMainClassName);\n-            Objects.requireNonNull(extra);\n-            Objects.requireNonNull(additionalLaunchers);\n+    private enum LauncherElement {\n+        MAIN(\"main-launcher\"),\n+        ADDITIONAL(\"add-launcher\");\n@@ -318,5 +285,2 @@\n-            for (final var property : List.of(version, mainLauncherName, mainLauncherMainClassName)) {\n-                if (property.isBlank()) {\n-                    throw new IllegalArgumentException();\n-                }\n-            }\n+        LauncherElement(String elementName) {\n+            this.elementName = Objects.requireNonNull(elementName);\n@@ -325,2 +289,5 @@\n-        ApplicationData(Application app) {\n-            this(app, app.mainLauncher().orElseThrow());\n+        List<Map<String, String>> readAll(Document xml, XPath xPath) throws XPathExpressionException {\n+            return XmlUtils.queryNodes(xml, xPath, \"\/jpackage-state\/\" + elementName + \"[@name]\")\n+                    .map(Element.class::cast).map(toFunction(e -> {\n+                        return AppImageProperties.launcher(e, xPath);\n+                    })).toList();\n@@ -329,6 +296,34 @@\n-        private ApplicationData(Application app, Launcher mainLauncher) {\n-            this(app.version(), mainLauncher.name(), mainLauncher.startupInfo().orElseThrow().qualifiedClassName(),\n-                    app.extraAppImageFileData(), app.additionalLaunchers().stream().map(launcher -> {\n-                        return new LauncherInfo(launcher.name(), launcher.isService(),\n-                                launcher.extraAppImageFileData());\n-                    }).toList());\n+        private final String elementName;\n+    }\n+\n+    private record LauncherInfo(String name, Map<String, String> properties) {\n+        LauncherInfo {\n+            Objects.requireNonNull(name);\n+            Objects.requireNonNull(properties);\n+        }\n+\n+        LauncherInfo(Launcher launcher) {\n+            this(launcher.name(), properties(launcher));\n+        }\n+\n+        void save(XMLStreamWriter xml, String elementName) throws IOException, XMLStreamException {\n+            xml.writeStartElement(elementName);\n+            xml.writeAttribute(\"name\", name());\n+            for (var key : properties().keySet().stream().sorted().toList()) {\n+                xml.writeStartElement(key);\n+                xml.writeCharacters(properties().get(key));\n+                xml.writeEndElement();\n+            }\n+            xml.writeEndElement();\n+        }\n+\n+        private static Map<String, String> properties(Launcher launcher) {\n+            List<Map.Entry<String, String>> standardProps = new ArrayList<>();\n+            if (launcher.isService()) {\n+                standardProps.add(Map.entry(LAUNCHER_AS_SERVICE.getName(), Boolean.TRUE.toString()));\n+            }\n+\n+            return Stream.concat(\n+                    standardProps.stream(),\n+                    launcher.extraAppImageFileData().entrySet().stream()\n+            ).collect(toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));\n@@ -338,0 +333,1 @@\n+\n@@ -350,0 +346,1 @@\n+\n@@ -351,2 +348,0 @@\n-    private final String launcherName;\n-    private final String mainClass;\n@@ -354,3 +349,1 @@\n-    private final List<LauncherInfo> addLauncherInfos;\n-    private final String creatorVersion;\n-    private final String creatorPlatform;\n+    private final List<LauncherInfo> launcherInfos;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AppImageFile.java","additions":165,"deletions":172,"binary":false,"changes":337,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.util.stream.Collectors;\n@@ -43,1 +44,1 @@\n-import jdk.jpackage.internal.model.ExternalApplication.LauncherInfo;\n+import jdk.jpackage.internal.model.JPackageException;\n@@ -58,5 +59,3 @@\n-        final var launcherCount = launchersAsList.size();\n-\n-        if (launcherCount != launchersAsList.stream().map(Launcher::name).distinct().count()) {\n-            throw buildConfigException(\"ERR_NoUniqueName\").create();\n-        }\n+        launchersAsList.stream().collect(Collectors.toMap(Launcher::name, x -> x, (a, b) -> {\n+            throw new JPackageException(I18N.format(\"error.launcher-duplicate-name\", a.name()));\n+        }));\n@@ -91,19 +90,2 @@\n-    ApplicationBuilder initFromExternalApplication(ExternalApplication app,\n-            Function<LauncherInfo, Launcher> mapper) {\n-\n-        externalApp = Objects.requireNonNull(app);\n-\n-        if (version == null) {\n-            version = app.getAppVersion();\n-        }\n-        if (name == null) {\n-            name = app.getAppName();\n-        }\n-        runtimeBuilder = null;\n-\n-        var mainLauncherInfo = new LauncherInfo(app.getLauncherName(), false, Map.of());\n-\n-        launchers = new ApplicationLaunchers(\n-                mapper.apply(mainLauncherInfo),\n-                app.getAddLaunchers().stream().map(mapper).toList());\n-\n+    ApplicationBuilder externalApplication(ExternalApplication v) {\n+        externalApp = v;\n@@ -126,9 +108,0 @@\n-    Optional<String> mainLauncherClassName() {\n-        return launchers()\n-                .map(ApplicationLaunchers::mainLauncher)\n-                .flatMap(Launcher::startupInfo)\n-                .map(LauncherStartupInfo::qualifiedClassName).or(() -> {\n-                    return externalApplication().map(ExternalApplication::getMainClass);\n-                });\n-    }\n-\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ApplicationBuilder.java","additions":7,"deletions":34,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -1,71 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import java.nio.file.Path;\n-import jdk.internal.util.OperatingSystem;\n-import jdk.jpackage.internal.model.ApplicationLayout;\n-\n-\n-final class ApplicationLayoutUtils {\n-\n-    public static final ApplicationLayout PLATFORM_APPLICATION_LAYOUT;\n-\n-    private static final ApplicationLayout WIN_APPLICATION_LAYOUT = ApplicationLayout.build()\n-            .setAll(\"\")\n-            .appDirectory(\"app\")\n-            .runtimeDirectory(\"runtime\")\n-            .appModsDirectory(Path.of(\"app\", \"mods\"))\n-            .create();\n-\n-    private static final ApplicationLayout MAC_APPLICATION_LAYOUT = ApplicationLayout.build()\n-            .launchersDirectory(\"Contents\/MacOS\")\n-            .appDirectory(\"Contents\/app\")\n-            .runtimeDirectory(\"Contents\/runtime\/Contents\/Home\")\n-            .desktopIntegrationDirectory(\"Contents\/Resources\")\n-            .appModsDirectory(\"Contents\/app\/mods\")\n-            .contentDirectory(\"Contents\")\n-            .create();\n-\n-    private static final ApplicationLayout LINUX_APPLICATION_LAYOUT = ApplicationLayout.build()\n-            .launchersDirectory(\"bin\")\n-            .appDirectory(\"lib\/app\")\n-            .runtimeDirectory(\"lib\/runtime\")\n-            .desktopIntegrationDirectory(\"lib\")\n-            .appModsDirectory(\"lib\/app\/mods\")\n-            .contentDirectory(\"lib\")\n-            .create();\n-\n-    static {\n-        switch (OperatingSystem.current()) {\n-            case WINDOWS -> PLATFORM_APPLICATION_LAYOUT = WIN_APPLICATION_LAYOUT;\n-            case MACOS -> PLATFORM_APPLICATION_LAYOUT = MAC_APPLICATION_LAYOUT;\n-            case LINUX -> PLATFORM_APPLICATION_LAYOUT = LINUX_APPLICATION_LAYOUT;\n-            default -> {\n-                throw new UnsupportedOperationException();\n-            }\n-        }\n-    }\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ApplicationLayoutUtils.java","additions":0,"deletions":71,"binary":false,"changes":71,"status":"deleted"},{"patch":"@@ -1,867 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import jdk.internal.util.OperatingSystem;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.PackagerException;\n-import java.io.IOException;\n-import java.io.Reader;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.text.MessageFormat;\n-import java.util.ArrayList;\n-import java.util.EnumSet;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Properties;\n-import java.util.ResourceBundle;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-\/**\n- * Arguments\n- *\n- * This class encapsulates and processes the command line arguments,\n- * in effect, implementing all the work of jpackage tool.\n- *\n- * The primary entry point, processArguments():\n- * Processes and validates command line arguments, constructing DeployParams.\n- * Validates the DeployParams, and generate the BundleParams.\n- * Generates List of Bundlers from BundleParams valid for this platform.\n- * Executes each Bundler in the list.\n- *\/\n-public class Arguments {\n-    private static final ResourceBundle I18N = ResourceBundle.getBundle(\n-            \"jdk.jpackage.internal.resources.MainResources\");\n-\n-    private static final String FA_EXTENSIONS = \"extension\";\n-    private static final String FA_CONTENT_TYPE = \"mime-type\";\n-    private static final String FA_DESCRIPTION = \"description\";\n-    private static final String FA_ICON = \"icon\";\n-\n-    \/\/ Mac specific file association keys\n-    \/\/ String\n-    public static final String MAC_CFBUNDLETYPEROLE = \"mac.CFBundleTypeRole\";\n-    public static final String MAC_LSHANDLERRANK = \"mac.LSHandlerRank\";\n-    public static final String MAC_NSSTORETYPEKEY = \"mac.NSPersistentStoreTypeKey\";\n-    public static final String MAC_NSDOCUMENTCLASS = \"mac.NSDocumentClass\";\n-    \/\/ Boolean\n-    public static final String MAC_LSTYPEISPACKAGE = \"mac.LSTypeIsPackage\";\n-    public static final String MAC_LSDOCINPLACE = \"mac.LSSupportsOpeningDocumentsInPlace\";\n-    public static final String MAC_UIDOCBROWSER = \"mac.UISupportsDocumentBrowser\";\n-     \/\/ Array of strings\n-    public static final String MAC_NSEXPORTABLETYPES = \"mac.NSExportableTypes\";\n-    public static final String MAC_UTTYPECONFORMSTO = \"mac.UTTypeConformsTo\";\n-\n-    \/\/ regexp for parsing args (for example, for additional launchers)\n-    private static Pattern pattern = Pattern.compile(\n-          \"(?:(?:([\\\"'])(?:\\\\\\\\\\\\1|.)*?(?:\\\\1|$))|(?:\\\\\\\\[\\\"'\\\\s]|[^\\\\s]))++\");\n-\n-    private DeployParams deployParams = null;\n-\n-    private int pos = 0;\n-    private List<String> argList = null;\n-\n-    private List<CLIOptions> allOptions = null;\n-\n-    private boolean hasMainJar = false;\n-    private boolean hasMainClass = false;\n-    private boolean hasMainModule = false;\n-    public boolean userProvidedBuildRoot = false;\n-\n-    private String buildRoot = null;\n-    private String mainJarPath = null;\n-\n-    private boolean runtimeInstaller = false;\n-\n-    private List<AddLauncherArguments> addLaunchers = null;\n-\n-    private static final Map<String, CLIOptions> argIds = new HashMap<>();\n-    private static final Map<String, CLIOptions> argShortIds = new HashMap<>();\n-\n-    static {\n-        \/\/ init maps for parsing arguments\n-        (EnumSet.allOf(CLIOptions.class)).forEach(option -> {\n-            argIds.put(option.getIdWithPrefix(), option);\n-            if (option.getShortIdWithPrefix() != null) {\n-                argShortIds.put(option.getShortIdWithPrefix(), option);\n-            }\n-        });\n-    }\n-\n-    private static final InheritableThreadLocal<Arguments> instance =\n-            new InheritableThreadLocal<Arguments>();\n-\n-    public Arguments(String[] args) {\n-        instance.set(this);\n-\n-        argList = new ArrayList<String>(args.length);\n-        for (String arg : args) {\n-            argList.add(arg);\n-        }\n-\n-        pos = 0;\n-\n-        deployParams = new DeployParams();\n-\n-        allOptions = new ArrayList<>();\n-\n-        addLaunchers = new ArrayList<>();\n-    }\n-\n-    \/\/ CLIOptions is public for DeployParamsTest\n-    public enum CLIOptions {\n-        PACKAGE_TYPE(\"type\", \"t\", OptionCategories.PROPERTY, () -> {\n-            var type = popArg();\n-            context().deployParams.setTargetFormat(type);\n-            setOptionValue(\"type\", type);\n-        }),\n-\n-        INPUT (\"input\", \"i\", OptionCategories.PROPERTY, () -> {\n-            setOptionValue(\"input\", popArg());\n-        }),\n-\n-        OUTPUT (\"dest\", \"d\", OptionCategories.PROPERTY, () -> {\n-            var path = Path.of(popArg());\n-            setOptionValue(\"dest\", path);\n-        }),\n-\n-        DESCRIPTION (\"description\", OptionCategories.PROPERTY),\n-\n-        VENDOR (\"vendor\", OptionCategories.PROPERTY),\n-\n-        APPCLASS (\"main-class\", OptionCategories.PROPERTY, () -> {\n-            context().hasMainClass = true;\n-            setOptionValue(\"main-class\", popArg());\n-        }),\n-\n-        NAME (\"name\", \"n\", OptionCategories.PROPERTY),\n-\n-        VERBOSE (\"verbose\", OptionCategories.PROPERTY, () -> {\n-            setOptionValue(\"verbose\", true);\n-            Log.setVerbose();\n-        }),\n-\n-        RESOURCE_DIR(\"resource-dir\",\n-                OptionCategories.PROPERTY, () -> {\n-            String resourceDir = popArg();\n-            setOptionValue(\"resource-dir\", resourceDir);\n-        }),\n-\n-        DMG_CONTENT (\"mac-dmg-content\", OptionCategories.PROPERTY, () -> {\n-            List<String> content = getArgumentList(popArg());\n-            content.forEach(a -> setOptionValue(\"mac-dmg-content\", a));\n-        }),\n-\n-        ARGUMENTS (\"arguments\", OptionCategories.PROPERTY, () -> {\n-            List<String> arguments = getArgumentList(popArg());\n-            setOptionValue(\"arguments\", arguments);\n-        }),\n-\n-        JLINK_OPTIONS (\"jlink-options\", OptionCategories.PROPERTY, () -> {\n-            List<String> options = getArgumentList(popArg());\n-            setOptionValue(\"jlink-options\", options);\n-        }),\n-\n-        ICON (\"icon\", OptionCategories.PROPERTY),\n-\n-        COPYRIGHT (\"copyright\", OptionCategories.PROPERTY),\n-\n-        LICENSE_FILE (\"license-file\", OptionCategories.PROPERTY),\n-\n-        VERSION (\"app-version\", OptionCategories.PROPERTY),\n-\n-        RELEASE (\"linux-app-release\", OptionCategories.PROPERTY),\n-\n-        ABOUT_URL (\"about-url\", OptionCategories.PROPERTY),\n-\n-        JAVA_OPTIONS (\"java-options\", OptionCategories.PROPERTY, () -> {\n-            List<String> args = getArgumentList(popArg());\n-            args.forEach(a -> setOptionValue(\"java-options\", a));\n-        }),\n-\n-        APP_CONTENT (\"app-content\", OptionCategories.PROPERTY, () -> {\n-            getArgumentList(popArg()).forEach(\n-                    a -> setOptionValue(\"app-content\", a));\n-        }),\n-\n-        FILE_ASSOCIATIONS (\"file-associations\",\n-                OptionCategories.PROPERTY, () -> {\n-            Map<String, ? super Object> args = new HashMap<>();\n-\n-            \/\/ load .properties file\n-            Map<String, String> initialMap = getPropertiesFromFile(popArg());\n-\n-            putUnlessNull(args, StandardBundlerParam.FA_EXTENSIONS.getID(),\n-                    initialMap.get(FA_EXTENSIONS));\n-\n-            putUnlessNull(args, StandardBundlerParam.FA_CONTENT_TYPE.getID(),\n-                    initialMap.get(FA_CONTENT_TYPE));\n-\n-            putUnlessNull(args, StandardBundlerParam.FA_DESCRIPTION.getID(),\n-                    initialMap.get(FA_DESCRIPTION));\n-\n-            putUnlessNull(args, StandardBundlerParam.FA_ICON.getID(),\n-                    initialMap.get(FA_ICON));\n-\n-            \/\/ Mac extended file association arguments\n-            putUnlessNull(args, MAC_CFBUNDLETYPEROLE,\n-                    initialMap.get(MAC_CFBUNDLETYPEROLE));\n-\n-            putUnlessNull(args, MAC_LSHANDLERRANK,\n-                    initialMap.get(MAC_LSHANDLERRANK));\n-\n-            putUnlessNull(args, MAC_NSSTORETYPEKEY,\n-                    initialMap.get(MAC_NSSTORETYPEKEY));\n-\n-            putUnlessNull(args, MAC_NSDOCUMENTCLASS,\n-                    initialMap.get(MAC_NSDOCUMENTCLASS));\n-\n-            putUnlessNull(args, MAC_LSTYPEISPACKAGE,\n-                    initialMap.get(MAC_LSTYPEISPACKAGE));\n-\n-            putUnlessNull(args, MAC_LSDOCINPLACE,\n-                    initialMap.get(MAC_LSDOCINPLACE));\n-\n-            putUnlessNull(args, MAC_UIDOCBROWSER,\n-                    initialMap.get(MAC_UIDOCBROWSER));\n-\n-            putUnlessNull(args, MAC_NSEXPORTABLETYPES,\n-                    initialMap.get(MAC_NSEXPORTABLETYPES));\n-\n-            putUnlessNull(args, MAC_UTTYPECONFORMSTO,\n-                    initialMap.get(MAC_UTTYPECONFORMSTO));\n-\n-            ArrayList<Map<String, ? super Object>> associationList =\n-                new ArrayList<Map<String, ? super Object>>();\n-\n-            associationList.add(args);\n-\n-            \/\/ check that we really add _another_ value to the list\n-            setOptionValue(\"file-associations\", associationList);\n-\n-        }),\n-\n-        ADD_LAUNCHER (\"add-launcher\",\n-                    OptionCategories.PROPERTY, () -> {\n-            String spec = popArg();\n-            String name = null;\n-            String filename = spec;\n-            if (spec.contains(\"=\")) {\n-                String[] values = spec.split(\"=\", 2);\n-                name = values[0];\n-                filename = values[1];\n-            }\n-            context().addLaunchers.add(\n-                new AddLauncherArguments(name, filename));\n-        }),\n-\n-        TEMP_ROOT (\"temp\", OptionCategories.PROPERTY, () -> {\n-            context().buildRoot = popArg();\n-            context().userProvidedBuildRoot = true;\n-            setOptionValue(\"temp\", context().buildRoot);\n-        }),\n-\n-        INSTALL_DIR (\"install-dir\", OptionCategories.PROPERTY),\n-\n-        PREDEFINED_APP_IMAGE (\"app-image\", OptionCategories.PROPERTY),\n-\n-        PREDEFINED_RUNTIME_IMAGE (\"runtime-image\", OptionCategories.PROPERTY),\n-\n-        MAIN_JAR (\"main-jar\",  OptionCategories.PROPERTY, () -> {\n-            context().mainJarPath = popArg();\n-            context().hasMainJar = true;\n-            setOptionValue(\"main-jar\", context().mainJarPath);\n-        }),\n-\n-        MODULE (\"module\", \"m\", OptionCategories.MODULAR, () -> {\n-            context().hasMainModule = true;\n-            setOptionValue(\"module\", popArg());\n-        }),\n-\n-        ADD_MODULES (\"add-modules\", OptionCategories.MODULAR),\n-\n-        MODULE_PATH (\"module-path\", \"p\", OptionCategories.MODULAR),\n-\n-        LAUNCHER_AS_SERVICE (\"launcher-as-service\", OptionCategories.PROPERTY, () -> {\n-            setOptionValue(\"launcher-as-service\", true);\n-        }),\n-\n-        MAC_SIGN (\"mac-sign\", \"s\", OptionCategories.PLATFORM_MAC, () -> {\n-            setOptionValue(\"mac-sign\", true);\n-        }),\n-\n-        MAC_APP_STORE (\"mac-app-store\", OptionCategories.PLATFORM_MAC, () -> {\n-            setOptionValue(\"mac-app-store\", true);\n-        }),\n-\n-        MAC_CATEGORY (\"mac-app-category\", OptionCategories.PLATFORM_MAC),\n-\n-        MAC_BUNDLE_NAME (\"mac-package-name\", OptionCategories.PLATFORM_MAC),\n-\n-        MAC_BUNDLE_IDENTIFIER(\"mac-package-identifier\",\n-                    OptionCategories.PLATFORM_MAC),\n-\n-        MAC_BUNDLE_SIGNING_PREFIX (\"mac-package-signing-prefix\",\n-                    OptionCategories.PLATFORM_MAC),\n-\n-        MAC_SIGNING_KEY_NAME (\"mac-signing-key-user-name\",\n-                    OptionCategories.PLATFORM_MAC),\n-\n-        MAC_APP_IMAGE_SIGN_IDENTITY (\"mac-app-image-sign-identity\",\n-                    OptionCategories.PLATFORM_MAC),\n-\n-        MAC_INSTALLER_SIGN_IDENTITY (\"mac-installer-sign-identity\",\n-                    OptionCategories.PLATFORM_MAC),\n-\n-        MAC_SIGNING_KEYCHAIN (\"mac-signing-keychain\",\n-                    OptionCategories.PLATFORM_MAC),\n-\n-        MAC_ENTITLEMENTS (\"mac-entitlements\", OptionCategories.PLATFORM_MAC),\n-\n-        WIN_HELP_URL (\"win-help-url\", OptionCategories.PLATFORM_WIN),\n-\n-        WIN_UPDATE_URL (\"win-update-url\", OptionCategories.PLATFORM_WIN),\n-\n-        WIN_MENU_HINT (\"win-menu\", OptionCategories.PLATFORM_WIN,\n-                createArgumentWithOptionalValueAction(\"win-menu\")),\n-\n-        WIN_MENU_GROUP (\"win-menu-group\", OptionCategories.PLATFORM_WIN),\n-\n-        WIN_SHORTCUT_HINT (\"win-shortcut\", OptionCategories.PLATFORM_WIN,\n-                createArgumentWithOptionalValueAction(\"win-shortcut\")),\n-\n-        WIN_SHORTCUT_PROMPT (\"win-shortcut-prompt\",\n-                OptionCategories.PLATFORM_WIN, () -> {\n-            setOptionValue(\"win-shortcut-prompt\", true);\n-        }),\n-\n-        WIN_PER_USER_INSTALLATION (\"win-per-user-install\",\n-                OptionCategories.PLATFORM_WIN, () -> {\n-            setOptionValue(\"win-per-user-install\", false);\n-        }),\n-\n-        WIN_DIR_CHOOSER (\"win-dir-chooser\",\n-                OptionCategories.PLATFORM_WIN, () -> {\n-            setOptionValue(\"win-dir-chooser\", true);\n-        }),\n-\n-        WIN_UPGRADE_UUID (\"win-upgrade-uuid\",\n-                OptionCategories.PLATFORM_WIN),\n-\n-        WIN_CONSOLE_HINT (\"win-console\", OptionCategories.PLATFORM_WIN, () -> {\n-            setOptionValue(\"win-console\", true);\n-        }),\n-\n-        LINUX_BUNDLE_NAME (\"linux-package-name\",\n-                OptionCategories.PLATFORM_LINUX),\n-\n-        LINUX_DEB_MAINTAINER (\"linux-deb-maintainer\",\n-                OptionCategories.PLATFORM_LINUX),\n-\n-        LINUX_CATEGORY (\"linux-app-category\",\n-                OptionCategories.PLATFORM_LINUX),\n-\n-        LINUX_RPM_LICENSE_TYPE (\"linux-rpm-license-type\",\n-                OptionCategories.PLATFORM_LINUX),\n-\n-        LINUX_PACKAGE_DEPENDENCIES (\"linux-package-deps\",\n-                OptionCategories.PLATFORM_LINUX),\n-\n-        LINUX_SHORTCUT_HINT (\"linux-shortcut\", OptionCategories.PLATFORM_LINUX,\n-                createArgumentWithOptionalValueAction(\"linux-shortcut\")),\n-\n-        LINUX_MENU_GROUP (\"linux-menu-group\", OptionCategories.PLATFORM_LINUX);\n-\n-        private final String id;\n-        private final String shortId;\n-        private final OptionCategories category;\n-        private final Runnable action;\n-        private static Arguments argContext;\n-\n-        private CLIOptions(String id, OptionCategories category) {\n-            this(id, null, category, null);\n-        }\n-\n-        private CLIOptions(String id, String shortId,\n-                           OptionCategories category) {\n-            this(id, shortId, category, null);\n-        }\n-\n-        private CLIOptions(String id,\n-                OptionCategories category, Runnable action) {\n-            this(id, null, category, action);\n-        }\n-\n-        private CLIOptions(String id, String shortId,\n-                           OptionCategories category, Runnable action) {\n-            this.id = id;\n-            this.shortId = shortId;\n-            this.action = action;\n-            this.category = category;\n-        }\n-\n-        public static Arguments context() {\n-            return instance.get();\n-        }\n-\n-        public String getId() {\n-            return this.id;\n-        }\n-\n-        String getIdWithPrefix() {\n-            return \"--\" + this.id;\n-        }\n-\n-        String getShortIdWithPrefix() {\n-            return this.shortId == null ? null : \"-\" + this.shortId;\n-        }\n-\n-        void execute() {\n-            if (action != null) {\n-                action.run();\n-            } else {\n-                defaultAction();\n-            }\n-        }\n-\n-        private void defaultAction() {\n-            context().deployParams.addBundleArgument(id, popArg());\n-        }\n-\n-        private static void setOptionValue(String option, Object value) {\n-            context().deployParams.addBundleArgument(option, value);\n-        }\n-\n-        private static String popArg() {\n-            nextArg();\n-            return (context().pos >= context().argList.size()) ?\n-                            \"\" : context().argList.get(context().pos);\n-        }\n-\n-        private static String getArg() {\n-            return (context().pos >= context().argList.size()) ?\n-                        \"\" : context().argList.get(context().pos);\n-        }\n-\n-        private static void nextArg() {\n-            context().pos++;\n-        }\n-\n-        private static void prevArg() {\n-            Objects.checkIndex(context().pos, context().argList.size());\n-            context().pos--;\n-        }\n-\n-        private static boolean hasNextArg() {\n-            return context().pos < context().argList.size();\n-        }\n-\n-        private static Runnable createArgumentWithOptionalValueAction(String option) {\n-            Objects.requireNonNull(option);\n-            return () -> {\n-                nextArg();\n-                if (hasNextArg()) {\n-                    var value = getArg();\n-                    if (value.startsWith(\"-\")) {\n-                        prevArg();\n-                        setOptionValue(option, true);\n-                    } else {\n-                        setOptionValue(option, value);\n-                    }\n-                } else {\n-                    setOptionValue(option, true);\n-                }\n-            };\n-        }\n-    }\n-\n-    enum OptionCategories {\n-        MODULAR,\n-        PROPERTY,\n-        PLATFORM_MAC,\n-        PLATFORM_WIN,\n-        PLATFORM_LINUX;\n-    }\n-\n-    public boolean processArguments() {\n-        try {\n-            \/\/ parse cmd line\n-            String arg;\n-            CLIOptions option;\n-            for (; CLIOptions.hasNextArg(); CLIOptions.nextArg()) {\n-                arg = CLIOptions.getArg();\n-                if ((option = toCLIOption(arg)) != null) {\n-                    \/\/ found a CLI option\n-                    allOptions.add(option);\n-                    option.execute();\n-                } else {\n-                    throw new PackagerException(\"ERR_InvalidOption\", arg);\n-                }\n-            }\n-\n-            \/\/ display error for arguments that are not supported\n-            \/\/ for current configuration.\n-\n-            validateArguments();\n-\n-            List<Map<String, ? super Object>> launchersAsMap =\n-                    new ArrayList<>();\n-\n-            for (AddLauncherArguments sl : addLaunchers) {\n-                launchersAsMap.add(sl.getLauncherMap());\n-            }\n-\n-            deployParams.addBundleArgument(\n-                    StandardBundlerParam.ADD_LAUNCHERS.getID(),\n-                    launchersAsMap);\n-\n-            \/\/ at this point deployParams should be already configured\n-\n-            deployParams.validate();\n-\n-            BundleParams bp = deployParams.getBundleParams();\n-\n-            \/\/ validate name(s)\n-            ArrayList<String> usedNames = new ArrayList<String>();\n-            usedNames.add(bp.getName()); \/\/ add main app name\n-\n-            for (AddLauncherArguments sl : addLaunchers) {\n-                Map<String, ? super Object> slMap = sl.getLauncherMap();\n-                String slName =\n-                        (String) slMap.get(Arguments.CLIOptions.NAME.getId());\n-                if (slName == null) {\n-                    throw new PackagerException(\"ERR_NoAddLauncherName\");\n-                }\n-                \/\/ same rules apply to additional launcher names as app name\n-                DeployParams.validateName(slName, false);\n-                for (String usedName : usedNames) {\n-                    if (slName.equals(usedName)) {\n-                        throw new PackagerException(\"ERR_NoUniqueName\");\n-                    }\n-                }\n-                usedNames.add(slName);\n-            }\n-\n-            generateBundle(bp.getBundleParamsAsMap());\n-            return true;\n-        } catch (Exception e) {\n-            Log.verbose(e);\n-            String msg1 = e.getMessage();\n-            Log.fatalError(msg1);\n-            if (e.getCause() != null && e.getCause() != e) {\n-                String msg2 = e.getCause().getMessage();\n-                if (msg2 != null && !msg1.contains(msg2)) {\n-                    Log.fatalError(msg2);\n-                }\n-            }\n-            return false;\n-        }\n-    }\n-\n-    private void validateArguments() throws PackagerException {\n-        String type = deployParams.getTargetFormat();\n-        String ptype = (type != null) ? type : \"default\";\n-        boolean imageOnly = deployParams.isTargetAppImage();\n-        boolean hasAppImage = allOptions.contains(\n-                CLIOptions.PREDEFINED_APP_IMAGE);\n-        boolean hasRuntime = allOptions.contains(\n-                CLIOptions.PREDEFINED_RUNTIME_IMAGE);\n-        boolean installerOnly = !imageOnly && hasAppImage;\n-        boolean isMac = OperatingSystem.isMacOS();\n-        runtimeInstaller = !imageOnly && hasRuntime && !hasAppImage &&\n-                !hasMainModule && !hasMainJar;\n-\n-        for (CLIOptions option : allOptions) {\n-            if (!ValidOptions.checkIfSupported(option)) {\n-                \/\/ includes option valid only on different platform\n-                throw new PackagerException(\"ERR_UnsupportedOption\",\n-                        option.getIdWithPrefix());\n-            }\n-            if ((imageOnly && !isMac) || (imageOnly && !hasAppImage && isMac)) {\n-                if (!ValidOptions.checkIfImageSupported(option)) {\n-                    throw new PackagerException(\"ERR_InvalidTypeOption\",\n-                        option.getIdWithPrefix(), type);\n-                }\n-            } else if (imageOnly && hasAppImage && isMac) { \/\/ Signing app image\n-                if (!ValidOptions.checkIfSigningSupported(option)) {\n-                    throw new PackagerException(\n-                            \"ERR_InvalidOptionWithAppImageSigning\",\n-                            option.getIdWithPrefix());\n-                }\n-            } else if (installerOnly || runtimeInstaller) {\n-                if (!ValidOptions.checkIfInstallerSupported(option)) {\n-                    if (runtimeInstaller) {\n-                        throw new PackagerException(\"ERR_NoInstallerEntryPoint\",\n-                            option.getIdWithPrefix());\n-                    } else {\n-                        throw new PackagerException(\"ERR_InvalidTypeOption\",\n-                            option.getIdWithPrefix(), ptype);\n-                   }\n-                }\n-            }\n-        }\n-        if (hasRuntime) {\n-            if (hasAppImage) {\n-                \/\/ note --runtime-image is only for image or runtime installer.\n-                throw new PackagerException(\"ERR_MutuallyExclusiveOptions\",\n-                        CLIOptions.PREDEFINED_RUNTIME_IMAGE.getIdWithPrefix(),\n-                        CLIOptions.PREDEFINED_APP_IMAGE.getIdWithPrefix());\n-            }\n-            if (allOptions.contains(CLIOptions.ADD_MODULES)) {\n-                throw new PackagerException(\"ERR_MutuallyExclusiveOptions\",\n-                        CLIOptions.PREDEFINED_RUNTIME_IMAGE.getIdWithPrefix(),\n-                        CLIOptions.ADD_MODULES.getIdWithPrefix());\n-            }\n-            if (allOptions.contains(CLIOptions.JLINK_OPTIONS)) {\n-                throw new PackagerException(\"ERR_MutuallyExclusiveOptions\",\n-                        CLIOptions.PREDEFINED_RUNTIME_IMAGE.getIdWithPrefix(),\n-                        CLIOptions.JLINK_OPTIONS.getIdWithPrefix());\n-            }\n-        }\n-        if (allOptions.contains(CLIOptions.MAC_SIGNING_KEY_NAME) &&\n-            allOptions.contains(CLIOptions.MAC_APP_IMAGE_SIGN_IDENTITY)) {\n-                throw new PackagerException(\"ERR_MutuallyExclusiveOptions\",\n-                        CLIOptions.MAC_SIGNING_KEY_NAME.getIdWithPrefix(),\n-                        CLIOptions.MAC_APP_IMAGE_SIGN_IDENTITY.getIdWithPrefix());\n-        }\n-        if (allOptions.contains(CLIOptions.MAC_SIGNING_KEY_NAME) &&\n-            allOptions.contains(CLIOptions.MAC_INSTALLER_SIGN_IDENTITY)) {\n-                throw new PackagerException(\"ERR_MutuallyExclusiveOptions\",\n-                        CLIOptions.MAC_SIGNING_KEY_NAME.getIdWithPrefix(),\n-                        CLIOptions.MAC_INSTALLER_SIGN_IDENTITY.getIdWithPrefix());\n-        }\n-        if (isMac && (imageOnly || \"dmg\".equals(type)) &&\n-            allOptions.contains(CLIOptions.MAC_INSTALLER_SIGN_IDENTITY)) {\n-                throw new PackagerException(\"ERR_InvalidTypeOption\",\n-                        CLIOptions.MAC_INSTALLER_SIGN_IDENTITY.getIdWithPrefix(),\n-                        type);\n-        }\n-        if (allOptions.contains(CLIOptions.DMG_CONTENT)\n-                && !(\"dmg\".equals(type))) {\n-            throw new PackagerException(\"ERR_InvalidTypeOption\",\n-                    CLIOptions.DMG_CONTENT.getIdWithPrefix(), ptype);\n-        }\n-        if (hasMainJar && hasMainModule) {\n-            throw new PackagerException(\"ERR_BothMainJarAndModule\");\n-        }\n-        if (imageOnly && !hasAppImage && !hasMainJar && !hasMainModule) {\n-                throw new PackagerException(\"ERR_NoEntryPoint\");\n-        }\n-    }\n-\n-    private jdk.jpackage.internal.Bundler getPlatformBundler() {\n-        boolean appImage = deployParams.isTargetAppImage();\n-        String type = deployParams.getTargetFormat();\n-        String bundleType = (appImage ?  \"IMAGE\" : \"INSTALLER\");\n-\n-        for (jdk.jpackage.internal.Bundler bundler :\n-                Bundlers.createBundlersInstance().getBundlers(bundleType)) {\n-            if (type == null) {\n-                if (bundler.isDefault()) {\n-                    return bundler;\n-                }\n-            } else {\n-                if (appImage || type.equalsIgnoreCase(bundler.getID())) {\n-                    return bundler;\n-                }\n-            }\n-        }\n-        return null;\n-    }\n-\n-    private void generateBundle(Map<String,? super Object> params)\n-            throws PackagerException {\n-\n-        \/\/ the temp dir needs to be fetched from the params early,\n-        \/\/ to prevent each copy of the params (such as may be used for\n-        \/\/ additional launchers) from generating a separate temp dir when\n-        \/\/ the default is used (the default is a new temp directory)\n-        \/\/ The bundler.cleanup() below would not otherwise be able to\n-        \/\/ clean these extra (and unneeded) temp directories.\n-        StandardBundlerParam.TEMP_ROOT.fetchFrom(params);\n-\n-        \/\/ determine what bundler to run\n-        jdk.jpackage.internal.Bundler bundler = getPlatformBundler();\n-\n-        if (bundler == null || !bundler.supported(runtimeInstaller)) {\n-            String type = Optional.ofNullable(bundler).map(Bundler::getID).orElseGet(\n-                    () -> deployParams.getTargetFormat());\n-            throw new PackagerException(\"ERR_InvalidInstallerType\", type);\n-        }\n-\n-        Map<String, ? super Object> localParams = new HashMap<>(params);\n-        try {\n-            Path result = executeBundler(bundler, params, localParams);\n-            if (result == null) {\n-                throw new PackagerException(\"MSG_BundlerFailed\",\n-                        bundler.getID(), bundler.getName());\n-            }\n-            Log.verbose(MessageFormat.format(\n-                    I18N.getString(\"message.bundle-created\"),\n-                    bundler.getName()));\n-        } catch (ConfigException e) {\n-            Log.verbose(e);\n-            if (e.getAdvice() != null)  {\n-                throw new PackagerException(e, \"MSG_BundlerConfigException\",\n-                        bundler.getName(), e.getMessage(), e.getAdvice());\n-            } else {\n-                throw new PackagerException(e,\n-                       \"MSG_BundlerConfigExceptionNoAdvice\",\n-                        bundler.getName(), e.getMessage());\n-            }\n-        } catch (RuntimeException re) {\n-            Log.verbose(re);\n-            throw new PackagerException(re, \"MSG_BundlerRuntimeException\",\n-                    bundler.getName(), re.toString());\n-        } finally {\n-            if (userProvidedBuildRoot) {\n-                Log.verbose(MessageFormat.format(\n-                        I18N.getString(\"message.debug-working-directory\"),\n-                        (Path.of(buildRoot)).toAbsolutePath().toString()));\n-            } else {\n-                \/\/ always clean up the temporary directory created\n-                \/\/ when --temp option not used.\n-                bundler.cleanup(localParams);\n-            }\n-        }\n-    }\n-\n-    private static Path executeBundler(Bundler bundler, Map<String, ? super Object> params,\n-            Map<String, ? super Object> localParams) throws ConfigException, PackagerException {\n-        try {\n-            bundler.validate(localParams);\n-            return bundler.execute(localParams, StandardBundlerParam.OUTPUT_DIR.fetchFrom(params));\n-        } catch (ConfigException|PackagerException ex) {\n-            throw ex;\n-        } catch (RuntimeException ex) {\n-            if (ex.getCause() instanceof ConfigException cfgEx) {\n-                throw cfgEx;\n-            } else if (ex.getCause() instanceof PackagerException pkgEx) {\n-                throw pkgEx;\n-            } else {\n-                throw ex;\n-            }\n-        }\n-    }\n-\n-    static CLIOptions toCLIOption(String arg) {\n-        CLIOptions option;\n-        if ((option = argIds.get(arg)) == null) {\n-            option = argShortIds.get(arg);\n-        }\n-        return option;\n-    }\n-\n-    static Map<String, String> getPropertiesFromFile(String filename) {\n-        Map<String, String> map = new HashMap<>();\n-        \/\/ load properties file\n-        Properties properties = new Properties();\n-        try (Reader reader = Files.newBufferedReader(Path.of(filename))) {\n-            properties.load(reader);\n-        } catch (IOException e) {\n-            Log.error(\"Exception: \" + e.getMessage());\n-        }\n-\n-        for (final String name: properties.stringPropertyNames()) {\n-            map.put(name, properties.getProperty(name));\n-        }\n-\n-        return map;\n-    }\n-\n-    static List<String> getArgumentList(String inputString) {\n-        List<String> list = new ArrayList<>();\n-        if (inputString == null || inputString.isEmpty()) {\n-             return list;\n-        }\n-\n-        \/\/ The \"pattern\" regexp attempts to abide to the rule that\n-        \/\/ strings are delimited by whitespace unless surrounded by\n-        \/\/ quotes, then it is anything (including spaces) in the quotes.\n-        Matcher m = pattern.matcher(inputString);\n-        while (m.find()) {\n-            String s = inputString.substring(m.start(), m.end()).trim();\n-            \/\/ Ensure we do not have an empty string. trim() will take care of\n-            \/\/ whitespace only strings. The regex preserves quotes and escaped\n-            \/\/ chars so we need to clean them before adding to the List\n-            if (!s.isEmpty()) {\n-                list.add(unquoteIfNeeded(s));\n-            }\n-        }\n-        return list;\n-    }\n-\n-    static void putUnlessNull(Map<String, ? super Object> params,\n-            String param, Object value) {\n-        if (value != null) {\n-            params.put(param, value);\n-        }\n-    }\n-\n-    private static String unquoteIfNeeded(String in) {\n-        if (in == null) {\n-            return null;\n-        }\n-\n-        if (in.isEmpty()) {\n-            return \"\";\n-        }\n-\n-        \/\/ Use code points to preserve non-ASCII chars\n-        StringBuilder sb = new StringBuilder();\n-        int codeLen = in.codePointCount(0, in.length());\n-        int quoteChar = -1;\n-        for (int i = 0; i < codeLen; i++) {\n-            int code = in.codePointAt(i);\n-            if (code == '\"' || code == '\\'') {\n-                \/\/ If quote is escaped make sure to copy it\n-                if (i > 0 && in.codePointAt(i - 1) == '\\\\') {\n-                    sb.deleteCharAt(sb.length() - 1);\n-                    sb.appendCodePoint(code);\n-                    continue;\n-                }\n-                if (quoteChar != -1) {\n-                    if (code == quoteChar) {\n-                        \/\/ close quote, skip char\n-                        quoteChar = -1;\n-                    } else {\n-                        sb.appendCodePoint(code);\n-                    }\n-                } else {\n-                    \/\/ opening quote, skip char\n-                    quoteChar = code;\n-                }\n-            } else {\n-                sb.appendCodePoint(code);\n-            }\n-        }\n-        return sb.toString();\n-    }\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Arguments.java","additions":0,"deletions":867,"binary":false,"changes":867,"status":"deleted"},{"patch":"@@ -1,86 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.ServiceLoader;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-\n-\/**\n- * BasicBundlers\n- *\n- * A basic bundlers collection that loads the default bundlers.\n- * Loads the common bundlers.\n- * <UL>\n- *     <LI>Windows file image<\/LI>\n- *     <LI>Mac .app<\/LI>\n- *     <LI>Linux file image<\/LI>\n- *     <LI>Windows MSI<\/LI>\n- *     <LI>Windows EXE<\/LI>\n- *     <LI>Mac DMG<\/LI>\n- *     <LI>Mac PKG<\/LI>\n- *     <LI>Linux DEB<\/LI>\n- *     <LI>Linux RPM<\/LI>\n- *\n- * <\/UL>\n- *\/\n-public class BasicBundlers implements Bundlers {\n-\n-    boolean defaultsLoaded = false;\n-\n-    private final Collection<Bundler> bundlers = new CopyOnWriteArrayList<>();\n-\n-    @Override\n-    public Collection<Bundler> getBundlers() {\n-        return Collections.unmodifiableCollection(bundlers);\n-    }\n-\n-    @Override\n-    public Collection<Bundler> getBundlers(String type) {\n-        if (type == null) return Collections.emptySet();\n-        switch (type) {\n-            case \"NONE\":\n-                return Collections.emptySet();\n-            case \"ALL\":\n-                return getBundlers();\n-            default:\n-                return Arrays.asList(getBundlers().stream()\n-                        .filter(b -> type.equalsIgnoreCase(b.getBundleType()))\n-                        .toArray(Bundler[]::new));\n-        }\n-    }\n-\n-    \/\/ Loads bundlers from the META-INF\/services direct\n-    @Override\n-    public void loadBundlersFromServices(ClassLoader cl) {\n-        ServiceLoader<Bundler> loader = ServiceLoader.load(Bundler.class, cl);\n-        for (Bundler aLoader : loader) {\n-            bundlers.add(aLoader);\n-        }\n-    }\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/BasicBundlers.java","additions":0,"deletions":86,"binary":false,"changes":86,"status":"deleted"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.cli.StandardOption.PREDEFINED_APP_IMAGE;\n+import static jdk.jpackage.internal.cli.StandardOption.PREDEFINED_RUNTIME_IMAGE;\n+import static jdk.jpackage.internal.cli.StandardOption.RESOURCE_DIR;\n+import static jdk.jpackage.internal.cli.StandardOption.TEMP_ROOT;\n+import static jdk.jpackage.internal.cli.StandardOption.VERBOSE;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import jdk.jpackage.internal.cli.Options;\n+import jdk.jpackage.internal.model.Application;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.model.Package;\n+import jdk.jpackage.internal.model.RuntimeLayout;\n+\n+final class BuildEnvFromOptions {\n+\n+    BuildEnvFromOptions() {\n+        predefinedRuntimeImageLayout(RuntimeLayout.DEFAULT);\n+    }\n+\n+    BuildEnvFromOptions predefinedAppImageLayout(Function<Path, ApplicationLayout> v) {\n+        predefinedAppImageLayout = v;\n+        return this;\n+    }\n+\n+    BuildEnvFromOptions predefinedAppImageLayout(ApplicationLayout v) {\n+        return predefinedAppImageLayout(path -> v.resolveAt(path));\n+    }\n+\n+    BuildEnvFromOptions predefinedRuntimeImageLayout(Function<Path, RuntimeLayout> v) {\n+        predefinedRuntimeImageLayout = v;\n+        return this;\n+    }\n+\n+    BuildEnvFromOptions predefinedRuntimeImageLayout(RuntimeLayout v) {\n+        return predefinedRuntimeImageLayout(path -> v.resolveAt(path));\n+    }\n+\n+    BuildEnv create(Options options, Application app) {\n+        return create(options, app, Optional.empty());\n+    }\n+\n+    BuildEnv create(Options options, Package pkg) {\n+        return create(options, pkg.app(), Optional.of(pkg));\n+    }\n+\n+    private BuildEnv create(Options options, Application app, Optional<Package> pkg) {\n+        Objects.requireNonNull(options);\n+        Objects.requireNonNull(app);\n+        Objects.requireNonNull(pkg);\n+        Objects.requireNonNull(predefinedAppImageLayout);\n+        Objects.requireNonNull(predefinedRuntimeImageLayout);\n+\n+        final var builder = new BuildEnvBuilder(TEMP_ROOT.getFrom(options));\n+\n+        RESOURCE_DIR.ifPresentIn(options, builder::resourceDir);\n+        VERBOSE.ifPresentIn(options, builder::verbose);\n+\n+        if (app.isRuntime()) {\n+            var path = PREDEFINED_RUNTIME_IMAGE.getFrom(options);\n+            builder.appImageLayout(predefinedRuntimeImageLayout.apply(path));\n+        } else if (PREDEFINED_APP_IMAGE.containsIn(options)) {\n+            var path = PREDEFINED_APP_IMAGE.getFrom(options);\n+            builder.appImageLayout(predefinedAppImageLayout.apply(path));\n+        } else {\n+            pkg.ifPresentOrElse(builder::appImageDirFor, () -> {\n+                builder.appImageDirFor(app);\n+            });\n+        }\n+\n+        return builder.create();\n+    }\n+\n+    private Function<Path, ApplicationLayout> predefinedAppImageLayout;\n+    private Function<Path, RuntimeLayout> predefinedRuntimeImageLayout;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/BuildEnvFromOptions.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -1,74 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import static jdk.jpackage.internal.ApplicationLayoutUtils.PLATFORM_APPLICATION_LAYOUT;\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE;\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_RUNTIME_IMAGE;\n-import static jdk.jpackage.internal.StandardBundlerParam.RESOURCE_DIR;\n-import static jdk.jpackage.internal.StandardBundlerParam.TEMP_ROOT;\n-import static jdk.jpackage.internal.StandardBundlerParam.VERBOSE;\n-\n-import java.nio.file.Path;\n-import java.util.Map;\n-import java.util.function.Function;\n-import jdk.jpackage.internal.model.ApplicationLayout;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.RuntimeLayout;\n-\n-final class BuildEnvFromParams {\n-\n-    static BuildEnv create(Map<String, ? super Object> params,\n-            Function<Path, ApplicationLayout> predefinedAppImageLayoutProvider,\n-            Function<Path, RuntimeLayout> predefinedRuntimeImageLayoutProvider) throws ConfigException {\n-\n-        final var builder = new BuildEnvBuilder(TEMP_ROOT.fetchFrom(params));\n-\n-        RESOURCE_DIR.copyInto(params, builder::resourceDir);\n-        VERBOSE.copyInto(params, builder::verbose);\n-\n-        final var app = FromParams.APPLICATION.findIn(params).orElseThrow();\n-\n-        final var pkg = FromParams.getCurrentPackage(params);\n-\n-        if (app.isRuntime()) {\n-            var layout = predefinedRuntimeImageLayoutProvider.apply(PREDEFINED_RUNTIME_IMAGE.findIn(params).orElseThrow());\n-            builder.appImageLayout(layout);\n-        } else if (StandardBundlerParam.hasPredefinedAppImage(params)) {\n-            var layout = predefinedAppImageLayoutProvider.apply(PREDEFINED_APP_IMAGE.findIn(params).orElseThrow());\n-            builder.appImageLayout(layout);\n-        } else if (pkg.isPresent()) {\n-            builder.appImageDirFor(pkg.orElseThrow());\n-        } else {\n-            builder.appImageDirFor(app);\n-        }\n-\n-        return builder.create();\n-    }\n-\n-    static final BundlerParamInfo<BuildEnv> BUILD_ENV = BundlerParamInfo.createBundlerParam(BuildEnv.class, params -> {\n-        return create(params, PLATFORM_APPLICATION_LAYOUT::resolveAt, RuntimeLayout.DEFAULT::resolveAt);\n-    });\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/BuildEnvFromParams.java","additions":0,"deletions":74,"binary":false,"changes":74,"status":"deleted"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;\n-\n-public class BundleParams {\n-\n-    protected final Map<String, ? super Object> params;\n-\n-    \/**\n-     * create a new bundle with all default values\n-     *\/\n-    public BundleParams() {\n-        params = new HashMap<>();\n-    }\n-\n-    \/**\n-     * Create a bundle params with a copy of the params\n-     * @param params map of initial parameters to be copied in.\n-     *\/\n-    public BundleParams(Map<String, ?> params) {\n-        this.params = new HashMap<>(params);\n-    }\n-\n-    public void addAllBundleParams(Map<String, ? super Object> params) {\n-        this.params.putAll(params);\n-    }\n-\n-    \/\/ NOTE: we do not care about application parameters here\n-    \/\/ as they will be embedded into jar file manifest and\n-    \/\/ java launcher will take care of them!\n-\n-    public Map<String, ? super Object> getBundleParamsAsMap() {\n-        return new HashMap<>(params);\n-    }\n-\n-    public String getName() {\n-        return APP_NAME.fetchFrom(params);\n-    }\n-\n-    private void putUnlessNull(String param, Object value) {\n-        if (value != null) {\n-            params.put(param, value);\n-        }\n-    }\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/BundleParams.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -1,126 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.nio.file.Path;\n-import java.util.Map;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.PackagerException;\n-\n-\/**\n- * Bundler\n- *\n- * The basic interface implemented by all Bundlers.\n- *\/\n-public interface Bundler {\n-    \/**\n-     * @return User Friendly name of this bundler.\n-     *\/\n-    String getName();\n-\n-    \/**\n-     * @return Command line identifier of the bundler.  Should be unique.\n-     *\/\n-    String getID();\n-\n-    \/**\n-     * @return The bundle type of the bundle that is created by this bundler.\n-     *\/\n-    String getBundleType();\n-\n-    \/**\n-     * Determines if this bundler will execute with the given parameters.\n-     *\n-     * @param params The parameters to be validate.  Validation may modify\n-     *               the map, so if you are going to be using the same map\n-     *               across multiple bundlers you should pass in a deep copy.\n-     * @return true if valid\n-     * @throws ConfigException If the configuration params are incorrect.  The\n-     *         exception may contain advice on how to modify the params map\n-     *         to make it valid.\n-     *\/\n-    public boolean validate(Map<String, ? super Object> params)\n-            throws ConfigException;\n-\n-    \/**\n-     * Creates a bundle from existing content.\n-     *\n-     * If a call to {@link #validate(java.util.Map)} date} returns true with\n-     * the parameters map, then you can expect a valid output.\n-     * However if an exception was thrown out of validate or it returned\n-     * false then you should not expect sensible results from this call.\n-     * It may or may not return a value, and it may or may not throw an\n-     * exception.  But any output should not be considered valid or sane.\n-     *\n-     * @param params The Bundle parameters,\n-     *               Keyed by the id from the ParamInfo.  Execution may\n-     *               modify the map, so if you are going to be using the\n-     *               same map across multiple bundlers you should pass\n-     *               in a deep copy.\n-     * @param outputParentDir\n-     *   The parent dir that the returned bundle will be placed in.\n-     * @return The resulting bundled file\n-     *\n-     * For a bundler that produces a single artifact file this will be the\n-     * location of that artifact (.exe file, .deb file, etc)\n-     *\n-     * For a bundler that produces a specific directory format output this will\n-     * be the location of that specific directory (.app file, etc).\n-     *\n-     * For a bundler that produce multiple files, this will be a parent\n-     * directory of those files (linux and windows images), whose name is not\n-     * relevant to the result.\n-     *\n-     * @throws java.lang.IllegalArgumentException for any of the following\n-     * reasons:\n-     *  <ul>\n-     *      <li>A required parameter is not found in the params list, for\n-     *      example missing the main class.<\/li>\n-     *      <li>A parameter has the wrong type of an object, for example a\n-     *      String where a File is required<\/li>\n-     *      <li>Bundler specific incompatibilities with the parameters, for\n-     *      example a bad version number format or an application id with\n-     *      forward slashes.<\/li>\n-     *  <\/ul>\n-     *\/\n-    public Path execute(Map<String, ? super Object> params,\n-            Path outputParentDir) throws PackagerException;\n-\n-     \/**\n-     * Removes temporary files that are used for bundling.\n-     *\/\n-    public void cleanup(Map<String, ? super Object> params);\n-\n-    \/**\n-     * Returns \"true\" if this bundler is supported on current platform.\n-     *\/\n-    public boolean supported(boolean runtimeInstaller);\n-\n-    \/**\n-     * Returns \"true\" if this bundler is he default for the current platform.\n-     *\/\n-    public boolean isDefault();\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Bundler.java","additions":0,"deletions":126,"binary":false,"changes":126,"status":"deleted"},{"patch":"@@ -1,179 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.nio.file.Path;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.function.BiFunction;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-import jdk.jpackage.internal.util.function.ThrowingFunction;\n-\n-\/**\n- * BundlerParamInfo<T>\n- *\n- * A BundlerParamInfo encapsulates an individual bundler parameter of type <T>.\n- *\n- * @param id The command line and hashmap name of the parameter\n- *\n- * @param valueType Type of the parameter\n- *\n- * @param defaultValueFunction If the value is not set, and no fallback value is found, the\n- * parameter uses the value returned by the producer.\n- *\n- * @param stringConverter An optional string converter for command line arguments.\n- *\/\n-record BundlerParamInfo<T>(String id, Class<T> valueType,\n-        Function<Map<String, ? super Object>, T> defaultValueFunction,\n-        BiFunction<String, Map<String, ? super Object>, T> stringConverter) {\n-\n-    BundlerParamInfo {\n-        Objects.requireNonNull(id);\n-        Objects.requireNonNull(valueType);\n-    }\n-\n-    static BundlerParamInfo<String> createStringBundlerParam(String id) {\n-        return new BundlerParamInfo<>(id, String.class, null, null);\n-    }\n-\n-    static BundlerParamInfo<Boolean> createBooleanBundlerParam(String id) {\n-        return new BundlerParamInfo<>(id, Boolean.class, null, BundlerParamInfo::toBoolean);\n-    }\n-\n-    static BundlerParamInfo<Path> createPathBundlerParam(String id) {\n-        return new BundlerParamInfo<>(id, Path.class, null, BundlerParamInfo::toPath);\n-    }\n-\n-    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n-    static <U> BundlerParamInfo<U> createBundlerParam(String id, Class<? super U> valueType,\n-            ThrowingFunction<Map<String, ? super Object>, U> valueCtor) {\n-        return new BundlerParamInfo(id, valueType, ThrowingFunction.toFunction(valueCtor), null);\n-    }\n-\n-    static <U> BundlerParamInfo<U> createBundlerParam(Class<? super U> valueType,\n-            ThrowingFunction<Map<String, ? super Object>, U> valueCtor) {\n-        return createBundlerParam(valueType.getName(), valueType, valueCtor);\n-    }\n-\n-    static boolean toBoolean(String value, Map<String, ? super Object> params) {\n-        if (value == null || \"null\".equalsIgnoreCase(value)) {\n-            return false;\n-        } else {\n-            return Boolean.valueOf(value);\n-        }\n-    }\n-\n-    static Path toPath(String value, Map<String, ? super Object> params) {\n-        return Path.of(value);\n-    }\n-\n-    String getID() {\n-        return id;\n-    }\n-\n-    Class<T> getValueType() {\n-        return valueType;\n-    }\n-\n-    \/**\n-     * Returns true if value was not provided on command line for this parameter.\n-     *\n-     * @param params - params from which value will be fetch\n-     * @return true if value was not provided on command line, false otherwise\n-     *\/\n-    boolean getIsDefaultValue(Map<String, ? super Object> params) {\n-        Object o = params.get(getID());\n-        if (o != null) {\n-            return false; \/\/ We have user provided value\n-        }\n-\n-        if (params.containsKey(getID())) {\n-            return false; \/\/ explicit nulls are allowed for provided value\n-        }\n-\n-        return true;\n-    }\n-\n-    Function<Map<String, ? super Object>, T> getDefaultValueFunction() {\n-        return defaultValueFunction;\n-    }\n-\n-    BiFunction<String, Map<String, ? super Object>, T> getStringConverter() {\n-        return stringConverter;\n-    }\n-\n-    final T fetchFrom(Map<String, ? super Object> params) {\n-        return fetchFrom(params, true);\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    final T fetchFrom(Map<String, ? super Object> params,\n-            boolean invokeDefault) {\n-        Object o = params.get(getID());\n-        if (o instanceof String && getStringConverter() != null) {\n-            return getStringConverter().apply((String) o, params);\n-        }\n-\n-        Class<T> klass = getValueType();\n-        if (klass.isInstance(o)) {\n-            return (T) o;\n-        }\n-        if (o != null) {\n-            throw new IllegalArgumentException(\"Param \" + getID()\n-                    + \" should be of type \" + getValueType()\n-                    + \" but is a \" + o.getClass());\n-        }\n-        if (params.containsKey(getID())) {\n-            \/\/ explicit nulls are allowed\n-            return null;\n-        }\n-\n-        if (invokeDefault && (getDefaultValueFunction() != null)) {\n-            T result = getDefaultValueFunction().apply(params);\n-            if (result != null) {\n-                params.put(getID(), result);\n-            }\n-            return result;\n-        }\n-\n-        \/\/ ultimate fallback\n-        return null;\n-    }\n-\n-    Optional<T> findIn(Map<String, ? super Object> params) {\n-        if (params.containsKey(getID())) {\n-            return Optional.of(fetchFrom(params, true));\n-        } else {\n-            return Optional.empty();\n-        }\n-    }\n-\n-    void copyInto(Map<String, ? super Object> params, Consumer<T> consumer) {\n-        findIn(params).ifPresent(consumer);\n-    }\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/BundlerParamInfo.java","additions":0,"deletions":179,"binary":false,"changes":179,"status":"deleted"},{"patch":"@@ -1,112 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.ServiceLoader;\n-\n-\/**\n- * Bundlers\n- *\n- * The interface implemented by BasicBundlers\n- *\/\n-public interface Bundlers {\n-\n-    \/**\n-     * This convenience method will call\n-     * {@link #createBundlersInstance(ClassLoader)}\n-     * with the classloader that this Bundlers is loaded from.\n-     *\n-     * @return an instance of Bundlers loaded and configured from\n-     *         the current ClassLoader.\n-     *\/\n-    public static Bundlers createBundlersInstance() {\n-        return createBundlersInstance(Bundlers.class.getClassLoader());\n-    }\n-\n-    \/**\n-     * This convenience method will automatically load a Bundlers instance\n-     * from either META-INF\/services or the default\n-     * {@link BasicBundlers} if none are found in\n-     * the services meta-inf.\n-     *\n-     * After instantiating the bundlers instance it will load the default\n-     * bundlers via {@link #loadDefaultBundlers()} as well as requesting\n-     * the services loader to load any other bundelrs via\n-     * {@link #loadBundlersFromServices(ClassLoader)}.\n-\n-     *\n-     * @param servicesClassLoader the classloader to search for\n-     *                            META-INF\/service registered bundlers\n-     * @return an instance of Bundlers loaded and configured from\n-     *         the specified ClassLoader\n-     *\/\n-    public static Bundlers createBundlersInstance(\n-            ClassLoader servicesClassLoader) {\n-        ServiceLoader<Bundlers> bundlersLoader =\n-                ServiceLoader.load(Bundlers.class, servicesClassLoader);\n-        Bundlers bundlers = null;\n-        Iterator<Bundlers> iter = bundlersLoader.iterator();\n-        if (iter.hasNext()) {\n-            bundlers = iter.next();\n-        }\n-        if (bundlers == null) {\n-            bundlers = new BasicBundlers();\n-        }\n-\n-        bundlers.loadBundlersFromServices(servicesClassLoader);\n-        return bundlers;\n-    }\n-\n-    \/**\n-     * Returns all of the preconfigured, requested, and manually\n-     * configured bundlers loaded with this instance.\n-     *\n-     * @return  a read-only collection of the requested bundlers\n-     *\/\n-    Collection<Bundler> getBundlers();\n-\n-    \/**\n-     * Returns all of the preconfigured, requested, and manually\n-     * configured bundlers loaded with this instance that are of\n-     * a specific BundleType, such as disk images, installers, or\n-     * remote installers.\n-     *\n-     * @return a read-only collection of the requested bundlers\n-     *\/\n-    Collection<Bundler> getBundlers(String type);\n-\n-    \/**\n-     * Loads bundlers from the META-INF\/services directly.\n-     *\n-     * This method is called from the\n-     * {@link #createBundlersInstance(ClassLoader)}\n-     * and {@link #createBundlersInstance()} methods.\n-     *\/\n-    void loadBundlersFromServices(ClassLoader cl);\n-\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Bundlers.java","additions":0,"deletions":112,"binary":false,"changes":112,"status":"deleted"},{"patch":"@@ -1,116 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import jdk.internal.util.OperatingSystem;\n-\n-import java.util.ResourceBundle;\n-import java.io.File;\n-import java.text.MessageFormat;\n-\n-\n-\/**\n- * CLIHelp\n- *\n- * Generate and show the command line interface help message(s).\n- *\/\n-public class CLIHelp {\n-\n-    private static final ResourceBundle I18N = ResourceBundle.getBundle(\n-            \"jdk.jpackage.internal.resources.HelpResources\");\n-\n-    \/\/ generates --help for jpackage's CLI\n-    public static void showHelp(boolean noArgs) {\n-\n-        if (noArgs) {\n-            Log.info(I18N.getString(\"MSG_Help_no_args\"));\n-        } else {\n-            OperatingSystem platform = OperatingSystem.current();\n-            String types;\n-            String pLaunchOptions;\n-            String pInstallOptions;\n-            String pInstallDir;\n-            String pAppImageDescription;\n-            String pSignSampleUsage;\n-            String pAppContentNote;\n-            switch (platform) {\n-                case MACOS:\n-                    types = \"{\\\"app-image\\\", \\\"dmg\\\", \\\"pkg\\\"}\";\n-                    pLaunchOptions = I18N.getString(\"MSG_Help_mac_launcher\");\n-                    pInstallOptions = I18N.getString(\"MSG_Help_mac_install\");\n-                    pInstallDir\n-                            = I18N.getString(\"MSG_Help_mac_linux_install_dir\");\n-                    pAppImageDescription\n-                            = I18N.getString(\"MSG_Help_mac_app_image\");\n-                    pSignSampleUsage\n-                            = I18N.getString(\"MSG_Help_mac_sign_sample_usage\");\n-                    pAppContentNote\n-                            = I18N.getString(\"MSG_Help_mac_app_content_note\");\n-                    break;\n-                case LINUX:\n-                    types = \"{\\\"app-image\\\", \\\"rpm\\\", \\\"deb\\\"}\";\n-                    pLaunchOptions = \"\";\n-                    pInstallOptions = I18N.getString(\"MSG_Help_linux_install\");\n-                    pInstallDir\n-                            = I18N.getString(\"MSG_Help_mac_linux_install_dir\");\n-                    pAppImageDescription\n-                            = I18N.getString(\"MSG_Help_default_app_image\");\n-                    pSignSampleUsage = \"\";\n-                    pAppContentNote = \"\";\n-                    break;\n-                case WINDOWS:\n-                    types = \"{\\\"app-image\\\", \\\"exe\\\", \\\"msi\\\"}\";\n-                    pLaunchOptions = I18N.getString(\"MSG_Help_win_launcher\");\n-                    pInstallOptions = I18N.getString(\"MSG_Help_win_install\");\n-                    pInstallDir\n-                            = I18N.getString(\"MSG_Help_win_install_dir\");\n-                    pAppImageDescription\n-                            = I18N.getString(\"MSG_Help_default_app_image\");\n-                    pSignSampleUsage = \"\";\n-                    pAppContentNote = \"\";\n-                    break;\n-                default:\n-                    types = \"{\\\"app-image\\\", \\\"exe\\\", \\\"msi\\\", \\\"rpm\\\", \\\"deb\\\", \\\"pkg\\\", \\\"dmg\\\"}\";\n-                    pLaunchOptions = I18N.getString(\"MSG_Help_win_launcher\")\n-                            + I18N.getString(\"MSG_Help_mac_launcher\");\n-                    pInstallOptions = I18N.getString(\"MSG_Help_win_install\")\n-                            + I18N.getString(\"MSG_Help_linux_install\")\n-                            + I18N.getString(\"MSG_Help_mac_install\");\n-                    pInstallDir\n-                            = I18N.getString(\"MSG_Help_default_install_dir\");\n-                    pAppImageDescription\n-                            = I18N.getString(\"MSG_Help_default_app_image\");\n-                    pSignSampleUsage = \"\";\n-                    pAppContentNote = \"\";\n-                    break;\n-            }\n-            Log.info(MessageFormat.format(I18N.getString(\"MSG_Help\"),\n-                    File.pathSeparator, types, pLaunchOptions,\n-                    pInstallOptions, pInstallDir, pAppImageDescription,\n-                    pSignSampleUsage, pAppContentNote));\n-        }\n-    }\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/CLIHelp.java","additions":0,"deletions":116,"binary":false,"changes":116,"status":"deleted"},{"patch":"@@ -33,1 +33,1 @@\n-import java.util.Optional;\n+import java.util.Objects;\n@@ -50,1 +50,1 @@\n-        version = app.version();\n+        version = Objects.requireNonNull(app.version());\n@@ -54,0 +54,4 @@\n+        Objects.requireNonNull(appLayout);\n+\n+        Objects.requireNonNull(startupInfo.qualifiedClassName());\n+\n@@ -61,1 +65,1 @@\n-            content.add(Map.entry(\"app.mainmodule\", modularStartupInfo.moduleName()\n+            content.add(Map.entry(\"app.mainmodule\", Objects.requireNonNull(modularStartupInfo.moduleName())\n@@ -70,3 +74,0 @@\n-            }\n-\n-            if (!jarStartupInfo.isJarWithMainClass()) {\n@@ -79,1 +80,1 @@\n-        for (var value : Optional.ofNullable(startupInfo.classPath()).orElseGet(List::of)) {\n+        for (var value : startupInfo.classPath()) {\n@@ -91,1 +92,1 @@\n-        for (var value : Optional.ofNullable(startupInfo.javaOptions()).orElseGet(List::of)) {\n+        for (var value : startupInfo.javaOptions()) {\n@@ -101,1 +102,1 @@\n-        var arguments = Optional.ofNullable(startupInfo.defaultParameters()).orElseGet(List::of);\n+        var arguments = startupInfo.defaultParameters();\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/CfgFile.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,283 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static java.util.stream.Collectors.toMap;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.cli.CliBundlingEnvironment;\n+import jdk.jpackage.internal.cli.Options;\n+import jdk.jpackage.internal.cli.StandardBundlingOperation;\n+import jdk.jpackage.internal.model.AppImagePackageType;\n+import jdk.jpackage.internal.model.Application;\n+import jdk.jpackage.internal.model.BundlingOperationDescriptor;\n+import jdk.jpackage.internal.model.JPackageException;\n+import jdk.jpackage.internal.model.Package;\n+import jdk.jpackage.internal.model.PackageType;\n+import jdk.jpackage.internal.model.StandardPackageType;\n+import jdk.jpackage.internal.util.Result;\n+\n+class DefaultBundlingEnvironment implements CliBundlingEnvironment {\n+\n+    DefaultBundlingEnvironment(Builder builder) {\n+        this(Optional.ofNullable(builder.defaultOperationSupplier), builder.bundlers);\n+    }\n+\n+    DefaultBundlingEnvironment(Optional<Supplier<Optional<BundlingOperationDescriptor>>> defaultOperationSupplier,\n+            Map<BundlingOperationDescriptor, Supplier<Result<Consumer<Options>>>> bundlers) {\n+\n+        this.bundlers = bundlers.entrySet().stream().collect(toMap(Map.Entry::getKey, e -> {\n+            return new CachingSupplier<>(e.getValue());\n+        }));\n+\n+        this.defaultOperationSupplier = Objects.requireNonNull(defaultOperationSupplier).map(CachingSupplier::new);\n+    }\n+\n+\n+    static final class Builder {\n+\n+        Builder defaultOperation(Supplier<Optional<BundlingOperationDescriptor>> v) {\n+            defaultOperationSupplier = v;\n+            return this;\n+        }\n+\n+        Builder defaultOperation(StandardBundlingOperation v) {\n+            return defaultOperation(() -> Optional.of(v.descriptor()));\n+        }\n+\n+        Builder bundler(StandardBundlingOperation op, Supplier<Result<Consumer<Options>>> bundlerSupplier) {\n+            bundlers.put(Objects.requireNonNull(op.descriptor()), Objects.requireNonNull(bundlerSupplier));\n+            return this;\n+        }\n+\n+        <T extends SystemEnvironment> Builder bundler(StandardBundlingOperation op,\n+                Supplier<Result<T>> sysEnvResultSupplier, BiConsumer<Options, T> bundler) {\n+            return bundler(op, createBundlerSupplier(sysEnvResultSupplier, bundler));\n+        }\n+\n+        Builder bundler(StandardBundlingOperation op, Consumer<Options> bundler) {\n+            Objects.requireNonNull(bundler);\n+            return bundler(op, () -> Result.ofValue(bundler));\n+        }\n+\n+        private Supplier<Optional<BundlingOperationDescriptor>> defaultOperationSupplier;\n+        private final Map<BundlingOperationDescriptor, Supplier<Result<Consumer<Options>>>> bundlers = new HashMap<>();\n+    }\n+\n+\n+    static Builder build() {\n+        return new Builder();\n+    }\n+\n+    static <T extends SystemEnvironment> Supplier<Result<Consumer<Options>>> createBundlerSupplier(\n+            Supplier<Result<T>> sysEnvResultSupplier, BiConsumer<Options, T> bundler) {\n+        Objects.requireNonNull(sysEnvResultSupplier);\n+        Objects.requireNonNull(bundler);\n+        return () -> {\n+            return sysEnvResultSupplier.get().map(sysEnv -> {\n+                return options -> {\n+                    bundler.accept(options, sysEnv);\n+                };\n+            });\n+        };\n+    }\n+\n+    static void createApplicationImage(Options options, Application app, PackagingPipeline.Builder pipelineBuilder) {\n+        Objects.requireNonNull(options);\n+        Objects.requireNonNull(app);\n+        Objects.requireNonNull(pipelineBuilder);\n+\n+        final var outputDir = OptionUtils.outputDir(options).resolve(app.appImageDirName());\n+\n+        IOUtils.writableOutputDir(outputDir.getParent());\n+\n+        final var env = new BuildEnvFromOptions()\n+                .predefinedAppImageLayout(app.asApplicationLayout().orElseThrow())\n+                .create(options, app);\n+\n+        Log.verbose(I18N.format(\"message.creating-app-bundle\", outputDir.getFileName(), outputDir.toAbsolutePath().getParent()));\n+\n+        if (Files.exists(outputDir)) {\n+            throw new JPackageException(I18N.format(\"error.root-exists\", outputDir.toAbsolutePath()));\n+        }\n+\n+        pipelineBuilder.excludeDirFromCopying(outputDir.getParent())\n+                .create().execute(BuildEnv.withAppImageDir(env, outputDir), app);\n+    }\n+\n+    static <T extends Package> void createNativePackage(Options options,\n+            Function<Options, T> createPackage,\n+            BiFunction<Options, T, BuildEnv> createBuildEnv,\n+            PackagingPipeline.Builder pipelineBuilder,\n+            Packager.PipelineBuilderMutatorFactory<T> pipelineBuilderMutatorFactory) {\n+\n+        Objects.requireNonNull(pipelineBuilder);\n+        createNativePackage(options, createPackage, createBuildEnv, _ -> pipelineBuilder, pipelineBuilderMutatorFactory);\n+    }\n+\n+    static <T extends Package> void createNativePackage(Options options,\n+            Function<Options, T> createPackage,\n+            BiFunction<Options, T, BuildEnv> createBuildEnv,\n+            Function<T, PackagingPipeline.Builder> createPipelineBuilder,\n+            Packager.PipelineBuilderMutatorFactory<T> pipelineBuilderMutatorFactory) {\n+\n+        Objects.requireNonNull(options);\n+        Objects.requireNonNull(createPackage);\n+        Objects.requireNonNull(createBuildEnv);\n+        Objects.requireNonNull(createPipelineBuilder);\n+        Objects.requireNonNull(pipelineBuilderMutatorFactory);\n+\n+        var pkg = Objects.requireNonNull(createPackage.apply(options));\n+\n+        Packager.<T>build().pkg(pkg)\n+            .outputDir(OptionUtils.outputDir(options))\n+            .env(Objects.requireNonNull(createBuildEnv.apply(options, pkg)))\n+            .pipelineBuilderMutatorFactory(pipelineBuilderMutatorFactory)\n+            .execute(Objects.requireNonNull(createPipelineBuilder.apply(pkg)));\n+    }\n+\n+    @Override\n+    public Optional<BundlingOperationDescriptor> defaultOperation() {\n+        return defaultOperationSupplier.flatMap(Supplier::get);\n+    }\n+\n+    @Override\n+    public void createBundle(BundlingOperationDescriptor op, Options cmdline) {\n+        final var bundler = getBundlerSupplier(op).get().orElseThrow();\n+        Optional<Path> permanentWorkDirectory = Optional.empty();\n+        try (var tempDir = new TempDirectory(cmdline)) {\n+            if (!tempDir.deleteOnClose()) {\n+                permanentWorkDirectory = Optional.of(tempDir.path());\n+            }\n+            bundler.accept(tempDir.options());\n+\n+            var packageType = OptionUtils.bundlingOperation(cmdline).packageType();\n+\n+            Log.verbose(I18N.format(\"message.bundle-created\", I18N.getString(bundleTypeDescription(packageType, op.os()))));\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        } finally {\n+            permanentWorkDirectory.ifPresent(workDir -> {\n+                Log.verbose(I18N.format(\"message.debug-working-directory\", workDir.toAbsolutePath()));\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public Collection<? extends Exception> configurationErrors(BundlingOperationDescriptor op) {\n+        return getBundlerSupplier(op).get().errors();\n+    }\n+\n+    private Supplier<Result<Consumer<Options>>> getBundlerSupplier(BundlingOperationDescriptor op) {\n+        return Optional.ofNullable(bundlers.get(op)).orElseThrow(NoSuchElementException::new);\n+    }\n+\n+    private String bundleTypeDescription(PackageType type, OperatingSystem os) {\n+        switch (type) {\n+            case StandardPackageType stdType -> {\n+                switch (stdType) {\n+                    case WIN_MSI -> {\n+                        return \"bundle-type.win-msi\";\n+                    }\n+                    case WIN_EXE -> {\n+                        return \"bundle-type.win-exe\";\n+                    }\n+                    case LINUX_DEB -> {\n+                        return \"bundle-type.linux-deb\";\n+                    }\n+                    case LINUX_RPM -> {\n+                        return \"bundle-type.linux-rpm\";\n+                    }\n+                    case MAC_DMG -> {\n+                        return \"bundle-type.mac-dmg\";\n+                    }\n+                    case MAC_PKG -> {\n+                        return \"bundle-type.mac-pkg\";\n+                    }\n+                    default -> {\n+                        throw new AssertionError();\n+                    }\n+                }\n+            }\n+            case AppImagePackageType appImageType -> {\n+                switch (os) {\n+                    case WINDOWS -> {\n+                        return \"bundle-type.win-app\";\n+                    }\n+                    case LINUX -> {\n+                        return \"bundle-type.linux-app\";\n+                    }\n+                    case MACOS -> {\n+                        return \"bundle-type.mac-app\";\n+                    }\n+                    default -> {\n+                        throw new AssertionError();\n+                    }\n+                }\n+            }\n+            default -> {\n+                throw new AssertionError();\n+            }\n+        }\n+    }\n+\n+\n+    private static final class CachingSupplier<T> implements Supplier<T> {\n+\n+        CachingSupplier(Supplier<T> getter) {\n+            this.getter = Objects.requireNonNull(getter);\n+        }\n+\n+        @Override\n+        public T get() {\n+            return cachedValue.updateAndGet(v -> {\n+                return Optional.ofNullable(v).orElseGet(getter);\n+            });\n+        }\n+\n+        private final Supplier<T> getter;\n+        private final AtomicReference<T> cachedValue = new AtomicReference<>();\n+    }\n+\n+\n+    private final Map<BundlingOperationDescriptor, Supplier<Result<Consumer<Options>>>> bundlers;\n+    private final Optional<CachingSupplier<Optional<BundlingOperationDescriptor>>> defaultOperationSupplier;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/DefaultBundlingEnvironment.java","additions":283,"deletions":0,"binary":false,"changes":283,"status":"added"},{"patch":"@@ -1,362 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.InvalidPathException;\n-import java.util.Arrays;\n-import java.util.LinkedHashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.TreeSet;\n-import java.util.stream.Stream;\n-import jdk.jpackage.internal.model.PackagerException;\n-\n-\/**\n- * DeployParams\n- *\n- * This class is generated and used in Arguments.processArguments() as\n- * intermediate step in generating the BundleParams and ultimately the Bundles\n- *\/\n-public class DeployParams {\n-\n-    String targetFormat = null; \/\/ means default type for this platform\n-\n-    \/\/ raw arguments to the bundler\n-    Map<String, ? super Object> bundlerArguments = new LinkedHashMap<>();\n-\n-    static class Template {\n-        Path in;\n-        Path out;\n-\n-        Template(Path in, Path out) {\n-            this.in = in;\n-            this.out = out;\n-        }\n-    }\n-\n-    \/\/ we need to expand as in some cases\n-    \/\/ (most notably jpackage)\n-    \/\/ we may get \".\" as filename and assumption is we include\n-    \/\/ everything in the given folder\n-    \/\/ (IOUtils.copyfiles() have recursive behavior)\n-    List<Path> expandFileset(Path root) throws IOException {\n-        List<Path> files = new LinkedList<>();\n-        if (!Files.isSymbolicLink(root)) {\n-            if (Files.isDirectory(root)) {\n-                try (Stream<Path> stream = Files.list(root)) {\n-                    List<Path> children = stream.toList();\n-                    if (children != null && children.size() > 0) {\n-                        children.forEach(f -> {\n-                            try {\n-                                files.addAll(expandFileset(f));\n-                            } catch (IOException ex) {\n-                                throw new RuntimeException(ex);\n-                            }\n-                        });\n-                    } else {\n-                        \/\/ Include empty folders\n-                        files.add(root);\n-                    }\n-                }\n-            } else {\n-                files.add(root);\n-            }\n-        }\n-        return files;\n-    }\n-\n-    static void validateName(String s, boolean forApp)\n-            throws PackagerException {\n-\n-        String exceptionKey = forApp ?\n-            \"ERR_InvalidAppName\" : \"ERR_InvalidSLName\";\n-\n-        if (s == null) {\n-            if (forApp) {\n-                return;\n-            } else {\n-                throw new PackagerException(exceptionKey);\n-            }\n-        }\n-        if (s.length() == 0 || s.charAt(s.length() - 1) == '\\\\') {\n-            throw new PackagerException(exceptionKey, s);\n-        }\n-        try {\n-            \/\/ name must be valid path element for this file system\n-            Path p = Path.of(s);\n-            \/\/ and it must be a single name element in a path\n-            if (p.getNameCount() != 1) {\n-                throw new PackagerException(exceptionKey, s);\n-            }\n-        } catch (InvalidPathException ipe) {\n-            throw new PackagerException(ipe, exceptionKey, s);\n-        }\n-\n-        for (int i = 0; i < s.length(); i++) {\n-            char a = s.charAt(i);\n-            \/\/ We check for ASCII codes first which we accept. If check fails,\n-            \/\/ check if it is acceptable extended ASCII or unicode character.\n-            if (a < ' ' || a > '~') {\n-                \/\/ Accept anything else including special chars like copyright\n-                \/\/ symbols. Note: space will be included by ASCII check above,\n-                \/\/ but other whitespace like tabs or new line will be rejected.\n-                if (Character.isISOControl(a)  ||\n-                        Character.isWhitespace(a)) {\n-                    throw new PackagerException(exceptionKey, s);\n-                }\n-            } else if (a == '\"' || a == '%') {\n-                throw new PackagerException(exceptionKey, s);\n-            }\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public void validate() throws PackagerException {\n-        boolean hasModule = (bundlerArguments.get(\n-                Arguments.CLIOptions.MODULE.getId()) != null);\n-        boolean hasAppImage = (bundlerArguments.get(\n-                Arguments.CLIOptions.PREDEFINED_APP_IMAGE.getId()) != null);\n-        boolean hasMain = (bundlerArguments.get(\n-                Arguments.CLIOptions.MAIN_JAR.getId()) != null);\n-        boolean hasRuntimeImage = (bundlerArguments.get(\n-                Arguments.CLIOptions.PREDEFINED_RUNTIME_IMAGE.getId()) != null);\n-        boolean hasInput = (bundlerArguments.get(\n-                Arguments.CLIOptions.INPUT.getId()) != null);\n-        boolean hasModulePath = (bundlerArguments.get(\n-                Arguments.CLIOptions.MODULE_PATH.getId()) != null);\n-        boolean hasMacAppStore = (bundlerArguments.get(\n-                Arguments.CLIOptions.MAC_APP_STORE.getId()) != null);\n-        boolean runtimeInstaller = !isTargetAppImage() &&\n-                !hasAppImage && !hasModule && !hasMain && hasRuntimeImage;\n-\n-        if (isTargetAppImage()) {\n-            \/\/ Module application requires --runtime-image or --module-path\n-            if (hasModule) {\n-                if (!hasModulePath && !hasRuntimeImage && !hasAppImage) {\n-                    throw new PackagerException(\"ERR_MissingArgument\",\n-                            \"--runtime-image or --module-path\");\n-                }\n-            } else {\n-                if (!hasInput && !hasAppImage) {\n-                    throw new PackagerException(\"error.no-input-parameter\");\n-                }\n-            }\n-        } else {\n-            if (!runtimeInstaller) {\n-                if (hasModule) {\n-                    if (!hasModulePath && !hasRuntimeImage && !hasAppImage) {\n-                        throw new PackagerException(\"ERR_MissingArgument\",\n-                            \"--runtime-image, --module-path or --app-image\");\n-                    }\n-                } else {\n-                    if (!hasInput && !hasAppImage) {\n-                        throw new PackagerException(\"ERR_MissingArgument\",\n-                                \"--input or --app-image\");\n-                    }\n-                }\n-            }\n-        }\n-\n-        \/\/ if bundling non-modular image, or installer without app-image\n-        \/\/ then we need some resources and a main class\n-        if (!hasModule && !hasAppImage && !runtimeInstaller && !hasMain) {\n-            throw new PackagerException(\"ERR_MissingArgument\", \"--main-jar\");\n-        }\n-\n-        String name = (String)bundlerArguments.get(\n-                Arguments.CLIOptions.NAME.getId());\n-        validateName(name, true);\n-\n-        \/\/ Validate app image if set\n-        String appImage = (String)bundlerArguments.get(\n-                Arguments.CLIOptions.PREDEFINED_APP_IMAGE.getId());\n-        if (appImage != null) {\n-            Path appImageDir = Path.of(appImage);\n-            if (!Files.exists(appImageDir)\n-                    || appImageDir.toFile().list() == null\n-                    || appImageDir.toFile().list().length == 0) {\n-                throw new PackagerException(\"ERR_AppImageNotExist\", appImage);\n-            }\n-        }\n-\n-        \/\/ Validate temp dir\n-        String root = (String)bundlerArguments.get(\n-                Arguments.CLIOptions.TEMP_ROOT.getId());\n-        if (root != null && Files.exists(Path.of(root))) {\n-            try (Stream<Path> stream = Files.walk(Path.of(root), 1)) {\n-                Path [] contents = stream.toArray(Path[]::new);\n-                \/\/ contents.length > 1 because Files.walk(path) includes path\n-                if (contents != null && contents.length > 1) {\n-                    throw new PackagerException(\n-                            \"ERR_BuildRootInvalid\", root);\n-                }\n-            } catch (IOException ioe) {\n-                throw new PackagerException(ioe);\n-            }\n-        }\n-\n-        \/\/ Validate resource dir\n-        String resources = (String)bundlerArguments.get(\n-                Arguments.CLIOptions.RESOURCE_DIR.getId());\n-        if (resources != null) {\n-            if (!(Files.exists(Path.of(resources)))) {\n-                throw new PackagerException(\n-                    \"message.resource-dir-does-not-exist\",\n-                    Arguments.CLIOptions.RESOURCE_DIR.getId(), resources);\n-            }\n-        }\n-\n-        \/\/ Validate predefined runtime dir\n-        String runtime = (String)bundlerArguments.get(\n-                Arguments.CLIOptions.PREDEFINED_RUNTIME_IMAGE.getId());\n-        if (runtime != null) {\n-            if (!(Files.exists(Path.of(runtime)))) {\n-                throw new PackagerException(\n-                    \"message.runtime-image-dir-does-not-exist\",\n-                    Arguments.CLIOptions.PREDEFINED_RUNTIME_IMAGE.getId(),\n-                    runtime);\n-            }\n-        }\n-\n-\n-        \/\/ Validate license file if set\n-        String license = (String)bundlerArguments.get(\n-                Arguments.CLIOptions.LICENSE_FILE.getId());\n-        if (license != null) {\n-            if (!(Files.exists(Path.of(license)))) {\n-                throw new PackagerException(\"ERR_LicenseFileNotExit\");\n-            }\n-        }\n-\n-        \/\/ Validate icon file if set\n-        String icon = (String)bundlerArguments.get(\n-                Arguments.CLIOptions.ICON.getId());\n-        if (icon != null) {\n-            if (!(Files.exists(Path.of(icon)))) {\n-                throw new PackagerException(\"ERR_IconFileNotExit\",\n-                        Path.of(icon).toAbsolutePath().toString());\n-            }\n-        }\n-\n-\n-        if (hasMacAppStore) {\n-            \/\/ Validate jlink-options if mac-app-store is set\n-            Object jlinkOptions = bundlerArguments.get(\n-                    Arguments.CLIOptions.JLINK_OPTIONS.getId());\n-            if (jlinkOptions instanceof List) {\n-                List<String> options = (List<String>) jlinkOptions;\n-                if (!options.contains(\"--strip-native-commands\")) {\n-                    throw new PackagerException(\n-                            \"ERR_MissingJLinkOptMacAppStore\",\n-                            \"--strip-native-commands\");\n-                }\n-            }\n-        }\n-    }\n-\n-    void setTargetFormat(String t) {\n-        targetFormat = t;\n-    }\n-\n-    String getTargetFormat() {\n-        return targetFormat;\n-    }\n-\n-    boolean isTargetAppImage() {\n-        return (\"app-image\".equals(targetFormat));\n-    }\n-\n-    private static final Set<String> multi_args = new TreeSet<>(Arrays.asList(\n-            StandardBundlerParam.JAVA_OPTIONS.getID(),\n-            StandardBundlerParam.ARGUMENTS.getID(),\n-            StandardBundlerParam.MODULE_PATH.getID(),\n-            StandardBundlerParam.ADD_MODULES.getID(),\n-            StandardBundlerParam.LIMIT_MODULES.getID(),\n-            StandardBundlerParam.FILE_ASSOCIATIONS.getID(),\n-            StandardBundlerParam.DMG_CONTENT.getID(),\n-            StandardBundlerParam.APP_CONTENT.getID(),\n-            StandardBundlerParam.JLINK_OPTIONS.getID()\n-    ));\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public void addBundleArgument(String key, Object value) {\n-        \/\/ special hack for multi-line arguments\n-        if (multi_args.contains(key)) {\n-            Object existingValue = bundlerArguments.get(key);\n-            if (existingValue instanceof String && value instanceof String) {\n-                String delim = \"\\n\\n\";\n-                if (key.equals(StandardBundlerParam.MODULE_PATH.getID())) {\n-                    delim = File.pathSeparator;\n-                } else if (\n-                        key.equals(StandardBundlerParam.DMG_CONTENT.getID()) ||\n-                        key.equals(StandardBundlerParam.APP_CONTENT.getID()) ||\n-                        key.equals(StandardBundlerParam.ADD_MODULES.getID())) {\n-                    delim = \",\";\n-                }\n-                bundlerArguments.put(key, existingValue + delim + value);\n-            } else if (existingValue instanceof List && value instanceof List) {\n-                ((List)existingValue).addAll((List)value);\n-            } else if (existingValue instanceof Map &&\n-                value instanceof String && ((String)value).contains(\"=\")) {\n-                String[] mapValues = ((String)value).split(\"=\", 2);\n-                ((Map)existingValue).put(mapValues[0], mapValues[1]);\n-            } else {\n-                bundlerArguments.put(key, value);\n-            }\n-        } else {\n-            bundlerArguments.put(key, value);\n-        }\n-    }\n-\n-    BundleParams getBundleParams() {\n-        BundleParams bundleParams = new BundleParams();\n-\n-        \/\/ check for collisions\n-        TreeSet<String> keys = new TreeSet<>(bundlerArguments.keySet());\n-        keys.retainAll(bundleParams.getBundleParamsAsMap().keySet());\n-\n-        if (!keys.isEmpty()) {\n-            throw new RuntimeException(\"Deploy Params and Bundler Arguments \"\n-                    + \"overlap in the following values:\" + keys.toString());\n-        }\n-\n-        bundleParams.addAllBundleParams(bundlerArguments);\n-\n-        return bundleParams;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"DeployParams {\" + \"output: \" + \"}\";\n-    }\n-\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/DeployParams.java","additions":0,"deletions":362,"binary":false,"changes":362,"status":"deleted"},{"patch":"@@ -114,0 +114,4 @@\n+        Optional<String> description() {\n+            return Optional.ofNullable(description);\n+        }\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/FileAssociationGroup.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,237 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.ApplicationBuilder.normalizeIcons;\n+import static jdk.jpackage.internal.JLinkRuntimeBuilder.ensureBaseModuleInModulePath;\n+import static jdk.jpackage.internal.OptionUtils.isRuntimeInstaller;\n+import static jdk.jpackage.internal.cli.StandardOption.ABOUT_URL;\n+import static jdk.jpackage.internal.cli.StandardOption.ADDITIONAL_LAUNCHERS;\n+import static jdk.jpackage.internal.cli.StandardOption.ADD_MODULES;\n+import static jdk.jpackage.internal.cli.StandardOption.APP_CONTENT;\n+import static jdk.jpackage.internal.cli.StandardOption.APP_VERSION;\n+import static jdk.jpackage.internal.cli.StandardOption.COPYRIGHT;\n+import static jdk.jpackage.internal.cli.StandardOption.DESCRIPTION;\n+import static jdk.jpackage.internal.cli.StandardOption.INPUT;\n+import static jdk.jpackage.internal.cli.StandardOption.INSTALL_DIR;\n+import static jdk.jpackage.internal.cli.StandardOption.JLINK_OPTIONS;\n+import static jdk.jpackage.internal.cli.StandardOption.LICENSE_FILE;\n+import static jdk.jpackage.internal.cli.StandardOption.MODULE_PATH;\n+import static jdk.jpackage.internal.cli.StandardOption.NAME;\n+import static jdk.jpackage.internal.cli.StandardOption.PREDEFINED_APP_IMAGE;\n+import static jdk.jpackage.internal.cli.StandardOption.PREDEFINED_RUNTIME_IMAGE;\n+import static jdk.jpackage.internal.cli.StandardOption.RESOURCE_DIR;\n+import static jdk.jpackage.internal.cli.StandardOption.VENDOR;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import jdk.jpackage.internal.cli.Options;\n+import jdk.jpackage.internal.model.Application;\n+import jdk.jpackage.internal.model.ApplicationLaunchers;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.model.Launcher;\n+import jdk.jpackage.internal.model.LauncherModularStartupInfo;\n+import jdk.jpackage.internal.model.PackageType;\n+import jdk.jpackage.internal.model.RuntimeLayout;\n+\n+final class FromOptions {\n+\n+    static ApplicationBuilderBuilder buildApplicationBuilder() {\n+        return new ApplicationBuilderBuilder();\n+    }\n+\n+    static PackageBuilder createPackageBuilder(Options options, Application app, PackageType type) {\n+\n+        final var builder = new PackageBuilder(app, type);\n+\n+        NAME.ifPresentIn(options, builder::name);\n+        DESCRIPTION.ifPresentIn(options, builder::description);\n+        APP_VERSION.ifPresentIn(options, builder::version);\n+        ABOUT_URL.ifPresentIn(options, builder::aboutURL);\n+        LICENSE_FILE.ifPresentIn(options, builder::licenseFile);\n+        PREDEFINED_APP_IMAGE.ifPresentIn(options, builder::predefinedAppImage);\n+        PREDEFINED_RUNTIME_IMAGE.ifPresentIn(options, builder::predefinedAppImage);\n+        INSTALL_DIR.ifPresentIn(options, builder::installDir);\n+\n+        return builder;\n+    }\n+\n+\n+    static final class ApplicationBuilderBuilder {\n+\n+        private ApplicationBuilderBuilder() {\n+        }\n+\n+        <T extends Launcher> ApplicationBuilder create(Options options,\n+                Function<Options, Launcher> launcherCtor,\n+                BiFunction<T, Launcher, T> launcherOverrideCtor,\n+                ApplicationLayout appLayout) {\n+\n+            final Optional<RuntimeLayout> thePredefinedRuntimeLayout;\n+            if (PREDEFINED_RUNTIME_IMAGE.containsIn(options)) {\n+                thePredefinedRuntimeLayout = Optional.ofNullable(\n+                        predefinedRuntimeLayout).or(() -> Optional.of(RuntimeLayout.DEFAULT));\n+            } else {\n+                thePredefinedRuntimeLayout = Optional.empty();\n+            }\n+\n+            final var transfomer = new OptionsTransformer(options, appLayout);\n+            final var appBuilder = createApplicationBuilder(\n+                    transfomer.appOptions(),\n+                    launcherCtor,\n+                    launcherOverrideCtor,\n+                    appLayout,\n+                    Optional.ofNullable(runtimeLayout).orElse(RuntimeLayout.DEFAULT),\n+                    thePredefinedRuntimeLayout);\n+\n+            transfomer.externalApp().ifPresent(appBuilder::externalApplication);\n+\n+            return appBuilder;\n+        }\n+\n+        \/**\n+         * Sets the layout of the predefined runtime image.\n+         * @param v the layout of the predefined runtime image. Null is permitted.\n+         * @return this\n+         *\/\n+        ApplicationBuilderBuilder predefinedRuntimeLayout(RuntimeLayout v) {\n+            predefinedRuntimeLayout = v;\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets the layout of a runtime bundle.\n+         * @param v the layout of a runtime bundle. Null is permitted.\n+         * @return this\n+         *\/\n+        ApplicationBuilderBuilder runtimeLayout(RuntimeLayout v) {\n+            runtimeLayout = v;\n+            return this;\n+        }\n+\n+        private RuntimeLayout runtimeLayout;\n+        private RuntimeLayout predefinedRuntimeLayout;\n+    }\n+\n+\n+    private static <T extends Launcher> ApplicationBuilder createApplicationBuilder(Options options,\n+            Function<Options, Launcher> launcherCtor,\n+            BiFunction<T, Launcher, T> launcherOverrideCtor,\n+            ApplicationLayout appLayout, RuntimeLayout runtimeLayout,\n+            Optional<RuntimeLayout> predefinedRuntimeLayout) {\n+\n+        final var appBuilder = new ApplicationBuilder();\n+\n+        final var isRuntimeInstaller = isRuntimeInstaller(options);\n+\n+        final var predefinedRuntimeImage = PREDEFINED_RUNTIME_IMAGE.findIn(options);\n+\n+        final var predefinedRuntimeDirectory = predefinedRuntimeLayout.flatMap(layout -> {\n+            return predefinedRuntimeImage.map(layout::resolveAt);\n+        }).map(RuntimeLayout::runtimeDirectory);\n+\n+        NAME.findIn(options).or(() -> {\n+            if (isRuntimeInstaller) {\n+                return predefinedRuntimeImage.map(Path::getFileName).map(Path::toString);\n+            } else {\n+                return Optional.empty();\n+            }\n+        }).ifPresent(appBuilder::name);\n+        DESCRIPTION.ifPresentIn(options, appBuilder::description);\n+        APP_VERSION.ifPresentIn(options, appBuilder::version);\n+        VENDOR.ifPresentIn(options, appBuilder::vendor);\n+        COPYRIGHT.ifPresentIn(options, appBuilder::copyright);\n+        INPUT.ifPresentIn(options, appBuilder::srcDir);\n+        APP_CONTENT.ifPresentIn(options, appBuilder::contentDirs);\n+\n+        if (isRuntimeInstaller) {\n+            appBuilder.appImageLayout(runtimeLayout);\n+        } else {\n+            appBuilder.appImageLayout(appLayout);\n+\n+            final var launchers = createLaunchers(options, launcherCtor);\n+\n+            if (PREDEFINED_APP_IMAGE.containsIn(options)) {\n+                appBuilder.launchers(launchers);\n+            } else {\n+                appBuilder.launchers(normalizeIcons(launchers, RESOURCE_DIR.findIn(options), launcherOverrideCtor));\n+\n+                final var runtimeBuilderBuilder = new RuntimeBuilderBuilder();\n+\n+                runtimeBuilderBuilder.modulePath(ensureBaseModuleInModulePath(MODULE_PATH.findIn(options).orElseGet(List::of)));\n+\n+                if (!APP_VERSION.containsIn(options)) {\n+                    \/\/ Version is not specified explicitly. Try to get it from the app's module.\n+                    launchers.mainLauncher().startupInfo().ifPresent(startupInfo -> {\n+                        if (startupInfo instanceof LauncherModularStartupInfo modularStartupInfo) {\n+                            modularStartupInfo.moduleVersion().ifPresent(moduleVersion -> {\n+                                appBuilder.version(moduleVersion);\n+                                Log.verbose(I18N.format(\"message.module-version\",\n+                                        moduleVersion, modularStartupInfo.moduleName()));\n+                            });\n+                        }\n+                    });\n+                }\n+\n+                predefinedRuntimeDirectory.ifPresentOrElse(runtimeBuilderBuilder::forRuntime, () -> {\n+                    final var startupInfos = launchers.asList().stream()\n+                            .map(Launcher::startupInfo)\n+                            .map(Optional::orElseThrow).toList();\n+                    final var jlinkOptionsBuilder = runtimeBuilderBuilder.forNewRuntime(startupInfos);\n+                    ADD_MODULES.findIn(options).map(Set::copyOf).ifPresent(jlinkOptionsBuilder::addModules);\n+                    JLINK_OPTIONS.ifPresentIn(options, jlinkOptionsBuilder::options);\n+                    jlinkOptionsBuilder.apply();\n+                });\n+\n+                appBuilder.runtimeBuilder(runtimeBuilderBuilder.create());\n+            }\n+        }\n+\n+        return appBuilder;\n+    }\n+\n+    private static ApplicationLaunchers createLaunchers(Options options, Function<Options, Launcher> launcherCtor) {\n+        var launchers = ADDITIONAL_LAUNCHERS.getFrom(options);\n+\n+        var mainLauncher = launcherCtor.apply(options);\n+\n+        \/\/\n+        \/\/ Additional launcher should:\n+        \/\/  - Use description from the main launcher by default.\n+        \/\/\n+        var mainLauncherDefaults = Options.of(Map.of(DESCRIPTION, mainLauncher.description()));\n+\n+        var additionalLaunchers = launchers.stream().map(launcherOptions -> {\n+            return launcherOptions.copyWithParent(mainLauncherDefaults);\n+        }).map(launcherCtor).toList();\n+\n+        return new ApplicationLaunchers(mainLauncher, additionalLaunchers);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/FromOptions.java","additions":237,"deletions":0,"binary":false,"changes":237,"status":"added"},{"patch":"@@ -1,251 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import static jdk.jpackage.internal.Arguments.CLIOptions.LINUX_SHORTCUT_HINT;\n-import static jdk.jpackage.internal.Arguments.CLIOptions.WIN_MENU_HINT;\n-import static jdk.jpackage.internal.Arguments.CLIOptions.WIN_SHORTCUT_HINT;\n-import static jdk.jpackage.internal.StandardBundlerParam.ABOUT_URL;\n-import static jdk.jpackage.internal.StandardBundlerParam.ADD_LAUNCHERS;\n-import static jdk.jpackage.internal.StandardBundlerParam.ADD_MODULES;\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_CONTENT;\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;\n-import static jdk.jpackage.internal.StandardBundlerParam.COPYRIGHT;\n-import static jdk.jpackage.internal.StandardBundlerParam.DESCRIPTION;\n-import static jdk.jpackage.internal.StandardBundlerParam.FILE_ASSOCIATIONS;\n-import static jdk.jpackage.internal.StandardBundlerParam.ICON;\n-import static jdk.jpackage.internal.StandardBundlerParam.INSTALLER_NAME;\n-import static jdk.jpackage.internal.StandardBundlerParam.INSTALL_DIR;\n-import static jdk.jpackage.internal.StandardBundlerParam.JLINK_OPTIONS;\n-import static jdk.jpackage.internal.StandardBundlerParam.LAUNCHER_AS_SERVICE;\n-import static jdk.jpackage.internal.StandardBundlerParam.LICENSE_FILE;\n-import static jdk.jpackage.internal.StandardBundlerParam.LIMIT_MODULES;\n-import static jdk.jpackage.internal.StandardBundlerParam.MODULE_PATH;\n-import static jdk.jpackage.internal.StandardBundlerParam.NAME;\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE;\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE_FILE;\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_RUNTIME_IMAGE;\n-import static jdk.jpackage.internal.StandardBundlerParam.RESOURCE_DIR;\n-import static jdk.jpackage.internal.StandardBundlerParam.SOURCE_DIR;\n-import static jdk.jpackage.internal.StandardBundlerParam.VENDOR;\n-import static jdk.jpackage.internal.StandardBundlerParam.VERSION;\n-import static jdk.jpackage.internal.StandardBundlerParam.hasPredefinedAppImage;\n-import static jdk.jpackage.internal.StandardBundlerParam.isRuntimeInstaller;\n-import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n-\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.function.BiFunction;\n-import java.util.function.Function;\n-import jdk.jpackage.internal.model.Application;\n-import jdk.jpackage.internal.model.ApplicationLaunchers;\n-import jdk.jpackage.internal.model.ApplicationLayout;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.ExternalApplication;\n-import jdk.jpackage.internal.model.ExternalApplication.LauncherInfo;\n-import jdk.jpackage.internal.model.Launcher;\n-import jdk.jpackage.internal.model.LauncherShortcut;\n-import jdk.jpackage.internal.model.LauncherShortcutStartupDirectory;\n-import jdk.jpackage.internal.model.PackageType;\n-import jdk.jpackage.internal.model.ParseUtils;\n-import jdk.jpackage.internal.model.RuntimeLayout;\n-import jdk.jpackage.internal.util.function.ThrowingFunction;\n-\n-final class FromParams {\n-\n-    static <T extends Launcher> ApplicationBuilder createApplicationBuilder(Map<String, ? super Object> params,\n-            Function<Map<String, ? super Object>, Launcher> launcherMapper,\n-            BiFunction<T, Launcher, T> launcherOverrideCtor,\n-            ApplicationLayout appLayout) throws ConfigException, IOException {\n-        return createApplicationBuilder(params, launcherMapper, launcherOverrideCtor, appLayout, RuntimeLayout.DEFAULT, Optional.of(RuntimeLayout.DEFAULT));\n-    }\n-\n-    static <T extends Launcher> ApplicationBuilder createApplicationBuilder(Map<String, ? super Object> params,\n-            Function<Map<String, ? super Object>, Launcher> launcherMapper,\n-            BiFunction<T, Launcher, T> launcherOverrideCtor,\n-            ApplicationLayout appLayout, RuntimeLayout runtimeLayout,\n-            Optional<RuntimeLayout> predefinedRuntimeLayout) throws ConfigException, IOException {\n-\n-        final var appBuilder = new ApplicationBuilder();\n-\n-        APP_NAME.copyInto(params, appBuilder::name);\n-        DESCRIPTION.copyInto(params, appBuilder::description);\n-        appBuilder.version(VERSION.fetchFrom(params));\n-        VENDOR.copyInto(params, appBuilder::vendor);\n-        COPYRIGHT.copyInto(params, appBuilder::copyright);\n-        SOURCE_DIR.copyInto(params, appBuilder::srcDir);\n-        APP_CONTENT.copyInto(params, appBuilder::contentDirs);\n-\n-        final var isRuntimeInstaller = isRuntimeInstaller(params);\n-\n-        final var predefinedRuntimeImage = PREDEFINED_RUNTIME_IMAGE.findIn(params);\n-\n-        final var predefinedRuntimeDirectory = predefinedRuntimeLayout.flatMap(\n-                layout -> predefinedRuntimeImage.map(layout::resolveAt)).map(RuntimeLayout::runtimeDirectory);\n-\n-        if (isRuntimeInstaller) {\n-            appBuilder.appImageLayout(runtimeLayout);\n-        } else {\n-            appBuilder.appImageLayout(appLayout);\n-\n-            if (hasPredefinedAppImage(params)) {\n-                final var appImageFile = PREDEFINED_APP_IMAGE_FILE.fetchFrom(params);\n-                appBuilder.initFromExternalApplication(appImageFile, launcherInfo -> {\n-                    var launcherParams = mapLauncherInfo(appImageFile, launcherInfo);\n-                    return launcherMapper.apply(mergeParams(params, launcherParams));\n-                });\n-            } else {\n-                final var launchers = createLaunchers(params, launcherMapper);\n-\n-                final var runtimeBuilderBuilder = new RuntimeBuilderBuilder();\n-\n-                runtimeBuilderBuilder.modulePath(MODULE_PATH.fetchFrom(params));\n-\n-                predefinedRuntimeDirectory.ifPresentOrElse(runtimeBuilderBuilder::forRuntime, () -> {\n-                    final var startupInfos = launchers.asList().stream()\n-                            .map(Launcher::startupInfo)\n-                            .map(Optional::orElseThrow).toList();\n-                    final var jlinkOptionsBuilder = runtimeBuilderBuilder.forNewRuntime(startupInfos);\n-                    ADD_MODULES.copyInto(params, jlinkOptionsBuilder::addModules);\n-                    LIMIT_MODULES.copyInto(params, jlinkOptionsBuilder::limitModules);\n-                    JLINK_OPTIONS.copyInto(params, jlinkOptionsBuilder::options);\n-                    jlinkOptionsBuilder.apply();\n-                });\n-\n-                final var normalizedLaunchers = ApplicationBuilder.normalizeIcons(launchers, RESOURCE_DIR.findIn(params), launcherOverrideCtor);\n-\n-                appBuilder.launchers(normalizedLaunchers).runtimeBuilder(runtimeBuilderBuilder.create());\n-            }\n-        }\n-\n-        return appBuilder;\n-    }\n-\n-    static PackageBuilder createPackageBuilder(\n-            Map<String, ? super Object> params, Application app,\n-            PackageType type) throws ConfigException {\n-\n-        final var builder = new PackageBuilder(app, type);\n-\n-        builder.name(INSTALLER_NAME.fetchFrom(params));\n-        DESCRIPTION.copyInto(params, builder::description);\n-        VERSION.copyInto(params, builder::version);\n-        ABOUT_URL.copyInto(params, builder::aboutURL);\n-        LICENSE_FILE.findIn(params).map(Path::of).ifPresent(builder::licenseFile);\n-        PREDEFINED_APP_IMAGE.findIn(params).ifPresent(builder::predefinedAppImage);\n-        PREDEFINED_RUNTIME_IMAGE.findIn(params).ifPresent(builder::predefinedAppImage);\n-        INSTALL_DIR.findIn(params).map(Path::of).ifPresent(builder::installDir);\n-\n-        return builder;\n-    }\n-\n-    static <T extends Application> BundlerParamInfo<T> createApplicationBundlerParam(\n-            ThrowingFunction<Map<String, ? super Object>, T> ctor) {\n-        return BundlerParamInfo.createBundlerParam(Application.class, ctor);\n-    }\n-\n-    static <T extends jdk.jpackage.internal.model.Package> BundlerParamInfo<T> createPackageBundlerParam(\n-            ThrowingFunction<Map<String, ? super Object>, T> ctor) {\n-        return BundlerParamInfo.createBundlerParam(jdk.jpackage.internal.model.Package.class, ctor);\n-    }\n-\n-    static Optional<jdk.jpackage.internal.model.Package> getCurrentPackage(Map<String, ? super Object> params) {\n-        return Optional.ofNullable((jdk.jpackage.internal.model.Package)params.get(\n-                jdk.jpackage.internal.model.Package.class.getName()));\n-    }\n-\n-    static Optional<LauncherShortcut> findLauncherShortcut(\n-            BundlerParamInfo<String> shortcutParam,\n-            Map<String, ? super Object> mainParams,\n-            Map<String, ? super Object> launcherParams) {\n-\n-        Optional<String> launcherValue;\n-        if (launcherParams == mainParams) {\n-            \/\/ The main launcher\n-            launcherValue = Optional.empty();\n-        } else {\n-            launcherValue = shortcutParam.findIn(launcherParams);\n-        }\n-\n-        return launcherValue.map(ParseUtils::parseLauncherShortcutForAddLauncher).or(() -> {\n-            return Optional.ofNullable(mainParams.get(shortcutParam.getID())).map(toFunction(value -> {\n-                if (value instanceof Boolean) {\n-                    return new LauncherShortcut(LauncherShortcutStartupDirectory.DEFAULT);\n-                } else {\n-                    try {\n-                        return ParseUtils.parseLauncherShortcutForMainLauncher((String)value);\n-                    } catch (IllegalArgumentException ex) {\n-                        throw I18N.buildConfigException(\"error.invalid-option-value\", value, \"--\" + shortcutParam.getID()).create();\n-                    }\n-                }\n-            }));\n-        });\n-    }\n-\n-    private static ApplicationLaunchers createLaunchers(\n-            Map<String, ? super Object> params,\n-            Function<Map<String, ? super Object>, Launcher> launcherMapper) {\n-        var launchers = ADD_LAUNCHERS.findIn(params).orElseGet(List::of);\n-\n-        var mainLauncher = launcherMapper.apply(params);\n-        var additionalLaunchers = launchers.stream().map(launcherParams -> {\n-            return launcherMapper.apply(mergeParams(params, launcherParams));\n-        }).toList();\n-\n-        return new ApplicationLaunchers(mainLauncher, additionalLaunchers);\n-    }\n-\n-    private static Map<String, ? super Object> mapLauncherInfo(ExternalApplication appImageFile, LauncherInfo launcherInfo) {\n-        Map<String, ? super Object> launcherParams = new HashMap<>();\n-        launcherParams.put(NAME.getID(), launcherInfo.name());\n-        if (!appImageFile.getLauncherName().equals(launcherInfo.name())) {\n-            \/\/ This is not the main launcher, accept the value\n-            \/\/ of \"launcher-as-service\" from the app image file (.jpackage.xml).\n-            launcherParams.put(LAUNCHER_AS_SERVICE.getID(), Boolean.toString(launcherInfo.service()));\n-        }\n-        launcherParams.putAll(launcherInfo.extra());\n-        return launcherParams;\n-    }\n-\n-    private static Map<String, ? super Object> mergeParams(Map<String, ? super Object> mainParams,\n-            Map<String, ? super Object> launcherParams) {\n-        if (!launcherParams.containsKey(DESCRIPTION.getID())) {\n-            launcherParams = new HashMap<>(launcherParams);\n-\/\/ FIXME: this is a good improvement but it fails existing tests\n-\/\/            launcherParams.put(DESCRIPTION.getID(), String.format(\"%s (%s)\", DESCRIPTION.fetchFrom(\n-\/\/                    mainParams), APP_NAME.fetchFrom(launcherParams)));\n-            launcherParams.put(DESCRIPTION.getID(), DESCRIPTION.fetchFrom(mainParams));\n-        }\n-        return AddLauncherArguments.merge(mainParams, launcherParams, ICON.getID(),\n-                ADD_LAUNCHERS.getID(), FILE_ASSOCIATIONS.getID(), WIN_MENU_HINT.getId(),\n-                WIN_SHORTCUT_HINT.getId(), LINUX_SHORTCUT_HINT.getId());\n-    }\n-\n-    static final BundlerParamInfo<Application> APPLICATION = createApplicationBundlerParam(null);\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/FromParams.java","additions":0,"deletions":251,"binary":false,"changes":251,"status":"deleted"},{"patch":"@@ -35,1 +35,1 @@\n-import jdk.jpackage.internal.model.PackagerException;\n+import jdk.jpackage.internal.model.JPackageException;\n@@ -93,1 +93,1 @@\n-    static void writableOutputDir(Path outdir) throws PackagerException {\n+    static void writableOutputDir(Path outdir) {\n@@ -98,2 +98,1 @@\n-                throw new PackagerException(\"error.cannot-create-output-dir\",\n-                    outdir.toAbsolutePath().toString());\n+                throw new JPackageException(I18N.format(\"error.cannot-create-output-dir\", outdir.toAbsolutePath()));\n@@ -104,2 +103,1 @@\n-            throw new PackagerException(\"error.cannot-write-to-output-dir\",\n-                    outdir.toAbsolutePath().toString());\n+            throw new JPackageException(I18N.format(\"error.cannot-write-to-output-dir\", outdir.toAbsolutePath()));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/IOUtils.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import java.text.MessageFormat;\n@@ -55,0 +54,1 @@\n+import jdk.jpackage.internal.model.JPackageException;\n@@ -57,1 +57,0 @@\n-import jdk.jpackage.internal.model.PackagerException;\n@@ -67,1 +66,1 @@\n-    public void create(AppImageLayout appImageLayout) throws PackagerException {\n+    public void create(AppImageLayout appImageLayout) {\n@@ -82,1 +81,1 @@\n-            throw new PackagerException(\"error.jlink.failed\", jlinkOut);\n+            throw new JPackageException(I18N.format(\"error.jlink.failed\", jlinkOut));\n@@ -180,2 +179,1 @@\n-                    throw new ConfigException(MessageFormat.format(I18N.getString(\n-                            \"error.blocked.option\"), option), null);\n+                    throw I18N.buildConfigException(\"error.blocked.option\", option).create();\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/JLinkRuntimeBuilder.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,58 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.io.PrintWriter;\n-import java.util.Optional;\n-import java.util.spi.ToolProvider;\n-\n-\/**\n- * JPackageToolProvider\n- *\n- * This is the ToolProvider implementation exported\n- * to java.util.spi.ToolProvider and ultimately javax.tools.ToolProvider\n- *\/\n-public class JPackageToolProvider implements ToolProvider {\n-\n-    public String name() {\n-        return \"jpackage\";\n-    }\n-\n-    public Optional<String> description() {\n-        return Optional.of(jdk.jpackage.main.Main.I18N.getString(\"jpackage.description\"));\n-    }\n-\n-    public synchronized int run(\n-            PrintWriter out, PrintWriter err, String... args) {\n-        try {\n-            return new jdk.jpackage.main.Main().execute(out, err, args);\n-        } catch (RuntimeException re) {\n-            Log.fatalError(re.getMessage());\n-            Log.verbose(re);\n-            return 1;\n-        }\n-    }\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/JPackageToolProvider.java","additions":0,"deletions":58,"binary":false,"changes":58,"status":"deleted"},{"patch":"@@ -1,307 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import jdk.jpackage.internal.model.ConfigException;\n-import java.io.File;\n-import java.io.IOException;\n-import java.lang.module.ModuleReference;\n-import java.nio.file.Files;\n-import java.nio.file.InvalidPathException;\n-import java.nio.file.Path;\n-import java.text.MessageFormat;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.function.Supplier;\n-import java.util.jar.Attributes;\n-import java.util.jar.JarFile;\n-import java.util.jar.Manifest;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_RUNTIME_IMAGE;\n-\n-\/**\n- * Extracts data needed to run application from parameters.\n- *\/\n-final class LauncherData {\n-    boolean isModular() {\n-        return moduleInfo != null;\n-    }\n-\n-    String qualifiedClassName() {\n-        return qualifiedClassName;\n-    }\n-\n-    boolean isClassNameFromMainJar() {\n-        return jarMainClass != null;\n-    }\n-\n-    String packageName() {\n-        int sepIdx = qualifiedClassName.lastIndexOf('.');\n-        if (sepIdx < 0) {\n-            return \"\";\n-        }\n-        return qualifiedClassName.substring(sepIdx + 1);\n-    }\n-\n-    String moduleName() {\n-        verifyIsModular(true);\n-        return moduleInfo.name();\n-    }\n-\n-    List<Path> modulePath() {\n-        verifyIsModular(true);\n-        return modulePath;\n-    }\n-\n-    Path mainJarName() {\n-        verifyIsModular(false);\n-        return mainJarName;\n-    }\n-\n-    List<Path> classPath() {\n-        return classPath;\n-    }\n-\n-    String getAppVersion() {\n-        if (isModular()) {\n-            return moduleInfo.version().orElse(null);\n-        }\n-\n-        return null;\n-    }\n-\n-    private LauncherData() {\n-    }\n-\n-    private void verifyIsModular(boolean isModular) {\n-        if ((moduleInfo == null) == isModular) {\n-            throw new IllegalStateException();\n-        }\n-    }\n-\n-    static LauncherData create(Map<String, ? super Object> params) throws\n-            ConfigException, IOException {\n-\n-        final String mainModule = getMainModule(params);\n-        final LauncherData result;\n-        if (mainModule == null) {\n-            result = createNonModular(params);\n-        } else {\n-            result = createModular(mainModule, params);\n-        }\n-        result.initClasspath(params);\n-        return result;\n-    }\n-\n-    private static LauncherData createModular(String mainModule,\n-            Map<String, ? super Object> params) throws ConfigException,\n-            IOException {\n-\n-        LauncherData launcherData = new LauncherData();\n-\n-        final int sepIdx = mainModule.indexOf(\"\/\");\n-        final String moduleName;\n-        if (sepIdx > 0) {\n-            launcherData.qualifiedClassName = mainModule.substring(sepIdx + 1);\n-            moduleName = mainModule.substring(0, sepIdx);\n-        } else {\n-            moduleName = mainModule;\n-        }\n-        launcherData.modulePath = getModulePath(params);\n-\n-        \/\/ Try to find module in the specified module path list.\n-        ModuleReference moduleRef = JLinkRuntimeBuilder.createModuleFinder(\n-                launcherData.modulePath).find(moduleName).orElse(null);\n-\n-        if (moduleRef != null) {\n-            launcherData.moduleInfo = ModuleInfo.fromModuleReference(moduleRef);\n-        } else if (params.containsKey(PREDEFINED_RUNTIME_IMAGE.getID())) {\n-            \/\/ Failed to find module in the specified module path list and\n-            \/\/ there is external runtime given to jpackage.\n-            \/\/ Lookup module in this runtime.\n-            Path cookedRuntime = PREDEFINED_RUNTIME_IMAGE.fetchFrom(params);\n-            launcherData.moduleInfo = ModuleInfo.fromCookedRuntime(moduleName,\n-                    cookedRuntime).orElse(null);\n-        }\n-\n-        if (launcherData.moduleInfo == null) {\n-            throw new ConfigException(MessageFormat.format(I18N.getString(\n-                    \"error.no-module-in-path\"), moduleName), null);\n-        }\n-\n-        if (launcherData.qualifiedClassName == null) {\n-            launcherData.qualifiedClassName = launcherData.moduleInfo.mainClass().orElse(null);\n-            if (launcherData.qualifiedClassName == null) {\n-                throw new ConfigException(I18N.getString(\"ERR_NoMainClass\"), null);\n-            }\n-        }\n-\n-        return launcherData;\n-    }\n-\n-    private static LauncherData createNonModular(\n-            Map<String, ? super Object> params) throws ConfigException, IOException {\n-        LauncherData launcherData = new LauncherData();\n-\n-        launcherData.qualifiedClassName = getMainClass(params);\n-\n-        launcherData.mainJarName = getMainJarName(params);\n-\n-        Path mainJarDir = StandardBundlerParam.SOURCE_DIR.fetchFrom(params);\n-\n-        final Path mainJarPath;\n-        if (launcherData.mainJarName != null && mainJarDir != null) {\n-            mainJarPath = mainJarDir.resolve(launcherData.mainJarName);\n-            if (!Files.exists(mainJarPath)) {\n-                throw new ConfigException(MessageFormat.format(I18N.getString(\n-                        \"error.main-jar-does-not-exist\"),\n-                        launcherData.mainJarName), I18N.getString(\n-                        \"error.main-jar-does-not-exist.advice\"));\n-            }\n-        } else {\n-            mainJarPath = null;\n-        }\n-\n-        if (launcherData.qualifiedClassName == null) {\n-            if (mainJarPath == null) {\n-                throw new ConfigException(I18N.getString(\"error.no-main-class\"),\n-                        I18N.getString(\"error.no-main-class.advice\"));\n-            }\n-\n-            try (JarFile jf = new JarFile(mainJarPath.toFile())) {\n-                Manifest m = jf.getManifest();\n-                Attributes attrs = (m != null) ? m.getMainAttributes() : null;\n-                if (attrs != null) {\n-                    launcherData.qualifiedClassName = attrs.getValue(\n-                            Attributes.Name.MAIN_CLASS);\n-                    launcherData.jarMainClass = launcherData.qualifiedClassName;\n-                }\n-            }\n-        }\n-\n-        if (launcherData.qualifiedClassName == null) {\n-            throw new ConfigException(MessageFormat.format(I18N.getString(\n-                    \"error.no-main-class-with-main-jar\"),\n-                    launcherData.mainJarName), MessageFormat.format(\n-                            I18N.getString(\n-                                    \"error.no-main-class-with-main-jar.advice\"),\n-                            launcherData.mainJarName));\n-        }\n-\n-        return launcherData;\n-    }\n-\n-    private void initClasspath(Map<String, ? super Object> params)\n-            throws IOException {\n-        Path inputDir = StandardBundlerParam.SOURCE_DIR.fetchFrom(params);\n-        if (inputDir == null) {\n-            classPath = Collections.emptyList();\n-        } else {\n-            try (Stream<Path> walk = Files.walk(inputDir, Integer.MAX_VALUE)) {\n-                Set<Path> jars = walk.filter(Files::isRegularFile)\n-                        .filter(file -> file.toString().endsWith(\".jar\"))\n-                        .map(p -> inputDir.toAbsolutePath()\n-                                  .relativize(p.toAbsolutePath()))\n-                        .collect(Collectors.toSet());\n-                jars.remove(mainJarName);\n-                classPath = jars.stream().sorted().toList();\n-            }\n-        }\n-    }\n-\n-    private static String getMainClass(Map<String, ? super Object> params) {\n-       return getStringParam(params, Arguments.CLIOptions.APPCLASS.getId());\n-    }\n-\n-    private static Path getMainJarName(Map<String, ? super Object> params)\n-            throws ConfigException {\n-       return getPathParam(params, Arguments.CLIOptions.MAIN_JAR.getId());\n-    }\n-\n-    private static String getMainModule(Map<String, ? super Object> params) {\n-       return getStringParam(params, Arguments.CLIOptions.MODULE.getId());\n-    }\n-\n-    private static String getStringParam(Map<String, ? super Object> params,\n-            String paramName) {\n-        Optional<Object> value = Optional.ofNullable(params.get(paramName));\n-        return value.map(Object::toString).orElse(null);\n-    }\n-\n-    private static <T> T getPathParam(String paramName, Supplier<T> func) throws ConfigException {\n-        try {\n-            return func.get();\n-        } catch (InvalidPathException ex) {\n-            throw new ConfigException(MessageFormat.format(I18N.getString(\n-                    \"error.not-path-parameter\"), paramName,\n-                    ex.getLocalizedMessage()), null, ex);\n-        }\n-    }\n-\n-    private static Path getPathParam(Map<String, ? super Object> params,\n-            String paramName) throws ConfigException {\n-        return getPathParam(paramName, () -> {\n-            String value = getStringParam(params, paramName);\n-            Path result = null;\n-            if (value != null) {\n-                result = Path.of(value);\n-            }\n-            return result;\n-        });\n-    }\n-\n-    private static List<Path> getModulePath(Map<String, ? super Object> params)\n-            throws ConfigException {\n-        List<Path> modulePath = getPathListParameter(Arguments.CLIOptions.MODULE_PATH.getId(), params);\n-\n-        if (params.containsKey(PREDEFINED_RUNTIME_IMAGE.getID())) {\n-            Path runtimePath = PREDEFINED_RUNTIME_IMAGE.fetchFrom(params);\n-            runtimePath = runtimePath.resolve(\"lib\");\n-            modulePath = Stream.of(modulePath, List.of(runtimePath))\n-                    .flatMap(List::stream)\n-                    .toList();\n-        }\n-\n-        return modulePath;\n-    }\n-\n-    private static List<Path> getPathListParameter(String paramName,\n-            Map<String, ? super Object> params) throws ConfigException {\n-        return getPathParam(paramName, () ->\n-                params.get(paramName) instanceof String value ?\n-                        Stream.of(value.split(File.pathSeparator)).map(Path::of).toList() : List.of());\n-    }\n-\n-    private String qualifiedClassName;\n-    private String jarMainClass;\n-    private Path mainJarName;\n-    private List<Path> classPath;\n-    private List<Path> modulePath;\n-    private ModuleInfo moduleInfo;\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/LauncherData.java","additions":0,"deletions":307,"binary":false,"changes":307,"status":"deleted"},{"patch":"@@ -0,0 +1,189 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.cli.StandardOption.APPCLASS;\n+import static jdk.jpackage.internal.cli.StandardOption.ARGUMENTS;\n+import static jdk.jpackage.internal.cli.StandardOption.DESCRIPTION;\n+import static jdk.jpackage.internal.cli.StandardOption.FILE_ASSOCIATIONS;\n+import static jdk.jpackage.internal.cli.StandardOption.ICON;\n+import static jdk.jpackage.internal.cli.StandardOption.INPUT;\n+import static jdk.jpackage.internal.cli.StandardOption.JAVA_OPTIONS;\n+import static jdk.jpackage.internal.cli.StandardOption.LAUNCHER_AS_SERVICE;\n+import static jdk.jpackage.internal.cli.StandardOption.MAIN_JAR;\n+import static jdk.jpackage.internal.cli.StandardOption.MODULE;\n+import static jdk.jpackage.internal.cli.StandardOption.MODULE_PATH;\n+import static jdk.jpackage.internal.cli.StandardOption.NAME;\n+import static jdk.jpackage.internal.cli.StandardOption.PREDEFINED_APP_IMAGE;\n+import static jdk.jpackage.internal.cli.StandardOption.PREDEFINED_RUNTIME_IMAGE;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.stream.IntStream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.FileAssociationGroup.FileAssociationException;\n+import jdk.jpackage.internal.FileAssociationGroup.FileAssociationNoExtensionsException;\n+import jdk.jpackage.internal.FileAssociationGroup.FileAssociationNoMimesException;\n+import jdk.jpackage.internal.cli.Options;\n+import jdk.jpackage.internal.cli.StandardFaOption;\n+import jdk.jpackage.internal.model.CustomLauncherIcon;\n+import jdk.jpackage.internal.model.DefaultLauncherIcon;\n+import jdk.jpackage.internal.model.FileAssociation;\n+import jdk.jpackage.internal.model.Launcher;\n+import jdk.jpackage.internal.model.LauncherIcon;\n+\n+final class LauncherFromOptions {\n+\n+    LauncherFromOptions() {\n+    }\n+\n+    LauncherFromOptions faGroupBuilderMutator(BiConsumer<FileAssociationGroup.Builder, LauncherBuilder> v) {\n+        faGroupBuilderMutator = v;\n+        return this;\n+    }\n+\n+    LauncherFromOptions faMapper(BiFunction<Options, FileAssociation, FileAssociation> v) {\n+        faMapper = v;\n+        return this;\n+    }\n+\n+    LauncherFromOptions faWithDefaultDescription() {\n+        return faGroupBuilderMutator((faGroupBuilder, launcherBuilder) -> {\n+            if (faGroupBuilder.description().isEmpty()) {\n+                var description = String.format(\"%s association\", launcherBuilder.create().name());\n+                faGroupBuilder.description(description);\n+            }\n+        });\n+    }\n+\n+    Launcher create(Options options) {\n+        final var builder = new LauncherBuilder().defaultIconResourceName(defaultIconResourceName());\n+\n+        DESCRIPTION.ifPresentIn(options, builder::description);\n+        builder.icon(toLauncherIcon(ICON.findIn(options).orElse(null)));\n+        LAUNCHER_AS_SERVICE.ifPresentIn(options, builder::isService);\n+        NAME.ifPresentIn(options, builder::name);\n+\n+        if (PREDEFINED_APP_IMAGE.findIn(options).isEmpty()) {\n+            final var startupInfoBuilder = new LauncherStartupInfoBuilder();\n+\n+            INPUT.ifPresentIn(options, startupInfoBuilder::inputDir);\n+            ARGUMENTS.ifPresentIn(options, startupInfoBuilder::defaultParameters);\n+            JAVA_OPTIONS.ifPresentIn(options, startupInfoBuilder::javaOptions);\n+            MAIN_JAR.ifPresentIn(options, startupInfoBuilder::mainJar);\n+            APPCLASS.ifPresentIn(options, startupInfoBuilder::mainClassName);\n+            MODULE.ifPresentIn(options, startupInfoBuilder::moduleName);\n+            MODULE_PATH.ifPresentIn(options, startupInfoBuilder::modulePath);\n+            PREDEFINED_RUNTIME_IMAGE.ifPresentIn(options, startupInfoBuilder::predefinedRuntimeImage);\n+\n+            builder.startupInfo(startupInfoBuilder.create());\n+        }\n+\n+        final var faOptionsList = FILE_ASSOCIATIONS.findIn(options).orElseGet(List::of);\n+\n+        final var faGroups = IntStream.range(0, faOptionsList.size()).mapToObj(idx -> {\n+            final var faOptions = faOptionsList.get(idx);\n+\n+            final var faGroupBuilder = FileAssociationGroup.build();\n+\n+            StandardFaOption.DESCRIPTION.ifPresentIn(faOptions, faGroupBuilder::description);\n+            StandardFaOption.ICON.ifPresentIn(faOptions, faGroupBuilder::icon);\n+            StandardFaOption.EXTENSIONS.ifPresentIn(faOptions, faGroupBuilder::extensions);\n+            StandardFaOption.CONTENT_TYPE.ifPresentIn(faOptions, faGroupBuilder::mimeTypes);\n+\n+            faGroupBuilderMutator().ifPresent(mutator -> {\n+                mutator.accept(faGroupBuilder, builder);\n+            });\n+\n+            final var faID = idx + 1;\n+\n+            final FileAssociationGroup faGroup;\n+            try {\n+                faGroup = faGroupBuilder.create();\n+            } catch (FileAssociationNoMimesException ex) {\n+                throw I18N.buildConfigException()\n+                        .message(\"error.no-content-types-for-file-association\", faID)\n+                        .advice(\"error.no-content-types-for-file-association.advice\", faID)\n+                        .create();\n+            } catch (FileAssociationNoExtensionsException ex) {\n+                \/\/ TODO: Must do something about this condition!\n+                throw new AssertionError();\n+            } catch (FileAssociationException ex) {\n+                \/\/ Should never happen\n+                throw new UnsupportedOperationException(ex);\n+            }\n+\n+            return faMapper().map(mapper -> {\n+                return new FileAssociationGroup(faGroup.items().stream().map(fa -> {\n+                    return mapper.apply(faOptions, fa);\n+                }).toList());\n+            }).orElse(faGroup);\n+\n+        }).toList();\n+\n+        return builder.faGroups(faGroups).create();\n+    }\n+\n+    private Optional<BiConsumer<FileAssociationGroup.Builder, LauncherBuilder>> faGroupBuilderMutator() {\n+        return Optional.ofNullable(faGroupBuilderMutator);\n+    }\n+\n+    private Optional<BiFunction<Options, FileAssociation, FileAssociation>> faMapper() {\n+        return Optional.ofNullable(faMapper);\n+    }\n+\n+    private static LauncherIcon toLauncherIcon(Path launcherIconPath) {\n+        if (launcherIconPath == null) {\n+            return DefaultLauncherIcon.INSTANCE;\n+        } else if (launcherIconPath.toString().isEmpty()) {\n+            return null;\n+        } else {\n+            return CustomLauncherIcon.create(launcherIconPath);\n+        }\n+    }\n+\n+    private static String defaultIconResourceName() {\n+        switch (OperatingSystem.current()) {\n+            case WINDOWS -> {\n+                return \"JavaApp.ico\";\n+            }\n+            case LINUX -> {\n+                return \"JavaApp.png\";\n+            }\n+            case MACOS -> {\n+                return \"JavaApp.icns\";\n+            }\n+            default -> {\n+                throw new UnsupportedOperationException();\n+            }\n+        }\n+    }\n+\n+    private BiConsumer<FileAssociationGroup.Builder, LauncherBuilder> faGroupBuilderMutator;\n+    private BiFunction<Options, FileAssociation, FileAssociation> faMapper;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/LauncherFromOptions.java","additions":189,"deletions":0,"binary":false,"changes":189,"status":"added"},{"patch":"@@ -1,156 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import static jdk.jpackage.internal.I18N.buildConfigException;\n-import static jdk.jpackage.internal.StandardBundlerParam.ARGUMENTS;\n-import static jdk.jpackage.internal.StandardBundlerParam.DESCRIPTION;\n-import static jdk.jpackage.internal.StandardBundlerParam.FA_CONTENT_TYPE;\n-import static jdk.jpackage.internal.StandardBundlerParam.FA_DESCRIPTION;\n-import static jdk.jpackage.internal.StandardBundlerParam.FA_EXTENSIONS;\n-import static jdk.jpackage.internal.StandardBundlerParam.FA_ICON;\n-import static jdk.jpackage.internal.StandardBundlerParam.FILE_ASSOCIATIONS;\n-import static jdk.jpackage.internal.StandardBundlerParam.ICON;\n-import static jdk.jpackage.internal.StandardBundlerParam.JAVA_OPTIONS;\n-import static jdk.jpackage.internal.StandardBundlerParam.LAUNCHER_AS_SERVICE;\n-import static jdk.jpackage.internal.StandardBundlerParam.LAUNCHER_DATA;\n-import static jdk.jpackage.internal.StandardBundlerParam.NAME;\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE;\n-import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n-\n-import java.nio.file.Path;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.function.BiFunction;\n-import java.util.stream.IntStream;\n-import jdk.internal.util.OperatingSystem;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.CustomLauncherIcon;\n-import jdk.jpackage.internal.model.DefaultLauncherIcon;\n-import jdk.jpackage.internal.model.FileAssociation;\n-import jdk.jpackage.internal.model.Launcher;\n-import jdk.jpackage.internal.model.LauncherIcon;\n-\n-record LauncherFromParams(Optional<BiFunction<FileAssociation, Map<String, ? super Object>, FileAssociation>> faExtension) {\n-\n-    LauncherFromParams {\n-        Objects.requireNonNull(faExtension);\n-    }\n-\n-    LauncherFromParams() {\n-        this(Optional.empty());\n-    }\n-\n-    Launcher create(Map<String, ? super Object> params) throws ConfigException {\n-        final var builder = new LauncherBuilder().defaultIconResourceName(defaultIconResourceName());\n-\n-        DESCRIPTION.copyInto(params, builder::description);\n-        builder.icon(toLauncherIcon(ICON.findIn(params).orElse(null)));\n-        LAUNCHER_AS_SERVICE.copyInto(params, builder::isService);\n-        NAME.copyInto(params, builder::name);\n-\n-        if (PREDEFINED_APP_IMAGE.findIn(params).isEmpty()) {\n-            final var startupInfoBuilder = new LauncherStartupInfoBuilder();\n-\n-            startupInfoBuilder.launcherData(LAUNCHER_DATA.fetchFrom(params));\n-            ARGUMENTS.copyInto(params, startupInfoBuilder::defaultParameters);\n-            JAVA_OPTIONS.copyInto(params, startupInfoBuilder::javaOptions);\n-\n-            builder.startupInfo(startupInfoBuilder.create());\n-        }\n-\n-        final var faParamsList = FILE_ASSOCIATIONS.findIn(params).orElseGet(List::of);\n-\n-        final var faGroups = IntStream.range(0, faParamsList.size()).mapToObj(idx -> {\n-            final var faParams = faParamsList.get(idx);\n-            return toSupplier(() -> {\n-                final var faGroupBuilder = FileAssociationGroup.build();\n-\n-                if (OperatingSystem.current() == OperatingSystem.MACOS) {\n-                    FA_DESCRIPTION.copyInto(faParams, faGroupBuilder::description);\n-                } else {\n-                    faGroupBuilder.description(FA_DESCRIPTION.findIn(faParams).orElseGet(() -> {\n-                        return String.format(\"%s association\", toSupplier(builder::create).get().name());\n-                    }));\n-                }\n-\n-                FA_ICON.copyInto(faParams, faGroupBuilder::icon);\n-                FA_EXTENSIONS.copyInto(faParams, faGroupBuilder::extensions);\n-                FA_CONTENT_TYPE.copyInto(faParams, faGroupBuilder::mimeTypes);\n-\n-                final var faID = idx + 1;\n-\n-                final FileAssociationGroup faGroup;\n-                try {\n-                    faGroup = faGroupBuilder.create();\n-                } catch (FileAssociationGroup.FileAssociationNoMimesException ex) {\n-                    throw buildConfigException()\n-                            .message(\"error.no-content-types-for-file-association\", faID)\n-                            .advice(\"error.no-content-types-for-file-association.advice\", faID)\n-                            .create();\n-                }\n-\n-                if (faExtension.isPresent()) {\n-                    return new FileAssociationGroup(faGroup.items().stream().map(fa -> {\n-                        return faExtension.get().apply(fa, faParams);\n-                    }).toList());\n-                } else {\n-                    return faGroup;\n-                }\n-            }).get();\n-        }).toList();\n-\n-        return builder.faGroups(faGroups).create();\n-    }\n-\n-    private static LauncherIcon toLauncherIcon(Path launcherIconPath) {\n-        if (launcherIconPath == null) {\n-            return DefaultLauncherIcon.INSTANCE;\n-        } else if (launcherIconPath.toString().isEmpty()) {\n-            return null;\n-        } else {\n-            return CustomLauncherIcon.create(launcherIconPath);\n-        }\n-    }\n-\n-    private static String defaultIconResourceName() {\n-        switch (OperatingSystem.current()) {\n-            case WINDOWS -> {\n-                return \"JavaApp.ico\";\n-            }\n-            case LINUX -> {\n-                return \"JavaApp.png\";\n-            }\n-            case MACOS -> {\n-                return \"JavaApp.icns\";\n-            }\n-            default -> {\n-                throw new UnsupportedOperationException();\n-            }\n-        }\n-    }\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/LauncherFromParams.java","additions":0,"deletions":156,"binary":false,"changes":156,"status":"deleted"},{"patch":"@@ -27,0 +27,3 @@\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n@@ -29,1 +32,9 @@\n-import java.util.function.UnaryOperator;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.jar.Attributes;\n+import java.util.jar.JarFile;\n+import java.util.jar.Manifest;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.model.JPackageException;\n@@ -34,1 +45,0 @@\n-import jdk.jpackage.internal.model.LauncherStartupInfo.Stub;\n@@ -40,7 +50,4 @@\n-        return decorator.apply(new Stub(qualifiedClassName, javaOptions,\n-                defaultParameters, classPath));\n-    }\n-\n-    LauncherStartupInfoBuilder launcherData(LauncherData launcherData) {\n-        if (launcherData.isModular()) {\n-            decorator = new ModuleStartupInfo(launcherData.moduleName());\n+        if (moduleName != null) {\n+            return createModular();\n+        } else if (mainJar != null) {\n+            return createNonModular();\n@@ -48,2 +55,1 @@\n-            decorator = new JarStartupInfo(launcherData.mainJarName(),\n-                    launcherData.isClassNameFromMainJar());\n+            throw new JPackageException(I18N.format(\"ERR_NoEntryPoint\"));\n@@ -51,2 +57,4 @@\n-        classPath = launcherData.classPath();\n-        qualifiedClassName = launcherData.qualifiedClassName();\n+    }\n+\n+    LauncherStartupInfoBuilder inputDir(Path v) {\n+        inputDir = v;\n@@ -57,0 +65,3 @@\n+        if (v != null) {\n+            v.forEach(Objects::requireNonNull);\n+        }\n@@ -62,0 +73,3 @@\n+        if (v != null) {\n+            v.forEach(Objects::requireNonNull);\n+        }\n@@ -66,1 +80,9 @@\n-    private static record ModuleStartupInfo(String moduleName) implements UnaryOperator<LauncherStartupInfo> {\n+    LauncherStartupInfoBuilder mainJar(Path v) {\n+        mainJar = v;\n+        return this;\n+    }\n+\n+    LauncherStartupInfoBuilder mainClassName(String v) {\n+        mainClassName = v;\n+        return this;\n+    }\n@@ -68,4 +90,18 @@\n-        @Override\n-        public LauncherStartupInfo apply(LauncherStartupInfo base) {\n-            return LauncherModularStartupInfo.create(base,\n-                    new LauncherModularStartupInfoMixin.Stub(moduleName));\n+    LauncherStartupInfoBuilder predefinedRuntimeImage(Path v) {\n+        cookedRuntimePath = v;\n+        return this;\n+    }\n+\n+    LauncherStartupInfoBuilder moduleName(String v) {\n+        if (v == null) {\n+            moduleName = null;\n+        } else {\n+            var slashIdx = v.indexOf('\/');\n+            if (slashIdx < 0) {\n+                moduleName = v;\n+            } else {\n+                moduleName = v.substring(0, slashIdx);\n+                if (slashIdx < v.length() - 1) {\n+                    mainClassName(v.substring(slashIdx + 1));\n+                }\n+            }\n@@ -73,0 +109,1 @@\n+        return this;\n@@ -75,3 +112,4 @@\n-    private static record JarStartupInfo(Path jarPath,\n-            boolean isClassNameFromMainJar) implements\n-            UnaryOperator<LauncherStartupInfo> {\n+    LauncherStartupInfoBuilder modulePath(List<Path> v) {\n+        modulePath = v;\n+        return this;\n+    }\n@@ -79,5 +117,87 @@\n-        @Override\n-        public LauncherStartupInfo apply(LauncherStartupInfo base) {\n-            return LauncherJarStartupInfo.create(base,\n-                    new LauncherJarStartupInfoMixin.Stub(jarPath,\n-                            isClassNameFromMainJar));\n+    private Optional<Path> inputDir() {\n+        return Optional.ofNullable(inputDir);\n+    }\n+\n+    private Optional<String> mainClassName() {\n+        return Optional.ofNullable(mainClassName);\n+    }\n+\n+    private Optional<Path> cookedRuntimePath() {\n+        return Optional.ofNullable(cookedRuntimePath);\n+    }\n+\n+    private LauncherStartupInfo createLauncherStartupInfo(String mainClassName, List<Path> classpath) {\n+        Objects.requireNonNull(mainClassName);\n+        classpath.forEach(Objects::requireNonNull);\n+        return new LauncherStartupInfo.Stub(mainClassName,\n+                Optional.ofNullable(javaOptions).orElseGet(List::of),\n+                Optional.ofNullable(defaultParameters).orElseGet(List::of),\n+                classpath);\n+    }\n+\n+    private static List<Path> createClasspath(Path inputDir, Set<Path> excludes) {\n+        excludes.forEach(Objects::requireNonNull);\n+        try (final var walk = Files.walk(inputDir)) {\n+            return walk.filter(Files::isRegularFile)\n+                    .filter(file -> file.getFileName().toString().endsWith(\".jar\"))\n+                    .map(inputDir::relativize)\n+                    .filter(Predicate.not(excludes::contains))\n+                    .distinct()\n+                    .toList();\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n+    }\n+\n+    private LauncherModularStartupInfo createModular() {\n+        final var fullModulePath = getFullModulePath();\n+\n+        \/\/ Try to find the module in the specified module path list.\n+        final var moduleInfo = JLinkRuntimeBuilder.createModuleFinder(fullModulePath).find(moduleName)\n+                .map(ModuleInfo::fromModuleReference).or(() -> {\n+                    \/\/ Failed to find the module in the specified module path list.\n+                    return cookedRuntimePath().flatMap(cookedRuntime -> {\n+                        \/\/ Lookup the module in the external runtime.\n+                        return ModuleInfo.fromCookedRuntime(moduleName, cookedRuntime);\n+                    });\n+                }).orElseThrow(() -> {\n+                    return I18N.buildConfigException(\"error.no-module-in-path\", moduleName).create();\n+                });\n+\n+        final var effectiveMainClassName = mainClassName().or(moduleInfo::mainClass).orElseThrow(() -> {\n+            return I18N.buildConfigException(\"ERR_NoMainClass\").create();\n+        });\n+\n+        \/\/ If module is located in the file system, exclude it from the classpath.\n+        final var classpath = inputDir().map(theInputDir -> {\n+            var classpathExcludes = moduleInfo.fileLocation().filter(moduleFile -> {\n+                return moduleFile.startsWith(theInputDir);\n+            }).map(theInputDir::relativize).map(Set::of).orElseGet(Set::of);\n+            return createClasspath(theInputDir, classpathExcludes);\n+        }).orElseGet(List::of);\n+\n+        return LauncherModularStartupInfo.create(\n+                createLauncherStartupInfo(effectiveMainClassName, classpath),\n+                new LauncherModularStartupInfoMixin.Stub(moduleInfo.name(), moduleInfo.version()));\n+    }\n+\n+    private List<Path> getFullModulePath() {\n+        return cookedRuntimePath().map(runtimeImage -> {\n+            return Stream.of(modulePath(), List.of(runtimeImage.resolve(\"lib\"))).flatMap(List::stream).toList();\n+        }).orElse(modulePath());\n+    }\n+\n+    private List<Path> modulePath() {\n+        return Optional.ofNullable(modulePath).orElseGet(List::of);\n+    }\n+\n+    private LauncherJarStartupInfo createNonModular() {\n+        final var theInputDir = inputDir().orElseThrow();\n+\n+        final var mainJarPath = theInputDir.resolve(mainJar);\n+\n+        if (!Files.exists(mainJarPath)) {\n+            throw I18N.buildConfigException()\n+                    .message(\"error.main-jar-does-not-exist\", mainJar)\n+                    .advice(\"error.main-jar-does-not-exist.advice\")\n+                    .create();\n@@ -85,0 +205,19 @@\n+\n+        final var effectiveMainClassName = mainClassName().or(() -> {\n+            try (final var jf = new JarFile(mainJarPath.toFile())) {\n+                return Optional.ofNullable(jf.getManifest()).map(Manifest::getMainAttributes).map(attrs -> {\n+                    return attrs.getValue(Attributes.Name.MAIN_CLASS);\n+                });\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }).orElseThrow(() -> {\n+            return I18N.buildConfigException()\n+                    .message(\"error.no-main-class-with-main-jar\", mainJar)\n+                    .advice(\"error.no-main-class-with-main-jar.advice\", mainJar)\n+                    .create();\n+        });\n+\n+        return LauncherJarStartupInfo.create(\n+                createLauncherStartupInfo(effectiveMainClassName, createClasspath(theInputDir, Set.of(mainJar))),\n+                new LauncherJarStartupInfoMixin.Stub(mainJar, mainClassName().isEmpty()));\n@@ -87,1 +226,10 @@\n-    private String qualifiedClassName;\n+    \/\/ Modular options\n+    private String moduleName;\n+    private List<Path> modulePath;\n+\n+    \/\/ Non-modular options\n+    private Path mainJar;\n+\n+    \/\/ Common options\n+    private Path inputDir;\n+    private String mainClassName;\n@@ -90,2 +238,1 @@\n-    private List<Path> classPath;\n-    private UnaryOperator<LauncherStartupInfo> decorator;\n+    private Path cookedRuntimePath;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/LauncherStartupInfoBuilder.java","additions":176,"deletions":29,"binary":false,"changes":205,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.cli.StandardOption.BUNDLING_OPERATION_DESCRIPTOR;\n+import static jdk.jpackage.internal.cli.StandardOption.DEST;\n+import static jdk.jpackage.internal.cli.StandardOption.MAIN_JAR;\n+import static jdk.jpackage.internal.cli.StandardOption.MODULE;\n+import static jdk.jpackage.internal.cli.StandardOption.PREDEFINED_APP_IMAGE;\n+import static jdk.jpackage.internal.cli.StandardOption.PREDEFINED_RUNTIME_IMAGE;\n+\n+import java.nio.file.Path;\n+import jdk.jpackage.internal.cli.Options;\n+import jdk.jpackage.internal.cli.StandardBundlingOperation;\n+\n+final class OptionUtils {\n+\n+    static boolean isRuntimeInstaller(Options options) {\n+        return PREDEFINED_RUNTIME_IMAGE.containsIn(options)\n+                && !PREDEFINED_APP_IMAGE.containsIn(options)\n+                && !MAIN_JAR.containsIn(options)\n+                && !MODULE.containsIn(options);\n+    }\n+\n+    static Path outputDir(Options options) {\n+        return DEST.getFrom(options);\n+    }\n+\n+    static StandardBundlingOperation bundlingOperation(Options options) {\n+        return StandardBundlingOperation.valueOf(BUNDLING_OPERATION_DESCRIPTOR.getFrom(options)).orElseThrow();\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/OptionUtils.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.cli.StandardOption.ADDITIONAL_LAUNCHERS;\n+import static jdk.jpackage.internal.cli.StandardOption.APP_VERSION;\n+import static jdk.jpackage.internal.cli.StandardOption.DESCRIPTION;\n+import static jdk.jpackage.internal.cli.StandardOption.ICON;\n+import static jdk.jpackage.internal.cli.StandardOption.NAME;\n+import static jdk.jpackage.internal.cli.StandardOption.PREDEFINED_APP_IMAGE;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import jdk.jpackage.internal.cli.Options;\n+import jdk.jpackage.internal.cli.WithOptionIdentifier;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.model.ExternalApplication;\n+\n+record OptionsTransformer(Options mainOptions, Optional<ExternalApplication> externalApp) {\n+\n+    OptionsTransformer {\n+        Objects.requireNonNull(mainOptions);\n+        Objects.requireNonNull(externalApp);\n+    }\n+\n+    OptionsTransformer(Options mainOptions, ApplicationLayout appLayout) {\n+        this(mainOptions, PREDEFINED_APP_IMAGE.findIn(mainOptions).map(appLayout::resolveAt).map(AppImageFile::load));\n+    }\n+\n+    Options appOptions() {\n+        return externalApp.map(ea -> {\n+            var overrideOptions = Map.<WithOptionIdentifier, Object>of(\n+                    NAME, ea.appName(),\n+                    APP_VERSION, ea.appVersion(),\n+                    ADDITIONAL_LAUNCHERS, ea.addLaunchers().stream().map(li -> {\n+                        return Options.concat(li.extra(), Options.of(Map.of(\n+                                NAME, li.name(),\n+                                \/\/ This should prevent the code building the Launcher instance\n+                                \/\/ from the Options object from trying to create a startup info object.\n+                                PREDEFINED_APP_IMAGE, PREDEFINED_APP_IMAGE.getFrom(mainOptions),\n+                                \/\/\n+                                \/\/ For backward compatibility, descriptions of the additional\n+                                \/\/ launchers in the predefined app image will be set to\n+                                \/\/ the application description, if available, or to the name\n+                                \/\/ of the main launcher in the predefined app image.\n+                                \/\/\n+                                \/\/ All launchers in the predefined app image will have the same description.\n+                                \/\/ This is wrong and should be revised.\n+                                \/\/\n+                                DESCRIPTION, DESCRIPTION.findIn(mainOptions).orElseGet(ea::appName)\n+                            )));\n+                    }).toList()\n+            );\n+            return Options.concat(\n+                    Options.of(overrideOptions),\n+                    ea.extra(),\n+                    \/\/ Remove icon if any from the application\/launcher options.\n+                    \/\/ If the icon is specified in the main options, it for the installer.\n+                    mainOptions.copyWithout(ICON.id())\n+            );\n+        }).orElse(mainOptions);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/OptionsTransformer.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.jpackage.internal.model.PackagerException;\n@@ -72,1 +71,1 @@\n-    Path execute(PackagingPipeline.Builder pipelineBuilder) throws PackagerException {\n+    Path execute(PackagingPipeline.Builder pipelineBuilder) {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Packager.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-import jdk.jpackage.internal.model.PackagerException;\n@@ -65,1 +64,1 @@\n-    void execute(BuildEnv env, Application app) throws PackagerException {\n+    void execute(BuildEnv env, Application app) {\n@@ -84,1 +83,1 @@\n-    void execute(BuildEnv env, Package pkg, Path outputDir) throws PackagerException {\n+    void execute(BuildEnv env, Package pkg, Path outputDir) {\n@@ -94,1 +93,1 @@\n-    void execute(StartupParameters startupParameters) throws PackagerException {\n+    void execute(StartupParameters startupParameters) {\n@@ -135,1 +134,1 @@\n-        void execute(TaskAction taskAction) throws IOException, PackagerException;\n+        void execute(TaskAction taskAction) throws IOException;\n@@ -164,1 +163,1 @@\n-        void execute(AppImageBuildEnv<T, U> env) throws IOException, PackagerException;\n+        void execute(AppImageBuildEnv<T, U> env) throws IOException;\n@@ -169,1 +168,1 @@\n-        void execute(AppImageBuildEnv<T, U> env) throws IOException, PackagerException;\n+        void execute(AppImageBuildEnv<T, U> env) throws IOException;\n@@ -174,1 +173,1 @@\n-        void execute(T pkg, AppImageLayout srcAppImage, AppImageLayout dstAppImage) throws IOException, PackagerException;\n+        void execute(T pkg, AppImageLayout srcAppImage, AppImageLayout dstAppImage) throws IOException;\n@@ -179,1 +178,1 @@\n-        void execute(PackageBuildEnv<T, U> env) throws IOException, PackagerException;\n+        void execute(PackageBuildEnv<T, U> env) throws IOException;\n@@ -184,1 +183,1 @@\n-        void execute() throws IOException, PackagerException;\n+        void execute() throws IOException;\n@@ -496,1 +495,1 @@\n-    private void execute(TaskContext context) throws PackagerException {\n+    private void execute(TaskContext context) {\n@@ -511,6 +510,0 @@\n-        } catch (ExceptionBox ex) {\n-            throw new PackagerException(ex.getCause());\n-        } catch (RuntimeException ex) {\n-            throw ex;\n-        } catch (PackagerException ex) {\n-            throw ex;\n@@ -518,1 +511,1 @@\n-            throw new PackagerException(ex);\n+            throw ExceptionBox.rethrowUnchecked(ex);\n@@ -549,1 +542,1 @@\n-        public void execute(TaskAction taskAction) throws IOException, PackagerException {\n+        public void execute(TaskAction taskAction) throws IOException {\n@@ -603,1 +596,1 @@\n-        public void execute(TaskAction taskAction) throws IOException, PackagerException {\n+        public void execute(TaskAction taskAction) throws IOException {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/PackagingPipeline.java","additions":13,"deletions":20,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1,513 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.text.MessageFormat;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.stream.Stream;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.ExternalApplication;\n-import static jdk.jpackage.internal.ApplicationLayoutUtils.PLATFORM_APPLICATION_LAYOUT;\n-\n-\/**\n- * Standard bundler parameters.\n- *\n- * Contains static definitions of all of the common bundler parameters.\n- * (additional platform specific and mode specific bundler parameters\n- * are defined in each of the specific bundlers)\n- *\n- * Also contains static methods that operate on maps of parameters.\n- *\/\n-final class StandardBundlerParam {\n-\n-    private static final String DEFAULT_VERSION = \"1.0\";\n-    private static final String DEFAULT_RELEASE = \"1\";\n-    private static final String[] DEFAULT_JLINK_OPTIONS = {\n-            \"--strip-native-commands\",\n-            \"--strip-debug\",\n-            \"--no-man-pages\",\n-            \"--no-header-files\"};\n-\n-    static final BundlerParamInfo<LauncherData> LAUNCHER_DATA = BundlerParamInfo.createBundlerParam(\n-            LauncherData.class, LauncherData::create);\n-\n-    static final BundlerParamInfo<Path> SOURCE_DIR =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.INPUT.getId(),\n-                    Path.class,\n-                    p -> null,\n-                    (s, p) -> Path.of(s)\n-            );\n-\n-    static final BundlerParamInfo<Path> OUTPUT_DIR =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.OUTPUT.getId(),\n-                    Path.class,\n-                    p -> Path.of(\"\").toAbsolutePath(),\n-                    (s, p) -> Path.of(s)\n-            );\n-\n-    \/\/ note that each bundler is likely to replace this one with\n-    \/\/ their own converter\n-    static final BundlerParamInfo<Path> MAIN_JAR =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.MAIN_JAR.getId(),\n-                    Path.class,\n-                    params -> LAUNCHER_DATA.fetchFrom(params).mainJarName(),\n-                    null\n-            );\n-\n-    static final BundlerParamInfo<Path> PREDEFINED_APP_IMAGE =\n-            new BundlerParamInfo<>(\n-            Arguments.CLIOptions.PREDEFINED_APP_IMAGE.getId(),\n-            Path.class,\n-            params -> null,\n-            (s, p) -> Path.of(s));\n-\n-    static final BundlerParamInfo<ExternalApplication> PREDEFINED_APP_IMAGE_FILE = BundlerParamInfo.createBundlerParam(\n-            ExternalApplication.class, params -> {\n-                if (hasPredefinedAppImage(params)) {\n-                    var appImage = PREDEFINED_APP_IMAGE.fetchFrom(params);\n-                    return AppImageFile.load(appImage, PLATFORM_APPLICATION_LAYOUT);\n-                } else {\n-                    return null;\n-                }\n-            });\n-\n-    static final BundlerParamInfo<String> MAIN_CLASS =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.APPCLASS.getId(),\n-                    String.class,\n-                    params -> {\n-                        if (isRuntimeInstaller(params)) {\n-                            return null;\n-                        } else if (hasPredefinedAppImage(params)) {\n-                            PREDEFINED_APP_IMAGE_FILE.fetchFrom(params).getMainClass();\n-                        }\n-                        return LAUNCHER_DATA.fetchFrom(params).qualifiedClassName();\n-                    },\n-                    (s, p) -> s\n-            );\n-\n-    static final BundlerParamInfo<Path> PREDEFINED_RUNTIME_IMAGE =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.PREDEFINED_RUNTIME_IMAGE.getId(),\n-                    Path.class,\n-                    params -> null,\n-                    (s, p) -> Path.of(s)\n-            );\n-\n-    \/\/ this is the raw --app-name arg - used in APP_NAME and INSTALLER_NAME\n-    static final BundlerParamInfo<String> NAME =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.NAME.getId(),\n-                    String.class,\n-                    params -> null,\n-                    (s, p) -> s\n-            );\n-\n-    \/\/ this is the application name, either from the app-image (if given),\n-    \/\/ the name (if given) derived from the main-class, or the runtime image\n-    static final BundlerParamInfo<String> APP_NAME =\n-            new BundlerParamInfo<>(\n-                    \"application-name\",\n-                    String.class,\n-                    params -> {\n-                        String appName = NAME.fetchFrom(params);\n-                        if (hasPredefinedAppImage(params)) {\n-                            appName = PREDEFINED_APP_IMAGE_FILE.fetchFrom(params).getLauncherName();\n-                        } else if (appName == null) {\n-                            String s = MAIN_CLASS.fetchFrom(params);\n-                            if (s != null) {\n-                                int idx = s.lastIndexOf(\".\");\n-                                appName = (idx < 0) ? s : s.substring(idx+1);\n-                            } else if (isRuntimeInstaller(params)) {\n-                                Path f = PREDEFINED_RUNTIME_IMAGE.fetchFrom(params);\n-                                if (f != null) {\n-                                    appName = f.getFileName().toString();\n-                                }\n-                            }\n-                        }\n-                        return appName;\n-                    },\n-                    (s, p) -> s\n-            );\n-\n-    static final BundlerParamInfo<String> INSTALLER_NAME =\n-            new BundlerParamInfo<>(\n-                    \"installer-name\",\n-                    String.class,\n-                    params -> {\n-                        String installerName = NAME.fetchFrom(params);\n-                        return (installerName != null) ? installerName :\n-                                APP_NAME.fetchFrom(params);\n-                    },\n-                    (s, p) -> s\n-            );\n-\n-    static final BundlerParamInfo<Path> ICON =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.ICON.getId(),\n-                    Path.class,\n-                    params -> null,\n-                    (s, p) -> Path.of(s)\n-            );\n-\n-    static final BundlerParamInfo<String> ABOUT_URL =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.ABOUT_URL.getId(),\n-                    String.class,\n-                    params -> null,\n-                    (s, p) -> s\n-            );\n-\n-    static final BundlerParamInfo<String> VENDOR =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.VENDOR.getId(),\n-                    String.class,\n-                    params -> I18N.getString(\"param.vendor.default\"),\n-                    (s, p) -> s\n-            );\n-\n-    static final BundlerParamInfo<String> DESCRIPTION =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.DESCRIPTION.getId(),\n-                    String.class,\n-                    params -> params.containsKey(APP_NAME.getID())\n-                            ? APP_NAME.fetchFrom(params)\n-                            : I18N.getString(\"param.description.default\"),\n-                    (s, p) -> s\n-            );\n-\n-    static final BundlerParamInfo<String> COPYRIGHT =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.COPYRIGHT.getId(),\n-                    String.class,\n-                    params -> MessageFormat.format(I18N.getString(\n-                            \"param.copyright.default\"), new Date()),\n-                    (s, p) -> s\n-            );\n-\n-    @SuppressWarnings(\"unchecked\")\n-    static final BundlerParamInfo<List<String>> ARGUMENTS =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.ARGUMENTS.getId(),\n-                    (Class<List<String>>) (Object) List.class,\n-                    params -> Collections.emptyList(),\n-                    (s, p) -> null\n-            );\n-\n-    @SuppressWarnings(\"unchecked\")\n-    static final BundlerParamInfo<List<String>> JAVA_OPTIONS =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.JAVA_OPTIONS.getId(),\n-                    (Class<List<String>>) (Object) List.class,\n-                    params -> Collections.emptyList(),\n-                    (s, p) -> Arrays.asList(s.split(\"\\n\\n\"))\n-            );\n-\n-    static final BundlerParamInfo<String> VERSION =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.VERSION.getId(),\n-                    String.class,\n-                    StandardBundlerParam::getDefaultAppVersion,\n-                    (s, p) -> s\n-            );\n-\n-    static final BundlerParamInfo<String> RELEASE =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.RELEASE.getId(),\n-                    String.class,\n-                    params -> DEFAULT_RELEASE,\n-                    (s, p) -> s\n-            );\n-\n-    public static final BundlerParamInfo<String> LICENSE_FILE =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.LICENSE_FILE.getId(),\n-                    String.class,\n-                    params -> null,\n-                    (s, p) -> s\n-            );\n-\n-    static final BundlerParamInfo<Path> TEMP_ROOT =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.TEMP_ROOT.getId(),\n-                    Path.class,\n-                    params -> {\n-                        try {\n-                            return Files.createTempDirectory(\"jdk.jpackage\");\n-                        } catch (IOException ioe) {\n-                            return null;\n-                        }\n-                    },\n-                    (s, p) -> Path.of(s)\n-            );\n-\n-    public static final BundlerParamInfo<Path> CONFIG_ROOT =\n-            new BundlerParamInfo<>(\n-                \"configRoot\",\n-                Path.class,\n-                params -> {\n-                    Path root = TEMP_ROOT.fetchFrom(params).resolve(\"config\");\n-                    try {\n-                        Files.createDirectories(root);\n-                    } catch (IOException ioe) {\n-                        return null;\n-                    }\n-                    return root;\n-                },\n-                (s, p) -> null\n-            );\n-\n-    static final BundlerParamInfo<Boolean> VERBOSE  =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.VERBOSE.getId(),\n-                    Boolean.class,\n-                    params -> false,\n-                    \/\/ valueOf(null) is false, and we actually do want null\n-                    (s, p) -> (s == null || \"null\".equalsIgnoreCase(s)) ?\n-                            true : Boolean.valueOf(s)\n-            );\n-\n-    static final BundlerParamInfo<Path> RESOURCE_DIR =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.RESOURCE_DIR.getId(),\n-                    Path.class,\n-                    params -> null,\n-                    (s, p) -> Path.of(s)\n-            );\n-\n-    static final BundlerParamInfo<String> INSTALL_DIR =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.INSTALL_DIR.getId(),\n-                    String.class,\n-                     params -> null,\n-                    (s, p) -> s\n-    );\n-\n-    static final BundlerParamInfo<Boolean> LAUNCHER_AS_SERVICE =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.LAUNCHER_AS_SERVICE.getId(),\n-                    Boolean.class,\n-                    params -> false,\n-                    \/\/ valueOf(null) is false, and we actually do want null\n-                    (s, p) -> (s == null || \"null\".equalsIgnoreCase(s)) ?\n-                            true : Boolean.valueOf(s)\n-            );\n-\n-\n-    @SuppressWarnings(\"unchecked\")\n-    static final BundlerParamInfo<List<Map<String, ? super Object>>> ADD_LAUNCHERS =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.ADD_LAUNCHER.getId(),\n-                    (Class<List<Map<String, ? super Object>>>) (Object)\n-                            List.class,\n-                    params -> new ArrayList<>(1),\n-                    \/\/ valueOf(null) is false, and we actually do want null\n-                    (s, p) -> null\n-            );\n-\n-    @SuppressWarnings(\"unchecked\")\n-    static final BundlerParamInfo\n-            <List<Map<String, ? super Object>>> FILE_ASSOCIATIONS =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.FILE_ASSOCIATIONS.getId(),\n-                    (Class<List<Map<String, ? super Object>>>) (Object)\n-                            List.class,\n-                    params -> new ArrayList<>(1),\n-                    \/\/ valueOf(null) is false, and we actually do want null\n-                    (s, p) -> null\n-            );\n-\n-    @SuppressWarnings(\"unchecked\")\n-    static final BundlerParamInfo<List<String>> FA_EXTENSIONS =\n-            new BundlerParamInfo<>(\n-                    \"fileAssociation.extension\",\n-                    (Class<List<String>>) (Object) List.class,\n-                    params -> null, \/\/ null means not matched to an extension\n-                    (s, p) -> Arrays.asList(s.split(\"(,|\\\\s)+\"))\n-            );\n-\n-    @SuppressWarnings(\"unchecked\")\n-    static final BundlerParamInfo<List<String>> FA_CONTENT_TYPE =\n-            new BundlerParamInfo<>(\n-                    \"fileAssociation.contentType\",\n-                    (Class<List<String>>) (Object) List.class,\n-                    params -> null,\n-                            \/\/ null means not matched to a content\/mime type\n-                    (s, p) -> Arrays.asList(s.split(\"(,|\\\\s)+\"))\n-            );\n-\n-    static final BundlerParamInfo<String> FA_DESCRIPTION =\n-            new BundlerParamInfo<>(\n-                    \"fileAssociation.description\",\n-                    String.class,\n-                    p -> null,\n-                    (s, p) -> s\n-            );\n-\n-    static final BundlerParamInfo<Path> FA_ICON =\n-            new BundlerParamInfo<>(\n-                    \"fileAssociation.icon\",\n-                    Path.class,\n-                    ICON::fetchFrom,\n-                    (s, p) -> Path.of(s)\n-            );\n-\n-    @SuppressWarnings(\"unchecked\")\n-    static final BundlerParamInfo<List<Path>> DMG_CONTENT =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.DMG_CONTENT.getId(),\n-                    (Class<List<Path>>) (Object)List.class,\n-                    p -> Collections.emptyList(),\n-                    (s, p) -> Stream.of(s.split(\",\")).map(Path::of).toList()\n-            );\n-\n-    @SuppressWarnings(\"unchecked\")\n-    static final BundlerParamInfo<List<Path>> APP_CONTENT =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.APP_CONTENT.getId(),\n-                    (Class<List<Path>>) (Object)List.class,\n-                    p->Collections.emptyList(),\n-                    (s, p) -> Stream.of(s.split(\",\")).map(Path::of).toList()\n-            );\n-\n-    @SuppressWarnings(\"unchecked\")\n-    static final BundlerParamInfo<List<Path>> MODULE_PATH =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.MODULE_PATH.getId(),\n-                    (Class<List<Path>>) (Object)List.class,\n-                    p -> JLinkRuntimeBuilder.ensureBaseModuleInModulePath(List.of()),\n-                    (s, p) -> {\n-                        List<Path> modulePath = Stream.of(s.split(File.pathSeparator))\n-                                .map(Path::of)\n-                                .toList();\n-                        return JLinkRuntimeBuilder.ensureBaseModuleInModulePath(modulePath);\n-                    });\n-\n-    static final BundlerParamInfo<String> MODULE =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.MODULE.getId(),\n-                    String.class,\n-                    p -> null,\n-                    (s, p) -> {\n-                        return String.valueOf(s);\n-                    });\n-\n-    @SuppressWarnings(\"unchecked\")\n-    static final BundlerParamInfo<Set<String>> ADD_MODULES =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.ADD_MODULES.getId(),\n-                    (Class<Set<String>>) (Object) Set.class,\n-                    p -> new LinkedHashSet<String>(),\n-                    (s, p) -> new LinkedHashSet<>(Arrays.asList(s.split(\",\")))\n-            );\n-\n-    @SuppressWarnings(\"unchecked\")\n-    static final BundlerParamInfo<List<String>> JLINK_OPTIONS =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.JLINK_OPTIONS.getId(),\n-                    (Class<List<String>>) (Object) List.class,\n-                    p -> Arrays.asList(DEFAULT_JLINK_OPTIONS),\n-                    (s, p) -> null);\n-\n-    @SuppressWarnings(\"unchecked\")\n-    static final BundlerParamInfo<Set<String>> LIMIT_MODULES =\n-            new BundlerParamInfo<>(\n-                    \"limit-modules\",\n-                    (Class<Set<String>>) (Object) Set.class,\n-                    p -> new LinkedHashSet<String>(),\n-                    (s, p) -> new LinkedHashSet<>(Arrays.asList(s.split(\",\")))\n-            );\n-\n-    static final BundlerParamInfo<Boolean> SIGN_BUNDLE =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.MAC_SIGN.getId(),\n-                    Boolean.class,\n-                    params -> false,\n-                    (s, p) -> (s == null || \"null\".equalsIgnoreCase(s)) ?\n-                    null : Boolean.valueOf(s)\n-        );\n-\n-    static boolean isRuntimeInstaller(Map<String, ? super Object> params) {\n-        if (params.containsKey(MODULE.getID()) ||\n-                params.containsKey(MAIN_JAR.getID()) ||\n-                params.containsKey(PREDEFINED_APP_IMAGE.getID())) {\n-            return false; \/\/ we are building or are given an application\n-        }\n-        \/\/ runtime installer requires --runtime-image, if this is false\n-        \/\/ here then we should have thrown error validating args.\n-        return params.containsKey(PREDEFINED_RUNTIME_IMAGE.getID());\n-    }\n-\n-    static boolean hasPredefinedAppImage(Map<String, ? super Object> params) {\n-        return params.containsKey(PREDEFINED_APP_IMAGE.getID());\n-    }\n-\n-    private static String getDefaultAppVersion(Map<String, ? super Object> params) {\n-        String appVersion = DEFAULT_VERSION;\n-\n-        if (isRuntimeInstaller(params)) {\n-            return appVersion;\n-        }\n-\n-        LauncherData launcherData = null;\n-        try {\n-            launcherData = LAUNCHER_DATA.fetchFrom(params);\n-        } catch (RuntimeException ex) {\n-            if (ex.getCause() instanceof ConfigException) {\n-                return appVersion;\n-            }\n-            throw ex;\n-        }\n-\n-        if (launcherData.isModular()) {\n-            String moduleVersion = launcherData.getAppVersion();\n-            if (moduleVersion != null) {\n-                Log.verbose(MessageFormat.format(I18N.getString(\n-                        \"message.module-version\"),\n-                        moduleVersion,\n-                        launcherData.moduleName()));\n-                appVersion = moduleVersion;\n-            }\n-        }\n-\n-        return appVersion;\n-    }\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/StandardBundlerParam.java","additions":0,"deletions":513,"binary":false,"changes":513,"status":"deleted"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import jdk.jpackage.internal.cli.Options;\n+import jdk.jpackage.internal.cli.StandardOption;\n+import jdk.jpackage.internal.util.FileUtils;\n+\n+final class TempDirectory implements Closeable {\n+\n+    TempDirectory(Options options) throws IOException {\n+        final var tempDir = StandardOption.TEMP_ROOT.findIn(options);\n+        if (tempDir.isPresent()) {\n+            this.path = tempDir.orElseThrow();\n+            this.options = options;\n+        } else {\n+            this.path = Files.createTempDirectory(\"jdk.jpackage\");\n+            this.options = options.copyWithDefaultValue(StandardOption.TEMP_ROOT, path);\n+        }\n+\n+        deleteOnClose = tempDir.isEmpty();\n+    }\n+\n+    Options options() {\n+        return options;\n+    }\n+\n+    Path path() {\n+        return path;\n+    }\n+\n+    boolean deleteOnClose() {\n+        return deleteOnClose;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        if (deleteOnClose) {\n+            FileUtils.deleteRecursive(path);\n+        }\n+    }\n+\n+    private final Path path;\n+    private final Options options;\n+    private final boolean deleteOnClose;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/TempDirectory.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -1,187 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.util.EnumSet;\n-import java.util.HashMap;\n-\n-import jdk.internal.util.OperatingSystem;\n-import jdk.jpackage.internal.Arguments.CLIOptions;\n-\n-\/**\n- * ValidOptions\n- *\n- * Two basic methods for validating command line options.\n- *\n- * initArgs()\n- *      Computes the Map of valid options for each mode on this Platform.\n- *\n- * checkIfSupported(CLIOptions arg)\n- *      Determine if the given arg is valid on this platform.\n- *\n- * checkIfImageSupported(CLIOptions arg)\n- *      Determine if the given arg is valid for creating app image.\n- *\n- * checkIfInstallerSupported(CLIOptions arg)\n- *      Determine if the given arg is valid for creating installer.\n- *\n- * checkIfSigningSupported(CLIOptions arg)\n- *      Determine if the given arg is valid for signing app image.\n- *\n- *\/\n-class ValidOptions {\n-\n-    enum USE {\n-        ALL,        \/\/ valid in all cases\n-        LAUNCHER,   \/\/ valid when creating a launcher\n-        INSTALL,    \/\/ valid when creating an installer\n-        SIGN,       \/\/ valid when signing is requested\n-    }\n-\n-    private static final HashMap<String, EnumSet<USE>> options = new HashMap<>();\n-\n-    \/\/ initializing list of mandatory arguments\n-    static {\n-        put(CLIOptions.NAME.getId(), USE.ALL);\n-        put(CLIOptions.VERSION.getId(), USE.ALL);\n-        put(CLIOptions.OUTPUT.getId(), USE.ALL);\n-        put(CLIOptions.TEMP_ROOT.getId(), USE.ALL);\n-        put(CLIOptions.VERBOSE.getId(),\n-                EnumSet.of(USE.ALL, USE.SIGN));\n-        put(CLIOptions.PREDEFINED_RUNTIME_IMAGE.getId(), USE.ALL);\n-        put(CLIOptions.RESOURCE_DIR.getId(), USE.ALL);\n-        put(CLIOptions.DESCRIPTION.getId(), USE.ALL);\n-        put(CLIOptions.VENDOR.getId(), USE.ALL);\n-        put(CLIOptions.COPYRIGHT.getId(), USE.ALL);\n-        put(CLIOptions.PACKAGE_TYPE.getId(),\n-                EnumSet.of(USE.ALL, USE.SIGN));\n-        put(CLIOptions.ICON.getId(), USE.ALL);\n-\n-        put(CLIOptions.INPUT.getId(), USE.LAUNCHER);\n-        put(CLIOptions.MODULE.getId(), USE.LAUNCHER);\n-        put(CLIOptions.MODULE_PATH.getId(), USE.LAUNCHER);\n-        put(CLIOptions.ADD_MODULES.getId(), USE.LAUNCHER);\n-        put(CLIOptions.MAIN_JAR.getId(), USE.LAUNCHER);\n-        put(CLIOptions.APPCLASS.getId(), USE.LAUNCHER);\n-        put(CLIOptions.ARGUMENTS.getId(), USE.LAUNCHER);\n-        put(CLIOptions.JAVA_OPTIONS.getId(), USE.LAUNCHER);\n-        put(CLIOptions.ADD_LAUNCHER.getId(), USE.LAUNCHER);\n-        put(CLIOptions.JLINK_OPTIONS.getId(), USE.LAUNCHER);\n-        put(CLIOptions.APP_CONTENT.getId(), USE.LAUNCHER);\n-\n-        put(CLIOptions.LICENSE_FILE.getId(), USE.INSTALL);\n-        put(CLIOptions.INSTALL_DIR.getId(), USE.INSTALL);\n-        put(CLIOptions.PREDEFINED_APP_IMAGE.getId(),\n-                (OperatingSystem.isMacOS()) ?\n-                        EnumSet.of(USE.INSTALL, USE.SIGN) :\n-                        EnumSet.of(USE.INSTALL));\n-        put(CLIOptions.LAUNCHER_AS_SERVICE.getId(), USE.INSTALL);\n-\n-        put(CLIOptions.ABOUT_URL.getId(), USE.INSTALL);\n-\n-        put(CLIOptions.FILE_ASSOCIATIONS.getId(),\n-            (OperatingSystem.isMacOS()) ? USE.ALL : USE.INSTALL);\n-\n-        if (OperatingSystem.isWindows()) {\n-            put(CLIOptions.WIN_CONSOLE_HINT.getId(), USE.LAUNCHER);\n-\n-            put(CLIOptions.WIN_HELP_URL.getId(), USE.INSTALL);\n-            put(CLIOptions.WIN_UPDATE_URL.getId(), USE.INSTALL);\n-\n-            put(CLIOptions.WIN_MENU_HINT.getId(), USE.INSTALL);\n-            put(CLIOptions.WIN_MENU_GROUP.getId(), USE.INSTALL);\n-            put(CLIOptions.WIN_SHORTCUT_HINT.getId(), USE.INSTALL);\n-            put(CLIOptions.WIN_SHORTCUT_PROMPT.getId(), USE.INSTALL);\n-            put(CLIOptions.WIN_DIR_CHOOSER.getId(), USE.INSTALL);\n-            put(CLIOptions.WIN_UPGRADE_UUID.getId(), USE.INSTALL);\n-            put(CLIOptions.WIN_PER_USER_INSTALLATION.getId(),\n-                    USE.INSTALL);\n-        }\n-\n-        if (OperatingSystem.isMacOS()) {\n-            put(CLIOptions.MAC_SIGN.getId(),\n-                    EnumSet.of(USE.ALL, USE.SIGN));\n-            put(CLIOptions.MAC_BUNDLE_NAME.getId(), USE.ALL);\n-            put(CLIOptions.MAC_BUNDLE_IDENTIFIER.getId(), USE.ALL);\n-            put(CLIOptions.MAC_BUNDLE_SIGNING_PREFIX.getId(),\n-                    EnumSet.of(USE.ALL, USE.SIGN));\n-            put(CLIOptions.MAC_SIGNING_KEY_NAME.getId(),\n-                    EnumSet.of(USE.ALL, USE.SIGN));\n-            put(CLIOptions.MAC_APP_IMAGE_SIGN_IDENTITY.getId(),\n-                    EnumSet.of(USE.ALL, USE.SIGN));\n-            put(CLIOptions.MAC_INSTALLER_SIGN_IDENTITY.getId(),\n-                    EnumSet.of(USE.INSTALL, USE.SIGN));\n-            put(CLIOptions.MAC_SIGNING_KEYCHAIN.getId(),\n-                    EnumSet.of(USE.ALL, USE.SIGN));\n-            put(CLIOptions.MAC_APP_STORE.getId(), USE.ALL);\n-            put(CLIOptions.MAC_CATEGORY.getId(), USE.ALL);\n-            put(CLIOptions.MAC_ENTITLEMENTS.getId(),\n-                    EnumSet.of(USE.ALL, USE.SIGN));\n-            put(CLIOptions.DMG_CONTENT.getId(), USE.INSTALL);\n-        }\n-\n-        if (OperatingSystem.isLinux()) {\n-            put(CLIOptions.LINUX_BUNDLE_NAME.getId(), USE.INSTALL);\n-            put(CLIOptions.LINUX_DEB_MAINTAINER.getId(), USE.INSTALL);\n-            put(CLIOptions.LINUX_CATEGORY.getId(), USE.INSTALL);\n-            put(CLIOptions.LINUX_RPM_LICENSE_TYPE.getId(), USE.INSTALL);\n-            put(CLIOptions.LINUX_PACKAGE_DEPENDENCIES.getId(),\n-                    USE.INSTALL);\n-            put(CLIOptions.LINUX_MENU_GROUP.getId(), USE.INSTALL);\n-            put(CLIOptions.RELEASE.getId(), USE.INSTALL);\n-            put(CLIOptions.LINUX_SHORTCUT_HINT.getId(), USE.INSTALL);\n-        }\n-    }\n-\n-    static boolean checkIfSupported(CLIOptions arg) {\n-        return options.containsKey(arg.getId());\n-    }\n-\n-    static boolean checkIfImageSupported(CLIOptions arg) {\n-        EnumSet<USE> value = options.get(arg.getId());\n-        return value.contains(USE.ALL) ||\n-                value.contains(USE.LAUNCHER) ||\n-                value.contains(USE.SIGN);\n-    }\n-\n-    static boolean checkIfInstallerSupported(CLIOptions arg) {\n-        EnumSet<USE> value = options.get(arg.getId());\n-        return value.contains(USE.ALL) || value.contains(USE.INSTALL);\n-    }\n-\n-    static boolean checkIfSigningSupported(CLIOptions arg) {\n-        EnumSet<USE> value = options.get(arg.getId());\n-        return value.contains(USE.SIGN);\n-    }\n-\n-    private static EnumSet<USE> put(String key, USE value) {\n-        return options.put(key, EnumSet.of(value));\n-    }\n-\n-    private static EnumSet<USE> put(String key, EnumSet<USE> value) {\n-        return options.put(key, value);\n-    }\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ValidOptions.java","additions":0,"deletions":187,"binary":false,"changes":187,"status":"deleted"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+import java.nio.file.Path;\n+\n+\n+record AdditionalLauncher(String name, Path propertyFile) {\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/AdditionalLauncher.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+\/**\n+ * Modifiers for jpackage operations.\n+ *\/\n+enum BundlingOperationModifier implements OptionScope {\n+    \/**\n+     * Create runtime native bundle.\n+     *\/\n+    BUNDLE_RUNTIME,\n+\n+    \/**\n+     * Create native bundle from the predefined app image.\n+     *\/\n+    BUNDLE_PREDEFINED_APP_IMAGE,\n+\n+    ;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/BundlingOperationModifier.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+\n+import jdk.jpackage.internal.model.BundlingOperationDescriptor;\n+\n+\/**\n+ * Bundling operation scope.\n+ * <p>\n+ * The scope of bundling operations. E.g., app image or native package bundling.\n+ *\/\n+interface BundlingOperationOptionScope extends OptionScope {\n+    BundlingOperationDescriptor descriptor();\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/BundlingOperationOptionScope.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import java.util.NoSuchElementException;\n+import jdk.jpackage.internal.model.BundlingEnvironment;\n+import jdk.jpackage.internal.model.BundlingOperationDescriptor;\n+\n+\/**\n+ * CLI bundling environment.\n+ *\/\n+public interface CliBundlingEnvironment extends BundlingEnvironment {\n+\n+    \/**\n+     * Requests to run a bundling operation denoted with the given descriptor with\n+     * the given values of command line options.\n+     *\n+     * @param op      the descriptor of the requested bundling operation\n+     * @param cmdline the validated values of the command line options\n+     * @throws NoSuchElementException if the specified descriptor is not one of the\n+     *                                items in the list returned by\n+     *                                {@link #supportedOperations()} method\n+     *\/\n+    void createBundle(BundlingOperationDescriptor op, Options cmdline);\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/CliBundlingEnvironment.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,191 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+import static java.util.stream.Collectors.toUnmodifiableMap;\n+import static java.util.stream.Collectors.toUnmodifiableSet;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+\n+final class DefaultOptions implements Options {\n+\n+    DefaultOptions(Map<? extends WithOptionIdentifier, Object> values) {\n+        this(values, Optional.empty());\n+    }\n+\n+    DefaultOptions(\n+            Map<? extends WithOptionIdentifier, Object> values,\n+            Predicate<OptionName> optionNamesFilter) {\n+\n+        this(values, Optional.of(optionNamesFilter));\n+    }\n+\n+    DefaultOptions(\n+            Map<? extends WithOptionIdentifier, Object> values,\n+            Optional<Predicate<OptionName>> optionNamesFilter) {\n+\n+        map = values.entrySet().stream().collect(toUnmodifiableMap(e -> {\n+            return e.getKey().id();\n+        }, e -> {\n+            return new OptionIdentifierWithValue(e.getKey(), e.getValue());\n+        }));\n+\n+        var optionNamesStream = optionNames(values.keySet().stream());\n+        optionNames = optionNamesFilter.map(optionNamesStream::filter).orElse(optionNamesStream)\n+                .collect(toUnmodifiableSet());\n+    }\n+\n+    private DefaultOptions(Snapshot snapshot) {\n+        map = snapshot.map();\n+        optionNames = snapshot.optionNames();\n+    }\n+\n+    static DefaultOptions create(Snapshot snapshot) {\n+        var options = new DefaultOptions(snapshot);\n+\n+        var mapOptionNames = optionNames(\n+                options.map.values().stream().map(OptionIdentifierWithValue::withId)\n+        ).collect(toUnmodifiableSet());\n+\n+        for (var e : options.map.entrySet()) {\n+            if (e.getKey() != e.getValue().withId().id()) {\n+                throw new IllegalArgumentException(\"Corrupted options map\");\n+            }\n+        }\n+\n+        if (!mapOptionNames.containsAll(snapshot.optionNames())) {\n+            throw new IllegalArgumentException(\"Unexpected option names\");\n+        }\n+        return options;\n+    }\n+\n+    @Override\n+    public Optional<Object> find(OptionIdentifier id) {\n+        return Optional.ofNullable(map.get(Objects.requireNonNull(id))).map(OptionIdentifierWithValue::value);\n+    }\n+\n+    @Override\n+    public boolean contains(OptionName optionName) {\n+        return optionNames.contains(Objects.requireNonNull(optionName));\n+    }\n+\n+    @Override\n+    public Set<? extends OptionIdentifier> ids() {\n+        return Collections.unmodifiableSet(map.keySet());\n+    }\n+\n+    @Override\n+    public DefaultOptions copyWithout(Iterable<? extends OptionIdentifier> ids) {\n+        return copy(StreamSupport.stream(ids.spliterator(), false), false);\n+    }\n+\n+    @Override\n+    public DefaultOptions copyWith(Iterable<? extends OptionIdentifier> ids) {\n+        return copy(StreamSupport.stream(ids.spliterator(), false), true);\n+    }\n+\n+    DefaultOptions add(DefaultOptions other) {\n+        return new DefaultOptions(new Snapshot(Stream.of(this, other).flatMap(v -> {\n+            return v.map.values().stream();\n+        }).collect(toUnmodifiableMap(OptionIdentifierWithValue::id, x -> x, (first, _) -> {\n+            return first;\n+        })), Stream.of(this, other)\n+                .map(DefaultOptions::optionNames)\n+                .flatMap(Collection::stream)\n+                .collect(toUnmodifiableSet())));\n+    }\n+\n+    Set<OptionName> optionNames() {\n+        return optionNames;\n+    }\n+\n+    Set<WithOptionIdentifier> withOptionIdentifierSet() {\n+        return map.values().stream()\n+                .map(OptionIdentifierWithValue::withId)\n+                .collect(toUnmodifiableSet());\n+    }\n+\n+    record Snapshot(Map<OptionIdentifier, OptionIdentifierWithValue> map, Set<OptionName> optionNames) {\n+        Snapshot {\n+            Objects.requireNonNull(map);\n+            Objects.requireNonNull(optionNames);\n+        }\n+    }\n+\n+    record OptionIdentifierWithValue(WithOptionIdentifier withId, Object value) {\n+        OptionIdentifierWithValue {\n+            Objects.requireNonNull(withId);\n+            Objects.requireNonNull(value);\n+        }\n+\n+        OptionIdentifier id() {\n+            return withId.id();\n+        }\n+\n+        OptionIdentifierWithValue copyWithValue(Object value) {\n+            return new OptionIdentifierWithValue(withId, value);\n+        }\n+    }\n+\n+    private DefaultOptions copy(Stream<? extends OptionIdentifier> ids, boolean includes) {\n+        var includeIds = ids.collect(toUnmodifiableSet());\n+        return new DefaultOptions(map.values().stream().filter(v -> {\n+            return includeIds.contains(v.id()) == includes;\n+        }).collect(toUnmodifiableMap(OptionIdentifierWithValue::withId, OptionIdentifierWithValue::value)));\n+    }\n+\n+    private static Stream<OptionName> optionNames(Stream<? extends WithOptionIdentifier> options) {\n+        return options.map(v -> {\n+            Optional<? extends OptionSpec<?>> spec;\n+            switch (v) {\n+                case Option option -> {\n+                    spec = Optional.of(option.spec());\n+                }\n+                case OptionValue<?> optionValue -> {\n+                    spec = optionValue.asOption().map(Option::spec);\n+                }\n+                default -> {\n+                    spec = Optional.empty();\n+                }\n+            }\n+            return spec;\n+        }).filter(Optional::isPresent).map(Optional::get).map(OptionSpec::names).flatMap(Collection::stream);\n+    }\n+\n+    static final DefaultOptions EMPTY = new DefaultOptions(Map.of());\n+\n+    private final Map<OptionIdentifier, OptionIdentifierWithValue> map;\n+    private final Set<OptionName> optionNames;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/DefaultOptions.java","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+\n+\/**\n+ * Generic help formatter.\n+ *\/\n+final class HelpFormatter {\n+\n+    private HelpFormatter(List<OptionGroup> optionGroups, OptionGroupFormatter formatter) {\n+        this.optionGroups = Objects.requireNonNull(optionGroups);\n+        this.formatter = Objects.requireNonNull(formatter);\n+\n+    }\n+\n+    void format(Consumer<CharSequence> sink) {\n+        for (var group : optionGroups) {\n+            formatter.format(group, sink);\n+        }\n+    }\n+\n+    static Builder build() {\n+        return new Builder();\n+    }\n+\n+\n+    static final class Builder {\n+\n+        private Builder() {\n+        }\n+\n+        HelpFormatter create() {\n+            return new HelpFormatter(groups, validatedGroupFormatter());\n+        }\n+\n+        Builder groups(Collection<OptionGroup> v) {\n+            groups.addAll(v);\n+            return this;\n+        }\n+\n+        Builder groups(OptionGroup... v) {\n+            return groups(List.of(v));\n+        }\n+\n+        Builder groupFormatter(OptionGroupFormatter v) {\n+            groupFormatter = v;\n+            return this;\n+        }\n+\n+        private OptionGroupFormatter validatedGroupFormatter() {\n+            return Optional.ofNullable(groupFormatter).orElseGet(Builder::createConsoleFormatter);\n+        }\n+\n+        private static OptionGroupFormatter createConsoleFormatter() {\n+            return new ConsoleOptionGroupFormatter(new ConsoleOptionFormatter(2, 10));\n+        }\n+\n+        private final List<OptionGroup> groups = new ArrayList<>();\n+        private OptionGroupFormatter groupFormatter;\n+    }\n+\n+\n+    interface OptionFormatter {\n+\n+        public default void format(OptionSpec<?> optionSpec, Consumer<CharSequence> sink) {\n+            format(optionSpec.names().stream().map(OptionName::formatForCommandLine).collect(Collectors.joining(\" \")),\n+                    optionSpec.valuePattern(),\n+                    optionSpec.description(), sink);\n+        }\n+\n+        void format(String optionNames, Optional<String> valuePattern, String description, Consumer<CharSequence> sink);\n+    }\n+\n+    interface OptionGroupFormatter {\n+\n+        default void format(OptionGroup group, Consumer<CharSequence> sink) {\n+            formatHeader(group.name(), sink);\n+            formatBody(group.options(), sink);\n+        }\n+\n+        void formatHeader(String gropName, Consumer<CharSequence> sink);\n+\n+        void formatBody(Iterable<? extends OptionSpec<?>> optionSpecs, Consumer<CharSequence> sink);\n+    }\n+\n+\n+    record ConsoleOptionFormatter(int nameOffset, int descriptionOffset) implements OptionFormatter {\n+\n+        @Override\n+        public void format(String optionNames, Optional<String> valuePattern, String description, Consumer<CharSequence> sink) {\n+            sink.accept(\" \".repeat(nameOffset));\n+            sink.accept(optionNames);\n+            valuePattern.map(v -> \" \" + v).ifPresent(sink);\n+            eol(sink);\n+            final var descriptionOffsetStr = \" \".repeat(descriptionOffset);\n+            Stream.of(description.split(\"\\\\R\")).map(line -> {\n+                return descriptionOffsetStr + line;\n+            }).forEach(line -> {\n+                sink.accept(line);\n+                eol(sink);\n+            });\n+        }\n+    }\n+\n+\n+    record ConsoleOptionGroupFormatter(OptionFormatter optionFormatter) implements OptionGroupFormatter {\n+\n+        ConsoleOptionGroupFormatter {\n+            Objects.requireNonNull(optionFormatter);\n+        }\n+\n+        @Override\n+        public void formatHeader(String groupName, Consumer<CharSequence> sink) {\n+            Objects.requireNonNull(groupName);\n+            eol(sink);\n+            sink.accept(groupName + \":\");\n+            eol(sink);\n+        }\n+\n+        @Override\n+        public void formatBody(Iterable<? extends OptionSpec<?>> optionSpecs, Consumer<CharSequence> sink) {\n+            optionSpecs.forEach(optionSpec -> {\n+                optionFormatter.format(optionSpec, sink);\n+            });\n+        }\n+    }\n+\n+\n+    record OptionGroup(String name, List<? extends OptionSpec<?>> options) {\n+\n+        OptionGroup {\n+            Objects.requireNonNull(name);\n+            Objects.requireNonNull(options);\n+        }\n+    }\n+\n+\n+    static Consumer<CharSequence> eol(Consumer<CharSequence> sink) {\n+        sink.accept(System.lineSeparator());\n+        return sink;\n+    }\n+\n+\n+    private final List<OptionGroup> optionGroups;\n+    private final OptionGroupFormatter formatter;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/HelpFormatter.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import java.util.List;\n+import java.util.Map;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.util.MultiResourceBundle;\n+import jdk.jpackage.internal.util.StringBundle;\n+\n+final class I18N {\n+\n+    private I18N() {\n+    }\n+\n+    static String format(String key, Object ... args) {\n+        return BUNDLE.format(key, args);\n+    }\n+\n+    private static final StringBundle BUNDLE;\n+\n+    static {\n+        var prefix = \"jdk.jpackage.internal.resources.\";\n+        BUNDLE = StringBundle.fromResourceBundle(MultiResourceBundle.create(\n+                prefix + \"MainResources\",\n+                Map.of(\n+                        OperatingSystem.LINUX, List.of(prefix + \"LinuxResources\"),\n+                        OperatingSystem.MACOS, List.of(prefix + \"MacResources\"),\n+                        OperatingSystem.WINDOWS, List.of(prefix + \"WinResources\")\n+                )\n+        ));\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/I18N.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,815 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+import static java.util.stream.Collectors.toUnmodifiableMap;\n+import static java.util.stream.Collectors.toUnmodifiableSet;\n+\n+import java.lang.reflect.Array;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+import jdk.internal.joptsimple.ArgumentAcceptingOptionSpec;\n+import jdk.internal.joptsimple.OptionParser;\n+import jdk.internal.joptsimple.OptionSet;\n+import jdk.jpackage.internal.cli.DefaultOptions.OptionIdentifierWithValue;\n+import jdk.jpackage.internal.cli.DefaultOptions.Snapshot;\n+import jdk.jpackage.internal.cli.OptionSpec.MergePolicy;\n+import jdk.jpackage.internal.util.Result;\n+\n+\n+\/**\n+ * Builds an instance of {@link Options} interface backed with joptsimple command\n+ * line parser.\n+ *\n+ * Two types of command line argument processing are supported:\n+ * <ol>\n+ * <li>Parse command line. Parsed data is stored as a map of strings.\n+ * <li>Convert strings to objects. Parsed data is stored as a map of objects.\n+ * <\/ol>\n+ *\/\n+final class JOptSimpleOptionsBuilder {\n+\n+    Function<String[], Result<OptionsBuilder>> create() {\n+        return createJOptSimpleParser()::parse;\n+    }\n+\n+    JOptSimpleOptionsBuilder options(Collection<? extends WithOptionIdentifier> v) {\n+        v.stream().map(u -> {\n+            switch (u) {\n+                case Option o -> {\n+                    return o;\n+                }\n+                case OptionValue<?> ov -> {\n+                    return ov.getOption();\n+                }\n+                default -> {\n+                    throw new IllegalArgumentException();\n+                }\n+            }\n+        }).forEach(options::add);\n+        return this;\n+    }\n+\n+    JOptSimpleOptionsBuilder options(WithOptionIdentifier... v) {\n+        return options(List.of(v));\n+    }\n+\n+    JOptSimpleOptionsBuilder optionSpecMapper(UnaryOperator<OptionSpec<?>> v) {\n+        optionSpecMapper = v;\n+        return this;\n+    }\n+\n+    JOptSimpleOptionsBuilder jOptSimpleParserErrorHandler(Function<JOptSimpleError, ? extends Exception> v) {\n+        jOptSimpleParserErrorHandler = v;\n+        return this;\n+    }\n+\n+    private JOptSimpleParser createJOptSimpleParser() {\n+        return JOptSimpleParser.create(options, Optional.ofNullable(optionSpecMapper),\n+                Optional.ofNullable(jOptSimpleParserErrorHandler));\n+    }\n+\n+\n+    static final class ConvertedOptionsBuilder {\n+\n+        private ConvertedOptionsBuilder(TypedOptions options) {\n+            impl = Objects.requireNonNull(options);\n+        }\n+\n+        Options create() {\n+            return impl;\n+        }\n+\n+        ConvertedOptionsBuilder copyWithExcludes(Collection<? extends OptionIdentifier> v) {\n+            return new ConvertedOptionsBuilder(impl.copyWithout(v));\n+        }\n+\n+        List<String> nonOptionArguments() {\n+            return impl.nonOptionArguments();\n+        }\n+\n+        List<OptionName> detectedOptions() {\n+            return impl.detectedOptions();\n+        }\n+\n+        private final TypedOptions impl;\n+    }\n+\n+\n+    static final class OptionsBuilder {\n+\n+        private OptionsBuilder(UntypedOptions options) {\n+            impl = Objects.requireNonNull(options);\n+        }\n+\n+        Result<ConvertedOptionsBuilder> convertedOptions() {\n+            return impl.toTypedOptions().map(ConvertedOptionsBuilder::new);\n+        }\n+\n+        Options create() {\n+            return impl;\n+        }\n+\n+        OptionsBuilder copyWithExcludes(Collection<? extends OptionIdentifier> v) {\n+            return new OptionsBuilder(impl.copyWithout(v));\n+        }\n+\n+        List<String> nonOptionArguments() {\n+            return impl.nonOptionArguments();\n+        }\n+\n+        List<OptionName> detectedOptions() {\n+            return impl.detectedOptions();\n+        }\n+\n+        private final UntypedOptions impl;\n+    }\n+\n+\n+    enum JOptSimpleErrorType {\n+\n+        \/\/ jdk.internal.joptsimple.UnrecognizedOptionException\n+        UNRECOGNIZED_OPTION(() -> {\n+            new OptionParser(false).parse(\"--foo\");\n+        }),\n+\n+        \/\/ jdk.internal.joptsimple.OptionMissingRequiredArgumentException\n+        OPTION_MISSING_REQUIRED_ARGUMENT(() -> {\n+            var parser = new OptionParser(false);\n+            parser.accepts(\"foo\").withRequiredArg();\n+            parser.parse(\"--foo\");\n+        }),\n+        ;\n+\n+        JOptSimpleErrorType(Runnable initializer) {\n+            try {\n+                initializer.run();\n+                throw new AssertionError();\n+            } catch (jdk.internal.joptsimple.OptionException ex) {\n+                type = ex.getClass();\n+            }\n+        }\n+\n+        private final Class<? extends jdk.internal.joptsimple.OptionException> type;\n+    }\n+\n+\n+    record JOptSimpleError(JOptSimpleErrorType type, OptionName optionName) {\n+\n+        JOptSimpleError {\n+            Objects.requireNonNull(type);\n+            Objects.requireNonNull(optionName);\n+        }\n+\n+        static JOptSimpleError create(jdk.internal.joptsimple.OptionException ex) {\n+            var optionName = OptionName.of(ex.options().getFirst());\n+            return Stream.of(JOptSimpleErrorType.values()).filter(v -> {\n+                return v.type.isInstance(ex);\n+            }).findFirst().map(v -> {\n+                return new JOptSimpleError(v, optionName);\n+            }).orElseThrow();\n+        }\n+    }\n+\n+\n+    private record JOptSimpleParser(\n+            OptionParser parser,\n+            Map<OptionIdentifier, ? extends OptionSpec<?>> optionMap,\n+            Optional<Function<JOptSimpleError, ? extends Exception>> jOptSimpleParserErrorHandler) {\n+\n+        private JOptSimpleParser {\n+            Objects.requireNonNull(parser);\n+            Objects.requireNonNull(optionMap);\n+            Objects.requireNonNull(jOptSimpleParserErrorHandler);\n+        }\n+\n+        Result<OptionsBuilder> parse(String... args) {\n+            return applyParser(parser, args).map(optionSet -> {\n+                final OptionSet mergerOptionSet;\n+                if (optionMap.values().stream().allMatch(spec -> spec.names().size() == 1)) {\n+                    \/\/ No specs with multiple names, merger not needed.\n+                    mergerOptionSet = optionSet;\n+                } else {\n+                    final var parser2 = createOptionParser();\n+                    final var optionSpecApplier = new OptionSpecApplier();\n+                    for (final var spec : optionMap.values()) {\n+                        optionSpecApplier.applyToParser(parser2, spec);\n+                    }\n+\n+                    mergerOptionSet = parser2.parse(args);\n+                }\n+                return new OptionsBuilder(new UntypedOptions(optionSet, mergerOptionSet, optionMap));\n+            });\n+        }\n+\n+        static JOptSimpleParser create(Iterable<Option> options,\n+                Optional<UnaryOperator<OptionSpec<?>>> optionSpecMapper,\n+                Optional<Function<JOptSimpleError, ? extends Exception>> jOptSimpleParserErrorHandler) {\n+            final var parser = createOptionParser();\n+\n+            \/\/ Create joptsimple option specs for distinct option names,\n+            \/\/ i.e., individual joptsimple option spec for every name of jpackage option spec.\n+            \/\/ This is needed to accurately detect what option names were passed.\n+            final var optionSpecApplier = new OptionSpecApplier().generateForEveryName(true);\n+\n+            final var optionStream = StreamSupport.stream(options.spliterator(), false);\n+\n+            final var optionMap = optionSpecMapper.map(mapper -> {\n+                return optionStream.map(option -> {\n+                    return option.copyWithSpec(mapper.apply(option.spec()));\n+                });\n+            }).orElse(optionStream).peek(option -> {\n+                optionSpecApplier.applyToParser(parser, option.spec());\n+            }).collect(toUnmodifiableMap(Option::id, Option::spec));\n+\n+            return new JOptSimpleParser(parser, optionMap, jOptSimpleParserErrorHandler);\n+        }\n+\n+        private Result<OptionSet> applyParser(OptionParser parser, String[] args) {\n+            try {\n+                return Result.ofValue(parser.parse(args));\n+            } catch (jdk.internal.joptsimple.OptionException ex) {\n+                return Result.ofError(jOptSimpleParserErrorHandler.map(handler -> {\n+                    var err = handler.apply(JOptSimpleError.create(ex));\n+                    return Objects.requireNonNull(err);\n+                }).orElse(ex));\n+            }\n+        }\n+\n+        private static OptionParser createOptionParser() {\n+            \/\/ No abbreviations!\n+            \/\/ Otherwise for the configured option \"foo\" it will recognize \"f\" as its abbreviation.\n+            return new OptionParser(false);\n+        }\n+    }\n+\n+\n+    private static final class OptionSpecApplier {\n+\n+        <T> void applyToParser(OptionParser parser, OptionSpec<T> spec) {\n+            final Stream<OptionSpec<T>> optionSpecs;\n+            if (generateForEveryName) {\n+                optionSpecs = spec.copyForEveryName();\n+            } else {\n+                optionSpecs = Stream.of(spec);\n+            }\n+\n+            optionSpecs.forEach(v -> {\n+                final var specBuilder = parser.acceptsAll(v.names().stream().map(OptionName::name).toList());\n+                if (v.hasValue()) {\n+                    if (v.isValueOptional()) {\n+                        specBuilder.withOptionalArg();\n+                    } else {\n+                        specBuilder.withRequiredArg();\n+                    }\n+                }\n+            });\n+        }\n+\n+        OptionSpecApplier generateForEveryName(boolean v) {\n+            generateForEveryName = v;\n+            return this;\n+        }\n+\n+        private boolean generateForEveryName;\n+    }\n+\n+\n+    sealed interface ExtendedOptions<T extends ExtendedOptions<T>> extends Options {\n+\n+        \/**\n+         * Gets the list of command line tokens not linked to any option in the order\n+         * they appear on the command line.\n+         *\n+         * @return Gets the list of command line tokens not linked to any option in the\n+         *         order they appear on the command line\n+         *\/\n+        List<String> nonOptionArguments();\n+\n+        \/**\n+         * Gets the list of names of detected options in the order they appear on the\n+         * command line. A name will appear in the list as many times as the\n+         * corresponding option on the command line.\n+         *\n+         * @return the list of names of detected options in the order they appear on the\n+         *         command line\n+         *\/\n+        List<OptionName> detectedOptions();\n+\n+        DefaultOptions toDefaultOptions();\n+    }\n+\n+\n+    private static final class UntypedOptions implements ExtendedOptions<UntypedOptions> {\n+\n+        UntypedOptions(OptionSet optionSet, OptionSet mergerOptionSet, Map<OptionIdentifier, ? extends OptionSpec<?>> optionMap) {\n+            this.optionSet = Objects.requireNonNull(optionSet);\n+            this.mergerOptionSet = Objects.requireNonNull(mergerOptionSet);\n+            optionNames = optionMap.values().stream()\n+                    .map(OptionSpec::names)\n+                    .flatMap(Collection::stream)\n+                    .filter(optionName -> {\n+                        return optionSet.has(optionName.name());\n+                    }).collect(toUnmodifiableSet());\n+            this.optionMap = optionMap.entrySet().stream().filter(e -> {\n+                return !Collections.disjoint(optionNames, e.getValue().names());\n+            }).collect(toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));\n+        }\n+\n+        private UntypedOptions(UntypedOptions other, Collection<? extends OptionIdentifier> excludes) {\n+            this(other.optionSet, other.mergerOptionSet, other.optionMap.entrySet().stream().filter(e -> {\n+                return !excludes.contains(e.getKey());\n+            }).collect(toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue)));\n+        }\n+\n+        @Override\n+        public UntypedOptions copyWithout(Iterable<? extends OptionIdentifier> ids) {\n+            return new UntypedOptions(this, StreamSupport.stream(ids.spliterator(), false).toList());\n+        }\n+\n+        @Override\n+        public Set<? extends OptionIdentifier> ids() {\n+            return optionMap.keySet();\n+        }\n+\n+        @Override\n+        public List<String> nonOptionArguments() {\n+            return optionSet.nonOptionArguments().stream().map(String.class::cast).toList();\n+        }\n+\n+        @Override\n+        public List<OptionName> detectedOptions() {\n+            return optionSet.specs().stream().flatMap(joptSpec -> {\n+                return joptSpec.options().stream().map(OptionName::new);\n+            }).filter(optionNames::contains).toList();\n+        }\n+\n+        @Override\n+        public DefaultOptions toDefaultOptions() {\n+            return new DefaultOptions(optionMap.entrySet().stream().collect(toUnmodifiableMap(e -> {\n+                return new Option(e.getKey(), e.getValue());\n+            }, e -> {\n+                return find(e.getKey()).orElseThrow();\n+            })), optionNames::contains);\n+        }\n+\n+        Result<TypedOptions> toTypedOptions() {\n+\n+            final List<Exception> errors = new ArrayList<>();\n+\n+            final var optionNameToOption = optionMap.entrySet().stream().map(e -> {\n+                return e.getValue().names().stream().map(optionName -> {\n+                    return Map.entry(optionName, new Option(e.getKey(), e.getValue()));\n+                });\n+            }).flatMap(x -> x).collect(toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));\n+\n+            var entries = OptionSpecWithValue.create(optionSet, mergerOptionSet, optionMap).stream().map(oswv -> {\n+                var option = optionNameToOption.get(oswv.optionName());\n+                if (!oswv.optionSpec().hasValue()) {\n+                    return new OptionIdentifierWithValue(option, Boolean.TRUE);\n+                } else {\n+                    return oswv.convertValue().map(v -> {\n+                        if (oswv.optionSpec().arrayValueConverter().isEmpty()) {\n+                            return new OptionIdentifierWithValue(option, v);\n+                        } else {\n+                            return new OptionIdentifierWithValue(option, new ArrayList<>(List.of(v)));\n+                        }\n+                    }).peekErrors(errors::addAll).value().orElse(null);\n+                }\n+            }).filter(Objects::nonNull).toList();\n+\n+            if (!errors.isEmpty()) {\n+                return Result.ofErrors(errors);\n+            } else {\n+                final Map<OptionIdentifier, OptionIdentifierWithValue> map = new HashMap<>();\n+\n+                for (var e : entries) {\n+                    var option = (Option)e.withId();\n+                    map.merge(option.id(), e, (a, b) -> {\n+                        if (option.spec().arrayValueConverter().isEmpty()) {\n+                            throw new AssertionError();\n+                        } else {\n+                            @SuppressWarnings(\"unchecked\")\n+                            var ar = ((List<Object>)a.value());\n+\n+                            @SuppressWarnings(\"unchecked\")\n+                            var br = ((List<Object>)b.value());\n+\n+                            ar.addAll(br);\n+                            return e.copyWithValue(ar);\n+                        }\n+                    });\n+                }\n+\n+                for (var value : map.values()) {\n+                    var option = (Option)value.withId();\n+                    if (option.spec().arrayValueConverter().isPresent()) {\n+                        var arr = mergeArrayValues(option.spec().mergePolicy(), (List<?>)value.value());\n+                        map.put(value.id(), value.copyWithValue(arr));\n+                    }\n+                }\n+\n+                return Result.ofValue(new TypedOptions(\n+                        DefaultOptions.create(new Snapshot(map, optionNames)),\n+                        detectedOptions(),\n+                        nonOptionArguments()));\n+            }\n+        }\n+\n+        @Override\n+        public Optional<Object> find(OptionIdentifier id) {\n+            Objects.requireNonNull(id);\n+            return Optional.ofNullable(optionMap.get(id)).map(spec -> {\n+                var values = getValues(spec);\n+                if (spec.hasValue()) {\n+                    return values.toArray(String[]::new);\n+                } else {\n+                    return new String[0];\n+                }\n+            });\n+        }\n+\n+        @Override\n+        public boolean contains(OptionName optionName) {\n+            return optionNames.contains(optionName);\n+        }\n+\n+        private List<String> getValues(OptionSpec<?> spec) {\n+            Objects.requireNonNull(spec);\n+\n+            final var values = optionValues(mergerOptionSet, spec.name());\n+\n+            if (!values.isEmpty()) {\n+                return getOptionValue(values, spec.mergePolicy());\n+            } else if (spec.names().stream().anyMatch(this::contains)) {\n+                \/\/ The spec belongs to an option detected on the command line.\n+                if (!spec.hasValue()) {\n+                    \/\/ The spec belongs to an option without a value.\n+                    return List.of();\n+                } else if (spec.isValueOptional()) {\n+                    \/\/ The spec belongs to an option with an optional value.\n+                    return List.of(spec.name().formatForCommandLine());\n+                }\n+            }\n+\n+            throw new AssertionError();\n+        }\n+\n+        private static Object mergeArrayValues(OptionSpec.MergePolicy mergePolicy, List<?> value) {\n+            switch (mergePolicy) {\n+                case USE_FIRST -> {\n+                    \/\/ Find the first non-empty array, get its first element and wrap it into one-element array.\n+                    return value.stream().filter(arr -> {\n+                        return Array.getLength(arr) > 0;\n+                    }).findFirst().map(arr -> {\n+                        return asArray(Array.get(arr, 0));\n+                    }).orElseGet(value::getFirst);\n+                }\n+                case USE_LAST -> {\n+                    \/\/ Find the last non-empty array, get its last element and wrap it into one-element array.\n+                    return value.reversed().stream().filter(arr -> {\n+                        return Array.getLength(arr) > 0;\n+                    }).findFirst().map(arr -> {\n+                        return asArray(Array.get(arr, Array.getLength(arr) - 1));\n+                    }).orElseGet(value::getFirst);\n+                }\n+                case CONCATENATE -> {\n+                    return value.stream().filter(arr -> {\n+                        return Array.getLength(arr) > 0;\n+                    }).map(Object.class::cast).reduce((a, b) -> {\n+                        final var al = Array.getLength(a);\n+                        final var bl = Array.getLength(b);\n+                        final var arr = Array.newInstance(a.getClass().componentType(), al + bl);\n+                        System.arraycopy(a, 0, arr, 0, al);\n+                        System.arraycopy(b, 0, arr, al, bl);\n+                        return arr;\n+                    }).orElseGet(value::getFirst);\n+                }\n+                default -> {\n+                    throw new AssertionError();\n+                }\n+            }\n+        }\n+\n+        private static Object asArray(Object v) {\n+            final var arr = Array.newInstance(v.getClass(), 1);\n+            Array.set(arr, 0, v);\n+            return arr;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private static List<String> optionValues(OptionSet optionSet, OptionName optionName) {\n+            return (List<String>)optionSet.valuesOf(optionName.name());\n+        }\n+\n+\n+        private record OptionSpecWithValue<T>(OptionSpec<T> optionSpec, Optional<String> optionValue) {\n+\n+            OptionSpecWithValue {\n+                Objects.requireNonNull(optionSpec);\n+                Objects.requireNonNull(optionValue);\n+\n+                if (optionSpec.names().size() != 1) {\n+                    throw new IllegalArgumentException();\n+                }\n+\n+                if (optionValue.isEmpty() && optionSpec.hasValue() && !optionSpec.isValueOptional()) {\n+                    throw new IllegalArgumentException();\n+                }\n+            }\n+\n+            OptionName optionName() {\n+                return optionSpec.name();\n+            }\n+\n+            Result<T> convertValue() {\n+                final var converter = optionSpec.converter().orElseThrow();\n+\n+                final Result<T> conversionResult = optionValue.map(v -> {\n+                    return converter.convert(optionName(), StringToken.of(v));\n+                }).orElseGet(() -> {\n+                    return Result.ofValue(optionSpec.defaultOptionalValue().orElseThrow());\n+                });\n+\n+                if (conversionResult.hasErrors()) {\n+                    final var arrConverter = optionSpec.arrayValueConverter().orElse(null);\n+\n+                    if (arrConverter != null && optionSpec.mergePolicy() != MergePolicy.CONCATENATE) {\n+                        \/\/ Maybe recoverable array conversion error\n+                        final var tokens = arrConverter.tokenize(optionValue.orElseThrow());\n+                        final String str = getOptionValue(List.of(tokens), optionSpec.mergePolicy()).getFirst();\n+                        final String[] token = arrConverter.tokenize(str);\n+                        if (token.length == 1 && str.equals(token[0])) {\n+                            final var singleTokenConversionResult = converter.convert(optionName(), StringToken.of(str));\n+                            if (singleTokenConversionResult.hasValue()) {\n+                                return singleTokenConversionResult;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                return conversionResult;\n+            }\n+\n+            static List<? extends OptionSpecWithValue<?>> create(OptionSet optionSet,\n+                    OptionSet mergerOptionSet, Map<OptionIdentifier, ? extends OptionSpec<?>> optionMap) {\n+\n+                Objects.requireNonNull(optionSet);\n+                Objects.requireNonNull(mergerOptionSet);\n+                Objects.requireNonNull(optionMap);\n+\n+                final var optionsWithOptionalValues = optionsWithOptionalValues(mergerOptionSet);\n+\n+                final var nameToOptionValues = optionMap.values().stream().map(optionSpec -> {\n+                    return optionSpec.names().stream();\n+                }).flatMap(x -> x).collect(toUnmodifiableMap(OptionName::name, optionName -> {\n+                    if (optionSet.has(optionName.name())) {\n+                        return Optional.ofNullable(optionsWithOptionalValues.get(optionName)).orElseGet(() -> {\n+                            return optionValues(optionSet, optionName).iterator();\n+                        });\n+                    } else {\n+                        return List.<String>of().iterator();\n+                    }\n+                }));\n+\n+                final var nameToOptionSpec = optionMap.values().stream().map(spec -> {\n+                    return spec.names().stream().map(name -> {\n+                        return Map.entry(name.name(), spec.copyWithName(name));\n+                    });\n+                }).flatMap(x -> x).collect(toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));\n+\n+                final var nameGroups = optionMap.values().stream().map(optionSpec -> {\n+                    return optionSpec.names().stream().map(optionName -> {\n+                        return Map.entry(optionName, optionSpec.names());\n+                    });\n+                }).flatMap(x -> x).collect(toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));\n+\n+                \/\/ Iterate option values in the order they appear on the command line.\n+                \/\/ OptionSet.specs() guarantees such order of option values.\n+                try {\n+                    return filterUnusedValues(nameGroups, optionSet.specs().stream().map(joptSpec -> {\n+                        var optionNames = joptSpec.options();\n+                        if (optionNames.size() != 1) {\n+                            throw new AssertionError();\n+                        }\n+                        return optionNames.getFirst();\n+                    }).filter(nameToOptionSpec::containsKey).map(name -> {\n+                        var optionSpec = nameToOptionSpec.get(name);\n+                        String optionValue;\n+                        if (!optionSpec.hasValue()) {\n+                            optionValue = null;\n+                        } else {\n+                            var it = nameToOptionValues.get(name);\n+                            if (it.hasNext()) {\n+                                optionValue = it.next();\n+                            } else if (optionSpec.isValueOptional()) {\n+                                return null;\n+                            } else {\n+                                throw new AssertionError();\n+                            }\n+                        }\n+                        OptionSpecWithValue<?> oswv = new OptionSpecWithValue<>(optionSpec, Optional.ofNullable(optionValue));\n+                        return oswv;\n+                    }).filter(Objects::nonNull).toList());\n+                } finally {\n+                    if (nameToOptionValues.values().stream().anyMatch(Iterator::hasNext)) {\n+                        throw new AssertionError(\"Unfetched option values detected\");\n+                    }\n+                }\n+            }\n+\n+            private static Map<OptionName, Iterator<String>> optionsWithOptionalValues(OptionSet optionSet) {\n+                Objects.requireNonNull(optionSet);\n+                return optionSet.specs().stream().distinct().filter(joptSpec -> {\n+                    if (joptSpec instanceof ArgumentAcceptingOptionSpec<?> v) {\n+                        return !v.requiresArgument();\n+                    } else {\n+                        return false;\n+                    }\n+                }).map(joptSpec -> {\n+                    @SuppressWarnings(\"unchecked\")\n+                    List<String> optionValues = ((List<String>)optionSet.valuesOf(joptSpec));\n+                    if (optionValues.isEmpty()) {\n+                        \/\/ `joptSpec` is detected on the command line without a value.\n+                        optionValues = Arrays.asList((String)null);\n+                    }\n+                    final var it = optionValues.iterator();\n+                    return joptSpec.options().stream().map(OptionName::of).map(optionName -> {\n+                        return Map.entry(optionName, it);\n+                    });\n+                }).flatMap(x -> x).collect(toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));\n+            }\n+\n+            private static List<? extends OptionSpecWithValue<?>> filterUnusedValues(\n+                    Map<OptionName, List<OptionName>> nameGroups, List<? extends OptionSpecWithValue<?>> items) {\n+\n+                items = filterFirstValues(nameGroups, items.reversed(), OptionSpec.MergePolicy.USE_LAST);\n+                items = filterFirstValues(nameGroups, items.reversed(), OptionSpec.MergePolicy.USE_FIRST);\n+\n+                return items;\n+            }\n+\n+            private static List<? extends OptionSpecWithValue<?>> filterFirstValues(\n+                    Map<OptionName, List<OptionName>> nameGroups,\n+                    List<? extends OptionSpecWithValue<?>> items,\n+                    OptionSpec.MergePolicy mergePolicy) {\n+\n+                Objects.requireNonNull(nameGroups);\n+                Objects.requireNonNull(items);\n+                Objects.requireNonNull(mergePolicy);\n+\n+                Set<OptionName> encounteredNames = new HashSet<>();\n+\n+                return items.stream().filter(item -> {\n+                    if (item.optionSpec().mergePolicy() != mergePolicy) {\n+                        return true;\n+                    } else if (!encounteredNames.contains(item.optionSpec().name())) {\n+                        encounteredNames.addAll(Objects.requireNonNull(nameGroups.get(item.optionSpec().name())));\n+                        return true;\n+                    } else {\n+                        return false;\n+                    }\n+                }).toList();\n+            }\n+        }\n+\n+        private final OptionSet optionSet;\n+        private final OptionSet mergerOptionSet;\n+        private final Map<OptionIdentifier, ? extends OptionSpec<?>> optionMap;\n+        private final Set<OptionName> optionNames;\n+    }\n+\n+\n+    private static final class TypedOptions implements ExtendedOptions<TypedOptions> {\n+\n+        TypedOptions(\n+                DefaultOptions options,\n+                List<OptionName> detectedOptions,\n+                List<String> nonOptionArguments) {\n+\n+            this.options = Objects.requireNonNull(options);\n+            this.nonOptionArguments = Objects.requireNonNull(nonOptionArguments);\n+            this.detectedOptions = Objects.requireNonNull(detectedOptions);\n+            assertNoUnexpectedOptionNames(options.withOptionIdentifierSet(), detectedOptions);\n+        }\n+\n+        @Override\n+        public TypedOptions copyWithout(Iterable<? extends OptionIdentifier> ids) {\n+            var newOptions = options.copyWithout(ids);\n+            var newDetectedOptions = detectedOptions.stream().filter(newOptions::contains).toList();\n+            return new TypedOptions(newOptions, newDetectedOptions, nonOptionArguments);\n+        }\n+\n+        @Override\n+        public List<String> nonOptionArguments() {\n+            return nonOptionArguments;\n+        }\n+\n+        @Override\n+        public List<OptionName> detectedOptions() {\n+            return detectedOptions;\n+        }\n+\n+        @Override\n+        public Set<? extends OptionIdentifier> ids() {\n+            return options.ids();\n+        }\n+\n+        @Override\n+        public Optional<Object> find(OptionIdentifier id) {\n+            return options.find(id);\n+        }\n+\n+        @Override\n+        public boolean contains(OptionName optionName) {\n+            return options.contains(optionName);\n+        }\n+\n+        @Override\n+        public DefaultOptions toDefaultOptions() {\n+            return options;\n+        }\n+\n+        private final DefaultOptions options;\n+        private final List<String> nonOptionArguments;\n+        private final List<OptionName> detectedOptions;\n+    }\n+\n+\n+    private static void assertNoUnexpectedOptionNames(Set<? extends WithOptionIdentifier> options, Collection<OptionName> optionNames) {\n+        final var allowedOptionNames = options.stream()\n+                .map(Option.class::cast)\n+                .map(Option::spec)\n+                .map(OptionSpec::names)\n+                .flatMap(Collection::stream)\n+                .toList();\n+        if (!allowedOptionNames.containsAll(optionNames)) {\n+            final var diff = new HashSet<>(optionNames);\n+            diff.removeAll(allowedOptionNames);\n+            throw new AssertionError(String.format(\"Unexpected option names: %s\", diff.stream().map(OptionName::name).sorted().toList()));\n+        }\n+    }\n+\n+    private static <T> List<T> getOptionValue(List<T> values, OptionSpec.MergePolicy mergePolicy) {\n+        Objects.requireNonNull(mergePolicy);\n+        if (values.size() == 1) {\n+            return values;\n+        } else {\n+            switch (mergePolicy) {\n+                case USE_LAST -> {\n+                    return List.of(values.getLast());\n+                }\n+                case USE_FIRST -> {\n+                    return List.of(values.getFirst());\n+                }\n+                case CONCATENATE -> {\n+                    return values;\n+                }\n+                default -> {\n+                    throw new AssertionError();\n+                }\n+            }\n+        }\n+    }\n+\n+    private Collection<Option> options = new ArrayList<>();\n+    private UnaryOperator<OptionSpec<?>> optionSpecMapper;\n+    private Function<JOptSimpleError, ? extends Exception> jOptSimpleParserErrorHandler;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/JOptSimpleOptionsBuilder.java","additions":815,"deletions":0,"binary":false,"changes":815,"status":"added"},{"patch":"@@ -0,0 +1,224 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+import static jdk.jpackage.internal.cli.StandardOption.HELP;\n+import static jdk.jpackage.internal.cli.StandardOption.VERBOSE;\n+import static jdk.jpackage.internal.cli.StandardOption.VERSION;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.UncheckedIOException;\n+import java.nio.file.NoSuchFileException;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.ServiceLoader;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import java.util.spi.ToolProvider;\n+import jdk.internal.opt.CommandLine;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.Log;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.JPackageException;\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n+\n+\/**\n+ * Main jpackage entry point.\n+ *\/\n+public final class Main {\n+\n+    public static final class Provider implements ToolProvider {\n+\n+        @Override\n+        public String name() {\n+            return \"jpackage\";\n+        }\n+\n+        @Override\n+        public int run(PrintWriter out, PrintWriter err, String... args) {\n+            return Main.run(out, err, args);\n+        }\n+    }\n+\n+\n+    private Main() {\n+    }\n+\n+    public static void main(String... args) {\n+        var out = new PrintWriter(System.out, true);\n+        var err = new PrintWriter(System.err, true);\n+        System.exit(run(out, err, args));\n+    }\n+\n+    public static int run(PrintWriter out, PrintWriter err, String... args) {\n+        Objects.requireNonNull(out);\n+        Objects.requireNonNull(err);\n+\n+        Log.setPrintWriter(out, err);\n+\n+        try {\n+            try {\n+                args = CommandLine.parse(args);\n+            } catch (FileNotFoundException|NoSuchFileException ex) {\n+                Log.fatalError(I18N.format(\"ERR_CannotParseOptions\", ex.getMessage()));\n+                return 1;\n+            } catch (IOException ex) {\n+                throw ExceptionBox.rethrowUnchecked(ex);\n+            }\n+\n+            final var bundlingEnv = ServiceLoader.load(CliBundlingEnvironment.class,\n+                    CliBundlingEnvironment.class.getClassLoader()).findFirst().orElseThrow();\n+\n+            final var parseResult = Utils.buildParser(OperatingSystem.current(), bundlingEnv).create().apply(args);\n+\n+            return new Runner().run(() -> {\n+                final var parsedOptionsBuilder = parseResult.orElseThrow();\n+\n+                final var options = parsedOptionsBuilder.create();\n+\n+                final var nonOptionArgumentsError = !parsedOptionsBuilder.nonOptionArguments().isEmpty();\n+\n+                if (options.ids().isEmpty() && !nonOptionArgumentsError) {\n+                    StandardHelpFormatter.INSTANCE.formatNoArgsHelp(out::append);\n+                    return List.of();\n+                } else if (HELP.containsIn(options)) {\n+                    if (VERSION.containsIn(options)) {\n+                        out.println(getVersion() + \"\\n\");\n+                    }\n+                    StandardHelpFormatter.INSTANCE.format(out::append);\n+                    return List.of();\n+                } else if (VERSION.containsIn(options) && !nonOptionArgumentsError) {\n+                    out.println(getVersion());\n+                    return List.of();\n+                }\n+\n+                if (VERBOSE.containsIn(options)) {\n+                    Log.setVerbose();\n+                }\n+\n+                final var optionsProcessor = new OptionsProcessor(parsedOptionsBuilder, bundlingEnv);\n+\n+                final var validationResult = optionsProcessor.validate();\n+\n+                final var bundlingResult = validationResult.map(optionsProcessor::runBundling);\n+\n+                if (bundlingResult.hasValue()) {\n+                    return bundlingResult.orElseThrow();\n+                } else {\n+                    return bundlingResult.errors();\n+                }\n+            });\n+        } finally {\n+            try {\n+                out.flush();\n+            } finally {\n+                err.flush();\n+            }\n+        }\n+    }\n+\n+\n+    record ErrorReporter(Consumer<Throwable> stackTracePrinter, Consumer<String> messagePrinter) {\n+        ErrorReporter {\n+            Objects.requireNonNull(stackTracePrinter);\n+            Objects.requireNonNull(messagePrinter);\n+        }\n+\n+        void reportError(Throwable t) {\n+            if (t instanceof ConfigException cfgEx) {\n+                printError(cfgEx, Optional.ofNullable(cfgEx.getAdvice()));\n+            } else if (t instanceof ExceptionBox ex) {\n+                reportError(ex.getCause());\n+            } else if (t instanceof UncheckedIOException ex) {\n+                reportError(ex.getCause());\n+            } else {\n+                printError(t, Optional.empty());\n+            }\n+        }\n+\n+        private void printError(Throwable t, Optional<String> advice) {\n+            stackTracePrinter.accept(t);\n+\n+            String msg;\n+            if (isAlienExceptionType(t)) {\n+                msg = t.toString();\n+            } else {\n+                msg = t.getMessage();\n+            }\n+\n+            messagePrinter.accept(I18N.format(\"message.error-header\", msg));\n+            advice.ifPresent(v -> messagePrinter.accept(I18N.format(\"message.advice-header\", v)));\n+        }\n+\n+        private static boolean isAlienExceptionType(Throwable t) {\n+            switch (t) {\n+                case JPackageException _ -> {\n+                    return false;\n+                }\n+                case Utils.ParseException _ -> {\n+                    return false;\n+                }\n+                case StandardOption.AddLauncherIllegalArgumentException _ -> {\n+                    return false;\n+                }\n+                default -> {\n+                    return true;\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    static final class Runner {\n+\n+        int run(Supplier<? extends Collection<? extends Exception>> r) {\n+            final var exceptions = runIt(r);\n+            if (exceptions.isEmpty()) {\n+                return 0;\n+            } else {\n+                var errorReporter = new ErrorReporter(Log::verbose, Log::fatalError);\n+                exceptions.forEach(errorReporter::reportError);\n+                return 1;\n+            }\n+        }\n+\n+        private static Collection<? extends Exception> runIt(Supplier<? extends Collection<? extends Exception>> r) {\n+            try {\n+                return r.get();\n+            } catch (RuntimeException ex) {\n+                return List.of(ex);\n+            }\n+        }\n+    }\n+\n+    private static String getVersion() {\n+        return System.getProperty(\"java.version\");\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/Main.java","additions":224,"deletions":0,"binary":false,"changes":224,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+final class MessageFormatUtils {\n+\n+    private MessageFormatUtils() {\n+    }\n+\n+    static String createMessage(Options cmdline, String formatId, Object... args) {\n+        return I18N.format(formatId, mapFormatArguments(cmdline, args));\n+    }\n+\n+    static String createMessage(String formatId, Object... args) {\n+        return I18N.format(formatId, mapFormatArguments(args));\n+    }\n+\n+    static Object[] mapFormatArguments(Object... args) {\n+        return mapFormatArguments(optionSpec -> {\n+            return optionSpec.name().formatForCommandLine();\n+        }, args);\n+    }\n+\n+    static Object[] mapFormatArguments(Options cmdline, Object... args) {\n+        Objects.requireNonNull(cmdline);\n+        return mapFormatArguments(optionSpec -> {\n+            return optionSpec.getFirstNameIn(cmdline).formatForCommandLine();\n+        }, args);\n+    }\n+\n+    private static Object[] mapFormatArguments(Function<OptionSpec<?>, String> optionSpecFormatter, Object... args) {\n+        Objects.requireNonNull(optionSpecFormatter);\n+        return Stream.of(args).map(arg -> {\n+            return asOptionSpec(arg).map(optionSpecFormatter).orElseGet(() -> {\n+                return Optional.ofNullable(arg).map(Object::toString).orElse(null);\n+            });\n+        }).toArray();\n+    }\n+\n+    private static Optional<OptionSpec<?>> asOptionSpec(Object v) {\n+        if (v instanceof OptionSpec<?> optionSpec) {\n+            return Optional.of(optionSpec);\n+        } else if (v instanceof OptionValue<?> ov) {\n+            return asOptionSpec(ov.getSpec());\n+        } else if (v instanceof Option option) {\n+            return asOptionSpec(option.spec());\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/MessageFormatUtils.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+import java.util.Objects;\n+import java.util.function.Predicate;\n+\n+\/**\n+ * Option identifier associated with option specification.\n+ *\/\n+record Option(OptionIdentifier id, OptionSpec<?> spec) implements WithOptionIdentifier {\n+\n+    Option {\n+        Objects.requireNonNull(id);\n+        Objects.requireNonNull(spec);\n+    }\n+\n+    Option(OptionSpec<?> spec) {\n+        this(OptionIdentifier.createIdentifier(), spec);\n+    }\n+\n+    Option copyWithSpec(OptionSpec<?> spec) {\n+        return new Option(id, spec);\n+    }\n+\n+    static Predicate<Option> fromOptionSpecPredicate(Predicate<OptionSpec<?>> p) {\n+        return option -> {\n+            return p.test(option.spec());\n+        };\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/Option.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+\/**\n+ * Defines creating an option value of type {@link T[]} from a string.\n+ *\n+ * @param <T> option value element type\n+ *\/\n+interface OptionArrayValueConverter<T> extends OptionValueConverter<T[]> {\n+\n+    \/**\n+     * Splits the given string into tokens and returns the result.\n+     *\n+     * @param str the string to tokenize\n+     * @return the result of tokenization of the input string\n+     *\/\n+    String[] tokenize(String str);\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionArrayValueConverter.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+import java.util.Objects;\n+\n+public sealed interface OptionIdentifier {\n+\n+    static OptionIdentifier createIdentifier() {\n+        return new Details.DefaultOptionIdentifier();\n+    }\n+\n+    static OptionIdentifier of(String id) {\n+        return new Details.StringOptionIdentifier(id);\n+    }\n+\n+    static final class Details {\n+\n+        private Details() {\n+        }\n+\n+        static final class DefaultOptionIdentifier implements OptionIdentifier {}\n+\n+        record StringOptionIdentifier(String value) implements OptionIdentifier {\n+            StringOptionIdentifier {\n+                Objects.requireNonNull(value);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionIdentifier.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import java.util.Objects;\n+\n+record OptionName(String name) implements Comparable<OptionName> {\n+\n+    OptionName(String name) {\n+        Objects.requireNonNull(name);\n+        if (name.isEmpty()) {\n+            throw new IllegalArgumentException(\"Name should not be empty\");\n+        }\n+\n+        if (name.charAt(0) != '-') {\n+            this.name = name;\n+        } else if (name.length() == 1) {\n+            throw new IllegalArgumentException(\"Short option without a name\");\n+        } else if (name.charAt(1) != '-') {\n+            \/\/ Reverse operation for a short option name\n+            this.name = name.substring(1, 2);\n+        } else if (name.length() == 2) {\n+            throw new IllegalArgumentException(\"Long option without a name\");\n+        } else {\n+            \/\/ Reverse operation for a long option name\n+            this.name = name.substring(2);\n+        }\n+    }\n+\n+    static OptionName of(String name) {\n+        return new OptionName(name);\n+    }\n+\n+    boolean isShort() {\n+        return name.length() == 1;\n+    }\n+\n+    String formatForCommandLine() {\n+        return (isShort() ? \"-\" : \"--\") + name;\n+    }\n+\n+    @Override\n+    public int compareTo(OptionName other) {\n+        return name.compareTo(other.name);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionName.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+\/**\n+ * Option scope.\n+ *\/\n+interface OptionScope {\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionScope.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+\/**\n+ * Source where command line options come from.\n+ *\/\n+sealed interface OptionSource {\n+\n+    static boolean isCommandLine(OptionSource v) {\n+        return v.equals(COMMAND_LINE);\n+    }\n+\n+    static Optional<Path> asFile(OptionSource v) {\n+        return Optional.of(v)\n+                .filter(Details.FileOptionSource.class::isInstance)\n+                .map(Details.FileOptionSource.class::cast)\n+                .map(Details.FileOptionSource::path);\n+    }\n+\n+    static OptionSource fromFile(Path v) {\n+        return new Details.FileOptionSource(v);\n+    }\n+\n+    static final class Details {\n+\n+        private Details() {\n+        }\n+\n+        private enum CommandLineOptionSource implements OptionSource {\n+            VALUE\n+        }\n+\n+        private record FileOptionSource(Path path) implements OptionSource {\n+            FileOptionSource {\n+                Objects.requireNonNull(path);\n+            }\n+        }\n+    }\n+\n+    static final OptionSource COMMAND_LINE = Details.CommandLineOptionSource.VALUE;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionSource.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,180 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+\n+\/**\n+ * Option spec.\n+ *\n+ * Names are used to identify an option. Converter converts option value from a\n+ * {@link String} to an object of type {@link T}. Scope defines where the option\n+ * applies. The standard scopes are: {@link BundlingOperationOptionScope},\n+ * {@link BundlingOperationModifier}. Merge policy defines how to handle\n+ * multiple values of the option. Value pattern and description are targeted for\n+ * help output.\n+ *\n+ * @param names                the names. Must be non-empty\n+ * @param converter            the converter. Converts from a {@link String} to\n+ *                             an object of type {@link T}\n+ * @param scope                the scope. Must be non-empty\n+ * @param defaultOptionalValue the default optional value or an empty\n+ *                             {@link Optional} instance if the option has a\n+ *                             mandatory value or doesn't have a value\n+ * @param mergePolicy          the merge policy\n+ * @param valuePattern         the value pattern. Used in help output\n+ * @param description          the description. Used in help output\n+ * @param <T>                  option value type\n+ *\/\n+record OptionSpec<T>(\n+        List<OptionName> names,\n+        Optional<OptionValueConverter<T>> converter,\n+        Set<OptionScope> scope,\n+        MergePolicy mergePolicy,\n+        Optional<T> defaultOptionalValue,\n+        Optional<String> valuePattern,\n+        String description) {\n+\n+    enum MergePolicy {\n+        USE_FIRST,\n+        USE_LAST,\n+        CONCATENATE\n+    }\n+\n+    OptionSpec {\n+        Objects.requireNonNull(names);\n+        if (names.isEmpty()) {\n+            throw new IllegalArgumentException(\"Empty name list\");\n+        }\n+        Objects.requireNonNull(converter);\n+        Objects.requireNonNull(scope);\n+        if (scope.isEmpty()) {\n+            throw new IllegalArgumentException(\"Empty scope\");\n+        }\n+        Objects.requireNonNull(mergePolicy);\n+        Objects.requireNonNull(valuePattern);\n+        if (converter.isEmpty() && valuePattern.isPresent()) {\n+            throw new IllegalArgumentException(\"Option without a value can not have a value pattern\");\n+        }\n+        if (converter.isEmpty() && defaultOptionalValue.isPresent()) {\n+            throw new IllegalArgumentException(\"Option with optional value should have a converter\");\n+        }\n+        Objects.requireNonNull(description);\n+\n+        final var typeMustBeArray = mergePolicy.equals(MergePolicy.CONCATENATE);\n+        final var type = valueType(converter);\n+        if (typeMustBeArray && !type.map(Class::isArray).orElse(false)) {\n+            throw new IllegalArgumentException(String.format(\"Invalid merge policy [%s] for type [%s]\",\n+                    mergePolicy, type.map(Class::getName).orElse(\"\")));\n+        }\n+\n+        names = List.copyOf(names);\n+        scope = Set.copyOf(scope);\n+    }\n+\n+    \/**\n+     * Returns the first (primary) name of this option spec.\n+     *\n+     * @return the first name of this option spec\n+     *\/\n+    OptionName name() {\n+        return names.getFirst();\n+    }\n+\n+    \/**\n+     * Returns all names but the first of this option spec. Returns an empty list if\n+     * the option spec has only one name.\n+     *\n+     * @return the additional names\n+     *\/\n+    List<OptionName> otherNames() {\n+        return names.subList(1, names.size());\n+    }\n+\n+    \/**\n+     * Returns a stream of copy option spec objects, each having a single name.\n+     * <p>\n+     * If the option has three names \"a\", \"b\", and \"c\", the stream will have three\n+     * option spec objects each with a single name. The firt will have name \"a\", the\n+     * second - \"b\", and the third \"c\".\n+     *\n+     * @return the stream of copy option spec objects each having a single name\n+     *\/\n+    Stream<OptionSpec<T>> copyForEveryName() {\n+        return names().stream().map(v -> {\n+            return new OptionSpec<>(List.of(v), converter, scope, mergePolicy, defaultOptionalValue, valuePattern, description);\n+        });\n+    }\n+\n+    <U> OptionSpec<U> copyWithConverter(OptionValueConverter<U> converter) {\n+        if (!defaultOptionalValue.isEmpty()) {\n+            throw new UnsupportedOperationException(\"Can not convert an option spec with optional value\");\n+        }\n+        return new OptionSpec<>(names, Optional.of(converter), scope, mergePolicy, Optional.empty(), valuePattern, description);\n+    }\n+\n+    OptionSpec<T> copyWithDescription(String description) {\n+        return new OptionSpec<>(names, converter, scope, mergePolicy, defaultOptionalValue, valuePattern, Objects.requireNonNull(description));\n+    }\n+\n+    OptionSpec<T> copyWithName(OptionName name) {\n+        return new OptionSpec<>(List.of(name), converter, scope, mergePolicy, defaultOptionalValue, valuePattern, description);\n+    }\n+\n+    List<OptionName> findNamesIn(Options cmdline) {\n+        return names().stream().filter(cmdline::contains).toList();\n+    }\n+\n+    OptionName getFirstNameIn(Options cmdline) {\n+        return findNamesIn(cmdline).getFirst();\n+    }\n+\n+    boolean hasValue() {\n+        return converter.isPresent();\n+    }\n+\n+    boolean isValueOptional() {\n+        return defaultOptionalValue.isPresent();\n+    }\n+\n+    Class<? extends T> valueType() {\n+        return valueType(converter).orElseThrow();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    <U> Optional<OptionArrayValueConverter<U>> arrayValueConverter() {\n+        return converter.filter(OptionArrayValueConverter.class::isInstance).map(v -> (OptionArrayValueConverter<U>)v);\n+    }\n+\n+    private static <T> Optional<Class<? extends T>> valueType(Optional<OptionValueConverter<T>> valueConverter) {\n+        return valueConverter.map(OptionValueConverter::valueType);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionSpec.java","additions":180,"deletions":0,"binary":false,"changes":180,"status":"added"},{"patch":"@@ -0,0 +1,475 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import java.io.File;\n+import java.lang.reflect.Array;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.cli.OptionSpec.MergePolicy;\n+\n+final class OptionSpecBuilder<T> {\n+\n+    static <T> OptionSpecBuilder<T> create(Class<? extends T> valueType) {\n+        return new OptionSpecBuilder<>(valueType);\n+    }\n+\n+    static String pathSeparator() {\n+        return File.pathSeparator;\n+    }\n+\n+    static <T> Function<OptionValue.Builder<T[]>, OptionValue<List<T>>> toList() {\n+        return builder -> {\n+            return builder.to(List::of).create();\n+        };\n+    }\n+\n+    private OptionSpecBuilder(Class<? extends T> valueType) {\n+        this.valueType = Objects.requireNonNull(valueType);\n+    }\n+\n+    OptionSpecBuilder(OptionSpecBuilder<T> other) {\n+        valueType = other.valueType;\n+        name = other.name;\n+        nameAliases.addAll(other.nameAliases);\n+        description = other.description;\n+        mergePolicy = other.mergePolicy;\n+        scope = Set.copyOf(other.scope);\n+        defaultValue = other.defaultValue;\n+        defaultOptionalValue = other.defaultOptionalValue;\n+        valuePattern = other.valuePattern;\n+        converterBuilder = other.converterBuilder.copy();\n+        validatorBuilder = other.validatorBuilder.copy();\n+\n+        if (other.arrayDefaultValue != null) {\n+            arrayDefaultValue = Arrays.copyOf(other.arrayDefaultValue, other.arrayDefaultValue.length);\n+        }\n+        arrayValuePatternSeparator = other.arrayValuePatternSeparator;\n+        arrayTokenizer = other.arrayTokenizer;\n+    }\n+\n+    OptionSpecBuilder<T> copy() {\n+        return new OptionSpecBuilder<>(this);\n+    }\n+\n+    Class<? extends T> valueType() {\n+        return valueType;\n+    }\n+\n+    OptionValue<T> create() {\n+        return toOptionValueBuilder().create();\n+    }\n+\n+    OptionValue<T[]> createArray() {\n+        return toArrayOptionValueBuilder().create();\n+    }\n+\n+    <U> OptionValue<U> create(Function<OptionValue.Builder<T>, OptionValue<U>> transformer) {\n+        return transformer.apply(toOptionValueBuilder());\n+    }\n+\n+    <U> OptionValue<U> createArray(Function<OptionValue.Builder<T[]>, OptionValue<U>> transformer) {\n+        return transformer.apply(toArrayOptionValueBuilder());\n+    }\n+\n+    OptionValue.Builder<T> toOptionValueBuilder() {\n+        final var builder = OptionValue.<T>build().spec(createOptionSpec());\n+        defaultValue().ifPresent(builder::defaultValue);\n+        return builder;\n+    }\n+\n+    OptionValue.Builder<T[]> toArrayOptionValueBuilder() {\n+        final var builder = OptionValue.<T[]>build().spec(createArrayOptionSpec());\n+        defaultArrayValue().ifPresent(builder::defaultValue);\n+        return builder;\n+    }\n+\n+    OptionSpec<T> createOptionSpec() {\n+        return new OptionSpec<>(\n+                names(),\n+                createConverter(),\n+                scope,\n+                mergePolicy().orElse(MergePolicy.USE_LAST),\n+                defaultOptionalValue(),\n+                valuePattern(),\n+                description().orElse(\"\"));\n+    }\n+\n+    OptionSpec<T[]> createArrayOptionSpec() {\n+        return new OptionSpec<>(\n+                names(),\n+                Optional.of(createArrayConverter()),\n+                scope,\n+                OptionSpecBuilder.this.mergePolicy().orElse(MergePolicy.CONCATENATE),\n+                defaultArrayOptionalValue(),\n+                Optional.of(arryValuePattern()),\n+                OptionSpecBuilder.this.description().orElse(\"\"));\n+    }\n+\n+    OptionSpecBuilder<T> tokenizer(String splitRegexp) {\n+        Objects.requireNonNull(splitRegexp);\n+        return tokenizer(str -> {\n+            return str.split(splitRegexp);\n+        }).arrayValuePatternSeparator(splitRegexp);\n+    }\n+\n+    OptionSpecBuilder<T> tokenizeOne() {\n+        return tokenizer((Function<String, String[]>)null);\n+    }\n+\n+    OptionSpecBuilder<T> tokenizer(Function<String, String[]> v) {\n+        arrayTokenizer = v;\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> mutate(Consumer<OptionSpecBuilder<T>> mutator) {\n+        mutator.accept(this);\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> validatorExceptionFormatString(String v) {\n+        validatorBuilder.formatString(v);\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> validatorExceptionFormatString(UnaryOperator<String> mutator) {\n+        validatorBuilder.formatString(mutator.apply(validatorBuilder.formatString().orElse(null)));\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> converterExceptionFormatString(String v) {\n+        converterBuilder.formatString(v);\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> converterExceptionFormatString(UnaryOperator<String> mutator) {\n+        converterBuilder.formatString(mutator.apply(converterBuilder.formatString().orElse(null)));\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> validatorExceptionFactory(OptionValueExceptionFactory<? extends RuntimeException> v) {\n+        validatorBuilder.exceptionFactory(v);\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> validatorExceptionFactory(UnaryOperator<OptionValueExceptionFactory<? extends RuntimeException>> mutator) {\n+        return validatorExceptionFactory(mutator.apply(validatorBuilder.exceptionFactory().orElse(null)));\n+    }\n+\n+    OptionSpecBuilder<T> converterExceptionFactory(OptionValueExceptionFactory<? extends RuntimeException> v) {\n+        converterBuilder.exceptionFactory(v);\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> converterExceptionFactory(UnaryOperator<OptionValueExceptionFactory<? extends RuntimeException>> mutator) {\n+        return converterExceptionFactory(mutator.apply(converterBuilder.exceptionFactory().orElse(null)));\n+    }\n+\n+    OptionSpecBuilder<T> exceptionFormatString(String v) {\n+        return validatorExceptionFormatString(v).converterExceptionFormatString(v);\n+    }\n+\n+    OptionSpecBuilder<T> exceptionFormatString(UnaryOperator<String> mutator) {\n+        return validatorExceptionFormatString(mutator).converterExceptionFormatString(mutator);\n+    }\n+\n+    OptionSpecBuilder<T> exceptionFactory(OptionValueExceptionFactory<? extends RuntimeException> v) {\n+        return validatorExceptionFactory(v).converterExceptionFactory(v);\n+    }\n+\n+    OptionSpecBuilder<T> exceptionFactory(UnaryOperator<OptionValueExceptionFactory<? extends RuntimeException>> mutator) {\n+        return validatorExceptionFactory(mutator).converterExceptionFactory(mutator);\n+    }\n+\n+    OptionSpecBuilder<T> converter(ValueConverter<T> v) {\n+        converterBuilder.converter(v);\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> converter(Function<String, T> v) {\n+        return converter(ValueConverter.create(v, valueType));\n+    }\n+\n+    OptionSpecBuilder<T> validator(Predicate<T> v) {\n+        validatorBuilder.predicate(v::test);\n+        return this;\n+    }\n+\n+    @SuppressWarnings(\"overloads\")\n+    OptionSpecBuilder<T> validator(Consumer<T> v) {\n+        validatorBuilder.consumer(v::accept);\n+        return this;\n+    }\n+\n+    @SuppressWarnings(\"overloads\")\n+    OptionSpecBuilder<T> validator(UnaryOperator<Validator.Builder<T, RuntimeException>> mutator) {\n+        validatorBuilder = mutator.apply(validatorBuilder);\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> withoutConverter() {\n+        converterBuilder.converter(null);\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> withoutValidator() {\n+        validatorBuilder.predicate(null).consumer(null);\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> name(String v) {\n+        name = v;\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> addAliases(String... v) {\n+        nameAliases.addAll(List.of(v));\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> description(String v) {\n+        description = v;\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> mergePolicy(MergePolicy v) {\n+        mergePolicy = v;\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> scope(OptionScope... v) {\n+        return scope(Set.of(v));\n+    }\n+\n+    OptionSpecBuilder<T> scope(Collection<? extends OptionScope> v) {\n+        scope = Set.copyOf(v);\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> scope(UnaryOperator<Set<OptionScope>> mutator) {\n+        return scope(mutator.apply(scope().orElseGet(Set::of)));\n+    }\n+\n+    OptionSpecBuilder<T> inScope(OptionScope... v) {\n+        return inScope(Set.of(v));\n+    }\n+\n+    OptionSpecBuilder<T> inScope(Collection<? extends OptionScope> v) {\n+        final Set<OptionScope> newScope = new HashSet<>(v);\n+        scope().ifPresent(newScope::addAll);\n+        scope = newScope;\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> outOfScope(OptionScope... v) {\n+        return outOfScope(Set.of(v));\n+    }\n+\n+    OptionSpecBuilder<T> outOfScope(Collection<? extends OptionScope> v) {\n+        if (scope != null) {\n+            final Set<OptionScope> newScope = new HashSet<>(scope);\n+            newScope.removeAll(v);\n+            scope = newScope;\n+        }\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> defaultValue(T v) {\n+        defaultValue = v;\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> defaultOptionalValue(T v) {\n+        defaultOptionalValue = v;\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> defaultArrayValue(T[] v) {\n+        arrayDefaultValue = v;\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> arrayValuePatternSeparator(String v) {\n+        arrayValuePatternSeparator = v;\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> valuePattern(String v) {\n+        valuePattern = v;\n+        return this;\n+    }\n+\n+    private Optional<String> name() {\n+        return Optional.ofNullable(name);\n+    }\n+\n+    private Optional<String> description() {\n+        return Optional.ofNullable(description);\n+    }\n+\n+    private Optional<MergePolicy> mergePolicy() {\n+        return Optional.ofNullable(mergePolicy);\n+    }\n+\n+    private Optional<Set<OptionScope>> scope() {\n+        return Optional.ofNullable(scope);\n+    }\n+\n+    private Optional<T> defaultValue() {\n+        return Optional.ofNullable(defaultValue);\n+    }\n+\n+    private Optional<T[]> defaultArrayValue() {\n+        return Optional.ofNullable(arrayDefaultValue).or(() -> {\n+            return OptionSpecBuilder.this.defaultValue().map(this::toOneElementArray);\n+        });\n+    }\n+\n+    private Optional<T> defaultOptionalValue() {\n+        return Optional.ofNullable(defaultOptionalValue);\n+    }\n+\n+    private Optional<T[]> defaultArrayOptionalValue() {\n+        return defaultOptionalValue().map(this::toOneElementArray);\n+    }\n+\n+    private Optional<String> valuePattern() {\n+        var hasOptionalValue = defaultOptionalValue().isPresent();\n+        return Optional.ofNullable(valuePattern).or(this::defaultValuePattern).map(str -> {\n+            if (str.isEmpty()) {\n+                return \"<>\";\n+            } else {\n+                var sb = new StringBuilder();\n+                switch (str.charAt(0)) {\n+                    case '<', '[' -> {\n+                    }\n+                    default -> {\n+                        if (hasOptionalValue) {\n+                            sb.append(\"[\");\n+                        }\n+                        sb.append(\"<\");\n+                    }\n+                }\n+                sb.append(str);\n+                switch (str.charAt(str.length() - 1)) {\n+                    case '>', ']' -> {\n+                    }\n+                    default -> {\n+                        sb.append(\">\");\n+                        if (hasOptionalValue) {\n+                            sb.append(\"]\");\n+                        }\n+                    }\n+                }\n+                return sb.toString();\n+            }\n+        });\n+    }\n+\n+    private Optional<String> defaultValuePattern() {\n+        return converterBuilder.converter().map(_ -> {\n+            final var tokens = name.split(\"-\");\n+            return tokens[tokens.length - 1];\n+        });\n+    }\n+\n+    private List<OptionName> names() {\n+        return Stream.of(\n+                List.of(name().orElseThrow()),\n+                nameAliases\n+        ).flatMap(Collection::stream).map(OptionName::new).distinct().toList();\n+    }\n+\n+    private Optional<OptionValueConverter<T>> createConverter() {\n+        if (converterBuilder.converter().isPresent()) {\n+            final var newBuilder = converterBuilder.copy();\n+            createValidator().ifPresent(newBuilder::validator);\n+            return Optional.of(newBuilder.create());\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private Optional<Validator<T, ? extends RuntimeException>> createValidator() {\n+        if (validatorBuilder.hasValidatingMethod()) {\n+            return Optional.of(validatorBuilder.create());\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private OptionValueConverter<T[]> createArrayConverter() {\n+        final var newBuilder = converterBuilder.copy();\n+        newBuilder.tokenizer(Optional.ofNullable(arrayTokenizer).orElse(str -> {\n+            return new String[] { str };\n+        }));\n+        createValidator().ifPresent(newBuilder::validator);\n+        return newBuilder.createArray();\n+    }\n+\n+    private String arryValuePattern() {\n+        final var elementValuePattern = OptionSpecBuilder.this.valuePattern().orElseThrow();\n+        if (arrayValuePatternSeparator == null) {\n+            return elementValuePattern;\n+        } else {\n+            return String.format(\"%s[%s%s...]\", elementValuePattern, arrayValuePatternSeparator, elementValuePattern);\n+        }\n+    }\n+\n+    private T[] toOneElementArray(T v) {\n+        Objects.requireNonNull(v);\n+        @SuppressWarnings(\"unchecked\")\n+        final var arr = (T[]) Array.newInstance(valueType, 1);\n+        arr[0] = v;\n+        return arr;\n+    }\n+\n+    private final Class<? extends T> valueType;\n+    private String name;\n+    private Collection<String> nameAliases = new LinkedHashSet<>();\n+    private String description;\n+    private MergePolicy mergePolicy;\n+    private Set<OptionScope> scope;\n+    private T defaultValue;\n+    private T defaultOptionalValue;\n+    private String valuePattern;\n+    private OptionValueConverter.Builder<T> converterBuilder = OptionValueConverter.build();\n+    private Validator.Builder<T, RuntimeException> validatorBuilder = Validator.build();\n+\n+    private T[] arrayDefaultValue;\n+    private String arrayValuePatternSeparator;\n+    private Function<String, String[]> arrayTokenizer;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionSpecBuilder.java","additions":475,"deletions":0,"binary":false,"changes":475,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import jdk.jpackage.internal.util.SetBuilder;\n+\n+\/**\n+ * Option scope facilitating mapping of {@link OptionSpec} instances based on\n+ * the given context.\n+ *\n+ * <p>\n+ * Use with option specs whose behavior is a function of a context. E.g.: if\n+ * option value validation depends on the current OS; if option description\n+ * varies depending on the current OS.\n+ *\n+ * @param <T> the type of option value\n+ * @param <T> the type of context\n+ *\/\n+interface OptionSpecMapperOptionScope<T, U> extends OptionScope {\n+\n+    OptionSpec<T> createOptionSpec(U context, boolean createArray);\n+\n+    Class<? extends U> contextType();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static <T, U> OptionSpec<T> mapOptionSpec(OptionSpec<T> optionSpec, U context) {\n+        return optionSpec.scope().stream()\n+                .filter(OptionSpecMapperOptionScope.class::isInstance)\n+                .map(OptionSpecMapperOptionScope.class::cast)\n+                .filter(scope -> {\n+                    return scope.contextType().isInstance(context);\n+                })\n+                .findFirst().map(scope -> {\n+                    return ((OptionSpecMapperOptionScope<T, U>)scope).createOptionSpec(\n+                            context, optionSpec.arrayValueConverter().isPresent());\n+                }).orElse(optionSpec);\n+    }\n+\n+    static <T, U> Consumer<OptionSpecBuilder<T>> createOptionSpecBuilderMutator(\n+            Class<? extends U> contextType,\n+            BiConsumer<OptionSpecBuilder<T>, U> mutator) {\n+        Objects.requireNonNull(mutator);\n+\n+        return builder -> {\n+            builder.scope(scope -> {\n+                return Details.<T, U>addOptionSpecBuilderMutator(contextType, scope, mutator, builder);\n+            });\n+        };\n+    }\n+\n+    static final class Details {\n+\n+        private Details() {\n+        }\n+\n+        private static <T, U> Set<OptionScope> addOptionSpecBuilderMutator(\n+                Class<? extends U> contextType,\n+                Set<OptionScope> scope,\n+                BiConsumer<OptionSpecBuilder<T>, U> optionSpecBuilderMutator,\n+                OptionSpecBuilder<T> optionSpecBuilder) {\n+\n+            Objects.requireNonNull(contextType);\n+            Objects.requireNonNull(scope);\n+            Objects.requireNonNull(optionSpecBuilderMutator);\n+            Objects.requireNonNull(optionSpecBuilder);\n+\n+            var contextOptionScope = scope.stream()\n+                    .filter(AccumulatingContextOptionScope.class::isInstance)\n+                    .map(AccumulatingContextOptionScope.class::cast)\n+                    .filter(s -> {\n+                        return s.contextType().equals(contextType);\n+                    })\n+                    .findFirst();\n+            contextOptionScope.ifPresent(v -> {\n+                @SuppressWarnings(\"unchecked\")\n+                var mutators = (AccumulatingContextOptionScope<T, U>)v;\n+                mutators.addMutator(optionSpecBuilderMutator);\n+                if (optionSpecBuilder != mutators.optionSpecBuilder) {\n+                    throw new IllegalArgumentException();\n+                }\n+            });\n+\n+            if (contextOptionScope.isEmpty()) {\n+                var mutators = new AccumulatingContextOptionScope<T, U>(optionSpecBuilder, contextType);\n+                mutators.addMutator(optionSpecBuilderMutator);\n+                scope = SetBuilder.build(OptionScope.class).add(scope).add(mutators).create();\n+            }\n+\n+            return scope;\n+        }\n+\n+        private static final class AccumulatingContextOptionScope<T, U> implements OptionSpecMapperOptionScope<T, U> {\n+\n+            AccumulatingContextOptionScope(OptionSpecBuilder<T> optionSpecBuilder, Class<? extends U> contextType) {\n+                this.optionSpecBuilder = Objects.requireNonNull(optionSpecBuilder);\n+                this.contextType = Objects.requireNonNull(contextType);\n+            }\n+\n+            @SuppressWarnings(\"unchecked\")\n+            @Override\n+            public OptionSpec<T> createOptionSpec(U context, boolean createArray) {\n+                var copy = optionSpecBuilder.copy();\n+                for (var mutator : optionSpecBuilderMutators) {\n+                    mutator.accept(copy, context);\n+                }\n+\n+                if (createArray) {\n+                    return (OptionSpec<T>)copy.createArrayOptionSpec();\n+                } else {\n+                    return copy.createOptionSpec();\n+                }\n+            }\n+\n+            @Override\n+            public Class<? extends U> contextType() {\n+                return contextType;\n+            }\n+\n+            void addMutator(BiConsumer<OptionSpecBuilder<T>, U> mutator) {\n+                optionSpecBuilderMutators.add(mutator);\n+            }\n+\n+            private final OptionSpecBuilder<T> optionSpecBuilder;\n+            private final Class<? extends U> contextType;\n+            private final List<BiConsumer<OptionSpecBuilder<T>, U>> optionSpecBuilderMutators = new ArrayList<>();\n+        }\n+\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionSpecMapperOptionScope.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+\/**\n+ * Typed getter of option values in {@link Options} objects.\n+ *\n+ * @param <T> option value type.\n+ *\/\n+public sealed interface OptionValue<T> extends WithOptionIdentifier {\n+\n+    Optional<Option> asOption();\n+\n+    default Option getOption() {\n+        return asOption().orElseThrow();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    default OptionSpec<T> getSpec() {\n+        return (OptionSpec<T>)getOption().spec();\n+    }\n+\n+    default String getName() {\n+        return getSpec().name().name();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    default Optional<T> findIn(Options cmdline) {\n+        return (Optional<T>)cmdline.find(id());\n+    }\n+\n+    default T getFrom(Options cmdline) {\n+        return findIn(cmdline).orElseThrow();\n+    }\n+\n+    default void ifPresentIn(Options cmdline, Consumer<T> consumer) {\n+        findIn(cmdline).ifPresent(consumer);\n+    }\n+\n+    default boolean containsIn(Options cmdline) {\n+        return cmdline.find(id()).isPresent();\n+    }\n+\n+    static <U> OptionValue<U> create() {\n+        return create(OptionIdentifier.createIdentifier());\n+    }\n+\n+    static <U> OptionValue<U> create(OptionIdentifier id) {\n+        return new Internal.Standard<>(id, Optional.empty(), Optional.empty());\n+    }\n+\n+    static <U> Builder<U> build() {\n+        return new Builder<>();\n+    }\n+\n+    static final class Builder<T> {\n+        OptionValue<T> create() {\n+            if (conv != null) {\n+                return conv.create(Optional.ofNullable(defaultValue));\n+            } else {\n+                return new Internal.Standard<>(\n+                        Optional.ofNullable(id).orElseGet(OptionIdentifier::createIdentifier),\n+                        Optional.ofNullable(spec),\n+                        Optional.ofNullable(defaultValue));\n+            }\n+        }\n+\n+        Builder<T> defaultValue(T v) {\n+            defaultValue = v;\n+            return this;\n+        }\n+\n+        Builder<T> spec(OptionSpec<?> v) {\n+            spec = v;\n+            conv = null;\n+            return this;\n+        }\n+\n+        Builder<T> id(OptionIdentifier v) {\n+            id = v;\n+            conv = null;\n+            return this;\n+        }\n+\n+        <U> Builder<T> from(OptionValue<U> base, Function<U, T> conv) {\n+            id(null).spec(null);\n+            this.conv = new Conv<>(base, conv);\n+            return this;\n+        }\n+\n+        <U> Builder<U> to(Function<T, U> conv) {\n+            return OptionValue.<U>build().from(create(), conv);\n+        }\n+\n+        private record Conv<U, V>(OptionValue<U> base, Function<U, V> conv) {\n+            Conv {\n+                Objects.requireNonNull(base);\n+                Objects.requireNonNull(conv);\n+            }\n+\n+            OptionValue<V> create(Optional<V> defaultValue) {\n+                return new Internal.Mapping<>(base, conv, defaultValue);\n+            }\n+        }\n+\n+        private Conv<?, T> conv;\n+        private T defaultValue;\n+        private OptionIdentifier id;\n+        private OptionSpec<?> spec;\n+    }\n+\n+\n+    static final class Internal {\n+\n+        private Internal() {\n+        }\n+\n+        private record Standard<T>(OptionIdentifier id, Optional<OptionSpec<?>> spec, Optional<T> defaultValue) implements OptionValue<T> {\n+\n+            Standard {\n+                Objects.requireNonNull(id);\n+                Objects.requireNonNull(spec);\n+                Objects.requireNonNull(defaultValue);\n+            }\n+\n+            @Override\n+            public Optional<Option> asOption() {\n+                return spec.map(v -> {\n+                    return new Option(id, v);\n+                });\n+            }\n+\n+            @Override\n+            public Optional<T> findIn(Options cmdline) {\n+                return OptionValue.super.findIn(cmdline).or(() -> defaultValue);\n+            }\n+        }\n+\n+        private record Mapping<T, U>(OptionValue<U> base, Function<U, T> conv, Optional<T> defaultValue) implements OptionValue<T> {\n+\n+            Mapping {\n+                Objects.requireNonNull(base);\n+                Objects.requireNonNull(conv);\n+                Objects.requireNonNull(defaultValue);\n+            }\n+\n+            @Override\n+            public OptionIdentifier id() {\n+                return base.id();\n+            }\n+\n+            @Override\n+            public Optional<Option> asOption() {\n+                return base.asOption();\n+            }\n+\n+            @Override\n+            public Optional<T> findIn(Options cmdline) {\n+                return base.findIn(cmdline).map(conv).or(() -> defaultValue);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionValue.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -0,0 +1,273 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import java.lang.reflect.Array;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import jdk.jpackage.internal.cli.Validator.ParsedValue;\n+import jdk.jpackage.internal.util.Result;\n+\n+\/**\n+ * Defines creating an option value of type {@link T} from a string.\n+ *\n+ * @param <T> option value type\n+ *\/\n+interface OptionValueConverter<T> {\n+\n+    \/**\n+     * Converts the given string value corresponding to the given option name into a\n+     * Java type.\n+     *\n+     * @param optionName  the option name\n+     * @param optionValue the string value of the option to convert\n+     * @return the conversion result\n+     *\/\n+    Result<T> convert(OptionName optionName, StringToken optionValue);\n+\n+    \/**\n+     * Gives the class of the type of values this converter converts to.\n+     *\n+     * @return the target class for conversion\n+     *\/\n+    Class<? extends T> valueType();\n+\n+    \/**\n+     * Thrown to indicate an error in the normal execution of the converter.\n+     *\/\n+    static final class ConverterException extends RuntimeException {\n+\n+        private ConverterException(Throwable cause) {\n+            super(cause);\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+    static <T> Builder<T> build() {\n+        return new Builder<>();\n+    }\n+\n+    static final class Builder<T> {\n+\n+        private Builder() {\n+        }\n+\n+        private Builder(Builder<T> other) {\n+            converter = other.converter;\n+            validator = other.validator;\n+            tokenizer = other.tokenizer;\n+            formatString = other.formatString;\n+            exceptionFactory = other.exceptionFactory;\n+        }\n+\n+        Builder<T> copy() {\n+            return new Builder<>(this);\n+        }\n+\n+        OptionValueConverter<T> create() {\n+            return new DefaultOptionValueConverter<>(\n+                    converter,\n+                    formatString().orElseGet(() -> {\n+                        if (exceptionFactory == null) {\n+                            return \"\";\n+                        } else {\n+                            return null;\n+                        }\n+                    }),\n+                    exceptionFactory().orElseGet(() -> {\n+                        if (formatString == null) {\n+                            return OptionValueExceptionFactory.unreachable();\n+                        } else {\n+                            return null;\n+                        }\n+                    }),\n+                    validator());\n+        }\n+\n+        OptionArrayValueConverter<T> createArray() {\n+            return new DefaultOptionArrayValueConverter<>(create(), tokenizer);\n+        }\n+\n+        Builder<T> converter(ValueConverter<T> v) {\n+            converter = v;\n+            return this;\n+        }\n+\n+        Builder<T> validator(Validator<T, ? extends RuntimeException> v) {\n+            validator = v;\n+            return this;\n+        }\n+\n+        Builder<T> tokenizer(Function<String, String[]> v) {\n+            tokenizer = v;\n+            return this;\n+        }\n+\n+        Builder<T> formatString(String v) {\n+            formatString = v;\n+            return this;\n+        }\n+\n+        Builder<T> exceptionFactory(OptionValueExceptionFactory<? extends RuntimeException> v) {\n+            exceptionFactory = v;\n+            return this;\n+        }\n+\n+        Builder<T> mutate(Consumer<Builder<T>> mutator) {\n+            mutator.accept(this);\n+            return this;\n+        }\n+\n+        Optional<ValueConverter<T>> converter() {\n+            return Optional.ofNullable(converter);\n+        }\n+\n+        Optional<Validator<T, ? extends RuntimeException>> validator() {\n+            return Optional.ofNullable(validator);\n+        }\n+\n+        Optional<Function<String, String[]>> tokenizer() {\n+            return Optional.ofNullable(tokenizer);\n+        }\n+\n+        Optional<String> formatString() {\n+            return Optional.ofNullable(formatString);\n+        }\n+\n+        Optional<OptionValueExceptionFactory<? extends RuntimeException>> exceptionFactory() {\n+            return Optional.ofNullable(exceptionFactory);\n+        }\n+\n+\n+        private record DefaultOptionValueConverter<T>(ValueConverter<T> converter, String formatString,\n+                OptionValueExceptionFactory<? extends RuntimeException> exceptionFactory,\n+                Optional<Validator<T, ? extends RuntimeException>> validator) implements OptionValueConverter<T> {\n+\n+            DefaultOptionValueConverter {\n+                Objects.requireNonNull(converter);\n+                Objects.requireNonNull(formatString);\n+                Objects.requireNonNull(exceptionFactory);\n+                Objects.requireNonNull(validator);\n+            }\n+\n+            @Override\n+            public Result<T> convert(OptionName optionName, StringToken optionValue) {\n+                Objects.requireNonNull(optionName);\n+\n+                final T convertedValue;\n+                try {\n+                    convertedValue = converter.convert(optionValue.value());\n+                } catch (Exception ex) {\n+                    return handleException(optionName, optionValue, ex);\n+                }\n+\n+                final List<? extends Exception> validationExceptions = validator.map(val -> {\n+                    try {\n+                        return val.validate(optionName, ParsedValue.create(convertedValue, optionValue));\n+                    } catch (Validator.ValidatorException ex) {\n+                        \/\/ All unexpected exceptions that the converter yields should be tunneled via ConverterException.\n+                        throw new ConverterException(ex.getCause());\n+                    }\n+                }).orElseGet(List::of);\n+\n+                if (validationExceptions.isEmpty()) {\n+                    return Result.ofValue(convertedValue);\n+                } else {\n+                    return Result.ofErrors(validationExceptions);\n+                }\n+            }\n+\n+            @Override\n+            public Class<? extends T> valueType() {\n+                return converter.valueType();\n+            }\n+\n+            private Result<T> handleException(OptionName optionName, StringToken optionValue, Exception ex) {\n+                if (ex instanceof IllegalArgumentException) {\n+                    return Result.ofError(exceptionFactory.create(optionName, optionValue, formatString, Optional.of(ex)));\n+                } else {\n+                    throw new ConverterException(ex);\n+                }\n+            }\n+        }\n+\n+\n+        private record DefaultOptionArrayValueConverter<T>(OptionValueConverter<T> elementConverter,\n+                Function<String, String[]> tokenizer) implements OptionArrayValueConverter<T> {\n+\n+            DefaultOptionArrayValueConverter {\n+                Objects.requireNonNull(elementConverter);\n+                Objects.requireNonNull(tokenizer);\n+            }\n+\n+            @SuppressWarnings(\"unchecked\")\n+            @Override\n+            public Result<T[]> convert(OptionName optionName, StringToken optionValue) {\n+\n+                final List<Exception> exceptions = new ArrayList<>();\n+                final List<T> convertedValues = new ArrayList<>();\n+\n+                final var tokens = tokenize(optionValue.value());\n+                for (var token : tokens) {\n+                    final var result = elementConverter.convert(optionName, StringToken.of(optionValue.value(), token));\n+                    exceptions.addAll(result.errors());\n+                    if (exceptions.isEmpty()) {\n+                        result.value().ifPresent(convertedValues::add);\n+                    }\n+                }\n+\n+                if (!exceptions.isEmpty()) {\n+                    return Result.ofErrors(exceptions);\n+                } else {\n+                    return Result.ofValue(convertedValues.toArray(length -> {\n+                        return (T[])Array.newInstance(elementConverter.valueType(), length);\n+                    }));\n+                }\n+            }\n+\n+            @SuppressWarnings(\"unchecked\")\n+            @Override\n+            public Class<? extends T[]> valueType() {\n+                return (Class<? extends T[]>)elementConverter.valueType().arrayType();\n+            }\n+\n+            @Override\n+            public String[] tokenize(String str) {\n+                return tokenizer.apply(Objects.requireNonNull(str));\n+            }\n+        }\n+\n+        private ValueConverter<T> converter;\n+        private Validator<T, ? extends RuntimeException> validator;\n+        private Function<String, String[]> tokenizer;\n+        private String formatString;\n+        private OptionValueExceptionFactory<? extends RuntimeException> exceptionFactory;\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionValueConverter.java","additions":273,"deletions":0,"binary":false,"changes":273,"status":"added"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Factory producing exception objects for option value processing failures.\n+ * <p>\n+ * Errors in converting option string values into objects or validating objects\n+ * created from option string values are typical option value processing\n+ * failures.\n+ *\n+ * @param T type of produced exceptions\n+ *\/\n+@FunctionalInterface\n+interface OptionValueExceptionFactory<T extends Exception> {\n+\n+    \/**\n+     * Create an exception object for the specified option name, value and optional\n+     * cause.\n+     *\n+     * @param optionName   the name of the option\n+     * @param optionValue  the value of the option\n+     * @param formatString the format string for formatting the exception message\n+     * @param cause        the cause if any, an empty {@ @link Optional} instance\n+     *                     otherwise\n+     * @return exception object\n+     *\/\n+    T create(OptionName optionName, StringToken optionValue, String formatString, Optional<Exception> cause);\n+\n+    static <T extends Exception> Builder<T> build() {\n+        return new Builder<>();\n+    }\n+\n+    static <T extends Exception> Builder<T> build(BiFunction<String, Throwable, T> ctor) {\n+        final Builder<T> builder = build();\n+        return builder.ctor(ctor);\n+    }\n+\n+    static <T extends Exception> OptionValueExceptionFactory<T> unreachable() {\n+        return (_, _, _, _) -> {\n+            throw new UnsupportedOperationException();\n+        };\n+    }\n+\n+\n+    @FunctionalInterface\n+    interface ArgumentsMapper {\n+        String[] apply(String formattedOptionName, StringToken optionValue);\n+\n+        static ArgumentsMapper appendArguments(ArgumentsMapper target, Object... args) {\n+            return (optionName, optionValue) -> {\n+                var arr = target.apply(optionName, optionValue);\n+                return Stream.concat(Stream.of(arr), Stream.of(args).map(Object::toString)).toArray(String[]::new);\n+            };\n+        }\n+    }\n+\n+\n+    enum StandardArgumentsMapper implements ArgumentsMapper {\n+        NAME_AND_VALUE((formattedOptionName, optionValue) -> {\n+            return new String[] { formattedOptionName, optionValue.tokenizedString() };\n+        }),\n+        VALUE_AND_NAME((formattedOptionName, optionValue) -> {\n+            return new String[] { optionValue.tokenizedString(), formattedOptionName };\n+        }),\n+        VALUE((formattedOptionName, optionValue) -> {\n+            return new String[] { optionValue.tokenizedString() };\n+        }),\n+        NONE((formattedOptionName, optionValue) -> {\n+            return new String[] {};\n+        });\n+\n+        StandardArgumentsMapper(ArgumentsMapper impl) {\n+            this.impl = Objects.requireNonNull(impl);\n+        }\n+\n+        @Override\n+        public String[] apply(String formattedOptionName, StringToken optionValue) {\n+            return impl.apply(formattedOptionName, optionValue);\n+        }\n+\n+        private final ArgumentsMapper impl;\n+    }\n+\n+\n+    static final class Builder<T extends Exception> {\n+\n+        OptionValueExceptionFactory<T> create() {\n+            return OptionValueExceptionFactory.create(ctor,\n+                    Optional.ofNullable(formatArgumentsTransformer).orElse(StandardArgumentsMapper.NAME_AND_VALUE),\n+                    Optional.ofNullable(messageFormatter).orElse(I18N::format),\n+                    printOptionPrefix);\n+        }\n+\n+        Builder<T> messageFormatter(BiFunction<String, Object[], String> v) {\n+            messageFormatter = v;\n+            return this;\n+        }\n+\n+        Builder<T> ctor(BiFunction<String, Throwable, T> v) {\n+            ctor = v;\n+            return this;\n+        }\n+\n+        Builder<T> formatArgumentsTransformer(ArgumentsMapper v) {\n+            formatArgumentsTransformer = v;\n+            return this;\n+        }\n+\n+        Builder<T> printOptionPrefix(boolean v) {\n+            printOptionPrefix = v;\n+            return this;\n+        }\n+\n+        private BiFunction<String, Throwable, T> ctor;\n+        private ArgumentsMapper formatArgumentsTransformer;\n+        private BiFunction<String, Object[], String> messageFormatter;\n+        private boolean printOptionPrefix = true;\n+    }\n+\n+\n+    private static <T extends Exception> OptionValueExceptionFactory<T> create(\n+            BiFunction<String, Throwable, T> ctor,\n+            ArgumentsMapper formatArgumentsTransformer,\n+            BiFunction<String, Object[], String> messageFormatter,\n+            boolean printOptionPrefix) {\n+        Objects.requireNonNull(ctor);\n+        Objects.requireNonNull(formatArgumentsTransformer);\n+        Objects.requireNonNull(messageFormatter);\n+\n+        return new OptionValueExceptionFactory<>() {\n+\n+            @Override\n+            public T create(OptionName optionName, StringToken optionValue, String formatString, Optional<Exception> cause) {\n+                return Objects.requireNonNull(ctor.apply(createMessage(optionName, optionValue, formatString), cause.orElse(null)));\n+            }\n+\n+            private String createMessage(OptionName optionName, StringToken optionValue, String formatString) {\n+                Objects.requireNonNull(optionName);\n+                Objects.requireNonNull(optionValue);\n+                Objects.requireNonNull(formatString);\n+\n+                final String formattedOptionName;\n+                if (printOptionPrefix) {\n+                    formattedOptionName = optionName.formatForCommandLine();\n+                } else {\n+                    formattedOptionName = optionName.name();\n+                }\n+\n+                final var args = Stream.of(formatArgumentsTransformer.apply(formattedOptionName, optionValue)).toArray();\n+                return Objects.requireNonNull(messageFormatter.apply(formatString, args));\n+            }\n+        };\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionValueExceptionFactory.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+import static java.util.stream.Collectors.toUnmodifiableMap;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+\n+\/**\n+ * R\/O collection of objects associated with option identifiers.\n+ * <p>\n+ * Use {@link OptionValue} for typed access of the stored objects.\n+ *\/\n+public sealed interface Options permits\n+        JOptSimpleOptionsBuilder.ExtendedOptions,\n+        DefaultOptions {\n+\n+    Optional<Object> find(OptionIdentifier id);\n+\n+    boolean contains(OptionName optionName);\n+\n+    Set<? extends OptionIdentifier> ids();\n+\n+    default Optional<Object> find(WithOptionIdentifier withId) {\n+        return find(withId.id());\n+    }\n+\n+    default boolean contains(OptionIdentifier id) {\n+        return find(id).isPresent();\n+    }\n+\n+    default boolean contains(WithOptionIdentifier withId) {\n+        return find(withId).isPresent();\n+    }\n+\n+    default Options copyWithDefaultValue(WithOptionIdentifier withId, Object value) {\n+        Objects.requireNonNull(withId);\n+        Objects.requireNonNull(value);\n+        if (contains(withId)) {\n+            return this;\n+        } else {\n+            return copyWithParent(of(Map.of(withId, value)));\n+        }\n+    }\n+\n+    default Options copyWithParent(Options other) {\n+        return concat(this, other);\n+    }\n+\n+    \/**\n+     * Creates a copy of this instance without the given option identifiers.\n+     * <p>\n+     * {@link #contains(OptionIdentifier)} called on the return instance with any of\n+     * the given identifiers will return {@code false}.\n+     * {@link #contains(OptionName)} called on the return instance with any option\n+     * name of option specifications associated with given identifiers will return\n+     * {@code false}.\n+     *\n+     * @param ids the identifiers to exclude\n+     * @return a copy of this instance without the given option identifiers\n+     *\/\n+    default Options copyWithout(OptionIdentifier... ids) {\n+        return copyWithout(List.of(ids));\n+    }\n+\n+    \/**\n+     * Creates a copy of this instance without the given option identifiers.\n+     * <p>\n+     * Same as {@link #copyWithout(OptionIdentifier...)} but takes an\n+     * {@code Iterable<OptionIdentifier>} instead of an {@code OptionIdentifier[]}.\n+     *\n+     * @param ids the identifiers to exclude\n+     * @return a copy of this instance without the given option identifiers\n+     *\/\n+    Options copyWithout(Iterable<? extends OptionIdentifier> ids);\n+\n+    \/**\n+     * Creates a copy of this instance with all but the given option identifiers\n+     * filtered out.\n+     * <p>\n+     * {@link #contains(OptionIdentifier)} called on the returned instance with any\n+     * identifiers not in the given array will return {@code false}.\n+     * {@link #contains(OptionName)} called on the returned instance with any name\n+     * returned by {@link OptionSpec#name()} method called on option specifications\n+     * of identifiers of type {@code Option} not from the given identifier array\n+     * will return {@code false}.\n+     *\n+     * @param ids the identifiers to keep in the copy\n+     * @return a copy of this instance with all but the given option identifiers\n+     *         filtered out\n+     *\/\n+    default Options copyWith(OptionIdentifier... ids) {\n+        return copyWith(List.of(ids));\n+    }\n+\n+    \/**\n+     * Creates a copy of this instance with all but the given option identifiers\n+     * filtered out.\n+     * <p>\n+     * Same as {@link #copyWith(OptionIdentifier...)} but takes an\n+     * {@code Iterable<OptionIdentifier>} instead of an {@code OptionIdentifier[]}.\n+     *\n+     * @param ids the identifiers to keep in the copy\n+     * @return a copy of this instance with all but the given option identifiers\n+     *         filtered out\n+     *\/\n+    default Options copyWith(Iterable<? extends OptionIdentifier> ids) {\n+        var excludes = new HashSet<>(ids());\n+        ids.forEach(excludes::remove);\n+        return copyWithout(excludes);\n+    }\n+\n+    \/**\n+     * Returns a map representation of this instance.\n+     * @return the map representation of this instance.\n+     *\/\n+    default Map<OptionIdentifier, Object> toMap() {\n+        return StreamSupport.stream(ids().spliterator(), false).collect(toUnmodifiableMap(x -> x, id -> {\n+            return find(id).orElseThrow();\n+        }));\n+    }\n+\n+    \/**\n+     * Creates {@code Options} instance from the map of objects with option\n+     * identifiers and associated option values.\n+     *\n+     * @param map the map of objects with option identifiers and associated option\n+     *            values\n+     * @return a new {@code Options} instance\n+     *\/\n+    public static Options of(Map<? extends WithOptionIdentifier, Object> map) {\n+        return new DefaultOptions(map);\n+    }\n+\n+    \/**\n+     * Creates {@code Options} instance from the map of option identifiers and\n+     * associated option values.\n+     * <p>\n+     * Similar to {@link #of(Map)} method, but {@link #contains(OptionName)} called\n+     * on the return instance will always return {@code false}.\n+     *\n+     * @param map the map of option identifiers and associated option values\n+     * @return a new {@code Options} instance\n+     *\/\n+    public static Options ofIDs(Map<OptionIdentifier, Object> map) {\n+        return new DefaultOptions(map.entrySet().stream().collect(toUnmodifiableMap(e -> {\n+            return new WithOptionIdentifierStub(e.getKey());\n+        }, Map.Entry::getValue)));\n+    }\n+\n+    public static Options concat(Options... options) {\n+        return Stream.of(options).map(Options::toDefaultOptions).reduce(DefaultOptions.EMPTY, DefaultOptions::add);\n+    }\n+\n+    private static DefaultOptions toDefaultOptions(Options v) {\n+        switch (Objects.requireNonNull(v)) {\n+            case DefaultOptions u -> {\n+                return u;\n+            }\n+            case JOptSimpleOptionsBuilder.ExtendedOptions<?> u -> {\n+                return u.toDefaultOptions();\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/Options.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -0,0 +1,430 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+import static jdk.jpackage.internal.cli.StandardOption.ADD_MODULES;\n+import static jdk.jpackage.internal.cli.StandardOption.INPUT;\n+import static jdk.jpackage.internal.cli.StandardOption.JLINK_OPTIONS;\n+import static jdk.jpackage.internal.cli.StandardOption.MAC_APP_IMAGE_SIGN_IDENTITY;\n+import static jdk.jpackage.internal.cli.StandardOption.MAC_APP_STORE;\n+import static jdk.jpackage.internal.cli.StandardOption.MAC_INSTALLER_SIGN_IDENTITY;\n+import static jdk.jpackage.internal.cli.StandardOption.MAC_SIGN;\n+import static jdk.jpackage.internal.cli.StandardOption.MAC_SIGNING_KEY_NAME;\n+import static jdk.jpackage.internal.cli.StandardOption.MAIN_JAR;\n+import static jdk.jpackage.internal.cli.StandardOption.MODULE;\n+import static jdk.jpackage.internal.cli.StandardOption.MODULE_PATH;\n+import static jdk.jpackage.internal.cli.StandardOption.PREDEFINED_APP_IMAGE;\n+import static jdk.jpackage.internal.cli.StandardOption.PREDEFINED_RUNTIME_IMAGE;\n+import static jdk.jpackage.internal.cli.StandardOption.TYPE;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.model.BundlingEnvironment;\n+import jdk.jpackage.internal.model.BundlingOperationDescriptor;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.JPackageException;\n+import jdk.jpackage.internal.model.PackageType;\n+\n+\/**\n+ * Analyzes jpackage command line structure.\n+ *\/\n+final class OptionsAnalyzer {\n+\n+    OptionsAnalyzer(Options cmdline, BundlingEnvironment bundlingEnv) {\n+        this(cmdline, getBundlingOperation(cmdline, OperatingSystem.current(), bundlingEnv), false);\n+    }\n+\n+    OptionsAnalyzer(Options cmdline, StandardBundlingOperation bundlingOperation) {\n+        this(cmdline, bundlingOperation, true);\n+    }\n+\n+    private OptionsAnalyzer(Options cmdline, StandardBundlingOperation bundlingOperation, boolean typedOptions) {\n+        this.cmdline = Objects.requireNonNull(cmdline);\n+        this.bundlingOperation = Objects.requireNonNull(bundlingOperation);\n+        this.typedOptions = typedOptions;\n+        hasAppImage = PREDEFINED_APP_IMAGE.containsIn(cmdline);\n+        isRuntimeInstaller = isRuntimeInstaller(cmdline, bundlingOperation);\n+    }\n+\n+    BundlingOperationDescriptor bundlingOperation() {\n+        return bundlingOperation.descriptor();\n+    }\n+\n+    List<ExceptionWithOrigin> findErrors() {\n+        if (hasAppImage && PREDEFINED_RUNTIME_IMAGE.containsIn(cmdline)) {\n+            \/\/ Short circuit this erroneous case as bundling operation is ambiguous.\n+            return List.of(new MutualExclusiveOptions(asOptionList(\n+                    PREDEFINED_RUNTIME_IMAGE, PREDEFINED_APP_IMAGE)).validate(cmdline).orElseThrow());\n+        }\n+\n+        final List<ExceptionWithOrigin> errors = new ArrayList<>();\n+\n+        StandardOption.options().stream()\n+                .filter(cmdline::contains)\n+                .map(Option::spec)\n+                .filter(matchInScope(bundlingOperation).and(matchInScope(bundlingOperationModifiers())).negate())\n+                .map(optionSpec -> {\n+                    var err = onOutOfScopeOption(optionSpec);\n+                    return errorWithOrigin(err, optionSpec);\n+                }).forEach(errors::add);\n+\n+        MUTUAL_EXCLUSIVE_OPTIONS.stream().map(v -> {\n+            return v.validate(cmdline);\n+        }).filter(Optional::isPresent).map(Optional::orElseThrow).forEach(errors::add);\n+\n+        if (isBundlingAppImage() && Stream.of(MODULE, MAIN_JAR).noneMatch(ov -> {\n+            return ov.containsIn(cmdline);\n+        })) {\n+            errors.add(errorWithOrigin(error(\"ERR_NoEntryPoint\")));\n+        }\n+\n+        if (bundlingOperation == StandardBundlingOperation.SIGN_MAC_APP_IMAGE && !MAC_SIGN.containsIn(cmdline)) {\n+            errors.add(errorWithOrigin(error(\"error.app-image.mac-sign.required\")));\n+        }\n+\n+        if (isBuildingAppImage()) {\n+            if (MAIN_JAR.containsIn(cmdline) && !INPUT.containsIn(cmdline)) {\n+                errors.add(errorWithOrigin(error(\"error.no-input-parameter\"), MAIN_JAR.getSpec()));\n+            }\n+\n+            if (MODULE.containsIn(cmdline) && Stream.of(PREDEFINED_RUNTIME_IMAGE, MODULE_PATH).noneMatch(ov -> {\n+                return ov.containsIn(cmdline);\n+            })) {\n+                errors.add(errorWithOrigin(error(\"ERR_MissingArgument2\", PREDEFINED_RUNTIME_IMAGE, MODULE_PATH), MODULE.getSpec()));\n+            }\n+        }\n+\n+        if (typedOptions) {\n+            errors.addAll(findErrorsInTypedOptions());\n+        }\n+\n+        return errors;\n+    }\n+\n+\n+    record ExceptionWithOrigin(Exception error, List<? extends OptionSpec<?>> origin) {\n+        ExceptionWithOrigin {\n+            Objects.requireNonNull(error);\n+            Objects.requireNonNull(origin);\n+        }\n+    }\n+\n+\n+    static Stream<ExceptionWithOrigin> orderErrors(List<OptionName> optionNames, Collection<ExceptionWithOrigin> unorderedErrors) {\n+        Objects.requireNonNull(optionNames);\n+        Objects.requireNonNull(unorderedErrors);\n+        return unorderedErrors.stream().sorted(Comparator.<ExceptionWithOrigin, Integer>comparing(err -> {\n+            \/\/ Return minimal index of an option name from the origin of this error in the `optionNames` list.\n+            return err.origin().stream()\n+                    .map(OptionSpec::names)\n+                    .flatMap(Collection::stream)\n+                    .mapToInt(optionNames::indexOf)\n+                    .filter(idx -> {\n+                        return idx >= 0;\n+                    }).min()\n+                    \/\/ Errors without origin go first.\n+                    .orElse(-1);\n+        }));\n+    }\n+\n+    private List<ExceptionWithOrigin> findErrorsInTypedOptions() {\n+        final List<ExceptionWithOrigin> errors = new ArrayList<>();\n+\n+        if (MAC_APP_STORE.containsIn(cmdline)) {\n+            JLINK_OPTIONS.ifPresentIn(cmdline, jlinkOptions -> {\n+                if (!jlinkOptions.contains(\"--strip-native-commands\")) {\n+                    errors.add(errorWithOrigin(\n+                            error(\"ERR_MissingJLinkOptMacAppStore\", \"--strip-native-commands\"),\n+                            Stream.of(MAC_APP_STORE, JLINK_OPTIONS).map(OptionValue::getSpec).toList()));\n+                }\n+            });\n+        }\n+\n+        return errors;\n+    }\n+\n+    private Set<BundlingOperationModifier> bundlingOperationModifiers() {\n+        final Set<BundlingOperationModifier> modifiers = new HashSet<>();\n+        if (isBundlingNativePackage()) {\n+            if (hasAppImage) {\n+                modifiers.add(BundlingOperationModifier.BUNDLE_PREDEFINED_APP_IMAGE);\n+            }\n+            if (isRuntimeInstaller) {\n+                modifiers.add(BundlingOperationModifier.BUNDLE_RUNTIME);\n+            }\n+        }\n+        return modifiers;\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the output of the bundling operation is a new app\n+     * image.\n+     *\n+     * @return {@code true} if the output of the bundling operation is a new app\n+     *         image\n+     *\/\n+    private boolean isBundlingAppImage() {\n+        return StandardBundlingOperation.CREATE_APP_IMAGE.contains(bundlingOperation);\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the output of the bundling operation is a new native\n+     * package.\n+     *\n+     * @return {@code true} if the output of the bundling operation is a new native\n+     *         package\n+     *\/\n+    private boolean isBundlingNativePackage() {\n+        return StandardBundlingOperation.CREATE_NATIVE.contains(bundlingOperation);\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the output of the bundling operation is either a new\n+     * app image or a new native package.\n+     *\n+     * @return {@code true} if the output of the bundling operation is either a new\n+     *         app image or a new native package\n+     *\/\n+    private boolean isBundling() {\n+        return StandardBundlingOperation.CREATE_BUNDLE.contains(bundlingOperation);\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the bundling operation will create an app image as\n+     * an intermediate or final step.\n+     *\n+     * @return {@code true} if the bundling operation will create an app image as\n+     *         an intermediate or final step\n+     *\/\n+    private boolean isBuildingAppImage() {\n+        return bundlingOperationModifiers().isEmpty() && isBundling();\n+    }\n+\n+    private RuntimeException onOutOfScopeOption(OptionSpec<?> optionSpec) {\n+        Objects.requireNonNull(optionSpec);\n+\n+        if (optionSpec.scope().stream()\n+                .filter(StandardBundlingOperation.class::isInstance)\n+                .map(StandardBundlingOperation.class::cast)\n+                .map(StandardBundlingOperation::os).noneMatch(bundlingOperation.os()::equals)) {\n+            \/\/ The option is for different OS.\n+            return error(\"ERR_UnsupportedOption\", mapFormatArguments(optionSpec));\n+        } else if (StandardBundlingOperation.SIGN_MAC_APP_IMAGE.equals(bundlingOperation)) {\n+            \/\/ The option is not applicable when signing a predefined app image.\n+            return error(\"ERR_InvalidOptionWithAppImageSigning\", mapFormatArguments(optionSpec));\n+        } else if (StandardBundlingOperation.CREATE_NATIVE.contains(bundlingOperation) && isRuntimeInstaller) {\n+            \/\/ The option is not applicable when packaging of a runtime in a native bundle.\n+            return error(\"ERR_NoInstallerEntryPoint\", mapFormatArguments(optionSpec));\n+        } else {\n+            return error(\"ERR_InvalidTypeOption\", mapFormatArguments(\n+                    optionSpec, bundlingOperation.packageTypeValue()));\n+        }\n+    }\n+\n+    private Object[] mapFormatArguments(Object... args) {\n+        return MessageFormatUtils.mapFormatArguments(cmdline, args);\n+    }\n+\n+    private static StandardBundlingOperation getBundlingOperation(Options cmdline,\n+            OperatingSystem os, BundlingEnvironment env) {\n+        Objects.requireNonNull(cmdline);\n+        Objects.requireNonNull(os);\n+        Objects.requireNonNull(env);\n+\n+        final var typeOption = TYPE.getOption();\n+\n+        return cmdline.find(typeOption).map(obj -> {\n+            if (obj instanceof PackageType packageType) {\n+                return packageType;\n+            } else {\n+                return typeOption.spec()\n+                        .converter().orElseThrow()\n+                        .convert(typeOption.spec().name(), StringToken.of(((String[])obj)[0]))\n+                        .orElseThrow();\n+            }\n+        }).map(packageType -> {\n+            \/\/ Find standard bundling operations producing the given package type.\n+            var bundlingOperations = Stream.of(StandardBundlingOperation.values()).filter(op -> {\n+                return op.packageType().equals(packageType);\n+            }).toList();\n+\n+            if (bundlingOperations.isEmpty()) {\n+                \/\/ jpackage internal error: none of the standard bundling operations produce\n+                \/\/ bundles of the `packageType`.\n+                throw new AssertionError(String.format(\n+                        \"None of the standard bundling operations produce bundles of type [%s]\",\n+                        packageType));\n+            } else if (bundlingOperations.size() == 1) {\n+                return bundlingOperations.getFirst();\n+            } else {\n+                \/\/ Multiple standard bundling operations produce the `packageType` package type.\n+                \/\/ Filter those that belong to the current OS\n+                bundlingOperations = bundlingOperations.stream().filter(op -> {\n+                    return op.os().equals(OperatingSystem.current());\n+                }).toList();\n+\n+                if (bundlingOperations.isEmpty()) {\n+                    \/\/ jpackage internal error: none of the standard bundling operations produce\n+                    \/\/ bundles of the `packageType` on the current OS.\n+                    throw new AssertionError(String.format(\n+                            \"None of the standard bundling operations produce bundles of type [%s] on %s\",\n+                            packageType, OperatingSystem.current()));\n+                } else if (bundlingOperations.size() == 1) {\n+                    return bundlingOperations.getFirst();\n+                } else if (StandardBundlingOperation.MACOS_APP_IMAGE.containsAll(bundlingOperations)) {\n+                    if (PREDEFINED_APP_IMAGE.containsIn(cmdline)) {\n+                        return StandardBundlingOperation.SIGN_MAC_APP_IMAGE;\n+                    } else {\n+                        return StandardBundlingOperation.CREATE_MAC_APP_IMAGE;\n+                    }\n+                } else {\n+                    \/\/ Pick the first one.\n+                    return bundlingOperations.getFirst();\n+                }\n+            }\n+        }).orElseGet(() -> {\n+            \/\/ No package type specified, use the default bundling operation in the given environment.\n+            return env.defaultOperation().map(descriptor -> {\n+                return Stream.of(StandardBundlingOperation.values()).filter(op -> {\n+                    return descriptor.equals(op.descriptor());\n+                }).findFirst().orElseThrow(() -> {\n+                    \/\/ jpackage internal error: none of the standard bundling operations match the\n+                    \/\/ descriptor of the default bundling operation in the given environment.\n+                    throw new AssertionError(String.format(\n+                            \"None of the standard bundling operations match bundling operation descriptor [%s]\",\n+                            descriptor));\n+                });\n+            }).orElseThrow(() -> {\n+                throw new ConfigException(\n+                        I18N.format(\"error.undefined-default-bundling-operation\"),\n+                        I18N.format(\"error.undefined-default-bundling-operation.advice\", TYPE.getSpec().name().formatForCommandLine()));\n+            });\n+        });\n+    }\n+\n+    private static boolean isRuntimeInstaller(Options cmdline, OptionScope bundlingOperation) {\n+        return StandardBundlingOperation.CREATE_BUNDLE.contains(bundlingOperation)\n+                && PREDEFINED_RUNTIME_IMAGE.containsIn(cmdline)\n+                && !PREDEFINED_APP_IMAGE.containsIn(cmdline)\n+                && !MAIN_JAR.containsIn(cmdline)\n+                && !MODULE.containsIn(cmdline);\n+    }\n+\n+    private static Predicate<OptionSpec<?>> matchInScope(Collection<? extends OptionScope> scope) {\n+        Objects.requireNonNull(scope);\n+        return optionSpec -> {\n+            return optionSpec.scope().containsAll(scope);\n+        };\n+    }\n+\n+    private static Predicate<OptionSpec<?>> matchInScope(OptionScope... scope) {\n+        return matchInScope(List.of(scope));\n+    }\n+\n+    private static List<Option> asOptionList(OptionValue<?>... options) {\n+        return Stream.of(options).map(OptionValue::getOption).toList();\n+    }\n+\n+    private static RuntimeException error(String formatId, Object ... args) {\n+        return new JPackageException(MessageFormatUtils.createMessage(formatId, args));\n+    }\n+\n+    private static ExceptionWithOrigin errorWithOrigin(Exception error, OptionSpec<?>... origin) {\n+        return errorWithOrigin(error, List.of(origin));\n+    }\n+\n+    private static ExceptionWithOrigin errorWithOrigin(Exception error, List<? extends OptionSpec<?>> origin) {\n+        return new ExceptionWithOrigin(error, origin);\n+    }\n+\n+\n+    private record MutualExclusiveOptions(List<Option> options, Function<Object[], RuntimeException> createException) {\n+        MutualExclusiveOptions {\n+            options.forEach(Objects::requireNonNull);\n+            if (options.size() < 2) {\n+                throw new IllegalArgumentException();\n+            }\n+            Objects.requireNonNull(createException);\n+        }\n+\n+        Optional<ExceptionWithOrigin> validate(Options cmdline) {\n+            final var detectedOptions = options.stream().filter(cmdline::contains).toList();\n+            if (detectedOptions.size() > 1) {\n+                final var errMesageformatArgs = detectedOptions.stream().map(Option::spec).map(optionSpec -> {\n+                    return MessageFormatUtils.mapFormatArguments(cmdline, optionSpec)[0];\n+                }).toArray();\n+                return Optional.of(errorWithOrigin(\n+                        createException.apply(errMesageformatArgs),\n+                        detectedOptions.stream().map(Option::spec).toList()));\n+            } else {\n+                return Optional.empty();\n+            }\n+        }\n+\n+        MutualExclusiveOptions(List<Option> options) {\n+            this(options, args -> {\n+                return error(\"ERR_MutuallyExclusiveOptions\", args);\n+            });\n+        }\n+    }\n+\n+\n+    private final Options cmdline;\n+    private final StandardBundlingOperation bundlingOperation;\n+    private final boolean typedOptions;\n+    private final boolean hasAppImage;\n+    private final boolean isRuntimeInstaller;\n+\n+    private static final List<MutualExclusiveOptions> MUTUAL_EXCLUSIVE_OPTIONS;\n+\n+    static {\n+        final List<MutualExclusiveOptions> config = new ArrayList<>();\n+\n+        Stream.of(\n+                asOptionList(PREDEFINED_RUNTIME_IMAGE, PREDEFINED_APP_IMAGE),\n+                asOptionList(PREDEFINED_RUNTIME_IMAGE, ADD_MODULES),\n+                asOptionList(PREDEFINED_RUNTIME_IMAGE, JLINK_OPTIONS),\n+                asOptionList(MAC_SIGNING_KEY_NAME, MAC_APP_IMAGE_SIGN_IDENTITY),\n+                asOptionList(MAC_SIGNING_KEY_NAME, MAC_INSTALLER_SIGN_IDENTITY)\n+        ).map(MutualExclusiveOptions::new).forEach(config::add);\n+\n+        config.add(new MutualExclusiveOptions(asOptionList(MODULE, MAIN_JAR), _ -> {\n+            return error(\"ERR_BothMainJarAndModule\");\n+        }));\n+\n+        MUTUAL_EXCLUSIVE_OPTIONS = List.copyOf(config);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionsAnalyzer.java","additions":430,"deletions":0,"binary":false,"changes":430,"status":"added"},{"patch":"@@ -0,0 +1,428 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+import static java.util.stream.Collectors.counting;\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.toMap;\n+import static jdk.jpackage.internal.cli.Option.fromOptionSpecPredicate;\n+import static jdk.jpackage.internal.cli.StandardOption.ADDITIONAL_LAUNCHERS;\n+import static jdk.jpackage.internal.cli.StandardOption.platformOption;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.function.Function;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.cli.JOptSimpleOptionsBuilder.ConvertedOptionsBuilder;\n+import jdk.jpackage.internal.cli.JOptSimpleOptionsBuilder.OptionsBuilder;\n+import jdk.jpackage.internal.model.BundlingEnvironment;\n+import jdk.jpackage.internal.model.BundlingOperationDescriptor;\n+import jdk.jpackage.internal.model.JPackageException;\n+import jdk.jpackage.internal.util.Result;\n+\n+\/**\n+ * Processes jpackage command line.\n+ *\/\n+final class OptionsProcessor {\n+\n+    OptionsProcessor(OptionsBuilder optionsBuilder, CliBundlingEnvironment bundlingEnv) {\n+        this.optionsBuilder = Objects.requireNonNull(optionsBuilder);\n+        this.bundlingEnv = Objects.requireNonNull(bundlingEnv);\n+    }\n+\n+    record ValidatedOptions(Options options, BundlingOperationDescriptor bundlingOperation) {\n+        ValidatedOptions {\n+            Objects.requireNonNull(options);\n+            Objects.requireNonNull(bundlingOperation);\n+        }\n+\n+        String bundleTypeName() {\n+            return bundlingOperation.bundleType();\n+        }\n+    }\n+\n+    Result<ValidatedOptions> validate() {\n+        final Collection<Exception> allErrors = new ArrayList<>();\n+\n+        \/\/ Check for non-option arguments.\n+        validateNonOptionArguments(optionsBuilder).ifPresent(allErrors::add);\n+\n+        \/\/ Parse the command line. The result is Options container of strings.\n+        final var untypedOptions = optionsBuilder.create();\n+\n+        \/\/ Create command line structure analyzer.\n+        final var analyzerResult = Result.create(() -> new OptionsAnalyzer(untypedOptions, bundlingEnv));\n+        if (analyzerResult.hasErrors()) {\n+            \/\/ Failed to derive the bundling operation from the command line.\n+            allErrors.addAll(analyzerResult.mapErrors().errors());\n+            return Result.ofErrors(allErrors);\n+        }\n+\n+        final var analyzer = analyzerResult.orElseThrow();\n+\n+        \/\/ Validate the bundling operation.\n+        final var bundlingOperationResult = validateBundlingOperation(analyzer.bundlingOperation()).map(op -> {\n+            return Map.entry(StandardOption.BUNDLING_OPERATION_DESCRIPTOR, op);\n+        });\n+\n+        bundlingOperationResult.peekErrors(allErrors::addAll);\n+\n+        \/\/ Validate command line structure.\n+        final var structureErrors = analyzer.findErrors();\n+        if (!structureErrors.isEmpty()) {\n+            OptionsAnalyzer.orderErrors(\n+                    optionsBuilder.detectedOptions(),\n+                    structureErrors\n+            ).map(err -> err.error()).forEach(allErrors::add);\n+            return Result.ofErrors(allErrors);\n+        }\n+\n+        final Result<ValidatedOptions> validatedOptionsResult = optionsBuilder\n+                \/\/ Command line structure is valid.\n+                \/\/ Run value converters that will convert strings into objects (e.g.: String -> Path)\n+                .convertedOptions().map(ConvertedOptionsBuilder::create).map(convertedOptions -> {\n+                    return new ValidatedOptions(convertedOptions, analyzer.bundlingOperation());\n+                });\n+\n+        validatedOptionsResult.peekErrors(allErrors::addAll);\n+\n+        if (validatedOptionsResult.hasErrors()) {\n+            \/\/ There are errors in the command line.\n+            \/\/ Inspect additional launcher names to see if there are duplicates.\n+            final var addLaunchers = untypedOptions.find(StandardOption.ADD_LAUNCHER_INTERNAL.id())\n+                    .map(String[].class::cast)\n+                    .map(Stream::of)\n+                    .orElseGet(Stream::of).map(addLauncherStr -> {\n+                        return addLauncherStr.split(\"=\", 2)[0];\n+                    }).map(addLauncherName -> {\n+                        return Options.of(Map.of(StandardOption.NAME, addLauncherName));\n+                    }).toArray(Options[]::new);\n+\n+            Map<WithOptionIdentifier, Object> options = new HashMap<>();\n+            options.put(ADD_LAUNCHER_INTERNAL, addLaunchers);\n+            untypedOptions.find(StandardOption.NAME.id()).ifPresent(strArray -> {\n+                options.put(StandardOption.NAME, ((String[])strArray)[0]);\n+            });\n+\n+            var result = validateAdditionalLaunchers(Options.of(options));\n+            result.peekErrors(allErrors::addAll);\n+        }\n+\n+        final var validatedAddLaunchersResult = validatedOptionsResult.value()\n+                .map(ValidatedOptions::options)\n+                .map(this::validateAdditionalLaunchers).map(result -> {\n+                    return result.map(addLaunchers -> {\n+                        return Map.entry(ADDITIONAL_LAUNCHERS, addLaunchers);\n+                    });\n+                }).orElseGet(() -> {\n+                    return Result.ofValue(Map.entry(ADDITIONAL_LAUNCHERS, List.of()));\n+                });\n+\n+        validatedAddLaunchersResult.peekErrors(allErrors::addAll);\n+\n+        final var validatedFaResult = Result.ofValue(Map.entry(\n+                StandardOption.FILE_ASSOCIATIONS,\n+                validatedOptionsResult.value()\n+                        .map(ValidatedOptions::options)\n+                        .map(FILE_ASSOCIATIONS_INTERNAL::getFrom)\n+                        .orElseGet(List::of)\n+        ));\n+\n+        validatedOptionsResult.value().ifPresent(validatedOptions -> {\n+            \/\/ Second pass: analyze command line options with values converted from strings.\n+            var errors = new OptionsAnalyzer(validatedOptions.options(),\n+                    StandardBundlingOperation.valueOf(validatedOptions.bundlingOperation()).orElseThrow(() -> {\n+                        \/\/ The bundle operation descriptor should correspond to one of the standard bundling operations.\n+                        throw new AssertionError();\n+                    })).findErrors();\n+            OptionsAnalyzer.orderErrors(\n+                    optionsBuilder.detectedOptions(),\n+                    errors\n+            ).map(err -> err.error()).forEach(allErrors::add);\n+        });\n+\n+        if (!allErrors.isEmpty()) {\n+            return Result.ofErrors(allErrors);\n+        } else {\n+            \/\/ No errors.\n+            \/\/ Add synthesized option values and return the result.\n+            final Map<WithOptionIdentifier, Object> extra = Stream.of(\n+                    bundlingOperationResult,\n+                    validatedAddLaunchersResult,\n+                    validatedFaResult\n+            ).map(Result::orElseThrow).collect(toMap(Map.Entry::getKey, Map.Entry::getValue));\n+\n+            return validatedOptionsResult.map(validatedOptions -> {\n+                return new ValidatedOptions(\n+                        Options.concat(\n+                                Options.of(extra),\n+                                validatedOptions.options().copyWithout(ADD_LAUNCHER_INTERNAL.id(), FILE_ASSOCIATIONS_INTERNAL.id())),\n+                        validatedOptions.bundlingOperation());\n+            });\n+        }\n+    }\n+\n+    private static Optional<? extends Exception> validateNonOptionArguments(OptionsBuilder optionsBuilder) {\n+        final var nonOptionArguments = optionsBuilder.nonOptionArguments();\n+        if (nonOptionArguments.isEmpty()) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(new JPackageException(I18N.format(\"error.non-option-arguments\", nonOptionArguments.size())));\n+        }\n+    }\n+\n+    private Result<BundlingOperationDescriptor> validateBundlingOperation(BundlingOperationDescriptor bundlingOperation) {\n+        Objects.requireNonNull(bundlingOperation);\n+        try {\n+            var errors = bundlingEnv.configurationErrors(bundlingOperation);\n+            if (errors.isEmpty()) {\n+                return Result.ofValue(bundlingOperation);\n+            } else {\n+                return Result.ofErrors(errors);\n+            }\n+        } catch (NoSuchElementException ex) {\n+            \/\/ Bundling environment doesn't recognize the descriptor of a bundling operation.\n+            return Result.ofError(new JPackageException(I18N.format(\"ERR_InvalidInstallerType\", bundlingOperation.bundleType())));\n+        }\n+    }\n+\n+    Collection<? extends Exception> runBundling(ValidatedOptions validatedOptions) {\n+        try {\n+            bundlingEnv.createBundle(validatedOptions.bundlingOperation(), validatedOptions.options());\n+            return List.of();\n+        } catch (Exception ex) {\n+            return List.of(ex);\n+        }\n+    }\n+\n+    \/**\n+     * Loads property file and processes properties as a command line.\n+     * <p>\n+     * Unrecognized options will be silently ignored.\n+     *\n+     * @param file             the source property file\n+     * @param options          the recognized options\n+     * @param optionSpecMapper optional option spec mapper\n+     * @return {@link Options} instance containing validated property values or the list\n+     *         of errors occured during option values processing\n+     * @throws UncheckedIOException if an I\/O error occurs\n+     *\/\n+    static Result<Options> processPropertyFile(Path file, Collection<Option> options,\n+            Optional<UnaryOperator<OptionSpec<?>>> optionSpecMapper) {\n+        final var props = new Properties();\n+        try (var in = Files.newBufferedReader(file)) {\n+            props.load(in);\n+        } catch (IOException ex) {\n+            return Result.ofError(ex);\n+        }\n+\n+        \/\/ Convert the property file into command line arguments.\n+        \/\/ Silently ignore unknown properties.\n+        final var args = options.stream().map(option -> {\n+            return option.spec().names().stream().map(optionName -> {\n+                return Optional.ofNullable(props.getProperty(optionName.name())).map(stringOptionValue -> {\n+                    return Stream.of(optionName.formatForCommandLine(), stringOptionValue);\n+                }).orElse(null);\n+            }).flatMap(x -> x);\n+        }).flatMap(x -> x).filter(Objects::nonNull).toArray(String[]::new);\n+\n+        \/\/ Feed the contents of the property file as a command line arguments to the command line parser.\n+        final var builder = new JOptSimpleOptionsBuilder().options(options);\n+\n+        optionSpecMapper.ifPresent(builder::optionSpecMapper);\n+\n+        final var result = builder.create().apply(args)\n+                .flatMap(OptionsBuilder::convertedOptions)\n+                .map(ConvertedOptionsBuilder::create);\n+\n+        return result.map(cmdline -> {\n+            return cmdline.copyWithDefaultValue(StandardOption.SOURCE_PROPERY_FILE, file);\n+        });\n+    }\n+\n+    static UnaryOperator<OptionSpec<?>> optionSpecMapper(OperatingSystem os, BundlingEnvironment bundlingEnv) {\n+        Objects.requireNonNull(os);\n+        Objects.requireNonNull(bundlingEnv);\n+\n+        var context = new StandardOptionContext(os);\n+\n+        return optionSpec -> {\n+            if (optionSpec.name().equals(StandardOption.ADD_LAUNCHER_INTERNAL.getSpec().name())) {\n+                final var options = filterForPlatform(os, StandardOption.launcherOptions());\n+                return optionSpec.copyWithConverter(new OptionsConverter<>(addLauncher -> {\n+                    var localContext = context.forFile(addLauncher.propertyFile());\n+                    var optionValues = processPropertyFile(addLauncher.propertyFile(), options, Optional.of(localContext::mapOptionSpec));\n+                    return optionValues.map(o -> {\n+                        return o.copyWithParent(Options.of(Map.of(StandardOption.NAME, addLauncher.name())));\n+                    });\n+                }, StandardOption.ADD_LAUNCHER_INTERNAL.getSpec()));\n+            } else if (optionSpec.name().equals(StandardOption.FILE_ASSOCIATIONS_INTERNAL.getSpec().name())) {\n+                final var options = filterForPlatform(os, StandardFaOption.options());\n+                return optionSpec.copyWithConverter(new OptionsConverter<>(fa -> {\n+                    var localContext = context.forFile(fa);\n+                    return processPropertyFile(fa, options, Optional.of(localContext::mapOptionSpec));\n+                }, StandardOption.FILE_ASSOCIATIONS_INTERNAL.getSpec()));\n+            } else {\n+                return context.mapOptionSpec(optionSpec);\n+            }\n+        };\n+    }\n+\n+    private Result<List<Options>> validateAdditionalLaunchers(Options cmdline) {\n+\n+        final var addLaunchers = ADD_LAUNCHER_INTERNAL.getFrom(cmdline);\n+\n+        final List<Exception> errors = new ArrayList<>();\n+\n+        \/\/ Count launcher names.\n+        final var names = Stream.concat(\n+                StandardOption.NAME.findIn(cmdline).stream(),\n+                addLaunchers.stream().map(StandardOption.NAME::getFrom)\n+        ).collect(groupingBy(x -> x, counting()));\n+\n+        \/\/ Sort duplicated names alphabetically\n+        names.entrySet().stream().filter(e -> {\n+            \/\/ Filter duplicated names.\n+            return e.getValue() > 1;\n+        }).map(Map.Entry::getKey).sorted().map(name -> {\n+            return new JPackageException(I18N.format(\"error.launcher-duplicate-name\", name));\n+        }).forEach(errors::add);\n+\n+        if (!errors.isEmpty()) {\n+            return Result.ofErrors(errors);\n+        } else {\n+            return Result.ofValue(addLaunchers.stream().map(addLauncherOptionValues -> {\n+\n+                \/\/\n+                \/\/ For additional launcher:\n+                \/\/  - Override name.\n+                \/\/  - Ignore icon configured for the app\/main launcher.\n+                \/\/  - Ignore shortcuts configured for the app\/main launcher.\n+                \/\/  - If the additional launcher is modular, delete non-modular options of the main launcher.\n+                \/\/  - If the additional launcher is non-modular, delete modular options of the main launcher.\n+                \/\/  - Combine other option values with the main option values.\n+                \/\/\n+\n+                List<OptionValue<?>> excludes = new ArrayList<>();\n+                excludes.add(StandardOption.ICON);\n+                excludes.add(StandardOption.LINUX_SHORTCUT_HINT);\n+                excludes.add(StandardOption.WIN_MENU_HINT);\n+                excludes.add(StandardOption.WIN_SHORTCUT_HINT);\n+                if (StandardOption.MODULE.containsIn(addLauncherOptionValues)) {\n+                    excludes.add(StandardOption.MAIN_JAR);\n+                    excludes.add(StandardOption.APPCLASS);\n+                }\n+                if (StandardOption.MAIN_JAR.containsIn(addLauncherOptionValues)) {\n+                    excludes.add(StandardOption.MODULE);\n+                }\n+\n+                return Options.concat(\n+                        addLauncherOptionValues,\n+                        cmdline.copyWithout(excludes.stream().map(WithOptionIdentifier::id).toList()));\n+            }).toList());\n+        }\n+    }\n+\n+    private static Collection<Option> filterForPlatform(OperatingSystem os, Collection<Option> options) {\n+        return options.stream().filter(fromOptionSpecPredicate(platformOption(os))).toList();\n+    }\n+\n+\n+    private static final class OptionsConverter<T> implements OptionArrayValueConverter<Options> {\n+\n+        OptionsConverter(Function<T, Result<Options>> mapper, OptionSpec<T[]> optionSpec) {\n+            this(mapper, optionSpec.<T>arrayValueConverter().orElseThrow());\n+        }\n+\n+        OptionsConverter(Function<T, Result<Options>> mapper, OptionArrayValueConverter<T> converter) {\n+            this.mapper = Objects.requireNonNull(mapper);\n+            this.converter = Objects.requireNonNull(converter);\n+        }\n+\n+        static <T> OptionValue<List<Options>> optionValue(OptionIdentifier id) {\n+            return OptionValue.<Options[]>build().id(id).to(List::of).defaultValue(List.of()).create();\n+        }\n+\n+        @Override\n+        public Result<Options[]> convert(OptionName optionName, StringToken optionValue) {\n+            return converter.convert(optionName, optionValue).flatMap(arr -> {\n+                return Stream.of(arr).map(mapper).reduce(Result.<List<Options>>ofValue(new ArrayList<>()), (result, o) -> {\n+                    if (Result.allHaveValues(result, o)) {\n+                        return result.map(v -> {\n+                            v.add(o.orElseThrow());\n+                            return v;\n+                        });\n+                    } else {\n+                        return o.mapErrors();\n+                    }\n+                }, (x, y) -> {\n+                    var errors = Stream.of(x, y).map(Result::errors).flatMap(Collection::stream).toList();\n+                    if (errors.isEmpty()) {\n+                        return Result.ofValue(Stream.of(x, y).map(Result::orElseThrow).flatMap(Collection::stream).toList());\n+                    } else {\n+                        return Result.ofErrors(errors);\n+                    }\n+                }).map(v -> v.toArray(Options[]::new));\n+            });\n+        }\n+\n+        @Override\n+        public Class<Options[]> valueType() {\n+            return Options[].class;\n+        }\n+\n+        @Override\n+        public String[] tokenize(String str) {\n+            return converter.tokenize(str);\n+        }\n+\n+        private final OptionArrayValueConverter<T> converter;\n+        private final Function<T, Result<Options>> mapper;\n+    }\n+\n+\n+    private final JOptSimpleOptionsBuilder.OptionsBuilder optionsBuilder;\n+    private final CliBundlingEnvironment bundlingEnv;\n+\n+    private static final OptionValue<List<Options>> ADD_LAUNCHER_INTERNAL =\n+            OptionsConverter.optionValue(StandardOption.ADD_LAUNCHER_INTERNAL.id());\n+\n+    private static final OptionValue<List<Options>> FILE_ASSOCIATIONS_INTERNAL =\n+            OptionsConverter.optionValue(StandardOption.FILE_ASSOCIATIONS_INTERNAL.id());\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionsProcessor.java","additions":428,"deletions":0,"binary":false,"changes":428,"status":"added"},{"patch":"@@ -0,0 +1,246 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static java.util.stream.Collectors.toMap;\n+import static java.util.stream.Collectors.toSet;\n+import static jdk.jpackage.internal.cli.StandardBundlingOperation.fromOptionName;\n+\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.model.LauncherShortcut;\n+\n+\/**\n+ * jpackage options in the app image (\".jpackage.xml\") file\n+ *\/\n+public final class StandardAppImageFileOption {\n+\n+    private StandardAppImageFileOption() {\n+    }\n+\n+\n+    public enum AppImageFileOptionScope implements OptionScope {\n+        APP,\n+        LAUNCHER,\n+        ;\n+\n+        public Stream<? extends OptionValue<?>> options(OperatingSystem os) {\n+            var scope = StandardBundlingOperation.ofPlatform(os).collect(toSet());\n+            return options().filter(ov -> {\n+                return !Collections.disjoint(ov.getSpec().scope(), scope);\n+            });\n+        }\n+\n+        public Stream<? extends OptionValue<?>> options() {\n+            return Utils.getOptionsWithSpecs(StandardAppImageFileOption.class).filter(ov -> {\n+                return ov.getSpec().scope().contains(AppImageFileOptionScope.this);\n+            });\n+        }\n+\n+        public Options parse(Path appImageFile, Map<String, String> properties, OperatingSystem os) throws InvalidOptionValueException {\n+            return parseProperties(appImageFile, properties, os, options().map(OptionValue::getOption));\n+        }\n+    }\n+\n+\n+    private enum MandatoryOption implements OptionScope {\n+        VALUE;\n+    }\n+\n+\n+    \/**\n+     * The name of a launcher.\n+     *\/\n+    public static final OptionValue<String> LAUNCHER_NAME = stringOption(\"name\")\n+            .inScope(AppImageFileOptionScope.LAUNCHER)\n+            .inScope(MandatoryOption.VALUE)\n+            .toOptionValueBuilder().id(StandardOption.NAME.id()).create();\n+\n+    \/**\n+     * The version of the application.\n+     *\/\n+    public static final OptionValue<String> APP_VERSION = stringOption(\"app-version\")\n+            .inScope(AppImageFileOptionScope.APP)\n+            .inScope(MandatoryOption.VALUE)\n+            .toOptionValueBuilder().id(StandardOption.APP_VERSION.id()).create();\n+\n+    \/**\n+     * Should install a launcher as a service?\n+     *\/\n+    public static final OptionValue<Boolean> LAUNCHER_AS_SERVICE = booleanOption(\"service\")\n+            .inScope(AppImageFileOptionScope.LAUNCHER)\n+            .toOptionValueBuilder().id(StandardOption.LAUNCHER_AS_SERVICE.id()).create();\n+\n+\n+    \/\/\n+    \/\/ Linux-specific\n+    \/\/\n+\n+    \/**\n+     * Configuration of the shortcut for a launcher. Linux-only.\n+     *\/\n+    public static final OptionValue<LauncherShortcut> LINUX_LAUNCHER_SHORTCUT = launcherShortcutOption(\"linux-shortcut\")\n+            .inScope(AppImageFileOptionScope.LAUNCHER)\n+            .toOptionValueBuilder().id(StandardOption.LINUX_SHORTCUT_HINT.id()).create();\n+\n+\n+    \/\/\n+    \/\/ Windows-specific\n+    \/\/\n+\n+    \/**\n+     * Configuration of the desktop shortcut for a launcher. Windows-only.\n+     *\/\n+    public static final OptionValue<LauncherShortcut> WIN_LAUNCHER_DESKTOP_SHORTCUT = launcherShortcutOption(\"win-shortcut\")\n+            .inScope(AppImageFileOptionScope.LAUNCHER)\n+            .toOptionValueBuilder().id(StandardOption.WIN_SHORTCUT_HINT.id()).create();\n+\n+    \/**\n+     * Configuration of the start menu shortcut for a launcher. Windows-only.\n+     *\/\n+    public static final OptionValue<LauncherShortcut> WIN_LAUNCHER_MENU_SHORTCUT = launcherShortcutOption(\"win-menu\")\n+            .inScope(AppImageFileOptionScope.LAUNCHER)\n+            .toOptionValueBuilder().id(StandardOption.WIN_MENU_HINT.id()).create();\n+\n+\n+    \/\/\n+    \/\/ macOS-specific\n+    \/\/\n+\n+    \/**\n+     * Fully-qualified name of the main class of the main launcher.\n+     *\/\n+    public static final OptionValue<String> MAC_MAIN_CLASS = stringOption(\"main-class\")\n+            .inScope(AppImageFileOptionScope.APP)\n+            .inScope(MandatoryOption.VALUE)\n+            .mutate(setPlatformScope(OperatingSystem.MACOS))\n+            .validator(StandardValidator.IS_CLASSNAME)\n+            \/\/ In case of validation failure, report it with\n+            \/\/ an exception of type InvalidOptionValueException with empty message.\n+            .validatorExceptionFactory(\n+                    OptionValueExceptionFactory.build(InvalidOptionValueException::new)\n+                            .messageFormatter((_, _) -> \"\") \/\/ just a stub\n+                            .create()\n+            )\n+            .validatorExceptionFormatString(\"\") \/\/ just a stub, not used\n+            .toOptionValueBuilder().id(StandardOption.APPCLASS.id()).create();\n+\n+    \/**\n+     * Is an application is for the App Store. macOS-only.\n+     *\/\n+    public static final OptionValue<Boolean> MAC_APP_STORE = booleanOption(\"app-store\")\n+            .inScope(AppImageFileOptionScope.APP)\n+            .mutate(setPlatformScope(OperatingSystem.MACOS))\n+            .toOptionValueBuilder().id(StandardOption.MAC_APP_STORE.id()).create();\n+\n+    \/**\n+     * Is an application image is signed. macOS-only.\n+     *\/\n+    public static final OptionValue<Boolean> MAC_SIGNED = booleanOption(\"signed\")\n+            .inScope(AppImageFileOptionScope.APP)\n+            .mutate(setPlatformScope(OperatingSystem.MACOS))\n+            .toOptionValueBuilder().id(StandardOption.MAC_SIGN.id()).create();\n+\n+\n+    public static final class InvalidOptionValueException extends RuntimeException {\n+\n+        InvalidOptionValueException(String str, Throwable t) {\n+            super(str, t);\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+\n+    public static final class MissingMandatoryOptionException extends RuntimeException {\n+\n+        MissingMandatoryOptionException(String str) {\n+            super(str);\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+\n+    private static <T> OptionSpecBuilder<T> option(String name, Class<? extends T> valueType) {\n+        return OptionSpecBuilder.<T>create(valueType)\n+                .name(Objects.requireNonNull(name))\n+                .description(\"\")\n+                .scope(fromOptionName(name))\n+                .valuePattern(\"\");\n+    }\n+\n+    private static OptionSpecBuilder<String> stringOption(String name) {\n+        return option(name, String.class).mutate(StandardOption.stringOptionMutator());\n+    }\n+\n+    private static OptionSpecBuilder<Boolean> booleanOption(String name) {\n+        return option(name, Boolean.class).mutate(StandardOption.booleanOptionMutator());\n+    }\n+\n+    private static OptionSpecBuilder<LauncherShortcut> launcherShortcutOption(String name) {\n+        return option(name, LauncherShortcut.class).mutate(StandardOption.launcherShortcutOptionMutator());\n+    }\n+\n+    private static Options parseProperties(\n+            Path appImageFile,\n+            Map<String, String> properties,\n+            OperatingSystem os,\n+            Stream<Option> options) throws InvalidOptionValueException, MissingMandatoryOptionException {\n+\n+        var scope = StandardBundlingOperation.ofPlatform(os).collect(toSet());\n+\n+        var context = new StandardOptionContext(os).forFile(appImageFile);\n+\n+        return Options.of(options.filter(option -> {\n+            return !Collections.disjoint(option.spec().scope(), scope);\n+        }).map(option -> {\n+            var spec = context.mapOptionSpec(option.spec());\n+            var strValue = Optional.ofNullable(properties.get(spec.name().name()));\n+\n+            if (strValue.isEmpty() && spec.scope().contains(MandatoryOption.VALUE)) {\n+                throw new MissingMandatoryOptionException(String.format(\"Missing mandatory '%s' property\", spec.name().name()));\n+            }\n+\n+            return strValue.map(v -> {\n+                return spec.converter().orElseThrow().convert(spec.name(), StringToken.of(v)).orElseThrow();\n+            }).map(v -> {\n+                return Map.entry(option, v);\n+            });\n+        }).filter(Optional::isPresent).map(Optional::get).collect(toMap(Map.Entry::getKey, Map.Entry::getValue)));\n+    }\n+\n+    private static <T> Consumer<OptionSpecBuilder<T>> setPlatformScope(OperatingSystem os) {\n+        return builder -> {\n+            builder.outOfScope(StandardBundlingOperation.values()).inScope(StandardBundlingOperation.ofPlatform(os).toList());\n+        };\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/StandardAppImageFileOption.java","additions":246,"deletions":0,"binary":false,"changes":246,"status":"added"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static jdk.jpackage.internal.model.AppImagePackageType.APP_IMAGE;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.model.BundlingOperationDescriptor;\n+import jdk.jpackage.internal.model.PackageType;\n+import jdk.jpackage.internal.model.StandardPackageType;\n+import jdk.jpackage.internal.util.SetBuilder;\n+\n+\n+\/**\n+ * Standard jpackage operations.\n+ *\/\n+public enum StandardBundlingOperation implements BundlingOperationOptionScope {\n+    CREATE_WIN_APP_IMAGE(APP_IMAGE, \"^(?!(linux-|mac-|win-exe-|win-msi-))\", OperatingSystem.WINDOWS),\n+    CREATE_LINUX_APP_IMAGE(APP_IMAGE, \"^(?!(win-|mac-|linux-rpm-|linux-deb-))\", OperatingSystem.LINUX),\n+    CREATE_MAC_APP_IMAGE(APP_IMAGE, \"^(?!(linux-|win-|mac-dmg-|mac-pkg-))\", OperatingSystem.MACOS),\n+    CREATE_WIN_EXE(StandardPackageType.WIN_EXE, \"^(?!(linux-|mac-|win-msi-))\", OperatingSystem.WINDOWS),\n+    CREATE_WIN_MSI(StandardPackageType.WIN_MSI, \"^(?!(linux-|mac-|win-exe-))\", OperatingSystem.WINDOWS),\n+    CREATE_LINUX_RPM(StandardPackageType.LINUX_RPM, \"^(?!(win-|mac-|linux-deb-))\", OperatingSystem.LINUX),\n+    CREATE_LINUX_DEB(StandardPackageType.LINUX_DEB, \"^(?!(win-|mac-|linux-rpm-))\", OperatingSystem.LINUX),\n+    CREATE_MAC_PKG(StandardPackageType.MAC_PKG, \"^(?!(linux-|win-|mac-dmg-))\", OperatingSystem.MACOS),\n+    CREATE_MAC_DMG(StandardPackageType.MAC_DMG, \"^(?!(linux-|win-|mac-pkg-))\", OperatingSystem.MACOS),\n+    SIGN_MAC_APP_IMAGE(APP_IMAGE, OperatingSystem.MACOS, \"sign\");\n+\n+    StandardBundlingOperation(PackageType packageType, String optionNameRegexp, OperatingSystem os, String descriptorVerb) {\n+        this.packageType = Objects.requireNonNull(packageType);\n+        optionNamePredicate = Pattern.compile(optionNameRegexp).asPredicate();\n+        this.os = Objects.requireNonNull(os);\n+        this.descriptorVerb = Objects.requireNonNull(descriptorVerb);\n+    }\n+\n+    StandardBundlingOperation(PackageType packageType, String optionNameRegexp, OperatingSystem os) {\n+        this(packageType, optionNameRegexp, os, \"create\");\n+    }\n+\n+    StandardBundlingOperation(PackageType packageType, OperatingSystem os, String descriptorVerb) {\n+        this.packageType = Objects.requireNonNull(packageType);\n+        optionNamePredicate = v -> false;\n+        this.os = Objects.requireNonNull(os);\n+        this.descriptorVerb = Objects.requireNonNull(descriptorVerb);\n+    }\n+\n+    OperatingSystem os() {\n+        return os;\n+    }\n+\n+    public String packageTypeValue() {\n+        if (packageType.equals(APP_IMAGE)) {\n+            return \"app-image\";\n+        } else {\n+            return ((StandardPackageType)packageType).suffix().substring(1);\n+        }\n+    }\n+\n+    public PackageType packageType() {\n+        return packageType;\n+    }\n+\n+    @Override\n+    public BundlingOperationDescriptor descriptor() {\n+        return new BundlingOperationDescriptor(os(), packageTypeValue(), descriptorVerb);\n+    }\n+\n+    public static Optional<StandardBundlingOperation> valueOf(BundlingOperationDescriptor descriptor) {\n+        Objects.requireNonNull(descriptor);\n+        return Stream.of(values()).filter(op -> {\n+            return op.descriptor().equals(descriptor);\n+        }).findFirst();\n+    }\n+\n+    static Stream<StandardBundlingOperation> ofPlatform(OperatingSystem os) {\n+        return Stream.of(values()).filter(platform(os));\n+    }\n+\n+    static Set<BundlingOperationOptionScope> fromOptionName(String optionName) {\n+        Objects.requireNonNull(optionName);\n+        return Stream.of(StandardBundlingOperation.values()).filter(v -> {\n+            return v.optionNamePredicate.test(optionName);\n+        }).collect(Collectors.toUnmodifiableSet());\n+    }\n+\n+    static Predicate<StandardBundlingOperation> platform(OperatingSystem os) {\n+        Objects.requireNonNull(os);\n+        return op -> {\n+            return  op.os() == os;\n+        };\n+    }\n+\n+    static Stream<StandardBundlingOperation> narrow(Stream<OptionScope> scope) {\n+        return scope.filter(StandardBundlingOperation.class::isInstance).map(StandardBundlingOperation.class::cast);\n+    }\n+\n+    static final Set<BundlingOperationOptionScope> WINDOWS_CREATE_BUNDLE = Set.of(\n+            CREATE_WIN_APP_IMAGE, CREATE_WIN_MSI, CREATE_WIN_EXE);\n+\n+    static final Set<BundlingOperationOptionScope> LINUX_CREATE_BUNDLE = Set.of(\n+            CREATE_LINUX_APP_IMAGE, CREATE_LINUX_RPM, CREATE_LINUX_DEB);\n+\n+    static final Set<BundlingOperationOptionScope> MACOS_CREATE_BUNDLE = Set.of(\n+            CREATE_MAC_APP_IMAGE, CREATE_MAC_DMG, CREATE_MAC_PKG);\n+\n+    static final Set<BundlingOperationOptionScope> WINDOWS_CREATE_NATIVE = Set.of(\n+            CREATE_WIN_MSI, CREATE_WIN_EXE);\n+\n+    static final Set<BundlingOperationOptionScope> LINUX_CREATE_NATIVE = Set.of(\n+            CREATE_LINUX_RPM, CREATE_LINUX_DEB);\n+\n+    static final Set<BundlingOperationOptionScope> MACOS_CREATE_NATIVE = Set.of(\n+            CREATE_MAC_DMG, CREATE_MAC_PKG);\n+\n+    static final Set<BundlingOperationOptionScope> WINDOWS = WINDOWS_CREATE_BUNDLE;\n+\n+    static final Set<BundlingOperationOptionScope> LINUX = LINUX_CREATE_BUNDLE;\n+\n+    static final Set<BundlingOperationOptionScope> MACOS = SetBuilder.build(\n+            BundlingOperationOptionScope.class).add(MACOS_CREATE_BUNDLE).add(SIGN_MAC_APP_IMAGE).create();\n+\n+    static final Set<BundlingOperationOptionScope> MACOS_APP_IMAGE = Set.of(\n+            SIGN_MAC_APP_IMAGE, CREATE_MAC_APP_IMAGE);\n+\n+    static final Set<BundlingOperationOptionScope> MAC_SIGNING = MACOS;\n+\n+    static final Set<BundlingOperationOptionScope> CREATE_APP_IMAGE = Set.of(\n+            CREATE_WIN_APP_IMAGE, CREATE_LINUX_APP_IMAGE, CREATE_MAC_APP_IMAGE);\n+\n+    static final Set<BundlingOperationOptionScope> CREATE_NATIVE = Set.of(\n+            CREATE_WIN_MSI, CREATE_WIN_EXE,\n+            CREATE_LINUX_RPM, CREATE_LINUX_DEB,\n+            CREATE_MAC_DMG, CREATE_MAC_PKG);\n+\n+    static final Set<BundlingOperationOptionScope> CREATE_BUNDLE = Stream.of(\n+            CREATE_APP_IMAGE,\n+            CREATE_NATIVE\n+    ).flatMap(Set::stream).collect(Collectors.toUnmodifiableSet());\n+\n+    private final Predicate<String> optionNamePredicate;\n+    private final OperatingSystem os;\n+    private final PackageType packageType;\n+    private final String descriptorVerb;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/StandardBundlingOperation.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static java.util.stream.Collectors.toUnmodifiableSet;\n+import static jdk.jpackage.internal.cli.OptionSpecBuilder.toList;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+\/**\n+ * jpackage file association options\n+ *\/\n+public final class StandardFaOption {\n+\n+    private StandardFaOption() {\n+    }\n+\n+    public static final OptionValue<String> DESCRIPTION = stringOption(\"description\").create();\n+\n+    public static final OptionValue<Path> ICON = fileOption(\"icon\").create();\n+\n+    public static final OptionValue<List<String>> EXTENSIONS = stringOption(\"extension\").tokenizer(\"(,|\\\\s)+\").createArray(toList());\n+\n+    public static final OptionValue<List<String>> CONTENT_TYPE = stringOption(\"mime-type\").tokenizer(\"(,|\\\\s)+\").createArray(toList());\n+\n+    \/\/\n+    \/\/ MacOS-specific\n+    \/\/\n+\n+    public static final OptionValue<String> MAC_CFBUNDLETYPEROLE = stringOption(\"mac.CFBundleTypeRole\").create();\n+\n+    public static final OptionValue<String> MAC_LSHANDLERRANK = stringOption(\"mac.LSHandlerRank\").create();\n+\n+    public static final OptionValue<String> MAC_NSSTORETYPEKEY = stringOption(\"mac.NSPersistentStoreTypeKey\").create();\n+\n+    public static final OptionValue<String> MAC_NSDOCUMENTCLASS = stringOption(\"mac.NSDocumentClass\").create();\n+\n+    public static final OptionValue<Boolean> MAC_LSTYPEISPACKAGE = booleanOption(\"mac.LSTypeIsPackage\").create();\n+\n+    public static final OptionValue<Boolean> MAC_LSDOCINPLACE = booleanOption(\"mac.LSSupportsOpeningDocumentsInPlace\").create();\n+\n+    public static final OptionValue<Boolean> MAC_UIDOCBROWSER = booleanOption(\"mac.UISupportsDocumentBrowser\").create();\n+\n+    public static final OptionValue<List<String>> MAC_NSEXPORTABLETYPES = stringOption(\"mac.NSExportableTypes\").tokenizer(\"(,|\\\\s)+\").createArray(toList());\n+\n+    public static final OptionValue<List<String>> MAC_UTTYPECONFORMSTO = stringOption(\"mac.UTTypeConformsTo\").tokenizer(\"(,|\\\\s)+\").createArray(toList());\n+\n+    \/**\n+     * Returns public and package-private options with option specs defined in\n+     * {@link StandardFaOption} class.\n+     *\n+     * @return public and package-private options defined in\n+     *         {@link StandardFaOption} class\n+     *\/\n+    static Set<Option> options() {\n+        return Utils.getOptionsWithSpecs(StandardFaOption.class).map(OptionValue::getOption).collect(toUnmodifiableSet());\n+    }\n+\n+    private static <T> OptionSpecBuilder<T> option(String name, Class<? extends T> valueType) {\n+        return OptionSpecBuilder.<T>create(valueType)\n+                .name(Objects.requireNonNull(name))\n+                .description(\"\")\n+                .scope(scopeFromOptionName(name))\n+                .valuePattern(\"\");\n+    }\n+\n+    private static OptionSpecBuilder<String> stringOption(String name) {\n+        return option(name, String.class).mutate(StandardOption.stringOptionMutator());\n+    }\n+\n+    private static OptionSpecBuilder<Path> fileOption(String name) {\n+        return option(name, Path.class).mutate(StandardOption.fileOptionMutator());\n+    }\n+\n+    private static OptionSpecBuilder<Boolean> booleanOption(String name) {\n+        return option(name, Boolean.class).mutate(StandardOption.booleanOptionMutator()).defaultValue(null);\n+    }\n+\n+    private static Set<? extends OptionScope> scopeFromOptionName(String name) {\n+        if (name.startsWith(\"mac.\")) {\n+            return Set.of(StandardBundlingOperation.CREATE_MAC_PKG);\n+        } else {\n+            return StandardBundlingOperation.CREATE_NATIVE;\n+        }\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/StandardFaOption.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,398 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+import static java.util.stream.Collectors.toSet;\n+import static jdk.jpackage.internal.cli.HelpFormatter.eol;\n+import static jdk.jpackage.internal.cli.StandardOption.platformOption;\n+import static jdk.jpackage.internal.cli.StandardOption.sharedOption;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.ResourceBundle;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.cli.HelpFormatter.ConsoleOptionFormatter;\n+import jdk.jpackage.internal.cli.HelpFormatter.ConsoleOptionGroupFormatter;\n+import jdk.jpackage.internal.cli.HelpFormatter.OptionFormatter;\n+import jdk.jpackage.internal.cli.HelpFormatter.OptionGroup;\n+import jdk.jpackage.internal.cli.HelpFormatter.OptionGroupFormatter;\n+import jdk.jpackage.internal.util.StringBundle;\n+\n+\/**\n+ * jpackage help formatter\n+ *\/\n+final class StandardHelpFormatter {\n+\n+    enum OptionGroupID {\n+        SAMPLES(\"sample\", OptionGroupContent::sampleGroupContent),\n+\n+        GENERIC_OPTIONS(\"generic\", OptionGroupContent::genericGroupContent),\n+\n+        RUNTIME_IMAGE_OPTIONS(\"runtime-image\", OptionGroupContent::runtimeImageGroupContent),\n+\n+        APPLICATION_IMAGE_OPTIONS(\"app-image\", OptionGroupContent::appImageGroupContent),\n+\n+        LAUNCHER_OPTIONS_SHARED(\"launcher\", OptionGroupContent::launcherGroupContent),\n+        LAUNCHER_OPTIONS_PLATFORM(\"launcher-platform\", OptionGroupContent::launcherPlatformGroupContent),\n+\n+        PACKAGE_OPTIONS_SHARED(\"package\", OptionGroupContent::nativePackageGroupContent),\n+        PACKAGE_OPTIONS_PLATFORM(\"package-platform\", OptionGroupContent::nativePackagePlatformGroupContent),\n+        ;\n+\n+        OptionGroupID(String name, Function<OperatingSystem, OptionGroupContent> optionGroupContentCreator) {\n+            this.name = \"help.option-group.\" + Objects.requireNonNull(name);\n+            this.optionGroupContentCreator = Objects.requireNonNull(optionGroupContentCreator);\n+        }\n+\n+        String groupName() {\n+            return name;\n+        }\n+\n+        Optional<OptionGroup> createNonEmptyOptionGroup(OperatingSystem os) {\n+            var optionGroup = optionGroupContentCreator.apply(os).createOptionGroup(name);\n+            if (optionGroup.options().isEmpty()) {\n+                return Optional.empty();\n+            } else {\n+                return Optional.of(optionGroup);\n+            }\n+        }\n+\n+        private final String name;\n+        private final Function<OperatingSystem, OptionGroupContent> optionGroupContentCreator;\n+    }\n+\n+    static final class OptionGroupContent {\n+\n+        static OptionGroupContent sampleGroupContent(OperatingSystem os) {\n+            List<String> ids = new ArrayList<>();\n+            ids.add(\"help.option-group.sample.create-native-package\");\n+            ids.add(\"help.option-group.sample.create-app-image\");\n+            ids.add(\"help.option-group.sample.create-runtime-installer\");\n+            if (os.equals(OperatingSystem.MACOS)) {\n+                ids.add(\"help.option-group.sample.sign-app-image\");\n+            }\n+            return new OptionGroupContent(ids.stream().map(descriptionId -> {\n+                return dummyOptionSpec(descriptionId, descriptionId);\n+            }).toList());\n+        }\n+\n+        static OptionGroupContent genericGroupContent(OperatingSystem os) {\n+            return shared(os).options(genericOptions()).create();\n+        }\n+\n+        static OptionGroupContent runtimeImageGroupContent(OperatingSystem os) {\n+            return shared(os).options(runtimeImageOptions()).create();\n+        }\n+\n+        static OptionGroupContent appImageGroupContent(OperatingSystem os) {\n+            return shared(os).options(appImageOptions()).create();\n+        }\n+\n+        static OptionGroupContent launcherGroupContent(OperatingSystem os) {\n+            return shared(os).options(launcherOptions(os)).create();\n+        }\n+\n+        static OptionGroupContent launcherPlatformGroupContent(OperatingSystem os) {\n+            return platform(os).options(launcherOptions(os)).create();\n+        }\n+\n+        static OptionGroupContent nativePackageGroupContent(OperatingSystem os) {\n+            return shared(os).options(nativePackageOptions(os)).create();\n+        }\n+\n+        static OptionGroupContent nativePackagePlatformGroupContent(OperatingSystem os) {\n+            return platform(os).options(nativePackageOptions(os)).create();\n+        }\n+\n+        private OptionGroupContent(List<? extends OptionSpec<?>> optionSpecs) {\n+            this.optionSpecs = List.copyOf(optionSpecs);\n+        }\n+\n+        private OptionGroup createOptionGroup(String name) {\n+            return new OptionGroup(name, optionSpecs);\n+        }\n+\n+        private static Builder shared(OperatingSystem os) {\n+            return new Builder(os, sharedOption()).optionSpecDescriptionGetter(standardOptionSpecDescriptionGetter(os));\n+        }\n+\n+        private static Builder platform(OperatingSystem os) {\n+            return new Builder(os, Predicate.not(sharedOption()));\n+        }\n+\n+        private static final class Builder {\n+\n+            private Builder(OperatingSystem os, Predicate<OptionSpec<?>> platformFilter) {\n+                this.context = new StandardOptionContext(os);\n+                this.platformFilter = Objects.requireNonNull(platformFilter);\n+            }\n+\n+            OptionGroupContent create() {\n+                return new OptionGroupContent(optionSpecs.stream()\n+                        .filter(platformFilter).sorted(optionSpecSorter()).toList());\n+            }\n+\n+            Builder optionSpecDescriptionGetter(Function<OptionSpec<?>, String> v) {\n+                descriptionGetter = v;\n+                return this;\n+            }\n+\n+            Builder options(Stream<? extends OptionSpec<?>> v) {\n+                optionSpecs.addAll(v.<OptionSpec<?>>map(context::mapOptionSpec).map(optionSpec -> {\n+                    return optionSpec.copyWithDescription(getDescription(optionSpec));\n+                }).toList());\n+                return this;\n+            }\n+\n+            private String getDescription(OptionSpec<?> optionSpec) {\n+                Objects.requireNonNull(optionSpec);\n+                return Optional.ofNullable(descriptionGetter).orElse(\n+                        OptionGroupContent::getDefaultOptionSpecDescription).apply(optionSpec);\n+            }\n+\n+            private final StandardOptionContext context;\n+            private final Predicate<OptionSpec<?>> platformFilter;\n+            private Function<OptionSpec<?>, String> descriptionGetter;\n+            private List<OptionSpec<?>> optionSpecs = new ArrayList<>();\n+        }\n+\n+        private static Stream<? extends OptionSpec<?>> genericOptions() {\n+            return Stream.of(\n+                    StandardOption.TYPE,\n+                    StandardOption.APP_VERSION,\n+                    StandardOption.COPYRIGHT,\n+                    StandardOption.DESCRIPTION,\n+                    StandardOption.HELP,\n+                    StandardOption.ICON,\n+                    StandardOption.NAME,\n+                    StandardOption.DEST,\n+                    StandardOption.TEMP_ROOT,\n+                    StandardOption.VENDOR,\n+                    StandardOption.VERBOSE,\n+                    StandardOption.VERSION\n+            ).map(OptionValue::getSpec);\n+        }\n+\n+        private static Stream<? extends OptionSpec<?>> appImageOptions() {\n+            return Stream.of(\n+                    StandardOption.INPUT,\n+                    StandardOption.APP_CONTENT\n+            ).map(OptionValue::getSpec);\n+        }\n+\n+        private static Stream<? extends OptionSpec<?>> runtimeImageOptions() {\n+            return Stream.of(\n+                    StandardOption.ADD_MODULES,\n+                    StandardOption.MODULE_PATH,\n+                    StandardOption.JLINK_OPTIONS,\n+                    StandardOption.PREDEFINED_RUNTIME_IMAGE\n+            ).map(OptionValue::getSpec);\n+        }\n+\n+        private static Stream<? extends OptionSpec<?>> launcherOptions(OperatingSystem os) {\n+            final var fromPropertyFile = StandardOption.launcherOptions().stream()\n+                    .map(Option::spec)\n+                    .filter(platformOption(os))\n+                    .filter(spec -> {\n+                        \/\/ Want options applicable to the app image bundling on the current platform.\n+                        return StandardBundlingOperation.narrow(spec.scope().stream())\n+                                .filter(StandardBundlingOperation.CREATE_APP_IMAGE::contains)\n+                                .findFirst().isPresent();\n+                    })\n+                    .filter(Predicate.not(genericOptions().toList()::contains));\n+\n+            final Stream<? extends OptionSpec<?>> additional = Stream.of(\n+                    StandardOption.ADD_LAUNCHER_INTERNAL\n+            ).map(OptionValue::getSpec);\n+\n+            return Stream.concat(fromPropertyFile, additional);\n+        }\n+\n+        private static Stream<? extends OptionSpec<?>> nativePackageOptions(OperatingSystem os) {\n+            \/\/ The most straightforward way to get the list of these options is to\n+            \/\/ subtract the options from other groups from the list of all supported options.\n+            \/\/ This presumes this method is called after the other enum elements have been initialized.\n+            final var base = StandardOption.options().stream().map(Option::spec).filter(platformOption(os))\n+                    .filter(Predicate.not(Stream.of(\n+                            genericOptions(),\n+                            appImageOptions(),\n+                            runtimeImageOptions(),\n+                            launcherOptions(os)).flatMap(x -> x).collect(toSet())::contains));\n+\n+            return Stream.concat(base, Stream.of(StandardOption.RUNTIME_INSTALLER_RUNTIME_IMAGE));\n+        }\n+\n+        private static String getDefaultOptionSpecDescription(OptionSpec<?> optionSpec) {\n+            return I18N.getString(optionSpec.description());\n+        }\n+\n+        private static Function<OptionSpec<?>, String> standardOptionSpecDescriptionGetter(OperatingSystem os) {\n+            return optionSpec -> {\n+                return getDefaultOptionSpecDescription(optionSpec);\n+            };\n+        }\n+\n+        private final List<OptionSpec<?>> optionSpecs;\n+    }\n+\n+\n+    private static final class GroupFormatter implements OptionGroupFormatter {\n+\n+        @Override\n+        public void formatHeader(String groupName, Consumer<CharSequence> sink) {\n+            groupFormatter.formatHeader(I18N.getString(groupName), sink);\n+        }\n+\n+        @Override\n+        public void formatBody(Iterable<? extends OptionSpec<?>> optionSpecs, Consumer<CharSequence> sink) {\n+            groupFormatter.formatBody(optionSpecs, sink);\n+        }\n+\n+        @Override\n+        public void format(HelpFormatter.OptionGroup group, Consumer<CharSequence> sink) {\n+            formatHeader(group.name(), sink);\n+            if (group.name().equals(OptionGroupID.GENERIC_OPTIONS.groupName())) {\n+                optionSpecFormatter.format(\"@<filename>\", Optional.empty(), I18N.getString(\"main.option.argument-file\"), sink);\n+            }\n+            formatBody(group.options(), sink);\n+        }\n+\n+        private final OptionFormatter optionSpecFormatter = new ConsoleOptionFormatter(2, 0);\n+        private final OptionGroupFormatter groupFormatter = new ConsoleOptionGroupFormatter(optionSpecFormatter);\n+    }\n+\n+\n+    private static final class SampleGroupFormatter implements OptionGroupFormatter {\n+\n+        @Override\n+        public void formatHeader(String groupName, Consumer<CharSequence> sink) {\n+            var formattedName = I18N.getString(groupName) + \":\";\n+            sink.accept(formattedName);\n+            eol(sink);\n+            sink.accept(\"-\".repeat(formattedName.length()));\n+            eol(sink);\n+        }\n+\n+        @Override\n+        public void formatBody(Iterable<? extends OptionSpec<?>> optionSpecs, Consumer<CharSequence> sink) {\n+            boolean first = true;\n+            for (var optionSpec : optionSpecs) {\n+                if (first) {\n+                    first = false;\n+                } else {\n+                    eol(sink);\n+                }\n+                sink.accept(I18N.getString(optionSpec.description()));\n+                eol(sink);\n+            }\n+        }\n+    }\n+\n+\n+    StandardHelpFormatter(OperatingSystem os) {\n+\n+        samplesHelpFormatter = HelpFormatter.build()\n+                .groupFormatter(new SampleGroupFormatter())\n+                .groups(OptionGroupID.SAMPLES.createNonEmptyOptionGroup(os).orElseThrow())\n+                .create();\n+\n+        final var builder = HelpFormatter.build().groupFormatter(new GroupFormatter());\n+\n+        Stream.of(OptionGroupID.values())\n+                .filter(Predicate.<OptionGroupID>isEqual(OptionGroupID.SAMPLES).negate())\n+                .map(optionGroupID -> {\n+                    return optionGroupID.createNonEmptyOptionGroup(os);\n+                })\n+                .filter(Optional::isPresent)\n+                .map(Optional::orElseThrow)\n+                .forEach(builder::groups);\n+\n+        mainHelpFormatter = builder.create();\n+    }\n+\n+    void format(Consumer<CharSequence> sink) {\n+        sink.accept(I18N.getString(\"help.header\"));\n+        eol(sink);\n+        eol(sink);\n+        samplesHelpFormatter.format(sink);\n+        mainHelpFormatter.format(sink);\n+    }\n+\n+    void formatNoArgsHelp(Consumer<CharSequence> sink) {\n+        sink.accept(I18N.getString(\"help.header\"));\n+        eol(sink);\n+        sink.accept(I18N.format(\"help.short\"));\n+        eol(sink);\n+    }\n+\n+    static Comparator<OptionSpec<?>> optionSpecSorter() {\n+        \/\/ Sort alphabetically by the first name except of the \"--type\" option, it goes first.\n+        return Comparator.comparing(OptionSpec::name, new Comparator<OptionName>() {\n+\n+            @Override\n+            public int compare(OptionName o1, OptionName o2) {\n+                if (o1.equals(TYPE) && o2.equals(TYPE)) {\n+                    return 0;\n+                } else if (o1.equals(TYPE)) {\n+                    return -1;\n+                } else if (o2.equals(TYPE)) {\n+                    return 1;\n+                } else {\n+                    return o1.compareTo(o2);\n+                }\n+            }\n+\n+            private static final OptionName TYPE = StandardOption.TYPE.getSpec().name();\n+        });\n+    }\n+\n+    private static OptionSpec<?> dummyOptionSpec(String name, String description) {\n+        return new OptionSpec<>(\n+                List.of(OptionName.of(name)),\n+                Optional.empty(),\n+                Set.copyOf(StandardBundlingOperation.CREATE_BUNDLE),\n+                OptionSpec.MergePolicy.USE_FIRST,\n+                Optional.empty(),\n+                Optional.empty(),\n+                description);\n+    }\n+\n+    private final HelpFormatter samplesHelpFormatter;\n+    private final HelpFormatter mainHelpFormatter;\n+\n+    private static final StringBundle I18N = StringBundle.fromResourceBundle(ResourceBundle.getBundle(\n+            \"jdk.jpackage.internal.resources.HelpResources\"));\n+\n+    static final StandardHelpFormatter INSTANCE = new StandardHelpFormatter(OperatingSystem.current());\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/StandardHelpFormatter.java","additions":398,"deletions":0,"binary":false,"changes":398,"status":"added"},{"patch":"@@ -0,0 +1,808 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static java.util.stream.Collectors.toUnmodifiableSet;\n+import static jdk.jpackage.internal.cli.OptionSpecBuilder.pathSeparator;\n+import static jdk.jpackage.internal.cli.OptionSpecBuilder.toList;\n+import static jdk.jpackage.internal.cli.StandardBundlingOperation.CREATE_MAC_PKG;\n+import static jdk.jpackage.internal.cli.StandardBundlingOperation.CREATE_NATIVE;\n+import static jdk.jpackage.internal.cli.StandardBundlingOperation.SIGN_MAC_APP_IMAGE;\n+import static jdk.jpackage.internal.cli.StandardBundlingOperation.fromOptionName;\n+import static jdk.jpackage.internal.cli.StandardOptionContext.createOptionSpecBuilderMutator;\n+import static jdk.jpackage.internal.cli.StandardOptionValueExceptionFactory.ERROR_WITHOUT_CONTEXT;\n+import static jdk.jpackage.internal.cli.StandardOptionValueExceptionFactory.ERROR_WITH_VALUE;\n+import static jdk.jpackage.internal.cli.StandardOptionValueExceptionFactory.ERROR_WITH_VALUE_AND_OPTION_NAME;\n+import static jdk.jpackage.internal.cli.StandardOptionValueExceptionFactory.forMessageWithOptionValueAndName;\n+import static jdk.jpackage.internal.cli.StandardValueConverter.addLauncherShortcutConv;\n+import static jdk.jpackage.internal.cli.StandardValueConverter.booleanConv;\n+import static jdk.jpackage.internal.cli.StandardValueConverter.identityConv;\n+import static jdk.jpackage.internal.cli.StandardValueConverter.mainLauncherShortcutConv;\n+import static jdk.jpackage.internal.cli.StandardValueConverter.pathConv;\n+import static jdk.jpackage.internal.cli.StandardValueConverter.uuidConv;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.model.BundlingOperationDescriptor;\n+import jdk.jpackage.internal.model.JPackageException;\n+import jdk.jpackage.internal.model.LauncherShortcut;\n+import jdk.jpackage.internal.model.LauncherShortcutStartupDirectory;\n+import jdk.jpackage.internal.model.PackageType;\n+import jdk.jpackage.internal.util.SetBuilder;\n+\n+\/**\n+ * jpackage command line options\n+ *\/\n+public final class StandardOption {\n+\n+    private StandardOption() {\n+    }\n+\n+    private static final Set<OperatingSystem> SUPPORTED_OS = Set.of(\n+            OperatingSystem.LINUX, OperatingSystem.WINDOWS, OperatingSystem.MACOS);\n+\n+\n+    \/**\n+     * Scope of options configuring a launcher.\n+     *\/\n+    enum LauncherProperty implements OptionScope {\n+        VALUE\n+    }\n+\n+\n+    \/**\n+     * Modes in which bundling operations don't involve building of an app image.\n+     *\/\n+    private static final Set<BundlingOperationModifier> NOT_BUILDING_APP_IMAGE = Set.of(\n+            \/\/ jpackage will not build an app image when bundling runtime native package\n+            BundlingOperationModifier.BUNDLE_RUNTIME,\n+            \/\/ jpackage will not build an app image if predefined app image is supplied\n+            BundlingOperationModifier.BUNDLE_PREDEFINED_APP_IMAGE);\n+\n+    private static final Set<OptionScope> MAC_SIGNING = new SetBuilder<OptionScope>()\n+            .add(StandardBundlingOperation.MAC_SIGNING)\n+            .add(NOT_BUILDING_APP_IMAGE)\n+            .create();\n+\n+\n+    static final OptionValue<Boolean> HELP = auxilaryOption(\"help\").addAliases(\"h\", \"?\").create();\n+\n+    static final OptionValue<Boolean> VERSION = auxilaryOption(\"version\").create();\n+\n+    public static final OptionValue<Boolean> VERBOSE = auxilaryOption(\"verbose\").create();\n+\n+    public static final OptionValue<PackageType> TYPE = option(\"type\", PackageType.class).addAliases(\"t\")\n+            .scope(StandardBundlingOperation.values()).inScope(NOT_BUILDING_APP_IMAGE)\n+            .converterExceptionFactory(ERROR_WITH_VALUE).converterExceptionFormatString(\"ERR_InvalidInstallerType\")\n+            .converter(str -> {\n+                Objects.requireNonNull(str);\n+                return Stream.of(StandardBundlingOperation.values()).filter(bundlingOperation -> {\n+                    return bundlingOperation.packageTypeValue().equals(str);\n+                }).map(StandardBundlingOperation::packageType).findFirst().orElseThrow(IllegalArgumentException::new);\n+            })\n+            .description(\"main.option.type\" + resourceKeySuffix(OperatingSystem.current()))\n+            .mutate(createOptionSpecBuilderMutator((b, context) -> {\n+                b.description(\"main.option.type\" + resourceKeySuffix(context.os()));\n+            })).create();\n+\n+    public static final OptionValue<Path> INPUT = directoryOption(\"input\").addAliases(\"i\")\n+            .outOfScope(NOT_BUILDING_APP_IMAGE)\n+            .create();\n+\n+    public static final OptionValue<Path> DEST = directoryOption(\"dest\").addAliases(\"d\")\n+            .valuePattern(\"destination path\")\n+            .validator(StandardValidator.IS_DIRECTORY_OR_NON_EXISTENT)\n+            .defaultValue(Path.of(\"\").toAbsolutePath())\n+            .create();\n+\n+    public static final OptionValue<String> DESCRIPTION = stringOption(\"description\")\n+            .inScope(LauncherProperty.VALUE)\n+            .valuePattern(\"description string\")\n+            .create();\n+\n+    public static final OptionValue<String> VENDOR = stringOption(\"vendor\").valuePattern(\"vendor string\").create();\n+\n+    public static final OptionValue<String> APPCLASS = stringOption(\"main-class\")\n+            .valuePattern(\"class name\")\n+            .outOfScope(NOT_BUILDING_APP_IMAGE)\n+            .inScope(LauncherProperty.VALUE)\n+            .create();\n+\n+    public static final OptionValue<String> NAME = stringOption(\"name\").addAliases(\"n\")\n+            .validator(StandardValidator.IS_NAME_VALID)\n+            .validatorExceptionFactory(ERROR_WITH_VALUE).validatorExceptionFormatString(\"ERR_InvalidAppName\")\n+            .create();\n+\n+    public static final OptionValue<Path> RESOURCE_DIR = directoryOption(\"resource-dir\")\n+            .scope(StandardBundlingOperation.values()).inScope(NOT_BUILDING_APP_IMAGE)\n+            .create();\n+\n+    public static final OptionValue<List<String>> ARGUMENTS = escapedStringListOption(\"arguments\")\n+            .valuePattern(\"main class arguments\")\n+            .outOfScope(NOT_BUILDING_APP_IMAGE)\n+            .inScope(LauncherProperty.VALUE)\n+            .createArray(toList());\n+\n+    public static final OptionValue<List<String>> JLINK_OPTIONS = escapedStringListOption(\"jlink-options\")\n+            .valuePattern(\"jlink options\")\n+            .outOfScope(NOT_BUILDING_APP_IMAGE)\n+            .createArray(toList());\n+\n+    public static final OptionValue<Path> ICON = fileOption(\"icon\")\n+            .validator(new Predicate<>() {\n+                @Override\n+                public boolean test(Path path) {\n+                    if (!path.toString().isEmpty()) {\n+                        return StandardValidator.IS_EXISTENT_NOT_DIRECTORY.test(path);\n+                    } else {\n+                        return true;\n+                    }\n+                }\n+            })\n+            .inScope(LauncherProperty.VALUE)\n+            .create();\n+\n+    public static final OptionValue<String> COPYRIGHT = stringOption(\"copyright\").valuePattern(\"copyright string\").create();\n+\n+    public static final OptionValue<Path> LICENSE_FILE = fileOption(\"license-file\")\n+            .validatorExceptionFormatString(\"ERR_LicenseFileNotExit\")\n+            .validatorExceptionFactory(ERROR_WITHOUT_CONTEXT)\n+            .create();\n+\n+    public static final OptionValue<String> APP_VERSION = stringOption(\"app-version\").create();\n+\n+    public static final OptionValue<String> ABOUT_URL = urlOption(\"about-url\")\n+            .scope(CREATE_NATIVE).inScope(NOT_BUILDING_APP_IMAGE)\n+            .create();\n+\n+    public static final OptionValue<List<String>> JAVA_OPTIONS = escapedStringListOption(\"java-options\")\n+            .valuePattern(\"java options\")\n+            .outOfScope(NOT_BUILDING_APP_IMAGE)\n+            .inScope(LauncherProperty.VALUE)\n+            .createArray(toList());\n+\n+    public static final OptionValue<List<Path>> APP_CONTENT = pathOption(\"app-content\")\n+            .tokenizer(\",\")\n+            .valuePattern(\"additional content\")\n+            .outOfScope(NOT_BUILDING_APP_IMAGE)\n+            .mutate(createOptionSpecBuilderMutator((b, context) -> {\n+                if (context.os() == OperatingSystem.MACOS) {\n+                    b.description(\"main.option.app-content\" + resourceKeySuffix(context.os()));\n+                }\n+            }))\n+            .createArray(toList());\n+\n+    static final OptionValue<Path[]> FILE_ASSOCIATIONS_INTERNAL = fileOption(\"file-associations\")\n+            .tokenizer(pathSeparator())\n+            .outOfScope(BundlingOperationModifier.BUNDLE_RUNTIME)\n+            .createArray();\n+\n+    static final OptionValue<AdditionalLauncher[]> ADD_LAUNCHER_INTERNAL = createAddLauncherOption(\"add-launcher\");\n+\n+    public static final OptionValue<Path> TEMP_ROOT = directoryOption(\"temp\")\n+            .validatorExceptionFactory((optionName, optionValue, formatString, cause) -> {\n+                if (cause.orElseThrow() instanceof StandardValidator.DirectoryListingIOException) {\n+                    formatString = \"error.path-paramater-ioexception\";\n+                    return ERROR_WITH_VALUE_AND_OPTION_NAME.create(optionName, optionValue, formatString, cause);\n+                } else {\n+                    return ERROR_WITH_VALUE.create(optionName, optionValue, formatString, cause);\n+                }\n+            })\n+            .validatorExceptionFormatString(\"ERR_BuildRootInvalid\")\n+            .validator(StandardValidator.IS_DIRECTORY_EMPTY_OR_NON_EXISTENT)\n+            .create();\n+\n+    public static final OptionValue<Path> INSTALL_DIR = pathOption(\"install-dir\")\n+            .valuePattern(\"directory path\")\n+            .mutate(createOptionSpecBuilderMutator((b, context) -> {\n+                if (context.os() == OperatingSystem.WINDOWS) {\n+                    b.description(\"main.option.install-dir\" + resourceKeySuffix(context.os()));\n+                }\n+            }))\n+            .create();\n+\n+    public static final OptionValue<Path> PREDEFINED_APP_IMAGE = directoryOption(\"app-image\")\n+            .scope(CREATE_NATIVE).inScope(SIGN_MAC_APP_IMAGE).inScope(BundlingOperationModifier.BUNDLE_PREDEFINED_APP_IMAGE)\n+            .validatorExceptionFactory(ERROR_WITH_VALUE)\n+            .validatorExceptionFormatString(\"ERR_AppImageNotExist\")\n+            .mutate(createOptionSpecBuilderMutator((b, context) -> {\n+                if (context.os() == OperatingSystem.MACOS) {\n+                    b.description(\"main.option.app-image\" + resourceKeySuffix(context.os()));\n+                }\n+            }))\n+            .create();\n+\n+    public static final OptionValue<Path> PREDEFINED_RUNTIME_IMAGE = directoryOption(\"runtime-image\")\n+            .outOfScope(BundlingOperationModifier.BUNDLE_PREDEFINED_APP_IMAGE)\n+            .create();\n+\n+    static final OptionSpec<Path> RUNTIME_INSTALLER_RUNTIME_IMAGE = directoryOption(\"runtime-image\")\n+            .outOfScope(BundlingOperationModifier.BUNDLE_PREDEFINED_APP_IMAGE)\n+            .description(\"main.option.installer-runtime-image\")\n+            .createOptionSpec();\n+\n+    public static final OptionValue<Path> MAIN_JAR = pathOption(\"main-jar\")\n+            .valuePattern(\"main jar file\")\n+            .outOfScope(NOT_BUILDING_APP_IMAGE)\n+            .inScope(LauncherProperty.VALUE)\n+            .create();\n+\n+    public static final OptionValue<String> MODULE = stringOption(\"module\").addAliases(\"m\")\n+            .valuePattern(\"<module name>[\/<main class>]\")\n+            .outOfScope(NOT_BUILDING_APP_IMAGE)\n+            .inScope(LauncherProperty.VALUE)\n+            .create();\n+\n+    public static final OptionValue<List<String>> ADD_MODULES = stringOption(\"add-modules\").tokenizer(\",\")\n+            .valuePattern(\"module name\")\n+            .outOfScope(NOT_BUILDING_APP_IMAGE)\n+            .createArray(toList());\n+\n+    public static final OptionValue<List<Path>> MODULE_PATH = pathOption(\"module-path\").addAliases(\"p\").tokenizer(pathSeparator())\n+            .valuePattern(\"module path\")\n+            .outOfScope(NOT_BUILDING_APP_IMAGE)\n+            .mutate(createOptionSpecBuilderMutator((b, context) -> {\n+                if (context.os() == OperatingSystem.WINDOWS) {\n+                    b.description(\"main.option.module-path\" + resourceKeySuffix(context.os()));\n+                }\n+            }))\n+            .createArray(toList());\n+\n+    public static final OptionValue<Boolean> LAUNCHER_AS_SERVICE = booleanOption(\"launcher-as-service\")\n+            .scope(nativeBundling())\n+            .inScope(LauncherProperty.VALUE)\n+            .create();\n+\n+    \/\/\n+    \/\/ Linux-specific\n+    \/\/\n+\n+    public static final OptionValue<String> LINUX_RELEASE = stringOption(\"linux-app-release\").scope(nativeBundling()).create();\n+\n+    public static final OptionValue<String> LINUX_PACKAGE_NAME = stringOption(\"linux-package-name\")\n+            .valuePattern(\"package name\")\n+            .scope(nativeBundling()).create();\n+\n+    public static final OptionValue<String> LINUX_DEB_MAINTAINER_EMAIL = stringOption(\"linux-deb-maintainer\")\n+            .valuePattern(\"email address\")\n+            .create();\n+\n+    public static final OptionValue<String> LINUX_APP_CATEGORY = stringOption(\"linux-app-category\").scope(nativeBundling()).create();\n+\n+    public static final OptionValue<String> LINUX_RPM_LICENSE_TYPE = stringOption(\"linux-rpm-license-type\")\n+            .valuePattern(\"license type\")\n+            .scope(nativeBundling()).create();\n+\n+    public static final OptionValue<String> LINUX_PACKAGE_DEPENDENCIES = stringOption(\"linux-package-deps\")\n+            .valuePattern(\"package-dep-string\")\n+            .scope(nativeBundling()).create();\n+\n+    public static final OptionValue<LauncherShortcut> LINUX_SHORTCUT_HINT = launcherShortcutOption(\"linux-shortcut\")\n+            .scope(nativeBundling())\n+            .inScope(LauncherProperty.VALUE)\n+            .create();\n+\n+    public static final OptionValue<String> LINUX_MENU_GROUP = stringOption(\"linux-menu-group\")\n+            .valuePattern(\"menu-group-name\")\n+            .scope(nativeBundling()).create();\n+\n+    \/\/\n+    \/\/ MacOS-specific\n+    \/\/\n+\n+    public static final OptionValue<List<Path>> MAC_DMG_CONTENT = pathOption(\"mac-dmg-content\")\n+            .valuePattern(\"additional content path\")\n+            \/\/.toArray(pathSeparator())\n+            .tokenizer(\",\")\n+            .createArray(toList());\n+\n+    public static final OptionValue<Boolean> MAC_SIGN = booleanOption(\"mac-sign\").scope(MAC_SIGNING).addAliases(\"s\").create();\n+\n+    public static final OptionValue<Boolean> MAC_APP_STORE = booleanOption(\"mac-app-store\")\n+            \/\/.scope(MAC_SIGNING) \/\/ TODO: --mac-app-store should be applicable to app image signing operation because it redefines signing key\n+            .create();\n+\n+    public static final OptionValue<String> MAC_APP_CATEGORY = stringOption(\"mac-app-category\").create();\n+\n+    public static final OptionValue<String> MAC_BUNDLE_NAME = stringOption(\"mac-package-name\")\n+            .valuePattern(\"package name\")\n+            .create();\n+\n+    public static final OptionValue<String> MAC_BUNDLE_IDENTIFIER = stringOption(\"mac-package-identifier\")\n+            .valuePattern(\"package identifier\")\n+            .create();\n+\n+    public static final OptionValue<String> MAC_BUNDLE_SIGNING_PREFIX = stringOption(\"mac-package-signing-prefix\").scope(MAC_SIGNING).create();\n+\n+    public static final OptionValue<String> MAC_SIGNING_KEY_NAME = stringOption(\"mac-signing-key-user-name\").scope(MAC_SIGNING).create();\n+\n+    public static final OptionValue<String> MAC_APP_IMAGE_SIGN_IDENTITY = stringOption(\"mac-app-image-sign-identity\").scope(MAC_SIGNING).create();\n+\n+    public static final OptionValue<String> MAC_INSTALLER_SIGN_IDENTITY = stringOption(\"mac-installer-sign-identity\")\n+            .scope(CREATE_MAC_PKG).inScope(NOT_BUILDING_APP_IMAGE)\n+            .create();\n+\n+    public static final OptionValue<Path> MAC_SIGNING_KEYCHAIN = pathOption(\"mac-signing-keychain\")\n+            .valuePattern(\"keychain name\")\n+            .scope(MAC_SIGNING).create();\n+\n+    public static final OptionValue<Path> MAC_ENTITLEMENTS = fileOption(\"mac-entitlements\")\n+            .valuePattern(\"file path\")\n+            .scope(MAC_SIGNING).create();\n+\n+    \/\/\n+    \/\/ Windows-specific\n+    \/\/\n+\n+    public static final OptionValue<String> WIN_HELP_URL = urlOption(\"win-help-url\").scope(nativeBundling()).create();\n+\n+    public static final OptionValue<String> WIN_UPDATE_URL = urlOption(\"win-update-url\").scope(nativeBundling()).create();\n+\n+    public static final OptionValue<LauncherShortcut> WIN_MENU_HINT = launcherShortcutOption(\"win-menu\")\n+            .scope(nativeBundling())\n+            .inScope(LauncherProperty.VALUE)\n+            .create();\n+\n+    public static final OptionValue<String> WIN_MENU_GROUP = stringOption(\"win-menu-group\")\n+            .valuePattern(\"menu group name\")\n+            .scope(nativeBundling()).create();\n+\n+    public static final OptionValue<LauncherShortcut> WIN_SHORTCUT_HINT = launcherShortcutOption(\"win-shortcut\")\n+            .scope(nativeBundling())\n+            .inScope(LauncherProperty.VALUE)\n+            .create();\n+\n+    public static final OptionValue<Boolean> WIN_SHORTCUT_PROMPT = booleanOption(\"win-shortcut-prompt\").scope(nativeBundling()).create();\n+\n+    public static final OptionValue<Boolean> WIN_PER_USER_INSTALLATION = booleanOption(\"win-per-user-install\").scope(nativeBundling()).create();\n+\n+    public static final OptionValue<Boolean> WIN_INSTALLDIR_CHOOSER = booleanOption(\"win-dir-chooser\").scope(nativeBundling()).create();\n+\n+    public static final OptionValue<UUID> WIN_UPGRADE_UUID = uuidOption(\"win-upgrade-uuid\").scope(nativeBundling()).create();\n+\n+    public static final OptionValue<Boolean> WIN_CONSOLE_HINT = booleanOption(\"win-console\")\n+            .outOfScope(NOT_BUILDING_APP_IMAGE)\n+            .inScope(LauncherProperty.VALUE)\n+            .create();\n+\n+    \/\/\n+    \/\/ Synthetic options\n+    \/\/\n+\n+    \/**\n+     * Processed additional launcher property files.\n+     * <p>\n+     * Items in the list are in the order \"--add-launcher\" options appeared on the\n+     * command line. Every item in the list has {@link #SOURCE_PROPERY_FILE} option\n+     * with the value set to the source property file and {@link #NAME} option with\n+     * the value set to the additional launcher name.\n+     *\/\n+    public static final OptionValue<List<Options>> ADDITIONAL_LAUNCHERS = OptionValue.create();\n+\n+    \/**\n+     * Processed file association property files.\n+     * <p>\n+     * Items in the list are in the order \"--file-associations\" options appeared on\n+     * the command line. Every item in the list has {@link #SOURCE_PROPERY_FILE}\n+     * option with the value set to the source property file.\n+     *\/\n+    public static final OptionValue<List<Options>> FILE_ASSOCIATIONS = OptionValue.create();\n+\n+    public static final OptionValue<Path> SOURCE_PROPERY_FILE = OptionValue.create();\n+\n+    public static final OptionValue<BundlingOperationDescriptor> BUNDLING_OPERATION_DESCRIPTOR = OptionValue.create();\n+\n+    \/**\n+     * Returns options configuring a launcher.\n+     *\n+     * @return the options configuring a launcher\n+     *\/\n+    static Set<Option> launcherOptions() {\n+        return options().stream().filter(option -> {\n+            return option.spec().scope().stream().anyMatch(LauncherProperty.class::isInstance);\n+        }).collect(toUnmodifiableSet());\n+    }\n+\n+    \/**\n+     * Returns public and package-private options with option specs defined in\n+     * {@link StandardOption} class.\n+     *\n+     * @return public and package-private options defined in\n+     *         {@link StandardOption} class\n+     *\/\n+    static Set<Option> options() {\n+        return Utils.getOptionsWithSpecs(StandardOption.class).map(OptionValue::getOption).collect(toUnmodifiableSet());\n+    }\n+\n+    \/**\n+     * Returns a {@link Predicate} that returns {@code true} if the given option\n+     * spec denotes an option supported on all platforms.\n+     *\n+     * @return the predicate\n+     *\/\n+    static Predicate<OptionSpec<?>> sharedOption() {\n+        return optionSpec -> {\n+            final var optionSupportedOSs = StandardBundlingOperation.narrow(optionSpec.scope().stream())\n+                    .map(StandardBundlingOperation::os).collect(toUnmodifiableSet());\n+            return optionSupportedOSs.equals(SUPPORTED_OS);\n+        };\n+    }\n+\n+    \/**\n+     * Returns a {@link Predicate} that returns {@code true} if the given option\n+     * spec denotes an option supported on the given platform.\n+     *\n+     * @param os the platform\n+     * @return the predicate\n+     *\/\n+    static Predicate<OptionSpec<?>> platformOption(OperatingSystem os) {\n+        Objects.requireNonNull(os);\n+        return optionSpec -> {\n+            return StandardBundlingOperation.narrow(optionSpec.scope().stream()).filter(op -> {\n+                return op.os().equals(os);\n+            }).findFirst().isPresent();\n+        };\n+    }\n+\n+    static Consumer<OptionSpecBuilder<String>> stringOptionMutator() {\n+        return builder -> {\n+            builder.converter(identityConv());\n+        };\n+    }\n+\n+    static Consumer<OptionSpecBuilder<Path>> pathOptionMutator() {\n+        return builder -> {\n+            builder.converter(pathConv())\n+            .mutate(createOptionSpecBuilderMutator((b, context) -> {\n+                context.asFileSource().ifPresent(propertyFile -> {\n+                    b.converterExceptionFactory(forMessageWithOptionValueAndName(propertyFile));\n+                    b.converterExceptionFormatString(\"error.properties-paramater-not-path\");\n+                });\n+            }))\n+            .converterExceptionFactory(ERROR_WITH_VALUE_AND_OPTION_NAME)\n+            .converterExceptionFormatString(\"error.paramater-not-path\");\n+        };\n+    }\n+\n+    static Consumer<OptionSpecBuilder<Path>> fileOptionMutator() {\n+        return builder -> {\n+            builder.mutate(pathOptionMutator())\n+            .mutate(createOptionSpecBuilderMutator((b, context) -> {\n+                context.asFileSource().ifPresent(propertyFile -> {\n+                    b.validatorExceptionFactory(forMessageWithOptionValueAndName(propertyFile));\n+                    b.validatorExceptionFormatString(\"error.properties-paramater-not-file\");\n+                });\n+            }))\n+            .validator(StandardValidator.IS_EXISTENT_NOT_DIRECTORY)\n+            .validatorExceptionFactory(ERROR_WITH_VALUE_AND_OPTION_NAME)\n+            .validatorExceptionFormatString(\"error.paramater-not-file\");\n+        };\n+    }\n+\n+    static Consumer<OptionSpecBuilder<Path>> directoryOptionMutator() {\n+        return builder -> {\n+            builder.mutate(pathOptionMutator())\n+            .validator(StandardValidator.IS_DIRECTORY)\n+            .validatorExceptionFactory(ERROR_WITH_VALUE_AND_OPTION_NAME)\n+            .validatorExceptionFormatString(\"error.paramater-not-directory\");\n+        };\n+    }\n+\n+    static Consumer<OptionSpecBuilder<Boolean>> booleanOptionMutator() {\n+        return builder -> {\n+            builder.mutate(createOptionSpecBuilderMutator((b, context) -> {\n+                context.asFileSource().ifPresent(propertyFile -> {\n+                    b.converter(booleanConv());\n+                });\n+            })).valuePattern(null).defaultValue(Boolean.FALSE);\n+        };\n+    }\n+\n+    static Consumer<OptionSpecBuilder<LauncherShortcut>> launcherShortcutOptionMutator() {\n+        return builder -> {\n+            builder.mutate(createOptionSpecBuilderMutator((b, context) -> {\n+                context.asFileSource().ifPresent(propertyFile -> {\n+                    b.converter(addLauncherShortcutConv()).defaultOptionalValue(null);\n+                    b.converterExceptionFactory(forMessageWithOptionValueAndName(propertyFile));\n+                    b.converterExceptionFormatString(\"error.properties-paramater-not-launcher-shortcut-dir\");\n+                });\n+            }))\n+            .converterExceptionFactory(ERROR_WITH_VALUE_AND_OPTION_NAME)\n+\/\/            .converterExceptionFormatString(\"error.paramater-not-launcher-shortcut-dir\")\n+            .converterExceptionFormatString(\"error.invalid-option-value\")\n+            .converter(mainLauncherShortcutConv())\n+            .defaultOptionalValue(new LauncherShortcut(LauncherShortcutStartupDirectory.DEFAULT))\n+            .valuePattern(\"shortcut startup directory\");\n+        };\n+    }\n+\n+    private static <T> OptionSpecBuilder<T> option(String name, Class<? extends T> valueType) {\n+        return OptionSpecBuilder.<T>create(valueType)\n+                .name(Objects.requireNonNull(name))\n+                .description(\"main.option.\" + name)\n+                .scope(fromOptionName(name))\n+                .scope(scope -> {\n+                    return SetBuilder.build(OptionScope.class)\n+                            .add(scope)\n+                            .add(BundlingOperationModifier.values())\n+                            .create();\n+                });\n+    }\n+\n+    private static OptionSpecBuilder<String> stringOption(String name) {\n+        return option(name, String.class).mutate(stringOptionMutator());\n+    }\n+\n+    private static OptionSpecBuilder<UUID> uuidOption(String name) {\n+        return option(name, UUID.class)\n+                .converter(uuidConv())\n+                .converterExceptionFactory(ERROR_WITH_VALUE_AND_OPTION_NAME)\n+                .converterExceptionFormatString(\"error.paramater-not-uuid\");\n+    }\n+\n+    private static OptionSpecBuilder<Path> pathOption(String name) {\n+        return option(name, Path.class).mutate(pathOptionMutator());\n+    }\n+\n+    private static OptionSpecBuilder<Path> fileOption(String name) {\n+        return option(name, Path.class)\n+                .valuePattern(\"file path\")\n+                .mutate(fileOptionMutator());\n+    }\n+\n+    private static OptionSpecBuilder<Path> directoryOption(String name) {\n+        return option(name, Path.class)\n+                .valuePattern(\"directory path\")\n+                .mutate(directoryOptionMutator());\n+    }\n+\n+    private static OptionSpecBuilder<String> urlOption(String name) {\n+        return stringOption(name)\n+                .valuePattern(\"url\")\n+                .validator(StandardValidator.IS_URL)\n+                .validatorExceptionFactory(ERROR_WITH_VALUE_AND_OPTION_NAME)\n+                .validatorExceptionFormatString(\"error.paramater-not-url\");\n+    }\n+\n+    private static OptionSpecBuilder<Boolean> booleanOption(String name) {\n+        return option(name, Boolean.class).mutate(booleanOptionMutator());\n+    }\n+\n+    private static OptionSpecBuilder<LauncherShortcut> launcherShortcutOption(String name) {\n+        return option(name, LauncherShortcut.class).mutate(launcherShortcutOptionMutator());\n+    }\n+\n+    private static OptionSpecBuilder<Boolean> auxilaryOption(String name) {\n+        return booleanOption(name)\n+                .scope(StandardBundlingOperation.values())\n+                .inScope(NOT_BUILDING_APP_IMAGE);\n+    }\n+\n+    private static OptionSpecBuilder<String> escapedStringListOption(String name) {\n+        return stringOption(name).tokenizer(str -> {\n+            return Arguments.getArgumentList(str).toArray(String[]::new);\n+        }).converter(Arguments::unquoteIfNeeded);\n+    }\n+\n+    private static UnaryOperator<Set<OptionScope>> nativeBundling() {\n+        return scope -> {\n+            return new SetBuilder<OptionScope>()\n+                    .set(scope)\n+                    .remove(new SetBuilder<OptionScope>().set(StandardBundlingOperation.values()).remove(CREATE_NATIVE).create())\n+                    .create();\n+        };\n+    }\n+\n+    private static OptionValue<AdditionalLauncher[]> createAddLauncherOption(String name) {\n+        OptionValueConverter<Path> propertyFileConverter = fileOption(name)\n+                .create().getSpec().converter().orElseThrow();\n+\n+        return option(name, AdditionalLauncher.class)\n+                .valuePattern(\"<launcher name>=<file path>\")\n+                .description(\"main.option.add-launcher\" + resourceKeySuffix(OperatingSystem.current()))\n+                .mutate(createOptionSpecBuilderMutator((b, context) -> {\n+                    b.description(\"main.option.add-launcher\" + resourceKeySuffix(context.os()));\n+                }))\n+                .outOfScope(NOT_BUILDING_APP_IMAGE)\n+                .converterExceptionFormatString(\"\")\n+                .converterExceptionFactory((optionName, optionValue, formatString, cause) -> {\n+                    final var theCause = cause.orElseThrow();\n+                    if (theCause instanceof AddLauncherSyntaxException) {\n+\/\/                        return ERROR_WITH_VALUE_AND_OPTION_NAME.create(optionName,\n+\/\/                                optionValue, \"error.paramater-add-launcher-malformed\", cause);\n+                        return ERROR_WITHOUT_CONTEXT.create(optionName,\n+                                optionValue, \"ERR_NoAddLauncherName\", cause);\n+                    } else {\n+                        return (RuntimeException)theCause;\n+                    }\n+                }).converter(value -> {\n+                    var components = value.split(\"=\", 2);\n+                    if (components.length != 2) {\n+                        throw new AddLauncherSyntaxException();\n+                    }\n+\n+                    final var launcherName = components[0];\n+\n+                    if (!StandardValidator.IS_NAME_VALID.test(launcherName)) {\n+                        throw new AddLauncherInvalidNameException(I18N.format(\"ERR_InvalidSLName\", launcherName));\n+                    }\n+\n+                    final Path propertyFile;\n+                    try {\n+                        propertyFile = propertyFileConverter.convert(OptionName.of(name),\n+                                StringToken.of(value, components[1])).orElseThrow();\n+                    } catch (JPackageException ex) {\n+                        throw new AddLauncherInvalidPropertyFileException(I18N.format(\n+                                \"error.paramater-add-launcher-not-file\", components[1], launcherName));\n+                    }\n+\n+                    return new AdditionalLauncher(launcherName, propertyFile);\n+                }).defaultArrayValue(new AdditionalLauncher[0]).createArray();\n+    }\n+\n+    private static String resourceKeySuffix(OperatingSystem os) {\n+        switch (os) {\n+            case LINUX -> {\n+                return \".linux\";\n+            }\n+            case MACOS -> {\n+                return \".mac\";\n+            }\n+            case WINDOWS -> {\n+                return \".win\";\n+            }\n+            default -> {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+    }\n+\n+\n+    static class AddLauncherIllegalArgumentException extends IllegalArgumentException {\n+\n+        AddLauncherIllegalArgumentException(String message) {\n+            super(message);\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+\n+    static final class AddLauncherInvalidNameException extends AddLauncherIllegalArgumentException {\n+\n+        AddLauncherInvalidNameException(String message) {\n+            super(message);\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+\n+    static final class AddLauncherInvalidPropertyFileException extends AddLauncherIllegalArgumentException {\n+\n+        AddLauncherInvalidPropertyFileException(String msg) {\n+            super(msg);\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+\n+    private static final class AddLauncherSyntaxException extends IllegalArgumentException {\n+\n+        AddLauncherSyntaxException() {\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+\n+    private static final class Arguments {\n+\n+        \/\/\n+        \/\/ This is a an extract copied from jdk.jpackage.internal.Arguments class with the following changes:\n+        \/\/  - Don't call unquoteIfNeeded() from getArgumentList().\n+        \/\/  - Edit a comment in getArgumentList().\n+        \/\/  - Insert Objects.requireNonNull() calls.\n+        \/\/  - throw IllegalArgumentException from unquoteIfNeeded() if the input string is empty.\n+        \/\/\n+\n+        \/\/ regexp for parsing args (for example, for additional launchers)\n+        private static Pattern pattern = Pattern.compile(\n+              \"(?:(?:([\\\"'])(?:\\\\\\\\\\\\1|.)*?(?:\\\\1|$))|(?:\\\\\\\\[\\\"'\\\\s]|[^\\\\s]))++\");\n+\n+        static List<String> getArgumentList(String inputString) {\n+            Objects.requireNonNull(inputString);\n+\n+            List<String> list = new ArrayList<>();\n+            if (inputString.isEmpty()) {\n+                 return list;\n+            }\n+\n+            \/\/ The \"pattern\" regexp attempts to abide to the rule that\n+            \/\/ strings are delimited by whitespace unless surrounded by\n+            \/\/ quotes, then it is anything (including spaces) in the quotes.\n+            Matcher m = pattern.matcher(inputString);\n+            while (m.find()) {\n+                String s = inputString.substring(m.start(), m.end()).trim();\n+                \/\/ Ensure we do not have an empty string. trim() will take care of\n+                \/\/ whitespace only strings. The regex preserves quotes and escaped\n+                \/\/ chars.\n+                if (!s.isEmpty()) {\n+                    list.add(s);\n+                }\n+            }\n+            return list;\n+        }\n+\n+        static String unquoteIfNeeded(String in) {\n+            Objects.requireNonNull(in);\n+            if (in.isEmpty()) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            \/\/ Use code points to preserve non-ASCII chars\n+            StringBuilder sb = new StringBuilder();\n+            int codeLen = in.codePointCount(0, in.length());\n+            int quoteChar = -1;\n+            for (int i = 0; i < codeLen; i++) {\n+                int code = in.codePointAt(i);\n+                if (code == '\"' || code == '\\'') {\n+                    \/\/ If quote is escaped make sure to copy it\n+                    if (i > 0 && in.codePointAt(i - 1) == '\\\\') {\n+                        sb.deleteCharAt(sb.length() - 1);\n+                        sb.appendCodePoint(code);\n+                        continue;\n+                    }\n+                    if (quoteChar != -1) {\n+                        if (code == quoteChar) {\n+                            \/\/ close quote, skip char\n+                            quoteChar = -1;\n+                        } else {\n+                            sb.appendCodePoint(code);\n+                        }\n+                    } else {\n+                        \/\/ opening quote, skip char\n+                        quoteChar = code;\n+                    }\n+                } else {\n+                    sb.appendCodePoint(code);\n+                }\n+            }\n+            return sb.toString();\n+        }\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/StandardOption.java","additions":808,"deletions":0,"binary":false,"changes":808,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import jdk.internal.util.OperatingSystem;\n+\n+\/**\n+ * The standard context for parsing command line options.\n+ *\/\n+record StandardOptionContext(OperatingSystem os, OptionSource src) {\n+\n+    StandardOptionContext {\n+        Objects.requireNonNull(os);\n+        Objects.requireNonNull(src);\n+    }\n+\n+    StandardOptionContext(OperatingSystem os) {\n+        this(os, OptionSource.COMMAND_LINE);\n+    }\n+\n+    StandardOptionContext() {\n+        this(OperatingSystem.current());\n+    }\n+\n+    StandardOptionContext forFile(Path file) {\n+        return new StandardOptionContext(os, OptionSource.fromFile(file));\n+    }\n+\n+    Optional<Path> asFileSource() {\n+        return OptionSource.asFile(src);\n+    }\n+\n+    <T> OptionSpec<T> mapOptionSpec(OptionSpec<T> optionSpec) {\n+        return OptionSpecMapperOptionScope.mapOptionSpec(optionSpec, this);\n+    }\n+\n+    static <T> Consumer<OptionSpecBuilder<T>> createOptionSpecBuilderMutator(\n+            BiConsumer<OptionSpecBuilder<T>, StandardOptionContext> mutator) {\n+        return OptionSpecMapperOptionScope.createOptionSpecBuilderMutator(StandardOptionContext.class, mutator);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/StandardOptionContext.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import java.nio.file.Path;\n+import java.util.function.UnaryOperator;\n+import jdk.jpackage.internal.cli.OptionValueExceptionFactory.ArgumentsMapper;\n+import jdk.jpackage.internal.cli.OptionValueExceptionFactory.StandardArgumentsMapper;\n+import jdk.jpackage.internal.model.JPackageException;\n+\n+final class StandardOptionValueExceptionFactory {\n+\n+    static OptionValueExceptionFactory<JPackageException> forMessageWithOptionValue(Path propertyFile) {\n+        return forMessageWithOptionValue(appendPath(propertyFile)).printOptionPrefix(false).create();\n+    }\n+\n+    static OptionValueExceptionFactory<JPackageException> forMessageWithOptionValueAndName(Path propertyFile) {\n+        return forMessageWithOptionValueAndName(appendPath(propertyFile)).printOptionPrefix(false).create();\n+    }\n+\n+    static OptionValueExceptionFactory<JPackageException> forFixedMessage(Path propertyFile) {\n+        return forFixedMessage(appendPath(propertyFile)).printOptionPrefix(false).create();\n+    }\n+\n+    private StandardOptionValueExceptionFactory() {\n+    }\n+\n+    private static UnaryOperator<ArgumentsMapper> appendPath(Path path) {\n+        return argumentsMapper -> {\n+            return ArgumentsMapper.appendArguments(argumentsMapper, path);\n+        };\n+    }\n+\n+    private static OptionValueExceptionFactory.Builder<JPackageException> forMessageWithOptionValue(UnaryOperator<ArgumentsMapper> mapper) {\n+        return OptionValueExceptionFactory.build(JPackageException::new)\n+                .formatArgumentsTransformer(mapper.apply(StandardArgumentsMapper.VALUE));\n+    }\n+\n+    private static OptionValueExceptionFactory.Builder<JPackageException> forMessageWithOptionValueAndName(UnaryOperator<ArgumentsMapper> mapper) {\n+        return OptionValueExceptionFactory.build(JPackageException::new)\n+                .formatArgumentsTransformer(mapper.apply(StandardArgumentsMapper.VALUE_AND_NAME));\n+    }\n+\n+    private static OptionValueExceptionFactory.Builder<JPackageException> forFixedMessage(UnaryOperator<ArgumentsMapper> mapper) {\n+        return OptionValueExceptionFactory.build(JPackageException::new)\n+                .formatArgumentsTransformer(mapper.apply(StandardArgumentsMapper.NONE));\n+    }\n+\n+    static final OptionValueExceptionFactory<JPackageException> ERROR_WITH_VALUE =\n+            forMessageWithOptionValue(UnaryOperator.identity()).create();\n+\n+    static final OptionValueExceptionFactory<JPackageException> ERROR_WITHOUT_CONTEXT =\n+            forFixedMessage(UnaryOperator.identity()).create();\n+\n+    static final OptionValueExceptionFactory<JPackageException> ERROR_WITH_VALUE_AND_OPTION_NAME =\n+            forMessageWithOptionValueAndName(UnaryOperator.identity()).create();\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/StandardOptionValueExceptionFactory.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import java.io.IOException;\n+import java.lang.constant.ClassDesc;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.DirectoryNotEmptyException;\n+import java.nio.file.Files;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.NotDirectoryException;\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import jdk.jpackage.internal.cli.Validator.ValidatingConsumerException;\n+\n+final class StandardValidator {\n+\n+    private StandardValidator() {\n+    }\n+\n+    static final Predicate<Path> IS_DIRECTORY = Files::isDirectory;\n+\n+    static final Predicate<Path> IS_EXISTENT_NOT_DIRECTORY = path -> {\n+        return Files.exists(path) && !Files.isDirectory(path);\n+    };\n+\n+    static final Predicate<Path> IS_DIRECTORY_OR_NON_EXISTENT = path -> {\n+        return !Files.exists(path) || Files.isDirectory(path);\n+    };\n+\n+    static final Consumer<Path> IS_DIRECTORY_EMPTY_OR_NON_EXISTENT = path -> {\n+        if (Files.exists(path)) {\n+            if (Files.isDirectory(path)) {\n+                try (var dirContents = Files.list(path)) {\n+                    if (dirContents.findAny().isPresent()) {\n+                        throw new ValidatingConsumerException(new DirectoryNotEmptyException(path.toString()));\n+                    }\n+                } catch (IOException ex) {\n+                    throw new ValidatingConsumerException(new DirectoryListingIOException(ex));\n+                }\n+            } else {\n+                throw new ValidatingConsumerException(new NotDirectoryException(path.toString()));\n+            }\n+        }\n+    };\n+\n+    static final Consumer<String> IS_URL = url -> {\n+        try {\n+            new URI(url);\n+        } catch (URISyntaxException ex) {\n+            throw new ValidatingConsumerException(ex);\n+        }\n+    };\n+\n+    static final Consumer<String> IS_CLASSNAME = str -> {\n+        try {\n+            ClassDesc.of(str);\n+        } catch (IllegalArgumentException ex) {\n+            throw new ValidatingConsumerException(ex);\n+        }\n+    };\n+\n+    \/\/ Copied from DeployParams.validateName()\n+    static final Predicate<String> IS_NAME_VALID = s -> {\n+        if (s.length() == 0 || s.indexOf('\\\\') != -1 || s.indexOf('\/') != -1 || s.isBlank() || !s.equals(s.trim())) {\n+            return false;\n+        }\n+\n+        try {\n+            \/\/ name must be valid path element for this file system\n+            Path p = Path.of(s);\n+            \/\/ and it must be a single name element in a path\n+            if (p.getNameCount() != 1) {\n+                return false;\n+            }\n+        } catch (InvalidPathException ipe) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < s.length(); i++) {\n+            char a = s.charAt(i);\n+            \/\/ We check for ASCII codes first which we accept. If check fails,\n+            \/\/ check if it is acceptable extended ASCII or unicode character.\n+            if (a < ' ' || a > '~') {\n+                \/\/ Accept anything else including special chars like copyright\n+                \/\/ symbols. Note: space will be included by ASCII check above,\n+                \/\/ but other whitespace like tabs or new line will be rejected.\n+                if (Character.isISOControl(a)|| Character.isWhitespace(a)) {\n+                    return false;\n+                }\n+            } else if (a == '\"' || a == '%') {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    };\n+\n+\n+    static final class DirectoryListingIOException extends RuntimeException{\n+\n+        DirectoryListingIOException(IOException cause) {\n+            super(Objects.requireNonNull(cause));\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/StandardValidator.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n+import java.util.UUID;\n+import jdk.jpackage.internal.model.LauncherShortcut;\n+import jdk.jpackage.internal.model.ParseUtils;\n+\n+\n+final class StandardValueConverter {\n+\n+    private StandardValueConverter() {\n+    }\n+\n+    static ValueConverter<String> identityConv() {\n+        return IDENTITY_CONV;\n+    }\n+\n+    static ValueConverter<Path> pathConv() {\n+        return PATH_CONV;\n+    }\n+\n+    static ValueConverter<UUID> uuidConv() {\n+        return UUID_CONV;\n+    }\n+\n+    static ValueConverter<Boolean> booleanConv() {\n+        return BOOLEAN_CONV;\n+    }\n+\n+    static ValueConverter<LauncherShortcut> mainLauncherShortcutConv() {\n+        return MAIN_LAUNCHER_SHORTCUT_CONV;\n+    }\n+\n+    static ValueConverter<LauncherShortcut> addLauncherShortcutConv() {\n+        return ADD_LAUNCHER_SHORTCUT_CONV;\n+    }\n+\n+    private static final ValueConverter<String> IDENTITY_CONV = ValueConverter.create(x -> x, String.class);\n+\n+    private static final ValueConverter<Path> PATH_CONV = ValueConverter.create(str -> {\n+        try {\n+            return Path.of(str);\n+        } catch (InvalidPathException ex) {\n+            throw new IllegalArgumentException(ex);\n+        }\n+    }, Path.class);\n+\n+    private static final ValueConverter<UUID> UUID_CONV = ValueConverter.create(UUID::fromString, UUID.class);\n+\n+    private static final ValueConverter<Boolean> BOOLEAN_CONV = ValueConverter.create(Boolean::valueOf, Boolean.class);\n+\n+    private static final ValueConverter<LauncherShortcut> MAIN_LAUNCHER_SHORTCUT_CONV = ValueConverter.create(\n+            ParseUtils::parseLauncherShortcutForMainLauncher, LauncherShortcut.class);\n+\n+    private static final ValueConverter<LauncherShortcut> ADD_LAUNCHER_SHORTCUT_CONV = ValueConverter.create(\n+            ParseUtils::parseLauncherShortcutForAddLauncher, LauncherShortcut.class);\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/StandardValueConverter.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import java.util.Objects;\n+\n+\/**\n+ * A token of a tokenized string.\n+ *\n+ * @param tokenizedString the tokenized string from which this token was extracted\n+ * @param value           the value of this token\n+ *\/\n+record StringToken(String tokenizedString, String value) {\n+    StringToken {\n+        Objects.requireNonNull(tokenizedString);\n+        Objects.requireNonNull(value);\n+\n+        if (!tokenizedString.contains(value)) {\n+            throw new IllegalArgumentException(String.format(\n+                    \"String token [%s] must be a substring of the tokenized string [%s]\", value, tokenizedString));\n+        }\n+    }\n+\n+    StringToken(String value) {\n+        this(value, value);\n+    }\n+\n+    static StringToken of(String value) {\n+        return new StringToken(value);\n+    }\n+\n+    static StringToken of(String tokenizedString, String value) {\n+        return new StringToken(tokenizedString, value);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/StringToken.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n+\n+import java.lang.reflect.Modifier;\n+import java.util.Objects;\n+import java.util.function.IntPredicate;\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.model.BundlingEnvironment;\n+\n+final class Utils {\n+\n+    private Utils() {\n+    }\n+\n+    \/**\n+     * Returns stream of option values with option specs defined in the specified\n+     * class.\n+     * <p>\n+     * The method uses reflection to get public and package private fields of type\n+     * {@link OptionValue} and filters those associated with {@link OptionSpec}\n+     * instances.\n+     *\n+     * @param c the target class\n+     * @return stream of option values with option specs defined in the specified\n+     *         class\n+     *\/\n+    static Stream<? extends OptionValue<?>> getOptionsWithSpecs(Class<?> c) {\n+        return Stream.of(c.getDeclaredFields()).filter(f -> {\n+            return Modifier.isStatic(f.getModifiers());\n+        }).filter(f -> {\n+            if (Modifier.isPublic(f.getModifiers())) {\n+                \/\/ Public is OK.\n+                return true;\n+            } else {\n+                \/\/ Package-private is OK.\n+                return Stream.<IntPredicate>of(Modifier::isPublic, Modifier::isPrivate, Modifier::isProtected).map(p -> {\n+                    return p.test(f.getModifiers());\n+                }).allMatch(v -> !v);\n+            }\n+        }).map(f -> {\n+            f.setAccessible(true);\n+            return toFunction(f::get).apply(null);\n+        }).map(v -> {\n+            OptionValue<?> result;\n+            if (v instanceof OptionValue<?> ov && ov.asOption().isPresent()) {\n+                result = ov;\n+            } else {\n+                result = null;\n+            }\n+            return result;\n+        }).filter(Objects::nonNull);\n+    }\n+\n+    static JOptSimpleOptionsBuilder buildParser(OperatingSystem os, BundlingEnvironment bundlingEnv) {\n+        return new JOptSimpleOptionsBuilder()\n+                .options(StandardOption.options())\n+                .optionSpecMapper(OptionsProcessor.optionSpecMapper(os, bundlingEnv))\n+                .jOptSimpleParserErrorHandler(errDesc -> {\n+                    final String formatId;\n+                    switch (errDesc.type()) {\n+                        case UNRECOGNIZED_OPTION -> {\n+                            formatId = \"ERR_InvalidOption\";\n+                        }\n+                        case OPTION_MISSING_REQUIRED_ARGUMENT -> {\n+                            formatId = \"ERR_InvalidOption\";\n+                        }\n+                        default -> {\n+                            throw new AssertionError();\n+                        }\n+                    }\n+                    return new ParseException(I18N.format(formatId, errDesc.optionName().formatForCommandLine()));\n+                });\n+    }\n+\n+    static final class ParseException extends RuntimeException {\n+\n+        ParseException(String msg) {\n+            super(msg);\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/Utils.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,265 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+\n+@FunctionalInterface\n+interface Validator<T, U extends Exception> {\n+\n+    List<U> validate(OptionName optionName, ParsedValue<T> optionValue);\n+\n+    default Validator<T, ? extends Exception> andThen(Validator<T, ? extends Exception> after) {\n+        return reduce(this, after);\n+    }\n+\n+    \/**\n+     * Thrown to indicate that the given value didn't pass validation.\n+     *\/\n+    static final class ValidatingConsumerException extends RuntimeException{\n+\n+        ValidatingConsumerException(String msg, Exception cause) {\n+            super(msg, Objects.requireNonNull(cause));\n+        }\n+\n+        ValidatingConsumerException(Throwable cause) {\n+            super(Objects.requireNonNull(cause));\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+\n+    \/**\n+     * Thrown to indicate an error in the normal execution of a validator.\n+     *\/\n+    static final class ValidatorException extends RuntimeException {\n+\n+        private ValidatorException(Exception cause) {\n+            super(cause);\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+\n+    sealed interface ParsedValue<T> {\n+        StringToken sourceToken();\n+        T value();\n+\n+        static <T> ParsedValue<T> create(T value, StringToken sourceToken) {\n+            return new Details.DefaultParsedValue<>(value, sourceToken);\n+        }\n+    }\n+\n+\n+    static <T, U extends Exception> Builder<T, U> build() {\n+        return new Builder<>();\n+    }\n+\n+\n+    static final class Builder<T, U extends Exception> {\n+\n+        Validator<T, U> create() {\n+            return new Details.ScalarValidator<>(\n+                    Optional.ofNullable(predicate),\n+                    Optional.ofNullable(consumer),\n+                    formatString().orElseGet(() -> {\n+                        if (exceptionFactory == null) {\n+                            return \"\";\n+                        } else {\n+                            return null;\n+                        }\n+                    }),\n+                    exceptionFactory().orElseGet(() -> {\n+                        if (formatString == null) {\n+                            return OptionValueExceptionFactory.unreachable();\n+                        } else {\n+                            return null;\n+                        }\n+                    }));\n+        }\n+\n+        private Builder() {\n+        }\n+\n+        Builder(Builder<T, U> other) {\n+            predicate = other.predicate;\n+            consumer = other.consumer;\n+            formatString = other.formatString;\n+            exceptionFactory = other.exceptionFactory;\n+        }\n+\n+        Builder<T, U> copy() {\n+            return new Builder<>(this);\n+        }\n+\n+        Builder<T, U> predicate(Predicate<T> v) {\n+            consumer = null;\n+            predicate = v;\n+            return this;\n+        }\n+\n+        Builder<T, U> consumer(Consumer<T> v) {\n+            predicate = null;\n+            consumer = v;\n+            return this;\n+        }\n+\n+        Builder<T, U> formatString(String v) {\n+            formatString = v;\n+            return this;\n+        }\n+\n+        Builder<T, U> exceptionFactory(OptionValueExceptionFactory<? extends U> v) {\n+            exceptionFactory = v;\n+            return this;\n+        }\n+\n+        Builder<T, U> mutate(Consumer<Builder<T, U>> mutator) {\n+            mutator.accept(this);\n+            return this;\n+        }\n+\n+        Optional<Predicate<T>> predicate() {\n+            return Optional.ofNullable(predicate);\n+        }\n+\n+        Optional<Consumer<T>> consumer() {\n+            return Optional.ofNullable(consumer);\n+        }\n+\n+        boolean hasValidatingMethod() {\n+            return predicate().isPresent() || consumer().isPresent();\n+        }\n+\n+        Optional<String> formatString() {\n+            return Optional.ofNullable(formatString);\n+        }\n+\n+        Optional<OptionValueExceptionFactory<? extends U>> exceptionFactory() {\n+            return Optional.ofNullable(exceptionFactory);\n+        }\n+\n+        private Predicate<T> predicate;\n+        private Consumer<T> consumer;\n+        private String formatString;\n+        private OptionValueExceptionFactory<? extends U> exceptionFactory;\n+    }\n+\n+\n+    static final class Details {\n+\n+        private Details() {\n+        }\n+\n+        private record ScalarValidator<T, U extends Exception>(Optional<Predicate<T>> predicate, Optional<Consumer<T>> consumer,\n+                String formatString, OptionValueExceptionFactory<? extends U> exceptionFactory) implements Validator<T, U> {\n+\n+            ScalarValidator {\n+                Objects.requireNonNull(predicate);\n+                Objects.requireNonNull(consumer);\n+                if (predicate.isEmpty() == consumer.isEmpty()) {\n+                    throw new IllegalArgumentException(\"Either consumer or predicate must be non-empty\");\n+                }\n+                Objects.requireNonNull(formatString);\n+                Objects.requireNonNull(exceptionFactory);\n+            }\n+\n+            @Override\n+            public List<U> validate(OptionName optionName, ParsedValue<T> optionValue) {\n+                Objects.requireNonNull(optionName);\n+                Objects.requireNonNull(optionValue);\n+\n+                try {\n+                    return predicate.map(validator -> {\n+                        if (validator.test(optionValue.value())) {\n+                            return List.<U>of();\n+                        } else {\n+                            return List.of((U)exceptionFactory.create(\n+                                    optionName,\n+                                    optionValue.sourceToken(),\n+                                    formatString,\n+                                    Optional.empty()));\n+                        }\n+                    }).or(() -> {\n+                        return consumer.map(validator -> {\n+                            try {\n+                                validator.accept(optionValue.value());\n+                                return List.of();\n+                            } catch (RuntimeException ex) {\n+                                return handleException(optionName, optionValue, ex);\n+                            }\n+                        });\n+                    }).orElseThrow();\n+                } catch (Exception ex) {\n+                    throw new ValidatorException(ex);\n+                }\n+            }\n+\n+            private List<U> handleException(OptionName optionName,  ParsedValue<T> optionValue, RuntimeException ex) {\n+                if (ex instanceof ValidatingConsumerException) {\n+                    return List.of((U)exceptionFactory.create(\n+                            optionName,\n+                            optionValue.sourceToken(),\n+                            formatString,\n+                            Optional.of((Exception)ex.getCause())));\n+                } else if (ex instanceof IllegalArgumentException) {\n+                    return List.of((U)exceptionFactory.create(\n+                            optionName,\n+                            optionValue.sourceToken(),\n+                            formatString,\n+                            Optional.of(ex)));\n+                } else {\n+                    throw ex;\n+                }\n+            }\n+        }\n+\n+\n+        private record DefaultParsedValue<T>(T value, StringToken sourceToken) implements ParsedValue<T> {\n+            DefaultParsedValue {\n+                Objects.requireNonNull(sourceToken);\n+                Objects.requireNonNull(value);\n+            }\n+        }\n+    }\n+\n+    @SafeVarargs\n+    private static <T> Validator<T, ? extends Exception> reduce(Validator<T, ? extends Exception>... validators) {\n+        @SuppressWarnings(\"varargs\")\n+        var theValidators = List.of(validators);\n+        return (optionName, optionValue) -> {\n+            return theValidators.stream().map(validator -> {\n+                return validator.validate(optionName, optionValue);\n+            }).flatMap(Collection::stream).map(Exception.class::cast).toList();\n+        };\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/Validator.java","additions":265,"deletions":0,"binary":false,"changes":265,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+interface ValueConverter<T> {\n+\n+    \/**\n+     * Converts the given string value into a Java type.\n+     *\n+     * @param value the string to convert\n+     * @return the converted value\n+     * @throws IllegalArgumentException if the given string value can not be\n+     *                                  converted to an object of type {@link T}\n+     *\/\n+    T convert(String value) throws IllegalArgumentException;\n+\n+    \/**\n+     * Gives the class of the type of values this converter converts to.\n+     *\n+     * @return the target class for conversion\n+     *\/\n+    Class<? extends T> valueType();\n+\n+    static <T> ValueConverter<T> create(Function<String, T> mapper, Class<? extends T> type) {\n+        Objects.requireNonNull(mapper);\n+        Objects.requireNonNull(type);\n+\n+        return new ValueConverter<>() {\n+\n+            @Override\n+            public T convert(String value) {\n+                Objects.requireNonNull(value);\n+                return Objects.requireNonNull(mapper.apply(value));\n+            }\n+\n+            @Override\n+            public Class<? extends T> valueType() {\n+                return type;\n+            }\n+\n+        };\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/ValueConverter.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+\/**\n+ * A type with an option identifier.\n+ *\/\n+public sealed interface WithOptionIdentifier permits Option, OptionValue, WithOptionIdentifierStub {\n+\n+    OptionIdentifier id();\n+\n+    static WithOptionIdentifier stub(OptionIdentifier id) {\n+        return new WithOptionIdentifierStub(id);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/WithOptionIdentifier.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+import java.util.Objects;\n+\n+record WithOptionIdentifierStub(OptionIdentifier id) implements WithOptionIdentifier {\n+\n+    WithOptionIdentifierStub {\n+        Objects.requireNonNull(id);\n+    }\n+\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/WithOptionIdentifierStub.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal.model;\n-\n-import java.io.IOException;\n-import java.nio.file.Path;\n-\n-\n-\/**\n- * Creates a bundle from the given specification.\n- *\/\n-@FunctionalInterface\n-public interface BundleCreator<T extends BundleSpec> {\n-\n-    \/**\n-     * Creates a bundle from the given specification in the given directory.\n-     *\n-     * @param spec the bundle specification\n-     * @param dst the directory where to create the bundle\n-     * @throws PackagerException if packaging error occurs\n-     * @throws IOException if an I\/O error occurs\n-     *\/\n-    void create(T spec, Path dst) throws PackagerException, IOException;\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/BundleCreator.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -27,1 +27,4 @@\n-import java.util.Set;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n@@ -35,5 +38,5 @@\n-     * Returns the default bundling operation.\n-     * <p>\n-     * The returned value should be one of the elements in the collection returned by {@link #enabledOperations()} method.\n-     * @return the default bundling operation\n-     * @throws ConfigException in not a single bundling operation can be performed.\n+     * Returns descriptor of the default bundling operation if there is such or an\n+     * empty {@link Optional} instance otherwise.\n+     *\n+     * @return the default bundling operation or an empty {@link Optional} instance\n+     *         if there is no such\n@@ -41,1 +44,1 @@\n-    BundlingOperation defaultOperation() throws ConfigException;\n+    Optional<BundlingOperationDescriptor> defaultOperation();\n@@ -44,2 +47,8 @@\n-     * Returns supported bundling operations.\n-     * @return the supported bundling operations\n+     * Returns configuration errors or an empty list if there are no such errors for\n+     * the target bundling operation.\n+     *\n+     * @param op the descriptor of the target bundling operation\n+     * @return the list of configuration errors or an empty list if there are no\n+     *         such errors for the specified bundling operation\n+     * @throws NoSuchElementException if the specified descriptor denotes an\n+     *                                unsupported bundling operation\n@@ -47,10 +56,2 @@\n-    Set<BundlingOperation> supportedOperations();\n-\n-    \/**\n-     * Returns enabled bundling operations.\n-     * <p>\n-     * The returned value should be a subset of the set returned by {@link #supportedOperations()} method.\n-     * @return the enabled bundling operations\n-     *\/\n-    default Set<BundlingOperation> enabledOperations() {\n-        return supportedOperations();\n+    default Collection<? extends Exception> configurationErrors(BundlingOperationDescriptor op) {\n+        return List.of();\n@@ -58,8 +59,0 @@\n-\n-    \/**\n-     * Returns a bundle creator corresponding to the given bundling operation in this bundling environment.\n-     * @param op the bundling operation\n-     * @return bundle creator corresponding to the given bundling operation in this bundling environment\n-     * @throws IllegalArgumentException if the given bundling operation is not enabled in this bundling environment\n-     *\/\n-    BundleCreator<?> getBundleCreator(BundlingOperation op);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/BundlingEnvironment.java","additions":20,"deletions":27,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal.model;\n-\n-\/**\n- * Generic bundling operation.\n- * <p>\n- * Bundling operation is comprised of creating of {@link BundleSpec} instance\n- * and using it as an input for {@link BundleCreator#create()} method to create\n- * a bundle.\n- *\/\n-public interface BundlingOperation {\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/BundlingOperation.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.util.Objects;\n+import jdk.internal.util.OperatingSystem;\n+\n+\/**\n+ * Descriptor of a generic bundling operation.\n+ *\n+ * @param os         the target bundle platform\n+ * @param bundleType the target bundle type\n+ * @param verb       the action to be applied to the target bundle\n+ *\/\n+public record BundlingOperationDescriptor(OperatingSystem os, String bundleType, String verb) {\n+    public BundlingOperationDescriptor {\n+        Objects.requireNonNull(os);\n+        Objects.requireNonNull(bundleType);\n+        Objects.requireNonNull(verb);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return os.name() + \":\" + verb + \":\" + bundleType;\n+    }\n+\n+    public static BundlingOperationDescriptor valueOf(String str) {\n+        final var components = str.split(\":\");\n+        return new BundlingOperationDescriptor(OperatingSystem.valueOf(components[0]), components[1], components[2]);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/BundlingOperationDescriptor.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -49,1 +49,1 @@\n-public class ConfigException extends Exception {\n+public class ConfigException extends JPackageException {\n@@ -63,3 +63,2 @@\n-    public ConfigException(Throwable cause) {\n-        super(cause);\n-        this.advice = null;\n+    public ConfigException(String msg, Throwable cause) {\n+        this(msg, null, cause);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/ConfigException.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import static jdk.jpackage.internal.cli.StandardOption.APP_VERSION;\n+import static jdk.jpackage.internal.cli.StandardOption.NAME;\n+\n@@ -30,0 +33,5 @@\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.cli.Options;\n+import jdk.jpackage.internal.cli.StandardAppImageFileOption.AppImageFileOptionScope;\n+import jdk.jpackage.internal.cli.WithOptionIdentifier;\n@@ -35,1 +43,7 @@\n-public interface ExternalApplication {\n+public sealed interface ExternalApplication {\n+\n+    \/**\n+     * Returns the main launcher configured for the application.\n+     * @return the main launcher configured for the application\n+     *\/\n+    LauncherInfo mainLauncher();\n@@ -43,1 +57,1 @@\n-    List<LauncherInfo> getAddLaunchers();\n+    List<LauncherInfo> addLaunchers();\n@@ -49,1 +63,1 @@\n-    String getAppVersion();\n+    String appVersion();\n@@ -55,13 +69,1 @@\n-    String getAppName();\n-\n-    \/**\n-     * Returns main launcher name.\n-     * @return the main launcher name\n-     *\/\n-    String getLauncherName();\n-\n-    \/**\n-     * Returns main class name.\n-     * @return the main class name\n-     *\/\n-    String getMainClass();\n+    String appName();\n@@ -73,1 +75,1 @@\n-    Map<String, String> getExtra();\n+    Options extra();\n@@ -76,1 +78,1 @@\n-     * Additional launcher description.\n+     * Launcher description.\n@@ -78,6 +80,101 @@\n-    record LauncherInfo(String name, boolean service, Map<String, String> extra) {\n-        public LauncherInfo {\n-            Objects.requireNonNull(name);\n-            Objects.requireNonNull(extra);\n-            if (name.isBlank()) {\n-                throw new IllegalArgumentException();\n+    sealed interface LauncherInfo {\n+\n+        \/**\n+         * Gets the name of the launcher.\n+         * @return the name of the launcher\n+         *\/\n+        String name();\n+\n+        \/**\n+         * Gets optional properties of the launcher.\n+         * @return the optional properties of the launcher\n+         *\/\n+        Options extra();\n+\n+        \/**\n+         * Returns {@code Options} representation of this instance.\n+         * <p>\n+         * Return value contains the value of {@link #NAME} property merged with the\n+         * {@code Options} instance returned by the {@link #extra()} method.\n+         *\n+         * @return the {@code Options} representation of this instance\n+         *\/\n+        default Options asOptions() {\n+            return Options.concat(Options.of(Map.of(NAME, name())), extra());\n+        }\n+\n+        static LauncherInfo create(Options options) {\n+            return new Internal.DefaultLauncherInfo(options);\n+        }\n+    }\n+\n+    static ExternalApplication create(Options appOptions, List<Options> addLauncherOptions, OperatingSystem os) {\n+\n+        var launcherRecognizedOptions = AppImageFileOptionScope.LAUNCHER.options(os).map(WithOptionIdentifier::id).toList();\n+\n+        var recognizedOptions = Stream.concat(\n+                launcherRecognizedOptions.stream(),\n+                AppImageFileOptionScope.APP.options(os).map(WithOptionIdentifier::id)\n+        ).toList();\n+\n+        appOptions = appOptions.copyWith(recognizedOptions);\n+\n+        var addLaunchres = addLauncherOptions.stream().map(options -> {\n+            return options.copyWith(launcherRecognizedOptions);\n+        }).map(Internal.DefaultLauncherInfo::new).map(LauncherInfo.class::cast).toList();\n+\n+        return new Internal.DefaultExternalApplication(appOptions, addLaunchres);\n+    }\n+\n+\n+    static final class Internal {\n+\n+        private Internal() {\n+        }\n+\n+        private record DefaultExternalApplication(Options options, List<LauncherInfo> addLaunchers) implements ExternalApplication {\n+\n+            DefaultExternalApplication {\n+                Objects.requireNonNull(options);\n+                Objects.requireNonNull(addLaunchers);\n+            }\n+\n+            @Override\n+            public String appVersion() {\n+                return APP_VERSION.getFrom(options);\n+            }\n+\n+            @Override\n+            public String appName() {\n+                return NAME.getFrom(options);\n+            }\n+\n+            @Override\n+            public Options extra() {\n+                return options\n+                        .copyWithout(APP_VERSION.id(), NAME.id())\n+                        .copyWithout(AppImageFileOptionScope.LAUNCHER.options().map(WithOptionIdentifier::id).toList());\n+            }\n+\n+            @Override\n+            public LauncherInfo mainLauncher() {\n+                return new DefaultLauncherInfo(options.copyWithout(extra().ids()));\n+            }\n+        }\n+\n+        private record DefaultLauncherInfo(Options options) implements LauncherInfo {\n+\n+            DefaultLauncherInfo {\n+                Objects.requireNonNull(options);\n+            }\n+\n+            @Override\n+            public String name() {\n+                return NAME.getFrom(options);\n+            }\n+\n+            @Override\n+            public Options extra() {\n+                return options\n+                        .copyWithout(NAME.id())\n+                        .copyWithout(AppImageFileOptionScope.APP.options().map(WithOptionIdentifier::id).toList());\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/ExternalApplication.java","additions":121,"deletions":24,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.model;\n+\n+import java.util.Objects;\n+\n+\/**\n+ * Generic jpackage exception with non-null message.\n+ *\/\n+public class JPackageException extends RuntimeException {\n+\n+    public JPackageException(String msg) {\n+        super(Objects.requireNonNull(msg));\n+    }\n+\n+    public JPackageException(String msg, Throwable cause) {\n+        super(Objects.requireNonNull(msg), cause);\n+    }\n+\n+    private static final long serialVersionUID = 1L;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/JPackageException.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -27,0 +27,2 @@\n+import java.util.Optional;\n+\n@@ -38,0 +40,9 @@\n+    \/**\n+     * Gets the main module version if available or an empty {@link Optional}\n+     * otherwise.\n+     *\n+     * @return the main module version if available or an empty {@link Optional}\n+     *         otherwise\n+     *\/\n+    Optional<String> moduleVersion();\n+\n@@ -41,1 +52,1 @@\n-    record Stub(String moduleName) implements LauncherModularStartupInfoMixin {\n+    record Stub(String moduleName, Optional<String> moduleVersion) implements LauncherModularStartupInfoMixin {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/LauncherModularStartupInfoMixin.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,84 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal.model;\n-\n-import jdk.jpackage.internal.util.StringBundle;\n-\n-\/**\n- * Signals that error has occurred at packaging phase.\n- * <p>\n- * The preferred way to construct instances of this class is to use\n- * {@link jdk.jpackage.internal.util.LocalizedExceptionBuilder#buildLocalizedException(StringBundle)} methods\n- *\n- * {@snippet :\n- * StringBundle i18n = getStringBundle(); \/\/ Some way to obtain a string bundle with localized messages\n- *\n- * throw buildLocalizedException(i18n).message(\"error.no.name\").create();\n- * }\n- *\/\n-public class PackagerException extends Exception {\n-\n-    private static final long serialVersionUID = 1L;\n-\n-    public PackagerException(Throwable cause) {\n-        super(cause);\n-    }\n-\n-    public PackagerException(String key, Throwable cause) {\n-        super(I18N.getString(key), cause);\n-    }\n-\n-    public PackagerException(String key) {\n-        super(I18N.getString(key));\n-    }\n-\n-    public PackagerException(String key, Object... arguments) {\n-        super(I18N.format(key, arguments));\n-    }\n-\n-    public PackagerException(Throwable cause, String key, Object... arguments) {\n-        super(I18N.format(key, arguments), cause);\n-    }\n-\n-    \/**\n-     * Throws the cause of the given {@link RuntimeException} exception\n-     * as {@link PackagerException} if the cause is of this type or re-throws the given\n-     * {@link RuntimeException} exception as-is otherwise.\n-     * <p>\n-     * Never return a value. It always throws some exception object.\n-     *\n-     * @param ex exception to re-throw\n-     * @return doesn't return value\n-     * @throws PackagerException\n-     *\/\n-    public static RuntimeException rethrowPackagerException(RuntimeException ex) throws PackagerException {\n-        if (ex.getCause() instanceof PackagerException pkgEx) {\n-            throw pkgEx;\n-        } else {\n-            throw ex;\n-        }\n-    }\n-\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/PackagerException.java","additions":0,"deletions":84,"binary":false,"changes":84,"status":"deleted"},{"patch":"@@ -47,1 +47,1 @@\n-    void create(AppImageLayout appImageLayout) throws PackagerException;\n+    void create(AppImageLayout appImageLayout);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/RuntimeBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,4 +27,5 @@\n-MSG_Help=Usage: jpackage <options>\\n\\\n-\\n\\\n-Sample usages:\\n\\\n---------------\\n\\\n+help.header=Usage: jpackage <options>\n+\n+help.short=Use jpackage --help (or -h) for a list of possible options\n+\n+help.option-group.sample.create-native-package=\\\n@@ -38,1 +39,3 @@\n-\\            jpackage -n name --app-image appImageDir\\n\\\n+\\            jpackage -n name --app-image appImageDir\n+\n+help.option-group.sample.create-app-image=\\\n@@ -51,1 +54,3 @@\n-\\                -m moduleName\/className --runtime-image appRuntimeImage\\n\\\n+\\                -m moduleName\/className --runtime-image appRuntimeImage\n+\n+help.option-group.sample.create-runtime-installer=\\\n@@ -53,23 +58,28 @@\n-\\        jpackage -n name --runtime-image <runtime-image>\\n\\\n-\\{6}\\\n-\\n\\\n-Generic Options:\\n\\\n-\\  @<filename> \\n\\\n-\\          Read options and\/or mode from a file \\n\\\n-\\          This option can be used multiple times.\\n\\\n-\\  --type -t <type> \\n\\\n-\\          The type of package to create\\n\\\n-\\          Valid values are: {1} \\n\\\n-\\          If this option is not specified a platform dependent\\n\\\n-\\          default type will be created.\\n\\\n-\\  --app-version <version>\\n\\\n-\\          Version of the application and\/or package\\n\\\n-\\  --copyright <copyright string>\\n\\\n-\\          Copyright for the application\\n\\\n-\\  --description <description string>\\n\\\n-\\          Description of the application\\n\\\n-\\  --help -h \\n\\\n-\\          Print the usage text with a list and description of each valid\\n\\\n-\\          option for the current platform to the output stream, and exit\\n\\\n-\\  --icon <file path>\\n\\\n-\\          Path of the icon of the application package\\n\\\n+\\        jpackage -n name --runtime-image <runtime-image>\n+\n+help.option-group.sample.sign-app-image=\\\n+\\    Sign the predefined application image:\\n\\\n+\\        jpackage --type app-image --app-image <app-image> \\\\\\n\\\n+\\            --mac-sign [<additional signing options>...]\\n\\\n+\\        Note: the only additional options that are permitted in this mode are:\\n\\\n+\\              the set of additional mac signing options and --verbose\n+\n+help.option-group.sample=Sample usages\n+help.option-group.generic=Generic Options\n+help.option-group.runtime-image=Options for creating the runtime image\n+help.option-group.app-image=Options for creating the application image\n+help.option-group.launcher=Options for creating the application launcher(s)\n+help.option-group.launcher-platform=Platform dependent option for creating the application launcher\n+help.option-group.package=Options for creating the application package\n+help.option-group.package-platform=Platform dependent options for creating the application package\n+\n+main.option.argument-file=\\\n+\\          Read options and\/or mode from a file\\n\\\n+\\          This option can be used multiple times.\n+\n+main.option.about-url=\\\n+\\          URL of the application's home page\n+\n+main.option.add-launcher.win=\\\n+\\          Name of launcher, and a path to a Properties file that contains\\n\\\n+\\          a list of key, value pairs\\n\\\n@@ -77,4 +87,13 @@\n-\\  --name -n <name>\\n\\\n-\\          Name of the application and\/or package\\n\\\n-\\  --dest -d <destination path>\\n\\\n-\\          Path where generated output file is placed\\n\\\n+\\          The keys \"arguments\", \"description\", \"icon\", \"java-options\",\\n\\\n+\\          \"launcher-as-service\", \"main-class\", \"main-jar\", \"module\",\\n\\\n+\\          \"win-console\", \"win-menu\", and \"win-shortcut\" can be used.\\n\\\n+\\          These options are added to, or used to overwrite, the original\\n\\\n+\\          command line options to build an additional alternative launcher.\\n\\\n+\\          The main application launcher will be built from the command line\\n\\\n+\\          options. Additional alternative launchers can be built using\\n\\\n+\\          this option, and this option can be used multiple times to\\n\\\n+\\          build multiple additional launchers.\n+\n+main.option.add-launcher.linux=\\\n+\\          Name of launcher, and a path to a Properties file that contains\\n\\\n+\\          a list of key, value pairs\\n\\\n@@ -82,3 +101,13 @@\n-\\          Defaults to the current working directory.\\n\\\n-\\  --temp <directory path>\\n\\\n-\\          Path of a new or empty directory used to create temporary files\\n\\\n+\\          The keys \"arguments\", \"description\", \"icon\", \"java-options\",\\n\\\n+\\          \"launcher-as-service\", \"linux-shortcut\", \"main-class\", \"main-jar\",\\n\\\n+\\          and \"module\" can be used.\\n\\\n+\\          These options are added to, or used to overwrite, the original\\n\\\n+\\          command line options to build an additional alternative launcher.\\n\\\n+\\          The main application launcher will be built from the command line\\n\\\n+\\          options. Additional alternative launchers can be built using\\n\\\n+\\          this option, and this option can be used multiple times to\\n\\\n+\\          build multiple additional launchers.\n+\n+main.option.add-launcher.mac=\\\n+\\          Name of launcher, and a path to a Properties file that contains\\n\\\n+\\          a list of key, value pairs\\n\\\n@@ -86,13 +115,11 @@\n-\\          If specified, the temp dir will not be removed upon the task\\n\\\n-\\          completion and must be removed manually.\\n\\\n-\\          If not specified, a temporary directory will be created and\\n\\\n-\\          removed upon the task completion.\\n\\\n-\\  --vendor <vendor string>\\n\\\n-\\          Vendor of the application\\n\\\n-\\  --verbose\\n\\\n-\\          Enables verbose output\\n\\\n-\\  --version\\n\\\n-\\          Print the product version to the output stream and exit.\\n\\\n-\\n\\\n-\\Options for creating the runtime image:\\n\\\n-\\  --add-modules <module name>[,<module name>...]\\n\\\n+\\          The keys \"arguments\", \"description\", \"icon\", \"java-options\",\\n\\\n+\\          \"launcher-as-service\", \"main-class\", \"main-jar\", and \"module\"\\n\\\n+\\          can be used.\\n\\\n+\\          These options are added to, or used to overwrite, the original\\n\\\n+\\          command line options to build an additional alternative launcher.\\n\\\n+\\          The main application launcher will be built from the command line\\n\\\n+\\          options. Additional alternative launchers can be built using\\n\\\n+\\          this option, and this option can be used multiple times to\\n\\\n+\\          build multiple additional launchers.\n+\n+main.option.add-modules=\\\n@@ -103,1 +130,1 @@\n-\\          specified), or the default set of modules (if --main-jar is \\n\\\n+\\          specified), or the default set of modules (if --main-jar is\\n\\\n@@ -105,28 +132,8 @@\n-\\          This option can be used multiple times.\\n\\\n-\\  --module-path -p <module path>...\\n\\\n-\\          A {0} separated list of paths\\n\\\n-\\          Each path is either a directory of modules or the path to a\\n\\\n-\\          modular jar.\\n\\\n-\\          (Each path is absolute or relative to the current directory.)\\n\\\n-\\          This option can be used multiple times.\\n\\\n-\\  --jlink-options <jlink options> \\n\\\n-\\          A space separated list of options to pass to jlink \\n\\\n-\\          If not specified, defaults to \"--strip-native-commands \\n\\\n-\\          --strip-debug --no-man-pages --no-header-files\". \\n\\\n-\\          This option can be used multiple times.\\n\\\n-\\  --runtime-image <directory path>\\n\\\n-\\          Path of the predefined runtime image that will be copied into\\n\\\n-\\          the application image\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\          If --runtime-image is not specified, jpackage will run jlink to\\n\\\n-\\          create the runtime image using options:\\n\\\n-\\          --strip-debug, --no-header-files, --no-man-pages, and\\n\\\n-\\          --strip-native-commands.\\n\\\n-\\n\\\n-\\Options for creating the application image:\\n\\\n-\\  --input -i <directory path>\\n\\\n-\\          Path of the input directory that contains the files to be packaged\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\          All files in the input directory will be packaged into the\\n\\\n-\\          application image.\\n\\\n-\\  --app-content <additional content>[,<additional content>...]\\n\\\n+\\          This option can be used multiple times.\n+\n+main.option.app-content=\\\n+\\          A comma separated list of paths to files and\/or directories\\n\\\n+\\          to add to the application payload.\\n\\\n+\\          This option can be used more than once.\n+\n+main.option.app-content.mac=\\\n@@ -136,18 +143,21 @@\n-{7}\\n\\\n-\\Options for creating the application launcher(s):\\n\\\n-\\  --add-launcher <launcher name>=<file path>\\n\\\n-\\          Name of launcher, and a path to a Properties file that contains\\n\\\n-\\          a list of key, value pairs\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\          The keys \"module\", \"main-jar\", \"main-class\", \"description\",\\n\\\n-\\          \"arguments\", \"java-options\", \"app-version\", \"icon\",\\n\\\n-\\          \"launcher-as-service\",\\n\\\n-\\          \"win-console\", \"win-shortcut\", \"win-menu\",\\n\\\n-\\          \"linux-app-category\", and \"linux-shortcut\" can be used.\\n\\\n-\\          These options are added to, or used to overwrite, the original\\n\\\n-\\          command line options to build an additional alternative launcher.\\n\\\n-\\          The main application launcher will be built from the command line\\n\\\n-\\          options. Additional alternative launchers can be built using\\n\\\n-\\          this option, and this option can be used multiple times to\\n\\\n-\\          build multiple additional launchers. \\n\\\n-\\  --arguments <main class arguments>\\n\\\n+\\          Note: The value should be a directory with the \"Resources\"\\n\\\n+\\          subdirectory (or any other directory that is valid in the \"Contents\"\\n\\\n+\\          directory of the application bundle). Otherwise, jpackage may produce\\n\\\n+\\          invalid application bundle which may fail code signing and\/or\\n\\\n+\\          notarization.\n+\n+main.option.app-image=\\\n+\\          Location of the predefined application image that is used\\n\\\n+\\          to build an installable package\\n\\\n+\\          (absolute path or relative to the current directory)\n+\n+main.option.app-image.mac=\\\n+\\          Location of the predefined application image that is used\\n\\\n+\\          to build an installable package or to sign the predefined\\n\\\n+\\          application image\\n\\\n+\\          (absolute path or relative to the current directory)\n+\n+main.option.app-version=\\\n+\\          Version of the application and\/or package\n+\n+main.option.arguments=\\\n@@ -156,24 +166,10 @@\n-\\          This option can be used multiple times.\\n\\\n-\\  --java-options <java options>\\n\\\n-\\          Options to pass to the Java runtime\\n\\\n-\\          This option can be used multiple times.\\n\\\n-\\  --main-class <class name>\\n\\\n-\\          Qualified name of the application main class to execute\\n\\\n-\\          This option can only be used if --main-jar is specified.\\n\\\n-\\  --main-jar <main jar file>\\n\\\n-\\          The main JAR of the application; containing the main class\\n\\\n-\\          (specified as a path relative to the input path)\\n\\\n-\\          Either --module or --main-jar option can be specified but not\\n\\\n-\\          both.\\n\\\n-\\  --module -m <module name>[\/<main class>]\\n\\\n-\\          The main module (and optionally main class) of the application\\n\\\n-\\          This module must be located on the module path.\\n\\\n-\\          When this option is specified, the main module will be linked\\n\\\n-\\          in the Java runtime image.  Either --module or --main-jar\\n\\\n-\\          option can be specified but not both.\\n\\\n-{2}\\n\\\n-\\Options for creating the application package:\\n\\\n-\\  --about-url <url>\\n\\\n-\\          URL of the application''s home page\\n\\\n-\\  --app-image <directory path>\\n\\\n-\\          {5}\\\n+\\          This option can be used multiple times.\n+\n+main.option.copyright=\\\n+\\          Copyright for the application\n+\n+main.option.description=\\\n+\\          Description of the application\n+\n+main.option.dest=\\\n+\\          Path where generated output file is placed\\n\\\n@@ -181,1 +177,3 @@\n-\\  --file-associations <file path>\\n\\\n+\\          Defaults to the current working directory.\n+\n+main.option.file-associations=\\\n@@ -186,10 +184,12 @@\n-\\          This option can be used multiple times.\\n\\\n-\\  --install-dir <directory path>\\n\\\n-\\          {4}\\\n-\\  --license-file <file path>\\n\\\n-\\          Path to the license file\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\  --resource-dir <directory path>\\n\\\n-\\          Path to override jpackage resources\\n\\\n-\\          Icons, template files, and other resources of jpackage can be\\n\\\n-\\          over-ridden by adding replacement resources to this directory.\\n\\\n+\\          This option can be used multiple times.\n+\n+main.option.help=\\\n+\\          Print the usage text with a list and description of each valid\\n\\\n+\\          option for the current platform to the output stream, and exit\n+\n+main.option.icon=\\\n+\\          Path of the icon of the application package\\n\\\n+\\          (absolute path or relative to the current directory)\n+\n+main.option.input=\\\n+\\          Path of the input directory that contains the files to be packaged\\n\\\n@@ -197,1 +197,11 @@\n-\\  --runtime-image <directory path>\\n\\\n+\\          All files in the input directory will be packaged into the\\n\\\n+\\          application image.\n+\n+main.option.install-dir=\\\n+\\          Absolute path of the installation directory of the application\n+\n+main.option.install-dir.win=\\\n+\\          Relative sub-path of the installation location of\\n\\\n+\\          the application such as \"Program Files\" or \"AppData\".\n+\n+main.option.installer-runtime-image=\\\n@@ -200,2 +210,13 @@\n-\\          Option is required when creating a runtime package.\\n\\\n-\\  --launcher-as-service\\n\\\n+\\          Option is required when creating a runtime package.\n+\n+main.option.java-options=\\\n+\\          Options to pass to the Java runtime\\n\\\n+\\          This option can be used multiple times.\n+\n+main.option.jlink-options=\\\n+\\          A space separated list of options to pass to jlink\\n\\\n+\\          If not specified, defaults to \"--strip-native-commands\\n\\\n+\\          --strip-debug --no-man-pages --no-header-files\".\\n\\\n+\\          This option can be used multiple times.\n+\n+main.option.launcher-as-service=\\\n@@ -203,11 +224,1 @@\n-\\          application launcher as a background service-type application.\\n\\\n-\\n\\\n-\\Platform dependent options for creating the application package:\\n\\\n-{3}\n-\n-MSG_Help_win_launcher=\\\n-\\n\\\n-\\Platform dependent option for creating the application launcher:\\n\\\n-\\  --win-console\\n\\\n-\\          Creates a console launcher for the application, should be\\n\\\n-\\          specified for application which requires console interactions\\n\\\n+\\          application launcher as a background service-type application.\n@@ -215,21 +226,20 @@\n-MSG_Help_win_install=\\\n-\\  --win-dir-chooser\\n\\\n-\\          Adds a dialog to enable the user to choose a directory in which\\n\\\n-\\          the product is installed.\\n\\\n-\\  --win-help-url <url>\\n\\\n-\\          URL where user can obtain further information or technical support\\n\\\n-\\  --win-menu\\n\\\n-\\          Request to add a Start menu shortcut for this application\\n\\\n-\\  --win-menu-group <menu group name>\\n\\\n-\\          Start Menu group this application is placed in\\n\\\n-\\  --win-per-user-install\\n\\\n-\\          Request to perform an install on a per-user basis\\n\\\n-\\  --win-shortcut\\n\\\n-\\          Request to add desktop shortcut for this application\\n\\\n-\\  --win-shortcut-prompt\\n\\\n-\\          Adds a dialog to enable the user to choose if shortcuts\\n\\\n-\\          will be created by installer.\\n\\\n-\\  --win-update-url <url>\\n\\\n-\\          URL of available application update information\\n\\\n-\\  --win-upgrade-uuid <id string>\\n\\\n-\\          UUID associated with upgrades for this package\\n\\\n+main.option.license-file=\\\n+\\          Path to the license file\\n\\\n+\\          (absolute path or relative to the current directory)\n+\n+main.option.linux-app-category=\\\n+\\          Group value of the RPM <name>.spec file or\\n\\\n+\\          Section value of DEB control file\n+\n+main.option.linux-app-release=\\\n+\\          Release value of the RPM <name>.spec file or\\n\\\n+\\          Debian revision value of the DEB control file\n+\n+main.option.linux-deb-maintainer=\\\n+\\          Maintainer for .deb package\n+\n+main.option.linux-menu-group=\\\n+\\          Menu group this application is placed in\n+\n+main.option.linux-package-deps=\\\n+\\          Required packages or capabilities for the application\n@@ -237,2 +247,2 @@\n-MSG_Help_win_install_dir=\\\n-\\Relative sub-path under the default installation location\\n\\\n+main.option.linux-package-name=\\\n+\\          Name for Linux package, defaults to the application name\n@@ -240,2 +250,20 @@\n-MSG_Help_mac_install=\\\n-\\  --mac-dmg-content <additional content path>[,<additional content path>...]\\n\\\n+main.option.linux-rpm-license-type=\\\n+\\          Type of the license (\"License: <value>\" of the RPM .spec)\n+\n+main.option.linux-shortcut=\\\n+\\          Creates a shortcut for the application.\n+\n+main.option.mac-app-category=\\\n+\\          String used to construct LSApplicationCategoryType in\\n\\\n+\\          application plist.  The default value is \"utilities\".\n+\n+main.option.mac-app-image-sign-identity=\\\n+\\          Identity used to sign application image. This value will be passed\\n\\\n+\\          directly to --sign option of \"codesign\" tool. This option cannot\\n\\\n+\\          be combined with --mac-signing-key-user-name.\n+\n+main.option.mac-app-store=\\\n+\\          Indicates that the jpackage output is intended for the\\n\\\n+\\          Mac App Store.\n+\n+main.option.mac-dmg-content=\\\n@@ -243,1 +271,10 @@\n-\\          This option can be used multiple times. \\n\\\n+\\          This option can be used multiple times.\n+\n+main.option.mac-entitlements=\\\n+\\          Path to file containing entitlements to use when signing\\n\\\n+\\          executables and libraries in the bundle.\n+\n+main.option.mac-installer-sign-identity=\\\n+\\          Identity used to sign \"pkg\" installer. This value will be passed\\n\\\n+\\          directly to --sign option of \"productbuild\" tool. This option\\n\\\n+\\          cannot be combined with --mac-signing-key-user-name.\n@@ -245,2 +282,1 @@\n-MSG_Help_mac_launcher=\\\n-\\  --mac-package-identifier <ID string>\\n\\\n+main.option.mac-package-identifier=\\\n@@ -250,2 +286,3 @@\n-\\          and period (.) characters.\\n\\\n-\\  --mac-package-name <name string>\\n\\\n+\\          and period (.) characters.\n+\n+main.option.mac-package-name=\\\n@@ -256,2 +293,3 @@\n-\\          Defaults to the application name.\\n\\\n-\\  --mac-package-signing-prefix <prefix string>\\n\\\n+\\          Defaults to the application name.\n+\n+main.option.mac-package-signing-prefix=\\\n@@ -260,2 +298,3 @@\n-\\          an existing package identifier.\\n\\\n-\\  --mac-sign\\n\\\n+\\          an existing package identifier.\n+\n+main.option.mac-sign=\\\n@@ -263,2 +302,3 @@\n-\\          signed.\\n\\\n-\\  --mac-signing-keychain <keychain name>\\n\\\n+\\          signed.\n+\n+main.option.mac-signing-keychain=\\\n@@ -266,2 +306,3 @@\n-\\          If not specified, the standard keychains are used.\\n\\\n-\\  --mac-signing-key-user-name <team name>\\n\\\n+\\          If not specified, the standard keychains are used.\n+\n+main.option.mac-signing-key-user-name=\\\n@@ -272,53 +313,1 @@\n-\\          --mac-app-image-sign-identity or --mac-installer-sign-identity.\\n\\\n-\\  --mac-app-image-sign-identity <identity>\\n\\\n-\\          Identity used to sign application image. This value will be passed\\n\\\n-\\          directly to --sign option of \"codesign\" tool. This option cannot\\n\\\n-\\          be combined with --mac-signing-key-user-name.\\n\\\n-\\  --mac-installer-sign-identity <identity>\\n\\\n-\\          Identity used to sign \"pkg\" installer. This value will be passed\\n\\\n-\\          directly to --sign option of \"productbuild\" tool. This option\\n\\\n-\\          cannot be combined with --mac-signing-key-user-name.\\n\\\n-\\  --mac-app-store\\n\\\n-\\          Indicates that the jpackage output is intended for the\\n\\\n-\\          Mac App Store.\\n\\\n-\\  --mac-entitlements <file path>\\n\\\n-\\          Path to file containing entitlements to use when signing\\n\\\n-\\          executables and libraries in the bundle.\\n\\\n-\\  --mac-app-category <category string>\\n\\\n-\\          String used to construct LSApplicationCategoryType in\\n\\\n-\\          application plist.  The default value is \"utilities\".\\n\\\n-\n-MSG_Help_linux_install=\\\n-\\  --linux-package-name <package name>\\n\\\n-\\          Name for Linux package, defaults to the application name\\n\\\n-\\  --linux-deb-maintainer <email address>\\n\\\n-\\          Maintainer for .deb package\\n\\\n-\\  --linux-menu-group <menu-group-name>\\n\\\n-\\          Menu group this application is placed in\\n\\\n-\\  --linux-package-deps <package-dep-string>\\n\\\n-\\          Required packages or capabilities for the application\\n\\\n-\\  --linux-rpm-license-type <type string>\\n\\\n-\\          Type of the license (\"License: <value>\" of the RPM .spec)\\n\\\n-\\  --linux-app-release <release value>\\n\\\n-\\          Release value of the RPM <name>.spec file or \\n\\\n-\\          Debian revision value of the DEB control file\\n\\\n-\\  --linux-app-category <category value>\\n\\\n-\\          Group value of the RPM <name>.spec file or \\n\\\n-\\          Section value of DEB control file\\n\\\n-\\  --linux-shortcut\\n\\\n-\\          Creates a shortcut for the application.\\n\\\n-\n-MSG_Help_mac_linux_install_dir=\\\n-\\Absolute path of the installation directory of the application\\n\\\n-\n-MSG_Help_default_install_dir=\\\n-\\Absolute path of the installation directory of the application on OS X\\n\\\n-\\          or Linux. Relative sub-path of the installation location of\\n\\\n-\\          the application such as \"Program Files\" or \"AppData\" on Windows.\\n\\\n-\n-MSG_Help_no_args=Usage: jpackage <options>\\n\\\n-\\Use jpackage --help (or -h) for a list of possible options\\\n-\n-MSG_Help_default_app_image=\\\n-\\Location of the predefined application image that is used\\n\\\n-\\          to build an installable package\\n\\\n+\\          --mac-app-image-sign-identity or --mac-installer-sign-identity.\n@@ -326,4 +315,3 @@\n-MSG_Help_mac_app_image=\\\n-\\Location of the predefined application image that is used\\n\\\n-\\          to build an installable package or to sign the predefined\\n\\\n-\\          application image\\n\\\n+main.option.main-class=\\\n+\\          Qualified name of the application main class to execute\\n\\\n+\\          This option can only be used if --main-jar is specified.\n@@ -331,6 +319,109 @@\n-MSG_Help_mac_sign_sample_usage=\\\n-\\    Sign the predefined application image:\\n\\\n-\\        jpackage --type app-image --app-image <app-image> \\\\\\n\\\n-\\            --mac-sign [<additional signing options>...]\\n\\\n-\\        Note: the only additional options that are permitted in this mode are:\\n\\\n-\\              the set of additional mac signing options and --verbose\\n\\\n+main.option.main-jar=\\\n+\\          The main JAR of the application; containing the main class\\n\\\n+\\          (specified as a path relative to the input path)\\n\\\n+\\          Either --module or --main-jar option can be specified but not\\n\\\n+\\          both.\n+\n+main.option.module=\\\n+\\          The main module (and optionally main class) of the application\\n\\\n+\\          This module must be located on the module path.\\n\\\n+\\          When this option is specified, the main module will be linked\\n\\\n+\\          in the Java runtime image.  Either --module or --main-jar\\n\\\n+\\          option can be specified but not both.\n+\n+main.option.module-path=\\\n+\\          A : separated list of paths\\n\\\n+\\          Each path is either a directory of modules or the path to a\\n\\\n+\\          modular jar.\\n\\\n+\\          (Each path is absolute or relative to the current directory.)\\n\\\n+\\          This option can be used multiple times.\n+main.option.module-path.win=\\\n+\\          A ; separated list of paths\\n\\\n+\\          Each path is either a directory of modules or the path to a\\n\\\n+\\          modular jar.\\n\\\n+\\          (Each path is absolute or relative to the current directory.)\\n\\\n+\\          This option can be used multiple times.\n+\n+main.option.name=\\\n+\\          Name of the application and\/or package\n+\n+main.option.resource-dir=\\\n+\\          Path to override jpackage resources\\n\\\n+\\          Icons, template files, and other resources of jpackage can be\\n\\\n+\\          over-ridden by adding replacement resources to this directory.\\n\\\n+\\          (absolute path or relative to the current directory)\n+\n+main.option.runtime-image=\\\n+\\          Path of the predefined runtime image that will be copied into\\n\\\n+\\          the application image\\n\\\n+\\          (absolute path or relative to the current directory)\\n\\\n+\\          If --runtime-image is not specified, jpackage will run jlink to\\n\\\n+\\          create the runtime image using options:\\n\\\n+\\          --strip-debug, --no-header-files, --no-man-pages, and\\n\\\n+\\          --strip-native-commands.\n+\n+main.option.temp=\\\n+\\          Path of a new or empty directory used to create temporary files\\n\\\n+\\          (absolute path or relative to the current directory)\\n\\\n+\\          If specified, the temp dir will not be removed upon the task\\n\\\n+\\          completion and must be removed manually.\\n\\\n+\\          If not specified, a temporary directory will be created and\\n\\\n+\\          removed upon the task completion.\n+\n+main.option.type.win=\\\n+\\          The type of package to create\\n\\\n+\\          Valid values are: {\"app-image\", \"exe\", \"msi\"}\\n\\\n+\\          If this option is not specified a platform dependent\\n\\\n+\\          default type will be created.\n+main.option.type.linux=\\\n+\\          The type of package to create\\n\\\n+\\          Valid values are: {\"app-image\", \"deb\", \"rpm\"}\\n\\\n+\\          If this option is not specified a platform dependent\\n\\\n+\\          default type will be created.\n+main.option.type.mac=\\\n+\\          The type of package to create\\n\\\n+\\          Valid values are: {\"app-image\", \"dmg\", \"pkg\"}\\n\\\n+\\          If this option is not specified a platform dependent\\n\\\n+\\          default type will be created.\n+\n+main.option.vendor=\\\n+\\          Vendor of the application\n+\n+main.option.verbose=\\\n+\\          Enables verbose output\n+\n+main.option.version=\\\n+\\          Print the product version to the output stream and exit.\n+\n+main.option.win-console=\\\n+\\          Creates a console launcher for the application, should be\\n\\\n+\\          specified for application which requires console interactions\n+\n+main.option.win-dir-chooser=\\\n+\\          Adds a dialog to enable the user to choose a directory in which\\n\\\n+\\          the product is installed.\n+\n+main.option.win-help-url=\\\n+\\          URL where user can obtain further information or technical support\n+\n+main.option.win-menu=\\\n+\\          Request to add a Start menu shortcut for this application\n+\n+main.option.win-menu-group=\\\n+\\          Start Menu group this application is placed in\n+\n+main.option.win-per-user-install=\\\n+\\          Request to perform an install on a per-user basis\n+\n+main.option.win-shortcut=\\\n+\\          Request to add desktop shortcut for this application\n+\n+main.option.win-shortcut-prompt=\\\n+\\          Adds a dialog to enable the user to choose if shortcuts\\n\\\n+\\          will be created by installer.\n+\n+main.option.win-update-url=\\\n+\\          URL of available application update information\n+\n+main.option.win-upgrade-uuid=\\\n+\\          UUID associated with upgrades for this package\n@@ -338,6 +429,0 @@\n-MSG_Help_mac_app_content_note=\\\n-\\          Note: The value should be a directory with the \"Resources\"\\n\\\n-\\          subdirectory (or any other directory that is valid in the \"Contents\"\\n\\\n-\\          directory of the application bundle). Otherwise, jpackage may produce\\n\\\n-\\          invalid application bundle which may fail code signing and\/or\\n\\\n-\\          notarization.\\n\\\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/HelpResources.properties","additions":337,"deletions":252,"binary":false,"changes":589,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-jpackage.description=package a self-contained Java application\n-\n@@ -33,0 +31,10 @@\n+bundle-type.win-app=Windows Application Image\n+bundle-type.win-exe=EXE Installer Package\n+bundle-type.win-msi=MSI Installer Package\n+bundle-type.mac-app=Mac Application Image\n+bundle-type.mac-dmg=Mac DMG Package\n+bundle-type.mac-pkg=Mac PKG Package\n+bundle-type.linux-app=Linux Application Image\n+bundle-type.linux-deb=DEB Bundle\n+bundle-type.linux-rpm=RPM Bundle\n+\n@@ -40,2 +48,0 @@\n-message.runtime-image-dir-does-not-exist=Specified runtime image directory {0}: {1} does not exist\n-message.resource-dir-does-not-exist=Specified resource directory {0}: {1} does not exist\n@@ -47,0 +53,3 @@\n+message.error-header={0}\n+message.advice-header=Advice to fix: {0}\n+\n@@ -64,0 +73,16 @@\n+error.non-option-arguments=Found {0} non-option arguments on the command line. Non-option arguments are not allowed\n+error.undefined-default-bundling-operation=Default bundling operation is undefined\n+error.undefined-default-bundling-operation.advice=Add {0} parameter to the command line\n+error.paramater-not-uuid=The value \"{0}\" provided for parameter {1} is not a valid UUID\n+error.paramater-not-path=The value \"{0}\" provided for parameter {1} is not a valid path\n+error.paramater-not-file=The value \"{0}\" provided for parameter {1} is not a file\n+error.paramater-not-directory=The value \"{0}\" provided for parameter {1} is not a directory\n+error.paramater-not-url=The value \"{0}\" provided for parameter {1} is not a valid URL\n+error.paramater-not-launcher-shortcut-dir=The value \"{0}\" provided for parameter {1} is not a valid shortcut startup directory\n+error.path-paramater-ioexception=I\/O error accessing path value \"{0}\" of parameter {1}\n+error.paramater-add-launcher-malformed=The value \"{0}\" provided for parameter {1} does not match the pattern <name>=<file path>\n+error.paramater-add-launcher-not-file=The value of path to a property file \"{0}\" provided for additional launcher \"{1}\" is not a valid file path\n+error.properties-paramater-not-path=The value \"{0}\" provided for property \"{1}\" in \"{2}\" file is not a valid path\n+error.properties-paramater-not-file=The value \"{0}\" provided for property \"{1}\" in \"{2}\" file is not a file\n+error.properties-paramater-not-launcher-shortcut-dir=The value \"{0}\" provided for property \"{1}\" in \"{2}\" file is not a valid shortcut startup directory\n+\n@@ -69,0 +94,2 @@\n+error.launcher-duplicate-name=Multiple launchers have the same name \"{0}\". Launchers should have unique names\n+\n@@ -81,2 +108,4 @@\n-error.foreign-app-image=Error: Missing .jpackage.xml file in app-image dir \"{0}\"\n-error.invalid-app-image=Error: app-image dir \"{0}\" generated by another jpackage version or malformed \"{1}\" file\n+error.missing-app-image-file=Error: \"{0}\" file is missing in the predefined app image \"{1}\"\n+error.invalid-app-image-file=Error: \"{0}\" file in the predefined app image \"{1}\" is corrupted or was created by another version of jpackage\n+error.malformed-app-image-file=Error: \"{0}\" file in the predefined app image \"{1}\" contains malformed XML data\n+error.reading-app-image-file=Error: Failed to read \"{0}\" file in the predefined app image \"{1}\"\n@@ -88,6 +117,0 @@\n-MSG_BundlerFailed=Error: Bundler \"{1}\" ({0}) failed to produce a package\n-MSG_BundlerConfigException=Bundler {0} skipped because of a configuration problem: {1} \\n\\\n-Advice to fix: {2}\n-MSG_BundlerConfigExceptionNoAdvice=Bundler {0} skipped because of a configuration problem: {1}\n-MSG_BundlerRuntimeException=Bundler {0} failed because of {1}\n-\n@@ -102,1 +125,1 @@\n-ERR_MissingRequiredArgument=Error: {0} argument requires at least one of [{1}] argument(s)\n+ERR_MissingArgument2=Error: Missing argument: {0} or {1}\n@@ -105,1 +128,0 @@\n-ERR_NoUniqueName=Error: --add-launcher <name>=<file path> requires a unique name\n@@ -108,1 +130,0 @@\n-ERR_IconFileNotExit=Error: Specified icon file [{0}] does not exist\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/MainResources.properties","additions":36,"deletions":15,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+public final class SetBuilder<T> {\n+\n+    public static <T> SetBuilder<T> build(Class<? extends T> type) {\n+        return new SetBuilder<>();\n+    }\n+\n+    public SetBuilder<T> set(Collection<? extends T> v) {\n+        return clear().add(v);\n+    }\n+\n+    @SafeVarargs\n+    @SuppressWarnings(\"varargs\")\n+    public final SetBuilder<T> set(T... v) {\n+        return set(List.of(v));\n+    }\n+\n+    public SetBuilder<T> add(Collection<? extends T> v) {\n+        values.addAll(v);\n+        return this;\n+    }\n+\n+    @SafeVarargs\n+    @SuppressWarnings(\"varargs\")\n+    public final SetBuilder<T> add(T... v) {\n+        return add(List.of(v));\n+    }\n+\n+    public SetBuilder<T> remove(Collection<? extends T> v) {\n+        values.removeAll(v);\n+        return this;\n+    }\n+\n+    @SafeVarargs\n+    @SuppressWarnings(\"varargs\")\n+    public final SetBuilder<T> remove(T... v) {\n+        return remove(List.of(v));\n+    }\n+\n+    public SetBuilder<T> clear() {\n+        values.clear();\n+        return this;\n+    }\n+\n+    public SetBuilder<T> emptyAllowed(boolean v) {\n+        emptyAllowed = v;\n+        return this;\n+    }\n+\n+    public Set<T> create() {\n+        if (values.isEmpty() && !emptyAllowed) {\n+            throw new UnsupportedOperationException();\n+        }\n+        return Set.copyOf(values);\n+    }\n+\n+    private boolean emptyAllowed;\n+    private final Set<T> values = new HashSet<>();\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/SetBuilder.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -28,11 +28,0 @@\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.nio.file.NoSuchFileException;\n-import java.text.MessageFormat;\n-import java.util.ResourceBundle;\n-import jdk.internal.opt.CommandLine;\n-import jdk.jpackage.internal.Arguments;\n-import jdk.jpackage.internal.CLIHelp;\n-import jdk.jpackage.internal.Log;\n-\n@@ -41,3 +30,0 @@\n-    public static final ResourceBundle I18N = ResourceBundle.getBundle(\n-            \"jdk.jpackage.internal.resources.MainResources\");\n-\n@@ -50,70 +36,2 @@\n-    public static void main(String... args) throws Exception {\n-\n-        PrintWriter out = new PrintWriter(System.out);\n-        PrintWriter err = new PrintWriter(System.err);\n-        int status = new jdk.jpackage.main.Main().execute(out, err, args);\n-        System.exit(status);\n-    }\n-\n-    \/**\n-     * execute() - this is the entry point for the ToolProvider API.\n-     *\n-     * @param out output stream\n-     * @param err error output stream\n-     * @param args command line arguments\n-     * @return an exit code. 0 means success, non-zero means an error occurred.\n-     *\/\n-    public int execute(PrintWriter out, PrintWriter err, String... args) {\n-        Log.setPrintWriter(out, err);\n-\n-        try {\n-            String[] newArgs;\n-            try {\n-                newArgs = CommandLine.parse(args);\n-            } catch (FileNotFoundException|NoSuchFileException fnfe) {\n-                Log.fatalError(MessageFormat.format(I18N.getString(\n-                        \"ERR_CannotParseOptions\"), fnfe.getMessage()));\n-                return 1;\n-            } catch (IOException ioe) {\n-                Log.fatalError(ioe.getMessage());\n-                return 1;\n-            }\n-\n-            if (newArgs.length == 0) {\n-                CLIHelp.showHelp(true);\n-            } else if (hasHelp(newArgs)){\n-                if (hasVersion(newArgs)) {\n-                    Log.info(System.getProperty(\"java.version\") + \"\\n\");\n-                }\n-                CLIHelp.showHelp(false);\n-            } else if (hasVersion(newArgs)) {\n-                Log.info(System.getProperty(\"java.version\"));\n-            } else {\n-                Arguments arguments = new Arguments(newArgs);\n-                if (!arguments.processArguments()) {\n-                    \/\/ processArguments() will log error message if failed.\n-                    return 1;\n-                }\n-            }\n-            return 0;\n-        } finally {\n-            Log.flush();\n-        }\n-    }\n-\n-    private boolean hasHelp(String[] args) {\n-        for (String a : args) {\n-            if (\"--help\".equals(a) || \"-h\".equals(a)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    private boolean hasVersion(String[] args) {\n-        for (String a : args) {\n-            if (\"--version\".equals(a)) {\n-                return true;\n-            }\n-        }\n-        return false;\n+    public static void main(String... args) {\n+        jdk.jpackage.internal.cli.Main.main(args);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/main\/Main.java","additions":2,"deletions":84,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -38,6 +38,0 @@\n- * @implNote The {@code jpackage} tool is not thread-safe. An application\n- * should not call either of the\n- * {@link java.util.spi.ToolProvider ToolProvider} {@code run} methods\n- * concurrently, even with separate {@code \"jpackage\"} {@code ToolProvider}\n- * instances, or undefined behavior may result.\n- *\n@@ -59,5 +53,1 @@\n-    uses jdk.jpackage.internal.Bundler;\n-    uses jdk.jpackage.internal.Bundlers;\n-\n-    provides jdk.jpackage.internal.Bundlers with\n-        jdk.jpackage.internal.BasicBundlers;\n+        uses jdk.jpackage.internal.cli.CliBundlingEnvironment;\n@@ -66,1 +56,1 @@\n-        with jdk.jpackage.internal.JPackageToolProvider;\n+        with jdk.jpackage.internal.cli.Main.Provider;\n","filename":"src\/jdk.jpackage\/share\/classes\/module-info.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-public class WinAppBundler extends AppImageBundler {\n-    public WinAppBundler() {\n-        setAppImageSupplier((params, output) -> {\n-            \/\/ Order is important!\n-            var app = WinFromParams.APPLICATION.fetchFrom(params);\n-            var env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n-            WinPackagingPipeline.build()\n-                    .excludeDirFromCopying(output.getParent())\n-                    .create().execute(BuildEnv.withAppImageDir(env, output), app);\n-        });\n-    }\n-}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinAppBundler.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.WinFromOpions.createWinApplication;\n+import static jdk.jpackage.internal.WinPackagingPipeline.APPLICATION_LAYOUT;\n+import static jdk.jpackage.internal.cli.StandardBundlingOperation.CREATE_WIN_APP_IMAGE;\n+import static jdk.jpackage.internal.cli.StandardBundlingOperation.CREATE_WIN_EXE;\n+import static jdk.jpackage.internal.cli.StandardBundlingOperation.CREATE_WIN_MSI;\n+\n+import jdk.jpackage.internal.cli.Options;\n+import jdk.jpackage.internal.util.Result;\n+\n+public class WinBundlingEnvironment extends DefaultBundlingEnvironment {\n+\n+    public WinBundlingEnvironment() {\n+        super(build()\n+                .defaultOperation(CREATE_WIN_EXE)\n+                .bundler(CREATE_WIN_APP_IMAGE, WinBundlingEnvironment::createAppImage)\n+                .bundler(CREATE_WIN_EXE, LazyLoad::sysEnv, WinBundlingEnvironment::createExePackage)\n+                .bundler(CREATE_WIN_MSI, LazyLoad::sysEnv, WinBundlingEnvironment::createMsiPackage));\n+    }\n+\n+    private static void createMsiPackage(Options options, WinSystemEnvironment sysEnv) {\n+\n+        createNativePackage(options,\n+                WinFromOpions::createWinMsiPackage,\n+                buildEnv()::create,\n+                WinPackagingPipeline.build(),\n+                (env, pkg, outputDir) -> {\n+\n+                    traceWixToolset(sysEnv);\n+\n+                    return new WinMsiPackager(env, pkg, outputDir, sysEnv);\n+                });\n+    }\n+\n+    private static void createExePackage(Options options, WinSystemEnvironment sysEnv) {\n+\n+        createNativePackage(options,\n+                WinFromOpions::createWinExePackage,\n+                buildEnv()::create,\n+                WinPackagingPipeline.build(),\n+                (env, pkg, outputDir) -> {\n+\n+                    traceWixToolset(sysEnv);\n+\n+                    final var msiOutputDir = env.buildRoot().resolve(\"msi\");\n+\n+                    var msiPackager = new WinMsiPackager(env, pkg.msiPackage(),\n+                            msiOutputDir, sysEnv);\n+                    var exePackager = new WinExePackager(env, pkg, outputDir, msiOutputDir);\n+\n+                    return msiPackager.andThen(exePackager);\n+                });\n+    }\n+\n+    private static void createAppImage(Options options) {\n+\n+        final var app = createWinApplication(options);\n+\n+        createApplicationImage(options, app, WinPackagingPipeline.build());\n+    }\n+\n+    private static BuildEnvFromOptions buildEnv() {\n+        return new BuildEnvFromOptions().predefinedAppImageLayout(APPLICATION_LAYOUT);\n+    }\n+\n+    private static void traceWixToolset(WinSystemEnvironment sysEnv) {\n+        final var wixToolset = sysEnv.wixToolset();\n+\n+        for (var tool : wixToolset.getType().getTools()) {\n+            Log.verbose(I18N.format(\"message.tool-version\",\n+                    wixToolset.getToolPath(tool).getFileName(),\n+                    wixToolset.getVersion()));\n+        }\n+    }\n+\n+    private static final class LazyLoad {\n+\n+        static Result<WinSystemEnvironment> sysEnv() {\n+            return SYS_ENV;\n+        }\n+\n+        private static final Result<WinSystemEnvironment> SYS_ENV = WinSystemEnvironment.create();\n+    }\n+}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinBundlingEnvironment.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -27,6 +27,0 @@\n-import java.nio.file.Path;\n-import java.util.Map;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.PackagerException;\n-import jdk.jpackage.internal.model.WinMsiPackage;\n-\n@@ -34,1 +28,1 @@\n-public class WinExeBundler extends AbstractBundler {\n+final class WinExeBundler {\n@@ -40,52 +34,0 @@\n-    @Override\n-    public String getName() {\n-        return I18N.getString(\"exe.bundler.name\");\n-    }\n-\n-    @Override\n-    public String getID() {\n-        return \"exe\";\n-    }\n-\n-    @Override\n-    public String getBundleType() {\n-        return \"INSTALLER\";\n-    }\n-\n-    @Override\n-    public boolean supported(boolean platformInstaller) {\n-        return msiBundler.supported(platformInstaller);\n-    }\n-\n-    @Override\n-    public boolean isDefault() {\n-        return true;\n-    }\n-\n-    @Override\n-    public boolean validate(Map<String, ? super Object> params)\n-            throws ConfigException {\n-        return msiBundler.validate(params, WinFromParams.EXE_PACKAGE);\n-    }\n-\n-    @Override\n-    public Path execute(Map<String, ? super Object> params, Path outdir)\n-            throws PackagerException {\n-\n-        \/\/ Order is important!\n-        var pkg = WinFromParams.EXE_PACKAGE.fetchFrom(params);\n-        var env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n-\n-        var msiOutputDir = env.buildRoot().resolve(\"msi\");\n-\n-        return Packager.<WinMsiPackage>build().outputDir(msiOutputDir)\n-                .pkg(pkg.msiPackage())\n-                .env(env)\n-                .pipelineBuilderMutatorFactory((packagingEnv, msiPackage, _) -> {\n-                    var msiPackager = new WinMsiPackager(packagingEnv, msiPackage,\n-                            msiOutputDir, msiBundler.sysEnv.orElseThrow());\n-                    var exePackager = new WinExePackager(packagingEnv, pkg, outdir, msiOutputDir);\n-                    return msiPackager.andThen(exePackager);\n-                }).execute(WinPackagingPipeline.build());\n-    }\n-\n@@ -93,2 +35,0 @@\n-\n-    private final WinMsiBundler msiBundler = new WinMsiBundler();\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinExeBundler.java","additions":1,"deletions":61,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.FromOptions.buildApplicationBuilder;\n+import static jdk.jpackage.internal.FromOptions.createPackageBuilder;\n+import static jdk.jpackage.internal.WinPackagingPipeline.APPLICATION_LAYOUT;\n+import static jdk.jpackage.internal.cli.StandardOption.ICON;\n+import static jdk.jpackage.internal.cli.StandardOption.RESOURCE_DIR;\n+import static jdk.jpackage.internal.cli.StandardOption.WIN_CONSOLE_HINT;\n+import static jdk.jpackage.internal.cli.StandardOption.WIN_HELP_URL;\n+import static jdk.jpackage.internal.cli.StandardOption.WIN_INSTALLDIR_CHOOSER;\n+import static jdk.jpackage.internal.cli.StandardOption.WIN_MENU_GROUP;\n+import static jdk.jpackage.internal.cli.StandardOption.WIN_MENU_HINT;\n+import static jdk.jpackage.internal.cli.StandardOption.WIN_PER_USER_INSTALLATION;\n+import static jdk.jpackage.internal.cli.StandardOption.WIN_SHORTCUT_HINT;\n+import static jdk.jpackage.internal.cli.StandardOption.WIN_SHORTCUT_PROMPT;\n+import static jdk.jpackage.internal.cli.StandardOption.WIN_UPDATE_URL;\n+import static jdk.jpackage.internal.cli.StandardOption.WIN_UPGRADE_UUID;\n+import static jdk.jpackage.internal.model.StandardPackageType.WIN_MSI;\n+\n+import jdk.jpackage.internal.cli.Options;\n+import jdk.jpackage.internal.model.Launcher;\n+import jdk.jpackage.internal.model.WinApplication;\n+import jdk.jpackage.internal.model.WinExePackage;\n+import jdk.jpackage.internal.model.WinLauncher;\n+import jdk.jpackage.internal.model.WinLauncherMixin;\n+import jdk.jpackage.internal.model.WinMsiPackage;\n+\n+final class WinFromOpions {\n+\n+    static WinApplication createWinApplication(Options options) {\n+\n+        final var launcherFromOptions = new LauncherFromOptions().faWithDefaultDescription();\n+\n+        final var appBuilder = buildApplicationBuilder().create(options, launcherOptions -> {\n+\n+            final var launcher = launcherFromOptions.create(launcherOptions);\n+\n+            final boolean isConsole = WIN_CONSOLE_HINT.getFrom(launcherOptions);\n+\n+            final var startMenuShortcut = WIN_MENU_HINT.findIn(launcherOptions);\n+\n+            final var desktopShortcut = WIN_SHORTCUT_HINT.findIn(launcherOptions);\n+\n+            return WinLauncher.create(launcher, new WinLauncherMixin.Stub(isConsole, startMenuShortcut, desktopShortcut));\n+\n+        }, (WinLauncher winLauncher, Launcher launcher) -> {\n+            return WinLauncher.create(launcher, winLauncher);\n+        }, APPLICATION_LAYOUT);\n+\n+        appBuilder.launchers().map(WinPackagingPipeline::normalizeShortcuts).ifPresent(appBuilder::launchers);\n+\n+        return WinApplication.create(appBuilder.create());\n+    }\n+\n+    static WinMsiPackage createWinMsiPackage(Options options) {\n+\n+        final var app = createWinApplication(options);\n+\n+        final var superPkgBuilder = createPackageBuilder(options, app, WIN_MSI);\n+\n+        final var pkgBuilder = new WinMsiPackageBuilder(superPkgBuilder);\n+\n+        WIN_HELP_URL.ifPresentIn(options, pkgBuilder::helpURL);\n+        pkgBuilder.isSystemWideInstall(!WIN_PER_USER_INSTALLATION.getFrom(options));\n+        WIN_MENU_GROUP.ifPresentIn(options, pkgBuilder::startMenuGroupName);\n+        WIN_UPDATE_URL.ifPresentIn(options, pkgBuilder::updateURL);\n+        WIN_INSTALLDIR_CHOOSER.ifPresentIn(options, pkgBuilder::withInstallDirChooser);\n+        WIN_SHORTCUT_PROMPT.ifPresentIn(options, pkgBuilder::withShortcutPrompt);\n+\n+        if (app.isService()) {\n+            RESOURCE_DIR.ifPresentIn(options, resourceDir -> {\n+                pkgBuilder.serviceInstaller(resourceDir.resolve(\"service-installer.exe\"));\n+            });\n+        }\n+\n+        WIN_UPGRADE_UUID.ifPresentIn(options, pkgBuilder::upgradeCode);\n+\n+        return pkgBuilder.create();\n+    }\n+\n+    static WinExePackage createWinExePackage(Options options) {\n+\n+        final var msiPkg = createWinMsiPackage(options);\n+\n+        final var pkgBuilder = new WinExePackageBuilder(msiPkg);\n+\n+        ICON.ifPresentIn(options, pkgBuilder::icon);\n+\n+        return pkgBuilder.create();\n+    }\n+}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinFromOpions.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -1,164 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import static jdk.jpackage.internal.BundlerParamInfo.createBooleanBundlerParam;\n-import static jdk.jpackage.internal.BundlerParamInfo.createStringBundlerParam;\n-import static jdk.jpackage.internal.FromParams.createApplicationBuilder;\n-import static jdk.jpackage.internal.FromParams.createApplicationBundlerParam;\n-import static jdk.jpackage.internal.FromParams.createPackageBuilder;\n-import static jdk.jpackage.internal.FromParams.createPackageBundlerParam;\n-import static jdk.jpackage.internal.FromParams.findLauncherShortcut;\n-import static jdk.jpackage.internal.StandardBundlerParam.ICON;\n-import static jdk.jpackage.internal.StandardBundlerParam.RESOURCE_DIR;\n-import static jdk.jpackage.internal.WinPackagingPipeline.APPLICATION_LAYOUT;\n-import static jdk.jpackage.internal.model.StandardPackageType.WIN_MSI;\n-import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n-\n-import java.io.IOException;\n-import java.util.Map;\n-import java.util.UUID;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.Launcher;\n-import jdk.jpackage.internal.model.WinApplication;\n-import jdk.jpackage.internal.model.WinExePackage;\n-import jdk.jpackage.internal.model.WinLauncher;\n-import jdk.jpackage.internal.model.WinLauncherMixin;\n-import jdk.jpackage.internal.model.WinMsiPackage;\n-\n-final class WinFromParams {\n-\n-    private static WinApplication createWinApplication(\n-            Map<String, ? super Object> params) throws ConfigException, IOException {\n-\n-        final var launcherFromParams = new LauncherFromParams();\n-\n-        final var app = createApplicationBuilder(params, toFunction(launcherParams -> {\n-\n-            final var launcher = launcherFromParams.create(launcherParams);\n-\n-            final boolean isConsole = CONSOLE_HINT.findIn(launcherParams).orElse(false);\n-\n-            final var startMenuShortcut = findLauncherShortcut(WIN_MENU_HINT, params, launcherParams);\n-\n-            final var desktopShortcut = findLauncherShortcut(WIN_SHORTCUT_HINT, params, launcherParams);\n-\n-            return WinLauncher.create(launcher, new WinLauncherMixin.Stub(isConsole, startMenuShortcut, desktopShortcut));\n-\n-        }), (WinLauncher winLauncher, Launcher launcher) -> {\n-            return WinLauncher.create(launcher, winLauncher);\n-        }, APPLICATION_LAYOUT).create();\n-\n-        return WinApplication.create(app);\n-    }\n-\n-    private static WinMsiPackage createWinMsiPackage(Map<String, ? super Object> params) throws ConfigException, IOException {\n-\n-        final var app = APPLICATION.fetchFrom(params);\n-\n-        final var superPkgBuilder = createPackageBuilder(params, app, WIN_MSI);\n-\n-        final var pkgBuilder = new WinMsiPackageBuilder(superPkgBuilder);\n-\n-        HELP_URL.copyInto(params, pkgBuilder::helpURL);\n-        MSI_SYSTEM_WIDE.copyInto(params, pkgBuilder::isSystemWideInstall);\n-        MENU_GROUP.copyInto(params, pkgBuilder::startMenuGroupName);\n-        UPDATE_URL.copyInto(params, pkgBuilder::updateURL);\n-        INSTALLDIR_CHOOSER.copyInto(params, pkgBuilder::withInstallDirChooser);\n-        SHORTCUT_PROMPT.copyInto(params, pkgBuilder::withShortcutPrompt);\n-\n-        if (app.isService()) {\n-            RESOURCE_DIR.copyInto(params, resourceDir -> {\n-                pkgBuilder.serviceInstaller(resourceDir.resolve(\"service-installer.exe\"));\n-            });\n-        }\n-\n-        try {\n-            UPGRADE_UUID.findIn(params).map(UUID::fromString).ifPresent(pkgBuilder::upgradeCode);\n-        } catch (IllegalArgumentException ex) {\n-            throw new ConfigException(ex);\n-        }\n-\n-        return pkgBuilder.create();\n-    }\n-\n-    private static WinExePackage createWinExePackage(Map<String, ? super Object> params) throws ConfigException, IOException {\n-\n-        final var msiPkg = MSI_PACKAGE.fetchFrom(params);\n-\n-        final var pkgBuilder = new WinExePackageBuilder(msiPkg);\n-\n-        ICON.copyInto(params, pkgBuilder::icon);\n-\n-        return pkgBuilder.create();\n-    }\n-\n-    static final BundlerParamInfo<WinApplication> APPLICATION = createApplicationBundlerParam(\n-            WinFromParams::createWinApplication);\n-\n-    static final BundlerParamInfo<WinMsiPackage> MSI_PACKAGE = createPackageBundlerParam(\n-            WinFromParams::createWinMsiPackage);\n-\n-    static final BundlerParamInfo<WinExePackage> EXE_PACKAGE = createPackageBundlerParam(\n-            WinFromParams::createWinExePackage);\n-\n-    private static final BundlerParamInfo<String> WIN_MENU_HINT = createStringBundlerParam(\n-            Arguments.CLIOptions.WIN_MENU_HINT.getId());\n-\n-    private static final BundlerParamInfo<String> WIN_SHORTCUT_HINT = createStringBundlerParam(\n-            Arguments.CLIOptions.WIN_SHORTCUT_HINT.getId());\n-\n-    public static final BundlerParamInfo<Boolean> CONSOLE_HINT = createBooleanBundlerParam(\n-            Arguments.CLIOptions.WIN_CONSOLE_HINT.getId());\n-\n-    private static final BundlerParamInfo<Boolean> INSTALLDIR_CHOOSER = new BundlerParamInfo<>(\n-            Arguments.CLIOptions.WIN_DIR_CHOOSER.getId(),\n-            Boolean.class,\n-            null,\n-            (s, p) -> Boolean.valueOf(s)\n-    );\n-\n-    private static final BundlerParamInfo<Boolean> SHORTCUT_PROMPT = new BundlerParamInfo<>(\n-            Arguments.CLIOptions.WIN_SHORTCUT_PROMPT.getId(),\n-            Boolean.class,\n-            null,\n-            (s, p) -> Boolean.valueOf(s)\n-    );\n-\n-    private static final BundlerParamInfo<String> MENU_GROUP = createStringBundlerParam(\n-            Arguments.CLIOptions.WIN_MENU_GROUP.getId());\n-\n-    private static final BundlerParamInfo<Boolean> MSI_SYSTEM_WIDE = createBooleanBundlerParam(\n-            Arguments.CLIOptions.WIN_PER_USER_INSTALLATION.getId());\n-\n-    private static final BundlerParamInfo<String> HELP_URL = createStringBundlerParam(\n-            Arguments.CLIOptions.WIN_HELP_URL.getId());\n-\n-    private static final BundlerParamInfo<String> UPDATE_URL = createStringBundlerParam(\n-            Arguments.CLIOptions.WIN_UPDATE_URL.getId());\n-\n-    private static final BundlerParamInfo<String> UPGRADE_UUID = createStringBundlerParam(\n-            Arguments.CLIOptions.WIN_UPGRADE_UUID.getId());\n-}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinFromParams.java","additions":0,"deletions":164,"binary":false,"changes":164,"status":"deleted"},{"patch":"@@ -1,122 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import static jdk.jpackage.internal.model.ConfigException.rethrowConfigException;\n-\n-import java.nio.file.Path;\n-import java.util.Map;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.Package;\n-import jdk.jpackage.internal.model.PackagerException;\n-import jdk.jpackage.internal.model.WinMsiPackage;\n-import jdk.jpackage.internal.util.Result;\n-\n-public class WinMsiBundler  extends AbstractBundler {\n-\n-    public WinMsiBundler() {\n-    }\n-\n-    @Override\n-    public String getName() {\n-        return I18N.getString(\"msi.bundler.name\");\n-    }\n-\n-    @Override\n-    public String getID() {\n-        return \"msi\";\n-    }\n-\n-    @Override\n-    public String getBundleType() {\n-        return \"INSTALLER\";\n-    }\n-\n-    @Override\n-    public boolean supported(boolean platformInstaller) {\n-        try {\n-            try {\n-                sysEnv.orElseThrow();\n-                return true;\n-            } catch (RuntimeException ex) {\n-                ConfigException.rethrowConfigException(ex);\n-            }\n-        } catch (ConfigException ce) {\n-            Log.error(ce.getMessage());\n-            if (ce.getAdvice() != null) {\n-                Log.error(ce.getAdvice());\n-            }\n-        } catch (Exception e) {\n-            Log.error(e.getMessage());\n-        }\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean isDefault() {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean validate(Map<String, ? super Object> params) throws ConfigException {\n-        return validate(params, WinFromParams.MSI_PACKAGE);\n-    }\n-\n-    boolean validate(Map<String, ? super Object> params, BundlerParamInfo<? extends Package> pkgParam)\n-            throws ConfigException {\n-        try {\n-            \/\/ Order is important!\n-            pkgParam.fetchFrom(params);\n-            BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n-\n-            final var wixToolset = sysEnv.orElseThrow().wixToolset();\n-\n-            for (var tool : wixToolset.getType().getTools()) {\n-                Log.verbose(I18N.format(\"message.tool-version\",\n-                        wixToolset.getToolPath(tool).getFileName(),\n-                        wixToolset.getVersion()));\n-            }\n-\n-            return true;\n-        } catch (RuntimeException re) {\n-            throw rethrowConfigException(re);\n-        }\n-    }\n-\n-    @Override\n-    public Path execute(Map<String, ? super Object> params,\n-            Path outputParentDir) throws PackagerException {\n-\n-        return Packager.<WinMsiPackage>build().outputDir(outputParentDir)\n-                .pkg(WinFromParams.MSI_PACKAGE.fetchFrom(params))\n-                .env(BuildEnvFromParams.BUILD_ENV.fetchFrom(params))\n-                .pipelineBuilderMutatorFactory((env, pkg, outputDir) -> {\n-                    return new WinMsiPackager(env, pkg, outputDir, sysEnv.orElseThrow());\n-                }).execute(WinPackagingPipeline.build());\n-    }\n-\n-    final Result<WinSystemEnvironment> sysEnv = WinSystemEnvironment.create();\n-}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinMsiBundler.java","additions":0,"deletions":122,"binary":false,"changes":122,"status":"deleted"},{"patch":"@@ -56,1 +56,0 @@\n-import jdk.jpackage.internal.model.PackagerException;\n@@ -175,1 +174,1 @@\n-    private void prepareConfigFiles() throws PackagerException, IOException {\n+    private void prepareConfigFiles() throws IOException {\n@@ -317,1 +316,1 @@\n-    private void buildPackage() throws PackagerException, IOException {\n+    private void buildPackage() throws IOException {\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinMsiPackager.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import static jdk.jpackage.internal.ApplicationBuilder.normalizeLauncherProperty;\n@@ -31,0 +32,4 @@\n+import java.nio.file.Path;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n@@ -36,0 +41,1 @@\n+import jdk.jpackage.internal.model.ApplicationLaunchers;\n@@ -37,1 +43,1 @@\n-import jdk.jpackage.internal.model.PackagerException;\n+import jdk.jpackage.internal.model.LauncherShortcut;\n@@ -40,0 +46,1 @@\n+import jdk.jpackage.internal.model.WinLauncherMixin;\n@@ -56,0 +63,27 @@\n+    static ApplicationLaunchers normalizeShortcuts(ApplicationLaunchers appLaunchers) {\n+\n+        appLaunchers = normalizeShortcuts(appLaunchers, WinLauncher::startMenuShortcut, (launcher, shortcut) -> {\n+            return new WinLauncherMixin.Stub(launcher.isConsole(), shortcut, launcher.desktopShortcut());\n+        });\n+\n+        appLaunchers = normalizeShortcuts(appLaunchers, WinLauncher::desktopShortcut, (launcher, shortcut) -> {\n+            return new WinLauncherMixin.Stub(launcher.isConsole(), launcher.startMenuShortcut(), shortcut);\n+        });\n+\n+        return appLaunchers;\n+    }\n+\n+    private static ApplicationLaunchers normalizeShortcuts(\n+            ApplicationLaunchers appLaunchers,\n+            Function<WinLauncher, Optional<LauncherShortcut>> shortcutGetter,\n+            BiFunction<WinLauncherMixin, Optional<LauncherShortcut>, WinLauncherMixin> shortcutOverrider) {\n+        return normalizeLauncherProperty(appLaunchers, launcher -> {\n+            \/\/ Return \"true\" if shortcut is not configured for the launcher.\n+            return shortcutGetter.apply(launcher).isEmpty();\n+        }, (WinLauncher launcher) -> {\n+            return shortcutGetter.apply(launcher).flatMap(LauncherShortcut::startupDirectory);\n+        }, (launcher, shortcut) -> {\n+            return WinLauncher.create(launcher, shortcutOverrider.apply(launcher, Optional.of(new LauncherShortcut(shortcut))));\n+        });\n+    }\n+\n@@ -57,1 +91,1 @@\n-            throws IOException, PackagerException {\n+            throws IOException {\n@@ -82,1 +116,6 @@\n-    static final ApplicationLayout APPLICATION_LAYOUT = ApplicationLayoutUtils.PLATFORM_APPLICATION_LAYOUT;\n+    static final ApplicationLayout APPLICATION_LAYOUT = ApplicationLayout.build()\n+            .setAll(\"\")\n+            .appDirectory(\"app\")\n+            .runtimeDirectory(\"runtime\")\n+            .appModsDirectory(Path.of(\"app\", \"mods\"))\n+            .create();\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinPackagingPipeline.java","additions":42,"deletions":3,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.WIN_LAUNCHER_DESKTOP_SHORTCUT;\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.WIN_LAUNCHER_MENU_SHORTCUT;\n+\n@@ -51,1 +54,1 @@\n-            shortcut.store(SHORTCUT_DESKTOP_ID, map::put);\n+            shortcut.store(WIN_LAUNCHER_DESKTOP_SHORTCUT.getName(), map::put);\n@@ -54,1 +57,1 @@\n-            shortcut.store(SHORTCUT_START_MENU_ID, map::put);\n+            shortcut.store(WIN_LAUNCHER_MENU_SHORTCUT.getName(), map::put);\n@@ -62,3 +65,0 @@\n-\n-    public static final String SHORTCUT_START_MENU_ID = \"win-menu\";\n-    public static final String SHORTCUT_DESKTOP_ID = \"win-shortcut\";\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/model\/WinLauncher.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,5 +26,0 @@\n-\n-app.bundler.name=Windows Application Image\n-exe.bundler.name=EXE Installer Package\n-msi.bundler.name=MSI Installer Package\n-\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResources.properties","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,5 +26,2 @@\n-provides jdk.jpackage.internal.Bundler with\n-    jdk.jpackage.internal.WinAppBundler,\n-    jdk.jpackage.internal.WinExeBundler,\n-    jdk.jpackage.internal.WinMsiBundler;\n-\n+provides jdk.jpackage.internal.cli.CliBundlingEnvironment with\n+    jdk.jpackage.internal.WinBundlingEnvironment;\n","filename":"src\/jdk.jpackage\/windows\/classes\/module-info.java.extra","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+    jdk.jpackage\/jdk.jpackage.internal.cli \\\n+    jdk.jpackage\/jdk.jpackage.internal.model \\\n","filename":"test\/jdk\/tools\/jpackage\/TEST.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n@@ -32,0 +33,1 @@\n+import java.util.Collections;\n@@ -33,0 +35,1 @@\n+import java.util.LinkedHashMap;\n@@ -38,0 +41,1 @@\n+import javax.xml.xpath.XPathExpressionException;\n@@ -43,1 +47,0 @@\n-import org.w3c.dom.Node;\n@@ -45,1 +48,1 @@\n-public record AppImageFile(String mainLauncherName, String mainLauncherClassName,\n+public record AppImageFile(String mainLauncherName, Optional<String> mainLauncherClassName,\n@@ -64,1 +67,1 @@\n-    public AppImageFile(String mainLauncherName, String mainLauncherClassName) {\n+    public AppImageFile(String mainLauncherName, Optional<String> mainLauncherClassName) {\n@@ -68,0 +71,4 @@\n+    public AppImageFile(String mainLauncherName, String mainLauncherClassName) {\n+        this(mainLauncherName, Optional.of(mainLauncherClassName));\n+    }\n+\n@@ -69,1 +76,1 @@\n-        return launchers.entrySet().stream().filter(e -> {\n+        var map = launchers.entrySet().stream().filter(e -> {\n@@ -71,1 +78,4 @@\n-        }).collect(toMap(Map.Entry::getKey, Map.Entry::getValue));\n+        }).collect(toMap(Map.Entry::getKey, Map.Entry::getValue, (k, _) -> {\n+            throw new IllegalStateException(String.format(\"Duplicate key %s\", k));\n+        }, LinkedHashMap::new));\n+        return Collections.unmodifiableMap(map);\n@@ -85,1 +95,1 @@\n-            xml.writeCharacters(mainLauncherName);\n+            xml.writeAttribute(\"name\", mainLauncherName);\n@@ -88,3 +98,5 @@\n-            xml.writeStartElement(\"main-class\");\n-            xml.writeCharacters(mainLauncherClassName);\n-            xml.writeEndElement();\n+            mainLauncherClassName.ifPresent(toConsumer(v -> {\n+                xml.writeStartElement(\"main-class\");\n+                xml.writeCharacters(v);\n+                xml.writeEndElement();\n+            }));\n@@ -123,5 +135,2 @@\n-            var mainLauncherName = xPath.evaluate(\n-                    \"\/jpackage-state\/main-launcher\/text()\", doc);\n-\n-            var mainLauncherClassName = xPath.evaluate(\n-                    \"\/jpackage-state\/main-class\/text()\", doc);\n+            var mainLauncherClassName = Optional.ofNullable(xPath.evaluate(\n+                    \"\/jpackage-state\/main-class\/text()\", doc));\n@@ -137,2 +146,3 @@\n-            var addLaunchers = XmlUtils.queryNodes(doc, xPath, \"\/jpackage-state\/add-launcher\").map(Element.class::cast).map(toFunction(addLauncher -> {\n-                Map<String, String> launcherProps = new HashMap<>();\n+            var addLaunchers = XmlUtils.queryNodes(doc, xPath, \"\/jpackage-state\/add-launcher\").map(Element.class::cast).map(toFunction(launcher -> {\n+                return readLauncherProperties(xPath, launcher);\n+            }));\n@@ -140,4 +150,22 @@\n-                \/\/ @name and @service attributes.\n-                XmlUtils.toStream(addLauncher.getAttributes()).forEach(attr -> {\n-                    launcherProps.put(attr.getNodeName(), attr.getNodeValue());\n-                });\n+            var mainLauncher = XmlUtils.queryNodes(doc, xPath, \"\/jpackage-state\/main-launcher[last()]\").map(Element.class::cast).map(toFunction(launcher -> {\n+                return readLauncherProperties(xPath, launcher);\n+            })).findFirst().orElseThrow();\n+\n+            var mainLauncherName = mainLauncher.get(\"name\");\n+\n+            var launchers = Stream.concat(Stream.of(mainLauncher), addLaunchers).collect(toMap(launcherProps -> {\n+                return Objects.requireNonNull(launcherProps.get(\"name\"));\n+            }, launcherProps -> {\n+                launcherProps.remove(\"name\");\n+                return Collections.unmodifiableMap(launcherProps);\n+            }, (k, _) -> {\n+                throw new IllegalStateException(String.format(\"Duplicate key %s\", k));\n+            }, LinkedHashMap::new));\n+\n+            return new AppImageFile(\n+                    mainLauncherName,\n+                    mainLauncherClassName,\n+                    version,\n+                    macSigned,\n+                    macAppStore,\n+                    Collections.unmodifiableMap(launchers));\n@@ -145,4 +173,2 @@\n-                \/\/ Extra properties.\n-                XmlUtils.queryNodes(addLauncher, xPath, \"*[count(*) = 0]\").map(Element.class::cast).forEach(e -> {\n-                    launcherProps.put(e.getNodeName(), e.getTextContent());\n-                });\n+        }).get();\n+    }\n@@ -150,2 +176,2 @@\n-                return launcherProps;\n-            }));\n+    private static HashMap<String, String> readLauncherProperties(XPath xPath, Element launcherElement) throws XPathExpressionException {\n+        HashMap<String, String> launcherProps = new HashMap<>();\n@@ -153,1 +179,1 @@\n-            var mainLauncherProperties = Map.of(\"name\", mainLauncherName);\n+        var name = Objects.requireNonNull(xPath.evaluate(\"@name\", launcherElement));\n@@ -155,7 +181,1 @@\n-            var launchers = Stream.concat(Stream.of(mainLauncherProperties), addLaunchers).collect(toMap(attrs -> {\n-                return Objects.requireNonNull(attrs.get(\"name\"));\n-            }, attrs -> {\n-                Map<String, String> copy = new HashMap<>(attrs);\n-                copy.remove(\"name\");\n-                return Map.copyOf(copy);\n-            }));\n+        launcherProps.put(\"name\", name);\n@@ -163,2 +183,4 @@\n-            return new AppImageFile(mainLauncherName, mainLauncherClassName,\n-                    version, macSigned, macAppStore, launchers);\n+        \/\/ Extra properties.\n+        XmlUtils.queryNodes(launcherElement, xPath, \"*[count(*) = 0]\").map(Element.class::cast).forEach(e -> {\n+            launcherProps.put(e.getNodeName(), e.getTextContent());\n+        });\n@@ -166,1 +188,1 @@\n-        }).get();\n+        return launcherProps;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/AppImageFile.java","additions":59,"deletions":37,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -796,1 +796,1 @@\n-                PropertyFinder.appImageFile(AppImageFile::mainLauncherClassName).map(getPackageIdFromClassName)\n+                PropertyFinder.appImageFileOptional(AppImageFile::mainLauncherClassName).map(getPackageIdFromClassName)\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacHelper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,5 +25,0 @@\n-import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n-\n-import java.io.PrintWriter;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n@@ -33,0 +28,1 @@\n+import java.util.NoSuchElementException;\n@@ -35,0 +31,1 @@\n+import java.util.ServiceLoader;\n@@ -36,1 +33,0 @@\n-import java.util.concurrent.atomic.AtomicBoolean;\n@@ -39,1 +35,4 @@\n-import jdk.jpackage.internal.Log;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.model.BundlingEnvironment;\n+import jdk.jpackage.internal.model.BundlingOperationDescriptor;\n+import jdk.jpackage.internal.util.function.ThrowingSupplier;\n@@ -45,10 +44,6 @@\n-    WIN_MSI(\".msi\",\n-            TKit.isWindows() ? \"jdk.jpackage.internal.WinMsiBundler\" : null),\n-    WIN_EXE(\".exe\",\n-            TKit.isWindows() ? \"jdk.jpackage.internal.WinMsiBundler\" : null),\n-    LINUX_DEB(\".deb\",\n-            TKit.isLinux() ? \"jdk.jpackage.internal.LinuxDebBundler\" : null),\n-    LINUX_RPM(\".rpm\",\n-            TKit.isLinux() ? \"jdk.jpackage.internal.LinuxRpmBundler\" : null),\n-    MAC_DMG(\".dmg\", TKit.isOSX() ? \"jdk.jpackage.internal.MacDmgBundler\" : null),\n-    MAC_PKG(\".pkg\", TKit.isOSX() ? \"jdk.jpackage.internal.MacPkgBundler\" : null),\n+    WIN_MSI(\".msi\", OperatingSystem.WINDOWS),\n+    WIN_EXE(\".exe\", OperatingSystem.WINDOWS),\n+    LINUX_DEB(\".deb\", OperatingSystem.LINUX),\n+    LINUX_RPM(\".rpm\", OperatingSystem.LINUX),\n+    MAC_DMG(\".dmg\", OperatingSystem.MACOS),\n+    MAC_PKG(\".pkg\", OperatingSystem.MACOS),\n@@ -64,1 +59,1 @@\n-    PackageType(String packageName, String bundleSuffix, String bundlerClass) {\n+    PackageType(String packageName, String bundleSuffix, OperatingSystem os) {\n@@ -67,1 +62,1 @@\n-        supported = Optional.ofNullable(bundlerClass).map(PackageType::isBundlerSupported).orElse(false);\n+        supported = isSupported(new BundlingOperationDescriptor(os, type, \"create\"));\n@@ -75,2 +70,2 @@\n-    PackageType(String bundleSuffix, String bundlerClass) {\n-        this(bundleSuffix.substring(1), bundleSuffix, bundlerClass);\n+    PackageType(String bundleSuffix, OperatingSystem os) {\n+        this(bundleSuffix.substring(1), bundleSuffix, os);\n@@ -108,16 +103,1 @@\n-    private static boolean isBundlerSupportedImpl(String bundlerClass) {\n-        try {\n-            Class<?> clazz = Class.forName(bundlerClass);\n-            Method supported = clazz.getMethod(\"supported\", boolean.class);\n-            return ((Boolean) supported.invoke(\n-                    clazz.getConstructor().newInstance(), true));\n-        } catch (ClassNotFoundException | IllegalAccessException ex) {\n-        } catch (InstantiationException | NoSuchMethodException\n-                | InvocationTargetException ex) {\n-            rethrowUnchecked(ex);\n-        }\n-        return false;\n-    }\n-\n-    private static boolean isBundlerSupported(String bundlerClass) {\n-        AtomicBoolean reply = new AtomicBoolean();\n+    private static boolean isSupported(BundlingOperationDescriptor op) {\n@@ -125,17 +105,3 @@\n-            \/\/ Capture jpackage's activity on configuring bundlers.\n-            \/\/ Log configuration is thread-local.\n-            \/\/ Call Log.setPrintWriter and Log.setVerbose in a separate\n-            \/\/ thread to keep the main log configuration intact.\n-            var thread = new Thread(() -> {\n-                Log.setPrintWriter(new PrintWriter(System.out), new PrintWriter(System.err));\n-                Log.setVerbose();\n-                try {\n-                    reply.set(isBundlerSupportedImpl(bundlerClass));\n-                } finally {\n-                    Log.flush();\n-                }\n-            });\n-            thread.run();\n-            thread.join();\n-        } catch (InterruptedException ex) {\n-            rethrowUnchecked(ex);\n+            return Inner.BUNDLING_ENV.configurationErrors(op).isEmpty();\n+        } catch (NoSuchElementException ex) {\n+            return false;\n@@ -143,1 +109,0 @@\n-        return reply.get();\n@@ -166,0 +131,9 @@\n+\n+        private static final BundlingEnvironment BUNDLING_ENV = ServiceLoader.load(\n+                ThrowingSupplier.toSupplier(() -> {\n+                    @SuppressWarnings(\"unchecked\")\n+                    var reply = (Class<BundlingEnvironment>)Class.forName(\"jdk.jpackage.internal.cli.CliBundlingEnvironment\");\n+                    return reply;\n+                }).get(),\n+                BundlingEnvironment.class.getClassLoader()\n+        ).findFirst().orElseThrow();\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/PackageType.java","additions":29,"deletions":55,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -3,1 +3,6 @@\n-lib.dirs = \/test\/jdk\/tools\/jpackage\/helpers \/test\/jdk\/tools\/jpackage\/junit\/tools\n+# \/test\/jdk\/tools\/jpackage\/share is needed to load ErrorTest class used in\n+# jdk.jpackage.internal.cli.StandardValueConverterTest unit test.\n+lib.dirs = \\\n+        \/test\/jdk\/tools\/jpackage\/helpers \\\n+        \/test\/jdk\/tools\/jpackage\/share \\\n+        \/test\/jdk\/tools\/jpackage\/junit\/tools\n@@ -6,0 +11,1 @@\n+        jdk.jpackage\/jdk.jpackage.internal.cli:+open \\\n","filename":"test\/jdk\/tools\/jpackage\/junit\/TEST.properties","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,0 +26,11 @@\n+import static java.util.stream.Collectors.toMap;\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.LAUNCHER_AS_SERVICE;\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.LAUNCHER_NAME;\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.LINUX_LAUNCHER_SHORTCUT;\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.MAC_APP_STORE;\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.MAC_SIGNED;\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.WIN_LAUNCHER_DESKTOP_SHORTCUT;\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.WIN_LAUNCHER_MENU_SHORTCUT;\n+import static jdk.jpackage.internal.cli.StandardOption.APPCLASS;\n+import static jdk.jpackage.internal.cli.StandardOption.APP_VERSION;\n+import static jdk.jpackage.internal.cli.StandardOption.NAME;\n@@ -27,0 +38,2 @@\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n@@ -29,0 +42,1 @@\n+import java.io.FileOutputStream;\n@@ -34,0 +48,1 @@\n+import java.util.Collection;\n@@ -39,2 +54,1 @@\n-import java.util.function.Function;\n-import java.util.stream.Collectors;\n+import java.util.function.Supplier;\n@@ -42,0 +56,6 @@\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.cli.OptionIdentifier;\n+import jdk.jpackage.internal.cli.OptionValue;\n+import jdk.jpackage.internal.cli.Options;\n+import jdk.jpackage.internal.cli.StandardAppImageFileOption.AppImageFileOptionScope;\n+import jdk.jpackage.internal.cli.WithOptionIdentifier;\n@@ -45,1 +65,1 @@\n-import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.ExternalApplication;\n@@ -47,0 +67,1 @@\n+import jdk.jpackage.internal.model.JPackageException;\n@@ -48,1 +69,3 @@\n-import jdk.jpackage.internal.model.LauncherStartupInfo;\n+import jdk.jpackage.internal.model.LauncherShortcut;\n+import jdk.jpackage.internal.model.LauncherShortcutStartupDirectory;\n+import jdk.jpackage.test.ObjectMapper;\n@@ -51,0 +74,2 @@\n+import org.junit.jupiter.api.condition.EnabledOnOs;\n+import org.junit.jupiter.api.condition.OS;\n@@ -53,1 +78,0 @@\n-import org.junit.jupiter.params.provider.Arguments;\n@@ -59,2 +83,55 @@\n-    static AppImageBuilder build() {\n-        return new AppImageBuilder();\n+    @Test\n+    public void testSimple() {\n+        build().createInDir(tempFolder);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testArbitraryExtra(Map<String, String> extra) {\n+        build().addExtra(extra).createInDir(tempFolder);\n+    }\n+\n+    @Test\n+    public void testAdditionalLaunchers() {\n+        build().addlauncher(\"T\").commit()\n+                .addlauncher(\"U\").service(true).commit()\n+                .addlauncher(\"F\").addExtra(Map.of(\"prop\", \"one\", \"prop2\", \"two\", \"prop3\", \"\")).commit()\n+                .createInDir(tempFolder);\n+    }\n+\n+    @Test\n+    public void testMalformedXml() throws IOException {\n+        var ex = assertThrowsExactly(JPackageException.class, () -> createFromXml(List.of(\"<a>\"), OperatingSystem.current(), tempFolder));\n+        Assertions.assertEquals(I18N.format(\"error.malformed-app-image-file\", \".jpackage.xml\", tempFolder), ex.getMessage());\n+        assertNotNull(ex.getCause());\n+    }\n+\n+    @Test\n+    public void testNoSuchFile() throws IOException {\n+        var ex = assertThrowsExactly(JPackageException.class, () -> AppImageFile.load(DUMMY_LAYOUT.resolveAt(tempFolder)));\n+        Assertions.assertEquals(I18N.format(\"error.missing-app-image-file\", \".jpackage.xml\", tempFolder), ex.getMessage());\n+        assertNull(ex.getCause());\n+    }\n+\n+    @Test\n+    public void testDirectory() throws IOException {\n+        Files.createDirectory(AppImageFile.getPathInAppImage(DUMMY_LAYOUT.resolveAt(tempFolder)));\n+\n+        var ex = assertThrowsExactly(JPackageException.class, () -> AppImageFile.load(DUMMY_LAYOUT.resolveAt(tempFolder)));\n+        Assertions.assertEquals(I18N.format(\"error.reading-app-image-file\", \".jpackage.xml\", tempFolder), ex.getMessage());\n+        assertNotNull(ex.getCause());\n+    }\n+\n+    @Test\n+    @EnabledOnOs(value = OS.WINDOWS, disabledReason = \"Can reliably lock a file using FileLock to cuase an IOException on Windows only\")\n+    @SuppressWarnings(\"try\")\n+    public void testGenericIOException() throws IOException {\n+\n+        final var appImageFile = AppImageFile.getPathInAppImage(DUMMY_LAYOUT.resolveAt(tempFolder));\n+        Files.writeString(appImageFile, \"\");\n+\n+        try (var out = new FileOutputStream(appImageFile.toFile()); var lock = out.getChannel().lock()) {\n+            var ex = assertThrowsExactly(JPackageException.class, () -> AppImageFile.load(DUMMY_LAYOUT.resolveAt(tempFolder)));\n+            Assertions.assertEquals(I18N.format(\"error.reading-app-image-file\", \".jpackage.xml\", tempFolder), ex.getMessage());\n+            assertNotNull(ex.getCause());\n+        }\n@@ -63,1 +140,13 @@\n-    static class AppImageBuilder {\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testInavlidXml(List<String> xmlData) throws IOException {\n+        var ex = assertThrowsExactly(JPackageException.class, () -> createFromXml(xmlData, OperatingSystem.current(), tempFolder));\n+        Assertions.assertEquals(I18N.format(\"error.invalid-app-image-file\", \".jpackage.xml\", tempFolder), ex.getMessage());\n+        assertNotNull(ex.getCause());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testValidXml(ReadTestSpec testSpec) throws IOException {\n+        testSpec.test(tempFolder);\n+    }\n@@ -65,1 +154,4 @@\n-        AppImageBuilder version(String v) {\n+\n+    private static final class AppBuilder {\n+\n+        AppBuilder version(String v) {\n@@ -70,2 +162,2 @@\n-        AppImageBuilder launcherName(String v) {\n-            launcherName = Objects.requireNonNull(v);\n+        AppBuilder appName(String v) {\n+            appName = Objects.requireNonNull(v);\n@@ -75,1 +167,1 @@\n-        AppImageBuilder mainClass(String v) {\n+        AppBuilder mainClass(String v) {\n@@ -80,2 +172,2 @@\n-        AppImageBuilder addExtra(Map<String, String> v) {\n-            extra.putAll(v);\n+        AppBuilder addExtra(Map<String, String> v) {\n+            extra.add(v);\n@@ -85,2 +177,2 @@\n-        AppImageBuilder addExtra(String key, String value) {\n-            extra.putAll(Map.of(key, value));\n+        <T> AppBuilder addExtra(WithOptionIdentifier option, T value) {\n+            extra.add(option, value);\n@@ -90,2 +182,2 @@\n-        AppImageBuilder addlauncher(String name) {\n-            return addlauncher(name, false);\n+        LauncherBuilder addlauncher(String name) {\n+            return new LauncherBuilder(name);\n@@ -94,2 +186,2 @@\n-        AppImageBuilder addlauncher(String name, boolean isService) {\n-            return addlauncher(name, isService, Map.of());\n+        LauncherBuilder mainlauncher() {\n+            return mainLauncherBuilder;\n@@ -98,5 +190,18 @@\n-        AppImageBuilder addlauncher(String name, boolean isService, Map<String, String> extra) {\n-            Objects.requireNonNull(name);\n-            Objects.requireNonNull(extra);\n-            addLauncherInfos.add(new LauncherInfo(name, isService, extra));\n-            return this;\n+        ExternalApplication createExternalApplication(OperatingSystem os) {\n+            var mainLauncherInfo = mainLauncherBuilder.createLauncherInfo();\n+\n+            var appOptions = Options.concat(\n+                    Options.of(Map.of(\n+                            APP_VERSION, version,\n+                            NAME, appName,\n+                            APPCLASS, mainClass)\n+                    ),\n+                    extra.asObjectValues(),\n+                    mainLauncherInfo.asOptions());\n+\n+            return ExternalApplication.create(\n+                    appOptions,\n+                    addLauncherBuilders.stream()\n+                            .map(LauncherBuilder::createLauncherInfo)\n+                            .map(LauncherInfo::asOptions).toList(),\n+                    os);\n@@ -105,2 +210,23 @@\n-        AppImageBuilder addlauncher(String name, Map<String, String> extra) {\n-            return addlauncher(name, false, extra);\n+        private Application createApplication() {\n+            var mainLauncher = mainLauncherBuilder.createLauncher();\n+\n+            var fullExtra = extra.asStringValues();\n+            if (OperatingSystem.isMacOS() && !fullExtra.containsKey(APPCLASS.getName())) {\n+                fullExtra = new HashMap<>(fullExtra);\n+                fullExtra.put(APPCLASS.getName(), mainClass);\n+            }\n+\n+            return new Application.Stub(\n+                    null,\n+                    null,\n+                    version,\n+                    null,\n+                    null,\n+                    Optional.empty(),\n+                    List.of(),\n+                    null,\n+                    Optional.empty(),\n+                    new ApplicationLaunchers(\n+                            mainLauncher,\n+                            addLauncherBuilders.stream().map(LauncherBuilder::createLauncher).toList()).asList(),\n+                    fullExtra);\n@@ -109,5 +235,7 @@\n-        AppImageFile create() {\n-            final var additionalLaunchers = addLauncherInfos.stream().map(li -> {\n-                return (Launcher)new Launcher.Stub(li.name(), Optional.empty(),\n-                        List.of(), li.service(), null, Optional.empty(), null, li.extra());\n-            }).toList();\n+        void createInDir(Path dir) {\n+            final var app = createApplication();\n+            final var copy = toSupplier(() -> {\n+                var layout = DUMMY_LAYOUT.resolveAt(dir);\n+                new AppImageFile(app).save(layout);\n+                return AppImageFile.load(layout);\n+            }).get();\n@@ -115,3 +243,2 @@\n-            final var startupInfo = new LauncherStartupInfo.Stub(mainClass, List.of(), List.of(), List.of());\n-            final var mainLauncher = new Launcher.Stub(launcherName, Optional.of(startupInfo),\n-                    List.of(), false, null, Optional.empty(), null, Map.of());\n+            assertEquals(createExternalApplication(OperatingSystem.current()), copy);\n+        }\n@@ -119,3 +246,0 @@\n-            final var app = new Application.Stub(null, null, version, null, null,\n-                    Optional.empty(), List.of(), null, Optional.empty(),\n-                    new ApplicationLaunchers(mainLauncher, additionalLaunchers).asList(), extra);\n@@ -123,1 +247,67 @@\n-            return new AppImageFile(app);\n+        final class LauncherBuilder {\n+            private LauncherBuilder(String name) {\n+                this.name = Optional.of(name);\n+            }\n+\n+            private LauncherBuilder() {\n+                this.name = Optional.empty();\n+            }\n+\n+            LauncherBuilder service(boolean v) {\n+                service = v;\n+                return this;\n+            }\n+\n+            LauncherBuilder addExtra(Map<String, String> v) {\n+                extra.add(v);\n+                return this;\n+            }\n+\n+            <T> LauncherBuilder addExtra(WithOptionIdentifier option, T value) {\n+                extra.add(option, value);\n+                return this;\n+            }\n+\n+            AppBuilder commit() {\n+                if (!isMainLauncher()) {\n+                    addLauncherBuilders.add(this);\n+                }\n+                return AppBuilder.this;\n+            }\n+\n+            private Launcher createLauncher() {\n+                return new Launcher.Stub(\n+                        name(),\n+                        Optional.empty(),\n+                        List.of(),\n+                        service,\n+                        null,\n+                        Optional.empty(),\n+                        null,\n+                        extra.asStringValues());\n+            }\n+\n+            private String name() {\n+                if (isMainLauncher()) {\n+                    return Objects.requireNonNull(appName);\n+                } else {\n+                    return name.orElseThrow();\n+                }\n+            }\n+\n+            private boolean isMainLauncher() {\n+                return name.isEmpty();\n+            }\n+\n+            private LauncherInfo createLauncherInfo() {\n+                var allProps = new ExtraPropertyBuilder(extra);\n+                if (service) {\n+                    allProps.add(LAUNCHER_AS_SERVICE, Boolean.valueOf(service));\n+                }\n+                allProps.add(LAUNCHER_NAME, name());\n+                return LauncherInfo.create(allProps.asObjectValues());\n+            }\n+\n+            private final Optional<String> name;\n+            private boolean service;\n+            private final ExtraPropertyBuilder extra = new ExtraPropertyBuilder();\n@@ -126,6 +316,0 @@\n-        void createInDir(Path dir) {\n-            final var file = create();\n-            final var copy = toSupplier(() -> {\n-                file.save(DUMMY_LAYOUT.resolveAt(dir));\n-                return AppImageFile.load(dir, DUMMY_LAYOUT);\n-            }).get();\n@@ -133,1 +317,30 @@\n-            assertEquals(file, copy);\n+        private static final class ExtraPropertyBuilder {\n+\n+            ExtraPropertyBuilder() {\n+            }\n+\n+            ExtraPropertyBuilder(ExtraPropertyBuilder other) {\n+                stringValues.putAll(other.stringValues);\n+                objValues.putAll(other.objValues);\n+            }\n+\n+            ExtraPropertyBuilder add(Map<String, String> v) {\n+                stringValues.putAll(v);\n+                return this;\n+            }\n+\n+            <T> ExtraPropertyBuilder add(WithOptionIdentifier option, T value) {\n+                objValues.put(option, Objects.requireNonNull(value));\n+                return this;\n+            }\n+\n+            Map<String, String> asStringValues() {\n+                return Map.copyOf(stringValues);\n+            }\n+\n+            Options asObjectValues() {\n+                return Options.of(objValues);\n+            }\n+\n+            private final Map<String, String> stringValues = new HashMap<>();\n+            private final Map<WithOptionIdentifier, Object> objValues = new HashMap<>();\n@@ -136,0 +349,1 @@\n+\n@@ -137,1 +351,1 @@\n-        private String launcherName = \"Foo\";\n+        private String appName = \"Foo\";\n@@ -139,2 +353,3 @@\n-        private Map<String, String> extra = new HashMap<>();\n-        private List<LauncherInfo> addLauncherInfos = new ArrayList<>();\n+        private final ExtraPropertyBuilder extra = new ExtraPropertyBuilder();\n+        private final LauncherBuilder mainLauncherBuilder = new LauncherBuilder();\n+        private final List<LauncherBuilder> addLauncherBuilders = new ArrayList<>();\n@@ -143,3 +358,47 @@\n-    @Test\n-    public void testSimple() {\n-        build().createInDir(tempFolder);\n+\n+    private record ReadTestSpec(ExternalApplication expected, List<String> xmlData, OperatingSystem os) {\n+\n+        ReadTestSpec {\n+            Objects.requireNonNull(expected);\n+            Objects.requireNonNull(xmlData);\n+            Objects.requireNonNull(os);\n+        }\n+\n+        void test(Path appImageDir) throws IOException {\n+            var actual = createFromXml(xmlData, os, appImageDir);\n+            assertEquals(expected, actual);\n+        }\n+\n+        static Builder build() {\n+            return new Builder();\n+        }\n+\n+        static final class Builder {\n+\n+            Builder expect(AppBuilder builder) {\n+                return expect(builder.createExternalApplication(os));\n+            }\n+\n+            Builder expect(ExternalApplication v) {\n+                expected = v;\n+                return this;\n+            }\n+\n+            Builder xml(String... xml) {\n+                xmlData = List.of(xml);\n+                return this;\n+            }\n+\n+            Builder os(OperatingSystem v) {\n+                os = v;\n+                return this;\n+            }\n+\n+            ReadTestSpec create() {\n+                return new ReadTestSpec(expected, createXml(os, xmlData.toArray(String[]::new)), os);\n+            }\n+\n+            private ExternalApplication expected;\n+            private List<String> xmlData;\n+            private OperatingSystem os = OperatingSystem.LINUX;\n+        }\n@@ -148,4 +407,3 @@\n-    @ParameterizedTest\n-    @MethodSource\n-    public void testExtra(Map<String, String> extra) {\n-        build().addExtra(extra).createInDir(tempFolder);\n+\n+    private static AppBuilder build() {\n+        return new AppBuilder();\n@@ -154,1 +412,1 @@\n-    private static Stream<Map<String, String>> testExtra() {\n+    private static Stream<Map<String, String>> testArbitraryExtra() {\n@@ -158,6 +416,33 @@\n-    @Test\n-    public void testAdditionalLaunchers() {\n-        build().addlauncher(\"T\")\n-                .addlauncher(\"U\", true)\n-                .addlauncher(\"F\", Map.of(\"prop\", \"one\", \"prop2\", \"two\", \"prop3\", \"\"))\n-                .createInDir(tempFolder);\n+    private static List<List<String>> testInavlidXml() {\n+        List<List<String>> data = new ArrayList<>();\n+\n+        var os = OperatingSystem.current();\n+\n+        data.addAll(List.of\n+                (List.of(\"<foo\/>\"),\n+                createValidBodyWithHeader(null, null),\n+                createValidBodyWithHeader(\"foo\", \"foo\"),\n+                createValidBodyWithHeader(null, \"foo\"),\n+                createValidBodyWithHeader(\"foo\", null),\n+                createValidBodyWithHeader(AppImageFile.getPlatform(os), null),\n+                createValidBodyWithHeader(AppImageFile.getPlatform(os), \"foo\"),\n+                createValidBodyWithHeader(null, AppImageFile.getVersion()),\n+                createValidBodyWithHeader(\"foo\", AppImageFile.getVersion()),\n+                createXml(os, \"<main-launcher><\/main-launcher>\"),\n+                createXml(os, \"<main-launcher>A<\/main-launcher>\"),\n+                createXml(os, \"<add-launcher>A<\/add-launcher>\"),\n+                createXml(os, createValidBodyWithHeader(AppImageFile.getPlatform(os), AppImageFile.getVersion()).toArray(String[]::new)),\n+                createWithHeader(AppImageFile.getPlatform(os), AppImageFile.getVersion(), () -> {\n+                    \/\/ Missing 'app-version' element.\n+                    return List.of(\n+                            \"<main-launcher name='D'\/>\",\n+                            \"<main-class>Hello<\/main-class>\"\n+                    );\n+                })\n+        ));\n+\n+        if (OperatingSystem.isMacOS()) {\n+            data.add(createXml(os, \"<main-launcher name='Foo'\/>\", \"<main-class><\/main-class>\"));\n+        }\n+\n+        return data;\n@@ -166,5 +451,7 @@\n-    @ParameterizedTest\n-    @MethodSource\n-    public void testInavlidXml(List<String> xmlData) throws IOException {\n-        assertThrowsExactly(ConfigException.class, () -> createFromXml(xmlData), () -> {\n-            return I18N.format(\"error.invalid-app-image\", tempFolder, \".jpackage.xml\");\n+    private static List<String> createValidBodyWithHeader(String platform, String version) {\n+        return createWithHeader(platform, version, () -> {\n+            return List.of(\n+                    \"<main-launcher name='D'\/>\",\n+                    \"<app-version>100<\/app-version>\",\n+                    \"<main-class>Hello<\/main-class>\"\n+            );\n@@ -174,8 +461,13 @@\n-    private static Stream<List<String>> testInavlidXml() {\n-        return Stream.of(List.of(\"<foo\/>\"),\n-                List.of(\"<jpackage-state\/>\"),\n-                createXml(),\n-                createXml(\"<main-launcher><\/main-launcher>\"),\n-                createXml(\"<main-launcher>Foo<\/main-launcher>\", \"<main-class><\/main-class>\"),\n-                createXml(\"<add-launcher>A<\/add-launcher>\")\n-        );\n+    private static List<String> createWithHeader(String platform, String version, Supplier<List<String>> body) {\n+\n+        var sb = new StringBuilder();\n+        sb.append(\"<jpackage-state\");\n+        Optional.ofNullable(platform).ifPresent(v -> {\n+            sb.append(String.format(\" platform=\\\"%s\\\"\", v));\n+        });\n+        Optional.ofNullable(version).ifPresent(v -> {\n+            sb.append(String.format(\" version=\\\"%s\\\"\", v));\n+        });\n+        sb.append(\">\");\n+\n+        return Stream.of(List.of(sb.toString()), body.get(), List.of(\"<\/jpackage-state>\")).flatMap(Collection::stream).toList();\n@@ -184,5 +476,35 @@\n-    @ParameterizedTest\n-    @MethodSource\n-    public void testValidXml(AppImageFile expected, List<String> xmlData) throws IOException, ConfigException {\n-        final var actual = createFromXml(xmlData);\n-        assertEquals(expected, actual);\n+\n+    private static Collection<ReadTestSpec> platformSpecificProperties() {\n+        var builder = ReadTestSpec.build().xml(\n+                \"<app-version>1.34<\/app-version>\",\n+                \"<main-class>Foo<\/main-class>\",\n+                \"<y\/>\",\n+                \"<x>property-x<\/x>\",\n+                \"<signed>true<\/signed>\",\n+                \"<app-store>False<\/app-store>\",\n+                \"<add-launcher name='add-launcher'>\",\n+                \"  <service>true<\/service>\",\n+                \"  <linux-shortcut>true<\/linux-shortcut>\",\n+                \"  <win-shortcut>false<\/win-shortcut>\",\n+                \"  <win-menu>app-dir<\/win-menu>\",\n+                \"<\/add-launcher>\",\n+                \"<main-launcher name='Bar'\/>\"\n+        );\n+\n+        Supplier<AppBuilder.LauncherBuilder> appBuilder = () -> {\n+            return build().mainClass(\"Foo\").version(\"1.34\").appName(\"Bar\").addlauncher(\"add-launcher\").service(true);\n+        };\n+\n+        List<ReadTestSpec> testCases = new ArrayList<>();\n+        testCases.add(builder.os(OperatingSystem.LINUX).expect(appBuilder.get()\n+                .addExtra(LINUX_LAUNCHER_SHORTCUT, new LauncherShortcut(LauncherShortcutStartupDirectory.DEFAULT)).commit()).create());\n+\n+        testCases.add(builder.os(OperatingSystem.WINDOWS).expect(appBuilder.get()\n+                .addExtra(WIN_LAUNCHER_DESKTOP_SHORTCUT, new LauncherShortcut())\n+                .addExtra(WIN_LAUNCHER_MENU_SHORTCUT, new LauncherShortcut(LauncherShortcutStartupDirectory.APP_DIR)).commit()).create());\n+\n+        testCases.add(builder.os(OperatingSystem.MACOS).expect(appBuilder.get().commit()\n+                .addExtra(MAC_APP_STORE, false)\n+                .addExtra(MAC_SIGNED, true)).create());\n+\n+        return testCases;\n@@ -191,4 +513,6 @@\n-    private static Stream<Arguments> testValidXml() {\n-        return Stream.of(\n-                Arguments.of(build().version(\"72\").launcherName(\"Y\").mainClass(\"main.Class\").create(), createXml(\n-                        \"<main-launcher>Y<\/main-launcher>\",\n+    private static Stream<ReadTestSpec> testValidXml() {\n+        return Stream.concat(platformSpecificProperties().stream(), Stream.of(\n+                ReadTestSpec.build().expect(\n+                        build().version(\"72\").appName(\"Y\").mainClass(\"main.Class\")\n+                ).xml(\n+                        \"<main-launcher name='Y'\/>\",\n@@ -196,16 +520,1 @@\n-                        \"<main-class>main.Class<\/main-class>\")\n-                ),\n-                Arguments.of(build().addExtra(\"x\", \"property-x\").addExtra(\"signed\", \"false\")\n-                        .addExtra(\"y\", \"\").addlauncher(\"another-launcher\").addlauncher(\"service-launcher\", true)\n-                        .addlauncher(\"launcher-with-extra\", Map.of(\"a\", \"\", \"b\", \"\", \"c\", \"Q\"))\n-                        .addlauncher(\"service-launcher-with-extra\", true, Map.of(\"h\", \"F\")).create(), createXml(\n-                        \"<app-version>1.0<\/app-version>\",\n-                        \"<main-class>Main<\/main-class>\",\n-                        \"<y\/>\",\n-                        \"<x>property-x<\/x>\",\n-                        \"<signed>false<\/signed>\",\n-                        \"<add-launcher name='service-launcher' service='true'\/>\",\n-                        \"<add-launcher name='another-launcher'><\/add-launcher>\",\n-                        \"<add-launcher name='launcher-with-extra'><a><\/a><b\/><c>Q<\/c><\/add-launcher>\",\n-                        \"<add-launcher name='service-launcher-with-extra' service='true'><h>F<\/h><\/add-launcher>\",\n-                        \"<main-launcher>Foo<\/main-launcher>\")\n+                        \"<main-class>main.Class<\/main-class>\"\n@@ -213,1 +522,9 @@\n-                Arguments.of(build().addExtra(\"signed\", \"FalsE\").create(), createXml(\n+                ReadTestSpec.build().os(OperatingSystem.LINUX).expect(\n+                        build()\n+                        .addlauncher(\"another-launcher\")\n+                                .addExtra(LINUX_LAUNCHER_SHORTCUT, new LauncherShortcut(LauncherShortcutStartupDirectory.APP_DIR))\n+                                .commit()\n+                        .addlauncher(\"service-launcher\")\n+                                .service(true)\n+                                .commit()\n+                ).xml(\n@@ -218,10 +535,1 @@\n-                        \"<main-launcher>Bar<\/main-launcher>\",\n-                        \"<main-launcher>Foo<\/main-launcher>\",\n-                        \"<signed>false<\/signed>\",\n-                        \"<signed>FalsE<\/signed>\")\n-                ),\n-                Arguments.of(build().addExtra(\"signed\", \"true\").addExtra(\"with-comment\", \"ab\")\n-                        .addlauncher(\"a\", Map.of(\"bar\", \"foo\")).create(), createXml(\n-                        \"<app-version>1.0<\/app-version>\",\n-                        \"<main-class>Main<\/main-class>\",\n-                        \"<main-launcher>Foo<\/main-launcher>\",\n+                        \"<x>property-x<\/x>\",\n@@ -229,4 +537,9 @@\n-                        \"<with-comment>a<!-- This is a comment -->b<\/with-comment>\",\n-                        \"<add-launcher name='a'><name>foo<\/name><bar>foo<\/bar><service>true<\/service><\/add-launcher>\",\n-                        \"<other><nested>false<\/nested><\/other>\",\n-                        \"<another-other>A<child\/>B<\/another-other>\")\n+                        \"<add-launcher name='service-launcher' service='true'>\",\n+                        \"  <linux-shortcut><nested>foo<\/nested><\/linux-shortcut>\",\n+                        \"<\/add-launcher>\",\n+                        \"<add-launcher name='another-launcher'>\",\n+                        \"  <linux-shortcut>true<\/linux-shortcut>\",\n+                        \"  <linux-shortcut>app-<!-- This is a comment -->dir<\/linux-shortcut>\",\n+                        \"<\/add-launcher>\",\n+                        \"<main-launcher name='Bar'\/>\",\n+                        \"<main-launcher name='Foo'\/>\"\n@@ -234,1 +547,1 @@\n-        );\n+        ).map(ReadTestSpec.Builder::create));\n@@ -237,4 +550,2 @@\n-    private AppImageFile createFromXml(List<String> xmlData) throws IOException, ConfigException {\n-        Path path = AppImageFile.getPathInAppImage(DUMMY_LAYOUT.resolveAt(tempFolder));\n-        path.toFile().mkdirs();\n-        Files.delete(path);\n+    private static ExternalApplication createFromXml(List<String> xmlData, OperatingSystem os, Path appImageDir) throws IOException {\n+        Path path = AppImageFile.getPathInAppImage(DUMMY_LAYOUT.resolveAt(appImageDir));\n@@ -246,2 +557,1 @@\n-        Files.write(path, data, StandardOpenOption.CREATE,\n-                    StandardOpenOption.TRUNCATE_EXISTING);\n+        Files.write(path, data, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);\n@@ -249,1 +559,1 @@\n-        AppImageFile image = AppImageFile.load(tempFolder, DUMMY_LAYOUT);\n+        ExternalApplication image = AppImageFile.load(DUMMY_LAYOUT.resolveAt(appImageDir), os);\n@@ -253,6 +563,2 @@\n-    private static void assertEquals(AppImageFile expected, AppImageFile actual) {\n-        assertPropertyEquals(expected, actual, AppImageFile::getAppVersion);\n-        assertPropertyEquals(expected, actual, AppImageFile::getLauncherName);\n-        assertPropertyEquals(expected, actual, AppImageFile::getMainClass);\n-        assertPropertyEquals(expected, actual, AppImageFile::getExtra);\n-        Assertions.assertEquals(additionaLaunchersAsMap(expected), additionaLaunchersAsMap(actual));\n+    private static void assertEquals(ExternalApplication expected, ExternalApplication actual) {\n+        Assertions.assertEquals(OM.map(expected), OM.map(actual));\n@@ -261,2 +567,4 @@\n-    private static Map<String, AppImageFile.LauncherInfo> additionaLaunchersAsMap(AppImageFile file) {\n-        return file.getAddLaunchers().stream().collect(Collectors.toMap(AppImageFile.LauncherInfo::name, x -> x));\n+    private static Map<String, Map<String, Object>> additionaLaunchersAsMap(ExternalApplication file) {\n+        return file.addLaunchers().stream().collect(toMap(LauncherInfo::name, li -> {\n+            return toPropertyMap(li.asOptions());\n+        }));\n@@ -265,5 +573,1 @@\n-    private static <T, U> void assertPropertyEquals(T expected, T actual, Function<T, U> getProperty) {\n-        Assertions.assertEquals(getProperty.apply(expected), getProperty.apply(actual));\n-    }\n-\n-    private static final List<String> createXml(String ...xml) {\n+    private static final List<String> createXml(OperatingSystem os, String ...xml) {\n@@ -271,1 +575,1 @@\n-        content.add(String.format(\"<jpackage-state platform=\\\"%s\\\" version=\\\"%s\\\">\", AppImageFile.getPlatform(), AppImageFile.getVersion()));\n+        content.add(String.format(\"<jpackage-state platform=\\\"%s\\\" version=\\\"%s\\\">\", AppImageFile.getPlatform(os), AppImageFile.getVersion()));\n@@ -277,0 +581,6 @@\n+    private static Map<String, Object> toPropertyMap(Options options) {\n+        return options.toMap().entrySet().stream().collect(toMap(e -> {\n+            return Objects.requireNonNull(OPTIONS.get(e.getKey()));\n+        }, Map.Entry::getValue));\n+    }\n+\n@@ -280,0 +590,2 @@\n+    private static final ObjectMapper OM;\n+\n@@ -281,0 +593,26 @@\n+\n+    private final static Map<OptionIdentifier, String> OPTIONS = Stream.of(AppImageFileOptionScope.values())\n+            .flatMap(AppImageFileOptionScope::options)\n+            .collect(toMap(OptionValue::id, OptionValue::getName));\n+\n+    static {\n+        var app = build().addlauncher(\"foo\").commit().createExternalApplication(OperatingSystem.current());\n+\n+        OM = ObjectMapper.standard()\n+                .subst(ExternalApplication.class, \"addLaunchers\", obj -> {\n+                    return additionaLaunchersAsMap(obj);\n+                })\n+                .subst(ExternalApplication.class, \"extra\", obj -> {\n+                    return toPropertyMap(obj.extra());\n+                })\n+                .subst(LauncherInfo.class, \"extra\", obj -> {\n+                    return toPropertyMap(obj.extra());\n+                })\n+                .subst(LauncherInfo.class, \"asOptions\", obj -> {\n+                    return toPropertyMap(obj.asOptions());\n+                })\n+                .exceptLeafClasses().add(NAME.id().getClass().getName()).apply()\n+                .exceptSomeMethods(app.getClass()).add(\"options\").apply()\n+                .exceptSomeMethods(app.mainLauncher().getClass()).add(\"options\").apply()\n+                .create();\n+    }\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/AppImageFileTest.java","additions":476,"deletions":138,"binary":false,"changes":614,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.util.Optional;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.model.BundlingOperationDescriptor;\n+import org.junit.jupiter.api.Test;\n+\n+\n+public class DefaultBundlingEnvironmentTest {\n+\n+    @Test\n+    void testDefaultBundlingOperation() {\n+\n+        var executed = new int[1];\n+\n+        var descriptor = new BundlingOperationDescriptor(OperatingSystem.current(), \"foo\", \"build\");\n+\n+        var env = new DefaultBundlingEnvironment(DefaultBundlingEnvironment.build().defaultOperation(() -> {\n+            executed[0] = executed[0] + 1;\n+            return Optional.of(descriptor);\n+        }));\n+\n+        \/\/ Assert the default bundling operation supplier is not called in the ctor.\n+        assertEquals(0, executed[0]);\n+\n+        \/\/ Assert the default bundling operation is as expected.\n+        assertEquals(descriptor, env.defaultOperation().orElseThrow());\n+        assertEquals(1, executed[0]);\n+\n+        \/\/ Assert the default bundling operation supplier is called only once.\n+        assertEquals(descriptor, env.defaultOperation().orElseThrow());\n+        assertEquals(1, executed[0]);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/DefaultBundlingEnvironmentTest.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -1,74 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-\n-import jdk.jpackage.internal.model.PackagerException;\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.ValueSource;\n-\n-\n-public class DeployParamsTest {\n-\n-    @Test\n-    public void testValidAppName() throws PackagerException {\n-        initParamsAppName();\n-\n-        setAppNameAndValidate(\"Test\");\n-\n-        setAppNameAndValidate(\"Test Name\");\n-\n-        setAppNameAndValidate(\"Test - Name !!!\");\n-    }\n-\n-    @ParameterizedTest\n-    @ValueSource(strings = {\"Test\\nName\", \"Test\\rName\", \"TestName\\\\\", \"Test \\\" Name\"})\n-    public void testInvalidAppName(String appName) throws PackagerException {\n-        initParamsAppName();\n-        var ex = assertThrowsExactly(PackagerException.class, () -> setAppNameAndValidate(appName));\n-\n-        assertTrue(ex.getMessage().startsWith(\"Error: Invalid Application name\"));\n-    }\n-\n-    \/\/ Returns deploy params initialized to pass all validation, except for\n-    \/\/ app name\n-    private void initParamsAppName() {\n-        params = new DeployParams();\n-\n-        params.addBundleArgument(Arguments.CLIOptions.APPCLASS.getId(),\n-                \"TestClass\");\n-        params.addBundleArgument(Arguments.CLIOptions.MAIN_JAR.getId(),\n-                \"test.jar\");\n-        params.addBundleArgument(Arguments.CLIOptions.INPUT.getId(), \"input\");\n-    }\n-\n-    private void setAppNameAndValidate(String appName) throws PackagerException {\n-        params.addBundleArgument(Arguments.CLIOptions.NAME.getId(), appName);\n-        params.validate();\n-    }\n-\n-    private DeployParams params;\n-}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/DeployParamsTest.java","additions":0,"deletions":74,"binary":false,"changes":74,"status":"deleted"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.LauncherJarStartupInfo;\n+import jdk.jpackage.internal.model.LauncherJarStartupInfoMixin;\n+import jdk.jpackage.internal.model.LauncherModularStartupInfo;\n+import jdk.jpackage.internal.model.LauncherModularStartupInfoMixin;\n+import jdk.jpackage.internal.model.LauncherStartupInfo;\n+import jdk.jpackage.test.Annotations.ParameterSupplier;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.HelloApp;\n+import jdk.jpackage.test.JUnitAdapter;\n+import jdk.jpackage.test.JavaAppDesc;\n+import jdk.jpackage.test.ObjectMapper;\n+import jdk.jpackage.test.TKit;\n+\n+public class LauncherStartupInfoBuilderTest extends JUnitAdapter {\n+\n+    public record TestSpec(JavaAppDesc javaAppDesc, boolean withMainClass, Object expectedInfo) {\n+        public TestSpec {\n+            Objects.requireNonNull(javaAppDesc);\n+            Objects.requireNonNull(expectedInfo);\n+        }\n+\n+        void test() throws ConfigException {\n+            final var workDir = TKit.createTempDirectory(\"input\");\n+\n+            HelloApp.createBundle(javaAppDesc, workDir);\n+\n+            final var builder = new LauncherStartupInfoBuilder();\n+\n+            builder.inputDir(workDir);\n+\n+            if (withMainClass) {\n+                builder.mainClassName(javaAppDesc.className());\n+            }\n+\n+            Optional.ofNullable(javaAppDesc.moduleName()).ifPresentOrElse(moduleName -> {\n+                if (javaAppDesc.isWithMainClass()) {\n+                    builder.moduleName(moduleName + \"\/\" + javaAppDesc.className());\n+                } else {\n+                    builder.moduleName(moduleName);\n+                }\n+                builder.modulePath(List.of(workDir));\n+            }, () -> {\n+                builder.mainJar(Path.of(javaAppDesc.jarFileName()));\n+            });\n+\n+            final var actualInfo = builder.create();\n+\n+            assertEquals(expectedInfo, OM.map(actualInfo));\n+        }\n+\n+        static final class Builder {\n+            TestSpec create() {\n+                return new TestSpec(javaAppDesc, withMainClass, OM.map(createInfo()));\n+            }\n+\n+            Builder javaAppDesc(String v) {\n+                javaAppDesc = JavaAppDesc.parse(v);\n+                return this;\n+            }\n+\n+            Builder withMainClass(boolean v) {\n+                withMainClass = v;\n+                return this;\n+            }\n+\n+            private LauncherStartupInfo createInfo() {\n+                final var base = createBaseInfo();\n+                if (javaAppDesc.moduleName() != null) {\n+                    return LauncherModularStartupInfo.create(base, createModularMixin());\n+                } else {\n+                    return LauncherJarStartupInfo.create(base, createJarMixin());\n+                }\n+            }\n+\n+            private LauncherStartupInfo createBaseInfo() {\n+                return new LauncherStartupInfo.Stub(javaAppDesc.className(), List.of(), List.of(), classPath);\n+            }\n+\n+            private LauncherJarStartupInfoMixin createJarMixin() {\n+                return new LauncherJarStartupInfoMixin.Stub(Path.of(javaAppDesc.jarFileName()),\n+                        !withMainClass && javaAppDesc.isWithMainClass());\n+            }\n+\n+            private LauncherModularStartupInfoMixin createModularMixin() {\n+                return new LauncherModularStartupInfoMixin.Stub(javaAppDesc.moduleName(),\n+                        Optional.ofNullable(javaAppDesc.moduleVersion()));\n+            }\n+\n+            private JavaAppDesc javaAppDesc;\n+            private boolean withMainClass = true;\n+            private List<Path> classPath = new ArrayList<>();\n+        }\n+    }\n+\n+    @Test\n+    @ParameterSupplier\n+    public static void test(TestSpec spec) throws ConfigException {\n+        spec.test();\n+    }\n+\n+    public static Collection<Object[]> test() {\n+        return Stream.of(\n+                build(\"\"),\n+                build(\"foo.jar:foo.bar.U\"),\n+                build(\"foo.jar:foo.bar.U!\"),\n+                build(\"foo.jar:foo.bar.U!\").withMainClass(false),\n+                build(\"a.b\/d.c.O\").withMainClass(true),\n+                build(\"a.b\/d.c.O@3.5.7-beta\").withMainClass(true),\n+                build(\"a.b\/d.c.O!\"),\n+                build(\"a.b\/d.c.O!\").withMainClass(false)\n+        ).map(TestSpec.Builder::create).map(v -> {\n+            return new Object[] {v};\n+        }).toList();\n+    }\n+\n+    private static TestSpec.Builder build(String javaAppDesc) {\n+        return new TestSpec.Builder().javaAppDesc(javaAppDesc);\n+    }\n+\n+    private static final ObjectMapper OM = ObjectMapper.standard().create();\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/LauncherStartupInfoBuilderTest.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -60,1 +60,0 @@\n-import jdk.jpackage.internal.model.ConfigException;\n@@ -63,1 +62,0 @@\n-import jdk.jpackage.internal.model.PackagerException;\n@@ -66,0 +64,1 @@\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n@@ -77,1 +76,1 @@\n-    void testBuildApplication(boolean withRuntimeBuilder, @TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+    void testBuildApplication(boolean withRuntimeBuilder, @TempDir Path workDir) throws IOException {\n@@ -118,1 +117,1 @@\n-    void testCopyApplication(@TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+    void testCopyApplication(@TempDir Path workDir) throws IOException {\n@@ -173,1 +172,1 @@\n-    void testCreatePackage(@TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+    void testCreatePackage(@TempDir Path workDir) throws IOException {\n@@ -212,1 +211,1 @@\n-    void testCreateRuntimeInstaller(boolean transformLayout, @TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+    void testCreateRuntimeInstaller(boolean transformLayout, @TempDir Path workDir) throws IOException {\n@@ -276,1 +275,1 @@\n-    void testCreatePackageFromExternalAppImage(ExternalAppImageMode mode, @TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+    void testCreatePackageFromExternalAppImage(ExternalAppImageMode mode, @TempDir Path workDir) throws IOException {\n@@ -325,1 +324,1 @@\n-    void testCreatePackageFromExternalAppImageNoCopyAction(ExternalAppImageMode mode, @TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+    void testCreatePackageFromExternalAppImageNoCopyAction(ExternalAppImageMode mode, @TempDir Path workDir) throws IOException {\n@@ -382,1 +381,1 @@\n-    void testCreatePackageFromExternalAppImageWithoutExternalAppImageError(@TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+    void testCreatePackageFromExternalAppImageWithoutExternalAppImageError(@TempDir Path workDir) throws IOException {\n@@ -392,1 +391,1 @@\n-    void testExceptionRethrow_RuntimeException() throws ConfigException, PackagerException, IOException {\n+    void testExceptionRethrow_RuntimeException() throws IOException {\n@@ -402,1 +401,1 @@\n-    void testExceptionRethrow_PackagerException() throws ConfigException, PackagerException, IOException {\n+    void testExceptionRethrow_PackagerException() throws IOException {\n@@ -404,1 +403,1 @@\n-        final var expectedException = new PackagerException(\"param.vendor.default\");\n+        final var expectedException = new RuntimeException(\"param.vendor.default\");\n@@ -412,1 +411,1 @@\n-    void testExceptionRethrow_Exception() throws ConfigException, PackagerException, IOException {\n+    void testExceptionRethrow_Exception() throws IOException {\n@@ -415,1 +414,1 @@\n-        final var ex = testExceptionRethrow(expectedException, PackagerException.class, () -> {\n+        final var ex = testExceptionRethrow(expectedException, ExceptionBox.class, () -> {\n@@ -422,1 +421,1 @@\n-    void testAppImageAction() throws PackagerException, IOException {\n+    void testAppImageAction() throws IOException {\n@@ -442,1 +441,1 @@\n-    void testAppImageActionWithPackage() throws PackagerException, IOException {\n+    void testAppImageActionWithPackage() throws IOException {\n@@ -465,1 +464,1 @@\n-    void testPackageActionWithApplication() throws PackagerException, IOException {\n+    void testPackageActionWithApplication() throws IOException {\n@@ -483,1 +482,1 @@\n-    void testContextMapper(boolean allowAll) throws PackagerException, IOException {\n+    void testContextMapper(boolean allowAll) throws IOException {\n@@ -493,1 +492,1 @@\n-                public void execute(TaskAction taskAction) throws IOException, PackagerException {\n+                public void execute(TaskAction taskAction) throws IOException {\n@@ -541,1 +540,1 @@\n-            NoArgTaskAction throwAction) throws PackagerException, IOException {\n+            NoArgTaskAction throwAction) throws IOException {\n@@ -554,1 +553,1 @@\n-    private static BuildEnv setupBuildEnvForExternalAppImage(Path workDir) throws ConfigException {\n+    private static BuildEnv setupBuildEnvForExternalAppImage(Path workDir) {\n@@ -568,1 +567,1 @@\n-            TaskID... expectedExecutedTaskActions) throws PackagerException, IOException {\n+            TaskID... expectedExecutedTaskActions) throws IOException {\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/PackagingPipelineTest.java","additions":21,"deletions":22,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static jdk.jpackage.internal.cli.OptionIdentifier.createIdentifier;\n+import static jdk.jpackage.internal.cli.WithOptionIdentifier.stub;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import jdk.jpackage.internal.cli.DefaultOptions.OptionIdentifierWithValue;\n+import jdk.jpackage.internal.cli.DefaultOptions.Snapshot;\n+import org.junit.jupiter.api.Test;\n+\n+public class DefaultOptionsTest {\n+\n+    @Test\n+    public void test_ctor_Snapshot_bad_option_names() {\n+        var ex = assertThrowsExactly(IllegalArgumentException.class, () -> {\n+            DefaultOptions.create(new Snapshot(Map.of(), Set.of(OptionName.of(\"foo\"))));\n+        });\n+\n+        assertEquals(\"Unexpected option names\", ex.getMessage());\n+    }\n+\n+    @Test\n+    public void test_ctor_Snapshot_bad_option_map() {\n+        var ex = assertThrowsExactly(IllegalArgumentException.class, () -> {\n+            DefaultOptions.create(new Snapshot(\n+                    Map.of(createIdentifier(), new OptionIdentifierWithValue(stub(createIdentifier()), \"foo\")),\n+                    Set.of()));\n+        });\n+\n+        assertEquals(\"Corrupted options map\", ex.getMessage());\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/DefaultOptionsTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static jdk.jpackage.test.JUnitUtils.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.lang.reflect.Array;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+final class ExpectedOptions {\n+\n+    static ExpectedOptions expectOptions() {\n+        return new ExpectedOptions();\n+    }\n+\n+    ExpectedOptions add(OptionIdentifier id, Object expectedValue) {\n+        expected.put(Objects.requireNonNull(id), Objects.requireNonNull(expectedValue));\n+        return this;\n+    }\n+\n+    ExpectedOptions add(OptionValue<?> ov, Object expectedValue) {\n+        ov.asOption().map(Option::spec).map(OptionSpec::names).ifPresent(names -> {\n+            expectedOptionNames.put(ov.id(), names);\n+        });\n+        return add(ov.id(), expectedValue);\n+    }\n+\n+    ExpectedOptions add(Option o, Object expectedValue) {\n+        expectedOptionNames.put(o.id(), o.spec().names());\n+        return add(o.id(), expectedValue);\n+    }\n+\n+    void apply(Options options) {\n+        for (var e : expected.entrySet()) {\n+            var actualValue = options.find(e.getKey()).orElseThrow();\n+            var expectedValue = e.getValue();\n+            if (expectedValue.getClass().isArray()) {\n+                assertArrayEquals(expectedValue, actualValue);\n+            } else {\n+                assertEquals(expectedValue, actualValue);\n+            }\n+        }\n+\n+        expectedOptionNames.values().stream().flatMap(Collection::stream).forEach(optionName -> {\n+            assertTrue(options.contains(optionName));\n+        });\n+\n+        assertEquals(convertArrayValuesToLists(expected), convertArrayValuesToLists(options.toMap()));\n+        assertEquals(expected.keySet(), options.ids());\n+    }\n+\n+    private Map<OptionIdentifier, Object> convertArrayValuesToLists(Map<OptionIdentifier, Object> map) {\n+        return map.entrySet().stream().map(e -> {\n+            var value = e.getValue();\n+            if (value.getClass().isArray()) {\n+                var objArray = new Object[Array.getLength(value)];\n+                System.arraycopy(value, 0, objArray, 0, objArray.length);\n+                return Map.<OptionIdentifier, Object>entry(e.getKey(), List.of(objArray));\n+            } else {\n+                return e;\n+            }\n+        }).collect(Collectors.toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    private final Map<OptionIdentifier, Object> expected = new HashMap<>();\n+    private final Map<OptionIdentifier, Collection<OptionName>> expectedOptionNames = new HashMap<>();\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/ExpectedOptions.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,181 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.StringReader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.test.JUnitAdapter;\n+import jdk.jpackage.test.TKit;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.condition.EnabledIfSystemProperty;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class HelpTest extends JUnitAdapter.TestSrcInitializer {\n+\n+    @Test\n+    public void testHelpOption() {\n+        final var cmdline = new JOptSimpleOptionsBuilder()\n+                .options(StandardOption.options())\n+                .create().apply(new String[] { \"-h\" }).orElseThrow().create();\n+\n+        assertTrue(StandardOption.HELP.containsIn(cmdline));\n+    }\n+\n+    @Disabled\n+    @ParameterizedTest\n+    @EnumSource(names = {\"WINDOWS\", \"LINUX\", \"MACOS\"})\n+    public void printHelp(OperatingSystem os) {\n+        new StandardHelpFormatter(os).format(System.out::print);\n+    }\n+\n+    @Disabled\n+    @ParameterizedTest\n+    @EnumSource(names = {\"WINDOWS\", \"LINUX\", \"MACOS\"})\n+    public void updateGoldenHelpFiles(OperatingSystem os) throws IOException {\n+        try (var sink = Files.newBufferedWriter(goldenHelpOutputFile(os)); var pw = new PrintWriter(sink)) {\n+            new StandardHelpFormatter(os).format(pw::append);\n+        }\n+    }\n+\n+    @Test\n+    public void printHelp() {\n+        StandardHelpFormatter.INSTANCE.format(System.out::print);\n+    }\n+\n+    @Test\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void verifyHelp() throws IOException {\n+        verifyHelp(StandardHelpFormatter.INSTANCE, OperatingSystem.current());\n+    }\n+\n+    @Test\n+    public void testOptionGroupNamesUnique() {\n+        \/\/ Test group names are unique.\n+        Stream.of(StandardHelpFormatter.OptionGroupID.values())\n+                .map(StandardHelpFormatter.OptionGroupID::groupName)\n+                .collect(Collectors.toMap(x -> x, x -> x));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(names = {\"WINDOWS\", \"LINUX\", \"MACOS\"})\n+    public void testOptionGroups(OperatingSystem os) {\n+\n+        final var groups = Stream.of(StandardHelpFormatter.OptionGroupID.values())\n+                .filter(Predicate.isEqual(StandardHelpFormatter.OptionGroupID.SAMPLES).negate())\n+                .map(optionGroupID -> {\n+                    return optionGroupID.createNonEmptyOptionGroup(os);\n+                })\n+                .filter(Optional::isPresent).map(Optional::orElseThrow)\n+                .collect(Collectors.toMap(HelpFormatter.OptionGroup::name, HelpFormatter.OptionGroup::options));\n+\n+        \/\/ Names of all options supported on the given platform.\n+        final var allOptionNames = StandardOption.options().stream().map(Option::spec)\n+                .filter(StandardOption.platformOption(os))\n+                .map(OptionSpec::names).flatMap(Collection::stream)\n+                .sorted().toList();\n+\n+        \/\/ Names of all options in the help groups.\n+        final var groupOptions = groups.values().stream().flatMap(Collection::stream)\n+                .map(OptionSpec::names).flatMap(Collection::stream)\n+                .sorted().toList();\n+\n+        \/\/ Test that each option belongs to only one group except of `--runtime-image`\n+        groupOptions.stream().collect(Collectors.toMap(x -> x, x -> x, (a, b) -> {\n+            if (a.equals(StandardOption.PREDEFINED_RUNTIME_IMAGE.getSpec().name())) {\n+                return a;\n+            } else {\n+                throw new AssertionError(String.format(\"Option [%s] is included in multiple groups\", a.name()));\n+            }\n+        }));\n+\n+        \/\/ Test that each option is added to some group.\n+        assertEquals(allOptionNames, groupOptions.stream().distinct().toList());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testOptionSpecSorter(List<String> unsortedNames, List<String> expectedNames) {\n+        var sortedNames = unsortedNames.stream()\n+                .map(HelpTest::dummyOptionSpec)\n+                .sorted(StandardHelpFormatter.optionSpecSorter())\n+                .map(OptionSpec::name)\n+                .map(OptionName::name).toList();\n+        assertEquals(expectedNames, sortedNames);\n+    }\n+\n+    private static Iterable<Arguments> testOptionSpecSorter() {\n+        return List.of(\n+                Arguments.of(List.of(\"a\", \"type\", \"w\"), List.of(\"type\", \"a\", \"w\")),\n+                Arguments.of(List.of(\"type\", \"type\", \"w\"), List.of(\"type\", \"type\", \"w\")),\n+                Arguments.of(List.of(\"a\", \"type\", \"type\"), List.of(\"type\", \"type\", \"a\")),\n+                Arguments.of(List.of(\"type\", \"w\", \"type\"), List.of(\"type\", \"type\", \"w\"))\n+        );\n+    }\n+\n+    private static OptionSpec<?> dummyOptionSpec(String name) {\n+        return new OptionSpec<>(\n+                List.of(OptionName.of(name)),\n+                Optional.empty(),\n+                Set.of(new OptionScope() {}),\n+                OptionSpec.MergePolicy.USE_FIRST,\n+                Optional.empty(),\n+                Optional.empty(),\n+                \"\");\n+    }\n+\n+    private static void verifyHelp(StandardHelpFormatter helpFormatter, OperatingSystem os) throws IOException {\n+\n+        var sb = new StringBuilder();\n+        helpFormatter.format(sb::append);\n+\n+        var help = new BufferedReader(new StringReader(sb.toString())).lines().toList();\n+\n+        var expectedHelp = Files.readAllLines(goldenHelpOutputFile(os));\n+\n+        assertEquals(expectedHelp, help);\n+    }\n+\n+    private static Path goldenHelpOutputFile(OperatingSystem os) {\n+        String fname = String.format(\"help-%s.txt\", os.name().toLowerCase());\n+        return TKit.TEST_SRC_ROOT.resolve(\"junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\", fname);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/HelpTest.java","additions":181,"deletions":0,"binary":false,"changes":181,"status":"added"},{"patch":"@@ -0,0 +1,1428 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static jdk.jpackage.internal.cli.ExpectedOptions.expectOptions;\n+import static jdk.jpackage.internal.cli.OptionSpecBuilder.pathSeparator;\n+import static jdk.jpackage.internal.cli.OptionSpecBuilder.toList;\n+import static jdk.jpackage.internal.cli.StandardValueConverter.identityConv;\n+import static jdk.jpackage.internal.cli.StandardValueConverter.pathConv;\n+import static jdk.jpackage.internal.cli.TestUtils.arrayElements;\n+import static jdk.jpackage.test.JUnitUtils.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+import jdk.jpackage.internal.cli.JOptSimpleOptionsBuilder.JOptSimpleErrorType;\n+import jdk.jpackage.internal.cli.OptionSpec.MergePolicy;\n+import jdk.jpackage.internal.cli.OptionValueConverter.ConverterException;\n+import jdk.jpackage.internal.cli.OptionValueExceptionFactory.StandardArgumentsMapper;\n+import jdk.jpackage.internal.cli.TestUtils.OptionFailure;\n+import jdk.jpackage.internal.cli.TestUtils.TestException;\n+import jdk.jpackage.internal.model.BundlingOperationDescriptor;\n+import jdk.jpackage.internal.util.Result;\n+import jdk.jpackage.test.JUnitUtils.ExceptionPattern;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+public class JOptSimpleOptionsBuilderTest {\n+\n+    enum ParserMode {\n+        PARSE,\n+        CONVERT\n+    }\n+\n+    public record TestSpec(Map<OptionValue<?>, ExpectedValue<?>> options, List<String> args) {\n+        public TestSpec {\n+            Objects.requireNonNull(options);\n+            Objects.requireNonNull(args);\n+        }\n+\n+        void test(ParserMode parserMode) {\n+            final var parser = createParser(parserMode, options.keySet());\n+\n+            final var cmdline = parser.apply(args);\n+\n+            for (final var e : options.entrySet()) {\n+                final var optionValue = e.getKey();\n+                final var expectedValue = e.getValue();\n+                final Object actualValue;\n+                if (parserMode.equals(ParserMode.PARSE)) {\n+                    actualValue = cmdline.find(optionValue.getOption()).orElseThrow();\n+                } else {\n+                    actualValue = optionValue.getFrom(cmdline);\n+                }\n+                expectedValue.assertIt(actualValue);\n+            }\n+        }\n+\n+\n+        static final class Builder {\n+\n+            TestSpec create() {\n+                return new TestSpec(options, args);\n+            }\n+\n+            final class OptionValueBuilder<T> {\n+\n+                OptionValueBuilder<T> expectParse(String... expectedValue) {\n+                    expectedValues.put(ParserMode.PARSE, new ExpectedValue<>(expectedValue, Assertions::assertArrayEquals));\n+                    return this;\n+                 }\n+\n+                OptionValueBuilder<T> expect(T expectedValue) {\n+                   return expect(expectedValue, defaultAsserter());\n+                }\n+\n+                OptionValueBuilder<T> expect(T expectedValue, BiConsumer<T, T> asserter) {\n+                    expectedValues.put(ParserMode.CONVERT, new ExpectedValue<>(expectedValue, asserter));\n+                    return this;\n+                }\n+\n+                Builder commit() {\n+                    if (expectedValues.isEmpty()) {\n+                        throw new UnsupportedOperationException(\"Missing expected value\");\n+                    }\n+\n+                    if (parserMode == null) {\n+                        if (expectedValues.size() > 1) {\n+                            throw new UnsupportedOperationException(\"Ambigous expected value\");\n+                        }\n+                        options.put(option, expectedValues.values().iterator().next());\n+                    } else {\n+                        options.put(option, Optional.ofNullable(expectedValues.get(parserMode)).orElseThrow(() -> {\n+                            return new UnsupportedOperationException(\"Mismatched expected value\");\n+                        }));\n+                    }\n+\n+                    return Builder.this;\n+                }\n+\n+                private OptionValueBuilder(OptionValue<T> option) {\n+                    this.option = Objects.requireNonNull(option);\n+                }\n+\n+                private final OptionValue<T> option;\n+                private final Map<ParserMode, ExpectedValue<?>> expectedValues = new HashMap<>();\n+            }\n+\n+            <T> OptionValueBuilder<T> optionValue(OptionValue<T> option) {\n+                return new OptionValueBuilder<>(option);\n+            }\n+\n+            Builder optionUntypedValue(OptionValue<?> option, String... expectedValue) {\n+                return new OptionValueBuilder<>(option).expectParse(expectedValue).commit();\n+             }\n+\n+            <T> Builder optionValue(OptionValue<T> option, T expectedValue) {\n+               return optionValue(option, expectedValue, defaultAsserter());\n+            }\n+\n+            <T> Builder optionValue(OptionValue<T> option, T expectedValue, BiConsumer<T, T> asserter) {\n+                return new OptionValueBuilder<>(option).expect(expectedValue, asserter).commit();\n+            }\n+\n+            Builder args(String...v) {\n+                return args(List.of(v));\n+            }\n+\n+            Builder args(Collection<String> v) {\n+                args.addAll(v);\n+                return this;\n+            }\n+\n+            Builder mode(ParserMode v) {\n+                parserMode = v;\n+                return this;\n+            }\n+\n+            private static <T> BiConsumer<T, T> defaultAsserter() {\n+                return (expected, actual) -> {\n+                    if (expected.getClass().isArray()) {\n+                        assertArrayEquals(expected, actual);\n+                    } else {\n+                        assertEquals(expected, actual);\n+                    }\n+                };\n+            }\n+\n+            private ParserMode parserMode;\n+            private final Map<OptionValue<?>, ExpectedValue<?>> options = new HashMap<>();\n+            private final List<String> args = new ArrayList<>();\n+        }\n+\n+\n+        private record ExpectedValue<T>(T value, BiConsumer<T, T> asserter) {\n+            ExpectedValue {\n+                Objects.requireNonNull(value);\n+                Objects.requireNonNull(asserter);\n+            }\n+\n+            @SuppressWarnings(\"unchecked\")\n+            void assertIt(Object actual) {\n+                asserter.accept(value, (T)actual);\n+            }\n+        }\n+    }\n+\n+    enum ShortNameTestCase {\n+        LONG(hasLongOption().and(hasShortOption().negate()), addLongOption()),\n+        SHORT(hasLongOption().negate().and(hasShortOption()), addShortOption()),\n+        LONG_AND_SHORT(hasLongOption().and(hasShortOption()), addLongOption(), addShortOption()),\n+        SHORT_AND_LONG(hasLongOption().and(hasShortOption()), addShortOption(), addLongOption()),\n+        NONE(hasLongOption().negate().and(hasShortOption().negate()))\n+        ;\n+\n+        @SafeVarargs\n+        ShortNameTestCase(Predicate<Options> validator, BiConsumer<Type, List<String>>... optionInitializers) {\n+            this.optionInitializer = (type, args) -> {\n+                for (final var optionInitializer : optionInitializers) {\n+                    optionInitializer.accept(type, args);\n+                }\n+            };\n+            this.validator = validator;\n+        }\n+\n+        void run(Type type, ParserMode parserMode) {\n+            final var parser = createParser(parserMode, type.optionValue);\n+            final List<String> args = new ArrayList<>();\n+            optionInitializer.accept(type, args);\n+            assertTrue(validator.test(parser.apply(args)));\n+        }\n+\n+        private static Predicate<Options> hasLongOption() {\n+            return cmdline -> {\n+                return cmdline.contains(LONG_NAME);\n+            };\n+        }\n+\n+        private static Predicate<Options> hasShortOption() {\n+            return cmdline -> {\n+                return cmdline.contains(SHORT_NAME);\n+            };\n+        }\n+\n+        private static BiConsumer<Type, List<String>> addLongOption() {\n+            return (type, args) -> {\n+                args.add(LONG_NAME.formatForCommandLine());\n+                type.valueInitializer.accept(FOO, args);\n+            };\n+        }\n+\n+        private static BiConsumer<Type, List<String>> addShortOption() {\n+            return (type, args) -> {\n+                args.add(SHORT_NAME.formatForCommandLine());\n+                type.valueInitializer.accept(BAR, args);\n+            };\n+        }\n+\n+        private enum Type {\n+            STRING(stringOption(LONG_NAME.name()).addAliases(SHORT_NAME.name()).create(), (optionValue, args) -> {\n+                args.add(optionValue);\n+            }),\n+            BOOLEAN(booleanOption(LONG_NAME.name()).addAliases(SHORT_NAME.name()).create(), (optionValue, args) -> {}),\n+            ;\n+\n+            Type(OptionValue<?> optionValue, BiConsumer<String, List<String>> valueInitializer) {\n+                this.optionValue = Objects.requireNonNull(optionValue);\n+                this.valueInitializer = Objects.requireNonNull(valueInitializer);\n+            }\n+\n+            final OptionValue<?> optionValue;\n+            final BiConsumer<String, List<String>> valueInitializer;\n+        }\n+\n+        private final BiConsumer<Type, List<String>> optionInitializer;\n+        private final Predicate<Options> validator;\n+\n+        private static final OptionName LONG_NAME = OptionName.of(\"input\");\n+        private static final OptionName SHORT_NAME = OptionName.of(\"i\");\n+\n+        private static final String FOO = \"foo\";\n+        private static final String BAR = \"bar\";\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(ShortNameTestCase.class)\n+    public void testShortNameString(ShortNameTestCase testCase) {\n+        for (final var parserMode : ParserMode.values()) {\n+            testCase.run(ShortNameTestCase.Type.STRING, parserMode);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(ShortNameTestCase.class)\n+    public void testShortNameBoolean(ShortNameTestCase testCase) {\n+        for (final var parserMode : List.of(ParserMode.CONVERT)) {\n+            testCase.run(ShortNameTestCase.Type.BOOLEAN, parserMode);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test(TestSpec spec) {\n+        spec.test(ParserMode.CONVERT);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testStringVector(TestSpec spec) {\n+        spec.test(ParserMode.CONVERT);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testOptionalValueParse(TestSpec spec) {\n+        spec.test(ParserMode.PARSE);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testOptionalValueConvert(TestSpec spec) {\n+        spec.test(ParserMode.CONVERT);\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(ParserMode.class)\n+    public void testOptionalValueNoDefault(ParserMode parserMode) {\n+        var option = option(\"x\", Integer.class).converter(Integer::valueOf).defaultOptionalValue(17).create();\n+        var option2 = option(\"y\", Integer.class).converter(Integer::valueOf).create();\n+\n+        var cmdline = createParser(parserMode, option, option2).apply(List.of(\"-y\", \"77\"));\n+\n+        assertTrue(option.findIn(cmdline).isEmpty());\n+        assertTrue(option2.findIn(cmdline).isPresent());\n+    }\n+\n+    @Test\n+    public void testConversionErrors(@TempDir Path tmpDir) {\n+\n+        final var dirOption = pathOption(\"dir\").addAliases(\"r\").tokenizer(\",\");\n+\n+        final var urlOption = stringOption(\"url\").converter(str -> {\n+            try {\n+                new URI(str);\n+                return str;\n+            } catch (URISyntaxException ex) {\n+                throw new IllegalArgumentException(ex);\n+            }\n+        });\n+\n+        final var lruOption = option(\"lru\", URI.class).converter(str -> {\n+            try {\n+                return new URI(str);\n+            } catch (URISyntaxException ex) {\n+                throw new IllegalArgumentException(ex);\n+            }\n+        }).mergePolicy(MergePolicy.USE_FIRST);\n+\n+        new FaultyParserArgsConfig()\n+                .options(urlOption, lruOption)\n+                .arrayOptions(dirOption)\n+                .args(\"--dir=*,foo,,bar\", \"-r\", \"file\", \"-r\", \"file,*\")\n+                .args(\"--url=http:\/\/foo\", \"--url=:foo\")\n+                .args(\"--lru=:bar\", \"--lru=http:\/\/bar\")\n+                .expectError(\"dir\", StringToken.of(\"*,foo,,bar\", \"*\"))\n+                .expectError(\"r\", StringToken.of(\"file,*\", \"*\"))\n+                .expectError(\"url\", \":foo\")\n+                .expectError(\"lru\", \":bar\")\n+                .test();\n+\n+        \/\/ Test errors are recorded in the order they appear on the command line.\n+        new FaultyParserArgsConfig()\n+                .options(urlOption, lruOption)\n+                .arrayOptions(dirOption)\n+                .args(\"--lru=:bar\", \"--lru=http:\/\/bar\")\n+                .args(\"--dir=*,foo,,bar\", \"-r\", \"file\")\n+                .args(\"--url=http:\/\/foo\", \"--url=:foo\")\n+                .args(\"-r\", \"file,*\")\n+                .expectError(\"lru\", \":bar\")\n+                .expectError(\"dir\", StringToken.of(\"*,foo,,bar\", \"*\"))\n+                .expectError(\"url\", \":foo\")\n+                .expectError(\"r\", StringToken.of(\"file,*\", \"*\"))\n+                .test();\n+    }\n+\n+    @Test\n+    public void testValidationErrors() {\n+\n+        final var numberArrayOption = option(\"number\", Integer.class)\n+                .addAliases(\"n\")\n+                .validator((Predicate<Integer>)(v -> v > 0))\n+                .tokenizer(\",\")\n+                .converter(Integer::valueOf);\n+\n+        new FaultyParserArgsConfig()\n+                .arrayOptions(numberArrayOption)\n+                .args(\"--number=56,23\", \"--number=2,-34,-45\", \"-n\", \"2,-17,0,56\")\n+                .expectError(\"number\", StringToken.of(\"2,-34,-45\", \"-34\"))\n+                .expectError(\"number\", StringToken.of(\"2,-34,-45\", \"-45\"))\n+                .expectError(\"n\", StringToken.of(\"2,-17,0,56\", \"-17\"))\n+                .expectError(\"n\", StringToken.of(\"2,-17,0,56\", \"0\"))\n+                .test();\n+\n+        \/\/ Test errors are recorded in the order they appear on the command line.\n+        new FaultyParserArgsConfig()\n+                .arrayOptions(numberArrayOption)\n+                .args(\"--number=56,23\", \"-n\", \"2,-17,0,56\", \"--number=2,-45,-34\")\n+                .expectError(\"n\", StringToken.of(\"2,-17,0,56\", \"-17\"))\n+                .expectError(\"n\", StringToken.of(\"2,-17,0,56\", \"0\"))\n+                .expectError(\"number\", StringToken.of(\"2,-45,-34\", \"-45\"))\n+                .expectError(\"number\", StringToken.of(\"2,-45,-34\", \"-34\"))\n+                .test();\n+    }\n+\n+    enum ConverterErrorOrigin {\n+        CONVERTER,\n+        VALIDATOR\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(ConverterErrorOrigin.class)\n+    public void testConverterError(ConverterErrorOrigin exceptionOrigin) {\n+\n+        final var scalarException = new RuntimeException(\"Scalar error\");\n+        final var arrayException = new RuntimeException(\"Array error\");\n+\n+        final Function<RuntimeException, Consumer<OptionSpecBuilder<String>>> mutatorCreator = ex -> {\n+            return builder -> {\n+                switch (exceptionOrigin) {\n+                    case CONVERTER -> {\n+                        builder.converter(_ -> {\n+                            throw ex;\n+                        });\n+                    }\n+\n+                    case VALIDATOR -> {\n+                        builder.validator(new Consumer<>() {\n+\n+                            @Override\n+                            public void accept(String t) {\n+                                throw ex;\n+                            }\n+\n+                        });\n+                    }\n+                }\n+            };\n+        };\n+\n+        final var scalarOption = stringOption(\"val\").mutate(mutatorCreator.apply(scalarException));\n+\n+        final var arrayOption = stringOption(\"arr\").mutate(mutatorCreator.apply(arrayException));\n+\n+        final var cfg = new FaultyParserArgsConfig()\n+                .options(scalarOption, stringOption(\"good\"))\n+                .arrayOptions(arrayOption);\n+\n+        cfg.clearArgs()\n+                .args(\"--val=10\")\n+                .expectConverterException(scalarException)\n+                .test();\n+\n+        cfg.clearArgs()\n+                .args(\"--arr=foo\")\n+                .expectConverterException(arrayException)\n+                .test();\n+\n+        cfg.clearArgs()\n+                .args(\"--arr=bar\", \"--val=57\")\n+                .expectConverterException(arrayException)\n+                .test();\n+\n+        cfg.clearArgs()\n+                .args(\"--val=57\", \"--arr=bar\")\n+                .expectConverterException(scalarException)\n+                .test();\n+    }\n+\n+    @Test\n+    public void testArrayUnrecoverableMergeFailure() {\n+\n+        new FaultyParserArgsConfig()\n+                .arrayOptions(pathOption(\"path\").tokenizer(\",\").mergePolicy(MergePolicy.USE_FIRST))\n+                .args(\"--path=*,foo\", \"--path=bar\")\n+                .expectError(\"path\", StringToken.of(\"*,foo\", \"*\"))\n+                .test();\n+\n+        new FaultyParserArgsConfig()\n+                .arrayOptions(pathOption(\"path\").tokenizer(\",\").mergePolicy(MergePolicy.USE_LAST))\n+                .args(\"--path=bar\", \"--path=foo,*\")\n+                .expectError(\"path\", StringToken.of(\"foo,*\", \"*\"))\n+                .test();\n+    }\n+\n+    @Test\n+    public void testScalarUnrecoverableMergeFailure() {\n+\n+        new FaultyParserArgsConfig()\n+                .options(pathOption(\"path\").mergePolicy(MergePolicy.USE_FIRST))\n+                .args(\"--path=*\", \"--path=bar\")\n+                .expectError(\"path\", StringToken.of(\"*\", \"*\"))\n+                .test();\n+\n+        new FaultyParserArgsConfig()\n+                .options(pathOption(\"path\").mergePolicy(MergePolicy.USE_LAST))\n+                .args(\"--path=bar\", \"--path=*\")\n+                .expectError(\"path\", StringToken.of(\"*\", \"*\"))\n+                .test();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testMergePolicy\")\n+    public void testMergePolicyScalar(MergePolicy mergePolicy, ParserMode parserMode) {\n+\n+        if (mergePolicy == MergePolicy.CONCATENATE) {\n+            assertThrowsExactly(IllegalArgumentException.class,\n+                    option(\"foo\", Object.class).mergePolicy(mergePolicy)::create);\n+            return;\n+        }\n+\n+        final var strOption = stringOption(\"str\").mergePolicy(mergePolicy).create();\n+\n+        final var monthOption = stringOption(\"month\").addAliases(\"m\")\n+                .mergePolicy(mergePolicy).create();\n+\n+        final var intOption = option(\"int\", Integer.class).addAliases(\"i\")\n+                .converter(Integer::valueOf).mergePolicy(mergePolicy).create();\n+\n+        final var floatOption = option(\"d\", Double.class)\n+                .converter(Double::valueOf).mergePolicy(mergePolicy).create();\n+\n+        final var builder = build()\n+                .args(\"-d\", \"1000\", \"--month=June\", \"--int=10\", \"-m\", \"July\", \"-i\", \"45\", \"-m\", \"August\")\n+                .args(\"--str=\", \"--str=A\");\n+\n+        if (parserMode.equals(ParserMode.PARSE)) {\n+            builder.optionUntypedValue(strOption, mergeUntypedValues(List.of(\"\", \"A\"), mergePolicy));\n+            builder.optionUntypedValue(monthOption, mergeUntypedValues(List.of(\"June\", \"July\", \"August\"), mergePolicy));\n+            builder.optionUntypedValue(intOption, mergeUntypedValues(List.of(\"10\", \"45\"), mergePolicy));\n+            builder.optionUntypedValue(floatOption, new String[] {\"1000\"});\n+        } else {\n+            builder.optionValue(strOption, mergeScalarValues(List.of(\"\", \"A\"), mergePolicy));\n+            builder.optionValue(monthOption, mergeScalarValues(List.of(\"June\", \"July\", \"August\"), mergePolicy));\n+            builder.optionValue(intOption, mergeScalarValues(List.of(10, 45), mergePolicy));\n+            builder.optionValue(floatOption, Double.valueOf(1000));\n+        }\n+\n+        builder.create().test(parserMode);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testMergePolicy\")\n+    public void testMergePolicyArray(MergePolicy mergePolicy, ParserMode parserMode) {\n+\n+        final var monthOption = stringOption(\"month\").addAliases(\"m\")\n+                .mergePolicy(mergePolicy)\n+                .tokenizer(Pattern.quote(\"+\"))\n+                .createArray();\n+\n+        final var intOption = option(\"int\", Integer.class).addAliases(\"i\")\n+                .converter(Integer::valueOf)\n+                .mergePolicy(mergePolicy)\n+                .tokenizer(TestUtils.splitOrEmpty(\":\"))\n+                .createArray();\n+\n+        final var floatOption = option(\"d\", Double.class)\n+                .converter(Double::valueOf)\n+                .mergePolicy(mergePolicy)\n+                .tokenizer(Pattern.quote(\"|\"))\n+                .createArray();\n+\n+        final var builder = build().args(\"-d\", \"1000\", \"--int=\", \"--month=June\", \"--int=10:333\", \"-m\", \"July+July\", \"-i\", \"45\", \"-m\", \"August\", \"--int=\");\n+\n+        if (parserMode.equals(ParserMode.PARSE)) {\n+            builder.optionUntypedValue(monthOption,\n+                    mergeUntypedValues(List.of(\"June\", \"July+July\", \"August\"), mergePolicy));\n+            builder.optionUntypedValue(intOption,\n+                    mergeUntypedValues(List.of(\"\", \"10:333\", \"45\", \"\"), mergePolicy));\n+            builder.optionUntypedValue(floatOption, new String[] {\"1000\"});\n+        } else {\n+            builder.optionValue(monthOption,\n+                    mergeArrayValues(arrayElements(String.class, List.of(\"June\", \"July\", \"July\", \"August\")), mergePolicy));\n+            builder.optionValue(intOption,\n+                    mergeArrayValues(arrayElements(Integer.class, Arrays.asList(null, 10, 333, 45, null)), mergePolicy));\n+            builder.optionValue(floatOption, new Double[] {Double.valueOf(1000)});\n+        }\n+\n+        builder.create().test(parserMode);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testMergePolicy\")\n+    public void testMergePolicyNoValue(MergePolicy mergePolicy, ParserMode parserMode) {\n+\n+        if (mergePolicy == MergePolicy.CONCATENATE) {\n+            assertThrowsExactly(IllegalArgumentException.class, booleanOption(\"foo\").mergePolicy(mergePolicy)::create);\n+            return;\n+        }\n+\n+        final var aOption = booleanOption(\"a\").mergePolicy(mergePolicy).create();\n+        final var bOption = booleanOption(\"boo\").addAliases(\"b\").mergePolicy(mergePolicy).create();\n+\n+        final var builder = build().args(\"-a\", \"-boo\", \"-b\");\n+\n+        if (parserMode.equals(ParserMode.PARSE)) {\n+            builder.optionUntypedValue(aOption, new String[0]);\n+            builder.optionUntypedValue(bOption, new String[0]);\n+        } else {\n+            builder.optionValue(aOption, mergeScalarValues(List.of(true), mergePolicy));\n+            builder.optionValue(bOption, mergeScalarValues(List.of(true, true), mergePolicy));\n+        }\n+\n+        builder.create().test(parserMode);\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void testUnrecognizedOptionMapping(boolean onlyUnrecognizedOption) {\n+\n+        final var option = option(\"x\", Object.class).converter(_ -> {\n+            throw new RuntimeException();\n+        }).create();\n+\n+        final List<String> args = new ArrayList<>();\n+\n+        if (!onlyUnrecognizedOption) {\n+            args.addAll(List.of(\"-x\", \"foo\"));\n+        }\n+        args.add(\"--unrecognized\");\n+\n+        final var result = new JOptSimpleOptionsBuilder().options(option).create().apply(args.toArray(String[]::new));\n+\n+        assertFalse(result.hasValue());\n+        assertEquals(1, result.errors().size());\n+\n+        assertTrue(new ExceptionPattern()\n+                .isInstanceOf(jdk.internal.joptsimple.OptionException.class)\n+                .match(result.errors().iterator().next()));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testErrorMapping(String expectedErrorMessage, String[] args) {\n+\n+        var booleanOption = booleanOption(\"bool\").addAliases(\"b\").create();\n+        var stringOption = stringOption(\"str\").addAliases(\"s\").create();\n+\n+        final var parse = new JOptSimpleOptionsBuilder()\n+                .options(booleanOption, stringOption)\n+                .jOptSimpleParserErrorHandler(err -> {\n+                    return new TestException(String.format(\"%s:%s\", err.type(), err.optionName().formatForCommandLine()));\n+                })\n+                .create();\n+\n+        final var expectedExceptions = List.of(new TestException(expectedErrorMessage));\n+        final var actualExceptions = parse.apply(args).errors();\n+\n+        assertEquals(\n+                expectedExceptions.stream().map(Exception::getMessage).toList(),\n+                actualExceptions.stream().map(Exception::getMessage).toList());\n+    }\n+\n+    @Test\n+    public void testNullErrorMapping() {\n+        final var parse = new JOptSimpleOptionsBuilder().jOptSimpleParserErrorHandler(_ -> {\n+            return null;\n+        }).create();\n+\n+        assertThrowsExactly(NullPointerException.class, () -> parse.apply(new String[] {\"--foo\"}));\n+    }\n+\n+    @Test\n+    public void testNoErrorMapping() {\n+        var errors = new JOptSimpleOptionsBuilder()\n+                .options(stringOption(\"str\").create())\n+                .create()\n+                .apply(new String[] {\"--str\"}).errors();\n+\n+        assertEquals(1, errors.size());\n+        assertTrue(errors.iterator().next() instanceof jdk.internal.joptsimple.OptionException);\n+    }\n+\n+    @Test\n+    public void test_optionSpecMapper() {\n+        var mappedOption = stringOption(\"foo\").create();\n+        var unmappedOption = stringOption(\"bar\").create();\n+        var unusedOption = stringOption(\"baz\").create();\n+\n+        final var parse = new JOptSimpleOptionsBuilder().optionSpecMapper(optionSpec -> {\n+            if (optionSpec.name().equals(mappedOption.getSpec().name())) {\n+                return optionSpec.copyWithConverter(OptionValueConverter.<String>build()\n+                        .converter(ValueConverter.create(str -> {\n+                            return str.toUpperCase();\n+                        }, String.class)).create());\n+            } else {\n+                return optionSpec;\n+            }\n+        }).options(mappedOption, unmappedOption, unusedOption).create();\n+\n+        var optionValues = parse.apply(new String[] {\"--foo=Value\", \"--bar\", \"Value\"})\n+                .orElseThrow().convertedOptions().orElseThrow().create();\n+\n+        assertEquals(\"VALUE\", mappedOption.getFrom(optionValues));\n+        assertEquals(\"Value\", unmappedOption.getFrom(optionValues));\n+        assertFalse(unusedOption.containsIn(optionValues));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(ParserMode.class)\n+    public void test_Options_find_negative(ParserMode mode) {\n+        final var booleanOption = booleanOption(\"b\").create();\n+        final var booleanOption2 = booleanOption(\"b2\").create();\n+\n+        final var stringOption = stringOption(\"str\").create();\n+        final var stringOption2 = stringOption(\"str2\").create();\n+\n+        final List<OptionValue<?>> allOptions = List.of(booleanOption, booleanOption2, stringOption, stringOption2);\n+\n+        final BiFunction<Collection<OptionValue<?>>, List<String>, Options> parse = (options, args) -> {\n+            var theParse = new JOptSimpleOptionsBuilder().options(options).create();\n+            var builder = theParse.apply(args.toArray(String[]::new)).orElseThrow();\n+\n+            switch (mode) {\n+                case PARSE -> {\n+                    return builder.create();\n+                }\n+                case CONVERT -> {\n+                    return builder.convertedOptions().orElseThrow().create();\n+                }\n+                default -> {\n+                    throw new AssertionError();\n+                }\n+            }\n+        };\n+\n+        var optionValues = parse.apply(List.of(booleanOption, stringOption), List.of());\n+\n+        assertTrue(optionValues.find(booleanOption.id()).isEmpty());\n+        assertTrue(optionValues.find(booleanOption2.id()).isEmpty());\n+        assertTrue(optionValues.find(stringOption.id()).isEmpty());\n+        assertTrue(optionValues.find(stringOption2.id()).isEmpty());\n+\n+        optionValues = parse.apply(allOptions, List.of());\n+\n+        assertTrue(optionValues.find(booleanOption.id()).isEmpty());\n+        assertTrue(optionValues.find(booleanOption2.id()).isEmpty());\n+        assertTrue(optionValues.find(stringOption.id()).isEmpty());\n+        assertTrue(optionValues.find(stringOption2.id()).isEmpty());\n+\n+        optionValues = parse.apply(allOptions, List.of(\"--b2\"));\n+\n+        assertTrue(optionValues.find(booleanOption.id()).isEmpty());\n+        assertTrue(optionValues.find(booleanOption2.id()).isPresent());\n+        assertTrue(optionValues.find(stringOption.id()).isEmpty());\n+        assertTrue(optionValues.find(stringOption2.id()).isEmpty());\n+\n+        optionValues = parse.apply(allOptions, List.of(\"--str=\"));\n+\n+        assertTrue(optionValues.find(booleanOption.id()).isEmpty());\n+        assertTrue(optionValues.find(booleanOption2.id()).isEmpty());\n+        assertTrue(optionValues.find(stringOption.id()).isPresent());\n+        assertTrue(optionValues.find(stringOption2.id()).isEmpty());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_copyWithExcludes(boolean withRedirects) {\n+        final var aOption = stringOption(\"astr\").createArray();\n+        final var bOption = stringOption(\"bstr\").tokenizeOne().createArray();\n+        final var cOption = stringOption(\"cstr\").tokenizeOne().converter(str -> {\n+            throw new RuntimeException();\n+        }).createArray();\n+\n+        var builder = new JOptSimpleOptionsBuilder().options(aOption, bOption, cOption);\n+        if (withRedirects) {\n+            builder.optionSpecMapper(spec -> {\n+                return spec.copyWithDescription(\"Foo\");\n+            });\n+        }\n+\n+        var vanillaParsedOptionBuilder = builder.create().apply(new String[] {\n+                \"--astr\", \"1\", \"--bstr\", \"2\", \"--astr\", \"3\", \"--bstr\", \"4\", \"--cstr\", \"foo\"\n+        }).orElseThrow();\n+\n+        var parsedOptionBuilder = vanillaParsedOptionBuilder;\n+        var options = parsedOptionBuilder.create();\n+\n+        assertEquals(Set.of(aOption.id(), bOption.id(), cOption.id()), options.ids());\n+        assertEquals(List.of(\"1\", \"3\"), List.of(aOption.getFrom(options)));\n+        assertEquals(List.of(\"2\", \"4\"), List.of(bOption.getFrom(options)));\n+        assertEquals(List.of(\"foo\"), List.of(cOption.getFrom(options)));\n+\n+        parsedOptionBuilder = parsedOptionBuilder.copyWithExcludes(List.of(cOption.id()));\n+        options = parsedOptionBuilder.create();\n+\n+        assertEquals(Set.of(aOption.id(), bOption.id()), options.ids());\n+        assertEquals(List.of(\"1\", \"3\"), List.of(aOption.getFrom(options)));\n+        assertEquals(List.of(\"2\", \"4\"), List.of(bOption.getFrom(options)));\n+        assertFalse(cOption.containsIn(options));\n+\n+        parsedOptionBuilder = parsedOptionBuilder.copyWithExcludes(List.of(bOption.id()));\n+        options = parsedOptionBuilder.create();\n+\n+        assertEquals(Set.of(aOption.id()), options.ids());\n+        assertEquals(List.of(\"1\", \"3\"), List.of(aOption.getFrom(options)));\n+        assertFalse(bOption.containsIn(options));\n+        assertFalse(cOption.containsIn(options));\n+\n+        var optionBuilder = vanillaParsedOptionBuilder.copyWithExcludes(List.of(cOption.id())).convertedOptions().orElseThrow();\n+        options = optionBuilder.create();\n+\n+        assertEquals(Set.of(aOption.id(), bOption.id()), options.ids());\n+        assertEquals(List.of(\"1\", \"3\"), List.of(aOption.getFrom(options)));\n+        assertEquals(List.of(\"2\", \"4\"), List.of(bOption.getFrom(options)));\n+        assertFalse(cOption.containsIn(options));\n+\n+        optionBuilder = optionBuilder.copyWithExcludes(List.of(aOption.id()));\n+        options = optionBuilder.create();\n+\n+        assertEquals(Set.of(bOption.id()), options.ids());\n+        assertFalse(aOption.containsIn(options));\n+        assertEquals(List.of(\"2\", \"4\"), List.of(bOption.getFrom(options)));\n+        assertFalse(cOption.containsIn(options));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(ParserMode.class)\n+    public void test_Options_concat(ParserMode mode) {\n+        final var a = stringOption(\"a\").create();\n+        final var b = stringOption(\"b\").create();\n+        final var c = stringOption(\"c\").create();\n+\n+        var builder = new JOptSimpleOptionsBuilder().options(a, b, c);\n+\n+        var parsedOptionBuilder = builder.create().apply(new String[] {\n+                \"-a\", \"foo\", \"-b\", \"bar\"\n+        }).orElseThrow();\n+\n+        Options optionsFromJoptSimple;\n+        var expectedOptions = expectOptions();\n+        switch (mode) {\n+            case PARSE -> {\n+                optionsFromJoptSimple = parsedOptionBuilder.create();\n+                expectedOptions.add(a, new String[] {\"foo\"});\n+            }\n+            case CONVERT -> {\n+                optionsFromJoptSimple = parsedOptionBuilder.convertedOptions().orElseThrow().create();\n+                expectedOptions.add(a, \"foo\");\n+            }\n+            default -> {\n+                throw new AssertionError();\n+            }\n+        }\n+\n+        var options = Options.concat(Options.of(Map.of(b, \"buz\")), optionsFromJoptSimple, Options.of(Map.of(c, 100)));\n+\n+        expectedOptions.add(c, 100).add(b, \"buz\").apply(options);\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(ParserMode.class)\n+    public void test_Options_copyWith(ParserMode mode) {\n+        final var a = stringOption(\"a\").create();\n+        final var b = stringOption(\"b\").create();\n+        final var c = stringOption(\"c\").create();\n+\n+        var builder = new JOptSimpleOptionsBuilder().options(a, b, c);\n+\n+        var parsedOptionBuilder = builder.create().apply(new String[] {\n+                \"-a\", \"foo\", \"-b\", \"bar\"\n+        }).orElseThrow();\n+\n+        Options optionsFromJoptSimple;\n+        var expectedOptions = expectOptions();\n+        switch (mode) {\n+            case PARSE -> {\n+                optionsFromJoptSimple = parsedOptionBuilder.create();\n+                expectedOptions.add(a, new String[] {\"foo\"});\n+            }\n+            case CONVERT -> {\n+                optionsFromJoptSimple = parsedOptionBuilder.convertedOptions().orElseThrow().create();\n+                expectedOptions.add(a, \"foo\");\n+            }\n+            default -> {\n+                throw new AssertionError();\n+            }\n+        }\n+\n+        var options = optionsFromJoptSimple.copyWith(a.id(), c.id());\n+\n+        expectedOptions.apply(options);\n+\n+        options = Options.concat(optionsFromJoptSimple.copyWith(a.id(), c.id()), Options.of(Map.of(c, 100)), Options.of(Map.of(b, \"buz\")));\n+\n+        expectedOptions.add(c, 100).add(b, \"buz\").apply(options);\n+    }\n+\n+    @Test\n+    public void test_detectedOptions() {\n+        final var aOption = stringOption(\"astr\").addAliases(\"a\").createArray();\n+        final var bOption = stringOption(\"bstr\").addAliases(\"b\").defaultOptionalValue(\"empty\").create();\n+        final var cOption = stringOption(\"cstr\").addAliases(\"c\").create();\n+        final var dOption = booleanOption(\"dbool\").addAliases(\"d\").create();\n+        final var eOption = booleanOption(\"ebool\").addAliases(\"e\").create();\n+\n+        var builder = new JOptSimpleOptionsBuilder().options(aOption, bOption, cOption, dOption, eOption);\n+\n+        assertEquals(List.of(), builder.create().apply(new String[] {}).orElseThrow().detectedOptions());\n+\n+        var vanillaParsedOptionBuilder = builder.create().apply(new String[] {\n+                \"-ddededa\", \"1\", \"--bstr\", \"--astr\", \"3\", \"--bstr\", \"4\", \"--ebool\", \"--cstr\", \"foo\", \"-b\"\n+        }).orElseThrow();\n+\n+        var parsedOptionBuilder = vanillaParsedOptionBuilder;\n+        var detectedOptions = parsedOptionBuilder.detectedOptions();\n+\n+        assertEquals(\n+                List.of(\"d\", \"d\", \"e\", \"d\", \"e\", \"d\", \"a\", \"bstr\", \"astr\", \"bstr\", \"ebool\", \"cstr\", \"b\"),\n+                detectedOptions.stream().map(OptionName::name).toList());\n+\n+        var convertedDetectedOptions = parsedOptionBuilder.convertedOptions().orElseThrow().detectedOptions();\n+        assertEquals(detectedOptions, convertedDetectedOptions);\n+\n+        parsedOptionBuilder = vanillaParsedOptionBuilder.copyWithExcludes(List.of(eOption.id()));\n+        detectedOptions = parsedOptionBuilder.detectedOptions();\n+\n+        assertEquals(\n+                List.of(\"d\", \"d\", \"d\", \"d\", \"a\", \"bstr\", \"astr\", \"bstr\", \"cstr\", \"b\"),\n+                detectedOptions.stream().map(OptionName::name).toList());\n+\n+        convertedDetectedOptions = parsedOptionBuilder.convertedOptions().orElseThrow().detectedOptions();\n+        assertEquals(detectedOptions, convertedDetectedOptions);\n+\n+        convertedDetectedOptions = parsedOptionBuilder.convertedOptions().orElseThrow().copyWithExcludes(List.of(aOption.id())).detectedOptions();\n+        assertEquals(\n+                List.of(\"d\", \"d\", \"d\", \"d\", \"bstr\", \"bstr\", \"cstr\", \"b\"),\n+                convertedDetectedOptions.stream().map(OptionName::name).toList());\n+    }\n+\n+    private static <T> T mergeScalarValues(List<T> values, MergePolicy mergePolicy) {\n+        switch (mergePolicy) {\n+            case USE_FIRST -> {\n+                return values.getFirst();\n+            }\n+            case USE_LAST -> {\n+                return values.getLast();\n+            }\n+            default -> {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+    }\n+\n+    private static <T> T[] mergeArrayValues(List<T[]> values, MergePolicy mergePolicy) {\n+        switch (mergePolicy) {\n+            case USE_FIRST -> {\n+                return values.getFirst();\n+            }\n+            case USE_LAST -> {\n+                return values.getLast();\n+            }\n+            case CONCATENATE -> {\n+                return values.stream().map(Stream::of).flatMap(x -> x).toList().toArray(values.getFirst());\n+            }\n+            default -> {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+    }\n+\n+    private static String[] mergeUntypedValues(List<String> values, MergePolicy mergePolicy) {\n+        switch (mergePolicy) {\n+            case USE_FIRST -> {\n+                return values.subList(0, 1).toArray(String[]::new);\n+            }\n+            case USE_LAST -> {\n+                return values.subList(values.size() - 1, values.size()).toArray(String[]::new);\n+            }\n+            case CONCATENATE -> {\n+                return values.toArray(String[]::new);\n+            }\n+            default -> {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+    }\n+\n+    private static List<Object[]> testMergePolicy() {\n+        final List<Object[]> data = new ArrayList<>();\n+        for (var mergePolicy : MergePolicy.values()) {\n+            for (var parserMode : ParserMode.values()) {\n+                data.add(new Object[] { mergePolicy, parserMode });\n+            }\n+        }\n+        return data;\n+    }\n+\n+    private static Collection<Object[]> testErrorMapping() {\n+        return List.<Object[]>of(\n+                testErrorMappingTestCase(JOptSimpleErrorType.UNRECOGNIZED_OPTION, \"-a\", \"-a\"),\n+                testErrorMappingTestCase(JOptSimpleErrorType.UNRECOGNIZED_OPTION, \"-a\", \"--a\"),\n+                testErrorMappingTestCase(JOptSimpleErrorType.UNRECOGNIZED_OPTION, \"-f\", \"-foo\"),\n+                \/\/ Two unrecognizable options, only the first one will be reported\n+                testErrorMappingTestCase(JOptSimpleErrorType.UNRECOGNIZED_OPTION, \"--foo\", \"--foo\", \"-z\"),\n+                testErrorMappingTestCase(JOptSimpleErrorType.UNRECOGNIZED_OPTION, \"-z\", \"-z\", \"--foo\"),\n+\n+                testErrorMappingTestCase(JOptSimpleErrorType.OPTION_MISSING_REQUIRED_ARGUMENT, \"--str\", \"--str\")\n+        );\n+    }\n+\n+    private static Object[] testErrorMappingTestCase(JOptSimpleErrorType type, String optionName, String... args) {\n+        Objects.requireNonNull(type);\n+        Objects.requireNonNull(optionName);\n+        return new Object[] { String.format(\"%s:%s\", type, optionName), args };\n+    }\n+\n+    private static Collection<TestSpec> testOptionalValueParse() {\n+        return testOptionalValue(ParserMode.PARSE);\n+    }\n+\n+    private static Collection<TestSpec> testOptionalValueConvert() {\n+        return testOptionalValue(ParserMode.CONVERT);\n+    }\n+\n+    private static Collection<TestSpec> testOptionalValue(ParserMode parserMode) {\n+        return Stream.of(\n+                build().mode(parserMode).args(\"-x\")\n+                .optionValue(option(\"x\", Integer.class).converter(Integer::valueOf).defaultOptionalValue(17).create())\n+                .expectParse(\"-x\").expect(17).commit(),\n+\n+                build().mode(parserMode).args(\"-x\")\n+                .optionValue(option(\"yy\", Integer.class).addAliases(\"x\").converter(Integer::valueOf).defaultOptionalValue(17).create())\n+                .expectParse(\"--yy\").expect(17).commit(),\n+\n+                build().mode(parserMode).args(\"--yy\")\n+                .optionValue(option(\"yy\", Integer.class).addAliases(\"x\").converter(Integer::valueOf).defaultOptionalValue(17).create())\n+                .expectParse(\"--yy\").expect(17).commit(),\n+\n+                build().mode(parserMode).args(\"-x\", \"23\")\n+                .optionValue(option(\"x\", Integer.class).converter(Integer::valueOf).defaultOptionalValue(17).create())\n+                .expectParse(\"23\").expect(23).commit(),\n+\n+                \/\/\n+                \/\/ joptsimple discards instances of an option without values if there is an instance of the option with a value\n+                \/\/\n+\n+                build().mode(parserMode).args(\"-x\", \"-x\", \"23\")\n+                .optionValue(option(\"x\", Integer.class).converter(Integer::valueOf).defaultOptionalValue(17).create())\n+                .expectParse(\"23\").expect(23).commit(),\n+\n+                build().mode(parserMode).args(\"-x\", \"-x\", \"23:17\", \"-x\", \"56\", \"-x\")\n+                .optionValue(option(\"x\", Integer.class).converter(Integer::valueOf).defaultOptionalValue(17).tokenizer(\":\").createArray())\n+                .expectParse(\"23:17\", \"56\").expect(new Integer[] {23, 17, 56}).commit(),\n+\n+                build().mode(parserMode).args(\"-x\", \"-x\", \"-x\")\n+                .optionValue(option(\"x\", Integer.class).converter(Integer::valueOf).defaultOptionalValue(17).tokenizer(\":\").createArray())\n+                .expectParse(\"-x\").expect(new Integer[] {17}).commit(),\n+\n+                build().mode(parserMode).args(\"-x\", \"--yy\")\n+                .optionValue(option(\"yy\", Integer.class).addAliases(\"x\").converter(Integer::valueOf).defaultOptionalValue(17).tokenizer(\":\").createArray())\n+                .expectParse(\"--yy\").expect(new Integer[] {17}).commit(),\n+\n+                build().mode(parserMode).args(\"-x\", \"--yy\", \"-x\", \"--yy\", \"-x\", \"--yy\")\n+                .optionValue(option(\"yy\", Integer.class).addAliases(\"x\").converter(Integer::valueOf).defaultOptionalValue(17).tokenizer(\":\").createArray())\n+                .expectParse(\"--yy\").expect(new Integer[] {17}).commit(),\n+\n+                build().mode(parserMode).args(\"-x\", \"--yy\", \"23:17\", \"-x\", \"56\", \"-x\")\n+                .optionValue(option(\"yy\", Integer.class).addAliases(\"x\").converter(Integer::valueOf).defaultOptionalValue(17).tokenizer(\":\").createArray())\n+                .expectParse(\"23:17\", \"56\").expect(new Integer[] {23, 17, 56}).commit(),\n+\n+                build().mode(parserMode).args(\"-x\", \"--yy\", \"23\", \"-x\", \"56\", \"-x\")\n+                .optionValue(option(\"yy\", Integer.class).addAliases(\"x\").converter(Integer::valueOf).defaultOptionalValue(17).create())\n+                .expectParse(\"56\").expect(56).commit()\n+        ).map(TestSpec.Builder::create).toList();\n+    }\n+\n+    private static Collection<TestSpec> test() {\n+        final var pwd = Path.of(\"\").toAbsolutePath();\n+        return Stream.of(\n+                build().optionValue(\n+                        directoryOption(\"input\").addAliases(\"i\").create(),\n+                        pwd\n+                ).args(\"--input\", \"\", \"-i\", pwd.toString()),\n+\n+                build().optionValue(\n+                        directoryOption(\"dir\").tokenizer(pathSeparator()).createArray(),\n+                        new Path[] { pwd, Path.of(\".\") }\n+                ).args(\"--dir=\" + pwd.toString() + pathSeparator() + \".\"),\n+\n+                build().optionValue(\n+                        stringOption(\"arguments\").tokenizer(\"\\\\s+\").createArray(toList()),\n+                        List.of(\"\", \"a\", \"b\", \"c\", \"\", \"de\")\n+                ).args(\"--arguments\", \" a b  c\", \"--arguments\", \" de\"),\n+\n+                build().optionValue(\n+                        stringOption(\"arguments\").tokenizer(\";+\").createArray(toList()),\n+                        List.of(\"a b\", \"c\", \"de\")\n+                ).args(\"--arguments\", \"a b;;c\", \"--arguments\", \"de;\"),\n+\n+                build().optionValue(stringOption(\"foo\").create(), \"--foo\").args(\"--foo\", \"--foo\"),\n+\n+                build().args(\"--foo\")\n+                        .optionValue(booleanOption(\"foo\").create(), true)\n+                        .optionValue(booleanOption(\"bar\").create(), false),\n+\n+                build().args(\"-x\", \"\").optionValue(stringOption(\"x\").create(), \"\"),\n+                build().args(\"-x\", \"\").optionValue(stringOption(\"x\").createArray(), new String[] {\"\"}),\n+                build().args(\"-x\", \"\", \"-x\", \"\").optionValue(stringOption(\"x\").createArray(), new String[] {\"\", \"\"}),\n+\n+                \/\/ Test merging order.\n+                build().optionValue(\n+                        stringOption(\"x\").addAliases(\"y\").tokenizeOne().createArray(toList()),\n+                        List.of(\"10\", \"RR\", \"P\", \"Z\")\n+                ).args(\"-x\", \"10\", \"-y\", \"RR\", \"-x\", \"P\", \"-y\", \"Z\"),\n+\n+                \/\/ Test converters are not executed on discarded invalid values (recoverable conversion errors).\n+                build().optionValue(\n+                        option(\"x\", Integer.class).converter(Integer::valueOf).create(),\n+                        100\n+                ).args(\"-x\", \"a\", \"-x\", \"100\"),\n+                build().optionValue(\n+                        option(\"x\", Integer.class).mergePolicy(MergePolicy.USE_FIRST)\n+                                .exceptionFormatString(\"\")\n+                                .exceptionFactory(ERROR_WITH_VALUE_AND_OPTION_NAME)\n+                                .converter(Integer::valueOf).tokenizer(\",\").createArray(),\n+                        new Integer[] {34}\n+                ).args(\"-x\", \"34,A\", \"-x\", \"f\"),\n+\n+                \/\/ Test the last array element (recoverable conversion errors).\n+                build().optionValue(\n+                        option(\"x\", Integer.class).mergePolicy(MergePolicy.USE_LAST)\n+                                .converter(Integer::valueOf).tokenizer(\",\").createArray(toList()),\n+                        List.of(78)\n+                ).args(\"-x\", \"1,3,78\"),\n+                build().optionValue(\n+                        option(\"x\", Integer.class).mergePolicy(MergePolicy.USE_LAST)\n+                                .exceptionFormatString(\"\")\n+                                .exceptionFactory(ERROR_WITH_VALUE_AND_OPTION_NAME)\n+                                .converter(Integer::valueOf).tokenizer(\",\").createArray(toList()),\n+                        List.of(78)\n+                ).args(\"-x\", \"1,ZZZ,78\"),\n+                build().optionValue(\n+                        option(\"x\", Integer.class).mergePolicy(MergePolicy.USE_LAST)\n+                                .converter(Integer::valueOf).tokenizer(\",\").createArray(toList()),\n+                        List.of(35)\n+                ).args(\"-x\", \"1,3,78\", \"-x\", \"a\", \"-x\", \"35\"),\n+                build().optionValue(\n+                        option(\"x\", Integer.class).mergePolicy(MergePolicy.USE_LAST)\n+                                .converter(Integer::valueOf).tokenizer(TestUtils.splitOrEmpty(\",\")).createArray(toList()),\n+                        List.of()\n+                ).args(\"-x\", \"1,3,78\", \"-x\", \"\"),\n+\n+                \/\/ Test the first array element (recoverable conversion errors).\n+                build().optionValue(\n+                        option(\"x\", Integer.class).mergePolicy(MergePolicy.USE_FIRST)\n+                                .exceptionFormatString(\"\")\n+                                .exceptionFactory(ERROR_WITH_VALUE_AND_OPTION_NAME)\n+                                .converter(Integer::valueOf).tokenizer(\",\").createArray(toList()),\n+                        List.of(1)\n+                ).args(\"-x\", \"1,ZZZ,78\"),\n+                build().optionValue(\n+                        option(\"x\", Integer.class).mergePolicy(MergePolicy.USE_FIRST)\n+                                .converter(Integer::valueOf).tokenizer(\",\").createArray(toList()),\n+                        List.of(1)\n+                ).args(\"-x\", \"1,3,78\", \"-x\", \"a\", \"-x\", \"35\"),\n+                build().optionValue(\n+                        option(\"x\", Integer.class).mergePolicy(MergePolicy.USE_FIRST)\n+                                .converter(Integer::valueOf).tokenizer(TestUtils.splitOrEmpty(\",\")).createArray(toList()),\n+                        List.of()\n+                ).args(\"-x\", \"\", \"-x\", \"1,23,78\"),\n+\n+                \/\/ Test array value is a scalar for parser.\n+                build().optionValue(\n+                        option(\"arr\", int[].class).converter(str -> {\n+                            return Stream.of(str.split(\",\")).map(Integer::valueOf).mapToInt(Integer::intValue).toArray();\n+                        }).create(),\n+                        new int[] {1, 45, 67}\n+                ).args(\"--arr=1,45,67\"),\n+\n+                \/\/ Test that parser can handle multi-dimensional arrays.\n+                build().optionValue(\n+                        option(\"arr\", int[].class).converter(str -> {\n+                            if (str.isEmpty()) {\n+                                return new int[0];\n+                            } else {\n+                                return Stream.of(str.split(\",\")).map(Integer::valueOf).mapToInt(Integer::intValue).toArray();\n+                            }\n+                        }).tokenizer(\":\").createArray(toList()),\n+                        List.of(new int[] {1, 45, 67}, new int[0], new int[] {3}, new int[] {56}, new int[] {77, 82}),\n+                        (expected, actual) -> {\n+                            assertEquals(expected.size(), actual.size());\n+                            for (int i = 0; i != expected.size(); i++) {\n+                                assertArrayEquals(expected.get(i), actual.get(i));\n+                            }\n+                        }\n+                ).args(\"--arr=1,45,67::3:56\", \"--arr=77,82\")\n+\n+        ).map(TestSpec.Builder::create).toList();\n+    }\n+\n+    private static Collection<TestSpec> testStringVector() {\n+        final var args = List.of(\"--foo\", \"1 22 333\", \"--foo\", \"44 44\");\n+        return Stream.of(\n+                build().optionValue(\n+                        stringOption(\"foo\").createArray(),\n+                        new String[] { \"1 22 333\", \"44 44\" }\n+                ).args(args),\n+\n+                build().optionValue(\n+                        stringOption(\"foo\").tokenizeOne().createArray(toList()),\n+                        List.of(\"1 22 333\", \"44 44\")\n+                ).args(args),\n+\n+                build().optionValue(\n+                        stringOption(\"foo\").tokenizer(\"\\\\s+\").createArray(),\n+                        new String[] { \"1\", \"22\", \"333\", \"44\", \"44\" }\n+                ).args(args),\n+\n+                build().optionValue(\n+                        stringOption(\"foo\").tokenizer(\"\\\\s+\").createArray(toList()),\n+                        List.of(\"1\", \"22\", \"333\", \"44\", \"44\")\n+                ).args(args)\n+        ).map(TestSpec.Builder::create).toList();\n+    }\n+\n+    private static <T> OptionSpecBuilder<T> option(String name, Class<? extends T> valueType) {\n+        return OptionSpecBuilder.<T>create(valueType)\n+                .name(Objects.requireNonNull(name))\n+                .scope(new BundlingOperationOptionScope() {\n+                    @Override\n+                    public BundlingOperationDescriptor descriptor() {\n+                        throw new AssertionError();\n+                    }});\n+    }\n+\n+    private static OptionSpecBuilder<String> stringOption(String name) {\n+        return option(name, String.class).converter(identityConv());\n+    }\n+\n+    private static OptionSpecBuilder<Path> pathOption(String name) {\n+        return option(name, Path.class)\n+                .converter(pathConv())\n+                \/\/ \"*\" is an invalid symbol in Windows paths and valid in Linux paths.\n+                \/\/ Add a validator to make it invalid on all platforms to simplify testing.\n+                .validator(new Predicate<Path>() {\n+                    @Override\n+                    public boolean test(Path path) {\n+                        return path.toString().indexOf(\"*\") == -1;\n+                    }\n+                })\n+                .converterExceptionFactory(ERROR_WITH_VALUE_AND_OPTION_NAME)\n+                .converterExceptionFormatString(FORMAT_STRING_ILLEGAL_PATH);\n+    }\n+\n+    private static OptionSpecBuilder<Path> directoryOption(String name) {\n+        return pathOption(name)\n+                .validator(StandardValidator.IS_DIRECTORY)\n+                .validatorExceptionFactory(ERROR_WITH_VALUE_AND_OPTION_NAME)\n+                .validatorExceptionFormatString(FORMAT_STRING_NOT_DIRECTORY);\n+    }\n+\n+    private static OptionSpecBuilder<Boolean> booleanOption(String name) {\n+        return option(name, Boolean.class).defaultValue(Boolean.FALSE);\n+    }\n+\n+    private static Function<List<String>, Options> createParser(ParserMode mode, OptionValue<?>... options) {\n+        return createParser(mode, List.of(options));\n+    }\n+\n+    private static Function<List<String>, Options> createParser(ParserMode mode, Iterable<OptionValue<?>> options) {\n+        Objects.requireNonNull(mode);\n+        final var parse = new JOptSimpleOptionsBuilder().options(StreamSupport.stream(options.spliterator(), false)\n+                .map(OptionValue::getOption).toList()).create();\n+        return args -> {\n+            final var builder = parse.apply(args.toArray(String[]::new)).orElseThrow();\n+            switch (mode) {\n+                case PARSE -> {\n+                    return builder.create();\n+                }\n+                case CONVERT -> {\n+                    return builder.convertedOptions().orElseThrow().create();\n+                }\n+                default -> {\n+                    throw new IllegalArgumentException();\n+                }\n+            }\n+        };\n+    }\n+\n+    private static TestSpec.Builder build() {\n+        return new TestSpec.Builder();\n+    }\n+\n+\n+    private static final class FaultyParserArgsConfig {\n+\n+        void test() {\n+\n+            final Collection<OptionFailure> recordedErrors = new ArrayList<>();\n+\n+            final List<OptionValue<?>> optionValues = new ArrayList<>();\n+\n+            optionSpecBuilders.stream().map(builder -> {\n+                configureExceptions(builder);\n+                return builder.exceptionFactory(TestUtils.recordExceptions(recordedErrors));\n+            }).map(OptionSpecBuilder::create).forEach(optionValues::add);\n+\n+            arrayOptionSpecBuilders.stream().map(builder -> {\n+                configureExceptions(builder);\n+                return builder.exceptionFactory(TestUtils.recordExceptions(recordedErrors));\n+            }).map(OptionSpecBuilder::createArray).forEach(optionValues::add);\n+\n+            final var parser = new JOptSimpleOptionsBuilder().options(optionValues).create();\n+\n+            final Supplier<Result<?>> createCmdline = parser.apply(args.toArray(String[]::new)).orElseThrow()::convertedOptions;\n+\n+            if (expectedConverterException == null) {\n+                final var result = createCmdline.get();\n+\n+                assertFalse(result.hasValue());\n+\n+                \/\/ Not all exceptions recorded by TestUtils.recordExceptions() facility\n+                \/\/ will be returned by JOptSimpleOptionsBuilder.OptionsBuilder.convertedOptions()\n+                \/\/ because it may run a converter multiple times on the same option value,\n+                \/\/ attempting to recover from a previous error.\n+                var actualErrors = result.errors().stream().map(exception -> {\n+                    return recordedErrors.stream().filter(recorderdFailure -> {\n+                        return (recorderdFailure.exception().orElseThrow() == exception);\n+                    }).findFirst().map(OptionFailure::withoutException).orElseThrow();\n+                }).toList();\n+\n+                assertEquals(expectedErrors, actualErrors);\n+\n+            } else {\n+                final var ex = assertThrowsExactly(ConverterException.class, () -> createCmdline.get());\n+                assertSame(expectedConverterException, ex.getCause());\n+            }\n+        }\n+\n+        FaultyParserArgsConfig args(Collection<String> v) {\n+            args.addAll(v);\n+            return this;\n+        }\n+\n+        FaultyParserArgsConfig args(String... v) {\n+            return args(List.of(v));\n+        }\n+\n+        FaultyParserArgsConfig clearArgs() {\n+            args.clear();\n+            return this;\n+        }\n+\n+        FaultyParserArgsConfig options(Collection<OptionSpecBuilder<?>> v) {\n+            optionSpecBuilders.addAll(v);\n+            return this;\n+        }\n+\n+        FaultyParserArgsConfig options(OptionSpecBuilder<?>... v) {\n+            return options(List.of(v));\n+        }\n+\n+        FaultyParserArgsConfig arrayOptions(Collection<OptionSpecBuilder<?>> v) {\n+            arrayOptionSpecBuilders.addAll(v);\n+            return this;\n+        }\n+\n+        FaultyParserArgsConfig arrayOptions(OptionSpecBuilder<?>... v) {\n+            return arrayOptions(List.of(v));\n+        }\n+\n+        FaultyParserArgsConfig expectErrors(Collection<OptionFailure> v) {\n+            expectedErrors.addAll(v);\n+            return this;\n+        }\n+\n+        FaultyParserArgsConfig expectErrors(OptionFailure... v) {\n+            return expectErrors(List.of(v));\n+        }\n+\n+        FaultyParserArgsConfig expectError(String optionName, String optionValue) {\n+            return expectError(optionName, StringToken.of(optionValue));\n+        }\n+\n+        FaultyParserArgsConfig expectError(String optionName, StringToken optionValue) {\n+            return expectErrors(new OptionFailure(optionName, optionValue));\n+        }\n+\n+        FaultyParserArgsConfig expectConverterException(Exception v) {\n+            expectedConverterException = v;\n+            return this;\n+        }\n+\n+        private static void configureExceptions(OptionSpecBuilder<?> builder) {\n+            builder.exceptionFactory(factory -> {\n+                if (factory == null) {\n+                    builder.exceptionFormatString(\"Option value [%s] of option %s\");\n+                    factory = ERROR_WITH_VALUE_AND_OPTION_NAME;\n+                }\n+                return factory;\n+            });\n+        }\n+\n+        private final List<String> args = new ArrayList<>();\n+        private final Collection<OptionSpecBuilder<?>> optionSpecBuilders = new ArrayList<>();\n+        private final Collection<OptionSpecBuilder<?>> arrayOptionSpecBuilders = new ArrayList<>();\n+        private final List<OptionFailure> expectedErrors = new ArrayList<>();\n+        private Exception expectedConverterException;\n+    }\n+\n+\n+    private static final String FORMAT_STRING_ILLEGAL_PATH = \"The value '%s' provided for parameter %s is not a valid path\";\n+\n+    private static final String FORMAT_STRING_NOT_DIRECTORY = \"The value '%s' provided for parameter %s is not a directory path\";\n+\n+    private static final OptionValueExceptionFactory<? extends RuntimeException> ERROR_WITH_VALUE_AND_OPTION_NAME = OptionValueExceptionFactory.build(TestException::new)\n+            .formatArgumentsTransformer(StandardArgumentsMapper.VALUE_AND_NAME)\n+            .messageFormatter(String::format)\n+            .create();\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/JOptSimpleOptionsBuilderTest.java","additions":1428,"deletions":0,"binary":false,"changes":1428,"status":"added"},{"patch":"@@ -0,0 +1,203 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.test.JUnitAdapter;\n+import jdk.jpackage.test.TKit;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class MainTest extends JUnitAdapter.TestSrcInitializer {\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testOutput(TestSpec test) throws IOException {\n+        test.run();\n+    }\n+\n+    private static Collection<TestSpec> testOutput() {\n+        return Stream.of(\n+                \/\/ Print the tool version\n+                build().expectShortHelp(),\n+                \/\/ Print the tool version\n+                build().args(\"--version\").expectVersion(),\n+                \/\/ Print the tool version\n+                build().args(\"foo\", \"bar\").expectErrors(I18N.format(\"error.non-option-arguments\", 2)),\n+                \/\/ Valid command line requesting to print the full help.\n+                build().args(\"-h\").expectFullHelp(),\n+                \/\/ Valid command line requesting to build a package and print the full help.\n+                build().args(\"--main-jar\", \"hello.jar\", \"-?\", \"--main-class\", \"foo\").expectFullHelp(),\n+                \/\/ Valid command line requesting to build a package and print the full help and the version of the tool.\n+                build().args(\"--main-jar\", \"hello.jar\", \"-?\", \"--main-class\", \"foo\", \"--version\").expectVersionWithHelp(),\n+                \/\/ Valid command line requesting to print the full help and the version of the tool.\n+                build().args(\"--help\", \"--version\").expectVersionWithHelp(),\n+                \/\/ Invalid command line requesting to print the version of the tool.\n+                build().args(\"foo\", \"--version\").expectErrors(I18N.format(\"error.non-option-arguments\", 1))\n+        ).map(TestSpec.Builder::create).toList();\n+    }\n+\n+\n+    record TestSpec(List<String> args, int expectedExitCode, List<String> expectedStdout, List<String> expectedStderr) {\n+\n+        TestSpec {\n+            Objects.requireNonNull(args);\n+            Objects.requireNonNull(expectedStdout);\n+            Objects.requireNonNull(expectedStderr);\n+        }\n+\n+        void run() {\n+            var result = ExecutionResult.create(args.toArray(String[]::new));\n+            assertEquals(expectedExitCode, result.exitCode());\n+            assertEquals(expectedStdout, result.stdout());\n+            assertEquals(expectedStderr, result.stderr());\n+        }\n+\n+\n+        static final class Builder {\n+\n+            TestSpec create() {\n+                return new TestSpec(args, expectedExitCode, expectedStdout, expectedStderr);\n+            }\n+\n+            Builder args(String... v) {\n+                return args(List.of(v));\n+            }\n+\n+            Builder args(Collection<String> v) {\n+                args.addAll(v);\n+                return this;\n+            }\n+\n+            Builder expectStdout(String... lines) {\n+                return expectStdout(List.of(lines));\n+            }\n+\n+            Builder expectStdout(Collection<String> lines) {\n+                return append(expectedStdout, lines);\n+            }\n+\n+            Builder expectStderr(String... lines) {\n+                return expectStderr(List.of(lines));\n+            }\n+\n+            Builder expectStderr(Collection<String> lines) {\n+                return append(expectedStderr, lines);\n+            }\n+\n+            Builder expectShortHelp() {\n+                var sb = new StringBuilder();\n+                new StandardHelpFormatter(OperatingSystem.current()).formatNoArgsHelp(sb::append);\n+                return expectStdout(lines(sb.toString()));\n+            }\n+\n+            Builder expectFullHelp() {\n+                try {\n+                    return expectStdout(Files.readAllLines(goldenHelpOutputFile(OperatingSystem.current())));\n+                } catch (IOException ex) {\n+                    throw new UncheckedIOException(ex);\n+                }\n+            }\n+\n+            Builder expectVersion() {\n+                return expectStdout(System.getProperty(\"java.version\"));\n+            }\n+\n+            Builder expectVersionWithHelp() {\n+                return expectVersion().expectStdout(\"\").expectFullHelp();\n+            }\n+\n+            Builder expectErrors(String... msg) {\n+                return expectErrorExitCode().expectStderr(Stream.of(msg).map(v -> {\n+                    return I18N.format(\"message.error-header\", v);\n+                }).toList());\n+            }\n+\n+            Builder expectExitCode(int v) {\n+                expectedExitCode = v;\n+                return this;\n+            }\n+\n+            Builder expectErrorExitCode() {\n+                return expectExitCode(1);\n+            }\n+\n+            private Builder append(List<String> sink, Collection<String> lines) {\n+                lines.forEach(sink::add);\n+                return this;\n+            }\n+\n+            private List<String> args = new ArrayList<>();\n+            private int expectedExitCode;\n+            private List<String> expectedStdout = new ArrayList<>();\n+            private List<String> expectedStderr = new ArrayList<>();\n+        }\n+    }\n+\n+\n+    private record ExecutionResult(List<String> stdout, List<String> stderr, int exitCode) {\n+\n+        ExecutionResult {\n+            Objects.requireNonNull(stdout);\n+            Objects.requireNonNull(stderr);\n+        }\n+\n+        static ExecutionResult create(String... args) {\n+            var stdout = new StringWriter();\n+            var stderr = new StringWriter();\n+\n+            var exitCode = Main.run(new PrintWriter(stdout), new PrintWriter(stderr), args);\n+\n+            return new ExecutionResult(lines(stdout.toString()), lines(stderr.toString()), exitCode);\n+        }\n+    }\n+\n+\n+    private static TestSpec.Builder build() {\n+        return new TestSpec.Builder();\n+    }\n+\n+    private static List<String> lines(String str) {\n+        return new BufferedReader(new StringReader(str)).lines().toList();\n+    }\n+\n+    private static Path goldenHelpOutputFile(OperatingSystem os) {\n+        String fname = String.format(\"help-%s.txt\", os.name().toLowerCase());\n+        return TKit.TEST_SRC_ROOT.resolve(\"junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\", fname);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/MainTest.java","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.model.BundlingOperationDescriptor;\n+\n+final class MockupCliBundlingEnvironment implements CliBundlingEnvironment {\n+\n+    static Builder build() {\n+        return new Builder();\n+    }\n+\n+    private MockupCliBundlingEnvironment(\n+            Optional<BundlingOperationDescriptor> defaultOperation,\n+            BiConsumer<BundlingOperationDescriptor, Options> createBundleCallback,\n+            Map<BundlingOperationDescriptor, List<Exception>> knownOperations) {\n+\n+        this.defaultOperation = Objects.requireNonNull(defaultOperation);\n+        this.createBundleCallback = Objects.requireNonNull(createBundleCallback);\n+        this.knownOperations = Map.copyOf(knownOperations);\n+    }\n+\n+    @Override\n+    public Optional<BundlingOperationDescriptor> defaultOperation() {\n+        return defaultOperation;\n+    }\n+\n+    @Override\n+    public void createBundle(BundlingOperationDescriptor op, Options cmdline) {\n+        createBundleCallback.accept(throwIfUnknownBundlingOperation(op), cmdline);\n+    }\n+\n+    @Override\n+    public Collection<? extends Exception> configurationErrors(BundlingOperationDescriptor op) {\n+        throwIfUnknownBundlingOperation(op);\n+        return Optional.ofNullable(knownOperations.get(op)).orElseGet(List::of);\n+    }\n+\n+    private BundlingOperationDescriptor throwIfUnknownBundlingOperation(BundlingOperationDescriptor op) {\n+        if (!knownOperations.containsKey(Objects.requireNonNull(op))) {\n+            throw new NoSuchElementException(String.format(\"Unknown bunbdling operation: [%s]\", op));\n+        }\n+        return op;\n+    }\n+\n+    static StandardBundlingOperation createAppImageBundlingOperation(OperatingSystem os) {\n+        Objects.requireNonNull(os);\n+        return StandardBundlingOperation.CREATE_APP_IMAGE.stream()\n+                .map(StandardBundlingOperation.class::cast)\n+                .filter(StandardBundlingOperation.platform(os))\n+                .findFirst().orElseThrow();\n+    }\n+\n+\n+    static final class Builder {\n+\n+        CliBundlingEnvironment create() {\n+            return new MockupCliBundlingEnvironment(\n+                    defaultOperation(),\n+                    createBundleCallback().orElse((_, _) -> {}),\n+                    knownOperations);\n+        }\n+\n+        Builder defaultOperation(BundlingOperationDescriptor v) {\n+            defaultOperation = v;\n+            return this;\n+        }\n+\n+        Builder knownOperation(BundlingOperationDescriptor v) {\n+            knownOperations.putIfAbsent(Objects.requireNonNull(v), List.of());\n+            return this;\n+        }\n+\n+        Builder createAppImageByDefault(OperatingSystem os) {\n+            return defaultOperation(createAppImageBundlingOperation(os).descriptor());\n+        }\n+\n+        Builder createAppImageByDefault() {\n+            return createAppImageByDefault(OperatingSystem.current());\n+        }\n+\n+        Builder createBundleCallback(Consumer<Options> v) {\n+            return createBundleCallback((_, options) -> v.accept(options));\n+        }\n+\n+        Builder createBundleCallback(BiConsumer<BundlingOperationDescriptor, Options> v) {\n+            createBundleCallback = v;\n+            return this;\n+        }\n+\n+        Builder configurationErrors(BundlingOperationDescriptor targetOperation, List<Exception> v) {\n+            if (targetOperation != null) {\n+                knownOperations.merge(targetOperation, v, (x, y) -> {\n+                    List<Exception> errors = new ArrayList<>(x);\n+                    errors.addAll(y);\n+                    return errors;\n+                });\n+            } else if (!knownOperations.isEmpty()) {\n+                knownOperations.keySet().forEach(op -> {\n+                    configurationErrors(op, v);\n+                });\n+            } else {\n+                throw new UnsupportedOperationException(\"Can not set errors for unknown bundling operations\");\n+            }\n+            return this;\n+        }\n+\n+        Builder configurationErrors(BundlingOperationDescriptor targetOperation, Exception... errors) {\n+            return configurationErrors(targetOperation, List.of(errors));\n+        }\n+\n+        private Optional<BiConsumer<BundlingOperationDescriptor, Options>> createBundleCallback() {\n+            return Optional.ofNullable(createBundleCallback);\n+        }\n+\n+        private Optional<BundlingOperationDescriptor> defaultOperation() {\n+            return Optional.ofNullable(defaultOperation);\n+        }\n+\n+        private BundlingOperationDescriptor defaultOperation;\n+        private BiConsumer<BundlingOperationDescriptor, Options> createBundleCallback;\n+        private final Map<BundlingOperationDescriptor, List<Exception>> knownOperations = new HashMap<>();\n+    }\n+\n+\n+    private final Optional<BundlingOperationDescriptor> defaultOperation;\n+    private final BiConsumer<BundlingOperationDescriptor, Options> createBundleCallback;\n+    private final Map<BundlingOperationDescriptor, List<Exception>> knownOperations;\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/MockupCliBundlingEnvironment.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static jdk.jpackage.internal.cli.OptionIdentifier.createIdentifier;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNotSame;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+\n+import org.junit.jupiter.api.Test;\n+\n+public class OptionIdentifierTest {\n+\n+    @Test\n+    public void test_createUnique() {\n+\n+        var a = createIdentifier();\n+        var b = createIdentifier();\n+\n+        assertNotNull(a);\n+        assertNotNull(b);\n+\n+        assertNotSame(a, b);\n+        assertNotEquals(a, b);\n+    }\n+\n+    @Test\n+    public void test_of() {\n+\n+        assertThrowsExactly(NullPointerException.class, () -> OptionIdentifier.of(null));\n+\n+        var a = OptionIdentifier.of(\"a\");\n+\n+        assertNotNull(a);\n+\n+        assertNotEquals(\"a\", a);\n+        assertNotEquals(createIdentifier(), a);\n+        assertEquals(OptionIdentifier.of(\"a\"), a);\n+        assertNotEquals(OptionIdentifier.of(\"A\"), a);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/OptionIdentifierTest.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class OptionNameTest {\n+\n+    record TestSpec(String value, String expectedName, String expectedOnCmdLine, boolean expectedIsShort) {\n+        TestSpec {\n+            Objects.requireNonNull(value);\n+            Objects.requireNonNull(expectedName);\n+            Objects.requireNonNull(expectedOnCmdLine);\n+        }\n+\n+        void run() {\n+            final var optionName = OptionName.of(value);\n+\n+            assertEquals(expectedName, optionName.name());\n+            assertEquals(expectedOnCmdLine, optionName.formatForCommandLine());\n+            assertEquals(expectedIsShort, optionName.isShort());\n+        }\n+\n+        static final class Builder {\n+\n+            TestSpec create() {\n+                return new TestSpec(value, validatedExpectedName(), validatedExpectedOnCmdLine(), validatedExpectedIsShort());\n+            }\n+\n+            Builder value(String v) {\n+                value = v;\n+                return this;\n+            }\n+\n+            Builder expectedName(String v) {\n+                expectedName = v;\n+                return this;\n+            }\n+\n+            Builder expectedOnCmdLine(String v) {\n+                expectedOnCmdLine = v;\n+                return this;\n+            }\n+\n+            Builder isShort() {\n+                expectedIsShort = true;\n+                return this;\n+            }\n+\n+            private String validatedExpectedName() {\n+                return Optional.ofNullable(expectedName).orElse(value);\n+            }\n+\n+            private String validatedExpectedOnCmdLine() {\n+                return Optional.ofNullable(expectedOnCmdLine).orElseGet(() -> {\n+                    if (validatedExpectedIsShort()) {\n+                        return \"-\" + validatedExpectedName();\n+                    } else {\n+                        return \"--\" + validatedExpectedName();\n+                    }\n+                });\n+            }\n+\n+            private boolean validatedExpectedIsShort() {\n+                return Optional.ofNullable(expectedIsShort).orElseGet(() -> {\n+                    return validatedExpectedName().length() == 1;\n+                });\n+            }\n+\n+            private String value;\n+            private String expectedName;\n+            private String expectedOnCmdLine;\n+            private Boolean expectedIsShort;\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test(TestSpec testSpec) {\n+        testSpec.run();\n+    }\n+\n+    private static List<TestSpec> test() {\n+        return Stream.of(\n+                build(\"foo\"),\n+                build(\"x\"),\n+                build(\"--foo\").expectedName(\"foo\"),\n+                build(\"--f\").expectedName(\"f\").isShort(),\n+                build(\"-foo\").expectedName(\"f\").isShort(),\n+                build(\"-x\").expectedName(\"x\").isShort(),\n+                build(\"---\").expectedName(\"-\")\n+        ).map(TestSpec.Builder::create).toList();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void negativeTest(Map.Entry<String, String> testSpec) {\n+        final var ex = assertThrowsExactly(IllegalArgumentException.class, () -> OptionName.of(testSpec.getKey()));\n+        assertEquals(testSpec.getValue(), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void compareTest() {\n+        assertTrue(0 == OptionName.of(\"a\").compareTo(OptionName.of(\"a\")));\n+        assertTrue(OptionName.of(\"a\").compareTo(OptionName.of(\"b\")) < 0);\n+        assertTrue(OptionName.of(\"b\").compareTo(OptionName.of(\"a\")) > 0);\n+    }\n+\n+    private static Collection<Map.Entry<String, String>> negativeTest() {\n+        return Map.of(\n+                \"\", \"Name should not be empty\",\n+                \"-\", \"Short option without a name\",\n+                \"--\", \"Long option without a name\"\n+        ).entrySet();\n+    }\n+\n+    private static TestSpec.Builder build(String value) {\n+        return new TestSpec.Builder().value(value);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/OptionNameTest.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+public class OptionSpecMutatorOptionScopeTest {\n+\n+    record DummyContext(int value) {\n+        <T> OptionSpec<T> mapOptionSpec(OptionSpec<T> optionSpec) {\n+            return OptionSpecMapperOptionScope.mapOptionSpec(optionSpec, this);\n+        }\n+\n+        static <T> Consumer<OptionSpecBuilder<T>> createOptionSpecBuilderMutator(\n+                BiConsumer<OptionSpecBuilder<T>, DummyContext> mutator) {\n+            return OptionSpecMapperOptionScope.createOptionSpecBuilderMutator(DummyContext.class, mutator);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_mapOptionSpec_scalar(boolean multipleMutators) {\n+\n+        var theSpecBuilder = OptionSpecBuilder.<String>create(String.class).converter(str -> {\n+            return \"123\";\n+        }).name(\"foo\");\n+\n+        DummyContext.<String>createOptionSpecBuilderMutator((specBuilder, context) -> {\n+            specBuilder.converter(str -> {\n+                return Integer.toString(context.value());\n+            });\n+        }).accept(theSpecBuilder);\n+\n+        if (multipleMutators) {\n+            DummyContext.<String>createOptionSpecBuilderMutator((specBuilder, _) -> {\n+                specBuilder.name(\"Foo\");\n+            }).accept(theSpecBuilder);\n+        }\n+\n+        var spec = theSpecBuilder.createOptionSpec();\n+\n+        var mappedSpec = new DummyContext(731).mapOptionSpec(spec);\n+\n+        if (multipleMutators) {\n+            assertEquals(OptionName.of(\"Foo\"), mappedSpec.name());\n+        } else {\n+            assertEquals(OptionName.of(\"foo\"), mappedSpec.name());\n+        }\n+\n+        assertEquals(\"731\", mappedSpec.converter().orElseThrow().convert(spec.name(), StringToken.of(\"str\")).orElseThrow());\n+\n+        assertEquals(OptionName.of(\"foo\"), spec.name());\n+\n+        assertEquals(\"123\", spec.converter().orElseThrow().convert(spec.name(), StringToken.of(\"str\")).orElseThrow());\n+    }\n+\n+    @Test\n+    public void test_mapOptionSpec_array() {\n+\n+        var theSpecBuilder = OptionSpecBuilder.<String>create(String.class).converter(str -> {\n+            return \"123\";\n+        }).name(\"foo\");\n+\n+        DummyContext.<String>createOptionSpecBuilderMutator((specBuilder, context) -> {\n+            specBuilder.converter(str -> {\n+                return Integer.toString(context.value());\n+            });\n+        }).accept(theSpecBuilder);\n+\n+        var spec = theSpecBuilder.createArrayOptionSpec();\n+\n+        var mappedSpec = new DummyContext(731).mapOptionSpec(spec);\n+\n+        assertArrayEquals(new String[] {\"731\"}, mappedSpec.converter().orElseThrow().convert(spec.name(), StringToken.of(\"str\")).orElseThrow());\n+\n+        assertEquals(OptionName.of(\"foo\"), spec.name());\n+\n+        assertArrayEquals(new String[] {\"123\"}, spec.converter().orElseThrow().convert(spec.name(), StringToken.of(\"str\")).orElseThrow());\n+\n+    }\n+\n+    @Test\n+    public void test_createOptionSpecBuilderMutator_multiple() {\n+\n+        var theSpecBuilder = OptionSpecBuilder.<Integer>create(Integer.class).converter(Integer::parseInt);\n+\n+        DummyContext.<Integer>createOptionSpecBuilderMutator((specBuilder, context) -> {\n+            specBuilder.description(\"Foo\");\n+        }).accept(theSpecBuilder);\n+\n+        DummyContext.<Integer>createOptionSpecBuilderMutator((specBuilder, context) -> {\n+            specBuilder.name(\"animal\");\n+        }).accept(theSpecBuilder);\n+\n+        DummyContext.<Integer>createOptionSpecBuilderMutator((specBuilder, context) -> {\n+            specBuilder.addAliases(\"fox\");\n+        }).accept(theSpecBuilder);\n+\n+        DummyContext.<Integer>createOptionSpecBuilderMutator((specBuilder, context) -> {\n+            specBuilder.addAliases(\"dog\");\n+        }).accept(theSpecBuilder);\n+\n+        var spec = theSpecBuilder.name(\"cat\").createArrayOptionSpec();\n+\n+        var mappedSpec = new DummyContext(0).mapOptionSpec(spec);\n+\n+        assertEquals(Stream.of(\"cat\").map(OptionName::of).toList(), spec.names());\n+        assertEquals(\"\", spec.description());\n+\n+        assertEquals(Stream.of(\"animal\", \"fox\", \"dog\").map(OptionName::of).toList(), mappedSpec.names());\n+        assertEquals(\"Foo\", mappedSpec.description());\n+\n+        assertEquals(spec.converter(), mappedSpec.converter());\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/OptionSpecMutatorOptionScopeTest.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,365 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static jdk.jpackage.internal.cli.StandardValueConverter.identityConv;\n+import static jdk.jpackage.internal.cli.StandardValueConverter.pathConv;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.IntStream;\n+import jdk.jpackage.internal.cli.OptionSpec.MergePolicy;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+public class OptionSpecTest {\n+\n+    @Test\n+    public void test_otherNames() {\n+        assertEquals(toOptionNames(\"b\", \"foo\"), buildSpec().names(\"a\", \"b\", \"foo\").create().otherNames());\n+        assertEquals(toOptionNames(), buildSpec().names(\"a\").create().otherNames());\n+        assertEquals(toOptionNames(\"b\", \"a\"), buildSpec().names(\"a\", \"b\", \"a\").create().otherNames());\n+    }\n+\n+    @Test\n+    public void test_names() {\n+        assertEquals(toOptionNames(\"a\", \"b\", \"foo\"), buildSpec().names(\"a\", \"b\", \"foo\").create().names());\n+        assertEquals(toOptionNames(\"a\"), buildSpec().names(\"a\").create().names());\n+        assertEquals(toOptionNames(\"a\", \"b\", \"a\"), buildSpec().names(\"a\", \"b\", \"a\").create().names());\n+    }\n+\n+    @Test\n+    public void test_name() {\n+        assertEquals(OptionName.of(\"a\"), buildSpec().names(\"a\", \"b\", \"foo\").create().name());\n+        assertEquals(OptionName.of(\"a\"), buildSpec().names(\"a\").create().name());\n+    }\n+\n+    @Test\n+    public void test_valueType() {\n+        assertThrows(RuntimeException.class, buildSpec().names(\"foo\").create()::valueType);\n+        assertEquals(String.class, OptionSpecTest.<String>buildSpec().names(\"foo\").converter(converter(identityConv())).create().valueType());\n+        assertEquals(Path.class, OptionSpecTest.<Path>buildSpec().names(\"foo\").converter(converter(pathConv())).create().valueType());\n+    }\n+\n+    @Test\n+    public void test_hasValue() {\n+        assertFalse(buildSpec().names(\"foo\").create().hasValue());\n+        assertTrue(OptionSpecTest.<String>buildSpec().names(\"foo\").converter(converter(identityConv())).create().hasValue());\n+        assertTrue(OptionSpecTest.<Path>buildSpec().names(\"foo\").converter(converter(pathConv())).create().hasValue());\n+    }\n+\n+    @Test\n+    public void test_isValueOptional() {\n+        assertFalse(buildSpec().names(\"foo\").create().isValueOptional());\n+        assertFalse(OptionSpecTest.<String>buildSpec().names(\"foo\").converter(converter(identityConv())).create().isValueOptional());\n+        assertTrue(OptionSpecTest.<String>buildSpec().names(\"foo\").converter(converter(identityConv())).defaultOptionalValue(\"str\").create().isValueOptional());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_copyWithConverter(boolean hasInitialConverter) {\n+\n+        final var scope = Set.of((OptionScope)new OptionScope() {});\n+\n+        final OptionSpecBuilder<?> builder;\n+        if (hasInitialConverter) {\n+            builder = OptionSpecTest.<String>buildSpec().converter(converter(identityConv()));\n+        } else {\n+            builder = buildSpec();\n+        }\n+\n+        UnaryOperator<OptionSpecBuilder<?>> builderMutator = v -> {\n+            v.names(\"foo\", \"bar\").description(\"description\").scope(scope);\n+            if (hasInitialConverter) {\n+                v.valuePattern(\"<value>\");\n+            }\n+            return v;\n+        };\n+\n+        final var converter = converter(pathConv());\n+\n+        final var spec = builderMutator.apply(builder).create();\n+\n+        assertThrowsExactly(NullPointerException.class, () -> spec.copyWithConverter(null));\n+\n+        final var actualConvSpec = spec.copyWithConverter(converter);\n+\n+        final var expectedConvSpec = builderMutator.apply(OptionSpecTest.<Path>buildSpec().converter(converter)).create();\n+\n+        assertEquals(expectedConvSpec, actualConvSpec);\n+    }\n+\n+    @Test\n+    public void test_copyWithConverter_fail() {\n+        var spec = OptionSpecTest.<String>buildSpec()\n+                .names(\"foo\")\n+                .valuePattern(\"<value>\")\n+                .defaultOptionalValue(\"str\")\n+                .converter(converter(identityConv()))\n+                .description(\"Hello!\").create();\n+\n+        final var pathConverter = converter(pathConv());\n+\n+        assertThrowsExactly(UnsupportedOperationException.class, () -> spec.copyWithConverter(pathConverter));\n+    }\n+\n+    @Test\n+    public void test_copyWithDescription() {\n+\n+        final var builder = OptionSpecTest.<String>buildSpec()\n+                .names(\"foo\", \"bar\")\n+                .valuePattern(\"<value>\")\n+                .converter(converter(identityConv()))\n+                .description(\"Hello!\");\n+\n+        final var spec = builder.create();\n+\n+        assertThrowsExactly(NullPointerException.class, () -> spec.copyWithDescription(null));\n+\n+        final var actualConvSpec = spec.copyWithDescription(\"Bye!\");\n+\n+        final var expectedConvSpec = builder.description(\"Bye!\").create();\n+\n+        assertEquals(expectedConvSpec, actualConvSpec);\n+    }\n+\n+    @Test\n+    public void test_copyWithName() {\n+\n+        final var builder = OptionSpecTest.<String>buildSpec()\n+                .names(\"foo\", \"bar\")\n+                .valuePattern(\"<value>\")\n+                .converter(converter(identityConv()))\n+                .description(\"Hello!\");\n+\n+        final var spec = builder.create();\n+\n+        assertThrowsExactly(NullPointerException.class, () -> spec.copyWithName(null));\n+\n+        final var actualConvSpec = spec.copyWithName(OptionName.of(\"buz\"));\n+\n+        final var expectedConvSpec = builder.names(\"buz\").create();\n+\n+        assertEquals(expectedConvSpec, actualConvSpec);\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_findNamesIn_and_getFirstNameIn(boolean found) {\n+\n+        var spec = OptionSpecTest.<String>buildSpec().names(\"z\", \"a\", \"b\").converter(converter(identityConv())).create();\n+\n+        final Options options;\n+        if (found) {\n+            options = Options.of(Map.of(OptionValue.<String>build().spec(spec).create(), 100));\n+        } else {\n+            options = Options.of(Map.of());\n+        }\n+\n+        final List<OptionName> expectedNames;\n+        if (found) {\n+            expectedNames = toOptionNames(\"z\", \"a\", \"b\");\n+        } else {\n+            expectedNames = List.of();\n+        }\n+\n+        assertEquals(expectedNames, spec.findNamesIn(options));\n+\n+        if (found) {\n+            assertEquals(expectedNames.getFirst(), spec.getFirstNameIn(options));\n+        } else {\n+            assertThrowsExactly(NoSuchElementException.class, () -> spec.getFirstNameIn(options));\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_arrayValueConverter(boolean empty) {\n+\n+        final Optional<OptionArrayValueConverter<String>> arrayConverter;\n+        final OptionSpec<?> spec;\n+        if (empty) {\n+            arrayConverter = Optional.empty();\n+            spec = OptionSpecTest.<String>buildSpec().names(\"foo\").converter(converter(identityConv())).create();\n+        } else {\n+            arrayConverter = Optional.of(buildConverter(identityConv()).tokenizer(str -> new String[] {str}).createArray());\n+            spec = OptionSpecTest.<String[]>buildSpec().names(\"foo\").converter(arrayConverter.get()).create();\n+        }\n+\n+        assertEquals(arrayConverter, spec.arrayValueConverter());\n+    }\n+\n+    @Test\n+    public void testInvalid() {\n+        IllegalArgumentException ex;\n+\n+        ex = assertThrowsExactly(IllegalArgumentException.class, () -> {\n+            buildSpec().names().create();\n+        });\n+        assertEquals(\"Empty name list\", ex.getMessage());\n+\n+        ex = assertThrowsExactly(IllegalArgumentException.class, () -> {\n+            buildSpec().names(\"foo\").scope(Set.of()).create();\n+        });\n+        assertEquals(\"Empty scope\", ex.getMessage());\n+\n+        ex = assertThrowsExactly(IllegalArgumentException.class, () -> {\n+            buildSpec().names(\"foo\").mergePolicy(MergePolicy.CONCATENATE).create();\n+        });\n+        assertEquals(\"Invalid merge policy [\" + MergePolicy.CONCATENATE + \"] for type []\", ex.getMessage());\n+\n+        ex = assertThrowsExactly(IllegalArgumentException.class, () -> {\n+            OptionSpecTest.<String>buildSpec().names(\"foo\")\n+                    .converter(converter(identityConv()))\n+                    .mergePolicy(MergePolicy.CONCATENATE)\n+                    .create();\n+        });\n+        assertEquals(\"Invalid merge policy [\" + MergePolicy.CONCATENATE + \"] for type [\" + String.class.getName() + \"]\", ex.getMessage());\n+\n+        ex = assertThrowsExactly(IllegalArgumentException.class, () -> {\n+            buildSpec().names(\"foo\").valuePattern(\"<int>\").create();\n+        });\n+        assertEquals(\"Option without a value can not have a value pattern\", ex.getMessage());\n+\n+        ex = assertThrowsExactly(IllegalArgumentException.class, () -> {\n+            buildSpec().names(\"foo\").defaultOptionalValue(new Object()).create();\n+        });\n+        assertEquals(\"Option with optional value should have a converter\", ex.getMessage());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_generateForEveryName(boolean hasValue) {\n+\n+        final var names = List.of(\"a\", \"b\", \"foo\");\n+\n+        final OptionSpecBuilder<?> builder;\n+        if (hasValue) {\n+            builder = OptionSpecTest.<String>buildSpec().names(names).converter(converter(identityConv()));\n+        } else {\n+            builder = buildSpec().names(names);\n+        }\n+\n+        final var optionSpecs = builder.create().copyForEveryName().toList();\n+\n+        assertEquals(names.size(), optionSpecs.size());\n+\n+        IntStream.range(0, names.size()).forEach(i -> {\n+            assertEquals(builder.names(names.get(i)).create(), optionSpecs.get(i));\n+        });\n+    }\n+\n+    private static <T> OptionSpecBuilder<T> buildSpec() {\n+        return new OptionSpecBuilder<>();\n+    }\n+\n+    private static List<OptionName> toOptionNames(Collection<String> names) {\n+        return names.stream().map(OptionName::of).toList();\n+    }\n+\n+    private static List<OptionName> toOptionNames(String... names) {\n+        return toOptionNames(List.of(names));\n+    }\n+\n+    private static <T> OptionValueConverter<T> converter(ValueConverter<T> conv) {\n+        return buildConverter(conv).create();\n+    }\n+\n+    private static <T> OptionValueConverter.Builder<T> buildConverter(ValueConverter<T> conv) {\n+        return OptionValueConverter.<T>build().converter(conv);\n+    }\n+\n+\n+    private static final class OptionSpecBuilder<T> {\n+\n+        OptionSpec<T> create() {\n+            return new OptionSpec<>(\n+                    Optional.ofNullable(names).orElseGet(List::of),\n+                    Optional.ofNullable(converter),\n+                    Optional.ofNullable(scope).orElseGet(Set::of),\n+                    mergePolicy,\n+                    Optional.ofNullable(defaultOptionalValue),\n+                    Optional.ofNullable(valuePattern),\n+                    description);\n+        }\n+\n+        OptionSpecBuilder<T> names(String... v) {\n+            return names(List.of(v));\n+        }\n+\n+        OptionSpecBuilder<T> description(String v) {\n+            description = v;\n+            return this;\n+        }\n+\n+        OptionSpecBuilder<T> names(List<String> v) {\n+            names = Optional.ofNullable(v).map(OptionSpecTest::toOptionNames).orElse(null);\n+            return this;\n+        }\n+\n+        OptionSpecBuilder<T> converter(OptionValueConverter<T> v) {\n+            converter = v;\n+            return this;\n+        }\n+\n+        OptionSpecBuilder<T> defaultOptionalValue(T v) {\n+            defaultOptionalValue = v;\n+            return this;\n+        }\n+\n+        OptionSpecBuilder<T> scope(Set<OptionScope> v) {\n+            scope = v;\n+            return this;\n+        }\n+\n+        OptionSpecBuilder<T> mergePolicy(MergePolicy v) {\n+            mergePolicy = v;\n+            return this;\n+        }\n+\n+        OptionSpecBuilder<T> valuePattern(String v) {\n+            valuePattern = v;\n+            return this;\n+        }\n+\n+        private List<OptionName> names;\n+        private OptionValueConverter<T> converter;\n+        private T defaultOptionalValue;\n+        private Set<OptionScope> scope = Set.of(new OptionScope() {});\n+        private MergePolicy mergePolicy = MergePolicy.USE_LAST;\n+        private String valuePattern;\n+        private String description = \"\";\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/OptionSpecTest.java","additions":365,"deletions":0,"binary":false,"changes":365,"status":"added"},{"patch":"@@ -0,0 +1,216 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static jdk.jpackage.internal.cli.TestUtils.assertExceptionListEquals;\n+import static jdk.jpackage.internal.cli.TestUtils.configureConverter;\n+import static jdk.jpackage.internal.cli.TestUtils.configureValidator;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNotSame;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.cli.OptionValueConverter.ConverterException;\n+import jdk.jpackage.internal.cli.TestUtils.TestException;\n+import jdk.jpackage.internal.util.Result;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+public class OptionValueConverterTest {\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test(boolean positive) {\n+\n+        final var converter = OptionValueConverter.build().converter(ValueConverter.create(str -> {\n+            return Integer.valueOf(str);\n+        }, Integer.class)).mutate(configureConverter()).create();\n+\n+        if (positive) {\n+            final var token = StringToken.of(\"758\");\n+            assertEquals(758, converter.convert(OptionName.of(\"number\"), token).orElseThrow());\n+        } else {\n+            final var token = StringToken.of(\"foo\");\n+            final var result = converter.convert(OptionName.of(\"number\"), token);\n+\n+            assertEquals(1, result.errors().size());\n+\n+            final var ex = result.firstError().orElseThrow();\n+\n+            assertNotNull(ex.getCause());\n+            assertTrue(ex.getCause() instanceof NumberFormatException);\n+            assertEquals(\"Option --number: bad substring [foo] in string [foo]\", ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void test_Builder_defaults() {\n+\n+        var converter = OptionValueConverter.<Integer>build()\n+                .converter(ValueConverter.create(Integer::valueOf, Integer.class)).create();\n+\n+        Function<String, Result<Integer>> convertString = (v) -> {\n+            return converter.convert(OptionName.of(\"foo\"), StringToken.of(v));\n+        };\n+\n+        assertEquals(10, convertString.apply(\"10\").orElseThrow());\n+\n+        assertThrowsExactly(UnsupportedOperationException.class, () -> convertString.apply(\"\"));\n+    }\n+\n+    @Test\n+    public void test_Builder_invalid() {\n+\n+        assertThrowsExactly(NullPointerException.class, OptionValueConverter.build()\n+                .converter(ValueConverter.create(Integer::valueOf, Integer.class))\n+                .mutate(configureConverter())\n+                .formatString(null)::create);\n+\n+        assertThrowsExactly(NullPointerException.class, OptionValueConverter.build()\n+                .converter(ValueConverter.create(Integer::valueOf, Integer.class))\n+                .mutate(configureConverter())\n+                .exceptionFactory(null)::create);\n+    }\n+\n+    @Test\n+    public void test_Builder_copy() {\n+\n+        Function<String, String[]> tokenizer = _ -> { throw new UnsupportedOperationException(); };\n+\n+        var builder = OptionValueConverter.<Integer>build()\n+                .converter(ValueConverter.create(Integer::valueOf, Integer.class))\n+                .validator(Validator.<Integer, RuntimeException>build().predicate(_ -> true).create())\n+                .mutate(configureConverter())\n+                .tokenizer(tokenizer);\n+\n+        var copy = builder.copy();\n+\n+        assertNotSame(copy,  builder);\n+\n+        assertSame(builder.converter().orElse(null), copy.converter().orElse(null));\n+        assertSame(builder.formatString().orElse(null), copy.formatString().orElse(null));\n+        assertSame(builder.exceptionFactory().orElse(null), copy.exceptionFactory().orElse(null));\n+        assertSame(builder.tokenizer().orElse(null), copy.tokenizer().orElse(null));\n+        assertSame(builder.validator().orElse(null), copy.validator().orElse(null));\n+\n+        copy.formatString(\"foo\");\n+\n+        assertNotEquals(builder.formatString().orElse(null), copy.formatString().orElse(null));\n+    }\n+\n+    @Test\n+    public void test_Builder_createArray() {\n+\n+        var converter = OptionValueConverter.<Integer>build()\n+                .converter(ValueConverter.create(Integer::valueOf, Integer.class))\n+                .mutate(configureConverter())\n+                .tokenizer(str -> str.split(\":\"))\n+                .createArray();\n+\n+        assertNotEquals(List.of(100, 67, 145), List.of(converter.convert(OptionName.of(\"foo\"), StringToken.of(\"110:67:145\")).orElseThrow()));\n+\n+        assertEquals(Integer[].class, converter.valueType());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_Builder_createArray_exceptions(boolean validateInConveter) {\n+\n+        var numberFormatException = assertThrowsExactly(NumberFormatException.class, () -> Integer.valueOf(\"str\"));\n+\n+        var builder = OptionValueConverter.<Integer>build()\n+                .mutate(configureConverter())\n+                .formatString(\"Ops\")\n+                .tokenizer(str -> str.split(\":\"));\n+\n+        if (validateInConveter) {\n+            builder.converter(ValueConverter.create(str -> {\n+                var i = Integer.valueOf(str);\n+                if (i < 0) {\n+                    throw new IllegalArgumentException(str);\n+                } else {\n+                    return i;\n+                }\n+            }, Integer.class));\n+        } else {\n+            builder.converter(ValueConverter.create(Integer::valueOf, Integer.class));\n+            builder.validator(Validator.<Integer, RuntimeException>build().consumer(i -> {\n+                if (i < 0) {\n+                    throw new IllegalArgumentException(i.toString());\n+                }\n+            }).mutate(configureValidator()).formatString(\"Ops\").create());\n+        }\n+\n+        var converter = builder.createArray();\n+\n+        var result = converter.convert(OptionName.of(\"foo\"), StringToken.of(\"100:-10:-10:67:str:145:-7\"));\n+\n+        assertExceptionListEquals(Stream.of(\n+                new IllegalArgumentException(\"-10\"),\n+                new IllegalArgumentException(\"-10\"),\n+                numberFormatException,\n+                new IllegalArgumentException(\"-7\")\n+        ).map(ex -> {\n+            return new TestException(\"Ops\", ex);\n+        }).toList(), result.errors());\n+    }\n+\n+    @Test\n+    public void testConverterException() {\n+\n+        final var exception = new RuntimeException(\"Always fail\");\n+\n+        final var converter = OptionValueConverter.build().converter(ValueConverter.create(str -> {\n+            throw exception;\n+        }, Integer.class)).mutate(configureConverter()).create();\n+\n+        final var token = StringToken.of(\"foo\");\n+        final var ex = assertThrowsExactly(ConverterException.class, () -> converter.convert(OptionName.of(\"number\"), token));\n+\n+        assertSame(exception, ex.getCause());\n+    }\n+\n+    @Test\n+    public void testValidatorExceptionTunneling() {\n+\n+        final var exception = new RuntimeException(\"Always fail\");\n+\n+        final var converter = OptionValueConverter.build().converter(ValueConverter.create(str -> {\n+            return Integer.valueOf(str);\n+        }, Object.class)).mutate(configureConverter()).validator(Validator.<Object, RuntimeException>build().predicate(_ -> {\n+            throw exception;\n+        }).mutate(configureValidator()).create()).create();\n+\n+        final var token = StringToken.of(\"100\");\n+        final var ex = assertThrowsExactly(ConverterException.class, () -> converter.convert(OptionName.of(\"number\"), token));\n+\n+        assertSame(exception, ex.getCause());\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/OptionValueConverterTest.java","additions":216,"deletions":0,"binary":false,"changes":216,"status":"added"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static jdk.jpackage.internal.cli.TestUtils.assertExceptionEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+import jdk.jpackage.internal.cli.OptionValueExceptionFactory.StandardArgumentsMapper;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+public class OptionValueExceptionFactoryTest {\n+\n+    @Test\n+    public void test_unreachable() {\n+\n+        var factory = OptionValueExceptionFactory.unreachable();\n+\n+        assertThrowsExactly(UnsupportedOperationException.class, () -> {\n+            factory.create(OptionName.of(\"foo\"), StringToken.of(\"str\"), \"\", Optional.empty());\n+        });\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(StandardArgumentsMapper.class)\n+    public void testStandardArgumentsMapper(StandardArgumentsMapper mapper) {\n+\n+        final Supplier<List<String>> arguments = () -> {\n+            return List.of(mapper.apply(TEST_OPTION_NAME.name(), TEST_OPTION_VALUE));\n+        };\n+\n+        switch (mapper) {\n+            case NAME_AND_VALUE -> {\n+                assertEquals(List.of(\"foo\", \"str\"), arguments.get());\n+            }\n+            case VALUE_AND_NAME -> {\n+                assertEquals(List.of(\"str\", \"foo\"), arguments.get());\n+            }\n+            case NONE -> {\n+                assertEquals(List.of(), arguments.get());\n+            }\n+            case VALUE -> {\n+                assertEquals(List.of(\"str\"), arguments.get());\n+            }\n+            default -> {\n+                throw new AssertionError();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void test_Builder_defaults() {\n+\n+        var factory = buildTestFactory().create();\n+\n+        var ex = factory.create(TEST_OPTION_NAME, TEST_OPTION_VALUE, \"error.paramater-not-file\", Optional.empty());\n+\n+        assertExceptionEquals(new Exception(I18N.format(\"error.paramater-not-file\", \"--foo\", \"str\")), ex);\n+    }\n+\n+    @Test\n+    public void test_Builder_formatArgumentsTransformer() {\n+\n+        var factory = buildTestFactory().formatArgumentsTransformer(StandardArgumentsMapper.VALUE_AND_NAME).create();\n+\n+        var ex = factory.create(TEST_OPTION_NAME, TEST_OPTION_VALUE, \"error.paramater-not-file\", Optional.empty());\n+\n+        assertExceptionEquals(new Exception(I18N.format(\"error.paramater-not-file\", \"str\", \"--foo\")), ex);\n+    }\n+\n+    @Test\n+    public void test_Builder_messageFormatter() {\n+\n+        var factory = buildTestFactory().messageFormatter(String::format).create();\n+\n+        var ex = factory.create(TEST_OPTION_NAME, TEST_OPTION_VALUE, \"The value of option %s is [%s]\", Optional.empty());\n+\n+        assertExceptionEquals(new Exception(\"The value of option --foo is [str]\"), ex);\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_Builder_printOptionPrefix(boolean printOptionPrefix) {\n+\n+        var factory = buildTestFactory().printOptionPrefix(printOptionPrefix).create();\n+\n+        var ex = factory.create(TEST_OPTION_NAME, TEST_OPTION_VALUE, \"error.paramater-not-file\", Optional.empty());\n+\n+        String formattedOptionName;\n+        if (printOptionPrefix) {\n+            formattedOptionName = \"--foo\";\n+        } else {\n+            formattedOptionName = \"foo\";\n+        }\n+        assertExceptionEquals(new Exception(I18N.format(\"error.paramater-not-file\", formattedOptionName, \"str\")), ex);\n+    }\n+\n+    @Test\n+    public void testWithCause() {\n+\n+        var factory = buildTestFactory().messageFormatter(String::format).create();\n+\n+        var ex = factory.create(TEST_OPTION_NAME, TEST_OPTION_VALUE, \"The value of option %s is [%s]\", Optional.of(new IllegalArgumentException(\"Ops\")));\n+\n+        assertExceptionEquals(new Exception(\"The value of option --foo is [str]\", new IllegalArgumentException(\"Ops\")), ex);\n+    }\n+\n+    @Test\n+    public void test_ArgumentsMapper_appendArguments() {\n+\n+        var maper = OptionValueExceptionFactory.ArgumentsMapper.appendArguments((formattedOptionName, optionValue) -> {\n+            return new String[] { optionValue.value(), formattedOptionName, optionValue.tokenizedString() };\n+        }, 100, \"foo\");\n+\n+        List<String> args = List.of(maper.apply(\"--bar\", StringToken.of(\"strrr\", \"tr\")));\n+\n+        assertEquals(List.of(\"tr\", \"--bar\", \"strrr\", \"100\", \"foo\"), args);\n+    }\n+\n+    private static OptionValueExceptionFactory.Builder<Exception> buildTestFactory() {\n+        return OptionValueExceptionFactory.build(Exception::new);\n+    }\n+\n+    private static final OptionName TEST_OPTION_NAME = OptionName.of(\"foo\");\n+    private static final StringToken TEST_OPTION_VALUE = StringToken.of(\"str\", \"s\");\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/OptionValueExceptionFactoryTest.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -0,0 +1,212 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import org.junit.jupiter.api.Test;\n+\n+public class OptionValueTest {\n+\n+    @Test\n+    public void test_asOption() {\n+\n+        assertFalse(OptionValue.create().asOption().isPresent());\n+\n+        assertTrue(build(String.class, \"foo\").create().asOption().isPresent());\n+    }\n+\n+    @Test\n+    public void test_getOption() {\n+\n+        assertThrowsExactly(NoSuchElementException.class, OptionValue.create()::getOption);\n+\n+        assertNotNull(build(String.class, \"foo\").create().getOption());\n+    }\n+\n+    @Test\n+    public void test_getSpec() {\n+\n+        assertThrowsExactly(NoSuchElementException.class, OptionValue.create()::getSpec);\n+\n+        assertNotNull(build(String.class, \"foo\").create().getSpec());\n+    }\n+\n+    @Test\n+    public void test_getName() {\n+\n+        assertThrowsExactly(NoSuchElementException.class, OptionValue.create()::getName);\n+\n+        assertEquals(\"foo\", build(String.class, \"foo\").create().getName());\n+    }\n+\n+    @Test\n+    public void test_ifPresentIn() {\n+\n+        var option = build(String.class, \"foo\").create();\n+\n+        String value[] = new String[1];\n+\n+        option.ifPresentIn(EMPTY_OPTIONS, _ -> {\n+            throw new AssertionError();\n+        });\n+\n+        assertNull(value[0]);\n+\n+        option.ifPresentIn(Options.of(Map.of(option, \"bar\")), v -> {\n+            value[0] = v;\n+        });\n+\n+        assertEquals(\"bar\", value[0]);\n+    }\n+\n+    @Test\n+    public void test_containsIn() {\n+        test_containsIn(OptionValue.create());\n+        test_containsIn(OptionValue.<Integer>build().defaultValue(45).create());\n+        test_containsIn(build(Path[].class, \"foo\").create());\n+    }\n+\n+    @Test\n+    public void test_Builder_build() {\n+\n+        var builder = OptionValue.<Integer>build();\n+\n+        var a = builder.create();\n+        var b = builder.create();\n+\n+        assertNotNull(a.id());\n+        assertTrue(a.asOption().isEmpty());\n+\n+        assertNotNull(b.id());\n+        assertTrue(b.asOption().isEmpty());\n+\n+        assertNotEquals(a.id(), b.id());\n+        assertEquals(a.id().getClass(), b.id().getClass());\n+    }\n+\n+    @Test\n+    public void test_Builder_defaultValue() {\n+\n+        var option = OptionValue.<Integer>build().defaultValue(100).create();\n+\n+        assertEquals(100, option.getFrom(EMPTY_OPTIONS));\n+\n+        assertEquals(300, option.getFrom(Options.of(Map.of(option, 300))));\n+    }\n+\n+    @Test\n+    public void test_Builder_defaultValue_withSpec() {\n+\n+        var option = OptionValue.<Integer>build().defaultValue(100)\n+                .spec(build(Integer.class, \"foo\").createOptionSpec())\n+                .create();\n+\n+        assertEquals(100, option.getFrom(EMPTY_OPTIONS));\n+\n+        assertEquals(300, option.getFrom(Options.of(Map.of(option, 300))));\n+    }\n+\n+    @Test\n+    public void test_Builder_from() {\n+\n+        var option = OptionValue.<Integer>build().from(OptionValue.<String>create(), Integer::valueOf).create();\n+\n+        assertFalse(option.containsIn(EMPTY_OPTIONS));\n+\n+        assertEquals(300, option.getFrom(Options.of(Map.of(option, \"300\"))));\n+    }\n+\n+    @Test\n+    public void test_Builder_to() {\n+\n+        var listOption = OptionValue.build().to(List::of).create();\n+\n+        assertFalse(listOption.containsIn(EMPTY_OPTIONS));\n+\n+        assertEquals(List.of(300), listOption.getFrom(Options.of(Map.of(listOption, 300))));\n+    }\n+\n+    @Test\n+    public void test_Builder_to_fromAnotherOption() {\n+\n+        var option = OptionValue.<String>build().from(OptionValue.<String>create(), x -> x).defaultValue(\"abc\").create();\n+\n+        OptionValue<List<String>> listOption = OptionValue.<String>build().from(option, x -> x).to(List::of).create();\n+\n+        assertSame(option.id(), listOption.id());\n+        assertFalse(listOption.containsIn(EMPTY_OPTIONS));\n+\n+        assertEquals(List.of(\"abc\"), listOption.getFrom(EMPTY_OPTIONS));\n+        assertEquals(\"abc\", option.getFrom(EMPTY_OPTIONS));\n+\n+        var options = Options.of(Map.of(option, \"Hello\"));\n+\n+        assertEquals(List.of(\"Hello\"), listOption.getFrom(options));\n+        assertEquals(\"Hello\", option.getFrom(options));\n+    }\n+\n+    @Test\n+    public void testContainsPathArray() {\n+\n+        OptionValue<String> option = build(String.class, \"foo\").create();\n+\n+        var options = Options.of(Map.of(option, new Object()));\n+\n+        \/\/ OptionValue.contains() should work regardless the type of its value stored in Options object.\n+        assertTrue(option.containsIn(options));\n+\n+        \/\/ Attempt to find a value will fail if the value is of incompatible type.\n+        assertThrowsExactly(ClassCastException.class, () -> option.getFrom(options).length());\n+    }\n+\n+    private static void test_containsIn(OptionValue<?> option) {\n+        Objects.requireNonNull(option);\n+\n+        var anotherOption = OptionValue.create();\n+\n+        assertFalse(option.containsIn(EMPTY_OPTIONS));\n+        assertFalse(option.containsIn(Options.of(Map.of(anotherOption, \"\"))));\n+\n+        assertTrue(option.containsIn(Options.of(Map.of(option, new int[10]))));\n+        assertTrue(option.containsIn(Options.of(Map.of(option, new Object()))));\n+    }\n+\n+    private static <T> OptionSpecBuilder<T> build(Class<? extends T> type, String name) {\n+        return OptionSpecBuilder.<T>create(type).name(Objects.requireNonNull(name)).scope(new OptionScope() {});\n+    }\n+\n+    private static final Options EMPTY_OPTIONS = Options.of(Map.of());\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/OptionValueTest.java","additions":212,"deletions":0,"binary":false,"changes":212,"status":"added"},{"patch":"@@ -0,0 +1,786 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static jdk.jpackage.internal.cli.TestUtils.assertExceptionListEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.cli.StandardOption.AddLauncherInvalidPropertyFileException;\n+import jdk.jpackage.internal.model.BundlingOperationDescriptor;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.JPackageException;\n+import jdk.jpackage.internal.model.StandardPackageType;\n+import jdk.jpackage.internal.util.Result;\n+import jdk.jpackage.test.JUnitUtils;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.condition.EnabledOnOs;\n+import org.junit.jupiter.api.condition.OS;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+public class OptionsProcessorTest {\n+\n+    @Test\n+    public void test_processPropertyFile(@TempDir Path workDir) throws IOException {\n+        final var propFile = workDir.resolve(\"launcher.properties\");\n+        Files.write(propFile, List.of(\"description=bar\", \"type=msi\"));\n+\n+        final var result = processPropertyFile(propFile,\n+                StandardOption.TYPE, StandardOption.DESCRIPTION);\n+\n+        assertTrue(result.hasValue());\n+\n+        assertEquals(StandardPackageType.WIN_MSI, StandardOption.TYPE.getFrom(result.orElseThrow()));\n+        assertEquals(\"bar\", StandardOption.DESCRIPTION.getFrom(result.orElseThrow()));\n+\n+        assertFalse(StandardOption.INPUT.containsIn(result.orElseThrow()));\n+\n+        assertEquals(propFile, StandardOption.SOURCE_PROPERY_FILE.getFrom(result.orElseThrow()));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(BooleanProperty.class)\n+    public void test_processPropertyFile_Boolean(BooleanProperty value, @TempDir Path workDir) throws IOException {\n+        final var propFile = workDir.resolve(\"launcher.properties\");\n+        Files.write(propFile, List.of(\"launcher-as-service=\" + value.propertyValue()));\n+\n+        final var props = processPropertyFile(propFile,\n+                StandardOption.LAUNCHER_AS_SERVICE).orElseThrow();\n+\n+        assertEquals(value.expectedValue(), StandardOption.LAUNCHER_AS_SERVICE.getFrom(props));\n+    }\n+\n+    @Test\n+    public void testMandatoryOptionsPresent(@TempDir Path workDir) {\n+        build().createAppImageByDefault().withMockupMainJar(workDir).createBundleCallback(cmdline -> {\n+            assertEquals(List.of(), StandardOption.ADDITIONAL_LAUNCHERS.getFrom(cmdline));\n+            assertEquals(List.of(), StandardOption.FILE_ASSOCIATIONS.getFrom(cmdline));\n+        }).create().execute();\n+    }\n+\n+    @Test\n+    public void testAdditionLauncher(@TempDir Path workDir) throws IOException {\n+\n+        final var propFile = workDir.resolve(\"launcher.properties\");\n+        Files.write(propFile, List.of(\"arguments=a b c\"));\n+\n+        build().createAppImageByDefault().withMockupMainJar(workDir).createBundleCallback(cmdline -> {\n+            assertFalse(StandardOption.ADD_LAUNCHER_INTERNAL.containsIn(cmdline));\n+\n+            var addLaunchers = StandardOption.ADDITIONAL_LAUNCHERS.getFrom(cmdline);\n+            assertEquals(1, addLaunchers.size());\n+\n+            var addLauncher = addLaunchers.getFirst();\n+\n+            assertEquals(\"foo\", StandardOption.NAME.getFrom(addLauncher));\n+            assertEquals(propFile, StandardOption.SOURCE_PROPERY_FILE.getFrom(addLauncher));\n+            assertEquals(List.of(\"a\", \"b\", \"c\"), StandardOption.ARGUMENTS.getFrom(addLauncher));\n+\n+        }).create(\"--add-launcher\", \"foo=\" + propFile).execute();\n+    }\n+\n+    @Test\n+    public void testFa(@TempDir Path workDir) throws IOException {\n+\n+        final var propFile = workDir.resolve(\"fa.properties\");\n+        Files.write(propFile, List.of(\"description=Hello\"));\n+\n+        build().createAppImageByDefault().withMockupMainJar(workDir).createBundleCallback(cmdline -> {\n+            assertFalse(StandardOption.FILE_ASSOCIATIONS_INTERNAL.containsIn(cmdline));\n+\n+            var fas = StandardOption.FILE_ASSOCIATIONS.getFrom(cmdline);\n+            assertEquals(1, fas.size());\n+\n+            var fa = fas.getFirst();\n+\n+            assertEquals(\"Hello\", StandardFaOption.DESCRIPTION.getFrom(fa));\n+            assertEquals(propFile, StandardOption.SOURCE_PROPERY_FILE.getFrom(fa));\n+\n+        }).create(\"--file-associations=\" + propFile).execute();\n+    }\n+\n+    \/**\n+     * Test that it fails if there are \"non-option\" arguments on the command line.\n+     *\/\n+    @Test\n+    public void testNonOptionArgumntsError(@TempDir Path workDir) {\n+\n+        build()\n+        .withDefaultBundlingOperation(true)\n+        .createAppImageBundlingOperation()\n+        .expectValidationErrors(\n+                new JPackageException(I18N.format(\"error.non-option-arguments\", 1)),\n+                new JPackageException(I18N.format(\"ERR_NoEntryPoint\"))\n+        ).create(\"foo\").validate();\n+\n+        build()\n+        .createAppImageBundlingOperation()\n+        .expectValidationErrors(\n+                new JPackageException(I18N.format(\"error.non-option-arguments\", 3)),\n+                new JPackageException(I18N.format(\"ERR_NoEntryPoint\"))\n+        ).create(\"some\", \"-t\", \"app-image\", \"foo\", \"bar\", \"--dest\", \"dir\").validate();\n+    }\n+\n+    \/**\n+     * Test that it fails as expected when `--type` option is missing and the\n+     * bundling environment doesn't have the default bundling operation.\n+     *\/\n+    @Test\n+    public void testNoDefaultBundlingOperation() {\n+        build().expectValidationErrors(\n+                new ConfigException(\n+                        I18N.format(\"error.undefined-default-bundling-operation\"),\n+                        I18N.format(\"error.undefined-default-bundling-operation.advice\", \"--type\")\n+                )\n+        ).create().validate();\n+    }\n+\n+    \/**\n+     * Test that it fails as expected when `--type` option is missing and the\n+     * default bundling operation of the bundling environment is unrecognizable.\n+     *\/\n+    @Test\n+    public void testUnknownDefaultBundlingOperation() {\n+        var descriptor = new BundlingOperationDescriptor(OperatingSystem.current(), \"foo\", \"create\");\n+\n+        var err = assertThrowsExactly(AssertionError.class, build().withDefaultBundlingOperation(true)\n+                .bundlingOperation(descriptor)\n+                .create()::validate);\n+\n+        assertEquals(String.format(\"None of the standard bundling operations match bundling operation descriptor [%s]\", descriptor), err.getMessage());\n+    }\n+\n+    \/**\n+     * Test that it fails as expected when the value of `--type` option is a valid\n+     * bundle type but unsupported by the bundling environment.\n+     *\/\n+    @Test\n+    public void testUnsupportedBundlingOperation() {\n+        var err = new JPackageException(I18N.format(\"ERR_InvalidInstallerType\", \"msi\"));\n+        build().createAppImageByDefault().expectBundlingEnvironmentConfigurationErrors(err)\n+                .expectValidationErrors(err)\n+                .create(\"-t\", \"msi\").validate();\n+    }\n+\n+    \/**\n+     * Test that it fails as expected when the value of `--type` option is unrecognizable.\n+     *\/\n+    @Test\n+    public void testUnknownBundlingOperation() {\n+        var err = new JPackageException(I18N.format(\"ERR_InvalidInstallerType\", \"foo\"), new IllegalArgumentException());\n+        build().createAppImageByDefault().expectBundlingEnvironmentConfigurationErrors(err)\n+                .expectValidationErrors(err)\n+                .create(\"-t\", \"foo\").validate();\n+    }\n+\n+    \/**\n+     * Test that the error occurred at the bundling phase is propagated as expected.\n+     *\/\n+    @Test\n+    public void testBundlingOperationError(@TempDir Path workDir) {\n+        var validator = build().createAppImageByDefault().createBundleCallback(_ -> {\n+            throw new RuntimeException(\"No bundling for you\");\n+        }).withMockupMainJar(workDir).create();\n+\n+        var validatedOptions = validator.validate().orElseThrow();\n+\n+        assertExceptionListEquals(List.of(new RuntimeException(\"No bundling for you\")), validator.runBundling(validatedOptions));\n+    }\n+\n+    \/**\n+     * Test that internal errors that occur when configuring bundlers in the\n+     * bundling environment are reported as expected.\n+     *\/\n+    @Test\n+    public void testBundlingOperationConfigurationErrors(@TempDir Path workDir) {\n+        build().createAppImageByDefault()\n+                .expectBundlingEnvironmentConfigurationErrors(\n+                        new UnsupportedOperationException(\"Ops\"),\n+                        new Exception(\"Yikes\"),\n+                        new NoSuchElementException(\"Goofy\")\n+                )\n+                .expectValidationErrors(\n+                        new UnsupportedOperationException(\"Ops\"),\n+                        new Exception(\"Yikes\"),\n+                        new NoSuchElementException(\"Goofy\")\n+                )\n+                .withMockupMainJar(workDir).create().validate();\n+    }\n+\n+    \/**\n+     * Test that the options analyzer can detect and report multiple errors in\n+     * untyped command line values.\n+     * <p>\n+     * Options analyzer examines command line options without accessing their values\n+     * as converters have not been run on them yet. At this phase the analyzer can\n+     * detect the type of a bundling operation, test if specific option is on the\n+     * command line or not and analyze if specific combinations of options are\n+     * valid.\n+     *\/\n+    @Test\n+    public void testMultipleCommandLineStructureAnalyzerErrors() {\n+        build().createAppImageByDefault().expectValidationErrors(\n+                new JPackageException(I18N.format(\"ERR_BothMainJarAndModule\")),\n+                new JPackageException(I18N.format(\"ERR_MissingArgument2\", \"--runtime-image\", \"--module-path\")),\n+                new JPackageException(I18N.format(\"error.no-input-parameter\"))\n+        ).validationErrorsOrdered(false).create(\"-m\", \"com.foo\", \"--main-jar\", \"main.jar\").validate();\n+    }\n+\n+    \/**\n+     * Test that options analyzer can detect and report multiple errors in typed\n+     * command line values.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void testTypedOptionValuesAnalyzerErrors(boolean expectError, @TempDir Path workDir) {\n+        var builder = build().platform(OperatingSystem.MACOS).withMockupMainJar(workDir).createAppImageByDefault();\n+\n+        if (expectError) {\n+            builder.expectValidationErrors(\n+                    new JPackageException(I18N.format(\"ERR_MissingJLinkOptMacAppStore\", \"--strip-native-commands\"))\n+            )\n+            .create(\"--mac-app-store\", \"--jlink-options=\").validate();\n+        } else {\n+            builder.create(\"--mac-app-store\", \"--jlink-options\", \"--strip-debug --strip-native-commands\").validate();\n+        }\n+    }\n+\n+    \/**\n+     * Test that multiple converter\/validator errors are in the same order as\n+     * erroneous options on the command line.\n+     *\/\n+    @Test\n+    public void testMultipleOptionValueConverterErrors(@TempDir Path workDir) {\n+        build().createAppImageByDefault().expectValidationErrors(\n+                \/\/ --i\n+                new JPackageException(I18N.format(\"error.paramater-not-directory\", workDir.resolve(\"non-existent\"), \"-i\")),\n+                \/\/ --name\n+                new JPackageException(I18N.format(\"ERR_InvalidAppName\", \"He\/llo\"))\n+        )\n+        .create(\"--main-jar=foo.jar\", \"-i\", workDir.resolve(\"non-existent\"), \"--name=He\/llo\").validate();\n+\n+        build().createAppImageByDefault().expectValidationErrors(\n+                \/\/ --name\n+                new JPackageException(I18N.format(\"ERR_InvalidAppName\", \"He\/llo\")),\n+                \/\/ --i\n+                new JPackageException(I18N.format(\"error.paramater-not-directory\", workDir.resolve(\"non-existent\"), \"-i\"))\n+        )\n+        .create(\"--main-jar=foo.jar\", \"--name=He\/llo\", \"-i\", workDir.resolve(\"non-existent\")).validate();\n+    }\n+\n+    @Test\n+    public void testMultipleErrors(@TempDir Path workDir) throws IOException {\n+\n+        final var invalidPropertyFile = workDir.resolve(\"invalid.properties\");\n+\n+        try (var writer = Files.newBufferedWriter(invalidPropertyFile)) {\n+            var props = new Properties();\n+            props.setProperty(\"icon\", workDir.toString());\n+            props.store(writer, null);\n+        }\n+\n+        build().createAppImageByDefault()\n+        .expectBundlingEnvironmentConfigurationErrors(\n+                new UnsupportedOperationException(\"Ops\"),\n+                new Exception(\"Yikes\"),\n+                new NoSuchElementException(\"Goofy\")\n+        )\n+        .expectValidationErrors(\n+                new UnsupportedOperationException(\"Ops\"),\n+                new Exception(\"Yikes\"),\n+                new NoSuchElementException(\"Goofy\"),\n+                new JPackageException(I18N.format(\"error.properties-paramater-not-file\", workDir, \"icon\", invalidPropertyFile)),\n+                new JPackageException(I18N.format(\"error.paramater-not-directory\", workDir.resolve(\"non-existent\"), \"-i\")),\n+                new JPackageException(I18N.format(\"error.launcher-duplicate-name\", \"a\"))\n+        )\n+        .withMockupMainJar(workDir).create(\"--add-launcher=a=\" + invalidPropertyFile, \"--name=a\", \"-i\", workDir.resolve(\"non-existent\")).validate();\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(ints = {0, 1})\n+    public void testMultipleErrors2(int testType, @TempDir Path workDir) throws IOException {\n+\n+        List<String> badOptions;\n+        switch (testType) {\n+            case 0 -> {\n+                badOptions = List.of(\"--linux-shortcut\", \"--win-console\");\n+            }\n+            case 1 -> {\n+                badOptions = List.of(\"--win-console\", \"--linux-shortcut\");\n+            }\n+            default -> {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        var builder = build().os(OperatingSystem.WINDOWS)\n+                .bundlingOperation(StandardBundlingOperation.CREATE_WIN_MSI.descriptor())\n+                .expectValidationErrors(new JPackageException(I18N.format(\"ERR_InvalidInstallerType\", \"dmg\")));\n+\n+        for (var badOption : badOptions) {\n+            builder.expectValidationErrors(new JPackageException(I18N.format(\"ERR_UnsupportedOption\", badOption)));\n+        }\n+\n+        List<Object> args = new ArrayList<>(List.of(\"-t\", \"dmg\", \"-i\", workDir.resolve(\"non-existent\")));\n+        args.addAll(badOptions);\n+        args.addAll(List.of(\"--mac-package-name\", \"foo\"));\n+        builder.create(args).validate();\n+    }\n+\n+    @Test\n+    public void testMultipleErrors3(@TempDir Path workDir) throws IOException {\n+\n+        build().os(OperatingSystem.WINDOWS)\n+                .bundlingOperation(StandardBundlingOperation.CREATE_WIN_MSI.descriptor())\n+                .withDefaultBundlingOperation(true)\n+                .expectValidationErrors(\n+                        new JPackageException(I18N.format(\"ERR_UnsupportedOption\", \"--linux-shortcut\")),\n+                        new JPackageException(I18N.format(\"ERR_UnsupportedOption\", \"--mac-package-name\")),\n+                        new JPackageException(I18N.format(\"ERR_UnsupportedOption\", \"--linux-menu-group\"))\n+                )\n+                .create(\"-i\", workDir.resolve(\"non-existent\"), \"--linux-shortcut\", \"--mac-package-name\", \"foo\", \"--linux-menu-group\", \"grp\").validate();\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(ints = {0, 1, 2})\n+    public void testMultipleErrors4(int testType, @TempDir Path workDir) throws IOException {\n+\n+        List<String> args;\n+        List<String> expectedErrors = null;\n+\n+        switch (testType) {\n+            case 0 -> {\n+                args = List.of(\"--linux-shortcut\", \"--mac-package-name\", \"foo\", \"-p\", \"m1\", \"--linux-menu-group\", \"grp\", \"-p\", \"m2\", \"--app-image\", \"foo\");\n+                expectedErrors = List.of(\n+                        I18N.format(\"ERR_UnsupportedOption\", \"--linux-shortcut\"),\n+                        I18N.format(\"ERR_UnsupportedOption\", \"--mac-package-name\"),\n+                        I18N.format(\"ERR_InvalidTypeOption\", \"-p\", \"msi\"),\n+                        I18N.format(\"ERR_UnsupportedOption\", \"--linux-menu-group\")\n+                );\n+            }\n+            case 1 -> {\n+                args = List.of(\"--linux-shortcut\", \"--mac-package-name\", \"foo\", \"--module-path\", \"m1\", \"--linux-menu-group\", \"grp\", \"-p\", \"m2\", \"--app-image\", \"foo\");\n+                expectedErrors = List.of(\n+                        I18N.format(\"ERR_UnsupportedOption\", \"--linux-shortcut\"),\n+                        I18N.format(\"ERR_UnsupportedOption\", \"--mac-package-name\"),\n+                        I18N.format(\"ERR_InvalidTypeOption\", \"--module-path\", \"msi\"),\n+                        I18N.format(\"ERR_UnsupportedOption\", \"--linux-menu-group\")\n+                );\n+            }\n+            case 2 -> {\n+                args = List.of(\"--linux-shortcut\", \"--mac-package-name\", \"foo\", \"-p\", \"m1\", \"--linux-menu-group\", \"grp\", \"--module-path\", \"m2\", \"--app-image\", \"foo\");\n+                expectedErrors = List.of(\n+                        I18N.format(\"ERR_UnsupportedOption\", \"--linux-shortcut\"),\n+                        I18N.format(\"ERR_UnsupportedOption\", \"--mac-package-name\"),\n+                        I18N.format(\"ERR_InvalidTypeOption\", \"--module-path\", \"msi\"),\n+                        I18N.format(\"ERR_UnsupportedOption\", \"--linux-menu-group\")\n+                );\n+            }\n+            default -> {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        build().os(OperatingSystem.WINDOWS)\n+                .withDefaultBundlingOperation(true)\n+                .bundlingOperation(StandardBundlingOperation.CREATE_WIN_MSI.descriptor())\n+                .expectValidationErrors(expectedErrors.stream().map(JPackageException::new).toList())\n+                .create(args.toArray()).validate();\n+    }\n+\n+\n+    \/**\n+     * Test that it will collect all errors when processing multiple property files\n+     * for additional launchers.\n+     *\/\n+    @Test\n+    @EnabledOnOs(value = OS.WINDOWS, disabledReason = \"Can reliably lock a file using FileLock to cuase an IOException on Windows only\")\n+    @SuppressWarnings(\"try\")\n+    public void testMultipleAddLauncherErrors(@TempDir Path workDir) throws IOException {\n+\n+        final var lockedPropertyFile = workDir.resolve(\"locked.properties\");\n+        Files.write(lockedPropertyFile, List.of(\"\"));\n+\n+        final var invalidPropertyFile = workDir.resolve(\"invalid.properties\");\n+        Files.write(invalidPropertyFile, List.of(\"icon=*.png\"));\n+\n+        final var nonExistentPropertyFile = workDir.resolve(\"non-existent.properties\");\n+\n+        try (var out = new FileOutputStream(lockedPropertyFile.toFile()); var lock = out.getChannel().lock()) {\n+\n+            final IOException lockedException = assertThrowsExactly(IOException.class, () -> {\n+                Files.readAllBytes(lockedPropertyFile);\n+            });\n+\n+            build().createAppImageByDefault().expectValidationErrors(\n+                    \/\/ --name=Hello*\n+                    new JPackageException(I18N.format(\"ERR_InvalidAppName\", \"Hello*\")),\n+\n+                    \/\/ --i \"non-existent\"\n+                    new JPackageException(I18N.format(\"error.paramater-not-directory\", workDir.resolve(\"non-existent\"), \"-i\")),\n+\n+                    \/\/ --main-jar=?.jar\n+                    new JPackageException(I18N.format(\"error.paramater-not-path\", \"?.jar\", \"--main-jar\"), new IllegalArgumentException()),\n+\n+                    \/\/ icon=*.png in \"invalid.properties\"\n+                    new JPackageException(I18N.format(\"error.properties-paramater-not-path\", \"*.png\", \"icon\", invalidPropertyFile), new IllegalArgumentException()),\n+\n+                    \/\/ \"locked.properties\"\n+                    lockedException,\n+\n+                    \/\/ \"non-existent.properties\"\n+                    new AddLauncherInvalidPropertyFileException(I18N.format(\"error.paramater-add-launcher-not-file\", nonExistentPropertyFile, \"b\")),\n+\n+                    new JPackageException(I18N.format(\"error.launcher-duplicate-name\", \"b\"))\n+            )\n+            .create(\"--name=Hello*\", \"-i\", workDir.resolve(\"non-existent\"), \"--main-jar=?.jar\",\n+                    \"--add-launcher\", \"a=\" + invalidPropertyFile,\n+                    \"--add-launcher\", \"b=\" + lockedPropertyFile,\n+                    \"--add-launcher\", \"b=\" + nonExistentPropertyFile).validate();\n+        }\n+    }\n+\n+    @Test\n+    public void testDuplicateAddLauncherErrors(@TempDir Path workDir) throws IOException {\n+\n+        final var propertyFile = workDir.resolve(\"foo.properties\");\n+        Files.write(propertyFile, List.of(\"\"));\n+\n+        build().createAppImageByDefault().withMockupMainJar(workDir).expectValidationErrors(\n+                new JPackageException(I18N.format(\"error.launcher-duplicate-name\", \"a\"))\n+        )\n+        .create(\"--name=a\", \"--add-launcher=a=\" + propertyFile).validate();\n+\n+        build().createAppImageByDefault().withMockupMainJar(workDir).expectValidationErrors(\n+                new JPackageException(I18N.format(\"error.launcher-duplicate-name\", \"a\"))\n+        )\n+        .create(\"--name=a\", \"--add-launcher=a=\" + propertyFile, \"--add-launcher=a=\" + propertyFile, \"--add-launcher=a=\" + propertyFile).validate();\n+\n+        build().createAppImageByDefault().withMockupMainJar(workDir).expectValidationErrors(\n+                new JPackageException(I18N.format(\"error.launcher-duplicate-name\", \"a\")),\n+                new JPackageException(I18N.format(\"error.launcher-duplicate-name\", \"b\"))\n+        )\n+        .create(\"-name=c\",\n+                \"--add-launcher=a=\" + propertyFile,\n+                \"--add-launcher=b=\" + propertyFile,\n+                \"--add-launcher=a=\" + propertyFile,\n+                \"--add-launcher=b=\" + propertyFile).validate();\n+\n+        build().createAppImageByDefault().withMockupMainJar(workDir).expectValidationErrors(\n+                new JPackageException(I18N.format(\"error.launcher-duplicate-name\", \"a\")),\n+                new JPackageException(I18N.format(\"error.launcher-duplicate-name\", \"b\"))\n+        )\n+        .create(\"-name=c\",\n+                \"--add-launcher=b=\" + propertyFile,\n+                \"--add-launcher=a=\" + propertyFile,\n+                \"--add-launcher=b=\" + propertyFile,\n+                \"--add-launcher=a=\" + propertyFile).validate();\n+    }\n+\n+    enum BooleanProperty {\n+\n+        TRUE(\"true\", true),\n+        TRUE_UPPERCASE_FIRST(\"True\", true),\n+        TRUE_UPPERCASE_ALL(\"TRUE\", true),\n+        TRUE_UPPERCASE_LAST(\"truE\", true),\n+        TRUE_UPPERCASE_MIDDLE(\"tRUe\", true),\n+        FALSE(\"false\", false),\n+        FALSE_UPPERCASE(\"FALSE\", false),\n+        EMPTY(\"\", false),\n+        RANDOM(\"foo\", false),\n+        TRUELISH(\"truee\", false),\n+        FALSEISH(\"fals\", false),\n+        ;\n+\n+        BooleanProperty(String propertyValue, boolean expectedValue) {\n+            this.propertyValue = Objects.requireNonNull(propertyValue);\n+            this.expectedValue = Objects.requireNonNull(expectedValue);\n+        }\n+\n+        String propertyValue() {\n+            return propertyValue;\n+        }\n+\n+        boolean expectedValue() {\n+            return expectedValue;\n+        }\n+\n+        private final String propertyValue;\n+        private final boolean expectedValue;\n+    }\n+\n+    private static Result<Options> processPropertyFile(Path propFile, OptionValue<?>... options) {\n+        return OptionsProcessor.processPropertyFile(propFile,\n+                Stream.of(options).map(OptionValue::getOption).toList(),\n+                Optional.of(spec -> {\n+                    return new StandardOptionContext(OperatingSystem.current()).forFile(propFile).mapOptionSpec(spec);\n+                }));\n+    }\n+\n+    private static OptionsProcessorValidatorBuilder build() {\n+        return new OptionsProcessorValidatorBuilder();\n+    }\n+\n+\n+    private record OptionsProcessorValidator(\n+            OptionsProcessor optionsProcessor,\n+            CreateBundleCallbackRecorder recorder,\n+            Collection<Map<String, Object>> expectedValidationErrors) {\n+\n+        OptionsProcessorValidator {\n+            Objects.requireNonNull(optionsProcessor);\n+            Objects.requireNonNull(recorder);\n+            Objects.requireNonNull(expectedValidationErrors);\n+        }\n+\n+        Result<OptionsProcessor.ValidatedOptions> validate() {\n+            var curExecutedCounter = recorder.executedCounter();\n+\n+            var result = optionsProcessor.validate();\n+\n+            \/\/ Assert validation doesn't trigger bundling.\n+            assertEquals(curExecutedCounter, recorder.executedCounter());\n+\n+            var errors = result.errors().stream().map(JUnitUtils::exceptionAsPropertyMap).map(propertyMap -> {\n+                \/\/ Don't dive into the cause chain, stop at the first one.\n+                Optional.ofNullable(propertyMap.get(\"getCause\")).ifPresent(causePropertyMap -> {\n+                    ((Map<?, ?>)causePropertyMap).remove(\"getCause\");\n+                    ((Map<?, ?>)causePropertyMap).remove(\"getMessage\");\n+                });\n+                return propertyMap;\n+            }).toList();\n+            if (expectedValidationErrors instanceof Set<?>) {\n+                assertEquals(expectedValidationErrors, Set.copyOf(errors));\n+            } else {\n+                assertEquals(expectedValidationErrors, errors);\n+            }\n+\n+            return result;\n+        }\n+\n+        Collection<? extends Exception> runBundling(OptionsProcessor.ValidatedOptions validatedOptions) {\n+            var curExecutedCounter = recorder.executedCounter();\n+\n+            var result = optionsProcessor.runBundling(validatedOptions);\n+\n+            assertEquals(curExecutedCounter + 1, recorder.executedCounter());\n+\n+            return result;\n+        }\n+\n+        void execute() {\n+            var exceptions = runBundling(validate().orElseThrow());\n+\n+            for (var ex : exceptions) {\n+                ex.printStackTrace();\n+            }\n+\n+            assertEquals(List.of(), exceptions);\n+        }\n+    }\n+\n+\n+    private static final class CreateBundleCallbackRecorder implements Consumer<Options> {\n+\n+        CreateBundleCallbackRecorder(Optional<Consumer<Options>> callback) {\n+            this.callback = Objects.requireNonNull(callback);\n+        }\n+\n+        @Override\n+        public void accept(Options cmdline) {\n+            executedCounter++;\n+            callback.ifPresent(c -> c.accept(cmdline));\n+        }\n+\n+        int executedCounter() {\n+            return executedCounter;\n+        }\n+\n+        private final Optional<Consumer<Options>> callback;\n+        private int executedCounter;\n+    }\n+\n+\n+    private static final class OptionsProcessorValidatorBuilder {\n+\n+        OptionsProcessorValidator create(Object... args) {\n+            return create(List.of(args));\n+        }\n+\n+        OptionsProcessorValidator create(Iterable<Object> args) {\n+\n+            var stringArgs = Stream.concat(\n+                    baseArgs.stream(),\n+                    StreamSupport.stream(args.spliterator(), false).map(Object::toString)\n+            ).toArray(String[]::new);\n+\n+            var recorder = new CreateBundleCallbackRecorder(createBundleCallback());\n+\n+            CliBundlingEnvironment bundlingEnv = bundlingEnvironmentBuilder.createBundleCallback(recorder).create();\n+\n+            var optionsBuilder = Utils.buildParser(os, bundlingEnv).create().apply(stringArgs).orElseThrow();\n+\n+            var op = new OptionsProcessor(optionsBuilder, bundlingEnv);\n+\n+            Collection<Map<String, Object>> errors;\n+            if (expectedValidationErrorsOrdered) {\n+                errors = expectedValidationErrors.stream().map(JUnitUtils::exceptionAsPropertyMap).toList();\n+            } else {\n+                errors = expectedValidationErrors.stream().map(JUnitUtils::exceptionAsPropertyMap).collect(Collectors.toSet());\n+            }\n+\n+            return new OptionsProcessorValidator(op, recorder, errors);\n+        }\n+\n+        OptionsProcessorValidatorBuilder args(Iterable<Object> v) {\n+            StreamSupport.stream(v.spliterator(), false).map(Object::toString).forEach(baseArgs::add);\n+            return this;\n+        }\n+\n+        OptionsProcessorValidatorBuilder args(Object... args) {\n+            return args(List.of(args));\n+        }\n+\n+        OptionsProcessorValidatorBuilder os(OperatingSystem v) {\n+            os = Objects.requireNonNull(v);\n+            return this;\n+        }\n+\n+        OptionsProcessorValidatorBuilder withMockupMainJar(Path inputDir) {\n+\n+            try {\n+                Files.write(inputDir.resolve(\"mockup.jar\"), new byte[] {});\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+\n+            return args(\"--input\", inputDir, \"--main-jar\", \"mockup.jar\");\n+        }\n+\n+        OptionsProcessorValidatorBuilder withDefaultBundlingOperation(boolean v) {\n+            withDefaultBundlingOperation = v;\n+            if (withDefaultBundlingOperation) {\n+                bundlingEnvironmentBuilder.defaultOperation(bundlingOperation);\n+            } else {\n+                bundlingEnvironmentBuilder.defaultOperation(null);\n+            }\n+            return this;\n+        }\n+\n+        OptionsProcessorValidatorBuilder bundlingOperation(BundlingOperationDescriptor v) {\n+            bundlingOperation = Objects.requireNonNull(v);\n+            bundlingEnvironmentBuilder.knownOperation(bundlingOperation);\n+            withDefaultBundlingOperation(withDefaultBundlingOperation);\n+            return this;\n+        }\n+\n+        OptionsProcessorValidatorBuilder createAppImageBundlingOperation() {\n+            return bundlingOperation(MockupCliBundlingEnvironment.createAppImageBundlingOperation(os).descriptor());\n+        }\n+\n+        OptionsProcessorValidatorBuilder createAppImageByDefault() {\n+            return createAppImageBundlingOperation().withDefaultBundlingOperation(true);\n+        }\n+\n+        OptionsProcessorValidatorBuilder platform(OperatingSystem v) {\n+            os = Objects.requireNonNull(v);\n+            return this;\n+        }\n+\n+        OptionsProcessorValidatorBuilder createBundleCallback(Consumer<Options> v) {\n+            createBundleCallback = v;\n+            return this;\n+        }\n+\n+        OptionsProcessorValidatorBuilder expectValidationErrors(Iterable<? extends Exception> v) {\n+            v.forEach(this::expectValidationError);\n+            return this;\n+        }\n+\n+        OptionsProcessorValidatorBuilder expectValidationError(Exception v) {\n+\n+            if (expectedValidationErrors.stream().anyMatch(err -> {\n+                return err.getMessage().equals(v.getMessage());\n+            })) {\n+                throw new IllegalArgumentException(String.format(\"Error message [%s] already expected\", v.getMessage()));\n+            }\n+            expectedValidationErrors.add(v);\n+            return this;\n+        }\n+\n+        OptionsProcessorValidatorBuilder expectValidationErrors(Exception... errors) {\n+            return expectValidationErrors(List.of(errors));\n+        }\n+\n+        OptionsProcessorValidatorBuilder expectBundlingEnvironmentConfigurationErrors(List<Exception> v) {\n+            bundlingEnvironmentBuilder.configurationErrors(bundlingOperation, v);\n+            return this;\n+        }\n+\n+        OptionsProcessorValidatorBuilder expectBundlingEnvironmentConfigurationErrors(Exception... errors) {\n+            return expectBundlingEnvironmentConfigurationErrors(List.of(errors));\n+        }\n+\n+        OptionsProcessorValidatorBuilder validationErrorsOrdered(boolean v) {\n+            expectedValidationErrorsOrdered = v;\n+            return this;\n+        }\n+\n+        private Optional<Consumer<Options>> createBundleCallback() {\n+            return Optional.ofNullable(createBundleCallback);\n+        }\n+\n+        private final List<String> baseArgs = new ArrayList<>();\n+        private BundlingOperationDescriptor bundlingOperation;\n+        private OperatingSystem os = OperatingSystem.current();\n+        private boolean withDefaultBundlingOperation;\n+        private final List<Exception> expectedValidationErrors = new ArrayList<>();\n+        private Consumer<Options> createBundleCallback;\n+        private boolean expectedValidationErrorsOrdered = true;\n+        private final MockupCliBundlingEnvironment.Builder bundlingEnvironmentBuilder = MockupCliBundlingEnvironment.build();\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/OptionsProcessorTest.java","additions":786,"deletions":0,"binary":false,"changes":786,"status":"added"},{"patch":"@@ -0,0 +1,256 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static jdk.jpackage.internal.cli.ExpectedOptions.expectOptions;\n+import static jdk.jpackage.internal.cli.OptionIdentifier.createIdentifier;\n+import static jdk.jpackage.internal.cli.WithOptionIdentifier.stub;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.api.Test;\n+\n+public class OptionsTest {\n+\n+    @Test\n+    public void test_ofIDs() {\n+        var fooID = createIdentifier();\n+        var barID = createIdentifier();\n+        var buzID = createIdentifier();\n+\n+        var options = Options.ofIDs(Map.of(fooID, \"Hello\", barID, 100));\n+\n+        expectOptions().add(fooID, \"Hello\").add(barID, 100).apply(options);\n+        assertFalse(options.find(buzID).isPresent());\n+    }\n+\n+    @Test\n+    public void test_of_duplicate_id() {\n+        var withId = stub(createIdentifier());\n+        var barO = dummyOption(\"bar\");\n+        var barOV = OptionValue.build().spec(dummyOptionSpec(\"another-bar\")).id(barO.id()).create();\n+\n+        assertThrowsExactly(IllegalStateException.class, () -> {\n+            Options.of(Map.of(withId, \"Hello\", barO, 100, barOV, \"Bye\"));\n+        });\n+    }\n+\n+    @Test\n+    public void test_of() {\n+        var withId = stub(createIdentifier());\n+        var bar = dummyOption(\"bar\");\n+        var buz = OptionValue.build().spec(dummyOptionSpec(\"another-bar\")).create();\n+\n+        var options = Options.of(Map.of(withId, \"Hello\", bar, 100, buz, \"Bye\"));\n+\n+        expectOptions().add(withId.id(), \"Hello\").add(bar, 100).add(buz, \"Bye\").apply(options);\n+    }\n+\n+    @Test\n+    public void test_of_empty() {\n+        var options = Options.of(Map.of());\n+\n+        assertFalse(options.contains(createIdentifier()));\n+\n+        var barID = dummyOption(\"bar\");\n+        assertFalse(options.contains(barID));\n+        assertFalse(options.contains(barID.spec().name()));\n+    }\n+\n+    @Test\n+    public void test_of_Option() {\n+        var fooID = createIdentifier();\n+        var barID = dummyOption(\"bar\");\n+        var buzID = createIdentifier();\n+\n+        var options = Options.of(Map.of(stub(fooID), \"Hello\", barID, 100));\n+\n+        expectOptions().add(fooID, \"Hello\").add(barID, 100).apply(options);\n+        assertFalse(options.find(buzID).isPresent());\n+        assertFalse(options.contains(OptionName.of(\"foo\")));\n+    }\n+\n+    @Test\n+    public void test_toMap() {\n+        var idA = createIdentifier();\n+        var idB = createIdentifier();\n+\n+        var a = Options.ofIDs(Map.of(idA, \"Foo\", idB, true));\n+        var b = Options.concat(Options.ofIDs(Map.of(idA, \"Foo\")), Options.ofIDs(Map.of(idB, true)));\n+\n+        assertEquals(a.toMap(), b.toMap());\n+    }\n+\n+    @Test\n+    public void test_copyWithDefaultValue() {\n+        var fooID = createIdentifier();\n+        var barOV = OptionValue.build().spec(dummyOptionSpec(\"bar\")).create();\n+\n+        var options = Options.ofIDs(Map.of(fooID, \"Hello\"));\n+        var expected = expectOptions().add(fooID, \"Hello\");\n+\n+        expected.apply(options);\n+        assertFalse(options.contains(barOV.getSpec().name()));\n+\n+        options = options.copyWithDefaultValue(barOV, 89);\n+        expected.add(barOV, 89).apply(options);\n+\n+    }\n+\n+    @Test\n+    public void test_copyWithDefaultValue_nop() {\n+        var fooID = createIdentifier();\n+        var barOV = OptionValue.build().spec(dummyOptionSpec(\"bar\")).create();\n+\n+        var options = Options.of(Map.of(stub(fooID), \"Hello\", barOV, 89));\n+        var expected = expectOptions().add(fooID, \"Hello\").add(barOV, 89);\n+\n+        expected.apply(options);\n+        options = options.copyWithDefaultValue(barOV, 75);\n+        expected.apply(options);\n+    }\n+\n+    @Test\n+    public void test_copyWithParent() {\n+        var fooID = createIdentifier();\n+        var barID = dummyOption(\"bar\");\n+\n+        var options = Options.ofIDs(Map.of(fooID, \"Hello\"));\n+        expectOptions().add(fooID, \"Hello\").apply(options);\n+        assertFalse(options.contains(barID.spec().name()));\n+\n+        var parentOptions = Options.of(Map.of(barID, 89));\n+        expectOptions().add(barID, 89).apply(parentOptions);\n+\n+        expectOptions().add(fooID, \"Hello\").add(barID, 89).apply(options.copyWithParent(parentOptions));\n+    }\n+\n+    @Test\n+    public void test_copyWithout() {\n+        var a = createIdentifier();\n+        var b = OptionIdentifier.of(\"foo\");\n+        var c = dummyOption(\"bar\", \"b\");\n+        var d = dummyOption(\"str\", \"s\", \"q\");\n+\n+        var options = Options.concat(\n+                Options.ofIDs(Map.of(a, \"Hello\", b, 189)),\n+                Options.of(Map.of(c, Set.of(78, \"56\"), d, List.of(100)))\n+        );\n+\n+        expectOptions().add(a, \"Hello\").add(b, 189).add(c, Set.of(78, \"56\")).add(d, List.of(100)).apply(options);\n+\n+        var without = options.copyWithout(a, d.id());\n+\n+        expectOptions().add(b, 189).add(c, Set.of(78, \"56\")).apply(without);\n+\n+        assertFalse(without.contains(a));\n+        assertFalse(without.contains(d));\n+        for (var name : d.spec().names()) {\n+            assertFalse(without.contains(name));\n+        }\n+    }\n+\n+    @Test\n+    public void test_copyWithout_duplicate_option_name() {\n+        var x = dummyOption(\"b\", \"c\", \"d\");\n+        var y = dummyOption(\"a\", \"b\", \"d\");\n+\n+        var options = Options.of(Map.of(x, \"Hello\", y, 189));\n+\n+        assertTrue(options.contains(OptionName.of(\"a\")));\n+        assertTrue(options.contains(OptionName.of(\"b\")));\n+        assertTrue(options.contains(OptionName.of(\"c\")));\n+        assertTrue(options.contains(OptionName.of(\"d\")));\n+\n+        var without = options.copyWithout(x.id());\n+\n+        assertTrue(without.contains(OptionName.of(\"a\")));\n+        assertTrue(without.contains(OptionName.of(\"b\")));\n+        assertFalse(without.contains(OptionName.of(\"c\")));\n+        assertTrue(without.contains(OptionName.of(\"d\")));\n+    }\n+\n+    @Test\n+    public void test_copyWith() {\n+        var a = createIdentifier();\n+        var b = OptionIdentifier.of(\"foo\");\n+        var c = dummyOption(\"bar\", \"b\");\n+        var d = dummyOption(\"str\", \"s\", \"q\");\n+        var unused = createIdentifier();\n+\n+        var options = Options.of(Map.of(stub(a), \"Hello\", stub(b), 189, c, Set.of(78, \"56\"), d, List.of(100)));\n+\n+        expectOptions().add(a, \"Hello\").add(b, 189).add(c, Set.of(78, \"56\")).add(d, List.of(100)).apply(options);\n+\n+        var with = options.copyWith(a, c.id(), unused);\n+\n+        expectOptions().add(a, \"Hello\").add(c, Set.of(78, \"56\")).apply(with);\n+\n+        assertFalse(with.contains(b));\n+        assertFalse(with.contains(d));\n+        assertFalse(with.contains(unused));\n+        for (var name : d.spec().names()) {\n+            assertFalse(with.contains(name));\n+        }\n+    }\n+\n+    @Test\n+    public void test_copyWithParent_override() {\n+        var fooID = createIdentifier();\n+        var barID = dummyOption(\"bar\");\n+\n+        var options = Options.concat(\n+                Options.ofIDs(Map.of(fooID, \"Hello\")),\n+                Options.of(Map.of(barID, 137))\n+        );\n+        var expected = expectOptions().add(fooID, \"Hello\").add(barID, 137);\n+        expected.apply(options);\n+\n+        var parentOptions = Options.of(Map.of(barID, 89));\n+        expectOptions().add(barID, 89).apply(parentOptions);\n+\n+        expected.apply(options.copyWithParent(parentOptions));\n+    }\n+\n+    private static Option dummyOption(String... names) {\n+        return new Option(dummyOptionSpec(names));\n+    }\n+\n+    private static OptionSpec<String> dummyOptionSpec(String... names) {\n+        return new OptionSpec<>(\n+                Stream.of(names).map(OptionName::of).toList(),\n+                Optional.empty(),\n+                Set.of(new OptionScope() {}),\n+                OptionSpec.MergePolicy.USE_FIRST,\n+                Optional.empty(),\n+                Optional.empty(),\n+                \"\");\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/OptionsTest.java","additions":256,"deletions":0,"binary":false,"changes":256,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+ErrorTest.test(IMAGE; app-desc=Hello; args-add=[--app-version, 0.2]; errors=[message.version-string-first-number-not-zero, error.invalid-cfbundle-version.advice])\n+ErrorTest.test(IMAGE; app-desc=Hello; args-add=[--app-version, 1.2.3.4]; errors=[message.version-string-too-many-components, error.invalid-cfbundle-version.advice])\n+ErrorTest.test(IMAGE; app-desc=Hello; args-add=[--app-version, 1.]; errors=[error.version-string-zero-length-component+[1.]])\n+ErrorTest.test(IMAGE; app-desc=Hello; args-add=[--app-version, 1.b.3]; errors=[error.version-string-invalid-component+[1.b.3, b.3]])\n+ErrorTest.test(IMAGE; app-desc=Hello; args-add=[--app-version, ]; errors=[error.version-string-empty])\n+ErrorTest.test(IMAGE; app-desc=Hello; args-add=[--jlink-options, --add-modules]; errors=[error.blocked.option+[--add-modules]])\n+ErrorTest.test(IMAGE; app-desc=Hello; args-add=[--jlink-options, --foo]; errors=[error.jlink.failed+[Error: unknown option: --foo]])\n+ErrorTest.test(IMAGE; app-desc=Hello; args-add=[--jlink-options, --module-path]; errors=[error.blocked.option+[--module-path]])\n+ErrorTest.test(IMAGE; app-desc=Hello; args-add=[--jlink-options, --output]; errors=[error.blocked.option+[--output]])\n+ErrorTest.test(IMAGE; app-desc=Hello; args-add=[--main-jar, non-existent.jar]; errors=[error.main-jar-does-not-exist+[non-existent.jar]])\n+ErrorTest.test(IMAGE; app-desc=Hello; args-add=[--runtime-image, @@EMPTY_DIR@@]; errors=[error.invalid-runtime-image-missing-file+[@@EMPTY_DIR@@, lib\/**\/libjli.dylib]])\n+ErrorTest.test(IMAGE; app-desc=Hello; args-add=[--runtime-image, @@INVALID_MAC_RUNTIME_BUNDLE@@]; errors=[error.invalid-runtime-image-missing-file+[@@INVALID_MAC_RUNTIME_BUNDLE@@, Contents\/Home\/lib\/**\/libjli.dylib]])\n+ErrorTest.test(IMAGE; app-desc=Hello; args-add=[--runtime-image, @@INVALID_MAC_RUNTIME_IMAGE@@]; errors=[error.invalid-runtime-image-missing-file+[@@INVALID_MAC_RUNTIME_IMAGE@@, lib\/**\/libjli.dylib]])\n+ErrorTest.test(IMAGE; app-desc=Hello; args-del=[--main-class]; errors=[error.no-main-class-with-main-jar+[hello.jar], error.no-main-class-with-main-jar.advice+[hello.jar]])\n+ErrorTest.test(IMAGE; args-add=[--module, com.foo.bar, --runtime-image, @@JAVA_HOME@@]; errors=[error.no-module-in-path+[com.foo.bar]])\n+ErrorTest.test(IMAGE; args-add=[--module, java.base, --runtime-image, @@JAVA_HOME@@]; errors=[ERR_NoMainClass])\n+ErrorTest.test(LINUX_DEB; app-desc=Hello; args-add=[--linux-package-name, #]; errors=[error.deb-invalid-value-for-package-name+[#], error.deb-invalid-value-for-package-name.advice])\n+ErrorTest.test(LINUX_RPM; app-desc=Hello; args-add=[--linux-package-name, #]; errors=[error.rpm-invalid-value-for-package-name+[#], error.rpm-invalid-value-for-package-name.advice])\n+ErrorTest.test(MAC_PKG; app-desc=Hello; args-add=[--mac-package-identifier, #1]; errors=[message.invalid-identifier+[#1]])\n+ErrorTest.test(NATIVE; app-desc=Hello; args-add=[--mac-app-store, --runtime-image, @@JAVA_HOME@@]; errors=[error.invalid-runtime-image-bin-dir+[@@JAVA_HOME@@], error.invalid-runtime-image-bin-dir.advice+[--mac-app-store]])\n+ErrorTest.test(NATIVE; app-desc=Hello; args-add=[--runtime-image, @@EMPTY_DIR@@]; errors=[error.invalid-runtime-image-missing-file+[@@EMPTY_DIR@@, lib\/**\/libjli.dylib]])\n+ErrorTest.test(NATIVE; app-desc=Hello; args-add=[--runtime-image, @@INVALID_MAC_RUNTIME_BUNDLE@@]; errors=[error.invalid-runtime-image-missing-file+[@@INVALID_MAC_RUNTIME_BUNDLE@@, Contents\/Home\/lib\/**\/libjli.dylib]])\n+ErrorTest.test(NATIVE; app-desc=Hello; args-add=[--runtime-image, @@INVALID_MAC_RUNTIME_IMAGE@@]; errors=[error.invalid-runtime-image-missing-file+[@@INVALID_MAC_RUNTIME_IMAGE@@, lib\/**\/libjli.dylib]])\n+ErrorTest.test(NATIVE; args-add=[--runtime-image, @@EMPTY_DIR@@]; errors=[error.invalid-runtime-image-missing-file+[@@EMPTY_DIR@@, lib\/**\/libjli.dylib]])\n+ErrorTest.test(NATIVE; args-add=[--runtime-image, @@INVALID_MAC_RUNTIME_BUNDLE@@]; errors=[error.invalid-runtime-image-missing-file+[@@INVALID_MAC_RUNTIME_BUNDLE@@, Contents\/Home\/lib\/**\/libjli.dylib]])\n+ErrorTest.test(NATIVE; args-add=[--runtime-image, @@INVALID_MAC_RUNTIME_IMAGE@@]; errors=[error.invalid-runtime-image-missing-file+[@@INVALID_MAC_RUNTIME_IMAGE@@, lib\/**\/libjli.dylib]])\n+ErrorTest.test(WIN_EXE; app-desc=Hello; args-add=[--app-version, 1.2.3.4.5]; errors=[error.msi-product-version-components+[1.2.3.4.5], error.version-string-wrong-format.advice])\n+ErrorTest.test(WIN_EXE; app-desc=Hello; args-add=[--app-version, 1.2.65536]; errors=[error.msi-product-version-build-out-of-range+[1.2.65536], error.version-string-wrong-format.advice])\n+ErrorTest.test(WIN_EXE; app-desc=Hello; args-add=[--app-version, 1.256]; errors=[error.msi-product-version-minor-out-of-range+[1.256], error.version-string-wrong-format.advice])\n+ErrorTest.test(WIN_EXE; app-desc=Hello; args-add=[--app-version, 1234]; errors=[error.msi-product-version-components+[1234], error.version-string-wrong-format.advice])\n+ErrorTest.test(WIN_EXE; app-desc=Hello; args-add=[--app-version, 256.1]; errors=[error.msi-product-version-major-out-of-range+[256.1], error.version-string-wrong-format.advice])\n+ErrorTest.test(WIN_EXE; app-desc=Hello; args-add=[--launcher-as-service]; errors=[error.missing-service-installer, error.missing-service-installer.advice])\n+ErrorTest.test(WIN_MSI; app-desc=Hello; args-add=[--app-version, 1.2.3.4.5]; errors=[error.msi-product-version-components+[1.2.3.4.5], error.version-string-wrong-format.advice])\n+ErrorTest.test(WIN_MSI; app-desc=Hello; args-add=[--app-version, 1.2.65536]; errors=[error.msi-product-version-build-out-of-range+[1.2.65536], error.version-string-wrong-format.advice])\n+ErrorTest.test(WIN_MSI; app-desc=Hello; args-add=[--app-version, 1.256]; errors=[error.msi-product-version-minor-out-of-range+[1.256], error.version-string-wrong-format.advice])\n+ErrorTest.test(WIN_MSI; app-desc=Hello; args-add=[--app-version, 1234]; errors=[error.msi-product-version-components+[1234], error.version-string-wrong-format.advice])\n+ErrorTest.test(WIN_MSI; app-desc=Hello; args-add=[--app-version, 256.1]; errors=[error.msi-product-version-major-out-of-range+[256.1], error.version-string-wrong-format.advice])\n+ErrorTest.test(WIN_MSI; app-desc=Hello; args-add=[--launcher-as-service]; errors=[error.missing-service-installer, error.missing-service-installer.advice])\n+ErrorTest.test(args-add=[@foo]; errors=[ERR_CannotParseOptions+[foo]])\n+ErrorTest.testMacSigningIdentityValidation(IMAGE, --mac-app-image-sign-identity, true)\n+ErrorTest.testMacSigningIdentityValidation(IMAGE, --mac-signing-key-user-name, false)\n+ErrorTest.testMacSigningIdentityValidation(MAC_DMG, --mac-app-image-sign-identity, true)\n+ErrorTest.testMacSigningIdentityValidation(MAC_DMG, --mac-signing-key-user-name, false)\n+ErrorTest.testMacSigningIdentityValidation(MAC_PKG, --mac-app-image-sign-identity, true)\n+ErrorTest.testMacSigningIdentityValidation(MAC_PKG, --mac-installer-sign-identity, true)\n+ErrorTest.testMacSigningIdentityValidation(MAC_PKG, --mac-signing-key-user-name, false)\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/OptionsValidationFailTest.excludes","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,245 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static jdk.jpackage.internal.util.function.ThrowingRunnable.toRunnable;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.UncheckedIOException;\n+import java.lang.invoke.MethodHandles;\n+import java.nio.file.Files;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.model.BundlingOperationDescriptor;\n+import jdk.jpackage.internal.util.Result;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.JUnitAdapter;\n+import jdk.jpackage.test.JavaTool;\n+import jdk.jpackage.test.TKit;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DynamicTest;\n+import org.junit.jupiter.api.TestFactory;\n+import org.junit.jupiter.api.condition.EnabledIf;\n+\n+\/**\n+ * Runs some ErrorTest test cases from an IDE on a mockup jpackage tool\n+ * provider.\n+ * <p>\n+ * ErrorTest is comprised of test cases that pass faulty command line arguments\n+ * to jpackage and expect it to fail. It is natural to reuse these test cases to\n+ * test jpackage command line validation.\n+ * <p>\n+ * ErrorTest provides better test coverage, but it is a jtreg test, it runs\n+ * slowly and there is no integration of jtreg tests in IDEs. This JUnit test\n+ * class leverages ErrorTest test cases to test jpackage command line validation\n+ * from an IDE.\n+ *\n+ * <p>\n+ * The scenario breaks down into two components:\n+ * <ol>\n+ * <li>Load ErrorTest jtreg test\n+ * <li>Setup custom jpackage tool provider\n+ * <\/ol>\n+ *\n+ * <h1>1. Load ErrorTest jtreg test<\/h1>\n+ * <p>\n+ * Build OptionsValidationFailTest, ErrorTest and its nested classes such that\n+ * they reside in the unnamed module together with the classes from the\n+ * \"jdk.jpackage.test\" package.\n+ * <p>\n+ * There is no straightforward way to access classes in the unnamed package\n+ * outside their module. However, these classes (class files) can be accessed as\n+ * resources. So the workaround is to read class files of classes in the unnamed\n+ * package and load them using a custom class loader.\n+ * <p>\n+ * jpackage jtreg tests are in the unnamed package according to jtreg\n+ * recommendations, see\n+ * <a href=\"https:\/\/openjdk.org\/jtreg\/faq.html#how-should-i-organize-tests-libraries-and-other-test-related-files\">jtreg FAQ<\/a>\n+ *\/\n+@EnabledIf(\"jtregErrorTestAvailable\")\n+public class OptionsValidationFailTest {\n+\n+    @BeforeAll\n+    public static void setCustomJPackageToolProvider() {\n+        JPackageCommand.useToolProviderByDefault(new ToolProvider() {\n+\n+            @Override\n+            public String name() {\n+                return \"jpackage-mockup\";\n+            }\n+\n+            @Override\n+            public int run(PrintWriter out, PrintWriter err, String... args) {\n+\n+                var errorReporter = new Main.ErrorReporter(ex -> {\n+                    ex.printStackTrace(err);\n+                }, out::append);\n+\n+                return parse(args).peekErrors(errors -> {\n+                    final var firstErr = errors.stream().findFirst().orElseThrow();\n+                    errorReporter.reportError(firstErr);\n+                }).map(builder -> {\n+                    var result = new OptionsProcessor(builder, bundlingEnv).validate();\n+                    if (result.hasValue()) {\n+                        return 0;\n+                    } else {\n+                        result.peekErrors(errors -> {\n+                            errors.forEach(errorReporter::reportError);\n+                        });\n+                        return 1;\n+                    }\n+                }).value().orElse(1);\n+            }\n+\n+            private Result<JOptSimpleOptionsBuilder.OptionsBuilder> parse(String... args) {\n+                return Utils.buildParser(OperatingSystem.current(), bundlingEnv).create().apply(args);\n+            }\n+\n+            private final CliBundlingEnvironment bundlingEnv = new CliBundlingEnvironment() {\n+\n+                @Override\n+                public Optional<BundlingOperationDescriptor> defaultOperation() {\n+                    switch (OperatingSystem.current()) {\n+                        case WINDOWS -> {\n+                            return Optional.of(StandardBundlingOperation.CREATE_WIN_EXE.descriptor());\n+                        }\n+                        case LINUX -> {\n+                            return Optional.of(StandardBundlingOperation.CREATE_LINUX_RPM.descriptor());\n+                        }\n+                        case MACOS -> {\n+                            return Optional.of(StandardBundlingOperation.CREATE_MAC_PKG.descriptor());\n+                        }\n+                        default -> {\n+                            throw new UnsupportedOperationException();\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void createBundle(BundlingOperationDescriptor op, Options cmdline) {\n+                    throw new AssertionError();\n+                }\n+\n+            };\n+        });\n+    }\n+\n+    @AfterAll\n+    public static void resetJPackageToolProvider() {\n+        Optional.ofNullable(JavaTool.JPACKAGE.asToolProvider()).ifPresentOrElse(\n+                JPackageCommand::useToolProviderByDefault, JPackageCommand::useExecutableByDefault);\n+    }\n+\n+    @TestFactory\n+    Stream<DynamicTest> getTestCasesFromErrorTest() throws Throwable {\n+        final var jpackageTestsUnnamedModule = JUnitAdapter.class.getModule();\n+\n+        final var testClassloader = new InMemoryClassLoader(Stream.of(\n+                \"ErrorTest\",\n+                \"ErrorTest$ArgumentGroup\",\n+                \"ErrorTest$PackageTypeSpec\",\n+                \"ErrorTest$TestSpec$Builder\",\n+                \"ErrorTest$TestSpec\",\n+                \"ErrorTest$Token\",\n+                \"ErrorTest$UnsupportedPlatformOption\"\n+        ).collect(Collectors.toMap(x -> x, className -> {\n+            try (final var in = Objects.requireNonNull(jpackageTestsUnnamedModule.getResourceAsStream(className + \".class\"))) {\n+                final var buffer= new ByteArrayOutputStream();\n+                in.transferTo(buffer);\n+                return buffer.toByteArray();\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        })));\n+\n+        final var thisModule = getClass().getModule();\n+        if (thisModule.isNamed()) {\n+            for (final var m : List.of(testClassloader.getUnnamedModule(), jpackageTestsUnnamedModule)) {\n+                thisModule.addOpens(\"jdk.jpackage.internal\", m);\n+            }\n+        }\n+\n+        final var defaultExcludesFile = TKit.TEST_SRC_ROOT.resolve(String.format(\n+                \"junit\/share\/jdk.jpackage\/%s.excludes\", OptionsValidationFailTest.class.getName().replace(\".\", \"\/\")));\n+\n+        final var defaultExcludes = Files.readAllLines(defaultExcludesFile).stream().map(testDesc -> {\n+            return \"--jpt-exclude=\" + testDesc;\n+        });\n+\n+        final var defaultIncludes = Stream.of(\n+\/\/              \"ErrorTest.test(NATIVE; args-add=[--runtime-image, @@JAVA_HOME@@, --app-image, app-image]; errors=[ERR_MutuallyExclusiveOptions+[--runtime-image, --app-image]])\"\n+        ).map(testDesc -> {\n+            return \"--jpt-include=\" + testDesc;\n+        });\n+\n+        return JUnitAdapter.createJPackageTests(testClassloader, Stream.of(\n+                defaultExcludes,\n+                defaultIncludes,\n+                Stream.of(\"--jpt-run=ErrorTest\")\n+        ).flatMap(x -> x).toArray(String[]::new));\n+    }\n+\n+    private static boolean jtregErrorTestAvailable() {\n+        final var jpackageTestsUnnamedModule = JUnitAdapter.class.getModule();\n+\n+        try (final var in = jpackageTestsUnnamedModule.getResourceAsStream(\"ErrorTest.class\")) {\n+            return in != null;\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n+    }\n+\n+    private static final class InMemoryClassLoader extends ClassLoader {\n+        InMemoryClassLoader(Map<String, byte[]> classes) {\n+            super(InMemoryClassLoader.class.getClassLoader());\n+            this.classes = Objects.requireNonNull(classes);\n+        }\n+\n+        @Override\n+        protected Class<?> findClass(String name) throws ClassNotFoundException {\n+            final var classBytes = classes.get(name);\n+            if (classBytes != null) {\n+                return defineClass(name, classBytes, 0, classBytes.length);\n+            } else {\n+                return getParent().loadClass(name);\n+            }\n+        }\n+\n+        private final Map<String, byte[]> classes;\n+    }\n+\n+    static {\n+        \/\/ Ensure JUnitAdapter class is initialized to get the value of the \"test.src\"\n+        \/\/ property set when the test is executed by a test runner other than jtreg.\n+        toRunnable(() -> MethodHandles.lookup().ensureInitialized(JUnitAdapter.class)).run();\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/OptionsValidationFailTest.java","additions":245,"deletions":0,"binary":false,"changes":245,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static java.util.stream.Collectors.toMap;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.model.BundlingOperationDescriptor;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class StandardBundlingOperationTest {\n+\n+    @Test\n+    public void testUniqueDescriptors() {\n+        Stream.of(StandardBundlingOperation.values()).collect(toMap(StandardBundlingOperation::descriptor, x -> x));\n+    }\n+\n+    @Test\n+    public void test_valueOf() {\n+        for (var op : StandardBundlingOperation.values()) {\n+            assertSame(op, StandardBundlingOperation.valueOf(op.descriptor()).orElseThrow());\n+        }\n+\n+        assertFalse(StandardBundlingOperation.valueOf(BundlingOperationDescriptor.valueOf(\"WINDOWS:create:foo\")).isPresent());\n+    }\n+\n+    @Test\n+    public void test_ofPlatform() {\n+        var combined = Stream.of(OperatingSystem.WINDOWS, OperatingSystem.MACOS, OperatingSystem.LINUX)\n+                .map(StandardBundlingOperation::ofPlatform)\n+                .flatMap(x -> x).sorted().toList();\n+\n+        var whole = Stream.of(StandardBundlingOperation.values()).sorted().toList();\n+\n+        assertEquals(whole, combined);\n+    }\n+\n+    @Test\n+    public void test_narrow() {\n+        assertEquals(\n+                List.of(StandardBundlingOperation.CREATE_LINUX_APP_IMAGE),\n+                StandardBundlingOperation.narrow(Stream.of(StandardBundlingOperation.CREATE_LINUX_APP_IMAGE, new OptionScope() {})).toList());\n+\n+        assertEquals(List.of(), StandardBundlingOperation.narrow(Stream.of(new OptionScope() {})).toList());\n+        assertEquals(List.of(), StandardBundlingOperation.narrow(Stream.of()).toList());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testFromOptionName(Map.Entry<String, Set<BundlingOperationOptionScope>> testSpec) {\n+        final var actualScope = StandardBundlingOperation.fromOptionName(testSpec.getKey());\n+        assertEquals(testSpec.getValue(), actualScope);\n+    }\n+\n+    private static List<Map.Entry<String, Set<BundlingOperationOptionScope>>> testFromOptionName() {\n+        return List.of(\n+                Map.entry(\"foo\", StandardBundlingOperation.CREATE_BUNDLE),\n+                Map.entry(\"win-foo\", StandardBundlingOperation.WINDOWS),\n+                Map.entry(\"linux-foo\", StandardBundlingOperation.LINUX),\n+                Map.entry(\"mac-foo\", MAC_CREATE_BUNDLE),\n+                Map.entry(\"win-exe-foo\", Set.of(StandardBundlingOperation.CREATE_WIN_EXE)),\n+                Map.entry(\"win-msi-foo\", Set.of(StandardBundlingOperation.CREATE_WIN_MSI)),\n+                Map.entry(\"linux-rpm-foo\", Set.of(StandardBundlingOperation.CREATE_LINUX_RPM)),\n+                Map.entry(\"linux-deb-foo\", Set.of(StandardBundlingOperation.CREATE_LINUX_DEB)),\n+                Map.entry(\"mac-dmg-foo\", Set.of(StandardBundlingOperation.CREATE_MAC_DMG)),\n+                Map.entry(\"mac-pkg-foo\", Set.of(StandardBundlingOperation.CREATE_MAC_PKG))\n+        );\n+    }\n+\n+    private static final Set<BundlingOperationOptionScope> MAC_CREATE_BUNDLE = Set.of(\n+            StandardBundlingOperation.CREATE_MAC_APP_IMAGE,\n+            StandardBundlingOperation.CREATE_MAC_DMG,\n+            StandardBundlingOperation.CREATE_MAC_PKG);\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/StandardBundlingOperationTest.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,646 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static java.util.stream.Collectors.joining;\n+import static java.util.stream.Collectors.toMap;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.DirectoryNotEmptyException;\n+import java.nio.file.Files;\n+import java.nio.file.NotDirectoryException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.ResourceBundle;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.cli.JOptSimpleOptionsBuilder.ConvertedOptionsBuilder;\n+import jdk.jpackage.internal.cli.JOptSimpleOptionsBuilder.OptionsBuilder;\n+import jdk.jpackage.internal.cli.StandardOption.LauncherProperty;\n+import jdk.jpackage.internal.model.JPackageException;\n+import jdk.jpackage.internal.model.LauncherShortcut;\n+import jdk.jpackage.internal.model.LauncherShortcutStartupDirectory;\n+import jdk.jpackage.internal.util.StringBundle;\n+import jdk.jpackage.test.Comm;\n+import jdk.jpackage.test.JUnitAdapter;\n+import jdk.jpackage.test.TKit;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+public class StandardOptionTest extends JUnitAdapter.TestSrcInitializer {\n+\n+    @Test\n+    public void testNamesUnique() {\n+\n+        final var options = StandardOption.options();\n+\n+        \/\/ Test option names are unique. Let Collectors.toMap() do it.\n+        options.stream()\n+                .map(Option::spec)\n+                .map(OptionSpec::names)\n+                .flatMap(Collection::stream)\n+                .map(OptionName::name)\n+                .collect(toMap(x -> x, x -> x));\n+    }\n+\n+    @Test\n+    public void testDescription() {\n+\n+        final var options = StandardOption.options();\n+\n+        var i18n = StringBundle.fromResourceBundle(ResourceBundle.getBundle(\"jdk.jpackage.internal.resources.HelpResources\"));\n+\n+        options.stream().map(Option::spec).map(OptionSpec::description).forEach(i18n::getString);\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"\", \"icon\"})\n+    public void test_ICON(String name, @TempDir Path workDir) throws IOException {\n+\n+        if (!name.isEmpty()) {\n+            var file = workDir.resolve(name);\n+\n+            Files.write(file, new byte[0]);\n+\n+            name = file.toString();\n+        }\n+\n+        var spec = StandardOption.ICON.getSpec();\n+\n+        var result = spec.converter().orElseThrow().convert(spec.name(), StringToken.of(name));\n+\n+        assertEquals(Path.of(name), result.orElseThrow());\n+    }\n+\n+    @Test\n+    public void test_ICON_validator_fail(@TempDir Path workDir) {\n+\n+        var spec = StandardOption.ICON.getSpec();\n+\n+        var result = spec.converter().orElseThrow().convert(spec.name(), StringToken.of(workDir.toString()));\n+\n+        var ex = assertThrows(JPackageException.class, result::orElseThrow);\n+\n+        assertEquals(I18N.format(\"error.paramater-not-file\", workDir, \"--icon\"), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void test_ICON_validator_fail_in_property_file(@TempDir Path workDir) {\n+\n+        var propertyFile = Path.of(\"foo.properties\");\n+\n+        var spec = new StandardOptionContext().forFile(propertyFile).mapOptionSpec(StandardOption.ICON.getSpec());\n+\n+        var result = spec.converter().orElseThrow().convert(spec.name(), StringToken.of(workDir.toString()));\n+\n+        var ex = assertThrows(JPackageException.class, result::orElseThrow);\n+\n+        assertEquals(I18N.format(\"error.properties-paramater-not-file\", workDir, \"icon\", propertyFile), ex.getMessage());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"\", \"non-existent\"})\n+    public void test_TEMP_ROOT_valid(String dir, @TempDir Path workDir) {\n+\n+        var spec = StandardOption.TEMP_ROOT.getSpec();\n+\n+        var tempRoot = workDir.resolve(dir);\n+\n+        var value = spec.converter().orElseThrow().convert(spec.name(), StringToken.of(tempRoot.toString())).orElseThrow();\n+\n+        assertEquals(tempRoot, value);\n+    }\n+\n+    @Test\n+    public void test_TEMP_ROOT_invalid(@TempDir Path workDir) throws IOException {\n+\n+        var spec = StandardOption.TEMP_ROOT.getSpec();\n+\n+        var tempRoot = workDir.resolve(\"file\");\n+\n+        Files.writeString(tempRoot, \"foo\");\n+\n+        var ex = assertThrowsExactly(JPackageException.class,\n+                spec.converter().orElseThrow().convert(spec.name(), StringToken.of(tempRoot.toString()))::orElseThrow);\n+        assertEquals(I18N.format(\"ERR_BuildRootInvalid\", tempRoot), ex.getMessage());\n+        assertEquals(NotDirectoryException.class, ex.getCause().getClass());\n+\n+        tempRoot = workDir;\n+\n+        ex = assertThrowsExactly(JPackageException.class,\n+                spec.converter().orElseThrow().convert(spec.name(), StringToken.of(tempRoot.toString()))::orElseThrow);\n+        assertEquals(I18N.format(\"ERR_BuildRootInvalid\", tempRoot), ex.getMessage());\n+        assertEquals(DirectoryNotEmptyException.class, ex.getCause().getClass());\n+    }\n+\n+    @Test\n+    public void test_TYPE_valid() {\n+\n+        var spec = StandardOption.TYPE.getSpec();\n+\n+        Stream.of(StandardBundlingOperation.values()).forEach(bundlingOperation -> {\n+            var pkgTypeStr = bundlingOperation.packageTypeValue();\n+            var pkgType = spec.converter().orElseThrow().convert(spec.name(), StringToken.of(pkgTypeStr)).orElseThrow();\n+            assertSame(bundlingOperation.packageType(), pkgType);\n+        });\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"\", \"msii\", \"RPM\", \"App-image\"})\n+    public void test_TYPE_invalid(String name) {\n+\n+        var spec = StandardOption.TYPE.getSpec();\n+\n+        var result = spec.converter().orElseThrow().convert(spec.name(), StringToken.of(name));\n+\n+        var ex = assertThrows(JPackageException.class, result::orElseThrow);\n+\n+        assertEquals(I18N.format(\"ERR_InvalidInstallerType\", name), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void test_booleanOptionMutator() {\n+\n+        var option = OptionSpecBuilder.create(Boolean.class).name(\"foo\").mutate(StandardOption.booleanOptionMutator()).create();\n+\n+        var empty = Options.of(Map.of());\n+\n+        \/\/ Expect the default value.\n+        assertTrue(option.findIn(empty).isPresent());\n+\n+        \/\/ Expect the option is not found.\n+        assertFalse(option.containsIn(empty));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testLauncherShortcutOptions(LauncherShortcutTestSpec testSpec) {\n+        testSpec.test();\n+    }\n+\n+    @Test\n+    public void test_launcherOptions() {\n+        var options = StandardOption.launcherOptions().stream().map(Option::id).toList();\n+\n+        \/\/ Test some that should be in the set\n+        assertTrue(options.contains(StandardOption.ARGUMENTS.id()));\n+        assertTrue(options.contains(StandardOption.MODULE.id()));\n+        assertTrue(options.contains(StandardOption.APPCLASS.id()));\n+        assertTrue(options.contains(StandardOption.WIN_CONSOLE_HINT.id()));\n+\n+        \/\/ Test some that should NOT be in the set\n+        assertFalse(options.contains(StandardOption.NAME.id()));\n+        assertFalse(options.contains(StandardOption.INSTALL_DIR.id()));\n+    }\n+\n+    @Test\n+    public void test_sharedOption() {\n+\n+        var pred = StandardOption.sharedOption();\n+\n+        var options = StandardOption.options().stream().filter(option -> {\n+            return pred.test(option.spec());\n+        }).map(Option::id).toList();\n+\n+        \/\/ Test some that should be in the set\n+        assertTrue(options.contains(StandardOption.NAME.id()));\n+        assertTrue(options.contains(StandardOption.INSTALL_DIR.id()));\n+\n+        \/\/ Test some that should NOT be in the set\n+        assertFalse(options.contains(StandardOption.WIN_CONSOLE_HINT.id()));\n+        assertFalse(options.contains(StandardOption.LINUX_MENU_GROUP.id()));\n+        assertFalse(options.contains(StandardOption.MAC_APP_CATEGORY.id()));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(names = {\"WINDOWS\", \"LINUX\", \"MACOS\"})\n+    public void test_platformOption(OperatingSystem os) {\n+\n+        var pred = StandardOption.platformOption(os);\n+\n+        var options = StandardOption.options().stream().filter(option -> {\n+            return pred.test(option.spec());\n+        }).map(Option::id).toList();\n+\n+        \/\/ Test some that should be in the set\n+        assertTrue(options.contains(StandardOption.NAME.id()));\n+        assertTrue(options.contains(StandardOption.INSTALL_DIR.id()));\n+\n+        switch (os) {\n+            case WINDOWS -> {\n+                assertTrue(options.contains(StandardOption.WIN_CONSOLE_HINT.id()));\n+                assertFalse(options.contains(StandardOption.LINUX_MENU_GROUP.id()));\n+                assertFalse(options.contains(StandardOption.MAC_APP_CATEGORY.id()));\n+            }\n+            case LINUX -> {\n+                assertFalse(options.contains(StandardOption.WIN_CONSOLE_HINT.id()));\n+                assertTrue(options.contains(StandardOption.LINUX_MENU_GROUP.id()));\n+                assertFalse(options.contains(StandardOption.MAC_APP_CATEGORY.id()));\n+            }\n+            case MACOS -> {\n+                assertFalse(options.contains(StandardOption.WIN_CONSOLE_HINT.id()));\n+                assertFalse(options.contains(StandardOption.LINUX_MENU_GROUP.id()));\n+                assertTrue(options.contains(StandardOption.MAC_APP_CATEGORY.id()));\n+            }\n+            default -> {\n+                throw new AssertionError();\n+            }\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test_ARGUMENTS(String value, List<String> expectedTokens) {\n+\n+        var spec = StandardOption.ARGUMENTS.getOption().spec();\n+\n+        var result = spec.converter().orElseThrow().convert(spec.name(), StringToken.of(value));\n+\n+        assertEquals(expectedTokens, List.of(result.map(String[].class::cast).orElseThrow()));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testAddLauncherOption(AddLauncherTestSpec testSpec, @TempDir Path workDir) throws IOException {\n+        testSpec.test(workDir);\n+    }\n+\n+    @Disabled\n+    @Test\n+    public void printMarkdownOptionTable() {\n+        OptionSpecFormatter.groupByOption(System.out::println,\n+                StandardOption.options().stream().map(Option::spec).toList());\n+    }\n+\n+    @Disabled\n+    @Test\n+    public void updateMarkdownOptionTable() throws IOException {\n+        try (var sink = Files.newBufferedWriter(GOLDEN_JPACKAGE_OPTIONS_MD); var pw = new PrintWriter(sink)) {\n+            OptionSpecFormatter.groupByOption(pw::println,\n+                    StandardOption.options().stream().map(Option::spec).toList());\n+        }\n+    }\n+\n+    @Test\n+    public void verifyOptions() throws IOException {\n+\n+        List<String> optionTable = new ArrayList<>();\n+\n+        OptionSpecFormatter.groupByOption(optionTable::add,\n+                StandardOption.options().stream().map(Option::spec).toList());\n+\n+        var expectedOptionTable = Files.readAllLines(GOLDEN_JPACKAGE_OPTIONS_MD);\n+\n+        assertEquals(expectedOptionTable, optionTable);\n+    }\n+\n+    private static Collection<Arguments> test_ARGUMENTS() {\n+        return List.of(\n+                Arguments.of(\"abc\", List.of(\"abc\")),\n+                Arguments.of(\"a b c\", List.of(\"a\", \"b\", \"c\")),\n+                Arguments.of(\"a=10 -Dorg.acme.name='John Smith' c=\\\\\\\"foo\\\\\\\"\", List.of(\"a=10\", \"-Dorg.acme.name=John Smith\", \"c=\\\"foo\\\"\")),\n+                Arguments.of(\"\\\"\\\"\", List.of(\"\")),\n+                Arguments.of(\" \", List.of()),\n+                Arguments.of(\"\", List.of())\n+        );\n+    }\n+\n+\n+    record AddLauncherTestSpec(Optional<AdditionalLauncher> expected, List<String> expectedErrors, Optional<String> optionValue) {\n+        AddLauncherTestSpec {\n+            if (expected.isEmpty() == expectedErrors.isEmpty()) {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        void test(Path workDir) throws IOException {\n+            final List<String> args = new ArrayList<>();\n+            args.add(StandardOption.ADD_LAUNCHER_INTERNAL.getSpec().name().formatForCommandLine());\n+            optionValue.ifPresent(args::add);\n+            if (optionValue.isEmpty()) {\n+                var path = workDir.resolve(expected.orElseThrow().propertyFile());\n+                Files.createDirectories(path.getParent());\n+                Files.createFile(path);\n+                expected.map(v -> v.name() + \"=\" + path).ifPresent(args::add);\n+            }\n+\n+            final var result = new JOptSimpleOptionsBuilder().options(StandardOption.ADD_LAUNCHER_INTERNAL).create()\n+                    .apply(args.toArray(String[]::new))\n+                    .flatMap(OptionsBuilder::convertedOptions).map(ConvertedOptionsBuilder::create);\n+\n+            if (expectedErrors.isEmpty()) {\n+                final var cmdline = result.orElseThrow();\n+                assertEquals(expected.map(List::of).orElseGet(List::of), Stream.of(StandardOption.ADD_LAUNCHER_INTERNAL.getFrom(cmdline)).map(v -> {\n+                    if (optionValue.isEmpty()) {\n+                        return new AdditionalLauncher(v.name(), workDir.relativize(v.propertyFile()));\n+                    } else {\n+                        return v;\n+                    }\n+                }).toList());\n+            } else {\n+                assertEquals(expectedErrors.stream().toList(), result.errors().stream().map(Exception::getMessage).toList());\n+            }\n+        }\n+\n+        static final class Builder {\n+\n+            AddLauncherTestSpec create() {\n+                return new AddLauncherTestSpec(Optional.ofNullable(expected), expectedErrors, Optional.ofNullable(optionValue));\n+            }\n+\n+            Builder expect(String name, String path) {\n+                expected = new AdditionalLauncher(name, Path.of(path));\n+                return this;\n+            }\n+\n+            Builder expectErrors(String... v) {\n+                expectedErrors.addAll(List.of(v));\n+                return this;\n+            }\n+\n+\/\/            Builder expectMalformedError(String v) {\n+\/\/                Objects.requireNonNull(v);\n+\/\/                return optionValue(v).expectErrors(I18N.format(\"error.paramater-add-launcher-malformed\", v, \"--add-launcher\"));\n+\/\/            }\n+\n+            Builder optionValue(String v) {\n+                optionValue = v;\n+                return this;\n+            }\n+\n+            private AdditionalLauncher expected;\n+            private List<String> expectedErrors = new ArrayList<>();\n+            private String optionValue;\n+        }\n+    }\n+\n+\n+    private static Collection<AddLauncherTestSpec> testAddLauncherOption() {\n+        return Stream.of(\n+                buildAddLauncherTest().expect(\"foo\", \"some.properties\"),\n+                buildAddLauncherTest().expect(\"foo\", \"a\/b\/some.properties\").expect(\"bar\", \"=\"),\n+                buildAddLauncherTest().expect(\"a\", \"a.properties\").expect(\"a\", \"b.properties\"),\n+                buildAddLauncherTest().optionValue(\"some\").expectErrors(I18N.format(\"ERR_NoAddLauncherName\")),\n+                buildAddLauncherTest().optionValue(\"\").expectErrors(I18N.format(\"ERR_NoAddLauncherName\")),\n+                buildAddLauncherTest().optionValue(\"=\").expectErrors(I18N.format(\"ERR_InvalidSLName\", \"\")),\n+                buildAddLauncherTest().optionValue(\"a=\").expectErrors(I18N.format(\"error.paramater-add-launcher-not-file\", \"\", \"a\")),\n+                buildAddLauncherTest().optionValue(\"=a\").expectErrors(I18N.format(\"ERR_InvalidSLName\", \"\")),\n+                \/\/ Not a path\n+                buildAddLauncherTest().optionValue(\"foo=*\").expectErrors(I18N.format(\"error.paramater-add-launcher-not-file\", \"*\", \"foo\")),\n+                \/\/ The path is a directory\n+                buildAddLauncherTest().optionValue(\"foo=.\").expectErrors(I18N.format(\"error.paramater-add-launcher-not-file\", \".\", \"foo\")),\n+                \/\/ The path doesn't exist\n+                buildAddLauncherTest().optionValue(\"Foo=foo\/bar\/buz\/111.z\").expectErrors(I18N.format(\"error.paramater-add-launcher-not-file\", \"foo\/bar\/buz\/111.z\", \"Foo\"))\n+        ).map(AddLauncherTestSpec.Builder::create).toList();\n+    }\n+\n+    private static AddLauncherTestSpec.Builder buildAddLauncherTest() {\n+        return new AddLauncherTestSpec.Builder();\n+    }\n+\n+\n+    record LauncherShortcutTestSpec(OptionValue<LauncherShortcut> option, Optional<LauncherShortcut> expected, List<String> expectedErrors, boolean propertyFile, Optional<String> optionValue) {\n+        LauncherShortcutTestSpec {\n+            Objects.requireNonNull(option);\n+            if (expected.isEmpty() == expectedErrors.isEmpty()) {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        void test() {\n+            final List<String> args = new ArrayList<>();\n+            args.add(option.getSpec().name().formatForCommandLine());\n+            optionValue.ifPresent(args::add);\n+\n+            final var builder = new JOptSimpleOptionsBuilder().options(option);\n+            if (propertyFile) {\n+                builder.optionSpecMapper(spec -> {\n+                    return new StandardOptionContext().forFile(DUMMY_PROPERTY_FILE).mapOptionSpec(spec);\n+                });\n+            }\n+\n+            final var result = builder.create()\n+                    .apply(args.toArray(String[]::new))\n+                    .flatMap(OptionsBuilder::convertedOptions).map(ConvertedOptionsBuilder::create);\n+\n+            if (expectedErrors.isEmpty()) {\n+                assertEquals(expected.orElseThrow(), option.getFrom(result.orElseThrow()));\n+            } else {\n+                assertEquals(expectedErrors.stream().toList(), result.errors().stream().map(Exception::getMessage).toList());\n+            }\n+        }\n+\n+        static final class Builder {\n+\n+            LauncherShortcutTestSpec create() {\n+                var theExpected = Optional.ofNullable(expected);\n+                return new LauncherShortcutTestSpec(\n+                        option,\n+                        theExpected,\n+                        theExpected.map(v -> {\n+                            return List.<String>of();\n+                        }).orElseGet(() -> {\n+                            if (propertyFile) {\n+                                return List.of(I18N.format(\"error.properties-paramater-not-launcher-shortcut-dir\",\n+                                        optionValue, option.getSpec().name().name(), DUMMY_PROPERTY_FILE));\n+                            } else {\n+                                return List.of(I18N.format(\"error.invalid-option-value\", optionValue, option.getSpec().name().formatForCommandLine()));\n+                            }\n+                        }), propertyFile, Optional.ofNullable(optionValue));\n+            }\n+\n+            Builder option(OptionValue<LauncherShortcut> v) {\n+                option = v;\n+                return this;\n+            }\n+\n+            Builder expect(LauncherShortcut v) {\n+                expected = v;\n+                if (expected != null) {\n+                    optionValue(v.startupDirectory().map(LauncherShortcutStartupDirectory::asStringValue).orElse(null));\n+                } else {\n+                    optionValue(null);\n+                }\n+                return this;\n+            }\n+\n+            Builder expect(LauncherShortcutStartupDirectory v) {\n+                return expect(new LauncherShortcut(v));\n+            }\n+\n+            Builder propertyFile(boolean v) {\n+                propertyFile = v;\n+                return this;\n+            }\n+\n+            Builder optionValue(String v) {\n+                optionValue = v;\n+                return this;\n+            }\n+\n+\n+            OptionValue<LauncherShortcut> option;\n+            private boolean propertyFile;\n+            private LauncherShortcut expected;\n+            private String optionValue;\n+        }\n+\n+        private static final Path DUMMY_PROPERTY_FILE = Path.of(\"foo.properties\");\n+    }\n+\n+\n+    private static Collection<LauncherShortcutTestSpec> testLauncherShortcutOptions() {\n+        return Stream.of(\n+                buildLauncherShortcutTest().expect(LauncherShortcutStartupDirectory.DEFAULT).optionValue(null),\n+                buildLauncherShortcutTest().expect(LauncherShortcutStartupDirectory.APP_DIR),\n+                buildLauncherShortcutTest().expect(LauncherShortcutStartupDirectory.DEFAULT).propertyFile(true),\n+                buildLauncherShortcutTest().expect(LauncherShortcutStartupDirectory.APP_DIR).propertyFile(true),\n+                buildLauncherShortcutTest().expect(new LauncherShortcut()).optionValue(\"false\").propertyFile(true),\n+                buildLauncherShortcutTest().optionValue(LauncherShortcutStartupDirectory.DEFAULT.asStringValue()),\n+                buildLauncherShortcutTest().optionValue(\"false\"),\n+                buildLauncherShortcutTest().optionValue(\"\"),\n+\/\/                buildLauncherShortcutTest().optionValue(\"\").propertyFile(true),\n+                buildLauncherShortcutTest().expect(new LauncherShortcut()).optionValue(\"\").propertyFile(true),\n+                buildLauncherShortcutTest().optionValue(\"bar\"),\n+\/\/                buildLauncherShortcutTest().optionValue(\"bar\").propertyFile(true)\n+                buildLauncherShortcutTest().expect(new LauncherShortcut()).optionValue(\"bar\").propertyFile(true)\n+        ).map(builder -> {\n+            return Stream.of(\n+                    StandardOption.LINUX_SHORTCUT_HINT,\n+                    StandardOption.WIN_MENU_HINT,\n+                    StandardOption.WIN_SHORTCUT_HINT\n+            ).map(builder::option).map(LauncherShortcutTestSpec.Builder::create);\n+        }).flatMap(x -> x).toList();\n+    }\n+\n+    private static LauncherShortcutTestSpec.Builder buildLauncherShortcutTest() {\n+        return new LauncherShortcutTestSpec.Builder();\n+    }\n+\n+    private static final class OptionSpecFormatter {\n+        static void groupByOption(Consumer<String>sink, Collection<? extends OptionSpec<?>> specs) {\n+            sink.accept(\"| Option | Scope | With runtime installer | With predefined app image | Recognized in add launcher .property file | Merge\");\n+            sink.accept(\"| --- | --- | :---: | :---: | :---: | :---: |\");\n+            for (final var spec : specs.stream().sorted(Comparator.comparing(v -> { return v.name().name(); })).toList()) {\n+                final var mods = filterByType(spec.scope(), BundlingOperationModifier.class);\n+                sink.accept(String.format(\"| %s | %s | %s | %s | %s | %s |\",\n+                        formatOptionNames(spec),\n+                        format(filterByType(spec.scope(), BundlingOperationOptionScope.class)),\n+                        (mods.contains(BundlingOperationModifier.BUNDLE_RUNTIME) ? \"x\" : \"\"),\n+                        (mods.contains(BundlingOperationModifier.BUNDLE_PREDEFINED_APP_IMAGE) ? \"x\" : \"\"),\n+                        (!filterByType(spec.scope(), LauncherProperty.class).isEmpty() ? \"x\" : \"\"),\n+                        spec.mergePolicy()\n+                ));\n+            }\n+        }\n+\n+        private static String formatOptionNames(OptionSpec<?> spec) {\n+            return spec.names().stream().map(OptionName::formatForCommandLine).collect(joining(\", \"));\n+        }\n+\n+        private static String format(OptionScope op) {\n+            return Optional.ofNullable(KNOWN_BUNDLING_OPERATIONS.get(op)).orElseGet(op::toString);\n+        }\n+\n+        private static String format(Set<OptionScope> ops) {\n+            final List<String> knownScopeLabels = new ArrayList<>();\n+\n+            for (;;) {\n+                final var theOps = ops;\n+                final var bestMatchedKnownScope = KNOWN_SCOPES.keySet().stream().map(knownGroup -> {\n+                    return Comm.compare(theOps, knownGroup);\n+                }).filter(comm -> {\n+                    return comm.unique2().isEmpty();\n+                }).max(Comparator.comparing(comm -> {\n+                    return comm.common().size();\n+                }));\n+\n+                if (bestMatchedKnownScope.isEmpty()) {\n+                    break;\n+                } else {\n+                    knownScopeLabels.add(KNOWN_SCOPES.get(bestMatchedKnownScope.orElseThrow().common()));\n+                    ops = bestMatchedKnownScope.orElseThrow().unique1();\n+                }\n+            }\n+\n+            return Stream.concat(\n+                    knownScopeLabels.stream(),\n+                    ops.stream().map(OptionSpecFormatter::format)\n+            ).sorted().collect(joining(\", \"));\n+        }\n+\n+        private static Set<OptionScope> filterByType(Collection<OptionScope> ops, Class<? extends OptionScope> filterType) {\n+            return ops.stream().filter(filterType::isInstance).collect(Collectors.toSet());\n+        }\n+\n+        private static final Map<OptionScope, String> KNOWN_BUNDLING_OPERATIONS = Map.of(\n+                StandardBundlingOperation.CREATE_WIN_APP_IMAGE, \"app-image-win\",\n+                StandardBundlingOperation.CREATE_LINUX_APP_IMAGE, \"app-image-linux\",\n+                StandardBundlingOperation.CREATE_MAC_APP_IMAGE, \"app-image-mac\",\n+                StandardBundlingOperation.CREATE_WIN_EXE, \"win-exe\",\n+                StandardBundlingOperation.CREATE_WIN_MSI, \"win-msi\",\n+                StandardBundlingOperation.CREATE_LINUX_RPM, \"linux-rpm\",\n+                StandardBundlingOperation.CREATE_LINUX_DEB, \"linux-deb\",\n+                StandardBundlingOperation.CREATE_MAC_PKG, \"mac-pkg\",\n+                StandardBundlingOperation.CREATE_MAC_DMG, \"mac-dmg\",\n+                StandardBundlingOperation.SIGN_MAC_APP_IMAGE, \"mac-sign\"\n+        );\n+\n+        private static final Map<Set<OptionScope>, String> KNOWN_SCOPES = Map.of(\n+                Set.copyOf(StandardBundlingOperation.CREATE_APP_IMAGE), \"app-image\",\n+                Set.copyOf(StandardBundlingOperation.WINDOWS), \"win\",\n+                Set.copyOf(StandardBundlingOperation.MACOS), \"mac\",\n+                Set.of(StandardBundlingOperation.CREATE_MAC_APP_IMAGE, StandardBundlingOperation.CREATE_MAC_DMG, StandardBundlingOperation.CREATE_MAC_PKG), \"mac-bundle\",\n+                Set.copyOf(StandardBundlingOperation.LINUX), \"linux\",\n+                Set.copyOf(StandardBundlingOperation.CREATE_NATIVE), \"native-bundle\",\n+                Set.copyOf(StandardBundlingOperation.CREATE_BUNDLE), \"bundle\",\n+                Set.of(StandardBundlingOperation.values()), \"all\"\n+        );\n+    }\n+\n+    private static final Path GOLDEN_JPACKAGE_OPTIONS_MD = TKit.TEST_SRC_ROOT.resolve(\n+            \"junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/jpackage-options.md\");\n+\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/StandardOptionTest.java","additions":646,"deletions":0,"binary":false,"changes":646,"status":"added"},{"patch":"@@ -0,0 +1,227 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.io.IOException;\n+import java.nio.file.DirectoryNotEmptyException;\n+import java.nio.file.Files;\n+import java.nio.file.NotDirectoryException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import jdk.jpackage.test.JUnitUtils.ExceptionPattern;\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.cli.Validator.ValidatingConsumerException;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+public class StandardValidatorTest {\n+\n+    @Test\n+    public void test_IS_DIRECTORY(@TempDir Path tempDir) throws IOException {\n+\n+        final var testee = StandardValidator.IS_DIRECTORY;\n+\n+        assertTrue(testee.test(tempDir));\n+        assertFalse(testee.test(tempDir.resolve(\"foo\")));\n+\n+        final var file = tempDir.resolve(\"foo\");\n+        Files.writeString(file, \"foo\");\n+\n+        assertFalse(testee.test(file));\n+        assertTrue(testee.test(tempDir));\n+\n+        assertThrowsExactly(NullPointerException.class, () -> testee.test(null));\n+    }\n+\n+    @Test\n+    public void test_IS_EXISTENT_NOT_DIRECTORY(@TempDir Path tempDir) throws IOException {\n+\n+        final var testee = StandardValidator.IS_EXISTENT_NOT_DIRECTORY;\n+\n+        assertFalse(testee.test(tempDir));\n+        assertFalse(testee.test(tempDir.resolve(\"foo\")));\n+\n+        final var file = tempDir.resolve(\"foo\");\n+        Files.writeString(file, \"foo\");\n+\n+        assertTrue(testee.test(file));\n+        assertFalse(testee.test(tempDir));\n+\n+        assertThrowsExactly(NullPointerException.class, () -> testee.test(null));\n+    }\n+\n+    @Test\n+    public void test_IS_DIRECTORY_OR_NON_EXISTENT(@TempDir Path tempDir) throws IOException {\n+\n+        final var testee = StandardValidator.IS_DIRECTORY_OR_NON_EXISTENT;\n+\n+        assertTrue(testee.test(tempDir));\n+        assertTrue(testee.test(tempDir.resolve(\"foo\")));\n+\n+        final var file = tempDir.resolve(\"foo\");\n+        Files.writeString(file, \"foo\");\n+\n+        assertFalse(testee.test(file));\n+        assertTrue(testee.test(tempDir));\n+\n+        assertThrowsExactly(NullPointerException.class, () -> testee.test(null));\n+    }\n+\n+    @Test\n+    public void test_IS_DIRECTORY_EMPTY_OR_NON_EXISTENT(@TempDir Path tempDir) throws IOException {\n+\n+        final var testee = StandardValidator.IS_DIRECTORY_EMPTY_OR_NON_EXISTENT;\n+\n+        assertDoesNotThrow(() -> testee.accept(tempDir));\n+        assertDoesNotThrow(() -> testee.accept(tempDir.resolve(\"foo\")));\n+\n+        final var file = tempDir.resolve(\"foo\");\n+        Files.writeString(file, \"foo\");\n+\n+        var cause = assertThrowsExactly(ValidatingConsumerException.class, () -> testee.accept(file)).getCause();\n+        assertEquals(NotDirectoryException.class, cause.getClass());\n+\n+        cause = assertThrowsExactly(ValidatingConsumerException.class, () -> testee.accept(tempDir)).getCause();\n+        assertEquals(DirectoryNotEmptyException.class, cause.getClass());\n+\n+        assertThrowsExactly(NullPointerException.class, () -> testee.accept(null));\n+    }\n+\n+    @Test\n+    public void test_IS_URL() {\n+\n+        final var testee = StandardValidator.IS_URL;\n+\n+        assertDoesNotThrow(() -> testee.accept(\"http:\/\/foo\"));\n+\n+        final var ex = assertThrowsExactly(ValidatingConsumerException.class, () -> testee.accept(\":\"));\n+\n+        assertNotNull(ex.getCause());\n+\n+        assertThrowsExactly(NullPointerException.class, () -> testee.accept(null));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test_IS_NAME_VALID_valid(String name) {\n+\n+        final var testee = StandardValidator.IS_NAME_VALID;\n+\n+        assertTrue(testee.test(name));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test_IS_NAME_VALID_invalid(String name) {\n+\n+        final var testee = StandardValidator.IS_NAME_VALID;\n+\n+        assertFalse(testee.test(name));\n+    }\n+\n+    @Test\n+    public void test_IS_NAME_VALID_null() {\n+\n+        final var testee = StandardValidator.IS_NAME_VALID;\n+\n+        assertThrowsExactly(NullPointerException.class, () -> testee.test(null));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"Foo\", \"1\", \"public\"})\n+    public void test_IS_CLASSNAME_valid(String classname) {\n+\n+        final var testee = StandardValidator.IS_CLASSNAME;\n+\n+        testee.accept(classname);\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"\", \"a\/b\"})\n+    public void test_IS_CLASSNAME_invalid(String classname) {\n+\n+        final var testee = StandardValidator.IS_CLASSNAME;\n+\n+        final var ex = assertThrowsExactly(ValidatingConsumerException.class, () -> testee.accept(classname));\n+\n+        assertTrue(new ExceptionPattern().isCauseInstanceOf(IllegalArgumentException.class).match(ex));\n+    }\n+\n+    @Test\n+    public void test_IS_CLASSNAME_null() {\n+\n+        final var testee = StandardValidator.IS_CLASSNAME;\n+\n+        assertThrowsExactly(NullPointerException.class, () -> testee.accept(null));\n+    }\n+\n+    private static Stream<Arguments> test_IS_NAME_VALID_valid() {\n+        List<String> data = new ArrayList<>();\n+        data.addAll(List.of(\n+                \"a\",\n+                \"a!\",\n+                \"name with space\"\n+        ));\n+\n+        if (!OperatingSystem.isWindows()) {\n+            data.addAll(List.of(\"a?\", \"*foo*\"));\n+        }\n+\n+        return data.stream().map(Arguments::of);\n+    }\n+\n+    private static Stream<Arguments> test_IS_NAME_VALID_invalid() {\n+        List<String> data = new ArrayList<>();\n+        data.addAll(List.of(\n+                \" \",\n+                \"a\\0b\",\n+                \"foo \",\n+                \"\",\n+                \"a\/b\",\n+                \"a\\\\b\",\n+                \"ab\\\\\",\n+                \"ab\/\",\n+                \"a%b\",\n+                \"a\\\"b\"\n+        ));\n+\n+        if (OperatingSystem.isWindows()) {\n+            data.addAll(List.of(\"a?\", \"*foo*\"));\n+        }\n+\n+        return data.stream().map(Arguments::of);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/StandardValidatorTest.java","additions":227,"deletions":0,"binary":false,"changes":227,"status":"added"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Objects;\n+import jdk.jpackage.internal.model.LauncherShortcut;\n+import jdk.jpackage.internal.model.LauncherShortcutStartupDirectory;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+public class StandardValueConverterTest {\n+\n+    @Test\n+    public void test_identityConv() {\n+\n+        final var testee = StandardValueConverter.identityConv();\n+\n+        assertEquals(\"foo\", testee.convert(\"foo\"));\n+    }\n+\n+    @Test\n+    public void testNullValue() {\n+        assertThrowsExactly(NullPointerException.class, () -> StandardValueConverter.identityConv().convert(null));\n+        assertThrowsExactly(NullPointerException.class, () -> StandardValueConverter.pathConv().convert(null));\n+        assertThrowsExactly(NullPointerException.class, () -> StandardValueConverter.uuidConv().convert(null));\n+        assertThrowsExactly(NullPointerException.class, () -> StandardValueConverter.booleanConv().convert(null));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_pathConv(boolean positive) {\n+\n+        final var testee = StandardValueConverter.pathConv();\n+\n+        if (positive) {\n+            assertEquals(Path.of(\"foo\"), testee.convert(\"foo\"));\n+        } else {\n+            final var ex = assertThrowsExactly(IllegalArgumentException.class, () -> testee.convert(\"\\0\"));\n+            assertNotNull(ex.getCause());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test_booleanConv(String value, Boolean expected) {\n+\n+        assertEquals(expected, StandardValueConverter.booleanConv().convert(value));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test_mainLauncherShortcutConv(String value, LauncherShortcut expected) {\n+\n+        assertEquals(expected, StandardValueConverter.mainLauncherShortcutConv().convert(value));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test_mainLauncherShortcutConv_invalid(String value) {\n+\n+        assertThrowsExactly(IllegalArgumentException.class, () -> StandardValueConverter.mainLauncherShortcutConv().convert(value));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test_addLauncherShortcutConv(String value, LauncherShortcut expected) {\n+\n+        assertEquals(expected, StandardValueConverter.addLauncherShortcutConv().convert(value));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    @Disabled(\"There is no invalid string value!\")\n+    public void test_addLauncherShortcutConv_invalid(String value) {\n+\n+        assertThrowsExactly(IllegalArgumentException.class, () -> StandardValueConverter.addLauncherShortcutConv().convert(value));\n+    }\n+\n+    private static List<Object[]> test_booleanConv() {\n+        return List.<Object[]>of(\n+                booleanConvTestCase(\"\", false),\n+                booleanConvTestCase(\"true\", true),\n+                booleanConvTestCase(\"True\", true),\n+                booleanConvTestCase(\"TRUE\", true),\n+                booleanConvTestCase(\"true2\", false),\n+                booleanConvTestCase(\"false\", false),\n+                booleanConvTestCase(\"false2\", false)\n+        );\n+    }\n+\n+    private static Object[] booleanConvTestCase(String value, boolean expected) {\n+        Objects.requireNonNull(value);\n+        Objects.requireNonNull(expected);\n+        return new Object[] { value, expected };\n+    }\n+\n+    private static List<Object[]> test_mainLauncherShortcutConv() {\n+        return List.<Object[]>of(\n+                launcherShortcutConvTestCase(\"app-dir\", new LauncherShortcut(LauncherShortcutStartupDirectory.APP_DIR))\n+        );\n+    }\n+\n+    private static List<Arguments> test_mainLauncherShortcutConv_invalid() {\n+        return List.of(\n+                Arguments.of(\"true\"),\n+                Arguments.of(\"false\"),\n+                Arguments.of(\"App-dir\"),\n+                Arguments.of(\"APP-DIR\")\n+        );\n+    }\n+\n+    private static List<Object[]> test_addLauncherShortcutConv() {\n+        return List.<Object[]>of(\n+                launcherShortcutConvTestCase(\"app-dir\", new LauncherShortcut(LauncherShortcutStartupDirectory.APP_DIR)),\n+                launcherShortcutConvTestCase(\"true\", new LauncherShortcut(LauncherShortcutStartupDirectory.DEFAULT)),\n+                launcherShortcutConvTestCase(\"false\", new LauncherShortcut()),\n+                launcherShortcutConvTestCase(\"APP-DIR\", new LauncherShortcut())\n+        );\n+    }\n+\n+    private static List<Arguments> test_addLauncherShortcutConv_invalid() {\n+        return List.of(\n+        );\n+    }\n+\n+    private static Object[] launcherShortcutConvTestCase(String value, LauncherShortcut expected) {\n+        Objects.requireNonNull(value);\n+        Objects.requireNonNull(expected);\n+        return new Object[] { value, expected };\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/StandardValueConverterTest.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+\n+import org.junit.jupiter.api.Test;\n+\n+public class StringTokenTest {\n+\n+    @Test\n+    public void test() {\n+        assertToken(\"abc\", \"a\", StringToken.of(\"abc\", \"a\"));\n+        assertToken(\"abc\", \"\", StringToken.of(\"abc\", \"\"));\n+        assertToken(\"abc\", \"abc\", StringToken.of(\"abc\"));\n+        assertToken(\"\", \"\", StringToken.of(\"\"));\n+        assertToken(\"abc\", \"bc\", StringToken.of(\"abc\", \"bc\"));\n+\n+        assertThrowsExactly(IllegalArgumentException.class, () -> StringToken.of(\"abc\", \"d\"));\n+        assertThrowsExactly(IllegalArgumentException.class, () -> StringToken.of(\"abc\", \"cb\"));\n+        assertThrowsExactly(IllegalArgumentException.class, () -> StringToken.of(\"abc\", \"abcd\"));\n+    }\n+\n+    private static void assertToken(String expectedTokenizedString, String expectedValue, StringToken token) {\n+        assertEquals(expectedTokenizedString, token.tokenizedString());\n+        assertEquals(expectedValue, token.value());\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/StringTokenTest.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.lang.reflect.Array;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.StreamSupport;\n+import jdk.jpackage.test.JUnitUtils;\n+\n+final class TestUtils {\n+\n+    private TestUtils() {\n+    }\n+\n+    static UnaryOperator<OptionValueExceptionFactory<? extends RuntimeException>> recordExceptions(Collection<OptionFailure> sink) {\n+        return exceptionFactory -> {\n+            return new RecordingExceptionFactory(exceptionFactory, sink::add);\n+        };\n+    }\n+\n+    static <T> Consumer<Validator.Builder<T, RuntimeException>> configureValidator() {\n+        return builder -> {\n+            builder.exceptionFactory(DEFAULT_EXCEPTION_FACTORY).formatString(DEFAULT_EXCEPTION_MESSAGE_FORMAT_STRING);\n+        };\n+    }\n+\n+    static <T> Consumer<Validator.Builder<T, Exception>> configureCheckedValidator() {\n+        return builder -> {\n+            builder.exceptionFactory(DEFAULT_EXCEPTION_FACTORY).formatString(DEFAULT_EXCEPTION_MESSAGE_FORMAT_STRING);\n+        };\n+    }\n+\n+    static <T> Consumer<OptionValueConverter.Builder<T>> configureConverter() {\n+        return builder -> {\n+            builder.exceptionFactory(DEFAULT_EXCEPTION_FACTORY).formatString(DEFAULT_EXCEPTION_MESSAGE_FORMAT_STRING);\n+        };\n+    }\n+\n+    static void assertExceptionEquals(Exception expected, Exception actual) {\n+        assertEquals(JUnitUtils.exceptionAsPropertyMap(expected), JUnitUtils.exceptionAsPropertyMap(actual));\n+    }\n+\n+    static void assertExceptionListEquals(Collection<? extends Exception> expected, Collection<? extends Exception> actual) {\n+        assertEquals(\n+                expected.stream().map(JUnitUtils::exceptionAsPropertyMap).toList(),\n+                actual.stream().map(JUnitUtils::exceptionAsPropertyMap).toList()\n+        );\n+    }\n+\n+\n+    static Function<String, String[]> splitOrEmpty(String splitRegexp) {\n+        Objects.requireNonNull(splitRegexp);\n+        return str -> {\n+            if (str.isEmpty()) {\n+                return new String[0];\n+            } else {\n+                return str.split(splitRegexp);\n+            }\n+        };\n+    }\n+\n+    static <T> List<T[]> arrayElements(Class<? extends T> elementType, Iterable<T> elements) {\n+        Objects.requireNonNull(elementType);\n+        return StreamSupport.stream(elements.spliterator(), false).map(e -> {\n+            @SuppressWarnings(\"unchecked\")\n+            final var arr = (T[])Array.newInstance(elementType, e == null ? 0 : 1);\n+            if (e != null) {\n+                Array.set(arr, 0, e);\n+            }\n+            return arr;\n+        }).toList();\n+    }\n+\n+\n+    record OptionFailure(OptionName optionName, StringToken optionValue, Optional<Exception> exception) {\n+        OptionFailure {\n+            Objects.requireNonNull(optionName);\n+            Objects.requireNonNull(optionValue);\n+            Objects.requireNonNull(exception);\n+        }\n+\n+        OptionFailure(OptionName optionName, StringToken optionValue) {\n+            this(optionName, optionValue, Optional.empty());\n+        }\n+\n+        OptionFailure(String optionName, StringToken optionValue) {\n+            this(OptionName. of(optionName), optionValue);\n+        }\n+\n+        OptionFailure(OptionName optionName, String optionValue) {\n+            this(optionName, StringToken.of(optionValue));\n+        }\n+\n+        OptionFailure(String optionName, String optionValue) {\n+            this(OptionName. of(optionName), optionValue);\n+        }\n+\n+        OptionFailure withoutException() {\n+            return exception.map(_ -> new OptionFailure(optionName, optionValue, Optional.empty())).orElse(this);\n+        }\n+\n+        static Comparator<OptionFailure> compareNameAndValue() {\n+            return Comparator.comparing(OptionFailure::optionName).thenComparing(v -> {\n+                return v.optionValue().value();\n+            }).thenComparing(v -> {\n+                return v.optionValue().tokenizedString();\n+            });\n+        }\n+    }\n+\n+\n+    static final class TestException extends RuntimeException {\n+\n+        TestException(String msg) {\n+            super(msg);\n+        }\n+\n+        TestException(String msg, Throwable cause) {\n+            super(msg, cause);\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+\n+    private record RecordingExceptionFactory(OptionValueExceptionFactory<? extends RuntimeException> factory,\n+            Consumer<OptionFailure> sink) implements OptionValueExceptionFactory<RuntimeException> {\n+\n+        RecordingExceptionFactory {\n+            Objects.requireNonNull(factory);\n+            Objects.requireNonNull(sink);\n+        }\n+\n+        @Override\n+        public RuntimeException create(OptionName optionName, StringToken optionValue, String formatString, Optional<Exception> cause) {\n+            final var ex = factory.create(optionName, optionValue, formatString, cause);\n+            sink.accept(new OptionFailure(optionName, optionValue, Optional.of(ex)));\n+            return ex;\n+        }\n+    }\n+\n+    private static final String DEFAULT_EXCEPTION_MESSAGE_FORMAT_STRING = \"Option %s: bad substring [%s] in string [%s]\";\n+\n+    private static final OptionValueExceptionFactory<? extends RuntimeException> DEFAULT_EXCEPTION_FACTORY = OptionValueExceptionFactory.build(TestException::new)\n+            .formatArgumentsTransformer((String formattedOptionName, StringToken optionValue) -> {\n+                return new String[] { formattedOptionName, optionValue.value(), optionValue.tokenizedString() };\n+            })\n+            .messageFormatter(String::format)\n+            .create();\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/TestUtils.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static java.util.stream.Collectors.toUnmodifiableSet;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.Optional;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.model.BundlingEnvironment;\n+import jdk.jpackage.internal.model.BundlingOperationDescriptor;\n+import jdk.jpackage.test.JUnitUtils.ExceptionPattern;\n+import org.junit.jupiter.api.Test;\n+\n+public class UtilsTest {\n+\n+    @Test\n+    public void testInvalidOption() {\n+        var errors = buildParser().create().apply(new String[] {\"--foo\"}).errors();\n+        assertEquals(1, errors.size());\n+\n+        assertTrue(new ExceptionPattern()\n+                .isInstanceOf(Utils.ParseException.class)\n+                .hasMessage(I18N.format(\"ERR_InvalidOption\", \"--foo\"))\n+                .match(errors.iterator().next()));\n+    }\n+\n+    @Test\n+    public void testMissingValueOption() {\n+        var errors = buildParser().create().apply(new String[] {\"--name\"}).errors();\n+        assertEquals(1, errors.size());\n+\n+        assertTrue(new ExceptionPattern()\n+                .isInstanceOf(Utils.ParseException.class)\n+                .hasMessage(I18N.format(\"ERR_InvalidOption\", \"--name\"))\n+                .match(errors.iterator().next()));\n+    }\n+\n+    @Test\n+    public void test_getOptionsWithSpecs() {\n+\n+        var options = Utils.getOptionsWithSpecs(UtilsTest.class).map(OptionValue::getOption).collect(toUnmodifiableSet());\n+\n+        assertEquals(2, options.size());\n+\n+        assertFalse(options.contains(A.getOption()));\n+        assertTrue(options.contains(B.getOption()));\n+        assertTrue(options.contains(C.getOption()));\n+    }\n+\n+    private static final OptionValue<String> A = dummyOptionValue(\"a\");\n+\n+    static final OptionValue<String> B = dummyOptionValue(\"b\");\n+\n+    public static final OptionValue<String> C = dummyOptionValue(\"c\");\n+\n+    private static OptionValue<String> dummyOptionValue(String name) {\n+        return OptionSpecBuilder.create(String.class).name(name).scope(new OptionScope() {}).create();\n+    }\n+\n+    private static JOptSimpleOptionsBuilder buildParser() {\n+        return Utils.buildParser(OperatingSystem.LINUX, new BundlingEnvironment() {\n+            @Override\n+            public Optional<BundlingOperationDescriptor> defaultOperation() {\n+                return Optional.empty();\n+            }\n+        });\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/UtilsTest.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,284 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static jdk.jpackage.internal.cli.TestUtils.assertExceptionListEquals;\n+import static jdk.jpackage.internal.cli.TestUtils.configureCheckedValidator;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotSame;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import jdk.jpackage.internal.cli.TestUtils.TestException;\n+import jdk.jpackage.internal.cli.Validator.ParsedValue;\n+import jdk.jpackage.internal.cli.Validator.ValidatingConsumerException;\n+import jdk.jpackage.internal.cli.Validator.ValidatorException;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class ValidatorTest {\n+\n+    enum ValidatorType {\n+        PREDICATE,\n+        CONSUMER\n+    }\n+\n+\n+    @ParameterizedTest\n+    @EnumSource(ValidatorType.class)\n+    public void test(ValidatorType type) {\n+\n+        final Validator.Builder<Object, Exception> builder = Validator.build();\n+\n+        switch (type) {\n+            case CONSUMER -> builder.consumer(_ -> {});\n+            case PREDICATE -> builder.predicate(_ -> true);\n+            default -> {\n+                throw new UnsupportedOperationException();\n+            }\n+        }\n+\n+        final var validator = builder.mutate(configureCheckedValidator()).create();\n+\n+        final var optionName = OptionName.of(\"obj\");\n+        final var optionValue = ParsedValue.create(new Object(), StringToken.of(\"foo\"));\n+        assertEquals(List.of(), validator.validate(optionName, optionValue));\n+    }\n+\n+    @Test\n+    public void test_predicate_negative() {\n+\n+        final var validator =  Validator.build().predicate(_ -> false).mutate(configureCheckedValidator()).create();\n+\n+        final var optionName = OptionName.of(\"obj\");\n+        final var optionValue = ParsedValue.create(new Object(), StringToken.of(\"foo\"));\n+\n+        final var exceptions = validator.validate(optionName, optionValue);\n+        assertExceptionListEquals(List.of(new TestException(\"Option --obj: bad substring [foo] in string [foo]\")), exceptions);\n+    }\n+\n+\n+    enum ValidatorConsumerType {\n+        CONSUMER_IllegalArgumentException,\n+        CONSUMER_ValidatingConsumerException\n+    }\n+\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test_consumer_negative(ValidatorConsumerType type, boolean withCause) {\n+\n+        final Validator.Builder<Object, Exception> builder = Validator.build();\n+\n+        final Exception cause;\n+        if (withCause) {\n+            cause = new FooException(\"foo cause\");\n+        } else {\n+            cause = null;\n+        }\n+\n+        final RuntimeException validatorException;\n+        final Exception expectedCause;\n+\n+        switch (type) {\n+            case CONSUMER_IllegalArgumentException -> {\n+                validatorException = new IllegalArgumentException(\"Invalid value\", cause);\n+                expectedCause = validatorException;\n+            }\n+\n+            case CONSUMER_ValidatingConsumerException -> {\n+                if (cause != null) {\n+                    validatorException = new ValidatingConsumerException(\"Invalid value\", cause);\n+                    expectedCause = cause;\n+                } else {\n+                    assertThrows(NullPointerException.class, () -> {\n+                        new ValidatingConsumerException(\"Invalid value\", cause);\n+                    });\n+                    return;\n+                }\n+            }\n+\n+            default -> {\n+                throw new UnsupportedOperationException();\n+            }\n+        }\n+\n+        final var validator = builder.consumer(_ -> {\n+            throw validatorException;\n+        }).mutate(configureCheckedValidator()).create();\n+\n+        final var optionName = OptionName.of(\"obj\");\n+        final var optionValue = ParsedValue.create(new Object(), StringToken.of(\"foo\"));\n+\n+        final var exceptions = validator.validate(optionName, optionValue);\n+        assertExceptionListEquals(List.of(new TestException(\"Option --obj: bad substring [foo] in string [foo]\", expectedCause)), exceptions);\n+    }\n+\n+    @Test\n+    public void testBuilderWithoutExceptionOrFormatStringFactory() {\n+\n+        Supplier<Validator.Builder<String, RuntimeException>> build = () -> {\n+            return Validator.<String, RuntimeException>build().predicate(_ -> true);\n+        };\n+\n+        build.get().create();\n+        build.get().formatString(null).create();\n+        assertThrowsExactly(NullPointerException.class, build.get().formatString(\"foo\")::create);\n+        assertThrowsExactly(NullPointerException.class, build.get().formatString(\"\")::create);\n+        assertThrowsExactly(NullPointerException.class, build.get().formatString(null).exceptionFactory(OptionValueExceptionFactory.unreachable())::create);\n+    }\n+\n+    @Test\n+    public void testBuilderCopy() {\n+\n+        var builder = Validator.<String, RuntimeException>build()\n+                .predicate(_ -> true)\n+                .formatString(\"foo\")\n+                .exceptionFactory(OptionValueExceptionFactory.unreachable());\n+\n+        var copy = builder.copy();\n+\n+        assertSame(builder.consumer().orElse(null), copy.consumer().orElse(null));\n+        assertSame(builder.predicate().orElse(null), copy.predicate().orElse(null));\n+        assertSame(builder.exceptionFactory().orElse(null), copy.exceptionFactory().orElse(null));\n+        assertSame(builder.formatString().orElse(null), copy.formatString().orElse(null));\n+\n+        builder.consumer(_ -> {});\n+\n+        copy = builder.copy();\n+\n+        assertSame(builder.consumer().orElse(null), copy.consumer().orElse(null));\n+        assertSame(builder.predicate(), copy.predicate());\n+        assertSame(builder.exceptionFactory().orElse(null), copy.exceptionFactory().orElse(null));\n+        assertSame(builder.formatString().orElse(null), copy.formatString().orElse(null));\n+\n+        copy.predicate(_ -> false);\n+\n+        assertNotSame(builder.consumer(), copy.consumer());\n+        assertNotSame(builder.predicate(), copy.predicate());\n+    }\n+\n+    @Test\n+    public void test_andThen() {\n+\n+        Function<String, Validator<String, Exception>> createFailingValidator = exceptionMessage -> {\n+            Objects.requireNonNull(exceptionMessage);\n+            var exceptionFactory = OptionValueExceptionFactory.build().ctor(TestException::new).messageFormatter((_, _) -> {\n+                return exceptionMessage;\n+            }).create();\n+\n+            return Validator.<String, Exception>build()\n+                    .predicate(_ -> false)\n+                    .formatString(\"\")\n+                    .exceptionFactory(exceptionFactory).create();\n+        };\n+\n+        Function<Validator<String, ? extends Exception>, List<? extends Exception>> validate = validator -> {\n+            return validator.validate(OptionName.of(\"a\"), ParsedValue.create(\"str\", StringToken.of(\"str\")));\n+        };\n+\n+        var pass = Validator.<String, RuntimeException>build().predicate(_ -> true).create();\n+\n+        var foo = createFailingValidator.apply(\"foo\");\n+        var bar = createFailingValidator.apply(\"bar\");\n+        var buz = createFailingValidator.apply(\"buz\");\n+\n+        assertExceptionListEquals(List.of(\n+                new TestException(\"foo\"),\n+                new TestException(\"bar\"),\n+                new TestException(\"buz\")\n+        ),  validate.apply(foo.andThen(bar).andThen(pass).andThen(buz)));\n+\n+        assertExceptionListEquals(List.of(\n+                new TestException(\"bar\"),\n+                new TestException(\"buz\"),\n+                new TestException(\"foo\")\n+        ),  validate.apply(pass.andThen(bar).andThen(buz).andThen(foo)));\n+\n+        assertExceptionListEquals(List.of(\n+                new TestException(\"foo\"),\n+                new TestException(\"foo\")\n+        ),  validate.apply(foo.andThen(foo)));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(ValidatorType.class)\n+    public void testValidatorException(ValidatorType type) {\n+\n+        final Validator.Builder<String, Exception> builder = Validator.build();\n+\n+        switch (type) {\n+            case CONSUMER -> builder.consumer(_ -> {\n+                throw VALITDATOR_EXCEPTION;\n+            });\n+\n+            case PREDICATE -> builder.predicate(_ -> {\n+                throw VALITDATOR_EXCEPTION;\n+            });\n+\n+            default -> {\n+                throw new UnsupportedOperationException();\n+            }\n+        }\n+\n+        final var validator = builder.mutate(configureCheckedValidator()).create();\n+\n+        final var token = StringToken.of(\"foo\");\n+        final var ex = assertThrowsExactly(ValidatorException.class, () -> {\n+            validator.validate(OptionName.of(\"foo\"), ParsedValue.create(token.value(), token));\n+        });\n+\n+        assertSame(VALITDATOR_EXCEPTION, ex.getCause());\n+    }\n+\n+    private static List<Object[]> test_consumer_negative() {\n+        final List<Object[]> data = new ArrayList<>();\n+        for (var type : ValidatorConsumerType.values()) {\n+            for (var withCause : List.of(true, false)) {\n+                data.add(new Object[] { type, withCause });\n+            }\n+        }\n+        return data;\n+    }\n+\n+\n+    static final class FooException extends Exception {\n+\n+        FooException(String msg) {\n+            super(msg);\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+\n+    static final RuntimeException VALITDATOR_EXCEPTION = new RuntimeException(\"Always fail\");\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/ValidatorTest.java","additions":284,"deletions":0,"binary":false,"changes":284,"status":"added"},{"patch":"@@ -0,0 +1,197 @@\n+Usage: jpackage <options>\n+\n+Sample usages:\n+--------------\n+    Generate an application package suitable for the host system:\n+        For a modular application:\n+            jpackage -n name -p modulePath -m moduleName\/className\n+        For a non-modular application:\n+            jpackage -i inputDir -n name \\\n+                --main-class className --main-jar myJar.jar\n+        From a pre-built application image:\n+            jpackage -n name --app-image appImageDir\n+\n+    Generate an application image:\n+        For a modular application:\n+            jpackage --type app-image -n name -p modulePath \\\n+                -m moduleName\/className\n+        For a non-modular application:\n+            jpackage --type app-image -i inputDir -n name \\\n+                --main-class className --main-jar myJar.jar\n+        To provide your own options to jlink, run jlink separately:\n+            jlink --output appRuntimeImage -p modulePath \\\n+                --add-modules moduleName \\\n+                --no-header-files [<additional jlink options>...]\n+            jpackage --type app-image -n name \\\n+                -m moduleName\/className --runtime-image appRuntimeImage\n+\n+    Generate a Java runtime package:\n+        jpackage -n name --runtime-image <runtime-image>\n+\n+Generic Options:\n+  @<filename>\n+          Read options and\/or mode from a file\n+          This option can be used multiple times.\n+  --type -t <type>\n+          The type of package to create\n+          Valid values are: {\"app-image\", \"deb\", \"rpm\"}\n+          If this option is not specified a platform dependent\n+          default type will be created.\n+  --app-version <version>\n+          Version of the application and\/or package\n+  --copyright <copyright string>\n+          Copyright for the application\n+  --description <description string>\n+          Description of the application\n+  --dest -d <destination path>\n+          Path where generated output file is placed\n+          (absolute path or relative to the current directory)\n+          Defaults to the current working directory.\n+  --help -h -?\n+          Print the usage text with a list and description of each valid\n+          option for the current platform to the output stream, and exit\n+  --icon <file path>\n+          Path of the icon of the application package\n+          (absolute path or relative to the current directory)\n+  --name -n <name>\n+          Name of the application and\/or package\n+  --temp <directory path>\n+          Path of a new or empty directory used to create temporary files\n+          (absolute path or relative to the current directory)\n+          If specified, the temp dir will not be removed upon the task\n+          completion and must be removed manually.\n+          If not specified, a temporary directory will be created and\n+          removed upon the task completion.\n+  --vendor <vendor string>\n+          Vendor of the application\n+  --verbose\n+          Enables verbose output\n+  --version\n+          Print the product version to the output stream and exit.\n+\n+Options for creating the runtime image:\n+  --add-modules <module name>[,<module name>...]\n+          A comma (\",\") separated list of modules to add\n+          This module list, along with the main module (if specified)\n+          will be passed to jlink as the --add-module argument.\n+          If not specified, either just the main module (if --module is\n+          specified), or the default set of modules (if --main-jar is\n+          specified) are used.\n+          This option can be used multiple times.\n+  --jlink-options <jlink options>\n+          A space separated list of options to pass to jlink\n+          If not specified, defaults to \"--strip-native-commands\n+          --strip-debug --no-man-pages --no-header-files\".\n+          This option can be used multiple times.\n+  --module-path -p <module path>[:<module path>...]\n+          A : separated list of paths\n+          Each path is either a directory of modules or the path to a\n+          modular jar.\n+          (Each path is absolute or relative to the current directory.)\n+          This option can be used multiple times.\n+  --runtime-image <directory path>\n+          Path of the predefined runtime image that will be copied into\n+          the application image\n+          (absolute path or relative to the current directory)\n+          If --runtime-image is not specified, jpackage will run jlink to\n+          create the runtime image using options:\n+          --strip-debug, --no-header-files, --no-man-pages, and\n+          --strip-native-commands.\n+\n+Options for creating the application image:\n+  --app-content <additional content>[,<additional content>...]\n+          A comma separated list of paths to files and\/or directories\n+          to add to the application payload.\n+          This option can be used more than once.\n+  --input -i <directory path>\n+          Path of the input directory that contains the files to be packaged\n+          (absolute path or relative to the current directory)\n+          All files in the input directory will be packaged into the\n+          application image.\n+\n+Options for creating the application launcher(s):\n+  --add-launcher <launcher name>=<file path>\n+          Name of launcher, and a path to a Properties file that contains\n+          a list of key, value pairs\n+          (absolute path or relative to the current directory)\n+          The keys \"arguments\", \"description\", \"icon\", \"java-options\",\n+          \"launcher-as-service\", \"linux-shortcut\", \"main-class\", \"main-jar\",\n+          and \"module\" can be used.\n+          These options are added to, or used to overwrite, the original\n+          command line options to build an additional alternative launcher.\n+          The main application launcher will be built from the command line\n+          options. Additional alternative launchers can be built using\n+          this option, and this option can be used multiple times to\n+          build multiple additional launchers.\n+  --arguments <main class arguments>\n+          Command line arguments to pass to the main class if no command\n+          line arguments are given to the launcher\n+          This option can be used multiple times.\n+  --java-options <java options>\n+          Options to pass to the Java runtime\n+          This option can be used multiple times.\n+  --main-class <class name>\n+          Qualified name of the application main class to execute\n+          This option can only be used if --main-jar is specified.\n+  --main-jar <main jar file>\n+          The main JAR of the application; containing the main class\n+          (specified as a path relative to the input path)\n+          Either --module or --main-jar option can be specified but not\n+          both.\n+  --module -m <module name>[\/<main class>]\n+          The main module (and optionally main class) of the application\n+          This module must be located on the module path.\n+          When this option is specified, the main module will be linked\n+          in the Java runtime image.  Either --module or --main-jar\n+          option can be specified but not both.\n+\n+Options for creating the application package:\n+  --about-url <url>\n+          URL of the application's home page\n+  --app-image <directory path>\n+          Location of the predefined application image that is used\n+          to build an installable package\n+          (absolute path or relative to the current directory)\n+  --file-associations <file path>[:<file path>...]\n+          Path to a Properties file that contains list of key, value pairs\n+          (absolute path or relative to the current directory)\n+          The keys \"extension\", \"mime-type\", \"icon\", and \"description\"\n+          can be used to describe the association.\n+          This option can be used multiple times.\n+  --install-dir <directory path>\n+          Absolute path of the installation directory of the application\n+  --launcher-as-service\n+          Request to create an installer that will register the main\n+          application launcher as a background service-type application.\n+  --license-file <file path>\n+          Path to the license file\n+          (absolute path or relative to the current directory)\n+  --resource-dir <directory path>\n+          Path to override jpackage resources\n+          Icons, template files, and other resources of jpackage can be\n+          over-ridden by adding replacement resources to this directory.\n+          (absolute path or relative to the current directory)\n+  --runtime-image <directory path>\n+          Path of the predefined runtime image to install\n+          (absolute path or relative to the current directory)\n+          Option is required when creating a runtime package.\n+\n+Platform dependent options for creating the application package:\n+  --linux-app-category <category>\n+          Group value of the RPM <name>.spec file or\n+          Section value of DEB control file\n+  --linux-app-release <release>\n+          Release value of the RPM <name>.spec file or\n+          Debian revision value of the DEB control file\n+  --linux-deb-maintainer <email address>\n+          Maintainer for .deb package\n+  --linux-menu-group <menu-group-name>\n+          Menu group this application is placed in\n+  --linux-package-deps <package-dep-string>\n+          Required packages or capabilities for the application\n+  --linux-package-name <package name>\n+          Name for Linux package, defaults to the application name\n+  --linux-rpm-license-type <license type>\n+          Type of the license (\"License: <value>\" of the RPM .spec)\n+  --linux-shortcut [<shortcut startup directory>]\n+          Creates a shortcut for the application.\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/help-linux.txt","additions":197,"deletions":0,"binary":false,"changes":197,"status":"added"},{"patch":"@@ -0,0 +1,238 @@\n+Usage: jpackage <options>\n+\n+Sample usages:\n+--------------\n+    Generate an application package suitable for the host system:\n+        For a modular application:\n+            jpackage -n name -p modulePath -m moduleName\/className\n+        For a non-modular application:\n+            jpackage -i inputDir -n name \\\n+                --main-class className --main-jar myJar.jar\n+        From a pre-built application image:\n+            jpackage -n name --app-image appImageDir\n+\n+    Generate an application image:\n+        For a modular application:\n+            jpackage --type app-image -n name -p modulePath \\\n+                -m moduleName\/className\n+        For a non-modular application:\n+            jpackage --type app-image -i inputDir -n name \\\n+                --main-class className --main-jar myJar.jar\n+        To provide your own options to jlink, run jlink separately:\n+            jlink --output appRuntimeImage -p modulePath \\\n+                --add-modules moduleName \\\n+                --no-header-files [<additional jlink options>...]\n+            jpackage --type app-image -n name \\\n+                -m moduleName\/className --runtime-image appRuntimeImage\n+\n+    Generate a Java runtime package:\n+        jpackage -n name --runtime-image <runtime-image>\n+\n+    Sign the predefined application image:\n+        jpackage --type app-image --app-image <app-image> \\\n+            --mac-sign [<additional signing options>...]\n+        Note: the only additional options that are permitted in this mode are:\n+              the set of additional mac signing options and --verbose\n+\n+Generic Options:\n+  @<filename>\n+          Read options and\/or mode from a file\n+          This option can be used multiple times.\n+  --type -t <type>\n+          The type of package to create\n+          Valid values are: {\"app-image\", \"dmg\", \"pkg\"}\n+          If this option is not specified a platform dependent\n+          default type will be created.\n+  --app-version <version>\n+          Version of the application and\/or package\n+  --copyright <copyright string>\n+          Copyright for the application\n+  --description <description string>\n+          Description of the application\n+  --dest -d <destination path>\n+          Path where generated output file is placed\n+          (absolute path or relative to the current directory)\n+          Defaults to the current working directory.\n+  --help -h -?\n+          Print the usage text with a list and description of each valid\n+          option for the current platform to the output stream, and exit\n+  --icon <file path>\n+          Path of the icon of the application package\n+          (absolute path or relative to the current directory)\n+  --name -n <name>\n+          Name of the application and\/or package\n+  --temp <directory path>\n+          Path of a new or empty directory used to create temporary files\n+          (absolute path or relative to the current directory)\n+          If specified, the temp dir will not be removed upon the task\n+          completion and must be removed manually.\n+          If not specified, a temporary directory will be created and\n+          removed upon the task completion.\n+  --vendor <vendor string>\n+          Vendor of the application\n+  --verbose\n+          Enables verbose output\n+  --version\n+          Print the product version to the output stream and exit.\n+\n+Options for creating the runtime image:\n+  --add-modules <module name>[,<module name>...]\n+          A comma (\",\") separated list of modules to add\n+          This module list, along with the main module (if specified)\n+          will be passed to jlink as the --add-module argument.\n+          If not specified, either just the main module (if --module is\n+          specified), or the default set of modules (if --main-jar is\n+          specified) are used.\n+          This option can be used multiple times.\n+  --jlink-options <jlink options>\n+          A space separated list of options to pass to jlink\n+          If not specified, defaults to \"--strip-native-commands\n+          --strip-debug --no-man-pages --no-header-files\".\n+          This option can be used multiple times.\n+  --module-path -p <module path>[:<module path>...]\n+          A : separated list of paths\n+          Each path is either a directory of modules or the path to a\n+          modular jar.\n+          (Each path is absolute or relative to the current directory.)\n+          This option can be used multiple times.\n+  --runtime-image <directory path>\n+          Path of the predefined runtime image that will be copied into\n+          the application image\n+          (absolute path or relative to the current directory)\n+          If --runtime-image is not specified, jpackage will run jlink to\n+          create the runtime image using options:\n+          --strip-debug, --no-header-files, --no-man-pages, and\n+          --strip-native-commands.\n+\n+Options for creating the application image:\n+  --app-content <additional content>[,<additional content>...]\n+          A comma separated list of paths to files and\/or directories\n+          to add to the application payload.\n+          This option can be used more than once.\n+          Note: The value should be a directory with the \"Resources\"\n+          subdirectory (or any other directory that is valid in the \"Contents\"\n+          directory of the application bundle). Otherwise, jpackage may produce\n+          invalid application bundle which may fail code signing and\/or\n+          notarization.\n+  --input -i <directory path>\n+          Path of the input directory that contains the files to be packaged\n+          (absolute path or relative to the current directory)\n+          All files in the input directory will be packaged into the\n+          application image.\n+\n+Options for creating the application launcher(s):\n+  --add-launcher <launcher name>=<file path>\n+          Name of launcher, and a path to a Properties file that contains\n+          a list of key, value pairs\n+          (absolute path or relative to the current directory)\n+          The keys \"arguments\", \"description\", \"icon\", \"java-options\",\n+          \"launcher-as-service\", \"main-class\", \"main-jar\", and \"module\"\n+          can be used.\n+          These options are added to, or used to overwrite, the original\n+          command line options to build an additional alternative launcher.\n+          The main application launcher will be built from the command line\n+          options. Additional alternative launchers can be built using\n+          this option, and this option can be used multiple times to\n+          build multiple additional launchers.\n+  --arguments <main class arguments>\n+          Command line arguments to pass to the main class if no command\n+          line arguments are given to the launcher\n+          This option can be used multiple times.\n+  --java-options <java options>\n+          Options to pass to the Java runtime\n+          This option can be used multiple times.\n+  --main-class <class name>\n+          Qualified name of the application main class to execute\n+          This option can only be used if --main-jar is specified.\n+  --main-jar <main jar file>\n+          The main JAR of the application; containing the main class\n+          (specified as a path relative to the input path)\n+          Either --module or --main-jar option can be specified but not\n+          both.\n+  --module -m <module name>[\/<main class>]\n+          The main module (and optionally main class) of the application\n+          This module must be located on the module path.\n+          When this option is specified, the main module will be linked\n+          in the Java runtime image.  Either --module or --main-jar\n+          option can be specified but not both.\n+\n+Options for creating the application package:\n+  --about-url <url>\n+          URL of the application's home page\n+  --app-image <directory path>\n+          Location of the predefined application image that is used\n+          to build an installable package or to sign the predefined\n+          application image\n+          (absolute path or relative to the current directory)\n+  --file-associations <file path>[:<file path>...]\n+          Path to a Properties file that contains list of key, value pairs\n+          (absolute path or relative to the current directory)\n+          The keys \"extension\", \"mime-type\", \"icon\", and \"description\"\n+          can be used to describe the association.\n+          This option can be used multiple times.\n+  --install-dir <directory path>\n+          Absolute path of the installation directory of the application\n+  --launcher-as-service\n+          Request to create an installer that will register the main\n+          application launcher as a background service-type application.\n+  --license-file <file path>\n+          Path to the license file\n+          (absolute path or relative to the current directory)\n+  --resource-dir <directory path>\n+          Path to override jpackage resources\n+          Icons, template files, and other resources of jpackage can be\n+          over-ridden by adding replacement resources to this directory.\n+          (absolute path or relative to the current directory)\n+  --runtime-image <directory path>\n+          Path of the predefined runtime image to install\n+          (absolute path or relative to the current directory)\n+          Option is required when creating a runtime package.\n+\n+Platform dependent options for creating the application package:\n+  --mac-app-category <category>\n+          String used to construct LSApplicationCategoryType in\n+          application plist.  The default value is \"utilities\".\n+  --mac-app-image-sign-identity <identity>\n+          Identity used to sign application image. This value will be passed\n+          directly to --sign option of \"codesign\" tool. This option cannot\n+          be combined with --mac-signing-key-user-name.\n+  --mac-app-store\n+          Indicates that the jpackage output is intended for the\n+          Mac App Store.\n+  --mac-dmg-content <additional content path>[,<additional content path>...]\n+          Include all the referenced content in the dmg.\n+          This option can be used multiple times.\n+  --mac-entitlements <file path>\n+          Path to file containing entitlements to use when signing\n+          executables and libraries in the bundle.\n+  --mac-installer-sign-identity <identity>\n+          Identity used to sign \"pkg\" installer. This value will be passed\n+          directly to --sign option of \"productbuild\" tool. This option\n+          cannot be combined with --mac-signing-key-user-name.\n+  --mac-package-identifier <package identifier>\n+          An identifier that uniquely identifies the application for macOS\n+          Defaults to the main class name.\n+          May only use alphanumeric (A-Z,a-z,0-9), hyphen (-),\n+          and period (.) characters.\n+  --mac-package-name <package name>\n+          Name of the application as it appears in the Menu Bar\n+          This can be different from the application name.\n+          This name must be less than 16 characters long and be suitable for\n+          displaying in the menu bar and the application Info window.\n+          Defaults to the application name.\n+  --mac-package-signing-prefix <prefix>\n+          When signing the application package, this value is prefixed\n+          to all components that need to be signed that don't have\n+          an existing package identifier.\n+  --mac-sign -s\n+          Request that the package or the predefined application image be\n+          signed.\n+  --mac-signing-key-user-name <name>\n+          Team or user name portion of Apple signing identities. For direct\n+          control of the signing identity used to sign application images or\n+          installers use --mac-app-image-sign-identity and\/or\n+          --mac-installer-sign-identity. This option cannot be combined with\n+          --mac-app-image-sign-identity or --mac-installer-sign-identity.\n+  --mac-signing-keychain <keychain name>\n+          Name of the keychain to search for the signing identity\n+          If not specified, the standard keychains are used.\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/help-macos.txt","additions":238,"deletions":0,"binary":false,"changes":238,"status":"added"},{"patch":"@@ -0,0 +1,205 @@\n+Usage: jpackage <options>\n+\n+Sample usages:\n+--------------\n+    Generate an application package suitable for the host system:\n+        For a modular application:\n+            jpackage -n name -p modulePath -m moduleName\/className\n+        For a non-modular application:\n+            jpackage -i inputDir -n name \\\n+                --main-class className --main-jar myJar.jar\n+        From a pre-built application image:\n+            jpackage -n name --app-image appImageDir\n+\n+    Generate an application image:\n+        For a modular application:\n+            jpackage --type app-image -n name -p modulePath \\\n+                -m moduleName\/className\n+        For a non-modular application:\n+            jpackage --type app-image -i inputDir -n name \\\n+                --main-class className --main-jar myJar.jar\n+        To provide your own options to jlink, run jlink separately:\n+            jlink --output appRuntimeImage -p modulePath \\\n+                --add-modules moduleName \\\n+                --no-header-files [<additional jlink options>...]\n+            jpackage --type app-image -n name \\\n+                -m moduleName\/className --runtime-image appRuntimeImage\n+\n+    Generate a Java runtime package:\n+        jpackage -n name --runtime-image <runtime-image>\n+\n+Generic Options:\n+  @<filename>\n+          Read options and\/or mode from a file\n+          This option can be used multiple times.\n+  --type -t <type>\n+          The type of package to create\n+          Valid values are: {\"app-image\", \"exe\", \"msi\"}\n+          If this option is not specified a platform dependent\n+          default type will be created.\n+  --app-version <version>\n+          Version of the application and\/or package\n+  --copyright <copyright string>\n+          Copyright for the application\n+  --description <description string>\n+          Description of the application\n+  --dest -d <destination path>\n+          Path where generated output file is placed\n+          (absolute path or relative to the current directory)\n+          Defaults to the current working directory.\n+  --help -h -?\n+          Print the usage text with a list and description of each valid\n+          option for the current platform to the output stream, and exit\n+  --icon <file path>\n+          Path of the icon of the application package\n+          (absolute path or relative to the current directory)\n+  --name -n <name>\n+          Name of the application and\/or package\n+  --temp <directory path>\n+          Path of a new or empty directory used to create temporary files\n+          (absolute path or relative to the current directory)\n+          If specified, the temp dir will not be removed upon the task\n+          completion and must be removed manually.\n+          If not specified, a temporary directory will be created and\n+          removed upon the task completion.\n+  --vendor <vendor string>\n+          Vendor of the application\n+  --verbose\n+          Enables verbose output\n+  --version\n+          Print the product version to the output stream and exit.\n+\n+Options for creating the runtime image:\n+  --add-modules <module name>[,<module name>...]\n+          A comma (\",\") separated list of modules to add\n+          This module list, along with the main module (if specified)\n+          will be passed to jlink as the --add-module argument.\n+          If not specified, either just the main module (if --module is\n+          specified), or the default set of modules (if --main-jar is\n+          specified) are used.\n+          This option can be used multiple times.\n+  --jlink-options <jlink options>\n+          A space separated list of options to pass to jlink\n+          If not specified, defaults to \"--strip-native-commands\n+          --strip-debug --no-man-pages --no-header-files\".\n+          This option can be used multiple times.\n+  --module-path -p <module path>[;<module path>...]\n+          A ; separated list of paths\n+          Each path is either a directory of modules or the path to a\n+          modular jar.\n+          (Each path is absolute or relative to the current directory.)\n+          This option can be used multiple times.\n+  --runtime-image <directory path>\n+          Path of the predefined runtime image that will be copied into\n+          the application image\n+          (absolute path or relative to the current directory)\n+          If --runtime-image is not specified, jpackage will run jlink to\n+          create the runtime image using options:\n+          --strip-debug, --no-header-files, --no-man-pages, and\n+          --strip-native-commands.\n+\n+Options for creating the application image:\n+  --app-content <additional content>[,<additional content>...]\n+          A comma separated list of paths to files and\/or directories\n+          to add to the application payload.\n+          This option can be used more than once.\n+  --input -i <directory path>\n+          Path of the input directory that contains the files to be packaged\n+          (absolute path or relative to the current directory)\n+          All files in the input directory will be packaged into the\n+          application image.\n+\n+Options for creating the application launcher(s):\n+  --add-launcher <launcher name>=<file path>\n+          Name of launcher, and a path to a Properties file that contains\n+          a list of key, value pairs\n+          (absolute path or relative to the current directory)\n+          The keys \"arguments\", \"description\", \"icon\", \"java-options\",\n+          \"launcher-as-service\", \"main-class\", \"main-jar\", \"module\",\n+          \"win-console\", \"win-menu\", and \"win-shortcut\" can be used.\n+          These options are added to, or used to overwrite, the original\n+          command line options to build an additional alternative launcher.\n+          The main application launcher will be built from the command line\n+          options. Additional alternative launchers can be built using\n+          this option, and this option can be used multiple times to\n+          build multiple additional launchers.\n+  --arguments <main class arguments>\n+          Command line arguments to pass to the main class if no command\n+          line arguments are given to the launcher\n+          This option can be used multiple times.\n+  --java-options <java options>\n+          Options to pass to the Java runtime\n+          This option can be used multiple times.\n+  --main-class <class name>\n+          Qualified name of the application main class to execute\n+          This option can only be used if --main-jar is specified.\n+  --main-jar <main jar file>\n+          The main JAR of the application; containing the main class\n+          (specified as a path relative to the input path)\n+          Either --module or --main-jar option can be specified but not\n+          both.\n+  --module -m <module name>[\/<main class>]\n+          The main module (and optionally main class) of the application\n+          This module must be located on the module path.\n+          When this option is specified, the main module will be linked\n+          in the Java runtime image.  Either --module or --main-jar\n+          option can be specified but not both.\n+\n+Platform dependent option for creating the application launcher:\n+  --win-console\n+          Creates a console launcher for the application, should be\n+          specified for application which requires console interactions\n+\n+Options for creating the application package:\n+  --about-url <url>\n+          URL of the application's home page\n+  --app-image <directory path>\n+          Location of the predefined application image that is used\n+          to build an installable package\n+          (absolute path or relative to the current directory)\n+  --file-associations <file path>[;<file path>...]\n+          Path to a Properties file that contains list of key, value pairs\n+          (absolute path or relative to the current directory)\n+          The keys \"extension\", \"mime-type\", \"icon\", and \"description\"\n+          can be used to describe the association.\n+          This option can be used multiple times.\n+  --install-dir <directory path>\n+          Relative sub-path of the installation location of\n+          the application such as \"Program Files\" or \"AppData\".\n+  --launcher-as-service\n+          Request to create an installer that will register the main\n+          application launcher as a background service-type application.\n+  --license-file <file path>\n+          Path to the license file\n+          (absolute path or relative to the current directory)\n+  --resource-dir <directory path>\n+          Path to override jpackage resources\n+          Icons, template files, and other resources of jpackage can be\n+          over-ridden by adding replacement resources to this directory.\n+          (absolute path or relative to the current directory)\n+  --runtime-image <directory path>\n+          Path of the predefined runtime image to install\n+          (absolute path or relative to the current directory)\n+          Option is required when creating a runtime package.\n+\n+Platform dependent options for creating the application package:\n+  --win-dir-chooser\n+          Adds a dialog to enable the user to choose a directory in which\n+          the product is installed.\n+  --win-help-url <url>\n+          URL where user can obtain further information or technical support\n+  --win-menu [<shortcut startup directory>]\n+          Request to add a Start menu shortcut for this application\n+  --win-menu-group <menu group name>\n+          Start Menu group this application is placed in\n+  --win-per-user-install\n+          Request to perform an install on a per-user basis\n+  --win-shortcut [<shortcut startup directory>]\n+          Request to add desktop shortcut for this application\n+  --win-shortcut-prompt\n+          Adds a dialog to enable the user to choose if shortcuts\n+          will be created by installer.\n+  --win-update-url <url>\n+          URL of available application update information\n+  --win-upgrade-uuid <uuid>\n+          UUID associated with upgrades for this package\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/help-windows.txt","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+| Option | Scope | With runtime installer | With predefined app image | Recognized in add launcher .property file | Merge\n+| --- | --- | :---: | :---: | :---: | :---: |\n+| --about-url | native-bundle | x | x |  | USE_LAST |\n+| --add-launcher | bundle |  |  |  | CONCATENATE |\n+| --add-modules | bundle |  |  |  | CONCATENATE |\n+| --app-content | bundle |  |  |  | CONCATENATE |\n+| --app-image | mac-sign, native-bundle |  | x |  | USE_LAST |\n+| --app-version | bundle | x | x |  | USE_LAST |\n+| --arguments | bundle |  |  | x | CONCATENATE |\n+| --copyright | bundle | x | x |  | USE_LAST |\n+| --description | bundle | x | x | x | USE_LAST |\n+| --dest, -d | bundle | x | x |  | USE_LAST |\n+| --file-associations | bundle |  | x |  | CONCATENATE |\n+| --help, -h, -? | all | x | x |  | USE_LAST |\n+| --icon | bundle | x | x | x | USE_LAST |\n+| --input, -i | bundle |  |  |  | USE_LAST |\n+| --install-dir | bundle | x | x |  | USE_LAST |\n+| --java-options | bundle |  |  | x | CONCATENATE |\n+| --jlink-options | bundle |  |  |  | CONCATENATE |\n+| --launcher-as-service | native-bundle | x | x | x | USE_LAST |\n+| --license-file | bundle | x | x |  | USE_LAST |\n+| --linux-app-category | linux-deb, linux-rpm | x | x |  | USE_LAST |\n+| --linux-app-release | linux-deb, linux-rpm | x | x |  | USE_LAST |\n+| --linux-deb-maintainer | linux-deb | x | x |  | USE_LAST |\n+| --linux-menu-group | linux-deb, linux-rpm | x | x |  | USE_LAST |\n+| --linux-package-deps | linux-deb, linux-rpm | x | x |  | USE_LAST |\n+| --linux-package-name | linux-deb, linux-rpm | x | x |  | USE_LAST |\n+| --linux-rpm-license-type | linux-rpm | x | x |  | USE_LAST |\n+| --linux-shortcut | linux-deb, linux-rpm | x | x | x | USE_LAST |\n+| --mac-app-category | mac-bundle | x | x |  | USE_LAST |\n+| --mac-app-image-sign-identity | mac | x | x |  | USE_LAST |\n+| --mac-app-store | mac-bundle | x | x |  | USE_LAST |\n+| --mac-dmg-content | mac-dmg | x | x |  | CONCATENATE |\n+| --mac-entitlements | mac | x | x |  | USE_LAST |\n+| --mac-installer-sign-identity | mac-pkg | x | x |  | USE_LAST |\n+| --mac-package-identifier | mac-bundle | x | x |  | USE_LAST |\n+| --mac-package-name | mac-bundle | x | x |  | USE_LAST |\n+| --mac-package-signing-prefix | mac | x | x |  | USE_LAST |\n+| --mac-sign, -s | mac | x | x |  | USE_LAST |\n+| --mac-signing-key-user-name | mac | x | x |  | USE_LAST |\n+| --mac-signing-keychain | mac | x | x |  | USE_LAST |\n+| --main-class | bundle |  |  | x | USE_LAST |\n+| --main-jar | bundle |  |  | x | USE_LAST |\n+| --module, -m | bundle |  |  | x | USE_LAST |\n+| --module-path, -p | bundle |  |  |  | CONCATENATE |\n+| --name, -n | bundle | x | x |  | USE_LAST |\n+| --resource-dir | all | x | x |  | USE_LAST |\n+| --runtime-image | bundle | x |  |  | USE_LAST |\n+| --temp | bundle | x | x |  | USE_LAST |\n+| --type, -t | all | x | x |  | USE_LAST |\n+| --vendor | bundle | x | x |  | USE_LAST |\n+| --verbose | all | x | x |  | USE_LAST |\n+| --version | all | x | x |  | USE_LAST |\n+| --win-console | win |  |  | x | USE_LAST |\n+| --win-dir-chooser | win-exe, win-msi | x | x |  | USE_LAST |\n+| --win-help-url | win-exe, win-msi | x | x |  | USE_LAST |\n+| --win-menu | win-exe, win-msi | x | x | x | USE_LAST |\n+| --win-menu-group | win-exe, win-msi | x | x |  | USE_LAST |\n+| --win-per-user-install | win-exe, win-msi | x | x |  | USE_LAST |\n+| --win-shortcut | win-exe, win-msi | x | x | x | USE_LAST |\n+| --win-shortcut-prompt | win-exe, win-msi | x | x |  | USE_LAST |\n+| --win-update-url | win-exe, win-msi | x | x |  | USE_LAST |\n+| --win-upgrade-uuid | win-exe, win-msi | x | x |  | USE_LAST |\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/jpackage-options.md","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -176,1 +176,1 @@\n-                \"error.invalid-app-image\", appImageDir, AppImageFile.getPathInAppImage(appImageDir));\n+                \"error.invalid-app-image-file\", AppImageFile.getPathInAppImage(Path.of(\"\")), appImageDir);\n@@ -188,2 +188,2 @@\n-        return configureBadAppImage(appImageDir,\n-                JPackageStringBundle.MAIN.cannedFormattedString(\"error.foreign-app-image\", appImageDir));\n+        return configureBadAppImage(appImageDir, JPackageStringBundle.MAIN.cannedFormattedString(\n+                \"error.missing-app-image-file\", AppImageFile.getPathInAppImage(Path.of(\"\")), appImageDir));\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppImagePackageTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,210 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Predicate;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.IntStream;\n+import jdk.jpackage.internal.util.function.ThrowingRunnable;\n+import jdk.jpackage.test.Annotations.ParameterSupplier;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.JavaTool;\n+import jdk.jpackage.test.Main;\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.RunnablePackageTest.Action;\n+import jdk.jpackage.test.TKit;\n+\n+\/*\n+ * @test\n+ * @summary Runs multiple jpackage tool provider instances asynchronously\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @build jdk.jpackage.test.*\n+ * @compile -Xlint:all -Werror AsyncTest.java\n+ * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=AsyncTest\n+ *\/\n+public class AsyncTest {\n+\n+    @Test\n+    public void test() throws Throwable {\n+        \/\/\n+        \/\/ Run test cases from InternalAsyncTest class asynchronously.\n+        \/\/ Spawn a thread for every test case.\n+        \/\/ Input data for test cases will be cooked asynchronously but in a safe way because every test case has an isolated work directory.\n+        \/\/ Multiple jpackage tool provider instances will be invoked asynchronously.\n+        \/\/\n+\n+        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n+\n+            var testFuncNames = List.of(\"testAppImage\", \"testNativeBundle\");\n+\n+            var runArg = String.format(\"--jpt-run=%s\", AsyncInnerTest.class.getName());\n+\n+            var futures = executor.invokeAll(IntStream.range(0, JOB_COUNT).mapToObj(Integer::toString).<Workload>mapMulti((idx, consumer) -> {\n+                for (var testFuncName : testFuncNames) {\n+                    var id = String.format(\"%s(%s)\", testFuncName, idx);\n+                    consumer.accept(new Workload(() -> {\n+                        Main.main(runArg, String.format(\"--jpt-include=%s\", id));\n+                    }, id));\n+                }\n+            }).toList());\n+\n+            \/\/ Wait for all test cases completion.\n+            for (var future : futures) {\n+                future.get(3, TimeUnit.MINUTES);\n+            }\n+\n+            Throwable[] fatalError = new Throwable[1];\n+\n+            for (var future : futures) {\n+                var result = future.get();\n+                TKit.trace(String.format(\"[%s] STDOUT BEGIN\\n%s\", result.id(), result.stdoutBuffer()));\n+                TKit.trace(String.format(\"[%s] STDOUT END\", result.id()));\n+                TKit.trace(String.format(\"[%s] STDERR BEGIN\\n%s\", result.id(), result.stderrBuffer()));\n+                TKit.trace(String.format(\"[%s] STDERR END\", result.id()));\n+                result.throwable().filter(Predicate.not(TKit::isSkippedException)).ifPresent(t -> {\n+                    fatalError[0] = t;\n+                });\n+            }\n+\n+            if (fatalError[0] != null) {\n+                throw fatalError[0];\n+            }\n+        }\n+    }\n+\n+    public static final class AsyncInnerTest {\n+\n+        @Test\n+        @ParameterSupplier(\"ids\")\n+        public void testAppImage(int id) throws Exception {\n+            init(JPackageCommand.helloAppImage()).executeAndAssertHelloAppImageCreated();\n+        }\n+\n+        @Test\n+        @ParameterSupplier(\"ids\")\n+        public void testNativeBundle(int id) throws Exception {\n+            new PackageTest().configureHelloApp().addInitializer(cmd -> {\n+                init(cmd);\n+            }).run(Action.CREATE_AND_UNPACK);\n+        }\n+\n+        public static Collection<Object[]> ids() {\n+            return IntStream.range(0, JOB_COUNT).mapToObj(Integer::valueOf).map(v -> {\n+                return new Object[] {v};\n+            }).toList();\n+        }\n+    }\n+\n+    private static JPackageCommand init(JPackageCommand cmd) {\n+        return cmd.useToolProvider(true).setFakeRuntime().setArgumentValue(\"--name\", \"Foo\");\n+    }\n+\n+\n+    private record Result(String stdoutBuffer, String stderrBuffer, String id, Optional<Throwable> throwable) {\n+\n+        Result {\n+            Objects.requireNonNull(stdoutBuffer);\n+            Objects.requireNonNull(stderrBuffer);\n+            Objects.requireNonNull(id);\n+            Objects.requireNonNull(throwable);\n+        }\n+    }\n+\n+\n+    private record Workload(\n+            ByteArrayOutputStream stdoutBuffer,\n+            ByteArrayOutputStream stderrBuffer,\n+            ThrowingRunnable runnable,\n+            String id) implements Callable<Result>  {\n+\n+        Workload {\n+            Objects.requireNonNull(stdoutBuffer);\n+            Objects.requireNonNull(stderrBuffer);\n+            Objects.requireNonNull(runnable);\n+            Objects.requireNonNull(id);\n+        }\n+\n+        Workload(ThrowingRunnable runnable, String id) {\n+            this(new ByteArrayOutputStream(), new ByteArrayOutputStream(), runnable, id);\n+        }\n+\n+        private String stdoutBufferAsString() {\n+            return new String(stdoutBuffer.toByteArray(), StandardCharsets.UTF_8);\n+        }\n+\n+        private String stderrBufferAsString() {\n+            return new String(stderrBuffer.toByteArray(), StandardCharsets.UTF_8);\n+        }\n+\n+        @Override\n+        public Result call() {\n+            \/\/ Reset the current test inherited in the state from the parent thread.\n+            TKit.state(DEFAULT_STATE);\n+\n+            var defaultToolProvider = JavaTool.JPACKAGE.asToolProvider();\n+\n+            JPackageCommand.useToolProviderByDefault(new ToolProvider() {\n+\n+                @Override\n+                public int run(PrintWriter out, PrintWriter err, String... args) {\n+                    try (var bufOut = new PrintWriter(stdoutBuffer, true, StandardCharsets.UTF_8);\n+                            var bufErr = new PrintWriter(stderrBuffer, true, StandardCharsets.UTF_8)) {\n+                        return defaultToolProvider.run(bufOut, bufErr, args);\n+                    }\n+                }\n+\n+                @Override\n+                public String name() {\n+                    return defaultToolProvider.name();\n+                }\n+            });\n+\n+            Optional<Throwable> err = Optional.empty();\n+            try (var bufOut = new PrintStream(stdoutBuffer, true, StandardCharsets.UTF_8);\n+                    var bufErr = new PrintStream(stderrBuffer, true, StandardCharsets.UTF_8)) {\n+                TKit.withStackTraceStream(() -> {\n+                    TKit.withMainLogStream(runnable, bufOut);\n+                }, bufErr);\n+            } catch (Throwable t) {\n+                err = Optional.of(t);\n+            }\n+            return new Result(stdoutBufferAsString(), stderrBufferAsString(), id, err);\n+        }\n+    }\n+\n+\n+    private static final int JOB_COUNT = 10;\n+    private static final TKit.State DEFAULT_STATE = TKit.state();\n+}\n","filename":"test\/jdk\/tools\/jpackage\/share\/AsyncTest.java","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"},{"patch":"@@ -404,1 +404,1 @@\n-                    .error(\"message.runtime-image-dir-does-not-exist\", \"runtime-image\", \"non-existent.runtime\"),\n+                    .error(\"error.paramater-not-directory\", \"non-existent.runtime\", \"--runtime-image\"),\n@@ -410,1 +410,1 @@\n-                    .error(\"message.resource-dir-does-not-exist\", \"resource-dir\", \"non-existent.dir\"),\n+                    .error(\"error.paramater-not-directory\", \"non-existent.dir\", \"--resource-dir\"),\n@@ -413,1 +413,1 @@\n-                    .error(\"ERR_IconFileNotExit\", cannedAbsolutePath(\"non-existent.icon\")),\n+                    .error(\"error.paramater-not-file\", \"non-existent.icon\", \"--icon\"),\n@@ -544,1 +544,1 @@\n-                    .error(\"ERR_NoUniqueName\")\n+                    .error(\"error.launcher-duplicate-name\", \"foo\")\n","filename":"test\/jdk\/tools\/jpackage\/share\/ErrorTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}