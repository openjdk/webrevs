{"files":[{"patch":"@@ -261,0 +261,8 @@\n+                        case LookupSwitchInstruction ls -> {\n+                            ls.defaultTarget();\n+                            ls.cases();\n+                        }\n+                        case TableSwitchInstruction ts -> {\n+                            ts.defaultTarget();\n+                            ts.cases();\n+                        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeImpl.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @bug 8339368\n@@ -30,4 +31,0 @@\n-\n-import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n-import static java.lang.classfile.ClassFile.ACC_STATIC;\n-import static java.lang.constant.ConstantDescs.*;\n@@ -35,2 +32,0 @@\n-import java.util.List;\n-\n@@ -44,2 +39,2 @@\n-import static org.junit.jupiter.api.Assertions.*;\n-import org.junit.jupiter.api.Test;\n+import java.lang.classfile.instruction.*;\n+import java.util.List;\n@@ -47,7 +42,1 @@\n-import java.lang.classfile.instruction.ConstantInstruction;\n-import java.lang.classfile.instruction.StoreInstruction;\n-import java.lang.classfile.instruction.BranchInstruction;\n-import java.lang.classfile.instruction.LoadInstruction;\n-import java.lang.classfile.instruction.OperatorInstruction;\n-import java.lang.classfile.instruction.FieldInstruction;\n-import java.lang.classfile.instruction.InvokeInstruction;\n+import org.junit.jupiter.api.Test;\n@@ -55,0 +44,4 @@\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import static java.lang.classfile.Opcode.*;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -59,1 +52,1 @@\n-import static java.lang.classfile.Opcode.*;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -159,0 +152,32 @@\n+\n+    @Test\n+    void testJava5ClassWriteRead() {\n+        MethodModel mm = ClassFile.of().parse(ClassFile.of().build(ClassDesc.of(\"MyClass\"), clb -> clb\n+                .withVersion(ClassFile.JAVA_5_VERSION, 0)\n+                .withMethodBody(\"switches\", MTD_void, ACC_STATIC, cob -> {\n+                    Label l1 = cob.newLabel(), l2 = cob.newLabel(), l3 = cob.newLabel(), l4 = cob.newLabel();\n+                    cob.iconst_0()\n+                       .tableswitch(l1, List.of(SwitchCase.of(0, l2)))\n+                       .labelBinding(l1)\n+                       .nop()\n+                       .labelBinding(l2)\n+                       .iconst_0()\n+                       .lookupswitch(l3, List.of(SwitchCase.of(0, l4)))\n+                       .labelBinding(l3)\n+                       .nop()\n+                       .labelBinding(l4)\n+                       .return_();\n+                }))).methods().getFirst();\n+        var it = mm.code().orElseThrow().iterator();\n+        while (!(it.next() instanceof ConstantInstruction));\n+        assertTrue(it.next() instanceof TableSwitchInstruction tsi\n+                   && it.next() instanceof LabelTarget lt1 && lt1.label().equals(tsi.defaultTarget())\n+                   && it.next() instanceof NopInstruction\n+                   && it.next() instanceof LabelTarget lt2 && lt2.label().equals(tsi.cases().getFirst().target())\n+                   && it.next() instanceof ConstantInstruction\n+                   && it.next() instanceof LookupSwitchInstruction lsi\n+                   && it.next() instanceof LabelTarget lt3 && lt3.label().equals(lsi.defaultTarget())\n+                   && it.next() instanceof NopInstruction\n+                   && it.next() instanceof LabelTarget lt4 && lt4.label().equals(lsi.cases().getFirst().target()),\n+                () -> mm.code().get().elementList().toString());\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/OneToOneTest.java","additions":41,"deletions":16,"binary":false,"changes":57,"status":"modified"}]}