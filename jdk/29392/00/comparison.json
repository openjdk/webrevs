{"files":[{"patch":"@@ -2517,1 +2517,1 @@\n-bool PhaseIdealLoop::is_scaled_iv_plus_offset(Node* exp, Node* iv, BasicType bt, jlong* p_scale, Node** p_offset, bool* p_short_scale, int depth) {\n+bool PhaseIdealLoop::is_scaled_iv_plus_offset(Node* exp, Node* iv, BasicType bt, jlong* p_scale, Node** p_offset, bool* p_short_scale, bool* p_short_offset, int depth) {\n@@ -2520,1 +2520,0 @@\n-  BasicType exp_bt = bt;\n@@ -2522,1 +2521,1 @@\n-  if (is_scaled_iv(exp, iv, exp_bt, &scale, p_short_scale)) {\n+  if (is_scaled_iv(exp, iv, bt, &scale, p_short_scale)) {\n@@ -2532,6 +2531,34 @@\n-  if (exp_bt != bt) {\n-    \/\/ We would now be matching inputs like (ConvI2L exp:(AddI (MulI iv S) E)).\n-    \/\/ It's hard to make 32-bit arithmetic linear if it overflows.  Although we do\n-    \/\/ cope with overflowing multiplication by S, it would be even more work to\n-    \/\/ handle overflowing addition of E.  So we bail out here on ConvI2L input.\n-    return false;\n+  \/\/ Handle ConvI2L wrapping an int linear expression: ConvI2L(iv + E) or ConvI2L(iv*K + E)\n+  \/\/ The int arithmetic may overflow, so flag this case via p_short_offset for special\n+  \/\/ handling at RCE time (clamp at max_jint + 1 instead of max_jint + offset + 1).\n+  if (bt == T_LONG && iv->bottom_type()->isa_int() && exp->Opcode() == Op_ConvI2L) {\n+    Node* inner = exp->in(1);\n+    jlong inner_scale = 0;\n+    Node* inner_offset = nullptr;\n+    bool inner_short_scale = false;\n+    if (is_scaled_iv_plus_offset(inner, iv, T_INT, &inner_scale, &inner_offset, &inner_short_scale, nullptr, depth + 1)) {\n+      \/\/ Found linear int expression inside ConvI2L\n+      if (p_scale != nullptr) {\n+        *p_scale = inner_scale;\n+      }\n+      if (p_offset != nullptr) {\n+        \/\/ Convert int offset to long\n+        if (inner_offset != nullptr && inner_offset->is_Con()) {\n+          *p_offset = longcon(inner_offset->get_int());\n+        } else if (inner_offset != nullptr) {\n+          Node* ctrl = get_ctrl(inner_offset);\n+          Node* long_offset = new ConvI2LNode(inner_offset);\n+          register_new_node(long_offset, ctrl);\n+          *p_offset = long_offset;\n+        } else {\n+          *p_offset = longcon(0);\n+        }\n+      }\n+      if (p_short_scale != nullptr) {\n+        *p_short_scale = inner_short_scale;\n+      }\n+      if (p_short_offset != nullptr) {\n+        *p_short_offset = true;\n+      }\n+      return true;\n+    }\n@@ -2542,1 +2569,1 @@\n-  if (opc == Op_Add(exp_bt)) {\n+  if (opc == Op_Add(bt)) {\n@@ -2556,2 +2583,2 @@\n-    if (is_scaled_iv_plus_extra_offset(exp->in(1), exp->in(2), iv, bt, p_scale, p_offset, p_short_scale, depth) ||\n-        is_scaled_iv_plus_extra_offset(exp->in(2), exp->in(1), iv, bt, p_scale, p_offset, p_short_scale, depth)) {\n+    if (is_scaled_iv_plus_extra_offset(exp->in(1), exp->in(2), iv, bt, p_scale, p_offset, p_short_scale, p_short_offset, depth) ||\n+        is_scaled_iv_plus_extra_offset(exp->in(2), exp->in(1), iv, bt, p_scale, p_offset, p_short_scale, p_short_offset, depth)) {\n@@ -2560,1 +2587,1 @@\n-  } else if (opc == Op_Sub(exp_bt)) {\n+  } else if (opc == Op_Sub(bt)) {\n@@ -2578,1 +2605,1 @@\n-          Node* zero = integercon(0, exp_bt);\n+          Node* zero = integercon(0, bt);\n@@ -2580,1 +2607,1 @@\n-          offset = SubNode::make(zero, offset, exp_bt);\n+          offset = SubNode::make(zero, offset, bt);\n@@ -2598,1 +2625,1 @@\n-                                                    bool* p_short_scale, int depth) {\n+                                                    bool* p_short_scale, bool* p_short_offset, int depth) {\n@@ -2606,1 +2633,1 @@\n-                               &offset2, p_short_scale, depth+1)) {\n+                               &offset2, p_short_scale, p_short_offset, depth+1)) {\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":44,"deletions":17,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -1580,1 +1580,2 @@\n-    bool ok = is_scaled_iv_plus_offset(rc_cmp->in(1), iv_add, T_LONG, &scale, &offset, &short_scale);\n+    bool short_offset = false;\n+    bool ok = is_scaled_iv_plus_offset(rc_cmp->in(1), iv_add, T_LONG, &scale, &offset, &short_scale, &short_offset);\n@@ -1591,1 +1592,8 @@\n-    if (short_scale) {\n+    if (short_offset) {\n+      \/\/ ConvI2L(i + E): clamp R at max_jint + 1 (offset E is inside int arithmetic).\n+      \/\/ Unlike short_scale where L is added in long after ConvI2L, here the offset\n+      \/\/ is part of the int computation, so we clamp without adding L.\n+      Node* max_jint_plus_one_long = longcon((jlong)max_jint + 1);\n+      R = MinMaxNode::unsigned_min(R, max_jint_plus_one_long, TypeLong::POS, _igvn);\n+      set_subtree_ctrl(R, true);\n+    } else if (short_scale) {\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1474,1 +1474,3 @@\n-  bool is_scaled_iv_plus_offset(Node* exp, Node* iv, BasicType bt, jlong* p_scale, Node** p_offset, bool* p_short_scale = nullptr, int depth = 0);\n+  \/\/ p_short_scale: set if int multiplication was widened to long (ConvI2L around MulI)\n+  \/\/ p_short_offset: set if int addition was widened to long (ConvI2L around AddI)\n+  bool is_scaled_iv_plus_offset(Node* exp, Node* iv, BasicType bt, jlong* p_scale, Node** p_offset, bool* p_short_scale = nullptr, bool* p_short_offset = nullptr, int depth = 0);\n@@ -1490,1 +1492,1 @@\n-                                      bool* p_short_scale, int depth);\n+                                      bool* p_short_scale, bool* p_short_offset, int depth);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * @bug 8343685 8331659\n+ * @bug 8343685 8331659 8356184\n@@ -108,0 +108,8 @@\n+        tests.put(\"testMemorySegmentBInvarISub\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aB.clone());\n+          return testMemorySegmentBInvarISub(data, 101, RANGE-200);\n+        });\n+        tests.put(\"testMemorySegmentBInvarI2Adr\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aB.clone());\n+          return testMemorySegmentBInvarI2Adr(data, 42, 10, RANGE-200);\n+        });\n@@ -236,0 +244,2 @@\n+                 \"testMemorySegmentBInvarISub\",\n+                 \"testMemorySegmentBInvarI2Adr\",\n@@ -427,2 +437,3 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n-                  IRNode.STORE_VECTOR,  \"= 0\"},\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n@@ -431,2 +442,0 @@\n-    \/\/ Does not vectorize: RangeChecks are not eliminated.\n-    \/\/ Filed RFE: JDK-8327209\n@@ -461,2 +470,3 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n-                  IRNode.STORE_VECTOR,  \"= 0\"},\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n@@ -465,2 +475,0 @@\n-    \/\/ Does not vectorize: RangeChecks are not eliminated.\n-    \/\/ Filed RFE: JDK-8327209\n@@ -476,0 +484,32 @@\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Subtraction inside ConvI2L: ConvI2L(SubI(iv, invar))\n+    static Object[] testMemorySegmentBInvarISub(MemorySegment m, int invar, int size) {\n+        for (int i = invar; i < size; i++) {\n+            long adr = i - invar;\n+            byte v = m.get(ValueLayout.JAVA_BYTE, adr);\n+            m.set(ValueLayout.JAVA_BYTE, adr, (byte)(v + 1));\n+        }\n+        return new Object[]{ m };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Nested int additions inside ConvI2L: ConvI2L(AddI(AddI(iv, invar1), invar2))\n+    static Object[] testMemorySegmentBInvarI2Adr(MemorySegment m, int invar1, int invar2, int size) {\n+        for (int i = 0; i < size; i++) {\n+            long adr = (i + invar1) + invar2;\n+            byte v = m.get(ValueLayout.JAVA_BYTE, adr);\n+            m.set(ValueLayout.JAVA_BYTE, adr, (byte)(v + 1));\n+        }\n+        return new Object[]{ m };\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestEquivalentInvariants.java","additions":49,"deletions":9,"binary":false,"changes":58,"status":"modified"}]}