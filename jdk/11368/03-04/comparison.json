{"files":[{"patch":"@@ -253,1 +253,1 @@\n-        return buildModule(moduleAttribute, List.of(), clb -> {});\n+        return buildModule(moduleAttribute, clb -> {});\n@@ -259,12 +259,0 @@\n-     * @param packages additional module packages\n-     * @return the classfile bytes\n-     *\/\n-    public static byte[] buildModule(ModuleAttribute moduleAttribute,\n-                                     List<PackageDesc> packages) {\n-        return buildModule(moduleAttribute, packages, clb -> {});\n-    }\n-\n-    \/**\n-     * Build a module descriptor into a byte array.\n-     * @param moduleAttribute the {@code Module} attribute\n-     * @param packages additional module packages\n@@ -275,1 +263,0 @@\n-                                     List<PackageDesc> packages,\n@@ -280,11 +267,0 @@\n-            if (!packages.isEmpty()) {\n-                var cp = clb.constantPool();\n-                var allPackages = new LinkedHashSet<PackageEntry>();\n-                for (var exp : moduleAttribute.exports()) allPackages.add(AbstractPoolEntry.maybeClone(cp, exp.exportedPackage()));\n-                for (var opn : moduleAttribute.opens()) allPackages.add(AbstractPoolEntry.maybeClone(cp, opn.openedPackage()));\n-                boolean emitMPA = false;\n-                for (var p : packages)\n-                    emitMPA |= allPackages.add(cp.packageEntry(p));\n-                if(emitMPA)\n-                    clb.with(new UnboundAttribute.UnboundModulePackagesAttribute(allPackages));\n-            }\n@@ -302,13 +278,1 @@\n-        buildModuleTo(path, moduleAttribute, List.of(), clb -> {});\n-    }\n-\n-    \/**\n-     * Build a module descriptor into a file.\n-     * @param path the file to write\n-     * @param moduleAttribute the {@code Module} attribute\n-     * @param packages additional module packages\n-     *\/\n-    public static void buildModuleTo(Path path,\n-                                     ModuleAttribute moduleAttribute,\n-                                     List<PackageDesc> packages) throws IOException {\n-        buildModuleTo(path, moduleAttribute, packages, clb -> {});\n+        buildModuleTo(path, moduleAttribute, clb -> {});\n@@ -321,1 +285,0 @@\n-     * @param packages additional module packages\n@@ -326,1 +289,0 @@\n-                                     List<PackageDesc> packages,\n@@ -328,1 +290,1 @@\n-        Files.write(path, buildModule(moduleAttribute, packages, handler));\n+        Files.write(path, buildModule(moduleAttribute, handler));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/Classfile.java","additions":3,"deletions":41,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -145,0 +145,13 @@\n+    \/**\n+     * {@return a {@code Module} attribute}\n+     *\n+     * @param moduleName the module name\n+     * @param attrHandler a handler that receives a {@link ModuleAttributeBuilder}\n+     *\/\n+    static ModuleAttribute of(ModuleEntry moduleName,\n+                              Consumer<ModuleAttributeBuilder> attrHandler) {\n+        var mb = new ModuleAttributeBuilderImpl(moduleName);\n+        attrHandler.accept(mb);\n+        return  mb.build();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/ModuleAttribute.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -52,2 +52,2 @@\n-    public ModuleAttributeBuilderImpl(ModuleDesc moduleName) {\n-        this.moduleEntry = TemporaryConstantPool.INSTANCE.moduleEntry(TemporaryConstantPool.INSTANCE.utf8Entry(moduleName.moduleName()));\n+    public ModuleAttributeBuilderImpl(ModuleEntry moduleName) {\n+        this.moduleEntry = moduleName;\n@@ -57,0 +57,4 @@\n+    public ModuleAttributeBuilderImpl(ModuleDesc moduleName) {\n+        this(TemporaryConstantPool.INSTANCE.moduleEntry(TemporaryConstantPool.INSTANCE.utf8Entry(moduleName.moduleName())));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ModuleAttributeBuilderImpl.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.module.InvalidModuleDescriptorException;\n@@ -32,0 +31,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -35,1 +35,0 @@\n-import jdk.internal.classfile.java.lang.constant.ModuleDesc;\n@@ -38,0 +37,1 @@\n+import jdk.internal.classfile.attribute.ModuleExportInfo;\n@@ -39,0 +39,2 @@\n+import jdk.internal.classfile.attribute.ModuleOpenInfo;\n+import jdk.internal.classfile.attribute.ModulePackagesAttribute;\n@@ -40,0 +42,1 @@\n+import jdk.internal.classfile.attribute.ModuleRequireInfo;\n@@ -41,0 +44,1 @@\n+import jdk.internal.classfile.constantpool.ModuleEntry;\n@@ -84,3 +88,5 @@\n-        try {\n-            return Classfile.buildModule(\n-                ModuleAttribute.of(ModuleDesc.of(md.name()), mb -> {\n+        \/\/using low-level module building to avoid validation in ModuleDesc and allow invalid names\n+        return Classfile.build(ClassDesc.of(\"module-info\"), clb -> {\n+            clb.withFlags(AccessFlag.MODULE);\n+            var cp = clb.constantPool();\n+            clb.with(ModuleAttribute.of(cp.moduleEntry(cp.utf8Entry(md.name())), mb -> {\n@@ -91,2 +97,1 @@\n-                    String vs = md.rawVersion().orElse(null);\n-                    if (vs != null) mb.moduleVersion(vs);\n+                    md.rawVersion().ifPresent(vs -> mb.moduleVersion(vs));\n@@ -99,2 +104,4 @@\n-                        vs = r.rawCompiledVersion().orElse(null);\n-                        mb.requires(ModuleDesc.of(r.name()), flags, vs);\n+                        mb.requires(ModuleRequireInfo.of(\n+                                cp.moduleEntry(cp.utf8Entry(r.name())),\n+                                flags,\n+                                r.rawCompiledVersion().map(cp::utf8Entry).orElse(null)));\n@@ -108,3 +115,6 @@\n-                        var targets = e.targets().stream().map(ModuleDesc::of)\n-                                .toArray(ModuleDesc[]::new);\n-                        mb.exports(PackageDesc.of(e.source()), flags, targets);\n+                        var targets = e.targets().stream().map(mn -> cp.moduleEntry(cp.utf8Entry(mn)))\n+                                .toArray(ModuleEntry[]::new);\n+                        mb.exports(ModuleExportInfo.of(\n+                                cp.packageEntry(cp.utf8Entry(e.source())),\n+                                flags,\n+                                targets));\n@@ -118,3 +128,6 @@\n-                        var targets = opens.targets().stream().map(ModuleDesc::of)\n-                                .toArray(ModuleDesc[]::new);\n-                        mb.opens(PackageDesc.of(opens.source()), flags, targets);\n+                        var targets = opens.targets().stream().map(mn -> cp.moduleEntry(cp.utf8Entry(mn)))\n+                                .toArray(ModuleEntry[]::new);\n+                        mb.opens(ModuleOpenInfo.of(\n+                                cp.packageEntry(cp.utf8Entry(opens.source())),\n+                                flags,\n+                                targets));\n@@ -133,1 +146,1 @@\n-                }),\n+                }));\n@@ -136,23 +149,19 @@\n-                md.packages().stream().map(PackageDesc::of).toList(),\n-\n-                \/\/ extra attributes\n-                clb -> {\n-                    \/\/ ModuleMainClass attribute\n-                    md.mainClass().ifPresent(mc ->\n-                            clb.with(ModuleMainClassAttribute.of(ClassDesc.of(mc))));\n-\n-                    \/\/ write ModuleResolution attribute if specified\n-                    if (mres != null) {\n-                        clb.with(ModuleResolutionAttribute.of(mres.value()));\n-                    }\n-\n-                    \/\/ write ModuleTarget attribute if there is a target platform\n-                    if (target != null && !target.targetPlatform().isEmpty()) {\n-                        clb.with(ModuleTargetAttribute.of(target.targetPlatform()));\n-                    }\n-                });\n-        } catch (IllegalArgumentException iae) {\n-            var t = new InvalidModuleDescriptorException(iae.getMessage());\n-            t.initCause(iae);\n-            throw t;\n-        }\n+                var packages = md.packages().stream().sorted().map(PackageDesc::of).toList();\n+                if (!packages.isEmpty()) {\n+                    clb.with(ModulePackagesAttribute.ofNames(packages));\n+                }\n+\n+                \/\/ ModuleMainClass attribute\n+                md.mainClass().ifPresent(mc ->\n+                        clb.with(ModuleMainClassAttribute.of(ClassDesc.of(mc))));\n+\n+                \/\/ write ModuleResolution attribute if specified\n+                if (mres != null) {\n+                    clb.with(ModuleResolutionAttribute.of(mres.value()));\n+                }\n+\n+                \/\/ write ModuleTarget attribute if there is a target platform\n+                if (target != null && !target.targetPlatform().isEmpty()) {\n+                    clb.with(ModuleTargetAttribute.of(target.targetPlatform()));\n+                }\n+            });\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleInfoWriter.java","additions":48,"deletions":39,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.java.lang.constant\n@@ -60,0 +63,4 @@\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.attribute.ModuleAttribute;\n+import jdk.internal.classfile.java.lang.constant.PackageDesc;\n+import jdk.internal.classfile.java.lang.constant.ModuleDesc;\n@@ -1365,8 +1372,4 @@\n-        ModuleDescriptor descriptor = ModuleDescriptor.newModule(\"foo\")\n-                .requires(\"java.base\")\n-                .exports(\"p\")\n-                .build();\n-\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        ModuleInfoWriter.write(descriptor, baos);\n-        ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());\n+        ByteBuffer bb = ByteBuffer.wrap(Classfile.buildModule(\n+                ModuleAttribute.of(ModuleDesc.of(\"foo\"), mb -> mb\n+                        .requires(ModuleDesc.of(\"java.base\"), 0, null)\n+                        .exports(PackageDesc.of(\"p\"), 0))));\n","filename":"test\/jdk\/java\/lang\/module\/ModuleDescriptorTest.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -88,1 +88,0 @@\n-                List.of(PackageDesc.of(\"foo.bar.baz\"), PackageDesc.of(\"quux\"), PackageDesc.of(\"foo.bar.baz\"), PackageDesc.of(\"quux\")),\n@@ -90,0 +89,1 @@\n+                          .with(ModulePackagesAttribute.ofNames(PackageDesc.of(\"foo.bar.baz\"), PackageDesc.of(\"quux\")))\n@@ -185,1 +185,1 @@\n-        assertEquals(a.packages().stream().map(pe -> pe.asSymbol().packageName()).toList(), List.of(\"0\", \"1\", \"2\", \"3\", \"4\", \"o0\", \"o1\", \"o2\", \"foo.bar.baz\", \"quux\"));\n+        assertEquals(a.packages().stream().map(pe -> pe.asSymbol().packageName()).toList(), List.of(\"foo.bar.baz\", \"quux\"));\n","filename":"test\/jdk\/jdk\/classfile\/ModuleBuilderTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-        byte[] moduleInfo = Classfile.buildModule(ModuleAttribute.of(moduleName, handler), List.of(), clb -> {\n+        byte[] moduleInfo = Classfile.buildModule(ModuleAttribute.of(moduleName, handler), clb -> {\n","filename":"test\/jdk\/jdk\/classfile\/examples\/ModuleExamples.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}