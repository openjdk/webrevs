{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.constant.ClassDesc;\n@@ -32,1 +33,0 @@\n-import java.util.ArrayList;\n@@ -36,0 +36,11 @@\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.attribute.ModuleAttribute;\n+import jdk.internal.classfile.attribute.ModuleHashInfo;\n+import jdk.internal.classfile.attribute.ModuleHashesAttribute;\n+import jdk.internal.classfile.attribute.ModuleMainClassAttribute;\n+import jdk.internal.classfile.attribute.ModulePackagesAttribute;\n+import jdk.internal.classfile.attribute.ModuleResolutionAttribute;\n+import jdk.internal.classfile.attribute.ModuleTargetAttribute;\n+import jdk.internal.classfile.java.lang.constant.ModuleDesc;\n+import jdk.internal.classfile.java.lang.constant.PackageDesc;\n@@ -37,9 +48,0 @@\n-import jdk.internal.org.objectweb.asm.Attribute;\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassVisitor;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.ModuleVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.commons.ModuleHashesAttribute;\n-import jdk.internal.org.objectweb.asm.commons.ModuleResolutionAttribute;\n-import jdk.internal.org.objectweb.asm.commons.ModuleTargetAttribute;\n@@ -151,38 +153,6 @@\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS\n-                                         + ClassWriter.COMPUTE_FRAMES);\n-\n-        ClassReader cr = new ClassReader(in);\n-\n-        ClassVisitor cv = new ClassVisitor(Opcodes.ASM7, cw) {\n-            @Override\n-            public ModuleVisitor visitModule(String name, int flags, String version) {\n-                Version v = ModuleInfoExtender.this.version;\n-                String vs = (v != null) ? v.toString() : version;\n-                ModuleVisitor mv = super.visitModule(name, flags, vs);\n-\n-                \/\/ ModuleMainClass attribute\n-                if (mainClass != null) {\n-                    mv.visitMainClass(mainClass.replace('.', '\/'));\n-                }\n-\n-                \/\/ ModulePackages attribute\n-                if (packages != null) {\n-                    packages.stream()\n-                            .sorted()\n-                            .forEach(pn -> mv.visitPackage(pn.replace('.', '\/')));\n-                }\n-\n-                return new ModuleVisitor(Opcodes.ASM7, mv) {\n-                    public void visitMainClass(String existingMainClass) {\n-                        \/\/ skip main class if there is a new value\n-                        if (mainClass == null) {\n-                            super.visitMainClass(existingMainClass);\n-                        }\n-                    }\n-                    public void visitPackage(String existingPackage) {\n-                        \/\/ skip packages if there is a new set of packages\n-                        if (packages == null) {\n-                            super.visitPackage(existingPackage);\n-                        }\n-                    }\n-                };\n+        var cm = Classfile.parse(in.readAllBytes());\n+        Version v = ModuleInfoExtender.this.version;\n+        return cm.transform(ClassTransform.endHandler(clb -> {\n+            \/\/ ModuleMainClass attribute\n+            if (mainClass != null) {\n+                clb.with(ModuleMainClassAttribute.of(ClassDesc.of(mainClass)));\n@@ -190,15 +160,0 @@\n-            @Override\n-            public void visitAttribute(Attribute attr) {\n-                String name = attr.type;\n-                \/\/ drop existing attributes if there are replacements\n-                if (name.equals(ClassFileConstants.MODULE_TARGET)\n-                    && targetPlatform != null)\n-                    return;\n-                if (name.equals(ClassFileConstants.MODULE_RESOLUTION)\n-                    && moduleResolution != null)\n-                    return;\n-                if (name.equals(ClassFileConstants.MODULE_HASHES)\n-                    && hashes != null)\n-                    return;\n-\n-                super.visitAttribute(attr);\n@@ -206,0 +161,7 @@\n+            \/\/ ModulePackages attribute\n+            if (packages != null) {\n+                List<PackageDesc> packageNames = packages.stream()\n+                        .sorted()\n+                        .map(PackageDesc::of)\n+                        .toList();\n+                clb.with(ModulePackagesAttribute.ofNames(packageNames));\n@@ -207,26 +169,0 @@\n-        };\n-\n-        List<Attribute> attrs = new ArrayList<>();\n-        attrs.add(new ModuleTargetAttribute());\n-        attrs.add(new ModuleResolutionAttribute());\n-        attrs.add(new ModuleHashesAttribute());\n-        cr.accept(cv, attrs.toArray(new Attribute[0]), 0);\n-\n-        \/\/ add ModuleTarget, ModuleResolution and ModuleHashes attributes\n-        if (targetPlatform != null) {\n-            cw.visitAttribute(new ModuleTargetAttribute(targetPlatform));\n-        }\n-        if (moduleResolution != null) {\n-            int flags = moduleResolution.value();\n-            cw.visitAttribute(new ModuleResolutionAttribute(flags));\n-        }\n-        if (hashes != null) {\n-            String algorithm = hashes.algorithm();\n-            List<String> names = new ArrayList<>();\n-            List<byte[]> values = new ArrayList<>();\n-            for (String name : hashes.names()) {\n-                names.add(name);\n-                values.add(hashes.hashFor(name));\n-            }\n-            cw.visitAttribute(new ModuleHashesAttribute(algorithm, names, values));\n-        }\n@@ -234,1 +170,30 @@\n-        return cw.toByteArray();\n+            \/\/ ModuleTarget, ModuleResolution and ModuleHashes attributes\n+            if (targetPlatform != null) {\n+                clb.with(ModuleTargetAttribute.of(targetPlatform));\n+            }\n+            if (moduleResolution != null) {\n+                clb.with(ModuleResolutionAttribute.of(moduleResolution.value()));\n+            }\n+            if (hashes != null) {\n+                clb.with(ModuleHashesAttribute.of(\n+                        hashes.algorithm(),\n+                        hashes.hashes().entrySet().stream().map(he ->\n+                                ModuleHashInfo.of(ModuleDesc.of(\n+                                        he.getKey()),\n+                                        he.getValue())).toList()));\n+            }\n+        }).andThen((clb, cle) -> {\n+            if (v != null && cle instanceof ModuleAttribute ma) {\n+                clb.with(ModuleAttribute.of(\n+                        ma.moduleName(),\n+                        ma.moduleFlagsMask(),\n+                        clb.constantPool().utf8Entry(v.toString()),\n+                        ma.requires(),\n+                        ma.exports(),\n+                        ma.opens(),\n+                        ma.uses(),\n+                        ma.provides()));\n+            } else {\n+                clb.accept(cle);\n+            }\n+        }));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleInfoExtender.java","additions":55,"deletions":90,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.module.InvalidModuleDescriptorException;\n@@ -32,8 +34,7 @@\n-import java.util.stream.Stream;\n-\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.ModuleVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.commons.ModuleResolutionAttribute;\n-import jdk.internal.org.objectweb.asm.commons.ModuleTargetAttribute;\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.java.lang.constant.ModuleDesc;\n+import jdk.internal.classfile.java.lang.constant.PackageDesc;\n+import jdk.internal.classfile.attribute.ModuleAttribute;\n+import jdk.internal.classfile.attribute.ModuleMainClassAttribute;\n+import jdk.internal.classfile.attribute.ModuleResolutionAttribute;\n+import jdk.internal.classfile.attribute.ModuleTargetAttribute;\n@@ -49,3 +50,3 @@\n-            ModuleDescriptor.Modifier.OPEN, ACC_OPEN,\n-            ModuleDescriptor.Modifier.SYNTHETIC, ACC_SYNTHETIC,\n-            ModuleDescriptor.Modifier.MANDATED, ACC_MANDATED\n+            ModuleDescriptor.Modifier.OPEN, Classfile.ACC_OPEN,\n+            ModuleDescriptor.Modifier.SYNTHETIC, Classfile.ACC_SYNTHETIC,\n+            ModuleDescriptor.Modifier.MANDATED, Classfile.ACC_MANDATED\n@@ -56,4 +57,4 @@\n-            ModuleDescriptor.Requires.Modifier.TRANSITIVE, ACC_TRANSITIVE,\n-            ModuleDescriptor.Requires.Modifier.STATIC, ACC_STATIC_PHASE,\n-            ModuleDescriptor.Requires.Modifier.SYNTHETIC, ACC_SYNTHETIC,\n-            ModuleDescriptor.Requires.Modifier.MANDATED, ACC_MANDATED\n+            ModuleDescriptor.Requires.Modifier.TRANSITIVE, Classfile.ACC_TRANSITIVE,\n+            ModuleDescriptor.Requires.Modifier.STATIC, Classfile.ACC_STATIC_PHASE,\n+            ModuleDescriptor.Requires.Modifier.SYNTHETIC, Classfile.ACC_SYNTHETIC,\n+            ModuleDescriptor.Requires.Modifier.MANDATED, Classfile.ACC_MANDATED\n@@ -64,2 +65,2 @@\n-            ModuleDescriptor.Exports.Modifier.SYNTHETIC, ACC_SYNTHETIC,\n-            ModuleDescriptor.Exports.Modifier.MANDATED, ACC_MANDATED\n+            ModuleDescriptor.Exports.Modifier.SYNTHETIC, Classfile.ACC_SYNTHETIC,\n+            ModuleDescriptor.Exports.Modifier.MANDATED, Classfile.ACC_MANDATED\n@@ -70,2 +71,2 @@\n-            ModuleDescriptor.Opens.Modifier.SYNTHETIC, ACC_SYNTHETIC,\n-            ModuleDescriptor.Opens.Modifier.MANDATED, ACC_MANDATED\n+            ModuleDescriptor.Opens.Modifier.SYNTHETIC, Classfile.ACC_SYNTHETIC,\n+            ModuleDescriptor.Opens.Modifier.MANDATED, Classfile.ACC_MANDATED\n@@ -74,2 +75,0 @@\n-    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n-\n@@ -85,46 +84,74 @@\n-        ClassWriter cw = new ClassWriter(0);\n-        cw.visit(Opcodes.V10, ACC_MODULE, \"module-info\", null, null, null);\n-\n-        int moduleFlags = md.modifiers().stream()\n-                .map(MODULE_MODS_TO_FLAGS::get)\n-                .reduce(0, (x, y) -> (x | y));\n-        String vs = md.rawVersion().orElse(null);\n-        ModuleVisitor mv = cw.visitModule(md.name(), moduleFlags, vs);\n-\n-        \/\/ requires\n-        for (ModuleDescriptor.Requires r : md.requires()) {\n-            int flags = r.modifiers().stream()\n-                    .map(REQUIRES_MODS_TO_FLAGS::get)\n-                    .reduce(0, (x, y) -> (x | y));\n-            vs = r.rawCompiledVersion().orElse(null);\n-            mv.visitRequire(r.name(), flags, vs);\n-        }\n-\n-        \/\/ exports\n-        for (ModuleDescriptor.Exports e : md.exports()) {\n-            int flags = e.modifiers().stream()\n-                    .map(EXPORTS_MODS_TO_FLAGS::get)\n-                    .reduce(0, (x, y) -> (x | y));\n-            String[] targets = e.targets().toArray(EMPTY_STRING_ARRAY);\n-            mv.visitExport(e.source().replace('.', '\/'), flags, targets);\n-        }\n-\n-        \/\/ opens\n-        for (ModuleDescriptor.Opens opens : md.opens()) {\n-            int flags = opens.modifiers().stream()\n-                    .map(OPENS_MODS_TO_FLAGS::get)\n-                    .reduce(0, (x, y) -> (x | y));\n-            String[] targets = opens.targets().toArray(EMPTY_STRING_ARRAY);\n-            mv.visitOpen(opens.source().replace('.', '\/'), flags, targets);\n-        }\n-\n-        \/\/ uses\n-        md.uses().stream().map(sn -> sn.replace('.', '\/')).forEach(mv::visitUse);\n-\n-        \/\/ provides\n-        for (ModuleDescriptor.Provides p : md.provides()) {\n-            mv.visitProvide(p.service().replace('.', '\/'),\n-                            p.providers()\n-                                .stream()\n-                                .map(pn -> pn.replace('.', '\/'))\n-                                .toArray(String[]::new));\n+        try {\n+            return Classfile.buildModule(\n+                ModuleAttribute.of(ModuleDesc.of(md.name()), mb -> {\n+                    mb.moduleFlags(md.modifiers().stream()\n+                            .mapToInt(mm -> MODULE_MODS_TO_FLAGS.getOrDefault(mm, 0))\n+                            .reduce(0, (x, y) -> (x | y)));\n+\n+                    String vs = md.rawVersion().orElse(null);\n+                    if (vs != null) mb.moduleVersion(vs);\n+\n+                    \/\/ requires\n+                    for (ModuleDescriptor.Requires r : md.requires()) {\n+                        int flags = r.modifiers().stream()\n+                                .mapToInt(REQUIRES_MODS_TO_FLAGS::get)\n+                                .reduce(0, (x, y) -> (x | y));\n+                        vs = r.rawCompiledVersion().orElse(null);\n+                        mb.requires(ModuleDesc.of(r.name()), flags, vs);\n+                    }\n+\n+                    \/\/ exports\n+                    for (ModuleDescriptor.Exports e : md.exports()) {\n+                        int flags = e.modifiers().stream()\n+                                .mapToInt(EXPORTS_MODS_TO_FLAGS::get)\n+                                .reduce(0, (x, y) -> (x | y));\n+                        var targets = e.targets().stream().map(ModuleDesc::of)\n+                                .toArray(ModuleDesc[]::new);\n+                        mb.exports(PackageDesc.of(e.source()), flags, targets);\n+                    }\n+\n+                    \/\/ opens\n+                    for (ModuleDescriptor.Opens opens : md.opens()) {\n+                        int flags = opens.modifiers().stream()\n+                                .mapToInt(OPENS_MODS_TO_FLAGS::get)\n+                                .reduce(0, (x, y) -> (x | y));\n+                        var targets = opens.targets().stream().map(ModuleDesc::of)\n+                                .toArray(ModuleDesc[]::new);\n+                        mb.opens(PackageDesc.of(opens.source()), flags, targets);\n+                    }\n+\n+                    \/\/ uses\n+                    md.uses().stream().map(ClassDesc::of).forEach(mb::uses);\n+\n+                    \/\/ provides\n+                    for (ModuleDescriptor.Provides p : md.provides()) {\n+                        mb.provides(ClassDesc.of(p.service()),\n+                                                 p.providers().stream()\n+                                                         .map(ClassDesc::of)\n+                                                         .toArray(ClassDesc[]::new));\n+                    }\n+                }),\n+\n+                \/\/ packages\n+                md.packages().stream().map(PackageDesc::of).toList(),\n+\n+                \/\/ extra attributes\n+                clb -> {\n+                    \/\/ ModuleMainClass attribute\n+                    md.mainClass().ifPresent(mc ->\n+                            clb.with(ModuleMainClassAttribute.of(ClassDesc.of(mc))));\n+\n+                    \/\/ write ModuleResolution attribute if specified\n+                    if (mres != null) {\n+                        clb.with(ModuleResolutionAttribute.of(mres.value()));\n+                    }\n+\n+                    \/\/ write ModuleTarget attribute if there is a target platform\n+                    if (target != null && !target.targetPlatform().isEmpty()) {\n+                        clb.with(ModuleTargetAttribute.of(target.targetPlatform()));\n+                    }\n+                });\n+        } catch (IllegalArgumentException iae) {\n+            var t = new InvalidModuleDescriptorException(iae.getMessage());\n+            t.initCause(iae);\n+            throw t;\n@@ -132,33 +159,0 @@\n-\n-        \/\/ add the ModulePackages attribute when there are packages that aren't\n-        \/\/ exported or open\n-        Stream<String> exported = md.exports().stream()\n-                .map(ModuleDescriptor.Exports::source);\n-        Stream<String> open = md.opens().stream()\n-                .map(ModuleDescriptor.Opens::source);\n-        long exportedOrOpen = Stream.concat(exported, open).distinct().count();\n-        if (md.packages().size() > exportedOrOpen) {\n-            md.packages().stream()\n-                    .map(pn -> pn.replace('.', '\/'))\n-                    .forEach(mv::visitPackage);\n-        }\n-\n-        \/\/ ModuleMainClass attribute\n-        md.mainClass()\n-            .map(mc -> mc.replace('.', '\/'))\n-            .ifPresent(mv::visitMainClass);\n-\n-        mv.visitEnd();\n-\n-        \/\/ write ModuleResolution attribute if specified\n-        if (mres != null) {\n-            cw.visitAttribute(new ModuleResolutionAttribute(mres.value()));\n-        }\n-\n-        \/\/ write ModuleTarget attribute if there is a target platform\n-        if (target != null && target.targetPlatform().length() > 0) {\n-            cw.visitAttribute(new ModuleTargetAttribute(target.targetPlatform()));\n-        }\n-\n-        cw.visitEnd();\n-        return cw.toByteArray();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleInfoWriter.java","additions":94,"deletions":100,"binary":false,"changes":194,"status":"modified"}]}