{"files":[{"patch":"@@ -253,1 +253,1 @@\n-        return buildModule(moduleAttribute, List.of(), clb -> {});\n+        return buildModule(moduleAttribute, clb -> {});\n@@ -259,12 +259,0 @@\n-     * @param packages additional module packages\n-     * @return the classfile bytes\n-     *\/\n-    public static byte[] buildModule(ModuleAttribute moduleAttribute,\n-                                     List<PackageDesc> packages) {\n-        return buildModule(moduleAttribute, packages, clb -> {});\n-    }\n-\n-    \/**\n-     * Build a module descriptor into a byte array.\n-     * @param moduleAttribute the {@code Module} attribute\n-     * @param packages additional module packages\n@@ -275,1 +263,0 @@\n-                                     List<PackageDesc> packages,\n@@ -280,11 +267,0 @@\n-            if (!packages.isEmpty()) {\n-                var cp = clb.constantPool();\n-                var allPackages = new LinkedHashSet<PackageEntry>();\n-                for (var exp : moduleAttribute.exports()) allPackages.add(AbstractPoolEntry.maybeClone(cp, exp.exportedPackage()));\n-                for (var opn : moduleAttribute.opens()) allPackages.add(AbstractPoolEntry.maybeClone(cp, opn.openedPackage()));\n-                boolean emitMPA = false;\n-                for (var p : packages)\n-                    emitMPA |= allPackages.add(cp.packageEntry(p));\n-                if(emitMPA)\n-                    clb.with(new UnboundAttribute.UnboundModulePackagesAttribute(allPackages));\n-            }\n@@ -302,13 +278,1 @@\n-        buildModuleTo(path, moduleAttribute, List.of(), clb -> {});\n-    }\n-\n-    \/**\n-     * Build a module descriptor into a file.\n-     * @param path the file to write\n-     * @param moduleAttribute the {@code Module} attribute\n-     * @param packages additional module packages\n-     *\/\n-    public static void buildModuleTo(Path path,\n-                                     ModuleAttribute moduleAttribute,\n-                                     List<PackageDesc> packages) throws IOException {\n-        buildModuleTo(path, moduleAttribute, packages, clb -> {});\n+        buildModuleTo(path, moduleAttribute, clb -> {});\n@@ -321,1 +285,0 @@\n-     * @param packages additional module packages\n@@ -326,1 +289,0 @@\n-                                     List<PackageDesc> packages,\n@@ -328,1 +290,1 @@\n-        Files.write(path, buildModule(moduleAttribute, packages, handler));\n+        Files.write(path, buildModule(moduleAttribute, handler));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/Classfile.java","additions":3,"deletions":41,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -145,0 +145,13 @@\n+    \/**\n+     * {@return a {@code Module} attribute}\n+     *\n+     * @param moduleName the module name\n+     * @param attrHandler a handler that receives a {@link ModuleAttributeBuilder}\n+     *\/\n+    static ModuleAttribute of(ModuleEntry moduleName,\n+                              Consumer<ModuleAttributeBuilder> attrHandler) {\n+        var mb = new ModuleAttributeBuilderImpl(moduleName);\n+        attrHandler.accept(mb);\n+        return  mb.build();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/ModuleAttribute.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -52,2 +52,2 @@\n-    public ModuleAttributeBuilderImpl(ModuleDesc moduleName) {\n-        this.moduleEntry = TemporaryConstantPool.INSTANCE.moduleEntry(TemporaryConstantPool.INSTANCE.utf8Entry(moduleName.moduleName()));\n+    public ModuleAttributeBuilderImpl(ModuleEntry moduleName) {\n+        this.moduleEntry = moduleName;\n@@ -57,0 +57,4 @@\n+    public ModuleAttributeBuilderImpl(ModuleDesc moduleName) {\n+        this(TemporaryConstantPool.INSTANCE.moduleEntry(TemporaryConstantPool.INSTANCE.utf8Entry(moduleName.moduleName())));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ModuleAttributeBuilderImpl.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.constant.ClassDesc;\n@@ -32,1 +33,0 @@\n-import java.util.ArrayList;\n@@ -36,0 +36,11 @@\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.attribute.ModuleAttribute;\n+import jdk.internal.classfile.attribute.ModuleHashInfo;\n+import jdk.internal.classfile.attribute.ModuleHashesAttribute;\n+import jdk.internal.classfile.attribute.ModuleMainClassAttribute;\n+import jdk.internal.classfile.attribute.ModulePackagesAttribute;\n+import jdk.internal.classfile.attribute.ModuleResolutionAttribute;\n+import jdk.internal.classfile.attribute.ModuleTargetAttribute;\n+import jdk.internal.classfile.java.lang.constant.ModuleDesc;\n+import jdk.internal.classfile.java.lang.constant.PackageDesc;\n@@ -37,9 +48,0 @@\n-import jdk.internal.org.objectweb.asm.Attribute;\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassVisitor;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.ModuleVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.commons.ModuleHashesAttribute;\n-import jdk.internal.org.objectweb.asm.commons.ModuleResolutionAttribute;\n-import jdk.internal.org.objectweb.asm.commons.ModuleTargetAttribute;\n@@ -151,38 +153,6 @@\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS\n-                                         + ClassWriter.COMPUTE_FRAMES);\n-\n-        ClassReader cr = new ClassReader(in);\n-\n-        ClassVisitor cv = new ClassVisitor(Opcodes.ASM7, cw) {\n-            @Override\n-            public ModuleVisitor visitModule(String name, int flags, String version) {\n-                Version v = ModuleInfoExtender.this.version;\n-                String vs = (v != null) ? v.toString() : version;\n-                ModuleVisitor mv = super.visitModule(name, flags, vs);\n-\n-                \/\/ ModuleMainClass attribute\n-                if (mainClass != null) {\n-                    mv.visitMainClass(mainClass.replace('.', '\/'));\n-                }\n-\n-                \/\/ ModulePackages attribute\n-                if (packages != null) {\n-                    packages.stream()\n-                            .sorted()\n-                            .forEach(pn -> mv.visitPackage(pn.replace('.', '\/')));\n-                }\n-\n-                return new ModuleVisitor(Opcodes.ASM7, mv) {\n-                    public void visitMainClass(String existingMainClass) {\n-                        \/\/ skip main class if there is a new value\n-                        if (mainClass == null) {\n-                            super.visitMainClass(existingMainClass);\n-                        }\n-                    }\n-                    public void visitPackage(String existingPackage) {\n-                        \/\/ skip packages if there is a new set of packages\n-                        if (packages == null) {\n-                            super.visitPackage(existingPackage);\n-                        }\n-                    }\n-                };\n+        var cm = Classfile.parse(in.readAllBytes());\n+        Version v = ModuleInfoExtender.this.version;\n+        return cm.transform(ClassTransform.endHandler(clb -> {\n+            \/\/ ModuleMainClass attribute\n+            if (mainClass != null) {\n+                clb.with(ModuleMainClassAttribute.of(ClassDesc.of(mainClass)));\n@@ -190,15 +160,0 @@\n-            @Override\n-            public void visitAttribute(Attribute attr) {\n-                String name = attr.type;\n-                \/\/ drop existing attributes if there are replacements\n-                if (name.equals(ClassFileConstants.MODULE_TARGET)\n-                    && targetPlatform != null)\n-                    return;\n-                if (name.equals(ClassFileConstants.MODULE_RESOLUTION)\n-                    && moduleResolution != null)\n-                    return;\n-                if (name.equals(ClassFileConstants.MODULE_HASHES)\n-                    && hashes != null)\n-                    return;\n-\n-                super.visitAttribute(attr);\n@@ -206,0 +161,7 @@\n+            \/\/ ModulePackages attribute\n+            if (packages != null) {\n+                List<PackageDesc> packageNames = packages.stream()\n+                        .sorted()\n+                        .map(PackageDesc::of)\n+                        .toList();\n+                clb.with(ModulePackagesAttribute.ofNames(packageNames));\n@@ -207,26 +169,0 @@\n-        };\n-\n-        List<Attribute> attrs = new ArrayList<>();\n-        attrs.add(new ModuleTargetAttribute());\n-        attrs.add(new ModuleResolutionAttribute());\n-        attrs.add(new ModuleHashesAttribute());\n-        cr.accept(cv, attrs.toArray(new Attribute[0]), 0);\n-\n-        \/\/ add ModuleTarget, ModuleResolution and ModuleHashes attributes\n-        if (targetPlatform != null) {\n-            cw.visitAttribute(new ModuleTargetAttribute(targetPlatform));\n-        }\n-        if (moduleResolution != null) {\n-            int flags = moduleResolution.value();\n-            cw.visitAttribute(new ModuleResolutionAttribute(flags));\n-        }\n-        if (hashes != null) {\n-            String algorithm = hashes.algorithm();\n-            List<String> names = new ArrayList<>();\n-            List<byte[]> values = new ArrayList<>();\n-            for (String name : hashes.names()) {\n-                names.add(name);\n-                values.add(hashes.hashFor(name));\n-            }\n-            cw.visitAttribute(new ModuleHashesAttribute(algorithm, names, values));\n-        }\n@@ -234,1 +170,30 @@\n-        return cw.toByteArray();\n+            \/\/ ModuleTarget, ModuleResolution and ModuleHashes attributes\n+            if (targetPlatform != null) {\n+                clb.with(ModuleTargetAttribute.of(targetPlatform));\n+            }\n+            if (moduleResolution != null) {\n+                clb.with(ModuleResolutionAttribute.of(moduleResolution.value()));\n+            }\n+            if (hashes != null) {\n+                clb.with(ModuleHashesAttribute.of(\n+                        hashes.algorithm(),\n+                        hashes.hashes().entrySet().stream().map(he ->\n+                                ModuleHashInfo.of(ModuleDesc.of(\n+                                        he.getKey()),\n+                                        he.getValue())).toList()));\n+            }\n+        }).andThen((clb, cle) -> {\n+            if (v != null && cle instanceof ModuleAttribute ma) {\n+                clb.with(ModuleAttribute.of(\n+                        ma.moduleName(),\n+                        ma.moduleFlagsMask(),\n+                        clb.constantPool().utf8Entry(v.toString()),\n+                        ma.requires(),\n+                        ma.exports(),\n+                        ma.opens(),\n+                        ma.uses(),\n+                        ma.provides()));\n+            } else {\n+                clb.accept(cle);\n+            }\n+        }));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleInfoExtender.java","additions":55,"deletions":90,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.constant.ClassDesc;\n@@ -30,0 +31,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -32,8 +34,11 @@\n-import java.util.stream.Stream;\n-\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.ModuleVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.commons.ModuleResolutionAttribute;\n-import jdk.internal.org.objectweb.asm.commons.ModuleTargetAttribute;\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.java.lang.constant.PackageDesc;\n+import jdk.internal.classfile.attribute.ModuleAttribute;\n+import jdk.internal.classfile.attribute.ModuleExportInfo;\n+import jdk.internal.classfile.attribute.ModuleMainClassAttribute;\n+import jdk.internal.classfile.attribute.ModuleOpenInfo;\n+import jdk.internal.classfile.attribute.ModulePackagesAttribute;\n+import jdk.internal.classfile.attribute.ModuleResolutionAttribute;\n+import jdk.internal.classfile.attribute.ModuleRequireInfo;\n+import jdk.internal.classfile.attribute.ModuleTargetAttribute;\n+import jdk.internal.classfile.constantpool.ModuleEntry;\n@@ -49,3 +54,3 @@\n-            ModuleDescriptor.Modifier.OPEN, ACC_OPEN,\n-            ModuleDescriptor.Modifier.SYNTHETIC, ACC_SYNTHETIC,\n-            ModuleDescriptor.Modifier.MANDATED, ACC_MANDATED\n+            ModuleDescriptor.Modifier.OPEN, Classfile.ACC_OPEN,\n+            ModuleDescriptor.Modifier.SYNTHETIC, Classfile.ACC_SYNTHETIC,\n+            ModuleDescriptor.Modifier.MANDATED, Classfile.ACC_MANDATED\n@@ -56,4 +61,4 @@\n-            ModuleDescriptor.Requires.Modifier.TRANSITIVE, ACC_TRANSITIVE,\n-            ModuleDescriptor.Requires.Modifier.STATIC, ACC_STATIC_PHASE,\n-            ModuleDescriptor.Requires.Modifier.SYNTHETIC, ACC_SYNTHETIC,\n-            ModuleDescriptor.Requires.Modifier.MANDATED, ACC_MANDATED\n+            ModuleDescriptor.Requires.Modifier.TRANSITIVE, Classfile.ACC_TRANSITIVE,\n+            ModuleDescriptor.Requires.Modifier.STATIC, Classfile.ACC_STATIC_PHASE,\n+            ModuleDescriptor.Requires.Modifier.SYNTHETIC, Classfile.ACC_SYNTHETIC,\n+            ModuleDescriptor.Requires.Modifier.MANDATED, Classfile.ACC_MANDATED\n@@ -64,2 +69,2 @@\n-            ModuleDescriptor.Exports.Modifier.SYNTHETIC, ACC_SYNTHETIC,\n-            ModuleDescriptor.Exports.Modifier.MANDATED, ACC_MANDATED\n+            ModuleDescriptor.Exports.Modifier.SYNTHETIC, Classfile.ACC_SYNTHETIC,\n+            ModuleDescriptor.Exports.Modifier.MANDATED, Classfile.ACC_MANDATED\n@@ -70,2 +75,2 @@\n-            ModuleDescriptor.Opens.Modifier.SYNTHETIC, ACC_SYNTHETIC,\n-            ModuleDescriptor.Opens.Modifier.MANDATED, ACC_MANDATED\n+            ModuleDescriptor.Opens.Modifier.SYNTHETIC, Classfile.ACC_SYNTHETIC,\n+            ModuleDescriptor.Opens.Modifier.MANDATED, Classfile.ACC_MANDATED\n@@ -74,2 +79,0 @@\n-    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n-\n@@ -85,80 +88,80 @@\n-        ClassWriter cw = new ClassWriter(0);\n-        cw.visit(Opcodes.V10, ACC_MODULE, \"module-info\", null, null, null);\n-\n-        int moduleFlags = md.modifiers().stream()\n-                .map(MODULE_MODS_TO_FLAGS::get)\n-                .reduce(0, (x, y) -> (x | y));\n-        String vs = md.rawVersion().orElse(null);\n-        ModuleVisitor mv = cw.visitModule(md.name(), moduleFlags, vs);\n-\n-        \/\/ requires\n-        for (ModuleDescriptor.Requires r : md.requires()) {\n-            int flags = r.modifiers().stream()\n-                    .map(REQUIRES_MODS_TO_FLAGS::get)\n-                    .reduce(0, (x, y) -> (x | y));\n-            vs = r.rawCompiledVersion().orElse(null);\n-            mv.visitRequire(r.name(), flags, vs);\n-        }\n-\n-        \/\/ exports\n-        for (ModuleDescriptor.Exports e : md.exports()) {\n-            int flags = e.modifiers().stream()\n-                    .map(EXPORTS_MODS_TO_FLAGS::get)\n-                    .reduce(0, (x, y) -> (x | y));\n-            String[] targets = e.targets().toArray(EMPTY_STRING_ARRAY);\n-            mv.visitExport(e.source().replace('.', '\/'), flags, targets);\n-        }\n-\n-        \/\/ opens\n-        for (ModuleDescriptor.Opens opens : md.opens()) {\n-            int flags = opens.modifiers().stream()\n-                    .map(OPENS_MODS_TO_FLAGS::get)\n-                    .reduce(0, (x, y) -> (x | y));\n-            String[] targets = opens.targets().toArray(EMPTY_STRING_ARRAY);\n-            mv.visitOpen(opens.source().replace('.', '\/'), flags, targets);\n-        }\n-\n-        \/\/ uses\n-        md.uses().stream().map(sn -> sn.replace('.', '\/')).forEach(mv::visitUse);\n-\n-        \/\/ provides\n-        for (ModuleDescriptor.Provides p : md.provides()) {\n-            mv.visitProvide(p.service().replace('.', '\/'),\n-                            p.providers()\n-                                .stream()\n-                                .map(pn -> pn.replace('.', '\/'))\n-                                .toArray(String[]::new));\n-        }\n-\n-        \/\/ add the ModulePackages attribute when there are packages that aren't\n-        \/\/ exported or open\n-        Stream<String> exported = md.exports().stream()\n-                .map(ModuleDescriptor.Exports::source);\n-        Stream<String> open = md.opens().stream()\n-                .map(ModuleDescriptor.Opens::source);\n-        long exportedOrOpen = Stream.concat(exported, open).distinct().count();\n-        if (md.packages().size() > exportedOrOpen) {\n-            md.packages().stream()\n-                    .map(pn -> pn.replace('.', '\/'))\n-                    .forEach(mv::visitPackage);\n-        }\n-\n-        \/\/ ModuleMainClass attribute\n-        md.mainClass()\n-            .map(mc -> mc.replace('.', '\/'))\n-            .ifPresent(mv::visitMainClass);\n-\n-        mv.visitEnd();\n-\n-        \/\/ write ModuleResolution attribute if specified\n-        if (mres != null) {\n-            cw.visitAttribute(new ModuleResolutionAttribute(mres.value()));\n-        }\n-\n-        \/\/ write ModuleTarget attribute if there is a target platform\n-        if (target != null && target.targetPlatform().length() > 0) {\n-            cw.visitAttribute(new ModuleTargetAttribute(target.targetPlatform()));\n-        }\n-\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+        \/\/using low-level module building to avoid validation in ModuleDesc and allow invalid names\n+        return Classfile.build(ClassDesc.of(\"module-info\"), clb -> {\n+            clb.withFlags(AccessFlag.MODULE);\n+            var cp = clb.constantPool();\n+            clb.with(ModuleAttribute.of(cp.moduleEntry(cp.utf8Entry(md.name())), mb -> {\n+                    mb.moduleFlags(md.modifiers().stream()\n+                            .mapToInt(mm -> MODULE_MODS_TO_FLAGS.getOrDefault(mm, 0))\n+                            .reduce(0, (x, y) -> (x | y)));\n+\n+                    md.rawVersion().ifPresent(vs -> mb.moduleVersion(vs));\n+\n+                    \/\/ requires\n+                    for (ModuleDescriptor.Requires r : md.requires()) {\n+                        int flags = r.modifiers().stream()\n+                                .mapToInt(REQUIRES_MODS_TO_FLAGS::get)\n+                                .reduce(0, (x, y) -> (x | y));\n+                        mb.requires(ModuleRequireInfo.of(\n+                                cp.moduleEntry(cp.utf8Entry(r.name())),\n+                                flags,\n+                                r.rawCompiledVersion().map(cp::utf8Entry).orElse(null)));\n+                    }\n+\n+                    \/\/ exports\n+                    for (ModuleDescriptor.Exports e : md.exports()) {\n+                        int flags = e.modifiers().stream()\n+                                .mapToInt(EXPORTS_MODS_TO_FLAGS::get)\n+                                .reduce(0, (x, y) -> (x | y));\n+                        var targets = e.targets().stream().map(mn -> cp.moduleEntry(cp.utf8Entry(mn)))\n+                                .toArray(ModuleEntry[]::new);\n+                        mb.exports(ModuleExportInfo.of(\n+                                cp.packageEntry(cp.utf8Entry(e.source())),\n+                                flags,\n+                                targets));\n+                    }\n+\n+                    \/\/ opens\n+                    for (ModuleDescriptor.Opens opens : md.opens()) {\n+                        int flags = opens.modifiers().stream()\n+                                .mapToInt(OPENS_MODS_TO_FLAGS::get)\n+                                .reduce(0, (x, y) -> (x | y));\n+                        var targets = opens.targets().stream().map(mn -> cp.moduleEntry(cp.utf8Entry(mn)))\n+                                .toArray(ModuleEntry[]::new);\n+                        mb.opens(ModuleOpenInfo.of(\n+                                cp.packageEntry(cp.utf8Entry(opens.source())),\n+                                flags,\n+                                targets));\n+                    }\n+\n+                    \/\/ uses\n+                    md.uses().stream().map(ClassDesc::of).forEach(mb::uses);\n+\n+                    \/\/ provides\n+                    for (ModuleDescriptor.Provides p : md.provides()) {\n+                        mb.provides(ClassDesc.of(p.service()),\n+                                                 p.providers().stream()\n+                                                         .map(ClassDesc::of)\n+                                                         .toArray(ClassDesc[]::new));\n+                    }\n+                }));\n+\n+                \/\/ packages\n+                var packages = md.packages().stream().sorted().map(PackageDesc::of).toList();\n+                if (!packages.isEmpty()) {\n+                    clb.with(ModulePackagesAttribute.ofNames(packages));\n+                }\n+\n+                \/\/ ModuleMainClass attribute\n+                md.mainClass().ifPresent(mc ->\n+                        clb.with(ModuleMainClassAttribute.of(ClassDesc.of(mc))));\n+\n+                \/\/ write ModuleResolution attribute if specified\n+                if (mres != null) {\n+                    clb.with(ModuleResolutionAttribute.of(mres.value()));\n+                }\n+\n+                \/\/ write ModuleTarget attribute if there is a target platform\n+                if (target != null && !target.targetPlatform().isEmpty()) {\n+                    clb.with(ModuleTargetAttribute.of(target.targetPlatform()));\n+                }\n+            });\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleInfoWriter.java","additions":104,"deletions":101,"binary":false,"changes":205,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.java.lang.constant\n@@ -60,0 +63,4 @@\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.attribute.ModuleAttribute;\n+import jdk.internal.classfile.java.lang.constant.PackageDesc;\n+import jdk.internal.classfile.java.lang.constant.ModuleDesc;\n@@ -1365,8 +1372,4 @@\n-        ModuleDescriptor descriptor = ModuleDescriptor.newModule(\"foo\")\n-                .requires(\"java.base\")\n-                .exports(\"p\")\n-                .build();\n-\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        ModuleInfoWriter.write(descriptor, baos);\n-        ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());\n+        ByteBuffer bb = ByteBuffer.wrap(Classfile.buildModule(\n+                ModuleAttribute.of(ModuleDesc.of(\"foo\"), mb -> mb\n+                        .requires(ModuleDesc.of(\"java.base\"), 0, null)\n+                        .exports(PackageDesc.of(\"p\"), 0))));\n","filename":"test\/jdk\/java\/lang\/module\/ModuleDescriptorTest.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -88,1 +88,0 @@\n-                List.of(PackageDesc.of(\"foo.bar.baz\"), PackageDesc.of(\"quux\"), PackageDesc.of(\"foo.bar.baz\"), PackageDesc.of(\"quux\")),\n@@ -90,0 +89,1 @@\n+                          .with(ModulePackagesAttribute.ofNames(PackageDesc.of(\"foo.bar.baz\"), PackageDesc.of(\"quux\")))\n@@ -185,1 +185,1 @@\n-        assertEquals(a.packages().stream().map(pe -> pe.asSymbol().packageName()).toList(), List.of(\"0\", \"1\", \"2\", \"3\", \"4\", \"o0\", \"o1\", \"o2\", \"foo.bar.baz\", \"quux\"));\n+        assertEquals(a.packages().stream().map(pe -> pe.asSymbol().packageName()).toList(), List.of(\"foo.bar.baz\", \"quux\"));\n","filename":"test\/jdk\/jdk\/classfile\/ModuleBuilderTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-        byte[] moduleInfo = Classfile.buildModule(ModuleAttribute.of(moduleName, handler), List.of(), clb -> {\n+        byte[] moduleInfo = Classfile.buildModule(ModuleAttribute.of(moduleName, handler), clb -> {\n","filename":"test\/jdk\/jdk\/classfile\/examples\/ModuleExamples.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}