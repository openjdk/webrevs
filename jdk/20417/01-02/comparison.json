{"files":[{"patch":"@@ -0,0 +1,382 @@\n+\/*\n+ * Copyright (c) 2024, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#ifdef COMPILER2\n+#include \"asm\/macroAssembler.hpp\"\n+#include \"asm\/macroAssembler.inline.hpp\"\n+#include \"code\/vmreg.hpp\"\n+#include \"interpreter\/interpreter.hpp\"\n+#include \"opto\/runtime.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+#include \"runtime\/vframeArray.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"vmreg_riscv.inline.hpp\"\n+\n+class SimpleRuntimeFrame {\n+public:\n+\n+  \/\/ Most of the runtime stubs have this simple frame layout.\n+  \/\/ This class exists to make the layout shared in one place.\n+  \/\/ Offsets are for compiler stack slots, which are jints.\n+  enum layout {\n+    \/\/ The frame sender code expects that fp will be in the \"natural\" place and\n+    \/\/ will override any oopMap setting for it. We must therefore force the layout\n+    \/\/ so that it agrees with the frame sender code.\n+    \/\/ we don't expect any arg reg save area so riscv asserts that\n+    \/\/ frame::arg_reg_save_area_bytes == 0\n+    fp_off = 0, fp_off2,\n+    return_off, return_off2,\n+    framesize\n+  };\n+};\n+\n+#define __ masm->\n+\n+\/\/------------------------------generate_uncommon_trap_blob--------------------\n+void SharedRuntime::generate_uncommon_trap_blob() {\n+  \/\/ Allocate space for the code\n+  ResourceMark rm;\n+  \/\/ Setup code generation tools\n+  CodeBuffer buffer(\"uncommon_trap_blob\", 2048, 1024);\n+  MacroAssembler* masm = new MacroAssembler(&buffer);\n+  assert_cond(masm != nullptr);\n+\n+  assert(SimpleRuntimeFrame::framesize % 4 == 0, \"sp not 16-byte aligned\");\n+\n+  address start = __ pc();\n+\n+  \/\/ Push self-frame.  We get here with a return address in RA\n+  \/\/ and sp should be 16 byte aligned\n+  \/\/ push fp and retaddr by hand\n+  __ addi(sp, sp, -2 * wordSize);\n+  __ sd(ra, Address(sp, wordSize));\n+  __ sd(fp, Address(sp, 0));\n+  \/\/ we don't expect an arg reg save area\n+#ifndef PRODUCT\n+  assert(frame::arg_reg_save_area_bytes == 0, \"not expecting frame reg save area\");\n+#endif\n+  \/\/ compiler left unloaded_class_index in j_rarg0 move to where the\n+  \/\/ runtime expects it.\n+  __ sign_extend(c_rarg1, j_rarg0, 32);\n+\n+  \/\/ we need to set the past SP to the stack pointer of the stub frame\n+  \/\/ and the pc to the address where this runtime call will return\n+  \/\/ although actually any pc in this code blob will do).\n+  Label retaddr;\n+  __ set_last_Java_frame(sp, noreg, retaddr, t0);\n+\n+  \/\/ Call C code.  Need thread but NOT official VM entry\n+  \/\/ crud.  We cannot block on this call, no GC can happen.  Call should\n+  \/\/ capture callee-saved registers as well as return values.\n+  \/\/\n+  \/\/ UnrollBlock* uncommon_trap(JavaThread* thread, jint unloaded_class_index, jint exec_mode)\n+  \/\/\n+  \/\/ n.b. 3 gp args, 0 fp args, integral return type\n+\n+  __ mv(c_rarg0, xthread);\n+  __ mv(c_rarg2, Deoptimization::Unpack_uncommon_trap);\n+  __ rt_call(CAST_FROM_FN_PTR(address, Deoptimization::uncommon_trap));\n+  __ bind(retaddr);\n+\n+  \/\/ Set an oopmap for the call site\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(SimpleRuntimeFrame::framesize, 0);\n+  assert_cond(oop_maps != nullptr && map != nullptr);\n+\n+  \/\/ location of fp is known implicitly by the frame sender code\n+\n+  oop_maps->add_gc_map(__ pc() - start, map);\n+\n+  __ reset_last_Java_frame(false);\n+\n+  \/\/ move UnrollBlock* into x14\n+  __ mv(x14, x10);\n+\n+#ifdef ASSERT\n+  { Label L;\n+    __ lwu(t0, Address(x14, Deoptimization::UnrollBlock::unpack_kind_offset()));\n+    __ mv(t1, Deoptimization::Unpack_uncommon_trap);\n+    __ beq(t0, t1, L);\n+    __ stop(\"SharedRuntime::generate_uncommon_trap_blob: expected Unpack_uncommon_trap\");\n+    __ bind(L);\n+  }\n+#endif\n+\n+  \/\/ Pop all the frames we must move\/replace.\n+  \/\/\n+  \/\/ Frame picture (youngest to oldest)\n+  \/\/ 1: self-frame (no frame link)\n+  \/\/ 2: deopting frame  (no frame link)\n+  \/\/ 3: caller of deopting frame (could be compiled\/interpreted).\n+\n+  __ add(sp, sp, (SimpleRuntimeFrame::framesize) << LogBytesPerInt); \/\/ Epilog!\n+\n+  \/\/ Pop deoptimized frame (int)\n+  __ lwu(x12, Address(x14,\n+                      Deoptimization::UnrollBlock::\n+                      size_of_deoptimized_frame_offset()));\n+  __ sub(x12, x12, 2 * wordSize);\n+  __ add(sp, sp, x12);\n+  __ ld(fp, Address(sp, 0));\n+  __ ld(ra, Address(sp, wordSize));\n+  __ addi(sp, sp, 2 * wordSize);\n+  \/\/ RA should now be the return address to the caller (3) frame\n+\n+#ifdef ASSERT\n+  \/\/ Compilers generate code that bang the stack by as much as the\n+  \/\/ interpreter would need. So this stack banging should never\n+  \/\/ trigger a fault. Verify that it does not on non product builds.\n+  __ lwu(x11, Address(x14,\n+                      Deoptimization::UnrollBlock::\n+                      total_frame_sizes_offset()));\n+  __ bang_stack_size(x11, x12);\n+#endif\n+\n+  \/\/ Load address of array of frame pcs into x12 (address*)\n+  __ ld(x12, Address(x14,\n+                     Deoptimization::UnrollBlock::frame_pcs_offset()));\n+\n+  \/\/ Load address of array of frame sizes into x15 (intptr_t*)\n+  __ ld(x15, Address(x14,\n+                     Deoptimization::UnrollBlock::\n+                     frame_sizes_offset()));\n+\n+  \/\/ Counter\n+  __ lwu(x13, Address(x14,\n+                      Deoptimization::UnrollBlock::\n+                      number_of_frames_offset())); \/\/ (int)\n+\n+  \/\/ Now adjust the caller's stack to make up for the extra locals but\n+  \/\/ record the original sp so that we can save it in the skeletal\n+  \/\/ interpreter frame and the stack walking of interpreter_sender\n+  \/\/ will get the unextended sp value and not the \"real\" sp value.\n+\n+  const Register sender_sp = t1; \/\/ temporary register\n+\n+  __ lwu(x11, Address(x14,\n+                      Deoptimization::UnrollBlock::\n+                      caller_adjustment_offset())); \/\/ (int)\n+  __ mv(sender_sp, sp);\n+  __ sub(sp, sp, x11);\n+\n+  \/\/ Push interpreter frames in a loop\n+  Label loop;\n+  __ bind(loop);\n+  __ ld(x11, Address(x15, 0));       \/\/ Load frame size\n+  __ sub(x11, x11, 2 * wordSize);    \/\/ We'll push pc and fp by hand\n+  __ ld(ra, Address(x12, 0));        \/\/ Save return address\n+  __ enter();                        \/\/ and old fp & set new fp\n+  __ sub(sp, sp, x11);               \/\/ Prolog\n+  __ sd(sender_sp, Address(fp, frame::interpreter_frame_sender_sp_offset * wordSize)); \/\/ Make it walkable\n+  \/\/ This value is corrected by layout_activation_impl\n+  __ sd(zr, Address(fp, frame::interpreter_frame_last_sp_offset * wordSize));\n+  __ mv(sender_sp, sp);              \/\/ Pass sender_sp to next frame\n+  __ add(x15, x15, wordSize);        \/\/ Bump array pointer (sizes)\n+  __ add(x12, x12, wordSize);        \/\/ Bump array pointer (pcs)\n+  __ subw(x13, x13, 1);              \/\/ Decrement counter\n+  __ bgtz(x13, loop);\n+  __ ld(ra, Address(x12, 0));        \/\/ save final return address\n+  \/\/ Re-push self-frame\n+  __ enter();                        \/\/ & old fp & set new fp\n+\n+  \/\/ Use fp because the frames look interpreted now\n+  \/\/ Save \"the_pc\" since it cannot easily be retrieved using the last_java_SP after we aligned SP.\n+  \/\/ Don't need the precise return PC here, just precise enough to point into this code blob.\n+  address the_pc = __ pc();\n+  __ set_last_Java_frame(sp, fp, the_pc, t0);\n+\n+  \/\/ Call C code.  Need thread but NOT official VM entry\n+  \/\/ crud.  We cannot block on this call, no GC can happen.  Call should\n+  \/\/ restore return values to their stack-slots with the new SP.\n+  \/\/\n+  \/\/ BasicType unpack_frames(JavaThread* thread, int exec_mode)\n+  \/\/\n+\n+  \/\/ n.b. 2 gp args, 0 fp args, integral return type\n+\n+  \/\/ sp should already be aligned\n+  __ mv(c_rarg0, xthread);\n+  __ mv(c_rarg1, Deoptimization::Unpack_uncommon_trap);\n+  __ rt_call(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames));\n+\n+  \/\/ Set an oopmap for the call site\n+  \/\/ Use the same PC we used for the last java frame\n+  oop_maps->add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));\n+\n+  \/\/ Clear fp AND pc\n+  __ reset_last_Java_frame(true);\n+\n+  \/\/ Pop self-frame.\n+  __ leave();                 \/\/ Epilog\n+\n+  \/\/ Jump to interpreter\n+  __ ret();\n+\n+  \/\/ Make sure all code is generated\n+  masm->flush();\n+\n+  _uncommon_trap_blob =  UncommonTrapBlob::create(&buffer, oop_maps,\n+                                                  SimpleRuntimeFrame::framesize >> 1);\n+}\n+\n+\/\/------------------------------generate_exception_blob---------------------------\n+\/\/ creates exception blob at the end\n+\/\/ Using exception blob, this code is jumped from a compiled method.\n+\/\/ (see emit_exception_handler in riscv.ad file)\n+\/\/\n+\/\/ Given an exception pc at a call we call into the runtime for the\n+\/\/ handler in this method. This handler might merely restore state\n+\/\/ (i.e. callee save registers) unwind the frame and jump to the\n+\/\/ exception handler for the nmethod if there is no Java level handler\n+\/\/ for the nmethod.\n+\/\/\n+\/\/ This code is entered with a jmp.\n+\/\/\n+\/\/ Arguments:\n+\/\/   x10: exception oop\n+\/\/   x13: exception pc\n+\/\/\n+\/\/ Results:\n+\/\/   x10: exception oop\n+\/\/   x13: exception pc in caller\n+\/\/   destination: exception handler of caller\n+\/\/\n+\/\/ Note: the exception pc MUST be at a call (precise debug information)\n+\/\/       Registers x10, x13, x12, x14, x15, t0 are not callee saved.\n+\/\/\n+\n+void OptoRuntime::generate_exception_blob() {\n+  assert(!OptoRuntime::is_callee_saved_register(R13_num), \"\");\n+  assert(!OptoRuntime::is_callee_saved_register(R10_num), \"\");\n+  assert(!OptoRuntime::is_callee_saved_register(R12_num), \"\");\n+\n+  assert(SimpleRuntimeFrame::framesize % 4 == 0, \"sp not 16-byte aligned\");\n+\n+  \/\/ Allocate space for the code\n+  ResourceMark rm;\n+  \/\/ Setup code generation tools\n+  CodeBuffer buffer(\"exception_blob\", 2048, 1024);\n+  MacroAssembler* masm = new MacroAssembler(&buffer);\n+  assert_cond(masm != nullptr);\n+\n+  \/\/ TODO check various assumptions made here\n+  \/\/\n+  \/\/ make sure we do so before running this\n+\n+  address start = __ pc();\n+\n+  \/\/ push fp and retaddr by hand\n+  \/\/ Exception pc is 'return address' for stack walker\n+  __ addi(sp, sp, -2 * wordSize);\n+  __ sd(ra, Address(sp, wordSize));\n+  __ sd(fp, Address(sp));\n+  \/\/ there are no callee save registers and we don't expect an\n+  \/\/ arg reg save area\n+#ifndef PRODUCT\n+  assert(frame::arg_reg_save_area_bytes == 0, \"not expecting frame reg save area\");\n+#endif\n+  \/\/ Store exception in Thread object. We cannot pass any arguments to the\n+  \/\/ handle_exception call, since we do not want to make any assumption\n+  \/\/ about the size of the frame where the exception happened in.\n+  __ sd(x10, Address(xthread, JavaThread::exception_oop_offset()));\n+  __ sd(x13, Address(xthread, JavaThread::exception_pc_offset()));\n+\n+  \/\/ This call does all the hard work.  It checks if an exception handler\n+  \/\/ exists in the method.\n+  \/\/ If so, it returns the handler address.\n+  \/\/ If not, it prepares for stack-unwinding, restoring the callee-save\n+  \/\/ registers of the frame being removed.\n+  \/\/\n+  \/\/ address OptoRuntime::handle_exception_C(JavaThread* thread)\n+  \/\/\n+  \/\/ n.b. 1 gp arg, 0 fp args, integral return type\n+\n+  \/\/ the stack should always be aligned\n+  address the_pc = __ pc();\n+  __ set_last_Java_frame(sp, noreg, the_pc, t0);\n+  __ mv(c_rarg0, xthread);\n+  __ rt_call(CAST_FROM_FN_PTR(address, OptoRuntime::handle_exception_C));\n+\n+  \/\/ handle_exception_C is a special VM call which does not require an explicit\n+  \/\/ instruction sync afterwards.\n+\n+  \/\/ Set an oopmap for the call site.  This oopmap will only be used if we\n+  \/\/ are unwinding the stack.  Hence, all locations will be dead.\n+  \/\/ Callee-saved registers will be the same as the frame above (i.e.,\n+  \/\/ handle_exception_stub), since they were restored when we got the\n+  \/\/ exception.\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  assert_cond(oop_maps != nullptr);\n+\n+  oop_maps->add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));\n+\n+  __ reset_last_Java_frame(false);\n+\n+  \/\/ Restore callee-saved registers\n+\n+  \/\/ fp is an implicitly saved callee saved register (i.e. the calling\n+  \/\/ convention will save restore it in prolog\/epilog) Other than that\n+  \/\/ there are no callee save registers now that adapter frames are gone.\n+  \/\/ and we dont' expect an arg reg save area\n+  __ ld(fp, Address(sp));\n+  __ ld(x13, Address(sp, wordSize));\n+  __ addi(sp, sp , 2 * wordSize);\n+\n+  \/\/ x10: exception handler\n+\n+  \/\/ We have a handler in x10 (could be deopt blob).\n+  __ mv(t0, x10);\n+\n+  \/\/ Get the exception oop\n+  __ ld(x10, Address(xthread, JavaThread::exception_oop_offset()));\n+  \/\/ Get the exception pc in case we are deoptimized\n+  __ ld(x14, Address(xthread, JavaThread::exception_pc_offset()));\n+#ifdef ASSERT\n+  __ sd(zr, Address(xthread, JavaThread::exception_handler_pc_offset()));\n+  __ sd(zr, Address(xthread, JavaThread::exception_pc_offset()));\n+#endif\n+  \/\/ Clear the exception oop so GC no longer processes it as a root.\n+  __ sd(zr, Address(xthread, JavaThread::exception_oop_offset()));\n+\n+  \/\/ x10: exception oop\n+  \/\/ t0:  exception handler\n+  \/\/ x14: exception pc\n+  \/\/ Jump to handler\n+\n+  __ jr(t0);\n+\n+  \/\/ Make sure all code is generated\n+  masm->flush();\n+\n+  \/\/ Set exception blob\n+  _exception_blob =  ExceptionBlob::create(&buffer, oop_maps, SimpleRuntimeFrame::framesize >> 1);\n+}\n+#endif \/\/ COMPILER2\n+\n+\n","filename":"src\/hotspot\/cpu\/riscv\/runtime_riscv.cpp","additions":382,"deletions":0,"binary":false,"changes":382,"status":"added"}]}