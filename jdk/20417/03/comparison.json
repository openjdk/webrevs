{"files":[{"patch":"@@ -39,0 +39,327 @@\n+\n+class SimpleRuntimeFrame {\n+\n+  public:\n+\n+  \/\/ Most of the runtime stubs have this simple frame layout.\n+  \/\/ This class exists to make the layout shared in one place.\n+  \/\/ Offsets are for compiler stack slots, which are jints.\n+  enum layout {\n+    \/\/ The frame sender code expects that rbp will be in the \"natural\" place and\n+    \/\/ will override any oopMap setting for it. We must therefore force the layout\n+    \/\/ so that it agrees with the frame sender code.\n+    \/\/ we don't expect any arg reg save area so aarch64 asserts that\n+    \/\/ frame::arg_reg_save_area_bytes == 0\n+    rfp_off = 0,\n+    rfp_off2,\n+    return_off, return_off2,\n+    framesize\n+  };\n+};\n+\n+#define __ masm->\n+\n+\/\/------------------------------generate_uncommon_trap_blob--------------------\n+void OptoRuntime::generate_uncommon_trap_blob() {\n+  \/\/ Allocate space for the code\n+  ResourceMark rm;\n+  \/\/ Setup code generation tools\n+  CodeBuffer buffer(\"uncommon_trap_blob\", 2048, 1024);\n+  MacroAssembler* masm = new MacroAssembler(&buffer);\n+\n+  assert(SimpleRuntimeFrame::framesize % 4 == 0, \"sp not 16-byte aligned\");\n+\n+  address start = __ pc();\n+\n+  \/\/ Push self-frame.  We get here with a return address in LR\n+  \/\/ and sp should be 16 byte aligned\n+  \/\/ push rfp and retaddr by hand\n+  __ protect_return_address();\n+  __ stp(rfp, lr, Address(__ pre(sp, -2 * wordSize)));\n+  \/\/ we don't expect an arg reg save area\n+#ifndef PRODUCT\n+  assert(frame::arg_reg_save_area_bytes == 0, \"not expecting frame reg save area\");\n+#endif\n+  \/\/ compiler left unloaded_class_index in j_rarg0 move to where the\n+  \/\/ runtime expects it.\n+  if (c_rarg1 != j_rarg0) {\n+    __ movw(c_rarg1, j_rarg0);\n+  }\n+\n+  \/\/ we need to set the past SP to the stack pointer of the stub frame\n+  \/\/ and the pc to the address where this runtime call will return\n+  \/\/ although actually any pc in this code blob will do).\n+  Label retaddr;\n+  __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);\n+\n+  \/\/ Call C code.  Need thread but NOT official VM entry\n+  \/\/ crud.  We cannot block on this call, no GC can happen.  Call should\n+  \/\/ capture callee-saved registers as well as return values.\n+  \/\/ Thread is in rdi already.\n+  \/\/\n+  \/\/ UnrollBlock* uncommon_trap(JavaThread* thread, jint unloaded_class_index);\n+  \/\/\n+  \/\/ n.b. 2 gp args, 0 fp args, integral return type\n+\n+  __ mov(c_rarg0, rthread);\n+  __ movw(c_rarg2, (unsigned)Deoptimization::Unpack_uncommon_trap);\n+  __ lea(rscratch1,\n+         RuntimeAddress(CAST_FROM_FN_PTR(address,\n+                                         Deoptimization::uncommon_trap)));\n+  __ blr(rscratch1);\n+  __ bind(retaddr);\n+\n+  \/\/ Set an oopmap for the call site\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(SimpleRuntimeFrame::framesize, 0);\n+\n+  \/\/ location of rfp is known implicitly by the frame sender code\n+\n+  oop_maps->add_gc_map(__ pc() - start, map);\n+\n+  __ reset_last_Java_frame(false);\n+\n+  \/\/ move UnrollBlock* into r4\n+  __ mov(r4, r0);\n+\n+#ifdef ASSERT\n+  { Label L;\n+    __ ldrw(rscratch1, Address(r4, Deoptimization::UnrollBlock::unpack_kind_offset()));\n+    __ cmpw(rscratch1, (unsigned)Deoptimization::Unpack_uncommon_trap);\n+    __ br(Assembler::EQ, L);\n+    __ stop(\"OptoRuntime::generate_uncommon_trap_blob: expected Unpack_uncommon_trap\");\n+    __ bind(L);\n+  }\n+#endif\n+\n+  \/\/ Pop all the frames we must move\/replace.\n+  \/\/\n+  \/\/ Frame picture (youngest to oldest)\n+  \/\/ 1: self-frame (no frame link)\n+  \/\/ 2: deopting frame  (no frame link)\n+  \/\/ 3: caller of deopting frame (could be compiled\/interpreted).\n+\n+  \/\/ Pop self-frame.  We have no frame, and must rely only on r0 and sp.\n+  __ add(sp, sp, (SimpleRuntimeFrame::framesize) << LogBytesPerInt); \/\/ Epilog!\n+\n+  \/\/ Pop deoptimized frame (int)\n+  __ ldrw(r2, Address(r4,\n+                      Deoptimization::UnrollBlock::\n+                      size_of_deoptimized_frame_offset()));\n+  __ sub(r2, r2, 2 * wordSize);\n+  __ add(sp, sp, r2);\n+  __ ldp(rfp, zr, __ post(sp, 2 * wordSize));\n+\n+#ifdef ASSERT\n+  \/\/ Compilers generate code that bang the stack by as much as the\n+  \/\/ interpreter would need. So this stack banging should never\n+  \/\/ trigger a fault. Verify that it does not on non product builds.\n+  __ ldrw(r1, Address(r4,\n+                      Deoptimization::UnrollBlock::\n+                      total_frame_sizes_offset()));\n+  __ bang_stack_size(r1, r2);\n+#endif\n+\n+  \/\/ Load address of array of frame pcs into r2 (address*)\n+  __ ldr(r2, Address(r4,\n+                     Deoptimization::UnrollBlock::frame_pcs_offset()));\n+\n+  \/\/ Load address of array of frame sizes into r5 (intptr_t*)\n+  __ ldr(r5, Address(r4,\n+                     Deoptimization::UnrollBlock::\n+                     frame_sizes_offset()));\n+\n+  \/\/ Counter\n+  __ ldrw(r3, Address(r4,\n+                      Deoptimization::UnrollBlock::\n+                      number_of_frames_offset())); \/\/ (int)\n+\n+  \/\/ Now adjust the caller's stack to make up for the extra locals but\n+  \/\/ record the original sp so that we can save it in the skeletal\n+  \/\/ interpreter frame and the stack walking of interpreter_sender\n+  \/\/ will get the unextended sp value and not the \"real\" sp value.\n+\n+  const Register sender_sp = r8;\n+\n+  __ mov(sender_sp, sp);\n+  __ ldrw(r1, Address(r4,\n+                      Deoptimization::UnrollBlock::\n+                      caller_adjustment_offset())); \/\/ (int)\n+  __ sub(sp, sp, r1);\n+\n+  \/\/ Push interpreter frames in a loop\n+  Label loop;\n+  __ bind(loop);\n+  __ ldr(r1, Address(r5, 0));       \/\/ Load frame size\n+  __ sub(r1, r1, 2 * wordSize);     \/\/ We'll push pc and rfp by hand\n+  __ ldr(lr, Address(r2, 0));       \/\/ Save return address\n+  __ enter();                       \/\/ and old rfp & set new rfp\n+  __ sub(sp, sp, r1);               \/\/ Prolog\n+  __ str(sender_sp, Address(rfp, frame::interpreter_frame_sender_sp_offset * wordSize)); \/\/ Make it walkable\n+  \/\/ This value is corrected by layout_activation_impl\n+  __ str(zr, Address(rfp, frame::interpreter_frame_last_sp_offset * wordSize));\n+  __ mov(sender_sp, sp);          \/\/ Pass sender_sp to next frame\n+  __ add(r5, r5, wordSize);       \/\/ Bump array pointer (sizes)\n+  __ add(r2, r2, wordSize);       \/\/ Bump array pointer (pcs)\n+  __ subsw(r3, r3, 1);            \/\/ Decrement counter\n+  __ br(Assembler::GT, loop);\n+  __ ldr(lr, Address(r2, 0));     \/\/ save final return address\n+  \/\/ Re-push self-frame\n+  __ enter();                     \/\/ & old rfp & set new rfp\n+\n+  \/\/ Use rfp because the frames look interpreted now\n+  \/\/ Save \"the_pc\" since it cannot easily be retrieved using the last_java_SP after we aligned SP.\n+  \/\/ Don't need the precise return PC here, just precise enough to point into this code blob.\n+  address the_pc = __ pc();\n+  __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);\n+\n+  \/\/ Call C code.  Need thread but NOT official VM entry\n+  \/\/ crud.  We cannot block on this call, no GC can happen.  Call should\n+  \/\/ restore return values to their stack-slots with the new SP.\n+  \/\/ Thread is in rdi already.\n+  \/\/\n+  \/\/ BasicType unpack_frames(JavaThread* thread, int exec_mode);\n+  \/\/\n+  \/\/ n.b. 2 gp args, 0 fp args, integral return type\n+\n+  \/\/ sp should already be aligned\n+  __ mov(c_rarg0, rthread);\n+  __ movw(c_rarg1, (unsigned)Deoptimization::Unpack_uncommon_trap);\n+  __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames)));\n+  __ blr(rscratch1);\n+\n+  \/\/ Set an oopmap for the call site\n+  \/\/ Use the same PC we used for the last java frame\n+  oop_maps->add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));\n+\n+  \/\/ Clear fp AND pc\n+  __ reset_last_Java_frame(true);\n+\n+  \/\/ Pop self-frame.\n+  __ leave();                 \/\/ Epilog\n+\n+  \/\/ Jump to interpreter\n+  __ ret(lr);\n+\n+  \/\/ Make sure all code is generated\n+  masm->flush();\n+\n+  _uncommon_trap_blob =  UncommonTrapBlob::create(&buffer, oop_maps,\n+                                                 SimpleRuntimeFrame::framesize >> 1);\n+}\n+\n+\/\/------------------------------generate_exception_blob---------------------------\n+\/\/ creates exception blob at the end\n+\/\/ Using exception blob, this code is jumped from a compiled method.\n+\/\/ (see emit_exception_handler in aarch64.ad file)\n+\/\/\n+\/\/ Given an exception pc at a call we call into the runtime for the\n+\/\/ handler in this method. This handler might merely restore state\n+\/\/ (i.e. callee save registers) unwind the frame and jump to the\n+\/\/ exception handler for the nmethod if there is no Java level handler\n+\/\/ for the nmethod.\n+\/\/\n+\/\/ This code is entered with a jmp.\n+\/\/\n+\/\/ Arguments:\n+\/\/   r0: exception oop\n+\/\/   r3: exception pc\n+\/\/\n+\/\/ Results:\n+\/\/   r0: exception oop\n+\/\/   r3: exception pc in caller or ???\n+\/\/   destination: exception handler of caller\n+\/\/\n+\/\/ Note: the exception pc MUST be at a call (precise debug information)\n+\/\/       Registers r0, r3, r2, r4, r5, r8-r11 are not callee saved.\n+\/\/\n+\n+void OptoRuntime::generate_exception_blob() {\n+  assert(!OptoRuntime::is_callee_saved_register(R3_num), \"\");\n+  assert(!OptoRuntime::is_callee_saved_register(R0_num), \"\");\n+  assert(!OptoRuntime::is_callee_saved_register(R2_num), \"\");\n+\n+  assert(SimpleRuntimeFrame::framesize % 4 == 0, \"sp not 16-byte aligned\");\n+\n+  \/\/ Allocate space for the code\n+  ResourceMark rm;\n+  \/\/ Setup code generation tools\n+  CodeBuffer buffer(\"exception_blob\", 2048, 1024);\n+  MacroAssembler* masm = new MacroAssembler(&buffer);\n+\n+  \/\/ TODO check various assumptions made here\n+  \/\/\n+  \/\/ make sure we do so before running this\n+\n+  address start = __ pc();\n+\n+  \/\/ push rfp and retaddr by hand\n+  \/\/ Exception pc is 'return address' for stack walker\n+  __ protect_return_address();\n+  __ stp(rfp, lr, Address(__ pre(sp, -2 * wordSize)));\n+  \/\/ there are no callee save registers and we don't expect an\n+  \/\/ arg reg save area\n+#ifndef PRODUCT\n+  assert(frame::arg_reg_save_area_bytes == 0, \"not expecting frame reg save area\");\n+#endif\n+  \/\/ Store exception in Thread object. We cannot pass any arguments to the\n+  \/\/ handle_exception call, since we do not want to make any assumption\n+  \/\/ about the size of the frame where the exception happened in.\n+  __ str(r0, Address(rthread, JavaThread::exception_oop_offset()));\n+  __ str(r3, Address(rthread, JavaThread::exception_pc_offset()));\n+\n+  \/\/ This call does all the hard work.  It checks if an exception handler\n+  \/\/ exists in the method.\n+  \/\/ If so, it returns the handler address.\n+  \/\/ If not, it prepares for stack-unwinding, restoring the callee-save\n+  \/\/ registers of the frame being removed.\n+  \/\/\n+  \/\/ address OptoRuntime::handle_exception_C(JavaThread* thread)\n+  \/\/\n+  \/\/ n.b. 1 gp arg, 0 fp args, integral return type\n+\n+  \/\/ the stack should always be aligned\n+  address the_pc = __ pc();\n+  __ set_last_Java_frame(sp, noreg, the_pc, rscratch1);\n+  __ mov(c_rarg0, rthread);\n+  __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, OptoRuntime::handle_exception_C)));\n+  __ blr(rscratch1);\n+  \/\/ handle_exception_C is a special VM call which does not require an explicit\n+  \/\/ instruction sync afterwards.\n+\n+  \/\/ May jump to SVE compiled code\n+  __ reinitialize_ptrue();\n+\n+  \/\/ Set an oopmap for the call site.  This oopmap will only be used if we\n+  \/\/ are unwinding the stack.  Hence, all locations will be dead.\n+  \/\/ Callee-saved registers will be the same as the frame above (i.e.,\n+  \/\/ handle_exception_stub), since they were restored when we got the\n+  \/\/ exception.\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+\n+  oop_maps->add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));\n+\n+  __ reset_last_Java_frame(false);\n+\n+  \/\/ Restore callee-saved registers\n+\n+  \/\/ rfp is an implicitly saved callee saved register (i.e. the calling\n+  \/\/ convention will save restore it in prolog\/epilog) Other than that\n+  \/\/ there are no callee save registers now that adapter frames are gone.\n+  \/\/ and we dont' expect an arg reg save area\n+  __ ldp(rfp, r3, Address(__ post(sp, 2 * wordSize)));\n+  __ authenticate_return_address(r3);\n+\n+  \/\/ r0: exception handler\n+\n+  \/\/ We have a handler in r0 (could be deopt blob).\n+  __ mov(r8, r0);\n+\n+  \/\/ Get the exception oop\n+  __ ldr(r0, Address(rthread, JavaThread::exception_oop_offset()));\n+  \/\/ Get the exception pc in case we are deoptimized\n+  __ ldr(r4, Address(rthread, JavaThread::exception_pc_offset()));\n+#ifdef ASSERT\n+  __ str(zr, Address(rthread, JavaThread::exception_handler_pc_offset()));\n+  __ str(zr, Address(rthread, JavaThread::exception_pc_offset()));\n@@ -40,0 +367,17 @@\n+  \/\/ Clear the exception oop so GC no longer processes it as a root.\n+  __ str(zr, Address(rthread, JavaThread::exception_oop_offset()));\n+\n+  \/\/ r0: exception oop\n+  \/\/ r8:  exception handler\n+  \/\/ r4: exception pc\n+  \/\/ Jump to handler\n+\n+  __ br(r8);\n+\n+  \/\/ Make sure all code is generated\n+  masm->flush();\n+\n+  \/\/ Set exception blob\n+  _exception_blob =  ExceptionBlob::create(&buffer, oop_maps, SimpleRuntimeFrame::framesize >> 1);\n+}\n+#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/cpu\/aarch64\/runtime_aarch64.cpp","additions":344,"deletions":0,"binary":false,"changes":344,"status":"modified"},{"patch":"@@ -71,20 +71,0 @@\n-class SimpleRuntimeFrame {\n-\n-  public:\n-\n-  \/\/ Most of the runtime stubs have this simple frame layout.\n-  \/\/ This class exists to make the layout shared in one place.\n-  \/\/ Offsets are for compiler stack slots, which are jints.\n-  enum layout {\n-    \/\/ The frame sender code expects that rbp will be in the \"natural\" place and\n-    \/\/ will override any oopMap setting for it. We must therefore force the layout\n-    \/\/ so that it agrees with the frame sender code.\n-    \/\/ we don't expect any arg reg save area so aarch64 asserts that\n-    \/\/ frame::arg_reg_save_area_bytes == 0\n-    rfp_off = 0,\n-    rfp_off2,\n-    return_off, return_off2,\n-    framesize\n-  };\n-};\n-\n@@ -2584,191 +2564,0 @@\n-#ifdef COMPILER2\n-\/\/------------------------------generate_uncommon_trap_blob--------------------\n-void SharedRuntime::generate_uncommon_trap_blob() {\n-  \/\/ Allocate space for the code\n-  ResourceMark rm;\n-  \/\/ Setup code generation tools\n-  CodeBuffer buffer(\"uncommon_trap_blob\", 2048, 1024);\n-  MacroAssembler* masm = new MacroAssembler(&buffer);\n-\n-  assert(SimpleRuntimeFrame::framesize % 4 == 0, \"sp not 16-byte aligned\");\n-\n-  address start = __ pc();\n-\n-  \/\/ Push self-frame.  We get here with a return address in LR\n-  \/\/ and sp should be 16 byte aligned\n-  \/\/ push rfp and retaddr by hand\n-  __ protect_return_address();\n-  __ stp(rfp, lr, Address(__ pre(sp, -2 * wordSize)));\n-  \/\/ we don't expect an arg reg save area\n-#ifndef PRODUCT\n-  assert(frame::arg_reg_save_area_bytes == 0, \"not expecting frame reg save area\");\n-#endif\n-  \/\/ compiler left unloaded_class_index in j_rarg0 move to where the\n-  \/\/ runtime expects it.\n-  if (c_rarg1 != j_rarg0) {\n-    __ movw(c_rarg1, j_rarg0);\n-  }\n-\n-  \/\/ we need to set the past SP to the stack pointer of the stub frame\n-  \/\/ and the pc to the address where this runtime call will return\n-  \/\/ although actually any pc in this code blob will do).\n-  Label retaddr;\n-  __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);\n-\n-  \/\/ Call C code.  Need thread but NOT official VM entry\n-  \/\/ crud.  We cannot block on this call, no GC can happen.  Call should\n-  \/\/ capture callee-saved registers as well as return values.\n-  \/\/ Thread is in rdi already.\n-  \/\/\n-  \/\/ UnrollBlock* uncommon_trap(JavaThread* thread, jint unloaded_class_index);\n-  \/\/\n-  \/\/ n.b. 2 gp args, 0 fp args, integral return type\n-\n-  __ mov(c_rarg0, rthread);\n-  __ movw(c_rarg2, (unsigned)Deoptimization::Unpack_uncommon_trap);\n-  __ lea(rscratch1,\n-         RuntimeAddress(CAST_FROM_FN_PTR(address,\n-                                         Deoptimization::uncommon_trap)));\n-  __ blr(rscratch1);\n-  __ bind(retaddr);\n-\n-  \/\/ Set an oopmap for the call site\n-  OopMapSet* oop_maps = new OopMapSet();\n-  OopMap* map = new OopMap(SimpleRuntimeFrame::framesize, 0);\n-\n-  \/\/ location of rfp is known implicitly by the frame sender code\n-\n-  oop_maps->add_gc_map(__ pc() - start, map);\n-\n-  __ reset_last_Java_frame(false);\n-\n-  \/\/ move UnrollBlock* into r4\n-  __ mov(r4, r0);\n-\n-#ifdef ASSERT\n-  { Label L;\n-    __ ldrw(rscratch1, Address(r4, Deoptimization::UnrollBlock::unpack_kind_offset()));\n-    __ cmpw(rscratch1, (unsigned)Deoptimization::Unpack_uncommon_trap);\n-    __ br(Assembler::EQ, L);\n-    __ stop(\"SharedRuntime::generate_uncommon_trap_blob: expected Unpack_uncommon_trap\");\n-    __ bind(L);\n-  }\n-#endif\n-\n-  \/\/ Pop all the frames we must move\/replace.\n-  \/\/\n-  \/\/ Frame picture (youngest to oldest)\n-  \/\/ 1: self-frame (no frame link)\n-  \/\/ 2: deopting frame  (no frame link)\n-  \/\/ 3: caller of deopting frame (could be compiled\/interpreted).\n-\n-  \/\/ Pop self-frame.  We have no frame, and must rely only on r0 and sp.\n-  __ add(sp, sp, (SimpleRuntimeFrame::framesize) << LogBytesPerInt); \/\/ Epilog!\n-\n-  \/\/ Pop deoptimized frame (int)\n-  __ ldrw(r2, Address(r4,\n-                      Deoptimization::UnrollBlock::\n-                      size_of_deoptimized_frame_offset()));\n-  __ sub(r2, r2, 2 * wordSize);\n-  __ add(sp, sp, r2);\n-  __ ldp(rfp, zr, __ post(sp, 2 * wordSize));\n-\n-#ifdef ASSERT\n-  \/\/ Compilers generate code that bang the stack by as much as the\n-  \/\/ interpreter would need. So this stack banging should never\n-  \/\/ trigger a fault. Verify that it does not on non product builds.\n-  __ ldrw(r1, Address(r4,\n-                      Deoptimization::UnrollBlock::\n-                      total_frame_sizes_offset()));\n-  __ bang_stack_size(r1, r2);\n-#endif\n-\n-  \/\/ Load address of array of frame pcs into r2 (address*)\n-  __ ldr(r2, Address(r4,\n-                     Deoptimization::UnrollBlock::frame_pcs_offset()));\n-\n-  \/\/ Load address of array of frame sizes into r5 (intptr_t*)\n-  __ ldr(r5, Address(r4,\n-                     Deoptimization::UnrollBlock::\n-                     frame_sizes_offset()));\n-\n-  \/\/ Counter\n-  __ ldrw(r3, Address(r4,\n-                      Deoptimization::UnrollBlock::\n-                      number_of_frames_offset())); \/\/ (int)\n-\n-  \/\/ Now adjust the caller's stack to make up for the extra locals but\n-  \/\/ record the original sp so that we can save it in the skeletal\n-  \/\/ interpreter frame and the stack walking of interpreter_sender\n-  \/\/ will get the unextended sp value and not the \"real\" sp value.\n-\n-  const Register sender_sp = r8;\n-\n-  __ mov(sender_sp, sp);\n-  __ ldrw(r1, Address(r4,\n-                      Deoptimization::UnrollBlock::\n-                      caller_adjustment_offset())); \/\/ (int)\n-  __ sub(sp, sp, r1);\n-\n-  \/\/ Push interpreter frames in a loop\n-  Label loop;\n-  __ bind(loop);\n-  __ ldr(r1, Address(r5, 0));       \/\/ Load frame size\n-  __ sub(r1, r1, 2 * wordSize);     \/\/ We'll push pc and rfp by hand\n-  __ ldr(lr, Address(r2, 0));       \/\/ Save return address\n-  __ enter();                       \/\/ and old rfp & set new rfp\n-  __ sub(sp, sp, r1);               \/\/ Prolog\n-  __ str(sender_sp, Address(rfp, frame::interpreter_frame_sender_sp_offset * wordSize)); \/\/ Make it walkable\n-  \/\/ This value is corrected by layout_activation_impl\n-  __ str(zr, Address(rfp, frame::interpreter_frame_last_sp_offset * wordSize));\n-  __ mov(sender_sp, sp);          \/\/ Pass sender_sp to next frame\n-  __ add(r5, r5, wordSize);       \/\/ Bump array pointer (sizes)\n-  __ add(r2, r2, wordSize);       \/\/ Bump array pointer (pcs)\n-  __ subsw(r3, r3, 1);            \/\/ Decrement counter\n-  __ br(Assembler::GT, loop);\n-  __ ldr(lr, Address(r2, 0));     \/\/ save final return address\n-  \/\/ Re-push self-frame\n-  __ enter();                     \/\/ & old rfp & set new rfp\n-\n-  \/\/ Use rfp because the frames look interpreted now\n-  \/\/ Save \"the_pc\" since it cannot easily be retrieved using the last_java_SP after we aligned SP.\n-  \/\/ Don't need the precise return PC here, just precise enough to point into this code blob.\n-  address the_pc = __ pc();\n-  __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);\n-\n-  \/\/ Call C code.  Need thread but NOT official VM entry\n-  \/\/ crud.  We cannot block on this call, no GC can happen.  Call should\n-  \/\/ restore return values to their stack-slots with the new SP.\n-  \/\/ Thread is in rdi already.\n-  \/\/\n-  \/\/ BasicType unpack_frames(JavaThread* thread, int exec_mode);\n-  \/\/\n-  \/\/ n.b. 2 gp args, 0 fp args, integral return type\n-\n-  \/\/ sp should already be aligned\n-  __ mov(c_rarg0, rthread);\n-  __ movw(c_rarg1, (unsigned)Deoptimization::Unpack_uncommon_trap);\n-  __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames)));\n-  __ blr(rscratch1);\n-\n-  \/\/ Set an oopmap for the call site\n-  \/\/ Use the same PC we used for the last java frame\n-  oop_maps->add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));\n-\n-  \/\/ Clear fp AND pc\n-  __ reset_last_Java_frame(true);\n-\n-  \/\/ Pop self-frame.\n-  __ leave();                 \/\/ Epilog\n-\n-  \/\/ Jump to interpreter\n-  __ ret(lr);\n-\n-  \/\/ Make sure all code is generated\n-  masm->flush();\n-\n-  _uncommon_trap_blob =  UncommonTrapBlob::create(&buffer, oop_maps,\n-                                                 SimpleRuntimeFrame::framesize >> 1);\n-}\n-#endif \/\/ COMPILER2\n-\n@@ -2986,138 +2775,0 @@\n-\n-#ifdef COMPILER2\n-\/\/ This is here instead of runtime_aarch64_64.cpp because it uses SimpleRuntimeFrame\n-\/\/\n-\/\/------------------------------generate_exception_blob---------------------------\n-\/\/ creates exception blob at the end\n-\/\/ Using exception blob, this code is jumped from a compiled method.\n-\/\/ (see emit_exception_handler in x86_64.ad file)\n-\/\/\n-\/\/ Given an exception pc at a call we call into the runtime for the\n-\/\/ handler in this method. This handler might merely restore state\n-\/\/ (i.e. callee save registers) unwind the frame and jump to the\n-\/\/ exception handler for the nmethod if there is no Java level handler\n-\/\/ for the nmethod.\n-\/\/\n-\/\/ This code is entered with a jmp.\n-\/\/\n-\/\/ Arguments:\n-\/\/   r0: exception oop\n-\/\/   r3: exception pc\n-\/\/\n-\/\/ Results:\n-\/\/   r0: exception oop\n-\/\/   r3: exception pc in caller or ???\n-\/\/   destination: exception handler of caller\n-\/\/\n-\/\/ Note: the exception pc MUST be at a call (precise debug information)\n-\/\/       Registers r0, r3, r2, r4, r5, r8-r11 are not callee saved.\n-\/\/\n-\n-void OptoRuntime::generate_exception_blob() {\n-  assert(!OptoRuntime::is_callee_saved_register(R3_num), \"\");\n-  assert(!OptoRuntime::is_callee_saved_register(R0_num), \"\");\n-  assert(!OptoRuntime::is_callee_saved_register(R2_num), \"\");\n-\n-  assert(SimpleRuntimeFrame::framesize % 4 == 0, \"sp not 16-byte aligned\");\n-\n-  \/\/ Allocate space for the code\n-  ResourceMark rm;\n-  \/\/ Setup code generation tools\n-  CodeBuffer buffer(\"exception_blob\", 2048, 1024);\n-  MacroAssembler* masm = new MacroAssembler(&buffer);\n-\n-  \/\/ TODO check various assumptions made here\n-  \/\/\n-  \/\/ make sure we do so before running this\n-\n-  address start = __ pc();\n-\n-  \/\/ push rfp and retaddr by hand\n-  \/\/ Exception pc is 'return address' for stack walker\n-  __ protect_return_address();\n-  __ stp(rfp, lr, Address(__ pre(sp, -2 * wordSize)));\n-  \/\/ there are no callee save registers and we don't expect an\n-  \/\/ arg reg save area\n-#ifndef PRODUCT\n-  assert(frame::arg_reg_save_area_bytes == 0, \"not expecting frame reg save area\");\n-#endif\n-  \/\/ Store exception in Thread object. We cannot pass any arguments to the\n-  \/\/ handle_exception call, since we do not want to make any assumption\n-  \/\/ about the size of the frame where the exception happened in.\n-  __ str(r0, Address(rthread, JavaThread::exception_oop_offset()));\n-  __ str(r3, Address(rthread, JavaThread::exception_pc_offset()));\n-\n-  \/\/ This call does all the hard work.  It checks if an exception handler\n-  \/\/ exists in the method.\n-  \/\/ If so, it returns the handler address.\n-  \/\/ If not, it prepares for stack-unwinding, restoring the callee-save\n-  \/\/ registers of the frame being removed.\n-  \/\/\n-  \/\/ address OptoRuntime::handle_exception_C(JavaThread* thread)\n-  \/\/\n-  \/\/ n.b. 1 gp arg, 0 fp args, integral return type\n-\n-  \/\/ the stack should always be aligned\n-  address the_pc = __ pc();\n-  __ set_last_Java_frame(sp, noreg, the_pc, rscratch1);\n-  __ mov(c_rarg0, rthread);\n-  __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, OptoRuntime::handle_exception_C)));\n-  __ blr(rscratch1);\n-  \/\/ handle_exception_C is a special VM call which does not require an explicit\n-  \/\/ instruction sync afterwards.\n-\n-  \/\/ May jump to SVE compiled code\n-  __ reinitialize_ptrue();\n-\n-  \/\/ Set an oopmap for the call site.  This oopmap will only be used if we\n-  \/\/ are unwinding the stack.  Hence, all locations will be dead.\n-  \/\/ Callee-saved registers will be the same as the frame above (i.e.,\n-  \/\/ handle_exception_stub), since they were restored when we got the\n-  \/\/ exception.\n-\n-  OopMapSet* oop_maps = new OopMapSet();\n-\n-  oop_maps->add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));\n-\n-  __ reset_last_Java_frame(false);\n-\n-  \/\/ Restore callee-saved registers\n-\n-  \/\/ rfp is an implicitly saved callee saved register (i.e. the calling\n-  \/\/ convention will save restore it in prolog\/epilog) Other than that\n-  \/\/ there are no callee save registers now that adapter frames are gone.\n-  \/\/ and we dont' expect an arg reg save area\n-  __ ldp(rfp, r3, Address(__ post(sp, 2 * wordSize)));\n-  __ authenticate_return_address(r3);\n-\n-  \/\/ r0: exception handler\n-\n-  \/\/ We have a handler in r0 (could be deopt blob).\n-  __ mov(r8, r0);\n-\n-  \/\/ Get the exception oop\n-  __ ldr(r0, Address(rthread, JavaThread::exception_oop_offset()));\n-  \/\/ Get the exception pc in case we are deoptimized\n-  __ ldr(r4, Address(rthread, JavaThread::exception_pc_offset()));\n-#ifdef ASSERT\n-  __ str(zr, Address(rthread, JavaThread::exception_handler_pc_offset()));\n-  __ str(zr, Address(rthread, JavaThread::exception_pc_offset()));\n-#endif\n-  \/\/ Clear the exception oop so GC no longer processes it as a root.\n-  __ str(zr, Address(rthread, JavaThread::exception_oop_offset()));\n-\n-  \/\/ r0: exception oop\n-  \/\/ r8:  exception handler\n-  \/\/ r4: exception pc\n-  \/\/ Jump to handler\n-\n-  __ br(r8);\n-\n-  \/\/ Make sure all code is generated\n-  masm->flush();\n-\n-  \/\/ Set exception blob\n-  _exception_blob =  ExceptionBlob::create(&buffer, oop_maps, SimpleRuntimeFrame::framesize >> 1);\n-}\n-\n-#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":0,"deletions":349,"binary":false,"changes":349,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-#endif\n@@ -44,0 +43,137 @@\n+\/\/------------------------------generate_uncommon_trap_blob--------------------\n+\/\/ Ought to generate an ideal graph & compile, but here's some ASM\n+\/\/ instead.\n+void OptoRuntime::generate_uncommon_trap_blob() {\n+  \/\/ allocate space for the code\n+  ResourceMark rm;\n+\n+  \/\/ setup code generation tools\n+#ifdef _LP64\n+  CodeBuffer buffer(\"uncommon_trap_blob\", 2700, 512);\n+#else\n+  \/\/ Measured 8\/7\/03 at 660 in 32bit debug build\n+  CodeBuffer buffer(\"uncommon_trap_blob\", 2000, 512);\n+#endif\n+  \/\/ bypassed when code generation useless\n+  MacroAssembler* masm               = new MacroAssembler(&buffer);\n+  const Register Rublock = R6;\n+  const Register Rsender = altFP_7_11;\n+  assert_different_registers(Rublock, Rsender, Rexception_obj, R0, R1, R2, R3, R8, Rtemp);\n+\n+  \/\/\n+  \/\/ This is the entry point for all traps the compiler takes when it thinks\n+  \/\/ it cannot handle further execution of compilation code. The frame is\n+  \/\/ deoptimized in these cases and converted into interpreter frames for\n+  \/\/ execution\n+  \/\/ The steps taken by this frame are as follows:\n+  \/\/   - push a fake \"unpack_frame\"\n+  \/\/   - call the C routine Deoptimization::uncommon_trap (this function\n+  \/\/     packs the current compiled frame into vframe arrays and returns\n+  \/\/     information about the number and size of interpreter frames which\n+  \/\/     are equivalent to the frame which is being deoptimized)\n+  \/\/   - deallocate the \"unpack_frame\"\n+  \/\/   - deallocate the deoptimization frame\n+  \/\/   - in a loop using the information returned in the previous step\n+  \/\/     push interpreter frames;\n+  \/\/   - create a dummy \"unpack_frame\"\n+  \/\/   - call the C routine: Deoptimization::unpack_frames (this function\n+  \/\/     lays out values on the interpreter frame which was just created)\n+  \/\/   - deallocate the dummy unpack_frame\n+  \/\/   - return to the interpreter entry point\n+  \/\/\n+  \/\/  Refer to the following methods for more information:\n+  \/\/   - Deoptimization::uncommon_trap\n+  \/\/   - Deoptimization::unpack_frame\n+\n+  \/\/ the unloaded class index is in R0 (first parameter to this blob)\n+\n+  __ raw_push(FP, LR);\n+  __ set_last_Java_frame(SP, FP, false, Rtemp);\n+  __ mov(R2, Deoptimization::Unpack_uncommon_trap);\n+  __ mov(R1, R0);\n+  __ mov(R0, Rthread);\n+  __ call(CAST_FROM_FN_PTR(address, Deoptimization::uncommon_trap));\n+  __ mov(Rublock, R0);\n+  __ reset_last_Java_frame(Rtemp);\n+  __ raw_pop(FP, LR);\n+\n+#ifdef ASSERT\n+  { Label L;\n+    __ ldr_s32(Rtemp, Address(Rublock, Deoptimization::UnrollBlock::unpack_kind_offset()));\n+    __ cmp_32(Rtemp, Deoptimization::Unpack_uncommon_trap);\n+    __ b(L, eq);\n+    __ stop(\"OptoRuntime::generate_uncommon_trap_blob: expected Unpack_uncommon_trap\");\n+    __ bind(L);\n+  }\n+#endif\n+\n+\n+  \/\/ Set initial stack state before pushing interpreter frames\n+  __ ldr_s32(Rtemp, Address(Rublock, Deoptimization::UnrollBlock::size_of_deoptimized_frame_offset()));\n+  __ ldr(R2, Address(Rublock, Deoptimization::UnrollBlock::frame_pcs_offset()));\n+  __ ldr(R3, Address(Rublock, Deoptimization::UnrollBlock::frame_sizes_offset()));\n+\n+  __ add(SP, SP, Rtemp);\n+\n+  \/\/ See if it is enough stack to push deoptimized frames.\n+#ifdef ASSERT\n+  \/\/ Compilers generate code that bang the stack by as much as the\n+  \/\/ interpreter would need. So this stack banging should never\n+  \/\/ trigger a fault. Verify that it does not on non product builds.\n+  \/\/\n+  \/\/ The compiled method that we are deoptimizing was popped from the stack.\n+  \/\/ If the stack bang results in a stack overflow, we don't return to the\n+  \/\/ method that is being deoptimized. The stack overflow exception is\n+  \/\/ propagated to the caller of the deoptimized method. Need to get the pc\n+  \/\/ from the caller in LR and restore FP.\n+  __ ldr(LR, Address(R2, 0));\n+  __ ldr(FP, Address(Rublock, Deoptimization::UnrollBlock::initial_info_offset()));\n+  __ ldr_s32(R8, Address(Rublock, Deoptimization::UnrollBlock::total_frame_sizes_offset()));\n+  __ arm_stack_overflow_check(R8, Rtemp);\n+#endif\n+  __ ldr_s32(R8, Address(Rublock, Deoptimization::UnrollBlock::number_of_frames_offset()));\n+  __ ldr_s32(Rtemp, Address(Rublock, Deoptimization::UnrollBlock::caller_adjustment_offset()));\n+  __ mov(Rsender, SP);\n+  __ sub(SP, SP, Rtemp);\n+  \/\/  __ ldr(FP, Address(FP));\n+  __ ldr(FP, Address(Rublock, Deoptimization::UnrollBlock::initial_info_offset()));\n+\n+  \/\/ Push interpreter frames in a loop\n+  Label loop;\n+  __ bind(loop);\n+  __ ldr(LR, Address(R2, wordSize, post_indexed));         \/\/ load frame pc\n+  __ ldr(Rtemp, Address(R3, wordSize, post_indexed));      \/\/ load frame size\n+\n+  __ raw_push(FP, LR);                                     \/\/ create new frame\n+  __ mov(FP, SP);\n+  __ sub(Rtemp, Rtemp, 2*wordSize);\n+\n+  __ sub(SP, SP, Rtemp);\n+\n+  __ str(Rsender, Address(FP, frame::interpreter_frame_sender_sp_offset * wordSize));\n+  __ mov(LR, 0);\n+  __ str(LR, Address(FP, frame::interpreter_frame_last_sp_offset * wordSize));\n+  __ subs(R8, R8, 1);                               \/\/ decrement counter\n+  __ mov(Rsender, SP);\n+  __ b(loop, ne);\n+\n+  \/\/ Re-push self-frame\n+  __ ldr(LR, Address(R2));\n+  __ raw_push(FP, LR);\n+  __ mov(FP, SP);\n+\n+  \/\/ Call unpack_frames with proper arguments\n+  __ mov(R0, Rthread);\n+  __ mov(R1, Deoptimization::Unpack_uncommon_trap);\n+  __ set_last_Java_frame(SP, FP, true, Rtemp);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames));\n+  \/\/  oop_maps->add_gc_map(__ pc() - start, new OopMap(frame_size_in_words, 0));\n+  __ reset_last_Java_frame(Rtemp);\n+\n+  __ mov(SP, FP);\n+  __ pop(RegisterSet(FP) | RegisterSet(PC));\n+\n+  masm->flush();\n+  _uncommon_trap_blob = UncommonTrapBlob::create(&buffer, nullptr, 2 \/* LR+FP *\/);\n+}\n+\n@@ -151,0 +287,3 @@\n+\n+#endif \/\/ COMPILER2\n+\n","filename":"src\/hotspot\/cpu\/arm\/runtime_arm.cpp","additions":140,"deletions":1,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -1598,141 +1598,0 @@\n-#ifdef COMPILER2\n-\n-\/\/------------------------------generate_uncommon_trap_blob--------------------\n-\/\/ Ought to generate an ideal graph & compile, but here's some ASM\n-\/\/ instead.\n-void SharedRuntime::generate_uncommon_trap_blob() {\n-  \/\/ allocate space for the code\n-  ResourceMark rm;\n-\n-  \/\/ setup code generation tools\n-#ifdef _LP64\n-  CodeBuffer buffer(\"uncommon_trap_blob\", 2700, 512);\n-#else\n-  \/\/ Measured 8\/7\/03 at 660 in 32bit debug build\n-  CodeBuffer buffer(\"uncommon_trap_blob\", 2000, 512);\n-#endif\n-  \/\/ bypassed when code generation useless\n-  MacroAssembler* masm               = new MacroAssembler(&buffer);\n-  const Register Rublock = R6;\n-  const Register Rsender = altFP_7_11;\n-  assert_different_registers(Rublock, Rsender, Rexception_obj, R0, R1, R2, R3, R8, Rtemp);\n-\n-  \/\/\n-  \/\/ This is the entry point for all traps the compiler takes when it thinks\n-  \/\/ it cannot handle further execution of compilation code. The frame is\n-  \/\/ deoptimized in these cases and converted into interpreter frames for\n-  \/\/ execution\n-  \/\/ The steps taken by this frame are as follows:\n-  \/\/   - push a fake \"unpack_frame\"\n-  \/\/   - call the C routine Deoptimization::uncommon_trap (this function\n-  \/\/     packs the current compiled frame into vframe arrays and returns\n-  \/\/     information about the number and size of interpreter frames which\n-  \/\/     are equivalent to the frame which is being deoptimized)\n-  \/\/   - deallocate the \"unpack_frame\"\n-  \/\/   - deallocate the deoptimization frame\n-  \/\/   - in a loop using the information returned in the previous step\n-  \/\/     push interpreter frames;\n-  \/\/   - create a dummy \"unpack_frame\"\n-  \/\/   - call the C routine: Deoptimization::unpack_frames (this function\n-  \/\/     lays out values on the interpreter frame which was just created)\n-  \/\/   - deallocate the dummy unpack_frame\n-  \/\/   - return to the interpreter entry point\n-  \/\/\n-  \/\/  Refer to the following methods for more information:\n-  \/\/   - Deoptimization::uncommon_trap\n-  \/\/   - Deoptimization::unpack_frame\n-\n-  \/\/ the unloaded class index is in R0 (first parameter to this blob)\n-\n-  __ raw_push(FP, LR);\n-  __ set_last_Java_frame(SP, FP, false, Rtemp);\n-  __ mov(R2, Deoptimization::Unpack_uncommon_trap);\n-  __ mov(R1, R0);\n-  __ mov(R0, Rthread);\n-  __ call(CAST_FROM_FN_PTR(address, Deoptimization::uncommon_trap));\n-  __ mov(Rublock, R0);\n-  __ reset_last_Java_frame(Rtemp);\n-  __ raw_pop(FP, LR);\n-\n-#ifdef ASSERT\n-  { Label L;\n-    __ ldr_s32(Rtemp, Address(Rublock, Deoptimization::UnrollBlock::unpack_kind_offset()));\n-    __ cmp_32(Rtemp, Deoptimization::Unpack_uncommon_trap);\n-    __ b(L, eq);\n-    __ stop(\"SharedRuntime::generate_uncommon_trap_blob: expected Unpack_uncommon_trap\");\n-    __ bind(L);\n-  }\n-#endif\n-\n-\n-  \/\/ Set initial stack state before pushing interpreter frames\n-  __ ldr_s32(Rtemp, Address(Rublock, Deoptimization::UnrollBlock::size_of_deoptimized_frame_offset()));\n-  __ ldr(R2, Address(Rublock, Deoptimization::UnrollBlock::frame_pcs_offset()));\n-  __ ldr(R3, Address(Rublock, Deoptimization::UnrollBlock::frame_sizes_offset()));\n-\n-  __ add(SP, SP, Rtemp);\n-\n-  \/\/ See if it is enough stack to push deoptimized frames.\n-#ifdef ASSERT\n-  \/\/ Compilers generate code that bang the stack by as much as the\n-  \/\/ interpreter would need. So this stack banging should never\n-  \/\/ trigger a fault. Verify that it does not on non product builds.\n-  \/\/\n-  \/\/ The compiled method that we are deoptimizing was popped from the stack.\n-  \/\/ If the stack bang results in a stack overflow, we don't return to the\n-  \/\/ method that is being deoptimized. The stack overflow exception is\n-  \/\/ propagated to the caller of the deoptimized method. Need to get the pc\n-  \/\/ from the caller in LR and restore FP.\n-  __ ldr(LR, Address(R2, 0));\n-  __ ldr(FP, Address(Rublock, Deoptimization::UnrollBlock::initial_info_offset()));\n-  __ ldr_s32(R8, Address(Rublock, Deoptimization::UnrollBlock::total_frame_sizes_offset()));\n-  __ arm_stack_overflow_check(R8, Rtemp);\n-#endif\n-  __ ldr_s32(R8, Address(Rublock, Deoptimization::UnrollBlock::number_of_frames_offset()));\n-  __ ldr_s32(Rtemp, Address(Rublock, Deoptimization::UnrollBlock::caller_adjustment_offset()));\n-  __ mov(Rsender, SP);\n-  __ sub(SP, SP, Rtemp);\n-  \/\/  __ ldr(FP, Address(FP));\n-  __ ldr(FP, Address(Rublock, Deoptimization::UnrollBlock::initial_info_offset()));\n-\n-  \/\/ Push interpreter frames in a loop\n-  Label loop;\n-  __ bind(loop);\n-  __ ldr(LR, Address(R2, wordSize, post_indexed));         \/\/ load frame pc\n-  __ ldr(Rtemp, Address(R3, wordSize, post_indexed));      \/\/ load frame size\n-\n-  __ raw_push(FP, LR);                                     \/\/ create new frame\n-  __ mov(FP, SP);\n-  __ sub(Rtemp, Rtemp, 2*wordSize);\n-\n-  __ sub(SP, SP, Rtemp);\n-\n-  __ str(Rsender, Address(FP, frame::interpreter_frame_sender_sp_offset * wordSize));\n-  __ mov(LR, 0);\n-  __ str(LR, Address(FP, frame::interpreter_frame_last_sp_offset * wordSize));\n-  __ subs(R8, R8, 1);                               \/\/ decrement counter\n-  __ mov(Rsender, SP);\n-  __ b(loop, ne);\n-\n-  \/\/ Re-push self-frame\n-  __ ldr(LR, Address(R2));\n-  __ raw_push(FP, LR);\n-  __ mov(FP, SP);\n-\n-  \/\/ Call unpack_frames with proper arguments\n-  __ mov(R0, Rthread);\n-  __ mov(R1, Deoptimization::Unpack_uncommon_trap);\n-  __ set_last_Java_frame(SP, FP, true, Rtemp);\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames));\n-  \/\/  oop_maps->add_gc_map(__ pc() - start, new OopMap(frame_size_in_words, 0));\n-  __ reset_last_Java_frame(Rtemp);\n-\n-  __ mov(SP, FP);\n-  __ pop(RegisterSet(FP) | RegisterSet(PC));\n-\n-  masm->flush();\n-  _uncommon_trap_blob = UncommonTrapBlob::create(&buffer, nullptr, 2 \/* LR+FP *\/);\n-}\n-\n-#endif \/\/ COMPILER2\n-\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":0,"deletions":141,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -3081,1 +3081,1 @@\n-void SharedRuntime::generate_uncommon_trap_blob() {\n+void OptoRuntime::generate_uncommon_trap_blob() {\n@@ -3147,1 +3147,1 @@\n-  __ asm_assert_eq(\"SharedRuntime::generate_deopt_blob: expected Unpack_uncommon_trap\");\n+  __ asm_assert_eq(\"OptoRuntime::generate_uncommon_trap_blob: expected Unpack_uncommon_trap\");\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,382 @@\n+\/*\n+ * Copyright (c) 2024, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#ifdef COMPILER2\n+#include \"asm\/macroAssembler.hpp\"\n+#include \"asm\/macroAssembler.inline.hpp\"\n+#include \"code\/vmreg.hpp\"\n+#include \"interpreter\/interpreter.hpp\"\n+#include \"opto\/runtime.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+#include \"runtime\/vframeArray.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"vmreg_riscv.inline.hpp\"\n+\n+class SimpleRuntimeFrame {\n+public:\n+\n+  \/\/ Most of the runtime stubs have this simple frame layout.\n+  \/\/ This class exists to make the layout shared in one place.\n+  \/\/ Offsets are for compiler stack slots, which are jints.\n+  enum layout {\n+    \/\/ The frame sender code expects that fp will be in the \"natural\" place and\n+    \/\/ will override any oopMap setting for it. We must therefore force the layout\n+    \/\/ so that it agrees with the frame sender code.\n+    \/\/ we don't expect any arg reg save area so riscv asserts that\n+    \/\/ frame::arg_reg_save_area_bytes == 0\n+    fp_off = 0, fp_off2,\n+    return_off, return_off2,\n+    framesize\n+  };\n+};\n+\n+#define __ masm->\n+\n+\/\/------------------------------generate_uncommon_trap_blob--------------------\n+void OptoRuntime::generate_uncommon_trap_blob() {\n+  \/\/ Allocate space for the code\n+  ResourceMark rm;\n+  \/\/ Setup code generation tools\n+  CodeBuffer buffer(\"uncommon_trap_blob\", 2048, 1024);\n+  MacroAssembler* masm = new MacroAssembler(&buffer);\n+  assert_cond(masm != nullptr);\n+\n+  assert(SimpleRuntimeFrame::framesize % 4 == 0, \"sp not 16-byte aligned\");\n+\n+  address start = __ pc();\n+\n+  \/\/ Push self-frame.  We get here with a return address in RA\n+  \/\/ and sp should be 16 byte aligned\n+  \/\/ push fp and retaddr by hand\n+  __ addi(sp, sp, -2 * wordSize);\n+  __ sd(ra, Address(sp, wordSize));\n+  __ sd(fp, Address(sp, 0));\n+  \/\/ we don't expect an arg reg save area\n+#ifndef PRODUCT\n+  assert(frame::arg_reg_save_area_bytes == 0, \"not expecting frame reg save area\");\n+#endif\n+  \/\/ compiler left unloaded_class_index in j_rarg0 move to where the\n+  \/\/ runtime expects it.\n+  __ sign_extend(c_rarg1, j_rarg0, 32);\n+\n+  \/\/ we need to set the past SP to the stack pointer of the stub frame\n+  \/\/ and the pc to the address where this runtime call will return\n+  \/\/ although actually any pc in this code blob will do).\n+  Label retaddr;\n+  __ set_last_Java_frame(sp, noreg, retaddr, t0);\n+\n+  \/\/ Call C code.  Need thread but NOT official VM entry\n+  \/\/ crud.  We cannot block on this call, no GC can happen.  Call should\n+  \/\/ capture callee-saved registers as well as return values.\n+  \/\/\n+  \/\/ UnrollBlock* uncommon_trap(JavaThread* thread, jint unloaded_class_index, jint exec_mode)\n+  \/\/\n+  \/\/ n.b. 3 gp args, 0 fp args, integral return type\n+\n+  __ mv(c_rarg0, xthread);\n+  __ mv(c_rarg2, Deoptimization::Unpack_uncommon_trap);\n+  __ rt_call(CAST_FROM_FN_PTR(address, Deoptimization::uncommon_trap));\n+  __ bind(retaddr);\n+\n+  \/\/ Set an oopmap for the call site\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(SimpleRuntimeFrame::framesize, 0);\n+  assert_cond(oop_maps != nullptr && map != nullptr);\n+\n+  \/\/ location of fp is known implicitly by the frame sender code\n+\n+  oop_maps->add_gc_map(__ pc() - start, map);\n+\n+  __ reset_last_Java_frame(false);\n+\n+  \/\/ move UnrollBlock* into x14\n+  __ mv(x14, x10);\n+\n+#ifdef ASSERT\n+  { Label L;\n+    __ lwu(t0, Address(x14, Deoptimization::UnrollBlock::unpack_kind_offset()));\n+    __ mv(t1, Deoptimization::Unpack_uncommon_trap);\n+    __ beq(t0, t1, L);\n+    __ stop(\"OptoRuntime::generate_uncommon_trap_blob: expected Unpack_uncommon_trap\");\n+    __ bind(L);\n+  }\n+#endif\n+\n+  \/\/ Pop all the frames we must move\/replace.\n+  \/\/\n+  \/\/ Frame picture (youngest to oldest)\n+  \/\/ 1: self-frame (no frame link)\n+  \/\/ 2: deopting frame  (no frame link)\n+  \/\/ 3: caller of deopting frame (could be compiled\/interpreted).\n+\n+  __ add(sp, sp, (SimpleRuntimeFrame::framesize) << LogBytesPerInt); \/\/ Epilog!\n+\n+  \/\/ Pop deoptimized frame (int)\n+  __ lwu(x12, Address(x14,\n+                      Deoptimization::UnrollBlock::\n+                      size_of_deoptimized_frame_offset()));\n+  __ sub(x12, x12, 2 * wordSize);\n+  __ add(sp, sp, x12);\n+  __ ld(fp, Address(sp, 0));\n+  __ ld(ra, Address(sp, wordSize));\n+  __ addi(sp, sp, 2 * wordSize);\n+  \/\/ RA should now be the return address to the caller (3) frame\n+\n+#ifdef ASSERT\n+  \/\/ Compilers generate code that bang the stack by as much as the\n+  \/\/ interpreter would need. So this stack banging should never\n+  \/\/ trigger a fault. Verify that it does not on non product builds.\n+  __ lwu(x11, Address(x14,\n+                      Deoptimization::UnrollBlock::\n+                      total_frame_sizes_offset()));\n+  __ bang_stack_size(x11, x12);\n+#endif\n+\n+  \/\/ Load address of array of frame pcs into x12 (address*)\n+  __ ld(x12, Address(x14,\n+                     Deoptimization::UnrollBlock::frame_pcs_offset()));\n+\n+  \/\/ Load address of array of frame sizes into x15 (intptr_t*)\n+  __ ld(x15, Address(x14,\n+                     Deoptimization::UnrollBlock::\n+                     frame_sizes_offset()));\n+\n+  \/\/ Counter\n+  __ lwu(x13, Address(x14,\n+                      Deoptimization::UnrollBlock::\n+                      number_of_frames_offset())); \/\/ (int)\n+\n+  \/\/ Now adjust the caller's stack to make up for the extra locals but\n+  \/\/ record the original sp so that we can save it in the skeletal\n+  \/\/ interpreter frame and the stack walking of interpreter_sender\n+  \/\/ will get the unextended sp value and not the \"real\" sp value.\n+\n+  const Register sender_sp = t1; \/\/ temporary register\n+\n+  __ lwu(x11, Address(x14,\n+                      Deoptimization::UnrollBlock::\n+                      caller_adjustment_offset())); \/\/ (int)\n+  __ mv(sender_sp, sp);\n+  __ sub(sp, sp, x11);\n+\n+  \/\/ Push interpreter frames in a loop\n+  Label loop;\n+  __ bind(loop);\n+  __ ld(x11, Address(x15, 0));       \/\/ Load frame size\n+  __ sub(x11, x11, 2 * wordSize);    \/\/ We'll push pc and fp by hand\n+  __ ld(ra, Address(x12, 0));        \/\/ Save return address\n+  __ enter();                        \/\/ and old fp & set new fp\n+  __ sub(sp, sp, x11);               \/\/ Prolog\n+  __ sd(sender_sp, Address(fp, frame::interpreter_frame_sender_sp_offset * wordSize)); \/\/ Make it walkable\n+  \/\/ This value is corrected by layout_activation_impl\n+  __ sd(zr, Address(fp, frame::interpreter_frame_last_sp_offset * wordSize));\n+  __ mv(sender_sp, sp);              \/\/ Pass sender_sp to next frame\n+  __ add(x15, x15, wordSize);        \/\/ Bump array pointer (sizes)\n+  __ add(x12, x12, wordSize);        \/\/ Bump array pointer (pcs)\n+  __ subw(x13, x13, 1);              \/\/ Decrement counter\n+  __ bgtz(x13, loop);\n+  __ ld(ra, Address(x12, 0));        \/\/ save final return address\n+  \/\/ Re-push self-frame\n+  __ enter();                        \/\/ & old fp & set new fp\n+\n+  \/\/ Use fp because the frames look interpreted now\n+  \/\/ Save \"the_pc\" since it cannot easily be retrieved using the last_java_SP after we aligned SP.\n+  \/\/ Don't need the precise return PC here, just precise enough to point into this code blob.\n+  address the_pc = __ pc();\n+  __ set_last_Java_frame(sp, fp, the_pc, t0);\n+\n+  \/\/ Call C code.  Need thread but NOT official VM entry\n+  \/\/ crud.  We cannot block on this call, no GC can happen.  Call should\n+  \/\/ restore return values to their stack-slots with the new SP.\n+  \/\/\n+  \/\/ BasicType unpack_frames(JavaThread* thread, int exec_mode)\n+  \/\/\n+\n+  \/\/ n.b. 2 gp args, 0 fp args, integral return type\n+\n+  \/\/ sp should already be aligned\n+  __ mv(c_rarg0, xthread);\n+  __ mv(c_rarg1, Deoptimization::Unpack_uncommon_trap);\n+  __ rt_call(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames));\n+\n+  \/\/ Set an oopmap for the call site\n+  \/\/ Use the same PC we used for the last java frame\n+  oop_maps->add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));\n+\n+  \/\/ Clear fp AND pc\n+  __ reset_last_Java_frame(true);\n+\n+  \/\/ Pop self-frame.\n+  __ leave();                 \/\/ Epilog\n+\n+  \/\/ Jump to interpreter\n+  __ ret();\n+\n+  \/\/ Make sure all code is generated\n+  masm->flush();\n+\n+  _uncommon_trap_blob =  UncommonTrapBlob::create(&buffer, oop_maps,\n+                                                  SimpleRuntimeFrame::framesize >> 1);\n+}\n+\n+\/\/------------------------------generate_exception_blob---------------------------\n+\/\/ creates exception blob at the end\n+\/\/ Using exception blob, this code is jumped from a compiled method.\n+\/\/ (see emit_exception_handler in riscv.ad file)\n+\/\/\n+\/\/ Given an exception pc at a call we call into the runtime for the\n+\/\/ handler in this method. This handler might merely restore state\n+\/\/ (i.e. callee save registers) unwind the frame and jump to the\n+\/\/ exception handler for the nmethod if there is no Java level handler\n+\/\/ for the nmethod.\n+\/\/\n+\/\/ This code is entered with a jmp.\n+\/\/\n+\/\/ Arguments:\n+\/\/   x10: exception oop\n+\/\/   x13: exception pc\n+\/\/\n+\/\/ Results:\n+\/\/   x10: exception oop\n+\/\/   x13: exception pc in caller\n+\/\/   destination: exception handler of caller\n+\/\/\n+\/\/ Note: the exception pc MUST be at a call (precise debug information)\n+\/\/       Registers x10, x13, x12, x14, x15, t0 are not callee saved.\n+\/\/\n+\n+void OptoRuntime::generate_exception_blob() {\n+  assert(!OptoRuntime::is_callee_saved_register(R13_num), \"\");\n+  assert(!OptoRuntime::is_callee_saved_register(R10_num), \"\");\n+  assert(!OptoRuntime::is_callee_saved_register(R12_num), \"\");\n+\n+  assert(SimpleRuntimeFrame::framesize % 4 == 0, \"sp not 16-byte aligned\");\n+\n+  \/\/ Allocate space for the code\n+  ResourceMark rm;\n+  \/\/ Setup code generation tools\n+  CodeBuffer buffer(\"exception_blob\", 2048, 1024);\n+  MacroAssembler* masm = new MacroAssembler(&buffer);\n+  assert_cond(masm != nullptr);\n+\n+  \/\/ TODO check various assumptions made here\n+  \/\/\n+  \/\/ make sure we do so before running this\n+\n+  address start = __ pc();\n+\n+  \/\/ push fp and retaddr by hand\n+  \/\/ Exception pc is 'return address' for stack walker\n+  __ addi(sp, sp, -2 * wordSize);\n+  __ sd(ra, Address(sp, wordSize));\n+  __ sd(fp, Address(sp));\n+  \/\/ there are no callee save registers and we don't expect an\n+  \/\/ arg reg save area\n+#ifndef PRODUCT\n+  assert(frame::arg_reg_save_area_bytes == 0, \"not expecting frame reg save area\");\n+#endif\n+  \/\/ Store exception in Thread object. We cannot pass any arguments to the\n+  \/\/ handle_exception call, since we do not want to make any assumption\n+  \/\/ about the size of the frame where the exception happened in.\n+  __ sd(x10, Address(xthread, JavaThread::exception_oop_offset()));\n+  __ sd(x13, Address(xthread, JavaThread::exception_pc_offset()));\n+\n+  \/\/ This call does all the hard work.  It checks if an exception handler\n+  \/\/ exists in the method.\n+  \/\/ If so, it returns the handler address.\n+  \/\/ If not, it prepares for stack-unwinding, restoring the callee-save\n+  \/\/ registers of the frame being removed.\n+  \/\/\n+  \/\/ address OptoRuntime::handle_exception_C(JavaThread* thread)\n+  \/\/\n+  \/\/ n.b. 1 gp arg, 0 fp args, integral return type\n+\n+  \/\/ the stack should always be aligned\n+  address the_pc = __ pc();\n+  __ set_last_Java_frame(sp, noreg, the_pc, t0);\n+  __ mv(c_rarg0, xthread);\n+  __ rt_call(CAST_FROM_FN_PTR(address, OptoRuntime::handle_exception_C));\n+\n+  \/\/ handle_exception_C is a special VM call which does not require an explicit\n+  \/\/ instruction sync afterwards.\n+\n+  \/\/ Set an oopmap for the call site.  This oopmap will only be used if we\n+  \/\/ are unwinding the stack.  Hence, all locations will be dead.\n+  \/\/ Callee-saved registers will be the same as the frame above (i.e.,\n+  \/\/ handle_exception_stub), since they were restored when we got the\n+  \/\/ exception.\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  assert_cond(oop_maps != nullptr);\n+\n+  oop_maps->add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));\n+\n+  __ reset_last_Java_frame(false);\n+\n+  \/\/ Restore callee-saved registers\n+\n+  \/\/ fp is an implicitly saved callee saved register (i.e. the calling\n+  \/\/ convention will save restore it in prolog\/epilog) Other than that\n+  \/\/ there are no callee save registers now that adapter frames are gone.\n+  \/\/ and we dont' expect an arg reg save area\n+  __ ld(fp, Address(sp));\n+  __ ld(x13, Address(sp, wordSize));\n+  __ addi(sp, sp , 2 * wordSize);\n+\n+  \/\/ x10: exception handler\n+\n+  \/\/ We have a handler in x10 (could be deopt blob).\n+  __ mv(t0, x10);\n+\n+  \/\/ Get the exception oop\n+  __ ld(x10, Address(xthread, JavaThread::exception_oop_offset()));\n+  \/\/ Get the exception pc in case we are deoptimized\n+  __ ld(x14, Address(xthread, JavaThread::exception_pc_offset()));\n+#ifdef ASSERT\n+  __ sd(zr, Address(xthread, JavaThread::exception_handler_pc_offset()));\n+  __ sd(zr, Address(xthread, JavaThread::exception_pc_offset()));\n+#endif\n+  \/\/ Clear the exception oop so GC no longer processes it as a root.\n+  __ sd(zr, Address(xthread, JavaThread::exception_oop_offset()));\n+\n+  \/\/ x10: exception oop\n+  \/\/ t0:  exception handler\n+  \/\/ x14: exception pc\n+  \/\/ Jump to handler\n+\n+  __ jr(t0);\n+\n+  \/\/ Make sure all code is generated\n+  masm->flush();\n+\n+  \/\/ Set exception blob\n+  _exception_blob =  ExceptionBlob::create(&buffer, oop_maps, SimpleRuntimeFrame::framesize >> 1);\n+}\n+#endif \/\/ COMPILER2\n+\n+\n","filename":"src\/hotspot\/cpu\/riscv\/runtime_riscv.cpp","additions":382,"deletions":0,"binary":false,"changes":382,"status":"added"},{"patch":"@@ -70,18 +70,0 @@\n-class SimpleRuntimeFrame {\n-public:\n-\n-  \/\/ Most of the runtime stubs have this simple frame layout.\n-  \/\/ This class exists to make the layout shared in one place.\n-  \/\/ Offsets are for compiler stack slots, which are jints.\n-  enum layout {\n-    \/\/ The frame sender code expects that fp will be in the \"natural\" place and\n-    \/\/ will override any oopMap setting for it. We must therefore force the layout\n-    \/\/ so that it agrees with the frame sender code.\n-    \/\/ we don't expect any arg reg save area so riscv asserts that\n-    \/\/ frame::arg_reg_save_area_bytes == 0\n-    fp_off = 0, fp_off2,\n-    return_off, return_off2,\n-    framesize\n-  };\n-};\n-\n@@ -2444,189 +2426,0 @@\n-#ifdef COMPILER2\n-\/\/------------------------------generate_uncommon_trap_blob--------------------\n-void SharedRuntime::generate_uncommon_trap_blob() {\n-  \/\/ Allocate space for the code\n-  ResourceMark rm;\n-  \/\/ Setup code generation tools\n-  CodeBuffer buffer(\"uncommon_trap_blob\", 2048, 1024);\n-  MacroAssembler* masm = new MacroAssembler(&buffer);\n-  assert_cond(masm != nullptr);\n-\n-  assert(SimpleRuntimeFrame::framesize % 4 == 0, \"sp not 16-byte aligned\");\n-\n-  address start = __ pc();\n-\n-  \/\/ Push self-frame.  We get here with a return address in RA\n-  \/\/ and sp should be 16 byte aligned\n-  \/\/ push fp and retaddr by hand\n-  __ addi(sp, sp, -2 * wordSize);\n-  __ sd(ra, Address(sp, wordSize));\n-  __ sd(fp, Address(sp, 0));\n-  \/\/ we don't expect an arg reg save area\n-#ifndef PRODUCT\n-  assert(frame::arg_reg_save_area_bytes == 0, \"not expecting frame reg save area\");\n-#endif\n-  \/\/ compiler left unloaded_class_index in j_rarg0 move to where the\n-  \/\/ runtime expects it.\n-  __ sign_extend(c_rarg1, j_rarg0, 32);\n-\n-  \/\/ we need to set the past SP to the stack pointer of the stub frame\n-  \/\/ and the pc to the address where this runtime call will return\n-  \/\/ although actually any pc in this code blob will do).\n-  Label retaddr;\n-  __ set_last_Java_frame(sp, noreg, retaddr, t0);\n-\n-  \/\/ Call C code.  Need thread but NOT official VM entry\n-  \/\/ crud.  We cannot block on this call, no GC can happen.  Call should\n-  \/\/ capture callee-saved registers as well as return values.\n-  \/\/\n-  \/\/ UnrollBlock* uncommon_trap(JavaThread* thread, jint unloaded_class_index, jint exec_mode)\n-  \/\/\n-  \/\/ n.b. 3 gp args, 0 fp args, integral return type\n-\n-  __ mv(c_rarg0, xthread);\n-  __ mv(c_rarg2, Deoptimization::Unpack_uncommon_trap);\n-  __ rt_call(CAST_FROM_FN_PTR(address, Deoptimization::uncommon_trap));\n-  __ bind(retaddr);\n-\n-  \/\/ Set an oopmap for the call site\n-  OopMapSet* oop_maps = new OopMapSet();\n-  OopMap* map = new OopMap(SimpleRuntimeFrame::framesize, 0);\n-  assert_cond(oop_maps != nullptr && map != nullptr);\n-\n-  \/\/ location of fp is known implicitly by the frame sender code\n-\n-  oop_maps->add_gc_map(__ pc() - start, map);\n-\n-  __ reset_last_Java_frame(false);\n-\n-  \/\/ move UnrollBlock* into x14\n-  __ mv(x14, x10);\n-\n-#ifdef ASSERT\n-  { Label L;\n-    __ lwu(t0, Address(x14, Deoptimization::UnrollBlock::unpack_kind_offset()));\n-    __ mv(t1, Deoptimization::Unpack_uncommon_trap);\n-    __ beq(t0, t1, L);\n-    __ stop(\"SharedRuntime::generate_uncommon_trap_blob: expected Unpack_uncommon_trap\");\n-    __ bind(L);\n-  }\n-#endif\n-\n-  \/\/ Pop all the frames we must move\/replace.\n-  \/\/\n-  \/\/ Frame picture (youngest to oldest)\n-  \/\/ 1: self-frame (no frame link)\n-  \/\/ 2: deopting frame  (no frame link)\n-  \/\/ 3: caller of deopting frame (could be compiled\/interpreted).\n-\n-  __ add(sp, sp, (SimpleRuntimeFrame::framesize) << LogBytesPerInt); \/\/ Epilog!\n-\n-  \/\/ Pop deoptimized frame (int)\n-  __ lwu(x12, Address(x14,\n-                      Deoptimization::UnrollBlock::\n-                      size_of_deoptimized_frame_offset()));\n-  __ sub(x12, x12, 2 * wordSize);\n-  __ add(sp, sp, x12);\n-  __ ld(fp, Address(sp, 0));\n-  __ ld(ra, Address(sp, wordSize));\n-  __ addi(sp, sp, 2 * wordSize);\n-  \/\/ RA should now be the return address to the caller (3) frame\n-\n-#ifdef ASSERT\n-  \/\/ Compilers generate code that bang the stack by as much as the\n-  \/\/ interpreter would need. So this stack banging should never\n-  \/\/ trigger a fault. Verify that it does not on non product builds.\n-  __ lwu(x11, Address(x14,\n-                      Deoptimization::UnrollBlock::\n-                      total_frame_sizes_offset()));\n-  __ bang_stack_size(x11, x12);\n-#endif\n-\n-  \/\/ Load address of array of frame pcs into x12 (address*)\n-  __ ld(x12, Address(x14,\n-                     Deoptimization::UnrollBlock::frame_pcs_offset()));\n-\n-  \/\/ Load address of array of frame sizes into x15 (intptr_t*)\n-  __ ld(x15, Address(x14,\n-                     Deoptimization::UnrollBlock::\n-                     frame_sizes_offset()));\n-\n-  \/\/ Counter\n-  __ lwu(x13, Address(x14,\n-                      Deoptimization::UnrollBlock::\n-                      number_of_frames_offset())); \/\/ (int)\n-\n-  \/\/ Now adjust the caller's stack to make up for the extra locals but\n-  \/\/ record the original sp so that we can save it in the skeletal\n-  \/\/ interpreter frame and the stack walking of interpreter_sender\n-  \/\/ will get the unextended sp value and not the \"real\" sp value.\n-\n-  const Register sender_sp = t1; \/\/ temporary register\n-\n-  __ lwu(x11, Address(x14,\n-                      Deoptimization::UnrollBlock::\n-                      caller_adjustment_offset())); \/\/ (int)\n-  __ mv(sender_sp, sp);\n-  __ sub(sp, sp, x11);\n-\n-  \/\/ Push interpreter frames in a loop\n-  Label loop;\n-  __ bind(loop);\n-  __ ld(x11, Address(x15, 0));       \/\/ Load frame size\n-  __ sub(x11, x11, 2 * wordSize);    \/\/ We'll push pc and fp by hand\n-  __ ld(ra, Address(x12, 0));        \/\/ Save return address\n-  __ enter();                        \/\/ and old fp & set new fp\n-  __ sub(sp, sp, x11);               \/\/ Prolog\n-  __ sd(sender_sp, Address(fp, frame::interpreter_frame_sender_sp_offset * wordSize)); \/\/ Make it walkable\n-  \/\/ This value is corrected by layout_activation_impl\n-  __ sd(zr, Address(fp, frame::interpreter_frame_last_sp_offset * wordSize));\n-  __ mv(sender_sp, sp);              \/\/ Pass sender_sp to next frame\n-  __ add(x15, x15, wordSize);        \/\/ Bump array pointer (sizes)\n-  __ add(x12, x12, wordSize);        \/\/ Bump array pointer (pcs)\n-  __ subw(x13, x13, 1);              \/\/ Decrement counter\n-  __ bgtz(x13, loop);\n-  __ ld(ra, Address(x12, 0));        \/\/ save final return address\n-  \/\/ Re-push self-frame\n-  __ enter();                        \/\/ & old fp & set new fp\n-\n-  \/\/ Use fp because the frames look interpreted now\n-  \/\/ Save \"the_pc\" since it cannot easily be retrieved using the last_java_SP after we aligned SP.\n-  \/\/ Don't need the precise return PC here, just precise enough to point into this code blob.\n-  address the_pc = __ pc();\n-  __ set_last_Java_frame(sp, fp, the_pc, t0);\n-\n-  \/\/ Call C code.  Need thread but NOT official VM entry\n-  \/\/ crud.  We cannot block on this call, no GC can happen.  Call should\n-  \/\/ restore return values to their stack-slots with the new SP.\n-  \/\/\n-  \/\/ BasicType unpack_frames(JavaThread* thread, int exec_mode)\n-  \/\/\n-\n-  \/\/ n.b. 2 gp args, 0 fp args, integral return type\n-\n-  \/\/ sp should already be aligned\n-  __ mv(c_rarg0, xthread);\n-  __ mv(c_rarg1, Deoptimization::Unpack_uncommon_trap);\n-  __ rt_call(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames));\n-\n-  \/\/ Set an oopmap for the call site\n-  \/\/ Use the same PC we used for the last java frame\n-  oop_maps->add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));\n-\n-  \/\/ Clear fp AND pc\n-  __ reset_last_Java_frame(true);\n-\n-  \/\/ Pop self-frame.\n-  __ leave();                 \/\/ Epilog\n-\n-  \/\/ Jump to interpreter\n-  __ ret();\n-\n-  \/\/ Make sure all code is generated\n-  masm->flush();\n-\n-  _uncommon_trap_blob =  UncommonTrapBlob::create(&buffer, oop_maps,\n-                                                  SimpleRuntimeFrame::framesize >> 1);\n-}\n-#endif \/\/ COMPILER2\n-\n@@ -2838,136 +2631,0 @@\n-\n-#ifdef COMPILER2\n-\/\/------------------------------generate_exception_blob---------------------------\n-\/\/ creates exception blob at the end\n-\/\/ Using exception blob, this code is jumped from a compiled method.\n-\/\/ (see emit_exception_handler in riscv.ad file)\n-\/\/\n-\/\/ Given an exception pc at a call we call into the runtime for the\n-\/\/ handler in this method. This handler might merely restore state\n-\/\/ (i.e. callee save registers) unwind the frame and jump to the\n-\/\/ exception handler for the nmethod if there is no Java level handler\n-\/\/ for the nmethod.\n-\/\/\n-\/\/ This code is entered with a jmp.\n-\/\/\n-\/\/ Arguments:\n-\/\/   x10: exception oop\n-\/\/   x13: exception pc\n-\/\/\n-\/\/ Results:\n-\/\/   x10: exception oop\n-\/\/   x13: exception pc in caller\n-\/\/   destination: exception handler of caller\n-\/\/\n-\/\/ Note: the exception pc MUST be at a call (precise debug information)\n-\/\/       Registers x10, x13, x12, x14, x15, t0 are not callee saved.\n-\/\/\n-\n-void OptoRuntime::generate_exception_blob() {\n-  assert(!OptoRuntime::is_callee_saved_register(R13_num), \"\");\n-  assert(!OptoRuntime::is_callee_saved_register(R10_num), \"\");\n-  assert(!OptoRuntime::is_callee_saved_register(R12_num), \"\");\n-\n-  assert(SimpleRuntimeFrame::framesize % 4 == 0, \"sp not 16-byte aligned\");\n-\n-  \/\/ Allocate space for the code\n-  ResourceMark rm;\n-  \/\/ Setup code generation tools\n-  CodeBuffer buffer(\"exception_blob\", 2048, 1024);\n-  MacroAssembler* masm = new MacroAssembler(&buffer);\n-  assert_cond(masm != nullptr);\n-\n-  \/\/ TODO check various assumptions made here\n-  \/\/\n-  \/\/ make sure we do so before running this\n-\n-  address start = __ pc();\n-\n-  \/\/ push fp and retaddr by hand\n-  \/\/ Exception pc is 'return address' for stack walker\n-  __ addi(sp, sp, -2 * wordSize);\n-  __ sd(ra, Address(sp, wordSize));\n-  __ sd(fp, Address(sp));\n-  \/\/ there are no callee save registers and we don't expect an\n-  \/\/ arg reg save area\n-#ifndef PRODUCT\n-  assert(frame::arg_reg_save_area_bytes == 0, \"not expecting frame reg save area\");\n-#endif\n-  \/\/ Store exception in Thread object. We cannot pass any arguments to the\n-  \/\/ handle_exception call, since we do not want to make any assumption\n-  \/\/ about the size of the frame where the exception happened in.\n-  __ sd(x10, Address(xthread, JavaThread::exception_oop_offset()));\n-  __ sd(x13, Address(xthread, JavaThread::exception_pc_offset()));\n-\n-  \/\/ This call does all the hard work.  It checks if an exception handler\n-  \/\/ exists in the method.\n-  \/\/ If so, it returns the handler address.\n-  \/\/ If not, it prepares for stack-unwinding, restoring the callee-save\n-  \/\/ registers of the frame being removed.\n-  \/\/\n-  \/\/ address OptoRuntime::handle_exception_C(JavaThread* thread)\n-  \/\/\n-  \/\/ n.b. 1 gp arg, 0 fp args, integral return type\n-\n-  \/\/ the stack should always be aligned\n-  address the_pc = __ pc();\n-  __ set_last_Java_frame(sp, noreg, the_pc, t0);\n-  __ mv(c_rarg0, xthread);\n-  __ rt_call(CAST_FROM_FN_PTR(address, OptoRuntime::handle_exception_C));\n-\n-  \/\/ handle_exception_C is a special VM call which does not require an explicit\n-  \/\/ instruction sync afterwards.\n-\n-  \/\/ Set an oopmap for the call site.  This oopmap will only be used if we\n-  \/\/ are unwinding the stack.  Hence, all locations will be dead.\n-  \/\/ Callee-saved registers will be the same as the frame above (i.e.,\n-  \/\/ handle_exception_stub), since they were restored when we got the\n-  \/\/ exception.\n-\n-  OopMapSet* oop_maps = new OopMapSet();\n-  assert_cond(oop_maps != nullptr);\n-\n-  oop_maps->add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));\n-\n-  __ reset_last_Java_frame(false);\n-\n-  \/\/ Restore callee-saved registers\n-\n-  \/\/ fp is an implicitly saved callee saved register (i.e. the calling\n-  \/\/ convention will save restore it in prolog\/epilog) Other than that\n-  \/\/ there are no callee save registers now that adapter frames are gone.\n-  \/\/ and we dont' expect an arg reg save area\n-  __ ld(fp, Address(sp));\n-  __ ld(x13, Address(sp, wordSize));\n-  __ addi(sp, sp , 2 * wordSize);\n-\n-  \/\/ x10: exception handler\n-\n-  \/\/ We have a handler in x10 (could be deopt blob).\n-  __ mv(t0, x10);\n-\n-  \/\/ Get the exception oop\n-  __ ld(x10, Address(xthread, JavaThread::exception_oop_offset()));\n-  \/\/ Get the exception pc in case we are deoptimized\n-  __ ld(x14, Address(xthread, JavaThread::exception_pc_offset()));\n-#ifdef ASSERT\n-  __ sd(zr, Address(xthread, JavaThread::exception_handler_pc_offset()));\n-  __ sd(zr, Address(xthread, JavaThread::exception_pc_offset()));\n-#endif\n-  \/\/ Clear the exception oop so GC no longer processes it as a root.\n-  __ sd(zr, Address(xthread, JavaThread::exception_oop_offset()));\n-\n-  \/\/ x10: exception oop\n-  \/\/ t0:  exception handler\n-  \/\/ x14: exception pc\n-  \/\/ Jump to handler\n-\n-  __ jr(t0);\n-\n-  \/\/ Make sure all code is generated\n-  masm->flush();\n-\n-  \/\/ Set exception blob\n-  _exception_blob =  ExceptionBlob::create(&buffer, oop_maps, SimpleRuntimeFrame::framesize >> 1);\n-}\n-#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":0,"deletions":343,"binary":false,"changes":343,"status":"modified"},{"patch":"@@ -2709,1 +2709,1 @@\n-void SharedRuntime::generate_uncommon_trap_blob() {\n+void OptoRuntime::generate_uncommon_trap_blob() {\n@@ -2772,1 +2772,1 @@\n-  __ asm_assert(Assembler::bcondEqual, \"SharedRuntime::generate_deopt_blob: expected Unpack_uncommon_trap\", 0);\n+  __ asm_assert(Assembler::bcondEqual, \"OptoRuntime::generate_deopt_blob: expected Unpack_uncommon_trap\", 0);\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,0 +44,174 @@\n+\/\/------------------------------generate_uncommon_trap_blob--------------------\n+void OptoRuntime::generate_uncommon_trap_blob() {\n+  \/\/ allocate space for the code\n+  ResourceMark rm;\n+  \/\/ setup code generation tools\n+  CodeBuffer   buffer(\"uncommon_trap_blob\", 512, 512);\n+  MacroAssembler* masm = new MacroAssembler(&buffer);\n+\n+  enum frame_layout {\n+    arg0_off,      \/\/ thread                     sp + 0 \/\/ Arg location for\n+    arg1_off,      \/\/ unloaded_class_index       sp + 1 \/\/ calling C\n+    arg2_off,      \/\/ exec_mode                  sp + 2\n+    \/\/ The frame sender code expects that rbp will be in the \"natural\" place and\n+    \/\/ will override any oopMap setting for it. We must therefore force the layout\n+    \/\/ so that it agrees with the frame sender code.\n+    rbp_off,       \/\/ callee saved register      sp + 3\n+    return_off,    \/\/ slot for return address    sp + 4\n+    framesize\n+  };\n+\n+  address start = __ pc();\n+\n+  \/\/ Push self-frame.\n+  __ subptr(rsp, return_off*wordSize);     \/\/ Epilog!\n+\n+  \/\/ rbp, is an implicitly saved callee saved register (i.e. the calling\n+  \/\/ convention will save restore it in prolog\/epilog) Other than that\n+  \/\/ there are no callee save registers no that adapter frames are gone.\n+  __ movptr(Address(rsp, rbp_off*wordSize), rbp);\n+\n+  \/\/ Clear the floating point exception stack\n+  __ empty_FPU_stack();\n+\n+  \/\/ set last_Java_sp\n+  __ get_thread(rdx);\n+  __ set_last_Java_frame(rdx, noreg, noreg, nullptr, noreg);\n+\n+  \/\/ Call C code.  Need thread but NOT official VM entry\n+  \/\/ crud.  We cannot block on this call, no GC can happen.  Call should\n+  \/\/ capture callee-saved registers as well as return values.\n+  __ movptr(Address(rsp, arg0_off*wordSize), rdx);\n+  \/\/ argument already in ECX\n+  __ movl(Address(rsp, arg1_off*wordSize),rcx);\n+  __ movl(Address(rsp, arg2_off*wordSize), Deoptimization::Unpack_uncommon_trap);\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::uncommon_trap)));\n+\n+  \/\/ Set an oopmap for the call site\n+  OopMapSet *oop_maps = new OopMapSet();\n+  OopMap* map =  new OopMap( framesize, 0 );\n+  \/\/ No oopMap for rbp, it is known implicitly\n+\n+  oop_maps->add_gc_map( __ pc()-start, map);\n+\n+  __ get_thread(rcx);\n+\n+  __ reset_last_Java_frame(rcx, false);\n+\n+  \/\/ Load UnrollBlock into EDI\n+  __ movptr(rdi, rax);\n+\n+#ifdef ASSERT\n+  { Label L;\n+    __ cmpptr(Address(rdi, Deoptimization::UnrollBlock::unpack_kind_offset()),\n+            (int32_t)Deoptimization::Unpack_uncommon_trap);\n+    __ jcc(Assembler::equal, L);\n+    __ stop(\"OptoRuntime::generate_uncommon_trap_blob: expected Unpack_uncommon_trap\");\n+    __ bind(L);\n+  }\n+#endif\n+\n+  \/\/ Pop all the frames we must move\/replace.\n+  \/\/\n+  \/\/ Frame picture (youngest to oldest)\n+  \/\/ 1: self-frame (no frame link)\n+  \/\/ 2: deopting frame  (no frame link)\n+  \/\/ 3: caller of deopting frame (could be compiled\/interpreted).\n+\n+  \/\/ Pop self-frame.  We have no frame, and must rely only on EAX and ESP.\n+  __ addptr(rsp,(framesize-1)*wordSize);     \/\/ Epilog!\n+\n+  \/\/ Pop deoptimized frame\n+  __ movl2ptr(rcx, Address(rdi,Deoptimization::UnrollBlock::size_of_deoptimized_frame_offset()));\n+  __ addptr(rsp, rcx);\n+\n+  \/\/ sp should be pointing at the return address to the caller (3)\n+\n+  \/\/ Pick up the initial fp we should save\n+  \/\/ restore rbp before stack bang because if stack overflow is thrown it needs to be pushed (and preserved)\n+  __ movptr(rbp, Address(rdi, Deoptimization::UnrollBlock::initial_info_offset()));\n+\n+#ifdef ASSERT\n+  \/\/ Compilers generate code that bang the stack by as much as the\n+  \/\/ interpreter would need. So this stack banging should never\n+  \/\/ trigger a fault. Verify that it does not on non product builds.\n+  __ movl(rbx, Address(rdi ,Deoptimization::UnrollBlock::total_frame_sizes_offset()));\n+  __ bang_stack_size(rbx, rcx);\n+#endif\n+\n+  \/\/ Load array of frame pcs into ECX\n+  __ movl(rcx,Address(rdi,Deoptimization::UnrollBlock::frame_pcs_offset()));\n+\n+  __ pop(rsi); \/\/ trash the pc\n+\n+  \/\/ Load array of frame sizes into ESI\n+  __ movptr(rsi,Address(rdi,Deoptimization::UnrollBlock::frame_sizes_offset()));\n+\n+  Address counter(rdi, Deoptimization::UnrollBlock::counter_temp_offset());\n+\n+  __ movl(rbx, Address(rdi, Deoptimization::UnrollBlock::number_of_frames_offset()));\n+  __ movl(counter, rbx);\n+\n+  \/\/ Now adjust the caller's stack to make up for the extra locals\n+  \/\/ but record the original sp so that we can save it in the skeletal interpreter\n+  \/\/ frame and the stack walking of interpreter_sender will get the unextended sp\n+  \/\/ value and not the \"real\" sp value.\n+\n+  Address sp_temp(rdi, Deoptimization::UnrollBlock::sender_sp_temp_offset());\n+  __ movptr(sp_temp, rsp);\n+  __ movl(rbx, Address(rdi, Deoptimization::UnrollBlock::caller_adjustment_offset()));\n+  __ subptr(rsp, rbx);\n+\n+  \/\/ Push interpreter frames in a loop\n+  Label loop;\n+  __ bind(loop);\n+  __ movptr(rbx, Address(rsi, 0));      \/\/ Load frame size\n+  __ subptr(rbx, 2*wordSize);           \/\/ we'll push pc and rbp, by hand\n+  __ pushptr(Address(rcx, 0));          \/\/ save return address\n+  __ enter();                           \/\/ save old & set new rbp,\n+  __ subptr(rsp, rbx);                  \/\/ Prolog!\n+  __ movptr(rbx, sp_temp);              \/\/ sender's sp\n+  \/\/ This value is corrected by layout_activation_impl\n+  __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), NULL_WORD );\n+  __ movptr(Address(rbp, frame::interpreter_frame_sender_sp_offset * wordSize), rbx); \/\/ Make it walkable\n+  __ movptr(sp_temp, rsp);              \/\/ pass to next frame\n+  __ addptr(rsi, wordSize);             \/\/ Bump array pointer (sizes)\n+  __ addptr(rcx, wordSize);             \/\/ Bump array pointer (pcs)\n+  __ decrementl(counter);             \/\/ decrement counter\n+  __ jcc(Assembler::notZero, loop);\n+  __ pushptr(Address(rcx, 0));            \/\/ save final return address\n+\n+  \/\/ Re-push self-frame\n+  __ enter();                           \/\/ save old & set new rbp,\n+  __ subptr(rsp, (framesize-2) * wordSize);   \/\/ Prolog!\n+\n+\n+  \/\/ set last_Java_sp, last_Java_fp\n+  __ get_thread(rdi);\n+  __ set_last_Java_frame(rdi, noreg, rbp, nullptr, noreg);\n+\n+  \/\/ Call C code.  Need thread but NOT official VM entry\n+  \/\/ crud.  We cannot block on this call, no GC can happen.  Call should\n+  \/\/ restore return values to their stack-slots with the new SP.\n+  __ movptr(Address(rsp,arg0_off*wordSize),rdi);\n+  __ movl(Address(rsp,arg1_off*wordSize), Deoptimization::Unpack_uncommon_trap);\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames)));\n+  \/\/ Set an oopmap for the call site\n+  oop_maps->add_gc_map( __ pc()-start, new OopMap( framesize, 0 ) );\n+\n+  __ get_thread(rdi);\n+  __ reset_last_Java_frame(rdi, true);\n+\n+  \/\/ Pop self-frame.\n+  __ leave();     \/\/ Epilog!\n+\n+  \/\/ Jump to interpreter\n+  __ ret(0);\n+\n+  \/\/ -------------\n+  \/\/ make sure all code is generated\n+  masm->flush();\n+\n+   _uncommon_trap_blob = UncommonTrapBlob::create(&buffer, oop_maps, framesize);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/runtime_x86_32.cpp","additions":174,"deletions":0,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -37,0 +37,78 @@\n+\n+class SimpleRuntimeFrame {\n+\n+  public:\n+\n+  \/\/ Most of the runtime stubs have this simple frame layout.\n+  \/\/ This class exists to make the layout shared in one place.\n+  \/\/ Offsets are for compiler stack slots, which are jints.\n+  enum layout {\n+    \/\/ The frame sender code expects that rbp will be in the \"natural\" place and\n+    \/\/ will override any oopMap setting for it. We must therefore force the layout\n+    \/\/ so that it agrees with the frame sender code.\n+    rbp_off = frame::arg_reg_save_area_bytes\/BytesPerInt,\n+    rbp_off2,\n+    return_off, return_off2,\n+    framesize\n+  };\n+};\n+\n+#define __ masm->\n+\n+\/\/------------------------------generate_uncommon_trap_blob--------------------\n+void OptoRuntime::generate_uncommon_trap_blob() {\n+  \/\/ Allocate space for the code\n+  ResourceMark rm;\n+  \/\/ Setup code generation tools\n+  CodeBuffer buffer(\"uncommon_trap_blob\", 2048, 1024);\n+  MacroAssembler* masm = new MacroAssembler(&buffer);\n+\n+  assert(SimpleRuntimeFrame::framesize % 4 == 0, \"sp not 16-byte aligned\");\n+\n+  address start = __ pc();\n+\n+  \/\/ Push self-frame.  We get here with a return address on the\n+  \/\/ stack, so rsp is 8-byte aligned until we allocate our frame.\n+  __ subptr(rsp, SimpleRuntimeFrame::return_off << LogBytesPerInt); \/\/ Epilog!\n+\n+  \/\/ No callee saved registers. rbp is assumed implicitly saved\n+  __ movptr(Address(rsp, SimpleRuntimeFrame::rbp_off << LogBytesPerInt), rbp);\n+\n+  \/\/ compiler left unloaded_class_index in j_rarg0 move to where the\n+  \/\/ runtime expects it.\n+  __ movl(c_rarg1, j_rarg0);\n+\n+  __ set_last_Java_frame(noreg, noreg, nullptr, rscratch1);\n+\n+  \/\/ Call C code.  Need thread but NOT official VM entry\n+  \/\/ crud.  We cannot block on this call, no GC can happen.  Call should\n+  \/\/ capture callee-saved registers as well as return values.\n+  \/\/ Thread is in rdi already.\n+  \/\/\n+  \/\/ UnrollBlock* uncommon_trap(JavaThread* thread, jint unloaded_class_index);\n+\n+  __ mov(c_rarg0, r15_thread);\n+  __ movl(c_rarg2, Deoptimization::Unpack_uncommon_trap);\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::uncommon_trap)));\n+\n+  \/\/ Set an oopmap for the call site\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(SimpleRuntimeFrame::framesize, 0);\n+\n+  \/\/ location of rbp is known implicitly by the frame sender code\n+\n+  oop_maps->add_gc_map(__ pc() - start, map);\n+\n+  __ reset_last_Java_frame(false);\n+\n+  \/\/ Load UnrollBlock* into rdi\n+  __ mov(rdi, rax);\n+\n+#ifdef ASSERT\n+  { Label L;\n+    __ cmpptr(Address(rdi, Deoptimization::UnrollBlock::unpack_kind_offset()),\n+              Deoptimization::Unpack_uncommon_trap);\n+    __ jcc(Assembler::equal, L);\n+    __ stop(\"OptoRuntime::generate_uncommon_trap_blob: expected Unpack_uncommon_trap\");\n+    __ bind(L);\n+  }\n@@ -39,0 +117,240 @@\n+  \/\/ Pop all the frames we must move\/replace.\n+  \/\/\n+  \/\/ Frame picture (youngest to oldest)\n+  \/\/ 1: self-frame (no frame link)\n+  \/\/ 2: deopting frame  (no frame link)\n+  \/\/ 3: caller of deopting frame (could be compiled\/interpreted).\n+\n+  \/\/ Pop self-frame.  We have no frame, and must rely only on rax and rsp.\n+  __ addptr(rsp, (SimpleRuntimeFrame::framesize - 2) << LogBytesPerInt); \/\/ Epilog!\n+\n+  \/\/ Pop deoptimized frame (int)\n+  __ movl(rcx, Address(rdi,\n+                       Deoptimization::UnrollBlock::\n+                       size_of_deoptimized_frame_offset()));\n+  __ addptr(rsp, rcx);\n+\n+  \/\/ rsp should be pointing at the return address to the caller (3)\n+\n+  \/\/ Pick up the initial fp we should save\n+  \/\/ restore rbp before stack bang because if stack overflow is thrown it needs to be pushed (and preserved)\n+  __ movptr(rbp, Address(rdi, Deoptimization::UnrollBlock::initial_info_offset()));\n+\n+#ifdef ASSERT\n+  \/\/ Compilers generate code that bang the stack by as much as the\n+  \/\/ interpreter would need. So this stack banging should never\n+  \/\/ trigger a fault. Verify that it does not on non product builds.\n+  __ movl(rbx, Address(rdi ,Deoptimization::UnrollBlock::total_frame_sizes_offset()));\n+  __ bang_stack_size(rbx, rcx);\n+#endif\n+\n+  \/\/ Load address of array of frame pcs into rcx (address*)\n+  __ movptr(rcx, Address(rdi, Deoptimization::UnrollBlock::frame_pcs_offset()));\n+\n+  \/\/ Trash the return pc\n+  __ addptr(rsp, wordSize);\n+\n+  \/\/ Load address of array of frame sizes into rsi (intptr_t*)\n+  __ movptr(rsi, Address(rdi, Deoptimization::UnrollBlock:: frame_sizes_offset()));\n+\n+  \/\/ Counter\n+  __ movl(rdx, Address(rdi, Deoptimization::UnrollBlock:: number_of_frames_offset())); \/\/ (int)\n+\n+  \/\/ Now adjust the caller's stack to make up for the extra locals but\n+  \/\/ record the original sp so that we can save it in the skeletal\n+  \/\/ interpreter frame and the stack walking of interpreter_sender\n+  \/\/ will get the unextended sp value and not the \"real\" sp value.\n+\n+  const Register sender_sp = r8;\n+\n+  __ mov(sender_sp, rsp);\n+  __ movl(rbx, Address(rdi, Deoptimization::UnrollBlock:: caller_adjustment_offset())); \/\/ (int)\n+  __ subptr(rsp, rbx);\n+\n+  \/\/ Push interpreter frames in a loop\n+  Label loop;\n+  __ bind(loop);\n+  __ movptr(rbx, Address(rsi, 0)); \/\/ Load frame size\n+  __ subptr(rbx, 2 * wordSize);    \/\/ We'll push pc and rbp by hand\n+  __ pushptr(Address(rcx, 0));     \/\/ Save return address\n+  __ enter();                      \/\/ Save old & set new rbp\n+  __ subptr(rsp, rbx);             \/\/ Prolog\n+  __ movptr(Address(rbp, frame::interpreter_frame_sender_sp_offset * wordSize),\n+            sender_sp);            \/\/ Make it walkable\n+  \/\/ This value is corrected by layout_activation_impl\n+  __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), NULL_WORD);\n+  __ mov(sender_sp, rsp);          \/\/ Pass sender_sp to next frame\n+  __ addptr(rsi, wordSize);        \/\/ Bump array pointer (sizes)\n+  __ addptr(rcx, wordSize);        \/\/ Bump array pointer (pcs)\n+  __ decrementl(rdx);              \/\/ Decrement counter\n+  __ jcc(Assembler::notZero, loop);\n+  __ pushptr(Address(rcx, 0));     \/\/ Save final return address\n+\n+  \/\/ Re-push self-frame\n+  __ enter();                 \/\/ Save old & set new rbp\n+  __ subptr(rsp, (SimpleRuntimeFrame::framesize - 4) << LogBytesPerInt);\n+                              \/\/ Prolog\n+\n+  \/\/ Use rbp because the frames look interpreted now\n+  \/\/ Save \"the_pc\" since it cannot easily be retrieved using the last_java_SP after we aligned SP.\n+  \/\/ Don't need the precise return PC here, just precise enough to point into this code blob.\n+  address the_pc = __ pc();\n+  __ set_last_Java_frame(noreg, rbp, the_pc, rscratch1);\n+\n+  \/\/ Call C code.  Need thread but NOT official VM entry\n+  \/\/ crud.  We cannot block on this call, no GC can happen.  Call should\n+  \/\/ restore return values to their stack-slots with the new SP.\n+  \/\/ Thread is in rdi already.\n+  \/\/\n+  \/\/ BasicType unpack_frames(JavaThread* thread, int exec_mode);\n+\n+  __ andptr(rsp, -(StackAlignmentInBytes)); \/\/ Align SP as required by ABI\n+  __ mov(c_rarg0, r15_thread);\n+  __ movl(c_rarg1, Deoptimization::Unpack_uncommon_trap);\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames)));\n+\n+  \/\/ Set an oopmap for the call site\n+  \/\/ Use the same PC we used for the last java frame\n+  oop_maps->add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));\n+\n+  \/\/ Clear fp AND pc\n+  __ reset_last_Java_frame(true);\n+\n+  \/\/ Pop self-frame.\n+  __ leave();                 \/\/ Epilog\n+\n+  \/\/ Jump to interpreter\n+  __ ret(0);\n+\n+  \/\/ Make sure all code is generated\n+  masm->flush();\n+\n+  _uncommon_trap_blob =  UncommonTrapBlob::create(&buffer, oop_maps,\n+                                                 SimpleRuntimeFrame::framesize >> 1);\n+}\n+\n+\/\/------------------------------generate_exception_blob---------------------------\n+\/\/ creates exception blob at the end\n+\/\/ Using exception blob, this code is jumped from a compiled method.\n+\/\/ (see emit_exception_handler in x86_64.ad file)\n+\/\/\n+\/\/ Given an exception pc at a call we call into the runtime for the\n+\/\/ handler in this method. This handler might merely restore state\n+\/\/ (i.e. callee save registers) unwind the frame and jump to the\n+\/\/ exception handler for the nmethod if there is no Java level handler\n+\/\/ for the nmethod.\n+\/\/\n+\/\/ This code is entered with a jmp.\n+\/\/\n+\/\/ Arguments:\n+\/\/   rax: exception oop\n+\/\/   rdx: exception pc\n+\/\/\n+\/\/ Results:\n+\/\/   rax: exception oop\n+\/\/   rdx: exception pc in caller or ???\n+\/\/   destination: exception handler of caller\n+\/\/\n+\/\/ Note: the exception pc MUST be at a call (precise debug information)\n+\/\/       Registers rax, rdx, rcx, rsi, rdi, r8-r11 are not callee saved.\n+\/\/\n+\n+void OptoRuntime::generate_exception_blob() {\n+  assert(!OptoRuntime::is_callee_saved_register(RDX_num), \"\");\n+  assert(!OptoRuntime::is_callee_saved_register(RAX_num), \"\");\n+  assert(!OptoRuntime::is_callee_saved_register(RCX_num), \"\");\n+\n+  assert(SimpleRuntimeFrame::framesize % 4 == 0, \"sp not 16-byte aligned\");\n+\n+  \/\/ Allocate space for the code\n+  ResourceMark rm;\n+  \/\/ Setup code generation tools\n+  CodeBuffer buffer(\"exception_blob\", 2048, 1024);\n+  MacroAssembler* masm = new MacroAssembler(&buffer);\n+\n+\n+  address start = __ pc();\n+\n+  \/\/ Exception pc is 'return address' for stack walker\n+  __ push(rdx);\n+  __ subptr(rsp, SimpleRuntimeFrame::return_off << LogBytesPerInt); \/\/ Prolog\n+\n+  \/\/ Save callee-saved registers.  See x86_64.ad.\n+\n+  \/\/ rbp is an implicitly saved callee saved register (i.e., the calling\n+  \/\/ convention will save\/restore it in the prolog\/epilog). Other than that\n+  \/\/ there are no callee save registers now that adapter frames are gone.\n+\n+  __ movptr(Address(rsp, SimpleRuntimeFrame::rbp_off << LogBytesPerInt), rbp);\n+\n+  \/\/ Store exception in Thread object. We cannot pass any arguments to the\n+  \/\/ handle_exception call, since we do not want to make any assumption\n+  \/\/ about the size of the frame where the exception happened in.\n+  \/\/ c_rarg0 is either rdi (Linux) or rcx (Windows).\n+  __ movptr(Address(r15_thread, JavaThread::exception_oop_offset()),rax);\n+  __ movptr(Address(r15_thread, JavaThread::exception_pc_offset()), rdx);\n+\n+  \/\/ This call does all the hard work.  It checks if an exception handler\n+  \/\/ exists in the method.\n+  \/\/ If so, it returns the handler address.\n+  \/\/ If not, it prepares for stack-unwinding, restoring the callee-save\n+  \/\/ registers of the frame being removed.\n+  \/\/\n+  \/\/ address OptoRuntime::handle_exception_C(JavaThread* thread)\n+\n+  \/\/ At a method handle call, the stack may not be properly aligned\n+  \/\/ when returning with an exception.\n+  address the_pc = __ pc();\n+  __ set_last_Java_frame(noreg, noreg, the_pc, rscratch1);\n+  __ mov(c_rarg0, r15_thread);\n+  __ andptr(rsp, -(StackAlignmentInBytes));    \/\/ Align stack\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, OptoRuntime::handle_exception_C)));\n+\n+  \/\/ Set an oopmap for the call site.  This oopmap will only be used if we\n+  \/\/ are unwinding the stack.  Hence, all locations will be dead.\n+  \/\/ Callee-saved registers will be the same as the frame above (i.e.,\n+  \/\/ handle_exception_stub), since they were restored when we got the\n+  \/\/ exception.\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+\n+  oop_maps->add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));\n+\n+  __ reset_last_Java_frame(false);\n+\n+  \/\/ Restore callee-saved registers\n+\n+  \/\/ rbp is an implicitly saved callee-saved register (i.e., the calling\n+  \/\/ convention will save restore it in prolog\/epilog) Other than that\n+  \/\/ there are no callee save registers now that adapter frames are gone.\n+\n+  __ movptr(rbp, Address(rsp, SimpleRuntimeFrame::rbp_off << LogBytesPerInt));\n+\n+  __ addptr(rsp, SimpleRuntimeFrame::return_off << LogBytesPerInt); \/\/ Epilog\n+  __ pop(rdx);                  \/\/ No need for exception pc anymore\n+\n+  \/\/ rax: exception handler\n+\n+  \/\/ We have a handler in rax (could be deopt blob).\n+  __ mov(r8, rax);\n+\n+  \/\/ Get the exception oop\n+  __ movptr(rax, Address(r15_thread, JavaThread::exception_oop_offset()));\n+  \/\/ Get the exception pc in case we are deoptimized\n+  __ movptr(rdx, Address(r15_thread, JavaThread::exception_pc_offset()));\n+#ifdef ASSERT\n+  __ movptr(Address(r15_thread, JavaThread::exception_handler_pc_offset()), NULL_WORD);\n+  __ movptr(Address(r15_thread, JavaThread::exception_pc_offset()), NULL_WORD);\n+#endif\n+  \/\/ Clear the exception oop so GC no longer processes it as a root.\n+  __ movptr(Address(r15_thread, JavaThread::exception_oop_offset()), NULL_WORD);\n+\n+  \/\/ rax: exception oop\n+  \/\/ r8:  exception handler\n+  \/\/ rdx: exception pc\n+  \/\/ Jump to handler\n+\n+  __ jmp(r8);\n+\n+  \/\/ Make sure all code is generated\n+  masm->flush();\n@@ -40,5 +358,4 @@\n-\/\/ This file should really contain the code for generating the OptoRuntime\n-\/\/ exception_blob. However that code uses SimpleRuntimeFrame which only\n-\/\/ exists in sharedRuntime_x86_64.cpp. When there is a sharedRuntime_<arch>.hpp\n-\/\/ file and SimpleRuntimeFrame is able to move there then the exception_blob\n-\/\/ code will move here where it belongs.\n+  \/\/ Set exception blob\n+  _exception_blob =  ExceptionBlob::create(&buffer, oop_maps, SimpleRuntimeFrame::framesize >> 1);\n+}\n+#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/cpu\/x86\/runtime_x86_64.cpp","additions":322,"deletions":5,"binary":false,"changes":327,"status":"modified"},{"patch":"@@ -2392,177 +2392,0 @@\n-\n-#ifdef COMPILER2\n-\/\/------------------------------generate_uncommon_trap_blob--------------------\n-void SharedRuntime::generate_uncommon_trap_blob() {\n-  \/\/ allocate space for the code\n-  ResourceMark rm;\n-  \/\/ setup code generation tools\n-  CodeBuffer   buffer(\"uncommon_trap_blob\", 512, 512);\n-  MacroAssembler* masm = new MacroAssembler(&buffer);\n-\n-  enum frame_layout {\n-    arg0_off,      \/\/ thread                     sp + 0 \/\/ Arg location for\n-    arg1_off,      \/\/ unloaded_class_index       sp + 1 \/\/ calling C\n-    arg2_off,      \/\/ exec_mode                  sp + 2\n-    \/\/ The frame sender code expects that rbp will be in the \"natural\" place and\n-    \/\/ will override any oopMap setting for it. We must therefore force the layout\n-    \/\/ so that it agrees with the frame sender code.\n-    rbp_off,       \/\/ callee saved register      sp + 3\n-    return_off,    \/\/ slot for return address    sp + 4\n-    framesize\n-  };\n-\n-  address start = __ pc();\n-\n-  \/\/ Push self-frame.\n-  __ subptr(rsp, return_off*wordSize);     \/\/ Epilog!\n-\n-  \/\/ rbp, is an implicitly saved callee saved register (i.e. the calling\n-  \/\/ convention will save restore it in prolog\/epilog) Other than that\n-  \/\/ there are no callee save registers no that adapter frames are gone.\n-  __ movptr(Address(rsp, rbp_off*wordSize), rbp);\n-\n-  \/\/ Clear the floating point exception stack\n-  __ empty_FPU_stack();\n-\n-  \/\/ set last_Java_sp\n-  __ get_thread(rdx);\n-  __ set_last_Java_frame(rdx, noreg, noreg, nullptr, noreg);\n-\n-  \/\/ Call C code.  Need thread but NOT official VM entry\n-  \/\/ crud.  We cannot block on this call, no GC can happen.  Call should\n-  \/\/ capture callee-saved registers as well as return values.\n-  __ movptr(Address(rsp, arg0_off*wordSize), rdx);\n-  \/\/ argument already in ECX\n-  __ movl(Address(rsp, arg1_off*wordSize),rcx);\n-  __ movl(Address(rsp, arg2_off*wordSize), Deoptimization::Unpack_uncommon_trap);\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::uncommon_trap)));\n-\n-  \/\/ Set an oopmap for the call site\n-  OopMapSet *oop_maps = new OopMapSet();\n-  OopMap* map =  new OopMap( framesize, 0 );\n-  \/\/ No oopMap for rbp, it is known implicitly\n-\n-  oop_maps->add_gc_map( __ pc()-start, map);\n-\n-  __ get_thread(rcx);\n-\n-  __ reset_last_Java_frame(rcx, false);\n-\n-  \/\/ Load UnrollBlock into EDI\n-  __ movptr(rdi, rax);\n-\n-#ifdef ASSERT\n-  { Label L;\n-    __ cmpptr(Address(rdi, Deoptimization::UnrollBlock::unpack_kind_offset()),\n-            (int32_t)Deoptimization::Unpack_uncommon_trap);\n-    __ jcc(Assembler::equal, L);\n-    __ stop(\"SharedRuntime::generate_uncommon_trap_blob: expected Unpack_uncommon_trap\");\n-    __ bind(L);\n-  }\n-#endif\n-\n-  \/\/ Pop all the frames we must move\/replace.\n-  \/\/\n-  \/\/ Frame picture (youngest to oldest)\n-  \/\/ 1: self-frame (no frame link)\n-  \/\/ 2: deopting frame  (no frame link)\n-  \/\/ 3: caller of deopting frame (could be compiled\/interpreted).\n-\n-  \/\/ Pop self-frame.  We have no frame, and must rely only on EAX and ESP.\n-  __ addptr(rsp,(framesize-1)*wordSize);     \/\/ Epilog!\n-\n-  \/\/ Pop deoptimized frame\n-  __ movl2ptr(rcx, Address(rdi,Deoptimization::UnrollBlock::size_of_deoptimized_frame_offset()));\n-  __ addptr(rsp, rcx);\n-\n-  \/\/ sp should be pointing at the return address to the caller (3)\n-\n-  \/\/ Pick up the initial fp we should save\n-  \/\/ restore rbp before stack bang because if stack overflow is thrown it needs to be pushed (and preserved)\n-  __ movptr(rbp, Address(rdi, Deoptimization::UnrollBlock::initial_info_offset()));\n-\n-#ifdef ASSERT\n-  \/\/ Compilers generate code that bang the stack by as much as the\n-  \/\/ interpreter would need. So this stack banging should never\n-  \/\/ trigger a fault. Verify that it does not on non product builds.\n-  __ movl(rbx, Address(rdi ,Deoptimization::UnrollBlock::total_frame_sizes_offset()));\n-  __ bang_stack_size(rbx, rcx);\n-#endif\n-\n-  \/\/ Load array of frame pcs into ECX\n-  __ movl(rcx,Address(rdi,Deoptimization::UnrollBlock::frame_pcs_offset()));\n-\n-  __ pop(rsi); \/\/ trash the pc\n-\n-  \/\/ Load array of frame sizes into ESI\n-  __ movptr(rsi,Address(rdi,Deoptimization::UnrollBlock::frame_sizes_offset()));\n-\n-  Address counter(rdi, Deoptimization::UnrollBlock::counter_temp_offset());\n-\n-  __ movl(rbx, Address(rdi, Deoptimization::UnrollBlock::number_of_frames_offset()));\n-  __ movl(counter, rbx);\n-\n-  \/\/ Now adjust the caller's stack to make up for the extra locals\n-  \/\/ but record the original sp so that we can save it in the skeletal interpreter\n-  \/\/ frame and the stack walking of interpreter_sender will get the unextended sp\n-  \/\/ value and not the \"real\" sp value.\n-\n-  Address sp_temp(rdi, Deoptimization::UnrollBlock::sender_sp_temp_offset());\n-  __ movptr(sp_temp, rsp);\n-  __ movl(rbx, Address(rdi, Deoptimization::UnrollBlock::caller_adjustment_offset()));\n-  __ subptr(rsp, rbx);\n-\n-  \/\/ Push interpreter frames in a loop\n-  Label loop;\n-  __ bind(loop);\n-  __ movptr(rbx, Address(rsi, 0));      \/\/ Load frame size\n-  __ subptr(rbx, 2*wordSize);           \/\/ we'll push pc and rbp, by hand\n-  __ pushptr(Address(rcx, 0));          \/\/ save return address\n-  __ enter();                           \/\/ save old & set new rbp,\n-  __ subptr(rsp, rbx);                  \/\/ Prolog!\n-  __ movptr(rbx, sp_temp);              \/\/ sender's sp\n-  \/\/ This value is corrected by layout_activation_impl\n-  __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), NULL_WORD );\n-  __ movptr(Address(rbp, frame::interpreter_frame_sender_sp_offset * wordSize), rbx); \/\/ Make it walkable\n-  __ movptr(sp_temp, rsp);              \/\/ pass to next frame\n-  __ addptr(rsi, wordSize);             \/\/ Bump array pointer (sizes)\n-  __ addptr(rcx, wordSize);             \/\/ Bump array pointer (pcs)\n-  __ decrementl(counter);             \/\/ decrement counter\n-  __ jcc(Assembler::notZero, loop);\n-  __ pushptr(Address(rcx, 0));            \/\/ save final return address\n-\n-  \/\/ Re-push self-frame\n-  __ enter();                           \/\/ save old & set new rbp,\n-  __ subptr(rsp, (framesize-2) * wordSize);   \/\/ Prolog!\n-\n-\n-  \/\/ set last_Java_sp, last_Java_fp\n-  __ get_thread(rdi);\n-  __ set_last_Java_frame(rdi, noreg, rbp, nullptr, noreg);\n-\n-  \/\/ Call C code.  Need thread but NOT official VM entry\n-  \/\/ crud.  We cannot block on this call, no GC can happen.  Call should\n-  \/\/ restore return values to their stack-slots with the new SP.\n-  __ movptr(Address(rsp,arg0_off*wordSize),rdi);\n-  __ movl(Address(rsp,arg1_off*wordSize), Deoptimization::Unpack_uncommon_trap);\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames)));\n-  \/\/ Set an oopmap for the call site\n-  oop_maps->add_gc_map( __ pc()-start, new OopMap( framesize, 0 ) );\n-\n-  __ get_thread(rdi);\n-  __ reset_last_Java_frame(rdi, true);\n-\n-  \/\/ Pop self-frame.\n-  __ leave();     \/\/ Epilog!\n-\n-  \/\/ Jump to interpreter\n-  __ ret(0);\n-\n-  \/\/ -------------\n-  \/\/ make sure all code is generated\n-  masm->flush();\n-\n-   _uncommon_trap_blob = UncommonTrapBlob::create(&buffer, oop_maps, framesize);\n-}\n-#endif \/\/ COMPILER2\n-\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":0,"deletions":177,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -75,18 +75,0 @@\n-class SimpleRuntimeFrame {\n-\n-  public:\n-\n-  \/\/ Most of the runtime stubs have this simple frame layout.\n-  \/\/ This class exists to make the layout shared in one place.\n-  \/\/ Offsets are for compiler stack slots, which are jints.\n-  enum layout {\n-    \/\/ The frame sender code expects that rbp will be in the \"natural\" place and\n-    \/\/ will override any oopMap setting for it. We must therefore force the layout\n-    \/\/ so that it agrees with the frame sender code.\n-    rbp_off = frame::arg_reg_save_area_bytes\/BytesPerInt,\n-    rbp_off2,\n-    return_off, return_off2,\n-    framesize\n-  };\n-};\n-\n@@ -2990,176 +2972,0 @@\n-#ifdef COMPILER2\n-\/\/------------------------------generate_uncommon_trap_blob--------------------\n-void SharedRuntime::generate_uncommon_trap_blob() {\n-  \/\/ Allocate space for the code\n-  ResourceMark rm;\n-  \/\/ Setup code generation tools\n-  CodeBuffer buffer(\"uncommon_trap_blob\", 2048, 1024);\n-  MacroAssembler* masm = new MacroAssembler(&buffer);\n-\n-  assert(SimpleRuntimeFrame::framesize % 4 == 0, \"sp not 16-byte aligned\");\n-\n-  address start = __ pc();\n-\n-  \/\/ Push self-frame.  We get here with a return address on the\n-  \/\/ stack, so rsp is 8-byte aligned until we allocate our frame.\n-  __ subptr(rsp, SimpleRuntimeFrame::return_off << LogBytesPerInt); \/\/ Epilog!\n-\n-  \/\/ No callee saved registers. rbp is assumed implicitly saved\n-  __ movptr(Address(rsp, SimpleRuntimeFrame::rbp_off << LogBytesPerInt), rbp);\n-\n-  \/\/ compiler left unloaded_class_index in j_rarg0 move to where the\n-  \/\/ runtime expects it.\n-  __ movl(c_rarg1, j_rarg0);\n-\n-  __ set_last_Java_frame(noreg, noreg, nullptr, rscratch1);\n-\n-  \/\/ Call C code.  Need thread but NOT official VM entry\n-  \/\/ crud.  We cannot block on this call, no GC can happen.  Call should\n-  \/\/ capture callee-saved registers as well as return values.\n-  \/\/ Thread is in rdi already.\n-  \/\/\n-  \/\/ UnrollBlock* uncommon_trap(JavaThread* thread, jint unloaded_class_index);\n-\n-  __ mov(c_rarg0, r15_thread);\n-  __ movl(c_rarg2, Deoptimization::Unpack_uncommon_trap);\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::uncommon_trap)));\n-\n-  \/\/ Set an oopmap for the call site\n-  OopMapSet* oop_maps = new OopMapSet();\n-  OopMap* map = new OopMap(SimpleRuntimeFrame::framesize, 0);\n-\n-  \/\/ location of rbp is known implicitly by the frame sender code\n-\n-  oop_maps->add_gc_map(__ pc() - start, map);\n-\n-  __ reset_last_Java_frame(false);\n-\n-  \/\/ Load UnrollBlock* into rdi\n-  __ mov(rdi, rax);\n-\n-#ifdef ASSERT\n-  { Label L;\n-    __ cmpptr(Address(rdi, Deoptimization::UnrollBlock::unpack_kind_offset()),\n-              Deoptimization::Unpack_uncommon_trap);\n-    __ jcc(Assembler::equal, L);\n-    __ stop(\"SharedRuntime::generate_uncommon_trap_blob: expected Unpack_uncommon_trap\");\n-    __ bind(L);\n-  }\n-#endif\n-\n-  \/\/ Pop all the frames we must move\/replace.\n-  \/\/\n-  \/\/ Frame picture (youngest to oldest)\n-  \/\/ 1: self-frame (no frame link)\n-  \/\/ 2: deopting frame  (no frame link)\n-  \/\/ 3: caller of deopting frame (could be compiled\/interpreted).\n-\n-  \/\/ Pop self-frame.  We have no frame, and must rely only on rax and rsp.\n-  __ addptr(rsp, (SimpleRuntimeFrame::framesize - 2) << LogBytesPerInt); \/\/ Epilog!\n-\n-  \/\/ Pop deoptimized frame (int)\n-  __ movl(rcx, Address(rdi,\n-                       Deoptimization::UnrollBlock::\n-                       size_of_deoptimized_frame_offset()));\n-  __ addptr(rsp, rcx);\n-\n-  \/\/ rsp should be pointing at the return address to the caller (3)\n-\n-  \/\/ Pick up the initial fp we should save\n-  \/\/ restore rbp before stack bang because if stack overflow is thrown it needs to be pushed (and preserved)\n-  __ movptr(rbp, Address(rdi, Deoptimization::UnrollBlock::initial_info_offset()));\n-\n-#ifdef ASSERT\n-  \/\/ Compilers generate code that bang the stack by as much as the\n-  \/\/ interpreter would need. So this stack banging should never\n-  \/\/ trigger a fault. Verify that it does not on non product builds.\n-  __ movl(rbx, Address(rdi ,Deoptimization::UnrollBlock::total_frame_sizes_offset()));\n-  __ bang_stack_size(rbx, rcx);\n-#endif\n-\n-  \/\/ Load address of array of frame pcs into rcx (address*)\n-  __ movptr(rcx, Address(rdi, Deoptimization::UnrollBlock::frame_pcs_offset()));\n-\n-  \/\/ Trash the return pc\n-  __ addptr(rsp, wordSize);\n-\n-  \/\/ Load address of array of frame sizes into rsi (intptr_t*)\n-  __ movptr(rsi, Address(rdi, Deoptimization::UnrollBlock:: frame_sizes_offset()));\n-\n-  \/\/ Counter\n-  __ movl(rdx, Address(rdi, Deoptimization::UnrollBlock:: number_of_frames_offset())); \/\/ (int)\n-\n-  \/\/ Now adjust the caller's stack to make up for the extra locals but\n-  \/\/ record the original sp so that we can save it in the skeletal\n-  \/\/ interpreter frame and the stack walking of interpreter_sender\n-  \/\/ will get the unextended sp value and not the \"real\" sp value.\n-\n-  const Register sender_sp = r8;\n-\n-  __ mov(sender_sp, rsp);\n-  __ movl(rbx, Address(rdi, Deoptimization::UnrollBlock:: caller_adjustment_offset())); \/\/ (int)\n-  __ subptr(rsp, rbx);\n-\n-  \/\/ Push interpreter frames in a loop\n-  Label loop;\n-  __ bind(loop);\n-  __ movptr(rbx, Address(rsi, 0)); \/\/ Load frame size\n-  __ subptr(rbx, 2 * wordSize);    \/\/ We'll push pc and rbp by hand\n-  __ pushptr(Address(rcx, 0));     \/\/ Save return address\n-  __ enter();                      \/\/ Save old & set new rbp\n-  __ subptr(rsp, rbx);             \/\/ Prolog\n-  __ movptr(Address(rbp, frame::interpreter_frame_sender_sp_offset * wordSize),\n-            sender_sp);            \/\/ Make it walkable\n-  \/\/ This value is corrected by layout_activation_impl\n-  __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), NULL_WORD);\n-  __ mov(sender_sp, rsp);          \/\/ Pass sender_sp to next frame\n-  __ addptr(rsi, wordSize);        \/\/ Bump array pointer (sizes)\n-  __ addptr(rcx, wordSize);        \/\/ Bump array pointer (pcs)\n-  __ decrementl(rdx);              \/\/ Decrement counter\n-  __ jcc(Assembler::notZero, loop);\n-  __ pushptr(Address(rcx, 0));     \/\/ Save final return address\n-\n-  \/\/ Re-push self-frame\n-  __ enter();                 \/\/ Save old & set new rbp\n-  __ subptr(rsp, (SimpleRuntimeFrame::framesize - 4) << LogBytesPerInt);\n-                              \/\/ Prolog\n-\n-  \/\/ Use rbp because the frames look interpreted now\n-  \/\/ Save \"the_pc\" since it cannot easily be retrieved using the last_java_SP after we aligned SP.\n-  \/\/ Don't need the precise return PC here, just precise enough to point into this code blob.\n-  address the_pc = __ pc();\n-  __ set_last_Java_frame(noreg, rbp, the_pc, rscratch1);\n-\n-  \/\/ Call C code.  Need thread but NOT official VM entry\n-  \/\/ crud.  We cannot block on this call, no GC can happen.  Call should\n-  \/\/ restore return values to their stack-slots with the new SP.\n-  \/\/ Thread is in rdi already.\n-  \/\/\n-  \/\/ BasicType unpack_frames(JavaThread* thread, int exec_mode);\n-\n-  __ andptr(rsp, -(StackAlignmentInBytes)); \/\/ Align SP as required by ABI\n-  __ mov(c_rarg0, r15_thread);\n-  __ movl(c_rarg1, Deoptimization::Unpack_uncommon_trap);\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames)));\n-\n-  \/\/ Set an oopmap for the call site\n-  \/\/ Use the same PC we used for the last java frame\n-  oop_maps->add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));\n-\n-  \/\/ Clear fp AND pc\n-  __ reset_last_Java_frame(true);\n-\n-  \/\/ Pop self-frame.\n-  __ leave();                 \/\/ Epilog\n-\n-  \/\/ Jump to interpreter\n-  __ ret(0);\n-\n-  \/\/ Make sure all code is generated\n-  masm->flush();\n-\n-  _uncommon_trap_blob =  UncommonTrapBlob::create(&buffer, oop_maps,\n-                                                 SimpleRuntimeFrame::framesize >> 1);\n-}\n-#endif \/\/ COMPILER2\n-\n@@ -3672,133 +3478,0 @@\n-#ifdef COMPILER2\n-\/\/ This is here instead of runtime_x86_64.cpp because it uses SimpleRuntimeFrame\n-\/\/\n-\/\/------------------------------generate_exception_blob---------------------------\n-\/\/ creates exception blob at the end\n-\/\/ Using exception blob, this code is jumped from a compiled method.\n-\/\/ (see emit_exception_handler in x86_64.ad file)\n-\/\/\n-\/\/ Given an exception pc at a call we call into the runtime for the\n-\/\/ handler in this method. This handler might merely restore state\n-\/\/ (i.e. callee save registers) unwind the frame and jump to the\n-\/\/ exception handler for the nmethod if there is no Java level handler\n-\/\/ for the nmethod.\n-\/\/\n-\/\/ This code is entered with a jmp.\n-\/\/\n-\/\/ Arguments:\n-\/\/   rax: exception oop\n-\/\/   rdx: exception pc\n-\/\/\n-\/\/ Results:\n-\/\/   rax: exception oop\n-\/\/   rdx: exception pc in caller or ???\n-\/\/   destination: exception handler of caller\n-\/\/\n-\/\/ Note: the exception pc MUST be at a call (precise debug information)\n-\/\/       Registers rax, rdx, rcx, rsi, rdi, r8-r11 are not callee saved.\n-\/\/\n-\n-void OptoRuntime::generate_exception_blob() {\n-  assert(!OptoRuntime::is_callee_saved_register(RDX_num), \"\");\n-  assert(!OptoRuntime::is_callee_saved_register(RAX_num), \"\");\n-  assert(!OptoRuntime::is_callee_saved_register(RCX_num), \"\");\n-\n-  assert(SimpleRuntimeFrame::framesize % 4 == 0, \"sp not 16-byte aligned\");\n-\n-  \/\/ Allocate space for the code\n-  ResourceMark rm;\n-  \/\/ Setup code generation tools\n-  CodeBuffer buffer(\"exception_blob\", 2048, 1024);\n-  MacroAssembler* masm = new MacroAssembler(&buffer);\n-\n-\n-  address start = __ pc();\n-\n-  \/\/ Exception pc is 'return address' for stack walker\n-  __ push(rdx);\n-  __ subptr(rsp, SimpleRuntimeFrame::return_off << LogBytesPerInt); \/\/ Prolog\n-\n-  \/\/ Save callee-saved registers.  See x86_64.ad.\n-\n-  \/\/ rbp is an implicitly saved callee saved register (i.e., the calling\n-  \/\/ convention will save\/restore it in the prolog\/epilog). Other than that\n-  \/\/ there are no callee save registers now that adapter frames are gone.\n-\n-  __ movptr(Address(rsp, SimpleRuntimeFrame::rbp_off << LogBytesPerInt), rbp);\n-\n-  \/\/ Store exception in Thread object. We cannot pass any arguments to the\n-  \/\/ handle_exception call, since we do not want to make any assumption\n-  \/\/ about the size of the frame where the exception happened in.\n-  \/\/ c_rarg0 is either rdi (Linux) or rcx (Windows).\n-  __ movptr(Address(r15_thread, JavaThread::exception_oop_offset()),rax);\n-  __ movptr(Address(r15_thread, JavaThread::exception_pc_offset()), rdx);\n-\n-  \/\/ This call does all the hard work.  It checks if an exception handler\n-  \/\/ exists in the method.\n-  \/\/ If so, it returns the handler address.\n-  \/\/ If not, it prepares for stack-unwinding, restoring the callee-save\n-  \/\/ registers of the frame being removed.\n-  \/\/\n-  \/\/ address OptoRuntime::handle_exception_C(JavaThread* thread)\n-\n-  \/\/ At a method handle call, the stack may not be properly aligned\n-  \/\/ when returning with an exception.\n-  address the_pc = __ pc();\n-  __ set_last_Java_frame(noreg, noreg, the_pc, rscratch1);\n-  __ mov(c_rarg0, r15_thread);\n-  __ andptr(rsp, -(StackAlignmentInBytes));    \/\/ Align stack\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, OptoRuntime::handle_exception_C)));\n-\n-  \/\/ Set an oopmap for the call site.  This oopmap will only be used if we\n-  \/\/ are unwinding the stack.  Hence, all locations will be dead.\n-  \/\/ Callee-saved registers will be the same as the frame above (i.e.,\n-  \/\/ handle_exception_stub), since they were restored when we got the\n-  \/\/ exception.\n-\n-  OopMapSet* oop_maps = new OopMapSet();\n-\n-  oop_maps->add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));\n-\n-  __ reset_last_Java_frame(false);\n-\n-  \/\/ Restore callee-saved registers\n-\n-  \/\/ rbp is an implicitly saved callee-saved register (i.e., the calling\n-  \/\/ convention will save restore it in prolog\/epilog) Other than that\n-  \/\/ there are no callee save registers now that adapter frames are gone.\n-\n-  __ movptr(rbp, Address(rsp, SimpleRuntimeFrame::rbp_off << LogBytesPerInt));\n-\n-  __ addptr(rsp, SimpleRuntimeFrame::return_off << LogBytesPerInt); \/\/ Epilog\n-  __ pop(rdx);                  \/\/ No need for exception pc anymore\n-\n-  \/\/ rax: exception handler\n-\n-  \/\/ We have a handler in rax (could be deopt blob).\n-  __ mov(r8, rax);\n-\n-  \/\/ Get the exception oop\n-  __ movptr(rax, Address(r15_thread, JavaThread::exception_oop_offset()));\n-  \/\/ Get the exception pc in case we are deoptimized\n-  __ movptr(rdx, Address(r15_thread, JavaThread::exception_pc_offset()));\n-#ifdef ASSERT\n-  __ movptr(Address(r15_thread, JavaThread::exception_handler_pc_offset()), NULL_WORD);\n-  __ movptr(Address(r15_thread, JavaThread::exception_pc_offset()), NULL_WORD);\n-#endif\n-  \/\/ Clear the exception oop so GC no longer processes it as a root.\n-  __ movptr(Address(r15_thread, JavaThread::exception_oop_offset()), NULL_WORD);\n-\n-  \/\/ rax: exception oop\n-  \/\/ r8:  exception handler\n-  \/\/ rdx: exception pc\n-  \/\/ Jump to handler\n-\n-  __ jmp(r8);\n-\n-  \/\/ Make sure all code is generated\n-  masm->flush();\n-\n-  \/\/ Set exception blob\n-  _exception_blob =  ExceptionBlob::create(&buffer, oop_maps, SimpleRuntimeFrame::framesize >> 1);\n-}\n-#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":0,"deletions":327,"binary":false,"changes":327,"status":"modified"},{"patch":"@@ -2154,1 +2154,1 @@\n-  address call_addr = SharedRuntime::uncommon_trap_blob()->entry_point();\n+  address call_addr = OptoRuntime::uncommon_trap_blob()->entry_point();\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-          nn->as_MachCall()->entry_point() == SharedRuntime::uncommon_trap_blob()->entry_point()) {\n+          nn->as_MachCall()->entry_point() == OptoRuntime::uncommon_trap_blob()->entry_point()) {\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5952,1 +5952,1 @@\n-          (obs->as_CallStaticJava()->entry_point() == SharedRuntime::uncommon_trap_blob()->entry_point())) {\n+          (obs->as_CallStaticJava()->entry_point() == OptoRuntime::uncommon_trap_blob()->entry_point())) {\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -570,1 +570,1 @@\n-    address call_addr = SharedRuntime::uncommon_trap_blob()->entry_point();\n+    address call_addr = OptoRuntime::uncommon_trap_blob()->entry_point();\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2963,1 +2963,1 @@\n-        call->entry_point() == SharedRuntime::uncommon_trap_blob()->entry_point()) {\n+        call->entry_point() == OptoRuntime::uncommon_trap_blob()->entry_point()) {\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -117,1 +117,2 @@\n-ExceptionBlob* OptoRuntime::_exception_blob;\n+UncommonTrapBlob*   OptoRuntime::_uncommon_trap_blob;\n+ExceptionBlob*      OptoRuntime::_exception_blob;\n@@ -141,0 +142,1 @@\n+  generate_uncommon_trap_blob();\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -171,0 +171,1 @@\n+  static UncommonTrapBlob*   _uncommon_trap_blob;\n@@ -172,0 +173,2 @@\n+\n+  static void generate_uncommon_trap_blob(void);\n@@ -211,0 +214,1 @@\n+  static UncommonTrapBlob* uncommon_trap_blob()                  { return _uncommon_trap_blob; }\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -206,1 +206,1 @@\n-      address call_addr = SharedRuntime::uncommon_trap_blob()->entry_point();\n+      address call_addr = OptoRuntime::uncommon_trap_blob()->entry_point();\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -103,4 +103,0 @@\n-#ifdef COMPILER2\n-UncommonTrapBlob*   SharedRuntime::_uncommon_trap_blob;\n-#endif \/\/ COMPILER2\n-\n@@ -132,4 +128,0 @@\n-\n-#ifdef COMPILER2\n-  generate_uncommon_trap_blob();\n-#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -65,4 +65,0 @@\n-#ifdef COMPILER2\n-  static UncommonTrapBlob*   _uncommon_trap_blob;\n-#endif \/\/ COMPILER2\n-\n@@ -226,5 +222,0 @@\n-#ifdef COMPILER2\n-  static void generate_uncommon_trap_blob(void);\n-  static UncommonTrapBlob* uncommon_trap_blob()                  { return _uncommon_trap_blob; }\n-#endif \/\/ COMPILER2\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"}]}