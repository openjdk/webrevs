{"files":[{"patch":"@@ -2063,1 +2063,1 @@\n-            if (endPosTable != null && result != tree) {\n+            if (endPosTable != null && result != null && result != tree) {\n@@ -3700,1 +3700,1 @@\n-            body.endpos = TreeInfo.endPos(tree.body);\n+            body.bracePos = TreeInfo.endPos(tree.body);\n@@ -4161,1 +4161,1 @@\n-                res.endpos = TreeInfo.endPos(tree);\n+                res.bracePos = TreeInfo.endPos(tree);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -503,1 +503,1 @@\n-            block.endpos = TreeInfo.endPos(clinitStats.last());\n+            block.bracePos = TreeInfo.endPos(clinitStats.last());\n@@ -556,2 +556,2 @@\n-            if (md.body.endpos == Position.NOPOS)\n-                md.body.endpos = TreeInfo.endPos(md.body.stats.last());\n+            if (md.body.bracePos == Position.NOPOS)\n+                md.body.bracePos = TreeInfo.endPos(md.body.stats.last());\n@@ -1124,1 +1124,1 @@\n-            code.statBegin(tree.endpos);\n+            code.statBegin(tree.bracePos);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -234,2 +234,2 @@\n-                ? new SimpleEndPosTable(this)\n-                : new EmptyEndPosTable(this);\n+                ? new SimpleEndPosTable()\n+                : new MinimalEndPosTable();\n@@ -636,0 +636,1 @@\n+     *  @return {@code tree}\n@@ -637,1 +638,1 @@\n-    protected void attach(JCTree tree, Comment dc) {\n+    protected <T extends JCTree> T attach(T tree, Comment dc) {\n@@ -642,0 +643,1 @@\n+        return tree;\n@@ -705,2 +707,9 @@\n-    protected void storeEnd(JCTree tree, int endpos) {\n-        endPosTable.storeEnd(tree, endpos);\n+    \/**\n+     * Store ending position for a tree, the value of which is the greater of\n+     * last error position in {@link #endPosTable} and the given ending position.\n+     * @param tree tree node\n+     * @param endpos the ending position to associate with {@code tree}\n+     * @return {@code tree}\n+     *\/\n+    protected <T extends JCTree> T storeEnd(T tree, int endpos) {\n+        return endPosTable.storeEnd(tree, endpos);\n@@ -709,2 +718,8 @@\n-    protected <T extends JCTree> T to(T t) {\n-        return endPosTable.to(t);\n+    \/**\n+     * Store current token's ending position for a tree, the value of which\n+     * will be the greater of last error position in {@link #endPosTable}\n+     * and the ending position of the current token.\n+     * @param tree tree node\n+     *\/\n+    protected <T extends JCTree> T to(T tree) {\n+        return storeEnd(tree, token.endPos);\n@@ -713,2 +728,8 @@\n-    protected <T extends JCTree> T toP(T t) {\n-        return endPosTable.toP(t);\n+    \/**\n+     * Store current token's ending position for a tree, the value of which\n+     * will be the greater of last error position in {@link #endPosTable}\n+     * and the ending position of the previous token.\n+     * @param tree tree node\n+     *\/\n+    protected <T extends JCTree> T toP(T tree) {\n+        return storeEnd(tree, S.prevToken().endPos);\n@@ -1744,1 +1765,1 @@\n-                    e.endpos = token.pos;\n+                    e.bracePos = token.pos;\n@@ -2822,1 +2843,1 @@\n-        \/\/ the Block node has a field \"endpos\" for first char of last token, which is\n+        \/\/ the Block node has a field \"bracePos\" for first char of last token, which is\n@@ -2824,1 +2845,1 @@\n-        t.endpos = token.pos;\n+        t.bracePos = token.pos;\n@@ -3145,1 +3166,1 @@\n-            t.endpos = token.endPos;\n+            t.bracePos = token.endPos;\n@@ -3661,3 +3682,1 @@\n-\n-        storeEnd(ann, S.prevToken().endPos);\n-        return ann;\n+        return toP(ann);\n@@ -3838,1 +3857,0 @@\n-        attach(result, dc);\n@@ -3840,1 +3858,1 @@\n-        return result;\n+        return attach(result, dc);\n@@ -4134,1 +4152,1 @@\n-        List<JCTree> topLevelDefs = isImplicitClass ?  constructImplicitClass(defs.toList()) : defs.toList();\n+        List<JCTree> topLevelDefs = isImplicitClass ? constructImplicitClass(defs.toList(), S.prevToken().endPos) : defs.toList();\n@@ -4144,1 +4162,0 @@\n-        this.endPosTable.setParser(null); \/\/ remove reference to parser\n@@ -4150,1 +4167,1 @@\n-    private List<JCTree> constructImplicitClass(List<JCTree> origDefs) {\n+    private List<JCTree> constructImplicitClass(List<JCTree> origDefs, int endPos) {\n@@ -4180,0 +4197,1 @@\n+        storeEnd(implicit, endPos);\n@@ -4195,0 +4213,1 @@\n+        int endPos = S.prevToken().endPos;\n@@ -4197,3 +4216,3 @@\n-        JCModuleDecl result = toP(F.at(pos).ModuleDef(mods, kind, name, directives));\n-        attach(result, dc);\n-        return result;\n+        JCModuleDecl result = F.at(pos).ModuleDef(mods, kind, name, directives);\n+        storeEnd(result, endPos);\n+        return attach(result, dc);\n@@ -4389,2 +4408,1 @@\n-        attach(result, dc);\n-        return result;\n+        return attach(result, dc);\n@@ -4437,2 +4455,1 @@\n-        attach(result, dc);\n-        return result;\n+        return attach(result, dc);\n@@ -4477,2 +4494,1 @@\n-        attach(result, dc);\n-        return result;\n+        return attach(result, dc);\n@@ -4525,2 +4541,1 @@\n-        attach(result, dc);\n-        return result;\n+        return attach(result, dc);\n@@ -4667,2 +4682,1 @@\n-        attach(result, dc);\n-        return result;\n+        return attach(result, dc);\n@@ -5100,2 +5114,1 @@\n-            attach(result, dc);\n-            return result;\n+            return attach(result, dc);\n@@ -5398,2 +5411,1 @@\n-            storeEnd(type, origEndPos);\n-            return type;\n+            return storeEnd(type, origEndPos);\n@@ -5625,2 +5637,2 @@\n-    \/*\n-     * a functional source tree and end position mappings\n+    \/**\n+     * A straightforward {@link EndPosTable} implementation.\n@@ -5630,1 +5642,1 @@\n-        private final IntHashTable endPosMap;\n+        private final IntHashTable endPosMap = new IntHashTable();\n@@ -5632,17 +5644,4 @@\n-        SimpleEndPosTable(JavacParser parser) {\n-            super(parser);\n-            endPosMap = new IntHashTable();\n-        }\n-\n-        public void storeEnd(JCTree tree, int endpos) {\n-            endPosMap.put(tree, errorEndPos > endpos ? errorEndPos : endpos);\n-        }\n-\n-        protected <T extends JCTree> T to(T t) {\n-            storeEnd(t, parser.token.endPos);\n-            return t;\n-        }\n-\n-        protected <T extends JCTree> T toP(T t) {\n-            storeEnd(t, parser.S.prevToken().endPos);\n-            return t;\n+        @Override\n+        public <T extends JCTree> T storeEnd(T tree, int endpos) {\n+            endPosMap.put(tree, Math.max(endpos, errorEndPos));\n+            return tree;\n@@ -5651,0 +5650,1 @@\n+        @Override\n@@ -5657,0 +5657,1 @@\n+        @Override\n@@ -5667,2 +5668,2 @@\n-    \/*\n-     * a default skeletal implementation without any mapping overhead.\n+    \/**\n+     * A minimal implementation that only stores what's required.\n@@ -5670,19 +5671,1 @@\n-    protected static class EmptyEndPosTable extends AbstractEndPosTable {\n-\n-        EmptyEndPosTable(JavacParser parser) {\n-            super(parser);\n-        }\n-\n-        public void storeEnd(JCTree tree, int endpos) { \/* empty *\/ }\n-\n-        protected <T extends JCTree> T to(T t) {\n-            return t;\n-        }\n-\n-        protected <T extends JCTree> T toP(T t) {\n-            return t;\n-        }\n-\n-        public int getEndPos(JCTree tree) {\n-            return Position.NOPOS;\n-        }\n+    protected static class MinimalEndPosTable extends SimpleEndPosTable {\n@@ -5690,2 +5673,13 @@\n-        public int replaceTree(JCTree oldTree, JCTree newTree) {\n-            return Position.NOPOS;\n+        @Override\n+        public <T extends JCTree> T storeEnd(T tree, int endpos) {\n+            switch (tree.getTag()) {\n+            case MODULEDEF:\n+            case PACKAGEDEF:\n+            case CLASSDEF:\n+            case METHODDEF:\n+            case VARDEF:\n+                break;\n+            default:\n+                return tree;\n+            }\n+            return super.storeEnd(tree, endpos);\n@@ -5693,1 +5687,0 @@\n-\n@@ -5697,4 +5690,0 @@\n-        \/**\n-         * The current parser.\n-         *\/\n-        protected JavacParser parser;\n@@ -5707,25 +5696,1 @@\n-        public AbstractEndPosTable(JavacParser parser) {\n-            this.parser = parser;\n-        }\n-\n-        \/**\n-         * Store current token's ending position for a tree, the value of which\n-         * will be the greater of last error position and the ending position of\n-         * the current token.\n-         * @param t The tree.\n-         *\/\n-        protected abstract <T extends JCTree> T to(T t);\n-\n-        \/**\n-         * Store current token's ending position for a tree, the value of which\n-         * will be the greater of last error position and the ending position of\n-         * the previous token.\n-         * @param t The tree.\n-         *\/\n-        protected abstract <T extends JCTree> T toP(T t);\n-\n-        \/**\n-         * Set the error position during the parsing phases, the value of which\n-         * will be set only if it is greater than the last stored error position.\n-         * @param errPos The error position\n-         *\/\n+        @Override\n@@ -5737,4 +5702,0 @@\n-\n-        public void setParser(JavacParser parser) {\n-            this.parser = parser;\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":76,"deletions":115,"binary":false,"changes":191,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import com.sun.tools.javac.util.Position;\n+\n@@ -30,0 +32,11 @@\n+ *\n+ * <p>\n+ * Implementations <b>must<\/b> store end positions for at least these node types:\n+ * <ul>\n+ *  <li>{@link JCTree.JCModuleDecl}\n+ *  <li>{@link JCTree.JCPackageDecl}\n+ *  <li>{@link JCTree.JCClassDecl}\n+ *  <li>{@link JCTree.JCMethodDecl}\n+ *  <li>{@link JCTree.JCVariableDecl}\n+ * <\/ul>\n+ *\n@@ -43,1 +56,1 @@\n-    public int getEndPos(JCTree tree);\n+    int getEndPos(JCTree tree);\n@@ -50,0 +63,8 @@\n+     * @return the {@code tree}\n+     *\/\n+    <T extends JCTree> T storeEnd(T tree, int endpos);\n+\n+    \/**\n+     * Set the error position during the parsing phases, the value of which\n+     * will be set only if it is greater than the last stored error position.\n+     * @param errPos The error position\n@@ -51,1 +72,1 @@\n-    public abstract void storeEnd(JCTree tree, int endpos);\n+    void setErrorEndPos(int errPos);\n@@ -61,1 +82,1 @@\n-    public int replaceTree(JCTree oldtree, JCTree newtree);\n+    int replaceTree(JCTree oldtree, JCTree newtree);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/EndPosTable.java","additions":25,"deletions":4,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1124,1 +1124,1 @@\n-        public int endpos = Position.NOPOS;\n+        public int bracePos = Position.NOPOS;\n@@ -1333,1 +1333,1 @@\n-        public int endpos = Position.NOPOS;\n+        public int bracePos = Position.NOPOS;\n@@ -1433,1 +1433,1 @@\n-        public int endpos = Position.NOPOS;\n+        public int bracePos = Position.NOPOS;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -503,2 +503,2 @@\n-    \/** The end position of given tree, if it is a block with\n-     *  defined endpos.\n+    \/** The closing brace position of given tree, if it is a block with\n+     *  defined bracePos.\n@@ -507,2 +507,2 @@\n-        if (tree.hasTag(BLOCK) && ((JCBlock) tree).endpos != Position.NOPOS)\n-            return ((JCBlock) tree).endpos;\n+        if (tree.hasTag(BLOCK) && ((JCBlock) tree).bracePos != Position.NOPOS)\n+            return ((JCBlock) tree).bracePos;\n@@ -516,2 +516,2 @@\n-                   ((JCSwitch) tree).endpos != Position.NOPOS) {\n-            return ((JCSwitch) tree).endpos;\n+                   ((JCSwitch) tree).bracePos != Position.NOPOS) {\n+            return ((JCSwitch) tree).bracePos;\n@@ -519,2 +519,2 @@\n-                   ((JCSwitchExpression) tree).endpos != Position.NOPOS) {\n-            return ((JCSwitchExpression) tree).endpos;\n+                   ((JCSwitchExpression) tree).bracePos != Position.NOPOS) {\n+            return ((JCSwitchExpression) tree).bracePos;\n@@ -649,5 +649,0 @@\n-        if (endPosTable == null) {\n-            \/\/ fall back on limited info in the tree\n-            return endPos(tree);\n-        }\n-\n@@ -734,2 +729,2 @@\n-     *  end position of given tree, if it is a block with\n-     *  defined endpos.\n+     *  closing brace position of given tree, if it is a block with\n+     *  defined closing brace position.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":11,"deletions":16,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -144,1 +144,0 @@\n-        this.endPosTable.setParser(null); \/\/ remove reference to parser\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/ReplParser.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -154,1 +154,1 @@\n-                lineNumber = env.toplevel.lineMap.getLineNumber(tryTree.finalizer.endpos);\n+                lineNumber = env.toplevel.lineMap.getLineNumber(tryTree.finalizer.bracePos);\n","filename":"test\/langtools\/tools\/javac\/T8180660\/MissingLNTEntryForFinalizerTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8350212\n+ * @summary Verify ending source positions are calculated for declarations supporting SuppressWarnings\n+ * @modules jdk.compiler\/com.sun.tools.javac.tree\n+ * @run main DeclarationEndPositions\n+ *\/\n+\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.util.JavacTask;\n+import com.sun.source.util.TreeScanner;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.*;\n+import com.sun.tools.javac.tree.TreeInfo;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.List;\n+\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.tools.ToolProvider;\n+\n+public class DeclarationEndPositions {\n+\n+    public static void checkEndPosition(Class<? extends JCTree> nodeType, String input, String marker) throws IOException {\n+\n+        \/\/ Create source\n+        var source = new SimpleJavaFileObject(URI.create(\"file:\/\/T.java\"), JavaFileObject.Kind.SOURCE) {\n+            @Override\n+            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n+                return input;\n+            }\n+        };\n+\n+        \/\/ Parse source\n+        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+        JavaCompiler.CompilationTask task = compiler.getTask(null, null, null, List.of(), List.of(), List.of(source));\n+        Iterable<? extends CompilationUnitTree> units = ((JavacTask)task).parse();\n+\n+        \/\/ Find node and check end position\n+        JCTree.JCCompilationUnit unit = (JCTree.JCCompilationUnit)units.iterator().next();\n+        unit.accept(new TreeScanner<Void, Void>() {\n+            @Override\n+            public Void scan(Tree node, Void aVoid) {\n+                if (nodeType.isInstance(node)) {\n+                    JCTree tree = (JCTree)node;\n+                    int actual = TreeInfo.getEndPos(tree, unit.endPositions);\n+                    int expected = marker.indexOf('^') + 1;\n+                    if (actual != expected) {\n+                        throw new AssertionError(String.format(\n+                          \"wrong end pos %d != %d for \\\"%s\\\" @ %d\", actual, expected, input, tree.pos));\n+                    }\n+                }\n+                return super.scan(node, aVoid);\n+            }\n+        }, null);\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+\n+        \/\/ JCModuleDecl\n+        checkEndPosition(JCModuleDecl.class,\n+           \"\/* comment *\/ module fred { \/* comment *\/ } \/* comment *\/\",\n+           \"                                          ^              \");\n+\n+        \/\/ JCPackageDecl\n+        checkEndPosition(JCPackageDecl.class,\n+           \"\/* comment *\/ package fred; \/* comment *\/\",\n+           \"                          ^              \");\n+\n+        \/\/ JCClassDecl\n+        checkEndPosition(JCClassDecl.class,\n+           \"\/* comment *\/ class Fred { \/* comment *\/ } \/* comment *\/\",\n+           \"                                         ^              \");\n+\n+        \/\/ JCMethodDecl\n+        checkEndPosition(JCMethodDecl.class,\n+           \"\/* comment *\/ class Fred { void m() { \/* comment *\/ } } \/* comment *\/\",\n+           \"                                                    ^                \");\n+\n+        \/\/ JCVariableDecl\n+        checkEndPosition(JCVariableDecl.class,\n+           \"\/* comment *\/ class Fred { int x; } \/* comment *\/\",\n+           \"                                ^                \");\n+        checkEndPosition(JCVariableDecl.class,\n+           \"\/* comment *\/ class Fred { int x = 123; } \/* comment *\/\",\n+           \"                                      ^                \");\n+        checkEndPosition(JCVariableDecl.class,\n+           \"\/* comment *\/ class A { try {} catch (Error err) {} } \/* comment *\/\",\n+           \"                                              ^                    \");\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/parser\/DeclarationEndPositions.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -2301,4 +2301,3 @@\n-        String code = \"\"\"\n-                      void main() {\n-                      }\n-                      \"\"\";\n+        \/\/             0         1         2\n+        \/\/             012345678901234567890\n+        String code = \"void main() { }\";\n@@ -2316,1 +2315,1 @@\n-                assertEquals(\"Wrong end position\", -1, sp.getEndPosition(cut, node));\n+                assertEquals(\"Wrong end position\", 15, sp.getEndPosition(cut, node));\n","filename":"test\/langtools\/tools\/javac\/parser\/JavacParserTest.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -142,1 +142,0 @@\n-        this.endPosTable.setParser(null); \/\/ remove reference to parser\n","filename":"test\/langtools\/tools\/javac\/parser\/extend\/TrialParser.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}