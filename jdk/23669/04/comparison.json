{"files":[{"patch":"@@ -382,0 +382,4 @@\n+        \/** Table of ending positions.\n+         *\/\n+        EndPosTable endPositions;\n+\n@@ -617,1 +621,1 @@\n-                    log.error(TreeInfo.diagEndPos(tree.body), Errors.MissingRetStmt);\n+                    log.error(TreeInfo.diagEndPos(endPositions, tree.body), Errors.MissingRetStmt);\n@@ -759,1 +763,1 @@\n-                        log.error(TreeInfo.diagEndPos(c.body),\n+                        log.error(TreeInfo.diagEndPos(endPositions, c.body),\n@@ -762,1 +766,1 @@\n-                        log.error(TreeInfo.diagEndPos(tree),\n+                        log.error(TreeInfo.diagEndPos(endPositions, tree),\n@@ -1235,1 +1239,1 @@\n-                    lint.logIfEnabled(TreeInfo.diagEndPos(tree.finalizer),\n+                    lint.logIfEnabled(TreeInfo.diagEndPos(endPositions, tree.finalizer),\n@@ -1341,0 +1345,1 @@\n+                endPositions = env.toplevel.endPositions;\n@@ -1344,0 +1349,1 @@\n+                endPositions = null;\n@@ -1925,0 +1931,1 @@\n+                endPositions = env.toplevel.endPositions;\n@@ -1930,0 +1937,1 @@\n+                endPositions = null;\n@@ -2539,1 +2547,1 @@\n-                                            checkInit(TreeInfo.diagEndPos(tree.body), var);\n+                                            checkInit(TreeInfo.diagEndPos(endPositions, tree.body), var);\n@@ -2545,1 +2553,1 @@\n-                                    checkInit(TreeInfo.diagEndPos(tree.body), var);\n+                                    checkInit(TreeInfo.diagEndPos(endPositions, tree.body), var);\n@@ -3226,1 +3234,1 @@\n-        public void analyzeTree(Env<?> env, TreeMaker make) {\n+        public void analyzeTree(Env<AttrContext> env, TreeMaker make) {\n@@ -3230,1 +3238,1 @@\n-        public void analyzeTree(Env<?> env, JCTree tree, TreeMaker make) {\n+        public void analyzeTree(Env<AttrContext> env, JCTree tree, TreeMaker make) {\n@@ -3243,0 +3251,1 @@\n+                endPositions = env.toplevel.endPositions;\n@@ -3258,0 +3267,1 @@\n+                endPositions = null;\n@@ -3470,0 +3480,1 @@\n+                endPositions = env.toplevel.endPositions;\n@@ -3472,0 +3483,1 @@\n+                endPositions = null;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1608,1 +1608,1 @@\n-        make.at(TreeInfo.endPos(block));\n+        make.at(TreeInfo.endPos(endPosTable, block));\n@@ -2051,1 +2051,1 @@\n-            if (endPosTable != null && result != tree) {\n+            if (endPosTable != null && result != null && result != tree) {\n@@ -3681,1 +3681,1 @@\n-            body.endpos = TreeInfo.endPos(tree.body);\n+            body.bracePos = TreeInfo.endPos(endPosTable, tree.body);\n@@ -3839,1 +3839,1 @@\n-                JCBreak b = make.at(TreeInfo.endPos(c.stats.last())).Break(null);\n+                JCBreak b = make.at(TreeInfo.endPos(endPosTable, c.stats.last())).Break(null);\n@@ -4142,1 +4142,1 @@\n-                res.endpos = TreeInfo.endPos(tree);\n+                res.bracePos = TreeInfo.endPos(endPosTable, tree);\n@@ -4386,0 +4386,1 @@\n+            this.endPosTable = env.toplevel.endPositions;\n@@ -4392,0 +4393,1 @@\n+            this.endPosTable = null;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,0 +85,1 @@\n+import com.sun.tools.javac.tree.EndPosTable;\n@@ -138,0 +139,1 @@\n+    private EndPosTable endPositions;\n@@ -754,1 +756,1 @@\n-            JCBreak brk = make.at(TreeInfo.endPos(pos)).Break(null);\n+            JCBreak brk = make.at(TreeInfo.endPos(endPositions, pos)).Break(null);\n@@ -1394,0 +1396,1 @@\n+            this.endPositions = env.toplevel.endPositions;\n@@ -1399,0 +1402,1 @@\n+            this.endPositions = null;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -503,1 +503,1 @@\n-            block.endpos = TreeInfo.endPos(clinitStats.last());\n+            block.bracePos = TreeInfo.endPos(endPosTable, clinitStats.last());\n@@ -556,2 +556,2 @@\n-            if (md.body.endpos == Position.NOPOS)\n-                md.body.endpos = TreeInfo.endPos(md.body.stats.last());\n+            if (md.body.bracePos == Position.NOPOS)\n+                md.body.bracePos = TreeInfo.endPos(endPosTable, md.body.stats.last());\n@@ -964,1 +964,1 @@\n-                    code.statBegin(TreeInfo.endPos(tree.body));\n+                    code.statBegin(TreeInfo.endPos(endPosTable, tree.body));\n@@ -1018,1 +1018,1 @@\n-                                        genCrt ? new CRTable(tree, env.toplevel.endPositions)\n+                                        genCrt ? new CRTable(tree, endPosTable)\n@@ -1124,1 +1124,1 @@\n-            code.statBegin(tree.endpos);\n+            code.statBegin(tree.bracePos);\n@@ -1453,1 +1453,1 @@\n-                 code.statBegin(TreeInfo.endPos(swtch));\n+                 code.statBegin(TreeInfo.endPos(endPosTable, swtch));\n@@ -1562,1 +1562,1 @@\n-            code.statBegin(TreeInfo.endPos(body));\n+            code.statBegin(TreeInfo.endPos(endPosTable, body));\n@@ -1564,1 +1564,1 @@\n-            code.statBegin(TreeInfo.endPos(env.tree));\n+            code.statBegin(TreeInfo.endPos(endPosTable, env.tree));\n@@ -1583,1 +1583,1 @@\n-                    code.statBegin(TreeInfo.endPos(env.tree));\n+                    code.statBegin(TreeInfo.endPos(endPosTable, env.tree));\n@@ -1611,1 +1611,1 @@\n-                code.statBegin(TreeInfo.finalizerPos(env.tree, PosKind.FIRST_STAT_POS));\n+                code.statBegin(TreeInfo.finalizerPos(endPosTable, env.tree, PosKind.FIRST_STAT_POS));\n@@ -1618,1 +1618,1 @@\n-                code.statBegin(TreeInfo.finalizerPos(env.tree, PosKind.END_POS));\n+                code.statBegin(TreeInfo.finalizerPos(endPosTable, env.tree, PosKind.END_POS));\n@@ -1634,1 +1634,1 @@\n-                    code.statBegin(TreeInfo.finalizerPos(env.tree, PosKind.FIRST_STAT_POS));\n+                    code.statBegin(TreeInfo.finalizerPos(endPosTable, env.tree, PosKind.FIRST_STAT_POS));\n@@ -1721,1 +1721,1 @@\n-            code.statBegin(TreeInfo.endPos(tree.body));\n+            code.statBegin(TreeInfo.endPos(endPosTable, tree.body));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -231,2 +231,2 @@\n-                ? new SimpleEndPosTable(this)\n-                : new EmptyEndPosTable(this);\n+                ? new SimpleEndPosTable()\n+                : new MinimalEndPosTable();\n@@ -633,0 +633,1 @@\n+     *  @return {@code tree}\n@@ -634,1 +635,1 @@\n-    protected void attach(JCTree tree, Comment dc) {\n+    protected <T extends JCTree> T attach(T tree, Comment dc) {\n@@ -639,0 +640,1 @@\n+        return tree;\n@@ -702,2 +704,9 @@\n-    protected void storeEnd(JCTree tree, int endpos) {\n-        endPosTable.storeEnd(tree, endpos);\n+    \/**\n+     * Store ending position for a tree, the value of which is the greater of\n+     * last error position in {@link #endPosTable} and the given ending position.\n+     * @param tree tree node\n+     * @param endpos the ending position to associate with {@code tree}\n+     * @return {@code tree}\n+     *\/\n+    protected <T extends JCTree> T storeEnd(T tree, int endpos) {\n+        return endPosTable.storeEnd(tree, endpos);\n@@ -706,2 +715,8 @@\n-    protected <T extends JCTree> T to(T t) {\n-        return endPosTable.to(t);\n+    \/**\n+     * Store current token's ending position for a tree, the value of which\n+     * will be the greater of last error position in {@link #endPosTable}\n+     * and the ending position of the current token.\n+     * @param tree tree node\n+     *\/\n+    protected <T extends JCTree> T to(T tree) {\n+        return storeEnd(tree, token.endPos);\n@@ -710,2 +725,8 @@\n-    protected <T extends JCTree> T toP(T t) {\n-        return endPosTable.toP(t);\n+    \/**\n+     * Store current token's ending position for a tree, the value of which\n+     * will be the greater of last error position in {@link #endPosTable}\n+     * and the ending position of the previous token.\n+     * @param tree tree node\n+     *\/\n+    protected <T extends JCTree> T toP(T tree) {\n+        return storeEnd(tree, S.prevToken().endPos);\n@@ -1741,1 +1762,1 @@\n-                    e.endpos = token.pos;\n+                    e.bracePos = token.pos;\n@@ -2819,1 +2840,1 @@\n-        \/\/ the Block node has a field \"endpos\" for first char of last token, which is\n+        \/\/ the Block node has a field \"bracePos\" for first char of last token, which is\n@@ -2821,1 +2842,1 @@\n-        t.endpos = token.pos;\n+        t.bracePos = token.pos;\n@@ -3142,1 +3163,0 @@\n-            t.endpos = token.endPos;\n@@ -3658,3 +3678,1 @@\n-\n-        storeEnd(ann, S.prevToken().endPos);\n-        return ann;\n+        return toP(ann);\n@@ -3835,1 +3853,0 @@\n-        attach(result, dc);\n@@ -3837,1 +3854,1 @@\n-        return result;\n+        return attach(result, dc);\n@@ -4130,1 +4147,1 @@\n-        List<JCTree> topLevelDefs = isImplicitClass ?  constructImplicitClass(defs.toList()) : defs.toList();\n+        List<JCTree> topLevelDefs = isImplicitClass ? constructImplicitClass(defs.toList(), S.prevToken().endPos) : defs.toList();\n@@ -4140,1 +4157,0 @@\n-        this.endPosTable.setParser(null); \/\/ remove reference to parser\n@@ -4146,1 +4162,1 @@\n-    private List<JCTree> constructImplicitClass(List<JCTree> origDefs) {\n+    private List<JCTree> constructImplicitClass(List<JCTree> origDefs, int endPos) {\n@@ -4176,0 +4192,1 @@\n+        storeEnd(implicit, endPos);\n@@ -4191,0 +4208,1 @@\n+        int endPos = S.prevToken().endPos;\n@@ -4193,3 +4211,3 @@\n-        JCModuleDecl result = toP(F.at(pos).ModuleDef(mods, kind, name, directives));\n-        attach(result, dc);\n-        return result;\n+        JCModuleDecl result = F.at(pos).ModuleDef(mods, kind, name, directives);\n+        storeEnd(result, endPos);\n+        return attach(result, dc);\n@@ -4396,2 +4414,1 @@\n-        attach(result, dc);\n-        return result;\n+        return attach(result, dc);\n@@ -4444,2 +4461,1 @@\n-        attach(result, dc);\n-        return result;\n+        return attach(result, dc);\n@@ -4484,2 +4500,1 @@\n-        attach(result, dc);\n-        return result;\n+        return attach(result, dc);\n@@ -4532,2 +4547,1 @@\n-        attach(result, dc);\n-        return result;\n+        return attach(result, dc);\n@@ -4674,2 +4688,1 @@\n-        attach(result, dc);\n-        return result;\n+        return attach(result, dc);\n@@ -5103,2 +5116,1 @@\n-            attach(result, dc);\n-            return result;\n+            return attach(result, dc);\n@@ -5401,2 +5413,1 @@\n-            storeEnd(type, origEndPos);\n-            return type;\n+            return storeEnd(type, origEndPos);\n@@ -5615,2 +5626,2 @@\n-    \/*\n-     * a functional source tree and end position mappings\n+    \/**\n+     * A straightforward {@link EndPosTable} implementation.\n@@ -5620,1 +5631,1 @@\n-        private final IntHashTable endPosMap;\n+        private final IntHashTable endPosMap = new IntHashTable();\n@@ -5622,17 +5633,4 @@\n-        SimpleEndPosTable(JavacParser parser) {\n-            super(parser);\n-            endPosMap = new IntHashTable();\n-        }\n-\n-        public void storeEnd(JCTree tree, int endpos) {\n-            endPosMap.put(tree, errorEndPos > endpos ? errorEndPos : endpos);\n-        }\n-\n-        protected <T extends JCTree> T to(T t) {\n-            storeEnd(t, parser.token.endPos);\n-            return t;\n-        }\n-\n-        protected <T extends JCTree> T toP(T t) {\n-            storeEnd(t, parser.S.prevToken().endPos);\n-            return t;\n+        @Override\n+        public <T extends JCTree> T storeEnd(T tree, int endpos) {\n+            endPosMap.put(tree, Math.max(endpos, errorEndPos));\n+            return tree;\n@@ -5641,0 +5639,1 @@\n+        @Override\n@@ -5647,0 +5646,1 @@\n+        @Override\n@@ -5657,2 +5657,2 @@\n-    \/*\n-     * a default skeletal implementation without any mapping overhead.\n+    \/**\n+     * A minimal implementation that only stores what's required.\n@@ -5660,19 +5660,1 @@\n-    protected static class EmptyEndPosTable extends AbstractEndPosTable {\n-\n-        EmptyEndPosTable(JavacParser parser) {\n-            super(parser);\n-        }\n-\n-        public void storeEnd(JCTree tree, int endpos) { \/* empty *\/ }\n-\n-        protected <T extends JCTree> T to(T t) {\n-            return t;\n-        }\n-\n-        protected <T extends JCTree> T toP(T t) {\n-            return t;\n-        }\n-\n-        public int getEndPos(JCTree tree) {\n-            return Position.NOPOS;\n-        }\n+    protected static class MinimalEndPosTable extends SimpleEndPosTable {\n@@ -5680,2 +5662,16 @@\n-        public int replaceTree(JCTree oldTree, JCTree newTree) {\n-            return Position.NOPOS;\n+        @Override\n+        public <T extends JCTree> T storeEnd(T tree, int endpos) {\n+            switch (tree.getTag()) {\n+            case MODULEDEF:\n+            case PACKAGEDEF:\n+            case CLASSDEF:\n+            case METHODDEF:\n+            case VARDEF:\n+            case BLOCK:\n+            case SWITCH:\n+            case SWITCH_EXPRESSION:\n+                break;\n+            default:\n+                return tree;\n+            }\n+            return super.storeEnd(tree, endpos);\n@@ -5683,1 +5679,0 @@\n-\n@@ -5687,4 +5682,0 @@\n-        \/**\n-         * The current parser.\n-         *\/\n-        protected JavacParser parser;\n@@ -5697,25 +5688,1 @@\n-        public AbstractEndPosTable(JavacParser parser) {\n-            this.parser = parser;\n-        }\n-\n-        \/**\n-         * Store current token's ending position for a tree, the value of which\n-         * will be the greater of last error position and the ending position of\n-         * the current token.\n-         * @param t The tree.\n-         *\/\n-        protected abstract <T extends JCTree> T to(T t);\n-\n-        \/**\n-         * Store current token's ending position for a tree, the value of which\n-         * will be the greater of last error position and the ending position of\n-         * the previous token.\n-         * @param t The tree.\n-         *\/\n-        protected abstract <T extends JCTree> T toP(T t);\n-\n-        \/**\n-         * Set the error position during the parsing phases, the value of which\n-         * will be set only if it is greater than the last stored error position.\n-         * @param errPos The error position\n-         *\/\n+        @Override\n@@ -5727,4 +5694,0 @@\n-\n-        public void setParser(JavacParser parser) {\n-            this.parser = parser;\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":78,"deletions":115,"binary":false,"changes":193,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import com.sun.tools.javac.util.Position;\n+\n@@ -30,0 +32,14 @@\n+ *\n+ * <p>\n+ * Implementations <b>must<\/b> store end positions for at least these node types:\n+ * <ul>\n+ *  <li>{@link JCTree.JCModuleDecl}\n+ *  <li>{@link JCTree.JCPackageDecl}\n+ *  <li>{@link JCTree.JCClassDecl}\n+ *  <li>{@link JCTree.JCMethodDecl}\n+ *  <li>{@link JCTree.JCVariableDecl}\n+ *  <li>{@link JCTree.JCBlock}\n+ *  <li>{@link JCTree.JCSwitch}\n+ *  <li>{@link JCTree.JCSwitchExpression}\n+ * <\/ul>\n+ *\n@@ -43,1 +59,1 @@\n-    public int getEndPos(JCTree tree);\n+    int getEndPos(JCTree tree);\n@@ -50,0 +66,8 @@\n+     * @return the {@code tree}\n+     *\/\n+    <T extends JCTree> T storeEnd(T tree, int endpos);\n+\n+    \/**\n+     * Set the error position during the parsing phases, the value of which\n+     * will be set only if it is greater than the last stored error position.\n+     * @param errPos The error position\n@@ -51,1 +75,1 @@\n-    public abstract void storeEnd(JCTree tree, int endpos);\n+    void setErrorEndPos(int errPos);\n@@ -61,1 +85,1 @@\n-    public int replaceTree(JCTree oldtree, JCTree newtree);\n+    int replaceTree(JCTree oldtree, JCTree newtree);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/EndPosTable.java","additions":28,"deletions":4,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1124,1 +1124,1 @@\n-        public int endpos = Position.NOPOS;\n+        public int bracePos = Position.NOPOS;\n@@ -1332,2 +1332,0 @@\n-        \/** Position of closing brace, optional. *\/\n-        public int endpos = Position.NOPOS;\n@@ -1433,1 +1431,1 @@\n-        public int endpos = Position.NOPOS;\n+        public int bracePos = Position.NOPOS;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-import java.util.function.ToIntFunction;\n+import java.util.function.ToIntBiFunction;\n@@ -503,2 +503,1 @@\n-    \/** The end position of given tree, if it is a block with\n-     *  defined endpos.\n+    \/** The end position of the given tree, if defined.\n@@ -506,6 +505,9 @@\n-    public static int endPos(JCTree tree) {\n-        if (tree.hasTag(BLOCK) && ((JCBlock) tree).endpos != Position.NOPOS)\n-            return ((JCBlock) tree).endpos;\n-        else if (tree.hasTag(SYNCHRONIZED))\n-            return endPos(((JCSynchronized) tree).body);\n-        else if (tree.hasTag(TRY)) {\n+    public static int endPos(EndPosTable endPosTable, JCTree tree) {\n+        switch (tree.getTag()) {\n+        case BLOCK:\n+            return ((JCBlock)tree).bracePos;\n+        case SWITCH_EXPRESSION:\n+            return ((JCSwitchExpression)tree).bracePos;\n+        case SYNCHRONIZED:\n+            return endPos(endPosTable, ((JCSynchronized)tree).body);\n+        case TRY:\n@@ -513,1 +515,1 @@\n-            return endPos((t.finalizer != null) ? t.finalizer\n+            return endPos(endPosTable, (t.finalizer != null) ? t.finalizer\n@@ -515,8 +517,7 @@\n-        } else if (tree.hasTag(SWITCH) &&\n-                   ((JCSwitch) tree).endpos != Position.NOPOS) {\n-            return ((JCSwitch) tree).endpos;\n-        } else if (tree.hasTag(SWITCH_EXPRESSION) &&\n-                   ((JCSwitchExpression) tree).endpos != Position.NOPOS) {\n-            return ((JCSwitchExpression) tree).endpos;\n-        } else\n-            return tree.pos;\n+        default:\n+            break;\n+        }\n+        int endPos = endPosTable.getEndPos(tree);\n+        if (endPos != Position.NOPOS)\n+            return endPos;\n+        return tree.pos;\n@@ -649,5 +650,0 @@\n-        if (endPosTable == null) {\n-            \/\/ fall back on limited info in the tree\n-            return endPos(tree);\n-        }\n-\n@@ -737,2 +733,2 @@\n-    public static DiagnosticPosition diagEndPos(final JCTree tree) {\n-        final int endPos = TreeInfo.endPos(tree);\n+    public static DiagnosticPosition diagEndPos(EndPosTable endPosTable, final JCTree tree) {\n+        final int endPos = TreeInfo.endPos(endPosTable, tree);\n@@ -750,2 +746,2 @@\n-        START_POS(TreeInfo::getStartPos),\n-        FIRST_STAT_POS(TreeInfo::firstStatPos),\n+        START_POS((table, tree) -> TreeInfo.getStartPos(tree)),\n+        FIRST_STAT_POS((table, tree) -> TreeInfo.firstStatPos(tree)),\n@@ -754,1 +750,1 @@\n-        final ToIntFunction<JCTree> posFunc;\n+        final ToIntBiFunction<EndPosTable, JCTree> posFunc;\n@@ -756,1 +752,1 @@\n-        PosKind(ToIntFunction<JCTree> posFunc) {\n+        PosKind(ToIntBiFunction<EndPosTable, JCTree> posFunc) {\n@@ -760,2 +756,2 @@\n-        int toPos(JCTree tree) {\n-            return posFunc.applyAsInt(tree);\n+        int toPos(EndPosTable endPosTable, JCTree tree) {\n+            return posFunc.applyAsInt(endPosTable, tree);\n@@ -767,1 +763,1 @@\n-    public static int finalizerPos(JCTree tree, PosKind posKind) {\n+    public static int finalizerPos(EndPosTable endPosTable, JCTree tree, PosKind posKind) {\n@@ -771,1 +767,1 @@\n-            return posKind.toPos(t.finalizer);\n+            return posKind.toPos(endPosTable, t.finalizer);\n@@ -773,1 +769,1 @@\n-            return endPos(((JCSynchronized) tree).body);\n+            return endPos(endPosTable, ((JCSynchronized)tree).body);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":31,"deletions":35,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -144,1 +144,0 @@\n-        this.endPosTable.setParser(null); \/\/ remove reference to parser\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/ReplParser.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -154,1 +154,1 @@\n-                lineNumber = env.toplevel.lineMap.getLineNumber(tryTree.finalizer.endpos);\n+                lineNumber = env.toplevel.lineMap.getLineNumber(tryTree.finalizer.bracePos);\n","filename":"test\/langtools\/tools\/javac\/T8180660\/MissingLNTEntryForFinalizerTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8350212\n+ * @summary Verify ending source positions are calculated for declarations supporting SuppressWarnings\n+ * @modules jdk.compiler\/com.sun.tools.javac.tree\n+ * @run main DeclarationEndPositions\n+ *\/\n+\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.util.JavacTask;\n+import com.sun.source.util.TreeScanner;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.*;\n+import com.sun.tools.javac.tree.TreeInfo;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.List;\n+\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.tools.ToolProvider;\n+\n+public class DeclarationEndPositions {\n+\n+    public static void checkEndPosition(Class<? extends JCTree> nodeType, String input, String marker) throws IOException {\n+\n+        \/\/ Create source\n+        var source = new SimpleJavaFileObject(URI.create(\"file:\/\/T.java\"), JavaFileObject.Kind.SOURCE) {\n+            @Override\n+            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n+                return input;\n+            }\n+        };\n+\n+        \/\/ Parse source\n+        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+        JavaCompiler.CompilationTask task = compiler.getTask(null, null, null, List.of(), List.of(), List.of(source));\n+        Iterable<? extends CompilationUnitTree> units = ((JavacTask)task).parse();\n+\n+        \/\/ Find node and check end position\n+        JCTree.JCCompilationUnit unit = (JCTree.JCCompilationUnit)units.iterator().next();\n+        unit.accept(new TreeScanner<Void, Void>() {\n+            @Override\n+            public Void scan(Tree node, Void aVoid) {\n+                if (nodeType.isInstance(node)) {\n+                    JCTree tree = (JCTree)node;\n+                    int actual = TreeInfo.endPos(unit.endPositions, tree);\n+                    int expected = marker.indexOf('^') + 1;\n+                    if (actual != expected) {\n+                        throw new AssertionError(String.format(\n+                          \"wrong end pos %d != %d for \\\"%s\\\" @ %d\", actual, expected, input, tree.pos));\n+                    }\n+                }\n+                return super.scan(node, aVoid);\n+            }\n+        }, null);\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+\n+        \/\/ JCModuleDecl\n+        checkEndPosition(JCModuleDecl.class,\n+           \"\/* comment *\/ module fred { \/* comment *\/ } \/* comment *\/\",\n+           \"                                          ^              \");\n+\n+        \/\/ JCPackageDecl\n+        checkEndPosition(JCPackageDecl.class,\n+           \"\/* comment *\/ package fred; \/* comment *\/\",\n+           \"                          ^              \");\n+\n+        \/\/ JCClassDecl\n+        checkEndPosition(JCClassDecl.class,\n+           \"\/* comment *\/ class Fred { \/* comment *\/ } \/* comment *\/\",\n+           \"                                         ^              \");\n+\n+        \/\/ JCMethodDecl\n+        checkEndPosition(JCMethodDecl.class,\n+           \"\/* comment *\/ class Fred { void m() { \/* comment *\/ } } \/* comment *\/\",\n+           \"                                                    ^                \");\n+\n+        \/\/ JCVariableDecl\n+        checkEndPosition(JCVariableDecl.class,\n+           \"\/* comment *\/ class Fred { int x; } \/* comment *\/\",\n+           \"                                ^                \");\n+        checkEndPosition(JCVariableDecl.class,\n+           \"\/* comment *\/ class Fred { int x = 123; } \/* comment *\/\",\n+           \"                                      ^                \");\n+        checkEndPosition(JCVariableDecl.class,\n+           \"\/* comment *\/ class A { try {} catch (Error err) {} } \/* comment *\/\",\n+           \"                                              ^                    \");\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/parser\/DeclarationEndPositions.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -2301,4 +2301,3 @@\n-        String code = \"\"\"\n-                      void main() {\n-                      }\n-                      \"\"\";\n+        \/\/             0         1         2\n+        \/\/             012345678901234567890\n+        String code = \"void main() { }\";\n@@ -2316,1 +2315,1 @@\n-                assertEquals(\"Wrong end position\", -1, sp.getEndPosition(cut, node));\n+                assertEquals(\"Wrong end position\", 15, sp.getEndPosition(cut, node));\n","filename":"test\/langtools\/tools\/javac\/parser\/JavacParserTest.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -142,1 +142,0 @@\n-        this.endPosTable.setParser(null); \/\/ remove reference to parser\n","filename":"test\/langtools\/tools\/javac\/parser\/extend\/TrialParser.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}