{"files":[{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -34,0 +35,28 @@\n+  precond(!FLAG_IS_ERGO(NewRatio));\n+  precond(!FLAG_IS_ERGO(NewSize));\n+  precond(!FLAG_IS_ERGO(MaxNewSize));\n+\n+  \/\/ Figure out compatible young gen sizing policies.\n+  \/\/ This will either use all default, NewRatio or a combination of NewSize and\n+  \/\/ MaxNewSize. If both ratio and size is user specified NewRatio will be ignored.\n+\n+  const bool user_specified_NewRatio = !FLAG_IS_DEFAULT(NewRatio);\n+  const bool user_specified_NewSize = !FLAG_IS_DEFAULT(NewSize);\n+  const bool user_specified_MaxNewSize = !FLAG_IS_DEFAULT(MaxNewSize);\n+\n+  \/\/ MaxNewSize is updated every time the heap is resized (and when initialized),\n+  \/\/ as such the value of MaxNewSize is only modified if it is also used by the\n+  \/\/ young generation sizing. (If MaxNewSize is user specified).\n+\n+  if (!user_specified_NewRatio && !user_specified_NewSize && !user_specified_MaxNewSize) {\n+    \/\/ Using Defaults.\n+    return;\n+  }\n+\n+  if (user_specified_NewRatio && !user_specified_NewSize && !user_specified_MaxNewSize) {\n+    \/\/ Using NewRatio.\n+    _sizer_kind = SizerNewRatio;\n+    _use_adaptive_sizing = false;\n+    return;\n+  }\n+\n@@ -35,6 +64,12 @@\n-    if (FLAG_IS_CMDLINE(NewSize) || FLAG_IS_CMDLINE(MaxNewSize)) {\n-      log_warning(gc, ergo)(\"-XX:NewSize and -XX:MaxNewSize override -XX:NewRatio\");\n-    } else {\n-      _sizer_kind = SizerNewRatio;\n-      _use_adaptive_sizing = false;\n-      return;\n+    \/\/ NewRatio ignored at this point, issue warning if NewRatio was specified\n+    \/\/ on the command line.\n+    log_warning(gc, ergo)(\"-XX:NewSize and -XX:MaxNewSize overrides -XX:NewRatio\");\n+  }\n+\n+  assert(!FLAG_IS_DEFAULT(InitialHeapSize), \"Initial heap size must be selected\");\n+  if (user_specified_NewSize && NewSize > InitialHeapSize) {\n+    \/\/ If user specifed NewSize is larger than the InitialHeapSize truncate the value.\n+    if (FLAG_IS_CMDLINE(NewSize)) {\n+      log_warning(gc, ergo)(\"NewSize (%zuk) is greater than the initial heap size (%zuk). \"\n+                            \"A new NewSize of %zuk will be used.\",\n+                            NewSize\/K, InitialHeapSize\/K, InitialHeapSize\/K);\n@@ -42,0 +77,12 @@\n+    FLAG_SET_ERGO(NewSize, InitialHeapSize);\n+  }\n+\n+  assert(!FLAG_IS_DEFAULT(MaxHeapSize), \"Max heap size must be selected\");\n+  if (user_specified_MaxNewSize && MaxNewSize > MaxHeapSize) {\n+    \/\/ If user specifed MaxNewSize is larger than the MaxHeapSize truncate the value.\n+    if (FLAG_IS_CMDLINE(MaxNewSize)) {\n+      log_warning(gc, ergo)(\"MaxNewSize (%zuk) greater than the entire heap (%zuk). \"\n+                            \"A new MaxNewSize of %zuk will be used.\",\n+                            MaxNewSize\/K, MaxHeapSize\/K, MaxHeapSize\/K);\n+    }\n+    FLAG_SET_ERGO(MaxNewSize, MaxHeapSize);\n@@ -45,0 +92,2 @@\n+    \/\/ Either NewSize, MaxNewSize or both have been specified and are incompatible.\n+    \/\/ In either case set MaxNewSize to the value of NewSize.\n@@ -46,2 +95,2 @@\n-      log_warning(gc, ergo)(\"NewSize (%zuk) is greater than the MaxNewSize (%zuk). \"\n-                            \"A new max generation size of %zuk will be used.\",\n+      log_warning(gc, ergo)(\"NewSize (%zuk) is greater than MaxNewSize (%zuk). \"\n+                            \"A new MaxNewSize of %zuk will be used.\",\n@@ -53,16 +102,15 @@\n-  if (FLAG_IS_CMDLINE(NewSize)) {\n-    _min_desired_young_length = MAX2((uint) (NewSize \/ G1HeapRegion::GrainBytes),\n-                                     1U);\n-    if (FLAG_IS_CMDLINE(MaxNewSize)) {\n-      _max_desired_young_length =\n-                             MAX2((uint) (MaxNewSize \/ G1HeapRegion::GrainBytes),\n-                                  1U);\n-      _sizer_kind = SizerMaxAndNewSize;\n-      _use_adaptive_sizing = _min_desired_young_length != _max_desired_young_length;\n-    } else {\n-      _sizer_kind = SizerNewSizeOnly;\n-    }\n-  } else if (FLAG_IS_CMDLINE(MaxNewSize)) {\n-    _max_desired_young_length =\n-                             MAX2((uint) (MaxNewSize \/ G1HeapRegion::GrainBytes),\n-                                  1U);\n+  if (user_specified_NewSize) {\n+    _min_desired_young_length = MAX2((uint)(NewSize \/ G1HeapRegion::GrainBytes), 1U);\n+  }\n+\n+  if (user_specified_MaxNewSize) {\n+    _max_desired_young_length = MAX2((uint)(MaxNewSize \/ G1HeapRegion::GrainBytes), 1U);\n+  }\n+\n+  if (user_specified_NewSize && user_specified_MaxNewSize) {\n+    _sizer_kind = SizerMaxAndNewSize;\n+    _use_adaptive_sizing = _min_desired_young_length != _max_desired_young_length;\n+  } else if (user_specified_NewSize) {\n+    _sizer_kind = SizerNewSizeOnly;\n+  } else {\n+    postcond(user_specified_MaxNewSize);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGenSizer.cpp","additions":72,"deletions":24,"binary":false,"changes":96,"status":"modified"}]}