{"files":[{"patch":"@@ -93,0 +93,13 @@\n+ * <h3>Range requests<\/h3>\n+ *\n+ * <p>The file server and {@linkplain #createFileHandler(Path) file handler} also support HTTP\n+ * <i>range requests<\/i>, allowing clients to\n+ * request partial file content using the {@code Range} request header, as specified in\n+ * <a href=\"https:\/\/www.rfc-editor.org\/rfc\/rfc9110.html#name-range-requests\">RFC 9110<\/a>.<\/p>\n+ *\n+ * <p>Conditional range requests with the {@code If-Range}\n+ * request header using a date are also supported.\n+ * If the provided date matches the file's {@code Last-Modified} timestamp, the server returns\n+ * the requested ranges; otherwise, it returns the entire file.\n+ * Entity-tag (ETag) based {@code If-Range} requests are not currently supported.<\/p>\n+ *\n@@ -114,0 +127,2 @@\n+ * @spec https:\/\/www.rfc-editor.org\/info\/rfc9110\n+ *       RFC 9110: HTTP Semantics\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/SimpleFileServer.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+    public static final int HTTP_RANGE_NOT_SATISFIABLE = 416;\n@@ -100,0 +101,1 @@\n+        case HTTP_RANGE_NOT_SATISFIABLE: return \" Range Not Satisfiable\";\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/Code.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.io.RandomAccessFile;\n@@ -38,0 +39,1 @@\n+import java.util.ArrayList;\n@@ -40,0 +42,1 @@\n+import java.util.UUID;\n@@ -45,0 +48,1 @@\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n@@ -268,1 +272,0 @@\n-\n@@ -275,7 +278,2 @@\n-        if (writeBody) {\n-            exchange.sendResponseHeaders(200, Files.size(path));\n-            try (InputStream fis = Files.newInputStream(path);\n-                 OutputStream os = exchange.getResponseBody()) {\n-                fis.transferTo(os);\n-            }\n-        } else {\n+        respHdrs.set(\"Accept-Ranges\", \"bytes\");\n+        if (!writeBody) {\n@@ -284,0 +282,5 @@\n+            return;\n+        }\n+        String rangeHeader = exchange.getRequestHeaders().getFirst(\"Range\");\n+        if (rangeHeader != null && handleRangedRequest(exchange, path, rangeHeader)) {\n+            return;\n@@ -285,0 +288,132 @@\n+        exchange.sendResponseHeaders(200, Files.size(path));\n+        try (InputStream fis = Files.newInputStream(path);\n+             OutputStream os = exchange.getResponseBody()) {\n+            fis.transferTo(os);\n+        }\n+    }\n+\n+    private boolean handleRangedRequest(HttpExchange exchange, Path path, String rangeHeader)\n+            throws IOException\n+    {\n+        var reqHdrs = exchange.getRequestHeaders();\n+        String ifRange = reqHdrs.getFirst(\"If-Range\");\n+        if (!(ifRange == null || ifRange.equals(getLastModified(path)))) {\n+            return false; \/\/ last-modified does not match with the resource, send the entire file\n+        }\n+        long fileSize = Files.size(path);\n+        List<RangeEntry> ranges = parseRangeHeader(rangeHeader, fileSize);\n+        if (ranges == null) {\n+            var respHdrs = exchange.getResponseHeaders();\n+            respHdrs.set(\"Content-Range\", \"bytes *\/%s\".formatted(fileSize));\n+            exchange.sendResponseHeaders(416, -1);\n+            return true;\n+        }\n+        servePartialContents(exchange, path, ranges);\n+        return true;\n+    }\n+\n+    \/\/ Parses the HTTP Range header and returns a list of byte ranges.\n+    \/\/ Returns null if the header is invalid.\n+    \/\/ Example of valid Range header values:make image\n+    \/\/  \"bytes=0-499\"           -> first 500 bytes\n+    \/\/  \"bytes=500-999\"         -> second 500 bytes\n+    \/\/  \"bytes=-500\"            -> last 500 bytes\n+    \/\/  \"bytes=9500-\"           -> from byte 9500 to end\n+    \/\/ Multiple ranges are allowed, separated by commas(without spaces):\n+    \/\/  \"bytes=0-499,1000-1499\" -> first 500 bytes and second 500 bytes\n+    public static List<RangeEntry> parseRangeHeader(String rangeHeader, long fileSize) {\n+        if (!rangeHeader.startsWith(\"bytes=\")) {\n+            return null;  \/\/ only 'bytes' unit is supported.\n+        }\n+        String rangesPart = rangeHeader.substring(\"bytes=\".length());\n+        List<RangeEntry> ranges = new ArrayList<>();\n+        for (String spec : rangesPart.split(\",\", -1)) {\n+            spec = spec.trim();\n+            int dashPos = spec.indexOf('-');\n+            if (dashPos == -1) {\n+                return null;  \/\/ '-' is always required.\n+            }\n+            String startStr = spec.substring(0, dashPos).trim();\n+            String endStr = spec.substring(dashPos + 1).trim();\n+            if (startStr.startsWith(\"+\") || endStr.startsWith(\"+\")) {\n+                return null;  \/\/ \"+\" prefix is not supported.\n+            }\n+            long start, end;\n+            try {\n+                if (startStr.isEmpty()) {  \/\/ \"-<suffix-length>\"\n+                    long suffixLength = Long.parseLong(endStr, 10);\n+                    if (suffixLength <= 0) {\n+                        return null;\n+                    }\n+                    start = Math.max(0, fileSize - suffixLength);\n+                    end = fileSize - 1;\n+                } else {  \/\/ \"<start>-<end>\" or \"<start>-\"\n+                    start = Long.parseLong(startStr, 10);\n+                    end = endStr.isEmpty() ? fileSize - 1 : Long.parseLong(endStr, 10);\n+                    if (end >= fileSize) {\n+                        end = fileSize - 1;\n+                    }\n+                }\n+            } catch (NumberFormatException e) {\n+                return null;  \/\/ invalid number format\n+            }\n+\n+            if (start < 0 || start > end)\n+                return null;  \/\/ invalid range values\n+\n+            ranges.add(new RangeEntry(start, end));\n+        }\n+        return ranges;\n+    }\n+\n+    private void servePartialContents(HttpExchange exchange, Path path, List<RangeEntry> ranges)\n+            throws IOException\n+    {\n+        var respHdrs = exchange.getResponseHeaders();\n+        String fileContentType = mediaType(path.toString());\n+        String boundary = UUID.randomUUID().toString();\n+        long fileSize = Files.size(path);\n+        boolean isSingleRange = ranges.size() == 1;\n+        long responseLength;\n+        if (isSingleRange) {\n+            RangeEntry range = ranges.get(0);\n+            respHdrs.set(\"Content-Range\",\n+                    \"bytes %s-%s\/%s\".formatted(range.start, range.end, fileSize));\n+            responseLength = range.end - range.start + 1;\n+        } else {\n+            respHdrs.set(\"Content-Type\", \"multipart\/byteranges; boundary=\" + boundary);\n+            responseLength = 0;  \/\/ 0 for chunked transfer encoding\n+        }\n+        exchange.sendResponseHeaders(206, responseLength); \/\/ Partial Content\n+        try (RandomAccessFile raf = new RandomAccessFile(path.toFile(), \"r\");\n+             OutputStream os = exchange.getResponseBody()) {\n+            for (RangeEntry range : ranges) {\n+                if (!isSingleRange) {\n+                    os.write((\"--\" + boundary + \"\\r\\n\").getBytes(US_ASCII));\n+                    os.write((\"Content-Type: \" + fileContentType + \"\\r\\n\").getBytes(US_ASCII));\n+                    os.write(\"Content-Range: bytes %s-%s\/%s\\r\\n\\r\\n\"\n+                            .formatted(range.start, range.end, fileSize).getBytes(US_ASCII));\n+                }\n+                raf.seek(range.start);\n+                long bytesToWrite = range.end - range.start + 1;\n+                byte[] buffer = new byte[8192];\n+                while (bytesToWrite > 0) {\n+                    int len = raf.read(buffer, 0, (int) Math.min(buffer.length, bytesToWrite));\n+                    if (len == -1) {\n+                        break;  \/\/ EOF\n+                    }\n+                    os.write(buffer, 0, len);\n+                    bytesToWrite -= len;\n+                }\n+                if (!isSingleRange) {\n+                    os.write(\"\\r\\n\".getBytes(US_ASCII));\n+                }\n+            }\n+            if (!isSingleRange) {\n+                String closingBoundary = \"--\" + boundary + \"--\\r\\n\";\n+                os.write(closingBoundary.getBytes(US_ASCII));\n+            }\n+        }\n+    }\n+\n+    public record RangeEntry(long start, long end) {\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/simpleserver\/FileServerHandler.java","additions":143,"deletions":8,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+import sun.net.httpserver.simpleserver.FileServerHandler;\n+\n@@ -85,0 +87,76 @@\n+    @DataProvider\n+    public Object[][] validRangeHeaders() {\n+        return new Object[][]{\n+                \/\/ start-end\n+                {1000L, \"bytes=0-499\", new FileServerHandler.RangeEntry(0, 499)},\n+                {1000L, \"bytes=500-999\", new FileServerHandler.RangeEntry(500, 999)},\n+                {500L,  \"bytes=100-199\", new FileServerHandler.RangeEntry(100, 199)},\n+\n+                \/\/ start-\n+                {1000L, \"bytes=0-\", new FileServerHandler.RangeEntry(0, 999)},\n+                {1000L, \"bytes=500-\", new FileServerHandler.RangeEntry(500, 999)},\n+                {500L,  \"bytes=250-\", new FileServerHandler.RangeEntry(250, 499)},\n+\n+                \/\/ -length\n+                {1000L, \"bytes=-500\", new FileServerHandler.RangeEntry(500, 999)},\n+                {1000L, \"bytes=-1\", new FileServerHandler.RangeEntry(999, 999)},\n+                {500L,  \"bytes=-50\", new FileServerHandler.RangeEntry(450, 499)},\n+\n+                \/\/ single byte ranges\n+                {1000L, \"bytes=0-0\", new FileServerHandler.RangeEntry(0, 0)},\n+                {1000L, \"bytes=999-999\", new FileServerHandler.RangeEntry(999, 999)},\n+                {500L,  \"bytes=499-499\", new FileServerHandler.RangeEntry(499, 499)},\n+\n+                \/\/ multiple ranges\n+                {\n+                        1000L, \"bytes=0-499,500-999\",\n+                        new FileServerHandler.RangeEntry(0, 499),\n+                        new FileServerHandler.RangeEntry(500, 999)\n+                },\n+                {\n+                        1000L, \"bytes=0-,-200\",\n+                        new FileServerHandler.RangeEntry(0, 999),\n+                        new FileServerHandler.RangeEntry(800, 999)\n+                },\n+                {\n+                        500L, \"bytes=0-99,200-\",\n+                        new FileServerHandler.RangeEntry(0, 99),\n+                        new FileServerHandler.RangeEntry(200, 499)\n+                }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"validRangeHeaders\")\n+    public void testValidRangeParse(long fileLength, String rangeHeader, FileServerHandler.RangeEntry... entries) {\n+        var ranges = FileServerHandler.parseRangeHeader(rangeHeader, fileLength);\n+        assertNotNull(ranges);\n+        assertEquals(ranges.size(), entries.length);\n+        for (int i = 0; i < entries.length; i++) {\n+            assertEquals(ranges.get(i).start(), entries[i].start());\n+            assertEquals(ranges.get(i).end(), entries[i].end());\n+        }\n+    }\n+\n+    @DataProvider\n+    public Object[][] invalidRangeHeaders() {\n+        return new Object[][]{\n+                \/\/ invalid ranges: start > end, end beyond file, start beyond file\n+                {\"bytes=500-400\"}, {\"bytes=1000-1001\"}, {\"bytes=1000-\"},\n+\n+                \/\/ malformed numbers or format\n+                {\"bytes=-0\"}, {\"bytes=meow\"}, {\"bytes=--500\"}, {\"bytes=500\"}, {\"bytes=-\"}, {\"bytes=+500-600\"},\n+\n+                \/\/ multiple ranges with one invalid\n+                {\"bytes=500-600,700-600\"},\n+\n+                \/\/ empty or extra commas\/spaces\n+                {\"bytes=\"}, {\"bytes=400-500,\"}, {\"bytes=,400-500\"}, {\"bytes= ,400-500\"}, {\"bytes=400-500, \"}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"invalidRangeHeaders\")\n+    public void testInvalidRangeParse(String rangeHeader) {\n+        var ranges = FileServerHandler.parseRangeHeader(rangeHeader, 1000L);\n+        assertNull(ranges);\n+    }\n+\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/FileServerHandlerTest.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import java.util.regex.Pattern;\n@@ -93,0 +94,3 @@\n+        \/\/ For improving performance, pre-create a file for range header support tests.\n+        var tempRoot = Files.createDirectory(TEST_DIR.resolve(\"rangeTestFilePrep\"));\n+        Files.writeString(tempRoot.resolve(\"aFile.txt\"), \"0123456789\", CREATE);\n@@ -113,0 +117,90 @@\n+            assertEquals(response.headers().firstValue(\"accept-ranges\").get(), \"bytes\");\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"singleRanges\")\n+    public void testSingleRangedRangeFileGET(String rangeSpec, String expectedRangeSpec, String expectedBody) throws Exception {\n+        var root = TEST_DIR.resolve(\"rangeTestFilePrep\");\n+        var file = root.resolve(\"aFile.txt\");\n+        var lastModified = getLastModified(file);\n+        var expectedLength = Integer.toString(expectedBody.getBytes(UTF_8).length);\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"aFile.txt\"))\n+                    .header(\"Range\", \"bytes=\" + rangeSpec)\n+                    .build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 206);\n+            assertEquals(response.body(), expectedBody);\n+            assertEquals(response.headers().firstValue(\"content-type\").get(), \"text\/plain\");\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            assertEquals(response.headers().firstValue(\"last-modified\").get(), lastModified);\n+            assertEquals(response.headers().firstValue(\"accept-ranges\").get(), \"bytes\");\n+            assertEquals(response.headers().firstValue(\"content-range\").get(), \"bytes \" + expectedRangeSpec + \"\/10\");\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @DataProvider(name = \"singleRanges\")\n+    public Object[][] singleRangeProvider() {\n+        return new Object[][]{\n+                \/\/ The file content is \"123456789\" (9 bytes)\n+                \/\/ {rangeSpec, expectedRangeSpec, expectedBody}\n+                {\"0-3\", \"0-3\", \"0123\"},\n+                {\"2-5\", \"2-5\", \"2345\"},\n+                {\"6-9\", \"6-9\", \"6789\"},\n+                {\"0-\",  \"0-9\", \"0123456789\"},\n+                {\"3-\",  \"3-9\", \"3456789\"},\n+                {\"-3\",  \"7-9\", \"789\"},\n+                {\"-1\",  \"9-9\", \"9\"},\n+                {\"-999\", \"0-9\", \"0123456789\"}\n+        };\n+    }\n+\n+    @Test\n+    public void testMultipleRangesFileGET() throws Exception {\n+        var root = TEST_DIR.resolve(\"rangeTestFilePrep\");\n+        var file = root.resolve(\"aFile.txt\");\n+        var lastModified = getLastModified(file);\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"aFile.txt\"))\n+                    .header(\"Range\", \"bytes=2-,3-4,-3\")\n+                    .build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 206);\n+            String contentType = response.headers().firstValue(\"content-type\").orElse(\"\");\n+            assertTrue(contentType.startsWith(\"multipart\/byteranges; boundary=\"));\n+\n+            String boundary = contentType.substring(\"multipart\/byteranges; boundary=\".length());\n+            String[] parts = response.body().split(Pattern.quote(\"--\" + boundary));\n+            assertEquals(parts.length, 5);  \/\/ 3 parts + preamble + epilogue\n+            {\n+                String[] firstPartLines = parts[1].trim().split(\"\\r\\n\");\n+                assertEquals(firstPartLines[0], \"Content-Type: text\/plain\");\n+                assertEquals(firstPartLines[1], \"Content-Range: bytes 2-9\/10\");\n+                assertEquals(firstPartLines[3], \"23456789\");\n+            }\n+            {\n+                String[] secondPartLines = parts[2].trim().split(\"\\r\\n\");\n+                assertEquals(secondPartLines[0], \"Content-Type: text\/plain\");\n+                assertEquals(secondPartLines[1], \"Content-Range: bytes 3-4\/10\");\n+                assertEquals(secondPartLines[3], \"34\");\n+            }\n+            {\n+                String[] thirdPartLines = parts[3].trim().split(\"\\r\\n\");\n+                assertEquals(thirdPartLines[0], \"Content-Type: text\/plain\");\n+                assertEquals(thirdPartLines[1], \"Content-Range: bytes 7-9\/10\");\n+                assertEquals(thirdPartLines[3], \"789\");\n+            }\n+            assertEquals(response.headers().firstValue(\"last-modified\").get(), lastModified);\n+            assertEquals(response.headers().firstValue(\"accept-ranges\").get(), \"bytes\");\n@@ -224,0 +318,1 @@\n+            assertEquals(response.headers().firstValue(\"accept-ranges\").get(), \"bytes\");\n@@ -420,0 +515,40 @@\n+    @DataProvider(name = \"invalidRanges\")\n+    public Object[][] invalidRangeProvider() {\n+        return new Object[][]{\n+                \/\/ The file content is \"123456789\" (9 bytes)\n+                \/\/ {unit, rangeSpec}\n+                {\"meows\", \"1-2\"},\n+                {\"bytes\", \"3-meow\"},\n+                {\"bytes\", \"meow-5\"},\n+                {\"bytes\", \"100-\"},\n+                {\"bytes\", \"100-120\"},\n+                {\"bytes\", \"1-2,3-4,500-600\"}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"invalidRanges\")\n+    public void testInvalidRangeGET(String unit, String rangeSpec) throws Exception {\n+        var root = TEST_DIR.resolve(\"rangeTestFilePrep\");\n+        var file = root.resolve(\"aFile.txt\");\n+        var lastModified = getLastModified(file);\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"aFile.txt\"))\n+                    .header(\"Range\", unit + \"=\" + rangeSpec)\n+                    .build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+\n+            assertEquals(response.statusCode(), 416);\n+            assertEquals(response.headers().firstValue(\"last-modified\").get(), lastModified);\n+            assertEquals(response.headers().firstValue(\"content-range\").get(), \"bytes *\/10\");\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), \"0\");\n+            assertEquals(response.headers().firstValue(\"accept-ranges\").get(), \"bytes\");\n+            assertEquals(response.body(), \"\");\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/SimpleFileServerTest.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+modules = jdk.httpserver\/sun.net.httpserver.simpleserver\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/TEST.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"}]}