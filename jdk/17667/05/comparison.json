{"files":[{"patch":"@@ -1215,1 +1215,2 @@\n-                      *op->stub()->entry());\n+                      *op->stub()->entry(),\n+                      op->zero_array());\n@@ -2507,1 +2508,3 @@\n-  __ bind(*stub->continuation());\n+  if (stub != nullptr) {\n+    __ bind(*stub->continuation());\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -879,1 +879,7 @@\n-  CodeEmitInfo* info = state_for(x, x->state());\n+  CodeEmitInfo* info = nullptr;\n+  if (x->state_before() != nullptr && x->state_before()->force_reexecute()) {\n+    info = state_for(x, x->state_before());\n+    info->set_force_reexecute();\n+  } else {\n+    info = state_for(x, x->state());\n+  }\n@@ -912,0 +918,3 @@\n+  if (x->check_flag(Instruction::OmitChecksFlag)) {\n+    flags = 0;\n+  }\n@@ -1133,1 +1142,7 @@\n-  CodeEmitInfo* info = state_for(x, x->state());\n+  CodeEmitInfo* info = nullptr;\n+  if (x->state_before() != nullptr && x->state_before()->force_reexecute()) {\n+    info = state_for(x, x->state_before());\n+    info->set_force_reexecute();\n+  } else {\n+    info = state_for(x, x->state());\n+  }\n@@ -1150,1 +1165,1 @@\n-  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path);\n+  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path, x->zero_array());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -275,1 +275,1 @@\n-void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int base_offset_in_bytes, int f, Register klass, Label& slow_case) {\n+void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int base_offset_in_bytes, int f, Register klass, Label& slow_case, bool zero_array) {\n@@ -300,1 +300,3 @@\n-  initialize_body(obj, arr_size, base_offset, t1, t2);\n+  if (zero_array) {\n+    initialize_body(obj, arr_size, base_offset, t1, t2);\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -103,1 +103,2 @@\n-  void allocate_array(Register obj, Register len, Register t, Register t2, int base_offset_in_bytes, int f, Register klass, Label& slow_case);\n+  \/\/ zero_array : zero the allocated array or not\n+  void allocate_array(Register obj, Register len, Register t, Register t2, int base_offset_in_bytes, int f, Register klass, Label& slow_case, bool zero_array);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1624,1 +1624,2 @@\n-                      *op->stub()->entry());\n+                      *op->stub()->entry(),\n+                      op->zero_array());\n@@ -3456,1 +3457,3 @@\n-  __ bind(*stub->continuation());\n+  if (stub != nullptr) {\n+    __ bind(*stub->continuation());\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1007,1 +1007,7 @@\n-  CodeEmitInfo* info = state_for(x, x->state());\n+  CodeEmitInfo* info = nullptr;\n+  if (x->state_before() != nullptr && x->state_before()->force_reexecute()) {\n+    info = state_for(x, x->state_before());\n+    info->set_force_reexecute();\n+  } else {\n+    info = state_for(x, x->state());\n+  }\n@@ -1019,0 +1025,7 @@\n+  int flags;\n+  ciArrayKlass* expected_type;\n+  arraycopy_helper(x, &flags, &expected_type);\n+  if (x->check_flag(Instruction::OmitChecksFlag)) {\n+    flags = 0;\n+  }\n+\n@@ -1026,0 +1039,5 @@\n+\n+  if (expected_type != nullptr && flags == 0) {\n+    FrameMap* f = Compilation::current()->frame_map();\n+    f->update_reserved_argument_area_size(3 * BytesPerWord);\n+  }\n@@ -1047,4 +1065,0 @@\n-  int flags;\n-  ciArrayKlass* expected_type;\n-  arraycopy_helper(x, &flags, &expected_type);\n-\n@@ -1313,1 +1327,7 @@\n-  CodeEmitInfo* info = state_for(x, x->state());\n+  CodeEmitInfo* info = nullptr;\n+  if (x->state_before() != nullptr && x->state_before()->force_reexecute()) {\n+    info = state_for(x, x->state_before());\n+    info->set_force_reexecute();\n+  } else {\n+    info = state_for(x, x->state());\n+  }\n@@ -1330,1 +1350,1 @@\n-  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path);\n+  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path, x->zero_array());\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":27,"deletions":7,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -281,1 +281,1 @@\n-void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int base_offset_in_bytes, Address::ScaleFactor f, Register klass, Label& slow_case) {\n+void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int base_offset_in_bytes, Address::ScaleFactor f, Register klass, Label& slow_case, bool zero_array) {\n@@ -303,5 +303,7 @@\n-  const Register len_zero = len;\n-  \/\/ Align-up to word boundary, because we clear the 4 bytes potentially\n-  \/\/ following the length field in initialize_header().\n-  int base_offset = align_up(base_offset_in_bytes, BytesPerWord);\n-  initialize_body(obj, arr_size, base_offset, len_zero);\n+  if (zero_array) {\n+      const Register len_zero = len;\n+      \/\/ Align-up to word boundary, because we clear the 4 bytes potentially\n+      \/\/ following the length field in initialize_header().\n+      int base_offset = align_up(base_offset_in_bytes, BytesPerWord);\n+      initialize_body(obj, arr_size, base_offset, len_zero);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -92,1 +92,2 @@\n-  void allocate_array(Register obj, Register len, Register t, Register t2, int base_offset_in_bytes, Address::ScaleFactor f, Register klass, Label& slow_case);\n+  \/\/ zero_array : zero the allocated array or not\n+  void allocate_array(Register obj, Register len, Register t, Register t2, int base_offset_in_bytes, Address::ScaleFactor f, Register klass, Label& slow_case, bool zero_array);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -238,0 +238,3 @@\n+#if defined(X86) || defined(AARCH64)\n+  case vmIntrinsics::_clone:\n+#endif\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2136,1 +2136,2 @@\n-        code == Bytecodes::_invokedynamic) {\n+        code == Bytecodes::_invokedynamic ||\n+        target->get_Method()->intrinsic_id() == vmIntrinsics::_clone) {\n@@ -2140,1 +2141,12 @@\n-      bool success = try_inline(inline_target, holder_known, false \/* ignore_return *\/, code, better_receiver);\n+      bool success;\n+      \/\/ Clone intrinsic and inlining can only kick when instance is a primitive array,\n+      \/\/ or when the target of the clone is not a Phi node\n+      ciType* receiver_type;\n+      if (target->get_Method()->intrinsic_id() == vmIntrinsics::_clone &&\n+          ((receiver_type = state()->stack_at(state()->stack_size() - inline_target->arg_size())->exact_type()) == nullptr || \/\/ clone target is phi\n+           !receiver_type->is_array_klass() || \/\/ not array\n+           !receiver_type->as_array_klass()->element_type()->is_primitive_type())) { \/\/ not primitive array\n+        success = false;\n+      } else {\n+        success = try_inline(inline_target, holder_known, false \/* ignore_return *\/, code, better_receiver);\n+      }\n@@ -2247,1 +2259,1 @@\n-  apush(append_split(new NewTypeArray(ipop(), (BasicType)stream()->get_index(), state_before)));\n+  apush(append_split(new NewTypeArray(ipop(), (BasicType)stream()->get_index(), state_before, true)));\n@@ -3654,0 +3666,1 @@\n+  case vmIntrinsicID::_clone                 : append_alloc_array_copy(callee); return;\n@@ -4431,0 +4444,26 @@\n+void GraphBuilder::append_alloc_array_copy(ciMethod* callee) {\n+  ValueStack* state_before = copy_state_before();\n+  state_before->set_force_reexecute();\n+  Value src = apop();\n+  BasicType basic_type = src->exact_type()->as_array_klass()->element_type()->basic_type();\n+  Value length = append(new ArrayLength(src, state_before));\n+  Value new_array = append_split(new NewTypeArray(length, basic_type, state_before, false));\n+\n+  ValueType* result_type = as_ValueType(callee->return_type());\n+  vmIntrinsics::ID id = vmIntrinsics::_arraycopy;\n+  Values* args = new Values(5);\n+  args->push(src);\n+  args->push(append(new Constant(new IntConstant(0))));\n+  args->push(new_array);\n+  args->push(append(new Constant(new IntConstant(0))));\n+  args->push(length);\n+  const bool has_receiver = true;\n+  Intrinsic* array_copy = new Intrinsic(result_type, id,\n+                                    args, has_receiver, state_before,\n+                                    vmIntrinsics::preserves_state(id),\n+                                    vmIntrinsics::can_trap(id));\n+  array_copy->set_flag(Instruction::OmitChecksFlag, true);\n+  append_split(array_copy);\n+  apush(new_array);\n+}\n+\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":42,"deletions":3,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -382,0 +382,1 @@\n+  void append_alloc_array_copy(ciMethod* callee);\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -367,0 +367,1 @@\n+    OmitChecksFlag,\n@@ -1330,0 +1331,1 @@\n+  bool _zero_array;\n@@ -1333,1 +1335,1 @@\n-  NewTypeArray(Value length, BasicType elt_type, ValueStack* state_before)\n+  NewTypeArray(Value length, BasicType elt_type, ValueStack* state_before, bool zero_array)\n@@ -1336,0 +1338,1 @@\n+  , _zero_array(zero_array)\n@@ -1340,0 +1343,1 @@\n+  bool zero_array()    const                     { return _zero_array; }\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -356,0 +356,7 @@\n+#if defined(X86) || defined(AARCH64)\n+  if (expected_type != nullptr && flags == 0) {\n+    _stub = nullptr;\n+  } else {\n+    _stub = new ArrayCopyStub(this);\n+  }\n+#else\n@@ -357,0 +364,1 @@\n+#endif\n@@ -1002,1 +1010,4 @@\n-  masm->append_code_stub(stub());\n+  ArrayCopyStub* code_stub = stub();\n+  if (code_stub != nullptr) {\n+    masm->append_code_stub(code_stub);\n+  }\n@@ -1368,1 +1379,1 @@\n-void LIR_List::allocate_array(LIR_Opr dst, LIR_Opr len, LIR_Opr t1,LIR_Opr t2, LIR_Opr t3,LIR_Opr t4, BasicType type, LIR_Opr klass, CodeStub* stub) {\n+void LIR_List::allocate_array(LIR_Opr dst, LIR_Opr len, LIR_Opr t1,LIR_Opr t2, LIR_Opr t3,LIR_Opr t4, BasicType type, LIR_Opr klass, CodeStub* stub, bool zero_array) {\n@@ -1378,1 +1389,2 @@\n-                           stub));\n+                           stub,\n+                           zero_array));\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1753,0 +1753,1 @@\n+  bool      _zero_array;\n@@ -1755,1 +1756,1 @@\n-  LIR_OpAllocArray(LIR_Opr klass, LIR_Opr len, LIR_Opr result, LIR_Opr t1, LIR_Opr t2, LIR_Opr t3, LIR_Opr t4, BasicType type, CodeStub* stub)\n+  LIR_OpAllocArray(LIR_Opr klass, LIR_Opr len, LIR_Opr result, LIR_Opr t1, LIR_Opr t2, LIR_Opr t3, LIR_Opr t4, BasicType type, CodeStub* stub, bool zero_array)\n@@ -1764,1 +1765,2 @@\n-    , _stub(stub) {}\n+    , _stub(stub)\n+    , _zero_array(zero_array) {}\n@@ -1775,0 +1777,1 @@\n+  bool zero_array()   const                      { return _zero_array;  }\n@@ -2305,1 +2308,1 @@\n-  void allocate_array(LIR_Opr dst, LIR_Opr len, LIR_Opr t1,LIR_Opr t2, LIR_Opr t3,LIR_Opr t4, BasicType type, LIR_Opr klass, CodeStub* stub);\n+  void allocate_array(LIR_Opr dst, LIR_Opr len, LIR_Opr t1,LIR_Opr t2, LIR_Opr t3,LIR_Opr t4, BasicType type, LIR_Opr klass, CodeStub* stub, bool zero_array = true);\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+  bool     _force_reexecute;                     \/\/ force the reexecute flag on, used for patching stub\n@@ -228,0 +229,3 @@\n+  bool force_reexecute() const         { return _force_reexecute; }\n+  void set_force_reexecute()           { _force_reexecute = true; }\n+\n","filename":"src\/hotspot\/share\/c1\/c1_ValueStack.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8302850\n+ *\n+ * @run main\/othervm -XX:-UseOnStackReplacement -XX:-BackgroundCompilation -XX:TieredStopAtLevel=1\n+ *                   -XX:CompileOnly=compiler.c1.TestNullArrayClone::test -XX:+UnlockExperimentalVMOptions\n+ *                   -XX:CompileCommand=blackhole,compiler.c1.TestNullArrayClone::blackhole\n+ *                   compiler.c1.TestNullArrayClone\n+ *\/\n+package compiler.c1;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+public class TestNullArrayClone {\n+    public static void main(String[] args)\n+    {\n+        final int size = 10;\n+        final int[] ints = new int[size];\n+        for (int i = 0; i < ints.length; i++)\n+        {\n+            ints[i] = ThreadLocalRandom.current().nextInt();\n+        }\n+\n+        for (int i = 0; i < 1_000; i++)\n+        {\n+            int[] result = test(ints);\n+            blackhole(result);\n+        }\n+\n+        try {\n+            test(null);\n+            System.out.println(\"Expected NullPointerException to be thrown\");\n+            System.exit(97);\n+        } catch (NullPointerException e) {\n+        }\n+    }\n+\n+    static int[] test(int[] ints)\n+    {\n+        return ints.clone();\n+    }\n+\n+    static void blackhole(Object obj) {}\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/TestNullArrayClone.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"}]}