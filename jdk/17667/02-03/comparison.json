{"files":[{"patch":"@@ -2529,3 +2529,3 @@\n- if (stub != nullptr) {\n-   __ bind(*stub->continuation());\n- }\n+  if (stub != nullptr) {\n+    __ bind(*stub->continuation());\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -879,1 +879,7 @@\n-  CodeEmitInfo* info = state_for(x, x->state());\n+  CodeEmitInfo* info = nullptr;\n+  if (x->state_before() != nullptr && x->state_before()->force_reexecute()) {\n+    info = state_for(x, x->state_before());\n+    info->set_force_reexecute();\n+  } else {\n+    info = state_for(x, x->state());\n+  }\n@@ -912,0 +918,3 @@\n+  if (x->check_flag(Instruction::OmitChecksFlag)) {\n+    flags = 0;\n+  }\n@@ -916,66 +925,0 @@\n-void LIRGenerator::do_Clone(Intrinsic* x) {\n-    assert(x->number_of_arguments() == 1, \"wrong type\");\n-\n-    LIRItem src(x->argument_at(0), this);\n-    ciType* src_type = src.value()->exact_type();\n-\n-    LIRItem array(src.value(), this);\n-    array.load_item();\n-    LIR_Opr len = new_register(T_INT);\n-    CodeEmitInfo* null_check_info = state_for(x, x->state_before());\n-    null_check_info->set_force_reexecute();\n-    __ load(new LIR_Address(array.result(), arrayOopDesc::length_offset_in_bytes(), T_INT), len, null_check_info);\n-    LIR_Opr len_r19 = FrameMap::r19_opr;\n-    __ move(len, len_r19);\n-\n-    LIR_Opr array_reg = result_register_for(x->type());\n-    LIR_Opr tmp1 = FrameMap::r10_oop_opr;\n-    LIR_Opr tmp2 = FrameMap::r11_oop_opr;\n-    LIR_Opr tmp3 = FrameMap::r5_oop_opr;\n-    LIR_Opr tmp4 = array_reg;\n-    LIR_Opr klass_reg = FrameMap::r3_metadata_opr;\n-\n-    ciArrayKlass* array_klass = src_type->as_array_klass();\n-    BasicType elem_type = array_klass->element_type()->basic_type();\n-\n-    __ metadata2reg(array_klass->constant_encoding(), klass_reg);\n-\n-    CodeEmitInfo* info = new CodeEmitInfo(null_check_info);\n-    CodeStub* slow_path = new NewTypeArrayStub(klass_reg, len_r19, array_reg, info);\n-    __ allocate_array(array_reg, len_r19, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path, false);\n-\n-    LIRItem src_pos(new Constant(new IntConstant(0)), this);\n-    LIR_Opr dst = new_register(T_OBJECT);\n-    __ move(array_reg, dst);\n-    LIRItem dst_pos(new Constant(new IntConstant(0)), this);\n-\n-    \/\/ operands for arraycopy must use fixed registers, otherwise\n-    \/\/ LinearScan will fail allocation (because arraycopy always needs a\n-    \/\/ call)\n-\n-    \/\/ The java calling convention will give us enough registers\n-    \/\/ so that on the stub side the args will be perfect already.\n-    \/\/ On the other slow\/special case side we call C and the arg\n-    \/\/ positions are not similar enough to pick one as the best.\n-    \/\/ Also because the java calling convention is a \"shifted\" version\n-    \/\/ of the C convention we can process the java args trivially into C\n-    \/\/ args without worry of overwriting during the xfer\n-\n-    src.load_item_force     (FrameMap::as_oop_opr(j_rarg0));\n-    src_pos.load_item_force (FrameMap::as_opr(j_rarg1));\n-    LIR_Opr destination = FrameMap::as_oop_opr(j_rarg2);\n-    __ move(dst, destination);\n-    dst_pos.load_item_force (FrameMap::as_opr(j_rarg3));\n-    LIR_Opr length = FrameMap::as_opr(j_rarg4);\n-    __ move(len, length);\n-    LIR_Opr tmp =           FrameMap::as_opr(j_rarg5);\n-\n-    int flags = 0;\n-    ciArrayKlass* expected_type = src_type->as_array_klass();\n-\n-    __ arraycopy(src.result(), src_pos.result(), destination, dst_pos.result(), length, tmp, expected_type, flags, info); \/\/ does add_safepoint\n-\n-    LIR_Opr result = rlock_result(x);\n-    __ move(dst, result);\n-}\n-\n@@ -1199,1 +1142,7 @@\n-  CodeEmitInfo* info = state_for(x, x->state());\n+  CodeEmitInfo* info = nullptr;\n+  if (x->state_before() != nullptr && x->state_before()->force_reexecute()) {\n+    info = state_for(x, x->state_before());\n+    info->set_force_reexecute();\n+  } else {\n+    info = state_for(x, x->state());\n+  }\n@@ -1216,1 +1165,1 @@\n-  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path);\n+  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path, x->zero_array());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":18,"deletions":69,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -875,4 +875,0 @@\n-void LIRGenerator::do_Clone(Intrinsic* x) {\n-  Unimplemented();\n-}\n-\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRGenerator_arm.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -786,3 +786,0 @@\n-void LIRGenerator::do_Clone(Intrinsic* x) {\n-  Unimplemented();\n-}\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRGenerator_ppc.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -774,4 +774,0 @@\n-void LIRGenerator::do_Clone(Intrinsic* x) {\n-  Unimplemented();\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRGenerator_riscv.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -741,4 +741,0 @@\n-void LIRGenerator::do_Clone(Intrinsic* x) {\n-  Unimplemented();\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRGenerator_s390.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1007,1 +1007,7 @@\n-  CodeEmitInfo* info = state_for(x, x->state());\n+  CodeEmitInfo* info = nullptr;\n+  if (x->state_before() != nullptr && x->state_before()->force_reexecute()) {\n+    info = state_for(x, x->state_before());\n+    info->set_force_reexecute();\n+  } else {\n+    info = state_for(x, x->state());\n+  }\n@@ -1050,0 +1056,3 @@\n+  if (x->check_flag(Instruction::OmitChecksFlag)) {\n+    flags = 0;\n+  }\n@@ -1054,85 +1063,0 @@\n-void LIRGenerator::do_Clone(Intrinsic* x) {\n-  assert(x->number_of_arguments() == 1, \"wrong type\");\n-\n-  LIRItem src(x->argument_at(0), this);\n-  ciType* src_type = src.value()->exact_type();\n-\n-  LIRItem array(src.value(), this);\n-  array.load_item();\n-  LIR_Opr len = new_register(T_INT);\n-  CodeEmitInfo* null_check_info = state_for(x, x->state_before());\n-  null_check_info->set_force_reexecute();\n-  __ load(new LIR_Address(array.result(), arrayOopDesc::length_offset_in_bytes(), T_INT), len, null_check_info);\n-  LIR_Opr len_rbx = FrameMap::rbx_opr;\n-  __ move(len, len_rbx);\n-\n-  LIR_Opr array_reg = result_register_for(x->type());\n-  LIR_Opr tmp1 = FrameMap::rcx_oop_opr;\n-  LIR_Opr tmp2 = FrameMap::rsi_oop_opr;\n-  LIR_Opr tmp3 = FrameMap::rdi_oop_opr;\n-  LIR_Opr tmp4 = array_reg;\n-  LIR_Opr klass_reg = FrameMap::rdx_metadata_opr;\n-\n-  ciArrayKlass* array_klass = src_type->as_array_klass();\n-  BasicType elem_type = array_klass->element_type()->basic_type();\n-\n-  __ metadata2reg(array_klass->constant_encoding(), klass_reg);\n-\n-  CodeEmitInfo* info = new CodeEmitInfo(null_check_info);\n-  CodeStub* slow_path = new NewTypeArrayStub(klass_reg, len_rbx, array_reg, info);\n-  __ allocate_array(array_reg, len_rbx, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path, false);\n-\n-  LIRItem src_pos(new Constant(new IntConstant(0)), this);\n-  LIR_Opr dst = new_register(T_OBJECT);\n-  __ move(array_reg, dst);\n-  LIRItem dst_pos(new Constant(new IntConstant(0)), this);\n-\n-  \/\/ operands for arraycopy must use fixed registers, otherwise\n-  \/\/ LinearScan will fail allocation (because arraycopy always needs a\n-  \/\/ call)\n-\n-#ifndef _LP64\n-\n-  src.load_item_force     (FrameMap::rcx_oop_opr);\n-  src_pos.load_item_force (FrameMap::rdx_opr);\n-  LIR_Opr destination = FrameMap::rax_oop_opr;\n-  __ move(dst, destination);\n-  dst_pos.load_item_force (FrameMap::rbx_opr);\n-  LIR_Opr length = FrameMap::rdi_opr;\n-  __ move(len, length);\n-\n-  LIR_Opr tmp =           (FrameMap::rsi_opr);\n-\n-  FrameMap* f = Compilation::current()->frame_map();\n-  f->update_reserved_argument_area_size(3 * BytesPerWord);\n-#else\n-\n-  \/\/ The java calling convention will give us enough registers\n-  \/\/ so that on the stub side the args will be perfect already.\n-  \/\/ On the other slow\/special case side we call C and the arg\n-  \/\/ positions are not similar enough to pick one as the best.\n-  \/\/ Also because the java calling convention is a \"shifted\" version\n-  \/\/ of the C convention we can process the java args trivially into C\n-  \/\/ args without worry of overwriting during the xfer\n-\n-\n-  src.load_item_force     (FrameMap::as_oop_opr(j_rarg0));\n-  src_pos.load_item_force (FrameMap::as_opr(j_rarg1));\n-  LIR_Opr destination = FrameMap::as_oop_opr(j_rarg2);\n-  __ move(dst, destination);\n-  dst_pos.load_item_force (FrameMap::as_opr(j_rarg3));\n-  LIR_Opr length = FrameMap::as_opr(j_rarg4);\n-  __ move(len, length);\n-\n-  LIR_Opr tmp =           FrameMap::as_opr(j_rarg5);\n-#endif \/\/ LP64\n-\n-  int flags = 0;\n-  ciArrayKlass* expected_type = src_type->as_array_klass();\n-\n-  __ arraycopy(src.result(), src_pos.result(), destination, dst_pos.result(), length, tmp, expected_type, flags, info); \/\/ does add_safepoint\n-\n-  LIR_Opr result = rlock_result(x);\n-  __ move(dst, result);\n-}\n-\n@@ -1396,1 +1320,7 @@\n-  CodeEmitInfo* info = state_for(x, x->state());\n+  CodeEmitInfo* info = nullptr;\n+  if (x->state_before() != nullptr && x->state_before()->force_reexecute()) {\n+    info = state_for(x, x->state_before());\n+    info->set_force_reexecute();\n+  } else {\n+    info = state_for(x, x->state());\n+  }\n@@ -1413,1 +1343,1 @@\n-  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path);\n+  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path, x->zero_array());\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":18,"deletions":88,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -286,0 +286,1 @@\n+  \/\/ clear rest of allocated space\n@@ -287,1 +288,0 @@\n-    \/\/ clear rest of allocated space\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2142,1 +2142,0 @@\n-\n@@ -2148,2 +2147,2 @@\n-          !receiver_type->is_array_klass() || \/\/ not array\n-          !receiver_type->as_array_klass()->element_type()->is_primitive_type())) { \/\/ not primitive array\n+           !receiver_type->is_array_klass() || \/\/ not array\n+           !receiver_type->as_array_klass()->element_type()->is_primitive_type())) { \/\/ not primitive array\n@@ -2260,1 +2259,1 @@\n-  apush(append_split(new NewTypeArray(ipop(), (BasicType)stream()->get_index(), state_before)));\n+  apush(append_split(new NewTypeArray(ipop(), (BasicType)stream()->get_index(), state_before, true)));\n@@ -3667,0 +3666,1 @@\n+  case vmIntrinsicID::_clone                 : append_alloc_array_copy(callee); return;\n@@ -3674,1 +3674,1 @@\n-  ValueStack* state_before = id == vmIntrinsics::_clone ? copy_state_before() : copy_state_for_exception();\n+  ValueStack* state_before = copy_state_for_exception();\n@@ -4444,0 +4444,26 @@\n+void GraphBuilder::append_alloc_array_copy(ciMethod* callee) {\n+  ValueStack* state_before = copy_state_before();\n+  state_before->set_force_reexecute();\n+  Value src = apop();\n+  BasicType basic_type = src->exact_type()->as_array_klass()->element_type()->basic_type();\n+  Value length = append(new ArrayLength(src, state_before));\n+  Value new_array = append_split(new NewTypeArray(length, basic_type, state_before, false));\n+\n+  ValueType* result_type = as_ValueType(callee->return_type());\n+  vmIntrinsics::ID id = vmIntrinsics::_arraycopy;\n+  Values* args = new Values(5);\n+  args->push(src);\n+  args->push(append(new Constant(new IntConstant(0))));\n+  args->push(new_array);\n+  args->push(append(new Constant(new IntConstant(0))));\n+  args->push(length);\n+  const bool has_receiver = true;\n+  Intrinsic* array_copy = new Intrinsic(result_type, id,\n+                                    args, has_receiver, state_before,\n+                                    vmIntrinsics::preserves_state(id),\n+                                    vmIntrinsics::can_trap(id));\n+  array_copy->set_flag(Instruction::OmitChecksFlag, true);\n+  append_split(array_copy);\n+  apush(new_array);\n+}\n+\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":31,"deletions":5,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -382,0 +382,1 @@\n+  void append_alloc_array_copy(ciMethod* callee);\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -367,0 +367,1 @@\n+    OmitChecksFlag,\n@@ -1330,0 +1331,1 @@\n+  bool _zero_array;\n@@ -1333,1 +1335,1 @@\n-  NewTypeArray(Value length, BasicType elt_type, ValueStack* state_before)\n+  NewTypeArray(Value length, BasicType elt_type, ValueStack* state_before, bool zero_array)\n@@ -1336,0 +1338,1 @@\n+  , _zero_array(zero_array)\n@@ -1340,0 +1343,1 @@\n+  bool zero_array()    const                     { return _zero_array; }\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -356,0 +356,1 @@\n+#if defined(X86) || defined(AARCH64)\n@@ -361,0 +362,3 @@\n+#else\n+  _stub = new ArrayCopyStub(this);\n+#endif\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1777,1 +1777,1 @@\n-  bool zero_array()    const                     { return _zero_array;  }\n+  bool zero_array()   const                      { return _zero_array;  }\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2980,1 +2980,0 @@\n-  case vmIntrinsicID::_clone:         do_Clone(x);         break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -267,1 +267,0 @@\n-  void do_Clone(Intrinsic* x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+  bool     _force_reexecute;                     \/\/ force the reexecute flag on, used for patching stub\n@@ -228,0 +229,3 @@\n+  bool force_reexecute() const         { return _force_reexecute; }\n+  void set_force_reexecute()           { _force_reexecute = true; }\n+\n","filename":"src\/hotspot\/share\/c1\/c1_ValueStack.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,8 +67,0 @@\n-\n-\/\/    static void blackhole(Object obj)\n-\/\/    {\n-\/\/        if (obj.hashCode() == System.nanoTime())\n-\/\/        {\n-\/\/            System.out.println(obj);\n-\/\/        }\n-\/\/    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/TestNullArrayClone.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"}]}