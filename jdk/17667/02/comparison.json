{"files":[{"patch":"@@ -1236,1 +1236,2 @@\n-                      *op->stub()->entry());\n+                      *op->stub()->entry(),\n+                      op->zero_array());\n@@ -2528,1 +2529,3 @@\n-  __ bind(*stub->continuation());\n+ if (stub != nullptr) {\n+   __ bind(*stub->continuation());\n+ }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -916,0 +916,66 @@\n+void LIRGenerator::do_Clone(Intrinsic* x) {\n+    assert(x->number_of_arguments() == 1, \"wrong type\");\n+\n+    LIRItem src(x->argument_at(0), this);\n+    ciType* src_type = src.value()->exact_type();\n+\n+    LIRItem array(src.value(), this);\n+    array.load_item();\n+    LIR_Opr len = new_register(T_INT);\n+    CodeEmitInfo* null_check_info = state_for(x, x->state_before());\n+    null_check_info->set_force_reexecute();\n+    __ load(new LIR_Address(array.result(), arrayOopDesc::length_offset_in_bytes(), T_INT), len, null_check_info);\n+    LIR_Opr len_r19 = FrameMap::r19_opr;\n+    __ move(len, len_r19);\n+\n+    LIR_Opr array_reg = result_register_for(x->type());\n+    LIR_Opr tmp1 = FrameMap::r10_oop_opr;\n+    LIR_Opr tmp2 = FrameMap::r11_oop_opr;\n+    LIR_Opr tmp3 = FrameMap::r5_oop_opr;\n+    LIR_Opr tmp4 = array_reg;\n+    LIR_Opr klass_reg = FrameMap::r3_metadata_opr;\n+\n+    ciArrayKlass* array_klass = src_type->as_array_klass();\n+    BasicType elem_type = array_klass->element_type()->basic_type();\n+\n+    __ metadata2reg(array_klass->constant_encoding(), klass_reg);\n+\n+    CodeEmitInfo* info = new CodeEmitInfo(null_check_info);\n+    CodeStub* slow_path = new NewTypeArrayStub(klass_reg, len_r19, array_reg, info);\n+    __ allocate_array(array_reg, len_r19, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path, false);\n+\n+    LIRItem src_pos(new Constant(new IntConstant(0)), this);\n+    LIR_Opr dst = new_register(T_OBJECT);\n+    __ move(array_reg, dst);\n+    LIRItem dst_pos(new Constant(new IntConstant(0)), this);\n+\n+    \/\/ operands for arraycopy must use fixed registers, otherwise\n+    \/\/ LinearScan will fail allocation (because arraycopy always needs a\n+    \/\/ call)\n+\n+    \/\/ The java calling convention will give us enough registers\n+    \/\/ so that on the stub side the args will be perfect already.\n+    \/\/ On the other slow\/special case side we call C and the arg\n+    \/\/ positions are not similar enough to pick one as the best.\n+    \/\/ Also because the java calling convention is a \"shifted\" version\n+    \/\/ of the C convention we can process the java args trivially into C\n+    \/\/ args without worry of overwriting during the xfer\n+\n+    src.load_item_force     (FrameMap::as_oop_opr(j_rarg0));\n+    src_pos.load_item_force (FrameMap::as_opr(j_rarg1));\n+    LIR_Opr destination = FrameMap::as_oop_opr(j_rarg2);\n+    __ move(dst, destination);\n+    dst_pos.load_item_force (FrameMap::as_opr(j_rarg3));\n+    LIR_Opr length = FrameMap::as_opr(j_rarg4);\n+    __ move(len, length);\n+    LIR_Opr tmp =           FrameMap::as_opr(j_rarg5);\n+\n+    int flags = 0;\n+    ciArrayKlass* expected_type = src_type->as_array_klass();\n+\n+    __ arraycopy(src.result(), src_pos.result(), destination, dst_pos.result(), length, tmp, expected_type, flags, info); \/\/ does add_safepoint\n+\n+    LIR_Opr result = rlock_result(x);\n+    __ move(dst, result);\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":66,"deletions":0,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -274,1 +274,1 @@\n-void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int header_size, int f, Register klass, Label& slow_case) {\n+void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int header_size, int f, Register klass, Label& slow_case, bool zero_array) {\n@@ -296,1 +296,3 @@\n-  initialize_body(obj, arr_size, header_size * BytesPerWord, t1, t2);\n+  if (zero_array) {\n+    initialize_body(obj, arr_size, header_size * BytesPerWord, t1, t2);\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -103,1 +103,2 @@\n-  void allocate_array(Register obj, Register len, Register t, Register t2, int header_size, int f, Register klass, Label& slow_case);\n+  \/\/ zero_array : zero the allocated array or not\n+  void allocate_array(Register obj, Register len, Register t, Register t2, int header_size, int f, Register klass, Label& slow_case, bool zero_array);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -875,0 +875,4 @@\n+void LIRGenerator::do_Clone(Intrinsic* x) {\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRGenerator_arm.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -786,0 +786,3 @@\n+void LIRGenerator::do_Clone(Intrinsic* x) {\n+  Unimplemented();\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRGenerator_ppc.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -774,0 +774,4 @@\n+void LIRGenerator::do_Clone(Intrinsic* x) {\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRGenerator_riscv.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -741,0 +741,4 @@\n+void LIRGenerator::do_Clone(Intrinsic* x) {\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRGenerator_s390.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1641,1 +1641,2 @@\n-                      *op->stub()->entry());\n+                      *op->stub()->entry(),\n+                      op->zero_array());\n@@ -3473,1 +3474,3 @@\n-  __ bind(*stub->continuation());\n+  if (stub != nullptr) {\n+    __ bind(*stub->continuation());\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1054,0 +1054,85 @@\n+void LIRGenerator::do_Clone(Intrinsic* x) {\n+  assert(x->number_of_arguments() == 1, \"wrong type\");\n+\n+  LIRItem src(x->argument_at(0), this);\n+  ciType* src_type = src.value()->exact_type();\n+\n+  LIRItem array(src.value(), this);\n+  array.load_item();\n+  LIR_Opr len = new_register(T_INT);\n+  CodeEmitInfo* null_check_info = state_for(x, x->state_before());\n+  null_check_info->set_force_reexecute();\n+  __ load(new LIR_Address(array.result(), arrayOopDesc::length_offset_in_bytes(), T_INT), len, null_check_info);\n+  LIR_Opr len_rbx = FrameMap::rbx_opr;\n+  __ move(len, len_rbx);\n+\n+  LIR_Opr array_reg = result_register_for(x->type());\n+  LIR_Opr tmp1 = FrameMap::rcx_oop_opr;\n+  LIR_Opr tmp2 = FrameMap::rsi_oop_opr;\n+  LIR_Opr tmp3 = FrameMap::rdi_oop_opr;\n+  LIR_Opr tmp4 = array_reg;\n+  LIR_Opr klass_reg = FrameMap::rdx_metadata_opr;\n+\n+  ciArrayKlass* array_klass = src_type->as_array_klass();\n+  BasicType elem_type = array_klass->element_type()->basic_type();\n+\n+  __ metadata2reg(array_klass->constant_encoding(), klass_reg);\n+\n+  CodeEmitInfo* info = new CodeEmitInfo(null_check_info);\n+  CodeStub* slow_path = new NewTypeArrayStub(klass_reg, len_rbx, array_reg, info);\n+  __ allocate_array(array_reg, len_rbx, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path, false);\n+\n+  LIRItem src_pos(new Constant(new IntConstant(0)), this);\n+  LIR_Opr dst = new_register(T_OBJECT);\n+  __ move(array_reg, dst);\n+  LIRItem dst_pos(new Constant(new IntConstant(0)), this);\n+\n+  \/\/ operands for arraycopy must use fixed registers, otherwise\n+  \/\/ LinearScan will fail allocation (because arraycopy always needs a\n+  \/\/ call)\n+\n+#ifndef _LP64\n+\n+  src.load_item_force     (FrameMap::rcx_oop_opr);\n+  src_pos.load_item_force (FrameMap::rdx_opr);\n+  LIR_Opr destination = FrameMap::rax_oop_opr;\n+  __ move(dst, destination);\n+  dst_pos.load_item_force (FrameMap::rbx_opr);\n+  LIR_Opr length = FrameMap::rdi_opr;\n+  __ move(len, length);\n+\n+  LIR_Opr tmp =           (FrameMap::rsi_opr);\n+\n+  FrameMap* f = Compilation::current()->frame_map();\n+  f->update_reserved_argument_area_size(3 * BytesPerWord);\n+#else\n+\n+  \/\/ The java calling convention will give us enough registers\n+  \/\/ so that on the stub side the args will be perfect already.\n+  \/\/ On the other slow\/special case side we call C and the arg\n+  \/\/ positions are not similar enough to pick one as the best.\n+  \/\/ Also because the java calling convention is a \"shifted\" version\n+  \/\/ of the C convention we can process the java args trivially into C\n+  \/\/ args without worry of overwriting during the xfer\n+\n+\n+  src.load_item_force     (FrameMap::as_oop_opr(j_rarg0));\n+  src_pos.load_item_force (FrameMap::as_opr(j_rarg1));\n+  LIR_Opr destination = FrameMap::as_oop_opr(j_rarg2);\n+  __ move(dst, destination);\n+  dst_pos.load_item_force (FrameMap::as_opr(j_rarg3));\n+  LIR_Opr length = FrameMap::as_opr(j_rarg4);\n+  __ move(len, length);\n+\n+  LIR_Opr tmp =           FrameMap::as_opr(j_rarg5);\n+#endif \/\/ LP64\n+\n+  int flags = 0;\n+  ciArrayKlass* expected_type = src_type->as_array_klass();\n+\n+  __ arraycopy(src.result(), src_pos.result(), destination, dst_pos.result(), length, tmp, expected_type, flags, info); \/\/ does add_safepoint\n+\n+  LIR_Opr result = rlock_result(x);\n+  __ move(dst, result);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":85,"deletions":0,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -265,1 +265,1 @@\n-void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int header_size, Address::ScaleFactor f, Register klass, Label& slow_case) {\n+void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int header_size, Address::ScaleFactor f, Register klass, Label& slow_case, bool zero_array) {\n@@ -286,3 +286,5 @@\n-  \/\/ clear rest of allocated space\n-  const Register len_zero = len;\n-  initialize_body(obj, arr_size, header_size * BytesPerWord, len_zero);\n+  if (zero_array) {\n+    \/\/ clear rest of allocated space\n+    const Register len_zero = len;\n+    initialize_body(obj, arr_size, header_size * BytesPerWord, len_zero);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -92,1 +92,2 @@\n-  void allocate_array(Register obj, Register len, Register t, Register t2, int header_size, Address::ScaleFactor f, Register klass, Label& slow_case);\n+  \/\/ zero_array : zero the allocated array or not\n+  void allocate_array(Register obj, Register len, Register t, Register t2, int header_size, Address::ScaleFactor f, Register klass, Label& slow_case, bool zero_array);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -238,0 +238,3 @@\n+#if defined(X86) || defined(AARCH64)\n+  case vmIntrinsics::_clone:\n+#endif\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2136,1 +2136,2 @@\n-        code == Bytecodes::_invokedynamic) {\n+        code == Bytecodes::_invokedynamic ||\n+        target->get_Method()->intrinsic_id() == vmIntrinsics::_clone) {\n@@ -2140,1 +2141,13 @@\n-      bool success = try_inline(inline_target, holder_known, false \/* ignore_return *\/, code, better_receiver);\n+      bool success;\n+\n+      \/\/ Clone intrinsic and inlining can only kick when instance is a primitive array,\n+      \/\/ or when the target of the clone is not a Phi node\n+      ciType* receiver_type;\n+      if (target->get_Method()->intrinsic_id() == vmIntrinsics::_clone &&\n+          ((receiver_type = state()->stack_at(state()->stack_size() - inline_target->arg_size())->exact_type()) == nullptr || \/\/ clone target is phi\n+          !receiver_type->is_array_klass() || \/\/ not array\n+          !receiver_type->as_array_klass()->element_type()->is_primitive_type())) { \/\/ not primitive array\n+        success = false;\n+      } else {\n+        success = try_inline(inline_target, holder_known, false \/* ignore_return *\/, code, better_receiver);\n+      }\n@@ -3661,1 +3674,1 @@\n-  ValueStack* state_before = copy_state_for_exception();\n+  ValueStack* state_before = id == vmIntrinsics::_clone ? copy_state_before() : copy_state_for_exception();\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -356,1 +356,5 @@\n-  _stub = new ArrayCopyStub(this);\n+  if (expected_type != nullptr && flags == 0) {\n+    _stub = nullptr;\n+  } else {\n+    _stub = new ArrayCopyStub(this);\n+  }\n@@ -1002,1 +1006,4 @@\n-  masm->append_code_stub(stub());\n+  ArrayCopyStub* code_stub = stub();\n+  if (code_stub != nullptr) {\n+    masm->append_code_stub(code_stub);\n+  }\n@@ -1368,1 +1375,1 @@\n-void LIR_List::allocate_array(LIR_Opr dst, LIR_Opr len, LIR_Opr t1,LIR_Opr t2, LIR_Opr t3,LIR_Opr t4, BasicType type, LIR_Opr klass, CodeStub* stub) {\n+void LIR_List::allocate_array(LIR_Opr dst, LIR_Opr len, LIR_Opr t1,LIR_Opr t2, LIR_Opr t3,LIR_Opr t4, BasicType type, LIR_Opr klass, CodeStub* stub, bool zero_array) {\n@@ -1378,1 +1385,2 @@\n-                           stub));\n+                           stub,\n+                           zero_array));\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1753,0 +1753,1 @@\n+  bool      _zero_array;\n@@ -1755,1 +1756,1 @@\n-  LIR_OpAllocArray(LIR_Opr klass, LIR_Opr len, LIR_Opr result, LIR_Opr t1, LIR_Opr t2, LIR_Opr t3, LIR_Opr t4, BasicType type, CodeStub* stub)\n+  LIR_OpAllocArray(LIR_Opr klass, LIR_Opr len, LIR_Opr result, LIR_Opr t1, LIR_Opr t2, LIR_Opr t3, LIR_Opr t4, BasicType type, CodeStub* stub, bool zero_array)\n@@ -1764,1 +1765,2 @@\n-    , _stub(stub) {}\n+    , _stub(stub)\n+    , _zero_array(zero_array) {}\n@@ -1775,0 +1777,1 @@\n+  bool zero_array()    const                     { return _zero_array;  }\n@@ -2305,1 +2308,1 @@\n-  void allocate_array(LIR_Opr dst, LIR_Opr len, LIR_Opr t1,LIR_Opr t2, LIR_Opr t3,LIR_Opr t4, BasicType type, LIR_Opr klass, CodeStub* stub);\n+  void allocate_array(LIR_Opr dst, LIR_Opr len, LIR_Opr t1,LIR_Opr t2, LIR_Opr t3,LIR_Opr t4, BasicType type, LIR_Opr klass, CodeStub* stub, bool zero_array = true);\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2980,0 +2980,1 @@\n+  case vmIntrinsicID::_clone:         do_Clone(x);         break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -267,0 +267,1 @@\n+  void do_Clone(Intrinsic* x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8302850\n+ *\n+ * @run main\/othervm -XX:-UseOnStackReplacement -XX:-BackgroundCompilation -XX:TieredStopAtLevel=1\n+ *                   -XX:CompileOnly=compiler.c1.TestNullArrayClone::test -XX:+UnlockExperimentalVMOptions\n+ *                   -XX:CompileCommand=blackhole,compiler.c1.TestNullArrayClone::blackhole\n+ *                   compiler.c1.TestNullArrayClone\n+ *\/\n+package compiler.c1;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+public class TestNullArrayClone {\n+    public static void main(String[] args)\n+    {\n+        final int size = 10;\n+        final int[] ints = new int[size];\n+        for (int i = 0; i < ints.length; i++)\n+        {\n+            ints[i] = ThreadLocalRandom.current().nextInt();\n+        }\n+\n+        for (int i = 0; i < 1_000; i++)\n+        {\n+            int[] result = test(ints);\n+            blackhole(result);\n+        }\n+\n+        try {\n+            test(null);\n+            System.out.println(\"Expected NullPointerException to be thrown\");\n+            System.exit(97);\n+        } catch (NullPointerException e) {\n+        }\n+    }\n+\n+    static int[] test(int[] ints)\n+    {\n+        return ints.clone();\n+    }\n+\n+    static void blackhole(Object obj) {}\n+\n+\/\/    static void blackhole(Object obj)\n+\/\/    {\n+\/\/        if (obj.hashCode() == System.nanoTime())\n+\/\/        {\n+\/\/            System.out.println(obj);\n+\/\/        }\n+\/\/    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/TestNullArrayClone.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"}]}