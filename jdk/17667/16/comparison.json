{"files":[{"patch":"@@ -1215,1 +1215,2 @@\n-                      *op->stub()->entry());\n+                      *op->stub()->entry(),\n+                      op->zero_array());\n@@ -2507,1 +2508,3 @@\n-  __ bind(*stub->continuation());\n+  if (stub != nullptr) {\n+    __ bind(*stub->continuation());\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -879,1 +879,7 @@\n-  CodeEmitInfo* info = state_for(x, x->state());\n+  CodeEmitInfo* info = nullptr;\n+  if (x->state_before() != nullptr && x->state_before()->force_reexecute()) {\n+    info = state_for(x, x->state_before());\n+    info->set_force_reexecute();\n+  } else {\n+    info = state_for(x, x->state());\n+  }\n@@ -912,0 +918,3 @@\n+  if (x->check_flag(Instruction::OmitChecksFlag)) {\n+    flags = 0;\n+  }\n@@ -1133,1 +1142,7 @@\n-  CodeEmitInfo* info = state_for(x, x->state());\n+  CodeEmitInfo* info = nullptr;\n+  if (x->state_before() != nullptr && x->state_before()->force_reexecute()) {\n+    info = state_for(x, x->state_before());\n+    info->set_force_reexecute();\n+  } else {\n+    info = state_for(x, x->state());\n+  }\n@@ -1150,1 +1165,1 @@\n-  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path);\n+  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path, x->zero_array());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -275,1 +275,1 @@\n-void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int base_offset_in_bytes, int f, Register klass, Label& slow_case) {\n+void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int base_offset_in_bytes, int f, Register klass, Label& slow_case, bool zero_array) {\n@@ -300,1 +300,3 @@\n-  initialize_body(obj, arr_size, base_offset, t1, t2);\n+  if (zero_array) {\n+    initialize_body(obj, arr_size, base_offset, t1, t2);\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -103,1 +103,2 @@\n-  void allocate_array(Register obj, Register len, Register t, Register t2, int base_offset_in_bytes, int f, Register klass, Label& slow_case);\n+  \/\/ zero_array          : zero the allocated array or not\n+  void allocate_array(Register obj, Register len, Register t, Register t2, int base_offset_in_bytes, int f, Register klass, Label& slow_case, bool zero_array);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1624,1 +1624,2 @@\n-                      *op->stub()->entry());\n+                      *op->stub()->entry(),\n+                      op->zero_array());\n@@ -3456,1 +3457,3 @@\n-  __ bind(*stub->continuation());\n+  if (stub != nullptr) {\n+    __ bind(*stub->continuation());\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1007,1 +1007,7 @@\n-  CodeEmitInfo* info = state_for(x, x->state());\n+  CodeEmitInfo* info = nullptr;\n+  if (x->state_before() != nullptr && x->state_before()->force_reexecute()) {\n+    info = state_for(x, x->state_before());\n+    info->set_force_reexecute();\n+  } else {\n+    info = state_for(x, x->state());\n+  }\n@@ -1019,0 +1025,7 @@\n+  int flags;\n+  ciArrayKlass* expected_type;\n+  arraycopy_helper(x, &flags, &expected_type);\n+  if (x->check_flag(Instruction::OmitChecksFlag)) {\n+    flags = 0;\n+  }\n+\n@@ -1026,0 +1039,5 @@\n+\n+  if (expected_type != nullptr && flags == 0) {\n+    FrameMap* f = Compilation::current()->frame_map();\n+    f->update_reserved_argument_area_size(3 * BytesPerWord);\n+  }\n@@ -1047,4 +1065,0 @@\n-  int flags;\n-  ciArrayKlass* expected_type;\n-  arraycopy_helper(x, &flags, &expected_type);\n-\n@@ -1313,1 +1327,7 @@\n-  CodeEmitInfo* info = state_for(x, x->state());\n+  CodeEmitInfo* info = nullptr;\n+  if (x->state_before() != nullptr && x->state_before()->force_reexecute()) {\n+    info = state_for(x, x->state_before());\n+    info->set_force_reexecute();\n+  } else {\n+    info = state_for(x, x->state());\n+  }\n@@ -1330,1 +1350,1 @@\n-  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path);\n+  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path, x->zero_array());\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":27,"deletions":7,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -281,1 +281,1 @@\n-void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int base_offset_in_bytes, Address::ScaleFactor f, Register klass, Label& slow_case) {\n+void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int base_offset_in_bytes, Address::ScaleFactor f, Register klass, Label& slow_case, bool zero_array) {\n@@ -303,5 +303,7 @@\n-  const Register len_zero = len;\n-  \/\/ Align-up to word boundary, because we clear the 4 bytes potentially\n-  \/\/ following the length field in initialize_header().\n-  int base_offset = align_up(base_offset_in_bytes, BytesPerWord);\n-  initialize_body(obj, arr_size, base_offset, len_zero);\n+  if (zero_array) {\n+    const Register len_zero = len;\n+    \/\/ Align-up to word boundary, because we clear the 4 bytes potentially\n+    \/\/ following the length field in initialize_header().\n+    int base_offset = align_up(base_offset_in_bytes, BytesPerWord);\n+    initialize_body(obj, arr_size, base_offset, len_zero);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -92,1 +92,2 @@\n-  void allocate_array(Register obj, Register len, Register t, Register t2, int base_offset_in_bytes, Address::ScaleFactor f, Register klass, Label& slow_case);\n+  \/\/ zero_array          : zero the allocated array or not\n+  void allocate_array(Register obj, Register len, Register t, Register t2, int base_offset_in_bytes, Address::ScaleFactor f, Register klass, Label& slow_case, bool zero_array);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -238,0 +238,3 @@\n+#if defined(X86) || defined(AARCH64)\n+  case vmIntrinsics::_clone:\n+#endif\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2030,2 +2030,5 @@\n-      if (type != nullptr && type->is_loaded() &&\n-          type->is_instance_klass() && !type->as_instance_klass()->is_interface()) {\n+      if (type != nullptr && type->is_loaded()) {\n+        assert(!type->is_instance_klass() || !type->as_instance_klass()->is_interface(), \"Must not be an interface\");\n+        \/\/ Detects non-interface instances, primitive arrays, and some object arrays.\n+        \/\/ Array receivers can only call Object methods, so we should be able to allow\n+        \/\/ all object arrays here too, even those with unloaded types.\n@@ -2247,1 +2250,1 @@\n-  apush(append_split(new NewTypeArray(ipop(), (BasicType)stream()->get_index(), state_before)));\n+  apush(append_split(new NewTypeArray(ipop(), (BasicType)stream()->get_index(), state_before, true)));\n@@ -3654,0 +3657,1 @@\n+  case vmIntrinsics::_clone                  : append_alloc_array_copy(callee); return;\n@@ -3657,0 +3661,3 @@\n+  if (_inline_bailout_msg != nullptr) {\n+    return;\n+  }\n@@ -3718,0 +3725,3 @@\n+  if (_inline_bailout_msg != nullptr) {\n+    return false;\n+  }\n@@ -4431,0 +4441,37 @@\n+void GraphBuilder::append_alloc_array_copy(ciMethod* callee) {\n+  const int args_base = state()->stack_size() - callee->arg_size();\n+  ciType* receiver_type = state()->stack_at(args_base)->exact_type();\n+  if (receiver_type == nullptr) {\n+    inline_bailout(\"must have a receiver\");\n+    return;\n+  }\n+  if (!receiver_type->is_type_array_klass()) {\n+    inline_bailout(\"clone array not primitive\");\n+    return;\n+  }\n+\n+  ValueStack* state_before = copy_state_before();\n+  state_before->set_force_reexecute();\n+  Value src = apop();\n+  BasicType basic_type = src->exact_type()->as_array_klass()->element_type()->basic_type();\n+  Value length = append(new ArrayLength(src, state_before));\n+  Value new_array = append_split(new NewTypeArray(length, basic_type, state_before, false));\n+\n+  ValueType* result_type = as_ValueType(callee->return_type());\n+  vmIntrinsics::ID id = vmIntrinsics::_arraycopy;\n+  Values* args = new Values(5);\n+  args->push(src);\n+  args->push(append(new Constant(new IntConstant(0))));\n+  args->push(new_array);\n+  args->push(append(new Constant(new IntConstant(0))));\n+  args->push(length);\n+  const bool has_receiver = true;\n+  Intrinsic* array_copy = new Intrinsic(result_type, id,\n+                                    args, has_receiver, state_before,\n+                                    vmIntrinsics::preserves_state(id),\n+                                    vmIntrinsics::can_trap(id));\n+  array_copy->set_flag(Instruction::OmitChecksFlag, true);\n+  append_split(array_copy);\n+  apush(new_array);\n+}\n+\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":50,"deletions":3,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -382,0 +382,1 @@\n+  void append_alloc_array_copy(ciMethod* callee);\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -367,0 +367,1 @@\n+    OmitChecksFlag,\n@@ -1330,0 +1331,1 @@\n+  bool _zero_array;\n@@ -1333,1 +1335,1 @@\n-  NewTypeArray(Value length, BasicType elt_type, ValueStack* state_before)\n+  NewTypeArray(Value length, BasicType elt_type, ValueStack* state_before, bool zero_array)\n@@ -1336,0 +1338,1 @@\n+  , _zero_array(zero_array)\n@@ -1340,0 +1343,1 @@\n+  bool zero_array()    const                     { return _zero_array; }\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -356,0 +356,7 @@\n+#if defined(X86) || defined(AARCH64)\n+  if (expected_type != nullptr && flags == 0) {\n+    _stub = nullptr;\n+  } else {\n+    _stub = new ArrayCopyStub(this);\n+  }\n+#else\n@@ -357,0 +364,1 @@\n+#endif\n@@ -1002,1 +1010,4 @@\n-  masm->append_code_stub(stub());\n+  ArrayCopyStub* code_stub = stub();\n+  if (code_stub != nullptr) {\n+    masm->append_code_stub(code_stub);\n+  }\n@@ -1368,1 +1379,1 @@\n-void LIR_List::allocate_array(LIR_Opr dst, LIR_Opr len, LIR_Opr t1,LIR_Opr t2, LIR_Opr t3,LIR_Opr t4, BasicType type, LIR_Opr klass, CodeStub* stub) {\n+void LIR_List::allocate_array(LIR_Opr dst, LIR_Opr len, LIR_Opr t1,LIR_Opr t2, LIR_Opr t3,LIR_Opr t4, BasicType type, LIR_Opr klass, CodeStub* stub, bool zero_array) {\n@@ -1378,1 +1389,2 @@\n-                           stub));\n+                           stub,\n+                           zero_array));\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1753,0 +1753,1 @@\n+  bool      _zero_array;\n@@ -1755,1 +1756,1 @@\n-  LIR_OpAllocArray(LIR_Opr klass, LIR_Opr len, LIR_Opr result, LIR_Opr t1, LIR_Opr t2, LIR_Opr t3, LIR_Opr t4, BasicType type, CodeStub* stub)\n+  LIR_OpAllocArray(LIR_Opr klass, LIR_Opr len, LIR_Opr result, LIR_Opr t1, LIR_Opr t2, LIR_Opr t3, LIR_Opr t4, BasicType type, CodeStub* stub, bool zero_array)\n@@ -1764,1 +1765,2 @@\n-    , _stub(stub) {}\n+    , _stub(stub)\n+    , _zero_array(zero_array) {}\n@@ -1775,0 +1777,1 @@\n+  bool zero_array()   const                      { return _zero_array;  }\n@@ -2305,1 +2308,1 @@\n-  void allocate_array(LIR_Opr dst, LIR_Opr len, LIR_Opr t1,LIR_Opr t2, LIR_Opr t3,LIR_Opr t4, BasicType type, LIR_Opr klass, CodeStub* stub);\n+  void allocate_array(LIR_Opr dst, LIR_Opr len, LIR_Opr t1,LIR_Opr t2, LIR_Opr t3,LIR_Opr t4, BasicType type, LIR_Opr klass, CodeStub* stub, bool zero_array = true);\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+  bool     _force_reexecute;                     \/\/ force the reexecute flag on, used for patching stub\n@@ -228,0 +229,3 @@\n+  bool force_reexecute() const         { return _force_reexecute; }\n+  void set_force_reexecute()           { _force_reexecute = true; }\n+\n","filename":"src\/hotspot\/share\/c1\/c1_ValueStack.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8302850\n+ * @summary Tests that an array clone call that has been compiled with C1\n+ *          handles null values correctly.\n+ * @run main\/othervm -XX:-UseOnStackReplacement -XX:-BackgroundCompilation -XX:TieredStopAtLevel=1\n+ *                   -XX:CompileOnly=compiler.c1.TestNullArrayClone::testClone* -XX:+UnlockExperimentalVMOptions\n+ *                   compiler.c1.TestNullArrayClone\n+ *\/\n+package compiler.c1;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+public class TestNullArrayClone {\n+    static final int ITER = 2000; \/\/ ~ Tier3CompileThreshold\n+    static final int ARRAY_SIZE = 999;\n+\n+    public static void main(String[] args) {\n+        testInts();\n+        testLongs();\n+        testBytes();\n+    }\n+\n+    private static void testInts() {\n+        final int[] arr = new int[ARRAY_SIZE];\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = ThreadLocalRandom.current().nextInt();\n+        }\n+\n+        for (int i = 0; i < ITER; i++) {\n+            int[] result = testClonePrimitiveInt(arr);\n+            if (result.length != arr.length) {\n+                throw new RuntimeException(\"Unexpected clone length: source array length \" + arr.length + \" != clone array length \" + result.length);\n+            }\n+            for (int j = 0; j < arr.length; j++) {\n+                if (result[j] != arr[j]) {\n+                    throw new RuntimeException(\"Unexpected result: \" + result[j] + \" != \" + j);\n+                }\n+            }\n+        }\n+\n+        try {\n+            testClonePrimitiveInt(null);\n+            throw new RuntimeException(\"Expected NullPointerException to be thrown\");\n+        } catch (NullPointerException e) {\n+        }\n+    }\n+\n+    private static void testLongs() {\n+        final long[] arr = new long[ARRAY_SIZE];\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = ThreadLocalRandom.current().nextLong();\n+        }\n+\n+        for (int i = 0; i < ITER; i++) {\n+            long[] result = testClonePrimitiveLong(arr);\n+            if (result.length != arr.length) {\n+                throw new RuntimeException(\"Unexpected clone length: source array length \" + arr.length + \" != clone array length \" + result.length);\n+            }\n+            for (int j = 0; j < arr.length; j++) {\n+                if (result[j] != arr[j]) {\n+                    throw new RuntimeException(\"Unexpected result: \" + result[j] + \" != \" + j);\n+                }\n+            }\n+        }\n+\n+        try {\n+            testClonePrimitiveLong(null);\n+            throw new RuntimeException(\"Expected NullPointerException to be thrown\");\n+        } catch (NullPointerException e) {\n+        }\n+    }\n+\n+    private static void testBytes() {\n+        final byte[] arr = new byte[ARRAY_SIZE];\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (byte) ThreadLocalRandom.current().nextInt();\n+        }\n+\n+        for (int i = 0; i < ITER; i++) {\n+            byte[] result = testClonePrimitiveBytes(arr);\n+            if (result.length != arr.length) {\n+                throw new RuntimeException(\"Unexpected clone length: source array length \" + arr.length + \" != clone array length \" + result.length);\n+            }\n+            for (int j = 0; j < arr.length; j++) {\n+                if (result[j] != arr[j]) {\n+                    throw new RuntimeException(\"Unexpected result: \" + result[j] + \" != \" + j);\n+                }\n+            }\n+        }\n+\n+        try {\n+            testClonePrimitiveBytes(null);\n+            throw new RuntimeException(\"Expected NullPointerException to be thrown\");\n+        } catch (NullPointerException e) {\n+        }\n+    }\n+\n+    static int[] testClonePrimitiveInt(int[] ints) {\n+        return ints.clone();\n+    }\n+\n+    static long[] testClonePrimitiveLong(long[] longs) {\n+        return longs.clone();\n+    }\n+\n+    static byte[] testClonePrimitiveBytes(byte[] bytes) {\n+        return bytes.clone();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/TestNullArrayClone.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"}]}