{"files":[{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/safepoint.hpp\"\n@@ -205,1 +206,2 @@\n-  assert(Heap_lock->owner() != nullptr, \"Should be owned on this thread's behalf.\");\n+  assert(Heap_lock->owner() != nullptr || SafepointSynchronize::is_at_safepoint(),\n+         \"Should be owned on this thread's behalf or at safepoint.\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"gc\/g1\/g1HeapEvaluationTask.hpp\"\n@@ -114,0 +115,1 @@\n+#include \"runtime\/vmOperations.hpp\"\n@@ -827,0 +829,3 @@\n+  \/\/ Note: Region timestamps are updated automatically when regions transition to free state\n+  \/\/ via set_free() calls, so no blanket reset is needed here\n+\n@@ -1093,1 +1098,36 @@\n-void G1CollectedHeap::shrink_helper(size_t shrink_bytes) {\n+void G1CollectedHeap::shrink_with_time_based_selection(size_t shrink_bytes) {\n+  if (capacity() == min_capacity()) {\n+    log_debug(gc, ergo, heap)(\"Time-based shrink: Did not shrink the heap (heap already at minimum)\");\n+    return;\n+  }\n+\n+  size_t aligned_shrink_bytes = os::align_down_vm_page_size(shrink_bytes);\n+  aligned_shrink_bytes = align_down(aligned_shrink_bytes, G1HeapRegion::GrainBytes);\n+\n+  aligned_shrink_bytes = capacity() - MAX2(capacity() - aligned_shrink_bytes, min_capacity());\n+  assert(is_aligned(aligned_shrink_bytes, G1HeapRegion::GrainBytes), \"Bytes to shrink %zuB not aligned\", aligned_shrink_bytes);\n+\n+  log_debug(gc, ergo, heap)(\"Time-based shrink: Requested shrink amount: %zuB aligned shrink amount: %zuB\",\n+                            shrink_bytes, aligned_shrink_bytes);\n+\n+  if (aligned_shrink_bytes == 0) {\n+    log_debug(gc, ergo, heap)(\"Time-based shrink: Did not shrink the heap (shrink request too small)\");\n+    return;\n+  }\n+\n+  _verifier->verify_region_sets_optional();\n+\n+  \/\/ We should only reach here from the service thread during idle time\n+  \/\/ but ensure any GC alloc regions are abandoned\n+  _allocator->abandon_gc_alloc_regions();\n+\n+  \/\/ For time-based shrink, we use time-aware selection instead of removing from end\n+  _hrm.remove_all_free_regions();\n+  shrink_helper_with_time_based_selection(aligned_shrink_bytes);\n+  rebuild_region_sets(true \/* free_list_only *\/);\n+\n+  _hrm.verify_optional();\n+  _verifier->verify_region_sets_optional();\n+}\n+\n+void G1CollectedHeap::shrink_helper_with_time_based_selection(size_t shrink_bytes) {\n@@ -1100,0 +1140,6 @@\n+  uint num_regions_removed = 0;\n+\n+  \/\/ Use time-based selection to shrink oldest eligible regions\n+  log_debug(gc, ergo, heap)(\"Time-based shrink: removing %u oldest regions (%zuB)\",\n+                            num_regions_to_remove, shrink_bytes);\n+  num_regions_removed = _hrm.shrink_by(num_regions_to_remove, true \/* use_time_based_selection *\/);\n@@ -1101,1 +1147,0 @@\n-  uint num_regions_removed = _hrm.shrink_by(num_regions_to_remove);\n@@ -1103,0 +1148,2 @@\n+  log_debug(gc, ergo, heap)(\"Time-based shrink: Requested shrinking amount: %zuB actual shrinking amount: %zuB (%u regions)\",\n+                           shrink_bytes, shrunk_bytes, num_regions_removed);\n@@ -1104,0 +1151,28 @@\n+  if (num_regions_removed > 0) {\n+    log_info(gc, heap)(\"Time-based shrink: uncommitted %u oldest regions (%zuMB), heap size now %zuMB\",\n+                       num_regions_removed, shrunk_bytes \/ M, capacity() \/ M);\n+    log_debug(gc, heap)(\"Time-based shrink details: requested=%zuB actual=%zuB \"\n+                        \"regions_removed=%u heap_capacity=%zuB\",\n+                        shrink_bytes, shrunk_bytes, num_regions_removed, capacity());\n+    policy()->record_new_heap_size(num_committed_regions());\n+  } else {\n+    log_debug(gc, ergo, heap)(\"Time-based shrink: Did not shrink the heap (no eligible regions found)\");\n+  }\n+}\n+\n+void G1CollectedHeap::shrink_helper(size_t shrink_bytes) {\n+  assert(shrink_bytes > 0, \"must be\");\n+  assert(is_aligned(shrink_bytes, G1HeapRegion::GrainBytes),\n+         \"Shrink request for %zuB not aligned to heap region size %zuB\",\n+         shrink_bytes, G1HeapRegion::GrainBytes);\n+\n+  uint num_regions_to_remove = (uint)(shrink_bytes \/ G1HeapRegion::GrainBytes);\n+  uint num_regions_removed = 0;\n+\n+  \/\/ Always perform normal heap shrinking when requested\n+  \/\/ This preserves the original GC-triggered shrinking behavior\n+  log_debug(gc, ergo, heap)(\"Heap shrink requested: removing %u regions (%zuB)\",\n+                            num_regions_to_remove, shrink_bytes);\n+  num_regions_removed = _hrm.shrink_by(num_regions_to_remove);\n+\n+  size_t shrunk_bytes = num_regions_removed * G1HeapRegion::GrainBytes;\n@@ -1105,1 +1180,2 @@\n-                            shrink_bytes, shrunk_bytes, num_regions_removed);\n+                           shrink_bytes, shrunk_bytes, num_regions_removed);\n+\n@@ -1107,0 +1183,5 @@\n+    log_info(gc, heap)(\"Heap shrink details: uncommitted %u regions (%zuMB), heap size now %zuMB\",\n+                       num_regions_removed, shrunk_bytes \/ M, capacity() \/ M);\n+    log_debug(gc, heap)(\"Heap shrink details: requested=%zuB actual=%zuB \"\n+                        \"regions_removed=%u heap_capacity=%zuB\",\n+                        shrink_bytes, shrunk_bytes, num_regions_removed, capacity());\n@@ -1109,1 +1190,1 @@\n-    log_debug(gc, ergo, heap)(\"Heap resize. Did not shrink the heap (heap shrinking operation failed)\");\n+    log_debug(gc, ergo, heap)(\"Did not shrink the heap (heap shrinking operation failed)\");\n@@ -1151,0 +1232,12 @@\n+bool G1CollectedHeap::request_heap_shrink(size_t shrink_bytes) {\n+  if (shrink_bytes == 0) {\n+    return false;\n+  }\n+\n+  \/\/ Always schedule a VM operation for proper synchronization with GC\n+  \/\/ The VM operation will re-evaluate which regions to uncommit at the time of execution\n+  VM_G1ShrinkHeap op(this, shrink_bytes);\n+  VMThread::execute(&op);\n+  return true;                       \/\/ Pages were requested to be released.\n+}\n+\n@@ -1259,0 +1352,2 @@\n+  _heap_evaluation_task = nullptr;\n+\n@@ -1520,0 +1615,8 @@\n+  if (G1UseTimeBasedHeapSizing) {\n+    _heap_evaluation_task = new G1HeapEvaluationTask(this, _heap_sizing_policy);\n+    _service_thread->register_task(_heap_evaluation_task);\n+    log_debug(gc, init)(\"G1 Time-Based Heap Evaluation task registered and scheduled\");\n+  } else {\n+    assert(_heap_evaluation_task == nullptr, \"pre-condition\");\n+  }\n+\n@@ -1523,1 +1626,1 @@\n-  }\n+  }  }\n@@ -2618,0 +2721,3 @@\n+  \/\/ Note: Region timestamps are updated automatically when regions transition to free state\n+  \/\/ via set_free() calls, so no blanket reset is needed here\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":111,"deletions":5,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"gc\/g1\/g1HeapEvaluationTask.hpp\"\n@@ -152,0 +153,1 @@\n+  friend class VM_G1ShrinkHeap;\n@@ -209,0 +211,2 @@\n+  G1HeapEvaluationTask* _heap_evaluation_task;\n+\n@@ -607,0 +611,5 @@\n+  \/\/ Request an immediate heap contraction of (at most) the given number of bytes.\n+  \/\/ Returns true if any pages were actually uncommitted.\n+  \/\/ Uses time-based region selection to shrink oldest eligible regions.\n+  bool request_heap_shrink(size_t shrink_bytes);\n+\n@@ -751,0 +760,4 @@\n+  \/\/ Time-based shrinking that selects oldest regions instead of from end\n+  void shrink_with_time_based_selection(size_t shrink_bytes);\n+  void shrink_helper_with_time_based_selection(size_t shrink_bytes);\n+\n@@ -934,0 +947,2 @@\n+  G1HeapSizingPolicy* heap_sizing_policy() const { return _heap_sizing_policy; }\n+  G1HeapRegionManager& heap_region_manager() { return _hrm; }\n@@ -995,0 +1010,3 @@\n+  \/\/ Deactivate a specific region by index.\n+  void deactivate_region_at(uint region_index) { _hrm.shrink_at(region_index, 1); }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"gc\/g1\/g1CollectedHeap.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n+#include \"gc\/g1\/g1HeapEvaluationTask.hpp\"\n+#include \"gc\/g1\/g1HeapSizingPolicy.hpp\"\n+#include \"gc\/g1\/g1ServiceThread.hpp\"\n+#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"utilities\/debug.hpp\"\n+\n+G1HeapEvaluationTask::G1HeapEvaluationTask(G1CollectedHeap* g1h, G1HeapSizingPolicy* heap_sizing_policy) :\n+  G1ServiceTask(\"G1 Heap Evaluation Task\"),\n+  _g1h(g1h),\n+  _heap_sizing_policy(heap_sizing_policy) {\n+}\n+\n+void G1HeapEvaluationTask::execute() {\n+  log_debug(gc, sizing)(\"Starting uncommit evaluation\");\n+\n+  ResourceMark rm; \/\/ Ensure temporary resources are released\n+\n+  size_t resize_amount;\n+\n+  \/\/ Use SuspendibleThreadSetJoiner for proper synchronization during heap evaluation\n+  \/\/ This ensures we don't race with concurrent GC operations while scanning region states\n+  {\n+    SuspendibleThreadSetJoiner sts;\n+    resize_amount = _heap_sizing_policy->evaluate_heap_resize_for_uncommit();\n+  }\n+\n+  static int evaluation_count = 0;\n+\n+  if (resize_amount > 0) {\n+    log_info(gc, sizing)(\"Uncommit evaluation: shrinking heap by %zuMB using time-based selection\", resize_amount \/ M);\n+    log_debug(gc, sizing)(\"Uncommit evaluation: policy recommends shrinking by %zuB\", resize_amount);\n+    \/\/ Request VM operation outside of suspendible thread set\n+    _g1h->request_heap_shrink(resize_amount);\n+  } else {\n+    if (++evaluation_count % 10 == 0) { \/\/ Log every 10th evaluation when no action taken\n+      log_info(gc, sizing)(\"Uncommit evaluation: no heap uncommit needed (evaluation #%d)\", evaluation_count);\n+    }\n+  }\n+\n+  \/\/ Schedule the next evaluation\n+  schedule(G1TimeBasedEvaluationIntervalMillis);\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapEvaluationTask.cpp","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1HEAPEVALUATIONTASK_HPP\n+#define SHARE_GC_G1_G1HEAPEVALUATIONTASK_HPP\n+\n+#include \"gc\/g1\/g1ServiceThread.hpp\"\n+#include \"gc\/g1\/g1_globals.hpp\"\n+\n+class G1CollectedHeap;\n+class G1HeapSizingPolicy;\n+\n+\/\/ Time-based heap evaluation task that runs on the G1 service thread.\n+\/\/ Uses G1ServiceTask for better integration with G1 lifecycle and scheduling.\n+class G1HeapEvaluationTask : public G1ServiceTask {\n+  G1CollectedHeap* _g1h;\n+  G1HeapSizingPolicy* _heap_sizing_policy;\n+\n+public:\n+  G1HeapEvaluationTask(G1CollectedHeap* g1h, G1HeapSizingPolicy* heap_sizing_policy);\n+  virtual void execute() override;\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1HEAPEVALUATIONTASK_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapEvaluationTask.hpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -123,0 +123,1 @@\n+  record_activity(); \/\/ Update timestamp when region becomes available\n@@ -159,0 +160,1 @@\n+    record_activity(); \/\/ Record timestamp when region becomes free\n@@ -263,0 +265,1 @@\n+  _last_access_timestamp(Ticks::now()), \/\/ Initialize timestamp with current time\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -38,0 +40,1 @@\n+#include \"utilities\/ticks.hpp\"\n@@ -73,0 +76,2 @@\n+\n+private:\n@@ -251,0 +256,3 @@\n+  \/\/ Time-based heap sizing: tracks last allocation\/access time\n+  Ticks _last_access_timestamp;\n+\n@@ -555,0 +563,19 @@\n+  \/\/ Time-based heap sizing methods\n+  void record_activity() {\n+    _last_access_timestamp = Ticks::now();\n+  }\n+\n+  Ticks last_access_time() const {\n+    return _last_access_timestamp;\n+  }\n+\n+  \/\/ Returns true if the region has been inactive for longer than the uncommit delay\n+  bool should_uncommit(Tickspan delay) const {\n+    if (!is_empty()) {\n+      return false;\n+    }\n+    Ticks current_time = Ticks::now();\n+    Tickspan elapsed = current_time - _last_access_timestamp;\n+    return elapsed > delay;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.hpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -318,0 +318,1 @@\n+\n@@ -589,0 +590,4 @@\n+  return shrink_by(num_regions_to_remove, false);\n+}\n+\n+uint G1HeapRegionManager::shrink_by(uint num_regions_to_remove, bool use_time_based_selection) {\n@@ -599,3 +604,0 @@\n-  uint cur = _next_highest_used_hrm_index;\n-  uint idx_last_found = 0;\n-  uint num_last_found = 0;\n@@ -603,3 +605,12 @@\n-  while ((removed < num_regions_to_remove) &&\n-      (num_last_found = find_empty_from_idx_reverse(cur, &idx_last_found)) > 0) {\n-    uint to_remove = MIN2(num_regions_to_remove - removed, num_last_found);\n+  if (use_time_based_selection) {\n+    \/\/ Time-based selection: find oldest empty regions across the entire heap\n+    removed = shrink_by_time_based_selection(num_regions_to_remove);\n+  } else {\n+    \/\/ Traditional selection: find empty regions from the end of heap (existing behavior)\n+    uint cur = _next_highest_used_hrm_index;\n+    uint idx_last_found = 0;\n+    uint num_last_found = 0;\n+\n+    while ((removed < num_regions_to_remove) &&\n+        (num_last_found = find_empty_from_idx_reverse(cur, &idx_last_found)) > 0) {\n+      uint to_remove = MIN2(num_regions_to_remove - removed, num_last_found);\n@@ -607,1 +618,1 @@\n-    shrink_at(idx_last_found + num_last_found - to_remove, to_remove);\n+      shrink_at(idx_last_found + num_last_found - to_remove, to_remove);\n@@ -609,2 +620,3 @@\n-    cur = idx_last_found;\n-    removed += to_remove;\n+      cur = idx_last_found;\n+      removed += to_remove;\n+    }\n@@ -618,0 +630,65 @@\n+uint G1HeapRegionManager::shrink_by_time_based_selection(uint num_regions_to_remove) {\n+  \/\/ Collect all empty regions with their access times for sorting\n+  GrowableArray<G1HeapRegion*> empty_regions;\n+\n+  \/\/ Scan all committed regions to find empty ones\n+  for (uint i = 0; i < _next_highest_used_hrm_index; i++) {\n+    if (is_available(i)) {\n+      G1HeapRegion* hr = at(i);\n+      if (hr != nullptr && hr->is_empty() && hr->is_free()) {\n+        \/\/ Check if this region should be considered for time-based uncommit\n+        Ticks current_time = Ticks::now();\n+        Tickspan elapsed = current_time - hr->last_access_time();\n+        if (elapsed.milliseconds() > G1UncommitDelayMillis) {\n+          empty_regions.append(hr);\n+        }\n+      }\n+    }\n+  }\n+\n+  if (empty_regions.length() == 0) {\n+    log_debug(gc, sizing)(\"Time-based shrink: no eligible empty regions found\");\n+    return 0;\n+  }\n+\n+  \/\/ Sort regions by access time (oldest first) using simple bubble sort\n+  \/\/ This is fine since the number of empty regions is typically small\n+  int n = empty_regions.length();\n+  for (int i = 0; i < n - 1; i++) {\n+    for (int j = 0; j < n - i - 1; j++) {\n+      G1HeapRegion* hr_a = empty_regions.at(j);\n+      G1HeapRegion* hr_b = empty_regions.at(j + 1);\n+\n+      \/\/ Swap if hr_a has newer access time than hr_b (older should come first)\n+      if (hr_a->last_access_time() > hr_b->last_access_time()) {\n+        empty_regions.at_put(j, hr_b);\n+        empty_regions.at_put(j + 1, hr_a);\n+      }\n+    }\n+  }\n+\n+  \/\/ Shrink the oldest regions first\n+  uint removed = 0;\n+  uint regions_to_process = MIN2(num_regions_to_remove, (uint)empty_regions.length());\n+\n+  log_debug(gc, sizing)(\"Time-based shrink: processing %u oldest regions out of %d empty regions\",\n+            regions_to_process, empty_regions.length());\n+\n+  for (uint i = 0; i < regions_to_process; i++) {\n+    G1HeapRegion* hr = empty_regions.at(i);\n+    uint region_index = hr->hrm_index();\n+\n+    log_debug(gc, sizing)(\"Time-based shrink: deactivating region %u (last_access=\" UINT64_FORMAT \"ms ago)\",\n+              region_index, (Ticks::now() - hr->last_access_time()).milliseconds());\n+\n+    shrink_at(region_index, 1);\n+    removed++;\n+  }\n+\n+  if (removed > 0) {\n+    log_info(gc, sizing)(\"Time-based shrink: deactivated %u oldest empty regions\", removed);\n+  }\n+\n+  return removed;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.cpp","additions":86,"deletions":9,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -140,0 +140,3 @@\n+  \/\/ Time-based shrinking helper: find and shrink oldest empty regions\n+  uint shrink_by_time_based_selection(uint num_regions_to_remove);\n+\n@@ -274,0 +277,1 @@\n+  uint shrink_by(uint num_regions_to_remove, bool use_time_based_selection);\n@@ -286,0 +290,4 @@\n+  \/\/ Reset access timestamps on all free regions to prevent stale timing data\n+  \/\/ Used after GC operations or shrink operations that may affect region state\n+\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#include \"gc\/g1\/g1_globals.hpp\"  \/\/ For flag declarations\n+#include \"gc\/g1\/g1CollectedHeap.hpp\"\n@@ -28,0 +30,3 @@\n+#include \"gc\/g1\/g1HeapRegion.hpp\"\n+#include \"gc\/g1\/g1HeapRegionManager.inline.hpp\"\n+#include \"gc\/g1\/g1Policy.hpp\"\n@@ -30,0 +35,1 @@\n+#include \"memory\/resourceArea.hpp\"\n@@ -31,0 +37,3 @@\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/safepoint.hpp\"\n@@ -33,0 +42,1 @@\n+#include \"utilities\/ticks.hpp\"\n@@ -439,0 +449,259 @@\n+\n+uint G1HeapSizingPolicy::count_uncommit_candidates() {\n+  uint inactive_regions = 0;\n+\n+  \/\/ Count regions that would be eligible for uncommit\n+  class CountUncommitCandidatesClosure : public G1HeapRegionClosure {\n+    uint* _inactive_regions;\n+    const G1HeapSizingPolicy* _policy;\n+  public:\n+    CountUncommitCandidatesClosure(uint* inactive_regions, const G1HeapSizingPolicy* policy) :\n+      _inactive_regions(inactive_regions),\n+      _policy(policy) {}\n+\n+    virtual bool do_heap_region(G1HeapRegion* r) {\n+      if (r->is_empty() && _policy->should_uncommit_region(r)) {\n+        (*_inactive_regions)++;\n+      }\n+      return false;\n+    }\n+  } cl(&inactive_regions, this);\n+\n+  log_debug(gc, sizing)(\"Full region scan: counting uncommit candidates\");\n+  _g1h->heap_region_iterate(&cl);\n+  return inactive_regions;\n+}\n+\n+void G1HeapSizingPolicy::find_uncommit_candidates_by_time(GrowableArray<G1HeapRegion*>* candidates, uint max_candidates) {\n+  uint inactive_regions = 0;\n+\n+  \/\/ Check each heap region for inactivity, limiting to max_candidates for efficiency\n+  class UncommitCandidatesClosure : public G1HeapRegionClosure {\n+    GrowableArray<G1HeapRegion*>* _candidates;\n+    uint* _inactive_regions;\n+    uint _max_candidates;\n+    const G1HeapSizingPolicy* _policy;\n+  public:\n+    UncommitCandidatesClosure(GrowableArray<G1HeapRegion*>* candidates,\n+                             uint* inactive_regions,\n+                             uint max_candidates,\n+                             const G1HeapSizingPolicy* policy) :\n+      _candidates(candidates),\n+      _inactive_regions(inactive_regions),\n+      _max_candidates(max_candidates),\n+      _policy(policy) {}\n+\n+    virtual bool do_heap_region(G1HeapRegion* r) {\n+      if (r->is_empty() && _policy->should_uncommit_region(r)) {\n+        _candidates->append(r);\n+        (*_inactive_regions)++;\n+        \/\/ Stop early if we have enough candidates\n+        if ((uint)_candidates->length() >= _max_candidates) {\n+          return true; \/\/ Stop iteration\n+        }\n+      }\n+      return false;\n+    }\n+  } cl(candidates, &inactive_regions, max_candidates, this);\n+\n+  _g1h->heap_region_iterate(&cl);\n+\n+  if (inactive_regions > 0) {\n+    log_debug(gc, sizing)(\"Time-based uncommit evaluation: found %u inactive regions (requested %u)\",\n+                         inactive_regions, max_candidates);\n+  }\n+}\n+\n+size_t G1HeapSizingPolicy::calculate_time_based_shrink_amount(uint max_regions_to_shrink) {\n+  ResourceMark rm;\n+\n+  GrowableArray<G1HeapRegion*> candidates(max_regions_to_shrink);\n+\n+  \/\/ Find time-based candidates\n+  find_uncommit_candidates_by_time(&candidates, max_regions_to_shrink);\n+\n+  if (candidates.length() == 0) {\n+    log_debug(gc, sizing)(\"Time-based shrink: no candidates found\");\n+    return 0;\n+  }\n+\n+  uint valid_candidates = 0;\n+  \/\/ Count valid candidates (must be available, empty, and free)\n+  for (int i = 0; i < candidates.length(); i++) {\n+    G1HeapRegion* hr = candidates.at(i);\n+    uint region_index = hr->hrm_index();\n+\n+    \/\/ Only count if region is ready for shrinking\n+    if (hr->is_empty() && hr->is_free()) {\n+      log_debug(gc, sizing)(\"Time-based shrink: identified region %u as candidate (last_access=\" UINT64_FORMAT \"ms ago)\",\n+                           region_index, (Ticks::now() - hr->last_access_time()).milliseconds());\n+      valid_candidates++;\n+    } else {\n+      log_debug(gc, sizing)(\"Time-based shrink: skipping region %u - not ready for shrinking \"\n+                           \"(empty=%s, free=%s)\",\n+                           region_index, hr->is_empty() ? \"true\" : \"false\", hr->is_free() ? \"true\" : \"false\");\n+    }\n+  }\n+\n+  size_t shrink_bytes = (size_t)valid_candidates * G1HeapRegion::GrainBytes;\n+\n+  if (valid_candidates > 0) {\n+    log_info(gc, sizing)(\"Time-based shrink: requesting %zuMB based on %u time-based candidates\",\n+                         shrink_bytes \/ M, valid_candidates);\n+  }\n+\n+  return shrink_bytes;\n+}\n+\n+bool G1HeapSizingPolicy::should_uncommit_region(G1HeapRegion* hr) const {\n+  \/\/ Note: Caller already guarantees hr->is_empty() is true\n+  \/\/ Empty regions should always be free and not in collection set in normal operation\n+\n+  Ticks current_time = Ticks::now();\n+  Ticks last_access = hr->last_access_time();\n+  Tickspan elapsed = current_time - last_access;\n+\n+  log_trace(gc, sizing)(\"Region %u uncommit check: elapsed=\" JLONG_FORMAT \"ms threshold=\" JLONG_FORMAT \"ms last_access=\" JLONG_FORMAT \" now=\" JLONG_FORMAT \" empty=%s\",\n+                     hr->hrm_index(), (jlong)elapsed.milliseconds(), (jlong)G1UncommitDelayMillis, last_access.value(), current_time.value(),\n+                     hr->is_empty() ? \"true\" : \"false\");\n+\n+  bool should_uncommit = elapsed.milliseconds() > G1UncommitDelayMillis;\n+  if (should_uncommit) {\n+    log_debug(gc, sizing)(\"Region state transition: transitioning from active to inactive\");\n+    log_debug(gc, sizing)(\"Region state transition: Region %u transitioning from active to inactive after \" JLONG_FORMAT \"ms idle\",\n+                  hr->hrm_index(), (jlong)elapsed.milliseconds());\n+  }\n+\n+  return should_uncommit;\n+}\n+\n+size_t G1HeapSizingPolicy::evaluate_heap_resize_for_uncommit() {\n+  if (!G1UseTimeBasedHeapSizing) {\n+    return 0;\n+  }\n+\n+  \/\/ Back off during allocation pressure - only evaluate when truly idle\n+  if (_analytics != nullptr) {\n+    double gc_time_ratio = _analytics->short_term_pause_time_ratio();\n+    if (gc_time_ratio > 0.05) { \/\/ 5% GC time still indicates pressure\n+      log_trace(gc, sizing)(\"Uncommit evaluation: skipping due to high GC overhead (%1.1f%%)\",\n+                           gc_time_ratio * 100.0);\n+      return 0;\n+    }\n+  }\n+\n+  \/\/ Must hold Heap_lock during heap resizing\n+  MutexLocker ml(Heap_lock);\n+\n+  ResourceMark rm; \/\/ Ensure GrowableArray resources are properly released\n+\n+  \/\/ Count regions eligible for uncommit (don't store them - VM operation will re-evaluate)\n+  uint inactive_count = count_uncommit_candidates();\n+  uint total_regions = _g1h->max_num_regions();\n+\n+  log_debug(gc, sizing)(\"Uncommit evaluation: found %u inactive candidates (min required: %zu)\",\n+                       inactive_count, (size_t)G1MinRegionsToUncommit);\n+\n+  \/\/ Need minimum number of inactive regions to proceed\n+  if (inactive_count >= G1MinRegionsToUncommit) {\n+    size_t region_size = G1HeapRegion::GrainBytes;\n+    size_t current_heap = _g1h->capacity();\n+    size_t min_heap = MAX2((size_t)InitialHeapSize, MinHeapSize);  \/\/ Never go below initial size\n+\n+    \/\/ Calculate maximum bytes we can uncommit while respecting min heap size\n+    size_t max_shrink_bytes = current_heap > min_heap ? current_heap - min_heap : 0;\n+\n+    log_trace(gc, sizing)(\"Uncommit evaluation: current_heap=%zuB min_heap=%zuB \"\n+                         \"region_size=%zuB max_shrink=%zuB initial_size=%zuB\",\n+                         current_heap, min_heap, region_size, max_shrink_bytes, InitialHeapSize);\n+\n+    if (max_shrink_bytes > 0 && region_size > 0) {\n+      \/\/ Conservative approach: only uncommit if we have significant excess\n+      \/\/ and preserve space for allocation without triggering GCs\n+\n+      size_t committed_regions = current_heap \/ region_size;\n+\n+      \/\/ Use G1's existing reserve calculation plus young generation requirements\n+      \/\/ G1 maintains a reserve (default 10% via G1ReservePercent) for allocation needs\n+      size_t young_gen_regions = _g1h->policy()->young_list_target_length();\n+      size_t total_regions = _g1h->max_num_regions();\n+      size_t g1_reserve_regions = (size_t)ceil((double)total_regions * G1ReservePercent \/ 100.0);\n+\n+      \/\/ Total regions we must keep available = young gen + G1's standard reserve\n+      size_t reserved_regions = young_gen_regions + g1_reserve_regions;\n+\n+      log_debug(gc, sizing)(\"Uncommit evaluation: regions analysis - committed=%zu, inactive=%u, \"\n+                           \"young_gen=%zu, g1_reserve=%zu, reserved_total=%zu\",\n+                           committed_regions, inactive_count, young_gen_regions, g1_reserve_regions,\n+                           reserved_regions);\n+\n+      \/\/ Conservative safety: ensure we always keep more than the reserved amount\n+      \/\/ This prevents expensive re-commits during the next GC or allocation burst\n+      \/\/ We add G1MinRegionsToUncommit as a small safety buffer beyond G1's standard reserves\n+      size_t min_regions_after_uncommit = reserved_regions + G1MinRegionsToUncommit;\n+\n+      if (committed_regions <= min_regions_after_uncommit) {\n+        log_debug(gc, sizing)(\"Time-based uncommit: insufficient excess regions for safe uncommit \"\n+                             \"(committed=%zu <= min_after_uncommit=%zu, reserved=%zu)\",\n+                             committed_regions, min_regions_after_uncommit, reserved_regions);\n+        log_info(gc, sizing)(\"Uncommit evaluation: no heap uncommit needed (insufficient excess regions)\");\n+        return 0; \/\/ Not enough excess to uncommit safely\n+      }\n+\n+      \/\/ Only uncommit regions beyond our conservative reserves\n+      \/\/ Limited by G1MinRegionsToUncommit to avoid thrashing\n+      size_t available_for_uncommit = inactive_count;\n+      if (available_for_uncommit < G1MinRegionsToUncommit) {\n+        log_debug(gc, sizing)(\"Time-based uncommit: below minimum threshold (%zu < %zu)\",\n+                             available_for_uncommit, (size_t)G1MinRegionsToUncommit);\n+        log_info(gc, sizing)(\"Uncommit evaluation: no heap uncommit needed (below minimum threshold)\");\n+        return 0;\n+      }\n+\n+      size_t max_inactive_regions = max_shrink_bytes \/ region_size;\n+\n+      \/\/ Be very conservative about how much to uncommit at once\n+      \/\/ Never uncommit more than a small fraction of committed regions\n+      size_t max_uncommit_at_once = MAX2((size_t)G1MinRegionsToUncommit, committed_regions \/ 8);\n+      size_t regions_to_uncommit = MIN3(available_for_uncommit, max_inactive_regions, max_uncommit_at_once);\n+\n+      size_t shrink_bytes = regions_to_uncommit * region_size;\n+      shrink_bytes = MIN2(shrink_bytes, current_heap - MinHeapSize);\n+\n+      if (current_heap - shrink_bytes < InitialHeapSize) {\n+        log_info(gc, sizing)(\"Uncommit evaluation: skipped, would reduce heap below initial size (%zuMB < %zuMB)\",\n+                            (current_heap - shrink_bytes) \/ M, InitialHeapSize \/ M);\n+        log_debug(gc, sizing)(\"Skipping uncommit - would reduce heap below initial size: \"\n+                             \"current=%zuB shrink=%zuB result=%zuB initial=%zuB min=%zuB\",\n+                             current_heap, shrink_bytes, current_heap - shrink_bytes,\n+                             InitialHeapSize, MinHeapSize);\n+        return 0;\n+      }\n+\n+      if (shrink_bytes > 0) {\n+        log_debug(gc, sizing)(\"Uncommit candidates found: %u inactive regions\", inactive_count);\n+        log_info(gc, sizing)(\"Uncommit evaluation: found %u inactive regions, uncommitting %zu regions (%zuMB)\",\n+                            inactive_count, regions_to_uncommit, shrink_bytes \/ M);\n+        log_debug(gc, sizing)(\"Uncommit evaluation: Found %u inactive regions out of %zu total regions, \"\n+                             \"target shrink: %zuB (max allowed: %zuB)\",\n+                             inactive_count, total_regions, shrink_bytes, max_shrink_bytes);\n+        log_debug(gc, sizing)(\"Region state transition: %zu regions selected for uncommit\",\n+                     regions_to_uncommit);\n+\n+        \/\/ Calculate shrink amount based on time-based candidates\n+        size_t time_based_shrink = calculate_time_based_shrink_amount((uint)regions_to_uncommit);\n+\n+        return time_based_shrink;\n+      }\n+\n+      return 0;\n+    }\n+  }\n+\n+  log_info(gc, sizing)(\"Uncommit evaluation: no heap uncommit needed \"\n+                      \"(inactive=%u min_required=%zu heap=%zuB min=%zuB)\",\n+                      inactive_count, (size_t)G1MinRegionsToUncommit,\n+                      _g1h->capacity(), MAX2((size_t)InitialHeapSize, MinHeapSize));\n+\n+  return 0;\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.cpp","additions":269,"deletions":0,"binary":false,"changes":269,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"gc\/g1\/g1_globals.hpp\"\n+#include \"gc\/g1\/g1HeapRegion.hpp\"\n@@ -30,0 +32,3 @@\n+#include \"runtime\/globals.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -31,0 +36,1 @@\n+#include \"utilities\/ticks.hpp\"\n@@ -96,1 +102,0 @@\n-public:\n@@ -98,0 +103,1 @@\n+public:\n@@ -110,0 +116,11 @@\n+  \/\/ Time-based sizing methods\n+  size_t evaluate_heap_resize_for_uncommit();\n+\n+  \/\/ Methods for time-based sizing analysis\n+  uint count_uncommit_candidates();\n+  void find_uncommit_candidates_by_time(GrowableArray<G1HeapRegion*>* candidates, uint max_candidates);\n+  bool should_uncommit_region(G1HeapRegion* hr) const;\n+\n+  \/\/ Mark specific time-based candidates as inactive for uncommitting\n+  size_t calculate_time_based_shrink_amount(uint max_regions_to_shrink);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.hpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -51,0 +51,7 @@\n+\n+  \/\/ Print a message about time-based heap sizing configuration.\n+  if (G1UseTimeBasedHeapSizing) {\n+    log_info_p(gc, init)(\"G1 Time-Based Heap Sizing enabled (uncommit-only)\");\n+    log_info_p(gc, init)(\"  Evaluation Interval: %zus, Uncommit Delay: %zus, Min Regions To Uncommit: %zu\",\n+                         G1TimeBasedEvaluationIntervalMillis \/ 1000, G1UncommitDelayMillis \/ 1000, G1MinRegionsToUncommit);\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1InitLogger.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -270,0 +270,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionToSpaceMapper.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/g1\/g1HeapSizingPolicy.hpp\"\n@@ -175,0 +176,10 @@\n+\n+void VM_G1ShrinkHeap::doit() {\n+  \/\/ Use the pre-evaluated shrink amount to avoid lock conflicts during safepoint\n+  \/\/ Re-evaluation during VM operation can cause Heap_lock violations\n+  log_debug(gc, ergo, heap)(\"VM_G1ShrinkHeap: executing shrink operation with %zuB\", _bytes);\n+  _g1h->shrink_with_time_based_selection(_bytes);\n+\n+  \/\/ Note: No timestamp reset needed - remaining free regions should continue aging naturally\n+  \/\/ from when they originally became free for accurate time-based selection\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+class G1CollectedHeap;\n+\n@@ -109,0 +111,13 @@\n+class VM_G1ShrinkHeap : public VM_Operation {\n+ private:\n+  G1CollectedHeap* _g1h;\n+  size_t _bytes;\n+ public:\n+  VM_G1ShrinkHeap(G1CollectedHeap* g1h, size_t bytes)\n+    : _g1h(g1h), _bytes(bytes) {}\n+  VMOp_Type type() const override { return VMOp_G1ShrinkHeap; }\n+  const char* name() const override { return \"G1ShrinkHeap\"; }\n+  bool is_gc_operation() const override { return true; }\n+  void doit() override;\n+};\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -374,0 +374,19 @@\n+  product(bool, G1UseTimeBasedHeapSizing, true, DIAGNOSTIC,                 \\\n+          \"Enable time-based heap sizing to uncommit memory from inactive \" \\\n+          \"regions independent of GC cycles\")                               \\\n+                                                                            \\\n+  product(uintx, G1TimeBasedEvaluationIntervalMillis, 60000, MANAGEABLE,    \\\n+          \"Interval in milliseconds between periodic heap-size evaluations \"\\\n+          \"when G1UseTimeBasedHeapSizing is enabled\")                       \\\n+          range(1000, LP64_ONLY(max_jlong) NOT_LP64(max_uintx \/ 2))         \\\n+                                                                            \\\n+  product(uintx, G1UncommitDelayMillis, 300000, MANAGEABLE,                 \\\n+          \"A region is considered inactive if it has not been accessed \"    \\\n+          \"within this many milliseconds\")                                  \\\n+          range(1000, LP64_ONLY(max_jlong) NOT_LP64(max_uintx \/ 2))         \\\n+                                                                            \\\n+  product(size_t, G1MinRegionsToUncommit, 10, DIAGNOSTIC,                   \\\n+          \"Minimum number of inactive regions required before G1 will \"     \\\n+          \"attempt to uncommit memory\")                                     \\\n+          range(1, max_uintx)                                               \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -182,0 +182,1 @@\n+  LOG_TAG(sizing) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+  template(G1ShrinkHeap)                          \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,252 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.g1;\n+\n+\/**\n+ * @test TestG1RegionUncommit\n+ * @requires vm.gc.G1\n+ * @summary Test that G1 uncommits regions based on time threshold\n+ * @bug 8357445\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\/sun.management\n+ * @run main\/othervm -XX:+UseG1GC -Xms8m -Xmx256m -XX:G1HeapRegionSize=1M\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:G1UncommitDelayMillis=3000 -XX:G1TimeBasedEvaluationIntervalMillis=2000\n+ *                   -XX:G1MinRegionsToUncommit=2\n+ *                   -Xlog:gc*,gc+sizing*=debug\n+ *                   gc.g1.TestG1RegionUncommit\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestG1RegionUncommit {\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ If no args, run the subprocess with log analysis\n+        if (args.length == 0) {\n+            testTimeBasedEvaluation();\n+            testMinimumHeapBoundary();\n+            testConcurrentAllocationUncommit();\n+        } else if (\"subprocess\".equals(args[0])) {\n+            \/\/ This is the subprocess that does the actual allocation\/deallocation\n+            runTimeBasedUncommitTest();\n+        } else if (\"minheap\".equals(args[0])) {\n+            runMinHeapBoundaryTest();\n+        } else if (\"concurrent\".equals(args[0])) {\n+            runConcurrentTest();\n+        }\n+    }\n+\n+    static void testTimeBasedEvaluation() throws Exception {\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+            \"-XX:+UseG1GC\",\n+            \"-Xms8m\", \"-Xmx256m\", \"-XX:G1HeapRegionSize=1M\",\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:G1UncommitDelayMillis=3000\", \"-XX:G1TimeBasedEvaluationIntervalMillis=2000\",\n+            \"-XX:G1MinRegionsToUncommit=2\",\n+            \"-Xlog:gc*,gc+sizing*=debug\",\n+            \"gc.g1.TestG1RegionUncommit\", \"subprocess\"\n+        );\n+\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        \/\/ Verify the uncommit evaluation logic is working\n+        output.shouldContain(\"G1 Time-Based Heap Sizing enabled (uncommit-only)\");\n+        output.shouldContain(\"Starting uncommit evaluation\");\n+        \n+        \/\/ The test should show either successful uncommit or reasons why uncommit didn't happen\n+        \/\/ Both are valid outcomes showing the evaluation system is working\n+        if (output.getStdout().contains(\"Region state transition:\") ||\n+            output.getStdout().contains(\"Uncommit evaluation: Found\") || \n+            output.getStdout().contains(\"Uncommit candidates found\") ||\n+            output.getStdout().contains(\"no heap uncommit needed\")) {\n+            \/\/ Test passed - evaluation system is working\n+            System.out.println(\"Time-based evaluation system is working\");\n+        } else {\n+            \/\/ If none of the expected evaluation messages appear, that's a failure\n+            output.shouldContain(\"Uncommit evaluation:\");\n+        }\n+\n+        output.shouldHaveExitValue(0);\n+        System.out.println(\"Test passed - time-based uncommit verified!\");\n+    }\n+\n+    static void runTimeBasedUncommitTest() throws Exception {\n+        final int allocSize = 64 * 1024 * 1024; \/\/ 64MB allocation - much larger than initial 8MB\n+        Object keepAlive;\n+        Object keepAlive2; \/\/ Keep some memory allocated to prevent full shrinkage\n+\n+        System.out.println(\"=== Testing G1 Time-Based Uncommit ===\");\n+\n+        \/\/ Phase 1: Allocate memory to force significant heap expansion\n+        System.out.println(\"Phase 1: Allocating large amount of memory\");\n+        keepAlive = new byte[allocSize];\n+\n+        \/\/ Phase 2: Keep some memory allocated, free the rest to create inactive regions\n+        \/\/ This ensures current_heap > min_heap so uncommit is possible\n+        System.out.println(\"Phase 2: Partially freeing memory, keeping some allocated\");\n+        keepAlive2 = new byte[24 * 1024 * 1024]; \/\/ Keep 24MB allocated\n+        keepAlive = null; \/\/ Free the 64MB, leaving regions available for uncommit\n+        System.gc();\n+        System.gc(); \/\/ Double GC to ensure the 64MB is cleaned up\n+\n+        \/\/ Phase 3: Wait for regions to become inactive and uncommit to occur\n+        System.out.println(\"Phase 3: Waiting for time-based uncommit...\");\n+\n+        \/\/ Wait long enough for:\n+        \/\/ 1. G1UncommitDelayMillis (3000ms) - regions to become inactive\n+        \/\/ 2. G1TimeBasedEvaluationIntervalMillis (2000ms) - evaluation to run\n+        \/\/ 3. Multiple evaluation cycles to ensure uncommit happens\n+        Thread.sleep(15000); \/\/ 15 seconds should be plenty\n+\n+        \/\/ Clean up remaining allocation\n+        keepAlive2 = null;\n+        System.gc();\n+\n+        System.out.println(\"=== Test completed ===\");\n+        Runtime.getRuntime().halt(0);\n+    }\n+\n+    static void testMinimumHeapBoundary() throws Exception {\n+        System.out.println(\"Testing minimum heap boundary conditions...\");\n+\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+            \"-XX:+UseG1GC\",\n+            \"-Xms32m\", \"-Xmx64m\",  \/\/ Small heap to test boundaries\n+            \"-XX:G1HeapRegionSize=1M\",\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:G1UncommitDelayMillis=2000\", \/\/ Short delay\n+            \"-XX:G1TimeBasedEvaluationIntervalMillis=1000\",\n+            \"-XX:G1MinRegionsToUncommit=1\",\n+            \"-Xlog:gc+sizing=debug,gc+task=debug\",\n+            \"gc.g1.TestG1RegionUncommit\", \"minheap\"\n+        );\n+\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        \/\/ Should not uncommit below initial heap size\n+        output.shouldHaveExitValue(0);\n+        System.out.println(\"Minimum heap boundary test passed!\");\n+    }\n+\n+    static void testConcurrentAllocationUncommit() throws Exception {\n+        System.out.println(\"Testing concurrent allocation and uncommit...\");\n+\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+            \"-XX:+UseG1GC\",\n+            \"-Xms64m\", \"-Xmx256m\",\n+            \"-XX:G1HeapRegionSize=1M\",\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:G1TimeBasedEvaluationIntervalMillis=1000\", \/\/ Frequent evaluation\n+            \"-XX:G1UncommitDelayMillis=2000\",\n+            \"-XX:G1MinRegionsToUncommit=2\",\n+            \"-Xlog:gc+sizing=debug,gc+task=debug\",\n+            \"gc.g1.TestG1RegionUncommit\", \"concurrent\"\n+        );\n+\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        \/\/ Should handle concurrent operations safely\n+        output.shouldHaveExitValue(0);\n+        System.out.println(\"Concurrent allocation\/uncommit test passed!\");\n+    }\n+\n+    static void runMinHeapBoundaryTest() throws Exception {\n+        System.out.println(\"=== Min Heap Boundary Test ===\");\n+\n+        List<byte[]> memory = new ArrayList<>();\n+\n+        \/\/ Allocate close to max\n+        for (int i = 0; i < 28; i++) { \/\/ 28MB, close to 32MB limit\n+            memory.add(new byte[1024 * 1024]);\n+        }\n+\n+        \/\/ Clear and wait for uncommit attempt\n+        memory.clear();\n+        System.gc();\n+        Thread.sleep(8000); \/\/ Wait longer than uncommit delay\n+\n+        System.out.println(\"MinHeapBoundaryTest completed\");\n+        Runtime.getRuntime().halt(0);\n+    }\n+\n+    static void runConcurrentTest() throws Exception {\n+        System.out.println(\"=== Concurrent Test ===\");\n+\n+        final List<byte[]> sharedMemory = new ArrayList<>();\n+        final boolean[] stopFlag = {false};\n+\n+        \/\/ Start allocation thread\n+        Thread allocThread = new Thread(() -> {\n+            int iterations = 0;\n+            while (!stopFlag[0] && iterations < 50) {\n+                try {\n+                    \/\/ Allocate\n+                    for (int j = 0; j < 5; j++) {\n+                        synchronized (sharedMemory) {\n+                            sharedMemory.add(new byte[1024 * 1024]); \/\/ 1MB\n+                        }\n+                        Thread.sleep(10);\n+                    }\n+\n+                    \/\/ Clear some\n+                    synchronized (sharedMemory) {\n+                        if (sharedMemory.size() > 10) {\n+                            for (int k = 0; k < 5; k++) {\n+                                if (!sharedMemory.isEmpty()) {\n+                                    sharedMemory.remove(0);\n+                                }\n+                            }\n+                        }\n+                    }\n+                    System.gc();\n+                    Thread.sleep(50);\n+                    iterations++;\n+                } catch (InterruptedException e) {\n+                    break;\n+                }\n+            }\n+        });\n+\n+        allocThread.start();\n+\n+        \/\/ Let it run for a while to trigger time-based evaluation\n+        Thread.sleep(8000);\n+\n+        stopFlag[0] = true;\n+        allocThread.join(2000);\n+\n+        synchronized (sharedMemory) {\n+            sharedMemory.clear();\n+        }\n+        System.gc();\n+\n+        System.out.println(\"ConcurrentTest completed\");\n+        Runtime.getRuntime().halt(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestG1RegionUncommit.java","additions":252,"deletions":0,"binary":false,"changes":252,"status":"added"},{"patch":"@@ -0,0 +1,186 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.g1;\n+\n+\/**\n+ * @test TestTimeBasedHeapConfig\n+ * @bug 8357445\n+ * @summary Test configuration settings and error conditions for time-based heap sizing\n+ * @requires vm.gc.G1\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\/sun.management\n+ * @run main\/othervm -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions\n+ *     -Xms16m -Xmx64m -XX:G1HeapRegionSize=1M\n+ *     -XX:G1TimeBasedEvaluationIntervalMillis=5000\n+ *     -XX:G1UncommitDelayMillis=10000\n+ *     -XX:G1MinRegionsToUncommit=2\n+ *     -Xlog:gc*,gc+sizing*=debug\n+ *     gc.g1.TestTimeBasedHeapConfig\n+ *\/\n+\n+import java.util.*;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestTimeBasedHeapConfig {\n+\n+    public static void main(String[] args) throws Exception {\n+        testConfigurationParameters();\n+        testBoundaryValues();\n+        testEdgeCaseConfigurations();\n+    }\n+\n+    static void testConfigurationParameters() throws Exception {\n+        \/\/ Test default settings\n+        verifyVMConfig(new String[] {\n+            \"-XX:+UseG1GC\",\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-Xms16m\", \"-Xmx64m\",\n+            \"-XX:G1HeapRegionSize=1M\",\n+            \"-Xlog:gc*,gc+sizing*=debug\",\n+            \"gc.g1.TestTimeBasedHeapConfig$BasicTest\"\n+        });\n+    }\n+\n+    private static void verifyVMConfig(String[] opts) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(opts);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    public static class BasicTest {\n+        private static final int MB = 1024 * 1024;\n+        private static ArrayList<byte[]> arrays = new ArrayList<>();\n+\n+        public static void main(String[] args) throws Exception {\n+            \/\/ Initial allocation\n+            allocateMemory(8); \/\/ 8MB\n+            System.gc();\n+            Thread.sleep(1000);\n+\n+            \/\/ Clean up\n+            arrays.clear();\n+            System.gc();\n+            Thread.sleep(2000);\n+\n+            System.out.println(\"Basic configuration test completed successfully\");\n+            Runtime.getRuntime().halt(0);\n+        }\n+\n+        static void allocateMemory(int mb) throws InterruptedException {\n+            for (int i = 0; i < mb; i++) {\n+                arrays.add(new byte[MB]);\n+                if (i % 2 == 0) Thread.sleep(10);\n+            }\n+        }\n+    }\n+\n+    static void testBoundaryValues() throws Exception {\n+        \/\/ Test minimum values\n+        verifyVMConfig(new String[] {\n+            \"-XX:+UseG1GC\",\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-Xms8m\", \"-Xmx32m\",\n+            \"-XX:G1HeapRegionSize=1M\",\n+            \"-XX:G1TimeBasedEvaluationIntervalMillis=1000\", \/\/ 1 second minimum\n+            \"-XX:G1UncommitDelayMillis=1000\", \/\/ 1 second minimum\n+            \"-XX:G1MinRegionsToUncommit=1\", \/\/ 1 region minimum\n+            \"-Xlog:gc*,gc+sizing*=debug\",\n+            \"gc.g1.TestTimeBasedHeapConfig$BoundaryTest\"\n+        });\n+\n+        \/\/ Test maximum reasonable values\n+        verifyVMConfig(new String[] {\n+            \"-XX:+UseG1GC\",\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-Xms32m\", \"-Xmx256m\",\n+            \"-XX:G1HeapRegionSize=1M\",\n+            \"-XX:G1TimeBasedEvaluationIntervalMillis=300000\", \/\/ 5 minutes\n+            \"-XX:G1UncommitDelayMillis=300000\", \/\/ 5 minutes\n+            \"-XX:G1MinRegionsToUncommit=50\", \/\/ 50 regions\n+            \"-Xlog:gc*,gc+sizing*=debug\",\n+            \"gc.g1.TestTimeBasedHeapConfig$BoundaryTest\"\n+        });\n+    }\n+\n+    static void testEdgeCaseConfigurations() throws Exception {\n+        \/\/ Test with very small heap (should still work)\n+        verifyVMConfig(new String[] {\n+            \"-XX:+UseG1GC\",\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-Xms4m\", \"-Xmx8m\", \/\/ Very small heap\n+            \"-XX:G1HeapRegionSize=1M\",\n+            \"-XX:G1TimeBasedEvaluationIntervalMillis=2000\",\n+            \"-XX:G1UncommitDelayMillis=3000\",\n+            \"-XX:G1MinRegionsToUncommit=1\",\n+            \"-Xlog:gc*,gc+sizing*=debug\",\n+            \"gc.g1.TestTimeBasedHeapConfig$SmallHeapTest\"\n+        });\n+    }\n+\n+    public static class BoundaryTest {\n+        private static final int MB = 1024 * 1024;\n+        private static ArrayList<byte[]> arrays = new ArrayList<>();\n+\n+        public static void main(String[] args) throws Exception {\n+            System.out.println(\"BoundaryTest: Starting\");\n+\n+            \/\/ Test with boundary conditions\n+            allocateMemory(4); \/\/ 4MB\n+            Thread.sleep(2000);\n+\n+            arrays.clear();\n+            System.gc();\n+            Thread.sleep(5000); \/\/ Wait for evaluation\n+\n+            System.out.println(\"BoundaryTest: Completed\");\n+            Runtime.getRuntime().halt(0);\n+        }\n+\n+        static void allocateMemory(int mb) throws InterruptedException {\n+            for (int i = 0; i < mb; i++) {\n+                arrays.add(new byte[MB]);\n+                Thread.sleep(10);\n+            }\n+        }\n+    }\n+\n+    public static class SmallHeapTest {\n+        public static void main(String[] args) throws Exception {\n+            System.out.println(\"SmallHeapTest: Starting with very small heap\");\n+\n+            \/\/ With 4-8MB heap, just allocate a small amount\n+            byte[] smallAlloc = new byte[1024 * 1024]; \/\/ 1MB\n+            Thread.sleep(2000);\n+\n+            smallAlloc = null;\n+            System.gc();\n+            Thread.sleep(5000);\n+\n+            System.out.println(\"SmallHeapTest: Completed\");\n+            Runtime.getRuntime().halt(0);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestTimeBasedHeapConfig.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"},{"patch":"@@ -0,0 +1,259 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.g1;\n+\n+\/**\n+ * @test TestTimeBasedHeapSizing\n+ * @bug 8357445\n+ * @summary Test time-based heap sizing functionality in G1\n+ * @requires vm.gc.G1\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\/sun.management\n+ * @run main\/othervm -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions\n+ *     -Xms32m -Xmx128m -XX:G1HeapRegionSize=1M\n+ *     -XX:G1TimeBasedEvaluationIntervalMillis=5000\n+ *     -XX:G1UncommitDelayMillis=10000\n+ *     -XX:G1MinRegionsToUncommit=2\n+ *     -Xlog:gc*,gc+sizing*=debug\n+ *     gc.g1.TestTimeBasedHeapSizing\n+ *\/\n+\n+import java.util.*;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestTimeBasedHeapSizing {\n+\n+    private static final String TEST_VM_OPTS = \"-XX:+UseG1GC \" +\n+        \"-XX:+UnlockDiagnosticVMOptions \" +\n+        \"-XX:G1TimeBasedEvaluationIntervalMillis=5000 \" +\n+        \"-XX:G1UncommitDelayMillis=10000 \" +\n+        \"-XX:G1MinRegionsToUncommit=2 \" +\n+        \"-XX:G1HeapRegionSize=1M \" +\n+        \"-Xmx128m -Xms32m \" +\n+        \"-Xlog:gc*,gc+sizing*=debug\";\n+\n+    public static void main(String[] args) throws Exception {\n+        testBasicFunctionality();\n+        testHumongousObjectHandling();\n+        testRapidAllocationCycles();\n+        testLargeHumongousObjects();\n+    }\n+\n+    static void testBasicFunctionality() throws Exception {\n+        String[] command = new String[TEST_VM_OPTS.split(\" \").length + 1];\n+        System.arraycopy(TEST_VM_OPTS.split(\" \"), 0, command, 0, TEST_VM_OPTS.split(\" \").length);\n+        command[command.length - 1] = \"gc.g1.TestTimeBasedHeapSizing$BasicFunctionalityTest\";\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(command);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        output.shouldContain(\"G1 Time-Based Heap Sizing enabled (uncommit-only)\");\n+        output.shouldContain(\"Starting uncommit evaluation\");\n+        output.shouldContain(\"Full region scan:\");\n+\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    public static class BasicFunctionalityTest {\n+        private static final int MB = 1024 * 1024;\n+        private static ArrayList<byte[]> arrays = new ArrayList<>();\n+\n+        public static void main(String[] args) throws Exception {\n+            System.out.println(\"BasicFunctionalityTest: Starting heap activity\");\n+\n+            \/\/ Create significant heap activity\n+            for (int cycle = 0; cycle < 3; cycle++) {\n+                System.out.println(\"Allocation cycle \" + cycle);\n+                allocateMemory(25);  \/\/ 25MB per cycle\n+                Thread.sleep(200);   \/\/ Brief pause\n+                clearMemory();\n+                System.gc();\n+                Thread.sleep(200);\n+            }\n+\n+            System.out.println(\"BasicFunctionalityTest: Starting idle period\");\n+\n+            \/\/ Sleep to allow time-based evaluation\n+            Thread.sleep(18000);  \/\/ 18 seconds\n+\n+            System.out.println(\"BasicFunctionalityTest: Completed idle period\");\n+\n+            \/\/ Final cleanup\n+            clearMemory();\n+            Thread.sleep(500);\n+\n+            System.out.println(\"BasicFunctionalityTest: Test completed\");\n+            Runtime.getRuntime().halt(0);\n+        }\n+\n+        static void allocateMemory(int mb) throws InterruptedException {\n+            for (int i = 0; i < mb; i++) {\n+                arrays.add(new byte[MB]);\n+                if (i % 4 == 0) Thread.sleep(10);\n+            }\n+        }\n+\n+        static void clearMemory() {\n+            arrays.clear();\n+            System.gc();\n+        }\n+    }\n+\n+    static void testHumongousObjectHandling() throws Exception {\n+        String[] command = new String[TEST_VM_OPTS.split(\" \").length + 1];\n+        System.arraycopy(TEST_VM_OPTS.split(\" \"), 0, command, 0, TEST_VM_OPTS.split(\" \").length);\n+        command[command.length - 1] = \"gc.g1.TestTimeBasedHeapSizing$HumongousObjectTest\";\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(command);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        output.shouldContain(\"Starting uncommit evaluation\");\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    static void testRapidAllocationCycles() throws Exception {\n+        String[] command = new String[TEST_VM_OPTS.split(\" \").length + 1];\n+        System.arraycopy(TEST_VM_OPTS.split(\" \"), 0, command, 0, TEST_VM_OPTS.split(\" \").length);\n+        command[command.length - 1] = \"gc.g1.TestTimeBasedHeapSizing$RapidCycleTest\";\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(command);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        output.shouldContain(\"Starting uncommit evaluation\");\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    static void testLargeHumongousObjects() throws Exception {\n+        System.out.println(\"Testing large humongous object activity tracking...\");\n+\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+            \"-XX:+UseG1GC\",\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-Xms64m\", \"-Xmx256m\",\n+            \"-XX:G1HeapRegionSize=1M\",\n+            \"-XX:G1UncommitDelayMillis=5000\",\n+            \"-XX:G1MinRegionsToUncommit=1\",\n+            \"-Xlog:gc*,gc+sizing*=debug\",\n+            \"gc.g1.TestTimeBasedHeapSizing$LargeHumongousTest\"\n+        );\n+\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        \/\/ Large humongous objects should not affect uncommit safety\n+        output.shouldContain(\"G1 Time-Based Heap Sizing enabled (uncommit-only)\");\n+        output.shouldHaveExitValue(0);\n+        System.out.println(\"Large humongous object test passed!\");\n+    }\n+\n+    public static class HumongousObjectTest {\n+        private static final int MB = 1024 * 1024;\n+        private static ArrayList<byte[]> humongousObjects = new ArrayList<>();\n+\n+        public static void main(String[] args) throws Exception {\n+            System.out.println(\"HumongousObjectTest: Starting\");\n+\n+            \/\/ Allocate humongous objects (> 512KB for 1MB regions)\n+            for (int i = 0; i < 8; i++) {\n+                humongousObjects.add(new byte[800 * 1024]); \/\/ 800KB humongous\n+                System.out.println(\"Allocated humongous object \" + (i + 1));\n+                Thread.sleep(200);\n+            }\n+\n+            \/\/ Keep them alive for a while\n+            Thread.sleep(3000);\n+\n+            \/\/ Clear and test uncommit behavior\n+            humongousObjects.clear();\n+            System.gc();\n+            Thread.sleep(12000); \/\/ Wait for uncommit delay\n+\n+            System.out.println(\"HumongousObjectTest: Test completed\");\n+            Runtime.getRuntime().halt(0);\n+        }\n+    }\n+\n+    public static class RapidCycleTest {\n+        private static final int MB = 1024 * 1024;\n+        private static ArrayList<byte[]> memory = new ArrayList<>();\n+\n+        public static void main(String[] args) throws Exception {\n+            System.out.println(\"RapidCycleTest: Starting\");\n+\n+            \/\/ Rapid allocation\/deallocation cycles\n+            for (int cycle = 0; cycle < 15; cycle++) {\n+                \/\/ Quick allocation\n+                for (int i = 0; i < 8; i++) {\n+                    memory.add(new byte[MB]); \/\/ 1MB\n+                }\n+\n+                \/\/ Quick deallocation\n+                memory.clear();\n+                System.gc();\n+\n+                \/\/ Brief pause\n+                Thread.sleep(100);\n+\n+                if (cycle % 5 == 0) {\n+                    System.out.println(\"Completed cycle \" + cycle);\n+                }\n+            }\n+\n+            \/\/ Final wait for time-based evaluation\n+            Thread.sleep(12000);\n+\n+            System.out.println(\"RapidCycleTest: Test completed\");\n+            Runtime.getRuntime().halt(0);\n+        }\n+    }\n+\n+    public static class LargeHumongousTest {\n+        public static void main(String[] args) throws Exception {\n+            System.out.println(\"=== Large Humongous Object Test ===\");\n+\n+            \/\/ Allocate several large humongous objects (multiple regions each)\n+            List<byte[]> humongousObjects = new ArrayList<>();\n+\n+            \/\/ Each region is 1MB, so allocate 2MB objects (humongous spanning multiple regions)\n+            for (int i = 0; i < 5; i++) {\n+                humongousObjects.add(new byte[2 * 1024 * 1024]);\n+                System.gc(); \/\/ Force potential region transitions\n+                Thread.sleep(100);\n+            }\n+\n+            \/\/ Hold some, release others to create mixed region states\n+            humongousObjects.remove(0);\n+            humongousObjects.remove(0);\n+            System.gc();\n+\n+            \/\/ Wait for time-based evaluation with humongous regions present\n+            Thread.sleep(8000);\n+\n+            \/\/ Clean up\n+            humongousObjects.clear();\n+            System.gc();\n+\n+            System.out.println(\"LargeHumongousTest: Test completed\");\n+            Runtime.getRuntime().halt(0);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestTimeBasedHeapSizing.java","additions":259,"deletions":0,"binary":false,"changes":259,"status":"added"},{"patch":"@@ -0,0 +1,361 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.g1;\n+\n+\/**\n+ * @test TestTimeBasedRegionTracking\n+ * @bug 8357445\n+ * @summary Test region activity tracking and state transitions for time-based heap sizing\n+ * @requires vm.gc.G1\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\/sun.management\n+ * @run main\/othervm\/timeout=120 -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions\n+ *      -Xms32m -Xmx128m -XX:G1HeapRegionSize=1M\n+ *      -XX:G1TimeBasedEvaluationIntervalMillis=5000\n+ *      -XX:G1UncommitDelayMillis=10000\n+ *      -XX:G1MinRegionsToUncommit=2\n+ *      -Xlog:gc*,gc+sizing*=debug gc.g1.TestTimeBasedRegionTracking\n+ *\/\n+\n+import java.util.*;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+public class TestTimeBasedRegionTracking {\n+\n+    private static final String TEST_VM_OPTS = \"-XX:+UseG1GC \" +\n+        \"-XX:+UnlockDiagnosticVMOptions \" +\n+        \"-XX:G1TimeBasedEvaluationIntervalMillis=5000 \" +\n+        \"-XX:G1UncommitDelayMillis=10000 \" +\n+        \"-XX:G1MinRegionsToUncommit=2 \" +\n+        \"-XX:G1HeapRegionSize=1M \" +\n+        \"-Xmx128m -Xms32m \" +\n+        \"-Xlog:gc*,gc+sizing*=debug\";\n+\n+    public static void main(String[] args) throws Exception {\n+        testRegionStateTransitions();\n+        testConcurrentRegionAccess();\n+        testRegionLifecycleEdgeCases();\n+        testSafepointRaceConditions();\n+    }\n+\n+    static void testRegionStateTransitions() throws Exception {\n+        String[] command = new String[TEST_VM_OPTS.split(\" \").length + 1];\n+        System.arraycopy(TEST_VM_OPTS.split(\" \"), 0, command, 0, TEST_VM_OPTS.split(\" \").length);\n+        command[command.length - 1] = \"gc.g1.TestTimeBasedRegionTracking$RegionTransitionTest\";\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(command);\n+        \n+        Process process = pb.start();\n+        OutputAnalyzer output = new OutputAnalyzer(process);\n+\n+        \/\/ Verify region state changes and basic functionality\n+        \/\/ Check for key log messages that indicate the feature is working\n+        if (output.getStdout().contains(\"Region state transition:\") || \n+            output.getStdout().contains(\"Uncommit candidates found:\") ||\n+            output.getStdout().contains(\"Starting uncommit evaluation\")) {\n+            System.out.println(\"Time-based evaluation system is working\");\n+        } else {\n+            \/\/ If none of the expected messages appear, that's a failure\n+            output.shouldContain(\"Starting uncommit evaluation\");\n+        }\n+\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    public static class RegionTransitionTest {\n+        private static final int MB = 1024 * 1024;\n+        private static ArrayList<byte[]> arrays = new ArrayList<>();\n+\n+        public static void main(String[] args) throws Exception {\n+            System.out.println(\"RegionTransitionTest: Starting\");\n+            \n+            \/\/ Phase 1: Active allocation\n+            allocateMemory(20); \/\/ Reduced from 32MB for faster execution\n+            System.gc();\n+\n+            \/\/ Phase 2: Idle period\n+            arrays.clear();\n+            System.gc();\n+            Thread.sleep(12000); \/\/ Reduced wait time - should still trigger uncommit\n+\n+            \/\/ Phase 3: Reallocation\n+            allocateMemory(10); \/\/ Smaller reallocation\n+            System.gc();\n+\n+            \/\/ Clean up and wait for final uncommit evaluation\n+            arrays = null;\n+            System.gc();\n+            Thread.sleep(1000); \/\/ Shorter final wait\n+            \n+            System.out.println(\"RegionTransitionTest: Test completed\");\n+            Runtime.getRuntime().halt(0);\n+        }\n+\n+        static void allocateMemory(int mb) throws InterruptedException {\n+            for (int i = 0; i < mb; i++) {\n+                arrays.add(new byte[MB]);\n+                if (i % 4 == 0) Thread.sleep(10);\n+            }\n+        }\n+    }\n+\n+    static void testConcurrentRegionAccess() throws Exception {\n+        String[] command = new String[TEST_VM_OPTS.split(\" \").length + 1];\n+        System.arraycopy(TEST_VM_OPTS.split(\" \"), 0, command, 0, TEST_VM_OPTS.split(\" \").length);\n+        command[command.length - 1] = \"gc.g1.TestTimeBasedRegionTracking$ConcurrentAccessTest\";\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(command);\n+        \n+        Process process = pb.start();\n+        OutputAnalyzer output = new OutputAnalyzer(process);\n+\n+        \/\/ Verify concurrent access is handled safely\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    static void testRegionLifecycleEdgeCases() throws Exception {\n+        String[] command = new String[TEST_VM_OPTS.split(\" \").length + 1];\n+        System.arraycopy(TEST_VM_OPTS.split(\" \"), 0, command, 0, TEST_VM_OPTS.split(\" \").length);\n+        command[command.length - 1] = \"gc.g1.TestTimeBasedRegionTracking$RegionLifecycleEdgeCaseTest\";\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(command);\n+        \n+        Process process = pb.start();\n+        OutputAnalyzer output = new OutputAnalyzer(process);\n+\n+        \/\/ Verify region lifecycle edge cases are handled\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    static void testSafepointRaceConditions() throws Exception {\n+        System.out.println(\"Testing safepoint and allocation race conditions...\");\n+\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+            \"-XX:+UseG1GC\",\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-Xms64m\", \"-Xmx256m\",\n+            \"-XX:G1HeapRegionSize=1M\",\n+            \"-XX:G1TimeBasedEvaluationIntervalMillis=5000\", \/\/ More reasonable interval\n+            \"-XX:G1UncommitDelayMillis=3000\", \/\/ Shorter delay for faster test\n+            \"-XX:G1MinRegionsToUncommit=1\",\n+            \"-Xlog:gc*,gc+sizing*=debug\",\n+            \"gc.g1.TestTimeBasedRegionTracking$SafepointRaceTest\"\n+        );\n+\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        \/\/ Should handle safepoint races without errors\n+        output.shouldContain(\"G1 Time-Based Heap Sizing enabled (uncommit-only)\");\n+        output.shouldHaveExitValue(0);\n+        System.out.println(\"Safepoint race conditions test passed!\");\n+    }\n+\n+    public static class ConcurrentAccessTest {\n+        private static final int MB = 1024 * 1024;\n+        private static final List<byte[]> sharedMemory = new ArrayList<>();\n+        private static volatile boolean stopThreads = false;\n+\n+        public static void main(String[] args) throws Exception {\n+            System.out.println(\"ConcurrentAccessTest: Starting\");\n+\n+            \/\/ Start multiple allocation threads\n+            Thread[] threads = new Thread[3];\n+            for (int t = 0; t < threads.length; t++) {\n+                final int threadId = t;\n+                threads[t] = new Thread(() -> {\n+                    int iterations = 0;\n+                    while (!stopThreads && iterations < 30) {\n+                        try {\n+                            \/\/ Allocate\n+                            for (int i = 0; i < 3; i++) {\n+                                synchronized (sharedMemory) {\n+                                    sharedMemory.add(new byte[512 * 1024]); \/\/ 512KB\n+                                }\n+                                Thread.sleep(10);\n+                            }\n+\n+                            \/\/ Clear some memory\n+                            synchronized (sharedMemory) {\n+                                if (sharedMemory.size() > 15) {\n+                                    for (int i = 0; i < 5; i++) {\n+                                        if (!sharedMemory.isEmpty()) {\n+                                            sharedMemory.remove(0);\n+                                        }\n+                                    }\n+                                }\n+                            }\n+\n+                            if (iterations % 10 == 0) {\n+                                System.gc();\n+                            }\n+\n+                            iterations++;\n+                            Thread.sleep(50);\n+                        } catch (InterruptedException e) {\n+                            break;\n+                        }\n+                    }\n+                    System.out.println(\"Thread \" + threadId + \" completed \" + iterations + \" iterations\");\n+                });\n+                threads[t].start();\n+            }\n+\n+            \/\/ Let threads run for a shorter time\n+            Thread.sleep(5000); \/\/ Reduced from 8000ms\n+\n+            stopThreads = true;\n+            for (Thread t : threads) {\n+                t.join(1000); \/\/ Reduced join timeout\n+            }\n+\n+            synchronized (sharedMemory) {\n+                sharedMemory.clear();\n+            }\n+            System.gc();\n+            Thread.sleep(1000); \/\/ Reduced from 3000ms\n+\n+            System.out.println(\"ConcurrentAccessTest: Test completed\");\n+            Runtime.getRuntime().halt(0);\n+        }\n+    }\n+\n+    public static class RegionLifecycleEdgeCaseTest {\n+        private static final int MB = 1024 * 1024;\n+        private static List<Object> memory = new ArrayList<>();\n+\n+        public static void main(String[] args) throws Exception {\n+            System.out.println(\"RegionLifecycleEdgeCaseTest: Starting\");\n+\n+            \/\/ Phase 1: Mixed allocation patterns\n+            \/\/ Small objects\n+            for (int i = 0; i < 100; i++) {\n+                memory.add(new byte[8 * 1024]); \/\/ 8KB objects\n+            }\n+\n+            \/\/ Medium objects\n+            for (int i = 0; i < 20; i++) {\n+                memory.add(new byte[40 * 1024]); \/\/ 40KB objects\n+            }\n+\n+            \/\/ Large objects (but not humongous)\n+            for (int i = 0; i < 5; i++) {\n+                memory.add(new byte[300 * 1024]); \/\/ 300KB objects\n+            }\n+\n+            Thread.sleep(2000);\n+\n+            \/\/ Phase 2: Create fragmentation by selective deallocation\n+            for (int i = memory.size() - 1; i >= 0; i -= 2) {\n+                memory.remove(i);\n+            }\n+\n+            System.gc();\n+            Thread.sleep(3000);\n+\n+            \/\/ Phase 3: Add humongous objects\n+            for (int i = 0; i < 3; i++) {\n+                memory.add(new byte[900 * 1024]); \/\/ 900KB humongous\n+                Thread.sleep(500);\n+            }\n+\n+            Thread.sleep(2000);\n+\n+            \/\/ Phase 4: Final cleanup\n+            memory.clear();\n+            System.gc();\n+            Thread.sleep(6000); \/\/ Reduced wait time but still allow for evaluation\n+\n+            System.out.println(\"RegionLifecycleEdgeCaseTest: Test completed\");\n+            Runtime.getRuntime().halt(0);\n+        }\n+    }\n+\n+    public static class SafepointRaceTest {\n+        public static void main(String[] args) throws Exception {\n+            System.out.println(\"=== Safepoint Race Conditions Test ===\");\n+\n+            final AtomicBoolean stopFlag = new AtomicBoolean(false);\n+            final List<byte[]> sharedMemory = Collections.synchronizedList(new ArrayList<>());\n+\n+            \/\/ Start fewer threads with reduced iterations for faster completion\n+            Thread[] threads = new Thread[2];\n+            for (int i = 0; i < threads.length; i++) {\n+                final int threadId = i;\n+                threads[i] = new Thread(() -> {\n+                    int iteration = 0;\n+                    while (!stopFlag.get() && iteration < 10) { \/\/ Reduced iterations\n+                        try {\n+                            \/\/ Allocate and deallocate\n+                            for (int j = 0; j < 3; j++) { \/\/ Fewer allocations per iteration\n+                                sharedMemory.add(new byte[256 * 1024]); \/\/ Smaller allocations\n+                            }\n+\n+                            \/\/ Force GC less frequently\n+                            if (iteration % 5 == 0) {\n+                                System.gc();\n+                            }\n+\n+                            \/\/ Clear some allocations\n+                            synchronized (sharedMemory) {\n+                                if (sharedMemory.size() > 6) {\n+                                    for (int k = 0; k < 2; k++) {\n+                                        if (!sharedMemory.isEmpty()) {\n+                                            sharedMemory.remove(0);\n+                                        }\n+                                    }\n+                                }\n+                            }\n+\n+                            Thread.sleep(50); \/\/ Shorter pause\n+                            iteration++;\n+                        } catch (InterruptedException e) {\n+                            break;\n+                        }\n+                    }\n+                    System.out.println(\"Thread \" + threadId + \" completed\");\n+                });\n+                threads[i].start();\n+            }\n+\n+            \/\/ Much shorter run time - just enough for one evaluation cycle\n+            Thread.sleep(4000);\n+\n+            \/\/ Stop threads\n+            stopFlag.set(true);\n+            for (Thread thread : threads) {\n+                thread.join(1000);\n+            }\n+\n+            \/\/ Clean up\n+            sharedMemory.clear();\n+            System.gc();\n+            \n+            \/\/ Wait for one more evaluation cycle to see some activity\n+            Thread.sleep(2000);\n+\n+            System.out.println(\"SafepointRaceTest: Test completed\");\n+            Runtime.getRuntime().halt(0);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestTimeBasedRegionTracking.java","additions":361,"deletions":0,"binary":false,"changes":361,"status":"added"}]}