{"files":[{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/safepoint.hpp\"\n@@ -205,1 +206,2 @@\n-  assert(Heap_lock->owner() != nullptr, \"Should be owned on this thread's behalf.\");\n+  assert(Heap_lock->owner() != nullptr || SafepointSynchronize::is_at_safepoint(),\n+         \"Should be owned on this thread's behalf or at safepoint.\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"gc\/g1\/g1HeapEvaluationTask.hpp\"\n@@ -114,0 +115,1 @@\n+#include \"runtime\/vmOperations.hpp\"\n@@ -1073,1 +1075,1 @@\n-                            shrink_bytes, shrunk_bytes, num_regions_removed);\n+                           shrink_bytes, shrunk_bytes, num_regions_removed);\n@@ -1075,0 +1077,6 @@\n+    log_info(gc, heap)(\"Heap shrink flagged: uncommitted %u regions (%zuMB), heap size now %zuMB\",\n+                       num_regions_removed, shrunk_bytes \/ M, capacity() \/ M);\n+    log_debug(gc, heap)(\"Heap shrink details: requested=%zuB attempted=%zuB actual=%zuB \"\n+                        \"regions_removed=%u heap_capacity=%zuB\",\n+                        shrink_bytes, num_regions_to_remove * G1HeapRegion::GrainBytes,\n+                        shrunk_bytes, num_regions_removed, capacity());\n@@ -1119,0 +1127,18 @@\n+bool G1CollectedHeap::request_heap_shrink(size_t shrink_bytes) {\n+  if (shrink_bytes == 0) {\n+    return false;\n+  }\n+\n+  \/\/ Fast path: if we are already at a safepoint (e.g. called from the\n+  \/\/ GC service thread) just do the work directly.\n+  if (SafepointSynchronize::is_at_safepoint()) {\n+    shrink(shrink_bytes);\n+    return true;                     \/\/ We did something.\n+  }\n+\n+  \/\/ Schedule a small VM-op so the work is done at the next safepoint\n+  VM_G1ShrinkHeap op(this, shrink_bytes);\n+  VMThread::execute(&op);\n+  return true;                       \/\/ Pages were at least requested to be released.\n+}\n+\n@@ -1222,0 +1248,2 @@\n+  _heap_evaluation_task = nullptr;\n+\n@@ -1475,0 +1503,9 @@\n+  \/\/ Create the heap evaluation task using PeriodicTask\n+  if (G1UseTimeBasedHeapSizing) {\n+    _heap_evaluation_task = new G1HeapEvaluationTask(this, _heap_sizing_policy);\n+    \/\/ PeriodicTask will be enrolled after G1 is fully initialized in post_initialize()\n+    log_debug(gc, init)(\"G1 Time-Based Heap Evaluation task created (PeriodicTask)\");\n+  } else {\n+    assert(_heap_evaluation_task == nullptr, \"pre-condition\");\n+  }\n+\n@@ -1534,0 +1571,6 @@\n+\n+  \/\/ Enroll the heap evaluation task after G1 is fully initialized\n+  if (G1UseTimeBasedHeapSizing) {\n+    _heap_evaluation_task->enroll();  \/\/ PeriodicTask enroll() starts the task\n+    log_debug(gc, init)(\"G1 Time-Based Heap Evaluation task enrolled (PeriodicTask)\");\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":44,"deletions":1,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"gc\/g1\/g1HeapEvaluationTask.hpp\"\n@@ -152,0 +153,1 @@\n+  friend class VM_G1ShrinkHeap;\n@@ -195,0 +197,2 @@\n+  G1HeapEvaluationTask* _heap_evaluation_task;\n+\n@@ -581,0 +585,4 @@\n+  \/\/ Request an immediate heap contraction of (at most) the given number of bytes.\n+  \/\/ Returns true if any pages were actually uncommitted.\n+  bool request_heap_shrink(size_t shrink_bytes);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"gc\/g1\/g1CollectedHeap.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n+#include \"gc\/g1\/g1HeapEvaluationTask.hpp\"\n+#include \"gc\/g1\/g1HeapSizingPolicy.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+G1HeapEvaluationTask::G1HeapEvaluationTask(G1CollectedHeap* g1h, G1HeapSizingPolicy* heap_sizing_policy) :\n+  PeriodicTask(G1TimeBasedEvaluationIntervalMillis),  \/\/ Use PeriodicTask with interval\n+  _g1h(g1h),\n+  _heap_sizing_policy(heap_sizing_policy) {\n+}\n+\n+void G1HeapEvaluationTask::task() {\n+  \/\/ This runs on WatcherThread during idle periods - perfect for uncommit evaluation!\n+  log_debug(gc, sizing)(\"Starting heap evaluation\");\n+\n+  if (!G1UseTimeBasedHeapSizing) {\n+    return;\n+  }\n+\n+  \/\/ Ensure we're not running during GC activity\n+  if (_g1h->is_stw_gc_active()) {\n+    log_trace(gc, sizing)(\"GC active, skipping uncommit evaluation\");\n+    return;\n+  }\n+\n+  ResourceMark rm; \/\/ Ensure temporary resources are released\n+\n+  bool should_expand = false;\n+  size_t resize_amount = _heap_sizing_policy->evaluate_heap_resize(should_expand);\n+\n+  if (resize_amount > 0) {\n+    \/\/ Uncommit-based sizing only handles shrinking, never expansion\n+    if (should_expand) {\n+      log_warning(gc, sizing)(\"Uncommit evaluation: unexpected expansion request ignored (resize_amount=%zuB)\", resize_amount);\n+      \/\/ This should not happen since uncommit-based policy only handles shrinking\n+      assert(false, \"Uncommit-based heap sizing should never request expansion\");\n+    } else {\n+      log_info(gc, sizing)(\"Uncommit evaluation: shrinking heap by %zuMB\", resize_amount \/ M);\n+      log_debug(gc, sizing)(\"Uncommit evaluation: policy recommends shrinking by %zuB\", resize_amount);\n+      _g1h->request_heap_shrink(resize_amount);\n+    }\n+  } else {\n+    \/\/ Periodic info log for ongoing evaluation activity (less frequent)\n+    static int evaluation_count = 0;\n+    if (++evaluation_count % 10 == 0) { \/\/ Log every 10th evaluation when no action taken\n+      log_info(gc, sizing)(\"Uncommit evaluation: no heap uncommit needed (evaluation #%d)\", evaluation_count);\n+    }\n+  }\n+\n+  \/\/ No need to schedule - PeriodicTask automatically reschedules itself!\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapEvaluationTask.cpp","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+ï»¿\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1HEAPEVALUATIONTASK_HPP\n+#define SHARE_GC_G1_G1HEAPEVALUATIONTASK_HPP\n+\n+#include \"runtime\/task.hpp\"\n+#include \"gc\/g1\/g1_globals.hpp\"\n+\n+class G1CollectedHeap;\n+class G1HeapSizingPolicy;\n+\n+\/\/ Time-based heap evaluation task that runs during idle periods.\n+\/\/ Uses PeriodicTask rather than G1ServiceTask due to build compatibility issues\n+\/\/ in JDK 25+. PeriodicTask's 10ms granularity is adequate for heap evaluation\n+\/\/ which typically runs on intervals of seconds or longer.\n+class G1HeapEvaluationTask : public PeriodicTask {\n+  G1CollectedHeap* _g1h;\n+  G1HeapSizingPolicy* _heap_sizing_policy;\n+\n+public:\n+  G1HeapEvaluationTask(G1CollectedHeap* g1h, G1HeapSizingPolicy* heap_sizing_policy);\n+  virtual void task() override;\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1HEAPEVALUATIONTASK_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapEvaluationTask.hpp","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -122,0 +122,1 @@\n+  record_activity(); \/\/ Update timestamp when region becomes available\n@@ -252,0 +253,1 @@\n+  _last_access_timestamp(Ticks::now()), \/\/ Initialize timestamp with current time\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -38,0 +40,1 @@\n+#include \"utilities\/ticks.hpp\"\n@@ -73,0 +76,1 @@\n+  friend class G1Allocator;  \/\/ For access to record_activity()\n@@ -74,0 +78,1 @@\n+private:\n@@ -252,0 +257,3 @@\n+  \/\/ Time-based heap sizing: tracks last allocation\/access time\n+  Ticks _last_access_timestamp;\n+\n@@ -553,0 +561,19 @@\n+  \/\/ Time-based heap sizing methods\n+  void record_activity() {\n+    _last_access_timestamp = Ticks::now();\n+  }\n+\n+  Ticks last_access_time() const {\n+    return _last_access_timestamp;\n+  }\n+\n+  \/\/ Returns true if the region has been inactive for longer than the uncommit delay\n+  bool should_uncommit(Tickspan delay) const {\n+    if (!is_empty()) {\n+      return false;\n+    }\n+    Ticks current_time = Ticks::now();\n+    Tickspan elapsed = current_time - _last_access_timestamp;\n+    return elapsed > delay;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.hpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n@@ -26,0 +27,2 @@\n+#include \"gc\/g1\/g1_globals.hpp\"  \/\/ For flag declarations\n+#include \"gc\/g1\/g1CollectedHeap.hpp\"\n@@ -28,0 +31,1 @@\n+#include \"gc\/g1\/g1HeapRegionManager.inline.hpp\"\n@@ -30,0 +34,1 @@\n+#include \"memory\/resourceArea.hpp\"\n@@ -31,0 +36,2 @@\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/os.hpp\"\n@@ -33,0 +40,1 @@\n+#include \"utilities\/ticks.hpp\"\n@@ -439,0 +447,147 @@\n+\n+void G1HeapSizingPolicy::get_uncommit_candidates(GrowableArray<G1HeapRegion*>* candidates) {\n+  uint inactive_regions = 0;\n+\n+  \/\/ Check each heap region for inactivity\n+  class UncommitCandidatesClosure : public G1HeapRegionClosure {\n+    GrowableArray<G1HeapRegion*>* _candidates;\n+    uint* _inactive_regions;\n+    const G1HeapSizingPolicy* _policy;\n+  public:\n+    UncommitCandidatesClosure(GrowableArray<G1HeapRegion*>* candidates,\n+                             uint* inactive_regions,\n+                             const G1HeapSizingPolicy* policy) :\n+      _candidates(candidates),\n+      _inactive_regions(inactive_regions),\n+      _policy(policy) {}\n+\n+    virtual bool do_heap_region(G1HeapRegion* r) {\n+      if (r->is_empty() && _policy->should_uncommit_region(r)) {\n+        _candidates->append(r);\n+        (*_inactive_regions)++;\n+      }\n+      return false;\n+    }\n+  } cl(candidates, &inactive_regions, this);\n+\n+  _g1h->heap_region_iterate(&cl);\n+\n+  if (inactive_regions > 0) {\n+    log_debug(gc, sizing)(\"Uncommit candidates found: %u inactive regions out of %u total regions\",\n+                  inactive_regions, _g1h->max_num_regions());\n+    log_debug(gc, sizing)(\"Region state transition: %u regions found eligible for uncommit after scan\",\n+                  inactive_regions);\n+  }\n+  log_debug(gc, sizing)(\"Full region scan: found %u inactive regions out of %u total regions\",\n+                       inactive_regions,\n+                       _g1h->max_num_regions());\n+}\n+\n+bool G1HeapSizingPolicy::should_uncommit_region(G1HeapRegion* hr) const {\n+  \/\/ Note: Caller already guarantees hr->is_empty() is true\n+  \/\/ Empty regions should always be free and not in collection set in normal operation\n+\n+  Ticks current_time = Ticks::now();\n+  Ticks last_access = hr->last_access_time();\n+  Tickspan elapsed = current_time - last_access;\n+\n+  log_trace(gc, sizing)(\"Region %u uncommit check: elapsed=\" JLONG_FORMAT \"ms threshold=\" JLONG_FORMAT \"ms last_access=\" JLONG_FORMAT \" now=\" JLONG_FORMAT \" empty=%s\",\n+                     hr->hrm_index(), (jlong)elapsed.milliseconds(), (jlong)G1UncommitDelayMillis, last_access.value(), current_time.value(),\n+                     hr->is_empty() ? \"true\" : \"false\");\n+\n+  bool should_uncommit = elapsed.milliseconds() > G1UncommitDelayMillis;\n+  if (should_uncommit) {\n+    log_debug(gc, sizing)(\"Region state transition: Region %u transitioning from active to inactive after \" JLONG_FORMAT \"ms idle\",\n+                  hr->hrm_index(), (jlong)elapsed.milliseconds());\n+  }\n+\n+  return should_uncommit;\n+}\n+\n+size_t G1HeapSizingPolicy::evaluate_heap_resize(bool& expand) {\n+  expand = false; \/\/ Time-based sizing only handles uncommit, never expansion\n+\n+  if (!G1UseTimeBasedHeapSizing) {\n+    return 0;\n+  }\n+\n+  \/\/ Don't resize during GC\n+  if (_g1h->is_stw_gc_active()) {\n+    return 0;\n+  }\n+\n+  \/\/ Must hold Heap_lock during heap resizing\n+  MutexLocker ml(Heap_lock);\n+\n+  ResourceMark rm; \/\/ Ensure GrowableArray resources are properly released\n+\n+  \/\/ Find regions eligible for uncommit\n+  GrowableArray<G1HeapRegion*> candidates;\n+  get_uncommit_candidates(&candidates);\n+\n+  uint inactive_count = candidates.length();\n+  uint total_regions = _g1h->max_num_regions();\n+\n+  \/\/ Need minimum number of inactive regions to proceed\n+  if (inactive_count >= G1MinRegionsToUncommit) {\n+    size_t region_size = G1HeapRegion::GrainBytes;\n+    size_t current_heap = _g1h->capacity();\n+    size_t min_heap = MAX2((size_t)InitialHeapSize, MinHeapSize);  \/\/ Never go below initial size\n+\n+    \/\/ Calculate maximum bytes we can uncommit while respecting min heap size\n+    size_t max_shrink_bytes = current_heap > min_heap ? current_heap - min_heap : 0;\n+\n+    log_trace(gc, sizing)(\"Uncommit evaluation: current_heap=%zuB min_heap=%zuB \"\n+                         \"region_size=%zuB max_shrink=%zuB initial_size=%zuB\",\n+                         current_heap, min_heap, region_size, max_shrink_bytes, InitialHeapSize);\n+\n+    if (max_shrink_bytes > 0 && region_size > 0) {\n+      size_t max_inactive_regions = max_shrink_bytes \/ region_size;\n+\n+      \/\/ Calculate maximum uncommit target as the smaller of:\n+      \/\/ 1. No more than 25% of inactive regions\n+      \/\/ 2. No more than 10% of total committed regions\n+      \/\/ 3. No more than max_shrink_bytes worth of regions\n+      size_t committed_regions = current_heap \/ region_size;\n+\n+      \/\/ Upper limits:\n+      size_t by_inactive = static_cast<size_t>(inactive_count) \/ 4;    \/\/ 25%\n+      size_t by_total = static_cast<size_t>(committed_regions) \/ 10;   \/\/ 10%\n+\n+      size_t regions_to_uncommit =\n+          MIN2(by_total, MIN2(by_inactive, max_inactive_regions));\n+\n+      size_t shrink_bytes = regions_to_uncommit * region_size;\n+      shrink_bytes = MIN2(shrink_bytes, current_heap - MinHeapSize);\n+\n+      if (current_heap - shrink_bytes < InitialHeapSize) {\n+        log_info(gc, sizing)(\"Uncommit evaluation: skipped, would reduce heap below initial size (%zuMB < %zuMB)\",\n+                            (current_heap - shrink_bytes) \/ M, InitialHeapSize \/ M);\n+        log_debug(gc, sizing)(\"Skipping uncommit - would reduce heap below initial size: \"\n+                             \"current=%zuB shrink=%zuB result=%zuB initial=%zuB min=%zuB\",\n+                             current_heap, shrink_bytes, current_heap - shrink_bytes,\n+                             InitialHeapSize, MinHeapSize);\n+        return 0;\n+      }\n+\n+      if (shrink_bytes > 0) {\n+        log_info(gc, sizing)(\"Uncommit evaluation: found %u inactive regions, uncommitting %zu regions (%zuMB)\",\n+                            inactive_count, regions_to_uncommit, shrink_bytes \/ M);\n+        log_debug(gc, sizing)(\"Uncommit evaluation: Found %u inactive regions out of %u total regions, \"\n+                             \"target shrink: %zuB (max allowed: %zuB)\",\n+                             inactive_count, total_regions, shrink_bytes, max_shrink_bytes);\n+        log_debug(gc, sizing)(\"Region state transition: %zu regions selected for uncommit\",\n+                     regions_to_uncommit);\n+      }\n+\n+      return shrink_bytes;\n+    }\n+  }\n+\n+  log_trace(gc, sizing)(\"Uncommit evaluation: no uncommit needed \"\n+                       \"(inactive=%u min_required=%zu heap=%zuB min=%zuB)\",\n+                       inactive_count, G1MinRegionsToUncommit,\n+                       _g1h->capacity(), MAX2((size_t)InitialHeapSize, MinHeapSize));\n+\n+  return 0;\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.cpp","additions":155,"deletions":0,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"gc\/g1\/g1_globals.hpp\"\n+#include \"gc\/g1\/g1HeapRegion.hpp\"\n@@ -30,0 +32,3 @@\n+#include \"runtime\/globals.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -31,0 +36,1 @@\n+#include \"utilities\/ticks.hpp\"\n@@ -96,1 +102,0 @@\n-public:\n@@ -98,0 +103,5 @@\n+  \/\/ Methods for time-based sizing\n+  void get_uncommit_candidates(GrowableArray<G1HeapRegion*>* candidates);\n+  bool should_uncommit_region(G1HeapRegion* hr) const;\n+\n+public:\n@@ -110,0 +120,3 @@\n+  \/\/ Time-based sizing methods\n+  size_t evaluate_heap_resize(bool& expand);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.hpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -51,0 +51,7 @@\n+\n+  \/\/ Print a message about time-based heap sizing configuration.\n+  if (G1UseTimeBasedHeapSizing) {\n+    log_info_p(gc, init)(\"G1 Time-Based Heap Sizing enabled (uncommit-only)\");\n+    log_info_p(gc, init)(\"  evaluation_interval=%zums, uncommit_delay=%zums, min_regions_to_uncommit=%zu\",\n+                         G1TimeBasedEvaluationIntervalMillis, G1UncommitDelayMillis, G1MinRegionsToUncommit);\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1InitLogger.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -173,0 +173,4 @@\n+\n+void VM_G1ShrinkHeap::doit() {\n+  _g1h->shrink(_bytes);\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+class G1CollectedHeap;\n+\n@@ -109,0 +111,13 @@\n+class VM_G1ShrinkHeap : public VM_Operation {\n+ private:\n+  G1CollectedHeap* _g1h;\n+  size_t _bytes;\n+ public:\n+  VM_G1ShrinkHeap(G1CollectedHeap* g1h, size_t bytes)\n+    : _g1h(g1h), _bytes(bytes) {}\n+  VMOp_Type type() const override { return VMOp_G1ShrinkHeap; }\n+  const char* name() const override { return \"G1ShrinkHeap\"; }\n+  bool is_gc_operation() const override { return true; }\n+  void doit() override;\n+};\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -373,0 +373,19 @@\n+  product(bool, G1UseTimeBasedHeapSizing, true, DIAGNOSTIC,                 \\\n+          \"Enable time-based heap sizing to uncommit memory from inactive \" \\\n+          \"regions independent of GC cycles\")                               \\\n+                                                                            \\\n+  product(uintx, G1TimeBasedEvaluationIntervalMillis, 60000, MANAGEABLE,    \\\n+          \"Interval in milliseconds between periodic heap-size evaluations \"\\\n+          \"when G1UseTimeBasedHeapSizing is enabled\")                       \\\n+          range(1000, LP64_ONLY(max_jlong) NOT_LP64(max_uintx \/ 2))         \\\n+                                                                            \\\n+  product(uintx, G1UncommitDelayMillis, 300000, MANAGEABLE,                 \\\n+          \"A region is considered inactive if it has not been accessed \"    \\\n+          \"within this many milliseconds\")                                  \\\n+          range(1000, LP64_ONLY(max_jlong) NOT_LP64(max_uintx \/ 2))         \\\n+                                                                            \\\n+  product(size_t, G1MinRegionsToUncommit, 10, DIAGNOSTIC,                   \\\n+          \"Minimum number of inactive regions required before G1 will \"     \\\n+          \"attempt to uncommit memory\")                                     \\\n+          range(1, max_uintx)                                               \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -181,0 +181,1 @@\n+  LOG_TAG(sizing) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+  template(G1ShrinkHeap)                          \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,244 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.g1;\n+\n+\/**\n+ * @test TestG1RegionUncommit\n+ * @requires vm.gc.G1\n+ * @summary Test that G1 uncommits regions based on time threshold\n+ * @bug 8357445\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\/sun.management\n+ * @run main\/othervm -XX:+UseG1GC -Xms8m -Xmx256m -XX:G1HeapRegionSize=1M\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:G1UncommitDelayMillis=3000 -XX:G1TimeBasedEvaluationIntervalMillis=2000\n+ *                   -XX:G1MinRegionsToUncommit=2\n+ *                   -Xlog:gc*,gc+sizing*=debug\n+ *                   gc.g1.TestG1RegionUncommit\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestG1RegionUncommit {\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ If no args, run the subprocess with log analysis\n+        if (args.length == 0) {\n+            testTimeBasedEvaluation();\n+            testMinimumHeapBoundary();\n+            testConcurrentAllocationUncommit();\n+        } else if (\"subprocess\".equals(args[0])) {\n+            \/\/ This is the subprocess that does the actual allocation\/deallocation\n+            runTimeBasedUncommitTest();\n+        } else if (\"minheap\".equals(args[0])) {\n+            runMinHeapBoundaryTest();\n+        } else if (\"concurrent\".equals(args[0])) {\n+            runConcurrentTest();\n+        }\n+    }\n+\n+    static void testTimeBasedEvaluation() throws Exception {\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+            \"-XX:+UseG1GC\",\n+            \"-Xms8m\", \"-Xmx256m\", \"-XX:G1HeapRegionSize=1M\",\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:G1UncommitDelayMillis=3000\", \"-XX:G1TimeBasedEvaluationIntervalMillis=2000\",\n+            \"-XX:G1MinRegionsToUncommit=2\",\n+            \"-Xlog:gc*,gc+sizing*=debug\",\n+            \"gc.g1.TestG1RegionUncommit\", \"subprocess\"\n+        );\n+\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        \/\/ Verify the uncommit evaluation logic is working\n+        output.shouldContain(\"G1 Time-Based Heap Sizing enabled (uncommit-only)\");\n+        output.shouldContain(\"Starting heap evaluation\");\n+        output.shouldContain(\"Region state transition:\");\n+        output.shouldContain(\"transitioning from active to inactive\");\n+        output.shouldContain(\"Uncommit candidates found:\");\n+        output.shouldContain(\"Uncommit evaluation: Found\");\n+        output.shouldContain(\"target shrink:\");\n+\n+        output.shouldHaveExitValue(0);\n+        System.out.println(\"Test passed - time-based uncommit verified!\");\n+    }\n+\n+    static void runTimeBasedUncommitTest() throws Exception {\n+        final int allocSize = 64 * 1024 * 1024; \/\/ 64MB allocation - much larger than initial 8MB\n+        Object keepAlive;\n+        Object keepAlive2; \/\/ Keep some memory allocated to prevent full shrinkage\n+\n+        System.out.println(\"=== Testing G1 Time-Based Uncommit ===\");\n+\n+        \/\/ Phase 1: Allocate memory to force significant heap expansion\n+        System.out.println(\"Phase 1: Allocating large amount of memory\");\n+        keepAlive = new byte[allocSize];\n+\n+        \/\/ Phase 2: Keep some memory allocated, free the rest to create inactive regions\n+        \/\/ This ensures current_heap > min_heap so uncommit is possible\n+        System.out.println(\"Phase 2: Partially freeing memory, keeping some allocated\");\n+        keepAlive2 = new byte[24 * 1024 * 1024]; \/\/ Keep 24MB allocated\n+        keepAlive = null; \/\/ Free the 64MB, leaving regions available for uncommit\n+        System.gc();\n+        System.gc(); \/\/ Double GC to ensure the 64MB is cleaned up\n+\n+        \/\/ Phase 3: Wait for regions to become inactive and uncommit to occur\n+        System.out.println(\"Phase 3: Waiting for time-based uncommit...\");\n+\n+        \/\/ Wait long enough for:\n+        \/\/ 1. G1UncommitDelayMillis (3000ms) - regions to become inactive\n+        \/\/ 2. G1TimeBasedEvaluationIntervalMillis (2000ms) - evaluation to run\n+        \/\/ 3. Multiple evaluation cycles to ensure uncommit happens\n+        Thread.sleep(15000); \/\/ 15 seconds should be plenty\n+\n+        \/\/ Clean up remaining allocation\n+        keepAlive2 = null;\n+        System.gc();\n+\n+        System.out.println(\"=== Test completed ===\");\n+        Runtime.getRuntime().halt(0);\n+    }\n+\n+    static void testMinimumHeapBoundary() throws Exception {\n+        System.out.println(\"Testing minimum heap boundary conditions...\");\n+\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+            \"-XX:+UseG1GC\",\n+            \"-Xms32m\", \"-Xmx64m\",  \/\/ Small heap to test boundaries\n+            \"-XX:G1HeapRegionSize=1M\",\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:G1UncommitDelayMillis=2000\", \/\/ Short delay\n+            \"-XX:G1TimeBasedEvaluationIntervalMillis=1000\",\n+            \"-XX:G1MinRegionsToUncommit=1\",\n+            \"-Xlog:gc+sizing=debug,gc+task=debug\",\n+            \"gc.g1.TestG1RegionUncommit\", \"minheap\"\n+        );\n+\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        \/\/ Should not uncommit below initial heap size\n+        output.shouldHaveExitValue(0);\n+        System.out.println(\"Minimum heap boundary test passed!\");\n+    }\n+\n+    static void testConcurrentAllocationUncommit() throws Exception {\n+        System.out.println(\"Testing concurrent allocation and uncommit...\");\n+\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+            \"-XX:+UseG1GC\",\n+            \"-Xms64m\", \"-Xmx256m\",\n+            \"-XX:G1HeapRegionSize=1M\",\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:G1TimeBasedEvaluationIntervalMillis=1000\", \/\/ Frequent evaluation\n+            \"-XX:G1UncommitDelayMillis=2000\",\n+            \"-XX:G1MinRegionsToUncommit=2\",\n+            \"-Xlog:gc+sizing=debug,gc+task=debug\",\n+            \"gc.g1.TestG1RegionUncommit\", \"concurrent\"\n+        );\n+\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        \/\/ Should handle concurrent operations safely\n+        output.shouldHaveExitValue(0);\n+        System.out.println(\"Concurrent allocation\/uncommit test passed!\");\n+    }\n+\n+    static void runMinHeapBoundaryTest() throws Exception {\n+        System.out.println(\"=== Min Heap Boundary Test ===\");\n+\n+        List<byte[]> memory = new ArrayList<>();\n+\n+        \/\/ Allocate close to max\n+        for (int i = 0; i < 28; i++) { \/\/ 28MB, close to 32MB limit\n+            memory.add(new byte[1024 * 1024]);\n+        }\n+\n+        \/\/ Clear and wait for uncommit attempt\n+        memory.clear();\n+        System.gc();\n+        Thread.sleep(8000); \/\/ Wait longer than uncommit delay\n+\n+        System.out.println(\"MinHeapBoundaryTest completed\");\n+        Runtime.getRuntime().halt(0);\n+    }\n+\n+    static void runConcurrentTest() throws Exception {\n+        System.out.println(\"=== Concurrent Test ===\");\n+\n+        final List<byte[]> sharedMemory = new ArrayList<>();\n+        final boolean[] stopFlag = {false};\n+\n+        \/\/ Start allocation thread\n+        Thread allocThread = new Thread(() -> {\n+            int iterations = 0;\n+            while (!stopFlag[0] && iterations < 50) {\n+                try {\n+                    \/\/ Allocate\n+                    for (int j = 0; j < 5; j++) {\n+                        synchronized (sharedMemory) {\n+                            sharedMemory.add(new byte[1024 * 1024]); \/\/ 1MB\n+                        }\n+                        Thread.sleep(10);\n+                    }\n+\n+                    \/\/ Clear some\n+                    synchronized (sharedMemory) {\n+                        if (sharedMemory.size() > 10) {\n+                            for (int k = 0; k < 5; k++) {\n+                                if (!sharedMemory.isEmpty()) {\n+                                    sharedMemory.remove(0);\n+                                }\n+                            }\n+                        }\n+                    }\n+                    System.gc();\n+                    Thread.sleep(50);\n+                    iterations++;\n+                } catch (InterruptedException e) {\n+                    break;\n+                }\n+            }\n+        });\n+\n+        allocThread.start();\n+\n+        \/\/ Let it run for a while to trigger time-based evaluation\n+        Thread.sleep(8000);\n+\n+        stopFlag[0] = true;\n+        allocThread.join(2000);\n+\n+        synchronized (sharedMemory) {\n+            sharedMemory.clear();\n+        }\n+        System.gc();\n+\n+        System.out.println(\"ConcurrentTest completed\");\n+        Runtime.getRuntime().halt(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestG1RegionUncommit.java","additions":244,"deletions":0,"binary":false,"changes":244,"status":"added"},{"patch":"@@ -0,0 +1,186 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.g1;\n+\n+\/**\n+ * @test TestTimeBasedHeapConfig\n+ * @bug 8357445\n+ * @summary Test configuration settings and error conditions for time-based heap sizing\n+ * @requires vm.gc.G1\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\/sun.management\n+ * @run main\/othervm -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions\n+ *     -Xms16m -Xmx64m -XX:G1HeapRegionSize=1M\n+ *     -XX:G1TimeBasedEvaluationIntervalMillis=5000\n+ *     -XX:G1UncommitDelayMillis=10000\n+ *     -XX:G1MinRegionsToUncommit=2\n+ *     -Xlog:gc*,gc+sizing*=debug\n+ *     gc.g1.TestTimeBasedHeapConfig\n+ *\/\n+\n+import java.util.*;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestTimeBasedHeapConfig {\n+\n+    public static void main(String[] args) throws Exception {\n+        testConfigurationParameters();\n+        testBoundaryValues();\n+        testEdgeCaseConfigurations();\n+    }\n+\n+    static void testConfigurationParameters() throws Exception {\n+        \/\/ Test default settings\n+        verifyVMConfig(new String[] {\n+            \"-XX:+UseG1GC\",\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-Xms16m\", \"-Xmx64m\",\n+            \"-XX:G1HeapRegionSize=1M\",\n+            \"-Xlog:gc*,gc+sizing*=debug\",\n+            \"gc.g1.TestTimeBasedHeapConfig$BasicTest\"\n+        });\n+    }\n+\n+    private static void verifyVMConfig(String[] opts) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(opts);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    public static class BasicTest {\n+        private static final int MB = 1024 * 1024;\n+        private static ArrayList<byte[]> arrays = new ArrayList<>();\n+\n+        public static void main(String[] args) throws Exception {\n+            \/\/ Initial allocation\n+            allocateMemory(8); \/\/ 8MB\n+            System.gc();\n+            Thread.sleep(1000);\n+\n+            \/\/ Clean up\n+            arrays.clear();\n+            System.gc();\n+            Thread.sleep(2000);\n+\n+            System.out.println(\"Basic configuration test completed successfully\");\n+            Runtime.getRuntime().halt(0);\n+        }\n+\n+        static void allocateMemory(int mb) throws InterruptedException {\n+            for (int i = 0; i < mb; i++) {\n+                arrays.add(new byte[MB]);\n+                if (i % 2 == 0) Thread.sleep(10);\n+            }\n+        }\n+    }\n+\n+    static void testBoundaryValues() throws Exception {\n+        \/\/ Test minimum values\n+        verifyVMConfig(new String[] {\n+            \"-XX:+UseG1GC\",\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-Xms8m\", \"-Xmx32m\",\n+            \"-XX:G1HeapRegionSize=1M\",\n+            \"-XX:G1TimeBasedEvaluationIntervalMillis=1000\", \/\/ 1 second minimum\n+            \"-XX:G1UncommitDelayMillis=1000\", \/\/ 1 second minimum\n+            \"-XX:G1MinRegionsToUncommit=1\", \/\/ 1 region minimum\n+            \"-Xlog:gc*,gc+sizing*=debug\",\n+            \"gc.g1.TestTimeBasedHeapConfig$BoundaryTest\"\n+        });\n+\n+        \/\/ Test maximum reasonable values\n+        verifyVMConfig(new String[] {\n+            \"-XX:+UseG1GC\",\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-Xms32m\", \"-Xmx256m\",\n+            \"-XX:G1HeapRegionSize=1M\",\n+            \"-XX:G1TimeBasedEvaluationIntervalMillis=300000\", \/\/ 5 minutes\n+            \"-XX:G1UncommitDelayMillis=300000\", \/\/ 5 minutes\n+            \"-XX:G1MinRegionsToUncommit=50\", \/\/ 50 regions\n+            \"-Xlog:gc*,gc+sizing*=debug\",\n+            \"gc.g1.TestTimeBasedHeapConfig$BoundaryTest\"\n+        });\n+    }\n+\n+    static void testEdgeCaseConfigurations() throws Exception {\n+        \/\/ Test with very small heap (should still work)\n+        verifyVMConfig(new String[] {\n+            \"-XX:+UseG1GC\",\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-Xms4m\", \"-Xmx8m\", \/\/ Very small heap\n+            \"-XX:G1HeapRegionSize=1M\",\n+            \"-XX:G1TimeBasedEvaluationIntervalMillis=2000\",\n+            \"-XX:G1UncommitDelayMillis=3000\",\n+            \"-XX:G1MinRegionsToUncommit=1\",\n+            \"-Xlog:gc*,gc+sizing*=debug\",\n+            \"gc.g1.TestTimeBasedHeapConfig$SmallHeapTest\"\n+        });\n+    }\n+\n+    public static class BoundaryTest {\n+        private static final int MB = 1024 * 1024;\n+        private static ArrayList<byte[]> arrays = new ArrayList<>();\n+\n+        public static void main(String[] args) throws Exception {\n+            System.out.println(\"BoundaryTest: Starting\");\n+\n+            \/\/ Test with boundary conditions\n+            allocateMemory(4); \/\/ 4MB\n+            Thread.sleep(2000);\n+\n+            arrays.clear();\n+            System.gc();\n+            Thread.sleep(5000); \/\/ Wait for evaluation\n+\n+            System.out.println(\"BoundaryTest: Completed\");\n+            Runtime.getRuntime().halt(0);\n+        }\n+\n+        static void allocateMemory(int mb) throws InterruptedException {\n+            for (int i = 0; i < mb; i++) {\n+                arrays.add(new byte[MB]);\n+                Thread.sleep(10);\n+            }\n+        }\n+    }\n+\n+    public static class SmallHeapTest {\n+        public static void main(String[] args) throws Exception {\n+            System.out.println(\"SmallHeapTest: Starting with very small heap\");\n+\n+            \/\/ With 4-8MB heap, just allocate a small amount\n+            byte[] smallAlloc = new byte[1024 * 1024]; \/\/ 1MB\n+            Thread.sleep(2000);\n+\n+            smallAlloc = null;\n+            System.gc();\n+            Thread.sleep(5000);\n+\n+            System.out.println(\"SmallHeapTest: Completed\");\n+            Runtime.getRuntime().halt(0);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestTimeBasedHeapConfig.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"},{"patch":"@@ -0,0 +1,259 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.g1;\n+\n+\/**\n+ * @test TestTimeBasedHeapSizing\n+ * @bug 8357445\n+ * @summary Test time-based heap sizing functionality in G1\n+ * @requires vm.gc.G1\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\/sun.management\n+ * @run main\/othervm -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions\n+ *     -Xms32m -Xmx128m -XX:G1HeapRegionSize=1M\n+ *     -XX:G1TimeBasedEvaluationIntervalMillis=5000\n+ *     -XX:G1UncommitDelayMillis=10000\n+ *     -XX:G1MinRegionsToUncommit=2\n+ *     -Xlog:gc*,gc+sizing*=debug\n+ *     gc.g1.TestTimeBasedHeapSizing\n+ *\/\n+\n+import java.util.*;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestTimeBasedHeapSizing {\n+\n+    private static final String TEST_VM_OPTS = \"-XX:+UseG1GC \" +\n+        \"-XX:+UnlockDiagnosticVMOptions \" +\n+        \"-XX:G1TimeBasedEvaluationIntervalMillis=5000 \" +\n+        \"-XX:G1UncommitDelayMillis=10000 \" +\n+        \"-XX:G1MinRegionsToUncommit=2 \" +\n+        \"-XX:G1HeapRegionSize=1M \" +\n+        \"-Xmx128m -Xms32m \" +\n+        \"-Xlog:gc*,gc+sizing*=debug\";\n+\n+    public static void main(String[] args) throws Exception {\n+        testBasicFunctionality();\n+        testHumongousObjectHandling();\n+        testRapidAllocationCycles();\n+        testLargeHumongousObjects();\n+    }\n+\n+    static void testBasicFunctionality() throws Exception {\n+        String[] command = new String[TEST_VM_OPTS.split(\" \").length + 1];\n+        System.arraycopy(TEST_VM_OPTS.split(\" \"), 0, command, 0, TEST_VM_OPTS.split(\" \").length);\n+        command[command.length - 1] = \"gc.g1.TestTimeBasedHeapSizing$BasicFunctionalityTest\";\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(command);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        output.shouldContain(\"G1 Time-Based Heap Sizing enabled (uncommit-only)\");\n+        output.shouldContain(\"Starting heap evaluation\");\n+        output.shouldContain(\"Full region scan:\");\n+\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    public static class BasicFunctionalityTest {\n+        private static final int MB = 1024 * 1024;\n+        private static ArrayList<byte[]> arrays = new ArrayList<>();\n+\n+        public static void main(String[] args) throws Exception {\n+            System.out.println(\"BasicFunctionalityTest: Starting heap activity\");\n+\n+            \/\/ Create significant heap activity\n+            for (int cycle = 0; cycle < 3; cycle++) {\n+                System.out.println(\"Allocation cycle \" + cycle);\n+                allocateMemory(25);  \/\/ 25MB per cycle\n+                Thread.sleep(200);   \/\/ Brief pause\n+                clearMemory();\n+                System.gc();\n+                Thread.sleep(200);\n+            }\n+\n+            System.out.println(\"BasicFunctionalityTest: Starting idle period\");\n+\n+            \/\/ Sleep to allow time-based evaluation\n+            Thread.sleep(18000);  \/\/ 18 seconds\n+\n+            System.out.println(\"BasicFunctionalityTest: Completed idle period\");\n+\n+            \/\/ Final cleanup\n+            clearMemory();\n+            Thread.sleep(500);\n+\n+            System.out.println(\"BasicFunctionalityTest: Test completed\");\n+            Runtime.getRuntime().halt(0);\n+        }\n+\n+        static void allocateMemory(int mb) throws InterruptedException {\n+            for (int i = 0; i < mb; i++) {\n+                arrays.add(new byte[MB]);\n+                if (i % 4 == 0) Thread.sleep(10);\n+            }\n+        }\n+\n+        static void clearMemory() {\n+            arrays.clear();\n+            System.gc();\n+        }\n+    }\n+\n+    static void testHumongousObjectHandling() throws Exception {\n+        String[] command = new String[TEST_VM_OPTS.split(\" \").length + 1];\n+        System.arraycopy(TEST_VM_OPTS.split(\" \"), 0, command, 0, TEST_VM_OPTS.split(\" \").length);\n+        command[command.length - 1] = \"gc.g1.TestTimeBasedHeapSizing$HumongousObjectTest\";\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(command);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        output.shouldContain(\"Starting heap evaluation\");\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    static void testRapidAllocationCycles() throws Exception {\n+        String[] command = new String[TEST_VM_OPTS.split(\" \").length + 1];\n+        System.arraycopy(TEST_VM_OPTS.split(\" \"), 0, command, 0, TEST_VM_OPTS.split(\" \").length);\n+        command[command.length - 1] = \"gc.g1.TestTimeBasedHeapSizing$RapidCycleTest\";\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(command);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        output.shouldContain(\"Starting heap evaluation\");\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    static void testLargeHumongousObjects() throws Exception {\n+        System.out.println(\"Testing large humongous object activity tracking...\");\n+\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+            \"-XX:+UseG1GC\",\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-Xms64m\", \"-Xmx256m\",\n+            \"-XX:G1HeapRegionSize=1M\",\n+            \"-XX:G1UncommitDelayMillis=5000\",\n+            \"-XX:G1MinRegionsToUncommit=1\",\n+            \"-Xlog:gc*,gc+sizing*=debug\",\n+            \"gc.g1.TestTimeBasedHeapSizing$LargeHumongousTest\"\n+        );\n+\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        \/\/ Large humongous objects should not affect uncommit safety\n+        output.shouldContain(\"G1 Time-Based Heap Sizing enabled (uncommit-only)\");\n+        output.shouldHaveExitValue(0);\n+        System.out.println(\"Large humongous object test passed!\");\n+    }\n+\n+    public static class HumongousObjectTest {\n+        private static final int MB = 1024 * 1024;\n+        private static ArrayList<byte[]> humongousObjects = new ArrayList<>();\n+\n+        public static void main(String[] args) throws Exception {\n+            System.out.println(\"HumongousObjectTest: Starting\");\n+\n+            \/\/ Allocate humongous objects (> 512KB for 1MB regions)\n+            for (int i = 0; i < 8; i++) {\n+                humongousObjects.add(new byte[800 * 1024]); \/\/ 800KB humongous\n+                System.out.println(\"Allocated humongous object \" + (i + 1));\n+                Thread.sleep(200);\n+            }\n+\n+            \/\/ Keep them alive for a while\n+            Thread.sleep(3000);\n+\n+            \/\/ Clear and test uncommit behavior\n+            humongousObjects.clear();\n+            System.gc();\n+            Thread.sleep(12000); \/\/ Wait for uncommit delay\n+\n+            System.out.println(\"HumongousObjectTest: Test completed\");\n+            Runtime.getRuntime().halt(0);\n+        }\n+    }\n+\n+    public static class RapidCycleTest {\n+        private static final int MB = 1024 * 1024;\n+        private static ArrayList<byte[]> memory = new ArrayList<>();\n+\n+        public static void main(String[] args) throws Exception {\n+            System.out.println(\"RapidCycleTest: Starting\");\n+\n+            \/\/ Rapid allocation\/deallocation cycles\n+            for (int cycle = 0; cycle < 15; cycle++) {\n+                \/\/ Quick allocation\n+                for (int i = 0; i < 8; i++) {\n+                    memory.add(new byte[MB]); \/\/ 1MB\n+                }\n+\n+                \/\/ Quick deallocation\n+                memory.clear();\n+                System.gc();\n+\n+                \/\/ Brief pause\n+                Thread.sleep(100);\n+\n+                if (cycle % 5 == 0) {\n+                    System.out.println(\"Completed cycle \" + cycle);\n+                }\n+            }\n+\n+            \/\/ Final wait for time-based evaluation\n+            Thread.sleep(12000);\n+\n+            System.out.println(\"RapidCycleTest: Test completed\");\n+            Runtime.getRuntime().halt(0);\n+        }\n+    }\n+\n+    public static class LargeHumongousTest {\n+        public static void main(String[] args) throws Exception {\n+            System.out.println(\"=== Large Humongous Object Test ===\");\n+\n+            \/\/ Allocate several large humongous objects (multiple regions each)\n+            List<byte[]> humongousObjects = new ArrayList<>();\n+\n+            \/\/ Each region is 1MB, so allocate 2MB objects (humongous spanning multiple regions)\n+            for (int i = 0; i < 5; i++) {\n+                humongousObjects.add(new byte[2 * 1024 * 1024]);\n+                System.gc(); \/\/ Force potential region transitions\n+                Thread.sleep(100);\n+            }\n+\n+            \/\/ Hold some, release others to create mixed region states\n+            humongousObjects.remove(0);\n+            humongousObjects.remove(0);\n+            System.gc();\n+\n+            \/\/ Wait for time-based evaluation with humongous regions present\n+            Thread.sleep(8000);\n+\n+            \/\/ Clean up\n+            humongousObjects.clear();\n+            System.gc();\n+\n+            System.out.println(\"LargeHumongousTest: Test completed\");\n+            Runtime.getRuntime().halt(0);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestTimeBasedHeapSizing.java","additions":259,"deletions":0,"binary":false,"changes":259,"status":"added"},{"patch":"@@ -0,0 +1,340 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.g1;\n+\n+\/**\n+ * @test TestTimeBasedRegionTracking\n+ * @bug 8357445\n+ * @summary Test region activity tracking and state transitions for time-based heap sizing\n+ * @requires vm.gc.G1\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\/sun.management\n+ * @run main\/othervm -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions\n+ *      -Xms32m -Xmx128m -XX:G1HeapRegionSize=1M\n+ *      -XX:G1TimeBasedEvaluationIntervalMillis=5000\n+ *      -XX:G1UncommitDelayMillis=10000\n+ *      -XX:G1MinRegionsToUncommit=2\n+ *      -Xlog:gc*,gc+sizing*=debug gc.g1.TestTimeBasedRegionTracking\n+ *\/\n+\n+import java.util.*;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+public class TestTimeBasedRegionTracking {\n+\n+    private static final String TEST_VM_OPTS = \"-XX:+UseG1GC \" +\n+        \"-XX:+UnlockDiagnosticVMOptions \" +\n+        \"-XX:G1TimeBasedEvaluationIntervalMillis=5000 \" +\n+        \"-XX:G1UncommitDelayMillis=10000 \" +\n+        \"-XX:G1MinRegionsToUncommit=2 \" +\n+        \"-XX:G1HeapRegionSize=1M \" +\n+        \"-Xmx128m -Xms32m \" +\n+        \"-Xlog:gc*,gc+sizing*=debug\";\n+\n+    public static void main(String[] args) throws Exception {\n+        testRegionStateTransitions();\n+        testConcurrentRegionAccess();\n+        testRegionLifecycleEdgeCases();\n+        testSafepointRaceConditions();\n+    }\n+\n+    static void testRegionStateTransitions() throws Exception {\n+        String[] command = new String[TEST_VM_OPTS.split(\" \").length + 1];\n+        System.arraycopy(TEST_VM_OPTS.split(\" \"), 0, command, 0, TEST_VM_OPTS.split(\" \").length);\n+        command[command.length - 1] = \"gc.g1.TestTimeBasedRegionTracking$RegionTransitionTest\";\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(command);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        \/\/ Verify region state changes\n+        output.shouldContain(\"Region state transition:\");\n+        output.shouldContain(\"Uncommit candidates found:\");\n+\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    public static class RegionTransitionTest {\n+        private static final int MB = 1024 * 1024;\n+        private static ArrayList<byte[]> arrays = new ArrayList<>();\n+\n+        public static void main(String[] args) throws Exception {\n+            \/\/ Phase 1: Active allocation\n+            allocateMemory(32); \/\/ 32MB\n+            System.gc();\n+\n+            \/\/ Phase 2: Idle period\n+            arrays.clear();\n+            System.gc();\n+            Thread.sleep(15000); \/\/ Wait for uncommit\n+\n+            \/\/ Phase 3: Reallocation\n+            allocateMemory(16); \/\/ 16MB\n+            System.gc();\n+\n+            \/\/ Clean up and wait for final uncommit evaluation\n+            arrays = null;\n+            System.gc();\n+            Thread.sleep(2000);\n+            Runtime.getRuntime().halt(0);\n+        }\n+\n+        static void allocateMemory(int mb) throws InterruptedException {\n+            for (int i = 0; i < mb; i++) {\n+                arrays.add(new byte[MB]);\n+                if (i % 4 == 0) Thread.sleep(10);\n+            }\n+        }\n+    }\n+\n+    static void testConcurrentRegionAccess() throws Exception {\n+        String[] command = new String[TEST_VM_OPTS.split(\" \").length + 1];\n+        System.arraycopy(TEST_VM_OPTS.split(\" \"), 0, command, 0, TEST_VM_OPTS.split(\" \").length);\n+        command[command.length - 1] = \"gc.g1.TestTimeBasedRegionTracking$ConcurrentAccessTest\";\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(command);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        \/\/ Verify concurrent access is handled safely\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    static void testRegionLifecycleEdgeCases() throws Exception {\n+        String[] command = new String[TEST_VM_OPTS.split(\" \").length + 1];\n+        System.arraycopy(TEST_VM_OPTS.split(\" \"), 0, command, 0, TEST_VM_OPTS.split(\" \").length);\n+        command[command.length - 1] = \"gc.g1.TestTimeBasedRegionTracking$RegionLifecycleEdgeCaseTest\";\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(command);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        \/\/ Verify region lifecycle edge cases are handled\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    static void testSafepointRaceConditions() throws Exception {\n+        System.out.println(\"Testing safepoint and allocation race conditions...\");\n+\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+            \"-XX:+UseG1GC\",\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-Xms64m\", \"-Xmx256m\",\n+            \"-XX:G1HeapRegionSize=1M\",\n+            \"-XX:G1TimeBasedEvaluationIntervalMillis=1000\", \/\/ Frequent evaluation (minimum allowed)\n+            \"-XX:G1UncommitDelayMillis=1000\", \/\/ Short delay\n+            \"-XX:G1MinRegionsToUncommit=1\",\n+            \"-Xlog:gc*,gc+sizing*=debug\",\n+            \"gc.g1.TestTimeBasedRegionTracking$SafepointRaceTest\"\n+        );\n+\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        \/\/ Should handle safepoint races without errors\n+        output.shouldContain(\"G1 Time-Based Heap Sizing enabled (uncommit-only)\");\n+        output.shouldHaveExitValue(0);\n+        System.out.println(\"Safepoint race conditions test passed!\");\n+    }\n+\n+    public static class ConcurrentAccessTest {\n+        private static final int MB = 1024 * 1024;\n+        private static final List<byte[]> sharedMemory = new ArrayList<>();\n+        private static volatile boolean stopThreads = false;\n+\n+        public static void main(String[] args) throws Exception {\n+            System.out.println(\"ConcurrentAccessTest: Starting\");\n+\n+            \/\/ Start multiple allocation threads\n+            Thread[] threads = new Thread[3];\n+            for (int t = 0; t < threads.length; t++) {\n+                final int threadId = t;\n+                threads[t] = new Thread(() -> {\n+                    int iterations = 0;\n+                    while (!stopThreads && iterations < 30) {\n+                        try {\n+                            \/\/ Allocate\n+                            for (int i = 0; i < 3; i++) {\n+                                synchronized (sharedMemory) {\n+                                    sharedMemory.add(new byte[512 * 1024]); \/\/ 512KB\n+                                }\n+                                Thread.sleep(10);\n+                            }\n+\n+                            \/\/ Clear some memory\n+                            synchronized (sharedMemory) {\n+                                if (sharedMemory.size() > 15) {\n+                                    for (int i = 0; i < 5; i++) {\n+                                        if (!sharedMemory.isEmpty()) {\n+                                            sharedMemory.remove(0);\n+                                        }\n+                                    }\n+                                }\n+                            }\n+\n+                            if (iterations % 10 == 0) {\n+                                System.gc();\n+                            }\n+\n+                            iterations++;\n+                            Thread.sleep(50);\n+                        } catch (InterruptedException e) {\n+                            break;\n+                        }\n+                    }\n+                    System.out.println(\"Thread \" + threadId + \" completed \" + iterations + \" iterations\");\n+                });\n+                threads[t].start();\n+            }\n+\n+            \/\/ Let threads run for a while\n+            Thread.sleep(8000);\n+\n+            stopThreads = true;\n+            for (Thread t : threads) {\n+                t.join(2000);\n+            }\n+\n+            synchronized (sharedMemory) {\n+                sharedMemory.clear();\n+            }\n+            System.gc();\n+            Thread.sleep(3000);\n+\n+            System.out.println(\"ConcurrentAccessTest: Test completed\");\n+            Runtime.getRuntime().halt(0);\n+        }\n+    }\n+\n+    public static class RegionLifecycleEdgeCaseTest {\n+        private static final int MB = 1024 * 1024;\n+        private static List<Object> memory = new ArrayList<>();\n+\n+        public static void main(String[] args) throws Exception {\n+            System.out.println(\"RegionLifecycleEdgeCaseTest: Starting\");\n+\n+            \/\/ Phase 1: Mixed allocation patterns\n+            \/\/ Small objects\n+            for (int i = 0; i < 100; i++) {\n+                memory.add(new byte[8 * 1024]); \/\/ 8KB objects\n+            }\n+\n+            \/\/ Medium objects\n+            for (int i = 0; i < 20; i++) {\n+                memory.add(new byte[40 * 1024]); \/\/ 40KB objects\n+            }\n+\n+            \/\/ Large objects (but not humongous)\n+            for (int i = 0; i < 5; i++) {\n+                memory.add(new byte[300 * 1024]); \/\/ 300KB objects\n+            }\n+\n+            Thread.sleep(2000);\n+\n+            \/\/ Phase 2: Create fragmentation by selective deallocation\n+            for (int i = memory.size() - 1; i >= 0; i -= 2) {\n+                memory.remove(i);\n+            }\n+\n+            System.gc();\n+            Thread.sleep(3000);\n+\n+            \/\/ Phase 3: Add humongous objects\n+            for (int i = 0; i < 3; i++) {\n+                memory.add(new byte[900 * 1024]); \/\/ 900KB humongous\n+                Thread.sleep(500);\n+            }\n+\n+            Thread.sleep(2000);\n+\n+            \/\/ Phase 4: Final cleanup\n+            memory.clear();\n+            System.gc();\n+            Thread.sleep(12000); \/\/ Wait for multiple evaluation cycles\n+\n+            System.out.println(\"RegionLifecycleEdgeCaseTest: Test completed\");\n+            Runtime.getRuntime().halt(0);\n+        }\n+    }\n+\n+    public static class SafepointRaceTest {\n+        public static void main(String[] args) throws Exception {\n+            System.out.println(\"=== Safepoint Race Conditions Test ===\");\n+\n+            final AtomicBoolean stopFlag = new AtomicBoolean(false);\n+            final List<byte[]> sharedMemory = Collections.synchronizedList(new ArrayList<>());\n+\n+            \/\/ Start multiple threads to create allocation pressure\n+            Thread[] threads = new Thread[3];\n+            for (int i = 0; i < threads.length; i++) {\n+                final int threadId = i;\n+                threads[i] = new Thread(() -> {\n+                    int iteration = 0;\n+                    while (!stopFlag.get() && iteration < 20) {\n+                        try {\n+                            \/\/ Allocate and deallocate rapidly\n+                            for (int j = 0; j < 5; j++) {\n+                                sharedMemory.add(new byte[512 * 1024]); \/\/ 512KB\n+                            }\n+\n+                            \/\/ Force GC to trigger safepoints\n+                            if (iteration % 3 == 0) {\n+                                System.gc();\n+                            }\n+\n+                            \/\/ Clear some allocations\n+                            synchronized (sharedMemory) {\n+                                if (sharedMemory.size() > 10) {\n+                                    for (int k = 0; k < 3; k++) {\n+                                        if (!sharedMemory.isEmpty()) {\n+                                            sharedMemory.remove(0);\n+                                        }\n+                                    }\n+                                }\n+                            }\n+\n+                            Thread.sleep(100); \/\/ Brief pause\n+                            iteration++;\n+                        } catch (InterruptedException e) {\n+                            break;\n+                        }\n+                    }\n+                });\n+                threads[i].start();\n+            }\n+\n+            \/\/ Let threads run during time-based evaluation\n+            Thread.sleep(8000);\n+\n+            \/\/ Stop threads\n+            stopFlag.set(true);\n+            for (Thread thread : threads) {\n+                thread.join(2000);\n+            }\n+\n+            \/\/ Clean up\n+            sharedMemory.clear();\n+            System.gc();\n+\n+            System.out.println(\"SafepointRaceTest: Test completed\");\n+            Runtime.getRuntime().halt(0);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestTimeBasedRegionTracking.java","additions":340,"deletions":0,"binary":false,"changes":340,"status":"added"}]}