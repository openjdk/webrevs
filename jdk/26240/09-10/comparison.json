{"files":[{"patch":"@@ -1120,3 +1120,5 @@\n-  \/\/ We should only reach here from the service thread during idle time\n-  \/\/ but ensure any GC alloc regions are abandoned\n-  _allocator->abandon_gc_alloc_regions();\n+  \/\/ We should only reach here from the service thread during idle time.\n+  \/\/ Note: Unlike full GC shrinking, time-based shrink may have an active mutator alloc region.\n+  \/\/ This is safe because we only remove free regions, not allocated ones.\n+  assert(GCCause::is_user_requested_gc(gc_cause()) || gc_cause() == GCCause::_no_gc,\n+         \"unexpected GC cause: %s\", GCCause::to_string(gc_cause()));\n@@ -1124,1 +1126,1 @@\n-  \/\/ For time-based shrink, we use time-aware selection instead of removing from end\n+  \/\/ For time-based shrink, we use time-aware selection instead of removing from end.\n@@ -1179,3 +1181,1 @@\n-  log_debug(gc, ergo, heap)(\"Heap resize. Requested shrinking amount: %zuB actual shrinking amount: %zuB (%u regions)\",\n-                            shrink_bytes, shrunk_bytes, num_regions_removed);\n-\n+  \n@@ -1183,5 +1183,9 @@\n-    log_info(gc, heap)(\"Heap shrink details: uncommitted %u regions (%zuMB), heap size now %zuMB\",\n-                       num_regions_removed, shrunk_bytes \/ M, capacity() \/ M);\n-    log_debug(gc, heap)(\"Heap shrink details: requested=%zuB actual=%zuB \"\n-                        \"regions_removed=%u heap_capacity=%zuB\",\n-                        shrink_bytes, shrunk_bytes, num_regions_removed, capacity());\n+    if (log_is_enabled(Debug, gc, heap)) {\n+      log_debug(gc, heap)(\"Heap shrink: uncommitted %u regions (%zuMB), heap size now %zuMB. \"\n+                         \"Details: requested=%zuB actual=%zuB heap_capacity=%zuB\",\n+                         num_regions_removed, shrunk_bytes \/ M, capacity() \/ M,\n+                         shrink_bytes, shrunk_bytes, capacity());\n+    } else {\n+      log_info(gc, heap)(\"Heap shrink: uncommitted %u regions (%zuMB), heap size now %zuMB\",\n+                        num_regions_removed, shrunk_bytes \/ M, capacity() \/ M);\n+    }\n@@ -1237,2 +1241,2 @@\n-  \/\/ Always schedule a VM operation for proper synchronization with GC\n-  \/\/ The VM operation will re-evaluate which regions to uncommit at the time of execution\n+  \/\/ Always schedule a VM operation for proper synchronization with GC.\n+  \/\/ The VM operation will re-evaluate which regions to uncommit at the time of execution.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -44,3 +44,1 @@\n-  log_debug(gc, sizing)(\"Starting uncommit evaluation\");\n-\n-  ResourceMark rm; \/\/ Ensure temporary resources are released\n+  log_debug(gc, sizing)(\"Starting uncommit evaluation.\");\n@@ -60,3 +58,3 @@\n-    log_info(gc, sizing)(\"Uncommit evaluation: shrinking heap by %zuMB using time-based selection\", resize_amount \/ M);\n-    log_debug(gc, sizing)(\"Uncommit evaluation: policy recommends shrinking by %zuB\", resize_amount);\n-    \/\/ Request VM operation outside of suspendible thread set\n+    log_info(gc, sizing)(\"Uncommit evaluation: shrinking heap by %zuMB using time-based selection.\", resize_amount \/ M);\n+    log_debug(gc, sizing)(\"Uncommit evaluation: policy recommends shrinking by %zuB.\", resize_amount);\n+    \/\/ Request VM operation outside of suspendible thread set.\n@@ -65,1 +63,1 @@\n-    if (++evaluation_count % 10 == 0) { \/\/ Log every 10th evaluation when no action taken\n+    if (++evaluation_count % 10 == 0) { \/\/ Log every 10th evaluation when no action taken.\n@@ -70,1 +68,1 @@\n-  \/\/ Schedule the next evaluation\n+  \/\/ Schedule the next evaluation.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapEvaluationTask.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -634,1 +634,1 @@\n-  \/\/ Scan all committed regions to find empty ones\n+  \/\/ Scan all committed regions to find free ones.\n@@ -638,2 +638,2 @@\n-      if (hr != nullptr && hr->is_empty() && hr->is_free()) {\n-        \/\/ Check if this region should be considered for time-based uncommit\n+      if (hr != nullptr && hr->is_free()) {\n+        \/\/ Check if this region should be considered for time-based uncommit.\n@@ -654,15 +654,10 @@\n-  \/\/ Sort regions by access time (oldest first) using simple bubble sort\n-  \/\/ This is fine since the number of empty regions is typically small\n-  int n = empty_regions.length();\n-  for (int i = 0; i < n - 1; i++) {\n-    for (int j = 0; j < n - i - 1; j++) {\n-      G1HeapRegion* hr_a = empty_regions.at(j);\n-      G1HeapRegion* hr_b = empty_regions.at(j + 1);\n-\n-      \/\/ Swap if hr_a has newer access time than hr_b (older should come first)\n-      if (hr_a->last_access_time() > hr_b->last_access_time()) {\n-        empty_regions.at_put(j, hr_b);\n-        empty_regions.at_put(j + 1, hr_a);\n-      }\n-    }\n-  }\n+  \/\/ Sort regions by access time (oldest first).\n+  \/\/ Use qsort for standard library sorting.\n+  static auto compare_region_age = [](G1HeapRegion** a, G1HeapRegion** b) -> int {\n+    Ticks time_a = (*a)->last_access_time();\n+    Ticks time_b = (*b)->last_access_time();\n+    if (time_a < time_b) return -1;  \/\/ Older first.\n+    if (time_a > time_b) return 1;\n+    return 0;\n+  };\n+  empty_regions.sort(compare_region_age);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.cpp","additions":13,"deletions":18,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -453,1 +453,1 @@\n-  \/\/ Count regions that would be eligible for uncommit\n+  \/\/ Count regions that would be eligible for uncommit.\n@@ -463,1 +463,2 @@\n-      if (r->is_empty() && _policy->should_uncommit_region(r)) {\n+      \/\/ Note: All free regions are empty, so only check is_free()\n+      if (r->is_free() && _policy->should_uncommit_region(r)) {\n@@ -478,1 +479,1 @@\n-  \/\/ Check each heap region for inactivity, limiting to max_candidates for efficiency\n+  \/\/ Check each heap region for inactivity, limiting to max_candidates for efficiency.\n@@ -495,1 +496,2 @@\n-      if (r->is_empty() && _policy->should_uncommit_region(r)) {\n+      \/\/ Note: All free regions are empty, so only check is_free().\n+      if (r->is_free() && _policy->should_uncommit_region(r)) {\n@@ -498,1 +500,1 @@\n-        \/\/ Stop early if we have enough candidates\n+        \/\/ Stop early if we have enough candidates.\n@@ -500,1 +502,1 @@\n-          return true; \/\/ Stop iteration\n+          return true; \/\/ Stop iteration.\n@@ -520,1 +522,1 @@\n-  \/\/ Find time-based candidates\n+  \/\/ Find time-based candidates.\n@@ -528,16 +530,6 @@\n-  uint valid_candidates = 0;\n-  \/\/ Count valid candidates (must be available, empty, and free)\n-  for (int i = 0; i < candidates.length(); i++) {\n-    G1HeapRegion* hr = candidates.at(i);\n-    uint region_index = hr->hrm_index();\n-\n-    \/\/ Only count if region is ready for shrinking\n-    if (hr->is_empty() && hr->is_free()) {\n-      log_debug(gc, sizing)(\"Time-based shrink: identified region %u as candidate (last_access=\" UINT64_FORMAT \"ms ago)\",\n-                           region_index, (Ticks::now() - hr->last_access_time()).milliseconds());\n-      valid_candidates++;\n-    } else {\n-      log_debug(gc, sizing)(\"Time-based shrink: skipping region %u - not ready for shrinking \"\n-                           \"(empty=%s, free=%s)\",\n-                           region_index, hr->is_empty() ? \"true\" : \"false\", hr->is_free() ? \"true\" : \"false\");\n-    }\n+  \/\/ Check if we should back off due to recent GC activity.\n+  \/\/ If GC overhead is high, don't compete with GC-based sizing.\n+  double gc_overhead = _analytics->short_term_gc_time_ratio();\n+  if (gc_overhead > 0.10) {  \/\/ Back off if GC overhead > 10%.\n+    log_debug(gc, sizing)(\"Time-based shrink: backing off due to GC pressure (overhead=%.2f%%)\", gc_overhead * 100);\n+    return 0;\n@@ -545,1 +537,3 @@\n-\n+  \n+  \/\/ All candidates are already validated by find_uncommit_candidates_by_time().\n+  uint valid_candidates = (uint)candidates.length();\n@@ -557,2 +551,2 @@\n-  \/\/ Note: Caller already guarantees hr->is_empty() is true\n-  \/\/ Empty regions should always be free and not in collection set in normal operation\n+  \/\/ Note: Caller already guarantees hr->is_empty() is true.\n+  \/\/ Empty regions should always be free and not in collection set in normal operation.\n@@ -583,1 +577,1 @@\n-  \/\/ Back off during allocation pressure - only evaluate when truly idle\n+  \/\/ Back off during allocation pressure - only evaluate when truly idle.\n@@ -586,1 +580,1 @@\n-    if (gc_time_ratio > 0.05) { \/\/ 5% GC time still indicates pressure\n+    if (gc_time_ratio > 0.05) { \/\/ 5% GC time still indicates pressure.\n@@ -593,1 +587,1 @@\n-  \/\/ Must hold Heap_lock during heap resizing\n+  \/\/ Must hold Heap_lock during heap resizing.\n@@ -596,1 +590,1 @@\n-  ResourceMark rm; \/\/ Ensure GrowableArray resources are properly released\n+  ResourceMark rm; \/\/ Ensure GrowableArray resources are properly released..\n@@ -598,1 +592,1 @@\n-  \/\/ Count regions eligible for uncommit (don't store them - VM operation will re-evaluate)\n+  \/\/ Count regions eligible for uncommit (don't store them - VM operation will re-evaluate).\n@@ -605,1 +599,1 @@\n-  \/\/ Need minimum number of idle regions to proceed\n+  \/\/ Need minimum number of idle regions to proceed.\n@@ -609,1 +603,1 @@\n-    size_t min_heap = MAX2((size_t)InitialHeapSize, MinHeapSize);  \/\/ Never go below initial size\n+    size_t min_heap = MAX2((size_t)InitialHeapSize, MinHeapSize);  \/\/ Never go below initial size..\n@@ -611,1 +605,1 @@\n-    \/\/ Calculate maximum bytes we can uncommit while respecting min heap size\n+    \/\/ Calculate maximum bytes we can uncommit while respecting min heap size.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.cpp","additions":28,"deletions":34,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"gc\/g1\/g1Allocator.hpp\"\n@@ -178,5 +179,38 @@\n-  \/\/ Use the pre-evaluated shrink amount to avoid lock conflicts during safepoint\n-  \/\/ Re-evaluation during VM operation can cause Heap_lock violations\n-  log_debug(gc, ergo, heap)(\"VM_G1ShrinkHeap: executing shrink operation with %zuB\", _bytes);\n-  _g1h->shrink_with_time_based_selection(_bytes);\n-\n+  \/\/ Re-evaluate which regions are still eligible for uncommit at safepoint time.\n+  \/\/ Heap state may have changed since the request was made.\n+  log_debug(gc, ergo, heap)(\"VM_G1ShrinkHeap: re-evaluating heap state at safepoint\");\n+  \n+  \/\/ Calculate maximum regions we can shrink based on original request.\n+  uint max_regions_to_shrink = (uint)(_bytes \/ G1HeapRegion::GrainBytes);\n+  \n+  \/\/ Re-evaluate candidates at safepoint - heap state may have changed.\n+  GrowableArray<G1HeapRegion*> candidates(max_regions_to_shrink);\n+  _g1h->heap_sizing_policy()->find_uncommit_candidates_by_time(&candidates, max_regions_to_shrink);\n+  \n+  if (candidates.length() == 0) {\n+    log_debug(gc, ergo, heap)(\"VM_G1ShrinkHeap: no valid candidates at safepoint, skipping shrink\");\n+    return;\n+  }\n+  \n+  \/\/ Validate each candidate is still free and empty at safepoint.\n+  uint valid_count = 0;\n+  for (int i = 0; i < candidates.length(); i++) {\n+    G1HeapRegion* hr = candidates.at(i);\n+    if (hr->is_free()) {\n+      valid_count++;\n+    } else {\n+      log_debug(gc, ergo, heap)(\"VM_G1ShrinkHeap: skipping region %u - no longer free\", hr->hrm_index());\n+    }\n+  }\n+  \n+  if (valid_count == 0) {\n+    log_debug(gc, ergo, heap)(\"VM_G1ShrinkHeap: no regions still valid at safepoint\");\n+    return;\n+  }\n+  \n+  size_t shrink_bytes = (size_t)valid_count * G1HeapRegion::GrainBytes;\n+  log_info(gc, ergo, heap)(\"VM_G1ShrinkHeap: executing shrink with %u regions (%zuMB) after re-evaluation\",\n+                           valid_count, shrink_bytes \/ M);\n+  \n+  _g1h->shrink_with_time_based_selection(shrink_bytes);\n+  \n@@ -184,1 +218,1 @@\n-  \/\/ from when they originally became free for accurate time-based selection\n+  \/\/ from when they originally became free for accurate time-based selection.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.cpp","additions":40,"deletions":6,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-  size_t _bytes;\n+  size_t _bytes;  \/\/ Maximum bytes to shrink (used as hint for re-evaluation)\n@@ -121,1 +121,1 @@\n-  void doit() override;\n+  void doit() override;  \/\/ Re-evaluates regions at safepoint\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}