{"files":[{"patch":"@@ -3713,1 +3713,1 @@\n-        byte[] value = StringConcatHelper.newArray(len);\n+        byte[] value = StringConcatHelper.newArray((int) len);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,256 +144,0 @@\n-    \/**\n-     * Return the coder for the character.\n-     * @param value character\n-     * @return      coder\n-     *\/\n-    static long coder(char value) {\n-        return StringLatin1.canEncode(value) ? LATIN1 : UTF16;\n-    }\n-\n-    \/**\n-     * Check for overflow, throw exception on overflow.\n-     *\n-     * @param lengthCoder String length with coder packed into higher bits\n-     *                    the upper word.\n-     * @return            the given parameter value, if valid\n-     *\/\n-    private static long checkOverflow(long lengthCoder) {\n-        if ((int)lengthCoder >= 0) {\n-            return lengthCoder;\n-        }\n-        throw new OutOfMemoryError(\"Overflow: String length out of range\");\n-    }\n-\n-    \/**\n-     * Mix value length and coder into current length and coder.\n-     * @param lengthCoder String length with coder packed into higher bits\n-     *                    the upper word.\n-     * @param value       value to mix in\n-     * @return            new length and coder\n-     *\/\n-    static long mix(long lengthCoder, boolean value) {\n-        return checkOverflow(lengthCoder + (value ? 4 : 5));\n-    }\n-\n-    \/**\n-     * Mix value length and coder into current length and coder.\n-     * @param lengthCoder String length with coder packed into higher bits\n-     *                    the upper word.\n-     * @param value       value to mix in\n-     * @return            new length and coder\n-     *\/\n-    static long mix(long lengthCoder, char value) {\n-        return checkOverflow(lengthCoder + 1) | coder(value);\n-    }\n-\n-    \/**\n-     * Mix value length and coder into current length and coder.\n-     * @param lengthCoder String length with coder packed into higher bits\n-     *                    the upper word.\n-     * @param value       value to mix in\n-     * @return            new length and coder\n-     *\/\n-    static long mix(long lengthCoder, int value) {\n-        return checkOverflow(lengthCoder + DecimalDigits.stringSize(value));\n-    }\n-\n-    \/**\n-     * Mix value length and coder into current length and coder.\n-     * @param lengthCoder String length with coder packed into higher bits\n-     *                    the upper word.\n-     * @param value       value to mix in\n-     * @return            new length and coder\n-     *\/\n-    static long mix(long lengthCoder, long value) {\n-        return checkOverflow(lengthCoder + DecimalDigits.stringSize(value));\n-    }\n-\n-    \/**\n-     * Mix value length and coder into current length and coder.\n-     * @param lengthCoder String length with coder packed into higher bits\n-     *                    the upper word.\n-     * @param value       value to mix in\n-     * @return            new length and coder\n-     *\/\n-    static long mix(long lengthCoder, String value) {\n-        lengthCoder += value.length();\n-        if (!value.isLatin1()) {\n-            lengthCoder |= UTF16;\n-        }\n-        return checkOverflow(lengthCoder);\n-    }\n-\n-    \/**\n-     * Prepends constant and the stringly representation of value into buffer,\n-     * given the coder and final index. Index is measured in chars, not in bytes!\n-     *\n-     * @param indexCoder final char index in the buffer, along with coder packed\n-     *                   into higher bits.\n-     * @param buf        buffer to append to\n-     * @param value      boolean value to encode\n-     * @param prefix     a constant to prepend before value\n-     * @return           updated index (coder value retained)\n-     *\/\n-    static long prepend(long indexCoder, byte[] buf, boolean value, String prefix) {\n-        int index = (int)indexCoder;\n-        if (indexCoder < UTF16) {\n-            if (value) {\n-                index -= 4;\n-                buf[index] = 't';\n-                buf[index + 1] = 'r';\n-                buf[index + 2] = 'u';\n-                buf[index + 3] = 'e';\n-            } else {\n-                index -= 5;\n-                buf[index] = 'f';\n-                buf[index + 1] = 'a';\n-                buf[index + 2] = 'l';\n-                buf[index + 3] = 's';\n-                buf[index + 4] = 'e';\n-            }\n-            index -= prefix.length();\n-            prefix.getBytes(buf, index, String.LATIN1);\n-            return index;\n-        } else {\n-            if (value) {\n-                index -= 4;\n-                StringUTF16.putChar(buf, index, 't');\n-                StringUTF16.putChar(buf, index + 1, 'r');\n-                StringUTF16.putChar(buf, index + 2, 'u');\n-                StringUTF16.putChar(buf, index + 3, 'e');\n-            } else {\n-                index -= 5;\n-                StringUTF16.putChar(buf, index, 'f');\n-                StringUTF16.putChar(buf, index + 1, 'a');\n-                StringUTF16.putChar(buf, index + 2, 'l');\n-                StringUTF16.putChar(buf, index + 3, 's');\n-                StringUTF16.putChar(buf, index + 4, 'e');\n-            }\n-            index -= prefix.length();\n-            prefix.getBytes(buf, index, String.UTF16);\n-            return index | UTF16;\n-        }\n-    }\n-\n-    \/**\n-     * Prepends constant and the stringly representation of value into buffer,\n-     * given the coder and final index. Index is measured in chars, not in bytes!\n-     *\n-     * @param indexCoder final char index in the buffer, along with coder packed\n-     *                   into higher bits.\n-     * @param buf        buffer to append to\n-     * @param value      char value to encode\n-     * @param prefix     a constant to prepend before value\n-     * @return           updated index (coder value retained)\n-     *\/\n-    static long prepend(long indexCoder, byte[] buf, char value, String prefix) {\n-        int index = (int)indexCoder;\n-        if (indexCoder < UTF16) {\n-            buf[--index] = (byte) (value & 0xFF);\n-            index -= prefix.length();\n-            prefix.getBytes(buf, index, String.LATIN1);\n-            return index;\n-        } else {\n-            StringUTF16.putChar(buf, --index, value);\n-            index -= prefix.length();\n-            prefix.getBytes(buf, index, String.UTF16);\n-            return index | UTF16;\n-        }\n-    }\n-\n-    \/**\n-     * Prepends constant and the stringly representation of value into buffer,\n-     * given the coder and final index. Index is measured in chars, not in bytes!\n-     *\n-     * @param indexCoder final char index in the buffer, along with coder packed\n-     *                   into higher bits.\n-     * @param buf        buffer to append to\n-     * @param value      int value to encode\n-     * @param prefix     a constant to prepend before value\n-     * @return           updated index (coder value retained)\n-     *\/\n-    static long prepend(long indexCoder, byte[] buf, int value, String prefix) {\n-        int index = (int)indexCoder;\n-        if (indexCoder < UTF16) {\n-            index = DecimalDigits.uncheckedGetCharsLatin1(value, index, buf);\n-            index -= prefix.length();\n-            prefix.getBytes(buf, index, String.LATIN1);\n-            return index;\n-        } else {\n-            index = DecimalDigits.uncheckedGetCharsUTF16(value, index, buf);\n-            index -= prefix.length();\n-            prefix.getBytes(buf, index, String.UTF16);\n-            return index | UTF16;\n-        }\n-    }\n-\n-    \/**\n-     * Prepends constant and the stringly representation of value into buffer,\n-     * given the coder and final index. Index is measured in chars, not in bytes!\n-     *\n-     * @param indexCoder final char index in the buffer, along with coder packed\n-     *                   into higher bits.\n-     * @param buf        buffer to append to\n-     * @param value      long value to encode\n-     * @param prefix     a constant to prepend before value\n-     * @return           updated index (coder value retained)\n-     *\/\n-    static long prepend(long indexCoder, byte[] buf, long value, String prefix) {\n-        int index = (int)indexCoder;\n-        if (indexCoder < UTF16) {\n-            index = DecimalDigits.uncheckedGetCharsLatin1(value, index, buf);\n-            index -= prefix.length();\n-            prefix.getBytes(buf, index, String.LATIN1);\n-            return index;\n-        } else {\n-            index = DecimalDigits.uncheckedGetCharsUTF16(value, index, buf);\n-            index -= prefix.length();\n-            prefix.getBytes(buf, index, String.UTF16);\n-            return index | UTF16;\n-        }\n-    }\n-\n-    \/**\n-     * Prepends constant and the stringly representation of value into buffer,\n-     * given the coder and final index. Index is measured in chars, not in bytes!\n-     *\n-     * @param indexCoder final char index in the buffer, along with coder packed\n-     *                   into higher bits.\n-     * @param buf        buffer to append to\n-     * @param value      boolean value to encode\n-     * @param prefix     a constant to prepend before value\n-     * @return           updated index (coder value retained)\n-     *\/\n-    static long prepend(long indexCoder, byte[] buf, String value, String prefix) {\n-        int index = ((int)indexCoder) - value.length();\n-        if (indexCoder < UTF16) {\n-            value.getBytes(buf, index, String.LATIN1);\n-            index -= prefix.length();\n-            prefix.getBytes(buf, index, String.LATIN1);\n-            return index;\n-        } else {\n-            value.getBytes(buf, index, String.UTF16);\n-            index -= prefix.length();\n-            prefix.getBytes(buf, index, String.UTF16);\n-            return index | UTF16;\n-        }\n-    }\n-\n-    \/**\n-     * Instantiates the String with given buffer and coder\n-     * @param buf           buffer to use\n-     * @param indexCoder    remaining index (should be zero) and coder\n-     * @return String       resulting string\n-     *\/\n-    static String newString(byte[] buf, long indexCoder) {\n-        \/\/ Use the private, non-copying constructor (unsafe!)\n-        if (indexCoder == LATIN1) {\n-            return new String(buf, String.LATIN1);\n-        } else if (indexCoder == UTF16) {\n-            return new String(buf, String.UTF16);\n-        } else {\n-            throw new InternalError(\"Storage is not completely initialized, \" +\n-                    (int)indexCoder + \" bytes left\");\n-        }\n-    }\n-\n@@ -469,4 +213,0 @@\n-    private static final long LATIN1 = (long)String.LATIN1 << 32;\n-\n-    private static final long UTF16 = (long)String.UTF16 << 32;\n-\n@@ -533,35 +273,0 @@\n-    \/**\n-     * Allocates an uninitialized byte array based on the length and coder\n-     * information, then prepends the given suffix string at the end of the\n-     * byte array before returning it. The calling code must adjust the\n-     * indexCoder so that it's taken the coder of the suffix into account, but\n-     * subtracted the length of the suffix.\n-     *\n-     * @param suffix\n-     * @param indexCoder\n-     * @return the newly allocated byte array\n-     *\/\n-    @ForceInline\n-    static byte[] newArrayWithSuffix(String suffix, long indexCoder) {\n-        byte[] buf = newArray(indexCoder + suffix.length());\n-        if (indexCoder < UTF16) {\n-            suffix.getBytes(buf, (int)indexCoder, String.LATIN1);\n-        } else {\n-            suffix.getBytes(buf, (int)indexCoder, String.UTF16);\n-        }\n-        return buf;\n-    }\n-\n-    \/**\n-     * Allocates an uninitialized byte array based on the length and coder information\n-     * in indexCoder\n-     * @param indexCoder\n-     * @return the newly allocated byte array\n-     *\/\n-    @ForceInline\n-    static byte[] newArray(long indexCoder) {\n-        byte coder = (byte)(indexCoder >> 32);\n-        int index = ((int)indexCoder) << coder;\n-        return newArray(index);\n-    }\n-\n@@ -581,8 +286,0 @@\n-    \/**\n-     * Provides the initial coder for the String.\n-     * @return initial coder, adjusted into the upper half\n-     *\/\n-    static long initialCoder() {\n-        return String.COMPACT_STRINGS ? LATIN1 : UTF16;\n-    }\n-\n@@ -606,1 +303,2 @@\n-     * @param indexCoder\n+     * @param index     final char index in the buffer\n+     * @param coder     coder of the buffer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringConcatHelper.java","additions":2,"deletions":304,"binary":false,"changes":306,"status":"modified"},{"patch":"@@ -2188,12 +2188,0 @@\n-            public long stringConcatInitialCoder() {\n-                return StringConcatHelper.initialCoder();\n-            }\n-\n-            public long stringConcatMix(long lengthCoder, String constant) {\n-                return StringConcatHelper.mix(lengthCoder, constant);\n-            }\n-\n-            public long stringConcatMix(long lengthCoder, char value) {\n-                return StringConcatHelper.mix(lengthCoder, value);\n-            }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import sun.invoke.util.Wrapper;\n@@ -122,1 +121,0 @@\n-    private static final int HIGH_ARITY_THRESHOLD;\n@@ -127,3 +125,0 @@\n-        String highArity = VM.getSavedProperty(\"java.lang.invoke.StringConcat.highArityThreshold\");\n-        HIGH_ARITY_THRESHOLD = highArity != null ? Integer.parseInt(highArity) : 0;\n-\n@@ -394,3 +389,0 @@\n-            if (mh == null && concatType.parameterCount() <= HIGH_ARITY_THRESHOLD) {\n-                mh = generateMHInlineCopy(concatType, constantStrings);\n-            }\n@@ -521,379 +513,0 @@\n-    \/**\n-     * <p>This strategy replicates what StringBuilders are doing: it builds the\n-     * byte[] array on its own and passes that byte[] array to String\n-     * constructor. This strategy requires access to some private APIs in JDK,\n-     * most notably, the private String constructor that accepts byte[] arrays\n-     * without copying.\n-     *\/\n-    private static MethodHandle generateMHInlineCopy(MethodType mt, String[] constants) {\n-        int paramCount = mt.parameterCount();\n-        String suffix = constants[paramCount];\n-\n-\n-        \/\/ else... fall-through to slow-path\n-\n-        \/\/ Create filters and obtain filtered parameter types. Filters would be used in the beginning\n-        \/\/ to convert the incoming arguments into the arguments we can process (e.g. Objects -> Strings).\n-        \/\/ The filtered argument type list is used all over in the combinators below.\n-\n-        Class<?>[] ptypes = mt.erase().parameterArray();\n-        MethodHandle[] objFilters = null;\n-        MethodHandle[] floatFilters = null;\n-        MethodHandle[] doubleFilters = null;\n-        for (int i = 0; i < ptypes.length; i++) {\n-            Class<?> cl = ptypes[i];\n-            \/\/ Use int as the logical type for subword integral types\n-            \/\/ (byte and short). char and boolean require special\n-            \/\/ handling so don't change the logical type of those\n-            ptypes[i] = promoteToIntType(ptypes[i]);\n-            \/\/ Object, float and double will be eagerly transformed\n-            \/\/ into a (non-null) String as a first step after invocation.\n-            \/\/ Set up to use String as the logical type for such arguments\n-            \/\/ internally.\n-            if (cl == Object.class) {\n-                if (objFilters == null) {\n-                    objFilters = new MethodHandle[ptypes.length];\n-                }\n-                objFilters[i] = objectStringifier();\n-                ptypes[i] = String.class;\n-            } else if (cl == float.class) {\n-                if (floatFilters == null) {\n-                    floatFilters = new MethodHandle[ptypes.length];\n-                }\n-                floatFilters[i] = floatStringifier();\n-                ptypes[i] = String.class;\n-            } else if (cl == double.class) {\n-                if (doubleFilters == null) {\n-                    doubleFilters = new MethodHandle[ptypes.length];\n-                }\n-                doubleFilters[i] = doubleStringifier();\n-                ptypes[i] = String.class;\n-            }\n-        }\n-\n-        \/\/ Start building the combinator tree. The tree \"starts\" with (<parameters>)String, and \"finishes\"\n-        \/\/ with the (byte[], long)String shape to invoke newString in StringConcatHelper. The combinators are\n-        \/\/ assembled bottom-up, which makes the code arguably hard to read.\n-\n-        \/\/ Drop all remaining parameter types, leave only helper arguments:\n-        MethodHandle mh = MethodHandles.dropArgumentsTrusted(newString(), 2, ptypes);\n-\n-        \/\/ Calculate the initialLengthCoder value by looking at all constant values and summing up\n-        \/\/ their lengths and adjusting the encoded coder bit if needed\n-        long initialLengthCoder = INITIAL_CODER;\n-\n-        for (String constant : constants) {\n-            if (constant != null) {\n-                initialLengthCoder = JLA.stringConcatMix(initialLengthCoder, constant);\n-            }\n-        }\n-\n-        \/\/ Mix in prependers. This happens when (byte[], long) = (storage, indexCoder) is already\n-        \/\/ known from the combinators below. We are assembling the string backwards, so the index coded\n-        \/\/ into indexCoder is the *ending* index.\n-        mh = filterInPrependers(mh, constants, ptypes);\n-\n-        \/\/ Fold in byte[] instantiation at argument 0\n-        MethodHandle newArrayCombinator;\n-        if (suffix == null || suffix.isEmpty()) {\n-            suffix = \"\";\n-        }\n-        \/\/ newArray variant that deals with prepending any trailing constant\n-        \/\/\n-        \/\/ initialLengthCoder is adjusted to have the correct coder\n-        \/\/ and length: The newArrayWithSuffix method expects only the coder of the\n-        \/\/ suffix to be encoded into indexCoder\n-        initialLengthCoder -= suffix.length();\n-        newArrayCombinator = newArrayWithSuffix(suffix);\n-\n-        mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, newArrayCombinator,\n-                1 \/\/ index\n-        );\n-\n-        \/\/ Start combining length and coder mixers.\n-        \/\/\n-        \/\/ Length is easy: constant lengths can be computed on the spot, and all non-constant\n-        \/\/ shapes have been either converted to Strings, or explicit methods for getting the\n-        \/\/ string length out of primitives are provided.\n-        \/\/\n-        \/\/ Coders are more interesting. Only Object, String and char arguments (and constants)\n-        \/\/ can have non-Latin1 encoding. It is easier to blindly convert constants to String,\n-        \/\/ and deduce the coder from there. Arguments would be either converted to Strings\n-        \/\/ during the initial filtering, or handled by specializations in MIXERS.\n-        \/\/\n-        \/\/ The method handle shape before all mixers are combined in is:\n-        \/\/   (long, <args>)String = (\"indexCoder\", <args>)\n-        \/\/\n-        \/\/ We will bind the initialLengthCoder value to the last mixer (the one that will be\n-        \/\/ executed first), then fold that in. This leaves the shape after all mixers are\n-        \/\/ combined in as:\n-        \/\/   (<args>)String = (<args>)\n-\n-        mh = filterAndFoldInMixers(mh, initialLengthCoder, ptypes);\n-\n-        \/\/ The method handle shape here is (<args>).\n-\n-        \/\/ Apply filters, converting the arguments:\n-        if (objFilters != null) {\n-            mh = MethodHandles.filterArguments(mh, 0, objFilters);\n-        }\n-        if (floatFilters != null) {\n-            mh = MethodHandles.filterArguments(mh, 0, floatFilters);\n-        }\n-        if (doubleFilters != null) {\n-            mh = MethodHandles.filterArguments(mh, 0, doubleFilters);\n-        }\n-\n-        return mh;\n-    }\n-\n-    \/\/ We need one prepender per argument, but also need to fold in constants. We do so by greedily\n-    \/\/ creating prependers that fold in surrounding constants into the argument prepender. This reduces\n-    \/\/ the number of unique MH combinator tree shapes we'll create in an application.\n-    \/\/ Additionally we do this in chunks to reduce the number of combinators bound to the root tree,\n-    \/\/ which simplifies the shape and makes construction of similar trees use less unique LF classes\n-    private static MethodHandle filterInPrependers(MethodHandle mh, String[] constants, Class<?>[] ptypes) {\n-        int pos;\n-        int[] argPositions = null;\n-        MethodHandle prepend;\n-        for (pos = 0; pos < ptypes.length - 3; pos += 4) {\n-            prepend = prepender(pos, constants, ptypes, 4);\n-            argPositions = filterPrependArgPositions(argPositions, pos, 4);\n-            mh = MethodHandles.filterArgumentsWithCombiner(mh, 1, prepend, argPositions);\n-        }\n-        if (pos < ptypes.length) {\n-            int count = ptypes.length - pos;\n-            prepend = prepender(pos, constants, ptypes, count);\n-            argPositions = filterPrependArgPositions(argPositions, pos, count);\n-            mh = MethodHandles.filterArgumentsWithCombiner(mh, 1, prepend, argPositions);\n-        }\n-        return mh;\n-    }\n-\n-    static int[] filterPrependArgPositions(int[] argPositions, int pos, int count) {\n-        if (argPositions == null || argPositions.length != count + 2) {\n-            argPositions = new int[count + 2];\n-            argPositions[0] = 1; \/\/ indexCoder\n-            argPositions[1] = 0; \/\/ storage\n-        }\n-        int limit = count + 2;\n-        for (int i = 2; i < limit; i++) {\n-            argPositions[i] = i + pos;\n-        }\n-        return argPositions;\n-    }\n-\n-\n-    \/\/ We need one mixer per argument.\n-    private static MethodHandle filterAndFoldInMixers(MethodHandle mh, long initialLengthCoder, Class<?>[] ptypes) {\n-        int pos;\n-        int[] argPositions = null;\n-        for (pos = 0; pos < ptypes.length - 4; pos += 4) {\n-            \/\/ Compute new \"index\" in-place pairwise using old value plus the appropriate arguments.\n-            MethodHandle mix = mixer(ptypes[pos], ptypes[pos + 1], ptypes[pos + 2], ptypes[pos + 3]);\n-            argPositions = filterMixerArgPositions(argPositions, pos, 4);\n-            mh = MethodHandles.filterArgumentsWithCombiner(mh, 0,\n-                    mix, argPositions);\n-        }\n-\n-        if (pos < ptypes.length) {\n-            \/\/ Mix in the last 1 to 4 parameters, insert the initialLengthCoder into the final mixer and\n-            \/\/ fold the result into the main combinator\n-            mh = foldInLastMixers(mh, initialLengthCoder, pos, ptypes, ptypes.length - pos);\n-        } else if (ptypes.length == 0) {\n-            \/\/ No mixer (constants only concat), insert initialLengthCoder directly\n-            mh = MethodHandles.insertArguments(mh, 0, initialLengthCoder);\n-        }\n-        return mh;\n-    }\n-\n-    static int[] filterMixerArgPositions(int[] argPositions, int pos, int count) {\n-        if (argPositions == null || argPositions.length != count + 2) {\n-            argPositions = new int[count + 1];\n-            argPositions[0] = 0; \/\/ indexCoder\n-        }\n-        int limit = count + 1;\n-        for (int i = 1; i < limit; i++) {\n-            argPositions[i] = i + pos;\n-        }\n-        return argPositions;\n-    }\n-\n-    private static MethodHandle foldInLastMixers(MethodHandle mh, long initialLengthCoder, int pos, Class<?>[] ptypes, int count) {\n-        MethodHandle mix = switch (count) {\n-            case 1 -> mixer(ptypes[pos]);\n-            case 2 -> mixer(ptypes[pos], ptypes[pos + 1]);\n-            case 3 -> mixer(ptypes[pos], ptypes[pos + 1], ptypes[pos + 2]);\n-            case 4 -> mixer(ptypes[pos], ptypes[pos + 1], ptypes[pos + 2], ptypes[pos + 3]);\n-            default -> throw new IllegalArgumentException(\"Unexpected count: \" + count);\n-        };\n-        mix = MethodHandles.insertArguments(mix,0, initialLengthCoder);\n-        \/\/ apply selected arguments on the 1-4 arg mixer and fold in the result\n-        return switch (count) {\n-            case 1 -> MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,\n-                    1 + pos);\n-            case 2 -> MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,\n-                    1 + pos, 2 + pos);\n-            case 3 -> MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,\n-                    1 + pos, 2 + pos, 3 + pos);\n-            case 4 -> MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,\n-                    1 + pos, 2 + pos, 3 + pos, 4 + pos);\n-            default -> throw new IllegalArgumentException();\n-        };\n-    }\n-\n-    \/\/ Simple prependers, single argument. May be used directly or as a\n-    \/\/ building block for complex prepender combinators.\n-    private static MethodHandle prepender(String prefix, Class<?> cl) {\n-        if (prefix == null || prefix.isEmpty()) {\n-            return noPrefixPrepender(cl);\n-        } else {\n-            return MethodHandles.insertArguments(\n-                    prepender(cl), 3, prefix);\n-        }\n-    }\n-\n-    private static MethodHandle prepender(Class<?> cl) {\n-        int idx = classIndex(cl);\n-        MethodHandle prepend = PREPENDERS[idx];\n-        if (prepend == null) {\n-            PREPENDERS[idx] = prepend = JLA.stringConcatHelper(\"prepend\",\n-                    methodType(long.class, long.class, byte[].class,\n-                            Wrapper.asPrimitiveType(cl), String.class)).rebind();\n-        }\n-        return prepend;\n-    }\n-\n-    private static MethodHandle noPrefixPrepender(Class<?> cl) {\n-        int idx = classIndex(cl);\n-        MethodHandle prepend = NO_PREFIX_PREPENDERS[idx];\n-        if (prepend == null) {\n-            NO_PREFIX_PREPENDERS[idx] = prepend = MethodHandles.insertArguments(prepender(cl), 3, \"\");\n-        }\n-        return prepend;\n-    }\n-\n-    private static final int INT_IDX = 0,\n-            CHAR_IDX = 1,\n-            LONG_IDX = 2,\n-            BOOLEAN_IDX = 3,\n-            STRING_IDX = 4,\n-            TYPE_COUNT = 5;\n-    private static int classIndex(Class<?> cl) {\n-        if (cl == String.class)                          return STRING_IDX;\n-        if (cl == int.class)                             return INT_IDX;\n-        if (cl == boolean.class)                         return BOOLEAN_IDX;\n-        if (cl == char.class)                            return CHAR_IDX;\n-        if (cl == long.class)                            return LONG_IDX;\n-        throw new IllegalArgumentException(\"Unexpected class: \" + cl);\n-    }\n-\n-    \/\/ Constant argument lists used by the prepender MH builders\n-    private static final int[] PREPEND_FILTER_FIRST_ARGS  = new int[] { 0, 1, 2 };\n-    private static final int[] PREPEND_FILTER_SECOND_ARGS = new int[] { 0, 1, 3 };\n-    private static final int[] PREPEND_FILTER_THIRD_ARGS  = new int[] { 0, 1, 4 };\n-    private static final int[] PREPEND_FILTER_FIRST_PAIR_ARGS  = new int[] { 0, 1, 2, 3 };\n-    private static final int[] PREPEND_FILTER_SECOND_PAIR_ARGS = new int[] { 0, 1, 4, 5 };\n-\n-    \/\/ Base MH for complex prepender combinators.\n-    private static @Stable MethodHandle PREPEND_BASE;\n-    private static MethodHandle prependBase() {\n-        MethodHandle base = PREPEND_BASE;\n-        if (base == null) {\n-            base = PREPEND_BASE = MethodHandles.dropArguments(\n-                    MethodHandles.identity(long.class), 1, byte[].class);\n-        }\n-        return base;\n-    }\n-\n-    private static final @Stable MethodHandle[][] DOUBLE_PREPENDERS = new MethodHandle[TYPE_COUNT][TYPE_COUNT];\n-\n-    private static MethodHandle prepender(String prefix, Class<?> cl, String prefix2, Class<?> cl2) {\n-        int idx1 = classIndex(cl);\n-        int idx2 = classIndex(cl2);\n-        MethodHandle prepend = DOUBLE_PREPENDERS[idx1][idx2];\n-        if (prepend == null) {\n-            prepend = DOUBLE_PREPENDERS[idx1][idx2] =\n-                    MethodHandles.dropArguments(prependBase(), 2, cl, cl2);\n-        }\n-        prepend = MethodHandles.filterArgumentsWithCombiner(prepend, 0, prepender(prefix, cl),\n-                PREPEND_FILTER_FIRST_ARGS);\n-        return MethodHandles.filterArgumentsWithCombiner(prepend, 0, prepender(prefix2, cl2),\n-                PREPEND_FILTER_SECOND_ARGS);\n-    }\n-\n-    private static MethodHandle prepender(int pos, String[] constants, Class<?>[] ptypes, int count) {\n-        \/\/ build the simple cases directly\n-        if (count == 1) {\n-            return prepender(constants[pos], ptypes[pos]);\n-        }\n-        if (count == 2) {\n-            return prepender(constants[pos], ptypes[pos], constants[pos + 1], ptypes[pos + 1]);\n-        }\n-        \/\/ build a tree from an unbound prepender, allowing us to bind the constants in a batch as a final step\n-        MethodHandle prepend = prependBase();\n-        if (count == 3) {\n-            prepend = MethodHandles.dropArguments(prepend, 2,\n-                    ptypes[pos], ptypes[pos + 1], ptypes[pos + 2]);\n-            prepend = MethodHandles.filterArgumentsWithCombiner(prepend, 0,\n-                    prepender(constants[pos], ptypes[pos], constants[pos + 1], ptypes[pos + 1]),\n-                    PREPEND_FILTER_FIRST_PAIR_ARGS);\n-            return MethodHandles.filterArgumentsWithCombiner(prepend, 0,\n-                    prepender(constants[pos + 2], ptypes[pos + 2]),\n-                    PREPEND_FILTER_THIRD_ARGS);\n-        } else if (count == 4) {\n-            prepend = MethodHandles.dropArguments(prepend, 2,\n-                    ptypes[pos], ptypes[pos + 1], ptypes[pos + 2], ptypes[pos + 3]);\n-            prepend = MethodHandles.filterArgumentsWithCombiner(prepend, 0,\n-                    prepender(constants[pos], ptypes[pos], constants[pos + 1], ptypes[pos + 1]),\n-                    PREPEND_FILTER_FIRST_PAIR_ARGS);\n-            return MethodHandles.filterArgumentsWithCombiner(prepend, 0,\n-                    prepender(constants[pos + 2], ptypes[pos + 2], constants[pos + 3], ptypes[pos + 3]),\n-                    PREPEND_FILTER_SECOND_PAIR_ARGS);\n-        } else {\n-            throw new IllegalArgumentException(\"Unexpected count: \" + count);\n-        }\n-    }\n-\n-    \/\/ Constant argument lists used by the mixer MH builders\n-    private static final int[] MIX_FILTER_SECOND_ARGS = new int[] { 0, 2 };\n-    private static final int[] MIX_FILTER_THIRD_ARGS  = new int[] { 0, 3 };\n-    private static final int[] MIX_FILTER_SECOND_PAIR_ARGS = new int[] { 0, 3, 4 };\n-    private static MethodHandle mixer(Class<?> cl) {\n-        int index = classIndex(cl);\n-        MethodHandle mix = MIXERS[index];\n-        if (mix == null) {\n-            MIXERS[index] = mix = JLA.stringConcatHelper(\"mix\",\n-                    methodType(long.class, long.class, Wrapper.asPrimitiveType(cl))).rebind();\n-        }\n-        return mix;\n-    }\n-\n-    private static final @Stable MethodHandle[][] DOUBLE_MIXERS = new MethodHandle[TYPE_COUNT][TYPE_COUNT];\n-    private static MethodHandle mixer(Class<?> cl, Class<?> cl2) {\n-        int idx1 = classIndex(cl);\n-        int idx2 = classIndex(cl2);\n-        MethodHandle mix = DOUBLE_MIXERS[idx1][idx2];\n-        if (mix == null) {\n-            mix = mixer(cl);\n-            mix = MethodHandles.dropArguments(mix, 2, cl2);\n-            DOUBLE_MIXERS[idx1][idx2] = mix = MethodHandles.filterArgumentsWithCombiner(mix, 0,\n-                    mixer(cl2), MIX_FILTER_SECOND_ARGS);\n-        }\n-        return mix;\n-    }\n-\n-    private static MethodHandle mixer(Class<?> cl, Class<?> cl2, Class<?> cl3) {\n-        MethodHandle mix = mixer(cl, cl2);\n-        mix = MethodHandles.dropArguments(mix, 3, cl3);\n-        return MethodHandles.filterArgumentsWithCombiner(mix, 0,\n-                mixer(cl3), MIX_FILTER_THIRD_ARGS);\n-    }\n-\n-    private static MethodHandle mixer(Class<?> cl, Class<?> cl2, Class<?> cl3, Class<?> cl4) {\n-        MethodHandle mix = mixer(cl, cl2);\n-        mix = MethodHandles.dropArguments(mix, 3, cl3, cl4);\n-        return MethodHandles.filterArgumentsWithCombiner(mix, 0,\n-                mixer(cl3, cl4), MIX_FILTER_SECOND_PAIR_ARGS);\n-    }\n-\n@@ -911,22 +524,0 @@\n-    private @Stable static MethodHandle NEW_STRING;\n-    private static MethodHandle newString() {\n-        MethodHandle mh = NEW_STRING;\n-        if (mh == null) {\n-            MethodHandle newString = JLA.stringConcatHelper(\"newString\",\n-                    methodType(String.class, byte[].class, long.class));\n-            NEW_STRING = mh = newString.rebind();\n-        }\n-        return mh;\n-    }\n-\n-    private @Stable static MethodHandle NEW_ARRAY_SUFFIX;\n-    private static MethodHandle newArrayWithSuffix(String suffix) {\n-        MethodHandle mh = NEW_ARRAY_SUFFIX;\n-        if (mh == null) {\n-            MethodHandle newArrayWithSuffix = JLA.stringConcatHelper(\"newArrayWithSuffix\",\n-                    methodType(byte[].class, String.class, long.class));\n-            NEW_ARRAY_SUFFIX = mh = newArrayWithSuffix.rebind();\n-        }\n-        return MethodHandles.insertArguments(mh, 0, suffix);\n-    }\n-\n@@ -938,9 +529,0 @@\n-    private @Stable static MethodHandle OBJECT_STRINGIFIER;\n-    private static MethodHandle objectStringifier() {\n-        MethodHandle mh = OBJECT_STRINGIFIER;\n-        if (mh == null) {\n-            OBJECT_STRINGIFIER = mh = JLA.stringConcatHelper(\"stringOf\",\n-                    methodType(String.class, Object.class));\n-        }\n-        return mh;\n-    }\n@@ -1030,32 +612,0 @@\n-    private static final @Stable MethodHandle[] NO_PREFIX_PREPENDERS = new MethodHandle[TYPE_COUNT];\n-    private static final @Stable MethodHandle[] PREPENDERS      = new MethodHandle[TYPE_COUNT];\n-    private static final @Stable MethodHandle[] MIXERS          = new MethodHandle[TYPE_COUNT];\n-    private static final long INITIAL_CODER = JLA.stringConcatInitialCoder();\n-\n-    \/**\n-     * Promote integral types to int.\n-     *\/\n-    private static Class<?> promoteToIntType(Class<?> t) {\n-        \/\/ use int for subword integral types; still need special mixers\n-        \/\/ and prependers for char, boolean\n-        return t == byte.class || t == short.class ? int.class : t;\n-    }\n-\n-    \/**\n-     * Returns a stringifier for references and floats\/doubles only.\n-     * Always returns null for other primitives.\n-     *\n-     * @param t class to stringify\n-     * @return stringifier; null, if not available\n-     *\/\n-    private static MethodHandle stringifierFor(Class<?> t) {\n-        if (t == Object.class) {\n-            return objectStringifier();\n-        } else if (t == float.class) {\n-            return floatStringifier();\n-        } else if (t == double.class) {\n-            return doubleStringifier();\n-        }\n-        return null;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":0,"deletions":450,"binary":false,"changes":450,"status":"modified"},{"patch":"@@ -455,15 +455,0 @@\n-    \/**\n-     * Get the string concat initial coder\n-     *\/\n-    long stringConcatInitialCoder();\n-\n-    \/**\n-     * Update lengthCoder for constant\n-     *\/\n-    long stringConcatMix(long lengthCoder, String constant);\n-\n-    \/**\n-     * Mix value length and coder into current length and coder.\n-     *\/\n-    long stringConcatMix(long lengthCoder, char value);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"}]}