{"files":[{"patch":"@@ -196,0 +196,6 @@\n+    int base_offset = arrayOopDesc::length_offset_in_bytes() + BytesPerInt;\n+    if (!is_aligned(base_offset, BytesPerWord)) {\n+      assert(is_aligned(base_offset, BytesPerInt), \"must be 4-byte aligned\");\n+      \/\/ Clear gap\/first 4 bytes following the length field.\n+      strw(zr, Address(obj, base_offset));\n+    }\n@@ -295,11 +301,3 @@\n-  \/\/ Clear leading 4 bytes, if necessary.\n-  \/\/ TODO: This could perhaps go into initialize_body() and also clear the leading 4 bytes\n-  \/\/ for non-array objects, thereby replacing the klass-gap clearing code in initialize_header().\n-  int base_offset = base_offset_in_bytes;\n-  if (!is_aligned(base_offset, BytesPerWord)) {\n-    assert(is_aligned(base_offset, BytesPerInt), \"must be 4-byte aligned\");\n-    strw(zr, Address(obj, base_offset));\n-    base_offset += BytesPerInt;\n-  }\n-  assert(is_aligned(base_offset, BytesPerWord), \"must be word-aligned\");\n-\n+  \/\/ Align-up to word boundary, because we clear the 4 bytes potentially\n+  \/\/ following the length field in initialize_header().\n+  int base_offset = align_up(base_offset_in_bytes, BytesPerWord);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -192,0 +192,1 @@\n+      assert(is_aligned(base_offset, BytesPerInt), \"must be 4-byte aligned\");\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}