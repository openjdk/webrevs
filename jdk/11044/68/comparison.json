{"files":[{"patch":"@@ -1212,1 +1212,1 @@\n-                      arrayOopDesc::header_size(op->type()),\n+                      arrayOopDesc::base_offset_in_bytes(op->type()),\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -196,0 +196,6 @@\n+    int base_offset = arrayOopDesc::length_offset_in_bytes() + BytesPerInt;\n+    if (!is_aligned(base_offset, BytesPerWord)) {\n+      assert(is_aligned(base_offset, BytesPerInt), \"must be 4-byte aligned\");\n+      \/\/ Clear gap\/first 4 bytes following the length field.\n+      strw(zr, Address(obj, base_offset));\n+    }\n@@ -274,1 +280,1 @@\n-void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int header_size, int f, Register klass, Label& slow_case) {\n+void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int base_offset_in_bytes, int f, Register klass, Label& slow_case) {\n@@ -287,1 +293,1 @@\n-  mov(arr_size, (int32_t)header_size * BytesPerWord + MinObjAlignmentInBytesMask);\n+  mov(arr_size, (int32_t)base_offset_in_bytes + MinObjAlignmentInBytesMask);\n@@ -295,0 +301,3 @@\n+  \/\/ Align-up to word boundary, because we clear the 4 bytes potentially\n+  \/\/ following the length field in initialize_header().\n+  int base_offset = align_up(base_offset_in_bytes, BytesPerWord);\n@@ -296,1 +305,1 @@\n-  initialize_body(obj, arr_size, header_size * BytesPerWord, t1, t2);\n+  initialize_body(obj, arr_size, base_offset, t1, t2);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,1 +103,1 @@\n-  void allocate_array(Register obj, Register len, Register t, Register t2, int header_size, int f, Register klass, Label& slow_case);\n+  void allocate_array(Register obj, Register len, Register t, Register t2, int base_offset_in_bytes, int f, Register klass, Label& slow_case);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -971,1 +971,1 @@\n-                      arrayOopDesc::header_size(op->type()),\n+                      arrayOopDesc::base_offset_in_bytes(op->type()),\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2301,1 +2301,1 @@\n-                      arrayOopDesc::header_size(op->type()),\n+                      arrayOopDesc::base_offset_in_bytes(op->type()),\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -313,1 +313,1 @@\n-  int      hdr_size,                   \/\/ object header size in words\n+  int      base_offset_in_bytes,       \/\/ elements offset in bytes\n@@ -345,1 +345,1 @@\n-  addi(arr_size, arr_len_in_bytes, hdr_size * wordSize + MinObjAlignmentInBytesMask); \/\/ Add space for header & alignment.\n+  addi(arr_size, arr_len_in_bytes, base_offset_in_bytes + MinObjAlignmentInBytesMask); \/\/ Add space for header & alignment.\n@@ -355,2 +355,12 @@\n-  addi(base, obj, hdr_size * wordSize);               \/\/ compute address of first element\n-  addi(index, arr_size, -(hdr_size * wordSize));      \/\/ compute index = number of bytes to clear\n+  addi(base, obj, base_offset_in_bytes);               \/\/ compute address of first element\n+  addi(index, arr_size, -(base_offset_in_bytes));      \/\/ compute index = number of bytes to clear\n+\n+  \/\/ Zero first 4 bytes, if start offset is not word aligned.\n+  if (!is_aligned(base_offset_in_bytes, BytesPerWord)) {\n+    assert(is_aligned(base_offset_in_bytes, BytesPerInt), \"must be 4-byte aligned\");\n+    li(t1, 0);\n+    stw(t1, 0, base);\n+    addi(base, base, BytesPerInt);\n+    \/\/ Note: initialize_body will align index down, no need to correct it here.\n+  }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,1 +83,1 @@\n-    int      hdr_size,                 \/\/ object header size in words\n+    int      base_offset_in_bytes,     \/\/ elements offset in bytes\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1023,1 +1023,1 @@\n-                      arrayOopDesc::header_size(op->type()),\n+                      arrayOopDesc::base_offset_in_bytes(op->type()),\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -283,1 +283,1 @@\n-void C1_MacroAssembler::allocate_array(Register obj, Register len, Register tmp1, Register tmp2, int header_size, int f, Register klass, Label& slow_case) {\n+void C1_MacroAssembler::allocate_array(Register obj, Register len, Register tmp1, Register tmp2, int base_offset_in_bytes, int f, Register klass, Label& slow_case) {\n@@ -295,1 +295,1 @@\n-  mv(arr_size, (int32_t)header_size * BytesPerWord + MinObjAlignmentInBytesMask);\n+  mv(arr_size, (int32_t)base_offset_in_bytes + MinObjAlignmentInBytesMask);\n@@ -303,0 +303,11 @@\n+  \/\/ Clear leading 4 bytes, if necessary.\n+  \/\/ TODO: This could perhaps go into initialize_body() and also clear the leading 4 bytes\n+  \/\/ for non-array objects, thereby replacing the klass-gap clearing code in initialize_header().\n+  int base_offset = base_offset_in_bytes;\n+  if (!is_aligned(base_offset, BytesPerWord)) {\n+    assert(is_aligned(base_offset, BytesPerInt), \"must be 4-byte aligned\");\n+    sw(zr, Address(obj, base_offset));\n+    base_offset += BytesPerInt;\n+  }\n+  assert(is_aligned(base_offset, BytesPerWord), \"must be word-aligned\");\n+\n@@ -305,1 +316,1 @@\n-  initialize_body(obj, arr_size, header_size * BytesPerWord, len_zero);\n+  initialize_body(obj, arr_size, base_offset, len_zero);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-  void allocate_array(Register obj, Register len, Register tmp1, Register tmp2, int header_size, int f, Register klass, Label& slow_case);\n+  void allocate_array(Register obj, Register len, Register tmp1, Register tmp2, int base_offset_in_bytes, int f, Register klass, Label& slow_case);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2385,1 +2385,1 @@\n-                      arrayOopDesc::header_size(op->type()),\n+                      arrayOopDesc::base_offset_in_bytes(op->type()),\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -274,1 +274,1 @@\n-  int      hdr_size,                   \/\/ object header size in words\n+  int      base_offset_in_bytes,       \/\/ elements offset in bytes\n@@ -300,2 +300,2 @@\n-  add2reg(arr_size, hdr_size * wordSize + MinObjAlignmentInBytesMask); \/\/ Add space for header & alignment.\n-  z_nill(arr_size, (~MinObjAlignmentInBytesMask) & 0xffff);            \/\/ Align array size.\n+  add2reg(arr_size, base_offset_in_bytes + MinObjAlignmentInBytesMask); \/\/ Add space for header & alignment.\n+  z_nill(arr_size, (~MinObjAlignmentInBytesMask) & 0xffff);             \/\/ Align array size.\n@@ -311,1 +311,1 @@\n-  z_aghi(arr_size, -(hdr_size * BytesPerWord));\n+  z_aghi(arr_size, -base_offset_in_bytes);\n@@ -313,1 +313,1 @@\n-  z_la(object_fields, hdr_size * BytesPerWord, obj);\n+  z_la(object_fields, base_offset_in_bytes, obj);\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,1 +89,1 @@\n-    int      hdr_size,                 \/\/ object header size in words\n+    int      base_offset_in_bytes,     \/\/ elements offset in bytes\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1621,1 +1621,1 @@\n-                      arrayOopDesc::header_size(op->type()),\n+                      arrayOopDesc::base_offset_in_bytes(op->type()),\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -189,0 +189,9 @@\n+#ifdef _LP64\n+    int base_offset = arrayOopDesc::length_offset_in_bytes() + BytesPerInt;\n+    if (!is_aligned(base_offset, BytesPerWord)) {\n+      assert(is_aligned(base_offset, BytesPerInt), \"must be 4-byte aligned\");\n+      \/\/ Clear gap\/first 4 bytes following the length field.\n+      xorl(t1, t1);\n+      movl(Address(obj, base_offset), t1);\n+    }\n+#endif\n@@ -272,1 +281,1 @@\n-void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int header_size, Address::ScaleFactor f, Register klass, Label& slow_case) {\n+void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int base_offset_in_bytes, Address::ScaleFactor f, Register klass, Label& slow_case) {\n@@ -285,1 +294,1 @@\n-  movptr(arr_size, header_size * BytesPerWord + MinObjAlignmentInBytesMask);\n+  movptr(arr_size, base_offset_in_bytes + MinObjAlignmentInBytesMask);\n@@ -295,1 +304,4 @@\n-  initialize_body(obj, arr_size, header_size * BytesPerWord, len_zero);\n+  \/\/ Align-up to word boundary, because we clear the 4 bytes potentially\n+  \/\/ following the length field in initialize_header().\n+  int base_offset = align_up(base_offset_in_bytes, BytesPerWord);\n+  initialize_body(obj, arr_size, base_offset, len_zero);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,1 @@\n-  void allocate_array(Register obj, Register len, Register t, Register t2, int header_size, Address::ScaleFactor f, Register klass, Label& slow_case);\n+  void allocate_array(Register obj, Register len, Register t, Register t2, int base_offset_in_bytes, Address::ScaleFactor f, Register klass, Label& slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -405,0 +405,7 @@\n+\/\/ Returns the header size in words aligned to the requirements of the\n+\/\/ array object type.\n+static int int_array_header_size() {\n+  size_t typesize_in_bytes = arrayOopDesc::header_size_in_bytes();\n+  return (int)align_up(typesize_in_bytes, HeapWordSize)\/HeapWordSize;\n+}\n+\n@@ -414,1 +421,1 @@\n-  size_t max_int_size = typeArrayOopDesc::header_size(T_INT) +\n+  size_t max_int_size = int_array_header_size() +\n@@ -421,1 +428,1 @@\n-  return align_object_offset(arrayOopDesc::header_size(T_INT)); \/\/ align to Long\n+  return align_object_offset(int_array_header_size()); \/\/ align to Long\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,11 @@\n-  const size_t header = arrayOopDesc::header_size(element_type);\n+\n+  \/\/ Clear leading 32 bits, if necessary.\n+  int base_offset = arrayOopDesc::base_offset_in_bytes(element_type);\n+  if (!is_aligned(base_offset, HeapWordSize)) {\n+    assert(is_aligned(base_offset, BytesPerInt), \"array base must be 32 bit aligned\");\n+    *reinterpret_cast<jint*>(reinterpret_cast<char*>(mem) + base_offset) = 0;\n+    base_offset += BytesPerInt;\n+  }\n+  assert(is_aligned(base_offset, HeapWordSize), \"remaining array base must be 64 bit aligned\");\n+\n+  const size_t header = heap_word_size(base_offset);\n","filename":"src\/hotspot\/share\/gc\/x\/xObjArrayAllocator.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,11 @@\n-  const size_t header = arrayOopDesc::header_size(element_type);\n+\n+  \/\/ Clear leading 32 bits, if necessary.\n+  int base_offset = arrayOopDesc::base_offset_in_bytes(element_type);\n+  if (!is_aligned(base_offset, HeapWordSize)) {\n+    assert(is_aligned(base_offset, BytesPerInt), \"array base must be 32 bit aligned\");\n+    *reinterpret_cast<jint*>(reinterpret_cast<char*>(mem) + base_offset) = 0;\n+    base_offset += BytesPerInt;\n+  }\n+  assert(is_aligned(base_offset, HeapWordSize), \"remaining array base must be 64 bit aligned\");\n+\n+  const size_t header = heap_word_size(base_offset);\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2445,1 +2445,1 @@\n-  return arrayOopDesc::header_size(type) * HeapWordSize;\n+  return arrayOopDesc::base_offset_in_bytes(type);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -48,0 +49,18 @@\n+private:\n+  \/\/ Returns the address of the length \"field\".  See length_offset_in_bytes().\n+  static int* length_addr_impl(void* obj_ptr) {\n+    char* ptr = static_cast<char*>(obj_ptr);\n+    return reinterpret_cast<int*>(ptr + length_offset_in_bytes());\n+  }\n+\n+  \/\/ Given a type, return true if elements of that type must be aligned to 64-bit.\n+  static bool element_type_should_be_aligned(BasicType type) {\n+#ifdef _LP64\n+    if (type == T_OBJECT || type == T_ARRAY) {\n+      return !UseCompressedOops;\n+    }\n+#endif\n+    return type == T_DOUBLE || type == T_LONG;\n+  }\n+\n+ public:\n@@ -50,2 +69,1 @@\n-  \/\/ Returns the aligned header_size_in_bytes.  This is not equivalent to\n-  \/\/ sizeof(arrayOopDesc) which should not appear in the code.\n+  \/\/ This is not equivalent to sizeof(arrayOopDesc) which should not appear in the code.\n@@ -53,2 +71,1 @@\n-    size_t hs = align_up(length_offset_in_bytes() + sizeof(int),\n-                              HeapWordSize);\n+    size_t hs = length_offset_in_bytes() + sizeof(int);\n@@ -64,14 +81,0 @@\n-  \/\/ Returns the address of the length \"field\".  See length_offset_in_bytes().\n-  static int* length_addr_impl(void* obj_ptr) {\n-    char* ptr = static_cast<char*>(obj_ptr);\n-    return reinterpret_cast<int*>(ptr + length_offset_in_bytes());\n-  }\n-\n-  \/\/ Check whether an element of a typeArrayOop with the given type must be\n-  \/\/ aligned 0 mod 8.  The typeArrayOop itself must be aligned at least this\n-  \/\/ strongly.\n-  static bool element_type_should_be_aligned(BasicType type) {\n-    return type == T_DOUBLE || type == T_LONG;\n-  }\n-\n- public:\n@@ -88,1 +91,2 @@\n-    return header_size(type) * HeapWordSize;\n+    size_t hs = header_size_in_bytes();\n+    return (int)(element_type_should_be_aligned(type) ? align_up(hs, BytesPerLong) : hs);\n@@ -125,12 +129,1 @@\n-  \/\/ Should only be called with constants as argument\n-  \/\/ (will not constant fold otherwise)\n-  \/\/ Returns the header size in words aligned to the requirements of the\n-  \/\/ array object type.\n-  static int header_size(BasicType type) {\n-    size_t typesize_in_bytes = header_size_in_bytes();\n-    return (int)(element_type_should_be_aligned(type)\n-      ? align_object_offset(typesize_in_bytes\/HeapWordSize)\n-      : typesize_in_bytes\/HeapWordSize);\n-  }\n-\n-  \/\/ Return the maximum length of an array of BasicType.  The length can passed\n+  \/\/ Return the maximum length of an array of BasicType.  The length can be passed\n@@ -144,0 +137,4 @@\n+    size_t hdr_size_in_bytes = base_offset_in_bytes(type);\n+    \/\/ This is rounded-up and may overlap with the first array elements.\n+    size_t hdr_size_in_words = align_up(hdr_size_in_bytes, HeapWordSize) \/ HeapWordSize;\n+\n@@ -145,1 +142,1 @@\n-      align_down((SIZE_MAX\/HeapWordSize - header_size(type)), MinObjAlignment);\n+      align_down((SIZE_MAX\/HeapWordSize - hdr_size_in_words), MinObjAlignment);\n@@ -153,1 +150,1 @@\n-      return align_down(max_jint - header_size(type), MinObjAlignment);\n+      return align_down(max_jint - hdr_size_in_words, MinObjAlignment);\n","filename":"src\/hotspot\/share\/oops\/arrayOop.hpp","additions":31,"deletions":34,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,26 +54,0 @@\n-private:\n-  \/\/ Give size of objArrayOop in HeapWords minus the header\n-  static int array_size(int length) {\n-    const uint OopsPerHeapWord = HeapWordSize\/heapOopSize;\n-    assert(OopsPerHeapWord >= 1 && (HeapWordSize % heapOopSize == 0),\n-           \"Else the following (new) computation would be in error\");\n-    uint res = ((uint)length + OopsPerHeapWord - 1)\/OopsPerHeapWord;\n-#ifdef ASSERT\n-    \/\/ The old code is left in for sanity-checking; it'll\n-    \/\/ go away pretty soon. XXX\n-    \/\/ Without UseCompressedOops, this is simply:\n-    \/\/ oop->length() * HeapWordsPerOop;\n-    \/\/ With narrowOops, HeapWordsPerOop is 1\/2 or equal 0 as an integer.\n-    \/\/ The oop elements are aligned up to wordSize\n-    const uint HeapWordsPerOop = heapOopSize\/HeapWordSize;\n-    uint old_res;\n-    if (HeapWordsPerOop > 0) {\n-      old_res = length * HeapWordsPerOop;\n-    } else {\n-      old_res = align_up((uint)length, OopsPerHeapWord)\/OopsPerHeapWord;\n-    }\n-    assert(res == old_res, \"Inconsistency between old and new.\");\n-#endif  \/\/ ASSERT\n-    return res;\n-  }\n-\n@@ -97,1 +71,0 @@\n-  static int header_size()    { return arrayOopDesc::header_size(T_OBJECT); }\n@@ -102,5 +75,5 @@\n-    uint asz = array_size(length);\n-    uint osz = align_object_size(header_size() + asz);\n-    assert(osz >= asz,   \"no overflow\");\n-    assert((int)osz > 0, \"no overflow\");\n-    return (size_t)osz;\n+    size_t asz = (size_t)length * heapOopSize;\n+    size_t size_words = heap_word_size(base_offset_in_bytes() + asz);\n+    size_t osz = align_object_size(size_words);\n+    assert(osz < max_jint, \"no overflow\");\n+    return osz;\n","filename":"src\/hotspot\/share\/oops\/objArrayOop.hpp","additions":6,"deletions":33,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -322,3 +322,2 @@\n-    const size_t hs = arrayOopDesc::header_size(elem_type);\n-    \/\/ Align to next 8 bytes to avoid trashing arrays's length.\n-    const size_t aligned_hs = align_object_offset(hs);\n+    size_t hs_bytes = arrayOopDesc::base_offset_in_bytes(elem_type);\n+    assert(is_aligned(hs_bytes, BytesPerInt), \"must be 4 byte aligned\");\n@@ -326,2 +325,3 @@\n-    if (aligned_hs > hs) {\n-      Copy::zero_to_words(obj+hs, aligned_hs-hs);\n+    if (!is_aligned(hs_bytes, BytesPerLong)) {\n+      *reinterpret_cast<jint*>(reinterpret_cast<char*>(obj) + hs_bytes) = 0;\n+      hs_bytes += BytesPerInt;\n@@ -329,0 +329,1 @@\n+\n@@ -330,0 +331,2 @@\n+    assert(is_aligned(hs_bytes, BytesPerLong), \"must be 8-byte aligned\");\n+    const size_t aligned_hs = hs_bytes \/ BytesPerLong;\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -5172,1 +5172,2 @@\n-    int header_size = objArrayOopDesc::header_size() * wordSize;\n+    BasicType basic_elem_type = elem()->basic_type();\n+    int header_size = arrayOopDesc::base_offset_in_bytes(basic_elem_type);\n@@ -5177,1 +5178,0 @@\n-      BasicType basic_elem_type = elem()->basic_type();\n@@ -5181,1 +5181,0 @@\n-        int array_base = arrayOopDesc::base_offset_in_bytes(basic_elem_type);\n@@ -5183,1 +5182,1 @@\n-        st->print(\"[%d]\", (_offset - array_base)\/elem_size);\n+        st->print(\"[%d]\", (_offset - header_size)\/elem_size);\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-  ( arrayOopDesc::header_size(T_DOUBLE) * HeapWordSize \\\n+  ( arrayOopDesc::base_offset_in_bytes(T_DOUBLE) \\\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,7 +119,0 @@\n-  \/\/ Check whether an element of a typeArrayOop with the given type must be\n-  \/\/ aligned 0 mod 8.  The typeArrayOop itself must be aligned at least this\n-  \/\/ strongly.\n-  public static boolean elementTypeShouldBeAligned(BasicType type) {\n-    return type == BasicType.T_DOUBLE || type == BasicType.T_LONG;\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/memory\/Universe.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,0 +60,12 @@\n+  \/\/ Check whether an element of a arrayOop with the given type must be\n+  \/\/ aligned 0 mod 8.  The arrayOop itself must be aligned at least this\n+  \/\/ strongly.\n+  private static boolean elementTypeShouldBeAligned(BasicType type) {\n+    if (VM.getVM().isLP64()) {\n+      if (type == BasicType.T_OBJECT || type == BasicType.T_ARRAY) {\n+        return !VM.getVM().isCompressedOopsEnabled();\n+      }\n+    }\n+    return type == BasicType.T_DOUBLE || type == BasicType.T_LONG;\n+  }\n+\n@@ -64,6 +76,1 @@\n-    if (VM.getVM().isCompressedKlassPointersEnabled()) {\n-      headerSize = typeSize;\n-    } else {\n-      headerSize = VM.getVM().alignUp(typeSize + VM.getVM().getIntSize(),\n-                                      VM.getVM().getHeapWordSize());\n-    }\n+    headerSize = lengthOffsetInBytes() + VM.getVM().getIntSize();\n@@ -73,9 +80,1 @@\n-  private static long headerSize(BasicType type) {\n-    if (Universe.elementTypeShouldBeAligned(type)) {\n-       return alignObjectSize(headerSizeInBytes())\/VM.getVM().getHeapWordSize();\n-    } else {\n-      return headerSizeInBytes()\/VM.getVM().getHeapWordSize();\n-    }\n-  }\n-\n-  private long lengthOffsetInBytes() {\n+  private static long lengthOffsetInBytes() {\n@@ -111,1 +110,7 @@\n-    return headerSize(type) * VM.getVM().getHeapWordSize();\n+    long typeSizeInBytes = headerSizeInBytes();\n+    if (elementTypeShouldBeAligned(type)) {\n+      VM vm = VM.getVM();\n+      return vm.alignUp(typeSizeInBytes, vm.getVM().getHeapWordSize());\n+    } else {\n+      return typeSizeInBytes;\n+    }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Array.java","additions":22,"deletions":17,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,8 +30,0 @@\n-class arrayOopDescTest {\n- public:\n-\n-  static int header_size_in_bytes() {\n-    return arrayOopDesc::header_size_in_bytes();\n-  }\n-};\n-\n@@ -42,1 +34,1 @@\n-          + arrayOopDescTest::header_size_in_bytes();\n+          + arrayOopDesc::base_offset_in_bytes(type);\n@@ -90,0 +82,44 @@\n+\n+TEST_VM(arrayOopDesc, base_offset) {\n+#ifdef _LP64\n+  if (UseCompressedClassPointers) {\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_BOOLEAN), 16);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_BYTE),    16);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_SHORT),   16);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_CHAR),    16);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_INT),     16);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_FLOAT),   16);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_LONG),    16);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_DOUBLE),  16);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_OBJECT),  16);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_ARRAY),   16);\n+  } else {\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_BOOLEAN), 20);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_BYTE),    20);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_SHORT),   20);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_CHAR),    20);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_INT),     20);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_FLOAT),   20);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_LONG),    24);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_DOUBLE),  24);\n+    if (UseCompressedOops) {\n+      EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_OBJECT), 20);\n+      EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_ARRAY),  20);\n+    } else {\n+      EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_OBJECT), 24);\n+      EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_ARRAY),  24);\n+    }\n+  }\n+#else\n+  EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_BOOLEAN), 12);\n+  EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_BYTE),    12);\n+  EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_SHORT),   12);\n+  EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_CHAR),    12);\n+  EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_INT),     12);\n+  EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_FLOAT),   12);\n+  EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_LONG),    16);\n+  EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_DOUBLE),  16);\n+  EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_OBJECT),  12);\n+  EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_ARRAY),   12);\n+#endif\n+}\n","filename":"test\/hotspot\/gtest\/oops\/test_arrayOop.cpp","additions":46,"deletions":10,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"oops\/objArrayOop.hpp\"\n+#include \"unittest.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+TEST_VM(objArrayOop, osize) {\n+  static const struct {\n+    int objal; bool ccp; bool coops; int result;\n+  } x[] = {\n+\/\/    ObjAligInB, UseCCP, UseCoops, object size in heap words\n+#ifdef _LP64\n+    { 8,          false,  false,    4 },  \/\/ 20 byte header, 8 byte oops\n+    { 8,          false,  true,     3 },  \/\/ 20 byte header, 4 byte oops\n+    { 8,          true,   false,    3 },  \/\/ 16 byte header, 8 byte oops\n+    { 8,          true,   true,     3 },  \/\/ 16 byte header, 4 byte oops\n+    { 16,         false,  false,    4 },  \/\/ 20 byte header, 8 byte oops, 16-byte align\n+    { 16,         false,  true,     4 },  \/\/ 20 byte header, 4 byte oops, 16-byte align\n+    { 16,         true,   false,    4 },  \/\/ 16 byte header, 8 byte oops, 16-byte align\n+    { 16,         true,   true,     4 },  \/\/ 16 byte header, 4 byte oops, 16-byte align\n+    { 256,        false,  false,    32 }, \/\/ 20 byte header, 8 byte oops, 256-byte align\n+    { 256,        false,  true,     32 }, \/\/ 20 byte header, 4 byte oops, 256-byte align\n+    { 256,        true,   false,    32 }, \/\/ 16 byte header, 8 byte oops, 256-byte align\n+    { 256,        true,   true,     32 }, \/\/ 16 byte header, 4 byte oops, 256-byte align\n+#else\n+    { 8,          false,  false,    4 }, \/\/ 12 byte header, 4 byte oops, wordsize 4\n+#endif\n+    { -1,         false,  false,   -1 }\n+  };\n+  for (int i = 0; x[i].result != -1; i++) {\n+    if (x[i].objal == (int)ObjectAlignmentInBytes && x[i].ccp == UseCompressedClassPointers && x[i].coops == UseCompressedOops) {\n+      EXPECT_EQ(objArrayOopDesc::object_size(1), (size_t)x[i].result);\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/oops\/test_objArrayOop.cpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * This tests object array sizes by running gtests with different settings.\n+ *\/\n+\n+\/* @test id=with-coops-with-ccp\n+ * @summary Run object array size tests with compressed oops and compressed class pointers\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @run main\/native GTestWrapper --gtest_filter=arrayOop -XX:+UseCompressedClassPointers -XX:+UseCompressedOops\n+ *\/\n+\/* @test id=with-coops-no-ccp\n+ * @summary Run object array size tests with compressed oops and compressed class pointers\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @run main\/native GTestWrapper --gtest_filter=arrayOop -XX:-UseCompressedClassPointers -XX:+UseCompressedOops\n+ *\/\n+\/* @test id=no-coops-with-ccp\n+ * @summary Run object array size tests with compressed oops and compressed class pointers\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @run main\/native GTestWrapper --gtest_filter=arrayOop -XX:+UseCompressedClassPointers -XX:-UseCompressedOops\n+ *\/\n+\/* @test id=no-coops-no-ccp\n+ * @summary Run object array size tests with compressed oops and compressed class pointers\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @run main\/native GTestWrapper --gtest_filter=arrayOop -XX:-UseCompressedClassPointers -XX:-UseCompressedOops\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gtest\/ArrayTests.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * This tests object array sizes by running gtests with different settings.\n+ *\/\n+\n+\/* @test id=with-coops-with-ccp\n+ * @summary Run object array size tests with compressed oops and compressed class pointers\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @run main\/native GTestWrapper --gtest_filter=objArrayOop -XX:+UseCompressedClassPointers -XX:+UseCompressedOops\n+ *\/\n+\/* @test id=with-coops-no-ccp\n+ * @summary Run object array size tests with compressed oops and compressed class pointers\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @run main\/native GTestWrapper --gtest_filter=objArrayOop -XX:-UseCompressedClassPointers -XX:+UseCompressedOops\n+ *\/\n+\/* @test id=no-coops-with-ccp\n+ * @summary Run object array size tests with compressed oops and compressed class pointers\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @run main\/native GTestWrapper --gtest_filter=objArrayOop -XX:+UseCompressedClassPointers -XX:-UseCompressedOops\n+ *\/\n+\/* @test id=no-coops-no-ccp\n+ * @summary Run object array size tests with compressed oops and compressed class pointers\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @run main\/native GTestWrapper --gtest_filter=objArrayOop -XX:-UseCompressedClassPointers -XX:-UseCompressedOops\n+ *\/\n+\n+\/* @test id=with-coops-with-ccp-large-align\n+ * @summary Run object array size tests with compressed oops and compressed class pointers\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @run main\/native GTestWrapper --gtest_filter=objArrayOop -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:ObjAlignmentInBytes=256\n+ *\/\n+\/* @test id=with-coops-no-ccp-large-align\n+ * @summary Run object array size tests with compressed oops and compressed class pointers\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @run main\/native GTestWrapper --gtest_filter=objArrayOop -XX:-UseCompressedClassPointers -XX:+UseCompressedOops -XX:ObjAlignmentInBytes=256\n+ *\/\n+\/* @test id=no-coops-with-ccp-large-align\n+ * @summary Run object array size tests with compressed oops and compressed class pointers\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @run main\/native GTestWrapper --gtest_filter=objArrayOop -XX:+UseCompressedClassPointers -XX:-UseCompressedOops -XX:ObjAlignmentInBytes=256\n+ *\/\n+\/* @test id=no-coops-no-ccp-large-align\n+ * @summary Run object array size tests with compressed oops and compressed class pointers\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @run main\/native GTestWrapper --gtest_filter=objArrayOop -XX:-UseCompressedClassPointers -XX:-UseCompressedOops -XX:ObjAlignmentInBytes=256\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gtest\/ObjArrayTests.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=with-coops-no-ccp\n+ * @library \/test\/lib\n+ * @requires vm.bits == \"64\"\n+ * @modules java.base\/jdk.internal.misc\n+ * @run main\/othervm -XX:+UseCompressedOops -XX:-UseCompressedClassPointers ArrayBaseOffsets\n+ *\/\n+\/*\n+ * @test id=with-coops-with-ccp\n+ * @library \/test\/lib\n+ * @requires vm.bits == \"64\"\n+ * @requires vm.opt.UseCompressedClassPointers != false\n+ * @modules java.base\/jdk.internal.misc\n+ * @run main\/othervm -XX:+UseCompressedOops -XX:+UseCompressedClassPointers ArrayBaseOffsets\n+ *\/\n+\/*\n+ * @test id=no-coops-no-ccp\n+ * @library \/test\/lib\n+ * @requires vm.bits == \"64\"\n+ * @modules java.base\/jdk.internal.misc\n+ * @run main\/othervm -XX:-UseCompressedOops -XX:-UseCompressedClassPointers ArrayBaseOffsets\n+ *\/\n+\/*\n+ * @test id=no-coops-with-ccp\n+ * @library \/test\/lib\n+ * @requires vm.bits == \"64\"\n+ * @requires vm.opt.UseCompressedClassPointers != false\n+ * @modules java.base\/jdk.internal.misc\n+ * @run main\/othervm -XX:-UseCompressedOops -XX:+UseCompressedClassPointers ArrayBaseOffsets\n+ *\/\n+\/*\n+ * @test id=32bit\n+ * @library \/test\/lib\n+ * @requires vm.bits == \"32\"\n+ * @modules java.base\/jdk.internal.misc\n+ * @run main\/othervm ArrayBaseOffsets\n+ *\/\n+\n+import jdk.internal.misc.Unsafe;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.RuntimeMXBean;\n+import java.util.List;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Platform;\n+\n+public class ArrayBaseOffsets {\n+\n+    private static final boolean COOP;\n+    private static final boolean CCP;\n+\n+    static {\n+        if (Platform.is64bit()) {\n+            RuntimeMXBean runtime = ManagementFactory.getRuntimeMXBean();\n+            List<String> vmargs = runtime.getInputArguments();\n+            CCP = !vmargs.contains(\"-XX:-UseCompressedClassPointers\");\n+            COOP = System.getProperty(\"java.vm.compressedOopsMode\") != null;\n+        } else {\n+            COOP = CCP = false;\n+        }\n+    }\n+\n+    static public void main(String[] args) {\n+        Unsafe unsafe = Unsafe.getUnsafe();\n+        int intOffset, longOffset;\n+        if (Platform.is64bit()) {\n+            if (CCP) {\n+                intOffset = 16;\n+                longOffset = 16;\n+            } else {\n+                intOffset = 20;\n+                longOffset = 24;\n+            }\n+        } else {\n+            intOffset = 12;\n+            longOffset = 16;\n+        }\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(boolean[].class), intOffset,  \"Misplaced boolean array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(byte[].class),    intOffset,  \"Misplaced byte    array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(char[].class),    intOffset,  \"Misplaced char    array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(short[].class),   intOffset,  \"Misplaced short   array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(int[].class),     intOffset,  \"Misplaced int     array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(long[].class),    longOffset, \"Misplaced long    array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(float[].class),   intOffset,  \"Misplaced float   array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(double[].class),  longOffset, \"Misplaced double  array base\");\n+        int expectedObjArrayOffset = (COOP || !Platform.is64bit()) ? intOffset : longOffset;\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(Object[].class),  expectedObjArrayOffset, \"Misplaced object  array base\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/FieldLayout\/ArrayBaseOffsets.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2020, 2024, Red Hat, Inc. All rights reserved.\n@@ -316,0 +316,3 @@\n+    static final boolean CCP = WhiteBox.getWhiteBox().getBooleanVMFlag(\"UseCompressedClassPointers\");\n+    static final int ARRAY_HEADER_SIZE = CCP ? 16 : (Platform.is64bit() ? 20 : 16);\n+\n@@ -399,1 +402,1 @@\n-        long expected = roundUp(4L*SMALL_ARRAY_SIZE + 16, OBJ_ALIGN);\n+        long expected = roundUp(4L*SMALL_ARRAY_SIZE + ARRAY_HEADER_SIZE, OBJ_ALIGN);\n@@ -407,1 +410,1 @@\n-        long expected = roundUp(4L*SMALL_ARRAY_SIZE + 16, OBJ_ALIGN);\n+        long expected = roundUp(4L*SMALL_ARRAY_SIZE + ARRAY_HEADER_SIZE, OBJ_ALIGN);\n@@ -416,1 +419,1 @@\n-        long expected = roundUp(4L*SMALL_ARRAY_SIZE + 16, OBJ_ALIGN);\n+        long expected = roundUp(4L*SMALL_ARRAY_SIZE + ARRAY_HEADER_SIZE, OBJ_ALIGN);\n@@ -423,1 +426,1 @@\n-        long expected = roundUp(REF_SIZE*SMALL_ARRAY_SIZE + 16, OBJ_ALIGN);\n+        long expected = roundUp(REF_SIZE*SMALL_ARRAY_SIZE + ARRAY_HEADER_SIZE, OBJ_ALIGN);\n@@ -431,1 +434,1 @@\n-        long expected = roundUp(REF_SIZE*SMALL_ARRAY_SIZE + 16, OBJ_ALIGN);\n+        long expected = roundUp(REF_SIZE*SMALL_ARRAY_SIZE + ARRAY_HEADER_SIZE, OBJ_ALIGN);\n@@ -440,1 +443,1 @@\n-        long expected = roundUp(REF_SIZE*SMALL_ARRAY_SIZE + 16, OBJ_ALIGN);\n+        long expected = roundUp(REF_SIZE*SMALL_ARRAY_SIZE + ARRAY_HEADER_SIZE, OBJ_ALIGN);\n@@ -448,1 +451,1 @@\n-        long expected = roundUp(4L*LARGE_INT_ARRAY_SIZE + 16, OBJ_ALIGN);\n+        long expected = roundUp(4L*LARGE_INT_ARRAY_SIZE + ARRAY_HEADER_SIZE, OBJ_ALIGN);\n@@ -456,1 +459,1 @@\n-        long expected = roundUp(REF_SIZE*LARGE_OBJ_ARRAY_SIZE + 16, OBJ_ALIGN);\n+        long expected = roundUp(REF_SIZE*LARGE_OBJ_ARRAY_SIZE + ARRAY_HEADER_SIZE, OBJ_ALIGN);\n","filename":"test\/jdk\/java\/lang\/instrument\/GetObjectSizeIntrinsicsTest.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"}]}