{"files":[{"patch":"@@ -1232,1 +1232,1 @@\n-                      arrayOopDesc::header_size(op->type()),\n+                      arrayOopDesc::base_offset_in_bytes(op->type()),\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -198,0 +198,8 @@\n+  \/\/ Zero first 4 bytes, if start offset is not word aligned.\n+  int start_offset = hdr_size_in_bytes;\n+  if (!is_aligned(start_offset, BytesPerWord)) {\n+    assert(is_aligned(start_offset, BytesPerInt), \"must be 32-bit-aligned\");\n+    strw(zr, Address(obj, start_offset));\n+    start_offset += BytesPerInt;\n+  }\n+\n@@ -200,1 +208,1 @@\n-  lea(t1, Address(obj, hdr_size_in_bytes));\n+  lea(t1, Address(obj, start_offset));\n@@ -224,1 +232,2 @@\n-  const int hdr_size_in_bytes = instanceOopDesc::header_size() * HeapWordSize;\n+  \/\/ TODO: Initialization code should deal with int-aligned header size, and skip the klass-gap clearing.\n+  const int hdr_size_in_bytes = align_up(instanceOopDesc::base_offset_in_bytes(), HeapWordSize);\n@@ -257,1 +266,1 @@\n-void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int header_size, int f, Register klass, Label& slow_case) {\n+void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int base_offset_in_bytes, int f, Register klass, Label& slow_case) {\n@@ -270,1 +279,1 @@\n-  mov(arr_size, (int32_t)header_size * BytesPerWord + MinObjAlignmentInBytesMask);\n+  mov(arr_size, (int32_t)base_offset_in_bytes + MinObjAlignmentInBytesMask);\n@@ -279,1 +288,1 @@\n-  initialize_body(obj, arr_size, header_size * BytesPerWord, t1, t2);\n+  initialize_body(obj, arr_size, base_offset_in_bytes, t1, t2);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -974,1 +974,1 @@\n-                      arrayOopDesc::header_size(op->type()),\n+                      arrayOopDesc::base_offset_in_bytes(op->type()),\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-                                       int header_size, int element_size,\n+                                       int base_offset_in_bytes, int element_size,\n@@ -169,1 +169,0 @@\n-  const int header_size_in_bytes = header_size * BytesPerWord;\n@@ -176,2 +175,2 @@\n-  bool align_header = ((header_size_in_bytes | element_size) & MinObjAlignmentInBytesMask) != 0;\n-  assert(align_header || ((header_size_in_bytes & MinObjAlignmentInBytesMask) == 0), \"must be\");\n+  bool align_header = ((base_offset_in_bytes | element_size) & MinObjAlignmentInBytesMask) != 0;\n+  assert(align_header || ((base_offset_in_bytes & MinObjAlignmentInBytesMask) == 0), \"must be\");\n@@ -180,1 +179,1 @@\n-  mov(obj_size, header_size_in_bytes + (align_header ? (MinObjAlignmentInBytes - 1) : 0));\n+  mov(obj_size, base_offset_in_bytes + (align_header ? (MinObjAlignmentInBytes - 1) : 0));\n@@ -188,1 +187,1 @@\n-  initialize_object(obj, tmp1, klass, len, tmp2, tmp3, header_size_in_bytes, -1, \/* is_tlab_allocated *\/ UseTLAB);\n+  initialize_object(obj, tmp1, klass, len, tmp2, tmp3, base_offset_in_bytes, -1, \/* is_tlab_allocated *\/ UseTLAB);\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-                       int header_size, int object_size,\n+                       int header_size_in_bytes, int object_size,\n@@ -55,1 +55,1 @@\n-                      int header_size, int element_size,\n+                      int base_offset_in_bytes, int element_size,\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2311,1 +2311,1 @@\n-                      arrayOopDesc::header_size(op->type()),\n+                      arrayOopDesc::base_offset_in_bytes(op->type()),\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -323,1 +323,1 @@\n-  int      hdr_size,                   \/\/ object header size in words\n+  int      base_offset_in_bytes,       \/\/ elements offset in bytes\n@@ -355,1 +355,1 @@\n-  addi(arr_size, arr_len_in_bytes, hdr_size * wordSize + MinObjAlignmentInBytesMask); \/\/ Add space for header & alignment.\n+  addi(arr_size, arr_len_in_bytes, base_offset_in_bytes + MinObjAlignmentInBytesMask); \/\/ Add space for header & alignment.\n@@ -365,2 +365,12 @@\n-  addi(base, obj, hdr_size * wordSize);               \/\/ compute address of first element\n-  addi(index, arr_size, -(hdr_size * wordSize));      \/\/ compute index = number of bytes to clear\n+  addi(base, obj, base_offset_in_bytes);               \/\/ compute address of first element\n+  addi(index, arr_size, -(base_offset_in_bytes));      \/\/ compute index = number of bytes to clear\n+\n+  \/\/ Zero first 4 bytes, if start offset is not word aligned.\n+  if (!is_aligned(base_offset_in_bytes, BytesPerWord)) {\n+    assert(is_aligned(base_offset_in_bytes, BytesPerInt), \"weird alignment\");\n+    li(t1, 0);\n+    stw(t1, 0, base);\n+    addi(base, base, BytesPerInt);\n+    \/\/ Note: initialize_body will align index down, no need to correct it here.\n+  }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1044,1 +1044,1 @@\n-                      arrayOopDesc::header_size(op->type()),\n+                      arrayOopDesc::base_offset_in_bytes(op->type()),\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -180,0 +180,9 @@\n+  \/\/ Zero first 4 bytes, if start offset is not word aligned.\n+  int start_offset_in_bytes = hdr_size_in_bytes;\n+  if (!is_aligned(start_offset_in_bytes, BytesPerWord)) {\n+    assert(is_aligned(start_offset_in_bytes, BytesPerInt), \"must be 32-bit-aligned\");\n+    sw(zr, Address(obj, start_offset_in_bytes));\n+    sub(len_in_bytes, len_in_bytes, BytesPerInt);\n+    start_offset_in_bytes += BytesPerInt;\n+  }\n+\n@@ -181,2 +190,2 @@\n-  if (hdr_size_in_bytes) {\n-    add(obj, obj, hdr_size_in_bytes);\n+  if (start_offset_in_bytes) {\n+    add(obj, obj, start_offset_in_bytes);\n@@ -185,2 +194,2 @@\n-  if (hdr_size_in_bytes) {\n-    sub(obj, obj, hdr_size_in_bytes);\n+  if (start_offset_in_bytes) {\n+    sub(obj, obj, start_offset_in_bytes);\n@@ -265,1 +274,1 @@\n-void C1_MacroAssembler::allocate_array(Register obj, Register len, Register tmp1, Register tmp2, int header_size, int f, Register klass, Label& slow_case) {\n+void C1_MacroAssembler::allocate_array(Register obj, Register len, Register tmp1, Register tmp2, int base_offset_in_bytes, int f, Register klass, Label& slow_case) {\n@@ -277,1 +286,1 @@\n-  mv(arr_size, (int32_t)header_size * BytesPerWord + MinObjAlignmentInBytesMask);\n+  mv(arr_size, (int32_t)base_offset_in_bytes + MinObjAlignmentInBytesMask);\n@@ -287,1 +296,1 @@\n-  initialize_body(obj, arr_size, header_size * BytesPerWord, len_zero);\n+  initialize_body(obj, arr_size, base_offset_in_bytes, len_zero);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2388,1 +2388,1 @@\n-                      arrayOopDesc::header_size(op->type()),\n+                      arrayOopDesc::base_offset_in_bytes(op->type()),\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -276,1 +276,1 @@\n-  int      hdr_size,                   \/\/ object header size in words\n+  int      base_offset_in_bytes,       \/\/ elements offset in bytes\n@@ -302,2 +302,2 @@\n-  add2reg(arr_size, hdr_size * wordSize + MinObjAlignmentInBytesMask); \/\/ Add space for header & alignment.\n-  z_nill(arr_size, (~MinObjAlignmentInBytesMask) & 0xffff);            \/\/ Align array size.\n+  add2reg(arr_size, base_offset_in_bytes + MinObjAlignmentInBytesMask); \/\/ Add space for header & alignment.\n+  z_nill(arr_size, (~MinObjAlignmentInBytesMask) & 0xffff);             \/\/ Align array size.\n@@ -313,1 +313,1 @@\n-  z_aghi(arr_size, -(hdr_size * BytesPerWord));\n+  z_aghi(arr_size, -base_offset_in_bytes);\n@@ -315,1 +315,1 @@\n-  z_la(object_fields, hdr_size * BytesPerWord, obj);\n+  z_la(object_fields, base_offset_in_bytes, obj);\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1638,1 +1638,1 @@\n-                      arrayOopDesc::header_size(op->type()),\n+                      arrayOopDesc::base_offset_in_bytes(op->type()),\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -197,1 +197,1 @@\n-  const int hdr_size_in_bytes = instanceOopDesc::header_size() * HeapWordSize;\n+  const int hdr_size_in_bytes = instanceOopDesc::base_offset_in_bytes();\n@@ -245,1 +245,1 @@\n-void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int header_size, Address::ScaleFactor f, Register klass, Label& slow_case) {\n+void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int base_offset_in_bytes, Address::ScaleFactor f, Register klass, Label& slow_case) {\n@@ -258,1 +258,1 @@\n-  movptr(arr_size, header_size * BytesPerWord + MinObjAlignmentInBytesMask);\n+  movptr(arr_size, base_offset_in_bytes + MinObjAlignmentInBytesMask);\n@@ -268,1 +268,1 @@\n-  initialize_body(obj, arr_size, header_size * BytesPerWord, len_zero);\n+  initialize_body(obj, arr_size, base_offset_in_bytes, len_zero);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4172,3 +4172,2 @@\n-  assert(address != length_in_bytes && address != temp && temp != length_in_bytes, \"registers must be different\");\n-  assert((offset_in_bytes & (BytesPerWord - 1)) == 0, \"offset must be a multiple of BytesPerWord\");\n-  Label done;\n+  assert_different_registers(address, length_in_bytes, temp);\n+  assert(is_aligned(offset_in_bytes, BytesPerInt), \"offset must be a multiple of BytesPerInt\");\n@@ -4176,5 +4175,2 @@\n-  testptr(length_in_bytes, length_in_bytes);\n-  jcc(Assembler::zero, done);\n-\n-  \/\/ initialize topmost word, divide index by 2, check if odd and test if zero\n-  \/\/ note: for the remaining code to work, index must be a multiple of BytesPerWord\n+  \/\/ For the remaining code to work, length must be a multiple of BytesPerInt.\n+  \/\/ Check that here.\n@@ -4184,1 +4180,1 @@\n-    testptr(length_in_bytes, BytesPerWord - 1);\n+    testptr(length_in_bytes, BytesPerInt - 1);\n@@ -4186,1 +4182,1 @@\n-    stop(\"length must be a multiple of BytesPerWord\");\n+    stop(\"length must be a multiple of BytesPerInt\");\n@@ -4190,1 +4186,6 @@\n-  Register index = length_in_bytes;\n+\n+  Label done;\n+\n+  testptr(length_in_bytes, length_in_bytes);\n+  jcc(Assembler::zero, done);\n+\n@@ -4192,0 +4193,16 @@\n+\n+#ifdef _LP64\n+  \/\/ Emit single 32bit store to clear leading bytes, if necessary.\n+  if (!is_aligned(offset_in_bytes, BytesPerWord)) {\n+    assert(is_aligned(offset_in_bytes, BytesPerInt), \"must be 32-bit-aligned\");\n+    movl(Address(address, offset_in_bytes), temp);\n+    offset_in_bytes += BytesPerInt;\n+    decrement(length_in_bytes, BytesPerInt);\n+  }\n+  assert(is_aligned(offset_in_bytes, BytesPerWord), \"offset must be a multiple of BytesPerWord\");\n+  testptr(length_in_bytes, length_in_bytes);\n+  jcc(Assembler::zero, done);\n+#endif\n+\n+  \/\/ initialize topmost word, divide index by 2, check if odd and test if zero\n+  Register index = length_in_bytes;\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":28,"deletions":11,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -654,1 +654,1 @@\n-                       oopDesc::header_size(), instance_size, klass_reg, !klass->is_initialized(), slow_path);\n+                       heap_word_size(instanceOopDesc::base_offset_in_bytes()), instance_size, klass_reg, !klass->is_initialized(), slow_path);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-  Copy::fill_to_words(new_obj, oopDesc::header_size(), 0);\n+  Copy::fill_to_bytes(new_obj, oopDesc::base_offset_in_bytes(), 0);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"gc\/shared\/collectedHeap.hpp\"\n+#include \"gc\/shared\/collectedHeap.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -256,2 +256,3 @@\n-  _filler_array_max_size = align_object_size(filler_array_hdr_size() +\n-                                             max_len \/ elements_per_word);\n+  int base_offset_in_ints = arrayOopDesc::base_offset_in_ints(T_INT);\n+  assert((uint32_t)base_offset_in_ints <= SIZE_MAX - max_len, \"must not overflow signed int\");\n+  _filler_array_max_size = align_object_size((base_offset_in_ints + max_len) \/ elements_per_word);\n@@ -411,19 +412,1 @@\n-  \/\/ This restriction could be removed by enabling filling with multiple arrays.\n-  \/\/ If we compute that the reasonable way as\n-  \/\/    header_size + ((sizeof(jint) * max_jint) \/ HeapWordSize)\n-  \/\/ we'll overflow on the multiply, so we do the divide first.\n-  \/\/ We actually lose a little by dividing first,\n-  \/\/ but that just makes the TLAB  somewhat smaller than the biggest array,\n-  \/\/ which is fine, since we'll be able to fill that.\n-  size_t max_int_size = typeArrayOopDesc::header_size(T_INT) +\n-              sizeof(jint) *\n-              ((juint) max_jint \/ (size_t) HeapWordSize);\n-  return align_down(max_int_size, MinObjAlignment);\n-}\n-\n-size_t CollectedHeap::filler_array_hdr_size() {\n-  return align_object_offset(arrayOopDesc::header_size(T_INT)); \/\/ align to Long\n-}\n-\n-size_t CollectedHeap::filler_array_min_size() {\n-  return align_object_size(filler_array_hdr_size()); \/\/ align to MinObjAlignment\n+  return _filler_array_max_size;\n@@ -433,2 +416,10 @@\n-  Copy::fill_to_words(start + filler_array_hdr_size(),\n-                      words - filler_array_hdr_size(), value);\n+  int payload_offset = arrayOopDesc::base_offset_in_bytes(T_INT);\n+  if (!is_aligned(payload_offset, HeapWordSize)) {\n+    assert(is_aligned(payload_offset, BytesPerInt), \"base offset must be 32-bit-aligned\");\n+    *(reinterpret_cast<juint*>(start) + (payload_offset \/ BytesPerInt)) = value;\n+    payload_offset += BytesPerInt;\n+  }\n+  assert(is_aligned(payload_offset, HeapWordSize), \"payload start must be heap word aligned\");\n+  int payload_offset_in_words = payload_offset \/ HeapWordSize;\n+  Copy::fill_to_words(start + payload_offset_in_words,\n+                      words - payload_offset_in_words, value);\n@@ -458,2 +449,3 @@\n-  const size_t payload_size = words - filler_array_hdr_size();\n-  const size_t len = payload_size * HeapWordSize \/ sizeof(jint);\n+  const size_t payload_size_bytes = words * HeapWordSize - arrayOopDesc::base_offset_in_bytes(T_INT);\n+  assert(is_aligned(payload_size_bytes, BytesPerInt), \"must be int aligned\");\n+  const size_t len = payload_size_bytes \/ BytesPerInt;\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":17,"deletions":25,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -165,4 +165,0 @@\n-  \/\/ Filler object utilities.\n-  static inline size_t filler_array_hdr_size();\n-  static inline size_t filler_array_min_size();\n-\n@@ -212,0 +208,3 @@\n+  \/\/ Filler object utilities.\n+  static inline size_t filler_array_min_size();\n+\n@@ -298,1 +297,1 @@\n-    return size_t(align_object_size(oopDesc::header_size()));\n+    return size_t(align_object_size(heap_word_size(instanceOopDesc::base_offset_in_bytes())));\n@@ -312,2 +311,2 @@\n-  static constexpr size_t min_dummy_object_size() {\n-    return oopDesc::header_size();\n+  static size_t min_dummy_object_size() {\n+    return min_fill_size();\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -49,0 +49,5 @@\n+inline size_t CollectedHeap::filler_array_min_size() {\n+  size_t header_size_words = heap_word_size(arrayOopDesc::base_offset_in_bytes(T_INT));\n+  return align_object_size(header_size_words); \/\/ align to MinObjAlignment\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -340,1 +340,1 @@\n-  if (value > (ThreadLocalAllocBuffer::max_size() * HeapWordSize)) {\n+  if (value \/ HeapWordSize > ThreadLocalAllocBuffer::max_size()) {\n@@ -342,3 +342,3 @@\n-                        \"MinTLABSize (\" SIZE_FORMAT \") must be \"\n-                        \"less than or equal to ergonomic TLAB maximum (\" SIZE_FORMAT \")\\n\",\n-                        value, ThreadLocalAllocBuffer::max_size() * HeapWordSize);\n+                        \"MinTLABSize (\" SIZE_FORMAT \" bytes) must be \"\n+                        \"less than or equal to ergonomic TLAB maximum (\" SIZE_FORMAT \" words)\\n\",\n+                        value, ThreadLocalAllocBuffer::max_size());\n@@ -360,1 +360,1 @@\n-    if (value > (ThreadLocalAllocBuffer::max_size() * HeapWordSize)) {\n+    if (value \/ HeapWordSize > ThreadLocalAllocBuffer::max_size()) {\n@@ -362,3 +362,3 @@\n-                          \"TLABSize (\" SIZE_FORMAT \") must be \"\n-                          \"less than or equal to ergonomic TLAB maximum size (\" SIZE_FORMAT \")\\n\",\n-                          value, (ThreadLocalAllocBuffer::max_size() * HeapWordSize));\n+                          \"TLABSize (\" SIZE_FORMAT \" bytes) must be \"\n+                          \"less than or equal to ergonomic TLAB maximum size (\" SIZE_FORMAT \" words)\\n\",\n+                          value, ThreadLocalAllocBuffer::max_size());\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-  if (!os::is_readable_range(obj, (HeapWord*)obj + oopDesc::header_size())) {\n+  if (!os::is_readable_range(obj, (char*)obj + oopDesc::base_offset_in_bytes())) {\n","filename":"src\/hotspot\/share\/gc\/shared\/locationPrinter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-             \"Found badHeapWordValue in post-allocation check\");\n+             \"Found badHeapWordValue in post-allocation check in slot \" SIZE_FORMAT, slot);\n@@ -340,1 +340,1 @@\n-    \/\/ ...and zap just allocated object.\n+    \/\/ ...and zap just allocated tlab.\n@@ -342,5 +342,1 @@\n-    \/\/ Skip mangling the space corresponding to the object header to\n-    \/\/ ensure that the returned space is not considered parsable by\n-    \/\/ any concurrent GC thread.\n-    size_t hdr_size = oopDesc::header_size();\n-    Copy::fill_to_words(mem + hdr_size, allocation._allocated_tlab_size - hdr_size, badHeapWordVal);\n+    Copy::fill_to_words(mem, allocation._allocated_tlab_size, badHeapWordVal);\n@@ -398,1 +394,1 @@\n-void MemAllocator::mem_clear(HeapWord* mem) const {\n+void MemAllocator::mem_clear(HeapWord* mem, size_t hdr_size_bytes) const {\n@@ -400,4 +396,2 @@\n-  const size_t hs = oopDesc::header_size();\n-  assert(_word_size >= hs, \"unexpected object size\");\n-  oopDesc::set_klass_gap(mem, 0);\n-  Copy::fill_to_aligned_words(mem + hs, _word_size - hs);\n+  assert(_word_size * HeapWordSize >= hdr_size_bytes, \"unexpected object size\");\n+  Copy::fill_to_bytes((char*)mem + hdr_size_bytes, _word_size * HeapWordSize - hdr_size_bytes);\n@@ -418,1 +412,1 @@\n-  mem_clear(mem);\n+  mem_clear(mem, instanceOopDesc::base_offset_in_bytes());\n@@ -422,9 +416,0 @@\n-MemRegion ObjArrayAllocator::obj_memory_range(oop obj) const {\n-  if (_do_zero) {\n-    return MemAllocator::obj_memory_range(obj);\n-  }\n-  ArrayKlass* array_klass = ArrayKlass::cast(_klass);\n-  const size_t hs = arrayOopDesc::header_size(array_klass->element_type());\n-  return MemRegion(cast_from_oop<HeapWord*>(obj) + hs, _word_size - hs);\n-}\n-\n@@ -437,1 +422,3 @@\n-    mem_clear(mem);\n+    ArrayKlass* array_klass = ArrayKlass::cast(_klass);\n+    const size_t hs = arrayOopDesc::header_size_in_bytes();\n+    mem_clear(mem, hs);\n@@ -448,1 +435,1 @@\n-  mem_clear(mem);\n+  mem_clear(mem, instanceOopDesc::base_offset_in_bytes());\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":11,"deletions":24,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-  void mem_clear(HeapWord* mem) const;\n+  void mem_clear(HeapWord* mem, size_t header_size_bytes) const;\n@@ -81,1 +81,1 @@\n-  virtual MemRegion obj_memory_range(oop obj) const {\n+  MemRegion obj_memory_range(oop obj) const {\n@@ -103,2 +103,0 @@\n-  virtual MemRegion obj_memory_range(oop obj) const;\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  return align_object_size(MAX2(MinTLABSize \/ HeapWordSize, (size_t)oopDesc::header_size())) + CollectedHeap::lab_alignment_reserve();\n+  return align_object_size(MAX2(MinTLABSize \/ HeapWordSize, heap_word_size(oopDesc::base_offset_in_bytes()))) + CollectedHeap::lab_alignment_reserve();\n","filename":"src\/hotspot\/share\/gc\/shared\/plab.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -116,1 +116,0 @@\n-  static size_t max_size_in_bytes()              { return max_size() * BytesPerWord; }\n","filename":"src\/hotspot\/share\/gc\/shared\/threadLocalAllocBuffer.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,5 +44,1 @@\n-    \/\/ Skip mangling the space corresponding to the object header to\n-    \/\/ ensure that the returned space is not considered parsable by\n-    \/\/ any concurrent GC thread.\n-    size_t hdr_size = oopDesc::header_size();\n-    Copy::fill_to_words(obj + hdr_size, size - hdr_size, badHeapWordVal);\n+    Copy::fill_to_words(obj, size, badHeapWordVal);\n","filename":"src\/hotspot\/share\/gc\/shared\/threadLocalAllocBuffer.inline.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -784,5 +784,1 @@\n-    \/\/ Skip mangling the space corresponding to the object header to\n-    \/\/ ensure that the returned space is not considered parsable by\n-    \/\/ any concurrent GC thread.\n-    size_t hdr_size = oopDesc::header_size();\n-    Copy::fill_to_words(gclab_buf + hdr_size, actual_size - hdr_size, badHeapWordVal);\n+    Copy::fill_to_words(gclab_buf, actual_size, badHeapWordVal);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -53,2 +53,9 @@\n-  const size_t header = arrayOopDesc::header_size(element_type);\n-  const size_t payload_size = _word_size - header;\n+  int base_offset = arrayOopDesc::base_offset_in_bytes(element_type);\n+\n+  \/\/ Clear leading 32 bits, if necessary.\n+  if (!is_aligned(base_offset, HeapWordSize)) {\n+    assert(is_aligned(base_offset, BytesPerInt), \"array base must be 32 bit aligned\");\n+    *reinterpret_cast<jint*>(reinterpret_cast<char*>(mem) + base_offset) = 0;\n+    base_offset += BytesPerInt;\n+  }\n+  assert(is_aligned(base_offset, HeapWordSize), \"remaining array base must be 64 bit aligned\");\n@@ -56,0 +63,2 @@\n+  const size_t header = heap_word_size(base_offset);\n+  const size_t payload_size = _word_size - header;\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1997,2 +1997,2 @@\n-                size_t hdr_size = oopDesc::header_size();\n-                Copy::fill_to_words(result + hdr_size, obj_size - hdr_size, 0);\n+                size_t hdr_size = instanceOopDesc::base_offset_in_bytes();\n+                Copy::fill_to_bytes((char*)result + hdr_size, obj_size * HeapWordSize- hdr_size, 0);\n@@ -2003,1 +2003,0 @@\n-              oopDesc::set_klass_gap(result, 0);\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2207,1 +2207,1 @@\n-  return arrayOopDesc::header_size(type) * HeapWordSize;\n+  return arrayOopDesc::base_offset_in_bytes(type);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"oops\/arrayOop.hpp\"\n+\n+\/\/ Return the maximum length (num elements) of an array of BasicType.  The length can passed\n+\/\/ to typeArrayOop::object_size(scale, length, header_size) without causing an\n+\/\/ overflow. We also need to make sure that this will not overflow a size_t on\n+\/\/ 32 bit platforms when we convert it to a byte size.\n+int32_t arrayOopDesc::max_array_length(BasicType type) {\n+  assert(type >= 0 && type < T_CONFLICT, \"wrong type\");\n+  assert(type2aelembytes(type) != 0, \"wrong type\");\n+\n+  const int elem_size = type2aelembytes(type);\n+  const size_t max_size_bytes = align_down(SIZE_MAX - base_offset_in_bytes(type), MinObjAlignmentInBytes);\n+  assert(is_aligned(max_size_bytes, elem_size), \"max_size_bytes should be aligned to element size\");\n+  size_t max_elements_per_size_t = max_size_bytes \/ elem_size;\n+  if ((size_t)max_jint < max_elements_per_size_t) {\n+    \/\/ It should be ok to return max_jint here, but parts of the code\n+    \/\/ (CollectedHeap, Klass::oop_oop_iterate(), and more) uses an int for\n+    \/\/ passing around the size (in words) of an object. So, we need to avoid\n+    \/\/ overflowing an int when we add the header. See CRs 4718400 and 7110613.\n+    const size_t header_size_words = heap_word_size(base_offset_in_bytes(type));\n+    max_elements_per_size_t = align_down(max_jint - static_cast<int>(header_size_words), MinObjAlignment);\n+  }\n+  assert(max_elements_per_size_t <= (size_t)max_jint, \"must not overflow unsigned int\");\n+  assert(((jlong)max_elements_per_size_t * elem_size + base_offset_in_bytes(type)) \/ HeapWordSize <= (jlong)max_jint,\n+         \"total array size in words must not overflow signed int: \" SIZE_FORMAT, max_elements_per_size_t);\n+  return (int32_t)max_elements_per_size_t;\n+}\n","filename":"src\/hotspot\/share\/oops\/arrayOop.cpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -48,16 +49,0 @@\n-  \/\/ Header size computation.\n-  \/\/ The header is considered the oop part of this type plus the length.\n-  \/\/ Returns the aligned header_size_in_bytes.  This is not equivalent to\n-  \/\/ sizeof(arrayOopDesc) which should not appear in the code.\n-  static int header_size_in_bytes() {\n-    size_t hs = align_up(length_offset_in_bytes() + sizeof(int),\n-                              HeapWordSize);\n-#ifdef ASSERT\n-    \/\/ make sure it isn't called before UseCompressedOops is initialized.\n-    static size_t arrayoopdesc_hs = 0;\n-    if (arrayoopdesc_hs == 0) arrayoopdesc_hs = hs;\n-    assert(arrayoopdesc_hs == hs, \"header size can't change\");\n-#endif \/\/ ASSERT\n-    return (int)hs;\n-  }\n-\n@@ -74,0 +59,5 @@\n+#ifdef _LP64\n+    if (type == T_OBJECT || type == T_ARRAY) {\n+      return !UseCompressedOops;\n+    }\n+#endif\n@@ -86,0 +76,14 @@\n+  \/\/ Header size computation.\n+  \/\/ The header is considered the oop part of this type plus the length.\n+  \/\/ This is not equivalent to sizeof(arrayOopDesc) which should not appear in the code.\n+  static int header_size_in_bytes() {\n+    size_t hs = length_offset_in_bytes() + sizeof(int);\n+#ifdef ASSERT\n+    \/\/ make sure it isn't called before UseCompressedOops is initialized.\n+    static size_t arrayoopdesc_hs = 0;\n+    if (arrayoopdesc_hs == 0) arrayoopdesc_hs = hs;\n+    assert(arrayoopdesc_hs == hs, \"header size can't change\");\n+#endif \/\/ ASSERT\n+    return (int)hs;\n+  }\n+\n@@ -88,1 +92,8 @@\n-    return header_size(type) * HeapWordSize;\n+    size_t hs = header_size_in_bytes();\n+    return (int)(element_type_should_be_aligned(type) ? align_up(hs, BytesPerLong) : hs);\n+  }\n+\n+  static int base_offset_in_ints(BasicType type) {\n+    int base_offset_in_bytes = arrayOopDesc::base_offset_in_bytes(type);\n+    assert(is_aligned(base_offset_in_bytes, BytesPerInt), \"must be aligned to int\");\n+    return base_offset_in_bytes \/ BytesPerInt;\n@@ -125,12 +136,1 @@\n-  \/\/ Should only be called with constants as argument\n-  \/\/ (will not constant fold otherwise)\n-  \/\/ Returns the header size in words aligned to the requirements of the\n-  \/\/ array object type.\n-  static int header_size(BasicType type) {\n-    size_t typesize_in_bytes = header_size_in_bytes();\n-    return (int)(element_type_should_be_aligned(type)\n-      ? align_object_offset(typesize_in_bytes\/HeapWordSize)\n-      : typesize_in_bytes\/HeapWordSize);\n-  }\n-\n-  \/\/ Return the maximum length of an array of BasicType.  The length can passed\n+  \/\/ Return the maximum number of elements of an array of BasicType.  The length can passed\n@@ -140,18 +140,1 @@\n-  static int32_t max_array_length(BasicType type) {\n-    assert(type >= 0 && type < T_CONFLICT, \"wrong type\");\n-    assert(type2aelembytes(type) != 0, \"wrong type\");\n-\n-    const size_t max_element_words_per_size_t =\n-      align_down((SIZE_MAX\/HeapWordSize - header_size(type)), MinObjAlignment);\n-    const size_t max_elements_per_size_t =\n-      HeapWordSize * max_element_words_per_size_t \/ type2aelembytes(type);\n-    if ((size_t)max_jint < max_elements_per_size_t) {\n-      \/\/ It should be ok to return max_jint here, but parts of the code\n-      \/\/ (CollectedHeap, Klass::oop_oop_iterate(), and more) uses an int for\n-      \/\/ passing around the size (in words) of an object. So, we need to avoid\n-      \/\/ overflowing an int when we add the header. See CRs 4718400 and 7110613.\n-      return align_down(max_jint - header_size(type), MinObjAlignment);\n-    }\n-    return (int32_t)max_elements_per_size_t;\n-  }\n-\n+  static int32_t max_array_length(BasicType type);\n","filename":"src\/hotspot\/share\/oops\/arrayOop.hpp","additions":30,"deletions":47,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -36,3 +36,0 @@\n-  \/\/ aligned header size.\n-  static int header_size() { return sizeof(instanceOopDesc)\/HeapWordSize; }\n-\n@@ -41,4 +38,1 @@\n-    return (UseCompressedClassPointers) ?\n-            klass_gap_offset_in_bytes() :\n-            sizeof(instanceOopDesc);\n-\n+    return oopDesc::base_offset_in_bytes();\n","filename":"src\/hotspot\/share\/oops\/instanceOop.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -54,26 +54,0 @@\n-private:\n-  \/\/ Give size of objArrayOop in HeapWords minus the header\n-  static int array_size(int length) {\n-    const uint OopsPerHeapWord = HeapWordSize\/heapOopSize;\n-    assert(OopsPerHeapWord >= 1 && (HeapWordSize % heapOopSize == 0),\n-           \"Else the following (new) computation would be in error\");\n-    uint res = ((uint)length + OopsPerHeapWord - 1)\/OopsPerHeapWord;\n-#ifdef ASSERT\n-    \/\/ The old code is left in for sanity-checking; it'll\n-    \/\/ go away pretty soon. XXX\n-    \/\/ Without UseCompressedOops, this is simply:\n-    \/\/ oop->length() * HeapWordsPerOop;\n-    \/\/ With narrowOops, HeapWordsPerOop is 1\/2 or equal 0 as an integer.\n-    \/\/ The oop elements are aligned up to wordSize\n-    const uint HeapWordsPerOop = heapOopSize\/HeapWordSize;\n-    uint old_res;\n-    if (HeapWordsPerOop > 0) {\n-      old_res = length * HeapWordsPerOop;\n-    } else {\n-      old_res = align_up((uint)length, OopsPerHeapWord)\/OopsPerHeapWord;\n-    }\n-    assert(res == old_res, \"Inconsistency between old and new.\");\n-#endif  \/\/ ASSERT\n-    return res;\n-  }\n-\n@@ -97,1 +71,0 @@\n-  static int header_size()    { return arrayOopDesc::header_size(T_OBJECT); }\n@@ -102,5 +75,5 @@\n-    uint asz = array_size(length);\n-    uint osz = align_object_size(header_size() + asz);\n-    assert(osz >= asz,   \"no overflow\");\n-    assert((int)osz > 0, \"no overflow\");\n-    return (size_t)osz;\n+    size_t asz = (size_t)length * heapOopSize;\n+    size_t size_words = heap_word_size(base_offset_in_bytes() + asz);\n+    size_t osz = align_object_size(size_words);\n+    assert(osz < max_jint, \"no overflow\");\n+    return osz;\n","filename":"src\/hotspot\/share\/oops\/objArrayOop.hpp","additions":5,"deletions":32,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -95,2 +95,4 @@\n-  \/\/ For klass field compression\n-  static inline void set_klass_gap(HeapWord* mem, int z);\n+  static int base_offset_in_bytes() {\n+    return (UseCompressedClassPointers) ?\n+            klass_gap_offset_in_bytes() :\n+            sizeof(oopDesc);\n@@ -98,2 +100,1 @@\n-  \/\/ size of object header, aligned to platform wordSize\n-  static constexpr int header_size() { return sizeof(oopDesc)\/HeapWordSize; }\n+  }\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -138,6 +138,0 @@\n-void oopDesc::set_klass_gap(HeapWord* mem, int v) {\n-  if (UseCompressedClassPointers) {\n-    *(int*)(((char*)mem) + klass_gap_offset_in_bytes()) = v;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2098,1 +2098,1 @@\n-      jint min_size = Klass::instance_layout_helper(oopDesc::header_size(), false);\n+      jint min_size = Klass::instance_layout_helper(heap_word_size(instanceOopDesc::base_offset_in_bytes()), false);\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -311,3 +311,2 @@\n-    const size_t hs = arrayOopDesc::header_size(elem_type);\n-    \/\/ Align to next 8 bytes to avoid trashing arrays's length.\n-    const size_t aligned_hs = align_object_offset(hs);\n+    size_t hs_bytes = arrayOopDesc::base_offset_in_bytes(elem_type);\n+    assert(is_aligned(hs_bytes, BytesPerInt), \"must be 4 byte aligned\");\n@@ -315,2 +314,3 @@\n-    if (aligned_hs > hs) {\n-      Copy::zero_to_words(obj+hs, aligned_hs-hs);\n+    if (!is_aligned(hs_bytes, BytesPerLong)) {\n+      *reinterpret_cast<jint*>(reinterpret_cast<char*>(obj) + hs_bytes) = 0;\n+      hs_bytes += BytesPerInt;\n@@ -318,0 +318,1 @@\n+\n@@ -319,0 +320,2 @@\n+    assert(is_aligned(hs_bytes, BytesPerLong), \"must be 8-byte aligned\");\n+    const size_t aligned_hs = hs_bytes \/ BytesPerLong;\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -5148,1 +5148,2 @@\n-    int header_size = objArrayOopDesc::header_size() * wordSize;\n+    BasicType basic_elem_type = elem()->basic_type();\n+    int header_size = arrayOopDesc::base_offset_in_bytes(basic_elem_type);\n@@ -5153,1 +5154,0 @@\n-      BasicType basic_elem_type = elem()->basic_type();\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-  ( arrayOopDesc::header_size(T_DOUBLE) * HeapWordSize \\\n+  ( arrayOopDesc::base_offset_in_bytes(T_DOUBLE) \\\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1287,2 +1287,2 @@\n-    const size_t hs = oopDesc::header_size();\n-    Copy::fill_to_aligned_words(mem + hs, vmClasses::StackChunk_klass()->size_helper() - hs);\n+    const size_t hs = oopDesc::base_offset_in_bytes();\n+    Copy::fill_to_bytes((char*)mem + hs, vmClasses::StackChunk_klass()->size_helper() * HeapWordSize - hs);\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-    \/\/ Use only if top > start && used_bytes <= max_tlab_size_bytes.\n+    \/\/ Use only if top > start && used_words <= max_tlab_size_words.\n@@ -48,3 +48,3 @@\n-    const size_t used_bytes = pointer_delta(top, start, 1);\n-    if (used_bytes <= ThreadLocalAllocBuffer::max_size_in_bytes()) {\n-      \/\/ Comparing used_bytes with the maximum allowed size will ensure\n+    const size_t used_words = pointer_delta(top, start);\n+    if (used_words <= ThreadLocalAllocBuffer::max_size()) {\n+      \/\/ Comparing used_words with the maximum allowed size will ensure\n@@ -55,1 +55,1 @@\n-      return allocated_bytes + used_bytes;\n+      return allocated_bytes + used_words * HeapWordSize;\n","filename":"src\/hotspot\/share\/runtime\/thread.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -64,6 +64,1 @@\n-    if (VM.getVM().isCompressedKlassPointersEnabled()) {\n-      headerSize = typeSize;\n-    } else {\n-      headerSize = VM.getVM().alignUp(typeSize + VM.getVM().getIntSize(),\n-                                      VM.getVM().getHeapWordSize());\n-    }\n+    headerSize = lengthOffsetInBytes() + VM.getVM().getIntSize();\n@@ -73,9 +68,1 @@\n-  private static long headerSize(BasicType type) {\n-    if (Universe.elementTypeShouldBeAligned(type)) {\n-       return alignObjectSize(headerSizeInBytes())\/VM.getVM().getHeapWordSize();\n-    } else {\n-      return headerSizeInBytes()\/VM.getVM().getHeapWordSize();\n-    }\n-  }\n-\n-  private long lengthOffsetInBytes() {\n+  private static long lengthOffsetInBytes() {\n@@ -111,1 +98,7 @@\n-    return headerSize(type) * VM.getVM().getHeapWordSize();\n+    long typeSizeInBytes = headerSizeInBytes();\n+    if (Universe.elementTypeShouldBeAligned(type)) {\n+      VM vm = VM.getVM();\n+      return vm.alignUp(typeSizeInBytes, vm.getVM().getHeapWordSize());\n+    } else {\n+      return typeSizeInBytes;\n+    }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Array.java","additions":9,"deletions":16,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,8 +30,0 @@\n-class arrayOopDescTest {\n- public:\n-\n-  static int header_size_in_bytes() {\n-    return arrayOopDesc::header_size_in_bytes();\n-  }\n-};\n-\n@@ -42,1 +34,1 @@\n-          + arrayOopDescTest::header_size_in_bytes();\n+          + arrayOopDesc::base_offset_in_bytes(type);\n@@ -90,0 +82,44 @@\n+\n+TEST_VM(arrayOopDesc, base_offset) {\n+#ifdef _LP64\n+  if (UseCompressedClassPointers) {\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_BOOLEAN), 16);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_BYTE),    16);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_SHORT),   16);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_CHAR),    16);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_INT),     16);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_FLOAT),   16);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_LONG),    16);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_DOUBLE),  16);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_OBJECT),  16);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_ARRAY),   16);\n+  } else {\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_BOOLEAN), 20);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_BYTE),    20);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_SHORT),   20);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_CHAR),    20);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_INT),     20);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_FLOAT),   20);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_LONG),    24);\n+    EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_DOUBLE),  24);\n+    if (UseCompressedOops) {\n+      EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_OBJECT), 20);\n+      EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_ARRAY),  20);\n+    } else {\n+      EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_OBJECT), 24);\n+      EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_ARRAY),  24);\n+    }\n+  }\n+#else\n+  EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_BOOLEAN), 12);\n+  EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_BYTE),    12);\n+  EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_SHORT),   12);\n+  EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_CHAR),    12);\n+  EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_INT),     12);\n+  EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_FLOAT),   12);\n+  EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_LONG),    16);\n+  EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_DOUBLE),  16);\n+  EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_OBJECT),  12);\n+  EXPECT_EQ(arrayOopDesc::base_offset_in_bytes(T_ARRAY),   12);\n+#endif\n+}\n","filename":"test\/hotspot\/gtest\/oops\/test_arrayOop.cpp","additions":46,"deletions":10,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"oops\/objArrayOop.hpp\"\n+#include \"unittest.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+TEST_VM(objArrayOop, osize) {\n+  static const struct {\n+    int objal; bool ccp; bool coops; int result;\n+  } x[] = {\n+\/\/    ObjAligInB, UseCCP, UseCoops, object size in heap words\n+#ifdef _LP64\n+    { 8,          false,  false,    4 },  \/\/ 20 byte header, 8 byte oops\n+    { 8,          false,  true,     3 },  \/\/ 20 byte header, 4 byte oops\n+    { 8,          true,   false,    3 },  \/\/ 16 byte header, 8 byte oops\n+    { 8,          true,   true,     3 },  \/\/ 16 byte header, 4 byte oops\n+    { 256,        false,  false,    32 }, \/\/ 20 byte header, 8 byte oops\n+    { 256,        false,  true,     32 }, \/\/ 20 byte header, 4 byte oops\n+    { 256,        true,   false,    32 }, \/\/ 16 byte header, 8 byte oops\n+    { 256,        true,   true,     32 }, \/\/ 16 byte header, 4 byte oops\n+#else\n+    { 8,          false,  false,    4 }, \/\/ 12 byte header, 4 byte oops, wordsize 4\n+#endif\n+    { -1,         false,  false,   -1 }\n+  };\n+  for (int i = 0; x[i].result != -1; i++) {\n+    if (x[i].objal == (int)ObjectAlignmentInBytes && x[i].ccp == UseCompressedClassPointers && x[i].coops == UseCompressedOops) {\n+      EXPECT_EQ(objArrayOopDesc::object_size(1), (size_t)x[i].result);\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/oops\/test_objArrayOop.cpp","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2022 Amazon.com Inc. or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * This tests object array sizes by running gtests with different settings.\n+ *\/\n+\n+\/* @test id=with-coops-with-ccp\n+ * @summary Run object array size tests with compressed oops and compressed class pointers\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @run main\/native GTestWrapper --gtest_filter=arrayOop::base_offset -XX:+UseCompressedClassPointers -XX:+UseCompressedOops\n+ *\/\n+\/* @test id=with-coops-no-ccp\n+ * @summary Run object array size tests with compressed oops and compressed class pointers\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @run main\/native GTestWrapper --gtest_filter=arrayOop::base_offset -XX:-UseCompressedClassPointers -XX:+UseCompressedOops\n+ *\/\n+\/* @test id=no-coops-with-ccp\n+ * @summary Run object array size tests with compressed oops and compressed class pointers\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @run main\/native GTestWrapper --gtest_filter=arrayOop::base_offset -XX:+UseCompressedClassPointers -XX:-UseCompressedOops\n+ *\/\n+\/* @test id=no-coops-no-ccp\n+ * @summary Run object array size tests with compressed oops and compressed class pointers\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @run main\/native GTestWrapper --gtest_filter=arrayOop::base_offset -XX:-UseCompressedClassPointers -XX:-UseCompressedOops\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gtest\/ArrayTest.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2022 Amazon.com Inc. or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * This tests object array sizes by running gtests with different settings.\n+ *\/\n+\n+\/* @test id=with-coops-with-ccp\n+ * @summary Run object array size tests with compressed oops and compressed class pointers\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @run main\/native GTestWrapper --gtest_filter=objArrayOop -XX:+UseCompressedClassPointers -XX:+UseCompressedOops\n+ *\/\n+\/* @test id=with-coops-no-ccp\n+ * @summary Run object array size tests with compressed oops and compressed class pointers\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @run main\/native GTestWrapper --gtest_filter=objArrayOop -XX:-UseCompressedClassPointers -XX:+UseCompressedOops\n+ *\/\n+\/* @test id=no-coops-with-ccp\n+ * @summary Run object array size tests with compressed oops and compressed class pointers\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @run main\/native GTestWrapper --gtest_filter=objArrayOop -XX:+UseCompressedClassPointers -XX:-UseCompressedOops\n+ *\/\n+\/* @test id=no-coops-no-ccp\n+ * @summary Run object array size tests with compressed oops and compressed class pointers\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @run main\/native GTestWrapper --gtest_filter=objArrayOop -XX:-UseCompressedClassPointers -XX:-UseCompressedOops\n+ *\/\n+\n+\/* @test id=with-coops-with-ccp-large-align\n+ * @summary Run object array size tests with compressed oops and compressed class pointers\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @run main\/native GTestWrapper --gtest_filter=objArrayOop -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:ObjAlignmentInBytes=256\n+ *\/\n+\/* @test id=with-coops-no-ccp-large-align\n+ * @summary Run object array size tests with compressed oops and compressed class pointers\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @run main\/native GTestWrapper --gtest_filter=objArrayOop -XX:-UseCompressedClassPointers -XX:+UseCompressedOops -XX:ObjAlignmentInBytes=256\n+ *\/\n+\/* @test id=no-coops-with-ccp-large-align\n+ * @summary Run object array size tests with compressed oops and compressed class pointers\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @run main\/native GTestWrapper --gtest_filter=objArrayOop -XX:+UseCompressedClassPointers -XX:-UseCompressedOops -XX:ObjAlignmentInBytes=256\n+ *\/\n+\/* @test id=no-coops-no-ccp-large-align\n+ * @summary Run object array size tests with compressed oops and compressed class pointers\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @run main\/native GTestWrapper --gtest_filter=objArrayOop -XX:-UseCompressedClassPointers -XX:-UseCompressedOops -XX:ObjAlignmentInBytes=256\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gtest\/ObjArrayTests.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (C) 2022, Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=with-coops-no-ccp\n+ * @library \/test\/lib\n+ * @requires vm.bits == \"64\"\n+ * @modules java.base\/jdk.internal.misc\n+ * @run main\/othervm -XX:+UseCompressedOops -XX:-UseCompressedClassPointers ArrayBaseOffsets\n+ *\/\n+\/*\n+ * @test id=with-coops-with-ccp\n+ * @library \/test\/lib\n+ * @requires vm.bits == \"64\"\n+ * @requires vm.opt.UseCompressedClassPointers != false\n+ * @modules java.base\/jdk.internal.misc\n+ * @run main\/othervm -XX:+UseCompressedOops -XX:+UseCompressedClassPointers ArrayBaseOffsets\n+ *\/\n+\/*\n+ * @test id=no-coops-no-ccp\n+ * @library \/test\/lib\n+ * @requires vm.bits == \"64\"\n+ * @modules java.base\/jdk.internal.misc\n+ * @run main\/othervm -XX:-UseCompressedOops -XX:-UseCompressedClassPointers ArrayBaseOffsets\n+ *\/\n+\/*\n+ * @test id=no-coops-with-ccp\n+ * @library \/test\/lib\n+ * @requires vm.bits == \"64\"\n+ * @requires vm.opt.UseCompressedClassPointers != false\n+ * @modules java.base\/jdk.internal.misc\n+ * @run main\/othervm -XX:-UseCompressedOops -XX:+UseCompressedClassPointers ArrayBaseOffsets\n+ *\/\n+\/*\n+ * @test id=32bit\n+ * @library \/test\/lib\n+ * @requires vm.bits == \"32\"\n+ * @modules java.base\/jdk.internal.misc\n+ * @run main\/othervm ArrayBaseOffsets\n+ *\/\n+\n+import jdk.internal.misc.Unsafe;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.RuntimeMXBean;\n+import java.util.List;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Platform;\n+\n+public class ArrayBaseOffsets {\n+\n+    private static final boolean COOP;\n+    private static final boolean CCP;\n+\n+    static {\n+        if (Platform.is64bit()) {\n+            RuntimeMXBean runtime = ManagementFactory.getRuntimeMXBean();\n+            List<String> vmargs = runtime.getInputArguments();\n+            CCP = !vmargs.contains(\"-XX:-UseCompressedClassPointers\");\n+            COOP = System.getProperty(\"java.vm.compressedOopsMode\") != null;\n+        } else {\n+            COOP = CCP = false;\n+        }\n+    }\n+\n+    static public void main(String[] args) {\n+        Unsafe unsafe = Unsafe.getUnsafe();\n+        int intOffset, longOffset;\n+        if (Platform.is64bit()) {\n+            if (CCP) {\n+                intOffset = 16;\n+                longOffset = 16;\n+            } else {\n+                intOffset = 20;\n+                longOffset = 24;\n+            }\n+        } else {\n+            intOffset = 12;\n+            longOffset = 16;\n+        }\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(boolean[].class), intOffset,  \"Misplaced boolean array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(byte[].class),    intOffset,  \"Misplaced byte    array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(char[].class),    intOffset,  \"Misplaced char    array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(short[].class),   intOffset,  \"Misplaced short   array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(int[].class),     intOffset,  \"Misplaced int     array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(long[].class),    longOffset, \"Misplaced long    array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(float[].class),   intOffset,  \"Misplaced float   array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(double[].class),  longOffset, \"Misplaced double  array base\");\n+        int expectedObjArrayOffset = (COOP || !Platform.is64bit()) ? intOffset : longOffset;\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(Object[].class),  expectedObjArrayOffset, \"Misplaced object  array base\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/FieldLayout\/ArrayBaseOffsets.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"}]}