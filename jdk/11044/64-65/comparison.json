{"files":[{"patch":"@@ -189,0 +189,8 @@\n+#ifdef _LP64\n+    int base_offset = arrayOopDesc::length_offset_in_bytes() + BytesPerInt;\n+    if (!is_aligned(base_offset, BytesPerWord)) {\n+      \/\/ Clear gap\/first 4 bytes following the length field.\n+      xorl(t1, t1);\n+      movl(Address(obj, arrayOopDesc::length_offset_in_bytes() + BytesPerInt), t1);\n+    }\n+#endif\n@@ -293,13 +301,0 @@\n-  \/\/ Clear leading 4 bytes, if necessary.\n-  \/\/ TODO: This could perhaps go into initialize_body() and also clear the leading 4 bytes\n-  \/\/ for non-array objects, thereby replacing the klass-gap clearing code in initialize_header().\n-  int base_offset = base_offset_in_bytes;\n-#ifdef _LP64\n-  if (!is_aligned(base_offset, BytesPerWord)) {\n-    assert(is_aligned(base_offset, BytesPerInt), \"must be 4-byte aligned\");\n-    movl(Address(obj, base_offset), 0);\n-    base_offset += BytesPerInt;\n-  }\n-#endif\n-  assert(is_aligned(base_offset, BytesPerWord), \"must be word aligned\");\n-\n@@ -308,0 +303,3 @@\n+  \/\/ Align-up to word boundary, because we clear the 4 bytes potentially\n+  \/\/ following the length field in initialize_header().\n+  int base_offset = align_up(base_offset_in_bytes, BytesPerWord);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"}]}