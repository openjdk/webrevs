{"files":[{"patch":"@@ -231,5 +231,1 @@\n-    if (LockingMode == LM_MONITOR) {\n-      __ b(*stub->entry());\n-    } else {\n-      __ unlock_object(R5, R6, R4, *stub->entry());\n-    }\n+    __ unlock_object(R5, R6, R4, *stub->entry());\n@@ -2621,19 +2617,6 @@\n-    if (LockingMode != LM_MONITOR) {\n-      assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n-      \/\/ Add debug info for NullPointerException only if one is possible.\n-      if (op->info() != nullptr) {\n-        if (!os::zero_page_read_protected() || !ImplicitNullChecks) {\n-          explicit_null_check(obj, op->info());\n-        } else {\n-          add_debug_info_for_null_check_here(op->info());\n-        }\n-      }\n-      __ lock_object(hdr, obj, lock, op->scratch_opr()->as_register(), *op->stub()->entry());\n-    } else {\n-      \/\/ always do slow locking\n-      \/\/ note: The slow locking code could be inlined here, however if we use\n-      \/\/       slow locking, speed doesn't matter anyway and this solution is\n-      \/\/       simpler and requires less duplicated code - additionally, the\n-      \/\/       slow locking code is the same in either case which simplifies\n-      \/\/       debugging.\n-      if (op->info() != nullptr) {\n+    assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n+    \/\/ Add debug info for NullPointerException only if one is possible.\n+    if (op->info() != nullptr) {\n+      if (!os::zero_page_read_protected() || !ImplicitNullChecks) {\n+        explicit_null_check(obj, op->info());\n+      } else {\n@@ -2641,1 +2624,0 @@\n-        __ null_check(obj);\n@@ -2643,1 +2625,0 @@\n-      __ b(*op->stub()->entry());\n@@ -2645,0 +2626,1 @@\n+    __ lock_object(hdr, obj, lock, op->scratch_opr()->as_register(), *op->stub()->entry());\n@@ -2647,12 +2629,2 @@\n-    if (LockingMode != LM_MONITOR) {\n-      assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n-      __ unlock_object(hdr, obj, lock, *op->stub()->entry());\n-    } else {\n-      \/\/ always do slow unlocking\n-      \/\/ note: The slow unlocking code could be inlined here, however if we use\n-      \/\/       slow unlocking, speed doesn't matter anyway and this solution is\n-      \/\/       simpler and requires less duplicated code - additionally, the\n-      \/\/       slow unlocking code is the same in either case which simplifies\n-      \/\/       debugging.\n-      __ b(*op->stub()->entry());\n-    }\n+    assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n+    __ unlock_object(hdr, obj, lock, *op->stub()->entry());\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":10,"deletions":38,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -85,34 +85,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lightweight_lock(Rbox, Roop, Rmark, Rscratch, slow_int);\n-  } else if (LockingMode == LM_LEGACY) {\n-\n-    if (DiagnoseSyncOnValueBasedClasses != 0) {\n-      load_klass(Rscratch, Roop);\n-      lbz(Rscratch, in_bytes(Klass::misc_flags_offset()), Rscratch);\n-      testbitdi(CR0, R0, Rscratch, exact_log2(KlassFlags::_misc_is_value_based_class));\n-      bne(CR0, slow_int);\n-    }\n-\n-    \/\/ ... and mark it unlocked.\n-    ori(Rmark, Rmark, markWord::unlocked_value);\n-\n-    \/\/ Save unlocked object header into the displaced header location on the stack.\n-    std(Rmark, BasicLock::displaced_header_offset_in_bytes(), Rbox);\n-\n-    \/\/ Compare object markWord with Rmark and if equal exchange Rscratch with object markWord.\n-    assert(oopDesc::mark_offset_in_bytes() == 0, \"cas must take a zero displacement\");\n-    cmpxchgd(\/*flag=*\/CR0,\n-             \/*current_value=*\/Rscratch,\n-             \/*compare_value=*\/Rmark,\n-             \/*exchange_value=*\/Rbox,\n-             \/*where=*\/Roop\/*+0==mark_offset_in_bytes*\/,\n-             MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n-             MacroAssembler::cmpxchgx_hint_acquire_lock(),\n-             noreg,\n-             &cas_failed,\n-             \/*check without membar and ldarx first*\/true);\n-    \/\/ If compare\/exchange succeeded we found an unlocked object and we now have locked it\n-    \/\/ hence we are done.\n-  } else {\n-    assert(false, \"Unhandled LockingMode:%d\", LockingMode);\n-  }\n+  lightweight_lock(Rbox, Roop, Rmark, Rscratch, slow_int);\n@@ -124,10 +91,0 @@\n-  if (LockingMode == LM_LEGACY) {\n-    bind(cas_failed);\n-    \/\/ We did not find an unlocked object so see if this is a recursive case.\n-    sub(Rscratch, Rscratch, R1_SP);\n-    load_const_optimized(R0, (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n-    and_(R0\/*==0?*\/, Rscratch, R0);\n-    std(R0\/*==0, perhaps*\/, BasicLock::displaced_header_offset_in_bytes(), Rbox);\n-    bne(CR0, slow_int);\n-  }\n-\n@@ -135,3 +92,0 @@\n-  if (LockingMode == LM_LEGACY) {\n-    inc_held_monitor_count(Rmark \/*tmp*\/);\n-  }\n@@ -149,7 +103,0 @@\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    \/\/ Test first if it is a fast recursive unlock.\n-    ld(Rmark, BasicLock::displaced_header_offset_in_bytes(), Rbox);\n-    cmpdi(CR0, Rmark, 0);\n-    beq(CR0, done);\n-  }\n-\n@@ -160,17 +107,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lightweight_unlock(Roop, Rmark, slow_int);\n-  } else if (LockingMode == LM_LEGACY) {\n-    \/\/ Check if it is still a light weight lock, this is is true if we see\n-    \/\/ the stack address of the basicLock in the markWord of the object.\n-    cmpxchgd(\/*flag=*\/CR0,\n-             \/*current_value=*\/R0,\n-             \/*compare_value=*\/Rbox,\n-             \/*exchange_value=*\/Rmark,\n-             \/*where=*\/Roop,\n-             MacroAssembler::MemBarRel,\n-             MacroAssembler::cmpxchgx_hint_release_lock(),\n-             noreg,\n-             &slow_int);\n-  } else {\n-    assert(false, \"Unhandled LockingMode:%d\", LockingMode);\n-  }\n+  lightweight_unlock(Roop, Rmark, slow_int);\n@@ -183,3 +114,0 @@\n-  if (LockingMode == LM_LEGACY) {\n-    dec_held_monitor_count(Rmark \/*tmp*\/);\n-  }\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":2,"deletions":74,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -949,39 +949,2 @@\n-  if (LockingMode == LM_MONITOR) {\n-    call_VM_preemptable(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n-  } else {\n-    \/\/ template code (for LM_LEGACY):\n-    \/\/\n-    \/\/ markWord displaced_header = obj->mark().set_unlocked();\n-    \/\/ monitor->lock()->set_displaced_header(displaced_header);\n-    \/\/ if (Atomic::cmpxchg(\/*addr*\/obj->mark_addr(), \/*cmp*\/displaced_header, \/*ex=*\/monitor) == displaced_header) {\n-    \/\/   \/\/ We stored the monitor address into the object's mark word.\n-    \/\/ } else if (THREAD->is_lock_owned((address)displaced_header))\n-    \/\/   \/\/ Simple recursive case.\n-    \/\/   monitor->lock()->set_displaced_header(nullptr);\n-    \/\/ } else {\n-    \/\/   \/\/ Slow path.\n-    \/\/   InterpreterRuntime::monitorenter(THREAD, monitor);\n-    \/\/ }\n-\n-    const Register header           = R7_ARG5;\n-    const Register object_mark_addr = R8_ARG6;\n-    const Register current_header   = R9_ARG7;\n-    const Register tmp              = R10_ARG8;\n-\n-    Label count_locking, done, slow_case, cas_failed;\n-\n-    assert_different_registers(header, object_mark_addr, current_header, tmp);\n-\n-    \/\/ markWord displaced_header = obj->mark().set_unlocked();\n-\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      lightweight_lock(monitor, object, header, tmp, slow_case);\n-      b(done);\n-    } else if (LockingMode == LM_LEGACY) {\n-\n-      if (DiagnoseSyncOnValueBasedClasses != 0) {\n-        load_klass(tmp, object);\n-        lbz(tmp, in_bytes(Klass::misc_flags_offset()), tmp);\n-        testbitdi(CR0, R0, tmp, exact_log2(KlassFlags::_misc_is_value_based_class));\n-        bne(CR0, slow_case);\n-      }\n+  const Register header           = R7_ARG5;\n+  const Register tmp              = R8_ARG6;\n@@ -989,56 +952,1 @@\n-      \/\/ Load markWord from object into header.\n-      ld(header, oopDesc::mark_offset_in_bytes(), object);\n-\n-      \/\/ Set displaced_header to be (markWord of object | UNLOCK_VALUE).\n-      ori(header, header, markWord::unlocked_value);\n-\n-      \/\/ monitor->lock()->set_displaced_header(displaced_header);\n-      const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n-      const int mark_offset = lock_offset +\n-                              BasicLock::displaced_header_offset_in_bytes();\n-\n-      \/\/ Initialize the box (Must happen before we update the object mark!).\n-      std(header, mark_offset, monitor);\n-\n-      \/\/ if (Atomic::cmpxchg(\/*addr*\/obj->mark_addr(), \/*cmp*\/displaced_header, \/*ex=*\/monitor) == displaced_header) {\n-\n-      \/\/ Store stack address of the BasicObjectLock (this is monitor) into object.\n-      addi(object_mark_addr, object, oopDesc::mark_offset_in_bytes());\n-\n-      \/\/ Must fence, otherwise, preceding store(s) may float below cmpxchg.\n-      \/\/ CmpxchgX sets CR0 to cmpX(current, displaced).\n-      cmpxchgd(\/*flag=*\/CR0,\n-               \/*current_value=*\/current_header,\n-               \/*compare_value=*\/header, \/*exchange_value=*\/monitor,\n-               \/*where=*\/object_mark_addr,\n-               MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n-               MacroAssembler::cmpxchgx_hint_acquire_lock(),\n-               noreg,\n-               &cas_failed,\n-               \/*check without membar and ldarx first*\/true);\n-\n-      \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n-      \/\/ object and we have now locked it.\n-      b(count_locking);\n-      bind(cas_failed);\n-\n-      \/\/ } else if (THREAD->is_lock_owned((address)displaced_header))\n-      \/\/   \/\/ Simple recursive case.\n-      \/\/   monitor->lock()->set_displaced_header(nullptr);\n-\n-      \/\/ We did not see an unlocked object so try the fast recursive case.\n-\n-      \/\/ Check if owner is self by comparing the value in the markWord of object\n-      \/\/ (current_header) with the stack pointer.\n-      sub(current_header, current_header, R1_SP);\n-\n-      assert(os::vm_page_size() > 0xfff, \"page size too small - change the constant\");\n-      load_const_optimized(tmp, ~(os::vm_page_size()-1) | markWord::lock_mask_in_place);\n-\n-      and_(R0\/*==0?*\/, current_header, tmp);\n-      \/\/ If condition is true we are done and hence we can store 0 in the displaced\n-      \/\/ header indicating it is a recursive lock.\n-      bne(CR0, slow_case);\n-      std(R0\/*==0!*\/, mark_offset, monitor);\n-      b(count_locking);\n-    }\n+  Label done, slow_case;\n@@ -1046,18 +954,9 @@\n-    \/\/ } else {\n-    \/\/   \/\/ Slow path.\n-    \/\/   InterpreterRuntime::monitorenter(THREAD, monitor);\n-\n-    \/\/ None of the above fast optimizations worked so we have to get into the\n-    \/\/ slow case of monitor enter.\n-    bind(slow_case);\n-    call_VM_preemptable(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n-    \/\/ }\n-\n-    if (LockingMode == LM_LEGACY) {\n-      b(done);\n-      align(32, 12);\n-      bind(count_locking);\n-      inc_held_monitor_count(current_header \/*tmp*\/);\n-    }\n-    bind(done);\n-  }\n+  assert_different_registers(header, tmp);\n+\n+  lightweight_lock(monitor, object, header, tmp, slow_case);\n+  b(done);\n+\n+  bind(slow_case);\n+  call_VM_preemptable(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n+\n+  bind(done);\n@@ -1074,3 +973,3 @@\n-  if (LockingMode == LM_MONITOR) {\n-    call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), monitor);\n-  } else {\n+  const Register object           = R7_ARG5;\n+  const Register header           = R8_ARG6;\n+  const Register current_header   = R10_ARG8;\n@@ -1078,36 +977,2 @@\n-    \/\/ template code (for LM_LEGACY):\n-    \/\/\n-    \/\/ if ((displaced_header = monitor->displaced_header()) == nullptr) {\n-    \/\/   \/\/ Recursive unlock. Mark the monitor unlocked by setting the object field to null.\n-    \/\/   monitor->set_obj(nullptr);\n-    \/\/ } else if (Atomic::cmpxchg(obj->mark_addr(), monitor, displaced_header) == monitor) {\n-    \/\/   \/\/ We swapped the unlocked mark in displaced_header into the object's mark word.\n-    \/\/   monitor->set_obj(nullptr);\n-    \/\/ } else {\n-    \/\/   \/\/ Slow path.\n-    \/\/   InterpreterRuntime::monitorexit(monitor);\n-    \/\/ }\n-\n-    const Register object           = R7_ARG5;\n-    const Register header           = R8_ARG6;\n-    const Register object_mark_addr = R9_ARG7;\n-    const Register current_header   = R10_ARG8;\n-\n-    Label free_slot;\n-    Label slow_case;\n-\n-    assert_different_registers(object, header, object_mark_addr, current_header);\n-\n-    if (LockingMode != LM_LIGHTWEIGHT) {\n-      \/\/ Test first if we are in the fast recursive case.\n-      ld(header, in_bytes(BasicObjectLock::lock_offset()) +\n-                 BasicLock::displaced_header_offset_in_bytes(), monitor);\n-\n-      \/\/ If the displaced header is zero, we have a recursive unlock.\n-      cmpdi(CR0, header, 0);\n-      beq(CR0, free_slot); \/\/ recursive unlock\n-    }\n-\n-    \/\/ } else if (Atomic::cmpxchg(obj->mark_addr(), monitor, displaced_header) == monitor) {\n-    \/\/   \/\/ We swapped the unlocked mark in displaced_header into the object's mark word.\n-    \/\/   monitor->set_obj(nullptr);\n+  Label free_slot;\n+  Label slow_case;\n@@ -1115,1 +980,1 @@\n-    \/\/ If we still have a lightweight lock, unlock the object and be done.\n+  assert_different_registers(object, header, current_header);\n@@ -1117,2 +982,2 @@\n-    \/\/ The object address from the monitor is in object.\n-    ld(object, in_bytes(BasicObjectLock::obj_offset()), monitor);\n+  \/\/ The object address from the monitor is in object.\n+  ld(object, in_bytes(BasicObjectLock::obj_offset()), monitor);\n@@ -1120,19 +985,1 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      lightweight_unlock(object, header, slow_case);\n-    } else {\n-      addi(object_mark_addr, object, oopDesc::mark_offset_in_bytes());\n-\n-      \/\/ We have the displaced header in displaced_header. If the lock is still\n-      \/\/ lightweight, it will contain the monitor address and we'll store the\n-      \/\/ displaced header back into the object's mark word.\n-      \/\/ CmpxchgX sets CR0 to cmpX(current, monitor).\n-      cmpxchgd(\/*flag=*\/CR0,\n-               \/*current_value=*\/current_header,\n-               \/*compare_value=*\/monitor, \/*exchange_value=*\/header,\n-               \/*where=*\/object_mark_addr,\n-               MacroAssembler::MemBarRel,\n-               MacroAssembler::cmpxchgx_hint_release_lock(),\n-               noreg,\n-               &slow_case);\n-    }\n-    b(free_slot);\n+  lightweight_unlock(object, header, slow_case);\n@@ -1140,3 +987,1 @@\n-    \/\/ } else {\n-    \/\/   \/\/ Slow path.\n-    \/\/   InterpreterRuntime::monitorexit(monitor);\n+  b(free_slot);\n@@ -1144,5 +989,2 @@\n-    \/\/ The lock has been converted into a heavy lock and hence\n-    \/\/ we need to get into the slow case.\n-    bind(slow_case);\n-    call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), monitor);\n-    \/\/ }\n+  bind(slow_case);\n+  call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), monitor);\n@@ -1150,2 +992,2 @@\n-    Label done;\n-    b(done); \/\/ Monitor register may be overwritten! Runtime has already freed the slot.\n+  Label done;\n+  b(done); \/\/ Monitor register may be overwritten! Runtime has already freed the slot.\n@@ -1153,10 +995,6 @@\n-    \/\/ Exchange worked, do monitor->set_obj(nullptr);\n-    align(32, 12);\n-    bind(free_slot);\n-    li(R0, 0);\n-    std(R0, in_bytes(BasicObjectLock::obj_offset()), monitor);\n-    if (LockingMode == LM_LEGACY) {\n-      dec_held_monitor_count(current_header \/*tmp*\/);\n-    }\n-    bind(done);\n-  }\n+  \/\/ Do monitor->set_obj(nullptr);\n+  align(32, 12);\n+  bind(free_slot);\n+  li(R0, 0);\n+  std(R0, in_bytes(BasicObjectLock::obj_offset()), monitor);\n+  bind(done);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":32,"deletions":194,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -2674,232 +2674,0 @@\n-void MacroAssembler::compiler_fast_lock_object(ConditionRegister flag, Register oop, Register box,\n-                                               Register temp, Register displaced_header, Register current_header) {\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"uses fast_lock_lightweight\");\n-  assert_different_registers(oop, box, temp, displaced_header, current_header);\n-  Label object_has_monitor;\n-  Label cas_failed;\n-  Label success, failure;\n-\n-  \/\/ Load markWord from object into displaced_header.\n-  ld(displaced_header, oopDesc::mark_offset_in_bytes(), oop);\n-\n-  if (DiagnoseSyncOnValueBasedClasses != 0) {\n-    load_klass(temp, oop);\n-    lbz(temp, in_bytes(Klass::misc_flags_offset()), temp);\n-    testbitdi(flag, R0, temp, exact_log2(KlassFlags::_misc_is_value_based_class));\n-    bne(flag, failure);\n-  }\n-\n-  \/\/ Handle existing monitor.\n-  \/\/ The object has an existing monitor iff (mark & monitor_value) != 0.\n-  andi_(temp, displaced_header, markWord::monitor_value);\n-  bne(CR0, object_has_monitor);\n-\n-  if (LockingMode == LM_MONITOR) {\n-    \/\/ Set NE to indicate 'failure' -> take slow-path.\n-    crandc(flag, Assembler::equal, flag, Assembler::equal);\n-    b(failure);\n-  } else {\n-    assert(LockingMode == LM_LEGACY, \"must be\");\n-    \/\/ Set displaced_header to be (markWord of object | UNLOCK_VALUE).\n-    ori(displaced_header, displaced_header, markWord::unlocked_value);\n-\n-    \/\/ Load Compare Value application register.\n-\n-    \/\/ Initialize the box. (Must happen before we update the object mark!)\n-    std(displaced_header, BasicLock::displaced_header_offset_in_bytes(), box);\n-\n-    \/\/ Must fence, otherwise, preceding store(s) may float below cmpxchg.\n-    \/\/ Compare object markWord with mark and if equal exchange scratch1 with object markWord.\n-    cmpxchgd(\/*flag=*\/flag,\n-             \/*current_value=*\/current_header,\n-             \/*compare_value=*\/displaced_header,\n-             \/*exchange_value=*\/box,\n-             \/*where=*\/oop,\n-             MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n-             MacroAssembler::cmpxchgx_hint_acquire_lock(),\n-             noreg,\n-             &cas_failed,\n-             \/*check without membar and ldarx first*\/true);\n-    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-    \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n-    \/\/ object and we have now locked it.\n-    b(success);\n-\n-    bind(cas_failed);\n-    \/\/ We did not see an unlocked object so try the fast recursive case.\n-\n-    \/\/ Check if the owner is self by comparing the value in the markWord of object\n-    \/\/ (current_header) with the stack pointer.\n-    sub(current_header, current_header, R1_SP);\n-    load_const_optimized(temp, ~(os::vm_page_size()-1) | markWord::lock_mask_in_place);\n-\n-    and_(R0\/*==0?*\/, current_header, temp);\n-    \/\/ If condition is true we are cont and hence we can store 0 as the\n-    \/\/ displaced header in the box, which indicates that it is a recursive lock.\n-    std(R0\/*==0, perhaps*\/, BasicLock::displaced_header_offset_in_bytes(), box);\n-\n-    if (flag != CR0) {\n-      mcrf(flag, CR0);\n-    }\n-    beq(CR0, success);\n-    b(failure);\n-  }\n-\n-  \/\/ Handle existing monitor.\n-  bind(object_has_monitor);\n-\n-  \/\/ Try to CAS owner (no owner => current thread's _monitor_owner_id).\n-  addi(temp, displaced_header, in_bytes(ObjectMonitor::owner_offset()) - markWord::monitor_value);\n-  Register thread_id = displaced_header;\n-  ld(thread_id, in_bytes(JavaThread::monitor_owner_id_offset()), R16_thread);\n-  cmpxchgd(\/*flag=*\/flag,\n-           \/*current_value=*\/current_header,\n-           \/*compare_value=*\/(intptr_t)0,\n-           \/*exchange_value=*\/thread_id,\n-           \/*where=*\/temp,\n-           MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n-           MacroAssembler::cmpxchgx_hint_acquire_lock());\n-\n-  \/\/ Store a non-null value into the box.\n-  std(box, BasicLock::displaced_header_offset_in_bytes(), box);\n-  beq(flag, success);\n-\n-  \/\/ Check for recursive locking.\n-  cmpd(flag, current_header, thread_id);\n-  bne(flag, failure);\n-\n-  \/\/ Current thread already owns the lock. Just increment recursions.\n-  Register recursions = displaced_header;\n-  ld(recursions, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), temp);\n-  addi(recursions, recursions, 1);\n-  std(recursions, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), temp);\n-\n-  \/\/ flag == EQ indicates success, increment held monitor count if LM_LEGACY is enabled\n-  \/\/ flag == NE indicates failure\n-  bind(success);\n-  if (LockingMode == LM_LEGACY) {\n-    inc_held_monitor_count(temp);\n-  }\n-#ifdef ASSERT\n-  \/\/ Check that unlocked label is reached with flag == EQ.\n-  Label flag_correct;\n-  beq(flag, flag_correct);\n-  stop(\"compiler_fast_lock_object: Flag != EQ\");\n-#endif\n-  bind(failure);\n-#ifdef ASSERT\n-  \/\/ Check that slow_path label is reached with flag == NE.\n-  bne(flag, flag_correct);\n-  stop(\"compiler_fast_lock_object: Flag != NE\");\n-  bind(flag_correct);\n-#endif\n-}\n-\n-void MacroAssembler::compiler_fast_unlock_object(ConditionRegister flag, Register oop, Register box,\n-                                                 Register temp, Register displaced_header, Register current_header) {\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"uses fast_unlock_lightweight\");\n-  assert_different_registers(oop, box, temp, displaced_header, current_header);\n-  Label success, failure, object_has_monitor, not_recursive;\n-\n-  if (LockingMode == LM_LEGACY) {\n-    \/\/ Find the lock address and load the displaced header from the stack.\n-    ld(displaced_header, BasicLock::displaced_header_offset_in_bytes(), box);\n-\n-    \/\/ If the displaced header is 0, we have a recursive unlock.\n-    cmpdi(flag, displaced_header, 0);\n-    beq(flag, success);\n-  }\n-\n-  \/\/ Handle existing monitor.\n-  \/\/ The object has an existing monitor iff (mark & monitor_value) != 0.\n-  ld(current_header, oopDesc::mark_offset_in_bytes(), oop);\n-  andi_(R0, current_header, markWord::monitor_value);\n-  bne(CR0, object_has_monitor);\n-\n-  if (LockingMode == LM_MONITOR) {\n-    \/\/ Set NE to indicate 'failure' -> take slow-path.\n-    crandc(flag, Assembler::equal, flag, Assembler::equal);\n-    b(failure);\n-  } else {\n-    assert(LockingMode == LM_LEGACY, \"must be\");\n-    \/\/ Check if it is still a light weight lock, this is is true if we see\n-    \/\/ the stack address of the basicLock in the markWord of the object.\n-    \/\/ Cmpxchg sets flag to cmpd(current_header, box).\n-    cmpxchgd(\/*flag=*\/flag,\n-             \/*current_value=*\/current_header,\n-             \/*compare_value=*\/box,\n-             \/*exchange_value=*\/displaced_header,\n-             \/*where=*\/oop,\n-             MacroAssembler::MemBarRel,\n-             MacroAssembler::cmpxchgx_hint_release_lock(),\n-             noreg,\n-             &failure);\n-    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-    b(success);\n-  }\n-\n-  \/\/ Handle existing monitor.\n-  bind(object_has_monitor);\n-  STATIC_ASSERT(markWord::monitor_value <= INT_MAX);\n-  addi(current_header, current_header, -(int)markWord::monitor_value); \/\/ monitor\n-\n-  ld(displaced_header, in_bytes(ObjectMonitor::recursions_offset()), current_header);\n-  addic_(displaced_header, displaced_header, -1);\n-  blt(CR0, not_recursive); \/\/ Not recursive if negative after decrement.\n-\n-  \/\/ Recursive unlock\n-  std(displaced_header, in_bytes(ObjectMonitor::recursions_offset()), current_header);\n-  if (flag == CR0) { \/\/ Otherwise, flag is already EQ, here.\n-    crorc(CR0, Assembler::equal, CR0, Assembler::equal); \/\/ Set CR0 EQ\n-  }\n-  b(success);\n-\n-  bind(not_recursive);\n-\n-  \/\/ Set owner to null.\n-  \/\/ Release to satisfy the JMM\n-  release();\n-  li(temp, 0);\n-  std(temp, in_bytes(ObjectMonitor::owner_offset()), current_header);\n-  \/\/ We need a full fence after clearing owner to avoid stranding.\n-  \/\/ StoreLoad achieves this.\n-  membar(StoreLoad);\n-\n-  \/\/ Check if the entry_list is empty.\n-  ld(temp, in_bytes(ObjectMonitor::entry_list_offset()), current_header);\n-  cmpdi(flag, temp, 0);\n-  beq(flag, success);  \/\/ If so we are done.\n-\n-  \/\/ Check if there is a successor.\n-  ld(temp, in_bytes(ObjectMonitor::succ_offset()), current_header);\n-  cmpdi(flag, temp, 0);\n-  \/\/ Invert equal bit\n-  crnand(flag, Assembler::equal, flag, Assembler::equal);\n-  beq(flag, success);  \/\/ If there is a successor we are done.\n-\n-  \/\/ Save the monitor pointer in the current thread, so we can try\n-  \/\/ to reacquire the lock in SharedRuntime::monitor_exit_helper().\n-  std(current_header, in_bytes(JavaThread::unlocked_inflated_monitor_offset()), R16_thread);\n-  b(failure); \/\/ flag == NE\n-\n-  \/\/ flag == EQ indicates success, decrement held monitor count if LM_LEGACY is enabled\n-  \/\/ flag == NE indicates failure\n-  bind(success);\n-  if (LockingMode == LM_LEGACY) {\n-    dec_held_monitor_count(temp);\n-  }\n-#ifdef ASSERT\n-  \/\/ Check that unlocked label is reached with flag == EQ.\n-  Label flag_correct;\n-  beq(flag, flag_correct);\n-  stop(\"compiler_fast_unlock_object: Flag != EQ\");\n-#endif\n-  bind(failure);\n-#ifdef ASSERT\n-  \/\/ Check that slow_path label is reached with flag == NE.\n-  bne(flag, flag_correct);\n-  stop(\"compiler_fast_unlock_object: Flag != NE\");\n-  bind(flag_correct);\n-#endif\n-}\n-\n@@ -4772,32 +4540,0 @@\n-\/\/ Note: Must preserve CR0 EQ (invariant).\n-void MacroAssembler::inc_held_monitor_count(Register tmp) {\n-  assert(LockingMode == LM_LEGACY, \"\");\n-  ld(tmp, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n-#ifdef ASSERT\n-  Label ok;\n-  cmpdi(CR0, tmp, 0);\n-  bge_predict_taken(CR0, ok);\n-  stop(\"held monitor count is negativ at increment\");\n-  bind(ok);\n-  crorc(CR0, Assembler::equal, CR0, Assembler::equal); \/\/ Restore CR0 EQ\n-#endif\n-  addi(tmp, tmp, 1);\n-  std(tmp, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n-}\n-\n-\/\/ Note: Must preserve CR0 EQ (invariant).\n-void MacroAssembler::dec_held_monitor_count(Register tmp) {\n-  assert(LockingMode == LM_LEGACY, \"\");\n-  ld(tmp, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n-#ifdef ASSERT\n-  Label ok;\n-  cmpdi(CR0, tmp, 0);\n-  bgt_predict_taken(CR0, ok);\n-  stop(\"held monitor count is <= 0 at decrement\");\n-  bind(ok);\n-  crorc(CR0, Assembler::equal, CR0, Assembler::equal); \/\/ Restore CR0 EQ\n-#endif\n-  addi(tmp, tmp, -1);\n-  std(tmp, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n-}\n-\n@@ -4845,1 +4581,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n@@ -4902,1 +4637,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":0,"deletions":266,"binary":false,"changes":266,"status":"modified"},{"patch":"@@ -700,2 +700,0 @@\n-  void inc_held_monitor_count(Register tmp);\n-  void dec_held_monitor_count(Register tmp);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11576,32 +11576,0 @@\n-instruct cmpFastLock(flagsRegCR0 crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2) %{\n-  predicate(LockingMode != LM_LIGHTWEIGHT);\n-  match(Set crx (FastLock oop box));\n-  effect(TEMP tmp1, TEMP tmp2);\n-\n-  format %{ \"FASTLOCK  $oop, $box, $tmp1, $tmp2\" %}\n-  ins_encode %{\n-    __ compiler_fast_lock_object($crx$$CondRegister, $oop$$Register, $box$$Register,\n-                                 $tmp1$$Register, $tmp2$$Register, \/*tmp3*\/ R0);\n-    \/\/ If locking was successful, crx should indicate 'EQ'.\n-    \/\/ The compiler generates a branch to the runtime call to\n-    \/\/ _complete_monitor_locking_Java for the case where crx is 'NE'.\n-  %}\n-  ins_pipe(pipe_class_compare);\n-%}\n-\n-instruct cmpFastUnlock(flagsRegCR0 crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2, iRegPdst tmp3) %{\n-  predicate(LockingMode != LM_LIGHTWEIGHT);\n-  match(Set crx (FastUnlock oop box));\n-  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);\n-\n-  format %{ \"FASTUNLOCK  $oop, $box, $tmp1, $tmp2\" %}\n-  ins_encode %{\n-    __ compiler_fast_unlock_object($crx$$CondRegister, $oop$$Register, $box$$Register,\n-                                   $tmp1$$Register, $tmp2$$Register, $tmp3$$Register);\n-    \/\/ If unlocking was successful, crx should indicate 'EQ'.\n-    \/\/ The compiler generates a branch to the runtime call to\n-    \/\/ _complete_monitor_unlocking_Java for the case where crx is 'NE'.\n-  %}\n-  ins_pipe(pipe_class_compare);\n-%}\n-\n@@ -11609,1 +11577,1 @@\n-  predicate(LockingMode == LM_LIGHTWEIGHT && !UseObjectMonitorTable);\n+  predicate(!UseObjectMonitorTable);\n@@ -11625,1 +11593,1 @@\n-  predicate(LockingMode == LM_LIGHTWEIGHT && UseObjectMonitorTable);\n+  predicate(UseObjectMonitorTable);\n@@ -11641,1 +11609,0 @@\n-  predicate(LockingMode == LM_LIGHTWEIGHT);\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":2,"deletions":35,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2449,8 +2449,3 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      \/\/ fast_lock kills r_temp_1, r_temp_2, r_temp_3.\n-      Register r_temp_3_or_noreg = UseObjectMonitorTable ? r_temp_3 : noreg;\n-      __ compiler_fast_lock_lightweight_object(CR0, r_oop, r_box, r_temp_1, r_temp_2, r_temp_3_or_noreg);\n-    } else {\n-      \/\/ fast_lock kills r_temp_1, r_temp_2, r_temp_3.\n-      __ compiler_fast_lock_object(CR0, r_oop, r_box, r_temp_1, r_temp_2, r_temp_3);\n-    }\n+    \/\/ fast_lock kills r_temp_1, r_temp_2, r_temp_3.\n+    Register r_temp_3_or_noreg = UseObjectMonitorTable ? r_temp_3 : noreg;\n+    __ compiler_fast_lock_lightweight_object(CR0, r_oop, r_box, r_temp_1, r_temp_2, r_temp_3_or_noreg);\n@@ -2623,1 +2618,1 @@\n-    if (LockingMode != LM_LEGACY && method->is_object_wait0()) {\n+    if (method->is_object_wait0()) {\n@@ -2675,5 +2670,1 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      __ compiler_fast_unlock_lightweight_object(CR0, r_oop, r_box, r_temp_1, r_temp_2, r_temp_3);\n-    } else {\n-      __ compiler_fast_unlock_object(CR0, r_oop, r_box, r_temp_1, r_temp_2, r_temp_3);\n-    }\n+    __ compiler_fast_unlock_lightweight_object(CR0, r_oop, r_box, r_temp_1, r_temp_2, r_temp_3);\n@@ -2720,1 +2711,1 @@\n-  bool maybe_preempted = LockingMode != LM_LEGACY && method->is_object_wait0();\n+  bool maybe_preempted = method->is_object_wait0();\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":6,"deletions":15,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1365,1 +1365,1 @@\n-  bool support_vthread_preemption = Continuations::enabled() && LockingMode != LM_LEGACY;\n+  bool support_vthread_preemption = Continuations::enabled();\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}