{"files":[{"patch":"@@ -1416,0 +1416,14 @@\n+Node* MaxINode::Identity(PhaseGVN* phase) {\n+  const TypeInt* t1 = phase->type(in(1))->is_int();\n+  const TypeInt* t2 = phase->type(in(2))->is_int();\n+\n+  \/\/ Can we determine the maximum statically?\n+  if (t1->_lo >= t2->_hi) {\n+    return in(1);\n+  } else if (t2->_lo >= t1->_hi) {\n+    return in(2);\n+  }\n+\n+  return MaxNode::Identity(phase);\n+}\n+\n@@ -1435,0 +1449,14 @@\n+Node* MinINode::Identity(PhaseGVN* phase) {\n+  const TypeInt* t1 = phase->type(in(1))->is_int();\n+  const TypeInt* t2 = phase->type(in(2))->is_int();\n+\n+  \/\/ Can we determine the minimum statically?\n+  if (t1->_lo >= t2->_hi) {\n+    return in(2);\n+  } else if (t2->_lo >= t1->_hi) {\n+    return in(1);\n+  }\n+\n+  return MaxNode::Identity(phase);\n+}\n+\n@@ -1577,0 +1605,35 @@\n+int MaxNode::opposite_opcode() const {\n+  if (Opcode() == max_opcode()) {\n+    return min_opcode();\n+  } else {\n+    assert(Opcode() == min_opcode(), \"Caller should be either %s or %s, but is %s\", NodeClassNames[max_opcode()], NodeClassNames[min_opcode()], NodeClassNames[Opcode()]);\n+    return max_opcode();\n+  }\n+}\n+\n+\/\/ Given a redundant structure such as Max\/Min(A, Max\/Min(B, C)) where A == B or A == C, return the useful part of the structure.\n+\/\/ 'operation' is the node expected to be the inner 'Max\/Min(B, C)', and 'operand' is the node expected to be the 'A' operand of the outer node.\n+Node* MaxNode::find_identity_operation(Node* operation, Node* operand) {\n+  if (operation->Opcode() == Opcode() || operation->Opcode() == opposite_opcode()) {\n+    Node* n1 = operation->in(1);\n+    Node* n2 = operation->in(2);\n+\n+    \/\/ Given Op(A, Op(B, C)), see if either A == B or A == C is true.\n+    if (n1 == operand || n2 == operand) {\n+      \/\/ If the operations are the same return the inner operation, as Max(A, Max(A, B)) == Max(A, B).\n+      if (operation->Opcode() == Opcode()) {\n+        return operation;\n+      }\n+\n+      \/\/ If the operations are different return the operand 'A', as Max(A, Min(A, B)) == A if the value isn't floating point.\n+      \/\/ With floating point values, the identity doesn't hold if B == NaN.\n+      const Type* type = bottom_type();\n+      if (type->isa_int() || type->isa_long()) {\n+        return operand;\n+      }\n+    }\n+  }\n+\n+  return nullptr;\n+}\n+\n@@ -1582,0 +1645,10 @@\n+  Node* identity_1 = MaxNode::find_identity_operation(in(2), in(1));\n+  if (identity_1 != nullptr) {\n+    return identity_1;\n+  }\n+\n+  Node* identity_2 = MaxNode::find_identity_operation(in(1), in(2));\n+  if (identity_2 != nullptr) {\n+    return identity_2;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":73,"deletions":0,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -265,2 +265,1 @@\n-\/\/ all the behavior of addition on a ring.  Only new thing is that we allow\n-\/\/ 2 equal inputs to be equal.\n+\/\/ all the behavior of addition on a ring.\n@@ -280,0 +279,2 @@\n+  Node* find_identity_operation(Node* operation, Node* operand);\n+  int opposite_opcode() const;\n@@ -324,0 +325,1 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n@@ -340,1 +342,2 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+  virtual Node* Identity(PhaseGVN* phase);\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @bug 8290248 8312547\n+ * @bug 8290248 8312547 8341781\n@@ -49,0 +49,1 @@\n+                 \"testMax5\",\n@@ -52,1 +53,2 @@\n-                 \"testMin4\"})\n+                 \"testMin4\",\n+                 \"testMin5\"})\n@@ -79,0 +81,1 @@\n+        Asserts.assertEQ(8                                                          , testMax5(a));\n@@ -84,0 +87,1 @@\n+        Asserts.assertEQ(a & 7                                                      , testMin5(a));\n@@ -222,0 +226,12 @@\n+    @Test\n+    @IR(failOn = {IRNode.MAX_I})\n+    public int testMax5(int i) {\n+        return Math.max(i & 7, 8);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MIN_I})\n+    public int testMin5(int i) {\n+        return Math.min(i & 7, 8);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/MaxMinINodeIdealizationTests.java","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @bug 8341781\n+ * @summary Test identities of MinNodes and MaxNodes.\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestMinMaxIdentities\n+ *\/\n+\n+public class TestMinMaxIdentities {\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = { \"intMinMin\", \"intMinMax\", \"intMaxMin\", \"intMaxMax\",\n+                  \"longMinMin\", \"longMinMax\", \"longMaxMin\", \"longMaxMax\",\n+                  \"floatMinMin\", \"floatMaxMax\", \"doubleMinMin\", \"doubleMaxMax\",\n+                  \"floatMinMax\", \"floatMaxMin\", \"doubleMinMax\", \"doubleMaxMin\" })\n+    public void runMethod() {\n+        assertResult(10, 20, 10L, 20L, 10.f, 20.f, 10.0, 20.0);\n+        assertResult(20, 10, 20L, 10L, 20.f, 10.f, 20.0, 10.0);\n+\n+        assertResult(RANDOM.nextInt(), RANDOM.nextInt(), RANDOM.nextLong(), RANDOM.nextLong(), RANDOM.nextFloat(), RANDOM.nextFloat(), RANDOM.nextDouble(), RANDOM.nextDouble());\n+        assertResult(RANDOM.nextInt(), RANDOM.nextInt(), RANDOM.nextLong(), RANDOM.nextLong(), RANDOM.nextFloat(), RANDOM.nextFloat(), RANDOM.nextDouble(), RANDOM.nextDouble());\n+\n+        assertResult(Integer.MAX_VALUE, Integer.MIN_VALUE, Long.MAX_VALUE, Long.MIN_VALUE, Float.POSITIVE_INFINITY, Float.NaN, Double.POSITIVE_INFINITY, Double.NaN);\n+        assertResult(Integer.MIN_VALUE, Integer.MAX_VALUE, Long.MIN_VALUE, Long.MAX_VALUE, Float.NaN, Float.POSITIVE_INFINITY, Double.NaN, Double.POSITIVE_INFINITY);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(int iA, int iB, long lA, long lB, float fA, float fB, double dA, double dB) {\n+        Asserts.assertEQ(Math.min(iA, Math.min(iA, iB)), intMinMin(iA, iB));\n+        Asserts.assertEQ(Math.min(iA, Math.max(iA, iB)), intMinMax(iA, iB));\n+        Asserts.assertEQ(Math.max(iA, Math.min(iA, iB)), intMaxMin(iA, iB));\n+        Asserts.assertEQ(Math.max(iA, Math.max(iA, iB)), intMaxMax(iA, iB));\n+\n+        Asserts.assertEQ(Math.min(lA, Math.min(lA, lB)), longMinMin(lA, lB));\n+        Asserts.assertEQ(Math.min(lA, Math.max(lA, lB)), longMinMax(lA, lB));\n+        Asserts.assertEQ(Math.max(lA, Math.min(lA, lB)), longMaxMin(lA, lB));\n+        Asserts.assertEQ(Math.max(lA, Math.max(lA, lB)), longMaxMax(lA, lB));\n+\n+        Asserts.assertEQ(Math.min(fA, Math.min(fA, fB)), floatMinMin(fA, fB));\n+        Asserts.assertEQ(Math.max(fA, Math.max(fA, fB)), floatMaxMax(fA, fB));\n+\n+        Asserts.assertEQ(Math.min(dA, Math.min(dA, dB)), doubleMinMin(dA, dB));\n+        Asserts.assertEQ(Math.max(dA, Math.max(dA, dB)), doubleMaxMax(dA, dB));\n+\n+        \/\/ Due to NaN, these identities cannot be simplified.\n+\n+        Asserts.assertEQ(Math.min(fA, Math.max(fA, fB)), floatMinMax(fA, fB));\n+        Asserts.assertEQ(Math.max(fA, Math.min(fA, fB)), floatMaxMin(fA, fB));\n+        Asserts.assertEQ(Math.min(dA, Math.max(dA, dB)), doubleMinMax(dA, dB));\n+        Asserts.assertEQ(Math.max(dA, Math.min(dA, dB)), doubleMaxMin(dA, dB));\n+    }\n+\n+    \/\/ Integers\n+\n+    @Test\n+    @IR(counts = { IRNode.MIN_I, \"1\" })\n+    public int intMinMin(int a, int b) {\n+        return Math.min(a, Math.min(a, b));\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.MIN_I, IRNode.MAX_I })\n+    public int intMinMax(int a, int b) {\n+        return Math.min(a, Math.max(a, b));\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.MIN_I, IRNode.MAX_I })\n+    public int intMaxMin(int a, int b) {\n+        return Math.max(a, Math.min(a, b));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MAX_I, \"1\" })\n+    public int intMaxMax(int a, int b) {\n+        return Math.max(a, Math.max(a, b));\n+    }\n+\n+    \/\/ Longs\n+\n+    \/\/ As Math.min\/max(LL) is not intrinsified, it first needs to be transformed into CMoveL and then MinL\/MaxL before\n+    \/\/ the identity can be matched. However, the outer min\/max is not transformed into CMove because of the CMove cost model.\n+    \/\/ As JDK-8307513 adds intrinsics for the methods, the Long tests are disabled until then.\n+\n+    @Test\n+\/\/     @IR(applyIfPlatform = { \"riscv64\", \"false\" }, phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, counts = { IRNode.MIN_L, \"1\" })\n+    public long longMinMin(long a, long b) {\n+        return Math.min(a, Math.min(a, b));\n+    }\n+\n+    @Test\n+\/\/     @IR(applyIfPlatform = { \"riscv64\", \"false\" }, phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.MIN_L, IRNode.MAX_L })\n+    public long longMinMax(long a, long b) {\n+        return Math.min(a, Math.max(a, b));\n+    }\n+\n+    @Test\n+\/\/     @IR(applyIfPlatform = { \"riscv64\", \"false\" }, phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.MIN_L, IRNode.MAX_L })\n+    public long longMaxMin(long a, long b) {\n+        return Math.max(a, Math.min(a, b));\n+    }\n+\n+    @Test\n+\/\/     @IR(applyIfPlatform = { \"riscv64\", \"false\" }, phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, counts = { IRNode.MAX_L, \"1\" })\n+    public long longMaxMax(long a, long b) {\n+        return Math.max(a, Math.max(a, b));\n+    }\n+\n+    \/\/ Floats\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"}, counts = { IRNode.MIN_F, \"1\" })\n+    public float floatMinMin(float a, float b) {\n+        return Math.min(a, Math.min(a, b));\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"}, counts = { IRNode.MAX_F, \"1\" })\n+    public float floatMaxMax(float a, float b) {\n+        return Math.max(a, Math.max(a, b));\n+    }\n+\n+    \/\/ Doubles\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"}, counts = { IRNode.MIN_D, \"1\" })\n+    public double doubleMinMin(double a, double b) {\n+        return Math.min(a, Math.min(a, b));\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"}, counts = { IRNode.MAX_D, \"1\" })\n+    public double doubleMaxMax(double a, double b) {\n+        return Math.max(a, Math.max(a, b));\n+    }\n+\n+    \/\/ Float and double identities that cannot be simplified due to NaN\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"}, counts = { IRNode.MIN_F, \"1\", IRNode.MAX_F, \"1\" })\n+    public float floatMinMax(float a, float b) {\n+        return Math.min(a, Math.max(a, b));\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"}, counts = { IRNode.MIN_F, \"1\", IRNode.MAX_F, \"1\" })\n+    public float floatMaxMin(float a, float b) {\n+        return Math.max(a, Math.min(a, b));\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"}, counts = { IRNode.MIN_D, \"1\", IRNode.MAX_D, \"1\" })\n+    public double doubleMinMax(double a, double b) {\n+        return Math.min(a, Math.max(a, b));\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"}, counts = { IRNode.MIN_D, \"1\", IRNode.MAX_D, \"1\" })\n+    public double doubleMaxMin(double a, double b) {\n+        return Math.max(a, Math.min(a, b));\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestMinMaxIdentities.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -219,1 +219,0 @@\n-        int val = 65536;\n@@ -221,1 +220,1 @@\n-            res[i] = (short) Math.min(a[i], val);\n+            res[i] = (short) Math.min(a[i], b[i]);\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicShortOpTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}