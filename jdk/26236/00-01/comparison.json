{"files":[{"patch":"@@ -360,6 +360,0 @@\n-  \/\/ SVE requires vector indices for gather-load\/scatter-store operations\n-  \/\/ on all data types.\n-  bool Matcher::gather_scatter_needs_vector_index(BasicType bt) {\n-    return UseSVE > 0;\n-  }\n-\n@@ -5285,4 +5279,4 @@\n-   predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n-   match(Set dst (VectorSlice (Binary src1 src2) index));\n-   format %{ \"vslice_neon $dst, $src1, $src2, $index\" %}\n-   ins_encode %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (VectorSlice (Binary src1 src2) index));\n+  format %{ \"vslice_neon $dst, $src1, $src2, $index\" %}\n+  ins_encode %{\n@@ -5299,4 +5293,4 @@\n-   predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n-   match(Set dst_src1 (VectorSlice (Binary dst_src1 src2) index));\n-   format %{ \"vslice_sve $dst_src1, $dst_src1, $src2, $index\" %}\n-   ins_encode %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (VectorSlice (Binary dst_src1 src2) index));\n+  format %{ \"vslice_sve $dst_src1, $dst_src1, $src2, $index\" %}\n+  ins_encode %{\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -350,6 +350,0 @@\n-  \/\/ SVE requires vector indices for gather-load\/scatter-store operations\n-  \/\/ on all data types.\n-  bool Matcher::gather_scatter_needs_vector_index(BasicType bt) {\n-    return UseSVE > 0;\n-  }\n-\n@@ -3430,4 +3424,4 @@\n-   predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n-   match(Set dst (VectorSlice (Binary src1 src2) index));\n-   format %{ \"vslice_neon $dst, $src1, $src2, $index\" %}\n-   ins_encode %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (VectorSlice (Binary src1 src2) index));\n+  format %{ \"vslice_neon $dst, $src1, $src2, $index\" %}\n+  ins_encode %{\n@@ -3444,4 +3438,4 @@\n-   predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n-   match(Set dst_src1 (VectorSlice (Binary dst_src1 src2) index));\n-   format %{ \"vslice_sve $dst_src1, $dst_src1, $src2, $index\" %}\n-   ins_encode %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (VectorSlice (Binary dst_src1 src2) index));\n+  format %{ \"vslice_sve $dst_src1, $dst_src1, $src2, $index\" %}\n+  ins_encode %{\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -167,0 +167,6 @@\n+  \/\/ SVE requires vector indices for gather-load\/scatter-store operations\n+  \/\/ on all data types.\n+  static bool gather_scatter_needs_vector_index(BasicType bt) {\n+    return has_predicated_vectors();\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/matcher_aarch64.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1006,4 +1006,0 @@\n-bool Matcher::gather_scatter_needs_vector_index(BasicType bt) {\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -160,0 +160,5 @@\n+  \/\/ Return true if vector gather-load\/scatter-store needs vector index as input.\n+  static bool gather_scatter_needs_vector_index(BasicType bt) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/arm\/matcher_arm.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -170,0 +170,5 @@\n+  \/\/ Return true if vector gather-load\/scatter-store needs vector index as input.\n+  static bool gather_scatter_needs_vector_index(BasicType bt) {\n+    return !is_subword_type(bt);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/matcher_ppc.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2295,4 +2295,0 @@\n-bool Matcher::gather_scatter_needs_vector_index(BasicType bt) {\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -166,0 +166,5 @@\n+  \/\/ Return true if vector gather-load\/scatter-store needs vector index as input.\n+  static bool gather_scatter_needs_vector_index(BasicType bt) {\n+    return !is_subword_type(bt);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/matcher_riscv.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -166,4 +166,0 @@\n-\n-  bool Matcher::gather_scatter_needs_vector_index(BasicType bt) {\n-    return !is_subword_type(bt);\n-  }\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -163,0 +163,5 @@\n+  \/\/ Return true if vector gather-load\/scatter-store needs vector index as input.\n+  static bool gather_scatter_needs_vector_index(BasicType bt) {\n+    return !is_subword_type(bt);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/s390\/matcher_s390.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1812,4 +1812,0 @@\n-bool Matcher::gather_scatter_needs_vector_index(BasicType bt) {\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,0 +158,5 @@\n+  \/\/ Return true if vector gather-load\/scatter-store needs vector index as input.\n+  static bool gather_scatter_needs_vector_index(BasicType bt) {\n+    return !is_subword_type(bt);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/matcher_x86.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2103,5 +2103,0 @@\n-\/\/ Return true if vector gather-load\/scatter-store needs vector index as input.\n-bool Matcher::gather_scatter_needs_vector_index(BasicType bt) {\n-  return !is_subword_type(bt);\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -341,3 +341,0 @@\n-  \/\/ Return true if vector gather-load\/scatter-store needs vector index as input.\n-  static bool gather_scatter_needs_vector_index(BasicType bt);\n-\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1500,3 +1500,3 @@\n-  Node* idx_vect1 = nullptr;\n-  Node* idx_vect2 = nullptr;\n-  Node* idx_vect3 = nullptr;\n+  Node* indexes1 = nullptr;\n+  Node* indexes2 = nullptr;\n+  Node* indexes3 = nullptr;\n@@ -1507,4 +1507,2 @@\n-      idx_vect1 = unbox_vector(idx1, vbox_idx_type, T_INT, idx_num_elem);\n-      if (idx_vect1 == nullptr) {\n-        set_map(old_map);\n-        set_sp(old_sp);\n+      indexes1 = unbox_vector(idx1, vbox_idx_type, T_INT, idx_num_elem);\n+      if (indexes1 == nullptr) {\n@@ -1521,2 +1519,0 @@\n-        set_map(old_map);\n-        set_sp(old_sp);\n@@ -1526,5 +1522,3 @@\n-      idx_vect2 = unbox_vector(idx2, vbox_idx_type, T_INT, idx_num_elem);\n-      idx_vect3 = unbox_vector(idx3, vbox_idx_type, T_INT, idx_num_elem);\n-      if (idx_vect2 == nullptr || idx_vect3 == nullptr) {\n-        set_map(old_map);\n-        set_sp(old_sp);\n+      indexes2 = unbox_vector(idx2, vbox_idx_type, T_INT, idx_num_elem);\n+      indexes3 = unbox_vector(idx3, vbox_idx_type, T_INT, idx_num_elem);\n+      if (indexes2 == nullptr || indexes3 == nullptr) {\n@@ -1567,1 +1561,1 @@\n-        vload = gen_gather_load_masked_subword(addr, indexes, idx_vect1, idx_vect2, idx_vect3, mask, vector_type);\n+        vload = gen_gather_load_masked_subword(addr, indexes, indexes1, indexes2, indexes3, mask, vector_type);\n@@ -1573,1 +1567,1 @@\n-        vload = gen_gather_load_subword(addr, indexes, idx_vect1, idx_vect2, idx_vect3, vector_type);\n+        vload = gen_gather_load_subword(addr, indexes, indexes1, indexes2, indexes3, vector_type);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":10,"deletions":16,"binary":false,"changes":26,"status":"modified"}]}