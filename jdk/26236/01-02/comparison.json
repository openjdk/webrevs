{"files":[{"patch":"@@ -2404,14 +2404,0 @@\n-\/\/ Vector ideal reg size corresponding to the specified len in bytes\n-uint Matcher::vector_ideal_reg_size(int len) {\n-  assert(MaxVectorSize >= len, \"\");\n-  uint ideal_reg = vector_ideal_reg(len);\n-  switch (ideal_reg) {\n-    case Op_VecD: return 8;\n-    case Op_VecX: return 16;\n-    case Op_VecA: return MaxVectorSize;\n-    default:\n-      ShouldNotReachHere();\n-      return 0;\n-  }\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -5276,6 +5276,4 @@\n-\/\/ ---------------------------- Vector Slice ------------------------\n-\n-instruct vslice_neon(vReg dst, vReg src1, vReg src2, immI index) %{\n-  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n-  match(Set dst (VectorSlice (Binary src1 src2) index));\n-  format %{ \"vslice_neon $dst, $src1, $src2, $index\" %}\n+\/\/ ---------------------------- VectorConcatenate ------------------------------\n+instruct vconcatenate(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (VectorConcatenate src1 src2));\n+  format %{ \"vconcatenate $dst, $src1, $src2\" %}\n@@ -5284,17 +5282,8 @@\n-    uint scale = type2aelembytes(Matcher::vector_element_basic_type(this));\n-    __ ext($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n-           $src1$$FloatRegister, $src2$$FloatRegister,\n-           ((uint)$index$$constant * scale));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vslice_sve(vReg dst_src1, vReg src2, immI index) %{\n-  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n-  match(Set dst_src1 (VectorSlice (Binary dst_src1 src2) index));\n-  format %{ \"vslice_sve $dst_src1, $dst_src1, $src2, $index\" %}\n-  ins_encode %{\n-    assert(UseSVE > 0, \"must be sve\");\n-    uint scale = type2aelembytes(Matcher::vector_element_basic_type(this));\n-    __ sve_ext($dst_src1$$FloatRegister, $src2$$FloatRegister,\n-               ((uint)$index$$constant * scale));\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ uzp1($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_uzp1($dst$$FloatRegister, get_reg_variant(this),\n+                  $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n@@ -5970,3 +5959,3 @@\n-\/\/ Unpack elements from the lowest or highest half of the source\n-\/\/ predicate and place in elements of twice their size within the\n-\/\/ destination predicate.\n+\/\/ Unpack elements from the lower or upper half of the source\n+\/\/ predicate and place in elements of twice their size within\n+\/\/ the destination predicate.\n@@ -5975,1 +5964,1 @@\n-  predicate(UseSVE > 0 && n->as_VectorMaskWiden()->is_lo());\n+  predicate(UseSVE > 0 && !n->as_VectorMaskWiden()->is_hi());\n@@ -5985,1 +5974,1 @@\n-  predicate(UseSVE > 0 && !n->as_VectorMaskWiden()->is_lo());\n+  predicate(UseSVE > 0 && n->as_VectorMaskWiden()->is_hi());\n@@ -6727,1 +6716,1 @@\n-instruct gather_load_subword_le128(vReg dst, indirect mem, vReg idx) %{\n+instruct gather_loadB(vReg dst, indirect mem, vReg idx) %{\n@@ -6729,2 +6718,1 @@\n-            type2aelembytes(Matcher::vector_element_basic_type(n)) <= 2 &&\n-            Matcher::vector_length_in_bytes(n->as_LoadVectorGather()->in(3)) <= 16);\n+            type2aelembytes(n->as_LoadVectorGather()->mem_bt()) == 1);\n@@ -6732,2 +6720,1 @@\n-  effect(TEMP_DEF dst);\n-  format %{ \"gather_load_subword_le128 $dst, $mem, $idx\\t# vector (sve)\" %}\n+  format %{ \"gather_loadB $dst, $mem, $idx\\t# vector (sve)\" %}\n@@ -6735,12 +6722,4 @@\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    if (bt == T_BYTE) {\n-      __ sve_ld1b_gather($dst$$FloatRegister, ptrue,\n-                         as_Register($mem$$base), $idx$$FloatRegister);\n-      __ xtn($dst$$FloatRegister, __ T4H, $dst$$FloatRegister, __ T4S);\n-      __ xtn($dst$$FloatRegister, __ T8B, $dst$$FloatRegister, __ T8H);\n-    } else {\n-      assert(bt == T_SHORT, \"unsupported type\");\n-      __ sve_ld1h_gather($dst$$FloatRegister, ptrue,\n-                         as_Register($mem$$base), $idx$$FloatRegister);\n-      __ xtn($dst$$FloatRegister, __ T4H, $dst$$FloatRegister, __ T4S);\n-    }\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_ld1b_gather($dst$$FloatRegister, ptrue,\n+                       as_Register($mem$$base), $idx$$FloatRegister);\n@@ -6751,1 +6730,1 @@\n-instruct gather_load_subword_gt128(vReg dst, indirect mem, vReg idx, vReg vtmp) %{\n+instruct gather_loadH(vReg dst, indirect mem, vReg idx) %{\n@@ -6753,2 +6732,1 @@\n-            type2aelembytes(Matcher::vector_element_basic_type(n)) <= 2 &&\n-            Matcher::vector_length_in_bytes(n->as_LoadVectorGather()->in(3)) > 16);\n+            type2aelembytes(n->as_LoadVectorGather()->mem_bt()) == 2);\n@@ -6756,2 +6734,1 @@\n-  effect(TEMP_DEF dst, TEMP vtmp);\n-  format %{ \"gather_load_subword_gt128 $dst, $mem, $idx\\t# vector (sve). KILL $vtmp\" %}\n+  format %{ \"gather_loadH $dst, $mem, $idx\\t# vector (sve)\" %}\n@@ -6759,13 +6736,4 @@\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_dup($vtmp$$FloatRegister, __ S, 0);\n-    if (bt == T_BYTE) {\n-      __ sve_ld1b_gather($dst$$FloatRegister, ptrue,\n-                         as_Register($mem$$base), $idx$$FloatRegister);\n-      __ sve_uzp1($dst$$FloatRegister, __ H, $dst$$FloatRegister, $vtmp$$FloatRegister);\n-      __ sve_uzp1($dst$$FloatRegister, __ B, $dst$$FloatRegister, $vtmp$$FloatRegister);\n-    } else {\n-      assert(bt == T_SHORT, \"unsupported type\");\n-      __ sve_ld1h_gather($dst$$FloatRegister, ptrue,\n-                         as_Register($mem$$base), $idx$$FloatRegister);\n-      __ sve_uzp1($dst$$FloatRegister, __ H, $dst$$FloatRegister, $vtmp$$FloatRegister);\n-    }\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_ld1h_gather($dst$$FloatRegister, ptrue,\n+                       as_Register($mem$$base), $idx$$FloatRegister);\n@@ -6778,1 +6746,1 @@\n-            type2aelembytes(Matcher::vector_element_basic_type(n)) == 4);\n+            type2aelembytes(n->as_LoadVectorGather()->mem_bt()) == 4);\n@@ -6792,1 +6760,1 @@\n-            type2aelembytes(Matcher::vector_element_basic_type(n)) == 8);\n+            type2aelembytes(n->as_LoadVectorGather()->mem_bt()) == 8);\n@@ -6806,1 +6774,3 @@\n-instruct gather_load_subword_masked_le128(vReg dst, indirect mem, vReg idx, pRegGov pg) %{\n+\/\/ ------------------------------ Vector Load Gather Masked ---------------------------\n+\n+instruct gather_loadB_masked(vReg dst, indirect mem, vReg idx, pRegGov pg) %{\n@@ -6808,2 +6778,1 @@\n-            type2aelembytes(Matcher::vector_element_basic_type(n)) <= 2 &&\n-            Matcher::vector_length_in_bytes(n->as_LoadVectorGatherMasked()->in(3)->in(1)) <= 16);\n+            type2aelembytes(n->as_LoadVectorGatherMasked()->mem_bt()) == 1);\n@@ -6811,2 +6780,1 @@\n-  effect(TEMP_DEF dst);\n-  format %{ \"gather_load_subword_masked_le128 $dst, $pg, $mem, $idx\\t# vector (sve)\" %}\n+  format %{ \"gather_loadB_masked $dst, $pg, $mem, $idx\" %}\n@@ -6814,12 +6782,2 @@\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    if (bt == T_BYTE) {\n-      __ sve_ld1b_gather($dst$$FloatRegister, $pg$$PRegister,\n-                         as_Register($mem$$base), $idx$$FloatRegister);\n-      __ xtn($dst$$FloatRegister, __ T4H, $dst$$FloatRegister, __ T4S);\n-      __ xtn($dst$$FloatRegister, __ T8B, $dst$$FloatRegister, __ T8H);\n-    } else {\n-      assert(bt == T_SHORT, \"unsupported type\");\n-      __ sve_ld1h_gather($dst$$FloatRegister, $pg$$PRegister,\n-                         as_Register($mem$$base), $idx$$FloatRegister);\n-      __ xtn($dst$$FloatRegister, __ T4H, $dst$$FloatRegister, __ T4S);\n-    }\n+    __ sve_ld1b_gather($dst$$FloatRegister, $pg$$PRegister,\n+                       as_Register($mem$$base), $idx$$FloatRegister);\n@@ -6830,1 +6788,1 @@\n-instruct gather_load_subword_masked_gt128(vReg dst, indirect mem, vReg idx, vReg vtmp, pRegGov pg) %{\n+instruct gather_loadH_masked(vReg dst, indirect mem, vReg idx, pRegGov pg) %{\n@@ -6832,2 +6790,1 @@\n-            type2aelembytes(Matcher::vector_element_basic_type(n)) <= 2 &&\n-            Matcher::vector_length_in_bytes(n->as_LoadVectorGatherMasked()->in(3)->in(1)) > 16);\n+            type2aelembytes(n->as_LoadVectorGatherMasked()->mem_bt()) == 2);\n@@ -6835,2 +6792,1 @@\n-  effect(TEMP_DEF dst, TEMP vtmp);\n-  format %{ \"gather_load_subword_masked_gt128 $dst, $pg, $mem, $idx\\t# vector (sve). KILL $vtmp\" %}\n+  format %{ \"gather_loadH_masked $dst, $pg, $mem, $idx\" %}\n@@ -6838,13 +6794,2 @@\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_dup($vtmp$$FloatRegister, __ S, 0);\n-    if (bt == T_BYTE) {\n-      __ sve_ld1b_gather($dst$$FloatRegister, $pg$$PRegister,\n-                         as_Register($mem$$base), $idx$$FloatRegister);\n-      __ sve_uzp1($dst$$FloatRegister, __ H, $dst$$FloatRegister, $vtmp$$FloatRegister);\n-      __ sve_uzp1($dst$$FloatRegister, __ B, $dst$$FloatRegister, $vtmp$$FloatRegister);\n-    } else {\n-      assert(bt == T_SHORT, \"unsupported type\");\n-      __ sve_ld1h_gather($dst$$FloatRegister, $pg$$PRegister,\n-                         as_Register($mem$$base), $idx$$FloatRegister);\n-      __ sve_uzp1($dst$$FloatRegister, __ H, $dst$$FloatRegister, $vtmp$$FloatRegister);\n-    }\n+    __ sve_ld1h_gather($dst$$FloatRegister, $pg$$PRegister,\n+                       as_Register($mem$$base), $idx$$FloatRegister);\n@@ -6857,1 +6802,1 @@\n-            type2aelembytes(Matcher::vector_element_basic_type(n)) == 4);\n+            type2aelembytes(n->as_LoadVectorGatherMasked()->mem_bt()) == 4);\n@@ -6869,1 +6814,1 @@\n-            type2aelembytes(Matcher::vector_element_basic_type(n)) == 8);\n+            type2aelembytes(n->as_LoadVectorGatherMasked()->mem_bt()) == 8);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":47,"deletions":102,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -3421,6 +3421,4 @@\n-\/\/ ---------------------------- Vector Slice ------------------------\n-\n-instruct vslice_neon(vReg dst, vReg src1, vReg src2, immI index) %{\n-  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n-  match(Set dst (VectorSlice (Binary src1 src2) index));\n-  format %{ \"vslice_neon $dst, $src1, $src2, $index\" %}\n+\/\/ ---------------------------- VectorConcatenate ------------------------------\n+instruct vconcatenate(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (VectorConcatenate src1 src2));\n+  format %{ \"vconcatenate $dst, $src1, $src2\" %}\n@@ -3429,17 +3427,8 @@\n-    uint scale = type2aelembytes(Matcher::vector_element_basic_type(this));\n-    __ ext($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n-           $src1$$FloatRegister, $src2$$FloatRegister,\n-           ((uint)$index$$constant * scale));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vslice_sve(vReg dst_src1, vReg src2, immI index) %{\n-  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n-  match(Set dst_src1 (VectorSlice (Binary dst_src1 src2) index));\n-  format %{ \"vslice_sve $dst_src1, $dst_src1, $src2, $index\" %}\n-  ins_encode %{\n-    assert(UseSVE > 0, \"must be sve\");\n-    uint scale = type2aelembytes(Matcher::vector_element_basic_type(this));\n-    __ sve_ext($dst_src1$$FloatRegister, $src2$$FloatRegister,\n-               ((uint)$index$$constant * scale));\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ uzp1($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_uzp1($dst$$FloatRegister, get_reg_variant(this),\n+                  $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n@@ -4021,9 +4010,6 @@\n-\n-\/\/ Vector mask widen to twice size\n-\/\/\n-\/\/ Unpack elements from the lowest or highest half of the source\n-\/\/ predicate and place in elements of twice their size within the\n-\/\/ destination predicate.\n-\n-instruct vmaskwiden_lo_sve(pReg dst, pReg src) %{\n-  predicate(UseSVE > 0 && n->as_VectorMaskWiden()->is_lo());\n+dnl\n+dnl VECTOR_MASK_WIDEN($1)\n+dnl VECTOR_MASK_WIDEN(part)\n+define(`VECTOR_MASK_WIDEN', `\n+instruct vmaskwiden_$1_sve(pReg dst, pReg src) %{\n+  predicate(UseSVE > 0 && ifelse(lo, $1, !, `')n->as_VectorMaskWiden()->is_hi());\n@@ -4031,1 +4017,1 @@\n-  format %{ \"vmaskwiden_lo_sve $dst, $src\" %}\n+  format %{ \"vmaskwiden_$1_sve $dst, $src\" %}\n@@ -4033,1 +4019,1 @@\n-    __ sve_punpklo($dst$$PRegister, $src$$PRegister);\n+    __ sve_punpk$1($dst$$PRegister, $src$$PRegister);\n@@ -4036,1 +4022,2 @@\n-%}\n+%}')dnl\n+dnl\n@@ -4038,9 +4025,7 @@\n-instruct vmaskwiden_hi_sve(pReg dst, pReg src) %{\n-  predicate(UseSVE > 0 && !n->as_VectorMaskWiden()->is_lo());\n-  match(Set dst (VectorMaskWiden src));\n-  format %{ \"vmaskwiden_hi_sve $dst, $src\" %}\n-  ins_encode %{\n-    __ sve_punpkhi($dst$$PRegister, $src$$PRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n+\/\/ Vector mask widen to twice size\n+\/\/\n+\/\/ Unpack elements from the lower or upper half of the source\n+\/\/ predicate and place in elements of twice their size within\n+\/\/ the destination predicate.\n+VECTOR_MASK_WIDEN(lo)\n+VECTOR_MASK_WIDEN(hi)\n@@ -4734,28 +4719,5 @@\n-\n-\/\/ ------------------------------ Vector Load Gather ---------------------------\n-\n-instruct gather_load_subword_le128(vReg dst, indirect mem, vReg idx) %{\n-  predicate(UseSVE > 0 &&\n-            type2aelembytes(Matcher::vector_element_basic_type(n)) <= 2 &&\n-            Matcher::vector_length_in_bytes(n->as_LoadVectorGather()->in(3)) <= 16);\n-  match(Set dst (LoadVectorGather mem idx));\n-  effect(TEMP_DEF dst);\n-  format %{ \"gather_load_subword_le128 $dst, $mem, $idx\\t# vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    if (bt == T_BYTE) {\n-      __ sve_ld1b_gather($dst$$FloatRegister, ptrue,\n-                         as_Register($mem$$base), $idx$$FloatRegister);\n-      __ xtn($dst$$FloatRegister, __ T4H, $dst$$FloatRegister, __ T4S);\n-      __ xtn($dst$$FloatRegister, __ T8B, $dst$$FloatRegister, __ T8H);\n-    } else {\n-      assert(bt == T_SHORT, \"unsupported type\");\n-      __ sve_ld1h_gather($dst$$FloatRegister, ptrue,\n-                         as_Register($mem$$base), $idx$$FloatRegister);\n-      __ xtn($dst$$FloatRegister, __ T4H, $dst$$FloatRegister, __ T4S);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct gather_load_subword_gt128(vReg dst, indirect mem, vReg idx, vReg vtmp) %{\n+dnl\n+dnl VECTOR_GATHER_LOAD_BHS($1,   $2,   $3  )\n+dnl VECTOR_GATHER_LOAD_BHS(type, size, inst)\n+define(`VECTOR_GATHER_LOAD_BHS', `\n+instruct gather_load$1(vReg dst, indirect mem, vReg idx) %{\n@@ -4763,2 +4725,1 @@\n-            type2aelembytes(Matcher::vector_element_basic_type(n)) <= 2 &&\n-            Matcher::vector_length_in_bytes(n->as_LoadVectorGather()->in(3)) > 16);\n+            type2aelembytes(n->as_LoadVectorGather()->mem_bt()) == $2);\n@@ -4766,2 +4727,1 @@\n-  effect(TEMP_DEF dst, TEMP vtmp);\n-  format %{ \"gather_load_subword_gt128 $dst, $mem, $idx\\t# vector (sve). KILL $vtmp\" %}\n+  format %{ \"gather_load$1 $dst, $mem, $idx\\t# vector (sve)\" %}\n@@ -4769,13 +4729,4 @@\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_dup($vtmp$$FloatRegister, __ S, 0);\n-    if (bt == T_BYTE) {\n-      __ sve_ld1b_gather($dst$$FloatRegister, ptrue,\n-                         as_Register($mem$$base), $idx$$FloatRegister);\n-      __ sve_uzp1($dst$$FloatRegister, __ H, $dst$$FloatRegister, $vtmp$$FloatRegister);\n-      __ sve_uzp1($dst$$FloatRegister, __ B, $dst$$FloatRegister, $vtmp$$FloatRegister);\n-    } else {\n-      assert(bt == T_SHORT, \"unsupported type\");\n-      __ sve_ld1h_gather($dst$$FloatRegister, ptrue,\n-                         as_Register($mem$$base), $idx$$FloatRegister);\n-      __ sve_uzp1($dst$$FloatRegister, __ H, $dst$$FloatRegister, $vtmp$$FloatRegister);\n-    }\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_$3_gather($dst$$FloatRegister, ptrue,\n+                       as_Register($mem$$base), $idx$$FloatRegister);\n@@ -4784,3 +4735,7 @@\n-%}\n-\n-instruct gather_loadS(vReg dst, indirect mem, vReg idx) %{\n+%}')dnl\n+dnl\n+dnl\n+dnl VECTOR_GATHER_LOAD_PREDICATE_BHS($1,   $2,   $3  )\n+dnl VECTOR_GATHER_LOAD_PREDICATE_BHS(type, size, inst)\n+define(`VECTOR_GATHER_LOAD_PREDICATE_BHS', `\n+instruct gather_load$1_masked(vReg dst, indirect mem, vReg idx, pRegGov pg) %{\n@@ -4788,3 +4743,3 @@\n-            type2aelembytes(Matcher::vector_element_basic_type(n)) == 4);\n-  match(Set dst (LoadVectorGather mem idx));\n-  format %{ \"gather_loadS $dst, $mem, $idx\\t# vector (sve)\" %}\n+            type2aelembytes(n->as_LoadVectorGatherMasked()->mem_bt()) == $2);\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx pg)));\n+  format %{ \"gather_load$1_masked $dst, $pg, $mem, $idx\" %}\n@@ -4792,3 +4747,1 @@\n-    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n-    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n-    __ sve_ld1w_gather($dst$$FloatRegister, ptrue,\n+    __ sve_$3_gather($dst$$FloatRegister, $pg$$PRegister,\n@@ -4798,1 +4751,7 @@\n-%}\n+%}')dnl\n+dnl\n+\n+\/\/ ------------------------------ Vector Load Gather ---------------------------\n+VECTOR_GATHER_LOAD_BHS(B, 1, ld1b)\n+VECTOR_GATHER_LOAD_BHS(H, 2, ld1h)\n+VECTOR_GATHER_LOAD_BHS(S, 4, ld1w)\n@@ -4802,1 +4761,1 @@\n-            type2aelembytes(Matcher::vector_element_basic_type(n)) == 8);\n+            type2aelembytes(n->as_LoadVectorGather()->mem_bt()) == 8);\n@@ -4816,60 +4775,4 @@\n-instruct gather_load_subword_masked_le128(vReg dst, indirect mem, vReg idx, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            type2aelembytes(Matcher::vector_element_basic_type(n)) <= 2 &&\n-            Matcher::vector_length_in_bytes(n->as_LoadVectorGatherMasked()->in(3)->in(1)) <= 16);\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx pg)));\n-  effect(TEMP_DEF dst);\n-  format %{ \"gather_load_subword_masked_le128 $dst, $pg, $mem, $idx\\t# vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    if (bt == T_BYTE) {\n-      __ sve_ld1b_gather($dst$$FloatRegister, $pg$$PRegister,\n-                         as_Register($mem$$base), $idx$$FloatRegister);\n-      __ xtn($dst$$FloatRegister, __ T4H, $dst$$FloatRegister, __ T4S);\n-      __ xtn($dst$$FloatRegister, __ T8B, $dst$$FloatRegister, __ T8H);\n-    } else {\n-      assert(bt == T_SHORT, \"unsupported type\");\n-      __ sve_ld1h_gather($dst$$FloatRegister, $pg$$PRegister,\n-                         as_Register($mem$$base), $idx$$FloatRegister);\n-      __ xtn($dst$$FloatRegister, __ T4H, $dst$$FloatRegister, __ T4S);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct gather_load_subword_masked_gt128(vReg dst, indirect mem, vReg idx, vReg vtmp, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            type2aelembytes(Matcher::vector_element_basic_type(n)) <= 2 &&\n-            Matcher::vector_length_in_bytes(n->as_LoadVectorGatherMasked()->in(3)->in(1)) > 16);\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx pg)));\n-  effect(TEMP_DEF dst, TEMP vtmp);\n-  format %{ \"gather_load_subword_masked_gt128 $dst, $pg, $mem, $idx\\t# vector (sve). KILL $vtmp\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_dup($vtmp$$FloatRegister, __ S, 0);\n-    if (bt == T_BYTE) {\n-      __ sve_ld1b_gather($dst$$FloatRegister, $pg$$PRegister,\n-                         as_Register($mem$$base), $idx$$FloatRegister);\n-      __ sve_uzp1($dst$$FloatRegister, __ H, $dst$$FloatRegister, $vtmp$$FloatRegister);\n-      __ sve_uzp1($dst$$FloatRegister, __ B, $dst$$FloatRegister, $vtmp$$FloatRegister);\n-    } else {\n-      assert(bt == T_SHORT, \"unsupported type\");\n-      __ sve_ld1h_gather($dst$$FloatRegister, $pg$$PRegister,\n-                         as_Register($mem$$base), $idx$$FloatRegister);\n-      __ sve_uzp1($dst$$FloatRegister, __ H, $dst$$FloatRegister, $vtmp$$FloatRegister);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct gather_loadS_masked(vReg dst, indirect mem, vReg idx, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            type2aelembytes(Matcher::vector_element_basic_type(n)) == 4);\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx pg)));\n-  format %{ \"gather_loadS_masked $dst, $pg, $mem, $idx\" %}\n-  ins_encode %{\n-    __ sve_ld1w_gather($dst$$FloatRegister, $pg$$PRegister,\n-                       as_Register($mem$$base), $idx$$FloatRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n+\/\/ ------------------------------ Vector Load Gather Masked ---------------------------\n+VECTOR_GATHER_LOAD_PREDICATE_BHS(B, 1, ld1b)\n+VECTOR_GATHER_LOAD_PREDICATE_BHS(H, 2, ld1h)\n+VECTOR_GATHER_LOAD_PREDICATE_BHS(S, 4, ld1w)\n@@ -4879,1 +4782,1 @@\n-            type2aelembytes(Matcher::vector_element_basic_type(n)) == 8);\n+            type2aelembytes(n->as_LoadVectorGatherMasked()->mem_bt()) == 8);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":64,"deletions":161,"binary":false,"changes":225,"status":"modified"},{"patch":"@@ -1040,6 +1040,0 @@\n-\/\/ Vector ideal reg size corresponding to the specified size in bytes\n-uint Matcher::vector_ideal_reg_size(int size) {\n-  assert(MaxVectorSize >= size, \"\");\n-  return size;\n-}\n-\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2331,6 +2331,0 @@\n-\/\/ Vector ideal reg size corresponding to the specified size in bytes\n-uint Matcher::vector_ideal_reg_size(int size) {\n-  assert(MaxVectorSize == size, \"\");\n-  return size;\n-}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2017,6 +2017,0 @@\n-\/\/ Vector ideal reg size corresponding to the specified len in bytes\n-uint Matcher::vector_ideal_reg_size(int len) {\n-  assert(MaxVectorSize >= len, \"\");\n-  return MaxVectorSize;\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1850,6 +1850,0 @@\n-\/\/ Vector ideal reg size corresponding to the specified size in bytes\n-uint Matcher::vector_ideal_reg_size(int size) {\n-  assert(MaxVectorSize == size, \"\");\n-  return size;\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2250,6 +2250,0 @@\n-\/\/ Vector ideal reg size corresponding to the specified len in bytes\n-uint Matcher::vector_ideal_reg_size(int size) {\n-  assert(MaxVectorSize >= size, \"\");\n-  return size;\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4363,1 +4363,1 @@\n-    \"VectorRearrange\", \"VectorLoadShuffle\", \"VectorLoadConst\", \"VectorSlice\",\n+    \"VectorRearrange\", \"VectorLoadShuffle\", \"VectorLoadConst\", \"VectorConcatenate\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -537,0 +537,1 @@\n+macro(VectorConcatenate)\n@@ -539,1 +540,0 @@\n-macro(VectorSlice)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -420,2 +420,2 @@\n-  Node* gen_gather_load_subword(Node* addr, Node* indexes, Node* indexes1, Node* indexes2, Node* indexes3, const TypeVect* vector_type);\n-  Node* gen_gather_load_masked_subword(Node* addr, Node* indexes, Node* indexes1, Node* indexes2, Node* indexes3, Node* mask, const TypeVect* vector_type);\n+  Node* gen_vector_gather_load(Node* addr, Node* indexes, Node* indexes1, Node* indexes2, Node* indexes3, Node* mask, const TypeVect* vt);\n+  Node* gen_mask_for_subword_gather(Node* mask, const TypeVect* vt, uint part);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2443,1 +2443,0 @@\n-    case Op_VectorSlice:\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -363,2 +363,0 @@\n-  \/\/ Vector ideal reg size\n-  static uint vector_ideal_reg_size(int len);\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1176,45 +1176,23 @@\n-Node* LibraryCallKit::gen_gather_load_subword(Node* addr, Node* indexes0, Node* indexes1, Node* indexes2,\n-                                              Node* indexes3, const TypeVect* vt) {\n-  BasicType elem_bt = vt->element_basic_type();\n-  uint elem_num = vt->length();\n-  const TypeVect* index_vt = indexes0->bottom_type()->isa_vect();\n-  const TypePtr* addr_type = gvn().type(addr)->isa_ptr();\n-  Node* addr_mem = memory(addr);\n-\n-  \/\/ The first gather-load.\n-  Node* vgather = gvn().transform(new LoadVectorGatherNode(control(), addr_mem, addr, addr_type, vt, indexes0));\n-\n-  uint index_elem_num = index_vt != nullptr ? index_vt->length() : 0;\n-  uint vector_reg_size = Matcher::vector_ideal_reg_size(vt->length_in_bytes());\n-  uint max_elem_num = vector_reg_size \/ type2aelembytes(elem_bt);\n-\n-  \/\/ The second gather-load.\n-  if (indexes1 != nullptr) {\n-    assert(index_vt != nullptr, \"indexes0 must be a vector\");\n-    assert(Type::equals(indexes1->bottom_type(), index_vt), \"invalid vector type for indexes1\");\n-    Node* vgather1 = gvn().transform(new LoadVectorGatherNode(control(), addr_mem, addr, addr_type, vt, indexes1));\n-    \/\/ Merge the second gather with the first gather result.\n-    Node* idx = gvn().makecon(TypeInt::make(max_elem_num - index_elem_num));\n-    Node* vslice = gvn().transform(new VectorSliceNode(vgather1, vgather1, idx));\n-    vgather = gvn().transform(new OrVNode(vgather, vslice, vt));\n-  }\n-\n-  \/\/ The third and fourth gather-loads on byte vector.\n-  if (indexes2 != nullptr) {\n-    assert(elem_bt == T_BYTE, \"only byte vector needs more than 2 times of gather-load\");\n-    assert(indexes3 != nullptr, \"indexes3 must be non-null\");\n-    assert(Type::equals(indexes2->bottom_type(), index_vt), \"invalid vector type for indexes2\");\n-    assert(Type::equals(indexes3->bottom_type(), index_vt), \"invalid vector type for indexes3\");\n-    Node* vgather2 = gvn().transform(new LoadVectorGatherNode(control(), addr_mem, addr, addr_type, vt, indexes2));\n-    \/\/ Merge the third gather with previous results.\n-    Node* idx = gvn().makecon(TypeInt::make(max_elem_num - 2 * index_elem_num));\n-    Node* vslice = gvn().transform(new VectorSliceNode(vgather2, vgather2, idx));\n-    vgather = gvn().transform(new OrVNode(vgather, vslice, vt));\n-\n-    Node* vgather3 = gvn().transform(new LoadVectorGatherNode(control(), addr_mem, addr, addr_type, vt, indexes3));\n-    \/\/ Merge the fourth gather with previous results.\n-    idx = gvn().makecon(TypeInt::make(max_elem_num - 3 * index_elem_num));\n-    vslice = gvn().transform(new VectorSliceNode(vgather3, vgather3, idx));\n-    vgather = gvn().transform(new OrVNode(vgather, vslice, vt));\n-  }\n-  return vgather;\n+\/\/ Generate a vector mask by casting the input mask from \"byte|short\" type to \"int\" type for vector\n+\/\/ gather load with subword types. The elements to be extended are decided by the \"part\" parameter.\n+Node* LibraryCallKit::gen_mask_for_subword_gather(Node* in, const TypeVect* vt, uint part) {\n+  assert(vt->element_basic_type() == T_INT, \"must be\");\n+  const TypeVect* in_vt = in->bottom_type()->is_vect();\n+  BasicType in_bt = in_vt->element_basic_type();\n+\n+  if (in_bt == T_BYTE) {\n+    assert(part < 4, \"must be\");\n+    const TypeVect* temp_vt = TypeVect::makemask(T_SHORT, vt->length() * 2);\n+    \/\/ If part == 0, the elements of the lowest 1\/4 part are extended.\n+    \/\/ If part == 1, the elements of the 2\/4 part are extended.\n+    \/\/ If part == 2, the elements of the 3\/4 part are extended.\n+    \/\/ If part == 3, the elements of the 4\/4 part are extended.\n+    Node* mask = gvn().transform(new VectorMaskWidenNode(in, temp_vt, \/* is_hi *\/ (part & 2) != 0));\n+    return gvn().transform(new VectorMaskWidenNode(mask, vt, \/* is_hi *\/ (part & 1) != 0));\n+  }\n+\n+  assert(in_bt == T_SHORT, \"must be a subword type\");\n+  assert(part == 0 || part == 1, \"must be\");\n+  \/\/ If part == 0, the lower half of the input mask is extended.\n+  \/\/ If part == 1, the upper half of the input mask is extended.\n+  return gvn().transform(new VectorMaskWidenNode(in, vt, \/* is_hi *\/ part == 1));\n@@ -1223,3 +1201,2 @@\n-Node* LibraryCallKit::gen_gather_load_masked_subword(Node* addr, Node* indexes0, Node* indexes1,\n-                                                     Node* indexes2, Node* indexes3, Node* mask,\n-                                                     const TypeVect* vt) {\n+Node* LibraryCallKit::gen_vector_gather_load(Node* addr, Node* indexes0, Node* indexes1, Node* indexes2,\n+                                             Node* indexes3, Node* mask, const TypeVect* vt) {\n@@ -1231,4 +1208,11 @@\n-  \/\/ Case for architectures (e.g. X86_64) that the subword vector gather does not accept a vector\n-  \/\/ index as input. The given mask needs to be kept as it is.\n-  if (index_vt == nullptr) {\n-    return gvn().transform(new LoadVectorGatherMaskedNode(control(), addr_mem, addr, addr_type, vt, indexes0, mask));\n+  \/\/ A single gather-load IR is generated with mask and the vector type unchanged. This happens\n+  \/\/ for the following cases:\n+  \/\/ 1. It's not loading a subword type vector (e.g. int\/long\/float\/double).\n+  \/\/ 2. It's loading a subword type vector on platforms (e.g. X86_64) that the gather IR does\n+  \/\/    not accept a vector index.\n+  if (!is_subword_type(elem_bt) || index_vt == nullptr) {\n+    if (mask != nullptr) {\n+      return gvn().transform(new LoadVectorGatherMaskedNode(control(), addr_mem, addr, addr_type,\n+                                                            vt, indexes0, mask));\n+    }\n+    return gvn().transform(new LoadVectorGatherNode(control(), addr_mem, addr, addr_type, vt, indexes0));\n@@ -1237,3 +1221,2 @@\n-  \/\/ Otherwise, the given mask may need to be split and used by multiple masked vector gather-loads\n-  \/\/ respectively. Additionally, each part of the mask needs to be converted to int type because the\n-  \/\/ vector gather-load instruction works on the same type of the vector indice.\n+  \/\/ Otherwise, because the vector gather-load oepration works on the same type of the vector\n+  \/\/ indice, the vector type of each gather-load IR will be defined as the indice type.\n@@ -1241,4 +1224,8 @@\n-  \/\/ For example, if it is gather loading a short vector and it needs two times of gather-load, the\n-  \/\/ lower half of the given mask is used by the first gather-load, and the higher half of the given\n-  \/\/ mask is used by the second gather-load. It will be more complicated for byte vector, that the\n-  \/\/ mask maybe split into 4 parts. Here is an example:\n+  \/\/ For masked operation, the given mask may need to be split and used by multiple masked vector\n+  \/\/ gather-loads respectively. Additionally, each part of the mask needs to be converted to int\n+  \/\/ type.\n+  \/\/\n+  \/\/ For example, if it is gather loading a short vector and it needs two times of gather-load,\n+  \/\/ the lower half of the given mask is used by the first gather-load, and the upper half of the\n+  \/\/ given mask is used by the second gather-load. It will be more complicated for byte vector,\n+  \/\/ that the mask maybe split into 4 parts. Here is an example for byte vector:\n@@ -1252,5 +1239,5 @@\n-  \/\/\n-  \/\/ Define the mask type of gather mask as the same as the vector index.\n-  uint index_elem_num = index_vt->length();\n-  const TypeVect* mask_vt = TypeVect::makemask(T_INT, index_elem_num);\n-  Node* gather_mask_short = nullptr;\n+\n+  \/\/ Define the type of the gather mask as the same as the vector indice.\n+  const TypeVect* mask_vt = mask != nullptr ? TypeVect::makemask(T_INT, index_vt->length()) : nullptr;\n+\n+  \/\/ The first vector gather-load.\n@@ -1258,0 +1245,9 @@\n+  Node* vgather = nullptr;\n+  if (mask != nullptr) {\n+    gather_mask = gen_mask_for_subword_gather(mask, mask_vt, 0);\n+    vgather = gvn().transform(new LoadVectorGatherMaskedNode(control(), addr_mem, addr, addr_type,\n+                                                             index_vt, indexes0, gather_mask, elem_bt));\n+  } else {\n+    vgather = gvn().transform(new LoadVectorGatherNode(control(), addr_mem, addr, addr_type,\n+                                                       index_vt, indexes0, elem_bt));\n+  }\n@@ -1259,7 +1255,13 @@\n-  \/\/ The first masked vector gather-load with vector index.\n-  \/\/\n-  \/\/ Generate a new vector mask by widening the lower half of the given mask to int type. For byte\n-  \/\/ vector, it maybe the lowest 1\/4 part of the given mask.\n-  if (elem_bt == T_BYTE) {\n-    const TypeVect* mask_vt_short = TypeVect::makemask(T_SHORT, MaxVectorSize \/ type2aelembytes(T_SHORT));\n-    gather_mask_short = gvn().transform(new VectorMaskWidenNode(mask, mask_vt_short, \/* is_lo *\/ true));\n+  \/\/ If one gather-load is enough, cast the gather result to the target subword vector type.\n+  if (indexes1 == nullptr) {\n+    assert(indexes2 == nullptr && indexes3 == nullptr, \"must be\");\n+    return gvn().transform(new VectorCastI2XNode(vgather, vt));\n+  }\n+\n+  \/\/ It needs more than 2 times of gather-load. Here begins the second vector gather-load.\n+  assert(Type::equals(indexes1->bottom_type(), index_vt), \"index vector type mismatch\");\n+  Node* vgather1 = nullptr;\n+  if (mask != nullptr) {\n+    gather_mask = gen_mask_for_subword_gather(mask, mask_vt, 1);\n+    vgather1 = gvn().transform(new LoadVectorGatherMaskedNode(control(), addr_mem, addr, addr_type,\n+                                                              index_vt, indexes1, gather_mask, elem_bt));\n@@ -1267,50 +1269,41 @@\n-    gather_mask_short = mask;\n-  }\n-  gather_mask = gvn().transform(new VectorMaskWidenNode(gather_mask_short, mask_vt, \/* is_lo *\/ true));\n-  Node* vgather = gvn().transform(new LoadVectorGatherMaskedNode(control(), addr_mem, addr, addr_type, vt, indexes0, gather_mask));\n-\n-  \/\/ The second masked vector gather with vector index.\n-  uint vector_reg_size = Matcher::vector_ideal_reg_size(vt->length_in_bytes());\n-  uint max_elem_num = vector_reg_size \/ type2aelembytes(elem_bt);\n-  if (indexes1 != nullptr) {\n-    assert(index_vt != nullptr, \"indexes0 must be a vector\");\n-    assert(Type::equals(indexes1->bottom_type(), index_vt), \"invalid vector type for indexes1\");\n-\n-    \/\/ Generate a new vector mask by widening the higher half of the given mask to int type. For byte\n-    \/\/ vector, it maybe the 2\/4 part of the mask starting from the lowest bit.\n-    gather_mask = gvn().transform(new VectorMaskWidenNode(gather_mask_short, mask_vt, \/* is_lo *\/ false));\n-    Node* vgather1 = gvn().transform(new LoadVectorGatherMaskedNode(control(), addr_mem, addr, addr_type, vt, indexes1, gather_mask));\n-    \/\/ Merge the second gather with the first gather result.\n-    Node* idx = gvn().makecon(TypeInt::make(max_elem_num - index_elem_num));\n-    Node* slice = gvn().transform(new VectorSliceNode(vgather1, vgather1, idx));\n-    vgather = gvn().transform(new OrVNode(vgather, slice, vt));\n-  }\n-\n-  \/\/ The third and fourth masked vector gathers for byte vector.\n-  if (indexes2 != nullptr) {\n-    assert(elem_bt == T_BYTE, \"only byte vector needs more than 2 times of gather load\");\n-    assert(indexes3 != nullptr, \"indexes3 must be non-null\");\n-    assert(Type::equals(indexes2->bottom_type(), index_vt), \"invalid vector type for indexes2\");\n-    assert(Type::equals(indexes3->bottom_type(), index_vt), \"invalid vector type for indexes3\");\n-\n-    \/\/ The third masked vector gather with vector index. The new vector mask is widened from the 3\/4\n-    \/\/ part of the input mask.\n-    const TypeVect* mask_vt_short = TypeVect::makemask(T_SHORT, MaxVectorSize \/ type2aelembytes(T_SHORT));\n-    gather_mask_short = gvn().transform(new VectorMaskWidenNode(mask, mask_vt_short, \/* is_lo *\/ false));\n-    gather_mask = gvn().transform(new VectorMaskWidenNode(gather_mask_short, mask_vt, \/* is_lo *\/ true));\n-    Node* vgather2 = gvn().transform(new LoadVectorGatherMaskedNode(control(), addr_mem, addr, addr_type, vt, indexes2, gather_mask));\n-    \/\/ Merge the third gather with previous results.\n-    Node* idx = gvn().makecon(TypeInt::make(max_elem_num - 2 * index_elem_num));\n-    Node* slice = gvn().transform(new VectorSliceNode(vgather2, vgather2, idx));\n-    vgather = gvn().transform(new OrVNode(vgather, slice, vt));\n-\n-    \/\/ The fourth masked vector gather with vector index. The new vector mask is widened from the 4\/4\n-    \/\/ part of the input mask.\n-    gather_mask = gvn().transform(new VectorMaskWidenNode(gather_mask_short, mask_vt, \/* is_lo *\/ false));\n-    Node* vgather3 = gvn().transform(new LoadVectorGatherMaskedNode(control(), addr_mem, addr, addr_type, vt, indexes3, gather_mask));\n-    \/\/ Merge the fourth gather with previous results.\n-    idx = gvn().makecon(TypeInt::make(max_elem_num - 3 * index_elem_num));\n-    slice = gvn().transform(new VectorSliceNode(vgather3, vgather3, idx));\n-    vgather = gvn().transform(new OrVNode(vgather, slice, vt));\n-  }\n-  return vgather;\n+    vgather1 = gvn().transform(new LoadVectorGatherNode(control(), addr_mem, addr, addr_type,\n+                                                        index_vt, indexes1, elem_bt));\n+  }\n+  \/\/ Merge the second gather result with the first one.\n+  const TypeVect* merge_vt = TypeVect::make(T_SHORT, index_vt->length() * 2);\n+  Node* merge1 = gvn().transform(new VectorConcatenateNode(vgather, vgather1, merge_vt));\n+\n+  \/\/ If two gather-loads are enough, return the merged result.\n+  if (indexes2 == nullptr) {\n+    assert(indexes3 == nullptr, \"must be\");\n+    if (elem_bt == T_BYTE) {\n+      merge1 = gvn().transform(new VectorCastS2XNode(merge1, vt));\n+    }\n+    return merge1;\n+  }\n+\n+  \/\/ It needs 4 times of gather-load. This should just happen for byte vector.\n+  \/\/ Here begins the third and fourth vector gather-load.\n+  assert(elem_bt == T_BYTE, \"must be\");\n+  assert(indexes3 != nullptr, \"must be\");\n+  assert(Type::equals(indexes2->bottom_type(), index_vt), \"index vector type mismatch\");\n+  assert(Type::equals(indexes3->bottom_type(), index_vt), \"index vector type mismatch\");\n+  Node* vgather2 = nullptr;\n+  Node* vgather3 = nullptr;\n+  if (mask != nullptr) {\n+    gather_mask = gen_mask_for_subword_gather(mask, mask_vt, 2);\n+    vgather2 = gvn().transform(new LoadVectorGatherMaskedNode(control(), addr_mem, addr, addr_type,\n+                                                              index_vt, indexes2, gather_mask, elem_bt));\n+    gather_mask = gen_mask_for_subword_gather(mask, mask_vt, 3);\n+    vgather3 = gvn().transform(new LoadVectorGatherMaskedNode(control(), addr_mem, addr, addr_type,\n+                                                              index_vt, indexes3, gather_mask, elem_bt));\n+  } else {\n+    vgather2 = gvn().transform(new LoadVectorGatherNode(control(), addr_mem, addr, addr_type,\n+                                                        index_vt, indexes2, elem_bt));\n+    vgather3 = gvn().transform(new LoadVectorGatherNode(control(), addr_mem, addr, addr_type,\n+                                                        index_vt, indexes3, elem_bt));\n+  }\n+  \/\/ Merge the third and fourth gather results.\n+  Node* merge2 = gvn().transform(new VectorConcatenateNode(vgather2, vgather3, merge_vt));\n+  \/\/ Merge the two merged results.\n+  return gvn().transform(new VectorConcatenateNode(merge1, merge2, vt));\n@@ -1432,2 +1425,1 @@\n-      if (!arch_supports_vector(Op_VectorSlice, num_elem, elem_bt, VecMaskNotUsed) ||\n-          !arch_supports_vector(Op_OrV, num_elem, elem_bt, VecMaskNotUsed)) {\n+      if (!arch_supports_vector(Op_VectorConcatenate, idx_num_elem, T_INT, VecMaskNotUsed)) {\n@@ -1558,14 +1550,1 @@\n-    Node* vload = nullptr;\n-    if (mask != nullptr) {\n-      if (is_subword_type(elem_bt)) {\n-        vload = gen_gather_load_masked_subword(addr, indexes, indexes1, indexes2, indexes3, mask, vector_type);\n-      } else {\n-        vload = gvn().transform(new LoadVectorGatherMaskedNode(control(), memory(addr), addr, addr_type, vector_type, indexes, mask));\n-      }\n-    } else {\n-      if (is_subword_type(elem_bt)) {\n-        vload = gen_gather_load_subword(addr, indexes, indexes1, indexes2, indexes3, vector_type);\n-      } else {\n-        vload = gvn().transform(new LoadVectorGatherNode(control(), memory(addr), addr, addr_type, vector_type, indexes));\n-      }\n-    }\n+    Node* vload = gen_vector_gather_load(addr, indexes, indexes1, indexes2, indexes3, mask, vector_type);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":116,"deletions":137,"binary":false,"changes":253,"status":"modified"},{"patch":"@@ -1044,12 +1044,0 @@\n-  BasicType mask_bt = bt;\n-  uint mask_vlen = vlen;\n-  if (vopc == Op_LoadVectorGather && is_subword_type(bt)) {\n-    \/\/ It uses the index vector's type as the mask type for subword gather load.\n-    const TypeVect* index_vt = node->in(MemNode::ValueIn)->bottom_type()->isa_vect();\n-    if (index_vt == nullptr) {\n-      return nullptr;\n-    }\n-    mask_bt = index_vt->element_basic_type();\n-    mask_vlen = index_vt->length();\n-  }\n-\n@@ -1059,1 +1047,1 @@\n-      !Matcher::match_rule_supported_vector(Op_VectorMaskGen, mask_vlen, mask_bt)) {\n+      !Matcher::match_rule_supported_vector(Op_VectorMaskGen, vlen, bt)) {\n@@ -1066,3 +1054,3 @@\n-  if (mask_vlen * type2aelembytes(mask_bt) < (uint)MaxVectorSize) {\n-    Node* length = gvn->transform(new ConvI2LNode(gvn->makecon(TypeInt::make(mask_vlen))));\n-    mask = gvn->transform(VectorMaskGenNode::make(length, mask_bt, mask_vlen));\n+  if (vt->length_in_bytes() < (uint)MaxVectorSize) {\n+    Node* length = gvn->transform(new ConvI2LNode(gvn->makecon(TypeInt::make(vlen))));\n+    mask = gvn->transform(VectorMaskGenNode::make(length, bt, vlen));\n@@ -1083,1 +1071,2 @@\n-                                          node->in(3), mask);\n+                                          node->in(3), mask,\n+                                          node->as_LoadVectorGather()->mem_bt());\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":6,"deletions":17,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1119,0 +1119,5 @@\n+ private:\n+  \/\/ The basic type of memory, which might be different with the vector element type\n+  \/\/ when it is a subword type loading.\n+  BasicType _mem_bt;\n+\n@@ -1120,1 +1125,1 @@\n-  LoadVectorGatherNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices)\n+  LoadVectorGatherNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices, BasicType mem_bt = T_ILLEGAL)\n@@ -1127,0 +1132,1 @@\n+    _mem_bt = mem_bt != T_ILLEGAL ? mem_bt : vt->element_basic_type();\n@@ -1137,0 +1143,2 @@\n+  virtual uint size_of() const { return sizeof(*this); }\n+  BasicType mem_bt() const { return _mem_bt; }\n@@ -1249,0 +1257,5 @@\n+ private:\n+  \/\/ The basic type of memory, which might be different with the vector element type when it\n+  \/\/ is a subword type loading.\n+  BasicType _mem_bt;\n+\n@@ -1250,1 +1263,2 @@\n-  LoadVectorGatherMaskedNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices, Node* mask)\n+  LoadVectorGatherMaskedNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt,\n+                             Node* indices, Node* mask, BasicType mem_bt = T_ILLEGAL)\n@@ -1257,0 +1271,1 @@\n+    _mem_bt = mem_bt != T_ILLEGAL ? mem_bt : vt->element_basic_type();\n@@ -1267,0 +1282,2 @@\n+  virtual uint size_of() const { return sizeof(*this); }\n+  BasicType mem_bt() const { return _mem_bt; }\n@@ -1742,1 +1759,3 @@\n-\/\/ Generate a vector by slicing the two source vectors based on an index.\n+\/\/ Concatenate elements from two source vectors by narrowing the elements to half size. Put\n+\/\/ the narrowed elements from the first source vector to the lower half of the destination\n+\/\/ vector, and the narrowed elements from the second source vector to the upper half.\n@@ -1744,3 +1763,2 @@\n-\/\/ Copy the indexed byte up to the last byte of the first source vector\n-\/\/ to the bottom of the result vector, then fill the remainder of the\n-\/\/ result starting from the first byte of the second source vector.\n+\/\/ e.g. vec1 = [0d 0c 0b 0a], vec2 = [0h 0g 0f 0e]\n+\/\/      dst = [h g f e d c b a]\n@@ -1748,8 +1766,6 @@\n-\/\/ E.g. src1 = [hgfedcba] src2 = [ponmlkji] index = 3\n-\/\/      dst = [kjihgfed]\n-class VectorSliceNode : public VectorNode {\n- public:\n-  VectorSliceNode(Node* vec1, Node* vec2, Node* index)\n-    : VectorNode(vec1, vec2, index, vec1->bottom_type()->is_vect()) {\n-    assert(index->bottom_type()->isa_int(), \"index must be an integral value\");\n-    assert(index->is_Con(), \"index must be a constant\");\n+class VectorConcatenateNode : public VectorNode {\n+ public:\n+  VectorConcatenateNode(Node* vec1, Node* vec2, const TypeVect* vt)\n+    : VectorNode(vec1, vec2, vt) {\n+    assert(type2aelembytes(vec1->bottom_type()->is_vect()->element_basic_type()) ==\n+           type2aelembytes(vt->element_basic_type()) * 2, \"must be half size\");\n@@ -1822,2 +1838,4 @@\n-  \/\/ \"_is_lo\" is used to denote whether the lower half or\n-  \/\/ the upper half of the elements are widened.\n+  \/\/ \"_is_hi\" is used to denote whether the upper or lower half of the elements\n+  \/\/ are widened. Widen the upper half part if it is true, otherwise widen the\n+  \/\/ lower half part.\n+  \/\/\n@@ -1825,3 +1843,3 @@\n-  \/\/      _is_lo = true, dst = [0001 0001]\n-  \/\/      _is_lo = false, dst = [0101 0101]\n-  bool _is_lo;\n+  \/\/      _is_hi = false, dst = [0001 0001]\n+  \/\/      _is_hi = true, dst = [0101 0101]\n+  bool _is_hi;\n@@ -1830,1 +1848,2 @@\n-  VectorMaskWidenNode(Node* in, const TypeVect* vt, bool is_lo) : VectorNode(in, vt), _is_lo(is_lo) {\n+  VectorMaskWidenNode(Node* in, const TypeVect* vt, bool is_hi)\n+    : VectorNode(in, vt), _is_hi(is_hi) {\n@@ -1833,1 +1852,2 @@\n-    assert(type2aelembytes(in_vt->element_basic_type()) == type2aelembytes(vt->element_basic_type()) \/ 2, \"must be half size\");\n+    assert(type2aelembytes(in_vt->element_basic_type()) ==\n+           type2aelembytes(vt->element_basic_type()) \/ 2, \"must be half size\");\n@@ -1836,1 +1856,1 @@\n-  bool is_lo() const { return _is_lo; }\n+  bool is_hi() const { return _is_hi; }\n@@ -1839,0 +1859,4 @@\n+  virtual uint hash() const { return Node::hash() + _is_hi; }\n+  virtual bool cmp(const Node& n) const {\n+    return Node::cmp(n) && _is_hi == ((VectorMaskWidenNode&)n).is_hi();\n+  }\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":46,"deletions":22,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+ * @run driver compiler.vectorapi.VectorGatherSubwordTest MaxVectorSize_16\n+ * @run driver compiler.vectorapi.VectorGatherSubwordTest MaxVectorSize_32\n+ * @run driver compiler.vectorapi.VectorGatherSubwordTest MaxVectorSize_64\n@@ -42,2 +45,8 @@\n-    private static final VectorSpecies<Byte> B_SPECIES = ByteVector.SPECIES_PREFERRED;\n-    private static final VectorSpecies<Short> S_SPECIES = ShortVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Byte> BSPEC_64 = ByteVector.SPECIES_64;\n+    private static final VectorSpecies<Byte> BSPEC_128 = ByteVector.SPECIES_128;\n+    private static final VectorSpecies<Byte> BSPEC_256 = ByteVector.SPECIES_256;\n+    private static final VectorSpecies<Byte> BSPEC_512 = ByteVector.SPECIES_512;\n+    private static final VectorSpecies<Short> SSPEC_64 = ShortVector.SPECIES_64;\n+    private static final VectorSpecies<Short> SSPEC_128 = ShortVector.SPECIES_128;\n+    private static final VectorSpecies<Short> SSPEC_256 = ShortVector.SPECIES_256;\n+    private static final VectorSpecies<Short> SSPEC_512 = ShortVector.SPECIES_512;\n@@ -61,1 +70,1 @@\n-        indexes = new int[2][];\n+        indexes = new int[5][];\n@@ -71,2 +80,2 @@\n-        int[] nums = {B_SPECIES.length(), S_SPECIES.length()};\n-        for (int i = 0; i < 2; i++) {\n+        int[] nums = {4, 8, 16, 32, 64};\n+        for (int i = 0; i < 5; i++) {\n@@ -78,0 +87,2 @@\n+    \/\/ Tests for gather load of byte vector with different vector species.\n+\n@@ -79,5 +90,15 @@\n-    @IR(counts = { IRNode.LOAD_VECTOR_GATHER, \" >0 \"}, applyIfCPUFeature = {\"sve\", \"true\"})\n-    public void testLoadGatherByte() {\n-        for (int i = 0; i < LENGTH; i += B_SPECIES.length()) {\n-            ByteVector.fromArray(B_SPECIES, ba, i, indexes[0], 0)\n-                      .intoArray(br, i);\n+    @IR(counts = {IRNode.LOAD_VECTOR_GATHER, \"2\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \"16\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_GATHER, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \"32\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_GATHER_MASKED, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \"64\"})\n+    public void testLoadGatherByte64() {\n+        ByteVector.fromArray(BSPEC_64, ba, 0, indexes[1], 0)\n+                  .intoArray(br, 0);\n+    }\n+\n+    @Check(test = \"testLoadGatherByte64\")\n+    public void verifyLoadGatherByte64() {\n+        for (int i = 0; i < BSPEC_64.length(); i++) {\n+            Asserts.assertEquals(ba[indexes[1][i]], br[i]);\n@@ -87,6 +108,16 @@\n-    @Check(test = \"testLoadGatherByte\")\n-    public void verifyLoadGatherByte() {\n-        for (int i = 0; i < LENGTH; i += B_SPECIES.length()) {\n-            for (int j = 0; j < B_SPECIES.length(); j++) {\n-                Asserts.assertEquals(ba[i + indexes[0][j]], br[i + j]);\n-            }\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_GATHER, \"4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \"16\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_GATHER, \"2\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \"32\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_GATHER, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \"64\"})\n+    public void testLoadGatherByte128() {\n+        ByteVector.fromArray(BSPEC_128, ba, 0, indexes[2], 0)\n+                  .intoArray(br, 0);\n+    }\n+\n+    @Check(test = \"testLoadGatherByte128\")\n+    public void verifyLoadGatherByte128() {\n+        for (int i = 0; i < BSPEC_128.length(); i++) {\n+            Asserts.assertEquals(ba[indexes[2][i]], br[i]);\n@@ -97,5 +128,13 @@\n-    @IR(counts = { IRNode.LOAD_VECTOR_GATHER, \" >0 \"}, applyIfCPUFeature = {\"sve\", \"true\"})\n-    public void testLoadGatherShort() {\n-        for (int i = 0; i < LENGTH; i += S_SPECIES.length()) {\n-            ShortVector.fromArray(S_SPECIES, sa, i, indexes[1], 0)\n-                       .intoArray(sr, i);\n+    @IR(counts = {IRNode.LOAD_VECTOR_GATHER, \"4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \"32\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_GATHER, \"2\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \"64\"})\n+    public void testLoadGatherByte256() {\n+        ByteVector.fromArray(BSPEC_256, ba, 0, indexes[3], 0)\n+                  .intoArray(br, 0);\n+    }\n+\n+    @Check(test = \"testLoadGatherByte256\")\n+    public void verifyLoadGatherByte256() {\n+        for (int i = 0; i < BSPEC_256.length(); i++) {\n+            Asserts.assertEquals(ba[indexes[3][i]], br[i]);\n@@ -105,6 +144,12 @@\n-    @Check(test = \"testLoadGatherShort\")\n-    public void verifyLoadGatherShort() {\n-        for (int i = 0; i < LENGTH; i += S_SPECIES.length()) {\n-            for (int j = 0; j < S_SPECIES.length(); j++) {\n-                Asserts.assertEquals(sa[i + indexes[1][j]], sr[i + j]);\n-            }\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_GATHER, \"4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \"64\"})\n+    public void testLoadGatherByte512() {\n+        ByteVector.fromArray(BSPEC_512, ba, 0, indexes[4], 0)\n+                  .intoArray(br, 0);\n+    }\n+\n+    @Check(test = \"testLoadGatherByte512\")\n+    public void verifyLoadGatherByte512() {\n+        for (int i = 0; i < BSPEC_512.length(); i++) {\n+            Asserts.assertEquals(ba[indexes[4][i]], br[i]);\n@@ -114,0 +159,2 @@\n+    \/\/ Tests for gather load of short vector with different vector species.\n+\n@@ -115,6 +162,13 @@\n-    @IR(counts = { IRNode.LOAD_VECTOR_GATHER_MASKED, \" >0 \"}, applyIfCPUFeature = {\"sve\", \"true\"})\n-    public void testLoadGatherMaskedByte() {\n-        VectorMask<Byte> mask = VectorMask.fromArray(B_SPECIES, m, 0);\n-        for (int i = 0; i < LENGTH; i += B_SPECIES.length()) {\n-            ByteVector.fromArray(B_SPECIES, ba, i, indexes[0], 0, mask)\n-                      .intoArray(br, i);\n+    @IR(counts = {IRNode.LOAD_VECTOR_GATHER, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \"16\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_GATHER_MASKED, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \">= 32\"})\n+    public void testLoadGatherShort64() {\n+        ShortVector.fromArray(SSPEC_64, sa, 0, indexes[0], 0)\n+                   .intoArray(sr, 0);\n+    }\n+\n+    @Check(test = \"testLoadGatherShort64\")\n+    public void verifyLoadGatherShort64() {\n+        for (int i = 0; i < SSPEC_64.length(); i++) {\n+            Asserts.assertEquals(sa[indexes[0][i]], sr[i]);\n@@ -124,6 +178,16 @@\n-    @Check(test = \"testLoadGatherMaskedByte\")\n-    public void verifyLoadGatherMaskedByte() {\n-        for (int i = 0; i < LENGTH; i += B_SPECIES.length()) {\n-            for (int j = 0; j < B_SPECIES.length(); j++) {\n-                Asserts.assertEquals(m[j] ? ba[i + indexes[0][j]] : 0, br[i + j]);\n-            }\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_GATHER, \"2\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \"16\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_GATHER, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \"32\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_GATHER_MASKED, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \"64\"})\n+    public void testLoadGatherShort128() {\n+        ShortVector.fromArray(SSPEC_128, sa, 0, indexes[1], 0)\n+                   .intoArray(sr, 0);\n+    }\n+\n+    @Check(test = \"testLoadGatherShort128\")\n+    public void verifyLoadGatherShort128() {\n+        for (int i = 0; i < SSPEC_128.length(); i++) {\n+            Asserts.assertEquals(sa[indexes[1][i]], sr[i]);\n@@ -134,6 +198,13 @@\n-    @IR(counts = { IRNode.LOAD_VECTOR_GATHER_MASKED, \" >0 \"}, applyIfCPUFeature = {\"sve\", \"true\"})\n-    public void testLoadGatherMaskedShort() {\n-        VectorMask<Short> mask = VectorMask.fromArray(S_SPECIES, m, 0);\n-        for (int i = 0; i < LENGTH; i += S_SPECIES.length()) {\n-            ShortVector.fromArray(S_SPECIES, sa, i, indexes[1], 0, mask)\n-                       .intoArray(sr, i);\n+    @IR(counts = {IRNode.LOAD_VECTOR_GATHER, \"2\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \"32\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_GATHER, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \"64\"})\n+    public void testLoadGatherShort256() {\n+        ShortVector.fromArray(SSPEC_256, sa, 0, indexes[2], 0)\n+                   .intoArray(sr, 0);\n+    }\n+\n+    @Check(test = \"testLoadGatherShort256\")\n+    public void verifyLoadGatherShort256() {\n+        for (int i = 0; i < SSPEC_256.length(); i++) {\n+            Asserts.assertEquals(sa[indexes[2][i]], sr[i]);\n@@ -143,6 +214,156 @@\n-    @Check(test = \"testLoadGatherMaskedShort\")\n-    public void verifyLoadGatherMaskedShort() {\n-        for (int i = 0; i < LENGTH; i += S_SPECIES.length()) {\n-            for (int j = 0; j < S_SPECIES.length(); j++) {\n-                Asserts.assertEquals(m[j] ? sa[i + indexes[1][j]] : 0, sr[i + j]);\n-            }\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_GATHER, \"2\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \"64\"})\n+    public void testLoadGatherShort512() {\n+        ShortVector.fromArray(SSPEC_512, sa, 0, indexes[3], 0)\n+                   .intoArray(sr, 0);\n+    }\n+\n+    @Check(test = \"testLoadGatherShort512\")\n+    public void verifyLoadGatherShort512() {\n+        for (int i = 0; i < SSPEC_512.length(); i++) {\n+            Asserts.assertEquals(sa[indexes[3][i]], sr[i]);\n+        }\n+    }\n+\n+    \/\/ Tests for masked gather load of byte vector with different vector species.\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_GATHER_MASKED, \"2\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \"16\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_GATHER_MASKED, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \">= 32\"})\n+    public void testLoadGatherMaskedByte64() {\n+        VectorMask<Byte> mask = VectorMask.fromArray(BSPEC_64, m, 0);\n+        ByteVector.fromArray(BSPEC_64, ba, 0, indexes[1], 0, mask)\n+                  .intoArray(br, 0);\n+    }\n+\n+    @Check(test = \"testLoadGatherMaskedByte64\")\n+    public void verifyLoadGatherMaskedByte64() {\n+        for (int i = 0; i < BSPEC_64.length(); i++) {\n+            Asserts.assertEquals(m[i] ? ba[indexes[1][i]] : 0, br[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_GATHER_MASKED, \"4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \"16\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_GATHER_MASKED, \"2\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \"32\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_GATHER_MASKED, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \"64\"})\n+    public void testLoadGatherMaskedByte128() {\n+        VectorMask<Byte> mask = VectorMask.fromArray(BSPEC_128, m, 0);\n+        ByteVector.fromArray(BSPEC_128, ba, 0, indexes[2], 0, mask)\n+                  .intoArray(br, 0);\n+    }\n+\n+    @Check(test = \"testLoadGatherMaskedByte128\")\n+    public void verifyLoadGatherMaskedByte128() {\n+        for (int i = 0; i < BSPEC_128.length(); i++) {\n+            Asserts.assertEquals(m[i] ? ba[indexes[2][i]] : 0, br[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_GATHER_MASKED, \"4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \"32\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_GATHER_MASKED, \"2\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \"64\"})\n+    public void testLoadGatherMaskedByte256() {\n+        VectorMask<Byte> mask = VectorMask.fromArray(BSPEC_256, m, 0);\n+        ByteVector.fromArray(BSPEC_256, ba, 0, indexes[3], 0, mask)\n+                  .intoArray(br, 0);\n+    }\n+\n+    @Check(test = \"testLoadGatherMaskedByte256\")\n+    public void verifyLoadGatherMaskedByte256() {\n+        for (int i = 0; i < BSPEC_256.length(); i++) {\n+            Asserts.assertEquals(m[i] ? ba[indexes[3][i]] : 0, br[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_GATHER_MASKED, \"4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \"64\"})\n+    public void testLoadGatherMaskedByte512() {\n+        VectorMask<Byte> mask = VectorMask.fromArray(BSPEC_512, m, 0);\n+        ByteVector.fromArray(BSPEC_512, ba, 0, indexes[4], 0, mask)\n+                  .intoArray(br, 0);\n+    }\n+\n+    @Check(test = \"testLoadGatherMaskedByte512\")\n+    public void verifyLoadGatherMaskedByte512() {\n+        for (int i = 0; i < BSPEC_512.length(); i++) {\n+            Asserts.assertEquals(m[i] ? ba[indexes[4][i]] : 0, br[i]);\n+        }\n+    }\n+\n+    \/\/ Tests for masked gather load of short vector with different vector species.\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_GATHER_MASKED, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \">= 16\"})\n+    public void testLoadGatherMaskedShort64() {\n+        VectorMask<Short> mask = VectorMask.fromArray(SSPEC_64, m, 0);\n+        ShortVector.fromArray(SSPEC_64, sa, 0, indexes[0], 0, mask)\n+                   .intoArray(sr, 0);\n+    }\n+\n+    @Check(test = \"testLoadGatherMaskedShort64\")\n+    public void verifyLoadGatherMaskedShort64() {\n+        for (int i = 0; i < SSPEC_64.length(); i++) {\n+            Asserts.assertEquals(m[i] ? sa[indexes[0][i]] : 0, sr[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_GATHER_MASKED, \"2\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \"16\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_GATHER_MASKED, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \">= 32\"})\n+    public void testLoadGatherMaskedShort128() {\n+        VectorMask<Short> mask = VectorMask.fromArray(SSPEC_128, m, 0);\n+        ShortVector.fromArray(SSPEC_128, sa, 0, indexes[1], 0, mask)\n+                   .intoArray(sr, 0);\n+    }\n+\n+    @Check(test = \"testLoadGatherMaskedShort128\")\n+    public void verifyLoadGatherMaskedShort128() {\n+        for (int i = 0; i < SSPEC_128.length(); i++) {\n+            Asserts.assertEquals(m[i] ? sa[indexes[1][i]] : 0, sr[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_GATHER_MASKED, \"2\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \"32\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_GATHER_MASKED, \"1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \"64\"})\n+    public void testLoadGatherMaskedShort256() {\n+        VectorMask<Short> mask = VectorMask.fromArray(SSPEC_256, m, 0);\n+        ShortVector.fromArray(SSPEC_256, sa, 0, indexes[2], 0, mask)\n+                   .intoArray(sr, 0);\n+    }\n+\n+    @Check(test = \"testLoadGatherMaskedShort256\")\n+    public void verifyLoadGatherMaskedShort256() {\n+        for (int i = 0; i < SSPEC_256.length(); i++) {\n+            Asserts.assertEquals(m[i] ? sa[indexes[2][i]] : 0, sr[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_GATHER_MASKED, \"2\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"MaxVectorSize\", \"64\"})\n+    public void testLoadGatherMaskedShort512() {\n+        VectorMask<Short> mask = VectorMask.fromArray(SSPEC_512, m, 0);\n+        ShortVector.fromArray(SSPEC_512, sa, 0, indexes[3], 0, mask)\n+                   .intoArray(sr, 0);\n+    }\n+\n+    @Check(test = \"testLoadGatherMaskedShort512\")\n+    public void verifyLoadGatherMaskedShort512() {\n+        for (int i = 0; i < SSPEC_512.length(); i++) {\n+            Asserts.assertEquals(m[i] ? sa[indexes[3][i]] : 0, sr[i]);\n@@ -155,2 +376,21 @@\n-                     .addFlags(\"--add-modules=jdk.incubator.vector\")\n-                     .start();\n+                     .addFlags(\"--add-modules=jdk.incubator.vector\",\n+                               \"-XX:-TieredCompilation\");\n+        \/\/ Set MaxVectorSize for tests.\n+        if (args != null && args.length > 0) {\n+            String vmFlags = \"\";\n+            switch (args[0]) {\n+                case \"MaxVectorSize_16\":\n+                    vmFlags = \"-XX:MaxVectorSize=16\";\n+                    break;\n+                case \"MaxVectorSize_32\":\n+                    vmFlags = \"-XX:MaxVectorSize=32\";\n+                    break;\n+                case \"MaxVectorSize_64\":\n+                    vmFlags = \"-XX:MaxVectorSize=64\";\n+                    break;\n+                default:\n+                    throw new RuntimeException(\"Unexpected args\");\n+            }\n+            testFramework.addFlags(vmFlags);\n+        }\n+        testFramework.start();\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorGatherSubwordTest.java","additions":293,"deletions":53,"binary":false,"changes":346,"status":"modified"}]}