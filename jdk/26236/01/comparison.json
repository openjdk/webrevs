{"files":[{"patch":"@@ -2404,0 +2404,14 @@\n+\/\/ Vector ideal reg size corresponding to the specified len in bytes\n+uint Matcher::vector_ideal_reg_size(int len) {\n+  assert(MaxVectorSize >= len, \"\");\n+  uint ideal_reg = vector_ideal_reg(len);\n+  switch (ideal_reg) {\n+    case Op_VecD: return 8;\n+    case Op_VecX: return 16;\n+    case Op_VecA: return MaxVectorSize;\n+    default:\n+      ShouldNotReachHere();\n+      return 0;\n+  }\n+}\n+\n@@ -2650,6 +2664,7 @@\n-  \/\/ Loads and stores with indirect memory input (e.g., volatile loads and\n-  \/\/ stores) do not subsume the input into complex addressing expressions. If\n-  \/\/ the addressing expression is input to at least one such load or store, do\n-  \/\/ not clone the addressing expression. Query needs_acquiring_load and\n-  \/\/ needs_releasing_store as a proxy for indirect memory input, as it is not\n-  \/\/ possible to directly query for indirect memory input at this stage.\n+  \/\/ Loads and stores with indirect memory input (e.g., volatile loads\/stores,\n+  \/\/ and vector gather_loads\/scatter_stores) do not subsume the input into\n+  \/\/ complex addressing expressions. If the addressing expression is input\n+  \/\/ to at least one such load or store, do not clone the addressing expression.\n+  \/\/ Query needs_acquiring_load and needs_releasing_store as a proxy for\n+  \/\/ indirect memory input, as it is not possible to directly query for indirect\n+  \/\/ memory input at this stage.\n@@ -2664,0 +2679,7 @@\n+\n+    if (n->is_LoadVectorGather() ||\n+        n->is_StoreVectorScatter() ||\n+        n->is_LoadVectorGatherMasked() ||\n+        n->is_StoreVectorScatterMasked()) {\n+      return false;\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":28,"deletions":6,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -171,0 +171,2 @@\n+      case Op_LoadVectorGather:\n+      case Op_LoadVectorGatherMasked:\n@@ -177,0 +179,3 @@\n+      \/\/ Temporarily disable vector mask widen support for NEON,\n+      \/\/ because we do not have the use case now.\n+      case Op_VectorMaskWiden:\n@@ -181,6 +186,0 @@\n-      case Op_LoadVectorGather:\n-      case Op_LoadVectorGatherMasked:\n-        if (UseSVE == 0 || is_subword_type(bt)) {\n-          return false;\n-        }\n-        break;\n@@ -5277,0 +5276,29 @@\n+\/\/ ---------------------------- Vector Slice ------------------------\n+\n+instruct vslice_neon(vReg dst, vReg src1, vReg src2, immI index) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (VectorSlice (Binary src1 src2) index));\n+  format %{ \"vslice_neon $dst, $src1, $src2, $index\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    uint scale = type2aelembytes(Matcher::vector_element_basic_type(this));\n+    __ ext($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+           $src1$$FloatRegister, $src2$$FloatRegister,\n+           ((uint)$index$$constant * scale));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vslice_sve(vReg dst_src1, vReg src2, immI index) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (VectorSlice (Binary dst_src1 src2) index));\n+  format %{ \"vslice_sve $dst_src1, $dst_src1, $src2, $index\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    uint scale = type2aelembytes(Matcher::vector_element_basic_type(this));\n+    __ sve_ext($dst_src1$$FloatRegister, $src2$$FloatRegister,\n+               ((uint)$index$$constant * scale));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -5940,0 +5968,26 @@\n+\/\/ Vector mask widen to twice size\n+\/\/\n+\/\/ Unpack elements from the lowest or highest half of the source\n+\/\/ predicate and place in elements of twice their size within the\n+\/\/ destination predicate.\n+\n+instruct vmaskwiden_lo_sve(pReg dst, pReg src) %{\n+  predicate(UseSVE > 0 && n->as_VectorMaskWiden()->is_lo());\n+  match(Set dst (VectorMaskWiden src));\n+  format %{ \"vmaskwiden_lo_sve $dst, $src\" %}\n+  ins_encode %{\n+    __ sve_punpklo($dst$$PRegister, $src$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskwiden_hi_sve(pReg dst, pReg src) %{\n+  predicate(UseSVE > 0 && !n->as_VectorMaskWiden()->is_lo());\n+  match(Set dst (VectorMaskWiden src));\n+  format %{ \"vmaskwiden_hi_sve $dst, $src\" %}\n+  ins_encode %{\n+    __ sve_punpkhi($dst$$PRegister, $src$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -6673,0 +6727,49 @@\n+instruct gather_load_subword_le128(vReg dst, indirect mem, vReg idx) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) <= 2 &&\n+            Matcher::vector_length_in_bytes(n->as_LoadVectorGather()->in(3)) <= 16);\n+  match(Set dst (LoadVectorGather mem idx));\n+  effect(TEMP_DEF dst);\n+  format %{ \"gather_load_subword_le128 $dst, $mem, $idx\\t# vector (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (bt == T_BYTE) {\n+      __ sve_ld1b_gather($dst$$FloatRegister, ptrue,\n+                         as_Register($mem$$base), $idx$$FloatRegister);\n+      __ xtn($dst$$FloatRegister, __ T4H, $dst$$FloatRegister, __ T4S);\n+      __ xtn($dst$$FloatRegister, __ T8B, $dst$$FloatRegister, __ T8H);\n+    } else {\n+      assert(bt == T_SHORT, \"unsupported type\");\n+      __ sve_ld1h_gather($dst$$FloatRegister, ptrue,\n+                         as_Register($mem$$base), $idx$$FloatRegister);\n+      __ xtn($dst$$FloatRegister, __ T4H, $dst$$FloatRegister, __ T4S);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct gather_load_subword_gt128(vReg dst, indirect mem, vReg idx, vReg vtmp) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) <= 2 &&\n+            Matcher::vector_length_in_bytes(n->as_LoadVectorGather()->in(3)) > 16);\n+  match(Set dst (LoadVectorGather mem idx));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"gather_load_subword_gt128 $dst, $mem, $idx\\t# vector (sve). KILL $vtmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_dup($vtmp$$FloatRegister, __ S, 0);\n+    if (bt == T_BYTE) {\n+      __ sve_ld1b_gather($dst$$FloatRegister, ptrue,\n+                         as_Register($mem$$base), $idx$$FloatRegister);\n+      __ sve_uzp1($dst$$FloatRegister, __ H, $dst$$FloatRegister, $vtmp$$FloatRegister);\n+      __ sve_uzp1($dst$$FloatRegister, __ B, $dst$$FloatRegister, $vtmp$$FloatRegister);\n+    } else {\n+      assert(bt == T_SHORT, \"unsupported type\");\n+      __ sve_ld1h_gather($dst$$FloatRegister, ptrue,\n+                         as_Register($mem$$base), $idx$$FloatRegister);\n+      __ sve_uzp1($dst$$FloatRegister, __ H, $dst$$FloatRegister, $vtmp$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -6683,1 +6786,1 @@\n- %}\n+  %}\n@@ -6703,0 +6806,49 @@\n+instruct gather_load_subword_masked_le128(vReg dst, indirect mem, vReg idx, pRegGov pg) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) <= 2 &&\n+            Matcher::vector_length_in_bytes(n->as_LoadVectorGatherMasked()->in(3)->in(1)) <= 16);\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx pg)));\n+  effect(TEMP_DEF dst);\n+  format %{ \"gather_load_subword_masked_le128 $dst, $pg, $mem, $idx\\t# vector (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (bt == T_BYTE) {\n+      __ sve_ld1b_gather($dst$$FloatRegister, $pg$$PRegister,\n+                         as_Register($mem$$base), $idx$$FloatRegister);\n+      __ xtn($dst$$FloatRegister, __ T4H, $dst$$FloatRegister, __ T4S);\n+      __ xtn($dst$$FloatRegister, __ T8B, $dst$$FloatRegister, __ T8H);\n+    } else {\n+      assert(bt == T_SHORT, \"unsupported type\");\n+      __ sve_ld1h_gather($dst$$FloatRegister, $pg$$PRegister,\n+                         as_Register($mem$$base), $idx$$FloatRegister);\n+      __ xtn($dst$$FloatRegister, __ T4H, $dst$$FloatRegister, __ T4S);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct gather_load_subword_masked_gt128(vReg dst, indirect mem, vReg idx, vReg vtmp, pRegGov pg) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) <= 2 &&\n+            Matcher::vector_length_in_bytes(n->as_LoadVectorGatherMasked()->in(3)->in(1)) > 16);\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx pg)));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"gather_load_subword_masked_gt128 $dst, $pg, $mem, $idx\\t# vector (sve). KILL $vtmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_dup($vtmp$$FloatRegister, __ S, 0);\n+    if (bt == T_BYTE) {\n+      __ sve_ld1b_gather($dst$$FloatRegister, $pg$$PRegister,\n+                         as_Register($mem$$base), $idx$$FloatRegister);\n+      __ sve_uzp1($dst$$FloatRegister, __ H, $dst$$FloatRegister, $vtmp$$FloatRegister);\n+      __ sve_uzp1($dst$$FloatRegister, __ B, $dst$$FloatRegister, $vtmp$$FloatRegister);\n+    } else {\n+      assert(bt == T_SHORT, \"unsupported type\");\n+      __ sve_ld1h_gather($dst$$FloatRegister, $pg$$PRegister,\n+                         as_Register($mem$$base), $idx$$FloatRegister);\n+      __ sve_uzp1($dst$$FloatRegister, __ H, $dst$$FloatRegister, $vtmp$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":159,"deletions":7,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -161,0 +161,2 @@\n+      case Op_LoadVectorGather:\n+      case Op_LoadVectorGatherMasked:\n@@ -167,0 +169,3 @@\n+      \/\/ Temporarily disable vector mask widen support for NEON,\n+      \/\/ because we do not have the use case now.\n+      case Op_VectorMaskWiden:\n@@ -171,6 +176,0 @@\n-      case Op_LoadVectorGather:\n-      case Op_LoadVectorGatherMasked:\n-        if (UseSVE == 0 || is_subword_type(bt)) {\n-          return false;\n-        }\n-        break;\n@@ -3422,0 +3421,29 @@\n+\/\/ ---------------------------- Vector Slice ------------------------\n+\n+instruct vslice_neon(vReg dst, vReg src1, vReg src2, immI index) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (VectorSlice (Binary src1 src2) index));\n+  format %{ \"vslice_neon $dst, $src1, $src2, $index\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    uint scale = type2aelembytes(Matcher::vector_element_basic_type(this));\n+    __ ext($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+           $src1$$FloatRegister, $src2$$FloatRegister,\n+           ((uint)$index$$constant * scale));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vslice_sve(vReg dst_src1, vReg src2, immI index) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (VectorSlice (Binary dst_src1 src2) index));\n+  format %{ \"vslice_sve $dst_src1, $dst_src1, $src2, $index\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    uint scale = type2aelembytes(Matcher::vector_element_basic_type(this));\n+    __ sve_ext($dst_src1$$FloatRegister, $src2$$FloatRegister,\n+               ((uint)$index$$constant * scale));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -3994,0 +4022,26 @@\n+\/\/ Vector mask widen to twice size\n+\/\/\n+\/\/ Unpack elements from the lowest or highest half of the source\n+\/\/ predicate and place in elements of twice their size within the\n+\/\/ destination predicate.\n+\n+instruct vmaskwiden_lo_sve(pReg dst, pReg src) %{\n+  predicate(UseSVE > 0 && n->as_VectorMaskWiden()->is_lo());\n+  match(Set dst (VectorMaskWiden src));\n+  format %{ \"vmaskwiden_lo_sve $dst, $src\" %}\n+  ins_encode %{\n+    __ sve_punpklo($dst$$PRegister, $src$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskwiden_hi_sve(pReg dst, pReg src) %{\n+  predicate(UseSVE > 0 && !n->as_VectorMaskWiden()->is_lo());\n+  match(Set dst (VectorMaskWiden src));\n+  format %{ \"vmaskwiden_hi_sve $dst, $src\" %}\n+  ins_encode %{\n+    __ sve_punpkhi($dst$$PRegister, $src$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -4683,0 +4737,49 @@\n+instruct gather_load_subword_le128(vReg dst, indirect mem, vReg idx) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) <= 2 &&\n+            Matcher::vector_length_in_bytes(n->as_LoadVectorGather()->in(3)) <= 16);\n+  match(Set dst (LoadVectorGather mem idx));\n+  effect(TEMP_DEF dst);\n+  format %{ \"gather_load_subword_le128 $dst, $mem, $idx\\t# vector (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (bt == T_BYTE) {\n+      __ sve_ld1b_gather($dst$$FloatRegister, ptrue,\n+                         as_Register($mem$$base), $idx$$FloatRegister);\n+      __ xtn($dst$$FloatRegister, __ T4H, $dst$$FloatRegister, __ T4S);\n+      __ xtn($dst$$FloatRegister, __ T8B, $dst$$FloatRegister, __ T8H);\n+    } else {\n+      assert(bt == T_SHORT, \"unsupported type\");\n+      __ sve_ld1h_gather($dst$$FloatRegister, ptrue,\n+                         as_Register($mem$$base), $idx$$FloatRegister);\n+      __ xtn($dst$$FloatRegister, __ T4H, $dst$$FloatRegister, __ T4S);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct gather_load_subword_gt128(vReg dst, indirect mem, vReg idx, vReg vtmp) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) <= 2 &&\n+            Matcher::vector_length_in_bytes(n->as_LoadVectorGather()->in(3)) > 16);\n+  match(Set dst (LoadVectorGather mem idx));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"gather_load_subword_gt128 $dst, $mem, $idx\\t# vector (sve). KILL $vtmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_dup($vtmp$$FloatRegister, __ S, 0);\n+    if (bt == T_BYTE) {\n+      __ sve_ld1b_gather($dst$$FloatRegister, ptrue,\n+                         as_Register($mem$$base), $idx$$FloatRegister);\n+      __ sve_uzp1($dst$$FloatRegister, __ H, $dst$$FloatRegister, $vtmp$$FloatRegister);\n+      __ sve_uzp1($dst$$FloatRegister, __ B, $dst$$FloatRegister, $vtmp$$FloatRegister);\n+    } else {\n+      assert(bt == T_SHORT, \"unsupported type\");\n+      __ sve_ld1h_gather($dst$$FloatRegister, ptrue,\n+                         as_Register($mem$$base), $idx$$FloatRegister);\n+      __ sve_uzp1($dst$$FloatRegister, __ H, $dst$$FloatRegister, $vtmp$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -4693,1 +4796,1 @@\n- %}\n+  %}\n@@ -4713,0 +4816,49 @@\n+instruct gather_load_subword_masked_le128(vReg dst, indirect mem, vReg idx, pRegGov pg) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) <= 2 &&\n+            Matcher::vector_length_in_bytes(n->as_LoadVectorGatherMasked()->in(3)->in(1)) <= 16);\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx pg)));\n+  effect(TEMP_DEF dst);\n+  format %{ \"gather_load_subword_masked_le128 $dst, $pg, $mem, $idx\\t# vector (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (bt == T_BYTE) {\n+      __ sve_ld1b_gather($dst$$FloatRegister, $pg$$PRegister,\n+                         as_Register($mem$$base), $idx$$FloatRegister);\n+      __ xtn($dst$$FloatRegister, __ T4H, $dst$$FloatRegister, __ T4S);\n+      __ xtn($dst$$FloatRegister, __ T8B, $dst$$FloatRegister, __ T8H);\n+    } else {\n+      assert(bt == T_SHORT, \"unsupported type\");\n+      __ sve_ld1h_gather($dst$$FloatRegister, $pg$$PRegister,\n+                         as_Register($mem$$base), $idx$$FloatRegister);\n+      __ xtn($dst$$FloatRegister, __ T4H, $dst$$FloatRegister, __ T4S);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct gather_load_subword_masked_gt128(vReg dst, indirect mem, vReg idx, vReg vtmp, pRegGov pg) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) <= 2 &&\n+            Matcher::vector_length_in_bytes(n->as_LoadVectorGatherMasked()->in(3)->in(1)) > 16);\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx pg)));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  format %{ \"gather_load_subword_masked_gt128 $dst, $pg, $mem, $idx\\t# vector (sve). KILL $vtmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_dup($vtmp$$FloatRegister, __ S, 0);\n+    if (bt == T_BYTE) {\n+      __ sve_ld1b_gather($dst$$FloatRegister, $pg$$PRegister,\n+                         as_Register($mem$$base), $idx$$FloatRegister);\n+      __ sve_uzp1($dst$$FloatRegister, __ H, $dst$$FloatRegister, $vtmp$$FloatRegister);\n+      __ sve_uzp1($dst$$FloatRegister, __ B, $dst$$FloatRegister, $vtmp$$FloatRegister);\n+    } else {\n+      assert(bt == T_SHORT, \"unsupported type\");\n+      __ sve_ld1h_gather($dst$$FloatRegister, $pg$$PRegister,\n+                         as_Register($mem$$base), $idx$$FloatRegister);\n+      __ sve_uzp1($dst$$FloatRegister, __ H, $dst$$FloatRegister, $vtmp$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":159,"deletions":7,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -3663,0 +3663,4 @@\n+  \/\/ SVE 8-bit gather load bytes (scalar plus 32-bit unscaled offsets)\n+  INSN(sve_ld1b_gather,  0b1000010, 0b00, 0b00, 0b010);\n+  \/\/ SVE 16-bit gather load halfwords (scalar plus 32-bit scaled offsets)\n+  INSN(sve_ld1h_gather,  0b1000010, 0b01, 0b01, 0b010);\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -167,0 +167,6 @@\n+  \/\/ SVE requires vector indices for gather-load\/scatter-store operations\n+  \/\/ on all data types.\n+  static bool gather_scatter_needs_vector_index(BasicType bt) {\n+    return has_predicated_vectors();\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/matcher_aarch64.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1040,0 +1040,6 @@\n+\/\/ Vector ideal reg size corresponding to the specified size in bytes\n+uint Matcher::vector_ideal_reg_size(int size) {\n+  assert(MaxVectorSize >= size, \"\");\n+  return size;\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -160,0 +160,5 @@\n+  \/\/ Return true if vector gather-load\/scatter-store needs vector index as input.\n+  static bool gather_scatter_needs_vector_index(BasicType bt) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/arm\/matcher_arm.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -170,0 +170,5 @@\n+  \/\/ Return true if vector gather-load\/scatter-store needs vector index as input.\n+  static bool gather_scatter_needs_vector_index(BasicType bt) {\n+    return !is_subword_type(bt);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/matcher_ppc.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2331,0 +2331,6 @@\n+\/\/ Vector ideal reg size corresponding to the specified size in bytes\n+uint Matcher::vector_ideal_reg_size(int size) {\n+  assert(MaxVectorSize == size, \"\");\n+  return size;\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -166,0 +166,5 @@\n+  \/\/ Return true if vector gather-load\/scatter-store needs vector index as input.\n+  static bool gather_scatter_needs_vector_index(BasicType bt) {\n+    return !is_subword_type(bt);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/matcher_riscv.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -2017,0 +2017,6 @@\n+\/\/ Vector ideal reg size corresponding to the specified len in bytes\n+uint Matcher::vector_ideal_reg_size(int len) {\n+  assert(MaxVectorSize >= len, \"\");\n+  return MaxVectorSize;\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -163,0 +163,5 @@\n+  \/\/ Return true if vector gather-load\/scatter-store needs vector index as input.\n+  static bool gather_scatter_needs_vector_index(BasicType bt) {\n+    return !is_subword_type(bt);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/s390\/matcher_s390.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1850,0 +1850,6 @@\n+\/\/ Vector ideal reg size corresponding to the specified size in bytes\n+uint Matcher::vector_ideal_reg_size(int size) {\n+  assert(MaxVectorSize == size, \"\");\n+  return size;\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,0 +158,5 @@\n+  \/\/ Return true if vector gather-load\/scatter-store needs vector index as input.\n+  static bool gather_scatter_needs_vector_index(BasicType bt) {\n+    return !is_subword_type(bt);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/matcher_x86.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2250,0 +2250,6 @@\n+\/\/ Vector ideal reg size corresponding to the specified len in bytes\n+uint Matcher::vector_ideal_reg_size(int size) {\n+  assert(MaxVectorSize >= size, \"\");\n+  return size;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4363,1 +4363,1 @@\n-    \"VectorRearrange\", \"VectorLoadShuffle\", \"VectorLoadConst\",\n+    \"VectorRearrange\", \"VectorLoadShuffle\", \"VectorLoadConst\", \"VectorSlice\",\n@@ -4371,1 +4371,1 @@\n-    \"MaskAll\", \"AndVMask\", \"OrVMask\", \"XorVMask\", \"VectorMaskCast\",\n+    \"MaskAll\", \"AndVMask\", \"OrVMask\", \"XorVMask\", \"VectorMaskCast\", \"VectorMaskWiden\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -516,0 +516,1 @@\n+macro(VectorMaskWiden)\n@@ -538,0 +539,1 @@\n+macro(VectorSlice)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -420,0 +420,2 @@\n+  Node* gen_gather_load_subword(Node* addr, Node* indexes, Node* indexes1, Node* indexes2, Node* indexes3, const TypeVect* vector_type);\n+  Node* gen_gather_load_masked_subword(Node* addr, Node* indexes, Node* indexes1, Node* indexes2, Node* indexes3, Node* mask, const TypeVect* vector_type);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2443,0 +2443,1 @@\n+    case Op_VectorSlice:\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -363,0 +363,2 @@\n+  \/\/ Vector ideal reg size\n+  static uint vector_ideal_reg_size(int len);\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -195,0 +195,1 @@\n+class VectorMaskWidenNode;\n@@ -751,0 +752,1 @@\n+        DEFINE_CLASS_ID(VectorMaskWiden, Vector, 11)\n@@ -1012,0 +1014,1 @@\n+  DEFINE_CLASS_QUERY(VectorMaskWiden)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1176,0 +1176,143 @@\n+Node* LibraryCallKit::gen_gather_load_subword(Node* addr, Node* indexes0, Node* indexes1, Node* indexes2,\n+                                              Node* indexes3, const TypeVect* vt) {\n+  BasicType elem_bt = vt->element_basic_type();\n+  uint elem_num = vt->length();\n+  const TypeVect* index_vt = indexes0->bottom_type()->isa_vect();\n+  const TypePtr* addr_type = gvn().type(addr)->isa_ptr();\n+  Node* addr_mem = memory(addr);\n+\n+  \/\/ The first gather-load.\n+  Node* vgather = gvn().transform(new LoadVectorGatherNode(control(), addr_mem, addr, addr_type, vt, indexes0));\n+\n+  uint index_elem_num = index_vt != nullptr ? index_vt->length() : 0;\n+  uint vector_reg_size = Matcher::vector_ideal_reg_size(vt->length_in_bytes());\n+  uint max_elem_num = vector_reg_size \/ type2aelembytes(elem_bt);\n+\n+  \/\/ The second gather-load.\n+  if (indexes1 != nullptr) {\n+    assert(index_vt != nullptr, \"indexes0 must be a vector\");\n+    assert(Type::equals(indexes1->bottom_type(), index_vt), \"invalid vector type for indexes1\");\n+    Node* vgather1 = gvn().transform(new LoadVectorGatherNode(control(), addr_mem, addr, addr_type, vt, indexes1));\n+    \/\/ Merge the second gather with the first gather result.\n+    Node* idx = gvn().makecon(TypeInt::make(max_elem_num - index_elem_num));\n+    Node* vslice = gvn().transform(new VectorSliceNode(vgather1, vgather1, idx));\n+    vgather = gvn().transform(new OrVNode(vgather, vslice, vt));\n+  }\n+\n+  \/\/ The third and fourth gather-loads on byte vector.\n+  if (indexes2 != nullptr) {\n+    assert(elem_bt == T_BYTE, \"only byte vector needs more than 2 times of gather-load\");\n+    assert(indexes3 != nullptr, \"indexes3 must be non-null\");\n+    assert(Type::equals(indexes2->bottom_type(), index_vt), \"invalid vector type for indexes2\");\n+    assert(Type::equals(indexes3->bottom_type(), index_vt), \"invalid vector type for indexes3\");\n+    Node* vgather2 = gvn().transform(new LoadVectorGatherNode(control(), addr_mem, addr, addr_type, vt, indexes2));\n+    \/\/ Merge the third gather with previous results.\n+    Node* idx = gvn().makecon(TypeInt::make(max_elem_num - 2 * index_elem_num));\n+    Node* vslice = gvn().transform(new VectorSliceNode(vgather2, vgather2, idx));\n+    vgather = gvn().transform(new OrVNode(vgather, vslice, vt));\n+\n+    Node* vgather3 = gvn().transform(new LoadVectorGatherNode(control(), addr_mem, addr, addr_type, vt, indexes3));\n+    \/\/ Merge the fourth gather with previous results.\n+    idx = gvn().makecon(TypeInt::make(max_elem_num - 3 * index_elem_num));\n+    vslice = gvn().transform(new VectorSliceNode(vgather3, vgather3, idx));\n+    vgather = gvn().transform(new OrVNode(vgather, vslice, vt));\n+  }\n+  return vgather;\n+}\n+\n+Node* LibraryCallKit::gen_gather_load_masked_subword(Node* addr, Node* indexes0, Node* indexes1,\n+                                                     Node* indexes2, Node* indexes3, Node* mask,\n+                                                     const TypeVect* vt) {\n+  BasicType elem_bt = vt->element_basic_type();\n+  const TypeVect* index_vt = indexes0->bottom_type()->isa_vect();\n+  const TypePtr* addr_type = gvn().type(addr)->isa_ptr();\n+  Node* addr_mem = memory(addr);\n+\n+  \/\/ Case for architectures (e.g. X86_64) that the subword vector gather does not accept a vector\n+  \/\/ index as input. The given mask needs to be kept as it is.\n+  if (index_vt == nullptr) {\n+    return gvn().transform(new LoadVectorGatherMaskedNode(control(), addr_mem, addr, addr_type, vt, indexes0, mask));\n+  }\n+\n+  \/\/ Otherwise, the given mask may need to be split and used by multiple masked vector gather-loads\n+  \/\/ respectively. Additionally, each part of the mask needs to be converted to int type because the\n+  \/\/ vector gather-load instruction works on the same type of the vector indice.\n+  \/\/\n+  \/\/ For example, if it is gather loading a short vector and it needs two times of gather-load, the\n+  \/\/ lower half of the given mask is used by the first gather-load, and the higher half of the given\n+  \/\/ mask is used by the second gather-load. It will be more complicated for byte vector, that the\n+  \/\/ mask maybe split into 4 parts. Here is an example:\n+  \/\/\n+  \/\/  mask = [1010 0101 1111 1100]\n+  \/\/          ---- ---- ---- ----\n+  \/\/            |    |    |    |------ gather_mask0\n+  \/\/            |    |    |----------- gather_mask1\n+  \/\/            |    |---------------- gather_mask2\n+  \/\/            |--------------------- gather_mask3\n+  \/\/\n+  \/\/ Define the mask type of gather mask as the same as the vector index.\n+  uint index_elem_num = index_vt->length();\n+  const TypeVect* mask_vt = TypeVect::makemask(T_INT, index_elem_num);\n+  Node* gather_mask_short = nullptr;\n+  Node* gather_mask = nullptr;\n+\n+  \/\/ The first masked vector gather-load with vector index.\n+  \/\/\n+  \/\/ Generate a new vector mask by widening the lower half of the given mask to int type. For byte\n+  \/\/ vector, it maybe the lowest 1\/4 part of the given mask.\n+  if (elem_bt == T_BYTE) {\n+    const TypeVect* mask_vt_short = TypeVect::makemask(T_SHORT, MaxVectorSize \/ type2aelembytes(T_SHORT));\n+    gather_mask_short = gvn().transform(new VectorMaskWidenNode(mask, mask_vt_short, \/* is_lo *\/ true));\n+  } else {\n+    gather_mask_short = mask;\n+  }\n+  gather_mask = gvn().transform(new VectorMaskWidenNode(gather_mask_short, mask_vt, \/* is_lo *\/ true));\n+  Node* vgather = gvn().transform(new LoadVectorGatherMaskedNode(control(), addr_mem, addr, addr_type, vt, indexes0, gather_mask));\n+\n+  \/\/ The second masked vector gather with vector index.\n+  uint vector_reg_size = Matcher::vector_ideal_reg_size(vt->length_in_bytes());\n+  uint max_elem_num = vector_reg_size \/ type2aelembytes(elem_bt);\n+  if (indexes1 != nullptr) {\n+    assert(index_vt != nullptr, \"indexes0 must be a vector\");\n+    assert(Type::equals(indexes1->bottom_type(), index_vt), \"invalid vector type for indexes1\");\n+\n+    \/\/ Generate a new vector mask by widening the higher half of the given mask to int type. For byte\n+    \/\/ vector, it maybe the 2\/4 part of the mask starting from the lowest bit.\n+    gather_mask = gvn().transform(new VectorMaskWidenNode(gather_mask_short, mask_vt, \/* is_lo *\/ false));\n+    Node* vgather1 = gvn().transform(new LoadVectorGatherMaskedNode(control(), addr_mem, addr, addr_type, vt, indexes1, gather_mask));\n+    \/\/ Merge the second gather with the first gather result.\n+    Node* idx = gvn().makecon(TypeInt::make(max_elem_num - index_elem_num));\n+    Node* slice = gvn().transform(new VectorSliceNode(vgather1, vgather1, idx));\n+    vgather = gvn().transform(new OrVNode(vgather, slice, vt));\n+  }\n+\n+  \/\/ The third and fourth masked vector gathers for byte vector.\n+  if (indexes2 != nullptr) {\n+    assert(elem_bt == T_BYTE, \"only byte vector needs more than 2 times of gather load\");\n+    assert(indexes3 != nullptr, \"indexes3 must be non-null\");\n+    assert(Type::equals(indexes2->bottom_type(), index_vt), \"invalid vector type for indexes2\");\n+    assert(Type::equals(indexes3->bottom_type(), index_vt), \"invalid vector type for indexes3\");\n+\n+    \/\/ The third masked vector gather with vector index. The new vector mask is widened from the 3\/4\n+    \/\/ part of the input mask.\n+    const TypeVect* mask_vt_short = TypeVect::makemask(T_SHORT, MaxVectorSize \/ type2aelembytes(T_SHORT));\n+    gather_mask_short = gvn().transform(new VectorMaskWidenNode(mask, mask_vt_short, \/* is_lo *\/ false));\n+    gather_mask = gvn().transform(new VectorMaskWidenNode(gather_mask_short, mask_vt, \/* is_lo *\/ true));\n+    Node* vgather2 = gvn().transform(new LoadVectorGatherMaskedNode(control(), addr_mem, addr, addr_type, vt, indexes2, gather_mask));\n+    \/\/ Merge the third gather with previous results.\n+    Node* idx = gvn().makecon(TypeInt::make(max_elem_num - 2 * index_elem_num));\n+    Node* slice = gvn().transform(new VectorSliceNode(vgather2, vgather2, idx));\n+    vgather = gvn().transform(new OrVNode(vgather, slice, vt));\n+\n+    \/\/ The fourth masked vector gather with vector index. The new vector mask is widened from the 4\/4\n+    \/\/ part of the input mask.\n+    gather_mask = gvn().transform(new VectorMaskWidenNode(gather_mask_short, mask_vt, \/* is_lo *\/ false));\n+    Node* vgather3 = gvn().transform(new LoadVectorGatherMaskedNode(control(), addr_mem, addr, addr_type, vt, indexes3, gather_mask));\n+    \/\/ Merge the fourth gather with previous results.\n+    idx = gvn().makecon(TypeInt::make(max_elem_num - 3 * index_elem_num));\n+    slice = gvn().transform(new VectorSliceNode(vgather3, vgather3, idx));\n+    vgather = gvn().transform(new OrVNode(vgather, slice, vt));\n+  }\n+  return vgather;\n+}\n+\n@@ -1276,7 +1419,26 @@\n-  \/\/ Check that the vector holding indices is supported by architecture\n-  \/\/ For sub-word gathers expander receive index array.\n-  if (!is_subword_type(elem_bt) && !arch_supports_vector(Op_LoadVector, idx_num_elem, T_INT, VecMaskNotUsed)) {\n-    log_if_needed(\"  ** not supported: arity=%d op=%s\/loadindex vlen=%d etype=int is_masked_op=%d\",\n-                  is_scatter, is_scatter ? \"scatter\" : \"gather\",\n-                  idx_num_elem, is_masked_op ? 1 : 0);\n-    return false; \/\/ not supported\n+  bool needs_vector_index = Matcher::gather_scatter_needs_vector_index(elem_bt);\n+  if (needs_vector_index) {\n+    \/\/ Check that the vector holding indices is supported by architecture\n+    if (!arch_supports_vector(Op_LoadVector, idx_num_elem, T_INT, VecMaskNotUsed)) {\n+      log_if_needed(\"  ** not supported: arity=%d op=%s\/loadindex vlen=%d etype=int is_masked_op=%d\",\n+                    is_scatter, is_scatter ? \"scatter\" : \"gather\",\n+                    idx_num_elem, is_masked_op ? 1 : 0);\n+      return false; \/\/ not supported\n+    }\n+\n+    \/\/ Check more ops that are necessary to finish the whole subword gather with vector indexes.\n+    if (!is_scatter && gvn().type(argument(10)) != TypePtr::NULL_PTR) {\n+      assert(is_subword_type(elem_bt), \"Only subword gather operation accepts multiple indexes\");\n+      if (!arch_supports_vector(Op_VectorSlice, num_elem, elem_bt, VecMaskNotUsed) ||\n+          !arch_supports_vector(Op_OrV, num_elem, elem_bt, VecMaskNotUsed)) {\n+        log_if_needed(\"  ** not supported: op=gather\/merge vlen=%d etype=%s is_masked_op=%d\",\n+                      num_elem, type2name(elem_bt), is_masked_op ? 1 : 0);\n+        return false; \/\/ not supported\n+      }\n+\n+      if (is_masked_op && !arch_supports_vector(Op_VectorMaskWiden, idx_num_elem, T_INT, VecMaskNotUsed)) {\n+        log_if_needed(\"  ** not supported: op=gather\/maskwiden vlen=%d etype=%s is_masked_op=1\",\n+                      idx_num_elem, type2name(elem_bt));\n+        return false; \/\/ not supported\n+      }\n+    }\n@@ -1292,1 +1454,1 @@\n-  if (!is_subword_type(elem_bt)) {\n+  if (needs_vector_index) {\n@@ -1295,0 +1457,1 @@\n+    assert(is_subword_type(elem_bt), \"Only subword gather operation supports non-vector indexes\");\n@@ -1324,1 +1487,1 @@\n-  if (is_subword_type(elem_bt)) {\n+  if (!needs_vector_index) {\n@@ -1336,0 +1499,31 @@\n+  \/\/ Get other index vectors if they are not nullptr for subword gather operation.\n+  Node* indexes1 = nullptr;\n+  Node* indexes2 = nullptr;\n+  Node* indexes3 = nullptr;\n+  if (!is_scatter && needs_vector_index) {\n+    \/\/ Get the second index vector if it is not nullptr.\n+    Node* idx1 = argument(10);\n+    if (gvn().type(idx1) != TypePtr::NULL_PTR) {\n+      indexes1 = unbox_vector(idx1, vbox_idx_type, T_INT, idx_num_elem);\n+      if (indexes1 == nullptr) {\n+        return false;\n+      }\n+    }\n+\n+    \/\/ Get the third and fourth index vectors if they are not nullptr.\n+    Node* idx2 = argument(11);\n+    Node* idx3 = argument(12);\n+    if (gvn().type(idx2) != TypePtr::NULL_PTR) {\n+      assert(elem_bt == T_BYTE, \"Only byte gather needs more than 2 index vectors\");\n+      if (gvn().type(idx3) == TypePtr::NULL_PTR) {\n+        return false;\n+      }\n+\n+      indexes2 = unbox_vector(idx2, vbox_idx_type, T_INT, idx_num_elem);\n+      indexes3 = unbox_vector(idx3, vbox_idx_type, T_INT, idx_num_elem);\n+      if (indexes2 == nullptr || indexes3 == nullptr) {\n+        return false;\n+      }\n+    }\n+  }\n+\n@@ -1366,1 +1560,5 @@\n-      vload = gvn().transform(new LoadVectorGatherMaskedNode(control(), memory(addr), addr, addr_type, vector_type, indexes, mask));\n+      if (is_subword_type(elem_bt)) {\n+        vload = gen_gather_load_masked_subword(addr, indexes, indexes1, indexes2, indexes3, mask, vector_type);\n+      } else {\n+        vload = gvn().transform(new LoadVectorGatherMaskedNode(control(), memory(addr), addr, addr_type, vector_type, indexes, mask));\n+      }\n@@ -1368,1 +1566,5 @@\n-      vload = gvn().transform(new LoadVectorGatherNode(control(), memory(addr), addr, addr_type, vector_type, indexes));\n+      if (is_subword_type(elem_bt)) {\n+        vload = gen_gather_load_subword(addr, indexes, indexes1, indexes2, indexes3, vector_type);\n+      } else {\n+        vload = gvn().transform(new LoadVectorGatherNode(control(), memory(addr), addr, addr_type, vector_type, indexes));\n+      }\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":213,"deletions":11,"binary":false,"changes":224,"status":"modified"},{"patch":"@@ -1044,0 +1044,12 @@\n+  BasicType mask_bt = bt;\n+  uint mask_vlen = vlen;\n+  if (vopc == Op_LoadVectorGather && is_subword_type(bt)) {\n+    \/\/ It uses the index vector's type as the mask type for subword gather load.\n+    const TypeVect* index_vt = node->in(MemNode::ValueIn)->bottom_type()->isa_vect();\n+    if (index_vt == nullptr) {\n+      return nullptr;\n+    }\n+    mask_bt = index_vt->element_basic_type();\n+    mask_vlen = index_vt->length();\n+  }\n+\n@@ -1047,1 +1059,1 @@\n-      !Matcher::match_rule_supported_vector(Op_VectorMaskGen, vlen, bt)) {\n+      !Matcher::match_rule_supported_vector(Op_VectorMaskGen, mask_vlen, mask_bt)) {\n@@ -1054,3 +1066,3 @@\n-  if (vt->length_in_bytes() < (uint)MaxVectorSize) {\n-    Node* length = gvn->transform(new ConvI2LNode(gvn->makecon(TypeInt::make(vlen))));\n-    mask = gvn->transform(VectorMaskGenNode::make(length, bt, vlen));\n+  if (mask_vlen * type2aelembytes(mask_bt) < (uint)MaxVectorSize) {\n+    Node* length = gvn->transform(new ConvI2LNode(gvn->makecon(TypeInt::make(mask_vlen))));\n+    mask = gvn->transform(VectorMaskGenNode::make(length, mask_bt, mask_vlen));\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1742,0 +1742,18 @@\n+\/\/ Generate a vector by slicing the two source vectors based on an index.\n+\/\/\n+\/\/ Copy the indexed byte up to the last byte of the first source vector\n+\/\/ to the bottom of the result vector, then fill the remainder of the\n+\/\/ result starting from the first byte of the second source vector.\n+\/\/\n+\/\/ E.g. src1 = [hgfedcba] src2 = [ponmlkji] index = 3\n+\/\/      dst = [kjihgfed]\n+class VectorSliceNode : public VectorNode {\n+ public:\n+  VectorSliceNode(Node* vec1, Node* vec2, Node* index)\n+    : VectorNode(vec1, vec2, index, vec1->bottom_type()->is_vect()) {\n+    assert(index->bottom_type()->isa_int(), \"index must be an integral value\");\n+    assert(index->is_Con(), \"index must be a constant\");\n+  }\n+\n+  virtual int Opcode() const;\n+};\n@@ -1801,0 +1819,22 @@\n+\/\/ Unpack the elements to twice size.\n+class VectorMaskWidenNode : public VectorNode {\n+ private:\n+  \/\/ \"_is_lo\" is used to denote whether the lower half or\n+  \/\/ the upper half of the elements are widened.\n+  \/\/ E.g. src = [1111 0101]\n+  \/\/      _is_lo = true, dst = [0001 0001]\n+  \/\/      _is_lo = false, dst = [0101 0101]\n+  bool _is_lo;\n+\n+ public:\n+  VectorMaskWidenNode(Node* in, const TypeVect* vt, bool is_lo) : VectorNode(in, vt), _is_lo(is_lo) {\n+    init_class_id(Class_VectorMaskWiden);\n+    const TypeVect* in_vt = in->bottom_type()->is_vect();\n+    assert(type2aelembytes(in_vt->element_basic_type()) == type2aelembytes(vt->element_basic_type()) \/ 2, \"must be half size\");\n+  }\n+\n+  bool is_lo() const { return _is_lo; }\n+  virtual int Opcode() const;\n+  virtual uint size_of() const { return sizeof(*this); }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2090,0 +2090,2 @@\n+                        [\"ld1b\",     \"__ sve_ld1b_gather(z15, p0, r5, z16);\",              \"ld1b\\t{z15.s}, p0\/z, [x5, z16.s, uxtw]\"],\n+                        [\"ld1h\",     \"__ sve_ld1h_gather(z15, p0, r5, z16);\",              \"ld1h\\t{z15.s}, p0\/z, [x5, z16.s, uxtw #1]\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1103,0 +1103,2 @@\n+    __ sve_ld1b_gather(z15, p0, r5, z16);              \/\/       ld1b    {z15.s}, p0\/z, [x5, z16.s, uxtw]\n+    __ sve_ld1h_gather(z15, p0, r5, z16);              \/\/       ld1h    {z15.s}, p0\/z, [x5, z16.s, uxtw #1]\n@@ -1441,7 +1443,7 @@\n-    0x14000000,     0x17ffffd7,     0x140004b0,     0x94000000,\n-    0x97ffffd4,     0x940004ad,     0x3400000a,     0x34fffa2a,\n-    0x3400954a,     0x35000008,     0x35fff9c8,     0x350094e8,\n-    0xb400000b,     0xb4fff96b,     0xb400948b,     0xb500001d,\n-    0xb5fff91d,     0xb500943d,     0x10000013,     0x10fff8b3,\n-    0x100093d3,     0x90000013,     0x36300016,     0x3637f836,\n-    0x36309356,     0x3758000c,     0x375ff7cc,     0x375892ec,\n+    0x14000000,     0x17ffffd7,     0x140004b2,     0x94000000,\n+    0x97ffffd4,     0x940004af,     0x3400000a,     0x34fffa2a,\n+    0x3400958a,     0x35000008,     0x35fff9c8,     0x35009528,\n+    0xb400000b,     0xb4fff96b,     0xb40094cb,     0xb500001d,\n+    0xb5fff91d,     0xb500947d,     0x10000013,     0x10fff8b3,\n+    0x10009413,     0x90000013,     0x36300016,     0x3637f836,\n+    0x36309396,     0x3758000c,     0x375ff7cc,     0x3758932c,\n@@ -1452,13 +1454,13 @@\n-    0x540090c0,     0x54000001,     0x54fff541,     0x54009061,\n-    0x54000002,     0x54fff4e2,     0x54009002,     0x54000002,\n-    0x54fff482,     0x54008fa2,     0x54000003,     0x54fff423,\n-    0x54008f43,     0x54000003,     0x54fff3c3,     0x54008ee3,\n-    0x54000004,     0x54fff364,     0x54008e84,     0x54000005,\n-    0x54fff305,     0x54008e25,     0x54000006,     0x54fff2a6,\n-    0x54008dc6,     0x54000007,     0x54fff247,     0x54008d67,\n-    0x54000008,     0x54fff1e8,     0x54008d08,     0x54000009,\n-    0x54fff189,     0x54008ca9,     0x5400000a,     0x54fff12a,\n-    0x54008c4a,     0x5400000b,     0x54fff0cb,     0x54008beb,\n-    0x5400000c,     0x54fff06c,     0x54008b8c,     0x5400000d,\n-    0x54fff00d,     0x54008b2d,     0x5400000e,     0x54ffefae,\n-    0x54008ace,     0x5400000f,     0x54ffef4f,     0x54008a6f,\n+    0x54009100,     0x54000001,     0x54fff541,     0x540090a1,\n+    0x54000002,     0x54fff4e2,     0x54009042,     0x54000002,\n+    0x54fff482,     0x54008fe2,     0x54000003,     0x54fff423,\n+    0x54008f83,     0x54000003,     0x54fff3c3,     0x54008f23,\n+    0x54000004,     0x54fff364,     0x54008ec4,     0x54000005,\n+    0x54fff305,     0x54008e65,     0x54000006,     0x54fff2a6,\n+    0x54008e06,     0x54000007,     0x54fff247,     0x54008da7,\n+    0x54000008,     0x54fff1e8,     0x54008d48,     0x54000009,\n+    0x54fff189,     0x54008ce9,     0x5400000a,     0x54fff12a,\n+    0x54008c8a,     0x5400000b,     0x54fff0cb,     0x54008c2b,\n+    0x5400000c,     0x54fff06c,     0x54008bcc,     0x5400000d,\n+    0x54fff00d,     0x54008b6d,     0x5400000e,     0x54ffefae,\n+    0x54008b0e,     0x5400000f,     0x54ffef4f,     0x54008aaf,\n@@ -1671,71 +1673,72 @@\n-    0x0568aca7,     0x05b23230,     0x853040af,     0xc5b040af,\n-    0xe57080af,     0xe5b080af,     0x25034440,     0x254054c4,\n-    0x25034640,     0x25415a05,     0x25834440,     0x25c54489,\n-    0x250b5d3a,     0x2550dc20,     0x2518e3e1,     0x2518e021,\n-    0x2518e0a1,     0x2518e121,     0x2518e1a1,     0x2558e3e2,\n-    0x2558e042,     0x2558e0c2,     0x2558e142,     0x2598e3e3,\n-    0x2598e063,     0x2598e0e3,     0x2598e163,     0x25d8e3e4,\n-    0x25d8e084,     0x25d8e104,     0x25d8e184,     0x2518e407,\n-    0x05214800,     0x05614800,     0x05a14800,     0x05e14800,\n-    0x05214c00,     0x05614c00,     0x05a14c00,     0x05e14c00,\n-    0x05304001,     0x05314001,     0x05a18610,     0x05e18610,\n-    0x05271e11,     0x6545e891,     0x6585e891,     0x65c5e891,\n-    0x6545c891,     0x6585c891,     0x65c5c891,     0x45b0c210,\n-    0x45f1c231,     0x1e601000,     0x1e603000,     0x1e621000,\n-    0x1e623000,     0x1e641000,     0x1e643000,     0x1e661000,\n-    0x1e663000,     0x1e681000,     0x1e683000,     0x1e6a1000,\n-    0x1e6a3000,     0x1e6c1000,     0x1e6c3000,     0x1e6e1000,\n-    0x1e6e3000,     0x1e701000,     0x1e703000,     0x1e721000,\n-    0x1e723000,     0x1e741000,     0x1e743000,     0x1e761000,\n-    0x1e763000,     0x1e781000,     0x1e783000,     0x1e7a1000,\n-    0x1e7a3000,     0x1e7c1000,     0x1e7c3000,     0x1e7e1000,\n-    0x1e7e3000,     0xf8268267,     0xf82d023c,     0xf8301046,\n-    0xf83d2083,     0xf8263290,     0xf82d528c,     0xf8284299,\n-    0xf8337160,     0xf8386286,     0xf8bf820e,     0xf8a600e0,\n-    0xf8af1353,     0xf8a922ea,     0xf8b53396,     0xf8a251e3,\n-    0xf8b340f4,     0xf8a470fd,     0xf8a06209,     0xf8f48097,\n-    0xf8f002ea,     0xf8eb10d9,     0xf8ff21b0,     0xf8f7302c,\n-    0xf8ee52a9,     0xf8f041fa,     0xf8e471e4,     0xf8e863c6,\n-    0xf864823d,     0xf87d013a,     0xf86f1162,     0xf87d20e3,\n-    0xf86132bb,     0xf870510e,     0xf8704336,     0xf86572b4,\n-    0xf8706217,     0xb83e8294,     0xb8200264,     0xb8381284,\n-    0xb8242358,     0xb8333102,     0xb828530e,     0xb83042df,\n-    0xb824703f,     0xb82a6194,     0xb8a080e9,     0xb8b80090,\n-    0xb8bb1146,     0xb8bb21b8,     0xb8b032df,     0xb8b653f4,\n-    0xb8bd41c9,     0xb8b47287,     0xb8bc6169,     0xb8ee828c,\n-    0xb8e10138,     0xb8f3126d,     0xb8f020b0,     0xb8e03183,\n-    0xb8e851ef,     0xb8f041e4,     0xb8fe7005,     0xb8ea6376,\n-    0xb8638120,     0xb873015d,     0xb8781284,     0xb86723b8,\n-    0xb86e3175,     0xb87b51ed,     0xb87f41d1,     0xb863721e,\n-    0xb87660f4,     0xce216874,     0xce104533,     0xce648c15,\n-    0xce8e3302,     0xce6e82ab,     0xce6c87d1,     0xcec08063,\n-    0xce638937,     0x25e0c358,     0x25a1c7d3,     0x0580785a,\n-    0x05426328,     0x05009892,     0x25a0cc29,     0x2561cec8,\n-    0x058044b3,     0x05401c99,     0x05006b49,     0x25e0d6f7,\n-    0x2561c528,     0x0583c8bc,     0x0542522f,     0x05001ec0,\n-    0x25e0de65,     0x25a1c113,     0x05803cad,     0x0540f3c0,\n-    0x0500ab15,     0x2560c28c,     0x2561d7c0,     0x05801ed7,\n-    0x0542633b,     0x05003696,     0x2560d4b4,     0x25e1c918,\n-    0x058021ff,     0x05400e15,     0x0500f3de,     0x0473025a,\n-    0x04bd05ab,     0x658e0025,     0x658a08e2,     0x659a0493,\n-    0x043e1062,     0x04f418b4,     0x046d15bd,     0x04611fce,\n-    0x04d6a07c,     0x04001929,     0x041a09da,     0x04d098f4,\n-    0x04db10d4,     0x0459a3ad,     0x041aa029,     0x041919fb,\n-    0x04d39e24,     0x04118302,     0x04101dba,     0x04d7ae16,\n-    0x04dea571,     0x04180210,     0x05e786fc,     0x05e4915c,\n-    0x04881cf1,     0x044a0f04,     0x04090969,     0x048b16c4,\n-    0x044101e4,     0x04dcbf44,     0x65809745,     0x658d833f,\n-    0x65c68468,     0x65c79b07,     0x65829e38,     0x049dafca,\n-    0x6582bba8,     0x65c0b7ff,     0x65c1b4e0,     0x658dbadd,\n-    0x65819a9d,     0x65ed9246,     0x65b30815,     0x65e6263c,\n-    0x65eebb94,     0x65bad14e,     0x65efe178,     0x65fc5697,\n-    0x65e07f14,     0x040c55a6,     0x04977f4d,     0x043d3046,\n-    0x04b733a0,     0x046830a4,     0x04ed322d,     0x05686948,\n-    0x05bd6c13,     0x65c88ef0,     0x450db3d7,     0x4540b6d9,\n-    0x043e3979,     0x445896ce,     0x445a9005,     0x44d98069,\n-    0x445b87ae,     0x04da348e,     0x04982edb,     0x0499397f,\n-    0x0408338c,     0x04ca309c,     0x65c721e6,     0x65c63641,\n-    0x65982882,     0x04812b8b,     0x0e251083,     0x4e3712d5,\n-    0x0e61101f,     0x4e6d118b,     0x0eba1338,     0x4eb712d5,\n-    0x2e31120f,     0x6e2e11ac,     0x2e6810e6,     0x6e6f11cd,\n-    0x2eaa1128,     0x6eb1120f,\n+    0x0568aca7,     0x05b23230,     0x841040af,     0x84b040af,\n+    0x853040af,     0xc5b040af,     0xe57080af,     0xe5b080af,\n+    0x25034440,     0x254054c4,     0x25034640,     0x25415a05,\n+    0x25834440,     0x25c54489,     0x250b5d3a,     0x2550dc20,\n+    0x2518e3e1,     0x2518e021,     0x2518e0a1,     0x2518e121,\n+    0x2518e1a1,     0x2558e3e2,     0x2558e042,     0x2558e0c2,\n+    0x2558e142,     0x2598e3e3,     0x2598e063,     0x2598e0e3,\n+    0x2598e163,     0x25d8e3e4,     0x25d8e084,     0x25d8e104,\n+    0x25d8e184,     0x2518e407,     0x05214800,     0x05614800,\n+    0x05a14800,     0x05e14800,     0x05214c00,     0x05614c00,\n+    0x05a14c00,     0x05e14c00,     0x05304001,     0x05314001,\n+    0x05a18610,     0x05e18610,     0x05271e11,     0x6545e891,\n+    0x6585e891,     0x65c5e891,     0x6545c891,     0x6585c891,\n+    0x65c5c891,     0x45b0c210,     0x45f1c231,     0x1e601000,\n+    0x1e603000,     0x1e621000,     0x1e623000,     0x1e641000,\n+    0x1e643000,     0x1e661000,     0x1e663000,     0x1e681000,\n+    0x1e683000,     0x1e6a1000,     0x1e6a3000,     0x1e6c1000,\n+    0x1e6c3000,     0x1e6e1000,     0x1e6e3000,     0x1e701000,\n+    0x1e703000,     0x1e721000,     0x1e723000,     0x1e741000,\n+    0x1e743000,     0x1e761000,     0x1e763000,     0x1e781000,\n+    0x1e783000,     0x1e7a1000,     0x1e7a3000,     0x1e7c1000,\n+    0x1e7c3000,     0x1e7e1000,     0x1e7e3000,     0xf8268267,\n+    0xf82d023c,     0xf8301046,     0xf83d2083,     0xf8263290,\n+    0xf82d528c,     0xf8284299,     0xf8337160,     0xf8386286,\n+    0xf8bf820e,     0xf8a600e0,     0xf8af1353,     0xf8a922ea,\n+    0xf8b53396,     0xf8a251e3,     0xf8b340f4,     0xf8a470fd,\n+    0xf8a06209,     0xf8f48097,     0xf8f002ea,     0xf8eb10d9,\n+    0xf8ff21b0,     0xf8f7302c,     0xf8ee52a9,     0xf8f041fa,\n+    0xf8e471e4,     0xf8e863c6,     0xf864823d,     0xf87d013a,\n+    0xf86f1162,     0xf87d20e3,     0xf86132bb,     0xf870510e,\n+    0xf8704336,     0xf86572b4,     0xf8706217,     0xb83e8294,\n+    0xb8200264,     0xb8381284,     0xb8242358,     0xb8333102,\n+    0xb828530e,     0xb83042df,     0xb824703f,     0xb82a6194,\n+    0xb8a080e9,     0xb8b80090,     0xb8bb1146,     0xb8bb21b8,\n+    0xb8b032df,     0xb8b653f4,     0xb8bd41c9,     0xb8b47287,\n+    0xb8bc6169,     0xb8ee828c,     0xb8e10138,     0xb8f3126d,\n+    0xb8f020b0,     0xb8e03183,     0xb8e851ef,     0xb8f041e4,\n+    0xb8fe7005,     0xb8ea6376,     0xb8638120,     0xb873015d,\n+    0xb8781284,     0xb86723b8,     0xb86e3175,     0xb87b51ed,\n+    0xb87f41d1,     0xb863721e,     0xb87660f4,     0xce216874,\n+    0xce104533,     0xce648c15,     0xce8e3302,     0xce6e82ab,\n+    0xce6c87d1,     0xcec08063,     0xce638937,     0x25e0c358,\n+    0x25a1c7d3,     0x0580785a,     0x05426328,     0x05009892,\n+    0x25a0cc29,     0x2561cec8,     0x058044b3,     0x05401c99,\n+    0x05006b49,     0x25e0d6f7,     0x2561c528,     0x0583c8bc,\n+    0x0542522f,     0x05001ec0,     0x25e0de65,     0x25a1c113,\n+    0x05803cad,     0x0540f3c0,     0x0500ab15,     0x2560c28c,\n+    0x2561d7c0,     0x05801ed7,     0x0542633b,     0x05003696,\n+    0x2560d4b4,     0x25e1c918,     0x058021ff,     0x05400e15,\n+    0x0500f3de,     0x0473025a,     0x04bd05ab,     0x658e0025,\n+    0x658a08e2,     0x659a0493,     0x043e1062,     0x04f418b4,\n+    0x046d15bd,     0x04611fce,     0x04d6a07c,     0x04001929,\n+    0x041a09da,     0x04d098f4,     0x04db10d4,     0x0459a3ad,\n+    0x041aa029,     0x041919fb,     0x04d39e24,     0x04118302,\n+    0x04101dba,     0x04d7ae16,     0x04dea571,     0x04180210,\n+    0x05e786fc,     0x05e4915c,     0x04881cf1,     0x044a0f04,\n+    0x04090969,     0x048b16c4,     0x044101e4,     0x04dcbf44,\n+    0x65809745,     0x658d833f,     0x65c68468,     0x65c79b07,\n+    0x65829e38,     0x049dafca,     0x6582bba8,     0x65c0b7ff,\n+    0x65c1b4e0,     0x658dbadd,     0x65819a9d,     0x65ed9246,\n+    0x65b30815,     0x65e6263c,     0x65eebb94,     0x65bad14e,\n+    0x65efe178,     0x65fc5697,     0x65e07f14,     0x040c55a6,\n+    0x04977f4d,     0x043d3046,     0x04b733a0,     0x046830a4,\n+    0x04ed322d,     0x05686948,     0x05bd6c13,     0x65c88ef0,\n+    0x450db3d7,     0x4540b6d9,     0x043e3979,     0x445896ce,\n+    0x445a9005,     0x44d98069,     0x445b87ae,     0x04da348e,\n+    0x04982edb,     0x0499397f,     0x0408338c,     0x04ca309c,\n+    0x65c721e6,     0x65c63641,     0x65982882,     0x04812b8b,\n+    0x0e251083,     0x4e3712d5,     0x0e61101f,     0x4e6d118b,\n+    0x0eba1338,     0x4eb712d5,     0x2e31120f,     0x6e2e11ac,\n+    0x2e6810e6,     0x6e6f11cd,     0x2eaa1128,     0x6eb1120f,\n+\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":94,"deletions":91,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.generators.*;\n+import compiler.lib.ir_framework.*;\n+import jdk.incubator.vector.*;\n+import jdk.test.lib.Asserts;\n+\n+\/**\n+ * @test\n+ * @bug 8351623\n+ * @summary VectorAPI: Add SVE implementation for subword gather load operation\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run driver compiler.vectorapi.VectorGatherSubwordTest\n+ *\/\n+public class VectorGatherSubwordTest {\n+    private static final VectorSpecies<Byte> B_SPECIES = ByteVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Short> S_SPECIES = ShortVector.SPECIES_PREFERRED;\n+\n+    private static int LENGTH = 128;\n+    private static final Generators random = Generators.G;\n+\n+    private static byte[] ba;\n+    private static byte[] br;\n+    private static short[] sa;\n+    private static short[] sr;\n+    private static boolean[] m;\n+    private static int[][] indexes;\n+\n+    static {\n+        ba = new byte[LENGTH];\n+        br = new byte[LENGTH];\n+        sa = new short[LENGTH];\n+        sr = new short[LENGTH];\n+        m = new boolean[LENGTH];\n+        indexes = new int[2][];\n+\n+        Generator<Integer> byteGen = random.uniformInts(Byte.MIN_VALUE, Byte.MAX_VALUE);\n+        Generator<Integer> shortGen = random.uniformInts(Short.MIN_VALUE, Short.MAX_VALUE);\n+        for (int i = 0; i < LENGTH; i++) {\n+            ba[i] = byteGen.next().byteValue();\n+            sa[i] = shortGen.next().shortValue();\n+            m[i] = i % 2 == 0;\n+        }\n+\n+        int[] nums = {B_SPECIES.length(), S_SPECIES.length()};\n+        for (int i = 0; i < 2; i++) {\n+            indexes[i] = new int[nums[i]];\n+            random.fill(random.uniformInts(0, nums[i] - 1), indexes[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_GATHER, \" >0 \"}, applyIfCPUFeature = {\"sve\", \"true\"})\n+    public void testLoadGatherByte() {\n+        for (int i = 0; i < LENGTH; i += B_SPECIES.length()) {\n+            ByteVector.fromArray(B_SPECIES, ba, i, indexes[0], 0)\n+                      .intoArray(br, i);\n+        }\n+    }\n+\n+    @Check(test = \"testLoadGatherByte\")\n+    public void verifyLoadGatherByte() {\n+        for (int i = 0; i < LENGTH; i += B_SPECIES.length()) {\n+            for (int j = 0; j < B_SPECIES.length(); j++) {\n+                Asserts.assertEquals(ba[i + indexes[0][j]], br[i + j]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_GATHER, \" >0 \"}, applyIfCPUFeature = {\"sve\", \"true\"})\n+    public void testLoadGatherShort() {\n+        for (int i = 0; i < LENGTH; i += S_SPECIES.length()) {\n+            ShortVector.fromArray(S_SPECIES, sa, i, indexes[1], 0)\n+                       .intoArray(sr, i);\n+        }\n+    }\n+\n+    @Check(test = \"testLoadGatherShort\")\n+    public void verifyLoadGatherShort() {\n+        for (int i = 0; i < LENGTH; i += S_SPECIES.length()) {\n+            for (int j = 0; j < S_SPECIES.length(); j++) {\n+                Asserts.assertEquals(sa[i + indexes[1][j]], sr[i + j]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_GATHER_MASKED, \" >0 \"}, applyIfCPUFeature = {\"sve\", \"true\"})\n+    public void testLoadGatherMaskedByte() {\n+        VectorMask<Byte> mask = VectorMask.fromArray(B_SPECIES, m, 0);\n+        for (int i = 0; i < LENGTH; i += B_SPECIES.length()) {\n+            ByteVector.fromArray(B_SPECIES, ba, i, indexes[0], 0, mask)\n+                      .intoArray(br, i);\n+        }\n+    }\n+\n+    @Check(test = \"testLoadGatherMaskedByte\")\n+    public void verifyLoadGatherMaskedByte() {\n+        for (int i = 0; i < LENGTH; i += B_SPECIES.length()) {\n+            for (int j = 0; j < B_SPECIES.length(); j++) {\n+                Asserts.assertEquals(m[j] ? ba[i + indexes[0][j]] : 0, br[i + j]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_GATHER_MASKED, \" >0 \"}, applyIfCPUFeature = {\"sve\", \"true\"})\n+    public void testLoadGatherMaskedShort() {\n+        VectorMask<Short> mask = VectorMask.fromArray(S_SPECIES, m, 0);\n+        for (int i = 0; i < LENGTH; i += S_SPECIES.length()) {\n+            ShortVector.fromArray(S_SPECIES, sa, i, indexes[1], 0, mask)\n+                       .intoArray(sr, i);\n+        }\n+    }\n+\n+    @Check(test = \"testLoadGatherMaskedShort\")\n+    public void verifyLoadGatherMaskedShort() {\n+        for (int i = 0; i < LENGTH; i += S_SPECIES.length()) {\n+            for (int j = 0; j < S_SPECIES.length(); j++) {\n+                Asserts.assertEquals(m[j] ? sa[i + indexes[1][j]] : 0, sr[i + j]);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.setDefaultWarmup(5000)\n+                     .addFlags(\"--add-modules=jdk.incubator.vector\")\n+                     .start();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorGatherSubwordTest.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"}]}