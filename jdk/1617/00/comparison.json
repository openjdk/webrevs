{"files":[{"patch":"@@ -578,4 +578,10 @@\n-     * The maximum length of array to allocate (unless necessary).\n-     * Some VMs reserve some header words in an array.\n-     * Attempts to allocate larger arrays may result in\n-     * {@code OutOfMemoryError: Requested array size exceeds VM limit}\n+     * A soft maximum array length imposed by array growth computations.\n+     * Some JVMs (such as Hotspot) have an implementation limit that will cause\n+     *\n+     *     OutOfMemoryError(\"Requested array size exceeds VM limit\")\n+     *\n+     * to be thrown if a request is made to allocate an array of some length near\n+     * Integer.MAX_VALUE, even if there is sufficient heap available. The actual\n+     * limit might depend on some JVM implementation-specific characteristics such\n+     * as the object header size. The soft maximum value is chosen conservatively so\n+     * as to be smaller than any implementation limit that is likely to be encountered.\n@@ -583,1 +589,1 @@\n-    public static final int MAX_ARRAY_LENGTH = Integer.MAX_VALUE - 8;\n+    public static final int SOFT_MAX_ARRAY_LENGTH = Integer.MAX_VALUE - 8;\n@@ -586,9 +592,17 @@\n-     * Calculates a new array length given an array's current length, a preferred\n-     * growth value, and a minimum growth value.  If the preferred growth value\n-     * is less than the minimum growth value, the minimum growth value is used in\n-     * its place.  If the sum of the current length and the preferred growth\n-     * value does not exceed {@link #MAX_ARRAY_LENGTH}, that sum is returned.\n-     * If the sum of the current length and the minimum growth value does not\n-     * exceed {@code MAX_ARRAY_LENGTH}, then {@code MAX_ARRAY_LENGTH} is returned.\n-     * If the sum does not overflow an int, then {@code Integer.MAX_VALUE} is\n-     * returned.  Otherwise, {@code OutOfMemoryError} is thrown.\n+     * Computes a new array length given an array's current length, a minimum growth\n+     * amount, and a preferred growth amount. The computation is done in an overflow-safe\n+     * fashion.\n+     *\n+     * This method is used by objects that contain an array that might need to be grown\n+     * in order to fulfill some immediate need (the minimum growth amount) but would also\n+     * like to request more space (the preferred growth amount) in order to accommodate\n+     * potential future needs. The returned length is usually clamped at the soft maximum\n+     * length in order to avoid hitting the JVM implementation limit. However, the soft\n+     * maximum will be exceeded if the minimum growth amount requires it.\n+     *\n+     * If the preferred growth amount is less than the minimum growth amount, the\n+     * minimum growth amount is used as the preferred growth amount.\n+     *\n+     * The preferred length is determined by adding the preferred growth amount to the\n+     * current length. If the preferred length does not exceed the soft maximum length\n+     * (SOFT_MAX_ARRAY_LENGTH) then the preferred length is returned.\n@@ -596,5 +610,21 @@\n-     * @param oldLength   current length of the array (must be non negative)\n-     * @param minGrowth   minimum required growth of the array length (must be\n-     *                    positive)\n-     * @param prefGrowth  preferred growth of the array length (ignored, if less\n-     *                    then {@code minGrowth})\n+     * Since the preferred length exceeds the soft maximum, we use the minimum growth\n+     * amount. The minimum required length is determined by adding the minimum growth\n+     * amount to the current length. If the minimum required length is less than the\n+     * soft maximum, the soft maximum is returned. If the minimum required length is\n+     * greater than the soft maximum but does not exceed Integer.MAX_VALUE, the minimum\n+     * required length is returned. Otherwise, the minimum required length exceeds\n+     * Integer.MAX_VALUE, which can never be fulfilled, so this method throws OutOfMemoryError.\n+     *\n+     * Note that this method does not do any array allocation itself; it only does array\n+     * length growth computations. However, it will throw OutOfMemoryError as noted above.\n+     *\n+     * Note also that this method cannot detect the JVM's implementation limit, and it\n+     * may compute and return a length value up to and including Integer.MAX_VALUE that\n+     * might exceed the JVM's implementation limit. In that case, the caller will likely\n+     * attempt an array allocation with that length and encounter an OutOfMemoryError.\n+     * Of course, regardless of the length value returned from this method, the caller\n+     * may encounter OutOfMemoryError if there is insufficient heap to fufill the request.\n+     *\n+     * @param oldLength   current length of the array (must be nonnegative)\n+     * @param minGrowth   minimum required growth amount (must be positive)\n+     * @param prefGrowth  preferred growth amount\n@@ -602,2 +632,1 @@\n-     * @throws OutOfMemoryError if increasing {@code oldLength} by\n-     *                    {@code minGrowth} overflows.\n+     * @throws OutOfMemoryError if the new length would exceed Integer.MAX_VALUE\n@@ -609,3 +638,5 @@\n-        int newLength = Math.max(minGrowth, prefGrowth) + oldLength;\n-        if (newLength - MAX_ARRAY_LENGTH <= 0) {\n-            return newLength;\n+        int prefLength = oldLength + Math.max(minGrowth, prefGrowth); \/\/ might overflow\n+        if (0 < prefLength && prefLength <= SOFT_MAX_ARRAY_LENGTH) {\n+            return prefLength;\n+        } else {\n+            return hugeLength(oldLength, minGrowth);\n@@ -613,1 +644,0 @@\n-        return hugeLength(oldLength, minGrowth);\n@@ -619,4 +649,6 @@\n-            throw new OutOfMemoryError(\"Required array length too large\");\n-        }\n-        if (minLength <= MAX_ARRAY_LENGTH) {\n-            return MAX_ARRAY_LENGTH;\n+            throw new OutOfMemoryError(\n+                \"Required array length \" + oldLength + \" + \" + minGrowth + \" is too large\");\n+        } else if (minLength <= SOFT_MAX_ARRAY_LENGTH) {\n+            return SOFT_MAX_ARRAY_LENGTH;\n+        } else {\n+            return minLength;\n@@ -624,1 +656,0 @@\n-        return Integer.MAX_VALUE;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ArraysSupport.java","additions":61,"deletions":30,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import static jdk.internal.util.ArraysSupport.MAX_ARRAY_LENGTH;\n+import static jdk.internal.util.ArraysSupport.SOFT_MAX_ARRAY_LENGTH;\n@@ -175,1 +175,1 @@\n-        String maxString = \"*\".repeat(MAX_ARRAY_LENGTH);\n+        String maxString = \"*\".repeat(SOFT_MAX_ARRAY_LENGTH);\n","filename":"test\/jdk\/java\/util\/StringJoiner\/MergeTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import static jdk.internal.util.ArraysSupport.MAX_ARRAY_LENGTH;\n+import static jdk.internal.util.ArraysSupport.SOFT_MAX_ARRAY_LENGTH;\n@@ -52,1 +52,1 @@\n-    private static final String MAX_STRING = \"*\".repeat(MAX_ARRAY_LENGTH);\n+    private static final String MAX_STRING = \"*\".repeat(SOFT_MAX_ARRAY_LENGTH);\n","filename":"test\/jdk\/java\/util\/StringJoiner\/StringJoinerTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8247373\n+ * @modules java.base\/jdk.internal.util\n+ * @run testng NewLength\n+ * @summary Test edge cases of ArraysSupport.newLength\n+ *\/\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.fail;\n+\n+import jdk.internal.util.ArraysSupport;\n+\n+public class NewLength {\n+    static final int IMAX = Integer.MAX_VALUE;\n+    static final int SOFT = ArraysSupport.SOFT_MAX_ARRAY_LENGTH;\n+\n+    \/\/ Data that is expected to return a valid value.\n+\n+    @DataProvider(name = \"valid\")\n+    public Object[][] validProvider() {\n+        return new Object[][] {\n+           \/\/ old     min     pref    expected\n+            { 0,      1,      2,      2      },\n+            { 0,      2,      1,      2      },\n+            { 0,      1,      SOFT-1, SOFT-1 },\n+            { 0,      1,      SOFT,   SOFT   },\n+            { 0,      1,      SOFT+1, SOFT   },\n+            { 0,      1,      IMAX,   SOFT   },\n+            { 0,      SOFT-1, IMAX,   SOFT   },\n+            { 0,      SOFT,   IMAX,   SOFT   },\n+            { 0,      SOFT+1, IMAX,   SOFT+1 },\n+            { SOFT-2, 1,      2,      SOFT   },\n+            { SOFT-1, 1,      2,      SOFT   },\n+            { SOFT,   1,      2,      SOFT+1 },\n+            { SOFT+1, 1,      2,      SOFT+2 },\n+            { IMAX-2, 1,      2,      IMAX-1 },\n+            { IMAX-1, 1,      2,      IMAX   },\n+            { SOFT-2, 1,      IMAX,   SOFT   },\n+            { SOFT-1, 1,      IMAX,   SOFT   },\n+            { SOFT,   1,      IMAX,   SOFT+1 },\n+            { SOFT+1, 1,      IMAX,   SOFT+2 },\n+            { IMAX-2, 1,      IMAX,   IMAX-1 },\n+            { IMAX-1, 1,      IMAX,   IMAX   }\n+        };\n+    }\n+\n+    \/\/ Data that should provoke an OutOfMemoryError\n+\n+    @DataProvider(name = \"error\")\n+    public Object[][] errorProvider() {\n+        return new Object[][] {\n+            \/\/ old    min   pref\n+            {    1,   IMAX, IMAX },\n+            { SOFT,   IMAX, 0    },\n+            { SOFT,   IMAX, IMAX },\n+            { IMAX-1,    2, 0    },\n+            { IMAX,      1, 0    },\n+            { IMAX,   IMAX, 0    },\n+            { IMAX,   IMAX, IMAX }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"valid\")\n+    public void valid(int old, int min, int pref, int expected) {\n+        assertEquals(ArraysSupport.newLength(old, min, pref), expected);\n+    }\n+\n+    @Test(dataProvider = \"error\")\n+    public void error(int old, int min, int pref) {\n+        try {\n+            int r = ArraysSupport.newLength(old, min, pref);\n+            fail(\"expected OutOfMemoryError, got normal return value of \" + r);\n+        } catch (OutOfMemoryError oome) {\n+            \/\/ ok\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/internal\/util\/ArraysSupport\/NewLength.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"}]}