{"files":[{"patch":"@@ -2095,0 +2095,1 @@\n+Op_IL(Or)\n@@ -2106,0 +2107,2 @@\n+Op_IL(Max)\n+Op_IL(Min)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1544,0 +1544,72 @@\n+\/\/ For comparisons of the form op(a, b) < 0 or op(a, b) >= 0,\n+\/\/ it might be enough to compare a < 0 or a >= 0 (or b < 0 or b >= 0) instead.\n+\/\/ As a special case, xor requires negating the test\n+\/\/ if one argument is known to be negative: -1 ^ b < 0 <==> b >= 0\n+\/\/ but not if it is known to be nonnegative: 0 ^ b < 0 <==> b <  0\n+static Node* simplify_sign_invariant_comparison_input(PhaseGVN* phase, BoolNode* bool_node) {\n+  Node* cmp = bool_node->in(1);\n+  int cop = cmp->Opcode();\n+  if (cop != Op_CmpI && cop != Op_CmpL) {\n+    return nullptr;\n+  }\n+  BasicType bt = cop == Op_CmpI ? T_INT : T_LONG;\n+  Node* in_op = cmp->in(1);\n+  int in_opc = in_op->Opcode();\n+  if (in_opc != Op_And(bt) && in_opc != Op_Or(bt) && in_opc != Op_Xor(bt) &&\n+      in_opc != Op_Max(bt) && in_opc != Op_Min(bt)) {\n+    return nullptr;\n+  }\n+  Node* lhs = in_op->in(1);\n+  Node* rhs = in_op->in(2);\n+  const TypeInteger* lhs_type = phase->type(in_op->in(1))->isa_integer(bt);\n+  const TypeInteger* rhs_type = phase->type(in_op->in(2))->isa_integer(bt);\n+  if (lhs_type == nullptr || rhs_type == nullptr) {\n+    return nullptr;\n+  }\n+  Node* replacement = nullptr;\n+  bool negate_test = false;\n+  if (in_opc == Op_And(bt) || in_opc == Op_Max(bt)) {\n+    \/\/ x & y >= 0 is true for x < 0 iff y >= 0\n+    \/\/ max(x, y) >= 0 is true for x < 0 iff y >= 0\n+    if (lhs_type->hi_as_long() < 0) {\n+      replacement = rhs;\n+    } else if (rhs_type->hi_as_long() < 0) {\n+      replacement = lhs;\n+    }\n+  } else if (in_opc == Op_Or(bt) || in_opc == Op_Min(bt)) {\n+    \/\/ x | y >= 0 is true for x >= 0 iff y >= 0\n+    \/\/ min(x, y) >= 0 is true for x >= 0 iff y >= 0\n+    if (lhs_type->lo_as_long() >= 0) {\n+      replacement = rhs;\n+    } else if (rhs_type->lo_as_long() >= 0) {\n+      replacement = lhs;\n+    }\n+  } else if (in_opc == Op_Xor(bt)) {\n+    \/\/ x ^ y >= 0 is true for x >= 0 iff y >= 0\n+    \/\/ x ^ y >= 0 is true for x <  0 iff y <  0 (need to negate test)\n+    if (lhs_type->lo_as_long() >= 0) {\n+      replacement = rhs;\n+    } else if (rhs_type->lo_as_long() >= 0) {\n+      replacement = lhs;\n+    } else if (lhs_type->hi_as_long() < 0) {\n+      replacement = rhs;\n+      negate_test = true;\n+    } else if (rhs_type->hi_as_long() < 0) {\n+      replacement = lhs;\n+      negate_test = true;\n+    }\n+  } else {\n+    assert(false, \"unexpected opcode: %s\", in_op->Name());\n+  }\n+\n+  if (replacement != nullptr) {\n+    Node* new_cmp = cmp->clone();\n+    new_cmp->set_req(1, replacement);\n+    new_cmp->set_req(2, cmp->in(2));\n+    new_cmp = phase->transform(new_cmp);\n+    BoolTest new_test = negate_test ? bool_node->_test.negate() : bool_node->_test;\n+    return new BoolNode(new_cmp, new_test._test);\n+  }\n+  return nullptr; \/\/ no change\n+}\n+\n@@ -1586,0 +1658,8 @@\n+  if ((_test._test == BoolTest::lt || _test._test == BoolTest::ge) &&\n+    (cmp2->find_int_con(1) == 0 || cmp2->find_long_con(1) == 0)) {\n+    Node* result = simplify_sign_invariant_comparison_input(phase, this);\n+    if (result != nullptr) {\n+      return result;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -0,0 +1,757 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.gvn;\n+\n+import compiler.lib.generators.Generator;\n+import compiler.lib.generators.Generators;\n+import compiler.lib.generators.RestrictableGenerator;\n+import compiler.lib.ir_framework.DontCompile;\n+import compiler.lib.ir_framework.ForceInline;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.Run;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.TestFramework;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8373555\n+ * @summary Test that sign-invariant comparisons are simplified.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.gvn.BoolNodeSimplifySignInvariantTests\n+ *\/\n+public class BoolNodeSimplifySignInvariantTests {\n+    private static final RestrictableGenerator<Integer> GEN_INT = Generators.G.ints();\n+    private static final RestrictableGenerator<Long> GEN_LONG = Generators.G.longs();\n+\n+    private static final int LO_POS_I;\n+    private static final int HI_POS_I;\n+    private static final int LO_NEG_I;\n+    private static final int HI_NEG_I;\n+    private static final long LO_POS_L;\n+    private static final long HI_POS_L;\n+    private static final long LO_NEG_L;\n+    private static final long HI_NEG_L;\n+\n+    static {\n+        RestrictableGenerator<Integer> posI = GEN_INT.restricted(0, Integer.MAX_VALUE);\n+        int pos1i = posI.next();\n+        int pos2i = posI.next();\n+        LO_POS_I = Math.min(pos1i, pos2i);\n+        HI_POS_I = Math.max(pos1i, pos2i);\n+        RestrictableGenerator<Integer> negI = GEN_INT.restricted(Integer.MIN_VALUE, -1);\n+        int neg1i = negI.next();\n+        int neg2i = negI.next();\n+        LO_NEG_I = Math.min(neg1i, neg2i);\n+        HI_NEG_I = Math.max(neg1i, neg2i);\n+        RestrictableGenerator<Long> posL = GEN_LONG.restricted(0L, Long.MAX_VALUE);\n+        long pos1l = posL.next();\n+        long pos2l = posL.next();\n+        LO_POS_L = Math.min(pos1l, pos2l);\n+        HI_POS_L = Math.max(pos1l, pos2l);\n+        RestrictableGenerator<Long> negL = GEN_LONG.restricted(Long.MIN_VALUE, -1L);\n+        long neg1l = negL.next();\n+        long neg2l = negL.next();\n+        LO_NEG_L = Math.min(neg1l, neg2l);\n+        HI_NEG_L = Math.max(neg1l, neg2l);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\n+        \"knownAndInputInt1\", \"knownAndInputInt2\", \"knownAndInputInt3\", \"knownAndInputInt4\",\n+        \"knownMaxInputInt1\", \"knownMaxInputInt2\", \"knownMaxInputInt3\", \"knownMaxInputInt4\",\n+        \"knownOrInputInt1\", \"knownOrInputInt2\", \"knownOrInputInt3\", \"knownOrInputInt4\",\n+        \"knownMinInputInt1\", \"knownMinInputInt2\", \"knownMinInputInt3\", \"knownMinInputInt4\",\n+        \"knownXorInputInt1\", \"knownXorInputInt2\", \"knownXorInputInt3\", \"knownXorInputInt4\",\n+        \"knownXorInputInt5\", \"knownXorInputInt6\", \"knownXorInputInt7\", \"knownXorInputInt8\",\n+        \"knownAndInputLong1\", \"knownAndInputLong2\", \"knownAndInputLong3\", \"knownAndInputLong4\",\n+        \"knownMaxInputLong1\", \"knownMaxInputLong2\", \"knownMaxInputLong3\", \"knownMaxInputLong4\",\n+        \"knownOrInputLong1\", \"knownOrInputLong2\", \"knownOrInputLong3\", \"knownOrInputLong4\",\n+        \"knownMinInputLong1\", \"knownMinInputLong2\", \"knownMinInputLong3\", \"knownMinInputLong4\",\n+        \"knownXorInputLong1\", \"knownXorInputLong2\", \"knownXorInputLong3\", \"knownXorInputLong4\",\n+        \"knownXorInputLong5\", \"knownXorInputLong6\", \"knownXorInputLong7\", \"knownXorInputLong8\",\n+\n+        \"testRandomRangeAndInt1\", \"testRandomRangeAndInt2\", \"testRandomRangeAndLong1\", \"testRandomRangeAndLong2\",\n+        \"testRandomRangeOrInt1\", \"testRandomRangeOrInt2\", \"testRandomRangeOrLong1\", \"testRandomRangeOrLong2\",\n+        \"testRandomRangeXorInt1\", \"testRandomRangeXorInt2\", \"testRandomRangeXorLong1\", \"testRandomRangeXorLong2\",\n+        \"testRandomRangeMaxInt1\", \"testRandomRangeMaxInt2\", \"testRandomRangeMaxLong1\", \"testRandomRangeMaxLong2\",\n+        \"testRandomRangeMinInt1\", \"testRandomRangeMinInt2\", \"testRandomRangeMinLong1\", \"testRandomRangeMinLong2\",\n+    })\n+    public void runMethod() {\n+        assertResultI();\n+        assertResultL();\n+    }\n+\n+    @DontCompile\n+    private void assertResultI() {\n+        int a = GEN_INT.next();\n+        int b = GEN_INT.next();\n+        int aNeg = Math.min(HI_NEG_I, Math.max(LO_NEG_I, a));\n+        int bNeg = Math.min(HI_NEG_I, Math.max(LO_NEG_I, b));\n+        int aPos = Math.min(HI_POS_I, Math.max(LO_POS_I, a));\n+        int bPos = Math.min(HI_POS_I, Math.max(LO_POS_I, b));\n+\n+        Asserts.assertEQ((a & bNeg) < 0, knownAndInputInt1(a, b));\n+        Asserts.assertEQ((aNeg & b) < 0, knownAndInputInt2(a, b));\n+        Asserts.assertEQ((a & bNeg) >= 0, knownAndInputInt3(a, b));\n+        Asserts.assertEQ((aNeg & b) >= 0, knownAndInputInt4(a, b));\n+\n+        Asserts.assertEQ(Math.max(a, bNeg) < 0, knownMaxInputInt1(a, b));\n+        Asserts.assertEQ(Math.max(aNeg, b) < 0, knownMaxInputInt2(a, b));\n+        Asserts.assertEQ(Math.max(a, bNeg) >= 0, knownMaxInputInt3(a, b));\n+        Asserts.assertEQ(Math.max(aNeg, b) >= 0, knownMaxInputInt4(a, b));\n+\n+        Asserts.assertEQ((a | bPos) < 0, knownOrInputInt1(a, b));\n+        Asserts.assertEQ((aPos | b) < 0, knownOrInputInt2(a, b));\n+        Asserts.assertEQ((a | bPos) >= 0, knownOrInputInt3(a, b));\n+        Asserts.assertEQ((aPos | b) >= 0, knownOrInputInt4(a, b));\n+\n+        Asserts.assertEQ(Math.min(a, bPos) < 0, knownMinInputInt1(a, b));\n+        Asserts.assertEQ(Math.min(aPos, b) < 0, knownMinInputInt2(a, b));\n+        Asserts.assertEQ(Math.min(a, bPos) >= 0, knownMinInputInt3(a, b));\n+        Asserts.assertEQ(Math.min(aPos, b) >= 0, knownMinInputInt4(a, b));\n+\n+        Asserts.assertEQ((a ^ bNeg) < 0, knownXorInputInt1(a, b));\n+        Asserts.assertEQ((aNeg ^ b) < 0, knownXorInputInt2(a, b));\n+        Asserts.assertEQ((a ^ bNeg) >= 0, knownXorInputInt3(a, b));\n+        Asserts.assertEQ((aNeg ^ b) >= 0, knownXorInputInt4(a, b));\n+        Asserts.assertEQ((a ^ bPos) < 0, knownXorInputInt5(a, b));\n+        Asserts.assertEQ((aPos ^ b) < 0, knownXorInputInt6(a, b));\n+        Asserts.assertEQ((a ^ bPos) >= 0, knownXorInputInt7(a, b));\n+        Asserts.assertEQ((aPos ^ b) >= 0, knownXorInputInt8(a, b));\n+\n+        for (int i = 0; i < 10; i++) {\n+            int ia = GEN_INT.next();\n+            int ib = GEN_INT.next();\n+            Asserts.assertEQ(testRandomRangeAndInt1Interpreted(ia, ib), testRandomRangeAndInt1(ia, ib));\n+            Asserts.assertEQ(testRandomRangeAndInt2Interpreted(ia, ib), testRandomRangeAndInt2(ia, ib));\n+            Asserts.assertEQ(testRandomRangeOrInt1Interpreted(ia, ib), testRandomRangeOrInt1(ia, ib));\n+            Asserts.assertEQ(testRandomRangeOrInt2Interpreted(ia, ib), testRandomRangeOrInt2(ia, ib));\n+            Asserts.assertEQ(testRandomRangeXorInt1Interpreted(ia, ib), testRandomRangeXorInt1(ia, ib));\n+            Asserts.assertEQ(testRandomRangeXorInt2Interpreted(ia, ib), testRandomRangeXorInt2(ia, ib));\n+            Asserts.assertEQ(testRandomRangeMaxInt1Interpreted(ia, ib), testRandomRangeMaxInt1(ia, ib));\n+            Asserts.assertEQ(testRandomRangeMaxInt2Interpreted(ia, ib), testRandomRangeMaxInt2(ia, ib));\n+            Asserts.assertEQ(testRandomRangeMinInt1Interpreted(ia, ib), testRandomRangeMinInt1(ia, ib));\n+            Asserts.assertEQ(testRandomRangeMinInt2Interpreted(ia, ib), testRandomRangeMinInt2(ia, ib));\n+        }\n+    }\n+\n+    @DontCompile\n+    private void assertResultL() {\n+        long a = GEN_LONG.next();\n+        long b = GEN_LONG.next();\n+        long aNeg = Math.min(HI_NEG_L, Math.max(LO_NEG_L, a));\n+        long bNeg = Math.min(HI_NEG_L, Math.max(LO_NEG_L, b));\n+        long aPos = Math.min(HI_POS_L, Math.max(LO_POS_L, a));\n+        long bPos = Math.min(HI_POS_L, Math.max(LO_POS_L, b));\n+\n+        Asserts.assertEQ((a & bNeg) < 0, knownAndInputLong1(a, b));\n+        Asserts.assertEQ((aNeg & b) < 0, knownAndInputLong2(a, b));\n+        Asserts.assertEQ((a & bNeg) >= 0, knownAndInputLong3(a, b));\n+        Asserts.assertEQ((aNeg & b) >= 0, knownAndInputLong4(a, b));\n+\n+        Asserts.assertEQ(Math.max(a, bNeg) < 0, knownMaxInputLong1(a, b));\n+        Asserts.assertEQ(Math.max(aNeg, b) < 0, knownMaxInputLong2(a, b));\n+        Asserts.assertEQ(Math.max(a, bNeg) >= 0, knownMaxInputLong3(a, b));\n+        Asserts.assertEQ(Math.max(aNeg, b) >= 0, knownMaxInputLong4(a, b));\n+\n+        Asserts.assertEQ((a | bPos) < 0, knownOrInputLong1(a, b));\n+        Asserts.assertEQ((aPos | b) < 0, knownOrInputLong2(a, b));\n+        Asserts.assertEQ((a | bPos) >= 0, knownOrInputLong3(a, b));\n+        Asserts.assertEQ((aPos | b) >= 0, knownOrInputLong4(a, b));\n+\n+        Asserts.assertEQ(Math.min(a, bPos) < 0, knownMinInputLong1(a, b));\n+        Asserts.assertEQ(Math.min(aPos, b) < 0, knownMinInputLong2(a, b));\n+        Asserts.assertEQ(Math.min(a, bPos) >= 0, knownMinInputLong3(a, b));\n+        Asserts.assertEQ(Math.min(aPos, b) >= 0, knownMinInputLong4(a, b));\n+\n+        Asserts.assertEQ((a ^ bNeg) < 0, knownXorInputLong1(a, b));\n+        Asserts.assertEQ((aNeg ^ b) < 0, knownXorInputLong2(a, b));\n+        Asserts.assertEQ((a ^ bNeg) >= 0, knownXorInputLong3(a, b));\n+        Asserts.assertEQ((aNeg ^ b) >= 0, knownXorInputLong4(a, b));\n+        Asserts.assertEQ((a ^ bPos) < 0, knownXorInputLong5(a, b));\n+        Asserts.assertEQ((aPos ^ b) < 0, knownXorInputLong6(a, b));\n+        Asserts.assertEQ((a ^ bPos) >= 0, knownXorInputLong7(a, b));\n+        Asserts.assertEQ((aPos ^ b) >= 0, knownXorInputLong8(a, b));\n+\n+        for (int i = 0; i < 10; i++) {\n+            long la = GEN_LONG.next();\n+            long lb = GEN_LONG.next();\n+            Asserts.assertEQ(testRandomRangeAndLong1Interpreted(la, lb), testRandomRangeAndLong1(la, lb));\n+            Asserts.assertEQ(testRandomRangeAndLong2Interpreted(la, lb), testRandomRangeAndLong2(la, lb));\n+            Asserts.assertEQ(testRandomRangeOrLong1Interpreted(la, lb), testRandomRangeOrLong1(la, lb));\n+            Asserts.assertEQ(testRandomRangeOrLong2Interpreted(la, lb), testRandomRangeOrLong2(la, lb));\n+            Asserts.assertEQ(testRandomRangeXorLong1Interpreted(la, lb), testRandomRangeXorLong1(la, lb));\n+            Asserts.assertEQ(testRandomRangeXorLong2Interpreted(la, lb), testRandomRangeXorLong2(la, lb));\n+            Asserts.assertEQ(testRandomRangeMaxLong1Interpreted(la, lb), testRandomRangeMaxLong1(la, lb));\n+            Asserts.assertEQ(testRandomRangeMaxLong2Interpreted(la, lb), testRandomRangeMaxLong2(la, lb));\n+            Asserts.assertEQ(testRandomRangeMinLong1Interpreted(la, lb), testRandomRangeMinLong1(la, lb));\n+            Asserts.assertEQ(testRandomRangeMinLong2Interpreted(la, lb), testRandomRangeMinLong2(la, lb));\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.AND, IRNode.MAX, IRNode.MIN})\n+    public boolean knownAndInputInt1(int a, int b) {\n+        return (a & Math.min(HI_NEG_I, Math.max(LO_NEG_I, b))) < 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.AND, IRNode.MAX, IRNode.MIN})\n+    public boolean knownAndInputInt2(int a, int b) {\n+        return (Math.min(HI_NEG_I, Math.max(LO_NEG_I, a)) & b) < 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.AND, IRNode.MAX, IRNode.MIN})\n+    public boolean knownAndInputInt3(int a, int b) {\n+        return (a & Math.min(HI_NEG_I, Math.max(LO_NEG_I, b))) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.AND, IRNode.MAX, IRNode.MIN})\n+    public boolean knownAndInputInt4(int a, int b) {\n+        return (Math.min(HI_NEG_I, Math.max(LO_NEG_I, a)) & b) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MAX, IRNode.MIN})\n+    public boolean knownMaxInputInt1(int a, int b) {\n+        return Math.max(a, Math.min(HI_NEG_I, Math.max(LO_NEG_I, b))) < 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MAX, IRNode.MIN})\n+    public boolean knownMaxInputInt2(int a, int b) {\n+        return Math.max(Math.min(HI_NEG_I, Math.max(LO_NEG_I, a)), b) < 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MAX, IRNode.MIN})\n+    public boolean knownMaxInputInt3(int a, int b) {\n+        return Math.max(a, Math.min(HI_NEG_I, Math.max(LO_NEG_I, b))) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MAX, IRNode.MIN})\n+    public boolean knownMaxInputInt4(int a, int b) {\n+        return Math.max(Math.min(HI_NEG_I, Math.max(LO_NEG_I, a)), b) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.OR, IRNode.MAX, IRNode.MIN})\n+    public boolean knownOrInputInt1(int a, int b) {\n+        return (a | Math.min(HI_POS_I, Math.max(LO_POS_I, b))) < 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.OR, IRNode.MAX, IRNode.MIN})\n+    public boolean knownOrInputInt2(int a, int b) {\n+        return (Math.min(HI_POS_I, Math.max(LO_POS_I, a)) | b) < 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.OR, IRNode.MAX, IRNode.MIN})\n+    public boolean knownOrInputInt3(int a, int b) {\n+        return (a | Math.min(HI_POS_I, Math.max(LO_POS_I, b))) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.OR, IRNode.MAX, IRNode.MIN})\n+    public boolean knownOrInputInt4(int a, int b) {\n+        return (Math.min(HI_POS_I, Math.max(LO_POS_I, a)) | b) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MAX, IRNode.MIN})\n+    public boolean knownMinInputInt1(int a, int b) {\n+        return Math.min(a, Math.min(HI_POS_I, Math.max(LO_POS_I, b))) < 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MAX, IRNode.MIN})\n+    public boolean knownMinInputInt2(int a, int b) {\n+        return Math.min(Math.min(HI_POS_I, Math.max(LO_POS_I, a)), b) < 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MAX, IRNode.MIN})\n+    public boolean knownMinInputInt3(int a, int b) {\n+        return Math.min(a, Math.min(HI_POS_I, Math.max(LO_POS_I, b))) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MAX, IRNode.MIN})\n+    public boolean knownMinInputInt4(int a, int b) {\n+        return Math.min(Math.min(HI_POS_I, Math.max(LO_POS_I, a)), b) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR, IRNode.MAX, IRNode.MIN})\n+    public boolean knownXorInputInt1(int a, int b) {\n+        return (a ^ Math.min(HI_NEG_I, Math.max(LO_NEG_I, b))) < 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR, IRNode.MAX, IRNode.MIN})\n+    public boolean knownXorInputInt2(int a, int b) {\n+        return (Math.min(HI_NEG_I, Math.max(LO_NEG_I, a)) ^ b) < 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR, IRNode.MAX, IRNode.MIN})\n+    public boolean knownXorInputInt3(int a, int b) {\n+        return (a ^ Math.min(HI_NEG_I, Math.max(LO_NEG_I, b))) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR, IRNode.MAX, IRNode.MIN})\n+    public boolean knownXorInputInt4(int a, int b) {\n+        return (Math.min(HI_NEG_I, Math.max(LO_NEG_I, a)) ^ b) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR, IRNode.MAX, IRNode.MIN})\n+    public boolean knownXorInputInt5(int a, int b) {\n+        return (a ^ Math.min(HI_POS_I, Math.max(LO_POS_I, b))) < 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR, IRNode.MAX, IRNode.MIN})\n+    public boolean knownXorInputInt6(int a, int b) {\n+        return (Math.min(HI_POS_I, Math.max(LO_POS_I, a)) ^ b) < 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR, IRNode.MAX, IRNode.MIN})\n+    public boolean knownXorInputInt7(int a, int b) {\n+        return (a ^ Math.min(HI_POS_I, Math.max(LO_POS_I, b))) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR, IRNode.MAX, IRNode.MIN})\n+    public boolean knownXorInputInt8(int a, int b) {\n+        return (Math.min(HI_POS_I, Math.max(LO_POS_I, a)) ^ b) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.AND, IRNode.MAX, IRNode.MIN})\n+    public boolean knownAndInputLong1(long a, long b) {\n+        return (a & Math.min(HI_NEG_I, Math.max(LO_NEG_I, b))) < 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.AND, IRNode.MAX, IRNode.MIN})\n+    public boolean knownAndInputLong2(long a, long b) {\n+        return (Math.min(HI_NEG_L, Math.max(LO_NEG_L, a)) & b) < 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.AND, IRNode.MAX, IRNode.MIN})\n+    public boolean knownAndInputLong3(long a, long b) {\n+        return (a & Math.min(HI_NEG_L, Math.max(LO_NEG_L, b))) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.AND, IRNode.MAX, IRNode.MIN})\n+    public boolean knownAndInputLong4(long a, long b) {\n+        return (Math.min(HI_NEG_L, Math.max(LO_NEG_L, a)) & b) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MAX, IRNode.MIN})\n+    public boolean knownMaxInputLong1(long a, long b) {\n+        return Math.max(a, Math.min(HI_NEG_L, Math.max(LO_NEG_L, b))) < 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MAX, IRNode.MIN})\n+    public boolean knownMaxInputLong2(long a, long b) {\n+        return Math.max(Math.min(HI_NEG_L, Math.max(LO_NEG_L, a)), b) < 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MAX, IRNode.MIN})\n+    public boolean knownMaxInputLong3(long a, long b) {\n+        return Math.max(a, Math.min(HI_NEG_L, Math.max(LO_NEG_L, b))) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MAX, IRNode.MIN})\n+    public boolean knownMaxInputLong4(long a, long b) {\n+        return Math.max(Math.min(HI_NEG_L, Math.max(LO_NEG_L, a)), b) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.OR, IRNode.MAX, IRNode.MIN})\n+    public boolean knownOrInputLong1(long a, long b) {\n+        return (a | Math.min(HI_POS_L, Math.max(LO_POS_L, b))) < 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.OR, IRNode.MAX, IRNode.MIN})\n+    public boolean knownOrInputLong2(long a, long b) {\n+        return (Math.min(HI_POS_L, Math.max(LO_POS_L, a)) | b) < 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.OR, IRNode.MAX, IRNode.MIN})\n+    public boolean knownOrInputLong3(long a, long b) {\n+        return (a | Math.min(HI_POS_L, Math.max(LO_POS_L, b))) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.OR, IRNode.MAX, IRNode.MIN})\n+    public boolean knownOrInputLong4(long a, long b) {\n+        return (Math.min(HI_POS_L, Math.max(LO_POS_L, a)) | b) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR, IRNode.MAX, IRNode.MIN})\n+    public boolean knownXorInputLong1(long a, long b) {\n+        return (a ^ Math.min(HI_NEG_L, Math.max(LO_NEG_L, b))) < 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MAX, IRNode.MIN})\n+    public boolean knownMinInputLong1(long a, long b) {\n+        return Math.min(a, Math.min(HI_POS_L, Math.max(LO_POS_L, b))) < 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MAX, IRNode.MIN})\n+    public boolean knownMinInputLong2(long a, long b) {\n+        return Math.min(Math.min(HI_POS_L, Math.max(LO_POS_L, a)), b) < 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MAX, IRNode.MIN})\n+    public boolean knownMinInputLong3(long a, long b) {\n+        return Math.min(a, Math.min(HI_POS_L, Math.max(LO_POS_L, b))) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MAX, IRNode.MIN})\n+    public boolean knownMinInputLong4(long a, long b) {\n+        return Math.min(Math.min(HI_POS_L, Math.max(LO_POS_L, a)), b) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR, IRNode.MAX, IRNode.MIN})\n+    public boolean knownXorInputLong2(long a, long b) {\n+        return (Math.min(HI_NEG_L, Math.max(LO_NEG_L, a)) ^ b) < 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR, IRNode.MAX, IRNode.MIN})\n+    public boolean knownXorInputLong3(long a, long b) {\n+        return (a ^ Math.min(HI_NEG_L, Math.max(LO_NEG_L, b))) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR, IRNode.MAX, IRNode.MIN})\n+    public boolean knownXorInputLong4(long a, long b) {\n+        return (Math.min(HI_NEG_L, Math.max(LO_NEG_L, a)) ^ b) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR, IRNode.MAX, IRNode.MIN})\n+    public boolean knownXorInputLong5(long a, long b) {\n+        return (a ^ Math.min(HI_POS_L, Math.max(LO_POS_L, b))) < 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR, IRNode.MAX, IRNode.MIN})\n+    public boolean knownXorInputLong6(long a, long b) {\n+        return (Math.min(HI_POS_L, Math.max(LO_POS_L, a)) ^ b) < 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR, IRNode.MAX, IRNode.MIN})\n+    public boolean knownXorInputLong7(long a, long b) {\n+        return (a ^ Math.min(HI_POS_L, Math.max(LO_POS_L, b))) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR, IRNode.MAX, IRNode.MIN})\n+    public boolean knownXorInputLong8(long a, long b) {\n+        return (Math.min(HI_POS_L, Math.max(LO_POS_L, a)) ^ b) >= 0;\n+    }\n+\n+    private static final IntRange INT_RANGE_1 = IntRange.generate(GEN_INT);\n+    private static final IntRange INT_RANGE_2 = IntRange.generate(GEN_INT);\n+\n+    @Test\n+    public boolean testRandomRangeAndInt1(int a, int b) {\n+        return (INT_RANGE_1.clamp(a) & INT_RANGE_2.clamp(b)) < 0;\n+    }\n+\n+    @DontCompile\n+    public boolean testRandomRangeAndInt1Interpreted(int a, int b) {\n+        return (INT_RANGE_1.clamp(a) & INT_RANGE_2.clamp(b)) < 0;\n+    }\n+\n+    @Test\n+    public boolean testRandomRangeAndInt2(int a, int b) {\n+        return (INT_RANGE_1.clamp(a) & INT_RANGE_2.clamp(b)) >= 0;\n+    }\n+\n+    @DontCompile\n+    public boolean testRandomRangeAndInt2Interpreted(int a, int b) {\n+        return (INT_RANGE_1.clamp(a) & INT_RANGE_2.clamp(b)) >= 0;\n+    }\n+\n+    @Test\n+    public boolean testRandomRangeOrInt1(int a, int b) {\n+        return (INT_RANGE_1.clamp(a) | INT_RANGE_2.clamp(b)) < 0;\n+    }\n+\n+    @DontCompile\n+    public boolean testRandomRangeOrInt1Interpreted(int a, int b) {\n+        return (INT_RANGE_1.clamp(a) | INT_RANGE_2.clamp(b)) < 0;\n+    }\n+\n+    @Test\n+    public boolean testRandomRangeOrInt2(int a, int b) {\n+        return (INT_RANGE_1.clamp(a) | INT_RANGE_2.clamp(b)) >= 0;\n+    }\n+\n+    @DontCompile\n+    public boolean testRandomRangeOrInt2Interpreted(int a, int b) {\n+        return (INT_RANGE_1.clamp(a) | INT_RANGE_2.clamp(b)) >= 0;\n+    }\n+\n+    @Test\n+    public boolean testRandomRangeXorInt1(int a, int b) {\n+        return (INT_RANGE_1.clamp(a) ^ INT_RANGE_2.clamp(b)) < 0;\n+    }\n+\n+    @DontCompile\n+    public boolean testRandomRangeXorInt1Interpreted(int a, int b) {\n+        return (INT_RANGE_1.clamp(a) ^ INT_RANGE_2.clamp(b)) < 0;\n+    }\n+\n+    @Test\n+    public boolean testRandomRangeXorInt2(int a, int b) {\n+        return (INT_RANGE_1.clamp(a) ^ INT_RANGE_2.clamp(b)) >= 0;\n+    }\n+\n+    @DontCompile\n+    public boolean testRandomRangeXorInt2Interpreted(int a, int b) {\n+        return (INT_RANGE_1.clamp(a) ^ INT_RANGE_2.clamp(b)) >= 0;\n+    }\n+\n+    @Test\n+    public boolean testRandomRangeMaxInt1(int a, int b) {\n+        return Math.max(INT_RANGE_1.clamp(a), INT_RANGE_2.clamp(b)) < 0;\n+    }\n+\n+    @DontCompile\n+    public boolean testRandomRangeMaxInt1Interpreted(int a, int b) {\n+        return Math.max(INT_RANGE_1.clamp(a), INT_RANGE_2.clamp(b)) < 0;\n+    }\n+\n+    @Test\n+    public boolean testRandomRangeMaxInt2(int a, int b) {\n+        return Math.max(INT_RANGE_1.clamp(a), INT_RANGE_2.clamp(b)) >= 0;\n+    }\n+\n+    @DontCompile\n+    public boolean testRandomRangeMaxInt2Interpreted(int a, int b) {\n+        return Math.max(INT_RANGE_1.clamp(a), INT_RANGE_2.clamp(b)) >= 0;\n+    }\n+\n+    @Test\n+    public boolean testRandomRangeMinInt1(int a, int b) {\n+        return Math.min(INT_RANGE_1.clamp(a), INT_RANGE_2.clamp(b)) < 0;\n+    }\n+\n+    @DontCompile\n+    public boolean testRandomRangeMinInt1Interpreted(int a, int b) {\n+        return Math.min(INT_RANGE_1.clamp(a), INT_RANGE_2.clamp(b)) < 0;\n+    }\n+\n+    @Test\n+    public boolean testRandomRangeMinInt2(int a, int b) {\n+        return Math.min(INT_RANGE_1.clamp(a), INT_RANGE_2.clamp(b)) >= 0;\n+    }\n+\n+    @DontCompile\n+    public boolean testRandomRangeMinInt2Interpreted(int a, int b) {\n+        return Math.min(INT_RANGE_1.clamp(a), INT_RANGE_2.clamp(b)) >= 0;\n+    }\n+\n+    private static final LongRange LONG_RANGE_1 = LongRange.generate(GEN_LONG);\n+    private static final LongRange LONG_RANGE_2 = LongRange.generate(GEN_LONG);\n+\n+    @Test\n+    public boolean testRandomRangeAndLong1(long a, long b) {\n+        return (LONG_RANGE_1.clamp(a) & LONG_RANGE_2.clamp(b)) < 0;\n+    }\n+\n+    @DontCompile\n+    public boolean testRandomRangeAndLong1Interpreted(long a, long b) {\n+        return (LONG_RANGE_1.clamp(a) & LONG_RANGE_2.clamp(b)) < 0;\n+    }\n+\n+    @Test\n+    public boolean testRandomRangeAndLong2(long a, long b) {\n+        return (LONG_RANGE_1.clamp(a) & LONG_RANGE_2.clamp(b)) >= 0;\n+    }\n+\n+    @DontCompile\n+    public boolean testRandomRangeAndLong2Interpreted(long a, long b) {\n+        return (LONG_RANGE_1.clamp(a) & LONG_RANGE_2.clamp(b)) >= 0;\n+    }\n+\n+    @Test\n+    public boolean testRandomRangeOrLong1(long a, long b) {\n+        return (LONG_RANGE_1.clamp(a) | LONG_RANGE_2.clamp(b)) < 0;\n+    }\n+\n+    @DontCompile\n+    public boolean testRandomRangeOrLong1Interpreted(long a, long b) {\n+        return (LONG_RANGE_1.clamp(a) | LONG_RANGE_2.clamp(b)) < 0;\n+    }\n+\n+    @Test\n+    public boolean testRandomRangeOrLong2(long a, long b) {\n+        return (LONG_RANGE_1.clamp(a) | LONG_RANGE_2.clamp(b)) >= 0;\n+    }\n+\n+    @DontCompile\n+    public boolean testRandomRangeOrLong2Interpreted(long a, long b) {\n+        return (LONG_RANGE_1.clamp(a) | LONG_RANGE_2.clamp(b)) >= 0;\n+    }\n+\n+    @Test\n+    public boolean testRandomRangeXorLong1(long a, long b) {\n+        return (LONG_RANGE_1.clamp(a) ^ LONG_RANGE_2.clamp(b)) < 0;\n+    }\n+\n+    @DontCompile\n+    public boolean testRandomRangeXorLong1Interpreted(long a, long b) {\n+        return (LONG_RANGE_1.clamp(a) ^ LONG_RANGE_2.clamp(b)) < 0;\n+    }\n+\n+    @Test\n+    public boolean testRandomRangeXorLong2(long a, long b) {\n+        return (LONG_RANGE_1.clamp(a) ^ LONG_RANGE_2.clamp(b)) >= 0;\n+    }\n+\n+    @DontCompile\n+    public boolean testRandomRangeXorLong2Interpreted(long a, long b) {\n+        return (LONG_RANGE_1.clamp(a) ^ LONG_RANGE_2.clamp(b)) >= 0;\n+    }\n+\n+    @Test\n+    public boolean testRandomRangeMaxLong1(long a, long b) {\n+        return Math.max(LONG_RANGE_1.clamp(a), LONG_RANGE_2.clamp(b)) < 0;\n+    }\n+\n+    @DontCompile\n+    public boolean testRandomRangeMaxLong1Interpreted(long a, long b) {\n+        return Math.max(LONG_RANGE_1.clamp(a), LONG_RANGE_2.clamp(b)) < 0;\n+    }\n+\n+    @Test\n+    public boolean testRandomRangeMaxLong2(long a, long b) {\n+        return Math.max(LONG_RANGE_1.clamp(a), LONG_RANGE_2.clamp(b)) >= 0;\n+    }\n+\n+    @DontCompile\n+    public boolean testRandomRangeMaxLong2Interpreted(long a, long b) {\n+        return Math.max(LONG_RANGE_1.clamp(a), LONG_RANGE_2.clamp(b)) >= 0;\n+    }\n+\n+    @Test\n+    public boolean testRandomRangeMinLong1(long a, long b) {\n+        return Math.min(LONG_RANGE_1.clamp(a), LONG_RANGE_2.clamp(b)) < 0;\n+    }\n+\n+    @DontCompile\n+    public boolean testRandomRangeMinLong1Interpreted(long a, long b) {\n+        return Math.min(LONG_RANGE_1.clamp(a), LONG_RANGE_2.clamp(b)) < 0;\n+    }\n+\n+    @Test\n+    public boolean testRandomRangeMinLong2(long a, long b) {\n+        return Math.min(LONG_RANGE_1.clamp(a), LONG_RANGE_2.clamp(b)) >= 0;\n+    }\n+\n+    @DontCompile\n+    public boolean testRandomRangeMinLong2Interpreted(long a, long b) {\n+        return Math.min(LONG_RANGE_1.clamp(a), LONG_RANGE_2.clamp(b)) >= 0;\n+    }\n+\n+    record IntRange(int lo, int hi) {\n+        IntRange {\n+            if (lo > hi) {\n+                throw new IllegalArgumentException(\"lo > hi\");\n+            }\n+        }\n+\n+        @ForceInline\n+        int clamp(int v) {\n+            return Math.min(hi, Math.max(v, lo));\n+        }\n+\n+        static IntRange generate(Generator<Integer> g) {\n+            var a = g.next();\n+            var b = g.next();\n+            if (a > b) {\n+                var tmp = a;\n+                a = b;\n+                b = tmp;\n+            }\n+            return new IntRange(a, b);\n+        }\n+    }\n+    record LongRange(long lo, long hi) {\n+        LongRange {\n+            if (lo > hi) {\n+                throw new IllegalArgumentException(\"lo > hi\");\n+            }\n+        }\n+\n+        @ForceInline\n+        long clamp(long v) {\n+            return Math.min(hi, Math.max(v, lo));\n+        }\n+\n+        static LongRange generate(Generator<Long> g) {\n+            var a = g.next();\n+            var b = g.next();\n+            if (a > b) {\n+                var tmp = a;\n+                a = b;\n+                b = tmp;\n+            }\n+            return new LongRange(a, b);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/BoolNodeSimplifySignInvariantTests.java","additions":757,"deletions":0,"binary":false,"changes":757,"status":"added"}]}