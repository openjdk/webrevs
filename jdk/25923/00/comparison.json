{"files":[{"patch":"@@ -5596,0 +5596,1 @@\n+  const Register jdx = tmp1;\n@@ -5601,2 +5602,1 @@\n-  Label L_multiply_64_x_64_loop, L_done;\n-\n+  Label L_done;\n@@ -5606,61 +5606,0 @@\n-  const Register jdx = tmp1;\n-\n-  if (AvoidUnalignedAccesses) {\n-    int base_offset = arrayOopDesc::base_offset_in_bytes(T_INT);\n-    assert((base_offset % (UseCompactObjectHeaders ? 4 :\n-                           (UseCompressedClassPointers ? 8 : 4))) == 0, \"Must be\");\n-\n-    if ((base_offset % 8) == 0) {\n-      \/\/ multiply_64_x_64_loop emits 8-byte load\/store to access two elements\n-      \/\/ at a time from int arrays x and y. When base_offset is 8 bytes, these\n-      \/\/ accesses are naturally aligned if both xlen and ylen are even numbers.\n-      orr(t0, xlen, ylen);\n-      test_bit(t0, t0, 0);\n-      beqz(t0, L_multiply_64_x_64_loop);\n-    }\n-\n-    Label L_second_loop_unaligned, L_third_loop, L_third_loop_exit;\n-\n-    multiply_32_x_32_loop(x, xstart, x_xstart, y, y_idx, z, carry, product, idx, kdx);\n-    shadd(t0, xstart, z, t0, LogBytesPerInt);\n-    sw(carry, Address(t0, 0));\n-\n-    bind(L_second_loop_unaligned);\n-    mv(carry, zr);\n-    mv(jdx, ylen);\n-    subiw(xstart, xstart, 1);\n-    bltz(xstart, L_done);\n-\n-    subi(sp, sp, 2 * wordSize);\n-    sd(z, Address(sp, 0));\n-    sd(zr, Address(sp, wordSize));\n-    shadd(t0, xstart, z, t0, LogBytesPerInt);\n-    addi(z, t0, 4);\n-    shadd(t0, xstart, x, t0, LogBytesPerInt);\n-    lwu(product, Address(t0, 0));\n-\n-    blez(jdx, L_third_loop_exit);\n-\n-    bind(L_third_loop);\n-    subiw(jdx, jdx, 1);\n-    shadd(t0, jdx, y, t0, LogBytesPerInt);\n-    lwu(t0, Address(t0, 0));\n-    mul(t1, t0, product);\n-    add(t0, t1, carry);\n-    shadd(tmp6, jdx, z, t1, LogBytesPerInt);\n-    lwu(t1, Address(tmp6, 0));\n-    add(t0, t0, t1);\n-    sw(t0, Address(tmp6, 0));\n-    srli(carry, t0, 32);\n-    bgtz(jdx, L_third_loop);\n-\n-    bind(L_third_loop_exit);\n-    ld(z, Address(sp, 0));\n-    addi(sp, sp, 2 * wordSize);\n-    shadd(t0, xstart, z, t0, LogBytesPerInt);\n-    sw(carry, Address(t0, 0));\n-\n-    j(L_second_loop_unaligned);\n-  }\n-\n-  bind(L_multiply_64_x_64_loop);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":2,"deletions":63,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -328,2 +328,7 @@\n-  if (FLAG_IS_DEFAULT(UseMultiplyToLenIntrinsic)) {\n-    FLAG_SET_DEFAULT(UseMultiplyToLenIntrinsic, true);\n+  if (!AvoidUnalignedAccesses) {\n+    if (FLAG_IS_DEFAULT(UseMultiplyToLenIntrinsic)) {\n+      FLAG_SET_DEFAULT(UseMultiplyToLenIntrinsic, true);\n+    }\n+  } else if (UseMultiplyToLenIntrinsic) {\n+    warning(\"Intrinsics for BigInteger.multiplyToLen() not available on this CPU.\");\n+    FLAG_SET_DEFAULT(UseMultiplyToLenIntrinsic, false);\n@@ -332,2 +337,7 @@\n-  if (FLAG_IS_DEFAULT(UseSquareToLenIntrinsic)) {\n-    FLAG_SET_DEFAULT(UseSquareToLenIntrinsic, true);\n+  if (!AvoidUnalignedAccesses) {\n+    if (FLAG_IS_DEFAULT(UseSquareToLenIntrinsic)) {\n+      FLAG_SET_DEFAULT(UseSquareToLenIntrinsic, true);\n+    }\n+  } else if (UseSquareToLenIntrinsic) {\n+    warning(\"Intrinsics for BigInteger.squareToLen() not available on this CPU.\");\n+    FLAG_SET_DEFAULT(UseSquareToLenIntrinsic, false);\n@@ -336,2 +346,7 @@\n-  if (FLAG_IS_DEFAULT(UseMontgomeryMultiplyIntrinsic)) {\n-    FLAG_SET_DEFAULT(UseMontgomeryMultiplyIntrinsic, true);\n+  if (!AvoidUnalignedAccesses) {\n+    if (FLAG_IS_DEFAULT(UseMontgomeryMultiplyIntrinsic)) {\n+      FLAG_SET_DEFAULT(UseMontgomeryMultiplyIntrinsic, true);\n+    }\n+  } else if (UseMontgomeryMultiplyIntrinsic) {\n+    warning(\"Intrinsics for BigInteger.montgomeryMultiply() not available on this CPU.\");\n+    FLAG_SET_DEFAULT(UseMontgomeryMultiplyIntrinsic, false);\n@@ -340,2 +355,7 @@\n-  if (FLAG_IS_DEFAULT(UseMontgomerySquareIntrinsic)) {\n-    FLAG_SET_DEFAULT(UseMontgomerySquareIntrinsic, true);\n+  if (!AvoidUnalignedAccesses) {\n+    if (FLAG_IS_DEFAULT(UseMontgomerySquareIntrinsic)) {\n+      FLAG_SET_DEFAULT(UseMontgomerySquareIntrinsic, true);\n+    }\n+  } else if (UseMontgomerySquareIntrinsic) {\n+    warning(\"Intrinsics for BigInteger.montgomerySquare() not available on this CPU.\");\n+    FLAG_SET_DEFAULT(UseMontgomerySquareIntrinsic, false);\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":28,"deletions":8,"binary":false,"changes":36,"status":"modified"}]}