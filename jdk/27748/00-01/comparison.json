{"files":[{"patch":"@@ -1710,3 +1710,2 @@\n-  \/\/ Verify the field offset falls after the header and Klass pointer. This is a cheap check which\n-  \/\/ is able to detect a regression of JDK-8369506.\n-  Label valid;\n+  \/\/ Verify the field offset is not in the header, implicitly checks for 0\n+  Label L;\n@@ -1714,1 +1713,1 @@\n-  br(Assembler::GE, valid);\n+  br(Assembler::GE, L);\n@@ -1716,1 +1715,1 @@\n-  bind(valid);\n+  bind(L);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -235,3 +235,4 @@\n-\n-  \/\/ Patch the bytecode using STLR so that the last STLR used in\n-  \/\/ ResolvedFieldEntry::fill_in is observed before the patched bytecode.\n+  \/\/ Patch bytecode with release store to coordinate with ResolvedFieldEntry loads\n+  \/\/ in fast bytecode codelets. load_field_entry has a memory barrier that gains\n+  \/\/ the needed ordering, together with control dependency on entering the fast codelet\n+  \/\/ itself.\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"}]}