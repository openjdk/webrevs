{"files":[{"patch":"@@ -1401,0 +1401,15 @@\n+BoolTest::mask BoolTest::unsigned_mask(BoolTest::mask btm) {\n+  switch(btm) {\n+    case eq:\n+    case ne:\n+      return btm;\n+    case lt:\n+    case le:\n+    case gt:\n+    case ge:\n+      return mask(btm | unsigned_compare);\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -334,1 +334,1 @@\n-  static mask unsigned_mask(mask btm) { return mask(btm | unsigned_compare); }\n+  static mask unsigned_mask(mask btm);\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -149,0 +149,9 @@\n+    \/\/    I for I\n+    private int cmoveIEQforI(int a, int b, int c, int d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private int cmoveINEforI(int a, int b, int c, int d) {\n+        return (a != b) ? c : d;\n+    }\n+\n@@ -153,0 +162,21 @@\n+    private int cmoveIGEforI(int a, int b, int c, int d) {\n+        return (a >= b) ? c : d;\n+    }\n+\n+    private int cmoveILTforI(int a, int b, int c, int d) {\n+        return (a < b) ? c : d;\n+    }\n+\n+    private int cmoveILEforI(int a, int b, int c, int d) {\n+        return (a <= b) ? c : d;\n+    }\n+\n+    \/\/    I for L\n+    private long cmoveIEQforL(int a, int b, long c, long d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private long cmoveINEforL(int a, int b, long c, long d) {\n+        return (a != b) ? c : d;\n+    }\n+\n@@ -157,0 +187,21 @@\n+    private long cmoveIGEforL(int a, int b, long c, long d) {\n+        return (a >= b) ? c : d;\n+    }\n+\n+    private long cmoveILTforL(int a, int b, long c, long d) {\n+        return (a < b) ? c : d;\n+    }\n+\n+    private long cmoveILEforL(int a, int b, long c, long d) {\n+        return (a <= b) ? c : d;\n+    }\n+\n+    \/\/    I for F\n+    private float cmoveIEQforF(int a, int b, float c, float d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private float cmoveINEforF(int a, int b, float c, float d) {\n+        return (a != b) ? c : d;\n+    }\n+\n@@ -161,0 +212,21 @@\n+    private float cmoveIGEforF(int a, int b, float c, float d) {\n+        return (a >= b) ? c : d;\n+    }\n+\n+    private float cmoveILTforF(int a, int b, float c, float d) {\n+        return (a < b) ? c : d;\n+    }\n+\n+    private float cmoveILEforF(int a, int b, float c, float d) {\n+        return (a <= b) ? c : d;\n+    }\n+\n+    \/\/    I for D\n+    private double cmoveIEQforD(int a, int b, double c, double d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private double cmoveINEforD(int a, int b, double c, double d) {\n+        return (a != b) ? c : d;\n+    }\n+\n@@ -165,0 +237,21 @@\n+    private double cmoveIGEforD(int a, int b, double c, double d) {\n+        return (a >= b) ? c : d;\n+    }\n+\n+    private double cmoveILTforD(int a, int b, double c, double d) {\n+        return (a < b) ? c : d;\n+    }\n+\n+    private double cmoveILEforD(int a, int b, double c, double d) {\n+        return (a <= b) ? c : d;\n+    }\n+\n+    \/\/    L for I\n+    private int cmoveLEQforI(long a, long b, int c, int d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private int cmoveLNEforI(long a, long b, int c, int d) {\n+        return (a != b) ? c : d;\n+    }\n+\n@@ -169,0 +262,21 @@\n+    private int cmoveLGEforI(long a, long b, int c, int d) {\n+        return (a >= b) ? c : d;\n+    }\n+\n+    private int cmoveLLTforI(long a, long b, int c, int d) {\n+        return (a < b) ? c : d;\n+    }\n+\n+    private int cmoveLLEforI(long a, long b, int c, int d) {\n+        return (a <= b) ? c : d;\n+    }\n+\n+    \/\/    L for L\n+    private long cmoveLEQforL(long a, long b, long c, long d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private long cmoveLNEforL(long a, long b, long c, long d) {\n+        return (a != b) ? c : d;\n+    }\n+\n@@ -173,0 +287,21 @@\n+    private long cmoveLGEforL(long a, long b, long c, long d) {\n+        return (a >= b) ? c : d;\n+    }\n+\n+    private long cmoveLLTforL(long a, long b, long c, long d) {\n+        return (a < b) ? c : d;\n+    }\n+\n+    private long cmoveLLEforL(long a, long b, long c, long d) {\n+        return (a <= b) ? c : d;\n+    }\n+\n+    \/\/    L for F\n+    private float cmoveLEQforF(long a, long b, float c, float d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private float cmoveLNEforF(long a, long b, float c, float d) {\n+        return (a != b) ? c : d;\n+    }\n+\n@@ -177,0 +312,21 @@\n+    private float cmoveLGEforF(long a, long b, float c, float d) {\n+        return (a >= b) ? c : d;\n+    }\n+\n+    private float cmoveLLTforF(long a, long b, float c, float d) {\n+        return (a < b) ? c : d;\n+    }\n+\n+    private float cmoveLLEforF(long a, long b, float c, float d) {\n+        return (a <= b) ? c : d;\n+    }\n+\n+    \/\/    L for D\n+    private double cmoveLEQforD(long a, long b, double c, double d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private double cmoveLNEforD(long a, long b, double c, double d) {\n+        return (a != b) ? c : d;\n+    }\n+\n@@ -181,0 +337,12 @@\n+    private double cmoveLGEforD(long a, long b, double c, double d) {\n+        return (a >= b) ? c : d;\n+    }\n+\n+    private double cmoveLLTforD(long a, long b, double c, double d) {\n+        return (a < b) ? c : d;\n+    }\n+\n+    private double cmoveLLEforD(long a, long b, double c, double d) {\n+        return (a <= b) ? c : d;\n+    }\n+\n@@ -183,0 +351,8 @@\n+    private int cmoveUIEQforI(int a, int b, int c, int d) {\n+        return Integer.compareUnsigned(a, b) == 0 ? c : d;\n+    }\n+\n+    private int cmoveUINEforI(int a, int b, int c, int d) {\n+        return Integer.compareUnsigned(a, b) != 0 ? c : d;\n+    }\n+\n@@ -200,0 +376,8 @@\n+    private long cmoveUIEQforL(int a, int b, long c, long d) {\n+        return Integer.compareUnsigned(a, b) == 0 ? c : d;\n+    }\n+\n+    private long cmoveUINEforL(int a, int b, long c, long d) {\n+        return Integer.compareUnsigned(a, b) != 0 ? c : d;\n+    }\n+\n@@ -217,0 +401,8 @@\n+    private float cmoveUIEQforF(int a, int b, float c, float d) {\n+        return Integer.compareUnsigned(a, b) == 0 ? c : d;\n+    }\n+\n+    private float cmoveUINEforF(int a, int b, float c, float d) {\n+        return Integer.compareUnsigned(a, b) != 0 ? c : d;\n+    }\n+\n@@ -234,0 +426,8 @@\n+    private double cmoveUIEQforD(int a, int b, double c, double d) {\n+        return Integer.compareUnsigned(a, b) == 0 ? c : d;\n+    }\n+\n+    private double cmoveUINEforD(int a, int b, double c, double d) {\n+        return Integer.compareUnsigned(a, b) != 0 ? c : d;\n+    }\n+\n@@ -251,0 +451,8 @@\n+    private int cmoveULEQforI(long a, long b, int c, int d) {\n+        return Long.compareUnsigned(a, b) == 0 ? c : d;\n+    }\n+\n+    private int cmoveULNEforI(long a, long b, int c, int d) {\n+        return Long.compareUnsigned(a, b) != 0 ? c : d;\n+    }\n+\n@@ -268,0 +476,8 @@\n+    private long cmoveULEQforL(long a, long b, long c, long d) {\n+        return Long.compareUnsigned(a, b) == 0 ? c : d;\n+    }\n+\n+    private long cmoveULNEforL(long a, long b, long c, long d) {\n+        return Long.compareUnsigned(a, b) != 0 ? c : d;\n+    }\n+\n@@ -285,0 +501,8 @@\n+    private float cmoveULEQforF(long a, long b, float c, float d) {\n+        return Long.compareUnsigned(a, b) == 0 ? c : d;\n+    }\n+\n+    private float cmoveULNEforF(long a, long b, float c, float d) {\n+        return Long.compareUnsigned(a, b) != 0 ? c : d;\n+    }\n+\n@@ -302,0 +526,8 @@\n+    private double cmoveULEQforD(long a, long b, double c, double d) {\n+        return Long.compareUnsigned(a, b) == 0 ? c : d;\n+    }\n+\n+    private double cmoveULNEforD(long a, long b, double c, double d) {\n+        return Long.compareUnsigned(a, b) != 0 ? c : d;\n+    }\n+\n@@ -738,0 +970,1 @@\n+    \/\/     I fo I\n@@ -740,1 +973,1 @@\n-    private static void testCMoveIGTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+    private static void testCMoveIEQforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n@@ -745,1 +978,1 @@\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n@@ -751,17 +984,1 @@\n-    private static void testCMoveIGTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveIGTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+    private static void testCMoveINEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n@@ -769,2 +986,2 @@\n-            float cc = c[i];\n-            float dd = d[i];\n+            int cc = c[i];\n+            int dd = d[i];\n@@ -772,1 +989,1 @@\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n@@ -778,1 +995,1 @@\n-    private static void testCMoveIGTforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+    private static void testCMoveIGTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n@@ -780,2 +997,2 @@\n-            double cc = c[i];\n-            double dd = d[i];\n+            int cc = c[i];\n+            int dd = d[i];\n@@ -789,1 +1006,1 @@\n-    private static void testCMoveLGTforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+    private static void testCMoveIGEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n@@ -794,1 +1011,1 @@\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n+            r[i] = (a[i] >= b[i]) ? cc : dd;\n@@ -800,1 +1017,1 @@\n-    private static void testCMoveLGTforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+    private static void testCMoveILTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n@@ -802,2 +1019,2 @@\n-            long cc = c[i];\n-            long dd = d[i];\n+            int cc = c[i];\n+            int dd = d[i];\n@@ -805,1 +1022,1 @@\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n+            r[i] = (a[i] < b[i]) ? cc : dd;\n@@ -811,1 +1028,1 @@\n-    private static void testCMoveLGTforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+    private static void testCMoveILEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n@@ -813,19 +1030,2 @@\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n-    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n-    private static void testCMoveLGTforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n+            int cc = c[i];\n+            int dd = d[i];\n@@ -833,1 +1033,1 @@\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n+            r[i] = (a[i] <= b[i]) ? cc : dd;\n@@ -837,2 +1037,1 @@\n-    \/\/ Unsigned comparison: I\/L\n-    \/\/     I fo I\n+    \/\/     I fo L\n@@ -841,1 +1040,1 @@\n-    private static void testCMoveUIGTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+    private static void testCMoveIEQforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n@@ -843,2 +1042,2 @@\n-            int cc = c[i];\n-            int dd = d[i];\n+            long cc = c[i];\n+            long dd = d[i];\n@@ -846,1 +1045,1 @@\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n@@ -852,1 +1051,1 @@\n-    private static void testCMoveUIGEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+    private static void testCMoveINEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n@@ -854,2 +1053,2 @@\n-            int cc = c[i];\n-            int dd = d[i];\n+            long cc = c[i];\n+            long dd = d[i];\n@@ -857,1 +1056,1 @@\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n@@ -863,1 +1062,1 @@\n-    private static void testCMoveUILTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+    private static void testCMoveIGTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n@@ -865,2 +1064,2 @@\n-            int cc = c[i];\n-            int dd = d[i];\n+            long cc = c[i];\n+            long dd = d[i];\n@@ -868,1 +1067,1 @@\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n@@ -874,1 +1073,1 @@\n-    private static void testCMoveUILEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+    private static void testCMoveIGEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n@@ -876,2 +1075,2 @@\n-            int cc = c[i];\n-            int dd = d[i];\n+            long cc = c[i];\n+            long dd = d[i];\n@@ -879,1 +1078,1 @@\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+            r[i] = (a[i] >= b[i]) ? cc : dd;\n@@ -883,1 +1082,0 @@\n-    \/\/     I fo L\n@@ -886,1 +1084,1 @@\n-    private static void testCMoveUIGTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+    private static void testCMoveILTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n@@ -891,1 +1089,1 @@\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+            r[i] = (a[i] < b[i]) ? cc : dd;\n@@ -897,1 +1095,1 @@\n-    private static void testCMoveUIGEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+    private static void testCMoveILEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n@@ -902,1 +1100,1 @@\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+            r[i] = (a[i] <= b[i]) ? cc : dd;\n@@ -906,0 +1104,1 @@\n+    \/\/     I fo F\n@@ -907,2 +1106,7 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUILTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveIEQforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n@@ -910,2 +1114,2 @@\n-            long cc = c[i];\n-            long dd = d[i];\n+            float cc = c[i];\n+            float dd = d[i];\n@@ -913,1 +1117,1 @@\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n@@ -918,2 +1122,7 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUILEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveINEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n@@ -921,2 +1130,2 @@\n-            long cc = c[i];\n-            long dd = d[i];\n+            float cc = c[i];\n+            float dd = d[i];\n@@ -924,1 +1133,1 @@\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n@@ -928,1 +1137,0 @@\n-    \/\/     I fo F\n@@ -936,1 +1144,1 @@\n-    private static void testCMoveUIGTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+    private static void testCMoveIGTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n@@ -941,1 +1149,1 @@\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n@@ -952,1 +1160,1 @@\n-    private static void testCMoveUIGEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+    private static void testCMoveIGEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n@@ -957,1 +1165,1 @@\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+            r[i] = (a[i] >= b[i]) ? cc : dd;\n@@ -968,1 +1176,1 @@\n-    private static void testCMoveUILTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+    private static void testCMoveILTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n@@ -973,1 +1181,1 @@\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+            r[i] = (a[i] < b[i]) ? cc : dd;\n@@ -984,1 +1192,1 @@\n-    private static void testCMoveUILEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+    private static void testCMoveILEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n@@ -989,1 +1197,1 @@\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+            r[i] = (a[i] <= b[i]) ? cc : dd;\n@@ -996,1 +1204,1 @@\n-    private static void testCMoveUIGTforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+    private static void testCMoveIEQforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n@@ -1001,1 +1209,626 @@\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveINEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveIGTforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveIGEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] >= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveILTforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] < b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveILEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] <= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     L fo I\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLEQforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLNEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLGTforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLGEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] >= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLLTforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] < b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLLEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] <= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     L fo L\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLEQforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLNEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLGTforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLGEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] >= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLLTforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] < b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLLEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] <= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     L fo F\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLEQforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLNEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLGTforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLGEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] >= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLLTforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] < b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLLEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] <= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     L fo D\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveLEQforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveLNEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveLGTforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveLGEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] >= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveLLTforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] < b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveLLEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] <= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    \/\/ Unsigned comparison: I\/L\n+    \/\/     I fo I\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUIEQforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUINEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUIGTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUIGEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUILTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUILEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     I fo L\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUIEQforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUINEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUIGTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUIGEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUILTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUILEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     I fo F\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveUIEQforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveUINEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveUIGTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveUIGEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveUILTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveUILEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     I fo D\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUIEQforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUINEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUIGTforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n@@ -1031,2 +1864,25 @@\n-            double cc = c[i];\n-            double dd = d[i];\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     L fo I\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveULEQforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveULNEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n@@ -1034,1 +1890,1 @@\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n@@ -1038,1 +1894,0 @@\n-    \/\/     L fo I\n@@ -1084,0 +1939,22 @@\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveULEQforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveULNEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n+        }\n+    }\n+\n@@ -1129,0 +2006,22 @@\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveULEQforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveULNEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n+        }\n+    }\n+\n@@ -1174,0 +2073,34 @@\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveULEQforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveULNEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n+        }\n+    }\n+\n@@ -1526,0 +2459,3 @@\n+                 \/\/     I for I\n+                 \"testCMoveIEQforI\",\n+                 \"testCMoveINEforI\",\n@@ -1527,0 +2463,6 @@\n+                 \"testCMoveIGEforI\",\n+                 \"testCMoveILTforI\",\n+                 \"testCMoveILEforI\",\n+                 \/\/     I for L\n+                 \"testCMoveIEQforL\",\n+                 \"testCMoveINEforL\",\n@@ -1528,0 +2470,6 @@\n+                 \"testCMoveIGEforL\",\n+                 \"testCMoveILTforL\",\n+                 \"testCMoveILEforL\",\n+                 \/\/     I for F\n+                 \"testCMoveIEQforF\",\n+                 \"testCMoveINEforF\",\n@@ -1529,0 +2477,6 @@\n+                 \"testCMoveIGEforF\",\n+                 \"testCMoveILTforF\",\n+                 \"testCMoveILEforF\",\n+                 \/\/     I for D\n+                 \"testCMoveIEQforD\",\n+                 \"testCMoveINEforD\",\n@@ -1530,0 +2484,6 @@\n+                 \"testCMoveIGEforD\",\n+                 \"testCMoveILTforD\",\n+                 \"testCMoveILEforD\",\n+                 \/\/     L for I\n+                 \"testCMoveLEQforI\",\n+                 \"testCMoveLNEforI\",\n@@ -1531,0 +2491,6 @@\n+                 \"testCMoveLGEforI\",\n+                 \"testCMoveLLTforI\",\n+                 \"testCMoveLLEforI\",\n+                 \/\/     L for L\n+                 \"testCMoveLEQforL\",\n+                 \"testCMoveLNEforL\",\n@@ -1532,0 +2498,6 @@\n+                 \"testCMoveLGEforL\",\n+                 \"testCMoveLLTforL\",\n+                 \"testCMoveLLEforL\",\n+                 \/\/     L for F\n+                 \"testCMoveLEQforF\",\n+                 \"testCMoveLNEforF\",\n@@ -1533,0 +2505,6 @@\n+                 \"testCMoveLGEforF\",\n+                 \"testCMoveLLTforF\",\n+                 \"testCMoveLLEforF\",\n+                 \/\/     L for D\n+                 \"testCMoveLEQforD\",\n+                 \"testCMoveLNEforD\",\n@@ -1534,0 +2512,3 @@\n+                 \"testCMoveLGEforD\",\n+                 \"testCMoveLLTforD\",\n+                 \"testCMoveLLEforD\",\n@@ -1536,0 +2517,2 @@\n+                 \"testCMoveUIEQforI\",\n+                 \"testCMoveUINEforI\",\n@@ -1541,0 +2524,2 @@\n+                 \"testCMoveUIEQforL\",\n+                 \"testCMoveUINEforL\",\n@@ -1546,0 +2531,2 @@\n+                 \"testCMoveUIEQforF\",\n+                 \"testCMoveUINEforF\",\n@@ -1551,0 +2538,2 @@\n+                 \"testCMoveUIEQforD\",\n+                 \"testCMoveUINEforD\",\n@@ -1556,0 +2545,2 @@\n+                 \"testCMoveULEQforI\",\n+                 \"testCMoveULNEforI\",\n@@ -1561,0 +2552,2 @@\n+                 \"testCMoveULEQforL\",\n+                 \"testCMoveULNEforL\",\n@@ -1566,0 +2559,2 @@\n+                 \"testCMoveULEQforF\",\n+                 \"testCMoveULNEforF\",\n@@ -1571,0 +2566,2 @@\n+                 \"testCMoveULEQforD\",\n+                 \"testCMoveULNEforD\",\n@@ -1626,0 +2623,11 @@\n+        \/\/     I for I\n+        testCMoveIEQforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveIEQforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveINEforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveINEforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n@@ -1631,0 +2639,26 @@\n+        testCMoveIGEforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveIGEforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveILTforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveILTforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveILEforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveILEforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        \/\/     I for L\n+        testCMoveIEQforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveIEQforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveINEforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveINEforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n@@ -1636,0 +2670,26 @@\n+        testCMoveIGEforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveIGEforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveILTforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveILTforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveILEforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveILEforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        \/\/     I for F\n+        testCMoveIEQforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveIEQforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveINEforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveINEforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n@@ -1641,0 +2701,26 @@\n+        testCMoveIGEforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveIGEforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveILTforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveILTforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveILEforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveILEforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        \/\/     I for D\n+        testCMoveIEQforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveIEQforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveINEforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveINEforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n@@ -1646,0 +2732,26 @@\n+        testCMoveIGEforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveIGEforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveILTforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveILTforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveILEforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveILEforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        \/\/     L for I\n+        testCMoveLEQforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveLEQforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveLNEforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveLNEforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n@@ -1651,0 +2763,26 @@\n+        testCMoveLGEforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveLGEforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveLLTforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveLLTforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveLLEforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveLLEforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        \/\/     L for L\n+        testCMoveLEQforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveLEQforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveLNEforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveLNEforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n@@ -1656,0 +2794,26 @@\n+        testCMoveLGEforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveLGEforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveLLTforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveLLTforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveLLEforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveLLEforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        \/\/     L for F\n+        testCMoveLEQforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveLEQforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveLNEforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveLNEforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n@@ -1661,0 +2825,26 @@\n+        testCMoveLGEforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveLGEforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveLLTforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveLLTforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveLLEforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveLLEforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        \/\/     L for D\n+        testCMoveLEQforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveLEQforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveLNEforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveLNEforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n@@ -1666,0 +2856,15 @@\n+        testCMoveLGEforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveLGEforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveLLTforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveLLTforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveLLEforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveLLEforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n@@ -1668,0 +2873,10 @@\n+        testCMoveUIEQforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveUIEQforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveUINEforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveUINEforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n@@ -1689,0 +2904,10 @@\n+        testCMoveUIEQforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveUIEQforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveUINEforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveUINEforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n@@ -1710,0 +2935,10 @@\n+        testCMoveUIEQforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveUIEQforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveUINEforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveUINEforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n@@ -1731,0 +2966,10 @@\n+        testCMoveUIEQforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveUIEQforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveUINEforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveUINEforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n@@ -1752,0 +2997,10 @@\n+        testCMoveULEQforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveULEQforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveULNEforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveULNEforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n@@ -1773,0 +3028,10 @@\n+        testCMoveULEQforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveULEQforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveULNEforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveULNEforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n@@ -1794,0 +3059,10 @@\n+        testCMoveULEQforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveULEQforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveULNEforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveULNEforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n@@ -1815,0 +3090,10 @@\n+        testCMoveULEQforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveULEQforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveULNEforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveULNEforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorConditionalMove.java","additions":1385,"deletions":100,"binary":false,"changes":1485,"status":"modified"}]}