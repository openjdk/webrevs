{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -725,0 +725,1 @@\n+  bool has_scoped_access = false;\n@@ -732,0 +733,1 @@\n+    has_scoped_access = stream->read_bool(\"hasScopedAccess\");\n@@ -798,0 +800,1 @@\n+                                        has_scoped_access,\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2081,0 +2081,1 @@\n+                                                       bool has_scoped_access,\n@@ -2186,1 +2187,1 @@\n-        nm->set_has_scoped_access(true); \/\/ conservative\n+        nm->set_has_scoped_access(has_scoped_access);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -455,0 +455,1 @@\n+                                           bool                      has_scoped_access,\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -658,0 +658,1 @@\n+  declare_constant(ConstMethodFlags::_misc_is_scoped)                     \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -566,0 +566,1 @@\n+            writeBoolean(\"hasScopedAccess\", nmethod.hasScopedAccess());\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotCompiledCodeStream.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,0 +103,18 @@\n+\n+    \/**\n+     * Determines if {@code methods} contains at least one entry for which {@code HotSpotResolvedJavaMethod.isScoped()} returns true.\n+     *\/\n+    public boolean hasScopedAccess() {\n+        if (methods == null) {\n+            return false;\n+        }\n+        for (ResolvedJavaMethod method : methods) {\n+            if (method instanceof HotSpotResolvedJavaMethod hotSpotMethod) {\n+                if (hotSpotMethod.isScoped()) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotCompiledNmethod.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -173,1 +173,1 @@\n-        return UNSAFE.getShort(getMethodPointer() + config().methodFlagsOffset);\n+        return UNSAFE.getInt(getMethodPointer() + config().methodFlagsOffset);\n@@ -182,1 +182,1 @@\n-        return UNSAFE.getChar(getConstMethod() + config().constMethodFlagsOffset);\n+        return UNSAFE.getInt(getConstMethod() + config().constMethodFlagsOffset);\n@@ -327,0 +327,11 @@\n+    \/**\n+     * Returns true if this method has a\n+     * {@code jdk.internal.misc.ScopedMemoryAccess.Scoped} annotation.\n+     *\n+     * @return true if Scoped annotation present, false otherwise\n+     *\/\n+    @Override\n+    public boolean isScoped() {\n+        return (getConstMethodFlags() & config().constMethodFlagsIsScoped) != 0;\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethodImpl.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -197,0 +197,1 @@\n+    final int constMethodFlagsIsScoped = getConstant(\"ConstMethodFlags::_misc_is_scoped\", Integer.class);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -466,0 +466,10 @@\n+    \/**\n+     * Returns true if this method has a\n+     * {@code jdk.internal.misc.ScopedMemoryAccess.Scoped} annotation.\n+     *\n+     * @return true if Scoped annotation present, false otherwise.\n+     *\/\n+    default boolean isScoped() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/ResolvedJavaMethod.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -478,0 +478,18 @@\n+    @Test\n+    public void isScopedTest() throws NoSuchMethodException, ClassNotFoundException {\n+        \/\/ Must use reflection as ScopedMemoryAccess$Scoped is package-private\n+        Class<? extends Annotation> scopedAnnotationClass = Class.forName(\"jdk.internal.misc.ScopedMemoryAccess$Scoped\").asSubclass(Annotation.class);\n+        boolean scopedMethodFound = false;\n+        for (Map.Entry<Method, ResolvedJavaMethod> e : methods.entrySet()) {\n+            ResolvedJavaMethod m = e.getValue();\n+            Method key = e.getKey();\n+            boolean expect = key.isAnnotationPresent(scopedAnnotationClass);\n+            boolean actual = m.isScoped();\n+            assertEquals(m.toString(), expect, actual);\n+            if (expect) {\n+                scopedMethodFound = true;\n+            }\n+        }\n+        assertTrue(\"At least one scoped method must be present\", scopedMethodFound);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaMethod.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+import jdk.internal.misc.ScopedMemoryAccess;\n@@ -118,1 +119,1 @@\n-                        InnerStaticFinalClass.class, PrivateInnerClass.class, ProtectedInnerClass.class};\n+                        InnerStaticFinalClass.class, PrivateInnerClass.class, ProtectedInnerClass.class, ScopedMemoryAccess.class};\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TypeUniverse.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}