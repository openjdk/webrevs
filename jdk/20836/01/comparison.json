{"files":[{"patch":"@@ -830,1 +830,1 @@\n-            boolean genericPatternsExpanded = false;\n+            boolean useHashes = true;\n@@ -836,1 +836,1 @@\n-                    updatedPatterns = reduceNestedPatterns(updatedPatterns);\n+                    updatedPatterns = reduceNestedPatterns(updatedPatterns, useHashes);\n@@ -843,1 +843,1 @@\n-                    if (!repeat && !genericPatternsExpanded) {\n+                    if (!repeat) {\n@@ -845,1 +845,1 @@\n-                        \/\/class B extends S1, S2\n+                        \/\/class B permits S1, S2\n@@ -847,1 +847,1 @@\n-                        \/\/this should be joined to R(B, S2),\n+                        \/\/this might be joined to R(B, S2), as B could be rewritten to S2\n@@ -849,5 +849,8 @@\n-                        \/\/attempt to once expand all types to their transitive permitted types,\n-                        \/\/on all depth of nesting:\n-                        updatedPatterns = expandGenericPatterns(updatedPatterns);\n-                        genericPatternsExpanded = true;\n-                        repeat = !updatedPatterns.equals(patterns);\n+                        \/\/disable the use of hashing, and use subtyping in\n+                        \/\/reduceNestedPatterns to handle situations like this:\n+                        repeat = useHashes;\n+                        useHashes = false;\n+                    } else {\n+                        \/\/if a reduction happened, make sure hashing in reduceNestedPatterns\n+                        \/\/is enabled, as the hashing speeds up the process significantly:\n+                        useHashes = true;\n@@ -1026,0 +1029,6 @@\n+         *\n+         * useHashes: when true, patterns will be subject to exact equivalence;\n+         *            when false, two binding patterns will be considered equivalent\n+         *            if one of them is more generic than the other one;\n+         *            when false, the processing will be significantly slower,\n+         *            as pattern hashes cannot be used to speed up the matching process\n@@ -1027,1 +1036,2 @@\n-        private Set<PatternDescription> reduceNestedPatterns(Set<PatternDescription> patterns) {\n+        private Set<PatternDescription> reduceNestedPatterns(Set<PatternDescription> patterns,\n+                                                             boolean useHashes) {\n@@ -1052,1 +1062,1 @@\n-                    var groupByHashes =\n+                    var groupEquivalenceCandidates =\n@@ -1057,2 +1067,2 @@\n-                             .collect(groupingBy(pd -> pd.hashCode(mismatchingCandidateFin)));\n-                    for (var candidates : groupByHashes.values()) {\n+                             .collect(groupingBy(pd -> useHashes ? pd.hashCode(mismatchingCandidateFin) : 0));\n+                    for (var candidates : groupEquivalenceCandidates.values()) {\n@@ -1079,3 +1089,12 @@\n-                                        if (i != mismatchingCandidate &&\n-                                            !rpOne.nested[i].equals(rpOther.nested[i])) {\n-                                            continue NEXT_PATTERN;\n+                                        if (i != mismatchingCandidate) {\n+                                            if (!rpOne.nested[i].equals(rpOther.nested[i])) {\n+                                                if (useHashes ||\n+                                                    \/\/when not using hashes,\n+                                                    \/\/check if rpOne.nested[i] is\n+                                                    \/\/a subtype of rpOther.nested[i]:\n+                                                    !(rpOne.nested[i] instanceof BindingPattern bpOne) ||\n+                                                    !(rpOther.nested[i] instanceof BindingPattern bpOther) ||\n+                                                    !types.isSubtype(types.erasure(bpOne.type), types.erasure(bpOther.type))) {\n+                                                    continue NEXT_PATTERN;\n+                                                }\n+                                            }\n@@ -1089,1 +1108,1 @@\n-                            var updatedPatterns = reduceNestedPatterns(nestedPatterns);\n+                            var updatedPatterns = reduceNestedPatterns(nestedPatterns, useHashes);\n@@ -1096,1 +1115,3 @@\n-                                current.removeAll(join);\n+                                if (useHashes) {\n+                                    current.removeAll(join);\n+                                }\n@@ -1172,34 +1193,0 @@\n-        private Set<PatternDescription> expandGenericPatterns(Set<PatternDescription> patterns) {\n-            var newPatterns = new HashSet<PatternDescription>(patterns);\n-            boolean modified;\n-            do {\n-                modified = false;\n-                for (PatternDescription pd : patterns) {\n-                    if (pd instanceof RecordPattern rpOne) {\n-                        for (int i = 0; i < rpOne.nested.length; i++) {\n-                            Set<PatternDescription> toExpand = Set.of(rpOne.nested[i]);\n-                            Set<PatternDescription> expanded = expandGenericPatterns(toExpand);\n-                            if (expanded != toExpand) {\n-                                expanded.removeAll(toExpand);\n-                                for (PatternDescription exp : expanded) {\n-                                    PatternDescription[] newNested = Arrays.copyOf(rpOne.nested, rpOne.nested.length);\n-                                    newNested[i] = exp;\n-                                    modified |= newPatterns.add(new RecordPattern(rpOne.recordType(), rpOne.fullComponentTypes(), newNested));\n-                                }\n-                            }\n-                        }\n-                    } else if (pd instanceof BindingPattern bp) {\n-                        Set<Symbol> permittedSymbols = allPermittedSubTypes(bp.type.tsym, cs -> true);\n-\n-                        if (!permittedSymbols.isEmpty()) {\n-                            for (Symbol permitted : permittedSymbols) {\n-                                \/\/TODO infer.instantiatePatternType(selectorType, csym); (?)\n-                                modified |= newPatterns.add(new BindingPattern(permitted.type));\n-                            }\n-                        }\n-                    }\n-                }\n-            } while (modified);\n-            return newPatterns;\n-        }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":40,"deletions":53,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-tools\/javac\/patterns\/Exhaustiveness.java \t\t\t\t\t8326616    generic-all    intermittently timeout\n","filename":"test\/langtools\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}