{"files":[{"patch":"@@ -92,1 +92,1 @@\n-    bool yield_if_necessary(G1HeapRegion* hr) {\n+    bool yield_if_necessary() {\n@@ -95,5 +95,1 @@\n-        \/\/ If a yield occurs (potential young-gc pause), must recheck for\n-        \/\/ potential regions reclamation.\n-        if (_cm->do_yield_check() && !should_rebuild_or_scrub(hr)) {\n-          return true;\n-        }\n+        _cm->do_yield_check();\n@@ -118,1 +114,2 @@\n-    void scan_large_object(G1HeapRegion* hr, const oop obj, MemRegion scan_range) {\n+    \/\/ Returns true if marking has been aborted or false if completed.\n+    bool scan_large_object(G1HeapRegion* hr, const oop obj, MemRegion scan_range) {\n@@ -128,3 +125,8 @@\n-\n-        if (yield_if_necessary(hr)) {\n-          return;\n+        bool mark_aborted = yield_if_necessary();\n+        if (mark_aborted) {\n+          return true;\n+        } else if (!should_rebuild_or_scrub(hr)) {\n+          \/\/ We need to check should_rebuild_or_scrub() again because the region might\n+          \/\/ have been reclaimed during above yield\/safepoint.\n+          log_trace(gc, marking)(\"Rebuild aborted for reclaimed region: %u\", hr->hrm_index());\n+          return false;\n@@ -136,0 +138,1 @@\n+      return false;\n@@ -165,11 +168,34 @@\n-    \/\/ Scan or scrub depending on if addr is marked.\n-    HeapWord* scan_or_scrub(G1HeapRegion* hr, HeapWord* addr, HeapWord* limit) {\n-      if (_bitmap->is_marked(addr)) {\n-        \/\/  Live object, need to scan to rebuild remembered sets for this object.\n-        return addr + scan_object(hr, addr);\n-      } else {\n-        \/\/ Found dead object (which klass has potentially been unloaded). Scrub to next marked object.\n-        HeapWord* scrub_end = _bitmap->get_next_marked_addr(addr, limit);\n-        hr->fill_range_with_dead_objects(addr, scrub_end);\n-        \/\/ Return the next object to handle.\n-        return scrub_end;\n+    \/\/ Scrub a range of dead objects starting at scrub_start. Will never scrub past limit.\n+    HeapWord* scrub_to_next_live(G1HeapRegion* hr, HeapWord* scrub_start, HeapWord* limit) {\n+      assert(!_bitmap->is_marked(scrub_start), \"Should not scrub live object\");\n+\n+      HeapWord* scrub_end = _bitmap->get_next_marked_addr(scrub_start, limit);\n+      hr->fill_range_with_dead_objects(scrub_start, scrub_end);\n+\n+      \/\/ Return the next object to handle.\n+      return scrub_end;\n+    }\n+\n+    \/\/ Scan the given region from bottom to parsable_bottom. Returns whether marking has\n+    \/\/ been aborted.\n+    bool scan_and_scrub_to_pb(G1HeapRegion* hr, HeapWord* start, HeapWord* const limit) {\n+\n+      while (start < limit) {\n+        if (_bitmap->is_marked(start)) {\n+          \/\/  Live object, need to scan to rebuild remembered sets for this object.\n+          start += scan_object(hr, start);\n+        } else {\n+          \/\/ Found dead object (which klass has potentially been unloaded). Scrub to next\n+          \/\/ marked object and continue.\n+          start = scrub_to_next_live(hr, start, limit);\n+        }\n+\n+        bool mark_aborted = yield_if_necessary();\n+        if (mark_aborted) {\n+          return true;\n+        } else if (!should_rebuild_or_scrub(hr)) {\n+          \/\/ We need to check should_rebuild_or_scrub() again because the region might\n+          \/\/ have been reclaimed during above yield\/safepoint.\n+          log_trace(gc, marking)(\"Scan and scrub aborted for reclaimed region: %u\", hr->hrm_index());\n+          return false;\n+        }\n@@ -177,0 +203,1 @@\n+      return false;\n@@ -179,2 +206,23 @@\n-    \/\/ Scan and scrub the given region to tars.\n-    void scan_and_scrub_region(G1HeapRegion* hr, HeapWord* const pb) {\n+    \/\/ Scan the given region from parsable_bottom to tars. Returns whether marking has\n+    \/\/ been aborted.\n+    bool scan_from_pb_to_tars(G1HeapRegion* hr, HeapWord* start, HeapWord* const limit) {\n+\n+      while (start < limit) {\n+        start += scan_object(hr, start);\n+        \/\/ Avoid stalling safepoints and stop iteration if mark cycle has been aborted.\n+        bool mark_aborted = yield_if_necessary();\n+        if (mark_aborted) {\n+          return true;\n+        } else if (!should_rebuild_or_scrub(hr)) {\n+          \/\/ We need to check should_rebuild_or_scrub() again because the region might\n+          \/\/ have been reclaimed during above yield\/safepoint.\n+          log_trace(gc, marking)(\"Scan aborted for reclaimed region: %u\", hr->hrm_index());\n+          return false;\n+        }\n+      }\n+      return false;\n+    }\n+\n+    \/\/ Scan and scrub the given region to tars. Returns whether marking has\n+    \/\/ been aborted.\n+    bool scan_and_scrub_region(G1HeapRegion* hr, HeapWord* const pb) {\n@@ -186,11 +234,3 @@\n-      {\n-        \/\/ Step 1: Scan the given region from bottom to parsable_bottom.\n-        HeapWord* start = hr->bottom();\n-        HeapWord* limit = pb;\n-        while (start < limit) {\n-          start = scan_or_scrub(hr, start, limit);\n-\n-          if (yield_if_necessary(hr)) {\n-            return;\n-          }\n-        }\n+      if (scan_and_scrub_to_pb(hr, hr->bottom(), pb)) {\n+        log_trace(gc, marking)(\"Scan and scrub aborted for region: %u\", hr->hrm_index());\n+        return true;\n@@ -199,0 +239,5 @@\n+      \/\/ Yielding during scrubbing and scanning might have reclaimed the region, so need to\n+      \/\/ re-check after above.\n+      if (!should_rebuild_or_scrub(hr)) {\n+        return false;\n+      }\n@@ -203,11 +248,4 @@\n-      {\n-        \/\/ Step 2: Rebuild from TAMS (= parsable_bottom) to TARS.\n-        HeapWord* start = pb;\n-        HeapWord* limit = _cm->top_at_rebuild_start(hr);\n-        while (start < limit) {\n-          start += scan_object(hr, start);\n-\n-          if (yield_if_necessary(hr)) {\n-            return;\n-          }\n-        }\n+      \/\/ Rebuild from TAMS (= parsable_bottom) to TARS.\n+      if (scan_from_pb_to_tars(hr, pb, _cm->top_at_rebuild_start(hr))) {\n+        log_trace(gc, marking)(\"Rebuild aborted for region: %u (%s)\", hr->hrm_index(), hr->get_short_type_str());\n+        return true;\n@@ -215,0 +253,1 @@\n+      return false;\n@@ -218,2 +257,2 @@\n-    \/\/ stalling safepoints.\n-    void scan_humongous_region(G1HeapRegion* hr, HeapWord* const pb) {\n+    \/\/ stalling safepoints. Returns whether the concurrent marking phase has been aborted.\n+    bool scan_humongous_region(G1HeapRegion* hr, HeapWord* const pb) {\n@@ -224,1 +263,1 @@\n-        return;\n+        return false;\n@@ -242,1 +281,6 @@\n-      scan_large_object(hr, humongous, mr);\n+      bool mark_aborted = scan_large_object(hr, humongous, mr);\n+      if (mark_aborted) {\n+        log_trace(gc, marking)(\"Rebuild aborted for region: %u (%s)\", hr->hrm_index(), hr->get_short_type_str());\n+        return true;\n+      }\n+      return false;\n@@ -271,0 +315,1 @@\n+      bool mark_aborted;\n@@ -273,1 +318,1 @@\n-        scan_and_scrub_region(hr, pb);\n+        mark_aborted = scan_and_scrub_region(hr, pb);\n@@ -277,1 +322,1 @@\n-        scan_humongous_region(hr, pb);\n+        mark_aborted = scan_humongous_region(hr, pb);\n@@ -280,1 +325,1 @@\n-      return _cm->has_aborted();\n+      return mark_aborted;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRebuildAndScrub.cpp","additions":97,"deletions":52,"binary":false,"changes":149,"status":"modified"}]}