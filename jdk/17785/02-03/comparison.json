{"files":[{"patch":"@@ -1711,1 +1711,1 @@\n-const AlignmentSolution* SuperWord::pack_alignment_solution(Node_List* pack) {\n+const AlignmentSolution* SuperWord::pack_alignment_solution(const Node_List* pack) {\n@@ -1755,10 +1755,0 @@\n-  int new_packset_length = 0;\n-  for (int i = 0; i < _packset.length(); i++) {\n-    Node_List* pack = _packset.at(i);\n-    assert(pack != nullptr, \"no nullptr in packset\");\n-    bool keep = true;\n-    if (pack->at(0)->is_Load() || pack->at(0)->is_Store()) {\n-      mem_ops_count++;\n-      \/\/ Find solution for pack p, and filter with current solution.\n-      const AlignmentSolution* s = pack_alignment_solution(pack);\n-      const AlignmentSolution* intersect = current->filter(s);\n@@ -1766,8 +1756,12 @@\n-#ifndef PRODUCT\n-      if (is_trace_align_vector()) {\n-        tty->print(\"  solution for pack:         \");\n-        s->print();\n-        tty->print(\"  intersection with current: \");\n-        intersect->print();\n-      }\n-#endif\n+  filter_packs(\"SuperWord::filter_packs_for_alignment\",\n+               \"rejected by AlignVector (strinct alignment requirement)\",\n+               [&](const Node_List* pack) {\n+                 \/\/ Only memops need to be aligned.\n+                 if (!pack->at(0)->is_Load() &&\n+                     !pack->at(0)->is_Store()) {\n+                   return true; \/\/ accept all non memops\n+                 }\n+\n+                 mem_ops_count++;\n+                 const AlignmentSolution* s = pack_alignment_solution(pack);\n+                 const AlignmentSolution* intersect = current->filter(s);\n@@ -1775,2 +1769,0 @@\n-      if (intersect->is_empty()) {\n-        \/\/ Solution failed or is not compatible, remove pack i.\n@@ -1778,4 +1770,6 @@\n-        if (is_trace_superword_rejections() || is_trace_align_vector()) {\n-          tty->print_cr(\"Rejected by AlignVector:\");\n-          pack->at(0)->dump();\n-        }\n+                 if (is_trace_align_vector()) {\n+                   tty->print(\"  solution for pack:         \");\n+                   s->print();\n+                   tty->print(\"  intersection with current: \");\n+                   intersect->print();\n+                 }\n@@ -1783,14 +1777,4 @@\n-        keep = false;\n-        mem_ops_rejected++;\n-      } else {\n-        \/\/ Solution is compatible.\n-        current = intersect;\n-      }\n-    }\n-    if (keep) {\n-      assert(i >= new_packset_length, \"only move packs down\");\n-      _packset.at_put(new_packset_length++, pack);\n-    } else {\n-      remove_pack_at(i);\n-    }\n-  }\n+                 if (intersect->is_empty()) {\n+                   mem_ops_rejected++;\n+                   return false; \/\/ reject because of empty solution\n+                 }\n@@ -1798,2 +1782,3 @@\n-  assert(_packset.length() >= new_packset_length, \"filter only reduces number of packs\");\n-  _packset.trunc_to(new_packset_length);\n+                 current = intersect;\n+                 return true; \/\/ accept because of non-empty solution\n+               });\n@@ -1816,7 +1801,0 @@\n-\n-#ifndef PRODUCT\n-  if (is_trace_superword_packset() || is_trace_align_vector()) {\n-    tty->print_cr(\"\\nAfter Superword::filter_packs_for_alignment\");\n-    print_packset();\n-  }\n-#endif\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":26,"deletions":48,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -526,1 +526,1 @@\n-  const AlignmentSolution* pack_alignment_solution(Node_List* pack);\n+  const AlignmentSolution* pack_alignment_solution(const Node_List* pack);\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}