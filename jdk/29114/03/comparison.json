{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,2 +119,2 @@\n-    _oop_queue_set(_num_workers),\n-    _array_queue_set(_num_workers),\n+    _marking_task_queues(_num_workers),\n+    _partial_array_state_manager(nullptr),\n@@ -143,0 +143,2 @@\n+  _partial_array_state_manager = new PartialArrayStateManager(_num_workers);\n+\n@@ -146,2 +148,1 @@\n-    _oop_queue_set.register_queue(i, marker(i)->oop_stack());\n-    _array_queue_set.register_queue(i, marker(i)->objarray_stack());\n+    _marking_task_queues.register_queue(i, marker(i)->task_queue());\n@@ -149,0 +150,1 @@\n+\n@@ -154,0 +156,4 @@\n+PartialArrayStateManager* G1FullCollector::partial_array_state_manager() const {\n+  return _partial_array_state_manager;\n+}\n+\n@@ -160,0 +166,2 @@\n+  delete _partial_array_state_manager;\n+\n@@ -305,1 +313,1 @@\n-    assert(marker(0)->oop_stack()->is_empty(), \"Should be no oops on the stack\");\n+    assert(marker(0)->task_queue()->is_empty(), \"Should be no oops on the stack\");\n@@ -331,2 +339,1 @@\n-  oop_queue_set()->print_and_reset_taskqueue_stats(\"Oop Queue\");\n-  array_queue_set()->print_and_reset_taskqueue_stats(\"ObjArrayOop Queue\");\n+  marking_task_queues()->print_and_reset_taskqueue_stats(\"Marking Task Queue\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,2 +82,2 @@\n-  OopQueueSet               _oop_queue_set;\n-  ObjArrayTaskQueueSet      _array_queue_set;\n+  G1MarkTasksQueueSet       _marking_task_queues;\n+  PartialArrayStateManager* _partial_array_state_manager;\n@@ -116,2 +116,1 @@\n-  OopQueueSet*             oop_queue_set() { return &_oop_queue_set; }\n-  ObjArrayTaskQueueSet*    array_queue_set() { return &_array_queue_set; }\n+  G1MarkTasksQueueSet*     marking_task_queues() { return &_marking_task_queues; }\n@@ -128,0 +127,2 @@\n+  PartialArrayStateManager* partial_array_state_manager() const;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.hpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-    _terminator(collector->workers(), collector->array_queue_set()) {\n+    _terminator(collector->workers(), collector->marking_task_queues()) {\n@@ -57,1 +57,1 @@\n-  marker->complete_marking(collector()->oop_queue_set(), collector()->array_queue_set(), &_terminator);\n+  marker->complete_marking(collector()->marking_task_queues(), &_terminator);\n@@ -60,2 +60,1 @@\n-  assert(marker->oop_stack()->is_empty(), \"Marking should have completed\");\n-  assert(marker->objarray_stack()->is_empty(), \"Array marking should have completed\");\n+  assert(marker->task_queue()->is_empty(), \"Marking should have completed\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarkTask.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+#include \"gc\/shared\/partialArraySplitter.inline.hpp\"\n+#include \"gc\/shared\/partialArrayState.hpp\"\n@@ -39,2 +41,2 @@\n-    _oop_stack(),\n-    _objarray_stack(),\n+    _task_queue(),\n+    _partial_array_splitter(collector->partial_array_state_manager(), collector->workers(), ObjArrayMarkingStride),\n@@ -50,1 +52,1 @@\n-  assert(is_empty(), \"Must be empty at this point\");\n+  assert(is_task_queue_empty(), \"Must be empty at this point\");\n@@ -53,2 +55,19 @@\n-void G1FullGCMarker::complete_marking(OopQueueSet* oop_stacks,\n-                                      ObjArrayTaskQueueSet* array_stacks,\n+void G1FullGCMarker::follow_partial_objArray(PartialArrayState* state, bool stolen) {\n+  \/\/ Access state before release by claim().\n+  objArrayOop obj_array = objArrayOop(state->source());\n+  PartialArraySplitter::Claim claim =\n+    _partial_array_splitter.claim(state, task_queue(), stolen);\n+  follow_array(obj_array, claim._start, claim._end);\n+}\n+\n+void G1FullGCMarker::start_partial_objArray(objArrayOop obj) {\n+  mark_closure()->do_klass(obj->klass());\n+  \/\/ Don't push empty arrays to avoid unnecessary work.\n+  size_t array_length = obj->length();\n+  if (array_length > 0) {\n+    size_t initial_chunk_size = _partial_array_splitter.start(task_queue(), obj, nullptr, array_length);\n+    follow_array(obj, 0, initial_chunk_size);\n+  }\n+}\n+\n+void G1FullGCMarker::complete_marking(G1ScannerTasksQueueSet* task_queues,\n@@ -58,8 +77,3 @@\n-    ObjArrayTask steal_array;\n-    if (array_stacks->steal(_worker_id, steal_array)) {\n-      follow_array_chunk(objArrayOop(steal_array.obj()), steal_array.index());\n-    } else {\n-      oop steal_oop;\n-      if (oop_stacks->steal(_worker_id, steal_oop)) {\n-        follow_object(steal_oop);\n-      }\n+    ScannerTask stolen_task;\n+    if (task_queues->steal(_worker_id, stolen_task)) {\n+      dispatch_task(stolen_task, true);\n@@ -67,1 +81,1 @@\n-  } while (!is_empty() || !terminator->offer_termination());\n+  } while (!is_task_queue_empty() || !terminator->offer_termination());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.cpp","additions":29,"deletions":15,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+#include \"gc\/shared\/partialArraySplitter.hpp\"\n+#include \"gc\/shared\/partialArrayState.hpp\"\n@@ -41,2 +43,0 @@\n-typedef OverflowTaskQueue<oop, mtGC>                 OopQueue;\n-typedef OverflowTaskQueue<ObjArrayTask, mtGC>        ObjArrayTaskQueue;\n@@ -44,2 +44,0 @@\n-typedef GenericTaskQueueSet<OopQueue, mtGC>          OopQueueSet;\n-typedef GenericTaskQueueSet<ObjArrayTaskQueue, mtGC> ObjArrayTaskQueueSet;\n@@ -51,0 +49,3 @@\n+typedef OverflowTaskQueue<ScannerTask, mtGC>        G1MarkTasksQueue;\n+typedef GenericTaskQueueSet<G1MarkTasksQueue, mtGC> G1MarkTasksQueueSet;\n+\n@@ -59,2 +60,2 @@\n-  OopQueue           _oop_stack;\n-  ObjArrayTaskQueue  _objarray_stack;\n+  G1MarkTasksQueue     _task_queue;\n+  PartialArraySplitter _partial_array_splitter;\n@@ -71,2 +72,1 @@\n-  inline bool is_empty();\n-  inline void push_objarray(oop obj, size_t index);\n+  inline bool is_task_queue_empty();\n@@ -76,3 +76,7 @@\n-  inline void follow_object(oop obj);\n-  inline void follow_array(objArrayOop array);\n-  inline void follow_array_chunk(objArrayOop array, int index);\n+  inline void follow_array(objArrayOop obj, size_t start, size_t end);\n+  inline void dispatch_task(const ScannerTask& task, bool stolen);\n+  \/\/ Start processing the given objArrayOop by first pushing its continuations and\n+  \/\/ then scanning the first chunk.\n+  void start_partial_objArray(objArrayOop obj);\n+  \/\/ Process the given continuation.\n+  void follow_partial_objArray(PartialArrayState* state, bool stolen);\n@@ -81,6 +85,0 @@\n-  \/\/ Try to publish all contents from the objArray task queue overflow stack to\n-  \/\/ the shared objArray stack.\n-  \/\/ Returns true and a valid task if there has not been enough space in the shared\n-  \/\/ objArray stack, otherwise returns false and the task is invalid.\n-  inline bool publish_or_pop_objarray_tasks(ObjArrayTask& task);\n-\n@@ -93,3 +91,1 @@\n-  \/\/ Stack getters\n-  OopQueue*          oop_stack()       { return &_oop_stack; }\n-  ObjArrayTaskQueue* objarray_stack()  { return &_objarray_stack; }\n+  G1MarkTasksQueue* task_queue()       { return &_task_queue; }\n@@ -101,2 +97,1 @@\n-  void complete_marking(OopQueueSet* oop_stacks,\n-                        ObjArrayTaskQueueSet* array_stacks,\n+  void complete_marking(G1MarkTasksQueueSet* task_queues,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.hpp","additions":18,"deletions":23,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -74,1 +75,1 @@\n-      _oop_stack.push(obj);\n+      _task_queue.push(ScannerTask(obj));\n@@ -80,2 +81,2 @@\n-inline bool G1FullGCMarker::is_empty() {\n-  return _oop_stack.is_empty() && _objarray_stack.is_empty();\n+inline bool G1FullGCMarker::is_task_queue_empty() {\n+  return _task_queue.is_empty();\n@@ -84,4 +85,4 @@\n-inline void G1FullGCMarker::push_objarray(oop obj, size_t index) {\n-  ObjArrayTask task(obj, index);\n-  assert(task.is_valid(), \"bad ObjArrayTask\");\n-  _objarray_stack.push(task);\n+inline void G1FullGCMarker::follow_array(objArrayOop obj, size_t start, size_t end) {\n+  obj->oop_iterate_elements_range(mark_closure(),\n+                                  checked_cast<int>(start),\n+                                  checked_cast<int>(end));\n@@ -90,30 +91,4 @@\n-inline void G1FullGCMarker::follow_array(objArrayOop array) {\n-  mark_closure()->do_klass(array->klass());\n-  \/\/ Don't push empty arrays to avoid unnecessary work.\n-  if (array->length() > 0) {\n-    push_objarray(array, 0);\n-  }\n-}\n-\n-void G1FullGCMarker::follow_array_chunk(objArrayOop array, int index) {\n-  const int len = array->length();\n-  const int beg_index = index;\n-  assert(beg_index < len || len == 0, \"index too large\");\n-\n-  const int stride = MIN2(len - beg_index, (int) ObjArrayMarkingStride);\n-  const int end_index = beg_index + stride;\n-\n-  \/\/ Push the continuation first to allow more efficient work stealing.\n-  if (end_index < len) {\n-    push_objarray(array, end_index);\n-  }\n-\n-  array->oop_iterate_elements_range(mark_closure(), beg_index, end_index);\n-}\n-\n-inline void G1FullGCMarker::follow_object(oop obj) {\n-  assert(_bitmap->is_marked(obj), \"should be marked\");\n-  if (obj->is_objArray()) {\n-    \/\/ Handle object arrays explicitly to allow them to\n-    \/\/ be split into chunks if needed.\n-    follow_array((objArrayOop)obj);\n+inline void G1FullGCMarker::dispatch_task(const ScannerTask& task, bool stolen) {\n+  if (task.is_partial_array_state()) {\n+    assert(_bitmap->is_marked(task.to_partial_array_state()->source()), \"should be marked\");\n+    follow_partial_objArray(task.to_partial_array_state(), stolen);\n@@ -121,1 +96,9 @@\n-    obj->oop_iterate(mark_closure());\n+    oop obj = task.to_oop();\n+    assert(_bitmap->is_marked(obj), \"should be marked\");\n+    if (obj->is_objArray()) {\n+      \/\/ Handle object arrays explicitly to allow them to\n+      \/\/ be split into chunks if needed.\n+      start_partial_objArray((objArrayOop)obj);\n+    } else {\n+      obj->oop_iterate(mark_closure());\n+    }\n@@ -126,5 +109,4 @@\n-  oop obj;\n-  while (_oop_stack.pop_overflow(obj)) {\n-    if (!_oop_stack.try_push_to_taskqueue(obj)) {\n-      assert(_bitmap->is_marked(obj), \"must be marked\");\n-      follow_object(obj);\n+  ScannerTask task;\n+  while (_task_queue.pop_overflow(task)) {\n+    if (!_task_queue.try_push_to_taskqueue(task)) {\n+      dispatch_task(task, false);\n@@ -133,13 +115,2 @@\n-  while (_oop_stack.pop_local(obj)) {\n-    assert(_bitmap->is_marked(obj), \"must be marked\");\n-    follow_object(obj);\n-  }\n-}\n-\n-inline bool G1FullGCMarker::publish_or_pop_objarray_tasks(ObjArrayTask& task) {\n-  \/\/ It is desirable to move as much as possible work from the overflow queue to\n-  \/\/ the shared queue as quickly as possible.\n-  while (_objarray_stack.pop_overflow(task)) {\n-    if (!_objarray_stack.try_push_to_taskqueue(task)) {\n-      return true;\n-    }\n+  while (_task_queue.pop_local(task)) {\n+    dispatch_task(task, false);\n@@ -147,1 +118,0 @@\n-  return false;\n@@ -152,1 +122,0 @@\n-    \/\/ First, drain regular oop stack.\n@@ -154,8 +123,1 @@\n-\n-    \/\/ Then process ObjArrays one at a time to avoid marking stack bloat.\n-    ObjArrayTask task;\n-    if (publish_or_pop_objarray_tasks(task) ||\n-        _objarray_stack.pop_local(task)) {\n-      follow_array_chunk(objArrayOop(task.obj()), task.index());\n-    }\n-  } while (!is_empty());\n+  } while (!is_task_queue_empty());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.inline.hpp","additions":29,"deletions":67,"binary":false,"changes":96,"status":"modified"}]}