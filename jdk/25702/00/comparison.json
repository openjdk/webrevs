{"files":[{"patch":"@@ -26,1 +26,1 @@\n-#include \"asm\/macroAssembler.inline.hpp\"\n+#include \"asm\/macroAssembler.hpp\"\n@@ -31,0 +31,1 @@\n+#include \"nativeInst_aarch64.hpp\"\n@@ -93,1 +94,3 @@\n-  NativeGeneralJump* jump = nativeGeneralJump_at(method_holder->next_instruction_address());\n+  NativeJump* jump = MacroAssembler::codestub_branch_needs_far_jump()\n+                         ? nativeGeneralJump_at(method_holder->next_instruction_address())\n+                         : nativeJump_at(method_holder->next_instruction_address());\n@@ -99,1 +102,5 @@\n-  NativeGeneralJump::insert_unconditional(method_holder->next_instruction_address(), entry);\n+  if (MacroAssembler::codestub_branch_needs_far_jump()) {\n+    NativeGeneralJump::insert_unconditional(method_holder->next_instruction_address(), entry);\n+  } else {\n+    NativeJump::insert(method_holder->next_instruction_address(), entry);\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/compiledIC_aarch64.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -992,2 +992,6 @@\n-  movptr(rscratch1, 0);\n-  br(rscratch1);\n+  if (codestub_branch_needs_far_jump()) {\n+    movptr(rscratch1, 0);\n+    br(rscratch1);\n+  } else {\n+    b(pc());\n+  }\n@@ -997,0 +1001,4 @@\n+  if (!codestub_branch_needs_far_jump()) {\n+    \/\/ isb; movk; movz; movz; b\n+    return 5 * NativeInstruction::instruction_size;\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -362,0 +362,7 @@\n+void NativeJump::insert(address code_pos, address entry) {\n+  CodeBuffer cb(code_pos, instruction_size);\n+  MacroAssembler a(&cb);\n+\n+  a.b(entry);\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2025, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.aarch64;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.*;\n+\n+\/*\n+ * @test\n+ * @summary Calls to c2i interface stubs should be generated with near branches\n+ * for segmented code cache up to 250MB\n+ * @library \/test\/lib \/\n+ *\n+ * @requires vm.flagless\n+ * @requires os.arch==\"aarch64\"\n+ * @requires vm.debug == false\n+ * @requires vm.compiler2.enabled\n+ *\n+ * @run driver compiler.c2.aarch64.TestStaticCallStub\n+ *\/\n+public class TestStaticCallStub {\n+\n+    static String[] nearStaticCallOpcodeSeq = {\"isb\", \"mov\", \"movk\", \"movk\", \"b\"};\n+    static String[] farStaticCallOpcodeSeq = {\"isb\", \"mov\", \"movk\", \"movk\", \"mov\", \"movk\", \"movk\", \"br\"};\n+\n+    static String extractOpcode(String line) {\n+        line = line.trim();\n+        int semicolonIndex = line.indexOf(';');\n+        if (semicolonIndex != -1) {\n+            line = line.substring(0, semicolonIndex).trim();\n+        }\n+\n+        String[] words = line.split(\"\\\\s+\");\n+        if (words.length > 1) {\n+            return words[1];\n+        }\n+\n+        return \"\";\n+    }\n+\n+    static List<String> extractOpcodesN(ListIterator<String> itr, int n) {\n+        List<String> extractedOpcodes = new ArrayList<>();\n+\n+        while (itr.hasNext() && extractedOpcodes.size() < n) {\n+            String opcode = extractOpcode(itr.next());\n+            if (!opcode.isEmpty()) {\n+                extractedOpcodes.add(opcode);\n+            }\n+        }\n+\n+        return extractedOpcodes;\n+    }\n+\n+    static void verifyNearStaticCall(ListIterator<String> itr) {\n+        List<String> extractedOpcodes = extractOpcodesN(itr, nearStaticCallOpcodeSeq.length);\n+\n+        if (!Arrays.asList(nearStaticCallOpcodeSeq).equals(extractedOpcodes)) {\n+            throw new RuntimeException(\"for code cache < 250MB the static call stub is expected to be implemented using near branch\");\n+        }\n+\n+        return;\n+    }\n+\n+    static void verifyFarStaticCall(ListIterator<String> itr) {\n+        List<String> extractedOpcodes = extractOpcodesN(itr, farStaticCallOpcodeSeq.length);\n+\n+        if (!Arrays.asList(farStaticCallOpcodeSeq).equals(extractedOpcodes)) {\n+            throw new RuntimeException(\"for code cache > 250MB the static call stub is expected to be implemented using far branch\");\n+        }\n+\n+        return;\n+    }\n+\n+    static void runVM(boolean bigCodeCache) throws Exception {\n+        String className = TestStaticCallStub.class.getName();\n+        String[] procArgs = {\n+            \"-XX:-Inline\",\n+            \"-Xcomp\",\n+            \"-Xbatch\",\n+            \"-XX:+TieredCompilation\",\n+            \"-XX:+SegmentedCodeCache\",\n+            \"-XX:ReservedCodeCacheSize=\" + (bigCodeCache ? \"256M\" : \"200M\"),\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:CompileCommand=option,\" + className + \"::main,bool,PrintAssembly,true\",\n+            className};\n+\n+\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(procArgs);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        List<String> lines = output.asLines();\n+\n+        ListIterator<String> itr = lines.listIterator();\n+        while (itr.hasNext()) {\n+            String line = itr.next();\n+            if (line.contains(\"{static_stub}\")) {\n+                itr.previous();\n+                if (bigCodeCache) {\n+                    verifyFarStaticCall(itr);\n+                } else {\n+                    verifyNearStaticCall(itr);\n+                }\n+                return;\n+            }\n+        }\n+        throw new RuntimeException(\"Assembly output: static call stub is not found\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length == 0) {\n+            \/\/ Main VM: fork VM with options\n+            runVM(true);\n+            runVM(false);\n+            return;\n+        }\n+        if (args.length > 0) {\n+            \/\/ We are in a forked VM. Just exit\n+            System.out.println(\"Ok\");\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/aarch64\/TestStaticCallStub.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"}]}