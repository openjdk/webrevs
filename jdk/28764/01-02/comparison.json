{"files":[{"patch":"@@ -60,1 +60,1 @@\n-\/\/ use-def edges from the memory input of 'L' to the node 'A' that corresponds to 'a'.\n+\/\/ use-def edges from 'L' to the node 'A' that corresponds to 'a'.\n@@ -100,1 +100,1 @@\n-\/\/     'A', and 'L' must be a transitive use of 'F', similar to case 1.\n+\/\/     'A', and the memory input of 'L' must be a transitive use of 'F', similar to case 1.\n@@ -102,2 +102,1 @@\n-\/\/     use-def edges from the memory input of 'L' to 'A', since the address input of 'L' only\n-\/\/     depends on 'O'.\n+\/\/     use-def edges from 'L' to 'A'.\n@@ -155,2 +154,2 @@\n-\/\/ Find all loads from oop such that their memory inputs have not observed the escape of oop, and\n-\/\/ try to find their corresponding stores\n+\/\/ Find all loads from oop that have not observed the escape of oop, and try to find their\n+\/\/ corresponding stores\n@@ -160,1 +159,1 @@\n-  VectorSet candidate_mems;\n+  VectorSet candidate_set;\n@@ -162,2 +161,2 @@\n-  collect_loads(candidates, candidate_mems, oop);\n-  if (candidate_mems.is_empty()) {\n+  collect_loads(candidates, candidate_set, oop);\n+  if (candidate_set.is_empty()) {\n@@ -168,2 +167,2 @@\n-  process_candidates(candidate_mems, work_lists, oop);\n-  if (candidate_mems.is_empty()) {\n+  process_candidates(candidate_set, work_lists, oop);\n+  if (candidate_set.is_empty()) {\n@@ -176,1 +175,1 @@\n-    if (!candidate_mems.test(candidate->in(MemNode::Memory)->_idx)) {\n+    if (!candidate_set.test(candidate->_idx)) {\n@@ -191,2 +190,2 @@\n-void PhaseLoadFolding::collect_loads(Unique_Node_List& candidates, VectorSet& candidate_mems, Node* oop) {\n-  assert(candidates.size() == 0 && candidate_mems.is_empty(), \"must start with no candidates\");\n+void PhaseLoadFolding::collect_loads(Unique_Node_List& candidates, VectorSet& candidate_set, Node* oop) {\n+  assert(candidates.size() == 0 && candidate_set.is_empty(), \"must start with no candidates\");\n@@ -213,1 +212,1 @@\n-    candidate_mems.set(candidates.at(i)->in(MemNode::Memory)->_idx);\n+    candidate_set.set(candidates.at(i)->_idx);\n@@ -228,1 +227,1 @@\n-void PhaseLoadFolding::process_candidates(VectorSet& candidate_mems, WorkLists& work_lists, Node* oop) {\n+void PhaseLoadFolding::process_candidates(VectorSet& candidate_set, WorkLists& work_lists, Node* oop) {\n@@ -302,2 +301,2 @@\n-    candidate_mems.remove(n->_idx);\n-    if (candidate_mems.is_empty()) {\n+    candidate_set.remove(n->_idx);\n+    if (candidate_set.is_empty()) {\n@@ -377,0 +376,1 @@\n+        assert(res->is_Store() && res->as_Store()->value_basic_type() == candidate->value_basic_type(), \"must match\");\n","filename":"src\/hotspot\/share\/opto\/phaseloadfolding.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"}]}