{"files":[{"patch":"@@ -255,1 +255,2 @@\n-          if ((addp_out->is_Store() || addp_out->is_LoadStore()) && addp == addp_out->in(MemNode::Address)) {\n+          if ((addp_out->is_Store() || addp_out->is_LoadStore())) {\n+            assert(addp == addp_out->in(MemNode::Address), \"store a derived pointer?\");\n@@ -267,0 +268,8 @@\n+          } else if (addp_out->is_Mem()) {\n+            \/\/ A load, does not affect the memory\n+          } else if (addp_out->is_AddP()) {\n+            \/\/ Another AddP, it should share the base with the current addp, so it will be visited\n+            \/\/ later\n+          } else {\n+            \/\/ Some runtime calls receive the pointer without the base\n+            work_lists.escapes.push(addp_out);\n","filename":"src\/hotspot\/share\/opto\/phaseloadfolding.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    @Run(test = {\"test11\", \"test12\", \"test13\", \"test14\", \"test15\", \"test16\"})\n+    @Run(test = {\"test11\", \"test12\", \"test13\", \"test14\", \"test15\", \"test16\", \"test17\", \"test18\"})\n@@ -67,0 +67,2 @@\n+        test17(0);\n+        test18(0);\n@@ -69,1 +71,1 @@\n-    @Run(test = {\"test01\", \"test02\", \"test03\", \"test04\"})\n+    @Run(test = {\"test01\", \"test02\", \"test03\", \"test04\", \"test05\"})\n@@ -77,0 +79,1 @@\n+        test05(0);\n@@ -164,0 +167,31 @@\n+    @Test\n+    @IR(counts = {IRNode.LOAD_I, \"1\", IRNode.ALLOC_ARRAY, \"1\"})\n+    public int test17(int idx) {\n+        \/\/ Array\n+        int[] a = new int[2];\n+        a[0] = 1;\n+        a[1] = 2;\n+        int res = a[idx & 1];\n+        escape(null);\n+        res += a[0] + a[1];\n+        escape(a);\n+        return res;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.LOAD_I, counts = {IRNode.ALLOC_ARRAY, \"1\"})\n+    public int test18(int idx) {\n+        \/\/ Array, even if we will give up if we encounter a[idx & 1] = 3, we meet a[0] = 4 first,\n+        \/\/ so the load int res = a[0] can still be folded\n+        int[] a = new int[2];\n+        a[0] = 1;\n+        a[1] = 2;\n+        escape(null);\n+        a[idx & 1] = 3;\n+        a[0] = 4;\n+        escape(null);\n+        int res = a[0];\n+        escape(a);\n+        return res;\n+    }\n+\n@@ -211,0 +245,13 @@\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_I, \"2\", IRNode.ALLOC_ARRAY, \"1\"})\n+    public int test05(int idx) {\n+        int[] a = new int[2];\n+        a[0] = 1;\n+        a[1] = 2;\n+        escape(null);\n+        a[idx & 1] = 3;\n+        \/\/ Cannot fold the loads because we do not know which element is written to by\n+        \/\/ a[idx & 1] = 3\n+        return a[0] + a[1];\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/TestLoadFolding.java","additions":49,"deletions":2,"binary":false,"changes":51,"status":"modified"}]}