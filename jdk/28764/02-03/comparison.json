{"files":[{"patch":"@@ -32,0 +32,1 @@\n+#include \"opto\/mulnode.hpp\"\n@@ -34,0 +35,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -241,0 +243,1 @@\n+        assert(addp->base_node() == n, \"unexpected base of an AddP\");\n@@ -272,0 +275,1 @@\n+            assert(addp_out->in(AddPNode::Base) == n, \"must have the same base\");\n@@ -318,0 +322,25 @@\n+  \/\/ An arbitrary int can be the input to a StoreB or a StoreC, the load needs to do the\n+  \/\/ normalization\n+  auto extract_store_value = [&](StoreNode* store) {\n+    assert(store->Opcode() == candidate->store_Opcode(), \"must match %s - %s\", store->Name(), candidate->Name());\n+    Node* res = store->in(MemNode::ValueIn);\n+    if (candidate->Opcode() == Op_LoadUB) {\n+      res = new AndINode(res, _igvn.intcon(0xFF));\n+      _igvn.register_new_node_with_optimizer(res);\n+    } else if (candidate->Opcode() == Op_LoadB) {\n+      res = new LShiftINode(res, _igvn.intcon(24));\n+      _igvn.register_new_node_with_optimizer(res);\n+      res = new RShiftINode(res, _igvn.intcon(24));\n+      _igvn.register_new_node_with_optimizer(res);\n+    } else if (candidate->Opcode() == Op_LoadUS) {\n+      res = new AndINode(res, _igvn.intcon(0xFFFF));\n+      _igvn.register_new_node_with_optimizer(res);\n+    } else if (candidate->Opcode() == Op_LoadS) {\n+      res = new LShiftINode(res, _igvn.intcon(16));\n+      _igvn.register_new_node_with_optimizer(res);\n+      res = new RShiftINode(res, _igvn.intcon(16));\n+      _igvn.register_new_node_with_optimizer(res);\n+    }\n+    return res;\n+  };\n+\n@@ -363,1 +392,1 @@\n-             \"invalid pointer into a non-array object\");\n+             \"invalid pointer\");\n@@ -376,2 +405,2 @@\n-        assert(res->is_Store() && res->as_Store()->value_basic_type() == candidate->value_basic_type(), \"must match\");\n-        return res->in(MemNode::ValueIn);\n+        assert(res->is_Store(), \"must be a store %s\", res->Name());\n+        return extract_store_value(res->as_Store());\n@@ -385,1 +414,1 @@\n-        return mem->in(MemNode::ValueIn);\n+        return extract_store_value(mem->as_Store());\n","filename":"src\/hotspot\/share\/opto\/phaseloadfolding.cpp","additions":33,"deletions":4,"binary":false,"changes":37,"status":"modified"}]}