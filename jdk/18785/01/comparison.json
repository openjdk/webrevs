{"files":[{"patch":"@@ -281,0 +281,3 @@\n+    \/\/ Restore cpu control state after JNI call\n+    __ restore_cpu_control_state_after_jni(t0);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/downcallLinker_riscv.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1170,0 +1170,13 @@\n+void MacroAssembler::restore_cpu_control_state_after_jni(Register tmp) {\n+  if (RestoreMXCSROnJNICalls) {\n+    Label skip_fsrmi;\n+    frrm(tmp);\n+    \/\/ Set FRM to the state we need. We do want Round to Nearest. We\n+    \/\/ don't want non-IEEE rounding modes.\n+    guarantee(RoundingMode::rne == 0, \"must be\");\n+    beq(tmp, zr, skip_fsrmi);        \/\/ Only reset FRM if it's wrong\n+    fsrmi(RoundingMode::rne);\n+    bind(skip_fsrmi);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -584,0 +584,3 @@\n+  \/\/ Restore cpu control state after JNI call\n+  void restore_cpu_control_state_after_jni(Register tmp);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1712,0 +1712,3 @@\n+  \/\/ Verify or restore cpu control state after JNI call\n+  __ restore_cpu_control_state_after_jni(t0);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1160,0 +1160,3 @@\n+  \/\/ Restore cpu control state after JNI call\n+  __ restore_cpu_control_state_after_jni(t0);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}