{"files":[{"patch":"@@ -350,1 +350,1 @@\n-  ModRefBarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp2);\n+  CardTableBarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp2);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1BarrierSetAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n+#include \"gc\/shared\/cardTableBarrierSetAssembler.hpp\"\n@@ -37,1 +37,1 @@\n-class G1BarrierSetAssembler: public ModRefBarrierSetAssembler {\n+class G1BarrierSetAssembler: public CardTableBarrierSetAssembler {\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1BarrierSetAssembler_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,25 @@\n+void CardTableBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n+                                                      Register src, Register dst, Register count, RegSet saved_regs) {\n+\n+  if (is_oop) {\n+    gen_write_ref_array_pre_barrier(masm, decorators, dst, count, saved_regs);\n+  }\n+}\n+\n+void CardTableBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n+                                                      Register start, Register count, Register tmp,\n+                                                      RegSet saved_regs) {\n+  if (is_oop) {\n+    gen_write_ref_array_post_barrier(masm, decorators, start, count, tmp, saved_regs);\n+  }\n+}\n+\n+void CardTableBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                            Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) {\n+  if (is_reference_type(type)) {\n+    oop_store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n+  } else {\n+    BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/cardTableBarrierSetAssembler_aarch64.cpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n+#include \"gc\/shared\/barrierSetAssembler.hpp\"\n@@ -31,1 +31,1 @@\n-class CardTableBarrierSetAssembler: public ModRefBarrierSetAssembler {\n+class CardTableBarrierSetAssembler: public BarrierSetAssembler {\n@@ -33,1 +33,2 @@\n-  void store_check(MacroAssembler* masm, Register obj, Address dst);\n+  virtual void gen_write_ref_array_pre_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                               Register addr, Register count, RegSet saved_regs) {}\n@@ -40,0 +41,9 @@\n+  virtual void arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n+                                  Register src, Register dst, Register count, RegSet saved_regs);\n+\n+  virtual void arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n+                                  Register start, Register count, Register tmp, RegSet saved_regs);\n+  virtual void store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                        Address dst, Register val, Register tmp1, Register tmp2, Register tmp3);\n+\n+  void store_check(MacroAssembler* masm, Register obj, Address dst);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/cardTableBarrierSetAssembler_aarch64.hpp","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"asm\/macroAssembler.inline.hpp\"\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n-\n-#define __ masm->\n-\n-void ModRefBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n-                                                   Register src, Register dst, Register count, RegSet saved_regs) {\n-\n-  if (is_oop) {\n-    gen_write_ref_array_pre_barrier(masm, decorators, dst, count, saved_regs);\n-  }\n-}\n-\n-void ModRefBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n-                                                   Register start, Register count, Register tmp,\n-                                                   RegSet saved_regs) {\n-  if (is_oop) {\n-    gen_write_ref_array_post_barrier(masm, decorators, start, count, tmp, saved_regs);\n-  }\n-}\n-\n-void ModRefBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                         Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) {\n-  if (is_reference_type(type)) {\n-    oop_store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n-  } else {\n-    BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n-  }\n-}\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/modRefBarrierSetAssembler_aarch64.cpp","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef CPU_AARCH64_GC_SHARED_MODREFBARRIERSETASSEMBLER_AARCH64_HPP\n-#define CPU_AARCH64_GC_SHARED_MODREFBARRIERSETASSEMBLER_AARCH64_HPP\n-\n-#include \"asm\/macroAssembler.hpp\"\n-#include \"gc\/shared\/barrierSetAssembler.hpp\"\n-\n-\/\/ The ModRefBarrierSetAssembler filters away accesses on BasicTypes other\n-\/\/ than T_OBJECT\/T_ARRAY (oops). The oop accesses call one of the protected\n-\/\/ accesses, which are overridden in the concrete BarrierSetAssembler.\n-\n-class ModRefBarrierSetAssembler: public BarrierSetAssembler {\n-protected:\n-  virtual void gen_write_ref_array_pre_barrier(MacroAssembler* masm, DecoratorSet decorators,\n-                                               Register addr, Register count, RegSet saved_regs) {}\n-  virtual void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n-                                                Register start, Register count, Register tmp, RegSet saved_regs) {}\n-\n-  virtual void oop_store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                            Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) = 0;\n-\n-public:\n-  virtual void arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n-                                  Register src, Register dst, Register count, RegSet saved_regs);\n-  virtual void arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n-                                  Register start, Register count, Register tmp, RegSet saved_regs);\n-  virtual void store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                        Address dst, Register val, Register tmp1, Register tmp2, Register tmp3);\n-};\n-\n-#endif \/\/ CPU_AARCH64_GC_SHARED_MODREFBARRIERSETASSEMBLER_AARCH64_HPP\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/modRefBarrierSetAssembler_aarch64.hpp","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -323,1 +323,1 @@\n-  ModRefBarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp2, tmp3);\n+  CardTableBarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp2, tmp3);\n","filename":"src\/hotspot\/cpu\/arm\/gc\/g1\/g1BarrierSetAssembler_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n+#include \"gc\/shared\/cardTableBarrierSetAssembler.hpp\"\n@@ -37,1 +37,1 @@\n-class G1BarrierSetAssembler: public ModRefBarrierSetAssembler {\n+class G1BarrierSetAssembler: public CardTableBarrierSetAssembler {\n","filename":"src\/hotspot\/cpu\/arm\/gc\/g1\/g1BarrierSetAssembler_arm.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,0 +43,24 @@\n+void CardTableBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n+                                                      Register addr, Register count, int callee_saved_regs) {\n+\n+  if (is_oop) {\n+    gen_write_ref_array_pre_barrier(masm, decorators, addr, count, callee_saved_regs);\n+  }\n+}\n+\n+void CardTableBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n+                                                      Register addr, Register count, Register tmp) {\n+  if (is_oop) {\n+    gen_write_ref_array_post_barrier(masm, decorators, addr, count, tmp);\n+  }\n+}\n+\n+void CardTableBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                            Address obj, Register new_val, Register tmp1, Register tmp2, Register tmp3, bool is_null) {\n+  if (type == T_OBJECT || type == T_ARRAY) {\n+    oop_store_at(masm, decorators, type, obj, new_val, tmp1, tmp2, tmp3, is_null);\n+  } else {\n+    BarrierSetAssembler::store_at(masm, decorators, type, obj, new_val, tmp1, tmp2, tmp3, is_null);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/gc\/shared\/cardTableBarrierSetAssembler_arm.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n+#include \"gc\/shared\/barrierSetAssembler.hpp\"\n@@ -31,1 +31,1 @@\n-class CardTableBarrierSetAssembler: public ModRefBarrierSetAssembler {\n+class CardTableBarrierSetAssembler: public BarrierSetAssembler {\n@@ -40,0 +40,3 @@\n+  virtual void gen_write_ref_array_pre_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                               Register addr, Register count, int callee_saved_regs) {}\n+\n@@ -42,0 +45,1 @@\n+\n@@ -44,0 +48,9 @@\n+\n+public:\n+  virtual void arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n+                                  Register addr, Register count, int callee_saved_regs);\n+  virtual void arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n+                                  Register addr, Register count, Register tmp);\n+  virtual void store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                        Address obj, Register val, Register tmp1, Register tmp2, Register tmp3, bool is_null);\n+\n","filename":"src\/hotspot\/cpu\/arm\/gc\/shared\/cardTableBarrierSetAssembler_arm.hpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"asm\/macroAssembler.inline.hpp\"\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n-\n-#define __ masm->\n-\n-void ModRefBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n-                                                   Register addr, Register count, int callee_saved_regs) {\n-\n-  if (is_oop) {\n-    gen_write_ref_array_pre_barrier(masm, decorators, addr, count, callee_saved_regs);\n-  }\n-}\n-\n-void ModRefBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n-                                                   Register addr, Register count, Register tmp) {\n-  if (is_oop) {\n-    gen_write_ref_array_post_barrier(masm, decorators, addr, count, tmp);\n-  }\n-}\n-\n-void ModRefBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                         Address obj, Register new_val, Register tmp1, Register tmp2, Register tmp3, bool is_null) {\n-  if (type == T_OBJECT || type == T_ARRAY) {\n-    oop_store_at(masm, decorators, type, obj, new_val, tmp1, tmp2, tmp3, is_null);\n-  } else {\n-    BarrierSetAssembler::store_at(masm, decorators, type, obj, new_val, tmp1, tmp2, tmp3, is_null);\n-  }\n-}\n","filename":"src\/hotspot\/cpu\/arm\/gc\/shared\/modRefBarrierSetAssembler_arm.cpp","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef CPU_ARM_GC_SHARED_MODREFBARRIERSETASSEMBLER_ARM_HPP\n-#define CPU_ARM_GC_SHARED_MODREFBARRIERSETASSEMBLER_ARM_HPP\n-\n-#include \"asm\/macroAssembler.hpp\"\n-#include \"gc\/shared\/barrierSetAssembler.hpp\"\n-\n-\/\/ The ModRefBarrierSetAssembler filters away accesses on BasicTypes other\n-\/\/ than T_OBJECT\/T_ARRAY (oops). The oop accesses call one of the protected\n-\/\/ accesses, which are overridden in the concrete BarrierSetAssembler.\n-\n-class ModRefBarrierSetAssembler: public BarrierSetAssembler {\n-protected:\n-  virtual void gen_write_ref_array_pre_barrier(MacroAssembler* masm, DecoratorSet decorators,\n-                                               Register addr, Register count, int callee_saved_regs) {}\n-  virtual void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n-                                                Register addr, Register count, Register tmp) {}\n-\n-  virtual void oop_store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                            Address obj, Register val, Register tmp1, Register tmp2, Register tmp3, bool is_null) = 0;\n-\n-public:\n-  virtual void arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n-                                  Register addr, Register count, int callee_saved_regs);\n-  virtual void arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n-                                  Register addr, Register count, Register tmp);\n-  virtual void store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                        Address obj, Register val, Register tmp1, Register tmp2, Register tmp3, bool is_null);\n-};\n-\n-#endif \/\/ CPU_ARM_GC_SHARED_MODREFBARRIERSETASSEMBLER_ARM_HPP\n","filename":"src\/hotspot\/cpu\/arm\/gc\/shared\/modRefBarrierSetAssembler_arm.hpp","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -324,4 +324,4 @@\n-  ModRefBarrierSetAssembler::load_at(masm, decorators, type,\n-                                     base, ind_or_offs, dst,\n-                                     tmp1, tmp2,\n-                                     preservation_level, L_handle_null);\n+  CardTableBarrierSetAssembler::load_at(masm, decorators, type,\n+                                        base, ind_or_offs, dst,\n+                                        tmp1, tmp2,\n+                                        preservation_level, L_handle_null);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/g1\/g1BarrierSetAssembler_ppc.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n+#include \"gc\/shared\/cardTableBarrierSetAssembler.hpp\"\n@@ -42,1 +42,1 @@\n-class G1BarrierSetAssembler: public ModRefBarrierSetAssembler {\n+class G1BarrierSetAssembler: public CardTableBarrierSetAssembler {\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/g1\/g1BarrierSetAssembler_ppc.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/jniHandles.hpp\"\n@@ -43,0 +44,60 @@\n+void CardTableBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                                      Register src, Register dst, Register count, Register preserve1, Register preserve2) {\n+  if (type == T_OBJECT) {\n+    gen_write_ref_array_pre_barrier(masm, decorators,\n+                                    src, dst, count,\n+                                    preserve1, preserve2);\n+\n+    bool checkcast = (decorators & ARRAYCOPY_CHECKCAST) != 0;\n+    if (!checkcast) {\n+      assert_different_registers(dst, count, R9_ARG7, R10_ARG8);\n+      \/\/ Save some arguments for epilogue, e.g. disjoint_long_copy_core destroys them.\n+      __ mr(R9_ARG7, dst);\n+      __ mr(R10_ARG8, count);\n+    }\n+  }\n+}\n+\n+void CardTableBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                                      Register dst, Register count, Register preserve) {\n+  if (type == T_OBJECT) {\n+    bool checkcast = (decorators & ARRAYCOPY_CHECKCAST) != 0;\n+    if (!checkcast) {\n+      gen_write_ref_array_post_barrier(masm, decorators, R9_ARG7, R10_ARG8, preserve);\n+    } else {\n+      gen_write_ref_array_post_barrier(masm, decorators, dst, count, preserve);\n+    }\n+  }\n+}\n+\n+void CardTableBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                            Register base, RegisterOrConstant ind_or_offs, Register val,\n+                                            Register tmp1, Register tmp2, Register tmp3,\n+                                            MacroAssembler::PreservationLevel preservation_level) {\n+  if (is_reference_type(type)) {\n+    oop_store_at(masm, decorators, type,\n+                 base, ind_or_offs, val,\n+                 tmp1, tmp2, tmp3,\n+                 preservation_level);\n+  } else {\n+    BarrierSetAssembler::store_at(masm, decorators, type,\n+                                  base, ind_or_offs, val,\n+                                  tmp1, tmp2, tmp3,\n+                                  preservation_level);\n+  }\n+}\n+\n+void CardTableBarrierSetAssembler::resolve_jobject(MacroAssembler* masm, Register value,\n+                                                   Register tmp1, Register tmp2,\n+                                                   MacroAssembler::PreservationLevel preservation_level) {\n+  Label done;\n+  __ cmpdi(CR0, value, 0);\n+  __ beq(CR0, done);         \/\/ Use null as-is.\n+\n+  __ clrrdi(tmp1, value, JNIHandles::tag_size);\n+  __ ld(value, 0, tmp1);      \/\/ Resolve (untagged) jobject.\n+\n+  __ verify_oop(value, FILE_AND_LINE);\n+  __ bind(done);\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/cardTableBarrierSetAssembler_ppc.cpp","additions":61,"deletions":0,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n+#include \"gc\/shared\/barrierSetAssembler.hpp\"\n@@ -32,1 +32,1 @@\n-class CardTableBarrierSetAssembler: public ModRefBarrierSetAssembler {\n+class CardTableBarrierSetAssembler: public BarrierSetAssembler {\n@@ -34,3 +34,0 @@\n-  virtual void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n-                                                Register addr, Register count, Register preserve);\n-\n@@ -41,0 +38,6 @@\n+  virtual void gen_write_ref_array_pre_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                               Register from, Register to, Register count,\n+                                               Register preserve1, Register preserve2) {}\n+  virtual void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                                Register addr, Register count, Register preserve);\n+\n@@ -45,0 +48,18 @@\n+\n+public:\n+  virtual void arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                  Register src, Register dst, Register count,\n+                                  Register preserve1, Register preserve2);\n+  virtual void arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                  Register dst, Register count,\n+                                  Register preserve);\n+\n+  virtual void store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                        Register base, RegisterOrConstant ind_or_offs, Register val,\n+                        Register tmp1, Register tmp2, Register tmp3,\n+                        MacroAssembler::PreservationLevel preservation_level);\n+\n+  virtual void resolve_jobject(MacroAssembler* masm, Register value,\n+                               Register tmp1, Register tmp2,\n+                               MacroAssembler::PreservationLevel preservation_level);\n+\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/cardTableBarrierSetAssembler_ppc.hpp","additions":26,"deletions":5,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1,91 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018, 2025 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"asm\/macroAssembler.inline.hpp\"\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n-#include \"runtime\/jniHandles.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-#define __ masm->\n-\n-void ModRefBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                                   Register src, Register dst, Register count, Register preserve1, Register preserve2) {\n-  if (type == T_OBJECT) {\n-    gen_write_ref_array_pre_barrier(masm, decorators,\n-                                    src, dst, count,\n-                                    preserve1, preserve2);\n-\n-    bool checkcast = (decorators & ARRAYCOPY_CHECKCAST) != 0;\n-    if (!checkcast) {\n-      assert_different_registers(dst, count, R9_ARG7, R10_ARG8);\n-      \/\/ Save some arguments for epilogue, e.g. disjoint_long_copy_core destroys them.\n-      __ mr(R9_ARG7, dst);\n-      __ mr(R10_ARG8, count);\n-    }\n-  }\n-}\n-\n-void ModRefBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                                   Register dst, Register count, Register preserve) {\n-  if (type == T_OBJECT) {\n-    bool checkcast = (decorators & ARRAYCOPY_CHECKCAST) != 0;\n-    if (!checkcast) {\n-      gen_write_ref_array_post_barrier(masm, decorators, R9_ARG7, R10_ARG8, preserve);\n-    } else {\n-      gen_write_ref_array_post_barrier(masm, decorators, dst, count, preserve);\n-    }\n-  }\n-}\n-\n-void ModRefBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                         Register base, RegisterOrConstant ind_or_offs, Register val,\n-                                         Register tmp1, Register tmp2, Register tmp3,\n-                                         MacroAssembler::PreservationLevel preservation_level) {\n-  if (is_reference_type(type)) {\n-    oop_store_at(masm, decorators, type,\n-                 base, ind_or_offs, val,\n-                 tmp1, tmp2, tmp3,\n-                 preservation_level);\n-  } else {\n-    BarrierSetAssembler::store_at(masm, decorators, type,\n-                                  base, ind_or_offs, val,\n-                                  tmp1, tmp2, tmp3,\n-                                  preservation_level);\n-  }\n-}\n-\n-void ModRefBarrierSetAssembler::resolve_jobject(MacroAssembler* masm, Register value,\n-                                                Register tmp1, Register tmp2,\n-                                                MacroAssembler::PreservationLevel preservation_level) {\n-  Label done;\n-  __ cmpdi(CR0, value, 0);\n-  __ beq(CR0, done);         \/\/ Use null as-is.\n-\n-  __ clrrdi(tmp1, value, JNIHandles::tag_size);\n-  __ ld(value, 0, tmp1);      \/\/ Resolve (untagged) jobject.\n-\n-  __ verify_oop(value, FILE_AND_LINE);\n-  __ bind(done);\n-}\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/modRefBarrierSetAssembler_ppc.cpp","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018, 2021 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef CPU_PPC_GC_SHARED_MODREFBARRIERSETASSEMBLER_PPC_HPP\n-#define CPU_PPC_GC_SHARED_MODREFBARRIERSETASSEMBLER_PPC_HPP\n-\n-#include \"asm\/macroAssembler.hpp\"\n-#include \"gc\/shared\/barrierSetAssembler.hpp\"\n-\n-\/\/ The ModRefBarrierSetAssembler filters away accesses on BasicTypes other\n-\/\/ than T_OBJECT\/T_ARRAY (oops). The oop accesses call one of the protected\n-\/\/ accesses, which are overridden in the concrete BarrierSetAssembler.\n-\n-class ModRefBarrierSetAssembler: public BarrierSetAssembler {\n-protected:\n-  virtual void gen_write_ref_array_pre_barrier(MacroAssembler* masm, DecoratorSet decorators,\n-                                               Register from, Register to, Register count,\n-                                               Register preserve1, Register preserve2) {}\n-  virtual void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n-                                                Register addr, Register count, Register preserve) {}\n-\n-  virtual void oop_store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                            Register base, RegisterOrConstant ind_or_offs, Register val,\n-                            Register tmp1, Register tmp2, Register tmp3,\n-                            MacroAssembler::PreservationLevel preservation_level) = 0;\n-public:\n-  virtual void arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                  Register src, Register dst, Register count,\n-                                  Register preserve1, Register preserve2);\n-  virtual void arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                  Register dst, Register count,\n-                                  Register preserve);\n-\n-  virtual void store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                        Register base, RegisterOrConstant ind_or_offs, Register val,\n-                        Register tmp1, Register tmp2, Register tmp3,\n-                        MacroAssembler::PreservationLevel preservation_level);\n-\n-  virtual void resolve_jobject(MacroAssembler* masm, Register value,\n-                               Register tmp1, Register tmp2,\n-                               MacroAssembler::PreservationLevel preservation_level);\n-};\n-\n-#endif \/\/ CPU_PPC_GC_SHARED_MODREFBARRIERSETASSEMBLER_PPC_HPP\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/modRefBarrierSetAssembler_ppc.hpp","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -348,1 +348,1 @@\n-  ModRefBarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp2);\n+  CardTableBarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp2);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/g1\/g1BarrierSetAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n+#include \"gc\/shared\/cardTableBarrierSetAssembler.hpp\"\n@@ -40,1 +40,1 @@\n-class G1BarrierSetAssembler: public ModRefBarrierSetAssembler {\n+class G1BarrierSetAssembler: public CardTableBarrierSetAssembler {\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/g1\/g1BarrierSetAssembler_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,23 @@\n+void CardTableBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n+                                                      Register src, Register dst, Register count, RegSet saved_regs) {\n+  if (is_oop) {\n+    gen_write_ref_array_pre_barrier(masm, decorators, dst, count, saved_regs);\n+  }\n+}\n+\n+void CardTableBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n+                                                      Register start, Register count, Register tmp,\n+                                                      RegSet saved_regs) {\n+  if (is_oop) {\n+    gen_write_ref_array_post_barrier(masm, decorators, start, count, tmp, saved_regs);\n+  }\n+}\n+\n+void CardTableBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                            Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) {\n+  if (is_reference_type(type)) {\n+    oop_store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n+  } else {\n+    BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/cardTableBarrierSetAssembler_riscv.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n+#include \"gc\/shared\/barrierSetAssembler.hpp\"\n@@ -32,1 +32,1 @@\n-class CardTableBarrierSetAssembler: public ModRefBarrierSetAssembler {\n+class CardTableBarrierSetAssembler: public BarrierSetAssembler {\n@@ -36,0 +36,3 @@\n+  virtual void gen_write_ref_array_pre_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                               Register addr, Register count, RegSet saved_regs) {}\n+\n@@ -38,0 +41,1 @@\n+\n@@ -40,0 +44,10 @@\n+\n+public:\n+  virtual void arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n+                                  Register src, Register dst, Register count, RegSet saved_regs);\n+\n+  virtual void arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n+                                  Register start, Register count, Register tmp, RegSet saved_regs);\n+\n+  virtual void store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                        Address dst, Register val, Register tmp1, Register tmp2, Register tmp3);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/cardTableBarrierSetAssembler_riscv.hpp","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"asm\/macroAssembler.inline.hpp\"\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n-\n-#define __ masm->\n-\n-void ModRefBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n-                                                   Register src, Register dst, Register count, RegSet saved_regs) {\n-  if (is_oop) {\n-    gen_write_ref_array_pre_barrier(masm, decorators, dst, count, saved_regs);\n-  }\n-}\n-\n-void ModRefBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n-                                                   Register start, Register count, Register tmp,\n-                                                   RegSet saved_regs) {\n-  if (is_oop) {\n-    gen_write_ref_array_post_barrier(masm, decorators, start, count, tmp, saved_regs);\n-  }\n-}\n-\n-void ModRefBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                         Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) {\n-  if (is_reference_type(type)) {\n-    oop_store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n-  } else {\n-    BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n-  }\n-}\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/modRefBarrierSetAssembler_riscv.cpp","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef CPU_RISCV_GC_SHARED_MODREFBARRIERSETASSEMBLER_RISCV_HPP\n-#define CPU_RISCV_GC_SHARED_MODREFBARRIERSETASSEMBLER_RISCV_HPP\n-\n-#include \"asm\/macroAssembler.hpp\"\n-#include \"gc\/shared\/barrierSetAssembler.hpp\"\n-\n-\/\/ The ModRefBarrierSetAssembler filters away accesses on BasicTypes other\n-\/\/ than T_OBJECT\/T_ARRAY (oops). The oop accesses call one of the protected\n-\/\/ accesses, which are overridden in the concrete BarrierSetAssembler.\n-\n-class ModRefBarrierSetAssembler: public BarrierSetAssembler {\n-protected:\n-  virtual void gen_write_ref_array_pre_barrier(MacroAssembler* masm, DecoratorSet decorators,\n-                                               Register addr, Register count, RegSet saved_regs) {}\n-  virtual void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n-                                                Register start, Register count, Register tmp, RegSet saved_regs) {}\n-\n-  virtual void oop_store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                            Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) = 0;\n-\n-public:\n-  virtual void arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n-                                  Register src, Register dst, Register count, RegSet saved_regs);\n-  virtual void arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n-                                  Register start, Register count, Register tmp, RegSet saved_regs);\n-  virtual void store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                        Address dst, Register val, Register tmp1, Register tmp2, Register tmp3);\n-};\n-\n-#endif \/\/ CPU_RISCV_GC_SHARED_MODREFBARRIERSETASSEMBLER_RISCV_HPP\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/modRefBarrierSetAssembler_riscv.hpp","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -282,1 +282,1 @@\n-  ModRefBarrierSetAssembler::load_at(masm, decorators, type, src, dst, tmp1, tmp2, L_handle_null);\n+  CardTableBarrierSetAssembler::load_at(masm, decorators, type, src, dst, tmp1, tmp2, L_handle_null);\n","filename":"src\/hotspot\/cpu\/s390\/gc\/g1\/g1BarrierSetAssembler_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n+#include \"gc\/shared\/cardTableBarrierSetAssembler.hpp\"\n@@ -38,1 +38,1 @@\n-class G1BarrierSetAssembler: public ModRefBarrierSetAssembler {\n+class G1BarrierSetAssembler: public CardTableBarrierSetAssembler {\n","filename":"src\/hotspot\/cpu\/s390\/gc\/g1\/g1BarrierSetAssembler_s390.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/jniHandles.hpp\"\n@@ -45,0 +46,38 @@\n+void CardTableBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                                      Register src, Register dst, Register count) {\n+  if (is_reference_type(type)) {\n+    gen_write_ref_array_pre_barrier(masm, decorators, dst, count);\n+  }\n+}\n+\n+void CardTableBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                                      Register dst, Register count, bool do_return) {\n+  if (is_reference_type(type)) {\n+    gen_write_ref_array_post_barrier(masm, decorators, dst, count, do_return);\n+  } else {\n+    if (do_return) { __ z_br(Z_R14); }\n+  }\n+}\n+\n+void CardTableBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                            const Address& dst, Register val, Register tmp1, Register tmp2, Register tmp3) {\n+  if (is_reference_type(type)) {\n+    oop_store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n+  } else {\n+    BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n+  }\n+}\n+\n+void CardTableBarrierSetAssembler::resolve_jobject(MacroAssembler* masm, Register value, Register tmp1, Register tmp2) {\n+  NearLabel done;\n+\n+  __ z_ltgr(value, value);\n+  __ z_bre(done);  \/\/ use null as-is.\n+\n+  __ z_nill(value, ~JNIHandles::tag_mask);\n+  __ z_lg(value, 0, value); \/\/ Resolve (untagged) jobject.\n+\n+  __ verify_oop(value, FILE_AND_LINE);\n+  __ bind(done);\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/cardTableBarrierSetAssembler_s390.cpp","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n+#include \"gc\/shared\/barrierSetAssembler.hpp\"\n@@ -32,1 +32,1 @@\n-class CardTableBarrierSetAssembler: public ModRefBarrierSetAssembler {\n+class CardTableBarrierSetAssembler: public BarrierSetAssembler {\n@@ -36,0 +36,2 @@\n+  virtual void gen_write_ref_array_pre_barrier(MacroAssembler* masm, DecoratorSet decorators, Register addr, Register count) {}\n+\n@@ -41,0 +43,11 @@\n+public:\n+  virtual void arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                  Register src, Register dst, Register count);\n+\n+  virtual void arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                  Register dst, Register count, bool do_return = false);\n+\n+  virtual void store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                        const Address& dst, Register val, Register tmp1, Register tmp2, Register tmp3);\n+\n+  virtual void resolve_jobject(MacroAssembler* masm, Register value, Register tmp1, Register tmp2);\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/cardTableBarrierSetAssembler_s390.hpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018, 2024 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"asm\/macroAssembler.inline.hpp\"\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n-#include \"runtime\/jniHandles.hpp\"\n-\n-#define __ masm->\n-\n-void ModRefBarrierSetAssembler::gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators, Register addr, Register count,\n-                                                                 bool do_return) {\n-  if (do_return) { __ z_br(Z_R14); }\n-}\n-\n-void ModRefBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                                   Register src, Register dst, Register count) {\n-  if (is_reference_type(type)) {\n-    gen_write_ref_array_pre_barrier(masm, decorators, dst, count);\n-  }\n-}\n-\n-void ModRefBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                                   Register dst, Register count, bool do_return) {\n-  if (is_reference_type(type)) {\n-    gen_write_ref_array_post_barrier(masm, decorators, dst, count, do_return);\n-  } else {\n-    if (do_return) { __ z_br(Z_R14); }\n-  }\n-}\n-\n-void ModRefBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                         const Address& dst, Register val, Register tmp1, Register tmp2, Register tmp3) {\n-  if (is_reference_type(type)) {\n-    oop_store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n-  } else {\n-    BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n-  }\n-}\n-\n-void ModRefBarrierSetAssembler::resolve_jobject(MacroAssembler* masm, Register value, Register tmp1, Register tmp2) {\n-  NearLabel done;\n-\n-  __ z_ltgr(value, value);\n-  __ z_bre(done);  \/\/ use null as-is.\n-\n-  __ z_nill(value, ~JNIHandles::tag_mask);\n-  __ z_lg(value, 0, value); \/\/ Resolve (untagged) jobject.\n-\n-  __ verify_oop(value, FILE_AND_LINE);\n-  __ bind(done);\n-}\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/modRefBarrierSetAssembler_s390.cpp","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018, 2024 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef CPU_S390_GC_SHARED_MODREFBARRIERSETASSEMBLER_S390_HPP\n-#define CPU_S390_GC_SHARED_MODREFBARRIERSETASSEMBLER_S390_HPP\n-\n-#include \"asm\/macroAssembler.hpp\"\n-#include \"gc\/shared\/barrierSetAssembler.hpp\"\n-\n-\/\/ The ModRefBarrierSetAssembler filters away accesses on BasicTypes other\n-\/\/ than T_OBJECT\/T_ARRAY (oops). The oop accesses call one of the protected\n-\/\/ accesses, which are overridden in the concrete BarrierSetAssembler.\n-\n-class ModRefBarrierSetAssembler: public BarrierSetAssembler {\n-protected:\n-  virtual void gen_write_ref_array_pre_barrier(MacroAssembler* masm, DecoratorSet decorators, Register addr, Register count) {}\n-  virtual void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators, Register addr, Register count,\n-                                                bool do_return);\n-  virtual void oop_store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                            const Address& dst, Register val, Register tmp1, Register tmp2, Register tmp3) = 0;\n-public:\n-  virtual void arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                  Register src, Register dst, Register count);\n-  virtual void arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                  Register dst, Register count, bool do_return = false);\n-\n-  virtual void store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                        const Address& dst, Register val, Register tmp1, Register tmp2, Register tmp3);\n-\n-  virtual void resolve_jobject(MacroAssembler* masm, Register value, Register tmp1, Register tmp2);\n-};\n-\n-#endif \/\/ CPU_S390_GC_SHARED_MODREFBARRIERSETASSEMBLER_S390_HPP\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/modRefBarrierSetAssembler_s390.hpp","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -147,1 +147,1 @@\n-  ModRefBarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1);\n+  CardTableBarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n+#include \"gc\/shared\/cardTableBarrierSetAssembler.hpp\"\n@@ -37,1 +37,1 @@\n-class G1BarrierSetAssembler: public ModRefBarrierSetAssembler {\n+class G1BarrierSetAssembler: public CardTableBarrierSetAssembler {\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,0 +44,52 @@\n+void CardTableBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                                      Register src, Register dst, Register count) {\n+  bool checkcast = (decorators & ARRAYCOPY_CHECKCAST) != 0;\n+  bool disjoint = (decorators & ARRAYCOPY_DISJOINT) != 0;\n+  bool obj_int = (type == T_OBJECT) && UseCompressedOops;\n+\n+  if (is_reference_type(type)) {\n+    if (!checkcast) {\n+      if (!obj_int) {\n+        \/\/ Save count for barrier\n+        __ movptr(r11, count);\n+      } else if (disjoint) {\n+        \/\/ Save dst in r11 in the disjoint case\n+        __ movq(r11, dst);\n+      }\n+    }\n+    gen_write_ref_array_pre_barrier(masm, decorators, dst, count);\n+  }\n+}\n+\n+void CardTableBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                                      Register src, Register dst, Register count) {\n+  bool checkcast = (decorators & ARRAYCOPY_CHECKCAST) != 0;\n+  bool disjoint = (decorators & ARRAYCOPY_DISJOINT) != 0;\n+  bool obj_int = (type == T_OBJECT) && UseCompressedOops;\n+  Register tmp = rax;\n+\n+  if (is_reference_type(type)) {\n+    if (!checkcast) {\n+      if (!obj_int) {\n+        \/\/ Save count for barrier\n+        count = r11;\n+      } else if (disjoint) {\n+        \/\/ Use the saved dst in the disjoint case\n+        dst = r11;\n+      }\n+    } else {\n+      tmp = rscratch1;\n+    }\n+    gen_write_ref_array_post_barrier(masm, decorators, dst, count, tmp);\n+  }\n+}\n+\n+void CardTableBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                            Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) {\n+  if (is_reference_type(type)) {\n+    oop_store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n+  } else {\n+    BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/cardTableBarrierSetAssembler_x86.cpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n+#include \"gc\/shared\/barrierSetAssembler.hpp\"\n@@ -31,1 +31,1 @@\n-class CardTableBarrierSetAssembler: public ModRefBarrierSetAssembler {\n+class CardTableBarrierSetAssembler: public BarrierSetAssembler {\n@@ -33,0 +33,3 @@\n+  virtual void gen_write_ref_array_pre_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                               Register addr, Register count) {}\n+\n@@ -39,0 +42,11 @@\n+\n+public:\n+  virtual void arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                  Register src, Register dst, Register count);\n+\n+  virtual void arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                  Register src, Register dst, Register count);\n+\n+  virtual void store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                        Address dst, Register val, Register tmp1, Register tmp2, Register tmp3);\n+\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/cardTableBarrierSetAssembler_x86.hpp","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"asm\/macroAssembler.inline.hpp\"\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n-\n-#define __ masm->\n-\n-void ModRefBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                                   Register src, Register dst, Register count) {\n-  bool checkcast = (decorators & ARRAYCOPY_CHECKCAST) != 0;\n-  bool disjoint = (decorators & ARRAYCOPY_DISJOINT) != 0;\n-  bool obj_int = (type == T_OBJECT) && UseCompressedOops;\n-\n-  if (is_reference_type(type)) {\n-    if (!checkcast) {\n-      if (!obj_int) {\n-        \/\/ Save count for barrier\n-        __ movptr(r11, count);\n-      } else if (disjoint) {\n-        \/\/ Save dst in r11 in the disjoint case\n-        __ movq(r11, dst);\n-      }\n-    }\n-    gen_write_ref_array_pre_barrier(masm, decorators, dst, count);\n-  }\n-}\n-\n-void ModRefBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                                   Register src, Register dst, Register count) {\n-  bool checkcast = (decorators & ARRAYCOPY_CHECKCAST) != 0;\n-  bool disjoint = (decorators & ARRAYCOPY_DISJOINT) != 0;\n-  bool obj_int = (type == T_OBJECT) && UseCompressedOops;\n-  Register tmp = rax;\n-\n-  if (is_reference_type(type)) {\n-    if (!checkcast) {\n-      if (!obj_int) {\n-        \/\/ Save count for barrier\n-        count = r11;\n-      } else if (disjoint) {\n-        \/\/ Use the saved dst in the disjoint case\n-        dst = r11;\n-      }\n-    } else {\n-      tmp = rscratch1;\n-    }\n-    gen_write_ref_array_post_barrier(masm, decorators, dst, count, tmp);\n-  }\n-}\n-\n-void ModRefBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                         Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) {\n-  if (is_reference_type(type)) {\n-    oop_store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n-  } else {\n-    BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n-  }\n-}\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/modRefBarrierSetAssembler_x86.cpp","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef CPU_X86_GC_SHARED_MODREFBARRIERSETASSEMBLER_X86_HPP\n-#define CPU_X86_GC_SHARED_MODREFBARRIERSETASSEMBLER_X86_HPP\n-\n-#include \"asm\/macroAssembler.hpp\"\n-#include \"gc\/shared\/barrierSetAssembler.hpp\"\n-\n-\/\/ The ModRefBarrierSetAssembler filters away accesses on BasicTypes other\n-\/\/ than T_OBJECT\/T_ARRAY (oops). The oop accesses call one of the protected\n-\/\/ accesses, which are overridden in the concrete BarrierSetAssembler.\n-\n-class ModRefBarrierSetAssembler: public BarrierSetAssembler {\n-protected:\n-  virtual void gen_write_ref_array_pre_barrier(MacroAssembler* masm, DecoratorSet decorators,\n-                                               Register addr, Register count) {}\n-  virtual void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n-                                                Register addr, Register count, Register tmp) {}\n-  virtual void oop_store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                            Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) = 0;\n-public:\n-  virtual void arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                  Register src, Register dst, Register count);\n-  virtual void arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                  Register src, Register dst, Register count);\n-\n-  virtual void store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                        Address dst, Register val, Register tmp1, Register tmp2, Register tmp3);\n-};\n-\n-#endif \/\/ CPU_X86_GC_SHARED_MODREFBARRIERSETASSEMBLER_X86_HPP\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/modRefBarrierSetAssembler_x86.hpp","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef CPU_ZERO_GC_SHARED_MODREFBARRIERSETASSEMBLER_ZERO_HPP\n-#define CPU_ZERO_GC_SHARED_MODREFBARRIERSETASSEMBLER_ZERO_HPP\n-\n-class ModRefBarrierSetAssembler;\n-\n-#endif \/\/ CPU_ZERO_GC_SHARED_MODREFBARRIERSETASSEMBLER_ZERO_HPP\n","filename":"src\/hotspot\/cpu\/zero\/gc\/shared\/modRefBarrierSetAssembler_zero.hpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/c1\/modRefBarrierSetC1.hpp\"\n+#include \"gc\/shared\/c1\/cardTableBarrierSetC1.hpp\"\n@@ -96,1 +96,1 @@\n-class G1BarrierSetC1 : public ModRefBarrierSetC1 {\n+class G1BarrierSetC1 : public CardTableBarrierSetC1 {\n","filename":"src\/hotspot\/share\/gc\/g1\/c1\/g1BarrierSetC1.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -120,2 +120,2 @@\n-  class AccessBarrier: public ModRefBarrierSet::AccessBarrier<decorators, BarrierSetT> {\n-    typedef ModRefBarrierSet::AccessBarrier<decorators, BarrierSetT> ModRef;\n+  class AccessBarrier: public CardTableBarrierSet::AccessBarrier<decorators, BarrierSetT> {\n+    typedef CardTableBarrierSet::AccessBarrier<decorators, BarrierSetT> CardTableBS;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-  oop value = ModRef::oop_load_not_in_heap(addr);\n+  oop value = CardTableBS::oop_load_not_in_heap(addr);\n@@ -106,1 +106,1 @@\n-  oop value = ModRef::oop_load_in_heap(addr);\n+  oop value = CardTableBS::oop_load_in_heap(addr);\n@@ -114,1 +114,1 @@\n-  oop value = ModRef::oop_load_in_heap_at(base, offset);\n+  oop value = CardTableBS::oop_load_in_heap_at(base, offset);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-#include \"gc\/shared\/modRefBarrierSet.hpp\"\n","filename":"src\/hotspot\/share\/gc\/serial\/serialFullGC.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,2 +30,2 @@\n-\/\/ Do something for each concrete barrier set part of the build.\n-#define FOR_EACH_CONCRETE_BARRIER_SET_DO(f)          \\\n+\/\/ Do something for each barrier set part of the build.\n+#define FOR_EACH_BARRIER_SET_DO(f)                   \\\n@@ -38,8 +38,0 @@\n-#define FOR_EACH_ABSTRACT_BARRIER_SET_DO(f)          \\\n-  f(ModRef)\n-\n-\/\/ Do something for each known barrier set.\n-#define FOR_EACH_BARRIER_SET_DO(f)    \\\n-  FOR_EACH_ABSTRACT_BARRIER_SET_DO(f) \\\n-  FOR_EACH_CONCRETE_BARRIER_SET_DO(f)\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetConfig.hpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"gc\/shared\/modRefBarrierSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetConfig.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,62 @@\n+void CardTableBarrierSetC1::store_at_resolved(LIRAccess& access, LIR_Opr value) {\n+  DecoratorSet decorators = access.decorators();\n+  bool is_array = (decorators & IS_ARRAY) != 0;\n+  bool on_anonymous = (decorators & ON_UNKNOWN_OOP_REF) != 0;\n+\n+  if (access.is_oop()) {\n+    pre_barrier(access, access.resolved_addr(),\n+                LIR_OprFact::illegalOpr \/* pre_val *\/, access.patch_emit_info());\n+  }\n+\n+  BarrierSetC1::store_at_resolved(access, value);\n+\n+  if (access.is_oop()) {\n+    bool precise = is_array || on_anonymous;\n+    LIR_Opr post_addr = precise ? access.resolved_addr() : access.base().opr();\n+    post_barrier(access, post_addr, value);\n+  }\n+}\n+\n+LIR_Opr CardTableBarrierSetC1::atomic_cmpxchg_at_resolved(LIRAccess& access, LIRItem& cmp_value, LIRItem& new_value) {\n+  if (access.is_oop()) {\n+    pre_barrier(access, access.resolved_addr(),\n+                LIR_OprFact::illegalOpr \/* pre_val *\/, nullptr);\n+  }\n+\n+  LIR_Opr result = BarrierSetC1::atomic_cmpxchg_at_resolved(access, cmp_value, new_value);\n+\n+  if (access.is_oop()) {\n+    post_barrier(access, access.resolved_addr(), new_value.result());\n+  }\n+\n+  return result;\n+}\n+\n+LIR_Opr CardTableBarrierSetC1::atomic_xchg_at_resolved(LIRAccess& access, LIRItem& value) {\n+  if (access.is_oop()) {\n+    pre_barrier(access, access.resolved_addr(),\n+                LIR_OprFact::illegalOpr \/* pre_val *\/, nullptr);\n+  }\n+\n+  LIR_Opr result = BarrierSetC1::atomic_xchg_at_resolved(access, value);\n+\n+  if (access.is_oop()) {\n+    post_barrier(access, access.resolved_addr(), value.result());\n+  }\n+\n+  return result;\n+}\n+\n+\/\/ This overrides the default to resolve the address into a register,\n+\/\/ assuming it will be used by a write barrier anyway.\n+LIR_Opr CardTableBarrierSetC1::resolve_address(LIRAccess& access, bool resolve_in_register) {\n+  DecoratorSet decorators = access.decorators();\n+  bool needs_patching = (decorators & C1_NEEDS_PATCHING) != 0;\n+  bool is_write = (decorators & ACCESS_WRITE) != 0;\n+  bool is_array = (decorators & IS_ARRAY) != 0;\n+  bool on_anonymous = (decorators & ON_UNKNOWN_OOP_REF) != 0;\n+  bool precise = is_array || on_anonymous;\n+  resolve_in_register |= !needs_patching && is_write && access.is_oop() && precise;\n+  return BarrierSetC1::resolve_address(access, resolve_in_register);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/c1\/cardTableBarrierSetC1.cpp","additions":62,"deletions":0,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"gc\/shared\/c1\/modRefBarrierSetC1.hpp\"\n+#include \"gc\/shared\/c1\/barrierSetC1.hpp\"\n@@ -30,1 +30,1 @@\n-class CardTableBarrierSetC1 : public ModRefBarrierSetC1 {\n+class CardTableBarrierSetC1 : public BarrierSetC1 {\n@@ -32,0 +32,3 @@\n+  virtual void pre_barrier(LIRAccess& access, LIR_Opr addr_opr,\n+                         LIR_Opr pre_val, CodeEmitInfo* info) {}\n+\n@@ -33,0 +36,8 @@\n+\n+  virtual LIR_Opr resolve_address(LIRAccess& access, bool resolve_in_register);\n+\n+  virtual void store_at_resolved(LIRAccess& access, LIR_Opr value);\n+\n+  virtual LIR_Opr atomic_cmpxchg_at_resolved(LIRAccess& access, LIRItem& cmp_value, LIRItem& new_value);\n+\n+  virtual LIR_Opr atomic_xchg_at_resolved(LIRAccess& access, LIRItem& value);\n","filename":"src\/hotspot\/share\/gc\/shared\/c1\/cardTableBarrierSetC1.hpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1,94 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"gc\/shared\/c1\/modRefBarrierSetC1.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-#ifdef ASSERT\n-#define __ gen->lir(__FILE__, __LINE__)->\n-#else\n-#define __ gen->lir()->\n-#endif\n-\n-void ModRefBarrierSetC1::store_at_resolved(LIRAccess& access, LIR_Opr value) {\n-  DecoratorSet decorators = access.decorators();\n-  bool is_array = (decorators & IS_ARRAY) != 0;\n-  bool on_anonymous = (decorators & ON_UNKNOWN_OOP_REF) != 0;\n-\n-  if (access.is_oop()) {\n-    pre_barrier(access, access.resolved_addr(),\n-                LIR_OprFact::illegalOpr \/* pre_val *\/, access.patch_emit_info());\n-  }\n-\n-  BarrierSetC1::store_at_resolved(access, value);\n-\n-  if (access.is_oop()) {\n-    bool precise = is_array || on_anonymous;\n-    LIR_Opr post_addr = precise ? access.resolved_addr() : access.base().opr();\n-    post_barrier(access, post_addr, value);\n-  }\n-}\n-\n-LIR_Opr ModRefBarrierSetC1::atomic_cmpxchg_at_resolved(LIRAccess& access, LIRItem& cmp_value, LIRItem& new_value) {\n-  if (access.is_oop()) {\n-    pre_barrier(access, access.resolved_addr(),\n-                LIR_OprFact::illegalOpr \/* pre_val *\/, nullptr);\n-  }\n-\n-  LIR_Opr result = BarrierSetC1::atomic_cmpxchg_at_resolved(access, cmp_value, new_value);\n-\n-  if (access.is_oop()) {\n-    post_barrier(access, access.resolved_addr(), new_value.result());\n-  }\n-\n-  return result;\n-}\n-\n-LIR_Opr ModRefBarrierSetC1::atomic_xchg_at_resolved(LIRAccess& access, LIRItem& value) {\n-  if (access.is_oop()) {\n-    pre_barrier(access, access.resolved_addr(),\n-                LIR_OprFact::illegalOpr \/* pre_val *\/, nullptr);\n-  }\n-\n-  LIR_Opr result = BarrierSetC1::atomic_xchg_at_resolved(access, value);\n-\n-  if (access.is_oop()) {\n-    post_barrier(access, access.resolved_addr(), value.result());\n-  }\n-\n-  return result;\n-}\n-\n-\/\/ This overrides the default to resolve the address into a register,\n-\/\/ assuming it will be used by a write barrier anyway.\n-LIR_Opr ModRefBarrierSetC1::resolve_address(LIRAccess& access, bool resolve_in_register) {\n-  DecoratorSet decorators = access.decorators();\n-  bool needs_patching = (decorators & C1_NEEDS_PATCHING) != 0;\n-  bool is_write = (decorators & ACCESS_WRITE) != 0;\n-  bool is_array = (decorators & IS_ARRAY) != 0;\n-  bool on_anonymous = (decorators & ON_UNKNOWN_OOP_REF) != 0;\n-  bool precise = is_array || on_anonymous;\n-  resolve_in_register |= !needs_patching && is_write && access.is_oop() && precise;\n-  return BarrierSetC1::resolve_address(access, resolve_in_register);\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/c1\/modRefBarrierSetC1.cpp","additions":0,"deletions":94,"binary":false,"changes":94,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHARED_C1_MODREFBARRIERSETC1_HPP\n-#define SHARE_GC_SHARED_C1_MODREFBARRIERSETC1_HPP\n-\n-#include \"gc\/shared\/c1\/barrierSetC1.hpp\"\n-\n-\/\/ The ModRefBarrierSetC1 filters away accesses on BasicTypes other\n-\/\/ than T_OBJECT\/T_ARRAY (oops). The oop accesses call one of the protected\n-\/\/ accesses, which are overridden in the concrete BarrierSetAssembler.\n-\n-class ModRefBarrierSetC1 : public BarrierSetC1 {\n-protected:\n-  virtual void pre_barrier(LIRAccess& access, LIR_Opr addr_opr,\n-                           LIR_Opr pre_val, CodeEmitInfo* info) {}\n-  virtual void post_barrier(LIRAccess& access, LIR_Opr addr,\n-                            LIR_Opr new_val) {}\n-\n-  virtual LIR_Opr resolve_address(LIRAccess& access, bool resolve_in_register);\n-\n-  virtual void store_at_resolved(LIRAccess& access, LIR_Opr value);\n-\n-  virtual LIR_Opr atomic_cmpxchg_at_resolved(LIRAccess& access, LIRItem& cmp_value, LIRItem& new_value);\n-\n-  virtual LIR_Opr atomic_xchg_at_resolved(LIRAccess& access, LIRItem& value);\n-};\n-\n-#endif \/\/ SHARE_GC_SHARED_C1_MODREFBARRIERSETC1_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/c1\/modRefBarrierSetC1.hpp","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -38,0 +38,79 @@\n+Node* CardTableBarrierSetC2::store_at_resolved(C2Access& access, C2AccessValue& val) const {\n+  DecoratorSet decorators = access.decorators();\n+\n+  Node* adr = access.addr().node();\n+\n+  bool is_array = (decorators & IS_ARRAY) != 0;\n+  bool anonymous = (decorators & ON_UNKNOWN_OOP_REF) != 0;\n+  bool in_heap = (decorators & IN_HEAP) != 0;\n+  bool use_precise = is_array || anonymous;\n+  bool tightly_coupled_alloc = (decorators & C2_TIGHTLY_COUPLED_ALLOC) != 0;\n+\n+  if (!access.is_oop() || tightly_coupled_alloc || (!in_heap && !anonymous)) {\n+    return BarrierSetC2::store_at_resolved(access, val);\n+  }\n+\n+  assert(access.is_parse_access(), \"entry not supported at optimization time\");\n+  C2ParseAccess& parse_access = static_cast<C2ParseAccess&>(access);\n+\n+  Node* store = BarrierSetC2::store_at_resolved(access, val);\n+  post_barrier(parse_access.kit(), access.base(), adr, val.node(), use_precise);\n+\n+  return store;\n+}\n+\n+Node* CardTableBarrierSetC2::atomic_cmpxchg_val_at_resolved(C2AtomicParseAccess& access, Node* expected_val,\n+                                                            Node* new_val, const Type* value_type) const {\n+  if (!access.is_oop()) {\n+    return BarrierSetC2::atomic_cmpxchg_val_at_resolved(access, expected_val, new_val, value_type);\n+  }\n+\n+  Node* result = BarrierSetC2::atomic_cmpxchg_val_at_resolved(access, expected_val, new_val, value_type);\n+\n+  post_barrier(access.kit(), access.base(), access.addr().node(), new_val, true);\n+\n+  return result;\n+}\n+\n+Node* CardTableBarrierSetC2::atomic_cmpxchg_bool_at_resolved(C2AtomicParseAccess& access, Node* expected_val,\n+                                                             Node* new_val, const Type* value_type) const {\n+  GraphKit* kit = access.kit();\n+\n+  if (!access.is_oop()) {\n+    return BarrierSetC2::atomic_cmpxchg_bool_at_resolved(access, expected_val, new_val, value_type);\n+  }\n+\n+  Node* load_store = BarrierSetC2::atomic_cmpxchg_bool_at_resolved(access, expected_val, new_val, value_type);\n+\n+  \/\/ Emit the post barrier only when the actual store happened. This makes sense\n+  \/\/ to check only for LS_cmp_* that can fail to set the value.\n+  \/\/ LS_cmp_exchange does not produce any branches by default, so there is no\n+  \/\/ boolean result to piggyback on. TODO: When we merge CompareAndSwap with\n+  \/\/ CompareAndExchange and move branches here, it would make sense to conditionalize\n+  \/\/ post_barriers for LS_cmp_exchange as well.\n+  \/\/\n+  \/\/ CAS success path is marked more likely since we anticipate this is a performance\n+  \/\/ critical path, while CAS failure path can use the penalty for going through unlikely\n+  \/\/ path as backoff. Which is still better than doing a store barrier there.\n+  IdealKit ideal(kit);\n+  ideal.if_then(load_store, BoolTest::ne, ideal.ConI(0), PROB_STATIC_FREQUENT); {\n+    kit->sync_kit(ideal);\n+    post_barrier(kit, access.base(), access.addr().node(), new_val, true);\n+    ideal.sync_kit(kit);\n+  } ideal.end_if();\n+  kit->final_sync(ideal);\n+\n+  return load_store;\n+}\n+\n+Node* CardTableBarrierSetC2::atomic_xchg_at_resolved(C2AtomicParseAccess& access, Node* new_val, const Type* value_type) const {\n+  Node* result = BarrierSetC2::atomic_xchg_at_resolved(access, new_val, value_type);\n+  if (!access.is_oop()) {\n+    return result;\n+  }\n+\n+  post_barrier(access.kit(), access.base(), access.addr().node(), new_val, true);\n+\n+  return result;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/cardTableBarrierSetC2.cpp","additions":79,"deletions":0,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"gc\/shared\/c2\/modRefBarrierSetC2.hpp\"\n+#include \"gc\/shared\/c2\/barrierSetC2.hpp\"\n@@ -30,1 +30,1 @@\n-class CardTableBarrierSetC2: public ModRefBarrierSetC2 {\n+class CardTableBarrierSetC2: public BarrierSetC2 {\n@@ -38,0 +38,8 @@\n+  virtual Node* store_at_resolved(C2Access& access, C2AccessValue& val) const;\n+\n+  virtual Node* atomic_cmpxchg_val_at_resolved(C2AtomicParseAccess& access, Node* expected_val,\n+                                               Node* new_val, const Type* value_type) const;\n+  virtual Node* atomic_cmpxchg_bool_at_resolved(C2AtomicParseAccess& access, Node* expected_val,\n+                                                Node* new_val, const Type* value_type) const;\n+  virtual Node* atomic_xchg_at_resolved(C2AtomicParseAccess& access, Node* new_val, const Type* value_type) const;\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/cardTableBarrierSetC2.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,107 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"gc\/shared\/c2\/modRefBarrierSetC2.hpp\"\n-#include \"opto\/arraycopynode.hpp\"\n-#include \"opto\/graphKit.hpp\"\n-#include \"opto\/idealKit.hpp\"\n-\n-Node* ModRefBarrierSetC2::store_at_resolved(C2Access& access, C2AccessValue& val) const {\n-  DecoratorSet decorators = access.decorators();\n-\n-  Node* adr = access.addr().node();\n-\n-  bool is_array = (decorators & IS_ARRAY) != 0;\n-  bool anonymous = (decorators & ON_UNKNOWN_OOP_REF) != 0;\n-  bool in_heap = (decorators & IN_HEAP) != 0;\n-  bool use_precise = is_array || anonymous;\n-  bool tightly_coupled_alloc = (decorators & C2_TIGHTLY_COUPLED_ALLOC) != 0;\n-\n-  if (!access.is_oop() || tightly_coupled_alloc || (!in_heap && !anonymous)) {\n-    return BarrierSetC2::store_at_resolved(access, val);\n-  }\n-\n-  assert(access.is_parse_access(), \"entry not supported at optimization time\");\n-  C2ParseAccess& parse_access = static_cast<C2ParseAccess&>(access);\n-\n-  Node* store = BarrierSetC2::store_at_resolved(access, val);\n-  post_barrier(parse_access.kit(), access.base(), adr, val.node(), use_precise);\n-\n-  return store;\n-}\n-\n-Node* ModRefBarrierSetC2::atomic_cmpxchg_val_at_resolved(C2AtomicParseAccess& access, Node* expected_val,\n-                                                         Node* new_val, const Type* value_type) const {\n-  if (!access.is_oop()) {\n-    return BarrierSetC2::atomic_cmpxchg_val_at_resolved(access, expected_val, new_val, value_type);\n-  }\n-\n-  Node* result = BarrierSetC2::atomic_cmpxchg_val_at_resolved(access, expected_val, new_val, value_type);\n-\n-  post_barrier(access.kit(), access.base(), access.addr().node(), new_val, true);\n-\n-  return result;\n-}\n-\n-Node* ModRefBarrierSetC2::atomic_cmpxchg_bool_at_resolved(C2AtomicParseAccess& access, Node* expected_val,\n-                                                          Node* new_val, const Type* value_type) const {\n-  GraphKit* kit = access.kit();\n-\n-  if (!access.is_oop()) {\n-    return BarrierSetC2::atomic_cmpxchg_bool_at_resolved(access, expected_val, new_val, value_type);\n-  }\n-\n-  Node* load_store = BarrierSetC2::atomic_cmpxchg_bool_at_resolved(access, expected_val, new_val, value_type);\n-\n-  \/\/ Emit the post barrier only when the actual store happened. This makes sense\n-  \/\/ to check only for LS_cmp_* that can fail to set the value.\n-  \/\/ LS_cmp_exchange does not produce any branches by default, so there is no\n-  \/\/ boolean result to piggyback on. TODO: When we merge CompareAndSwap with\n-  \/\/ CompareAndExchange and move branches here, it would make sense to conditionalize\n-  \/\/ post_barriers for LS_cmp_exchange as well.\n-  \/\/\n-  \/\/ CAS success path is marked more likely since we anticipate this is a performance\n-  \/\/ critical path, while CAS failure path can use the penalty for going through unlikely\n-  \/\/ path as backoff. Which is still better than doing a store barrier there.\n-  IdealKit ideal(kit);\n-  ideal.if_then(load_store, BoolTest::ne, ideal.ConI(0), PROB_STATIC_FREQUENT); {\n-    kit->sync_kit(ideal);\n-    post_barrier(kit, access.base(), access.addr().node(), new_val, true);\n-    ideal.sync_kit(kit);\n-  } ideal.end_if();\n-  kit->final_sync(ideal);\n-\n-  return load_store;\n-}\n-\n-Node* ModRefBarrierSetC2::atomic_xchg_at_resolved(C2AtomicParseAccess& access, Node* new_val, const Type* value_type) const {\n-  Node* result = BarrierSetC2::atomic_xchg_at_resolved(access, new_val, value_type);\n-  if (!access.is_oop()) {\n-    return result;\n-  }\n-\n-  post_barrier(access.kit(), access.base(), access.addr().node(), new_val, true);\n-\n-  return result;\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/modRefBarrierSetC2.cpp","additions":0,"deletions":107,"binary":false,"changes":107,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHARED_C2_MODREFBARRIERSETC2_HPP\n-#define SHARE_GC_SHARED_C2_MODREFBARRIERSETC2_HPP\n-\n-#include \"gc\/shared\/c2\/barrierSetC2.hpp\"\n-\n-class TypeOopPtr;\n-\n-class ModRefBarrierSetC2: public BarrierSetC2 {\n-protected:\n-  virtual void post_barrier(GraphKit* kit,\n-                            Node* obj,\n-                            Node* adr,\n-                            Node* val,\n-                            bool use_precise) const {}\n-\n-  virtual Node* store_at_resolved(C2Access& access, C2AccessValue& val) const;\n-\n-  virtual Node* atomic_cmpxchg_val_at_resolved(C2AtomicParseAccess& access, Node* expected_val,\n-                                               Node* new_val, const Type* value_type) const;\n-  virtual Node* atomic_cmpxchg_bool_at_resolved(C2AtomicParseAccess& access, Node* expected_val,\n-                                                Node* new_val, const Type* value_type) const;\n-  virtual Node* atomic_xchg_at_resolved(C2AtomicParseAccess& access, Node* new_val, const Type* value_type) const;\n-};\n-\n-#endif \/\/ SHARE_GC_SHARED_C2_MODREFBARRIERSETC2_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/modRefBarrierSetC2.hpp","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -56,4 +56,6 @@\n-  ModRefBarrierSet(barrier_set_assembler,\n-                   barrier_set_c1,\n-                   barrier_set_c2,\n-                   fake_rtti.add_tag(BarrierSet::CardTableBarrierSet)),\n+  BarrierSet(barrier_set_assembler,\n+             barrier_set_c1,\n+             barrier_set_c2,\n+             nullptr \/* barrier_set_nmethod *\/,\n+             nullptr \/* barrier_set_stack_chunk *\/,\n+             fake_rtti.add_tag(BarrierSet::CardTableBarrierSet)),\n@@ -64,4 +66,6 @@\n-  ModRefBarrierSet(make_barrier_set_assembler<CardTableBarrierSetAssembler>(),\n-                   make_barrier_set_c1<CardTableBarrierSetC1>(),\n-                   make_barrier_set_c2<CardTableBarrierSetC2>(),\n-                   BarrierSet::FakeRtti(BarrierSet::CardTableBarrierSet)),\n+  BarrierSet(make_barrier_set_assembler<CardTableBarrierSetAssembler>(),\n+             make_barrier_set_c1<CardTableBarrierSetC1>(),\n+             make_barrier_set_c2<CardTableBarrierSetC2>(),\n+             nullptr \/* barrier_set_nmethod *\/,\n+             nullptr \/* barrier_set_stack_chunk *\/,\n+             BarrierSet::FakeRtti(BarrierSet::CardTableBarrierSet)),\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableBarrierSet.cpp","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/barrierSet.hpp\"\n@@ -29,1 +30,1 @@\n-#include \"gc\/shared\/modRefBarrierSet.hpp\"\n+#include \"memory\/memRegion.hpp\"\n@@ -44,1 +45,1 @@\n-class CardTableBarrierSet: public ModRefBarrierSet {\n+class CardTableBarrierSet: public BarrierSet {\n@@ -62,1 +63,2 @@\n-  CardTable* card_table() const { return _card_table; }\n+  template <DecoratorSet decorators, typename T>\n+  inline void write_ref_field_pre(T* addr) {}\n@@ -69,1 +71,1 @@\n-  void write_ref_field_post(T* field);\n+  inline void write_ref_field_post(T *addr);\n@@ -71,0 +73,1 @@\n+  \/\/ Causes all refs in \"mr\" to be assumed to be modified (by this JavaThread).\n@@ -73,0 +76,14 @@\n+  \/\/ Operations on arrays, or general regions (e.g., for \"clone\") may be\n+  \/\/ optimized by some barriers.\n+\n+  \/\/ Below length is the # array elements being written\n+  virtual void write_ref_array_pre(oop* dst, size_t length,\n+                                   bool dest_uninitialized) {}\n+  virtual void write_ref_array_pre(narrowOop* dst, size_t length,\n+                                   bool dest_uninitialized) {}\n+  \/\/ Below count is the # array elements being written, starting\n+  \/\/ at the address \"start\", which may not necessarily be HeapWord-aligned\n+  inline void write_ref_array(HeapWord* start, size_t count);\n+\n+  CardTable* card_table() const { return _card_table; }\n+\n@@ -78,1 +95,30 @@\n-  class AccessBarrier: public ModRefBarrierSet::AccessBarrier<decorators, BarrierSetT> {};\n+  class AccessBarrier: public BarrierSet::AccessBarrier<decorators, BarrierSetT> {\n+    typedef BarrierSet::AccessBarrier<decorators, BarrierSetT> Raw;\n+\n+  public:\n+    template <typename T>\n+    static void oop_store_in_heap(T* addr, oop value);\n+    template <typename T>\n+    static oop oop_atomic_cmpxchg_in_heap(T* addr, oop compare_value, oop new_value);\n+    template <typename T>\n+    static oop oop_atomic_xchg_in_heap(T* addr, oop new_value);\n+\n+    template <typename T>\n+    static bool oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,\n+                                      arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,\n+                                      size_t length);\n+\n+    static void clone_in_heap(oop src, oop dst, size_t size);\n+\n+    static void oop_store_in_heap_at(oop base, ptrdiff_t offset, oop value) {\n+      oop_store_in_heap(AccessInternal::oop_field_addr<decorators>(base, offset), value);\n+    }\n+\n+    static oop oop_atomic_xchg_in_heap_at(oop base, ptrdiff_t offset, oop new_value) {\n+      return oop_atomic_xchg_in_heap(AccessInternal::oop_field_addr<decorators>(base, offset), new_value);\n+    }\n+\n+    static oop oop_atomic_cmpxchg_in_heap_at(oop base, ptrdiff_t offset, oop compare_value, oop new_value) {\n+      return oop_atomic_cmpxchg_in_heap(AccessInternal::oop_field_addr<decorators>(base, offset), compare_value, new_value);\n+    }\n+  };\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableBarrierSet.hpp","additions":51,"deletions":5,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/barrierSet.hpp\"\n@@ -31,1 +32,3 @@\n-#include \"runtime\/atomicAccess.hpp\"\n+#include \"oops\/compressedOops.inline.hpp\"\n+#include \"oops\/objArrayOop.hpp\"\n+#include \"oops\/oop.hpp\"\n@@ -39,0 +42,108 @@\n+class Klass;\n+\n+\/\/ count is number of array elements being written\n+void CardTableBarrierSet::write_ref_array(HeapWord* start, size_t count) {\n+  HeapWord* end = (HeapWord*)((char*)start + (count*heapOopSize));\n+  \/\/ In the case of compressed oops, start and end may potentially be misaligned;\n+  \/\/ so we need to conservatively align the first downward (this is not\n+  \/\/ strictly necessary for current uses, but a case of good hygiene and,\n+  \/\/ if you will, aesthetics) and the second upward (this is essential for\n+  \/\/ current uses) to a HeapWord boundary, so we mark all cards overlapping\n+  \/\/ this write. If this evolves in the future to calling a\n+  \/\/ logging barrier of narrow oop granularity, like the pre-barrier for G1\n+  \/\/ (mentioned here merely by way of example), we will need to change this\n+  \/\/ interface, so it is \"exactly precise\" (if i may be allowed the adverbial\n+  \/\/ redundancy for emphasis) and does not include narrow oop slots not\n+  \/\/ included in the original write interval.\n+  HeapWord* aligned_start = align_down(start, HeapWordSize);\n+  HeapWord* aligned_end   = align_up  (end,   HeapWordSize);\n+  \/\/ If compressed oops were not being used, these should already be aligned\n+  assert(UseCompressedOops || (aligned_start == start && aligned_end == end),\n+         \"Expected heap word alignment of start and end\");\n+  write_region(MemRegion(aligned_start, aligned_end));\n+}\n+\n+template <DecoratorSet decorators, typename BarrierSetT>\n+template <typename T>\n+inline void CardTableBarrierSet::AccessBarrier<decorators, BarrierSetT>::\n+oop_store_in_heap(T* addr, oop value) {\n+  BarrierSetT *bs = barrier_set_cast<BarrierSetT>(barrier_set());\n+  bs->template write_ref_field_pre<decorators>(addr);\n+  Raw::oop_store(addr, value);\n+  bs->template write_ref_field_post<decorators>(addr);\n+}\n+\n+template <DecoratorSet decorators, typename BarrierSetT>\n+template <typename T>\n+inline oop CardTableBarrierSet::AccessBarrier<decorators, BarrierSetT>::\n+oop_atomic_cmpxchg_in_heap(T* addr, oop compare_value, oop new_value) {\n+  BarrierSetT *bs = barrier_set_cast<BarrierSetT>(barrier_set());\n+  bs->template write_ref_field_pre<decorators>(addr);\n+  oop result = Raw::oop_atomic_cmpxchg(addr, compare_value, new_value);\n+  if (result == compare_value) {\n+    bs->template write_ref_field_post<decorators>(addr);\n+  }\n+  return result;\n+}\n+\n+template <DecoratorSet decorators, typename BarrierSetT>\n+template <typename T>\n+inline oop CardTableBarrierSet::AccessBarrier<decorators, BarrierSetT>::\n+oop_atomic_xchg_in_heap(T* addr, oop new_value) {\n+  BarrierSetT *bs = barrier_set_cast<BarrierSetT>(barrier_set());\n+  bs->template write_ref_field_pre<decorators>(addr);\n+  oop result = Raw::oop_atomic_xchg(addr, new_value);\n+  bs->template write_ref_field_post<decorators>(addr);\n+  return result;\n+}\n+\n+template <DecoratorSet decorators, typename BarrierSetT>\n+template <typename T>\n+inline bool CardTableBarrierSet::AccessBarrier<decorators, BarrierSetT>::\n+oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,\n+                      arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,\n+                      size_t length) {\n+  BarrierSetT *bs = barrier_set_cast<BarrierSetT>(barrier_set());\n+\n+  src_raw = arrayOopDesc::obj_offset_to_raw(src_obj, src_offset_in_bytes, src_raw);\n+  dst_raw = arrayOopDesc::obj_offset_to_raw(dst_obj, dst_offset_in_bytes, dst_raw);\n+\n+  if (!HasDecorator<decorators, ARRAYCOPY_CHECKCAST>::value) {\n+    \/\/ Optimized covariant case\n+    bs->write_ref_array_pre(dst_raw, length,\n+                            HasDecorator<decorators, IS_DEST_UNINITIALIZED>::value);\n+    Raw::oop_arraycopy(nullptr, 0, src_raw, nullptr, 0, dst_raw, length);\n+    bs->write_ref_array((HeapWord*)dst_raw, length);\n+  } else {\n+    assert(dst_obj != nullptr, \"better have an actual oop\");\n+    Klass* bound = objArrayOop(dst_obj)->element_klass();\n+    T* from = const_cast<T*>(src_raw);\n+    T* end = from + length;\n+    for (T* p = dst_raw; from < end; from++, p++) {\n+      T element = *from;\n+      if (oopDesc::is_instanceof_or_null(CompressedOops::decode(element), bound)) {\n+        bs->template write_ref_field_pre<decorators>(p);\n+        *p = element;\n+      } else {\n+        \/\/ We must do a barrier to cover the partial copy.\n+        const size_t pd = pointer_delta(p, dst_raw, (size_t)heapOopSize);\n+        \/\/ pointer delta is scaled to number of elements (length field in\n+        \/\/ objArrayOop) which we assume is 32 bit.\n+        assert(pd == (size_t)(int)pd, \"length field overflow\");\n+        bs->write_ref_array((HeapWord*)dst_raw, pd);\n+        return false;\n+      }\n+    }\n+    bs->write_ref_array((HeapWord*)dst_raw, length);\n+  }\n+  return true;\n+}\n+\n+template <DecoratorSet decorators, typename BarrierSetT>\n+inline void CardTableBarrierSet::AccessBarrier<decorators, BarrierSetT>::\n+clone_in_heap(oop src, oop dst, size_t size) {\n+  Raw::clone(src, dst, size);\n+  BarrierSetT *bs = barrier_set_cast<BarrierSetT>(barrier_set());\n+  bs->write_region(MemRegion((HeapWord*)(void*)dst, size));\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableBarrierSet.inline.hpp","additions":112,"deletions":1,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -1,108 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHARED_MODREFBARRIERSET_HPP\n-#define SHARE_GC_SHARED_MODREFBARRIERSET_HPP\n-\n-#include \"gc\/shared\/barrierSet.hpp\"\n-#include \"memory\/memRegion.hpp\"\n-\n-class Klass;\n-\n-class ModRefBarrierSet: public BarrierSet {\n-protected:\n-  ModRefBarrierSet(BarrierSetAssembler* barrier_set_assembler,\n-                   BarrierSetC1* barrier_set_c1,\n-                   BarrierSetC2* barrier_set_c2,\n-                   const BarrierSet::FakeRtti& fake_rtti)\n-    : BarrierSet(barrier_set_assembler,\n-                 barrier_set_c1,\n-                 barrier_set_c2,\n-                 nullptr \/* barrier_set_nmethod *\/,\n-                 nullptr \/* barrier_set_stack_chunk *\/,\n-                 fake_rtti.add_tag(BarrierSet::ModRef)) { }\n-  ~ModRefBarrierSet() { }\n-\n-public:\n-  template <DecoratorSet decorators, typename T>\n-  inline void write_ref_field_pre(T* addr) {}\n-\n-  template <DecoratorSet decorators, typename T>\n-  inline void write_ref_field_post(T *addr) {}\n-\n-  \/\/ Causes all refs in \"mr\" to be assumed to be modified (by this JavaThread).\n-  virtual void write_region(MemRegion mr) = 0;\n-\n-  \/\/ Operations on arrays, or general regions (e.g., for \"clone\") may be\n-  \/\/ optimized by some barriers.\n-\n-  \/\/ Below length is the # array elements being written\n-  virtual void write_ref_array_pre(oop* dst, size_t length,\n-                                   bool dest_uninitialized) {}\n-  virtual void write_ref_array_pre(narrowOop* dst, size_t length,\n-                                   bool dest_uninitialized) {}\n-  \/\/ Below count is the # array elements being written, starting\n-  \/\/ at the address \"start\", which may not necessarily be HeapWord-aligned\n-  inline void write_ref_array(HeapWord* start, size_t count);\n-\n-  \/\/ The ModRef abstraction introduces pre and post barriers\n-  template <DecoratorSet decorators, typename BarrierSetT>\n-  class AccessBarrier: public BarrierSet::AccessBarrier<decorators, BarrierSetT> {\n-    typedef BarrierSet::AccessBarrier<decorators, BarrierSetT> Raw;\n-\n-  public:\n-    template <typename T>\n-    static void oop_store_in_heap(T* addr, oop value);\n-    template <typename T>\n-    static oop oop_atomic_cmpxchg_in_heap(T* addr, oop compare_value, oop new_value);\n-    template <typename T>\n-    static oop oop_atomic_xchg_in_heap(T* addr, oop new_value);\n-\n-    template <typename T>\n-    static bool oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,\n-                                      arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,\n-                                      size_t length);\n-\n-    static void clone_in_heap(oop src, oop dst, size_t size);\n-\n-    static void oop_store_in_heap_at(oop base, ptrdiff_t offset, oop value) {\n-      oop_store_in_heap(AccessInternal::oop_field_addr<decorators>(base, offset), value);\n-    }\n-\n-    static oop oop_atomic_xchg_in_heap_at(oop base, ptrdiff_t offset, oop new_value) {\n-      return oop_atomic_xchg_in_heap(AccessInternal::oop_field_addr<decorators>(base, offset), new_value);\n-    }\n-\n-    static oop oop_atomic_cmpxchg_in_heap_at(oop base, ptrdiff_t offset, oop compare_value, oop new_value) {\n-      return oop_atomic_cmpxchg_in_heap(AccessInternal::oop_field_addr<decorators>(base, offset), compare_value, new_value);\n-    }\n-  };\n-};\n-\n-template<>\n-struct BarrierSet::GetName<ModRefBarrierSet> {\n-  static const BarrierSet::Name value = BarrierSet::ModRef;\n-};\n-\n-#endif \/\/ SHARE_GC_SHARED_MODREFBARRIERSET_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/modRefBarrierSet.hpp","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"},{"patch":"@@ -1,144 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHARED_MODREFBARRIERSET_INLINE_HPP\n-#define SHARE_GC_SHARED_MODREFBARRIERSET_INLINE_HPP\n-\n-#include \"gc\/shared\/modRefBarrierSet.hpp\"\n-\n-#include \"gc\/shared\/barrierSet.hpp\"\n-#include \"oops\/compressedOops.inline.hpp\"\n-#include \"oops\/objArrayOop.hpp\"\n-#include \"oops\/oop.hpp\"\n-#include \"runtime\/thread.hpp\"\n-\n-class Klass;\n-\n-\/\/ count is number of array elements being written\n-void ModRefBarrierSet::write_ref_array(HeapWord* start, size_t count) {\n-  HeapWord* end = (HeapWord*)((char*)start + (count*heapOopSize));\n-  \/\/ In the case of compressed oops, start and end may potentially be misaligned;\n-  \/\/ so we need to conservatively align the first downward (this is not\n-  \/\/ strictly necessary for current uses, but a case of good hygiene and,\n-  \/\/ if you will, aesthetics) and the second upward (this is essential for\n-  \/\/ current uses) to a HeapWord boundary, so we mark all cards overlapping\n-  \/\/ this write. If this evolves in the future to calling a\n-  \/\/ logging barrier of narrow oop granularity, like the pre-barrier for G1\n-  \/\/ (mentioned here merely by way of example), we will need to change this\n-  \/\/ interface, so it is \"exactly precise\" (if i may be allowed the adverbial\n-  \/\/ redundancy for emphasis) and does not include narrow oop slots not\n-  \/\/ included in the original write interval.\n-  HeapWord* aligned_start = align_down(start, HeapWordSize);\n-  HeapWord* aligned_end   = align_up  (end,   HeapWordSize);\n-  \/\/ If compressed oops were not being used, these should already be aligned\n-  assert(UseCompressedOops || (aligned_start == start && aligned_end == end),\n-         \"Expected heap word alignment of start and end\");\n-  write_region(MemRegion(aligned_start, aligned_end));\n-}\n-\n-template <DecoratorSet decorators, typename BarrierSetT>\n-template <typename T>\n-inline void ModRefBarrierSet::AccessBarrier<decorators, BarrierSetT>::\n-oop_store_in_heap(T* addr, oop value) {\n-  BarrierSetT *bs = barrier_set_cast<BarrierSetT>(barrier_set());\n-  bs->template write_ref_field_pre<decorators>(addr);\n-  Raw::oop_store(addr, value);\n-  bs->template write_ref_field_post<decorators>(addr);\n-}\n-\n-template <DecoratorSet decorators, typename BarrierSetT>\n-template <typename T>\n-inline oop ModRefBarrierSet::AccessBarrier<decorators, BarrierSetT>::\n-oop_atomic_cmpxchg_in_heap(T* addr, oop compare_value, oop new_value) {\n-  BarrierSetT *bs = barrier_set_cast<BarrierSetT>(barrier_set());\n-  bs->template write_ref_field_pre<decorators>(addr);\n-  oop result = Raw::oop_atomic_cmpxchg(addr, compare_value, new_value);\n-  if (result == compare_value) {\n-    bs->template write_ref_field_post<decorators>(addr);\n-  }\n-  return result;\n-}\n-\n-template <DecoratorSet decorators, typename BarrierSetT>\n-template <typename T>\n-inline oop ModRefBarrierSet::AccessBarrier<decorators, BarrierSetT>::\n-oop_atomic_xchg_in_heap(T* addr, oop new_value) {\n-  BarrierSetT *bs = barrier_set_cast<BarrierSetT>(barrier_set());\n-  bs->template write_ref_field_pre<decorators>(addr);\n-  oop result = Raw::oop_atomic_xchg(addr, new_value);\n-  bs->template write_ref_field_post<decorators>(addr);\n-  return result;\n-}\n-\n-template <DecoratorSet decorators, typename BarrierSetT>\n-template <typename T>\n-inline bool ModRefBarrierSet::AccessBarrier<decorators, BarrierSetT>::\n-oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,\n-                      arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,\n-                      size_t length) {\n-  BarrierSetT *bs = barrier_set_cast<BarrierSetT>(barrier_set());\n-\n-  src_raw = arrayOopDesc::obj_offset_to_raw(src_obj, src_offset_in_bytes, src_raw);\n-  dst_raw = arrayOopDesc::obj_offset_to_raw(dst_obj, dst_offset_in_bytes, dst_raw);\n-\n-  if (!HasDecorator<decorators, ARRAYCOPY_CHECKCAST>::value) {\n-    \/\/ Optimized covariant case\n-    bs->write_ref_array_pre(dst_raw, length,\n-                            HasDecorator<decorators, IS_DEST_UNINITIALIZED>::value);\n-    Raw::oop_arraycopy(nullptr, 0, src_raw, nullptr, 0, dst_raw, length);\n-    bs->write_ref_array((HeapWord*)dst_raw, length);\n-  } else {\n-    assert(dst_obj != nullptr, \"better have an actual oop\");\n-    Klass* bound = objArrayOop(dst_obj)->element_klass();\n-    T* from = const_cast<T*>(src_raw);\n-    T* end = from + length;\n-    for (T* p = dst_raw; from < end; from++, p++) {\n-      T element = *from;\n-      if (oopDesc::is_instanceof_or_null(CompressedOops::decode(element), bound)) {\n-        bs->template write_ref_field_pre<decorators>(p);\n-        *p = element;\n-      } else {\n-        \/\/ We must do a barrier to cover the partial copy.\n-        const size_t pd = pointer_delta(p, dst_raw, (size_t)heapOopSize);\n-        \/\/ pointer delta is scaled to number of elements (length field in\n-        \/\/ objArrayOop) which we assume is 32 bit.\n-        assert(pd == (size_t)(int)pd, \"length field overflow\");\n-        bs->write_ref_array((HeapWord*)dst_raw, pd);\n-        return false;\n-      }\n-    }\n-    bs->write_ref_array((HeapWord*)dst_raw, length);\n-  }\n-  return true;\n-}\n-\n-template <DecoratorSet decorators, typename BarrierSetT>\n-inline void ModRefBarrierSet::AccessBarrier<decorators, BarrierSetT>::\n-clone_in_heap(oop src, oop dst, size_t size) {\n-  Raw::clone(src, dst, size);\n-  BarrierSetT *bs = barrier_set_cast<BarrierSetT>(barrier_set());\n-  bs->write_region(MemRegion((HeapWord*)(void*)dst, size));\n-}\n-\n-#endif \/\/ SHARE_GC_SHARED_MODREFBARRIERSET_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/modRefBarrierSet.inline.hpp","additions":0,"deletions":144,"binary":false,"changes":144,"status":"deleted"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHARED_MODREFBARRIERSETASSEMBLER_HPP\n-#define SHARE_GC_SHARED_MODREFBARRIERSETASSEMBLER_HPP\n-\n-#include \"utilities\/macros.hpp\"\n-\n-#include CPU_HEADER(gc\/shared\/modRefBarrierSetAssembler)\n-\n-#endif \/\/ SHARE_GC_SHARED_MODREFBARRIERSETASSEMBLER_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/modRefBarrierSetAssembler.hpp","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -135,2 +135,1 @@\n-           declare_type(ModRefBarrierSet,             BarrierSet)         \\\n-           declare_type(CardTableBarrierSet,          ModRefBarrierSet)   \\\n+           declare_type(CardTableBarrierSet,             BarrierSet)      \\\n@@ -186,1 +185,0 @@\n-  declare_constant(BarrierSet::ModRef)                                      \\\n","filename":"src\/hotspot\/share\/gc\/shared\/vmStructs_gc.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -222,1 +222,1 @@\n-        FOR_EACH_CONCRETE_BARRIER_SET_DO(BARRIER_SET_RESOLVE_BARRIER_CLOSURE)\n+        FOR_EACH_BARRIER_SET_DO(BARRIER_SET_RESOLVE_BARRIER_CLOSURE)\n@@ -245,1 +245,1 @@\n-        FOR_EACH_CONCRETE_BARRIER_SET_DO(BARRIER_SET_RESOLVE_BARRIER_CLOSURE)\n+        FOR_EACH_BARRIER_SET_DO(BARRIER_SET_RESOLVE_BARRIER_CLOSURE)\n","filename":"src\/hotspot\/share\/oops\/access.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3056,1 +3056,1 @@\n-      FOR_EACH_CONCRETE_BARRIER_SET_DO(BARRIER_SET_RESOLVE_BARRIER_CLOSURE)\n+      FOR_EACH_BARRIER_SET_DO(BARRIER_SET_RESOLVE_BARRIER_CLOSURE)\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}