{"files":[{"patch":"@@ -38,0 +38,1 @@\n+#include \"gc\/shared\/partialArraySplitter.inline.hpp\"\n@@ -39,1 +40,1 @@\n-#include \"gc\/shared\/partialArrayTaskStepper.inline.hpp\"\n+#include \"gc\/shared\/partialArrayTaskStats.hpp\"\n@@ -83,2 +84,1 @@\n-    _partial_array_state_allocator(g1h->partial_array_state_manager()),\n-    _partial_array_stepper(num_workers, ParGCArrayScanChunk),\n+    _partial_array_splitter(g1h->partial_array_state_manager(), num_workers),\n@@ -172,3 +172,6 @@\n-  \/\/ Must be in the collection set--it's already been copied.\n-  oop p = task->source();\n-  assert(_g1h->is_in_cset(p), \"p=\" PTR_FORMAT, p2i(p));\n+  assert(task != nullptr, \"invariant\");\n+  \/\/ Source isn't used for processing, so not recorded in task.\n+  assert(task->source() == nullptr, \"invariant\");\n+  oop p = task->destination();\n+  assert(_g1h->is_in_reserved(p),\n+         \"task=\" PTR_FORMAT \" dest=\" PTR_FORMAT, p2i(task), p2i(p));\n@@ -225,24 +228,5 @@\n-void G1ParScanThreadState::do_partial_array(PartialArrayState* state) {\n-  oop to_obj = state->destination();\n-\n-#ifdef ASSERT\n-  oop from_obj = state->source();\n-  assert(_g1h->is_in_reserved(from_obj), \"must be in heap.\");\n-  assert(from_obj->is_forwarded(), \"must be forwarded\");\n-  assert(from_obj != to_obj, \"should not be chunking self-forwarded objects\");\n-  assert(to_obj->is_objArray(), \"must be obj array\");\n-#endif \/\/ ASSERT\n-\n-  objArrayOop to_array = objArrayOop(to_obj);\n-\n-  \/\/ Claim a chunk and get number of additional tasks to enqueue.\n-  PartialArrayTaskStepper::Step step = _partial_array_stepper.next(state);\n-  \/\/ Push any additional partial scan tasks needed.  Pushed before processing\n-  \/\/ the claimed chunk to allow other workers to steal while we're processing.\n-  if (step._ncreate > 0) {\n-    state->add_references(step._ncreate);\n-    for (uint i = 0; i < step._ncreate; ++i) {\n-      push_on_queue(ScannerTask(state));\n-    }\n-  }\n-\n+void G1ParScanThreadState::do_partial_array(PartialArrayState* state, bool stolen) {\n+  \/\/ Access state before release by claim().\n+  objArrayOop to_array = objArrayOop(state->destination());\n+  PartialArraySplitter::Claim claim =\n+    _partial_array_splitter.claim(state, _task_queue, stolen);\n@@ -253,4 +237,2 @@\n-                              checked_cast<int>(step._index),\n-                              checked_cast<int>(step._index + _partial_array_stepper.chunk_size()));\n-  \/\/ Release reference to the state, now that we're done with it.\n-  _partial_array_state_allocator.release(state);\n+                              checked_cast<int>(claim._start),\n+                              checked_cast<int>(claim._end));\n@@ -268,1 +250,0 @@\n-\n@@ -270,19 +251,3 @@\n-  PartialArrayTaskStepper::Step step = _partial_array_stepper.start(array_length);\n-\n-  \/\/ Push any needed partial scan tasks.  Pushed before processing the\n-  \/\/ initial chunk to allow other workers to steal while we're processing.\n-  if (step._ncreate > 0) {\n-    assert(step._index < array_length, \"invariant\");\n-    assert(((array_length - step._index) % _partial_array_stepper.chunk_size()) == 0,\n-           \"invariant\");\n-    PartialArrayState* state =\n-      _partial_array_state_allocator.allocate(from_obj, to_obj,\n-                                              step._index,\n-                                              array_length,\n-                                              step._ncreate);\n-    for (uint i = 0; i < step._ncreate; ++i) {\n-      push_on_queue(ScannerTask(state));\n-    }\n-  } else {\n-    assert(step._index == array_length, \"invariant\");\n-  }\n+  size_t initial_chunk_size =\n+    \/\/ The source array is unused when processing states.\n+    _partial_array_splitter.start(_task_queue, nullptr, to_array, array_length);\n@@ -299,1 +264,1 @@\n-  to_array->oop_iterate_range(&_scanner, 0, checked_cast<int>(step._index));\n+  to_array->oop_iterate_range(&_scanner, 0, checked_cast<int>(initial_chunk_size));\n@@ -303,1 +268,1 @@\n-void G1ParScanThreadState::dispatch_task(ScannerTask task) {\n+void G1ParScanThreadState::dispatch_task(ScannerTask task, bool stolen) {\n@@ -310,1 +275,1 @@\n-    do_partial_array(task.to_partial_array_state());\n+    do_partial_array(task.to_partial_array_state(), stolen);\n@@ -323,1 +288,1 @@\n-        dispatch_task(task);\n+        dispatch_task(task, false);\n@@ -327,1 +292,1 @@\n-      dispatch_task(task);\n+      dispatch_task(task, false);\n@@ -336,1 +301,1 @@\n-    dispatch_task(stolen_task);\n+    dispatch_task(stolen_task, true);\n@@ -720,0 +685,8 @@\n+#if TASKQUEUE_STATS\n+\n+PartialArrayTaskStats* G1ParScanThreadState::partial_array_task_stats() {\n+  return _partial_array_splitter.stats();\n+}\n+\n+#endif \/\/ TASKQUEUE_STATS\n+\n@@ -747,0 +720,12 @@\n+\n+#if TASKQUEUE_STATS\n+\n+void G1ParScanThreadStateSet::print_partial_array_task_stats() {\n+  auto get_stats = [&](uint i) {\n+    return state_for_worker(i)->partial_array_task_stats();\n+  };\n+  PartialArrayTaskStats::log_set(_num_workers, get_stats,\n+                                 \"Partial Array Task Stats\");\n+}\n+\n+#endif \/\/ TASKQUEUE_STATS\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":45,"deletions":60,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/shared\/partialArraySplitter.hpp\"\n@@ -36,1 +37,0 @@\n-#include \"gc\/shared\/partialArrayTaskStepper.hpp\"\n@@ -87,2 +87,1 @@\n-  PartialArrayStateAllocator _partial_array_state_allocator;\n-  PartialArrayTaskStepper _partial_array_stepper;\n+  PartialArraySplitter _partial_array_splitter;\n@@ -166,0 +165,4 @@\n+#if TASKQUEUE_STATS\n+  PartialArrayTaskStats* partial_array_task_stats();\n+#endif \/\/ TASKQUEUE_STATS\n+\n@@ -167,1 +170,1 @@\n-  void do_partial_array(PartialArrayState* state);\n+  void do_partial_array(PartialArrayState* state, bool stolen);\n@@ -190,1 +193,1 @@\n-  void dispatch_task(ScannerTask task);\n+  void dispatch_task(ScannerTask task, bool stolen);\n@@ -262,0 +265,3 @@\n+#if TASKQUEUE_STATS\n+  void print_partial_array_task_stats();\n+#endif \/\/ TASKQUEUE_STATS\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1016,0 +1016,6 @@\n+#if TASKQUEUE_STATS\n+  \/\/ Logging uses thread states, which are deleted by cleanup, so this must\n+  \/\/ be done before cleanup.\n+  per_thread_states->print_partial_array_task_stats();\n+#endif \/\/ TASKQUEUE_STATS\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/shared\/partialArraySplitter.inline.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"gc\/shared\/partialArrayTaskStepper.inline.hpp\"\n@@ -124,1 +124,1 @@\n-  TASKQUEUE_STATS_ONLY(print_taskqueue_stats());\n+  TASKQUEUE_STATS_ONLY(print_and_reset_taskqueue_stats());\n@@ -148,22 +148,0 @@\n-void\n-PSPromotionManager::print_local_stats(outputStream* const out, uint i) const {\n-  #define FMT \" \" SIZE_FORMAT_W(10)\n-  out->print_cr(\"%3u\" FMT FMT FMT FMT,\n-                i, _array_chunk_pushes, _array_chunk_steals,\n-                _arrays_chunked, _array_chunks_processed);\n-  #undef FMT\n-}\n-\n-static const char* const pm_stats_hdr[] = {\n-  \"    ----partial array----     arrays      array\",\n-  \"thr       push      steal    chunked     chunks\",\n-  \"--- ---------- ---------- ---------- ----------\"\n-};\n-\n-void PSPromotionManager::print_taskqueue_stats() {\n-  if (!log_is_enabled(Trace, gc, task, stats)) {\n-    return;\n-  }\n-  Log(gc, task, stats) log;\n-  ResourceMark rm;\n-  LogStream ls(log.trace());\n@@ -171,1 +149,2 @@\n-  stack_array_depth()->print_taskqueue_stats(&ls, \"Oop Queue\");\n+void PSPromotionManager::print_and_reset_taskqueue_stats() {\n+  stack_array_depth()->print_and_reset_taskqueue_stats(\"Oop Queue\");\n@@ -173,2 +152,5 @@\n-  const uint hlines = sizeof(pm_stats_hdr) \/ sizeof(pm_stats_hdr[0]);\n-  for (uint i = 0; i < hlines; ++i) ls.print_cr(\"%s\", pm_stats_hdr[i]);\n+  auto get_pa_stats = [&](uint i) {\n+    return manager_array(i)->partial_array_task_stats();\n+  };\n+  PartialArrayTaskStats::log_set(ParallelGCThreads, get_pa_stats,\n+                                 \"Partial Array Task Stats\");\n@@ -176,1 +158,1 @@\n-    manager_array(i)->print_local_stats(&ls, i);\n+    get_pa_stats(i)->reset();\n@@ -180,4 +162,2 @@\n-void PSPromotionManager::reset_stats() {\n-  claimed_stack_depth()->stats.reset();\n-  _array_chunk_pushes = _array_chunk_steals = 0;\n-  _arrays_chunked = _array_chunks_processed = 0;\n+PartialArrayTaskStats* PSPromotionManager::partial_array_task_stats() {\n+  return _partial_array_splitter.stats();\n@@ -185,0 +165,1 @@\n+\n@@ -189,2 +170,1 @@\n-  : _partial_array_state_allocator(_partial_array_state_manager),\n-    _partial_array_stepper(ParallelGCThreads, ParGCArrayScanChunk)\n+  : _partial_array_splitter(_partial_array_state_manager, ParallelGCThreads)\n@@ -224,2 +204,0 @@\n-\n-  TASKQUEUE_STATS_ONLY(reset_stats());\n@@ -249,1 +227,1 @@\n-        process_popped_location_depth(task);\n+        process_popped_location_depth(task, false);\n@@ -254,1 +232,1 @@\n-      process_popped_location_depth(task);\n+      process_popped_location_depth(task, false);\n@@ -282,3 +260,2 @@\n-template <class T> void PSPromotionManager::process_array_chunk_work(\n-                                                 oop obj,\n-                                                 int start, int end) {\n+template <class T>\n+void PSPromotionManager::process_array_chunk_work(oop obj, int start, int end) {\n@@ -295,16 +272,7 @@\n-void PSPromotionManager::process_array_chunk(PartialArrayState* state) {\n-  TASKQUEUE_STATS_ONLY(++_array_chunks_processed);\n-\n-  \/\/ Claim a chunk.  Push additional tasks before processing the claimed\n-  \/\/ chunk to allow other workers to steal while we're processing.\n-  PartialArrayTaskStepper::Step step = _partial_array_stepper.next(state);\n-  if (step._ncreate > 0) {\n-    state->add_references(step._ncreate);\n-    for (uint i = 0; i < step._ncreate; ++i) {\n-      push_depth(ScannerTask(state));\n-    }\n-    TASKQUEUE_STATS_ONLY(_array_chunk_pushes += step._ncreate);\n-  }\n-  int start = checked_cast<int>(step._index);\n-  int end = checked_cast<int>(step._index + _partial_array_stepper.chunk_size());\n-  assert(start < end, \"invariant\");\n+void PSPromotionManager::process_array_chunk(PartialArrayState* state, bool stolen) {\n+  \/\/ Access before release by claim().\n+  oop new_obj = state->destination();\n+  PartialArraySplitter::Claim claim =\n+    _partial_array_splitter.claim(state, &_claimed_stack_depth, stolen);\n+  int start = checked_cast<int>(claim._start);\n+  int end = checked_cast<int>(claim._end);\n@@ -312,1 +280,1 @@\n-    process_array_chunk_work<narrowOop>(state->destination(), start, end);\n+    process_array_chunk_work<narrowOop>(new_obj, start, end);\n@@ -314,1 +282,1 @@\n-    process_array_chunk_work<oop>(state->destination(), start, end);\n+    process_array_chunk_work<oop>(new_obj, start, end);\n@@ -316,2 +284,0 @@\n-  \/\/ Release reference to state, now that we're done with it.\n-  _partial_array_state_allocator.release(state);\n@@ -325,15 +291,6 @@\n-  size_t array_length = objArrayOop(new_obj)->length();\n-  PartialArrayTaskStepper::Step step = _partial_array_stepper.start(array_length);\n-\n-  if (step._ncreate > 0) {\n-    TASKQUEUE_STATS_ONLY(++_arrays_chunked);\n-    PartialArrayState* state =\n-      _partial_array_state_allocator.allocate(old_obj, new_obj,\n-                                              step._index,\n-                                              array_length,\n-                                              step._ncreate);\n-    for (uint i = 0; i < step._ncreate; ++i) {\n-      push_depth(ScannerTask(state));\n-    }\n-    TASKQUEUE_STATS_ONLY(_array_chunk_pushes += step._ncreate);\n-  }\n+  objArrayOop to_array = objArrayOop(new_obj);\n+  size_t array_length = to_array->length();\n+  size_t initial_chunk_size =\n+    \/\/ The source array is unused when processing states.\n+    _partial_array_splitter.start(&_claimed_stack_depth, nullptr, to_array, array_length);\n+  int end = checked_cast<int>(initial_chunk_size);\n@@ -341,1 +298,1 @@\n-    process_array_chunk_work<narrowOop>(new_obj, 0, checked_cast<int>(step._index));\n+    process_array_chunk_work<narrowOop>(to_array, 0, end);\n@@ -343,1 +300,1 @@\n-    process_array_chunk_work<oop>(new_obj, 0, checked_cast<int>(step._index));\n+    process_array_chunk_work<oop>(to_array, 0, end);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":35,"deletions":78,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/partialArraySplitter.hpp\"\n@@ -32,1 +33,1 @@\n-#include \"gc\/shared\/partialArrayTaskStepper.hpp\"\n+#include \"gc\/shared\/partialArrayTaskStats.hpp\"\n@@ -70,9 +71,2 @@\n-  size_t                              _array_chunk_pushes;\n-  size_t                              _array_chunk_steals;\n-  size_t                              _arrays_chunked;\n-  size_t                              _array_chunks_processed;\n-\n-  void print_local_stats(outputStream* const out, uint i) const;\n-  static void print_taskqueue_stats();\n-\n-  void reset_stats();\n+  static void print_and_reset_taskqueue_stats();\n+  PartialArrayTaskStats* partial_array_task_stats();\n@@ -91,2 +85,1 @@\n-  PartialArrayStateAllocator          _partial_array_state_allocator;\n-  PartialArrayTaskStepper             _partial_array_stepper;\n+  PartialArraySplitter                _partial_array_splitter;\n@@ -108,1 +101,1 @@\n-  void process_array_chunk(PartialArrayState* state);\n+  void process_array_chunk(PartialArrayState* state, bool stolen);\n@@ -167,1 +160,1 @@\n-  inline void process_popped_location_depth(ScannerTask task);\n+  inline void process_popped_location_depth(ScannerTask task, bool stolen);\n@@ -177,2 +170,0 @@\n-  TASKQUEUE_STATS_ONLY(inline void record_steal(ScannerTask task);)\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":7,"deletions":16,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -334,1 +334,2 @@\n-inline void PSPromotionManager::process_popped_location_depth(ScannerTask task) {\n+inline void PSPromotionManager::process_popped_location_depth(ScannerTask task,\n+                                                              bool stolen) {\n@@ -337,1 +338,1 @@\n-    process_array_chunk(task.to_partial_array_state());\n+    process_array_chunk(task.to_partial_array_state(), stolen);\n@@ -352,8 +353,0 @@\n-#if TASKQUEUE_STATS\n-void PSPromotionManager::record_steal(ScannerTask task) {\n-  if (task.is_partial_array_state()) {\n-    ++_array_chunk_steals;\n-  }\n-}\n-#endif \/\/ TASKQUEUE_STATS\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -131,2 +131,1 @@\n-      TASKQUEUE_STATS_ONLY(pm->record_steal(task));\n-      pm->process_popped_location_depth(task);\n+      pm->process_popped_location_depth(task, true);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"gc\/shared\/partialArraySplitter.hpp\"\n+#include \"gc\/shared\/partialArrayState.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+PartialArraySplitter::PartialArraySplitter(PartialArrayStateManager* manager,\n+                                           uint num_workers)\n+  : _allocator(manager),\n+    _stepper(num_workers, ParGCArrayScanChunk)\n+    TASKQUEUE_STATS_ONLY(COMMA _stats())\n+{}\n+\n+#if TASKQUEUE_STATS\n+PartialArrayTaskStats* PartialArraySplitter::stats() {\n+  return &_stats;\n+}\n+#endif \/\/ TASKQUEUE_STATS\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArraySplitter.cpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_PARTIALARRAYSPLITTER_HPP\n+#define SHARE_GC_SHARED_PARTIALARRAYSPLITTER_HPP\n+\n+#include \"gc\/shared\/partialArrayState.hpp\"\n+#include \"gc\/shared\/partialArrayTaskStats.hpp\"\n+#include \"gc\/shared\/partialArrayTaskStepper.hpp\"\n+#include \"oops\/oop.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class outputStream;\n+\n+\/\/ Helper class for splitting the processing of a large objArray into multiple\n+\/\/ tasks, to permit multiple threads to work on different pieces of the array\n+\/\/ in parallel.\n+class PartialArraySplitter {\n+  PartialArrayStateAllocator _allocator;\n+  PartialArrayTaskStepper _stepper;\n+  TASKQUEUE_STATS_ONLY(PartialArrayTaskStats _stats;)\n+\n+public:\n+  explicit PartialArraySplitter(PartialArrayStateManager* manager,\n+                                uint num_workers);\n+  ~PartialArraySplitter() = default;\n+\n+  NONCOPYABLE(PartialArraySplitter);\n+\n+  \/\/ Setup to process an objArray in chunks.\n+  \/\/\n+  \/\/ from_array is the array found by the collector that needs processing.  It\n+  \/\/ may be null if to_array contains everything needed for processing.\n+  \/\/\n+  \/\/ to_array is an unprocessed (possibly partial) copy of from_array, or null\n+  \/\/ if a copy of from_array is not required.\n+  \/\/\n+  \/\/ length is their length in elements.\n+  \/\/\n+  \/\/ If t is a ScannerTask, queue->push(t) must be a valid expression.  The\n+  \/\/ result of that expression is ignored.\n+  \/\/\n+  \/\/ Returns the size of the initial chunk that is to be processed by the\n+  \/\/ caller.\n+  \/\/\n+  \/\/ Adds PartialArrayState ScannerTasks to the queue if needed to process the\n+  \/\/ array in chunks. This permits other workers to steal and process them\n+  \/\/ even while the caller is processing the initial chunk.  If length doesn't\n+  \/\/ exceed the chunk size then the result will be length, indicating the\n+  \/\/ caller is to process the entire array.  In this case, no tasks will have\n+  \/\/ been added to the queue.\n+  template<typename Queue>\n+  size_t start(Queue* queue,\n+               objArrayOop from_array,\n+               objArrayOop to_array,\n+               size_t length);\n+\n+  \/\/ Result type for claim(), carrying multiple values.  Provides the claimed\n+  \/\/ chunk's start and end array indices.\n+  struct Claim {\n+    size_t _start;\n+    size_t _end;\n+  };\n+\n+  \/\/ Claims a chunk from state, returning the index range for that chunk.  The\n+  \/\/ caller is expected to process that chunk.  Adds more state-based tasks to\n+  \/\/ the queue if needed, permitting other workers to steal and process them\n+  \/\/ even while the caller is processing this claim.\n+  \/\/\n+  \/\/ Releases the state. Callers must not use state after the call to this\n+  \/\/ function. The state may have been recycled and reused.\n+  \/\/\n+  \/\/ The queue has the same requirements as for start().\n+  \/\/\n+  \/\/ stolen indicates whether the state task was obtained from this queue or\n+  \/\/ stolen from some other queue.\n+  template<typename Queue>\n+  Claim claim(PartialArrayState* state, Queue* queue, bool stolen);\n+\n+  TASKQUEUE_STATS_ONLY(PartialArrayTaskStats* stats();)\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_PARTIALARRAYSPLITTER_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArraySplitter.hpp","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_PARTIALARRAYSPLITTER_INLINE_HPP\n+#define SHARE_GC_SHARED_PARTIALARRAYSPLITTER_INLINE_HPP\n+\n+#include \"gc\/shared\/partialArraySplitter.hpp\"\n+\n+#include \"gc\/shared\/partialArrayTaskStats.hpp\"\n+#include \"gc\/shared\/partialArrayTaskStepper.inline.hpp\"\n+#include \"gc\/shared\/taskqueue.inline.hpp\"\n+#include \"oops\/oop.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+template<typename Queue>\n+size_t PartialArraySplitter::start(Queue* queue,\n+                                   objArrayOop source,\n+                                   objArrayOop destination,\n+                                   size_t length) {\n+  PartialArrayTaskStepper::Step step = _stepper.start(length);\n+  \/\/ Push initial partial scan tasks.\n+  if (step._ncreate > 0) {\n+    TASKQUEUE_STATS_ONLY(_stats.inc_split(););\n+    TASKQUEUE_STATS_ONLY(_stats.inc_pushed(step._ncreate);)\n+    PartialArrayState* state =\n+      _allocator.allocate(source, destination, step._index, length, step._ncreate);\n+    for (uint i = 0; i < step._ncreate; ++i) {\n+      queue->push(ScannerTask(state));\n+    }\n+  } else {\n+    assert(step._index == length, \"invariant\");\n+  }\n+  return step._index;\n+}\n+\n+template<typename Queue>\n+PartialArraySplitter::Claim\n+PartialArraySplitter::claim(PartialArrayState* state, Queue* queue, bool stolen) {\n+#if TASKQUEUE_STATS\n+  if (stolen) _stats.inc_stolen();\n+  _stats.inc_processed();\n+#endif \/\/ TASKQUEUE_STATS\n+\n+  \/\/ Claim a chunk and get number of additional tasks to enqueue.\n+  PartialArrayTaskStepper::Step step = _stepper.next(state);\n+  \/\/ Push additional tasks.\n+  if (step._ncreate > 0) {\n+    TASKQUEUE_STATS_ONLY(_stats.inc_pushed(step._ncreate);)\n+    \/\/ Adjust reference count for tasks being added to the queue.\n+    state->add_references(step._ncreate);\n+    for (uint i = 0; i < step._ncreate; ++i) {\n+      queue->push(ScannerTask(state));\n+    }\n+  }\n+  \/\/ Release state, decrementing refcount, now that we're done with it.\n+  _allocator.release(state);\n+  return Claim{step._index, step._index + _stepper.chunk_size()};\n+}\n+\n+#endif \/\/ SHARE_GC_SHARED_PARTIALARRAYSPLITTER_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArraySplitter.inline.hpp","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/partialArrayTaskStats.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logHandle.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+#if TASKQUEUE_STATS\n+\n+PartialArrayTaskStats::PartialArrayTaskStats()\n+  : _split(0), _pushed(0), _stolen(0), _processed(0)\n+{}\n+\n+void PartialArrayTaskStats::accumulate(const PartialArrayTaskStats& stats) {\n+  _split += stats._split;\n+  _pushed += stats._pushed;\n+  _stolen += stats._stolen;\n+  _processed += stats._processed;\n+}\n+\n+void PartialArrayTaskStats::reset() {\n+  *this = PartialArrayTaskStats();\n+}\n+\n+LogTargetHandle PartialArrayTaskStats::log_target() {\n+  LogTarget(Trace, gc, task, stats) lt;\n+  return LogTargetHandle(lt);\n+}\n+\n+bool PartialArrayTaskStats::is_log_enabled() {\n+  return log_target().is_enabled();\n+}\n+\n+static const char* const stats_hdr[] = {\n+  \"     ----partial array----      arrays      array\",\n+  \"thread       push      steal    chunked     chunks\",\n+  \"------ ---------- ---------- ---------- ----------\"\n+};\n+\n+void PartialArrayTaskStats::print_header(outputStream* s, const char* title) {\n+  s->print_cr(\"%s:\", title);\n+  for (uint i = 0; i < ARRAY_SIZE(stats_hdr); ++i) {\n+    s->print_cr(\"%s\", stats_hdr[i]);\n+  }\n+}\n+\n+void PartialArrayTaskStats::print_values_impl(outputStream* s) const {\n+  \/\/ 10 digits for each counter, matching the segments in stats_hdr.\n+  s->print_cr(\" %10zu %10zu %10zu %10zu\",\n+              _pushed, _stolen, _split, _processed);\n+}\n+\n+void PartialArrayTaskStats::print_values(outputStream* s, uint id) const {\n+  \/\/ 6 digits for thread number, matching the segement in stats_hdr.\n+  s->print(\"%6u\", id);\n+  print_values_impl(s);\n+}\n+\n+void PartialArrayTaskStats::print_total(outputStream* s) const {\n+  \/\/ 6 characters for \"total\" id, matching the segment in stats_hdr.\n+  s->print(\"%6s\", \"total\");\n+  print_values_impl(s);\n+}\n+\n+#endif \/\/ TASKQUEUE_STATS\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayTaskStats.cpp","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_PARTIALARRAYTASKSTATS_HPP\n+#define SHARE_GC_SHARED_PARTIALARRAYTASKSTATS_HPP\n+\n+#include \"logging\/logHandle.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+#if TASKQUEUE_STATS\n+\n+class outputStream;\n+\n+\/\/ Repository for collecting and reporting statistics about partial array task\n+\/\/ processing.  Not thread-safe; each processing thread should have its own\n+\/\/ stats object.\n+class PartialArrayTaskStats {\n+  size_t _split;\n+  size_t _pushed;\n+  size_t _stolen;\n+  size_t _processed;\n+\n+  static LogTargetHandle log_target();\n+  static bool is_log_enabled();\n+  static void print_header(outputStream* s, const char* title);\n+  void print_values(outputStream* s, uint id) const;\n+  void print_total(outputStream* s) const;\n+  void print_values_impl(outputStream* s) const;\n+\n+  void accumulate(const PartialArrayTaskStats& stats);\n+\n+public:\n+  \/\/ All counters are initially zero.\n+  PartialArrayTaskStats();\n+\n+  \/\/ Trivially copied and destroyed.\n+\n+  \/\/ Number of arrays split into partial array tasks.\n+  size_t split() const { return _split; }\n+\n+  \/\/ Number of partial array tasks pushed onto a queue.\n+  size_t pushed() const { return _pushed; }\n+\n+  \/\/ Number of partial array tasks stolen from some other queue.\n+  size_t stolen() const { return _stolen; }\n+\n+  \/\/ Number of partial array tasks processed.\n+  size_t processed() const { return _processed; }\n+\n+  void inc_split(size_t n = 1) { _split += n; }\n+  void inc_pushed(size_t n = 1) { _pushed += n; }\n+  void inc_stolen(size_t n = 1) { _stolen += n; }\n+  void inc_processed(size_t n = 1) { _processed += n; }\n+\n+  \/\/ Set all counters to zero.\n+  void reset();\n+\n+  \/\/ Log a table of statistics, if logging is enabled (gc+task+stats=trace).\n+  \/\/\n+  \/\/ num_stats: The number of stats objects to include in the table, one row\n+  \/\/ for each.\n+  \/\/\n+  \/\/ access: A function taking a uint value < num_stats, and returning a\n+  \/\/ pointer to the corresponding stats object.\n+  \/\/\n+  \/\/ title: A string title for the table.\n+  template<typename StatsAccess>\n+  static void log_set(uint num_stats, StatsAccess access, const char* title);\n+};\n+\n+template<typename StatsAccess>\n+void PartialArrayTaskStats::log_set(uint num_stats,\n+                                    StatsAccess access,\n+                                    const char* title) {\n+  if (is_log_enabled()) {\n+    LogStream ls(log_target());\n+    PartialArrayTaskStats total;\n+    print_header(&ls, title);\n+    for (uint i = 0; i < num_stats; ++i) {\n+      const PartialArrayTaskStats* stats = access(i);\n+      stats->print_values(&ls, i);\n+      total.accumulate(*stats);\n+    }\n+    total.print_total(&ls);\n+  }\n+}\n+\n+#endif \/\/ TASKQUEUE_STATS\n+\n+#endif \/\/ SHARE_GC_SHARED_PARTIALARRAYTASKSTATS_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayTaskStats.hpp","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -361,0 +361,15 @@\n+\/\/ Enable collection of TaskQueue statistics.\n+\/\/ Enabled by default in debug builds.  Otherwise, disabled by default.\n+#ifndef TASKQUEUE_STATS\n+#ifdef ASSERT\n+#define TASKQUEUE_STATS 1\n+#else\n+#define TASKQUEUE_STATS 0\n+#endif \/\/ ASSERT\n+#endif \/\/ TASKQUEUE_STATS\n+#if TASKQUEUE_STATS\n+#define TASKQUEUE_STATS_ONLY(code) code\n+#else\n+#define TASKQUEUE_STATS_ONLY(code)\n+#endif \/\/ TASKQUEUE_STATS\n+\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"}]}