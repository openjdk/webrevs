{"files":[{"patch":"@@ -229,1 +229,1 @@\n-  \/\/ Access state before release by step.\n+  \/\/ Access state before release by claim().\n@@ -231,2 +231,2 @@\n-  PartialArraySplitter::Step step =\n-    _partial_array_splitter.step(state, _task_queue, stolen);\n+  PartialArraySplitter::Claim claim =\n+    _partial_array_splitter.claim(state, _task_queue, stolen);\n@@ -237,2 +237,2 @@\n-                              checked_cast<int>(step._start),\n-                              checked_cast<int>(step._end));\n+                              checked_cast<int>(claim._start),\n+                              checked_cast<int>(claim._end));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -273,1 +273,1 @@\n-  \/\/ Access before release by step.\n+  \/\/ Access before release by claim().\n@@ -275,4 +275,4 @@\n-  PartialArraySplitter::Step step =\n-    _partial_array_splitter.step(state, &_claimed_stack_depth, stolen);\n-  int start = checked_cast<int>(step._start);\n-  int end = checked_cast<int>(step._end);\n+  PartialArraySplitter::Claim claim =\n+    _partial_array_splitter.claim(state, &_claimed_stack_depth, stolen);\n+  int start = checked_cast<int>(claim._start);\n+  int end = checked_cast<int>(claim._end);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -69,3 +69,5 @@\n-  \/\/ array in chunks. If length doesn't exceed the chunk size then the result\n-  \/\/ will be length, indicating the caller is to process the entire array.  In\n-  \/\/ this case, no tasks will have been added to the queue.\n+  \/\/ array in chunks. This permits other workers to steal and process them\n+  \/\/ even while the caller is processing the initial chunk.  If length doesn't\n+  \/\/ exceed the chunk size then the result will be length, indicating the\n+  \/\/ caller is to process the entire array.  In this case, no tasks will have\n+  \/\/ been added to the queue.\n@@ -78,3 +80,3 @@\n-  \/\/ Result type for the step function, carrying multiple values.\n-  \/\/ Provides the claimed chunk's start and end array indices.\n-  struct Step {\n+  \/\/ Result type for claim(), carrying multiple values.  Provides the claimed\n+  \/\/ chunk's start and end array indices.\n+  struct Claim {\n@@ -87,1 +89,2 @@\n-  \/\/ the queue if needed.\n+  \/\/ the queue if needed, permitting other workers to steal and process them\n+  \/\/ even while the caller is processing this claim.\n@@ -97,1 +100,1 @@\n-  Step step(PartialArrayState* state, Queue* queue, bool stolen);\n+  Claim claim(PartialArrayState* state, Queue* queue, bool stolen);\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArraySplitter.hpp","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -44,2 +44,1 @@\n-  \/\/ Push any needed partial scan tasks.  Pushed before processing the initial\n-  \/\/ chunk to allow other workers to steal while we're processing.\n+  \/\/ Push initial partial scan tasks.\n@@ -61,2 +60,2 @@\n-PartialArraySplitter::Step\n-PartialArraySplitter::step(PartialArrayState* state, Queue* queue, bool stolen) {\n+PartialArraySplitter::Claim\n+PartialArraySplitter::claim(PartialArrayState* state, Queue* queue, bool stolen) {\n@@ -70,2 +69,1 @@\n-  \/\/ Push additional tasks before processing chunk, to allow other workers to\n-  \/\/ steal some of those tasks while we processing the chunk.\n+  \/\/ Push additional tasks.\n@@ -82,1 +80,1 @@\n-  return Step{step._index, step._index + _stepper.chunk_size()};\n+  return Claim{step._index, step._index + _stepper.chunk_size()};\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArraySplitter.inline.hpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"}]}