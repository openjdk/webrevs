{"files":[{"patch":"@@ -99,0 +99,4 @@\n+\/\/ sys\/mman.h defines MAP_ANON_64K beginning with AIX7.3 TL1\n+#ifndef MAP_ANON_64K\n+#define MAP_ANON_64K  0x400\n+#endif\n@@ -227,0 +231,1 @@\n+  bool can_use_64K_mmap_pages;\/\/ True if we can alloc 64K pages dynamically with mmap.\n@@ -234,1 +239,1 @@\n-  false, false,\n+  false, false, false,\n@@ -367,6 +372,10 @@\n-    guarantee(shmid != -1, \"shmget failed\");\n-    void* p = ::shmat(shmid, nullptr, 0);\n-    ::shmctl(shmid, IPC_RMID, nullptr);\n-    guarantee(p != (void*) -1, \"shmat failed\");\n-    g_multipage_support.shmpsize = os::Aix::query_pagesize(p);\n-    ::shmdt(p);\n+    assert(shmid != -1, \"shmget failed\");\n+    if (shmid != -1) {\n+      void* p = ::shmat(shmid, nullptr, 0);\n+      ::shmctl(shmid, IPC_RMID, nullptr);\n+      assert(p != (void*) -1, \"shmat failed\");\n+      if (p != (void*) -1) {\n+        g_multipage_support.shmpsize = os::Aix::query_pagesize(p);\n+        ::shmdt(p);\n+      }\n+    }\n@@ -422,16 +431,9 @@\n-      guarantee0(shmid != -1); \/\/ Should always work.\n-      \/\/ Try to set pagesize.\n-      struct shmid_ds shm_buf = { };\n-      shm_buf.shm_pagesize = pagesize;\n-      if (::shmctl(shmid, SHM_PAGESIZE, &shm_buf) != 0) {\n-        const int en = errno;\n-        ::shmctl(shmid, IPC_RMID, nullptr); \/\/ As early as possible!\n-        log_warning(pagesize)(\"shmctl(SHM_PAGESIZE) failed with errno=%d\", errno);\n-      } else {\n-        \/\/ Attach and double check pageisze.\n-        void* p = ::shmat(shmid, nullptr, 0);\n-        ::shmctl(shmid, IPC_RMID, nullptr); \/\/ As early as possible!\n-        guarantee0(p != (void*) -1); \/\/ Should always work.\n-        const size_t real_pagesize = os::Aix::query_pagesize(p);\n-        if (real_pagesize != pagesize) {\n-          log_warning(pagesize)(\"real page size (\" SIZE_FORMAT_X \") differs.\", real_pagesize);\n+      assert(shmid != -1, \"shmget failed\");\n+      if (shmid != -1) {\n+        \/\/ Try to set pagesize.\n+        struct shmid_ds shm_buf = { };\n+        shm_buf.shm_pagesize = pagesize;\n+        if (::shmctl(shmid, SHM_PAGESIZE, &shm_buf) != 0) {\n+          const int en = errno;\n+          ::shmctl(shmid, IPC_RMID, nullptr); \/\/ As early as possible!\n+          log_warning(pagesize)(\"shmctl(SHM_PAGESIZE) failed with errno=%d\", errno);\n@@ -439,1 +441,13 @@\n-          can_use = true;\n+          \/\/ Attach and double check pageisze.\n+          void* p = ::shmat(shmid, nullptr, 0);\n+          ::shmctl(shmid, IPC_RMID, nullptr); \/\/ As early as possible!\n+          assert(p != (void*) -1, \"shmat failed\");\n+          if (p != (void*) -1) {\n+            const size_t real_pagesize = os::Aix::query_pagesize(p);\n+            if (real_pagesize != pagesize) {\n+              log_warning(pagesize)(\"real page size (\" SIZE_FORMAT_X \") differs.\", real_pagesize);\n+            } else {\n+              can_use = true;\n+            }\n+            ::shmdt(p);\n+          }\n@@ -441,1 +455,0 @@\n-        ::shmdt(p);\n@@ -451,0 +464,10 @@\n+    \/\/ Can we use mmap with 64K pages? (Should be available with AIX7.3 TL1)\n+    {\n+      void* p = mmap(NULL, 64*K, PROT_READ | PROT_WRITE, MAP_ANON_64K | MAP_ANONYMOUS | MAP_SHARED, -1, 0);\n+      assert(p != (void*) -1, \"mmap failed\");\n+      if (p != (void*) -1) {\n+        g_multipage_support.can_use_64K_mmap_pages = (64*K == os::Aix::query_pagesize(p));\n+        munmap(p, 64*K);\n+      }\n+    }\n+\n@@ -463,0 +486,2 @@\n+  trcVerbose(\"Can use 64K pages with mmap memory: %s\",\n+      (g_multipage_support.can_use_64K_mmap_pages ? \"yes\" :\"no\"));\n@@ -1134,0 +1159,2 @@\n+  st->print_cr(\"  Can use 64K pages with mmap memory:     %s\",\n+    (g_multipage_support.can_use_64K_mmap_pages ? \"yes\" :\"no\"));\n@@ -1613,0 +1640,4 @@\n+  if (os::vm_page_size() == 64*K && g_multipage_support.can_use_64K_mmap_pages) {\n+    flags |= MAP_ANON_64K;\n+  }\n+\n@@ -1662,1 +1693,5 @@\n-  vmembk_add(addr, size, 4*K, VMEM_MAPPED);\n+  if (os::vm_page_size() == 64*K && g_multipage_support.can_use_64K_mmap_pages) {\n+    vmembk_add(addr, size, 64*K, VMEM_MAPPED);\n+  } else {\n+    vmembk_add(addr, size, 4*K, VMEM_MAPPED);\n+  }\n@@ -1855,2 +1890,2 @@\n-  \/\/ In 64K mode allocate small sizes with mmap, large ones with 64K shmatted.\n-  if (os::vm_page_size() == 4*K) {\n+  \/\/ In 64K mode allocate with mmap if it supports 64K pages, otherwise use 64K shmatted.\n+  if (os::vm_page_size() == 4*K || g_multipage_support.can_use_64K_mmap_pages) {\n@@ -2043,2 +2078,2 @@\n-  \/\/ In 64K mode allocate small sizes with mmap, large ones with 64K shmatted.\n-  if (os::vm_page_size() == 4*K) {\n+  \/\/ In 64K mode allocate with mmap if it supports 64K pages, otherwise use 64K shmatted.\n+  if (os::vm_page_size() == 4*K || g_multipage_support.can_use_64K_mmap_pages) {\n@@ -2184,3 +2219,3 @@\n-  \/\/ LDR_CNTRL    can_use_64K_pages_dynamically       what we do                      remarks\n-  \/\/ 4K           no                                  4K                              old systems (aix 5.2) or new systems with AME activated\n-  \/\/ 4k           yes                                 64k (treat 4k stacks as 64k)    different loader than java and standard settings\n+  \/\/ LDR_CNTRL    can_use_64K_pages_dynamically(mmap or shm)       what we do                      remarks\n+  \/\/ 4K           no                                               4K                              old systems (aix 5.2) or new systems with AME activated\n+  \/\/ 4k           yes                                              64k (treat 4k stacks as 64k)    different loader than java and standardsettings\n@@ -2188,1 +2223,1 @@\n-  \/\/ 64k          yes                                 64k                             new systems and standard java loader (we set datapsize=64k when linking)\n+  \/\/ 64k          yes                                              64k                             new systems and standard java loader (we set datapsize=64k when linking)\n@@ -2195,1 +2230,1 @@\n-    if (g_multipage_support.can_use_64K_pages) {\n+    if (g_multipage_support.can_use_64K_pages || g_multipage_support.can_use_64K_mmap_pages) {\n@@ -2225,1 +2260,1 @@\n-    assert0(g_multipage_support.can_use_64K_pages);\n+    assert0(g_multipage_support.can_use_64K_pages || g_multipage_support.can_use_64K_mmap_pages);\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":71,"deletions":36,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -957,12 +957,0 @@\n-#ifdef AIX\n-\/\/ On Aix, we should fail attach attempts not aligned to segment boundaries (256m)\n-TEST_VM(os, aix_reserve_at_non_shmlba_aligned_address) {\n-  if (Use64KPages) {\n-    char* p = os::attempt_reserve_memory_at((char*)0x1f00000, M);\n-    ASSERT_EQ(p, nullptr); \/\/ should have failed\n-    p = os::attempt_reserve_memory_at((char*)((64 * G) + M), M);\n-    ASSERT_EQ(p, nullptr); \/\/ should have failed\n-  }\n-}\n-#endif \/\/ AIX\n-\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#ifdef AIX\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"nmt\/memTracker.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"runtime\/threads.hpp\"\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"unittest.hpp\"\n+# include <sys\/mman.h>\n+\/\/ sys\/mman.h defines MAP_ANON_64K beginning with AIX7.3 TL1\n+# ifndef MAP_ANON_64K\n+# define MAP_ANON_64K  0x400\n+# endif\n+\n+\/\/ On Aix, when using shmget() in os::attempt_reserve_memory_at() we should fail with attach\n+\/\/ attempts not aligned to shmget() segment boundaries (256m)\n+\/\/ But shmget() is only used in cases we want to have 64K pages and mmap() does not provide it.\n+TEST_VM(os_aix, aix_reserve_at_non_shmlba_aligned_address) {\n+  \/\/ Can we use mmap with 64K pages? (Should be available with AIX 7.3 TL1)\n+  void* p = mmap(NULL, 1000000, PROT_READ | PROT_WRITE, MAP_ANON_64K | MAP_ANONYMOUS | MAP_SHARED, -1, 0);\n+  guarantee(p != (void*) -1, \"mmap returned invalid ptr.\"); \/\/ Should always work.\n+  bool can_use_64K_mmap_pages = (64*K == os::Aix::query_pagesize(p));\n+  munmap(p, 1000000);\n+\n+  if (os::vm_page_size() != 4*K && !can_use_64K_mmap_pages) {\n+    \/\/ With this condition true shmget() is used inside\n+    char* p = os::attempt_reserve_memory_at((char*)0x1f00000, M);\n+    ASSERT_EQ(p, nullptr); \/\/ should have failed\n+    p = os::attempt_reserve_memory_at((char*)((64 * G) + M), M);\n+    ASSERT_EQ(p, nullptr); \/\/ should have failed\n+  }\n+}\n+\n+#endif \/\/ AIX\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_aix.cpp","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"}]}