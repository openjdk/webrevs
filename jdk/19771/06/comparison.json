{"files":[{"patch":"@@ -72,0 +72,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -99,0 +100,6 @@\n+\/\/ sys\/mman.h defines MAP_ANON_64K beginning with AIX7.3 TL1\n+#ifndef MAP_ANON_64K\n+  #define MAP_ANON_64K 0x400\n+#else\n+  STATIC_ASSERT(MAP_ANON_64K == 0x400);\n+#endif\n@@ -220,8 +227,9 @@\n-  size_t pagesize;            \/\/ sysconf _SC_PAGESIZE (4K)\n-  size_t datapsize;           \/\/ default data page size (LDR_CNTRL DATAPSIZE)\n-  size_t shmpsize;            \/\/ default shared memory page size (LDR_CNTRL SHMPSIZE)\n-  size_t pthr_stack_pagesize; \/\/ stack page size of pthread threads\n-  size_t textpsize;           \/\/ default text page size (LDR_CNTRL STACKPSIZE)\n-  bool can_use_64K_pages;     \/\/ True if we can alloc 64K pages dynamically with Sys V shm.\n-  bool can_use_16M_pages;     \/\/ True if we can alloc 16M pages dynamically with Sys V shm.\n-  int error;                  \/\/ Error describing if something went wrong at multipage init.\n+  size_t pagesize;             \/\/ sysconf _SC_PAGESIZE (4K)\n+  size_t datapsize;            \/\/ default data page size (LDR_CNTRL DATAPSIZE)\n+  size_t shmpsize;             \/\/ default shared memory page size (LDR_CNTRL SHMPSIZE)\n+  size_t pthr_stack_pagesize;  \/\/ stack page size of pthread threads\n+  size_t textpsize;            \/\/ default text page size (LDR_CNTRL STACKPSIZE)\n+  bool can_use_64K_pages;      \/\/ True if we can alloc 64K pages dynamically with Sys V shm.\n+  bool can_use_16M_pages;      \/\/ True if we can alloc 16M pages dynamically with Sys V shm.\n+  bool can_use_64K_mmap_pages; \/\/ True if we can alloc 64K pages dynamically with mmap.\n+  int error;                   \/\/ Error describing if something went wrong at multipage init.\n@@ -234,1 +242,1 @@\n-  false, false,\n+  false, false, false,\n@@ -367,6 +375,10 @@\n-    guarantee(shmid != -1, \"shmget failed\");\n-    void* p = ::shmat(shmid, nullptr, 0);\n-    ::shmctl(shmid, IPC_RMID, nullptr);\n-    guarantee(p != (void*) -1, \"shmat failed\");\n-    g_multipage_support.shmpsize = os::Aix::query_pagesize(p);\n-    ::shmdt(p);\n+    assert(shmid != -1, \"shmget failed\");\n+    if (shmid != -1) {\n+      void* p = ::shmat(shmid, nullptr, 0);\n+      ::shmctl(shmid, IPC_RMID, nullptr);\n+      assert(p != (void*) -1, \"shmat failed\");\n+      if (p != (void*) -1) {\n+        g_multipage_support.shmpsize = os::Aix::query_pagesize(p);\n+        ::shmdt(p);\n+      }\n+    }\n@@ -422,16 +434,9 @@\n-      guarantee0(shmid != -1); \/\/ Should always work.\n-      \/\/ Try to set pagesize.\n-      struct shmid_ds shm_buf = { };\n-      shm_buf.shm_pagesize = pagesize;\n-      if (::shmctl(shmid, SHM_PAGESIZE, &shm_buf) != 0) {\n-        const int en = errno;\n-        ::shmctl(shmid, IPC_RMID, nullptr); \/\/ As early as possible!\n-        log_warning(pagesize)(\"shmctl(SHM_PAGESIZE) failed with errno=%d\", errno);\n-      } else {\n-        \/\/ Attach and double check pageisze.\n-        void* p = ::shmat(shmid, nullptr, 0);\n-        ::shmctl(shmid, IPC_RMID, nullptr); \/\/ As early as possible!\n-        guarantee0(p != (void*) -1); \/\/ Should always work.\n-        const size_t real_pagesize = os::Aix::query_pagesize(p);\n-        if (real_pagesize != pagesize) {\n-          log_warning(pagesize)(\"real page size (\" SIZE_FORMAT_X \") differs.\", real_pagesize);\n+      assert(shmid != -1, \"shmget failed\");\n+      if (shmid != -1) {\n+        \/\/ Try to set pagesize.\n+        struct shmid_ds shm_buf = { };\n+        shm_buf.shm_pagesize = pagesize;\n+        if (::shmctl(shmid, SHM_PAGESIZE, &shm_buf) != 0) {\n+          const int en = errno;\n+          ::shmctl(shmid, IPC_RMID, nullptr); \/\/ As early as possible!\n+          log_warning(pagesize)(\"shmctl(SHM_PAGESIZE) failed with errno=%d\", errno);\n@@ -439,1 +444,13 @@\n-          can_use = true;\n+          \/\/ Attach and double check pageisze.\n+          void* p = ::shmat(shmid, nullptr, 0);\n+          ::shmctl(shmid, IPC_RMID, nullptr); \/\/ As early as possible!\n+          assert(p != (void*) -1, \"shmat failed\");\n+          if (p != (void*) -1) {\n+            const size_t real_pagesize = os::Aix::query_pagesize(p);\n+            if (real_pagesize != pagesize) {\n+              log_warning(pagesize)(\"real page size (\" SIZE_FORMAT_X \") differs.\", real_pagesize);\n+            } else {\n+              can_use = true;\n+            }\n+            ::shmdt(p);\n+          }\n@@ -441,1 +458,0 @@\n-        ::shmdt(p);\n@@ -451,0 +467,10 @@\n+    \/\/ Can we use mmap with 64K pages? (Should be available with AIX7.3 TL1)\n+    {\n+      void* p = mmap(NULL, 64*K, PROT_READ | PROT_WRITE, MAP_ANON_64K | MAP_ANONYMOUS | MAP_SHARED, -1, 0);\n+      assert(p != (void*) -1, \"mmap failed\");\n+      if (p != (void*) -1) {\n+        g_multipage_support.can_use_64K_mmap_pages = (64*K == os::Aix::query_pagesize(p));\n+        munmap(p, 64*K);\n+      }\n+    }\n+\n@@ -463,0 +489,2 @@\n+  trcVerbose(\"Can use 64K pages with mmap memory: %s\",\n+      (g_multipage_support.can_use_64K_mmap_pages ? \"yes\" :\"no\"));\n@@ -1134,0 +1162,2 @@\n+  st->print_cr(\"  Can use 64K pages with mmap memory:     %s\",\n+    (g_multipage_support.can_use_64K_mmap_pages ? \"yes\" :\"no\"));\n@@ -1613,0 +1643,4 @@\n+  if (os::vm_page_size() == 64*K && g_multipage_support.can_use_64K_mmap_pages) {\n+    flags |= MAP_ANON_64K;\n+  }\n+\n@@ -1662,1 +1696,5 @@\n-  vmembk_add(addr, size, 4*K, VMEM_MAPPED);\n+  if (os::vm_page_size() == 64*K && g_multipage_support.can_use_64K_mmap_pages) {\n+    vmembk_add(addr, size, 64*K, VMEM_MAPPED);\n+  } else {\n+    vmembk_add(addr, size, 4*K, VMEM_MAPPED);\n+  }\n@@ -1855,2 +1893,2 @@\n-  \/\/ In 64K mode allocate small sizes with mmap, large ones with 64K shmatted.\n-  if (os::vm_page_size() == 4*K) {\n+  \/\/ In 64K mode allocate with mmap if it supports 64K pages, otherwise use 64K shmatted.\n+  if (os::vm_page_size() == 4*K || g_multipage_support.can_use_64K_mmap_pages) {\n@@ -2043,2 +2081,2 @@\n-  \/\/ In 64K mode allocate small sizes with mmap, large ones with 64K shmatted.\n-  if (os::vm_page_size() == 4*K) {\n+  \/\/ In 64K mode allocate with mmap if it supports 64K pages, otherwise use 64K shmatted.\n+  if (os::vm_page_size() == 4*K || g_multipage_support.can_use_64K_mmap_pages) {\n@@ -2184,3 +2222,3 @@\n-  \/\/ LDR_CNTRL    can_use_64K_pages_dynamically       what we do                      remarks\n-  \/\/ 4K           no                                  4K                              old systems (aix 5.2) or new systems with AME activated\n-  \/\/ 4k           yes                                 64k (treat 4k stacks as 64k)    different loader than java and standard settings\n+  \/\/ LDR_CNTRL    can_use_64K_pages_dynamically(mmap or shm)       what we do                      remarks\n+  \/\/ 4K           no                                               4K                              old systems (aix 5.2) or new systems with AME activated\n+  \/\/ 4k           yes                                              64k (treat 4k stacks as 64k)    different loader than java and standard settings\n@@ -2188,1 +2226,1 @@\n-  \/\/ 64k          yes                                 64k                             new systems and standard java loader (we set datapsize=64k when linking)\n+  \/\/ 64k          yes                                              64k                             new systems and standard java loader (we set datapsize=64k when linking)\n@@ -2195,1 +2233,1 @@\n-    if (g_multipage_support.can_use_64K_pages) {\n+    if (g_multipage_support.can_use_64K_pages || g_multipage_support.can_use_64K_mmap_pages) {\n@@ -2225,1 +2263,1 @@\n-    assert0(g_multipage_support.can_use_64K_pages);\n+    assert0(g_multipage_support.can_use_64K_pages || g_multipage_support.can_use_64K_mmap_pages);\n@@ -2710,0 +2748,4 @@\n+bool os::Aix::supports_64K_mmap_pages() {\n+  return g_multipage_support.can_use_64K_mmap_pages;\n+}\n+\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":86,"deletions":44,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+  static bool supports_64K_mmap_pages();\n","filename":"src\/hotspot\/os\/aix\/os_aix.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -383,1 +383,1 @@\n-        AIX_ONLY(&& os::vm_page_size() != 64*K)) {\n+        AIX_ONLY(&& (os::Aix::supports_64K_mmap_pages() || os::vm_page_size() == 4*K))) {\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1927,2 +1927,1 @@\n-    AIX_ONLY(os::vm_page_size() == 4*K ? 4*K : 256*M)\n-    NOT_AIX(os::vm_allocation_granularity());\n+    AIX_ONLY((!os::Aix::supports_64K_mmap_pages() && os::vm_page_size() == 64*K) ? 256*M : ) os::vm_allocation_granularity();\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -957,12 +957,0 @@\n-#ifdef AIX\n-\/\/ On Aix, we should fail attach attempts not aligned to segment boundaries (256m)\n-TEST_VM(os, aix_reserve_at_non_shmlba_aligned_address) {\n-  if (Use64KPages) {\n-    char* p = os::attempt_reserve_memory_at((char*)0x1f00000, M);\n-    ASSERT_EQ(p, nullptr); \/\/ should have failed\n-    p = os::attempt_reserve_memory_at((char*)((64 * G) + M), M);\n-    ASSERT_EQ(p, nullptr); \/\/ should have failed\n-  }\n-}\n-#endif \/\/ AIX\n-\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#ifdef AIX\n+\n+#include \"runtime\/os.inline.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"unittest.hpp\"\n+\n+\/\/ On Aix, when using shmget() in os::attempt_reserve_memory_at() we should fail with attach\n+\/\/ attempts not aligned to shmget() segment boundaries (256m)\n+\/\/ But shmget() is only used in cases we want to have 64K pages and mmap() does not provide it.\n+TEST_VM(os_aix, aix_reserve_at_non_shmlba_aligned_address) {\n+  if (os::vm_page_size() != 4*K && !os::Aix::supports_64K_mmap_pages()) {\n+    \/\/ With this condition true shmget() is used inside\n+    char* p = os::attempt_reserve_memory_at((char*)0x1f00000, M);\n+    ASSERT_EQ(p, nullptr); \/\/ should have failed\n+    p = os::attempt_reserve_memory_at((char*)((64 * G) + M), M);\n+    ASSERT_EQ(p, nullptr); \/\/ should have failed\n+  }\n+}\n+\n+#endif \/\/ AIX\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_aix.cpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"}]}