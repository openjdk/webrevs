{"files":[{"patch":"@@ -372,6 +372,10 @@\n-    guarantee(shmid != -1, \"shmget failed\");\n-    void* p = ::shmat(shmid, nullptr, 0);\n-    ::shmctl(shmid, IPC_RMID, nullptr);\n-    guarantee(p != (void*) -1, \"shmat failed\");\n-    g_multipage_support.shmpsize = os::Aix::query_pagesize(p);\n-    ::shmdt(p);\n+    assert(shmid != -1, \"shmget failed\");\n+    if (shmid != -1) {\n+      void* p = ::shmat(shmid, nullptr, 0);\n+      ::shmctl(shmid, IPC_RMID, nullptr);\n+      assert(p != (void*) -1, \"shmat failed\");\n+      if (p != (void*) -1) {\n+        g_multipage_support.shmpsize = os::Aix::query_pagesize(p);\n+        ::shmdt(p);\n+      }\n+    }\n@@ -427,16 +431,9 @@\n-      guarantee0(shmid != -1); \/\/ Should always work.\n-      \/\/ Try to set pagesize.\n-      struct shmid_ds shm_buf = { };\n-      shm_buf.shm_pagesize = pagesize;\n-      if (::shmctl(shmid, SHM_PAGESIZE, &shm_buf) != 0) {\n-        const int en = errno;\n-        ::shmctl(shmid, IPC_RMID, nullptr); \/\/ As early as possible!\n-        log_warning(pagesize)(\"shmctl(SHM_PAGESIZE) failed with errno=%d\", errno);\n-      } else {\n-        \/\/ Attach and double check pageisze.\n-        void* p = ::shmat(shmid, nullptr, 0);\n-        ::shmctl(shmid, IPC_RMID, nullptr); \/\/ As early as possible!\n-        guarantee0(p != (void*) -1); \/\/ Should always work.\n-        const size_t real_pagesize = os::Aix::query_pagesize(p);\n-        if (real_pagesize != pagesize) {\n-          log_warning(pagesize)(\"real page size (\" SIZE_FORMAT_X \") differs.\", real_pagesize);\n+      assert(shmid != -1, \"shmget failed\");\n+      if (shmid != -1) {\n+        \/\/ Try to set pagesize.\n+        struct shmid_ds shm_buf = { };\n+        shm_buf.shm_pagesize = pagesize;\n+        if (::shmctl(shmid, SHM_PAGESIZE, &shm_buf) != 0) {\n+          const int en = errno;\n+          ::shmctl(shmid, IPC_RMID, nullptr); \/\/ As early as possible!\n+          log_warning(pagesize)(\"shmctl(SHM_PAGESIZE) failed with errno=%d\", errno);\n@@ -444,1 +441,13 @@\n-          can_use = true;\n+          \/\/ Attach and double check pageisze.\n+          void* p = ::shmat(shmid, nullptr, 0);\n+          ::shmctl(shmid, IPC_RMID, nullptr); \/\/ As early as possible!\n+          assert(p != (void*) -1, \"shmat failed\");\n+          if (p != (void*) -1) {\n+            const size_t real_pagesize = os::Aix::query_pagesize(p);\n+            if (real_pagesize != pagesize) {\n+              log_warning(pagesize)(\"real page size (\" SIZE_FORMAT_X \") differs.\", real_pagesize);\n+            } else {\n+              can_use = true;\n+            }\n+            ::shmdt(p);\n+          }\n@@ -446,1 +455,0 @@\n-        ::shmdt(p);\n@@ -458,4 +466,6 @@\n-      void* p = mmap(NULL, 1000000, PROT_READ | PROT_WRITE, MAP_ANON_64K | MAP_ANONYMOUS | MAP_SHARED, -1, 0);\n-      guarantee0(p != (void*) -1); \/\/ Should always work.\n-      g_multipage_support.can_use_64K_mmap_pages = (64*K == os::Aix::query_pagesize(p));\n-      munmap(p, 1000000);\n+      void* p = mmap(NULL, 64*K, PROT_READ | PROT_WRITE, MAP_ANON_64K | MAP_ANONYMOUS | MAP_SHARED, -1, 0);\n+      assert(p != (void*) -1, \"mmap failed\");\n+      if (p != (void*) -1) {\n+        g_multipage_support.can_use_64K_mmap_pages = (64*K == os::Aix::query_pagesize(p));\n+        munmap(p, 64*K);\n+      }\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":38,"deletions":28,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -41,7 +41,0 @@\n-#ifdef AIX\n-# include <sys\/mman.h>\n-\/\/ sys\/mman.h defines MAP_ANON_64K beginning with AIX7.3 TL1\n-# ifndef MAP_ANON_64K\n-# define MAP_ANON_64K  0x400\n-# endif\n-#endif\n@@ -964,21 +957,0 @@\n-#ifdef AIX\n-\/\/ On Aix, when using shmget() in os::attempt_reserve_memory_at() we should fail with attach\n-\/\/ attempts not aligned to shmget() segment boundaries (256m)\n-\/\/ But shmget() is only used in cases we want to have 64K pages and mmap() does not provide it.\n-TEST_VM(os, aix_reserve_at_non_shmlba_aligned_address) {\n-  \/\/ Can we use mmap with 64K pages? (Should be available with AIX 7.3 TL1)\n-  void* p = mmap(NULL, 1000000, PROT_READ | PROT_WRITE, MAP_ANON_64K | MAP_ANONYMOUS | MAP_SHARED, -1, 0);\n-  guarantee(p != (void*) -1, \"mmap returned invalid ptr.\"); \/\/ Should always work.\n-  bool can_use_64K_mmap_pages = (64*K == os::Aix::query_pagesize(p));\n-  munmap(p, 1000000);\n-\n-  if (os::vm_page_size() != 4*K && !can_use_64K_mmap_pages) {\n-    \/\/ With this condition true shmget() is used inside\n-    char* p = os::attempt_reserve_memory_at((char*)0x1f00000, M);\n-    ASSERT_EQ(p, nullptr); \/\/ should have failed\n-    p = os::attempt_reserve_memory_at((char*)((64 * G) + M), M);\n-    ASSERT_EQ(p, nullptr); \/\/ should have failed\n-  }\n-}\n-#endif \/\/ AIX\n-\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":0,"deletions":28,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#ifdef AIX\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"nmt\/memTracker.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"runtime\/threads.hpp\"\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"unittest.hpp\"\n+# include <sys\/mman.h>\n+\/\/ sys\/mman.h defines MAP_ANON_64K beginning with AIX7.3 TL1\n+# ifndef MAP_ANON_64K\n+# define MAP_ANON_64K  0x400\n+# endif\n+\n+\/\/ On Aix, when using shmget() in os::attempt_reserve_memory_at() we should fail with attach\n+\/\/ attempts not aligned to shmget() segment boundaries (256m)\n+\/\/ But shmget() is only used in cases we want to have 64K pages and mmap() does not provide it.\n+TEST_VM(os_aix, aix_reserve_at_non_shmlba_aligned_address) {\n+  \/\/ Can we use mmap with 64K pages? (Should be available with AIX 7.3 TL1)\n+  void* p = mmap(NULL, 1000000, PROT_READ | PROT_WRITE, MAP_ANON_64K | MAP_ANONYMOUS | MAP_SHARED, -1, 0);\n+  guarantee(p != (void*) -1, \"mmap returned invalid ptr.\"); \/\/ Should always work.\n+  bool can_use_64K_mmap_pages = (64*K == os::Aix::query_pagesize(p));\n+  munmap(p, 1000000);\n+\n+  if (os::vm_page_size() != 4*K && !can_use_64K_mmap_pages) {\n+    \/\/ With this condition true shmget() is used inside\n+    char* p = os::attempt_reserve_memory_at((char*)0x1f00000, M);\n+    ASSERT_EQ(p, nullptr); \/\/ should have failed\n+    p = os::attempt_reserve_memory_at((char*)((64 * G) + M), M);\n+    ASSERT_EQ(p, nullptr); \/\/ should have failed\n+  }\n+}\n+\n+#endif \/\/ AIX\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_aix.cpp","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"}]}