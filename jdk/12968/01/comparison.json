{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.lang.ref.Cleaner;\n@@ -46,3 +47,6 @@\n- * A class is considered unloaded if its class loader is finalized.\n- * If there no finalization of class loader detected for some timeout,\n- * class is considered still loaded and method returns <i>false<\/i>.\n+ * A class is considered unloaded if its class loader is reclaimed.\n+ * A runnable lambda is registered to JVM to be called whenever the\n+ * class loader becomes unreachable.\n+ * After setting the class loader to null, if within a timeout no notification\n+ * of its reclaim is received, class is considered still loaded and\n+ * <code>unloadClass()<\/code> method returns <i>false<\/i>.\n@@ -50,1 +54,1 @@\n- * <p>Such finalization control applies only to a class loaded by\n+ * <p>Such reclaiming control applies only to a class loaded by\n@@ -76,1 +80,1 @@\n-     * Whole amount of time in milliseconds to wait for class loader finalization.\n+     * Whole amount of time in milliseconds to wait for class loader reclaim.\n@@ -81,1 +85,1 @@\n-     * Piece of time in milliseconds to wait in a loop for class loader finalization.\n+     * Piece of time in milliseconds to wait in a loop for class loader reclaim.\n@@ -86,1 +90,1 @@\n-     * Has class loader been finalized or not.\n+     * Has class loader been is_reclaimed or not.\n@@ -88,1 +92,1 @@\n-    volatile boolean finalized = false;\n+    volatile boolean is_reclaimed = false;\n@@ -134,1 +138,1 @@\n-        customClassLoader = new CustomClassLoader(this);\n+        customClassLoader = new CustomClassLoader();\n@@ -137,0 +141,3 @@\n+        \/\/ When customClassLoader becomes unreachable, the lambda is called by JVM\/GC.\n+        Cleaner.create().register(customClassLoader, () -> { is_reclaimed = true; } );\n+\n@@ -149,1 +156,3 @@\n-        customClassLoader.setClassUnloader(this);\n+\n+        \/\/ When customClassLoader becomes unreachable, the lambda is called by JVM\/GC.\n+        Cleaner.create().register(customClassLoader, () -> { is_reclaimed = true; } );\n@@ -238,1 +247,1 @@\n-        finalized = false;\n+        is_reclaimed = false;\n@@ -248,1 +257,1 @@\n-        \/\/ give GC chance to run and wait for finalization\n+        \/\/ give GC chance to run and wait for receiving reclaim notification\n@@ -250,1 +259,1 @@\n-        while (!finalized && System.currentTimeMillis() < timeToFinish) {\n+        while (!is_reclaimed && System.currentTimeMillis() < timeToFinish) {\n@@ -263,1 +272,1 @@\n-        if (finalized) {\n+        if (is_reclaimed) {\n@@ -268,1 +277,1 @@\n-        \/\/ class loader has not been finalized\n+        \/\/ class loader has not been is_reclaimed\n@@ -284,29 +293,3 @@\n-    \/**\n-     * Stresses memory by allocating arrays of bytes.\n-     *\n-     * Note that this method can throw Failure if any exception\n-     * is thrown while eating memory. To avoid OOM while allocating\n-     * exception we preallocate it before the lunch starts. It means\n-     * that exception stack trace does not correspond to the place\n-     * where exception is thrown, but points at start of the method.\n-     *\n-     * @throws  Failure if exception other than OutOfMemoryError\n-     *           is thrown while eating memory\n-     *\/\n-    public static void eatMemory(ExecutionController stresser) {\n-        GarbageUtils.eatMemory(stresser, 50, 1024, 2);\n-\n-        \/*\n-         * System.runFinalization() may potentially fail with OOM. This is why\n-         * System.runFinalization() is repeated several times.\n-         *\/\n-        for (int i = 0; i < 10; ++i) {\n-            try {\n-                if(!stresser.continueExecution()) {\n-                    return;\n-                }\n-                System.runFinalization();\n-                break;\n-            } catch (OutOfMemoryError e) {\n-            }\n-        }\n+     \/\/ Stresses memory by allocating arrays of bytes.\n+   public static void eatMemory(ExecutionController stresser) {\n+       GarbageUtils.eatMemory(stresser, 50, 1024, 2);\n@@ -315,12 +298,1 @@\n-        \/**\n-     * Stresses memory by allocating arrays of bytes.\n-     *\n-     * Note that this method can throw Failure if any exception\n-     * is thrown while eating memory. To avoid OOM while allocating\n-     * exception we preallocate it before the lunch starts. It means\n-     * that exception stack trace does not correspond to the place\n-     * where exception is thrown, but points at start of the method.\n-     *\n-     * @throws  Failure if exception other than OutOfMemoryError\n-     *           is thrown while eating memory\n-     *\/\n+     \/\/ Stresses memory by allocating arrays of bytes.\n@@ -336,15 +308,1 @@\n-        GarbageUtils.eatMemory(stresser, 50, 1024, 2);\n-        \/*\n-         * System.runFinalization() may potentially fail with OOM. This is why\n-         * System.runFinalization() is repeated several times.\n-         *\/\n-        for (int i = 0; i < 10; ++i) {\n-            try {\n-                if(!stresser.continueExecution()) {\n-                    return;\n-                }\n-                System.runFinalization();\n-                break;\n-            } catch (OutOfMemoryError e) {\n-            }\n-        }\n+        eatMemory(stresser);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/ClassUnloader.java","additions":30,"deletions":72,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,0 @@\n-    private ClassUnloader classUnloader;\n@@ -56,21 +55,0 @@\n-        this.classUnloader = null;\n-    }\n-\n-    \/**\n-     * Initializes a newly created <code>CustomClassloader<\/code> object\n-     * linked with specified <code>ClassUnloader<\/code> object.\n-     *\n-     * @param classUnloader an instance of <code>ClassUnloader<\/code>\n-     *\/\n-    public CustomClassLoader(ClassUnloader classUnloader) {\n-        super(CustomClassLoader.class.getClassLoader());\n-        this.classUnloader = classUnloader;\n-    }\n-\n-    \/**\n-     * Links this class loader with specified <code>ClassUnloader<\/code> object.\n-     *\n-     * @param classUnloader an instance of <code>ClassUnloader<\/code>\n-     *\/\n-    public void setClassUnloader(ClassUnloader classUnloader) {\n-        this.classUnloader = classUnloader;\n@@ -138,12 +116,0 @@\n-    \/**\n-     * Notifies <code>ClassUnloader<\/code> about finalization.\n-     *\/\n-    protected void finalize() throws Throwable {\n-\n-        \/\/ notify ClassUnloader about finalization\n-        if (classUnloader != null) {\n-            classUnloader.finalized = true;\n-        }\n-\n-        super.finalize();\n-    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/CustomClassLoader.java","additions":1,"deletions":35,"binary":false,"changes":36,"status":"modified"}]}