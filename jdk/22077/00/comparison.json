{"files":[{"patch":"@@ -34,2 +34,0 @@\n-import java.security.*;\n-\n@@ -65,15 +63,4 @@\n-        @SuppressWarnings(\"removal\")\n-        List<String> props = AccessController.doPrivileged(\n-            new PrivilegedAction<>() {\n-                @Override\n-                public List<String> run() {\n-                    return List.of(\n-                        System.getProperty(\n-                            \"sun.security.pkcs11.allowSingleThreadedModules\",\n-                            \"true\"),\n-                        System.getProperty(\"os.name\"),\n-                        System.getProperty(\"os.arch\"));\n-                }\n-            }\n-        );\n-        if (\"false\".equalsIgnoreCase(props.get(0))) {\n+        String allowSingleThreadedModules =\n+            System.getProperty(\n+                \"sun.security.pkcs11.allowSingleThreadedModules\", \"true\");\n+        if (\"false\".equalsIgnoreCase(allowSingleThreadedModules)) {\n@@ -84,2 +71,2 @@\n-        osName = props.get(1);\n-        osArch = props.get(2);\n+        osName = System.getProperty(\"os.name\");\n+        osArch = System.getProperty(\"os.arch\");\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Config.java","additions":6,"deletions":19,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -111,4 +111,0 @@\n-        PrivilegedAction<String> getKeyExtractionProp =\n-                () -> System.getProperty(\n-                        \"sun.security.pkcs11.disableKeyExtraction\", \"false\");\n-        @SuppressWarnings(\"removal\")\n@@ -116,1 +112,2 @@\n-                AccessController.doPrivileged(getKeyExtractionProp);\n+                System.getProperty(\n+                        \"sun.security.pkcs11.disableKeyExtraction\", \"false\");\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Key.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -78,3 +77,1 @@\n-            return AccessController.doPrivileged(\n-                (PrivilegedAction<Boolean>)\n-                () -> Boolean.getBoolean(\"jdk.crypto.KeyAgreement.legacyKDF\"));\n+            return Boolean.getBoolean(\"jdk.crypto.KeyAgreement.legacyKDF\");\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyAgreement.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,1 +133,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings(\"deprecation\")\n@@ -143,16 +143,2 @@\n-                p = AccessController.doPrivileged(\n-                    new PrivilegedAction<Provider>() {\n-                        public Provider run() {\n-                            try {\n-                                @SuppressWarnings(\"deprecation\")\n-                                Object o = c.newInstance();\n-                                return (Provider) o;\n-                            } catch (Exception e) {\n-                                throw new ProviderException(\n-                                        \"Could not find provider \" +\n-                                                providerName, e);\n-                            }\n-                        }\n-                    }, null, new RuntimePermission(\n-                            \"accessClassInPackage.\" + c.getPackageName()));\n-            } catch (ClassNotFoundException e) {\n+                p = (Provider) c.newInstance();\n+            } catch (Exception e) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Util.java","additions":4,"deletions":18,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -120,1 +120,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -125,8 +124,3 @@\n-            return AccessController.doPrivileged(new PrivilegedExceptionAction<>() {\n-                @Override\n-                public SunPKCS11 run() throws Exception {\n-                    return new SunPKCS11(new Config(newConfigName));\n-                }\n-            });\n-        } catch (PrivilegedActionException pae) {\n-            throw new InvalidParameterException(\"Error configuring SunPKCS11 provider\", pae.getException());\n+            return new SunPKCS11(new Config(newConfigName));\n+        } catch (IOException ioe) {\n+            throw new InvalidParameterException(\"Error configuring SunPKCS11 provider\", ioe);\n@@ -1120,1 +1114,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -1200,1 +1193,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -1213,1 +1205,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -1222,6 +1213,1 @@\n-        AccessController.doPrivileged(new PrivilegedAction<Object>() {\n-            public Object run() {\n-                clear();\n-                return null;\n-            }\n-        });\n+        clear();\n@@ -1389,30 +1375,23 @@\n-        @SuppressWarnings(\"removal\")\n-        var dummy = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n-            public Object run() {\n-                for (Map.Entry<Descriptor,Integer> entry\n-                        : supportedAlgs.entrySet()) {\n-                    Descriptor d = entry.getKey();\n-                    int mechanism = entry.getValue().intValue();\n-                    Service s = d.service(token, mechanism);\n-                    putService(s);\n-                }\n-                if (((token.tokenInfo.flags & CKF_RNG) != 0)\n-                        && config.isEnabled(PCKM_SECURERANDOM)\n-                        && !token.sessionManager.lowMaxSessions()) {\n-                    \/\/ do not register SecureRandom if the token does\n-                    \/\/ not support many sessions. if we did, we might\n-                    \/\/ run out of sessions in the middle of a\n-                    \/\/ nextBytes() call where we cannot fail over.\n-                    putService(new P11Service(token, SR, \"PKCS11\",\n-                        \"sun.security.pkcs11.P11SecureRandom\", null,\n-                        PCKM_SECURERANDOM));\n-                }\n-                if (config.isEnabled(PCKM_KEYSTORE)) {\n-                    putService(new P11Service(token, KS, \"PKCS11\",\n-                        \"sun.security.pkcs11.P11KeyStore\",\n-                        List.of(\"PKCS11-\" + config.getName()),\n-                        PCKM_KEYSTORE));\n-                }\n-                return null;\n-            }\n-        });\n+        for (Map.Entry<Descriptor,Integer> entry : supportedAlgs.entrySet()) {\n+            Descriptor d = entry.getKey();\n+            int mechanism = entry.getValue().intValue();\n+            Service s = d.service(token, mechanism);\n+            putService(s);\n+        }\n+        if (((token.tokenInfo.flags & CKF_RNG) != 0)\n+                && config.isEnabled(PCKM_SECURERANDOM)\n+                && !token.sessionManager.lowMaxSessions()) {\n+            \/\/ do not register SecureRandom if the token does\n+            \/\/ not support many sessions. if we did, we might\n+            \/\/ run out of sessions in the middle of a\n+            \/\/ nextBytes() call where we cannot fail over.\n+            putService(new P11Service(token, SR, \"PKCS11\",\n+                \"sun.security.pkcs11.P11SecureRandom\", null,\n+                PCKM_SECURERANDOM));\n+        }\n+        if (config.isEnabled(PCKM_KEYSTORE)) {\n+            putService(new P11Service(token, KS, \"PKCS11\",\n+                \"sun.security.pkcs11.P11KeyStore\",\n+                List.of(\"PKCS11-\" + config.getName()),\n+                PCKM_KEYSTORE));\n+        }\n@@ -1624,4 +1603,0 @@\n-     * @throws SecurityException if the does not pass a security check for\n-     *  <code>SecurityPermission(\"authProvider.<i>name<\/i>\")<\/code>,\n-     *  where <i>name<\/i> is the value returned by\n-     *  this provider's <code>getName<\/code> method\n@@ -1636,11 +1611,0 @@\n-        \/\/ security check\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            if (debug != null) {\n-                debug.println(\"checking login permission\");\n-            }\n-            sm.checkPermission(new SecurityPermission\n-                        (\"authProvider.\" + this.getName()));\n-        }\n-\n@@ -1756,4 +1720,0 @@\n-     * @throws SecurityException if the does not pass a security check for\n-     *  <code>SecurityPermission(\"authProvider.<i>name<\/i>\")<\/code>,\n-     *  where <i>name<\/i> is the value returned by\n-     *  this provider's <code>getName<\/code> method\n@@ -1766,8 +1726,0 @@\n-        \/\/ security check\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission\n-                (new SecurityPermission(\"authProvider.\" + this.getName()));\n-        }\n-\n@@ -1847,5 +1799,0 @@\n-     * @throws SecurityException if the caller does not pass a\n-     *  security check for\n-     *  <code>SecurityPermission(\"authProvider.<i>name<\/i>\")<\/code>,\n-     *  where <i>name<\/i> is the value returned by\n-     *  this provider's <code>getName<\/code> method\n@@ -1859,8 +1806,0 @@\n-        \/\/ security check\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission\n-                (new SecurityPermission(\"authProvider.\" + this.getName()));\n-        }\n-\n@@ -1890,9 +1829,3 @@\n-            try {\n-                if (debug != null) {\n-                    debug.println(\"getting default callback handler\");\n-                }\n-\n-                @SuppressWarnings(\"removal\")\n-                CallbackHandler myHandler = AccessController.doPrivileged\n-                    (new PrivilegedExceptionAction<CallbackHandler>() {\n-                    public CallbackHandler run() throws Exception {\n+            if (debug != null) {\n+                debug.println(\"getting default callback handler\");\n+            }\n@@ -1900,3 +1833,2 @@\n-                        String defaultHandler =\n-                                java.security.Security.getProperty\n-                                (\"auth.login.defaultCallbackHandler\");\n+            String defaultHandler = Security.getProperty\n+                    (\"auth.login.defaultCallbackHandler\");\n@@ -1904,2 +1836,1 @@\n-                        if (defaultHandler == null ||\n-                            defaultHandler.length() == 0) {\n+            if (defaultHandler == null || defaultHandler.length() == 0) {\n@@ -1907,6 +1838,6 @@\n-                            \/\/ ok\n-                            if (debug != null) {\n-                                debug.println(\"no default handler set\");\n-                            }\n-                            return null;\n-                        }\n+                \/\/ ok\n+                if (debug != null) {\n+                    debug.println(\"no default handler set\");\n+                }\n+                return null;\n+            }\n@@ -1914,15 +1845,10 @@\n-                        Class<?> c = Class.forName\n-                                   (defaultHandler,\n-                                   true,\n-                                   Thread.currentThread().getContextClassLoader());\n-                        if (!javax.security.auth.callback.CallbackHandler.class.isAssignableFrom(c)) {\n-                            \/\/ not the right subtype\n-                            if (debug != null) {\n-                                debug.println(\"default handler \" + defaultHandler +\n-                                              \" is not a CallbackHandler\");\n-                            }\n-                            return null;\n-                        }\n-                        @SuppressWarnings(\"deprecation\")\n-                        Object result = c.newInstance();\n-                        return (CallbackHandler)result;\n+            try {\n+                Class<?> c = Class.forName\n+                           (defaultHandler,\n+                           true,\n+                           Thread.currentThread().getContextClassLoader());\n+                if (!CallbackHandler.class.isAssignableFrom(c)) {\n+                    \/\/ not the right subtype\n+                    if (debug != null) {\n+                        debug.println(\"default handler \" + defaultHandler +\n+                                      \" is not a CallbackHandler\");\n@@ -1930,1 +1856,5 @@\n-                });\n+                    return null;\n+                }\n+                @SuppressWarnings(\"deprecation\")\n+                Object result = c.newInstance();\n+                CallbackHandler myHandler = (CallbackHandler)result;\n@@ -1935,1 +1865,1 @@\n-            } catch (PrivilegedActionException pae) {\n+            } catch (ReflectiveOperationException roe) {\n@@ -1939,1 +1869,1 @@\n-                    pae.printStackTrace();\n+                    roe.printStackTrace();\n@@ -1942,0 +1872,1 @@\n+            return null;\n@@ -1943,1 +1874,0 @@\n-        return null;\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SunPKCS11.java","additions":57,"deletions":127,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -54,3 +54,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-\n@@ -83,10 +80,6 @@\n-        \/\/ cannot use LoadLibraryAction because that would make the native\n-        \/\/ library available to the bootclassloader, but we run in the\n-        \/\/ extension classloader.\n-        @SuppressWarnings({\"removal\", \"restricted\"})\n-        var dummy = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n-            public Object run() {\n-                System.loadLibrary(PKCS11_WRAPPER);\n-                return null;\n-            }\n-        });\n+        loadAndInitializeLibrary();\n+    }\n+\n+    @SuppressWarnings(\"restricted\")\n+    private static void loadAndInitializeLibrary() {\n+        System.loadLibrary(PKCS11_WRAPPER);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/PKCS11.java","additions":6,"deletions":13,"binary":false,"changes":19,"status":"modified"}]}