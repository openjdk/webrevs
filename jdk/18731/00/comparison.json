{"files":[{"patch":"@@ -50,5 +50,5 @@\n- * that formats a decimal number in its compact form.\n- *\n- * The compact number formatting is designed for the environment where the space\n- * is limited, and the formatted string can be displayed in that limited space.\n- * It is defined by LDML's specification for\n+ * that formats a decimal number in a {@link Locale localized} compact form.\n+ * Compact number formatting is designed for an environment with limited space.\n+ * For example, displaying the formatted number {@code 7M} instead of {@code\n+ * 7,000,000.00} in the {@link java.util.Locale#US US locale}. The {@code\n+ * CompactNumberFormat} class is defined by LDML's specification for\n@@ -56,3 +56,1 @@\n- * Compact Number Formats<\/a>. A compact number formatting refers\n- * to the representation of a number in a shorter form, based on the patterns\n- * provided for a given locale.\n+ * Compact Number Formats<\/a>.\n@@ -60,8 +58,17 @@\n- * <p>\n- * For example:\n- * <br>In the {@link java.util.Locale#US US locale}, {@code 1000} can be formatted\n- * as {@code \"1K\"}, and {@code 1000000} as {@code \"1M\"}, depending upon the\n- * {@linkplain ##compact_number_style style} used.\n- * <br>In the {@code \"hi_IN\"} locale, {@code 1000} can be formatted as\n- * \"1 \\u0939\\u091C\\u093C\\u093E\\u0930\", and {@code 50000000} as \"5 \\u0915.\",\n- * depending upon the {@linkplain ##compact_number_style style} used.\n+ * <h2>Getting a CompactNumberFormat<\/h2>\n+ * To get a {@code CompactNumberFormat}, use one of the {@code NumberFormat} static\n+ * factory methods listed below.\n+ * <ul>\n+ * <li> Use {@link NumberFormat#getCompactNumberInstance()}\n+ * to obtain a {@code CompactNumberFormat} for the default locale.\n+ * <li> Use {@link NumberFormat#getCompactNumberInstance(Locale, Style)}\n+ * to obtain a {@code CompactNumberFormat} for a different locale\n+ * and to control the {@linkplain ##compact_number_style Style}.\n+ * <li> Use one of the {@code CompactNumberFormat} constructors, for example, {@link\n+ * CompactNumberFormat#CompactNumberFormat(String, DecimalFormatSymbols, String[])\n+ * CompactNumberFormat(decimalPattern, symbols, compactPatterns)}, to obtain a\n+ * {@code CompactNumberFormat} with further customization.\n+ * <\/ul>\n+ * <small>Note: It is recommended to use one of the NumberFormat factory methods\n+ * which is tailored to the conventions of the given locale to retrieve a\n+ * CompactNumberFormat.<\/small>\n@@ -69,5 +76,8 @@\n- * <p>\n- * To obtain a {@code CompactNumberFormat} for a locale, use one\n- * of the factory methods given by {@code NumberFormat} for compact number\n- * formatting. For example,\n- * {@link NumberFormat#getCompactNumberInstance(Locale, Style)}.\n+ * <h2><a id=\"compact_number_style\">Style<\/a><\/h2>\n+ * When using {@link NumberFormat#getCompactNumberInstance(Locale, Style)}, a\n+ * compact form can be retrieved with either a {@link NumberFormat.Style#SHORT\n+ * SHORT} or {@link NumberFormat.Style#LONG LONG} style.\n+ * For example, a {@link NumberFormat.Style#SHORT SHORT} style compact number instance in\n+ * the {@link java.util.Locale#US US locale} formats {@code 10000} as {@code\n+ * \"10K\"}. However, a {@link NumberFormat.Style#LONG LONG} style instance in\n+ * the same locale formats {@code 10000} as {@code \"10 thousand\"}.\n@@ -75,5 +85,2 @@\n- * <blockquote>{@snippet lang=java :\n- * NumberFormat fmt = NumberFormat.getCompactNumberInstance(\n- *                             Locale.forLanguageTag(\"hi-IN\"), NumberFormat.Style.SHORT);\n- * String result = fmt.format(1000);\n- * }<\/blockquote>\n+ * <h2>Using CompactNumberFormat<\/h2>\n+ * The following is an example of formatting and parsing in a localized fashion,\n@@ -81,14 +88,5 @@\n- * <h2><a id=\"compact_number_style\">Style<\/a><\/h2>\n- * <p>\n- * A number can be formatted in the compact forms with two different\n- * styles, {@link NumberFormat.Style#SHORT SHORT}\n- * and {@link NumberFormat.Style#LONG LONG}. Use\n- * {@link NumberFormat#getCompactNumberInstance(Locale, Style)} for formatting and\n- * parsing a number in {@link NumberFormat.Style#SHORT SHORT} or\n- * {@link NumberFormat.Style#LONG LONG} compact form,\n- * where the given {@code Style} parameter requests the desired\n- * format. A {@link NumberFormat.Style#SHORT SHORT} style\n- * compact number instance in the {@link java.util.Locale#US US locale} formats\n- * {@code 10000} as {@code \"10K\"}. However, a\n- * {@link NumberFormat.Style#LONG LONG} style instance in same locale\n- * formats {@code 10000} as {@code \"10 thousand\"}.\n+ * {@snippet lang=java :\n+ * NumberFormat compactFormat = NumberFormat.getCompactNumberInstance(Locale.US, NumberFormat.Style.SHORT);\n+ * compactFormat.format(1000); \/\/ returns \"1K\"\n+ * compactFormat.parse(\"1K\"); \/\/ returns 1000\n+ * }\n@@ -98,3 +96,11 @@\n- * The compact number patterns are represented in a series of patterns where each\n- * pattern is used to format a range of numbers. An example of\n- * {@link NumberFormat.Style#SHORT SHORT} styled compact number patterns\n+ * The {@code compactPatterns} in {@link\n+ * CompactNumberFormat#CompactNumberFormat(String, DecimalFormatSymbols, String[])\n+ * CompactNumberFormat(decimalPattern, symbols, compactPatterns}} are represented\n+ * as a series of strings, where each string is a {@link ##compact_number_syntax\n+ * pattern} that is used to format a range of numbers.\n+ *\n+ * <p><b>For those planning to only use the factory methods, the pattern syntax may\n+ * not be relevant. If this is the case, continue reading at the {@link ##formatting\n+ * Formatting} section.<\/b>\n+ *\n+ * <p> An example of the {@link NumberFormat.Style#SHORT SHORT} styled compact number patterns\n@@ -106,5 +112,5 @@\n- * For example, in the above patterns, pattern at index 3\n- * ({@code \"0K\"}) is used for formatting {@code number >= 1000 and number < 10000},\n- * pattern at index 4 ({@code \"00K\"}) is used for formatting\n- * {@code number >= 10000 and number < 100000} and so on. In most of the locales,\n- * patterns with the range\n+ * For example, in the above patterns, the pattern at index 3\n+ * ({@code \"0K\"}) is used for formatting a number in the range: {@code 1000 <= number < 10000},\n+ * index 4 ({@code \"00K\"}) for formatting a number the range: {@code 10000 <=\n+ * number < 100000}, and so forth.\n+ * <p>In most locales, patterns with the range\n@@ -117,1 +123,1 @@\n- * <p>\n+ * <h3>Negative Subpatterns<\/h3>\n@@ -119,1 +125,1 @@\n- * separated by a subpattern boundary character {@code ';' (U+003B)},\n+ * separated by a subpattern boundary character {@code ';'},\n@@ -123,1 +129,1 @@\n- * minus sign ({@code '-' U+002D HYPHEN-MINUS}) is used as the negative\n+ * minus sign ({@code '-'}) is used as the negative\n@@ -131,1 +137,1 @@\n- * <p>\n+ * <h4>Escaping Special Characters<\/h4>\n@@ -136,1 +142,1 @@\n- * characters. They must be quoted, using single quote {@code ' (U+0027)}\n+ * characters. These characters must be quoted using single quotes ({@code '})\n@@ -142,6 +148,2 @@\n- * In case some localization requires compact number patterns to be different for\n- * plurals, each singular and plural pattern can be enumerated within a pair of\n- * curly brackets <code>'{' (U+007B)<\/code> and <code>'}' (U+007D)<\/code>, separated\n- * by a space {@code ' ' (U+0020)}. If this format is used, each pattern needs to be\n- * prepended by its {@code count}, followed by a single colon {@code ':' (U+003A)}.\n- * If the pattern includes spaces literally, they must be quoted.\n+ * Plural rules differ between locales, in some cases, the compact number patterns\n+ * will have distinct forms for singular and plural.\n@@ -149,5 +151,7 @@\n- * For example, the compact number pattern representing millions in German locale can be\n- * specified as {@code \"{one:0' 'Million other:0' 'Millionen}\"}. The {@code count}\n- * follows LDML's\n- * <a href=\"https:\/\/unicode.org\/reports\/tr35\/tr35-numbers.html#Language_Plural_Rules\">\n- * Language Plural Rules<\/a>.\n+ * For example, while the pattern representing millions ({@code 10}<sup>{@code 6}\n+ * <\/sup>) in the US locale can be specified as the SimplePattern: {@code \"0 Million\"}, for the\n+ * German locale it can be specified as the PluralPattern:\n+ * {@code \"{one:0' 'Million other:0' 'Millionen}\"}.\n+ * As a space is reserved for separating subsequent {@code PluralPattern}s, it must\n+ * be quoted to be used literally in either the prefix or suffix, as seen in the German\n+ * locale example.\n@@ -155,1 +159,4 @@\n- * A compact pattern has the following syntax:\n+ * <a id=\"compact_number_syntax\">A compact pattern has the following syntax, with {@code count}<\/a>\n+ * following LDML's\n+ * <a href=\"https:\/\/unicode.org\/reports\/tr35\/tr35-numbers.html#Language_Plural_Rules\">\n+ * Language Plural Rules<\/a>:\n@@ -182,1 +189,1 @@\n- * <h2>Formatting<\/h2>\n+ * <h2 id=\"formatting\">Formatting<\/h2>\n@@ -196,0 +203,5 @@\n+ * <h3>Rounding<\/h3>\n+ * {@code CompactNumberFormat} provides rounding modes defined in\n+ * {@link java.math.RoundingMode} for formatting.  By default, it uses\n+ * {@link java.math.RoundingMode#HALF_EVEN RoundingMode.HALF_EVEN}.\n+ *\n@@ -203,5 +215,0 @@\n- * <h2>Rounding<\/h2>\n- * {@code CompactNumberFormat} provides rounding modes defined in\n- * {@link java.math.RoundingMode} for formatting.  By default, it uses\n- * {@link java.math.RoundingMode#HALF_EVEN RoundingMode.HALF_EVEN}.\n- *\n@@ -213,0 +220,1 @@\n+ * @see Locale\n@@ -383,2 +391,10 @@\n-     * {@code NumberFormat} for compact number formatting. For example,\n-     * {@link NumberFormat#getCompactNumberInstance(Locale, Style)}.\n+     * {@code NumberFormat} for compact number formatting.\n+     *\n+     * <p>Below is an example of using the constructor,\n+     *\n+     * {@snippet lang=java :\n+     * String[] compactPatterns = {\"\", \"\", \"\", \"a lot\"};\n+     * NumberFormat fmt = new CompactNumberFormat(\"00\", DecimalFormatSymbols.getInstance(Locale.US), compactPatterns);\n+     * fmt.format(1); \/\/ returns \"01\"\n+     * fmt.format(1000); \/\/ returns \"a lot\"\n+     * }\n@@ -386,1 +402,2 @@\n-     * @param decimalPattern a decimal pattern for general number formatting\n+     * @param decimalPattern a {@linkplain DecimalFormat##patterns decimal pattern}\n+     *                       for general number formatting\n@@ -413,1 +430,2 @@\n-     * @param decimalPattern a decimal pattern for general number formatting\n+     * @param decimalPattern a {@linkplain DecimalFormat##patterns decimal pattern}\n+     *                      for general number formatting\n","filename":"src\/java.base\/share\/classes\/java\/text\/CompactNumberFormat.java","additions":93,"deletions":75,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -58,4 +58,4 @@\n- * {@code NumberFormat} that formats decimal numbers. It has a variety of\n- * features designed to make it possible to parse and format numbers in any\n- * locale, including support for Western, Arabic, and Indic digits.  It also\n- * supports different kinds of numbers, including integers (123), fixed-point\n+ * {@code NumberFormat} that formats decimal numbers in a {@link Locale localized} manner.\n+ * It has a variety of features designed to make it possible to parse and format\n+ * numbers in any locale, including support for Western, Arabic, and Indic digits.\n+ * It also supports different kinds of numbers, including integers (123), fixed-point\n@@ -63,16 +63,1 @@\n- * currency amounts ($123).  All of these can be localized.\n- *\n- * <p>To obtain a {@code NumberFormat} for a specific locale, including the\n- * default locale, call one of {@code NumberFormat}'s factory methods, such\n- * as {@code getInstance()}.  In general, do not call the\n- * {@code DecimalFormat} constructors directly, since the\n- * {@code NumberFormat} factory methods may return subclasses other than\n- * {@code DecimalFormat}. If you need to customize the format object, do\n- * something like this:\n- *\n- * <blockquote>{@snippet lang=java :\n- * NumberFormat numFormat = NumberFormat.getInstance(loc);\n- * if (numFormat instanceof DecimalFormat decFormat) {\n- *     decFormat.setDecimalSeparatorAlwaysShown(true);\n- * }\n- * }<\/blockquote>\n+ * currency amounts ($123).\n@@ -80,6 +65,1 @@\n- * <p>A {@code DecimalFormat} comprises a <em>pattern<\/em> and a set of\n- * <em>symbols<\/em>.  The pattern may be set directly using\n- * {@code applyPattern()}, or indirectly using the API methods.  The\n- * symbols are stored in a {@code DecimalFormatSymbols} object.  When using\n- * the {@code NumberFormat} factory methods, the pattern and symbols are\n- * read from localized {@code ResourceBundle}s.\n+ * <h2>Getting a DecimalFormat<\/h2>\n@@ -87,1 +67,4 @@\n- * <h2 id=\"patterns\">Patterns<\/h2>\n+ * To get a {@code DecimalFormat} for the default Locale, use one of the {@code\n+ * NumberFormat} static factory methods listed below.\n+ * The following formats all provide an example of formatting the {@code Number}\n+ * \"2000.50\" with the {@link java.util.Locale#US US} locale as the default locale.\n@@ -89,8 +72,45 @@\n- * Note: For any given {@code DecimalFormat} pattern, if the pattern is not\n- * in scientific notation, the maximum number of integer digits will not be\n- * derived from the pattern, and instead set to {@link Integer#MAX_VALUE}.\n- * Otherwise, if the pattern is in scientific notation, the maximum number of\n- * integer digits will be derived from the pattern. This derivation is detailed\n- * in the {@link ##scientific_notation Scientific Notation} section. This behavior\n- * is the typical end-user desire; {@link #setMaximumIntegerDigits(int)} can be\n- * used to manually adjust the maximum integer digits.\n+ * <ul>\n+ * <li> Use {@link #getInstance()} or {@link #getNumberInstance()} to get\n+ * a decimal format. For example, {@code \"2,000.5\"}.\n+ * <li> Use {@link #getIntegerInstance()} to get an integer number format.\n+ * For example, {@code \"2,000\"}.\n+ * <li> Use {@link #getCurrencyInstance} to get a currency number format.\n+ * For example, {@code \"$2,000.50\"}.\n+ * <li> Use {@link #getPercentInstance} to get a format for displaying percentages.\n+ * For example, {@code \"200,050%\"}.\n+ * <li> Use one of the {@code DecimalFormat} constructors to obtain a {@code\n+ * DecimalFormat} with further customization.\n+ * <\/ul>\n+ *\n+ * <small>Note: It is recommended to use one of the NumberFormat factory methods\n+ * which is tailored to the conventions of the given locale to retrieve a\n+ * DecimalFormat.<\/small>\n+ *<p>\n+ * Alternatively, if a {@code DecimalFormat} for a different locale is required, use\n+ * one of the factory method variants that take {@code locale} as a parameter,\n+ * for example, {@link #getIntegerInstance(Locale)}. {@link\n+ * NumberFormat#getAvailableLocales()} can be used to determine if the desired\n+ * locale is supported.\n+ *\n+ * <h2>Using DecimalFormat<\/h2>\n+ * The following is an example of formatting and parsing in a customized localized fashion,\n+ *\n+ * {@snippet lang=java :\n+ * DecimalFormat currencyFormat = (DecimalFormat) NumberFormat.getCurrencyInstance(Locale.US);\n+ * \/\/ The positive prefix is implicitly \"$\" for a US currency instance\n+ * currencyFormat.setPositiveSuffix(\" dollars\");\n+ * currencyFormat.format(100000); \/\/ returns \"$100,000.00 dollars\"\n+ * currencyFormat.parse(\"$100,000.00 dollars\"); \/\/ returns 100000\n+ * }\n+ *\n+ * <h2 id=\"patterns\">DecimalFormat Pattern<\/h2>\n+ *\n+ * A {@code DecimalFormat} comprises a <em>pattern<\/em> and a set of\n+ * <em>symbols<\/em>. The pattern may be set directly using {@code applyPattern()},\n+ * or indirectly using the various API methods. The symbols are stored in a {@code\n+ * DecimalFormatSymbols} object. When using the {@code NumberFormat} factory\n+ * methods, the pattern and symbols are read from localized {@code ResourceBundle}s,\n+ * adhering to the given locale's conventions.\n+ * <p><b>For those planning to only use the factory methods, the pattern syntax may\n+ * not be relevant. If this is the case, continue reading at the {@link ##formatting Formatting and Parsing}\n+ * section.<\/b>\n@@ -137,31 +157,0 @@\n- * <p>A {@code DecimalFormat} pattern contains a positive and negative\n- * subpattern, for example, {@code \"#,##0.00;(#,##0.00)\"}.  Each\n- * subpattern has a prefix, numeric part, and suffix. The negative subpattern\n- * is optional; if absent, then the positive subpattern prefixed with the\n- * minus sign ({@code '-' U+002D HYPHEN-MINUS}) is used as the\n- * negative subpattern. That is, {@code \"0.00\"} alone is equivalent to\n- * {@code \"0.00;-0.00\"}.  If there is an explicit negative subpattern, it\n- * serves only to specify the negative prefix and suffix; the number of digits,\n- * minimal digits, and other characteristics are all the same as the positive\n- * pattern. That means that {@code \"#,##0.0#;(#)\"} produces precisely\n- * the same behavior as {@code \"#,##0.0#;(#,##0.0#)\"}.\n- *\n- * <p>The prefixes, suffixes, and various symbols used for infinity, digits,\n- * grouping separators, decimal separators, etc. may be set to arbitrary\n- * values, and they will appear properly during formatting.  However, care must\n- * be taken that the symbols and strings do not conflict, or parsing will be\n- * unreliable.  For example, either the positive and negative prefixes or the\n- * suffixes must be distinct for {@code DecimalFormat.parse()} to be able\n- * to distinguish positive from negative values.  (If they are identical, then\n- * {@code DecimalFormat} will behave as if no negative subpattern was\n- * specified.)  Another example is that the decimal separator and grouping\n- * separator should be distinct characters, or parsing will be impossible.\n- *\n- * <p>The grouping separator is commonly used for thousands, but in some\n- * countries it separates ten-thousands. The grouping size is a constant number\n- * of digits between the grouping characters, such as 3 for 100,000,000 or 4 for\n- * 1,0000,0000.  If you supply a pattern with multiple grouping characters, the\n- * interval between the last one and the end of the integer is the one that is\n- * used. So {@code \"#,##,###,####\"} == {@code \"######,####\"} ==\n- * {@code \"##,####,####\"}.\n- *\n@@ -170,3 +159,2 @@\n- * <p>Many characters in a pattern are taken literally; they are matched during\n- * parsing and output unchanged during formatting.  Special characters, on the\n- * other hand, stand for other characters, strings, or classes of characters.\n+ * <p>The special characters in the table below are interpreted syntatically when\n+ * used in the DecimalFormat pattern.\n@@ -176,5 +164,6 @@\n- * <p>The characters listed here are used in non-localized patterns.  Localized\n- * patterns use the corresponding characters taken from this formatter's\n- * {@code DecimalFormatSymbols} object instead, and these characters lose\n- * their special status.  Two exceptions are the currency sign and quote, which\n- * are not localized.\n+ * <p>When calling {@link #applyPattern(String)}, use the default symbols in the\n+ * table. When calling {@link #applyLocalizedPattern(String)} use the corresponding\n+ * localized symbol.\n+ * When {@link #applyLocalizedPattern(String)} is called, the default symbols lose their\n+ * syntactical meaning, and vice versa with {@link #applyPattern(String)} with exception\n+ * to the non localized symbols.\n@@ -188,0 +177,1 @@\n+ *          <th scope=\"col\" style=\"text-align:left\">Localized Symbol\n@@ -189,2 +179,1 @@\n- *          <th scope=\"col\" style=\"text-align:left\">Localized?\n- *          <th scope=\"col\" style=\"text-align:left\">Meaning\n+ *          <th scope=\"col\" style=\"text-align:left;width:50%\">Meaning\n@@ -193,1 +182,1 @@\n- *     <tr style=\"vertical-align:top\">\n+ *     <tr>\n@@ -195,0 +184,1 @@\n+ *          <td>{@link DecimalFormatSymbols#getZeroDigit()}\n@@ -196,1 +186,0 @@\n- *          <td>Yes\n@@ -198,1 +187,1 @@\n- *     <tr style=\"vertical-align: top\">\n+ *     <tr>\n@@ -200,0 +189,1 @@\n+ *          <td>{@link DecimalFormatSymbols#getDigit()}\n@@ -201,1 +191,0 @@\n- *          <td>Yes\n@@ -203,1 +192,1 @@\n- *     <tr style=\"vertical-align:top\">\n+ *     <tr>\n@@ -205,0 +194,1 @@\n+ *          <td>{@link DecimalFormatSymbols#getDecimalSeparator()}\n@@ -206,1 +196,0 @@\n- *          <td>Yes\n@@ -208,1 +197,1 @@\n- *     <tr style=\"vertical-align: top\">\n+ *     <tr>\n@@ -210,0 +199,1 @@\n+ *          <td>{@link DecimalFormatSymbols#getMinusSign()}\n@@ -211,1 +201,0 @@\n- *          <td>Yes\n@@ -213,1 +202,1 @@\n- *     <tr style=\"vertical-align:top\">\n+ *     <tr>\n@@ -215,0 +204,1 @@\n+ *          <td>{@link DecimalFormatSymbols#getGroupingSeparator()}\n@@ -216,1 +206,0 @@\n- *          <td>Yes\n@@ -218,1 +207,1 @@\n- *     <tr style=\"vertical-align: top\">\n+ *     <tr>\n@@ -220,0 +209,1 @@\n+ *          <td>{@link DecimalFormatSymbols#getExponentSeparator()}\n@@ -221,4 +211,3 @@\n- *          <td>Yes\n- *          <td>Separates mantissa and exponent in scientific notation.\n- *              <em>Need not be quoted in prefix or suffix.<\/em>\n- *     <tr style=\"vertical-align:top\">\n+ *          <td>Separates mantissa and exponent in scientific notation. This value\n+ *              is case sensistive. <em>Need not be quoted in prefix or suffix.<\/em>\n+ *     <tr>\n@@ -226,0 +215,1 @@\n+ *          <td>{@link DecimalFormatSymbols#getPatternSeparator()}\n@@ -227,1 +217,0 @@\n- *          <td>Yes\n@@ -229,1 +218,1 @@\n- *     <tr style=\"vertical-align: top\">\n+ *     <tr>\n@@ -231,0 +220,1 @@\n+ *          <td>{@link DecimalFormatSymbols#getPercent()}\n@@ -232,1 +222,0 @@\n- *          <td>Yes\n@@ -234,2 +223,3 @@\n- *     <tr style=\"vertical-align:top\">\n- *          <th scope=\"row\">{@code U+2030}\n+ *     <tr>\n+ *          <th scope=\"row\">&permil; ({@code U+2030})\n+ *          <td>{@link DecimalFormatSymbols#getPerMill()}\n@@ -237,1 +227,0 @@\n- *          <td>Yes\n@@ -239,1 +228,1 @@\n- *     <tr style=\"vertical-align: top\">\n+ *     <tr>\n@@ -241,0 +230,1 @@\n+ *          <td> n\/a (not localized)\n@@ -242,1 +232,0 @@\n- *          <td>No\n@@ -247,1 +236,1 @@\n- *     <tr style=\"vertical-align:top\">\n+ *     <tr>\n@@ -249,0 +238,1 @@\n+ *          <td> n\/a (not localized)\n@@ -250,1 +240,0 @@\n- *          <td>No\n@@ -259,0 +248,43 @@\n+ * <h3>Maximum Digits Derivation<\/h3>\n+ * For any given {@code DecimalFormat} pattern, if the pattern is not\n+ * in scientific notation, the maximum number of integer digits will not be\n+ * derived from the pattern, and instead set to {@link Integer#MAX_VALUE}.\n+ * Otherwise, if the pattern is in scientific notation, the maximum number of\n+ * integer digits will be derived from the pattern. This derivation is detailed\n+ * in the {@link ##scientific_notation Scientific Notation} section. This behavior\n+ * is the typical end-user desire; {@link #setMaximumIntegerDigits(int)} can be\n+ * used to manually adjust the maximum integer digits.\n+ *\n+ * <h3>Negative Subpatterns<\/h3>\n+ * A {@code DecimalFormat} pattern contains a positive and negative\n+ * subpattern, for example, {@code \"#,##0.00;(#,##0.00)\"}.  Each\n+ * subpattern has a prefix, numeric part, and suffix. The negative subpattern\n+ * is optional; if absent, then the positive subpattern prefixed with the\n+ * minus sign ({@code '-'}) is used as the\n+ * negative subpattern. That is, {@code \"0.00\"} alone is equivalent to\n+ * {@code \"0.00;-0.00\"}.  If there is an explicit negative subpattern, it\n+ * serves only to specify the negative prefix and suffix; the number of digits,\n+ * minimal digits, and other characteristics are all the same as the positive\n+ * pattern. That means that {@code \"#,##0.0#;(#)\"} produces precisely\n+ * the same behavior as {@code \"#,##0.0#;(#,##0.0#)\"}.\n+ *\n+ * <p>The prefixes, suffixes, and various symbols used for infinity, digits,\n+ * grouping separators, decimal separators, etc. may be set to arbitrary\n+ * values, and they will appear properly during formatting.  However, care must\n+ * be taken that the symbols and strings do not conflict, or parsing will be\n+ * unreliable.  For example, either the positive and negative prefixes or the\n+ * suffixes must be distinct for {@code DecimalFormat.parse()} to be able\n+ * to distinguish positive from negative values.  (If they are identical, then\n+ * {@code DecimalFormat} will behave as if no negative subpattern was\n+ * specified.)  Another example is that the decimal separator and grouping\n+ * separator should be distinct characters, or parsing will be impossible.\n+ *\n+ * <h3>Grouping Separator<\/h3>\n+ * <p>The grouping separator is commonly used for thousands, but in some\n+ * locales it separates ten-thousands. The grouping size is a constant number\n+ * of digits between the grouping characters, such as 3 for 100,000,000 or 4 for\n+ * 1,0000,0000. If you supply a pattern with multiple grouping characters, the\n+ * interval between the last one and the end of the integer is the one that is\n+ * used. For example, {@code \"#,##,###,####\"} == {@code \"######,####\"} ==\n+ * {@code \"##,####,####\"}.\n+ *\n@@ -341,1 +373,2 @@\n- * <h3>Rounding<\/h3>\n+ * <h2 id=\"formatting\">Formatting and Parsing<\/h2>\n+ * <h3 id=\"rounding\">Rounding<\/h3>\n@@ -343,2 +376,2 @@\n- * {@code DecimalFormat} provides rounding modes defined in\n- * {@link java.math.RoundingMode} for formatting.  By default, it uses\n+ * When formatting, {@code DecimalFormat} can adjust its rounding using {@link\n+ * #setRoundingMode(RoundingMode)}. By default, it uses\n@@ -349,1 +382,1 @@\n- * For formatting, {@code DecimalFormat} uses the ten consecutive\n+ * When formatting, {@code DecimalFormat} uses the ten consecutive\n@@ -351,3 +384,3 @@\n- * {@code DecimalFormatSymbols} object as digits. For parsing, these\n- * digits as well as all Unicode decimal digits, as defined by\n- * {@link Character#digit Character.digit}, are recognized.\n+ * {@code DecimalFormatSymbols} object as digits.\n+ * <p>When parsing, these digits as well as all Unicode decimal digits, as\n+ * defined by {@link Character#digit Character.digit}, are recognized.\n@@ -356,1 +389,0 @@\n- *\n@@ -364,6 +396,6 @@\n- * <h4>Special Values<\/h4>\n- *\n- * <p>Not a Number({@code NaN}) is formatted as a string, which typically has a\n- * single character {@code U+FFFD}.  This string is determined by the\n- * {@code DecimalFormatSymbols} object.  This is the only value for which\n- * the prefixes and suffixes are not used.\n+ * <h3>Special Values<\/h3>\n+ * <ul>\n+ * <li><p><b>Not a Number<\/b> ({@code NaN}) is successfully formatted as a string,\n+ * which is typically given as \"NaN\". This string is determined by {@link\n+ * DecimalFormatSymbols#getNaN()}. This is the only value for which the prefixes\n+ * and suffixes are not attached.\n@@ -371,4 +403,3 @@\n- * <p>Infinity is formatted as a string, which typically has a single character\n- * {@code U+221E}, with the positive or negative prefixes and suffixes\n- * applied.  The infinity string is determined by the\n- * {@code DecimalFormatSymbols} object.\n+ * <li><p><b>Infinity<\/b> is formatted as a string, which is typically given as\n+ * \"&#8734;\" ({@code U+221E}), with the positive or negative prefixes and suffixes\n+ * attached. This string is determined by {@link DecimalFormatSymbols#getInfinity()}.\n@@ -376,1 +407,1 @@\n- * <p>Negative zero ({@code \"-0\"}) parses to\n+ * <li><p><b>Negative zero<\/b> ({@code \"-0\"}) parses to\n@@ -379,1 +410,1 @@\n- * true,\n+ * true\n@@ -381,1 +412,1 @@\n- *     and {@code isParseIntegerOnly()} is true,\n+ *     and {@code isParseIntegerOnly()} is true\n@@ -383,1 +414,2 @@\n- * and {@code isParseIntegerOnly()} are false.\n+ * and {@code isParseIntegerOnly()} are false\n+ * <\/ul>\n@@ -386,1 +418,1 @@\n- * <h3><a id=\"synchronization\">Synchronization<\/a><\/h3>\n+ * <h2><a id=\"synchronization\">Synchronization<\/a><\/h2>\n@@ -394,32 +426,2 @@\n- * <h3>Example<\/h3>\n- *\n- * <blockquote>{@snippet lang=java :\n- * \/\/ Print out a number using the localized number, integer, currency,\n- * \/\/ and percent format for each locale\n- * Locale[] locales = NumberFormat.getAvailableLocales();\n- * double myNumber = -1234.56;\n- * NumberFormat form;\n- * for (int j = 0; j < 4; ++j) {\n- *     System.out.println(\"FORMAT\");\n- *     for (Locale locale : locales) {\n- *         if (locale.getCountry().length() == 0) {\n- *             continue; \/\/ Skip language-only locales\n- *         }\n- *         System.out.print(locale.getDisplayName());\n- *         form = switch (j) {\n- *             case 0 -> NumberFormat.getInstance(locale);\n- *             case 1 -> NumberFormat.getIntegerInstance(locale);\n- *             case 2 -> NumberFormat.getCurrencyInstance(locale);\n- *             default -> NumberFormat.getPercentInstance(locale);\n- *         };\n- *         if (form instanceof DecimalFormat decForm) {\n- *             System.out.print(\": \" + decForm.toPattern());\n- *         }\n- *         System.out.print(\" -> \" + form.format(myNumber));\n- *         try {\n- *             System.out.println(\" -> \" + form.parse(form.format(myNumber)));\n- *         } catch (ParseException e) {}\n- *     }\n- * }\n- * }<\/blockquote>\n- *\n+ * @spec         https:\/\/www.unicode.org\/reports\/tr35\n+ *               Unicode Locale Data Markup Language (LDML)\n@@ -430,0 +432,1 @@\n+ * @see          Locale\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":159,"deletions":156,"binary":false,"changes":315,"status":"modified"},{"patch":"@@ -61,36 +61,24 @@\n- * numbers. {@code NumberFormat} also provides methods for determining\n- * which locales have number formats, and what their names are.\n- *\n- * <p>\n- * {@code NumberFormat} helps you to format and parse numbers for any locale.\n- * Your code can be completely independent of the locale conventions for\n- * decimal points, thousands-separators, or even the particular decimal\n- * digits used, or whether the number format is even decimal.\n- *\n- * <p>\n- * To format a number for the current Locale, use one of the factory\n- * class methods:\n- * <blockquote>\n- * {@snippet lang=java :\n- * myString = NumberFormat.getInstance().format(myNumber);\n- * }\n- * <\/blockquote>\n- * If you are formatting multiple numbers, it is\n- * more efficient to get the format and use it multiple times so that\n- * the system doesn't have to fetch the information about the local\n- * language and country conventions multiple times.\n- * <blockquote>\n- * {@snippet lang=java :\n- * NumberFormat nf = NumberFormat.getInstance();\n- * for (var myNumber : numbers) {\n- *     output.println(nf.format(myNumber) + \"; \");\n- * }\n- * }\n- * <\/blockquote>\n- * To format a number for a different Locale, specify it in the\n- * call to {@code getInstance}.\n- * <blockquote>\n- * {@snippet lang=java :\n- * NumberFormat nf = NumberFormat.getInstance(Locale.FRENCH);\n- * }\n- * <\/blockquote>\n+ * numbers in a {@link Locale localized} manner. This enables code that can be completely\n+ * independent of the locale conventions for decimal points, thousands-separators,\n+ * whether the number format is even decimal, or even the particular decimal\n+ * digits used. For example, this class could be used within an application to\n+ * produce a number in a currency format according to conventions of the locale\n+ * a user resides in.\n+ *\n+ * <h2>Getting a NumberFormat<\/h2>\n+ * To get a {@code NumberFormat} for the default Locale, use one of the static\n+ * factory methods that return a concrete subclass of {@code NumberFormat}.\n+ * The following formats all provide an example of formatting the {@code Number}\n+ * \"2000.50\" with the {@link java.util.Locale#US US} locale as the default locale.\n+ * <ul>\n+ * <li> Use {@link #getInstance()} or {@link #getNumberInstance()} to get\n+ * a decimal format. For example, {@code \"2,000.5\"}.\n+ * <li> Use {@link #getIntegerInstance()} to get an integer number format.\n+ * For example, {@code \"2,000\"}.\n+ * <li> Use {@link #getCurrencyInstance} to get a currency number format.\n+ * For example, {@code \"$2,000.50\"}.\n+ * <li> Use {@link #getCompactNumberInstance} to get a compact number format.\n+ * For example, {@code \"2K\"}.\n+ * <li> Use {@link #getPercentInstance} to get a format for displaying percentages.\n+ * For example, {@code \"200,050%\"}.\n+ * <\/ul>\n@@ -98,1 +86,11 @@\n- * <p>If the locale contains \"nu\" (numbers) and\/or \"rg\" (region override)\n+ * Alternatively, if a {@code NumberFormat} for a different locale is required, use\n+ * one of the factory method variants that take {@code locale} as a parameter,\n+ * for example, {@link #getIntegerInstance(Locale)}. To determine if the current\n+ * locale is supported by the installed locale-sensitive service implementation,\n+ * either use {@link #getAvailableLocales()} or ensure a factory method call is enclosed\n+ * within a try block.\n+ *\n+ * <h3>Locale Extensions<\/h3>\n+ * <p>If the locale used for formatting contains \"nu\"\n+ * (<a href=\"https:\/\/unicode.org\/reports\/tr35\/#UnicodeNumberSystemIdentifier\">Numbering System<\/a>)\n+ * and\/or \"rg\" (<a href=\"https:\/\/unicode.org\/reports\/tr35\/#RegionOverride\">Region Override<\/a>)\n@@ -102,4 +100,11 @@\n- * extension supersedes the implicit one from the \"rg\" extension.\n- *\n- * <p>You can also use a {@code NumberFormat} to parse numbers:\n- * <blockquote>\n+ * extension supersedes the implicit one from the \"rg\" extension. Additionally,\n+ * currency formats support the \"cf\" ({@link #getCurrencyInstance(Locale) Currency\n+ * Format style}) extension. Although the LDML specification defines various\n+ * keys and values, actual locale-sensitive service implementations in a Java\n+ * Runtime Environment might not support any particular Unicode locale attributes\n+ * or key\/type pairs.\n+ * <p>Below is an example of a \"en-US\" locale with Thai digits,\n+ * <blockquote>{@code NumberFormat.getInstance(Locale.forLanguageTag(\"en-US-u-nu-thai\"));}<\/blockquote>\n+ *\n+ * <h2>Using NumberFormat<\/h2>\n+ * The following is an example of formatting and parsing in a localized fashion,\n@@ -107,1 +112,3 @@\n- * myNumber = nf.parse(myString);\n+ * NumberFormat currencyFormat = NumberFormat.getCurrencyInstance(Locale.US);\n+ * currencyFormat.format(100000); \/\/ returns \"$100,000.00\"\n+ * currencyFormat.parse(\"$100,000.00\"); \/\/ returns 100000\n@@ -109,10 +116,0 @@\n- * <\/blockquote>\n- * Use {@code getInstance} or {@code getNumberInstance} to get the\n- * normal number format. Use {@code getIntegerInstance} to get an\n- * integer number format. Use {@code getCurrencyInstance} to get the\n- * currency number format. Use {@code getCompactNumberInstance} to get the\n- * compact number format to format a number in shorter form. For example,\n- * {@code 2000} can be formatted as {@code \"2K\"} in\n- * {@link java.util.Locale#US US locale}. Use {@code getPercentInstance}\n- * to get a format for displaying percentages. With this format, a fraction\n- * like 0.53 is displayed as 53%.\n@@ -120,10 +117,12 @@\n- * <p>\n- * You can also control the display of numbers with such methods as\n- * {@code setMinimumFractionDigits}.\n- * If you want even more control over the format or parsing,\n- * or want to give your users more control,\n- * you can try casting the {@code NumberFormat} you get from the factory methods\n- * to a {@code DecimalFormat} or {@code CompactNumberFormat} depending on\n- * the factory method used. This will work for the vast majority of locales;\n- * just remember to put it in a {@code try} block in case you encounter\n- * an unusual one.\n+ * <h2>Customizing NumberFormat<\/h2>\n+ * {@code NumberFormat} provides API to customize formatting and parsing behavior,\n+ * <ul>\n+ * <li> {@link #setParseIntegerOnly(boolean)}; when {@code true}, will only return the\n+ * integer portion of the number parsed from the String.\n+ * <li> {@link #setMinimumFractionDigits}; Use to adjust the expected digits when\n+ * formatting. Use any of the other minimum\/maximum or fraction\/integer setter methods\n+ * in the same manner.\n+ * <li> {@link #setGroupingUsed}; when {@code true}, formatted numbers will be displayed\n+ * with grouping separators. Additionally, when {@code false}, parsing will not expect\n+ * grouping separators in the parsed String.\n+ * <\/ul>\n@@ -132,18 +131,7 @@\n- * NumberFormat and DecimalFormat are designed such that some controls\n- * work for formatting and others work for parsing.  The following is\n- * the detailed description for each these control methods,\n- * <p>\n- * setParseIntegerOnly : only affects parsing, e.g.\n- * if true,  \"3456.78\" &rarr; 3456 (and leaves the parse position just after index 6)\n- * if false, \"3456.78\" &rarr; 3456.78 (and leaves the parse position just after index 8)\n- * This is independent of formatting.  If you want to not show a decimal point\n- * where there might be no digits after the decimal point, use\n- * setDecimalSeparatorAlwaysShown.\n- * <p>\n- * setDecimalSeparatorAlwaysShown : only affects formatting, and only where\n- * there might be no digits after the decimal point, such as with a pattern\n- * like \"#,##0.##\", e.g.,\n- * if true,  3456.00 &rarr; \"3,456.\"\n- * if false, 3456.00 &rarr; \"3456\"\n- * This is independent of parsing.  If you want parsing to stop at the decimal\n- * point, use setParseIntegerOnly.\n+ * To provide more control over the format or parsing, cast the {@code\n+ * NumberFormat} you get from the factory methods to a {@code DecimalFormat} or\n+ * {@code CompactNumberFormat} depending on the factory method used. For example,\n+ * cast to {@code DecimalFormat} to call {@link DecimalFormat#setGroupingSize(int)}\n+ * to change the desired digits between grouping separators.\n+ * While this will work for the vast majority of locales; a {@code\n+ * try} block should be used in case a non-supported locale is encountered.\n@@ -156,2 +144,2 @@\n- * <li> progressively parse through pieces of a string\n- * <li> align the decimal point and other areas\n+ * <li> Progressively parse through pieces of a string\n+ * <li> Align the decimal point and other areas\n@@ -186,1 +174,3 @@\n- * @implSpec The {@link #format(double, StringBuffer, FieldPosition)},\n+ * @implSpec\n+ * <h3>Null Parameter Handling<\/h3>\n+ * The {@link #format(double, StringBuffer, FieldPosition)},\n@@ -193,1 +183,1 @@\n- * <p>\n+ * <h3>Default RoundingMode<\/h3>\n@@ -204,0 +194,2 @@\n+ * @spec         https:\/\/www.unicode.org\/reports\/tr35\n+ *               Unicode Locale Data Markup Language (LDML)\n@@ -207,0 +199,1 @@\n+ * @see          Locale\n","filename":"src\/java.base\/share\/classes\/java\/text\/NumberFormat.java","additions":77,"deletions":84,"binary":false,"changes":161,"status":"modified"}]}