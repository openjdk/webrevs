{"files":[{"patch":"@@ -50,5 +50,5 @@\n- * that formats a decimal number in its compact form.\n- *\n- * The compact number formatting is designed for the environment where the space\n- * is limited, and the formatted string can be displayed in that limited space.\n- * It is defined by LDML's specification for\n+ * that formats a decimal number in a localized compact form.\n+ * Compact number formatting is designed for an environment with limited space.\n+ * For example, displaying the formatted number {@code 7M} instead of {@code\n+ * 7,000,000.00} in the {@link java.util.Locale#US US locale}. The {@code\n+ * CompactNumberFormat} class is defined by LDML's specification for\n@@ -56,3 +56,1 @@\n- * Compact Number Formats<\/a>. A compact number formatting refers\n- * to the representation of a number in a shorter form, based on the patterns\n- * provided for a given locale.\n+ * Compact Number Formats<\/a>.\n@@ -60,8 +58,22 @@\n- * <p>\n- * For example:\n- * <br>In the {@link java.util.Locale#US US locale}, {@code 1000} can be formatted\n- * as {@code \"1K\"}, and {@code 1000000} as {@code \"1M\"}, depending upon the\n- * {@linkplain ##compact_number_style style} used.\n- * <br>In the {@code \"hi_IN\"} locale, {@code 1000} can be formatted as\n- * \"1 \\u0939\\u091C\\u093C\\u093E\\u0930\", and {@code 50000000} as \"5 \\u0915.\",\n- * depending upon the {@linkplain ##compact_number_style style} used.\n+ * <h2>Getting a CompactNumberFormat<\/h2>\n+ * To get a compact number format, use one of the ways listed below.\n+ * <ul>\n+ * <li> Use the factory method {@link NumberFormat#getCompactNumberInstance()}\n+ * to obtain a format for the default locale with\n+ * {@link NumberFormat.Style#SHORT SHORT} style.\n+ * <li> Use the factory methood {@link NumberFormat#getCompactNumberInstance(Locale, Style)}\n+ * to obtain a format for a different locale\n+ * and to control the {@linkplain ##compact_number_style Style}.\n+ * <li> Use one of the {@code CompactNumberFormat} constructors, for example, {@link\n+ * CompactNumberFormat#CompactNumberFormat(String, DecimalFormatSymbols, String[])\n+ * CompactNumberFormat(decimalPattern, symbols, compactPatterns)}, to obtain a\n+ * {@code CompactNumberFormat} with further customization.\n+ * <\/ul>\n+ * <p>If a standard compact format for a given locale and {@link\n+ * ##compact_number_style style} is desired, it is recommended to use one of the\n+ * NumberFormat factory methods listed above. To use an instance method\n+ * defined by {@code CompactNumberFormat}, the {@code NumberFormat} returned by\n+ * these factory methods should be type checked before converted to {@code CompactNumberFormat}.\n+ * If the installed locale-sensitive service implementation does not support\n+ * the given {@code Locale}, the parent locale chain will be looked up, and\n+ * a {@code Locale} used that is supported.\n@@ -69,5 +81,8 @@\n- * <p>\n- * To obtain a {@code CompactNumberFormat} for a locale, use one\n- * of the factory methods given by {@code NumberFormat} for compact number\n- * formatting. For example,\n- * {@link NumberFormat#getCompactNumberInstance(Locale, Style)}.\n+ * <h2><a id=\"compact_number_style\">Style<\/a><\/h2>\n+ * When using {@link NumberFormat#getCompactNumberInstance(Locale, Style)}, a\n+ * compact form can be retrieved with either a {@link NumberFormat.Style#SHORT\n+ * SHORT} or {@link NumberFormat.Style#LONG LONG} style.\n+ * For example, a {@link NumberFormat.Style#SHORT SHORT} style compact number instance in\n+ * the {@link java.util.Locale#US US locale} formats {@code 10000} as {@code\n+ * \"10K\"}. However, a {@link NumberFormat.Style#LONG LONG} style instance in\n+ * the same locale formats {@code 10000} as {@code \"10 thousand\"}.\n@@ -75,5 +90,2 @@\n- * <blockquote>{@snippet lang=java :\n- * NumberFormat fmt = NumberFormat.getCompactNumberInstance(\n- *                             Locale.forLanguageTag(\"hi-IN\"), NumberFormat.Style.SHORT);\n- * String result = fmt.format(1000);\n- * }<\/blockquote>\n+ * <h2>Using CompactNumberFormat<\/h2>\n+ * The following is an example of formatting and parsing in a localized manner,\n@@ -81,14 +93,31 @@\n- * <h2><a id=\"compact_number_style\">Style<\/a><\/h2>\n- * <p>\n- * A number can be formatted in the compact forms with two different\n- * styles, {@link NumberFormat.Style#SHORT SHORT}\n- * and {@link NumberFormat.Style#LONG LONG}. Use\n- * {@link NumberFormat#getCompactNumberInstance(Locale, Style)} for formatting and\n- * parsing a number in {@link NumberFormat.Style#SHORT SHORT} or\n- * {@link NumberFormat.Style#LONG LONG} compact form,\n- * where the given {@code Style} parameter requests the desired\n- * format. A {@link NumberFormat.Style#SHORT SHORT} style\n- * compact number instance in the {@link java.util.Locale#US US locale} formats\n- * {@code 10000} as {@code \"10K\"}. However, a\n- * {@link NumberFormat.Style#LONG LONG} style instance in same locale\n- * formats {@code 10000} as {@code \"10 thousand\"}.\n+ * {@snippet lang=java :\n+ * NumberFormat compactFormat = NumberFormat.getCompactNumberInstance(Locale.US, NumberFormat.Style.SHORT);\n+ * compactFormat.format(1000); \/\/ returns \"1K\"\n+ * compactFormat.parse(\"1K\"); \/\/ returns 1000\n+ * }\n+ *\n+ * <h2 id=\"formatting\">Formatting<\/h2>\n+ * The default formatting behavior returns a formatted string with no fractional\n+ * digits, however users can use the {@link #setMinimumFractionDigits(int)}\n+ * method to include the fractional part.\n+ * The number {@code 1000.0} or {@code 1000} is formatted as {@code \"1K\"}\n+ * not {@code \"1.00K\"} (in the {@link java.util.Locale#US US locale}). For this\n+ * reason, the patterns provided for formatting contain only the minimum\n+ * integer digits, prefix and\/or suffix, but no fractional part.\n+ * For example, patterns used are {@code {\"\", \"\", \"\", 0K, 00K, ...}}. If the pattern\n+ * selected for formatting a number is {@code \"0\"} (special pattern),\n+ * either explicit or defaulted, then the general number formatting provided by\n+ * {@link java.text.DecimalFormat DecimalFormat}\n+ * for the specified locale is used.\n+ *\n+ * <h3>Rounding<\/h3>\n+ * {@code CompactNumberFormat} provides rounding modes defined in\n+ * {@link java.math.RoundingMode} for formatting.  By default, it uses\n+ * {@link java.math.RoundingMode#HALF_EVEN RoundingMode.HALF_EVEN}.\n+ *\n+ * <h2>Parsing<\/h2>\n+ * The default parsing behavior does not allow a grouping separator until\n+ * grouping used is set to {@code true} by using\n+ * {@link #setGroupingUsed(boolean)}. The parsing of the fractional part\n+ * depends on the {@link #isParseIntegerOnly()}. For example, if the\n+ * parse integer only is set to true, then the fractional part is skipped.\n@@ -98,3 +127,7 @@\n- * The compact number patterns are represented in a series of patterns where each\n- * pattern is used to format a range of numbers. An example of\n- * {@link NumberFormat.Style#SHORT SHORT} styled compact number patterns\n+ * The {@code compactPatterns} in {@link\n+ * CompactNumberFormat#CompactNumberFormat(String, DecimalFormatSymbols, String[])\n+ * CompactNumberFormat(decimalPattern, symbols, compactPatterns)} are represented\n+ * as a series of strings, where each string is a {@link ##compact_number_syntax\n+ * pattern} that is used to format a range of numbers.\n+ *\n+ * <p> An example of the {@link NumberFormat.Style#SHORT SHORT} styled compact number patterns\n@@ -106,5 +139,5 @@\n- * For example, in the above patterns, pattern at index 3\n- * ({@code \"0K\"}) is used for formatting {@code number >= 1000 and number < 10000},\n- * pattern at index 4 ({@code \"00K\"}) is used for formatting\n- * {@code number >= 10000 and number < 100000} and so on. In most of the locales,\n- * patterns with the range\n+ * For example, in the above patterns, the pattern at index 3\n+ * ({@code \"0K\"}) is used for formatting a number in the range: {@code 1000 <= number < 10000},\n+ * index 4 ({@code \"00K\"}) for formatting a number the range: {@code 10000 <=\n+ * number < 100000}, and so forth.\n+ * <p>In most locales, patterns with the range\n@@ -117,1 +150,1 @@\n- * <p>\n+ * <h3>Negative Subpatterns<\/h3>\n@@ -119,1 +152,1 @@\n- * separated by a subpattern boundary character {@code ';' (U+003B)},\n+ * separated by a subpattern boundary character {@code ';'},\n@@ -123,1 +156,1 @@\n- * minus sign ({@code '-' U+002D HYPHEN-MINUS}) is used as the negative\n+ * minus sign {@code '-' (U+002D HYPHEN-MINUS)} is used as the negative\n@@ -131,1 +164,1 @@\n- * <p>\n+ * <h4>Escaping Special Characters<\/h4>\n@@ -136,1 +169,1 @@\n- * characters. They must be quoted, using single quote {@code ' (U+0027)}\n+ * characters. These characters must be quoted using single quotes {@code ' (U+0027)}\n@@ -141,0 +174,8 @@\n+ * <p> {@code CompactNumberFormat} support patterns for both singular and plural\n+ * compact forms. For the plural form, the {@code Pattern} should consist\n+ * of {@code PluralPattern}(s) separated by a space ' ' (U+0020) that are enumerated\n+ * within a pair of curly brackets '{' (U+007B) and '}' (U+007D).\n+ * In this format, each {@code PluralPattern} consists of its {@code count},\n+ * followed by a single colon {@code ':' (U+003A)} and a {@code SimplePattern}.\n+ * As a space is reserved for separating subsequent {@code PluralPattern}s, it must\n+ * be quoted to be used literally in either the {@code prefix} or {@code suffix}.\n@@ -142,6 +183,5 @@\n- * In case some localization requires compact number patterns to be different for\n- * plurals, each singular and plural pattern can be enumerated within a pair of\n- * curly brackets <code>'{' (U+007B)<\/code> and <code>'}' (U+007D)<\/code>, separated\n- * by a space {@code ' ' (U+0020)}. If this format is used, each pattern needs to be\n- * prepended by its {@code count}, followed by a single colon {@code ':' (U+003A)}.\n- * If the pattern includes spaces literally, they must be quoted.\n+ * For example, while the pattern representing millions ({@code 10}<sup>{@code 6}\n+ * <\/sup>) in the US locale can be specified as the SimplePattern: {@code \"0 Million\"}, for the\n+ * German locale it can be specified as the PluralPattern:\n+ * {@code \"{one:0' 'Million other:0' 'Millionen}\"}.\n+ *\n@@ -149,3 +189,2 @@\n- * For example, the compact number pattern representing millions in German locale can be\n- * specified as {@code \"{one:0' 'Million other:0' 'Millionen}\"}. The {@code count}\n- * follows LDML's\n+ * <a id=\"compact_number_syntax\">A compact pattern has the following syntax, with {@code count}<\/a>\n+ * following LDML's\n@@ -153,3 +192,1 @@\n- * Language Plural Rules<\/a>.\n- * <p>\n- * A compact pattern has the following syntax:\n+ * Language Plural Rules<\/a>:\n@@ -182,26 +219,0 @@\n- * <h2>Formatting<\/h2>\n- * The default formatting behavior returns a formatted string with no fractional\n- * digits, however users can use the {@link #setMinimumFractionDigits(int)}\n- * method to include the fractional part.\n- * The number {@code 1000.0} or {@code 1000} is formatted as {@code \"1K\"}\n- * not {@code \"1.00K\"} (in the {@link java.util.Locale#US US locale}). For this\n- * reason, the patterns provided for formatting contain only the minimum\n- * integer digits, prefix and\/or suffix, but no fractional part.\n- * For example, patterns used are {@code {\"\", \"\", \"\", 0K, 00K, ...}}. If the pattern\n- * selected for formatting a number is {@code \"0\"} (special pattern),\n- * either explicit or defaulted, then the general number formatting provided by\n- * {@link java.text.DecimalFormat DecimalFormat}\n- * for the specified locale is used.\n- *\n- * <h2>Parsing<\/h2>\n- * The default parsing behavior does not allow a grouping separator until\n- * grouping used is set to {@code true} by using\n- * {@link #setGroupingUsed(boolean)}. The parsing of the fractional part\n- * depends on the {@link #isParseIntegerOnly()}. For example, if the\n- * parse integer only is set to true, then the fractional part is skipped.\n- *\n- * <h2>Rounding<\/h2>\n- * {@code CompactNumberFormat} provides rounding modes defined in\n- * {@link java.math.RoundingMode} for formatting.  By default, it uses\n- * {@link java.math.RoundingMode#HALF_EVEN RoundingMode.HALF_EVEN}.\n- *\n@@ -213,0 +224,1 @@\n+ * @see Locale\n@@ -392,2 +404,10 @@\n-     * {@code NumberFormat} for compact number formatting. For example,\n-     * {@link NumberFormat#getCompactNumberInstance(Locale, Style)}.\n+     * {@code NumberFormat} for compact number formatting.\n+     *\n+     * <p>Below is an example of using the constructor,\n+     *\n+     * {@snippet lang=java :\n+     * String[] compactPatterns = {\"\", \"\", \"\", \"a lot\"};\n+     * NumberFormat fmt = new CompactNumberFormat(\"00\", DecimalFormatSymbols.getInstance(Locale.US), compactPatterns);\n+     * fmt.format(1); \/\/ returns \"01\"\n+     * fmt.format(1000); \/\/ returns \"a lot\"\n+     * }\n@@ -395,1 +415,2 @@\n-     * @param decimalPattern a decimal pattern for general number formatting\n+     * @param decimalPattern a {@linkplain DecimalFormat##patterns decimal pattern}\n+     *                       for general number formatting\n@@ -422,1 +443,2 @@\n-     * @param decimalPattern a decimal pattern for general number formatting\n+     * @param decimalPattern a {@linkplain DecimalFormat##patterns decimal pattern}\n+     *                      for general number formatting\n","filename":"src\/java.base\/share\/classes\/java\/text\/CompactNumberFormat.java","additions":117,"deletions":95,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -59,4 +59,4 @@\n- * {@code NumberFormat} that formats decimal numbers. It has a variety of\n- * features designed to make it possible to parse and format numbers in any\n- * locale, including support for Western, Arabic, and Indic digits.  It also\n- * supports different kinds of numbers, including integers (123), fixed-point\n+ * {@code NumberFormat} that formats decimal numbers in a localized manner.\n+ * It has a variety of features designed to make it possible to parse and format\n+ * numbers in any locale, including support for Western, Arabic, and Indic digits.\n+ * It also supports different kinds of numbers, including integers (123), fixed-point\n@@ -64,14 +64,29 @@\n- * currency amounts ($123).  All of these can be localized.\n- *\n- * <p>To obtain a {@code NumberFormat} for a specific locale, including the\n- * default locale, call one of {@code NumberFormat}'s factory methods, such\n- * as {@code getInstance()}.  In general, do not call the\n- * {@code DecimalFormat} constructors directly, since the\n- * {@code NumberFormat} factory methods may return subclasses other than\n- * {@code DecimalFormat}. If you need to customize the format object, do\n- * something like this:\n- *\n- * <blockquote>{@snippet lang=java :\n- * NumberFormat numFormat = NumberFormat.getInstance(loc);\n- * if (numFormat instanceof DecimalFormat decFormat) {\n- *     decFormat.setDecimalSeparatorAlwaysShown(true);\n+ * currency amounts ($123).\n+ *\n+ * <h2>Getting a DecimalFormat<\/h2>\n+ *\n+ * To obtain a standard decimal format for a specific locale, including the default locale,\n+ * it is recommended to call one of the {@code NumberFormat}\n+ * {@link NumberFormat##factory_methods factory methods}, such as {@link NumberFormat#getInstance()}.\n+ * These factory methods may not always return a {@code DecimalFormat}\n+ * depending on the locale-service provider implementation\n+ * installed. Thus, to use an instance method defined by {@code DecimalFormat},\n+ * the {@code NumberFormat} returned by the factory method should be\n+ * type checked before converted to {@code DecimalFormat}. If the installed locale-sensitive\n+ * service implementation does not support the given {@code Locale}, the parent\n+ * locale chain will be looked up, and a {@code Locale} used that is supported.\n+ *\n+ * <p>If the factory methods are not desired, use one of the constructors such\n+ * as {@link #DecimalFormat(String) DecimalFormat(String pattern)}. See the {@link\n+ * ##patterns Pattern} section for more information on the {@code pattern} parameter.\n+ *\n+ * <h2>Using DecimalFormat<\/h2>\n+ * The following is an example of formatting and parsing,\n+ * {@snippet lang=java :\n+ * NumberFormat nFmt = NumberFormat.getCurrencyInstance(Locale.US);\n+ * if (nFmt instanceof DecimalFormat dFmt) {\n+ *     \/\/ pattern match to DecimalFormat to use setPositiveSuffix(String)\n+ *     dFmt.setPositiveSuffix(\" dollars\");\n+ *     dFmt.format(100000); \/\/ returns \"$100,000.00 dollars\"\n+ *     dFmt.parse(\"$100,000.00 dollars\"); \/\/ returns 100000\n+ * }\n@@ -79,1 +94,0 @@\n- * }<\/blockquote>\n@@ -81,6 +95,0 @@\n- * <p>A {@code DecimalFormat} comprises a <em>pattern<\/em> and a set of\n- * <em>symbols<\/em>.  The pattern may be set directly using\n- * {@code applyPattern()}, or indirectly using the API methods.  The\n- * symbols are stored in a {@code DecimalFormatSymbols} object.  When using\n- * the {@code NumberFormat} factory methods, the pattern and symbols are\n- * read from localized {@code ResourceBundle}s.\n@@ -88,1 +96,2 @@\n- * <h2 id=\"patterns\">Patterns<\/h2>\n+ * <h2 id=\"formatting\">Formatting and Parsing<\/h2>\n+ * <h3 id=\"rounding\">Rounding<\/h3>\n@@ -90,8 +99,58 @@\n- * Note: For any given {@code DecimalFormat} pattern, if the pattern is not\n- * in scientific notation, the maximum number of integer digits will not be\n- * derived from the pattern, and instead set to {@link Integer#MAX_VALUE}.\n- * Otherwise, if the pattern is in scientific notation, the maximum number of\n- * integer digits will be derived from the pattern. This derivation is detailed\n- * in the {@link ##scientific_notation Scientific Notation} section. This behavior\n- * is the typical end-user desire; {@link #setMaximumIntegerDigits(int)} can be\n- * used to manually adjust the maximum integer digits.\n+ * When formatting, {@code DecimalFormat} can adjust its rounding using {@link\n+ * #setRoundingMode(RoundingMode)}. By default, it uses\n+ * {@link java.math.RoundingMode#HALF_EVEN RoundingMode.HALF_EVEN}.\n+ *\n+ * <h3>Digits<\/h3>\n+ *\n+ * When formatting, {@code DecimalFormat} uses the ten consecutive\n+ * characters starting with the localized zero digit defined in the\n+ * {@code DecimalFormatSymbols} object as digits.\n+ * <p>When parsing, these digits as well as all Unicode decimal digits, as\n+ * defined by {@link Character#digit Character.digit}, are recognized.\n+ *\n+ * <h3 id=\"digit_limits\"> Integer and Fraction Digit Limits <\/h3>\n+ * @implSpec\n+ * When formatting a {@code Number} other than {@code BigInteger} and\n+ * {@code BigDecimal}, {@code 309} is used as the upper limit for integer digits,\n+ * and {@code 340} as the upper limit for fraction digits. This occurs, even if\n+ * one of the {@code DecimalFormat} getter methods, for example, {@link #getMinimumFractionDigits()}\n+ * returns a numerically greater value.\n+ *\n+ * <h3>Special Values<\/h3>\n+ * <ul>\n+ * <li><p><b>Not a Number<\/b> ({@code NaN}) is formatted as a string,\n+ * which is typically given as \"NaN\". This string is determined by {@link\n+ * DecimalFormatSymbols#getNaN()}. This is the only value for which the prefixes\n+ * and suffixes are not attached.\n+ *\n+ * <li><p><b>Infinity<\/b> is formatted as a string, which is typically given as\n+ * \"&#8734;\" ({@code U+221E}), with the positive or negative prefixes and suffixes\n+ * attached. This string is determined by {@link DecimalFormatSymbols#getInfinity()}.\n+ *\n+ * <li><p><b>Negative zero<\/b> ({@code \"-0\"}) parses to\n+ * <ul>\n+ * <li>{@code BigDecimal(0)} if {@code isParseBigDecimal()} is\n+ * true\n+ * <li>{@code Long(0)} if {@code isParseBigDecimal()} is false\n+ *     and {@code isParseIntegerOnly()} is true\n+ * <li>{@code Double(-0.0)} if both {@code isParseBigDecimal()}\n+ * and {@code isParseIntegerOnly()} are false\n+ * <\/ul>\n+ * <\/ul>\n+ *\n+ * <h2><a id=\"synchronization\">Synchronization<\/a><\/h2>\n+ *\n+ * <p>\n+ * Decimal formats are generally not synchronized.\n+ * It is recommended to create separate format instances for each thread.\n+ * If multiple threads access a format concurrently, it must be synchronized\n+ * externally.\n+ *\n+ * <h2 id=\"patterns\">DecimalFormat Pattern<\/h2>\n+ *\n+ * A {@code DecimalFormat} comprises a <em>pattern<\/em> and a set of\n+ * <em>symbols<\/em>. The pattern may be set directly using {@code applyPattern()},\n+ * or indirectly using the various API methods. The symbols are stored in a {@code\n+ * DecimalFormatSymbols} object. When using the {@code NumberFormat} factory\n+ * methods, the pattern and symbols are created from the locale-sensitive service\n+ * implementation installed.\n@@ -138,31 +197,0 @@\n- * <p>A {@code DecimalFormat} pattern contains a positive and negative\n- * subpattern, for example, {@code \"#,##0.00;(#,##0.00)\"}.  Each\n- * subpattern has a prefix, numeric part, and suffix. The negative subpattern\n- * is optional; if absent, then the positive subpattern prefixed with the\n- * minus sign ({@code '-' U+002D HYPHEN-MINUS}) is used as the\n- * negative subpattern. That is, {@code \"0.00\"} alone is equivalent to\n- * {@code \"0.00;-0.00\"}.  If there is an explicit negative subpattern, it\n- * serves only to specify the negative prefix and suffix; the number of digits,\n- * minimal digits, and other characteristics are all the same as the positive\n- * pattern. That means that {@code \"#,##0.0#;(#)\"} produces precisely\n- * the same behavior as {@code \"#,##0.0#;(#,##0.0#)\"}.\n- *\n- * <p>The prefixes, suffixes, and various symbols used for infinity, digits,\n- * grouping separators, decimal separators, etc. may be set to arbitrary\n- * values, and they will appear properly during formatting.  However, care must\n- * be taken that the symbols and strings do not conflict, or parsing will be\n- * unreliable.  For example, either the positive and negative prefixes or the\n- * suffixes must be distinct for {@code DecimalFormat.parse()} to be able\n- * to distinguish positive from negative values.  (If they are identical, then\n- * {@code DecimalFormat} will behave as if no negative subpattern was\n- * specified.)  Another example is that the decimal separator and grouping\n- * separator should be distinct characters, or parsing will be impossible.\n- *\n- * <p>The grouping separator is commonly used for thousands, but in some\n- * countries it separates ten-thousands. The grouping size is a constant number\n- * of digits between the grouping characters, such as 3 for 100,000,000 or 4 for\n- * 1,0000,0000.  If you supply a pattern with multiple grouping characters, the\n- * interval between the last one and the end of the integer is the one that is\n- * used. So {@code \"#,##,###,####\"} == {@code \"######,####\"} ==\n- * {@code \"##,####,####\"}.\n- *\n@@ -171,3 +199,2 @@\n- * <p>Many characters in a pattern are taken literally; they are matched during\n- * parsing and output unchanged during formatting.  Special characters, on the\n- * other hand, stand for other characters, strings, or classes of characters.\n+ * <p>The special characters in the table below are interpreted syntactically when\n+ * used in the DecimalFormat pattern.\n@@ -177,5 +204,8 @@\n- * <p>The characters listed here are used in non-localized patterns.  Localized\n- * patterns use the corresponding characters taken from this formatter's\n- * {@code DecimalFormatSymbols} object instead, and these characters lose\n- * their special status.  Two exceptions are the currency sign and quote, which\n- * are not localized.\n+ * <p> The characters in the {@code Symbol} column are used in non-localized\n+ * patterns. The corresponding characters in the {@code Localized Symbol} column are used\n+ * in localized patterns, with the characters in {@code Symbol} losing their\n+ * syntactical meaning. Two exceptions are the currency sign ({@code U+00A4}) and\n+ * quote ({@code U+0027}), which are not localized.\n+ * <p>\n+ * Non-localized patterns should be used when calling {@link #applyPattern(String)}.\n+ * Localized patterns should be used when calling {@link #applyLocalizedPattern(String)}.\n@@ -189,0 +219,1 @@\n+ *          <th scope=\"col\" style=\"text-align:left\">Localized Symbol\n@@ -190,2 +221,1 @@\n- *          <th scope=\"col\" style=\"text-align:left\">Localized?\n- *          <th scope=\"col\" style=\"text-align:left\">Meaning\n+ *          <th scope=\"col\" style=\"text-align:left;width:50%\">Meaning\n@@ -194,1 +224,1 @@\n- *     <tr style=\"vertical-align:top\">\n+ *     <tr>\n@@ -196,0 +226,1 @@\n+ *          <td>{@link DecimalFormatSymbols#getZeroDigit()}\n@@ -197,1 +228,0 @@\n- *          <td>Yes\n@@ -199,1 +229,1 @@\n- *     <tr style=\"vertical-align: top\">\n+ *     <tr>\n@@ -201,0 +231,1 @@\n+ *          <td>{@link DecimalFormatSymbols#getDigit()}\n@@ -202,1 +233,0 @@\n- *          <td>Yes\n@@ -204,1 +234,1 @@\n- *     <tr style=\"vertical-align:top\">\n+ *     <tr>\n@@ -206,0 +236,1 @@\n+ *          <td>{@link DecimalFormatSymbols#getDecimalSeparator()}\n@@ -207,1 +238,0 @@\n- *          <td>Yes\n@@ -209,2 +239,3 @@\n- *     <tr style=\"vertical-align: top\">\n- *          <th scope=\"row\">{@code -}\n+ *     <tr>\n+ *          <th scope=\"row\">{@code - (U+002D)}\n+ *          <td>{@link DecimalFormatSymbols#getMinusSign()}\n@@ -212,1 +243,0 @@\n- *          <td>Yes\n@@ -214,1 +244,1 @@\n- *     <tr style=\"vertical-align:top\">\n+ *     <tr>\n@@ -216,0 +246,1 @@\n+ *          <td>{@link DecimalFormatSymbols#getGroupingSeparator()}\n@@ -217,1 +248,0 @@\n- *          <td>Yes\n@@ -219,1 +249,1 @@\n- *     <tr style=\"vertical-align: top\">\n+ *     <tr>\n@@ -221,0 +251,1 @@\n+ *          <td>{@link DecimalFormatSymbols#getExponentSeparator()}\n@@ -222,4 +253,3 @@\n- *          <td>Yes\n- *          <td>Separates mantissa and exponent in scientific notation.\n- *              <em>Need not be quoted in prefix or suffix.<\/em>\n- *     <tr style=\"vertical-align:top\">\n+ *          <td>Separates mantissa and exponent in scientific notation. This value\n+ *              is case sensistive. <em>Need not be quoted in prefix or suffix.<\/em>\n+ *     <tr>\n@@ -227,0 +257,1 @@\n+ *          <td>{@link DecimalFormatSymbols#getPatternSeparator()}\n@@ -228,1 +259,0 @@\n- *          <td>Yes\n@@ -230,1 +260,1 @@\n- *     <tr style=\"vertical-align: top\">\n+ *     <tr>\n@@ -232,0 +262,1 @@\n+ *          <td>{@link DecimalFormatSymbols#getPercent()}\n@@ -233,1 +264,0 @@\n- *          <td>Yes\n@@ -235,2 +265,3 @@\n- *     <tr style=\"vertical-align:top\">\n- *          <th scope=\"row\">{@code U+2030}\n+ *     <tr>\n+ *          <th scope=\"row\">&permil; ({@code U+2030})\n+ *          <td>{@link DecimalFormatSymbols#getPerMill()}\n@@ -238,1 +269,0 @@\n- *          <td>Yes\n@@ -240,1 +270,1 @@\n- *     <tr style=\"vertical-align: top\">\n+ *     <tr>\n@@ -242,0 +272,1 @@\n+ *          <td> n\/a (not localized)\n@@ -243,1 +274,0 @@\n- *          <td>No\n@@ -248,2 +278,3 @@\n- *     <tr style=\"vertical-align:top\">\n- *          <th scope=\"row\">{@code '}\n+ *     <tr>\n+ *          <th scope=\"row\">{@code ' (U+0027)}\n+ *          <td> n\/a (not localized)\n@@ -251,1 +282,0 @@\n- *          <td>No\n@@ -260,0 +290,43 @@\n+ * <h3>Maximum Digits Derivation<\/h3>\n+ * For any given {@code DecimalFormat} pattern, if the pattern is not\n+ * in scientific notation, the maximum number of integer digits will not be\n+ * derived from the pattern, and instead set to {@link Integer#MAX_VALUE}.\n+ * Otherwise, if the pattern is in scientific notation, the maximum number of\n+ * integer digits will be derived from the pattern. This derivation is detailed\n+ * in the {@link ##scientific_notation Scientific Notation} section. {@link\n+ * #setMaximumIntegerDigits(int)} can be used to manually adjust the maximum\n+ * integer digits.\n+ *\n+ * <h3>Negative Subpatterns<\/h3>\n+ * A {@code DecimalFormat} pattern contains a positive and negative\n+ * subpattern, for example, {@code \"#,##0.00;(#,##0.00)\"}.  Each\n+ * subpattern has a prefix, numeric part, and suffix. The negative subpattern\n+ * is optional; if absent, then the positive subpattern prefixed with the\n+ * minus sign {@code '-' (U+002D HYPHEN-MINUS)} is used as the\n+ * negative subpattern. That is, {@code \"0.00\"} alone is equivalent to\n+ * {@code \"0.00;-0.00\"}.  If there is an explicit negative subpattern, it\n+ * serves only to specify the negative prefix and suffix; the number of digits,\n+ * minimal digits, and other characteristics are all the same as the positive\n+ * pattern. That means that {@code \"#,##0.0#;(#)\"} produces precisely\n+ * the same behavior as {@code \"#,##0.0#;(#,##0.0#)\"}.\n+ *\n+ * <p>The prefixes, suffixes, and various symbols used for infinity, digits,\n+ * grouping separators, decimal separators, etc. may be set to arbitrary\n+ * values, and they will appear properly during formatting.  However, care must\n+ * be taken that the symbols and strings do not conflict, or parsing will be\n+ * unreliable.  For example, either the positive and negative prefixes or the\n+ * suffixes must be distinct for {@code DecimalFormat.parse()} to be able\n+ * to distinguish positive from negative values.  (If they are identical, then\n+ * {@code DecimalFormat} will behave as if no negative subpattern was\n+ * specified.)  Another example is that the decimal separator and grouping\n+ * separator should be distinct characters, or parsing will be impossible.\n+ *\n+ * <h3>Grouping Separator<\/h3>\n+ * <p>The grouping separator is commonly used for thousands, but in some\n+ * locales it separates ten-thousands. The grouping size is a constant number\n+ * of digits between the grouping characters, such as 3 for 100,000,000 or 4 for\n+ * 1,0000,0000. If you supply a pattern with multiple grouping characters, the\n+ * interval between the last one and the end of the integer is the one that is\n+ * used. For example, {@code \"#,##,###,####\"} == {@code \"######,####\"} ==\n+ * {@code \"##,####,####\"}.\n+ *\n@@ -342,85 +415,2 @@\n- * <h3>Rounding<\/h3>\n- *\n- * {@code DecimalFormat} provides rounding modes defined in\n- * {@link java.math.RoundingMode} for formatting.  By default, it uses\n- * {@link java.math.RoundingMode#HALF_EVEN RoundingMode.HALF_EVEN}.\n- *\n- * <h3>Digits<\/h3>\n- *\n- * For formatting, {@code DecimalFormat} uses the ten consecutive\n- * characters starting with the localized zero digit defined in the\n- * {@code DecimalFormatSymbols} object as digits. For parsing, these\n- * digits as well as all Unicode decimal digits, as defined by\n- * {@link Character#digit Character.digit}, are recognized.\n- *\n- * <h3 id=\"digit_limits\"> Integer and Fraction Digit Limits <\/h3>\n- *\n- * @implSpec\n- * When formatting a {@code Number} other than {@code BigInteger} and\n- * {@code BigDecimal}, {@code 309} is used as the upper limit for integer digits,\n- * and {@code 340} as the upper limit for fraction digits. This occurs, even if\n- * one of the {@code DecimalFormat} getter methods, for example, {@link #getMinimumFractionDigits()}\n- * returns a numerically greater value.\n- *\n- * <h4>Special Values<\/h4>\n- *\n- * <p>Not a Number({@code NaN}) is formatted as a string, which typically has a\n- * single character {@code U+FFFD}.  This string is determined by the\n- * {@code DecimalFormatSymbols} object.  This is the only value for which\n- * the prefixes and suffixes are not used.\n- *\n- * <p>Infinity is formatted as a string, which typically has a single character\n- * {@code U+221E}, with the positive or negative prefixes and suffixes\n- * applied.  The infinity string is determined by the\n- * {@code DecimalFormatSymbols} object.\n- *\n- * <p>Negative zero ({@code \"-0\"}) parses to\n- * <ul>\n- * <li>{@code BigDecimal(0)} if {@code isParseBigDecimal()} is\n- * true,\n- * <li>{@code Long(0)} if {@code isParseBigDecimal()} is false\n- *     and {@code isParseIntegerOnly()} is true,\n- * <li>{@code Double(-0.0)} if both {@code isParseBigDecimal()}\n- * and {@code isParseIntegerOnly()} are false.\n- * <\/ul>\n- *\n- * <h3><a id=\"synchronization\">Synchronization<\/a><\/h3>\n- *\n- * <p>\n- * Decimal formats are generally not synchronized.\n- * It is recommended to create separate format instances for each thread.\n- * If multiple threads access a format concurrently, it must be synchronized\n- * externally.\n- *\n- * <h3>Example<\/h3>\n- *\n- * <blockquote>{@snippet lang=java :\n- * \/\/ Print out a number using the localized number, integer, currency,\n- * \/\/ and percent format for each locale\n- * Locale[] locales = NumberFormat.getAvailableLocales();\n- * double myNumber = -1234.56;\n- * NumberFormat form;\n- * for (int j = 0; j < 4; ++j) {\n- *     System.out.println(\"FORMAT\");\n- *     for (Locale locale : locales) {\n- *         if (locale.getCountry().length() == 0) {\n- *             continue; \/\/ Skip language-only locales\n- *         }\n- *         System.out.print(locale.getDisplayName());\n- *         form = switch (j) {\n- *             case 0 -> NumberFormat.getInstance(locale);\n- *             case 1 -> NumberFormat.getIntegerInstance(locale);\n- *             case 2 -> NumberFormat.getCurrencyInstance(locale);\n- *             default -> NumberFormat.getPercentInstance(locale);\n- *         };\n- *         if (form instanceof DecimalFormat decForm) {\n- *             System.out.print(\": \" + decForm.toPattern());\n- *         }\n- *         System.out.print(\" -> \" + form.format(myNumber));\n- *         try {\n- *             System.out.println(\" -> \" + form.parse(form.format(myNumber)));\n- *         } catch (ParseException e) {}\n- *     }\n- * }\n- * }<\/blockquote>\n- *\n+ * @spec         https:\/\/www.unicode.org\/reports\/tr35\n+ *               Unicode Locale Data Markup Language (LDML)\n@@ -431,0 +421,1 @@\n+ * @see          Locale\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":178,"deletions":187,"binary":false,"changes":365,"status":"modified"},{"patch":"@@ -62,2 +62,6 @@\n- * numbers. {@code NumberFormat} also provides methods for determining\n- * which locales have number formats, and what their names are.\n+ * numbers in a localized manner. This enables code that can be completely\n+ * independent of the locale conventions for decimal points, thousands-separators,\n+ * the particular decimal digits used, or whether the number format is even\n+ * decimal. For example, this class could be used within an application to\n+ * produce a number in a currency format according to the conventions of the desired\n+ * locale.\n@@ -65,5 +69,17 @@\n- * <p>\n- * {@code NumberFormat} helps you to format and parse numbers for any locale.\n- * Your code can be completely independent of the locale conventions for\n- * decimal points, thousands-separators, or even the particular decimal\n- * digits used, or whether the number format is even decimal.\n+ * <h2 id=\"factory_methods\">Getting a NumberFormat<\/h2>\n+ * To get a {@code NumberFormat} for the default Locale, use one of the static\n+ * factory methods that return a concrete subclass of {@code NumberFormat}.\n+ * The following formats all provide an example of formatting the {@code Number}\n+ * \"2000.50\" with the {@link java.util.Locale#US US} locale as the default locale.\n+ * <ul>\n+ * <li> Use {@link #getInstance()} or {@link #getNumberInstance()} to get\n+ * a decimal format. For example, {@code \"2,000.5\"}.\n+ * <li> Use {@link #getIntegerInstance()} to get an integer number format.\n+ * For example, {@code \"2,000\"}.\n+ * <li> Use {@link #getCurrencyInstance} to get a currency number format.\n+ * For example, {@code \"$2,000.50\"}.\n+ * <li> Use {@link #getCompactNumberInstance} to get a compact number format.\n+ * For example, {@code \"2K\"}.\n+ * <li> Use {@link #getPercentInstance} to get a format for displaying percentages.\n+ * For example, {@code \"200,050%\"}.\n+ * <\/ul>\n@@ -71,27 +87,5 @@\n- * <p>\n- * To format a number for the current Locale, use one of the factory\n- * class methods:\n- * <blockquote>\n- * {@snippet lang=java :\n- * myString = NumberFormat.getInstance().format(myNumber);\n- * }\n- * <\/blockquote>\n- * If you are formatting multiple numbers, it is\n- * more efficient to get the format and use it multiple times so that\n- * the system doesn't have to fetch the information about the local\n- * language and country conventions multiple times.\n- * <blockquote>\n- * {@snippet lang=java :\n- * NumberFormat nf = NumberFormat.getInstance();\n- * for (var myNumber : numbers) {\n- *     output.println(nf.format(myNumber) + \"; \");\n- * }\n- * }\n- * <\/blockquote>\n- * To format a number for a different Locale, specify it in the\n- * call to {@code getInstance}.\n- * <blockquote>\n- * {@snippet lang=java :\n- * NumberFormat nf = NumberFormat.getInstance(Locale.FRENCH);\n- * }\n- * <\/blockquote>\n+ * Alternatively, if a {@code NumberFormat} for a different locale is required, use\n+ * one of the overloaded factory methods that take {@code Locale} as a parameter,\n+ * for example, {@link #getIntegerInstance(Locale)}. If the installed locale-sensitive\n+ * service implementation does not support the given {@code Locale}, the parent\n+ * locale chain will be looked up, and a {@code Locale} used that is supported.\n@@ -99,1 +93,2 @@\n- * <p>If the locale contains \"nu\" (numbers) and\/or \"rg\" (region override)\n+ * <h3>Locale Extensions<\/h3>\n+ * Formatting behavior can be changed when using a locale that contains any of the following\n@@ -101,1 +96,12 @@\n- * the decimal digits, and\/or the country used for formatting are overridden.\n+ * <ul>\n+ * <li> \"nu\"\n+ * (<a href=\"https:\/\/unicode.org\/reports\/tr35\/#UnicodeNumberSystemIdentifier\">\n+ * Numbering System<\/a>) - Overrides the decimal digits used\n+ * <li> \"rg\"\n+ * (<a href=\"https:\/\/unicode.org\/reports\/tr35\/#RegionOverride\">\n+ * Region Override<\/a>) - Overrides the country used\n+ * <li> \"cf\"\n+ * (<a href=\"https:\/\/www.unicode.org\/reports\/tr35\/tr35.html#UnicodeCurrencyFormatIdentifier\">\n+ * Currency Format style<\/a>) - Overrides the Currency Format style used\n+ * <\/ul>\n+ * <p>\n@@ -104,0 +110,8 @@\n+ * Although <a href=\"..\/util\/Locale.html#def_locale_extension\">Unicode extensions<\/a>\n+ * defines various keys and values, actual locale-sensitive service implementations\n+ * in a Java Runtime Environment might not support any particular Unicode locale\n+ * attributes or key\/type pairs.\n+ * <p>Below is an example of a \"US\" locale currency format with accounting style,\n+ * <blockquote>{@code NumberFormat.getCurrencyInstance(Locale.forLanguageTag(\"en-US-u-cf-account\"));}<\/blockquote>\n+ * With this style, a negative value is formatted enclosed in parentheses, instead\n+ * of being prepended with a minus sign.\n@@ -105,2 +119,2 @@\n- * <p>You can also use a {@code NumberFormat} to parse numbers:\n- * <blockquote>\n+ * <h2>Using NumberFormat<\/h2>\n+ * The following is an example of formatting and parsing in a localized fashion,\n@@ -108,1 +122,3 @@\n- * myNumber = nf.parse(myString);\n+ * NumberFormat currencyFormat = NumberFormat.getCurrencyInstance(Locale.US);\n+ * currencyFormat.format(100000); \/\/ returns \"$100,000.00\"\n+ * currencyFormat.parse(\"$100,000.00\"); \/\/ returns 100000\n@@ -110,10 +126,0 @@\n- * <\/blockquote>\n- * Use {@code getInstance} or {@code getNumberInstance} to get the\n- * normal number format. Use {@code getIntegerInstance} to get an\n- * integer number format. Use {@code getCurrencyInstance} to get the\n- * currency number format. Use {@code getCompactNumberInstance} to get the\n- * compact number format to format a number in shorter form. For example,\n- * {@code 2000} can be formatted as {@code \"2K\"} in\n- * {@link java.util.Locale#US US locale}. Use {@code getPercentInstance}\n- * to get a format for displaying percentages. With this format, a fraction\n- * like 0.53 is displayed as 53%.\n@@ -121,10 +127,15 @@\n- * <p>\n- * You can also control the display of numbers with such methods as\n- * {@code setMinimumFractionDigits}.\n- * If you want even more control over the format or parsing,\n- * or want to give your users more control,\n- * you can try casting the {@code NumberFormat} you get from the factory methods\n- * to a {@code DecimalFormat} or {@code CompactNumberFormat} depending on\n- * the factory method used. This will work for the vast majority of locales;\n- * just remember to put it in a {@code try} block in case you encounter\n- * an unusual one.\n+ * <h2>Customizing NumberFormat<\/h2>\n+ * {@code NumberFormat} provides API to customize formatting and parsing behavior,\n+ * <ul>\n+ * <li> {@link #setParseIntegerOnly(boolean)}; when {@code true}, will only return the\n+ * integer portion of the number parsed from the String.\n+ * <li> {@link #setMinimumFractionDigits(int)}; Use to adjust the expected digits when\n+ * formatting. Use any of the other minimum\/maximum or fraction\/integer setter methods\n+ * in the same manner.\n+ * <li> {@link #setGroupingUsed(boolean)}; when {@code true}, formatted numbers will be displayed\n+ * with grouping separators. Additionally, when {@code false}, parsing will not expect\n+ * grouping separators in the parsed String.\n+ * <li> {@link #setStrict(boolean)}; when {@code true}, parsing will be done strictly.\n+ * The behavior of strict parsing should be referred to in the implementing\n+ * {@code NumberFormat} subclass.\n+ * <\/ul>\n@@ -133,18 +144,15 @@\n- * NumberFormat and DecimalFormat are designed such that some controls\n- * work for formatting and others work for parsing.  The following is\n- * the detailed description for each these control methods,\n- * <p>\n- * setParseIntegerOnly : only affects parsing, e.g.\n- * if true,  \"3456.78\" &rarr; 3456 (and leaves the parse position just after index 6)\n- * if false, \"3456.78\" &rarr; 3456.78 (and leaves the parse position just after index 8)\n- * This is independent of formatting.  If you want to not show a decimal point\n- * where there might be no digits after the decimal point, use\n- * setDecimalSeparatorAlwaysShown.\n- * <p>\n- * setDecimalSeparatorAlwaysShown : only affects formatting, and only where\n- * there might be no digits after the decimal point, such as with a pattern\n- * like \"#,##0.##\", e.g.,\n- * if true,  3456.00 &rarr; \"3,456.\"\n- * if false, 3456.00 &rarr; \"3456\"\n- * This is independent of parsing.  If you want parsing to stop at the decimal\n- * point, use setParseIntegerOnly.\n+ * To provide more control over formatting or parsing behavior, type checking can\n+ * be done to safely convert to an implementing subclass of {@code NumberFormat}; this\n+ * provides additional methods defined by the subclass.\n+ * For example,\n+ * {@snippet lang=java :\n+ * NumberFormat nFmt = NumberFormat.getInstance(Locale.US);\n+ * if (nFmt instanceof DecimalFormat dFmt) {\n+ *     dFmt.setDecimalSeparatorAlwaysShown(true);\n+ *     dFmt.format(100); \/\/ returns \"100.\"\n+ * }\n+ * }\n+ * The {@code NumberFormat} subclass returned by the factory methods is dependent\n+ * on the locale-service provider implementation installed, and may not always\n+ * be {@link DecimalFormat} or {@link CompactNumberFormat}.\n+ *\n@@ -156,2 +164,2 @@\n- * <li> progressively parse through pieces of a string\n- * <li> align the decimal point and other areas\n+ * <li> Progressively parse through pieces of a string\n+ * <li> Align the decimal point and other areas\n@@ -200,1 +208,4 @@\n- * @implSpec The {@link #format(double, StringBuffer, FieldPosition)},\n+ * @implSpec\n+ * Null Parameter Handling\n+ * <ul>\n+ * <li> The {@link #format(double, StringBuffer, FieldPosition)},\n@@ -206,0 +217,1 @@\n+ * <\/ul>\n@@ -207,2 +219,3 @@\n- * <p>\n- * The default implementation provides rounding modes defined\n+ * Default RoundingMode\n+ * <ul>\n+ * <li> The default implementation provides rounding modes defined\n@@ -217,0 +230,1 @@\n+ * <\/ul>\n@@ -218,0 +232,2 @@\n+ * @spec         https:\/\/www.unicode.org\/reports\/tr35\n+ *               Unicode Locale Data Markup Language (LDML)\n@@ -221,0 +237,1 @@\n+ * @see          Locale\n","filename":"src\/java.base\/share\/classes\/java\/text\/NumberFormat.java","additions":99,"deletions":82,"binary":false,"changes":181,"status":"modified"}]}