{"files":[{"patch":"@@ -1309,1 +1309,14 @@\n-\/\/ We make a tuple of the global input state + TOP for the output values.\n+\n+bool CallLeafPureNode::is_dead() const {\n+  return proj_out_or_null(TypeFunc::Control) == nullptr;\n+}\n+\n+\/* We make a tuple of the global input state + TOP for the output values.\n+ * We use this to delete a pure function that is not used: by replacing the call with\n+ * such a tuple, we let output Proj's idealization pick the corresponding input of the\n+ * pure call, so jumping over it, and effectively, removing the call from the graph.\n+ * This avoids doing the graph surgery manually, but leave that to IGVN\n+ * that is specialized for doing that right. We need also tuple components for output\n+ * values of the function to respect the return arity, and in case there is a projection\n+ * that would pick an output (which shouldn't happen at the moment).\n+ *\/\n@@ -1329,1 +1342,1 @@\n-  if (proj_out_or_null(TypeFunc::Control) == nullptr) { \/\/ dead node\n+  if (is_dead()) { \/\/ dead node\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -919,0 +919,1 @@\n+  bool is_dead() const;\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3302,0 +3302,1 @@\n+    \/\/ If the pure call is not supported, then lower to a CallLeaf.\n@@ -3311,2 +3312,2 @@\n-      for (unsigned int i = 0; i < call->tf()->domain()->cnt() - TypeFunc::Parms; i++) {\n-        new_call->init_req(TypeFunc::Parms + i, call->in(TypeFunc::Parms + i));\n+      for (unsigned int i = TypeFunc::Parms; i < call->tf()->domain()->cnt(); i++) {\n+        new_call->init_req(i, call->in(i));\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1523,1 +1523,1 @@\n-  if (proj_out_or_null(TypeFunc::Control) == nullptr) { \/\/ dead node\n+  if (is_dead()) { \/\/ dead node\n@@ -1577,1 +1577,1 @@\n-  if (proj_out_or_null(TypeFunc::Control) == nullptr) { \/\/ dead node\n+  if (is_dead()) { \/\/ dead node\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1915,0 +1915,2 @@\n+    \/\/ Pure function have only control (for now) and data output, in particular\n+    \/\/ the don't touch the memory, so we don't want a memory proj that is set after.\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -109,1 +109,16 @@\n-\/\/------------------------------TupleNode---------------------------------------\n+\/* Tuples are used to avoid manual graph surgery. When a node with Proj outputs (such as a call)\n+ * must be removed and its ouputs replaced by its input, or some other value, we can make its\n+ * ::Ideal return a tuple of what we want for each output: the ::Identity of output Proj will\n+ * take care to jump over the Tuple and directly pick up the right input of the Tuple.\n+ *\n+ * For instance, if a function call is proven to have no side effect and return the constant 0,\n+ * we can replace it with the 6-tuple:\n+ * (control input, IO input, memory input, frame ptr input, return addr input, Con:0)\n+ * all the output projections will pick up the input of the now gone call, except for the result\n+ * projection that is replaced by 0.\n+ *\n+ * Using TupleNode avoid manual graph surgery and leave that to our expert surgeon: IGVN.\n+ * Since the user of a Tuple are expected to be Proj, when creating a tuple during idealization,\n+ * the output Proj should be enqueued for IGVN immediately after, and the tuple should not survive\n+ * after the current IGVN.\n+ *\/\n@@ -127,0 +142,4 @@\n+  \/* Give as many `Node*` as you want in the `nn` pack:\n+   * TupleNode::make(tf, input1)\n+   * TupleNode::make(tf, input1, input2, input3, input4)\n+   *\/\n","filename":"src\/hotspot\/share\/opto\/multnode.hpp","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"}]}