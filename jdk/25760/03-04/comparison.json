{"files":[{"patch":"@@ -1519,19 +1519,1 @@\n-Node* ModFNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n-  Node* super = CallLeafPureNode::Ideal(phase, can_reshape);\n-  if (super != nullptr) {\n-    return super;\n-  }\n-\n-  if (!can_reshape) {\n-    return nullptr;\n-  }\n-\n-  PhaseIterGVN* igvn = phase->is_IterGVN();\n-\n-  \/\/ Either input is TOP ==> the result is TOP\n-  const Type* t1 = phase->type(dividend());\n-  const Type* t2 = phase->type(divisor());\n-  if (t1 == Type::TOP || t2 == Type::TOP) {\n-    return phase->C->top();\n-  }\n-\n+const Type* ModFNode::get_result_if_constant(const Type* dividend, const Type* divisor) const {\n@@ -1539,1 +1521,1 @@\n-  if ((t1->base() != Type::FloatCon) || (t2->base() != Type::FloatCon)) {\n+  if ((dividend->base() != Type::FloatCon) || (divisor->base() != Type::FloatCon)) {\n@@ -1543,4 +1525,4 @@\n-  float f1 = t1->getf();\n-  float f2 = t2->getf();\n-  jint x1 = jint_cast(f1); \/\/ note:  *(int*)&f1, not just (int)f1\n-  jint x2 = jint_cast(f2);\n+  float dividend_f = dividend->getf();\n+  float divisor_f = divisor->getf();\n+  jint dividend_i = jint_cast(dividend_f); \/\/ note:  *(int*)&f1, not just (int)f1\n+  jint divisor_i = jint_cast(divisor_f);\n@@ -1549,2 +1531,2 @@\n-  if (g_isnan(f1)) {\n-    return replace_with_con(igvn, t1);\n+  if (g_isnan(dividend_f)) {\n+    return dividend;\n@@ -1552,2 +1534,2 @@\n-  if (g_isnan(f2)) {\n-    return replace_with_con(igvn, t2);\n+  if (g_isnan(divisor_f)) {\n+    return divisor;\n@@ -1557,1 +1539,1 @@\n-  if (!g_isfinite(f1) || !g_isfinite(f2) || x2 == 0 || x2 == min_jint) {\n+  if (!g_isfinite(dividend_f) || !g_isfinite(divisor_f) || divisor_i == 0 || divisor_i == min_jint) {\n@@ -1563,2 +1545,2 @@\n-  jint xr = jint_cast(fmod(f1, f2));\n-  if ((x1 ^ xr) < 0) {\n+  jint xr = jint_cast(fmod(dividend_f, divisor_f));\n+  if ((dividend_i ^ xr) < 0) {\n@@ -1568,1 +1550,1 @@\n-  return replace_with_con(igvn, TypeF::make(jfloat_cast(xr)));\n+  return TypeF::make(jfloat_cast(xr));\n@@ -1571,19 +1553,1 @@\n-Node* ModDNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n-  Node* super = CallLeafPureNode::Ideal(phase, can_reshape);\n-  if (super != nullptr) {\n-    return super;\n-  }\n-\n-  if (!can_reshape) {\n-    return nullptr;\n-  }\n-\n-  PhaseIterGVN* igvn = phase->is_IterGVN();\n-\n-  \/\/ Either input is TOP ==> the result is TOP\n-  const Type* t1 = phase->type(dividend());\n-  const Type* t2 = phase->type(divisor());\n-  if (t1 == Type::TOP || t2 == Type::TOP) {\n-    return nullptr;\n-  }\n-\n+const Type* ModDNode::get_result_if_constant(const Type* dividend, const Type* divisor) const {\n@@ -1591,1 +1555,1 @@\n-  if ((t1->base() != Type::DoubleCon) || (t2->base() != Type::DoubleCon)) {\n+  if ((dividend->base() != Type::DoubleCon) || (divisor->base() != Type::DoubleCon)) {\n@@ -1595,4 +1559,4 @@\n-  double f1 = t1->getd();\n-  double f2 = t2->getd();\n-  jlong x1 = jlong_cast(f1); \/\/ note:  *(long*)&f1, not just (long)f1\n-  jlong x2 = jlong_cast(f2);\n+  double dividend_d = dividend->getd();\n+  double divisor_d = divisor->getd();\n+  jlong dividend_l = jlong_cast(dividend_d); \/\/ note:  *(long*)&f1, not just (long)f1\n+  jlong divisor_l = jlong_cast(divisor_d);\n@@ -1601,2 +1565,2 @@\n-  if (g_isnan(f1)) {\n-    return replace_with_con(igvn, t1);\n+  if (g_isnan(dividend_d)) {\n+    return dividend;\n@@ -1604,2 +1568,2 @@\n-  if (g_isnan(f2)) {\n-    return replace_with_con(igvn, t2);\n+  if (g_isnan(divisor_d)) {\n+    return divisor;\n@@ -1609,1 +1573,1 @@\n-  if (!g_isfinite(f1) || !g_isfinite(f2) || x2 == 0 || x2 == min_jlong) {\n+  if (!g_isfinite(dividend_d) || !g_isfinite(divisor_d) || divisor_l == 0 || divisor_l == min_jlong) {\n@@ -1615,2 +1579,2 @@\n-  jlong xr = jlong_cast(fmod(f1, f2));\n-  if ((x1 ^ xr) < 0) {\n+  jlong xr = jlong_cast(fmod(dividend_d, divisor_d));\n+  if ((dividend_l ^ xr) < 0) {\n@@ -1620,1 +1584,20 @@\n-  return replace_with_con(igvn, TypeD::make(jdouble_cast(xr)));\n+  return TypeD::make(jdouble_cast(xr));\n+}\n+\n+Node* ModFloatingNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (can_reshape) {\n+    PhaseIterGVN* igvn = phase->is_IterGVN();\n+\n+    \/\/ Either input is TOP ==> the result is TOP\n+    const Type* dividend_type = phase->type(dividend());\n+    const Type* divisor_type = phase->type(divisor());\n+    if (dividend_type == Type::TOP || divisor_type == Type::TOP) {\n+      return phase->C->top();\n+    }\n+    const Type* constant_result = get_result_if_constant(dividend_type, divisor_type);\n+    if (constant_result != nullptr) {\n+      return make_tuple_of_input_state_and_constant_result(igvn, constant_result);\n+    }\n+  }\n+\n+  return CallLeafPureNode::Ideal(phase, can_reshape);\n@@ -1623,2 +1606,5 @@\n-Node* ModFloatingNode::replace_with_con(PhaseIterGVN* phase, const Type* con) {\n-  Compile* C = phase->C;\n+\/* Give a tuple node for ::Ideal to return, made of the input state (control to return addr)\n+ * and the given constant result. Idealization of projections will make sure to transparently\n+ * propagate the input state and replace the result by the said constant.\n+ *\/\n+TupleNode* ModFloatingNode::make_tuple_of_input_state_and_constant_result(PhaseIterGVN* phase, const Type* con) const {\n@@ -1626,10 +1612,10 @@\n-  CallProjections projs;\n-  extract_projections(&projs, false, false);\n-  phase->replace_node(projs.fallthrough_proj, in(TypeFunc::Control));\n-  if (projs.resproj != nullptr) {\n-    phase->replace_node(projs.resproj, con_node);\n-  }\n-  phase->replace_node(this, C->top());\n-  C->remove_macro_node(this);\n-  disconnect_inputs(C);\n-  return nullptr;\n+  TupleNode* tuple = TupleNode::make(\n+      tf()->range(),\n+      in(TypeFunc::Control),\n+      in(TypeFunc::I_O),\n+      in(TypeFunc::Memory),\n+      in(TypeFunc::FramePtr),\n+      in(TypeFunc::ReturnAdr),\n+      con_node);\n+\n+  return tuple;\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":62,"deletions":76,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -160,0 +160,2 @@\n+  TupleNode* make_tuple_of_input_state_and_constant_result(PhaseIterGVN* phase, const Type* con) const;\n+\n@@ -161,1 +163,3 @@\n-  Node* replace_with_con(PhaseIterGVN* phase, const Type* con);\n+  virtual Node* dividend() const = 0;\n+  virtual Node* divisor() const = 0;\n+  virtual const Type* get_result_if_constant(const Type* dividend, const Type* divisor) const = 0;\n@@ -165,0 +169,1 @@\n+  Node* Ideal(PhaseGVN* phase, bool can_reshape) override;\n@@ -170,2 +175,3 @@\n-  Node* dividend() const { return in(TypeFunc::Parms + 0); }\n-  Node* divisor() const { return in(TypeFunc::Parms + 1); }\n+  Node* dividend() const override { return in(TypeFunc::Parms + 0); }\n+  Node* divisor() const override { return in(TypeFunc::Parms + 1); }\n+  const Type* get_result_if_constant(const Type* dividend, const Type* divisor) const override;\n@@ -175,4 +181,3 @@\n-  virtual int Opcode() const;\n-  virtual uint ideal_reg() const { return Op_RegF; }\n-  virtual uint size_of() const { return sizeof(*this); }\n-  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  int Opcode() const override;\n+  uint ideal_reg() const override { return Op_RegF; }\n+  uint size_of() const override { return sizeof(*this); }\n@@ -184,2 +189,3 @@\n-  Node* dividend() const { return in(TypeFunc::Parms + 0); }\n-  Node* divisor() const { return in(TypeFunc::Parms + 2); }\n+  Node* dividend() const override { return in(TypeFunc::Parms + 0); }\n+  Node* divisor() const override { return in(TypeFunc::Parms + 2); }\n+  const Type* get_result_if_constant(const Type* dividend, const Type* divisor) const override;\n@@ -189,4 +195,3 @@\n-  virtual int Opcode() const;\n-  virtual uint ideal_reg() const { return Op_RegD; }\n-  virtual uint size_of() const { return sizeof(*this); }\n-  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  int Opcode() const override;\n+  uint ideal_reg() const override { return Op_RegD; }\n+  uint size_of() const override { return sizeof(*this); }\n","filename":"src\/hotspot\/share\/opto\/divnode.hpp","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"}]}