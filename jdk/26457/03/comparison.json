{"files":[{"patch":"@@ -1635,0 +1635,2 @@\n+    } else if (VectorNode::is_reinterpret_opcode(opc)) {\n+      retValue = Matcher::match_rule_supported_auto_vectorization(Op_VectorReinterpret, size, velt_basic_type(p0));\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -985,0 +985,4 @@\n+    case Op_MoveF2I:\n+    case Op_MoveD2L:\n+    case Op_MoveL2D:\n+    case Op_MoveI2F:\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -398,1 +398,1 @@\n-    \/\/ Would be nice to vectorize: Missing support for CmpF, CMove and MoveF2I.\n+    \/\/ Would be nice to vectorize: Missing support for CmpF and CMove.\n@@ -407,1 +407,3 @@\n-    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\"},\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  IRNode.VECTOR_REINTERPRET, \"> 0\"},\n@@ -410,1 +412,0 @@\n-    \/\/ Missing support for MoveF2I\n@@ -419,1 +420,3 @@\n-    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\"},\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  IRNode.VECTOR_REINTERPRET, \"> 0\"},\n@@ -422,1 +425,0 @@\n-    \/\/ Missing support for MoveI2F\n@@ -434,1 +436,1 @@\n-    \/\/ Missing support for Needs CmpD, CMove and MoveD2L\n+    \/\/ Missing support to vectorize CmpD and CMove\n@@ -443,1 +445,3 @@\n-    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\"},\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  IRNode.VECTOR_REINTERPRET, \"> 0\"},\n@@ -446,1 +450,0 @@\n-    \/\/ Missing support for MoveD2L\n@@ -455,1 +458,3 @@\n-    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\"},\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  IRNode.VECTOR_REINTERPRET, \"> 0\"},\n@@ -458,1 +463,0 @@\n-    \/\/ Missing support for MoveL2D\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestCompatibleUseDefTypeSize.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2025 IBM Corporation. All rights reserved.\n@@ -265,0 +266,14 @@\n+    @Benchmark\n+    public void convertD2LBits() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resL[i] = Double.doubleToLongBits(doubles[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convertD2LBitsRaw() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resL[i] = Double.doubleToRawLongBits(doubles[i]);\n+        }\n+    }\n+\n@@ -272,0 +287,14 @@\n+    @Benchmark\n+    public void convertF2IBits() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resI[i] = Float.floatToIntBits(floats[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convertF2IBitsRaw() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resI[i] = (int) Float.floatToRawIntBits(floats[i]);\n+        }\n+    }\n+\n@@ -307,0 +336,7 @@\n+    @Benchmark\n+    public void convertIBits2F() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resF[i] = Float.intBitsToFloat(ints[i]);\n+        }\n+    }\n+\n@@ -328,0 +364,7 @@\n+    @Benchmark\n+    public void convertLBits2D() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resD[i] = Double.longBitsToDouble(longs[i]);\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/TypeVectorOperations.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"}]}