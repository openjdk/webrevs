{"files":[{"patch":"@@ -179,0 +179,10 @@\n+\t<LI><P><B>{@systemProperty http.keepAlive.time.server}<\/B> and\n+        <B>{@systemProperty http.keepAlive.time.proxy}<\/B> <\/P>\n+\t<P>These properties modify the behavior of the HTTP keepalive cache in the case\n+        where the server (or proxy) has not specified a keepalive time. If the\n+        property is set in this case, then idle connections will be closed after the \n+        specified number of seconds. If the property is set, and the server does\n+        specify a keepalive time in a \"Keep-Alive\" response header, then the time specified \n+        by the server is used. If the property is not set and also the server\n+        does not specify a keepalive time, then connections are kept alive for an\n+        implementation defined time, assuming {@code http.keepAlive} is {@code true}.<\/P>\n","filename":"src\/java.base\/share\/classes\/java\/net\/doc-files\/net-properties.html","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -125,7 +125,7 @@\n-    \/**Idle timeout value, in milliseconds. Zero means infinity,\n-     * iff keepingAlive=true.\n-     * Unfortunately, we can't always believe this one.  If I'm connected\n-     * through a Netscape proxy to a server that sent me a keep-alive\n-     * time of 15 sec, the proxy unilaterally terminates my connection\n-     * after 5 sec.  So we have to hard code our effective timeout to\n-     * 4 sec for the case where we're using a proxy. *SIGH*\n+    \/*\n+     * The timeout if specified by the server. Following values possible\n+     *  0: the server specified no keep alive headers\n+     * -1: the server provided \"Connection: keep-alive\" but did not specify a\n+     *     a particular time in a \"Keep-Alive:\" headers\n+     * Positive values are the number of seconds specified by the server\n+     * in a \"Keep-Alive\" header\n@@ -238,1 +238,0 @@\n-\n@@ -901,1 +900,1 @@\n-                        keepAliveTimeout = p.findInt(\"timeout\", usingProxy?60:5);\n+                        keepAliveTimeout = p.findInt(\"timeout\", -1);\n@@ -1154,0 +1153,4 @@\n+    public boolean getUsingProxy() {\n+        return usingProxy;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/HttpClient.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+import sun.net.www.protocol.http.HttpURLConnection;\n+import sun.util.logging.PlatformLogger;\n@@ -57,0 +59,26 @@\n+    \/\/ Keep alive time set according to priority specified here:\n+    \/\/ 1. If server specifies a time with a Keep-Alive header\n+    \/\/ 2. If user specifies a time with system property below\n+    \/\/ 3. Default values which depend on proxy vs server and whether\n+    \/\/    a Connection: keep-alive header was sent by server\n+\n+    \/\/ name suffixed with \"server\" or \"proxy\"\n+    private static final String keepAliveProp = \"http.keepAlive.time.\";\n+\n+    private static final int userKeepAliveServer;\n+    private static final int userKeepAliveProxy;\n+\n+    static final PlatformLogger logger = HttpURLConnection.getHttpLogger();\n+\n+    @SuppressWarnings(\"removal\")\n+    static int getUserKeepAliveSeconds(String type) {\n+        int v = AccessController.doPrivileged(\n+            new GetIntegerAction(keepAliveProp+type, -1)).intValue();\n+        return v < -1 ? -1 : v;\n+    }\n+\n+    static {\n+        userKeepAliveServer = getUserKeepAliveSeconds(\"server\");\n+        userKeepAliveProxy = getUserKeepAliveSeconds(\"proxy\");\n+    }\n+\n@@ -130,4 +158,23 @@\n-                v = new ClientVector(keepAliveTimeout > 0 ?\n-                        keepAliveTimeout * 1000 : LIFETIME);\n-                v.put(http);\n-                super.put(key, v);\n+                if (keepAliveTimeout == 0) {\n+                    keepAliveTimeout = getUserKeepAlive(http.getUsingProxy());\n+                    if (keepAliveTimeout == -1) {\n+                        \/\/ same default for server and proxy\n+                        keepAliveTimeout = 5;\n+                    }\n+                } else if (keepAliveTimeout == -1) {\n+                    keepAliveTimeout = getUserKeepAlive(http.getUsingProxy());\n+                    if (keepAliveTimeout == -1) {\n+                        \/\/ different default for server and proxy\n+                        keepAliveTimeout = http.getUsingProxy() ? 60 : 5;\n+                    }\n+                }\n+                \/\/ at this point keepAliveTimeout is the number of seconds to keep\n+                \/\/ alive, which could be 0, if the user specified 0 for the property\n+                assert keepAliveTimeout >= 0;\n+                if (keepAliveTimeout == 0) {\n+                    http.closeServer();\n+                } else {\n+                    v = new ClientVector(keepAliveTimeout * 1000);\n+                    v.put(http);\n+                    super.put(key, v);\n+                }\n@@ -142,0 +189,5 @@\n+    \/\/ returns the keep alive set by user in system property or -1 if not set\n+    private static int getUserKeepAlive(boolean isProxy) {\n+        return isProxy ? userKeepAliveProxy : userKeepAliveServer;\n+    }\n+\n@@ -280,0 +332,5 @@\n+                    if (KeepAliveCache.logger.isLoggable(PlatformLogger.Level.FINEST)) {\n+                        String msg = \"cached HttpClient was idle for \"\n+                                + Long.toString(currentTime - e.idleStartTime);\n+                        KeepAliveCache.logger.finest(msg);\n+                    }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/KeepAliveCache.java","additions":61,"deletions":4,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @bug 8278067\n+ * @run main\/othervm -Dhttp.keepAlive.time.server=30 KeepAliveProperty long\n+ * @run main\/othervm -Dhttp.keepAlive.time.server=1 KeepAliveProperty short\n+ * @run main\/othervm -ea -Dhttp.keepAlive.time.server=0 KeepAliveProperty short\n+ *\/\n+\n+import java.net.*;\n+import java.io.*;\n+import java.nio.charset.*;\n+import java.util.logging.*;\n+import jdk.test.lib.net.URIBuilder;\n+import static java.net.Proxy.NO_PROXY;\n+\n+public class KeepAliveProperty {\n+\n+    static volatile boolean pass = false;\n+\n+    static class Server extends Thread {\n+        final ServerSocket server;\n+\n+        Server (ServerSocket server) {\n+            super ();\n+            this.server = server;\n+        }\n+\n+        void readAll (Socket s) throws IOException {\n+            byte[] buf = new byte [128];\n+            int c;\n+            String request = \"\";\n+            InputStream is = s.getInputStream ();\n+            while ((c=is.read(buf)) > 0) {\n+                request += new String(buf, 0, c, StandardCharsets.US_ASCII);\n+                if (request.contains(\"\\r\\n\\r\\n\")) {\n+                    return;\n+                }\n+            }\n+            if (c == -1)\n+                throw new IOException(\"Socket closed\");\n+        }\n+\n+        Socket s = null;\n+        String BODY;\n+        String CLEN;\n+        PrintStream out;\n+\n+        public void run() {\n+            try {\n+                s = server.accept();\n+                readAll(s);\n+\n+                BODY = \"Hello world\";\n+                CLEN = \"Content-Length: \" + BODY.length() + \"\\r\\n\";\n+                out = new PrintStream(new BufferedOutputStream(s.getOutputStream() ));\n+\n+                \/* send the header *\/\n+                out.print(\"HTTP\/1.1 200 OK\\r\\n\");\n+                out.print(\"Content-Type: text\/plain; charset=iso-8859-1\\r\\n\");\n+                out.print(CLEN);\n+                out.print(\"\\r\\n\");\n+                out.print(BODY);\n+                out.flush();\n+            } catch (Exception e) {\n+                pass = false;\n+                try {\n+                    if (s != null)\n+                        s.close();\n+                    server.close();\n+                } catch (IOException unused) {}\n+                return;\n+            }\n+\n+            \/\/ second request may legitimately fail\n+\n+            try (Socket s2 = s; ServerSocket server2 = server; PrintStream out2 = out) {\n+                \/\/ wait for second request.\n+                readAll(s2);\n+\n+                BODY = \"Goodbye world\";\n+                CLEN = \"Content-Length: \" + BODY.length() + \"\\r\\n\";\n+\n+                \/* send the header *\/\n+                out2.print(\"HTTP\/1.1 200 OK\\r\\n\");\n+                out2.print(\"Content-Type: text\/plain; charset=iso-8859-1\\r\\n\");\n+                out2.print(CLEN);\n+                out2.print(\"\\r\\n\");\n+                out2.print(BODY);\n+                out2.flush();\n+                pass = !expectClose;\n+                if (!pass) System.out.println(\"Failed: expected close\");\n+            } catch (Exception e) {\n+                pass = expectClose;\n+                if (!pass) System.out.println(\"Failed: did not expect close\");\n+            }\n+        }\n+    }\n+\n+    static String fetch(URL url) throws Exception {\n+        InputStream in = url.openConnection(NO_PROXY).getInputStream();\n+        String s = \"\";\n+        byte b[] = new byte[128];\n+        int n;\n+        do {\n+            n = in.read(b);\n+            if (n > 0)\n+                s += new String(b, 0, n, StandardCharsets.US_ASCII);\n+        } while (n > 0);\n+        in.close();\n+        return s;\n+    }\n+\n+    static volatile boolean expectClose;\n+\n+    public static void main(String args[]) throws Exception {\n+        \/\/ exercise the logging code\n+        Logger logger = Logger.getLogger(\"sun.net.www.protocol.http.HttpURLConnection\");\n+        logger.setLevel(Level.FINEST);\n+        ConsoleHandler h = new ConsoleHandler();\n+        h.setLevel(Level.FINEST);\n+        logger.addHandler(h);\n+\n+        expectClose = args[0].equals(\"short\");\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        ServerSocket ss = new ServerSocket();\n+        ss.bind(new InetSocketAddress(loopback, 0));\n+        Server s = new Server(ss);\n+        s.start();\n+\n+        URL url = URIBuilder.newBuilder()\n+            .scheme(\"http\")\n+            .loopback()\n+            .port(ss.getLocalPort())\n+            .toURL();\n+        System.out.println(\"URL: \" + url);\n+\n+        if (!fetch(url).equals(\"Hello world\"))\n+            throw new RuntimeException(\"Failed on first request\");\n+\n+        \/\/ Wait a while to see if connection is closed\n+        Thread.sleep(3 * 1000);\n+\n+        try {\n+            if (!fetch(url).equals(\"Goodbye world\"))\n+                throw new RuntimeException(\"Failed on second request\");\n+        } catch (Exception e) {\n+            if (!expectClose)\n+                throw e;\n+        }\n+\n+        if (!pass)\n+            throw new RuntimeException(\"Failed in server\");\n+    }\n+}\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveCache\/KeepAliveProperty.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"}]}