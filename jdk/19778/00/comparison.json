{"files":[{"patch":"@@ -161,1 +161,1 @@\n-        comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib powrprof.lib uuid.lib \\\n+        comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib powrprof.lib synchronization.lib uuid.lib \\\n","filename":"make\/autoconf\/libraries.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5484,31 +5484,0 @@\n-\/\/ An Event wraps a win32 \"CreateEvent\" kernel handle.\n-\/\/\n-\/\/ We have a number of choices regarding \"CreateEvent\" win32 handle leakage:\n-\/\/\n-\/\/ 1:  When a thread dies return the Event to the EventFreeList, clear the ParkHandle\n-\/\/     field, and call CloseHandle() on the win32 event handle.  Unpark() would\n-\/\/     need to be modified to tolerate finding a null (invalid) win32 event handle.\n-\/\/     In addition, an unpark() operation might fetch the handle field, but the\n-\/\/     event could recycle between the fetch and the SetEvent() operation.\n-\/\/     SetEvent() would either fail because the handle was invalid, or inadvertently work,\n-\/\/     as the win32 handle value had been recycled.  In an ideal world calling SetEvent()\n-\/\/     on an stale but recycled handle would be harmless, but in practice this might\n-\/\/     confuse other non-Sun code, so it's not a viable approach.\n-\/\/\n-\/\/ 2:  Once a win32 event handle is associated with an Event, it remains associated\n-\/\/     with the Event.  The event handle is never closed.  This could be construed\n-\/\/     as handle leakage, but only up to the maximum # of threads that have been extant\n-\/\/     at any one time.  This shouldn't be an issue, as windows platforms typically\n-\/\/     permit a process to have hundreds of thousands of open handles.\n-\/\/\n-\/\/ 3:  Same as (1), but periodically, at stop-the-world time, rundown the EventFreeList\n-\/\/     and release unused handles.\n-\/\/\n-\/\/ 4:  Add a CRITICAL_SECTION to the Event to protect LD+SetEvent from LD;ST(null);CloseHandle.\n-\/\/     It's not clear, however, that we wouldn't be trading one type of leak for another.\n-\/\/\n-\/\/ 5.  Use an RCU-like mechanism (Read-Copy Update).\n-\/\/     Or perhaps something similar to Maged Michael's \"Hazard pointers\".\n-\/\/\n-\/\/ We use (2).\n-\/\/\n@@ -5569,1 +5538,0 @@\n-  guarantee(_ParkHandle != nullptr , \"Invariant\");\n@@ -5572,2 +5540,0 @@\n-  \/\/ CONSIDER: defer assigning a CreateEvent() handle to the Event until\n-  \/\/ the initial park() operation.\n@@ -5585,3 +5551,0 @@\n-  \/\/ TODO: consider a brief spin here, gated on the success of recent\n-  \/\/ spin attempts by this thread.\n-  \/\/\n@@ -5591,8 +5554,0 @@\n-  \/\/ We trust the WAIT_TIMEOUT indication and don't track the elapsed wait time\n-  \/\/ with os::javaTimeNanos().  Furthermore, we assume that spurious returns from\n-  \/\/ ::WaitForSingleObject() caused by latent ::setEvent() operations will tend\n-  \/\/ to happen early in the wait interval.  Specifically, after a spurious wakeup (rv ==\n-  \/\/ WAIT_OBJECT_0 but _Event is still < 0) we don't bother to recompute Millis to compensate\n-  \/\/ for the already waited time.  This policy does not admit any new outcomes.\n-  \/\/ In the future, however, we might want to track the accumulated wait time and\n-  \/\/ adjust Millis accordingly if we encounter a spurious wakeup.\n@@ -5601,3 +5556,6 @@\n-  DWORD rv = WAIT_TIMEOUT;\n-  while (_Event < 0 && Millis > 0) {\n-    DWORD prd = Millis;     \/\/ set prd = MAX (Millis, MAXTIMEOUT)\n+  jlong waitStart = os::javaTimeNanos();\n+  \/\/ preserve initial millis for remaining time calculation on spurious wakeup\n+  jlong initialMillis = Millis;\n+  BOOL rv;\n+  while ((v = _Event) < 0 && Millis > 0) {\n+    DWORD prd = Millis;     \/\/ set prd = MIN (Millis, MAXTIMEOUT)\n@@ -5611,4 +5569,4 @@\n-    rv = ::WaitForSingleObject(_ParkHandle, prd);\n-    assert(rv != WAIT_FAILED,   \"WaitForSingleObject failed with error code: %lu\", GetLastError());\n-    assert(rv == WAIT_OBJECT_0 || rv == WAIT_TIMEOUT, \"WaitForSingleObject failed with return value: %lu\", rv);\n-    if (rv == WAIT_TIMEOUT) {\n+\n+    rv = ::WaitOnAddress(&_Event, &v, sizeof(_Event), prd);\n+    if (!rv) {\n+      assert(GetLastError() == ERROR_TIMEOUT, \"WaitOnAddress failed with error code: %lu\", GetLastError());\n@@ -5616,0 +5574,5 @@\n+    } else if (_Event < 0) { \/\/ spurious wakeup\n+      \/\/ calculate the time remaining\n+      jlong waitEnd = os::javaTimeNanos();\n+      jlong millisPassed = (waitEnd - waitStart) \/ 1000000;\n+      Millis = initialMillis - millisPassed;\n@@ -5635,1 +5598,0 @@\n-  guarantee(_ParkHandle != nullptr, \"Invariant\");\n@@ -5646,0 +5608,1 @@\n+  v = -1;\n@@ -5648,2 +5611,0 @@\n-  \/\/ TODO: consider a brief spin here, gated on the success of recent\n-  \/\/ spin attempts by this thread.\n@@ -5651,3 +5612,2 @@\n-    DWORD rv = ::WaitForSingleObject(_ParkHandle, INFINITE);\n-    assert(rv != WAIT_FAILED,   \"WaitForSingleObject failed with error code: %lu\", GetLastError());\n-    assert(rv == WAIT_OBJECT_0, \"WaitForSingleObject failed with return value: %lu\", rv);\n+    BOOL rv = ::WaitOnAddress(&_Event, &v, sizeof(_Event), INFINITE);\n+    assert(rv, \"WaitOnAddress failed with error code: %lu\", GetLastError());\n@@ -5665,1 +5625,0 @@\n-  guarantee(_ParkHandle != nullptr, \"Invariant\");\n@@ -5682,2 +5641,1 @@\n-\n-  ::SetEvent(_ParkHandle);\n+  ::WakeByAddressSingle((PVOID)&_Event);\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":19,"deletions":61,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-    HANDLE _ParkHandle ;\n@@ -44,2 +43,0 @@\n-      _ParkHandle = CreateEvent (nullptr, false, false, nullptr) ;\n-      guarantee (_ParkHandle != nullptr, \"invariant\") ;\n","filename":"src\/hotspot\/os\/windows\/park_windows.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"}]}