{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -320,1 +318,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -328,7 +325,4 @@\n-                AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n-                    MarshalledObjectInputStream.this.setObjectInputFilter(filter);\n-                    if (MarshalledObjectInputStream.this.locIn != null) {\n-                        MarshalledObjectInputStream.this.locIn.setObjectInputFilter(filter);\n-                    }\n-                    return null;\n-                });\n+                MarshalledObjectInputStream.this.setObjectInputFilter(filter);\n+                if (MarshalledObjectInputStream.this.locIn != null) {\n+                    MarshalledObjectInputStream.this.locIn.setObjectInputFilter(filter);\n+                }\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/MarshalledObject.java","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,8 +123,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-\n-        if (sm != null) {\n-            sm.checkPermission(\n-                new java.util.logging.LoggingPermission(\"control\", null));\n-        }\n-\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/server\/LogStream.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,2 +33,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -245,3 +243,1 @@\n-        @SuppressWarnings(\"removal\")\n-        String value = AccessController.doPrivileged(\n-            (PrivilegedAction<String>) () -> System.getProperty(\"java.rmi.server.randomIDs\"));\n+        String value = System.getProperty(\"java.rmi.server.randomIDs\");\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/server\/ObjID.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -115,6 +113,1 @@\n-    @SuppressWarnings(\"removal\")\n-    private static final RMIClassLoaderSpi provider =\n-        AccessController.doPrivileged(\n-            new PrivilegedAction<RMIClassLoaderSpi>() {\n-                public RMIClassLoaderSpi run() { return initializeProvider(); }\n-            });\n+    private static final RMIClassLoaderSpi provider = initializeProvider();\n@@ -541,5 +534,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(new RuntimePermission(\"setFactory\"));\n-        }\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/server\/RMIClassLoader.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -134,5 +134,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkSetFactory();\n-        }\n@@ -184,5 +179,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkSetFactory();\n-        }\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/server\/RMISocketFactory.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,3 +30,0 @@\n-import java.rmi.server.RMIClassLoader;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -135,1 +132,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -142,2 +138,1 @@\n-        this.Debug = AccessController.doPrivileged(\n-            (PrivilegedAction<Boolean>) () -> Boolean.getBoolean(\"sun.rmi.log.debug\"));\n+        this.Debug = Boolean.getBoolean(\"sun.rmi.log.debug\");\n@@ -334,3 +329,1 @@\n-        @SuppressWarnings(\"removal\")\n-        String logClassName = AccessController.doPrivileged(\n-            (PrivilegedAction<String>) () -> System.getProperty(\"sun.rmi.log.class\"));\n+        String logClassName = System.getProperty(\"sun.rmi.log.class\");\n@@ -339,8 +332,1 @@\n-                @SuppressWarnings(\"removal\")\n-                ClassLoader loader =\n-                    AccessController.doPrivileged(\n-                        new PrivilegedAction<ClassLoader>() {\n-                            public ClassLoader run() {\n-                               return ClassLoader.getSystemClassLoader();\n-                            }\n-                        });\n+                ClassLoader loader = ClassLoader.getSystemClassLoader();\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/log\/ReliableLog.java","additions":4,"deletions":18,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -266,1 +266,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -373,1 +372,0 @@\n-    @SuppressWarnings(\"removal\")\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/registry\/RegistryImpl.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import java.security.PrivilegedAction;\n@@ -72,3 +71,1 @@\n-        @SuppressWarnings(\"removal\")\n-        boolean useOld = java.security.AccessController.doPrivileged(\n-            (PrivilegedAction<Boolean>) () -> Boolean.getBoolean(\"sun.rmi.log.useOld\"));\n+        boolean useOld = Boolean.getBoolean(\"sun.rmi.log.useOld\");\n@@ -180,11 +177,6 @@\n-        @SuppressWarnings(\"removal\")\n-        private static final Handler alternateConsole =\n-                java.security.AccessController.doPrivileged(\n-                new java.security.PrivilegedAction<Handler>() {\n-                    public Handler run() {\n-                            InternalStreamHandler alternate =\n-                                new InternalStreamHandler(System.err);\n-                            alternate.setLevel(Level.ALL);\n-                            return alternate;\n-                        }\n-                });\n+        private static final Handler alternateConsole;\n+        static {\n+            var alternate = new InternalStreamHandler(System.err);\n+            alternate.setLevel(Level.ALL);\n+            alternateConsole = alternate;\n+        }\n@@ -202,1 +194,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -206,12 +197,5 @@\n-            if (level != null){\n-                java.security.AccessController.doPrivileged(\n-                    new java.security.PrivilegedAction<Void>() {\n-                        public Void run() {\n-                            if (!logger.isLoggable(level)) {\n-                                logger.setLevel(level);\n-                            }\n-                            logger.addHandler(alternateConsole);\n-                            return null;\n-                        }\n-                    }\n-                );\n+            if (level != null) {\n+                if (!logger.isLoggable(level)) {\n+                    logger.setLevel(level);\n+                }\n+                logger.addHandler(alternateConsole);\n@@ -250,2 +234,0 @@\n-         *\n-         * Calling code needs LoggingPermission \"control\".\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/runtime\/Log.java","additions":13,"deletions":31,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import sun.security.util.SecurityConstants;\n-\n@@ -33,2 +29,4 @@\n- * A PrivilegedAction for creating a new thread conveniently with an\n- * AccessController.doPrivileged construct.\n+ * A utility class for creating threads. The constructors take a\n+ * variety of parameters to configure the thread. The run() method\n+ * creates and sets up the thread and returns it, but does not\n+ * start it.\n@@ -51,1 +49,1 @@\n-public final class NewThreadAction implements PrivilegedAction<Thread> {\n+public final class NewThreadAction {\n@@ -54,12 +52,10 @@\n-    @SuppressWarnings(\"removal\")\n-    static final ThreadGroup systemThreadGroup =\n-        AccessController.doPrivileged(new PrivilegedAction<ThreadGroup>() {\n-            public ThreadGroup run() {\n-                ThreadGroup group = Thread.currentThread().getThreadGroup();\n-                ThreadGroup parent;\n-                while ((parent = group.getParent()) != null) {\n-                    group = parent;\n-                }\n-                return group;\n-            }\n-        });\n+    static final ThreadGroup systemThreadGroup;\n+    static {\n+        ThreadGroup group = Thread.currentThread().getThreadGroup();\n+        ThreadGroup parent;\n+        while ((parent = group.getParent()) != null) {\n+            group = parent;\n+        }\n+        systemThreadGroup = group;\n+    }\n+\n@@ -68,3 +64,4 @@\n-     * special child of the system thread group for running tasks that\n-     * may execute user code, so that the security policy for threads in\n-     * the system thread group will not apply\n+     * Special child of the system thread group for running tasks that\n+     * may execute user code. The need for a separate thread group may\n+     * be a vestige of it having had a different security policy from\n+     * the system thread group, so this might no longer be necessary.\n@@ -72,7 +69,1 @@\n-    @SuppressWarnings(\"removal\")\n-    static final ThreadGroup userThreadGroup =\n-        AccessController.doPrivileged(new PrivilegedAction<ThreadGroup>() {\n-            public ThreadGroup run() {\n-                return new ThreadGroup(systemThreadGroup, \"RMI Runtime\");\n-            }\n-        });\n+    static final ThreadGroup userThreadGroup = new ThreadGroup(systemThreadGroup, \"RMI Runtime\");\n@@ -131,5 +122,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);\n-        }\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/runtime\/NewThreadAction.java","additions":21,"deletions":35,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import java.security.AccessController;\n-import java.security.Permission;\n-import java.security.PrivilegedAction;\n@@ -40,4 +37,1 @@\n- * with a GetInstanceAction.  Getting the instance requires\n- * RuntimePermission(\"sun.rmi.runtime.RuntimeUtil.getInstance\")\n- * because the public methods of this class expose security-sensitive\n- * capabilities.\n+ * with a getInstance() call.\n@@ -54,1 +48,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -56,6 +49,1 @@\n-        AccessController.doPrivileged((PrivilegedAction<Integer>) () ->\n-            Integer.getInteger(\"sun.rmi.runtime.schedulerThreads\", 1));\n-\n-    \/** permission required to get instance *\/\n-    private static final Permission GET_INSTANCE_PERMISSION =\n-        new RuntimePermission(\"sun.rmi.runtime.RuntimeUtil.getInstance\");\n+        Integer.getInteger(\"sun.rmi.runtime.schedulerThreads\", 1);\n@@ -74,1 +62,0 @@\n-                @SuppressWarnings(\"removal\")\n@@ -77,4 +64,3 @@\n-                        return AccessController.doPrivileged(\n-                            new NewThreadAction(runnable,\n-                                \"Scheduler(\" + count.getAndIncrement() + \")\",\n-                                true));\n+                        return new NewThreadAction(runnable,\n+                            \"Scheduler(\" + count.getAndIncrement() + \")\",\n+                            true).run();\n@@ -97,23 +83,1 @@\n-    \/**\n-     * A PrivilegedAction for getting the RuntimeUtil instance.\n-     **\/\n-    public static class GetInstanceAction\n-        implements PrivilegedAction<RuntimeUtil>\n-    {\n-        \/**\n-         * Creates an action that returns the RuntimeUtil instance.\n-         **\/\n-        public GetInstanceAction() {\n-        }\n-\n-        public RuntimeUtil run() {\n-            return getInstance();\n-        }\n-    }\n-\n-    private static RuntimeUtil getInstance() {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(GET_INSTANCE_PERMISSION);\n-        }\n+    public static RuntimeUtil getInstance() {\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/runtime\/RuntimeUtil.java","additions":7,"deletions":43,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-import java.security.PrivilegedAction;\n@@ -65,1 +64,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -67,4 +65,2 @@\n-        ! java.security.AccessController.doPrivileged(\n-            (PrivilegedAction<String>) () -> System.getProperty(\n-                \"java.rmi.server.useCodebaseOnly\", \"true\"))\n-            .equalsIgnoreCase(\"false\");\n+        ! System.getProperty(\"java.rmi.server.useCodebaseOnly\", \"true\")\n+                .equalsIgnoreCase(\"false\");\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/server\/MarshalInputStream.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -67,7 +66,1 @@\n-        java.security.AccessController.doPrivileged(\n-            new java.security.PrivilegedAction<Void>() {\n-                public Void run() {\n-                enableReplaceObject(true);\n-                return null;\n-            }\n-        });\n+        enableReplaceObject(true);\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/server\/MarshalOutputStream.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,2 +41,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -67,1 +65,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -70,2 +67,1 @@\n-                   AccessController.doPrivileged((PrivilegedAction<Boolean>) () ->\n-                       Boolean.getBoolean(\"sun.rmi.client.logCalls\")));\n+                   Boolean.getBoolean(\"sun.rmi.client.logCalls\"));\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/server\/UnicastRef.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,2 +51,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -58,1 +56,0 @@\n-import java.util.concurrent.atomic.AtomicInteger;\n@@ -83,3 +80,1 @@\n-    @SuppressWarnings(\"removal\")\n-    public static final boolean logCalls = AccessController.doPrivileged(\n-        (PrivilegedAction<Boolean>) () -> Boolean.getBoolean(\"java.rmi.server.logCalls\"));\n+    public static final boolean logCalls = Boolean.getBoolean(\"java.rmi.server.logCalls\");\n@@ -95,1 +90,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -97,2 +91,1 @@\n-        AccessController.doPrivileged((PrivilegedAction<Boolean>) () ->\n-            Boolean.getBoolean(\"sun.rmi.server.exceptionTrace\"));\n+            Boolean.getBoolean(\"sun.rmi.server.exceptionTrace\");\n@@ -106,1 +99,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -108,2 +100,1 @@\n-        AccessController.doPrivileged((PrivilegedAction<Boolean>) () ->\n-            Boolean.getBoolean(\"sun.rmi.server.suppressStackTraces\"));\n+            Boolean.getBoolean(\"sun.rmi.server.suppressStackTraces\");\n@@ -416,1 +407,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -419,9 +409,2 @@\n-        if (filter != null &&\n-                in instanceof ObjectInputStream) {\n-            \/\/ Set the filter on the stream\n-            ObjectInputStream ois = (ObjectInputStream) in;\n-\n-            AccessController.doPrivileged((PrivilegedAction<Void>)() -> {\n-                ois.setObjectInputFilter(filter);\n-                return null;\n-            });\n+        if (filter != null && in instanceof ObjectInputStream ois) {\n+            ois.setObjectInputFilter(filter);\n@@ -579,1 +562,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -589,1 +571,0 @@\n-                            final Method m = method;\n@@ -595,8 +576,2 @@\n-                            AccessController.doPrivileged(\n-                                new PrivilegedAction<Void>() {\n-                                public Void run() {\n-                                    m.setAccessible(true);\n-                                    return null;\n-                                }\n-                            });\n-                            map.put(Util.computeMethodHash(m), m);\n+                            method.setAccessible(true);\n+                            map.put(Util.computeMethodHash(method), method);\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/server\/UnicastServerRef.java","additions":8,"deletions":33,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,0 @@\n-import java.rmi.registry.Registry;\n@@ -40,2 +39,0 @@\n-import java.rmi.server.ObjID;\n-import java.rmi.server.RMIClientSocketFactory;\n@@ -47,1 +44,0 @@\n-import java.security.AccessController;\n@@ -51,1 +47,0 @@\n-import java.security.PrivilegedAction;\n@@ -56,1 +51,0 @@\n-import sun.rmi.registry.RegistryImpl;\n@@ -58,2 +52,0 @@\n-import sun.rmi.transport.LiveRef;\n-import sun.rmi.transport.tcp.TCPEndpoint;\n@@ -69,4 +61,1 @@\n-    @SuppressWarnings(\"removal\")\n-    static final int logLevel = LogStream.parseLevel(\n-        AccessController.doPrivileged(\n-            (PrivilegedAction<String>) () -> System.getProperty(\"sun.rmi.server.logLevel\")));\n+    static final int logLevel = LogStream.parseLevel(System.getProperty(\"sun.rmi.server.logLevel\"));\n@@ -79,1 +68,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -81,2 +69,1 @@\n-        AccessController.doPrivileged(\n-            (PrivilegedAction<Boolean>) () -> Boolean.getBoolean(\"java.rmi.server.ignoreStubClasses\"));\n+        Boolean.getBoolean(\"java.rmi.server.ignoreStubClasses\");\n@@ -123,1 +110,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -153,6 +139,1 @@\n-            return AccessController.doPrivileged(new PrivilegedAction<Remote>() {\n-                public Remote run() {\n-                    return (Remote) Proxy.newProxyInstance(loader,\n-                                                           interfaces,\n-                                                           handler);\n-                }});\n+            return (Remote) Proxy.newProxyInstance(loader, interfaces, handler);\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/server\/Util.java","additions":4,"deletions":23,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -67,1 +65,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -69,2 +66,1 @@\n-        AccessController.doPrivileged((PrivilegedAction<Long>) () ->\n-            Long.getLong(\"sun.rmi.dgc.ackTimeout\", 300000));\n+        Long.getLong(\"sun.rmi.dgc.ackTimeout\", 300000);\n@@ -73,1 +69,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -75,2 +70,1 @@\n-        AccessController.doPrivileged(\n-            new RuntimeUtil.GetInstanceAction()).getScheduler();\n+        RuntimeUtil.getInstance().getScheduler();\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/transport\/DGCAckHandler.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.net.SocketPermission;\n@@ -32,2 +31,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -40,1 +37,0 @@\n-import java.rmi.ConnectException;\n@@ -52,4 +48,0 @@\n-import java.security.AccessControlContext;\n-import java.security.Permissions;\n-import java.security.ProtectionDomain;\n-\n@@ -94,1 +86,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -96,2 +87,1 @@\n-        AccessController.doPrivileged((PrivilegedAction<Long>) () ->\n-            Long.getLong(\"java.rmi.dgc.leaseValue\", 600000));\n+        Long.getLong(\"java.rmi.dgc.leaseValue\", 600000);\n@@ -100,1 +90,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -102,2 +91,1 @@\n-        AccessController.doPrivileged((PrivilegedAction<Long>) () ->\n-            Long.getLong(\"sun.rmi.dgc.cleanInterval\", 180000));\n+        Long.getLong(\"sun.rmi.dgc.cleanInterval\", 180000);\n@@ -106,1 +94,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -108,2 +95,1 @@\n-        AccessController.doPrivileged((PrivilegedAction<Long>) () ->\n-            Long.getLong(\"sun.rmi.dgc.client.gcInterval\", 3600000));\n+        Long.getLong(\"sun.rmi.dgc.client.gcInterval\", 3600000);\n@@ -123,15 +109,0 @@\n-    \/**\n-     * An AccessControlContext with only socket permissions,\n-     * suitable for an RMIClientSocketFactory.\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    private static final AccessControlContext SOCKET_ACC = createSocketAcc();\n-\n-    @SuppressWarnings(\"removal\")\n-    private static AccessControlContext createSocketAcc() {\n-        Permissions perms = new Permissions();\n-        perms.add(new SocketPermission(\"*\", \"connect,resolve\"));\n-        ProtectionDomain[] pd = { new ProtectionDomain(null, perms) };\n-        return new AccessControlContext(pd);\n-    }\n-\n@@ -259,1 +230,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -269,1 +239,1 @@\n-            renewCleanThread =  AccessController.doPrivileged(\n+            renewCleanThread =\n@@ -271,1 +241,1 @@\n-                                    \"RenewClean-\" + endpoint, true));\n+                                    \"RenewClean-\" + endpoint, true).run();\n@@ -499,1 +469,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -506,7 +475,1 @@\n-                    AccessController.doPrivileged(\n-                        new PrivilegedAction<Void>() {\n-                            public Void run() {\n-                            renewCleanThread.interrupt();\n-                            return null;\n-                        }\n-                    });\n+                    renewCleanThread.interrupt();\n@@ -525,1 +488,0 @@\n-            @SuppressWarnings(\"removal\")\n@@ -604,7 +566,3 @@\n-                    boolean needRenewal_ = needRenewal;\n-                    Set<RefEntry> refsToDirty_ = refsToDirty;\n-                    long sequenceNum_ = sequenceNum;\n-                    AccessController.doPrivileged((PrivilegedAction<Void>)() -> {\n-                        if (needRenewal_) {\n-                            makeDirtyCall(refsToDirty_, sequenceNum_);\n-                        }\n+                    if (needRenewal) {\n+                        makeDirtyCall(refsToDirty, sequenceNum);\n+                    }\n@@ -612,5 +570,3 @@\n-                        if (!pendingCleans.isEmpty()) {\n-                            makeCleanCalls();\n-                        }\n-                        return null;\n-                    }, SOCKET_ACC);\n+                    if (!pendingCleans.isEmpty()) {\n+                        makeCleanCalls();\n+                    }\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/transport\/DGCClient.java","additions":13,"deletions":57,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.net.SocketPermission;\n@@ -39,5 +38,0 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n-import java.security.Permissions;\n-import java.security.PrivilegedAction;\n-import java.security.ProtectionDomain;\n@@ -71,1 +65,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -73,2 +66,1 @@\n-        LogStream.parseLevel(AccessController.doPrivileged(\n-            (PrivilegedAction<String>) () -> System.getProperty(\"sun.rmi.dgc.logLevel\"))));\n+        LogStream.parseLevel(System.getProperty(\"sun.rmi.dgc.logLevel\")));\n@@ -77,1 +69,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -79,2 +70,1 @@\n-        AccessController.doPrivileged(\n-            (PrivilegedAction<Long>) () -> Long.getLong(\"java.rmi.dgc.leaseValue\", 600000));\n+        Long.getLong(\"java.rmi.dgc.leaseValue\", 600000);\n@@ -83,1 +73,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -85,2 +74,1 @@\n-        AccessController.doPrivileged(\n-            (PrivilegedAction<Long>) () -> Long.getLong(\"sun.rmi.dgc.checkInterval\", leaseValue \/ 2));\n+        Long.getLong(\"sun.rmi.dgc.checkInterval\", leaseValue \/ 2);\n@@ -89,1 +77,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -91,2 +78,1 @@\n-        AccessController.doPrivileged(\n-            new RuntimeUtil.GetInstanceAction()).getScheduler();\n+        RuntimeUtil.getInstance().getScheduler();\n@@ -127,3 +113,1 @@\n-    @SuppressWarnings(\"removal\")\n-    private static final ObjectInputFilter dgcFilter =\n-            AccessController.doPrivileged((PrivilegedAction<ObjectInputFilter>)DGCImpl::initDgcFilter);\n+    private static final ObjectInputFilter dgcFilter = initDgcFilter();\n@@ -326,1 +310,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -332,45 +315,20 @@\n-        AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-            public Void run() {\n-                ClassLoader savedCcl =\n-                    Thread.currentThread().getContextClassLoader();\n-                try {\n-                    Thread.currentThread().setContextClassLoader(\n-                        ClassLoader.getSystemClassLoader());\n-\n-                    \/*\n-                     * Put remote collector object in table by hand to prevent\n-                     * listen on port.  (UnicastServerRef.exportObject would\n-                     * cause transport to listen.)\n-                     *\/\n-                    try {\n-                        dgc = new DGCImpl();\n-                        ObjID dgcID = new ObjID(ObjID.DGC_ID);\n-                        LiveRef ref = new LiveRef(dgcID, 0);\n-                        UnicastServerRef disp = new UnicastServerRef(ref,\n-                                DGCImpl::checkInput);\n-                        Remote stub =\n-                            Util.createProxy(DGCImpl.class,\n-                                             new UnicastRef(ref), true);\n-                        disp.setSkeleton(dgc);\n-\n-                        Permissions perms = new Permissions();\n-                        perms.add(new SocketPermission(\"*\", \"accept,resolve\"));\n-                        ProtectionDomain[] pd = { new ProtectionDomain(null, perms) };\n-                        AccessControlContext acceptAcc = new AccessControlContext(pd);\n-\n-                        Target target = AccessController.doPrivileged(\n-                            new PrivilegedAction<Target>() {\n-                                public Target run() {\n-                                    return new Target(dgc, disp, stub, dgcID, true);\n-                                }\n-                            }, acceptAcc);\n-\n-                        ObjectTable.putTarget(target);\n-                    } catch (RemoteException e) {\n-                        throw new Error(\n-                            \"exception initializing server-side DGC\", e);\n-                    }\n-                } finally {\n-                    Thread.currentThread().setContextClassLoader(savedCcl);\n-                }\n-                return null;\n+        ClassLoader savedCcl = Thread.currentThread().getContextClassLoader();\n+        try {\n+            Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader());\n+\n+            \/*\n+             * Put remote collector object in table by hand to prevent\n+             * listen on port.  (UnicastServerRef.exportObject would\n+             * cause transport to listen.)\n+             *\/\n+            try {\n+                dgc = new DGCImpl();\n+                ObjID dgcID = new ObjID(ObjID.DGC_ID);\n+                LiveRef ref = new LiveRef(dgcID, 0);\n+                UnicastServerRef disp = new UnicastServerRef(ref, DGCImpl::checkInput);\n+                Remote stub = Util.createProxy(DGCImpl.class, new UnicastRef(ref), true);\n+                disp.setSkeleton(dgc);\n+                Target target = new Target(dgc, disp, stub, dgcID, true);\n+                ObjectTable.putTarget(target);\n+            } catch (RemoteException e) {\n+                throw new Error(\"exception initializing server-side DGC\", e);\n@@ -378,1 +336,3 @@\n-        });\n+        } finally {\n+            Thread.currentThread().setContextClassLoader(savedCcl);\n+        }\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/transport\/DGCImpl.java","additions":29,"deletions":69,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/transport\/DGCImpl_Stub.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -42,1 +40,1 @@\n-@SuppressWarnings({\"removal\", \"restricted\"})\n+@SuppressWarnings(\"restricted\")\n@@ -88,5 +86,1 @@\n-        AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-            public Void run() {\n-                System.loadLibrary(\"rmi\");\n-                return null;\n-            }});\n+        System.loadLibrary(\"rmi\");\n@@ -137,12 +131,6 @@\n-            PrivilegedAction<Void> pa = new PrivilegedAction<Void>() {\n-                public Void run() {\n-                    Thread t = InnocuousThread.newSystemThread(\"RMI GC Daemon\",\n-                                                               new Daemon());\n-                    assert t.getContextClassLoader() == null;\n-                    t.setDaemon(true);\n-                    t.setPriority(Thread.MIN_PRIORITY + 1);\n-                    t.start();\n-                    GC.daemon = t;\n-                    return null;\n-                }};\n-            AccessController.doPrivileged(pa);\n+            Thread t = InnocuousThread.newSystemThread(\"RMI GC Daemon\", new Daemon());\n+            assert t.getContextClassLoader() == null;\n+            t.setDaemon(true);\n+            t.setPriority(Thread.MIN_PRIORITY + 1);\n+            t.start();\n+            GC.daemon = t;\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/transport\/GC.java","additions":9,"deletions":21,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,2 +33,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -51,1 +49,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -53,2 +50,1 @@\n-        AccessController.doPrivileged((PrivilegedAction<Long>) () ->\n-            Long.getLong(\"sun.rmi.dgc.server.gcInterval\", 3600000));\n+        Long.getLong(\"sun.rmi.dgc.server.gcInterval\", 3600000);\n@@ -273,1 +269,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -279,2 +274,1 @@\n-                reaper = AccessController.doPrivileged(\n-                    new NewThreadAction(new Reaper(), \"Reaper\", false));\n+                reaper = new NewThreadAction(new Reaper(), \"Reaper\", false).run();\n@@ -310,1 +304,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -317,6 +310,1 @@\n-                AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-                    public Void run() {\n-                        reaper.interrupt();\n-                        return null;\n-                    }\n-                });\n+                reaper.interrupt();\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/transport\/ObjectTable.java","additions":4,"deletions":16,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,2 +40,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -142,1 +140,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -149,4 +146,1 @@\n-                AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n-                    in.setObjectInputFilter(filter);\n-                    return null;\n-                });\n+                in.setObjectInputFilter(filter);\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/transport\/StreamRemoteCall.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,3 +32,0 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -61,3 +58,0 @@\n-    \/** access control context in which target was created *\/\n-    @SuppressWarnings(\"removal\")\n-    private final AccessControlContext acc;\n@@ -89,1 +83,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -97,1 +90,0 @@\n-        this.acc = AccessController.getContext();\n@@ -180,5 +172,0 @@\n-    @SuppressWarnings(\"removal\")\n-    AccessControlContext getAccessControlContext() {\n-        return acc;\n-    }\n-\n@@ -310,1 +297,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -328,11 +314,6 @@\n-            if (obj instanceof Unreferenced) {\n-                final Unreferenced unrefObj = (Unreferenced) obj;\n-                AccessController.doPrivileged(\n-                    new NewThreadAction(() -> {\n-                        Thread.currentThread().setContextClassLoader(ccl);\n-                        AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n-                            unrefObj.unreferenced();\n-                            return null;\n-                        }, acc);\n-                    }, \"Unreferenced-\" + nextThreadNum++, false, true)).start();\n-                    \/\/ REMIND: access to nextThreadNum not synchronized; you care?\n+            if (obj instanceof Unreferenced unrefObj) {\n+                new NewThreadAction(() -> {\n+                    Thread.currentThread().setContextClassLoader(ccl);\n+                    unrefObj.unreferenced();\n+                }, \"Unreferenced-\" + nextThreadNum++, false, true).run().start();\n+                \/\/ REMIND: access to nextThreadNum not synchronized; you care?\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/transport\/Target.java","additions":7,"deletions":26,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,5 +39,0 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n-import java.security.Permissions;\n-import java.security.PrivilegedAction;\n-import java.security.ProtectionDomain;\n@@ -54,1 +49,1 @@\n-@SuppressWarnings({\"removal\",\"deprecation\"})\n+@SuppressWarnings({\"deprecation\"})\n@@ -61,2 +56,1 @@\n-        return java.security.AccessController.doPrivileged(\n-            (PrivilegedAction<String>) () -> System.getProperty(\"sun.rmi.transport.logLevel\"));\n+        return System.getProperty(\"sun.rmi.transport.logLevel\");\n@@ -75,9 +69,0 @@\n-    \/** AccessControlContext for setting context ClassLoader *\/\n-    private static final AccessControlContext SETCCL_ACC;\n-    static {\n-        Permissions perms = new Permissions();\n-        perms.add(new RuntimePermission(\"setContextClassLoader\"));\n-        ProtectionDomain[] pd = { new ProtectionDomain(null, perms) };\n-        SETCCL_ACC = new AccessControlContext(pd);\n-    }\n-\n@@ -124,8 +109,0 @@\n-    \/**\n-     * Verify that the current access control context has permission to accept\n-     * the connection being dispatched by the current thread.  The current\n-     * access control context is passed as a parameter to avoid the overhead of\n-     * an additional call to AccessController.getContext.\n-     *\/\n-    protected abstract void checkAcceptPermission(AccessControlContext acc);\n-\n@@ -136,4 +113,1 @@\n-        AccessController.doPrivileged((PrivilegedAction<Void>)() -> {\n-                Thread.currentThread().setContextClassLoader(ccl);\n-                return null;\n-            }, SETCCL_ACC);\n+        Thread.currentThread().setContextClassLoader(ccl);\n@@ -186,2 +160,0 @@\n-                final AccessControlContext acc =\n-                    target.getAccessControlContext();\n@@ -189,1 +161,0 @@\n-\n@@ -195,12 +166,1 @@\n-                    try {\n-                        java.security.AccessController.doPrivileged(\n-                            new java.security.PrivilegedExceptionAction<Void>() {\n-                            public Void run() throws IOException {\n-                                checkAcceptPermission(acc);\n-                                disp.dispatch(impl, call);\n-                                return null;\n-                            }\n-                        }, acc);\n-                    } catch (java.security.PrivilegedActionException pae) {\n-                        throw (IOException) pae.getException();\n-                    }\n+                    disp.dispatch(impl, call);\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/transport\/Transport.java","additions":5,"deletions":45,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,0 @@\n-import java.lang.ref.Reference;\n-import java.lang.ref.SoftReference;\n@@ -35,3 +33,0 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -41,1 +36,0 @@\n-import java.util.WeakHashMap;\n@@ -73,13 +67,0 @@\n-    \/** most recently authorized AccessControlContext *\/\n-    @SuppressWarnings(\"removal\")\n-    private AccessControlContext okContext;\n-\n-    \/** cache of authorized AccessControlContexts *\/\n-    @SuppressWarnings(\"removal\")\n-    private WeakHashMap<AccessControlContext,\n-                        Reference<AccessControlContext>> authcache;\n-\n-    \/** the SecurityManager which authorized okContext and authcache *\/\n-    @SuppressWarnings(\"removal\")\n-    private SecurityManager cacheSecurityManager = null;\n-\n@@ -87,1 +68,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -89,2 +69,1 @@\n-        AccessController.doPrivileged((PrivilegedAction<Long>) () ->\n-            Long.getLong(\"sun.rmi.transport.connectionTimeout\", 15000));\n+        Long.getLong(\"sun.rmi.transport.connectionTimeout\", 15000);\n@@ -93,1 +72,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -95,2 +73,1 @@\n-        AccessController.doPrivileged((PrivilegedAction<Integer>) () ->\n-            Integer.getInteger(\"sun.rmi.transport.tcp.handshakeTimeout\", 60000));\n+        Integer.getInteger(\"sun.rmi.transport.tcp.handshakeTimeout\", 60000);\n@@ -99,1 +76,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -101,2 +77,1 @@\n-        AccessController.doPrivileged((PrivilegedAction<Integer>) () ->\n-            Integer.getInteger(\"sun.rmi.transport.tcp.responseTimeout\", 0));\n+        Integer.getInteger(\"sun.rmi.transport.tcp.responseTimeout\", 0);\n@@ -105,1 +80,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -107,2 +81,1 @@\n-        AccessController.doPrivileged(\n-            new RuntimeUtil.GetInstanceAction()).getScheduler();\n+        RuntimeUtil.getInstance().getScheduler();\n@@ -125,35 +98,0 @@\n-    \/**\n-     * Checks if the current caller has sufficient privilege to make\n-     * a connection to the remote endpoint.\n-     * @exception SecurityException if caller is not allowed to use this\n-     * Channel.\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    private void checkConnectPermission() throws SecurityException {\n-        SecurityManager security = System.getSecurityManager();\n-        if (security == null)\n-            return;\n-\n-        if (security != cacheSecurityManager) {\n-            \/\/ The security manager changed: flush the cache\n-            okContext = null;\n-            authcache = new WeakHashMap<AccessControlContext,\n-                                        Reference<AccessControlContext>>();\n-            cacheSecurityManager = security;\n-        }\n-\n-        AccessControlContext ctx = AccessController.getContext();\n-\n-        \/\/ If ctx is the same context as last time, or if it\n-        \/\/ appears in the cache, bypass the checkConnect.\n-        if (okContext == null ||\n-            !(okContext.equals(ctx) || authcache.containsKey(ctx)))\n-        {\n-            security.checkConnect(ep.getHost(), ep.getPort());\n-            authcache.put(ctx, new SoftReference<AccessControlContext>(ctx));\n-            \/\/ A WeakHashMap is transformed into a SoftHashSet by making\n-            \/\/ each value softly refer to its own key (Peter's idea).\n-        }\n-        okContext = ctx;\n-    }\n-\n@@ -178,4 +116,0 @@\n-                    \/\/ If there is a security manager, make sure\n-                    \/\/ the caller is allowed to connect to the\n-                    \/\/ requested endpoint.\n-                    checkConnectPermission();\n@@ -470,5 +404,3 @@\n-        @SuppressWarnings(\"removal\")\n-        Thread t = AccessController.doPrivileged(\n-            new NewThreadAction(ConnectionAcceptor.this,\n-                                \"TCPChannel Accept-\" + ++ threadNum,\n-                                true));\n+        Thread t = new NewThreadAction(ConnectionAcceptor.this,\n+                                       \"TCPChannel Accept-\" + ++ threadNum,\n+                                       true).run();\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/transport\/tcp\/TCPChannel.java","additions":8,"deletions":76,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,2 +41,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -82,2 +80,0 @@\n-    \/\/ this should be a *private* method since it is privileged\n-    @SuppressWarnings(\"removal\")\n@@ -85,2 +81,1 @@\n-        return AccessController.doPrivileged(\n-                (PrivilegedAction<Integer>) () -> Integer.getInteger(name, def));\n+        return Integer.getInteger(name, def);\n@@ -89,2 +84,0 @@\n-    \/\/ this should be a *private* method since it is privileged\n-    @SuppressWarnings(\"removal\")\n@@ -92,2 +85,1 @@\n-        return AccessController.doPrivileged(\n-                (PrivilegedAction<Boolean>) () -> Boolean.getBoolean(name));\n+        return Boolean.getBoolean(name);\n@@ -99,1 +91,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -101,2 +92,1 @@\n-        return AccessController.doPrivileged(\n-            (PrivilegedAction<String>) () -> System.getProperty(\"java.rmi.server.hostname\"));\n+        return System.getProperty(\"java.rmi.server.hostname\");\n@@ -765,3 +755,1 @@\n-            @SuppressWarnings(\"removal\")\n-            Thread t = AccessController.doPrivileged(\n-                new NewThreadAction(FQDN.this, \"FQDN Finder\", true));\n+            Thread t = new NewThreadAction(FQDN.this, \"FQDN Finder\", true).run();\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/transport\/tcp\/TCPEndpoint.java","additions":5,"deletions":17,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.lang.ref.SoftReference;\n@@ -50,5 +49,0 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n-import java.security.Permissions;\n-import java.security.PrivilegedAction;\n-import java.security.ProtectionDomain;\n@@ -70,1 +64,0 @@\n-import sun.rmi.transport.Channel;\n@@ -90,1 +83,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -92,2 +84,1 @@\n-        LogStream.parseLevel(AccessController.doPrivileged(\n-            (PrivilegedAction<String>) () -> System.getProperty(\"sun.rmi.transport.tcp.logLevel\"))));\n+        LogStream.parseLevel(System.getProperty(\"sun.rmi.transport.tcp.logLevel\")));\n@@ -96,1 +87,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -98,3 +88,1 @@\n-        AccessController.doPrivileged((PrivilegedAction<Integer>) () ->\n-            Integer.getInteger(\"sun.rmi.transport.tcp.maxConnectionThreads\",\n-                               Integer.MAX_VALUE));\n+        Integer.getInteger(\"sun.rmi.transport.tcp.maxConnectionThreads\", Integer.MAX_VALUE);\n@@ -103,1 +91,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -105,2 +92,1 @@\n-        AccessController.doPrivileged((PrivilegedAction<Long>) () ->\n-            Long.getLong(\"sun.rmi.transport.tcp.threadKeepAliveTime\", 60000));\n+        Long.getLong(\"sun.rmi.transport.tcp.threadKeepAliveTime\", 60000);\n@@ -114,1 +100,0 @@\n-                @SuppressWarnings(\"removal\")\n@@ -116,2 +101,2 @@\n-                    return AccessController.doPrivileged(new NewThreadAction(\n-                        runnable, \"TCP Connection(idle)\", true, true));\n+                    return new NewThreadAction(\n+                        runnable, \"TCP Connection(idle)\", true, true).run();\n@@ -128,11 +113,0 @@\n-    \/** an AccessControlContext with no permissions *\/\n-    @SuppressWarnings(\"removal\")\n-    private static final AccessControlContext NOPERMS_ACC = createNopermsAcc();\n-\n-    @SuppressWarnings(\"removal\")\n-    private static AccessControlContext createNopermsAcc() {\n-        Permissions perms = new Permissions();\n-        ProtectionDomain[] pd = { new ProtectionDomain(null, perms) };\n-        return new AccessControlContext(pd);\n-    }\n-\n@@ -152,1 +126,2 @@\n-    \/** number of milliseconds in accepted-connection timeout.\n+    \/**\n+     * Number of milliseconds in accepted-connection timeout.\n@@ -158,1 +133,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -160,2 +134,1 @@\n-        AccessController.doPrivileged((PrivilegedAction<Integer>) () ->\n-            Integer.getInteger(\"sun.rmi.transport.tcp.readTimeout\", 2 * 3600 * 1000));\n+        Integer.getInteger(\"sun.rmi.transport.tcp.readTimeout\", 2 * 3600 * 1000);\n@@ -305,18 +278,0 @@\n-    \/**\n-     * Verify that the current access control context has permission to\n-     * accept the connection being dispatched by the current thread.\n-     *\/\n-    protected void checkAcceptPermission(@SuppressWarnings(\"removal\") AccessControlContext acc) {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm == null) {\n-            return;\n-        }\n-        ConnectionHandler h = threadConnectionHandler.get();\n-        if (h == null) {\n-            throw new Error(\n-                \"checkAcceptPermission not in ConnectionHandler thread\");\n-        }\n-        h.checkAcceptPermission(sm, acc);\n-    }\n-\n@@ -330,1 +285,2 @@\n-     * Listen on transport's endpoint.\n+     * Listen on transport's endpoint. Do nothing if a server socket\n+     * and listening thread already exist.\n@@ -350,4 +306,2 @@\n-                @SuppressWarnings(\"removal\")\n-                Thread t = AccessController.doPrivileged(\n-                    new NewThreadAction(new AcceptLoop(server),\n-                                        \"TCP Accept-\" + port, true));\n+                Thread t = new NewThreadAction(new AcceptLoop(server),\n+                                        \"TCP Accept-\" + port, true).run();\n@@ -360,8 +314,0 @@\n-\n-        } else {\n-            \/\/ otherwise verify security access to existing server socket\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager sm = System.getSecurityManager();\n-            if (sm != null) {\n-                sm.checkListen(port);\n-            }\n@@ -659,11 +605,0 @@\n-        \/** most recently accept-authorized AccessControlContext *\/\n-        @SuppressWarnings(\"removal\")\n-        private AccessControlContext okContext;\n-        \/** cache of accept-authorized AccessControlContexts *\/\n-        @SuppressWarnings(\"removal\")\n-        private Map<AccessControlContext,\n-                    Reference<AccessControlContext>> authCache;\n-        \/** security manager which authorized contexts in authCache *\/\n-        @SuppressWarnings(\"removal\")\n-        private SecurityManager cacheSecurityManager = null;\n-\n@@ -682,31 +617,0 @@\n-        \/**\n-         * Verify that the given AccessControlContext has permission to\n-         * accept this connection.\n-         *\/\n-        @SuppressWarnings(\"removal\")\n-        void checkAcceptPermission(SecurityManager sm,\n-                                   AccessControlContext acc)\n-        {\n-            \/*\n-             * Note: no need to synchronize on cache-related fields, since this\n-             * method only gets called from the ConnectionHandler's thread.\n-             *\/\n-            if (sm != cacheSecurityManager) {\n-                okContext = null;\n-                authCache = new WeakHashMap<AccessControlContext,\n-                                            Reference<AccessControlContext>>();\n-                cacheSecurityManager = sm;\n-            }\n-            if (acc.equals(okContext) || authCache.containsKey(acc)) {\n-                return;\n-            }\n-            InetAddress addr = socket.getInetAddress();\n-            String host = (addr != null) ? addr.getHostAddress() : \"*\";\n-\n-            sm.checkAccept(host, socket.getPort());\n-\n-            authCache.put(acc, new SoftReference<AccessControlContext>(acc));\n-            okContext = acc;\n-        }\n-\n-        @SuppressWarnings(\"removal\")\n@@ -720,4 +624,1 @@\n-                AccessController.doPrivileged((PrivilegedAction<Void>)() -> {\n-                    run0();\n-                    return null;\n-                }, NOPERMS_ACC);\n+                run0();\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/transport\/tcp\/TCPTransport.java","additions":14,"deletions":113,"binary":false,"changes":127,"status":"modified"}]}