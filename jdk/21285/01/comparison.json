{"files":[{"patch":"@@ -58,2 +58,6 @@\n-  \/\/ Only jvmci compiler threads can call Java\n-  _can_call_java = c != nullptr && c->is_jvmci();\n+  \/*\n+   * For compiler threads using the JVMCI jargraal compiler,\n+   * we need to enable Java calls for upcalls to the jargraal compiler.\n+   * Java calls are also needed by InterpreterRuntime when running the jargraal compiler.\n+   *\/\n+  _can_call_java = c != nullptr && c->is_jvmci() && !UseJVMCINativeLibrary;\n","filename":"src\/hotspot\/share\/compiler\/compilerThread.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -57,2 +57,1 @@\n-CompilerThreadCanCallJava::CompilerThreadCanCallJava(JavaThread* current, bool new_state) {\n-  _current = nullptr;\n+CompilerThread* CompilerThreadCanCallJava::update(JavaThread* current, bool new_state) {\n@@ -65,1 +64,1 @@\n-      \/\/ Only enter a new context if the ability of the\n+      \/\/ Only update the state if the ability of the\n@@ -67,1 +66,0 @@\n-      _reset_state = ct->_can_call_java;\n@@ -69,1 +67,1 @@\n-      _current = ct;\n+      return ct;\n@@ -72,0 +70,5 @@\n+  return nullptr;\n+}\n+\n+CompilerThreadCanCallJava::CompilerThreadCanCallJava(JavaThread* current, bool new_state) {\n+  _current = CompilerThreadCanCallJava::update(current, new_state);\n@@ -76,1 +79,1 @@\n-    _current->_can_call_java = _reset_state;\n+    _current->_can_call_java = !_current->_can_call_java;\n","filename":"src\/hotspot\/share\/jvmci\/jvmci.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -63,2 +63,0 @@\n-  bool _reset_state;        \/\/ Value prior to state change, undefined\n-                            \/\/ if no state change.\n@@ -66,5 +64,6 @@\n-  \/\/ Enters a scope in which the ability of the current CompilerThread\n-  \/\/ to call Java is specified by `new_state`. This call only makes a\n-  \/\/ change if the current thread is a CompilerThread associated with\n-  \/\/ a JVMCI compiler whose CompilerThread::_can_call_java is not\n-  \/\/ currently `new_state`.\n+  \/\/ If the current thread is a CompilerThread associated with\n+  \/\/ a JVMCI compiler where CompilerThread::_can_call_java != new_state,\n+  \/\/ then _can_call_java is set to `new_state`\n+  \/\/ Returns nullptr if no change was made, otherwise the current CompilerThread\n+  static CompilerThread* update(JavaThread* current, bool new_state);\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmci.hpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -187,1 +187,9 @@\n-  CompilerThreadCanCallJava ccj(thread, __is_hotspot);     \\\n+  bool __block_can_call_java;                              \\\n+  if (__is_hotspot) {                                      \\\n+    __block_can_call_java = true;                          \\\n+  } else if (thread->is_Compiler_thread()) {               \\\n+    __block_can_call_java = CompilerThread::cast(thread)->can_call_java();  \\\n+  } else {                                                 \\\n+    __block_can_call_java = false;                         \\\n+  }                                                        \\\n+  CompilerThreadCanCallJava ccj(thread, __block_can_call_java); \\\n@@ -404,0 +412,5 @@\n+C2V_VMENTRY_PREFIX(jboolean, updateCompilerThreadCanCallJava, (JNIEnv* env, jobject, jboolean newState))\n+  return CompilerThreadCanCallJava::update(thread, newState) != nullptr;\n+C2V_END\n+\n+\n@@ -3390,0 +3403,1 @@\n+  {CC \"updateCompilerThreadCanCallJava\",              CC \"(Z)Z\",                                                                            FN_PTR(updateCompilerThreadCanCallJava)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.hotspot;\n+\n+\/**\n+ * Scope used to potentially change whether the current thread can make VM-to-Java calls.\n+ * A scope is exited by the {@link #close()} method so it should be used in a\n+ * try-with-resources statement.\n+ *\n+ * The scope does nothing if the current thread is not a HotSpot VM CompilerThread\n+ * for a JVMCI compiler.\n+ *\/\n+public class CompilerThreadCanCallJavaScope implements AutoCloseable {\n+\n+    \/**\n+     * Thread state used during the scope.\n+     *\/\n+    private final boolean state;\n+\n+    \/**\n+     * Non-null iff the thread state needs resetting in {@link #close()}.\n+     *\/\n+    private final CompilerToVM vm;\n+\n+    \/**\n+     * The thread on which the constructor was called.\n+     *\/\n+    private final Thread thread;\n+\n+    \/**\n+     * Opens a scope to allow\/disallow the current thread to make VM-to-Java calls.\n+     * The scope is a no-op if the current thread is not a HotSpot VM CompilerThread\n+     * for a JVMCI compiler.\n+     *\n+     * @param newState true\/false to allow\/disallow VM-to-Java calls within the scope\n+     *\/\n+    public CompilerThreadCanCallJavaScope(boolean newState) {\n+        this.state = newState;\n+        this.thread = Thread.currentThread();\n+        CompilerToVM vm = HotSpotJVMCIRuntime.runtime().getCompilerToVM();\n+        if (vm.updateCompilerThreadCanCallJava(newState)) {\n+            this.vm = vm;\n+        } else {\n+            this.vm = null;\n+        }\n+    }\n+\n+    \/**\n+     * Resets the state of the current thread with respect to whether it can make\n+     * VM-to-Java calls to what it was before the constructor was called.\n+     *\n+     * @throws IllegalStateException if called on a different thread than the constructor\n+     *\/\n+    @Override\n+    public void close() {\n+        if (this.thread != Thread.currentThread()) {\n+            throw new IllegalStateException();\n+        }\n+\n+        if (vm != null) {\n+            vm.updateCompilerThreadCanCallJava(!state);\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerThreadCanCallJavaScope.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -1517,0 +1517,8 @@\n+\n+    \/**\n+     * If the current thread is a CompilerThread associated with a JVMCI compiler where\n+     * newState != CompilerThread::_can_call_java, then _can_call_java is set to newState.\n+     *\n+     * @returns false if no change was made, otherwise true\n+     *\/\n+    native boolean updateCompilerThreadCanCallJava(boolean newState);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}