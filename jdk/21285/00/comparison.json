{"files":[{"patch":"@@ -59,1 +59,3 @@\n-  _can_call_java = c != nullptr && c->is_jvmci();\n+  if (c != nullptr && c->is_jvmci()) {\n+      _can_call_java = TriBool{};\n+  }\n","filename":"src\/hotspot\/share\/compiler\/compilerThread.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include <utilities\/tribool.hpp>\n@@ -53,1 +54,1 @@\n-  bool                  _can_call_java;\n+  TriBool               _can_call_java;\n@@ -76,1 +77,1 @@\n-  virtual bool can_call_java() const             { return _can_call_java; }\n+  virtual bool can_call_java() const             { return _can_call_java.is_default() || _can_call_java; }\n","filename":"src\/hotspot\/share\/compiler\/compilerThread.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -57,2 +57,1 @@\n-CompilerThreadCanCallJava::CompilerThreadCanCallJava(JavaThread* current, bool new_state) {\n-  _current = nullptr;\n+Pair<CompilerThread*,TriBool> CompilerThreadCanCallJava::update(JavaThread* current, const TriBool new_state, bool force) {\n@@ -62,0 +61,1 @@\n+        (force || ct->_can_call_java.is_default()) &&\n@@ -65,1 +65,1 @@\n-      \/\/ Only enter a new context if the ability of the\n+      \/\/ Only update the state if the ability of the\n@@ -67,1 +67,1 @@\n-      _reset_state = ct->_can_call_java;\n+      TriBool prev_state{ct->_can_call_java};\n@@ -69,1 +69,1 @@\n-      _current = ct;\n+      return {ct, prev_state};\n@@ -72,0 +72,7 @@\n+  return {nullptr, {}};\n+}\n+\n+CompilerThreadCanCallJava::CompilerThreadCanCallJava(JavaThread* current, bool new_state, bool force) {\n+  Pair<CompilerThread*,TriBool> p  = CompilerThreadCanCallJava::update(current, new_state, force);\n+  _current = p.first;\n+  _prev_can_call_java = p.second;\n@@ -76,1 +83,1 @@\n-    _current->_can_call_java = _reset_state;\n+    _current->_can_call_java = _prev_can_call_java;\n@@ -205,1 +212,1 @@\n-  CompilerThreadCanCallJava ccj(THREAD, true);\n+  CompilerThreadCanCallJava ccj(THREAD, true, true);\n","filename":"src\/hotspot\/share\/jvmci\/jvmci.cpp","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+#include <utilities\/pair.hpp>\n+#include <utilities\/tribool.hpp>\n@@ -63,2 +65,1 @@\n-  bool _reset_state;        \/\/ Value prior to state change, undefined\n-                            \/\/ if no state change.\n+  TriBool _prev_can_call_java;\n@@ -66,6 +67,16 @@\n-  \/\/ Enters a scope in which the ability of the current CompilerThread\n-  \/\/ to call Java is specified by `new_state`. This call only makes a\n-  \/\/ change if the current thread is a CompilerThread associated with\n-  \/\/ a JVMCI compiler whose CompilerThread::_can_call_java is not\n-  \/\/ currently `new_state`.\n-  CompilerThreadCanCallJava(JavaThread* current, bool new_state);\n+  \/\/ Updates the `_can_call_java` state for the current thread if it's a `CompilerThread`\n+  \/\/ associated with a JVMCI compiler.\n+  \/\/\n+  \/\/ Conditions for updating:\n+  \/\/ - The current thread must be a `CompilerThread`.\n+  \/\/ - The thread's `_can_call_java` field must not already match `new_state`.\n+  \/\/ - Either the `force` flag must be `true`, or `_can_call_java` must be a default `TriBool` value.\n+  \/\/ - The thread must be associated with a valid JVMCI compiler (`_compiler != nullptr` and `_compiler->is_jvmci()`).\n+  \/\/\n+  \/\/ If the update is performed, `_can_call_java` is set to `new_state`, and the method returns a\n+  \/\/ `Pair` containing the current `CompilerThread` and its previous `_can_call_java` value.\n+  \/\/\n+  \/\/ If no update is performed, the method returns a `Pair` with `nullptr` and a default `TriBool` value.\n+  static Pair<CompilerThread*,TriBool> update(JavaThread* current, TriBool new_state, bool force);\n+\n+  CompilerThreadCanCallJava(JavaThread* current, bool new_state, bool force=false);\n","filename":"src\/hotspot\/share\/jvmci\/jvmci.hpp","additions":19,"deletions":8,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -404,0 +404,15 @@\n+C2V_VMENTRY_PREFIX(jint, updateCompilerThreadCanCallJava, (JNIEnv* env, jobject, jint newState))\n+    TriBool new_state{};\n+    if (newState != -1) {\n+        new_state = static_cast<bool>(newState);\n+    }\n+    Pair<CompilerThread*,TriBool> p = CompilerThreadCanCallJava::update(thread, new_state, true);\n+    TriBool result = p.first == nullptr ? new_state : p.second;\n+    if (result.is_default()) {\n+        return -1;\n+    } else {\n+        return static_cast<bool>(p.second);\n+    }\n+C2V_END\n+\n+\n@@ -586,1 +601,1 @@\n-  CompilerThreadCanCallJava canCallJava(thread, resolve); \/\/ Resolution requires Java calls\n+  CompilerThreadCanCallJava canCallJava(thread, resolve, true); \/\/ Resolution requires Java calls\n@@ -2034,1 +2049,1 @@\n-  CompilerThreadCanCallJava canCallJava(thread, true); \/\/ Linking requires Java calls\n+  CompilerThreadCanCallJava canCallJava(thread, true, true); \/\/ Linking requires Java calls\n@@ -2800,1 +2815,1 @@\n-  CompilerThreadCanCallJava canCallJava(thread, PEER_JVMCIENV->is_hotspot());\n+  CompilerThreadCanCallJava canCallJava(thread, PEER_JVMCIENV->is_hotspot(), true);\n@@ -3023,1 +3038,1 @@\n-  CompilerThreadCanCallJava canCallJava(thread, true); \/\/ Requires Java support\n+  CompilerThreadCanCallJava canCallJava(thread, true, true); \/\/ Requires Java support\n@@ -3030,1 +3045,1 @@\n-  CompilerThreadCanCallJava canCallJava(thread, true); \/\/ Requires Java support\n+  CompilerThreadCanCallJava canCallJava(thread, true, true); \/\/ Requires Java support\n@@ -3037,1 +3052,1 @@\n-  CompilerThreadCanCallJava canCallJava(thread, true); \/\/ Requires Java support\n+  CompilerThreadCanCallJava canCallJava(thread, true, true); \/\/ Requires Java support\n@@ -3101,1 +3116,1 @@\n-  CompilerThreadCanCallJava canCallJava(thread, true);\n+  CompilerThreadCanCallJava canCallJava(thread, true, true);\n@@ -3390,0 +3405,1 @@\n+  {CC \"updateCompilerThreadCanCallJava\",              CC \"(I)I\",                                                                            FN_PTR(updateCompilerThreadCanCallJava)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":23,"deletions":7,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1375,1 +1375,1 @@\n-    CompilerThreadCanCallJava ccj(THREAD, true);\n+    CompilerThreadCanCallJava ccj(THREAD, true, true);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.hotspot;\n+\n+\/**\n+ * Scope used to potentially change whether the current thread can make VM-to-Java calls.\n+ * A scope is exited by the {@link #close()} method so it should be used in a\n+ * try-with-resources statement.\n+ *\n+ * The scope does nothing if the current thread is not a HotSpot VM CompilerThread\n+ * for a JVMCI compiler.\n+ *\/\n+public class CompilerThreadCanCallJavaScope implements AutoCloseable {\n+\n+    \/**\n+     * Thread state used during the scope.\n+     *\/\n+    private final int rawPrevState;\n+\n+    \/**\n+     * Non-null iff the thread state needs resetting in {@link #close()}.\n+     *\/\n+    private final CompilerToVM vm;\n+\n+    \/**\n+     * The thread on which the constructor was called.\n+     *\/\n+    private final Thread thread;\n+\n+    \/**\n+     * Opens a scope to allow\/disallow the current thread to make VM-to-Java calls.\n+     * The scope is a no-op if the current thread is not a HotSpot VM CompilerThread\n+     * for a JVMCI compiler.\n+     *\n+     * @param newState true\/false to allow\/disallow VM-to-Java calls within the scope\n+     *\/\n+    public CompilerThreadCanCallJavaScope(boolean newState) {\n+        this.thread = Thread.currentThread();\n+        CompilerToVM vm = HotSpotJVMCIRuntime.runtime().getCompilerToVM();\n+        int rawNewState = newState ? 1 : 0;\n+        this.rawPrevState = vm.updateCompilerThreadCanCallJava(rawNewState);\n+        if (rawPrevState != rawNewState) {\n+            this.vm = vm;\n+        } else {\n+            this.vm = null;\n+        }\n+    }\n+\n+    \/**\n+     * Resets the state of the current thread with respect to whether it can make\n+     * VM-to-Java calls to what it was before the constructor was called.\n+     *\n+     * @throws IllegalStateException if called on a different thread than the constructor\n+     *\/\n+    @Override\n+    public void close() {\n+        if (this.thread != Thread.currentThread()) {\n+            throw new IllegalStateException();\n+        }\n+\n+        if (vm != null) {\n+            vm.updateCompilerThreadCanCallJava(rawPrevState);\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerThreadCanCallJavaScope.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -1517,0 +1517,10 @@\n+\n+    \/**\n+     * If the current thread is a {@code CompilerThread} associated with a JVMCI compiler where\n+     * {@code newState != CompilerThread::_can_call_java}, then {@code _can_call_java} is set\n+     * to {@code newState}.\n+     *\n+     * @return the previous {@code _can_call_java} value if change was made,\n+     * otherwise {@code newState}\n+     *\/\n+    native int updateCompilerThreadCanCallJava(int newState);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}