{"files":[{"patch":"@@ -110,0 +110,1 @@\n+    \/\/ Compiler context\n@@ -111,0 +112,1 @@\n+    private final Options options;\n@@ -116,3 +118,3 @@\n-    \/\/ Invariant: it's never the case that a category is in both \"values\" and \"suppressedValues\"\n-    private final EnumSet<LintCategory> values;\n-    private final EnumSet<LintCategory> suppressedValues;\n+    \/\/ For the root instance only, these are initialized lazily\n+    private EnumSet<LintCategory> values;           \/\/ categories enabled by default or \"-Xlint:key\" and not (yet) suppressed\n+    private EnumSet<LintCategory> suppressedValues; \/\/ categories suppressed by @SuppressWarnings, @Deprecated, or suppress()\n@@ -122,0 +124,1 @@\n+    \/\/ Instantiate the root instance\n@@ -124,2 +127,18 @@\n-        \/\/ initialize values according to the lint options\n-        Options options = Options.instance(context);\n+        this.context = context;\n+        context.put(lintKey, this);\n+        options = Options.instance(context);\n+    }\n+\n+    \/\/ Instantiate a non-root (\"symbol scoped\") instance\n+    protected Lint(Lint other) {\n+        other.initializeRootIfNeeded();\n+        this.context = other.context;\n+        this.options = other.options;\n+        this.syms = other.syms;\n+        this.names = other.names;\n+        this.values = other.values.clone();\n+        this.suppressedValues = other.suppressedValues.clone();\n+    }\n+\n+    \/\/ Process command line options on demand to allow use of root Lint early during startup\n+    private void initializeRootIfNeeded() {\n@@ -127,0 +146,5 @@\n+        \/\/ Already initialized?\n+        if (values != null)\n+            return;\n+\n+        \/\/ Initialize enabled categories based on \"-Xlint\" flags\n@@ -165,11 +189,0 @@\n-\n-        this.context = context;\n-        context.put(lintKey, this);\n-    }\n-\n-    protected Lint(Lint other) {\n-        this.context = other.context;\n-        this.syms = other.syms;\n-        this.names = other.names;\n-        this.values = other.values.clone();\n-        this.suppressedValues = other.suppressedValues.clone();\n@@ -180,0 +193,1 @@\n+        initializeRootIfNeeded();\n@@ -407,0 +421,1 @@\n+        initializeRootIfNeeded();\n@@ -417,0 +432,1 @@\n+        initializeRootIfNeeded();\n@@ -422,0 +438,14 @@\n+     *\n+     * @param log warning destination\n+     * @param warning key for the localized warning message\n+     *\/\n+    public void logIfEnabled(Log log, LintWarning warning) {\n+        logIfEnabled(log, null, warning);\n+    }\n+\n+    \/**\n+     * Helper method. Log a lint warning if its lint category is enabled.\n+     *\n+     * @param log warning destination\n+     * @param pos source position at which to report the warning\n+     * @param warning key for the localized warning message\n@@ -453,1 +483,1 @@\n-        initializeIfNeeded();\n+        initializeSymbolsIfNeeded();\n@@ -462,1 +492,1 @@\n-        initializeIfNeeded();\n+        initializeSymbolsIfNeeded();\n@@ -483,1 +513,1 @@\n-    private void initializeIfNeeded() {\n+    private void initializeSymbolsIfNeeded() {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":49,"deletions":19,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -71,0 +71,3 @@\n+    \/** flag: is the \"preview\" lint category enabled? *\/\n+    private final boolean verbose;\n+\n@@ -83,1 +86,0 @@\n-    private final Lint lint;\n@@ -104,1 +106,0 @@\n-        lint = Lint.instance(context);\n@@ -106,2 +107,2 @@\n-        this.previewHandler =\n-                new MandatoryWarningHandler(log, source, lint.isEnabled(LintCategory.PREVIEW), true, \"preview\", LintCategory.PREVIEW);\n+        verbose = Lint.instance(context).isEnabled(LintCategory.PREVIEW);\n+        previewHandler = new MandatoryWarningHandler(log, source, verbose, true, \"preview\", LintCategory.PREVIEW);\n@@ -179,6 +180,4 @@\n-        if (!lint.isSuppressed(LintCategory.PREVIEW)) {\n-            sourcesWithPreviewFeatures.add(log.currentSourceFile());\n-            previewHandler.report(pos, feature.isPlural() ?\n-                    LintWarnings.PreviewFeatureUsePlural(feature.nameFragment()) :\n-                    LintWarnings.PreviewFeatureUse(feature.nameFragment()));\n-        }\n+        sourcesWithPreviewFeatures.add(log.currentSourceFile());\n+        previewHandler.report(pos, feature.isPlural() ?\n+                LintWarnings.PreviewFeatureUsePlural(feature.nameFragment()) :\n+                LintWarnings.PreviewFeatureUse(feature.nameFragment()));\n@@ -194,1 +193,1 @@\n-        if (lint.isEnabled(LintCategory.PREVIEW)) {\n+        if (verbose) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+import com.sun.tools.javac.code.Lint;\n@@ -90,0 +91,1 @@\n+        lint = Lint.instance(context);\n@@ -91,1 +93,0 @@\n-        classLoaderClass = options.get(\"procloader\");\n@@ -93,9 +94,2 @@\n-        \/\/ Detect Lint options, but use Options.isLintSet() to avoid initializing the Lint class\n-        boolean warn = options.isLintSet(LintCategory.PATH.option);\n-        boolean fileClashOption = options.isLintSet(LintCategory.OUTPUT_FILE_CLASH.option);\n-        locations.update(log, warn, FSInfo.instance(context));\n-\n-        \/\/ Only track file clashes if enabled\n-        synchronized (this) {\n-            outputFilesWritten = fileClashOption ? new HashSet<>() : null;\n-        }\n+        \/\/ Initialize locations\n+        locations.update(log, lint, FSInfo.instance(context));\n@@ -115,6 +109,8 @@\n-        String s = options.get(\"fileManager.deferClose\");\n-        if (s != null) {\n-            try {\n-                deferredCloseTimeout = (int) (Float.parseFloat(s) * 1000);\n-            } catch (NumberFormatException e) {\n-                deferredCloseTimeout = 60 * 1000;  \/\/ default: one minute, in millis\n+        options.whenReady(options -> {\n+            String s = options.get(\"fileManager.deferClose\");\n+            if (s != null) {\n+                try {\n+                    deferredCloseTimeout = (int) (Float.parseFloat(s) * 1000);\n+                } catch (NumberFormatException e) {\n+                    deferredCloseTimeout = 60 * 1000;  \/\/ default: one minute, in millis\n+                }\n@@ -122,1 +118,1 @@\n-        }\n+        });\n@@ -141,1 +137,1 @@\n-    protected String classLoaderClass;\n+    protected Lint lint;\n@@ -145,2 +141,1 @@\n-    \/\/ This is non-null when output file clash detection is enabled\n-    private HashSet<Path> outputFilesWritten;\n+    private final HashSet<Path> outputFilesWritten = new HashSet<>();\n@@ -201,0 +196,1 @@\n+        String classLoaderClass = options.get(\"procloader\");\n@@ -246,0 +242,5 @@\n+\n+            @Override\n+            public void initialize() {\n+                options.initialize();\n+            }\n@@ -460,2 +461,1 @@\n-        if (outputFilesWritten != null)\n-            outputFilesWritten.clear();\n+        outputFilesWritten.clear();\n@@ -518,1 +518,1 @@\n-        if (outputFilesWritten == null)\n+        if (!lint.isEnabled(LintCategory.OUTPUT_FILE_CLASH))\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/BaseFileManager.java","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,0 +84,2 @@\n+import com.sun.tools.javac.code.Lint;\n+import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -129,1 +131,1 @@\n-     * Whether to warn about non-existent path elements\n+     * The root {@link Lint} instance.\n@@ -131,1 +133,1 @@\n-    private boolean warn;\n+    private Lint lint;\n@@ -173,1 +175,1 @@\n-    void update(Log log, boolean warn, FSInfo fsInfo) {\n+    void update(Log log, Lint lint, FSInfo fsInfo) {\n@@ -175,1 +177,1 @@\n-        this.warn = warn;\n+        this.lint = lint;\n@@ -226,3 +228,1 @@\n-                    if (warn) {\n-                        log.warning(LintWarnings.InvalidPath(s));\n-                    }\n+                    lint.logIfEnabled(log, LintWarnings.InvalidPath(s));\n@@ -316,1 +316,1 @@\n-            return addDirectories(dirs, warn);\n+            return addDirectories(dirs, true);\n@@ -322,2 +322,1 @@\n-                    log.warning(\n-                            LintWarnings.DirPathElementNotFound(dir));\n+                    lint.logIfEnabled(log, LintWarnings.DirPathElementNotFound(dir));\n@@ -343,1 +342,1 @@\n-            return addFiles(files, warn);\n+            return addFiles(files, true);\n@@ -356,1 +355,1 @@\n-            return addFiles(files, warn);\n+            return addFiles(files, true);\n@@ -368,2 +367,1 @@\n-                    log.warning(\n-                            LintWarnings.PathElementNotFound(file));\n+                    lint.logIfEnabled(log, LintWarnings.PathElementNotFound(file));\n@@ -391,2 +389,1 @@\n-                                log.warning(\n-                                        LintWarnings.UnexpectedArchiveFile(file));\n+                                lint.logIfEnabled(log, LintWarnings.UnexpectedArchiveFile(file));\n@@ -397,2 +394,1 @@\n-                                log.warning(\n-                                        LintWarnings.InvalidArchiveFile(file));\n+                                lint.logIfEnabled(log, LintWarnings.InvalidArchiveFile(file));\n@@ -1492,2 +1488,2 @@\n-                if (warn && false) {  \/\/ temp disable, when enabled, massage examples.not-yet.txt suitably.\n-                    log.warning(Warnings.LocnUnknownFileOnModulePath(p));\n+                if (false) {  \/\/ temp disable, when enabled, massage examples.not-yet.txt suitably.\n+                    log.warning(LintWarnings.LocnUnknownFileOnModulePath(p));\n@@ -1661,6 +1657,3 @@\n-                if (warn) {\n-                    Warning key = Files.exists(prefix)\n-                            ? LintWarnings.DirPathElementNotDirectory(prefix)\n-                            : LintWarnings.DirPathElementNotFound(prefix);\n-                    log.warning(key);\n-                }\n+                lint.logIfEnabled(log, Files.exists(prefix) ?\n+                    LintWarnings.DirPathElementNotDirectory(prefix) :\n+                    LintWarnings.DirPathElementNotFound(prefix));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/Locations.java","additions":20,"deletions":27,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,0 @@\n-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n@@ -123,4 +122,0 @@\n-   \/** Lint option: warn about classfile issues\n-     *\/\n-    boolean lintClassfile;\n-\n@@ -147,0 +142,3 @@\n+    \/** The root Lint config. *\/\n+    Lint lint;\n+\n@@ -308,1 +306,1 @@\n-        lintClassfile = Lint.instance(context).isEnabled(LintCategory.CLASSFILE);\n+        lint = Lint.instance(context);\n@@ -856,1 +854,1 @@\n-                if (lintClassfile && !warnedAttrs.contains(name)) {\n+                if (!warnedAttrs.contains(name)) {\n@@ -859,1 +857,1 @@\n-                        log.warning((DiagnosticPosition) null,\n+                        lint.logIfEnabled(log,\n@@ -1613,3 +1611,1 @@\n-            if (lintClassfile) {\n-                log.warning(LintWarnings.RuntimeVisibleInvisibleParamAnnotationsMismatch(currentClassFile));\n-            }\n+            lint.logIfEnabled(log, LintWarnings.RuntimeVisibleInvisibleParamAnnotationsMismatch(currentClassFile));\n@@ -2080,5 +2076,4 @@\n-                if (lintClassfile) {\n-                    if (failure == null) {\n-                        log.warning(LintWarnings.AnnotationMethodNotFound(container, name));\n-                    } else {\n-                        log.warning(LintWarnings.AnnotationMethodNotFoundReason(container,\n+                if (failure == null) {\n+                    lint.logIfEnabled(log, LintWarnings.AnnotationMethodNotFound(container, name));\n+                } else {\n+                    lint.logIfEnabled(log, LintWarnings.AnnotationMethodNotFoundReason(container,\n@@ -2087,1 +2082,0 @@\n-                    }\n@@ -2963,3 +2957,1 @@\n-        if (lintClassfile) {\n-            log.warning(LintWarnings.RuntimeInvisibleParameterAnnotations(currentClassFile));\n-        }\n+        lint.logIfEnabled(log, LintWarnings.RuntimeInvisibleParameterAnnotations(currentClassFile));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":13,"deletions":21,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -168,0 +168,5 @@\n+        @Override\n+        public void initialize() {\n+            options.initialize();\n+        }\n+\n@@ -223,0 +228,5 @@\n+\n+        @Override\n+        public void initialize() {\n+            options.initialize();\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/Arguments.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1158,0 +1158,1 @@\n+        helper.initialize();\n@@ -1211,0 +1212,1 @@\n+        helper.initialize();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/Option.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,0 +88,5 @@\n+    \/**\n+     * Initialize this instance, as needed, if not already initialized.\n+     *\/\n+    public abstract void initialize();\n+\n@@ -142,0 +147,4 @@\n+        @Override\n+        public void initialize() {\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/OptionHelper.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -341,0 +341,1 @@\n+    Lint lint;\n@@ -347,2 +348,0 @@\n-    private final boolean lint;\n-\n@@ -425,1 +424,1 @@\n-        lint = (Lint.instance(context)).isEnabled(PROCESSING);\n+        lint = Lint.instance(context);\n@@ -490,1 +489,1 @@\n-        if (lint) {\n+        if (lint.isEnabled(PROCESSING)) {\n@@ -711,2 +710,1 @@\n-            if (lint)\n-                log.warning(LintWarnings.ProcIllegalFileName(name));\n+            lint.logIfEnabled(log, LintWarnings.ProcIllegalFileName(name));\n@@ -740,2 +738,1 @@\n-            if (lint)\n-                log.warning(LintWarnings.ProcTypeRecreate(typename));\n+            lint.logIfEnabled(log, LintWarnings.ProcTypeRecreate(typename));\n@@ -744,2 +741,2 @@\n-        if (lint && existing != null) {\n-            log.warning(LintWarnings.ProcTypeAlreadyExists(typename));\n+        if (existing != null) {\n+            lint.logIfEnabled(log, LintWarnings.ProcTypeAlreadyExists(typename));\n@@ -774,2 +771,1 @@\n-            if (lint)\n-                log.warning(LintWarnings.ProcFileReopening(fileObject.getName()));\n+            lint.logIfEnabled(log, LintWarnings.ProcFileReopening(fileObject.getName()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacFiler.java","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,1 +113,0 @@\n-    private final boolean lint;\n@@ -126,0 +125,1 @@\n+    private final Lint lint;\n@@ -208,1 +208,1 @@\n-        lint = Lint.instance(context).isEnabled(PROCESSING);\n+        lint = Lint.instance(context);\n@@ -628,1 +628,1 @@\n-                       boolean allowModules, ProcessingEnvironment env, boolean lint) {\n+                       boolean allowModules, ProcessingEnvironment env, Lint lint) {\n@@ -651,2 +651,2 @@\n-                    if (lint && !patternAdded) {\n-                        log.warning(LintWarnings.ProcDuplicateSupportedAnnotation(annotationPattern,\n+                    if (!patternAdded) {\n+                        lint.logIfEnabled(log, LintWarnings.ProcDuplicateSupportedAnnotation(annotationPattern,\n@@ -663,2 +663,1 @@\n-                if (lint &&\n-                    supportedAnnotationPatterns.contains(MatchingUtils.validImportStringToPattern(\"*\")) &&\n+                if (supportedAnnotationPatterns.contains(MatchingUtils.validImportStringToPattern(\"*\")) &&\n@@ -666,1 +665,1 @@\n-                    log.warning(LintWarnings.ProcRedundantTypesWithWildcard(p.getClass().getName()));\n+                    lint.logIfEnabled(log, LintWarnings.ProcRedundantTypesWithWildcard(p.getClass().getName()));\n@@ -673,2 +672,2 @@\n-                        if (lint && !optionAdded) {\n-                            log.warning(LintWarnings.ProcDuplicateOptionName(optionName,\n+                        if (!optionAdded) {\n+                            lint.logIfEnabled(log, LintWarnings.ProcDuplicateOptionName(optionName,\n@@ -891,1 +890,1 @@\n-        if (lint && unmatchedAnnotations.size() > 0) {\n+        if (lint.isEnabled(PROCESSING) && unmatchedAnnotations.size() > 0) {\n@@ -1664,1 +1663,1 @@\n-    private static Pattern importStringToPattern(boolean allowModules, String s, Processor p, Log log, boolean lint) {\n+    private static Pattern importStringToPattern(boolean allowModules, String s, Processor p, Log log, Lint lint) {\n@@ -1690,4 +1689,2 @@\n-    private static Pattern warnAndNoMatches(String s, Processor p, Log log, boolean lint) {\n-        if (lint) {\n-            log.warning(LintWarnings.ProcMalformedSupportedString(s, p.getClass().getName()));\n-        }\n+    private static Pattern warnAndNoMatches(String s, Processor p, Log log, Lint lint) {\n+        lint.logIfEnabled(log, LintWarnings.ProcMalformedSupportedString(s, p.getClass().getName()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":14,"deletions":17,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1573,0 +1573,1 @@\n+# lint: path\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,4 +76,1 @@\n-\n-            final Options options = Options.instance(context);\n-            initOptions(options);\n-            options.addListener(() -> initOptions(options));\n+            Options.instance(context).whenReady(this::initOptions);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/JCDiagnostic.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,1 +93,9 @@\n-        Options options = Options.instance(context);\n+\n+        \/\/ Initialize fields configured by Options that we may need before it is ready\n+        diagFormatter = new BasicDiagnosticFormatter(this);\n+\n+        \/\/ Once Options is ready, complete the initialization\n+        Options.instance(context).whenReady(this::initOptions);\n+    }\n+\n+    private void initOptions(Options options) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/JavacMessages.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -348,0 +348,7 @@\n+        \/\/ Initialize fields configured by Options that we may need before it is ready\n+        this.emitWarnings = true;\n+        this.MaxErrors = getDefaultMaxErrors();\n+        this.MaxWarnings = getDefaultMaxWarnings();\n+        this.diagFormatter = new BasicDiagnosticFormatter(messages);\n+\n+        \/\/ Once Options is ready, complete the initialization\n@@ -349,2 +356,1 @@\n-        initOptions(options);\n-        options.addListener(() -> initOptions(options));\n+        options.whenReady(this::initOptions);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Log.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n@@ -37,0 +39,12 @@\n+ * <p>\n+ * Instances start in an uninitialized\/empty state. They transition to the initialized state once they start\n+ * being populated from the flags and arguments provided to the compiler, or manually via {@link #initialize}.\n+ *\n+ * <p>\n+ * Because {@link Options} singletons are used to configure many other compiler singletons, depending on how\n+ * the compiler is invoked, it's possible for some of these singletons to query options before they have been\n+ * populated. If this happens, null\/false is returned, and then if\/when listeners are notified (indicating that\n+ * the population process is complete), if it turns out that the actual option value is different from what was\n+ * previously returned, then an assertion error is generated (as this would indicate a startup ordering bug).\n+ * To fix, change the initialization order or have the singleton initialize itself using {@link #whenReady}.\n+ *\n@@ -48,1 +62,2 @@\n-    private LinkedHashMap<String,String> values;\n+    private final LinkedHashMap<String,String> values;\n+    private boolean initialized;\n@@ -65,0 +80,7 @@\n+    \/**\n+     * Mark this instance as ready to accept queries.\n+     *\/\n+    public void initialize() {\n+        initialized = true;\n+    }\n+\n@@ -67,0 +89,2 @@\n+     *\n+     * @param name option name\n@@ -69,1 +93,1 @@\n-        return values.get(name);\n+        return computeIfReady(() -> values.get(name), null, Option.XD.primaryName + name);\n@@ -74,0 +98,2 @@\n+     *\n+     * @param option option to get\n@@ -76,1 +102,1 @@\n-        return values.get(option.primaryName);\n+        return computeIfReady(() -> values.get(option.primaryName), null, option.primaryName);\n@@ -80,1 +106,1 @@\n-     * Get the boolean value for an option, patterned after Boolean.getBoolean,\n+     * Get the boolean value for an undocumented option, patterned after Boolean.getBoolean,\n@@ -82,0 +108,2 @@\n+     *\n+     * @param name option name\n@@ -88,1 +116,4 @@\n-     * Get the boolean with a default value if the option is not set.\n+     * Get the undocumented boolean with a default value if the option is not set.\n+     *\n+     * @param name option name\n+     * @param defaultValue return value if option is not set\n@@ -91,2 +122,7 @@\n-        String value = get(name);\n-        return (value == null) ? defaultValue : Boolean.parseBoolean(value);\n+        return computeIfReady(\n+            () -> Optional.of(name)\n+                  .map(values::get)\n+                  .map(Boolean::parseBoolean)\n+                  .orElse(defaultValue),\n+            defaultValue,\n+            Option.XD.primaryName + name);\n@@ -99,1 +135,1 @@\n-        return (values.get(name) != null);\n+        return computeIfReady(() -> values.get(name) != null, false, Option.XD.primaryName + name);\n@@ -106,1 +142,1 @@\n-        return (values.get(option.primaryName) != null);\n+        return computeIfReady(() -> values.get(option.primaryName) != null, false, option.primaryName);\n@@ -113,13 +149,1 @@\n-        return (values.get(option.primaryName + value) != null);\n-    }\n-\n-    \/** Check if the value for a lint option has been explicitly set, either with -Xlint:opt\n-     *  or if all lint options have enabled and this one not disabled with -Xlint:-opt.\n-     *\/\n-    public boolean isLintSet(String s) {\n-        \/\/ return true if either the specific option is enabled, or\n-        \/\/ they are all enabled without the specific one being\n-        \/\/ disabled\n-        return\n-            isSet(XLINT_CUSTOM, s) ||\n-            (isSet(XLINT) || isSet(XLINT_CUSTOM, \"all\")) && isUnset(XLINT_CUSTOM, \"-\" + s);\n+        return computeIfReady(() -> values.get(option.primaryName + value) != null, false, option.primaryName + value);\n@@ -132,1 +156,1 @@\n-        return (values.get(name) == null);\n+        return !isSet(name);\n@@ -139,1 +163,1 @@\n-        return (values.get(option.primaryName) == null);\n+        return !isSet(option);\n@@ -146,1 +170,1 @@\n-        return (values.get(option.primaryName + value) == null);\n+        return !isSet(option, value);\n@@ -151,0 +175,1 @@\n+        initialized = true;\n@@ -155,0 +180,1 @@\n+        initialized = true;\n@@ -159,0 +185,1 @@\n+        initialized = true;\n@@ -163,0 +190,1 @@\n+        initialized = true;\n@@ -182,0 +210,1 @@\n+        initialized = true;\n@@ -184,0 +213,1 @@\n+        listeners = List.nil();\n@@ -189,0 +219,26 @@\n+        initialized = false;\n+    }\n+\n+    \/**\n+     * Perform the given action once this instance is ready for queries,\n+     * or immediately if it is ready now.\n+     *\n+     * @param action action to take; will be given this instance\n+     *\/\n+    public void whenReady(Consumer<? super Options> action) {\n+        if (initialized)\n+            action.accept(this);\n+        else\n+            addListener(() -> action.accept(this));\n+    }\n+\n+    \/**\n+     * Return the computed value if initialized, otherwise return the given default value\n+     * and add a notify listener that asserts that our assumption was correct.\n+     *\/\n+    private <T> T computeIfReady(Supplier<T> ifReady, T ifNotReady, String flag) {\n+        \/\/System.out.println(\"computeIfReady(\"+initialized+\"): \\\"\"+flag+\"\\\" -> \" + ifReady.get());\n+        if (initialized)\n+            return ifReady.get();\n+        addListener(() -> Assert.check(Objects.equals(ifReady.get(), ifNotReady), () -> \"ignored flag: \" + flag));\n+        return ifNotReady;          \/\/ hopefully this is correct...\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Options.java","additions":82,"deletions":26,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8347474\n+ * @summary Verify -XDrawDiagnostics flag is picked up by JavacMessages singleton\n+ * @library \/tools\/lib\n+ * @modules\n+ *  jdk.compiler\/com.sun.tools.javac.api\n+ *  jdk.compiler\/com.sun.tools.javac.file\n+ *  jdk.compiler\/com.sun.tools.javac.main\n+ *  jdk.compiler\/com.sun.tools.javac.util:+open\n+ *\/\n+\n+import java.io.PrintWriter;\n+import java.io.Writer;\n+import java.lang.reflect.Field;\n+import java.net.URI;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Objects;\n+\n+import com.sun.tools.javac.file.JavacFileManager;\n+import com.sun.tools.javac.main.Main;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.JavacMessages;\n+import com.sun.tools.javac.util.RawDiagnosticFormatter;\n+\n+import toolbox.JavacTask;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+\n+public class OptionsOrderingTest extends TestRunner {\n+\n+    protected final ToolBox tb;\n+\n+    public OptionsOrderingTest() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void testJavacMessagesDiagFormatter() throws Exception {\n+\n+        \/\/ Write source file\n+        Path dir = Paths.get(getClass().getSimpleName());\n+        tb.writeJavaFiles(dir, \"class Test { }\");\n+\n+        \/\/ Run the compiler where we supply the Context\n+        Context context = new Context();\n+        JavacFileManager.preRegister(context);\n+        Main compiler = new Main(\"javac\", new PrintWriter(Writer.nullWriter()));\n+        String[] args = new String[] {\n+          \"-XDrawDiagnostics\",\n+          tb.findJavaFiles(dir)[0].toString()\n+        };\n+        Main.Result result = compiler.compile(args, context);\n+\n+        \/\/ Verify field JavacMessages.diagFormatter is a RawDiagnosticFormatter\n+        JavacMessages messages = JavacMessages.instance(context);\n+        Field diagFormatterField = messages.getClass().getDeclaredField(\"diagFormatter\");\n+        diagFormatterField.setAccessible(true);\n+        Class<?> diagFormatterClass = diagFormatterField.get(messages).getClass();\n+        if (!Objects.equals(diagFormatterClass, RawDiagnosticFormatter.class)) {\n+            throw new AssertionError(String.format(\n+              \"diagFormatter: expected %s but found %s\",\n+              RawDiagnosticFormatter.class, diagFormatterClass));\n+        }\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new OptionsOrderingTest().testJavacMessagesDiagFormatter();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/options\/OptionsOrderingTest.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"}]}