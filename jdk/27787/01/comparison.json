{"files":[{"patch":"@@ -64,0 +64,1 @@\n+import java.util.concurrent.CompletionException;\n@@ -78,0 +79,1 @@\n+import java.util.function.Function;\n@@ -977,0 +979,3 @@\n+            \/\/ Exceptions are often thrown from asynchronous code, making it\n+            \/\/ difficult to trace back to the user's original entry point.\n+            \/\/ Wrap exceptions explicitly to preserve that context.\n@@ -1105,0 +1110,1 @@\n+            res = translateSendAsyncExecFailure(res);\n@@ -1124,0 +1130,23 @@\n+    \/**\n+     * {@return a new {@code CompletableFuture} wrapping the\n+     * {@link #sendAsync(HttpRequest, BodyHandler, PushPromiseHandler, Executor) sendAsync()}\n+     * execution failures with, as per specification, {@link IOException}, if necessary}\n+     *\/\n+    private static <T> CompletableFuture<HttpResponse<T>> translateSendAsyncExecFailure(\n+            CompletableFuture<HttpResponse<T>> responseFuture) {\n+            return responseFuture\n+                    .handle((response, exception) -> {\n+                        if (exception == null) {\n+                            return MinimalFuture.completedFuture(response);\n+                        }\n+                        var unwrappedException = Utils.getCompletionCause(exception);\n+                        \/\/ Except `Error`s, wrap failures inside an `IOException`.\n+                        \/\/ This is required to comply with the specification of `HttpClient::sendAsync`.\n+                        var translatedException = unwrappedException instanceof Error\n+                                ? unwrappedException\n+                                : Utils.toIOException(exception);\n+                        return MinimalFuture.<HttpResponse<T>>failedFuture(translatedException);\n+                    })\n+                    .thenCompose(Function.identity());\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -670,2 +670,2 @@\n-            return UncheckedIOException.class.isInstance(throwable)\n-                    && CustomIOException.class.isInstance(throwable.getCause());\n+            \/\/ `UncheckedIOException` is peeled off by `HttpClientImpl::translateSendAsyncExecFailure`\n+            return throwable instanceof CustomIOException;\n","filename":"test\/jdk\/java\/net\/httpclient\/AbstractThrowingPublishers.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -682,2 +682,2 @@\n-            return UncheckedIOException.class.isInstance(throwable)\n-                    && CustomIOException.class.isInstance(throwable.getCause());\n+            \/\/ `UncheckedIOException` is peeled off by `HttpClientImpl::translateSendAsyncExecFailure`\n+            return throwable instanceof CustomIOException;\n","filename":"test\/jdk\/java\/net\/httpclient\/AbstractThrowingSubscribers.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,258 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import javax.net.ssl.SSLParameters;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.lang.reflect.Method;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpHeaders;\n+import java.net.http.HttpOption;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.UnsupportedProtocolVersionException;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Consumer;\n+\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8368249\n+ * @summary Verifies exceptions thrown by `HttpClient::sendAsync`\n+ * @library \/test\/jdk\/java\/net\/httpclient\/lib \/test\/lib\n+ * @run junit HttpClientSendAsyncExceptionTest\n+ *\/\n+\n+class HttpClientSendAsyncExceptionTest {\n+\n+    @Test\n+    void testClosedClient() {\n+        var client = HttpClient.newHttpClient();\n+        client.close();\n+        var exception = assertThrows(ExecutionException.class, () -> {\n+            var request = HttpRequest.newBuilder(URI.create(\"https:\/\/example.com\")).GET().build();\n+            var responseBodyHandler = HttpResponse.BodyHandlers.discarding();\n+            client.sendAsync(request, responseBodyHandler).get();\n+        });\n+        var cause = assertThrowableInstanceOf(IOException.class, exception.getCause());\n+        assertContains(cause.getMessage(), \"closed\");\n+    }\n+\n+    @Test\n+    void testH3IncompatClient() {\n+        SSLParameters h3IncompatSslParameters = new SSLParameters(new String[0], new String[]{\"foo\"});\n+        try (var h3IncompatClient = HttpClient.newBuilder()\n+                \/\/ Provide `SSLParameters` incompatible with QUIC's TLS requirements to disarm the HTTP\/3 support\n+                .sslParameters(h3IncompatSslParameters)\n+                .build()) {\n+            var exception = assertThrows(ExecutionException.class, () -> {\n+                var h3Request = HttpRequest.newBuilder(URI.create(\"https:\/\/example.com\"))\n+                        .GET()\n+                        .version(HttpClient.Version.HTTP_3)\n+                        .setOption(HttpOption.H3_DISCOVERY, HttpOption.Http3DiscoveryMode.HTTP_3_URI_ONLY)\n+                        .build();\n+                var responseBodyHandler = HttpResponse.BodyHandlers.discarding();\n+                h3IncompatClient.sendAsync(h3Request, responseBodyHandler).get();\n+            });\n+            var cause = assertThrowableInstanceOf(UnsupportedProtocolVersionException.class, exception.getCause());\n+            assertEquals(\"HTTP3 is not supported\", cause.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    void testConnectMethod() {\n+        try (var client = HttpClient.newHttpClient()) {\n+            var exception = assertThrows(IllegalArgumentException.class, () -> {\n+                \/\/ The default `HttpRequest` builder does not allow `CONNECT`.\n+                \/\/ Hence, we create our custom `HttpRequest` instance:\n+                var connectRequest = new HttpRequest() {\n+\n+                    @Override\n+                    public Optional<BodyPublisher> bodyPublisher() {\n+                        return Optional.empty();\n+                    }\n+\n+                    @Override\n+                    public String method() {\n+                        return \"CONNECT\";\n+                    }\n+\n+                    @Override\n+                    public Optional<Duration> timeout() {\n+                        return Optional.empty();\n+                    }\n+\n+                    @Override\n+                    public boolean expectContinue() {\n+                        return false;\n+                    }\n+\n+                    @Override\n+                    public URI uri() {\n+                        return URI.create(\"https:\/\/example.com\");\n+                    }\n+\n+                    @Override\n+                    public Optional<HttpClient.Version> version() {\n+                        return Optional.empty();\n+                    }\n+\n+                    @Override\n+                    public HttpHeaders headers() {\n+                        return HttpHeaders.of(Collections.emptyMap(), (_, _) -> true);\n+                    }\n+\n+                };\n+                var responseBodyHandler = HttpResponse.BodyHandlers.discarding();\n+                client.sendAsync(connectRequest, responseBodyHandler);\n+            });\n+            assertContains(exception.getMessage(), \"Unsupported method CONNECT\");\n+        }\n+    }\n+\n+    static List<ExceptionTestCase> exceptionTestCases() {\n+\n+        \/\/ `RuntimeException`\n+        List<ExceptionTestCase> testCases = new ArrayList<>();\n+        var runtimeException = new RuntimeException();\n+        testCases.add(new ExceptionTestCase(\n+                \"RuntimeException\",\n+                _ -> { throw runtimeException; },\n+                exception -> {\n+                    assertThrowableInstanceOf(IOException.class, exception);\n+                    assertThrowableSame(runtimeException, exception.getCause());\n+                }));\n+\n+        \/\/ `Error`\n+        var error = new Error();\n+        testCases.add(new ExceptionTestCase(\n+                \"Error\",\n+                _ -> { throw error; },\n+                exception -> assertThrowableSame(error, exception)));\n+\n+        \/\/ `IOException` (needs sneaky throw)\n+        var ioException = new IOException();\n+        testCases.add(new ExceptionTestCase(\n+                \"IOException\",\n+                _ -> { sneakyThrow(ioException); throw new AssertionError(); },\n+                exception -> assertThrowableSame(ioException, exception)));\n+\n+        \/\/ `UncheckedIOException`\n+        var uncheckedIOException = new UncheckedIOException(ioException);\n+        testCases.add(new ExceptionTestCase(\n+                \"UncheckedIOException(IOException)\",\n+                _ -> { throw uncheckedIOException; },\n+                exception -> assertThrowableSame(ioException, exception)));\n+\n+        return testCases;\n+\n+    }\n+\n+    private static <T extends Throwable> T assertThrowableInstanceOf(Class<T> expectedClass, Throwable actual) {\n+        if (!expectedClass.isInstance(actual)) {\n+            var message = \"Was expecting `%s`\".formatted(expectedClass.getCanonicalName());\n+            throw new AssertionError(message, actual);\n+        }\n+        return expectedClass.cast(actual);\n+    }\n+\n+    private static void assertThrowableSame(Throwable expected, Throwable actual) {\n+        if (expected != actual) {\n+            var message = \"Was expecting `%s`\".formatted(expected.getClass().getCanonicalName());\n+            throw new AssertionError(message, actual);\n+        }\n+    }\n+\n+    private record ExceptionTestCase(\n+            String description,\n+            HttpResponse.BodyHandler<Void> throwingResponseBodyHandler,\n+            Consumer<Throwable> exceptionVerifier) {\n+\n+        @Override\n+        public String toString() {\n+            return description;\n+        }\n+\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static <T extends Throwable> void sneakyThrow(Throwable throwable) throws T {\n+        throw (T) throwable;\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"exceptionTestCases\")\n+    void testIOExceptionWrap(ExceptionTestCase testCase, TestInfo testInfo) throws Exception {\n+        var version = HttpClient.Version.HTTP_1_1;\n+        try (var server = HttpServerAdapters.HttpTestServer.create(version);\n+             var client = HttpServerAdapters.createClientBuilderFor(version).proxy(NO_PROXY).build()) {\n+\n+            \/\/ Configure the server to respond with 200 containing a single byte\n+            var serverHandlerPath = \"\/%s\/%s\/\".formatted(\n+                    testInfo.getTestClass().map(Class::getSimpleName).orElse(\"unknown-class\"),\n+                    testInfo.getTestMethod().map(Method::getName).orElse(\"unknown-method\"));\n+            HttpServerAdapters.HttpTestHandler serverHandler = exchange -> {\n+                try (exchange) {\n+                    exchange.sendResponseHeaders(200, 1);\n+                    exchange.getResponseBody().write(new byte[]{0});\n+                }\n+            };\n+            server.addHandler(serverHandler, serverHandlerPath);\n+            server.start();\n+\n+            \/\/ Verify the execution failure\n+            var requestUri = URI.create(\"http:\/\/\" + server.serverAuthority() + serverHandlerPath);\n+            var request = HttpRequest.newBuilder(requestUri).version(version).build();\n+            var exception = assertThrows(\n+                    ExecutionException.class,\n+                    \/\/ We need to make `sendAsync()` execution fail.\n+                    \/\/ There are several ways to achieve this.\n+                    \/\/ We choose to use a throwing response handler.\n+                    () -> client.sendAsync(request, testCase.throwingResponseBodyHandler).get());\n+            testCase.exceptionVerifier.accept(exception.getCause());\n+\n+        }\n+\n+    }\n+\n+    private static void assertContains(String target, String expected) {\n+        assertTrue(target.contains(expected), \"does not contain `\" + expected + \"`: \" + target);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpClientSendAsyncExceptionTest.java","additions":258,"deletions":0,"binary":false,"changes":258,"status":"added"},{"patch":"@@ -57,1 +57,0 @@\n-import com.sun.net.httpserver.HttpServer;\n@@ -69,1 +68,0 @@\n-import java.net.InetAddress;\n@@ -297,9 +295,2 @@\n-                Throwable cause = x;\n-                if (x instanceof CompletionException || x instanceof ExecutionException) {\n-                    cause = x.getCause();\n-                }\n-                if (cause instanceof IOException && cause.getCause() != null) {\n-                    cause = cause.getCause();\n-                }\n-                if (cause instanceof IllegalArgumentException) {\n-                    System.out.println(\"Got expected exception: \" + cause);\n+                if (throwableCausalChainContainsInstanceOf(IllegalArgumentException.class, x)) {\n+                    System.out.println(\"Got expected exception: \" + x);\n@@ -363,9 +354,2 @@\n-                Throwable cause = x;\n-                if (x instanceof CompletionException || x instanceof ExecutionException) {\n-                    cause = x.getCause();\n-                }\n-                if (cause instanceof IOException && cause.getCause() != null) {\n-                    cause = cause.getCause();\n-                }\n-                if (cause instanceof IllegalArgumentException) {\n-                    System.out.println(\"Got expected exception: \" + cause);\n+                if (throwableCausalChainContainsInstanceOf(IllegalArgumentException.class, x)) {\n+                    System.out.println(\"Got expected exception: \" + x);\n@@ -416,9 +400,2 @@\n-                Throwable cause = x;\n-                if (x instanceof CompletionException || x instanceof ExecutionException) {\n-                    cause = x.getCause();\n-                }\n-                if (cause instanceof IOException && cause.getCause() != null) {\n-                    cause = cause.getCause();\n-                }\n-                if (cause instanceof IllegalArgumentException) {\n-                    System.out.println(\"Got expected exception: \" + cause);\n+                if (throwableCausalChainContainsInstanceOf(IllegalArgumentException.class, x)) {\n+                    System.out.println(\"Got expected exception: \" + x);\n@@ -476,9 +453,2 @@\n-                Throwable cause = x;\n-                if (x instanceof CompletionException || x instanceof ExecutionException) {\n-                    cause = x.getCause();\n-                }\n-                if (cause instanceof IOException && cause.getCause() != null) {\n-                    cause = cause.getCause();\n-                }\n-                if (cause instanceof IllegalArgumentException) {\n-                    System.out.println(\"Got expected exception: \" + cause);\n+                if (throwableCausalChainContainsInstanceOf(IllegalArgumentException.class, x)) {\n+                    System.out.println(\"Got expected exception: \" + x);\n@@ -506,0 +476,11 @@\n+    private static boolean throwableCausalChainContainsInstanceOf(\n+            Class<? extends Throwable> expectedClass,\n+            Throwable throwable) {\n+        for (Throwable t = throwable; t != null; t = t.getCause()) {\n+            if (expectedClass.isInstance(t)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n@@ -561,5 +542,0 @@\n-    static String serverAuthority(HttpServer server) {\n-        return InetAddress.getLoopbackAddress().getHostName() + \":\"\n-                + server.getAddress().getPort();\n-    }\n-\n","filename":"test\/jdk\/java\/net\/httpclient\/InvalidInputStreamSubscriptionRequest.java","additions":19,"deletions":43,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -343,2 +343,1 @@\n-            if (expectedException != null\n-                    && !expectedException.isAssignableFrom(e.getClass())) {\n+            if (!throwableCausalChainContainsInstanceOf(expectedException, e)) {\n@@ -363,0 +362,11 @@\n+\n+    private static boolean throwableCausalChainContainsInstanceOf(\n+            Class<? extends Throwable> expectedClass,\n+            Throwable throwable) {\n+        for (Throwable t = throwable; t != null; t = t.getCause()) {\n+            if (expectedClass.isInstance(t)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n","filename":"test\/jdk\/java\/net\/httpclient\/http3\/H3QuicTLSConnection.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import java.util.concurrent.ExecutionException;\n@@ -162,6 +161,2 @@\n-            if (actualException instanceof CancellationException) {\n-                \/\/ expected\n-                System.out.println(\"Received the expected CancellationException\");\n-            } else if (actualException instanceof ExecutionException\n-                    && actualException.getCause() instanceof CancellationException) {\n-                System.out.println(\"Received CancellationException wrapped as ExecutionException\");\n+            if (throwableCausalChainContainsInstanceOf(CancellationException.class, actualException)) {\n+                System.out.println(\"Received the expected `CancellationException` in the causal chain\");\n@@ -189,0 +184,11 @@\n+    private static boolean throwableCausalChainContainsInstanceOf(\n+            Class<? extends Throwable> expectedClass,\n+            Throwable throwable) {\n+        for (Throwable t = throwable; t != null; t = t.getCause()) {\n+            if (expectedClass.isInstance(t)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/http3\/StopSendingTest.java","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"}]}