{"files":[{"patch":"@@ -979,3 +979,6 @@\n-            \/\/ Exceptions are often thrown from asynchronous code, making it\n-            \/\/ difficult to trace back to the user's original entry point.\n-            \/\/ Wrap exceptions explicitly to preserve that context.\n+            \/\/ Exceptions are often thrown from asynchronous code, and the\n+            \/\/ stacktrace may not always contain the application classes. That\n+            \/\/ makes it difficult to trace back to the application code which\n+            \/\/ invoked the `HttpClient`. Here we instantiate\/recreate the\n+            \/\/ exceptions to capture the application's calling code in the\n+            \/\/ stacktrace of the thrown exception.\n@@ -1148,0 +1151,1 @@\n+                                || unwrappedException instanceof IOException\n@@ -1149,1 +1153,1 @@\n-                                : Utils.toIOException(exception);\n+                                : new IOException(unwrappedException);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -69,5 +69,4 @@\n-        var exception = assertThrows(ExecutionException.class, () -> {\n-            var request = HttpRequest.newBuilder(URI.create(\"https:\/\/example.com\")).GET().build();\n-            var responseBodyHandler = HttpResponse.BodyHandlers.discarding();\n-            client.sendAsync(request, responseBodyHandler).get();\n-        });\n+        var request = HttpRequest.newBuilder(URI.create(\"https:\/\/example.com\")).GET().build();\n+        var responseBodyHandler = HttpResponse.BodyHandlers.discarding();\n+        var responseFuture = client.sendAsync(request, responseBodyHandler);\n+        var exception = assertThrows(ExecutionException.class, responseFuture::get);\n@@ -85,9 +84,8 @@\n-            var exception = assertThrows(ExecutionException.class, () -> {\n-                var h3Request = HttpRequest.newBuilder(URI.create(\"https:\/\/example.com\"))\n-                        .GET()\n-                        .version(HttpClient.Version.HTTP_3)\n-                        .setOption(HttpOption.H3_DISCOVERY, HttpOption.Http3DiscoveryMode.HTTP_3_URI_ONLY)\n-                        .build();\n-                var responseBodyHandler = HttpResponse.BodyHandlers.discarding();\n-                h3IncompatClient.sendAsync(h3Request, responseBodyHandler).get();\n-            });\n+            var h3Request = HttpRequest.newBuilder(URI.create(\"https:\/\/example.com\"))\n+                    .GET()\n+                    .version(HttpClient.Version.HTTP_3)\n+                    .setOption(HttpOption.H3_DISCOVERY, HttpOption.Http3DiscoveryMode.HTTP_3_URI_ONLY)\n+                    .build();\n+            var responseBodyHandler = HttpResponse.BodyHandlers.discarding();\n+            var responseFuture = h3IncompatClient.sendAsync(h3Request, responseBodyHandler);\n+            var exception = assertThrows(ExecutionException.class, responseFuture::get);\n@@ -102,44 +100,44 @@\n-            var exception = assertThrows(IllegalArgumentException.class, () -> {\n-                \/\/ The default `HttpRequest` builder does not allow `CONNECT`.\n-                \/\/ Hence, we create our custom `HttpRequest` instance:\n-                var connectRequest = new HttpRequest() {\n-\n-                    @Override\n-                    public Optional<BodyPublisher> bodyPublisher() {\n-                        return Optional.empty();\n-                    }\n-\n-                    @Override\n-                    public String method() {\n-                        return \"CONNECT\";\n-                    }\n-\n-                    @Override\n-                    public Optional<Duration> timeout() {\n-                        return Optional.empty();\n-                    }\n-\n-                    @Override\n-                    public boolean expectContinue() {\n-                        return false;\n-                    }\n-\n-                    @Override\n-                    public URI uri() {\n-                        return URI.create(\"https:\/\/example.com\");\n-                    }\n-\n-                    @Override\n-                    public Optional<HttpClient.Version> version() {\n-                        return Optional.empty();\n-                    }\n-\n-                    @Override\n-                    public HttpHeaders headers() {\n-                        return HttpHeaders.of(Collections.emptyMap(), (_, _) -> true);\n-                    }\n-\n-                };\n-                var responseBodyHandler = HttpResponse.BodyHandlers.discarding();\n-                client.sendAsync(connectRequest, responseBodyHandler);\n-            });\n+            \/\/ The default `HttpRequest` builder does not allow `CONNECT`.\n+            \/\/ Hence, we create our custom `HttpRequest` instance:\n+            var connectRequest = new HttpRequest() {\n+\n+                @Override\n+                public Optional<BodyPublisher> bodyPublisher() {\n+                    return Optional.empty();\n+                }\n+\n+                @Override\n+                public String method() {\n+                    return \"CONNECT\";\n+                }\n+\n+                @Override\n+                public Optional<Duration> timeout() {\n+                    return Optional.empty();\n+                }\n+\n+                @Override\n+                public boolean expectContinue() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public URI uri() {\n+                    return URI.create(\"https:\/\/example.com\");\n+                }\n+\n+                @Override\n+                public Optional<HttpClient.Version> version() {\n+                    return Optional.empty();\n+                }\n+\n+                @Override\n+                public HttpHeaders headers() {\n+                    return HttpHeaders.of(Collections.emptyMap(), (_, _) -> true);\n+                }\n+\n+            };\n+            var responseBodyHandler = HttpResponse.BodyHandlers.discarding();\n+            var exception = assertThrows(\n+                    IllegalArgumentException.class,\n+                    () -> client.sendAsync(connectRequest, responseBodyHandler));\n@@ -189,1 +187,1 @@\n-                exception -> assertThrowableSame(ioException, exception)));\n+                exception -> assertThrowableSame(uncheckedIOException, exception.getCause())));\n@@ -250,6 +248,5 @@\n-            var exception = assertThrows(\n-                    ExecutionException.class,\n-                    \/\/ We need to make `sendAsync()` execution fail.\n-                    \/\/ There are several ways to achieve this.\n-                    \/\/ We choose to use a throwing response handler.\n-                    () -> client.sendAsync(request, testCase.throwingResponseBodyHandler).get());\n+            \/\/ We need to make `sendAsync()` execution fail.\n+            \/\/ There are several ways to achieve this.\n+            \/\/ We choose to use a throwing response handler.\n+            var responseFuture = client.sendAsync(request, testCase.throwingResponseBodyHandler);\n+            var exception = assertThrows(ExecutionException.class, responseFuture::get);\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpClientSendAsyncExceptionTest.java","additions":62,"deletions":65,"binary":false,"changes":127,"status":"modified"}]}