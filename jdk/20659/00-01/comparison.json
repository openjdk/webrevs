{"files":[{"patch":"@@ -669,1 +669,2 @@\n-     * to {@code m} (if any). Then, the returned var handle is computed as follows:\n+     * to {@code m} ({@code Q} could be an empty layout path if {@code k == m}).\n+     * Then, the returned var handle is computed as follows:\n@@ -673,1 +674,1 @@\n-     * MemoryLayout target = ((AddressLayout)this.select(Q)).targetLayout().get();\n+     * MemoryLayout target = ((AddressLayout)this.select(P)).targetLayout().get();\n@@ -975,2 +976,2 @@\n-         * {@return a path element that dereferences an address layout as its\n-         * {@linkplain AddressLayout#targetLayout() target layout} (where set)}\n+         * {@return a path element that selects the {@linkplain AddressLayout#targetLayout() target layout} of\n+         * an address layout (where set)}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -122,0 +122,24 @@\n+    static final MemoryLayout A_VALUE = MemoryLayout.structLayout(\n+            ValueLayout.ADDRESS.withName(\"b\")\n+                    .withTargetLayout(ValueLayout.JAVA_INT)\n+    );\n+\n+    static final VarHandle a_value = A_VALUE.varHandle(\n+            PathElement.groupElement(\"b\"), PathElement.dereferenceElement());\n+\n+    @Test\n+    public void testDerefValue() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            \/\/ init structs\n+            MemorySegment a = arena.allocate(A);\n+            MemorySegment b = arena.allocate(ValueLayout.JAVA_INT);\n+            \/\/ init struct fields\n+            a.set(ValueLayout.ADDRESS, 0, b);\n+            b.set(ValueLayout.JAVA_INT, 0, 42);\n+            \/\/ dereference\n+            int val = (int) a_value.get(a, 0L);\n+            assertEquals(val, 42);\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/java\/foreign\/TestDereferencePath.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"}]}