{"files":[{"patch":"@@ -29,2 +29,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -336,1 +334,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -338,9 +335,6 @@\n-        AccessController.doPrivileged((PrivilegedAction<Thread>) () -> {\n-            String name = \"AWT-Shutdown\";\n-            Thread thread = new Thread(\n-                   ThreadGroupUtils.getRootThreadGroup(), this, name, 0, false);\n-            thread.setContextClassLoader(null);\n-            thread.setDaemon(false);\n-            blockerThread = thread;\n-            return thread;\n-        }).start();\n+        String name = \"AWT-Shutdown\";\n+        Thread thread = new Thread(ThreadGroupUtils.getRootThreadGroup(), this, name, 0, false);\n+        thread.setContextClassLoader(null);\n+        thread.setDaemon(false);\n+        blockerThread = thread;\n+        thread.start();\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/AWTAutoShutdown.java","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,2 +35,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -232,1 +230,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -239,7 +236,1 @@\n-        this.contextClassLoader =\n-             AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {\n-                    public ClassLoader run() {\n-                        return Thread.currentThread().getContextClassLoader();\n-                    }\n-                });\n-\n+        this.contextClassLoader = Thread.currentThread().getContextClassLoader();\n@@ -257,1 +248,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -262,10 +252,7 @@\n-        AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-            public Void run() {\n-                ThreadGroup currentThreadGroup =\n-                        Thread.currentThread().getThreadGroup();\n-                ThreadGroup parentThreadGroup = currentThreadGroup.getParent();\n-                while (parentThreadGroup != null) {\n-                    \/\/ Find the root ThreadGroup to construct our main AppContext\n-                    currentThreadGroup = parentThreadGroup;\n-                    parentThreadGroup = currentThreadGroup.getParent();\n-                }\n+        ThreadGroup currentThreadGroup = Thread.currentThread().getThreadGroup();\n+        ThreadGroup parentThreadGroup = currentThreadGroup.getParent();\n+        while (parentThreadGroup != null) {\n+            \/\/ Find the root ThreadGroup to construct our main AppContext\n+            currentThreadGroup = parentThreadGroup;\n+            parentThreadGroup = currentThreadGroup.getParent();\n+        }\n@@ -273,4 +260,1 @@\n-                mainAppContext = SunToolkit.createNewAppContext(currentThreadGroup);\n-                return null;\n-            }\n-        });\n+        mainAppContext = SunToolkit.createNewAppContext(currentThreadGroup);\n@@ -287,1 +271,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -297,25 +280,20 @@\n-            appContext = AccessController.doPrivileged(new PrivilegedAction<AppContext>()\n-            {\n-                public AppContext run() {\n-                    \/\/ Get the current ThreadGroup, and look for it and its\n-                    \/\/ parents in the hash from ThreadGroup to AppContext --\n-                    \/\/ it should be found, because we use createNewContext()\n-                    \/\/ when new AppContext objects are created.\n-                    ThreadGroup currentThreadGroup = Thread.currentThread().getThreadGroup();\n-                    ThreadGroup threadGroup = currentThreadGroup;\n-\n-                    \/\/ Special case: we implicitly create the main app context\n-                    \/\/ if no contexts have been created yet. This covers standalone apps\n-                    \/\/ and excludes applets because by the time applet starts\n-                    \/\/ a number of contexts have already been created by the plugin.\n-                    synchronized (getAppContextLock) {\n-                        if (numAppContexts.get() == 0) {\n-                            if (System.getProperty(\"javaplugin.version\") == null &&\n-                                    System.getProperty(\"javawebstart.version\") == null) {\n-                                initMainAppContext();\n-                            } else if (System.getProperty(\"javafx.version\") != null &&\n-                                    threadGroup.getParent() != null) {\n-                                \/\/ Swing inside JavaFX case\n-                                SunToolkit.createNewAppContext();\n-                            }\n-                        }\n+            \/\/ Get the current ThreadGroup, and look for it and its\n+            \/\/ parents in the hash from ThreadGroup to AppContext --\n+            \/\/ it should be found, because we use createNewContext()\n+            \/\/ when new AppContext objects are created.\n+            ThreadGroup currentThreadGroup = Thread.currentThread().getThreadGroup();\n+            ThreadGroup threadGroup = currentThreadGroup;\n+\n+            \/\/ Special case: we implicitly create the main app context\n+            \/\/ if no contexts have been created yet. This covers standalone apps\n+            \/\/ and excludes applets because by the time applet starts\n+            \/\/ a number of contexts have already been created by the plugin.\n+            synchronized (getAppContextLock) {\n+                if (numAppContexts.get() == 0) {\n+                    if (System.getProperty(\"javaplugin.version\") == null &&\n+                            System.getProperty(\"javawebstart.version\") == null) {\n+                        initMainAppContext();\n+                    } else if (System.getProperty(\"javafx.version\") != null &&\n+                            threadGroup.getParent() != null) {\n+                        \/\/ Swing inside JavaFX case\n+                        SunToolkit.createNewAppContext();\n@@ -323,0 +301,2 @@\n+                }\n+            }\n@@ -324,22 +304,11 @@\n-                    AppContext context = threadGroup2appContext.get(threadGroup);\n-                    while (context == null) {\n-                        threadGroup = threadGroup.getParent();\n-                        if (threadGroup == null) {\n-                            \/\/ We've got up to the root thread group and did not find an AppContext\n-                            \/\/ Try to get it from the security manager\n-                            SecurityManager securityManager = System.getSecurityManager();\n-                            if (securityManager != null) {\n-                                ThreadGroup smThreadGroup = securityManager.getThreadGroup();\n-                                if (smThreadGroup != null) {\n-                                    \/*\n-                                     * If we get this far then it's likely that\n-                                     * the ThreadGroup does not actually belong\n-                                     * to the applet, so do not cache it.\n-                                     *\/\n-                                    return threadGroup2appContext.get(smThreadGroup);\n-                                }\n-                            }\n-                            return null;\n-                        }\n-                        context = threadGroup2appContext.get(threadGroup);\n-                    }\n+            AppContext context = threadGroup2appContext.get(threadGroup);\n+            while (context == null) {\n+                threadGroup = threadGroup.getParent();\n+                if (threadGroup == null) {\n+                    \/\/ We've got up to the root thread group and did not find an AppContext\n+                    \/\/ We have nowhere else to look, and this is not supposed to happen.\n+                    \/\/ return null from this whole method.\n+                    return null;\n+                }\n+                context = threadGroup2appContext.get(threadGroup);\n+            }\n@@ -347,6 +316,6 @@\n-                    \/\/ In case we did anything in the above while loop, we add\n-                    \/\/ all the intermediate ThreadGroups to threadGroup2appContext\n-                    \/\/ so we won't spin again.\n-                    for (ThreadGroup tg = currentThreadGroup; tg != threadGroup; tg = tg.getParent()) {\n-                        threadGroup2appContext.put(tg, context);\n-                    }\n+            \/\/ In case we did anything in the above while loop, we add\n+            \/\/ all the intermediate ThreadGroups to threadGroup2appContext\n+            \/\/ so we won't spin again.\n+            for (ThreadGroup tg = currentThreadGroup; tg != threadGroup; tg = tg.getParent()) {\n+                threadGroup2appContext.put(tg, context);\n+            }\n@@ -354,2 +323,2 @@\n-                    \/\/ Now we're done, so we cache the latest key\/value pair.\n-                    threadAppContext.set(context);\n+            \/\/ Now we're done, so we cache the latest key\/value pair.\n+            threadAppContext.set(context);\n@@ -357,3 +326,1 @@\n-                    return context;\n-                }\n-            });\n+            appContext = context;\n@@ -398,1 +365,1 @@\n-    @SuppressWarnings({\"deprecation\", \"removal\"})\n+    @SuppressWarnings(\"deprecation\")\n@@ -442,13 +409,7 @@\n-                AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-                        public Void run() {\n-                            if (!GraphicsEnvironment.isHeadless() && SystemTray.isSupported())\n-                            {\n-                                SystemTray systemTray = SystemTray.getSystemTray();\n-                                TrayIcon[] trayIconsToDispose = systemTray.getTrayIcons();\n-                                for (TrayIcon ti : trayIconsToDispose) {\n-                                    systemTray.remove(ti);\n-                                }\n-                            }\n-                            return null;\n-                        }\n-                    });\n+                if (!GraphicsEnvironment.isHeadless() && SystemTray.isSupported()) {\n+                    SystemTray systemTray = SystemTray.getSystemTray();\n+                    TrayIcon[] trayIconsToDispose = systemTray.getTrayIcons();\n+                    for (TrayIcon ti : trayIconsToDispose) {\n+                        systemTray.remove(ti);\n+                    }\n+                }\n@@ -549,19 +510,0 @@\n-    static final class CreateThreadAction implements PrivilegedAction<Thread> {\n-        private final AppContext appContext;\n-        private final Runnable runnable;\n-\n-        CreateThreadAction(AppContext ac, Runnable r) {\n-            appContext = ac;\n-            runnable = r;\n-        }\n-\n-        public Thread run() {\n-            Thread t = new Thread(appContext.getThreadGroup(),\n-                                  runnable, \"AppContext Disposer\", 0, false);\n-            t.setContextClassLoader(appContext.getContextClassLoader());\n-            t.setPriority(Thread.NORM_PRIORITY + 1);\n-            t.setDaemon(true);\n-            return t;\n-        }\n-    }\n-\n@@ -579,3 +521,5 @@\n-                PrivilegedAction<Thread> action = new CreateThreadAction(appContext, r);\n-                @SuppressWarnings(\"removal\")\n-                Thread thread = AccessController.doPrivileged(action);\n+                Thread thread = new Thread(appContext.getThreadGroup(),\n+                                           r, \"AppContext Disposer\", 0, false);\n+                thread.setContextClassLoader(appContext.getContextClassLoader());\n+                thread.setPriority(Thread.NORM_PRIORITY + 1);\n+                thread.setDaemon(true);\n@@ -809,1 +753,0 @@\n-            @SuppressWarnings(\"removal\")\n@@ -811,6 +754,1 @@\n-                return AccessController.doPrivileged(new PrivilegedAction<Boolean>() {\n-                    @Override\n-                    public Boolean run() {\n-                        return ecx.threadGroup.getParent() == null;\n-                    }\n-                });\n+                return ecx.threadGroup.getParent() == null;\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/AppContext.java","additions":65,"deletions":127,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -33,2 +33,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -75,1 +73,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -122,11 +119,5 @@\n-            AccessController.doPrivileged(new PrivilegedAction<Object>() {\n-                @Override\n-                public Object run() {\n-                    consumedField.setAccessible(true);\n-                    try {\n-                        consumedField.set(focusEvent, consumed);\n-                    } catch (IllegalAccessException e) {\n-                    }\n-                    return null;\n-                }\n-            });\n+            consumedField.setAccessible(true);\n+            try {\n+                consumedField.set(focusEvent, consumed);\n+            } catch (IllegalAccessException e) {\n+            }\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/CausedFocusEvent.java","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -111,1 +111,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -114,9 +113,3 @@\n-        java.security.AccessController.doPrivileged(\n-            new java.security.PrivilegedAction<Void>() {\n-                public Void run() {\n-                    loadDefaultProperties();\n-                    loadFileProperties();\n-                    loadSystemProperties();\n-                    return null;\n-                }\n-            });\n+        loadDefaultProperties();\n+        loadFileProperties();\n+        loadSystemProperties();\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/DebugSettings.java","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -38,2 +38,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -123,1 +121,1 @@\n-         * update any other state. Also avoid a doPrivileged block.\n+         * update any other state.\n@@ -159,14 +157,2 @@\n-        @SuppressWarnings(\"removal\")\n-        Boolean exists = java.security.AccessController.doPrivileged(\n-            new java.security.PrivilegedAction<Boolean>() {\n-                 public Boolean run() {\n-                     try {\n-                         File f = new File(fileName);\n-                         return Boolean.valueOf(f.exists());\n-                     }\n-                     catch (Exception e) {\n-                         return Boolean.FALSE;\n-                     }\n-                 }\n-                });\n-        return exists.booleanValue();\n+        File f = new File(fileName);\n+        return f.exists();\n@@ -963,12 +949,5 @@\n-            @SuppressWarnings(\"removal\")\n-            Class<?> fcc = AccessController.doPrivileged(new PrivilegedAction<Class<?>>() {\n-                    public Class<?> run() {\n-                        try {\n-                            return Class.forName(charsetName, true,\n-                                                 ClassLoader.getSystemClassLoader());\n-                        } catch (ClassNotFoundException e) {\n-                        }\n-                        return null;\n-                    }\n-                });\n-\n+            Class<?> fcc = null;\n+            try {\n+                fcc = Class.forName(charsetName, true, ClassLoader.getSystemClassLoader());\n+            } catch (ClassNotFoundException e) {\n+            }\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/FontConfiguration.java","additions":8,"deletions":29,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -123,4 +123,1 @@\n-        @SuppressWarnings(\"removal\")\n-        String enc = java.security.AccessController.doPrivileged(\n-           new sun.security.action.GetPropertyAction(\"sun.io.unicode.encoding\",\n-                                                          \"UnicodeBig\"));\n+        String enc = System.getProperty(\"sun.io.unicode.encoding\", \"UnicodeBig\");\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/FontDescriptor.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    @SuppressWarnings({\"removal\", \"restricted\"})\n+    @SuppressWarnings(\"restricted\")\n@@ -57,7 +57,1 @@\n-        java.security.AccessController.doPrivileged(\n-            new java.security.PrivilegedAction<Void>() {\n-                public Void run() {\n-                    System.loadLibrary(\"awt\");\n-                    return null;\n-                }\n-            });\n+        System.loadLibrary(\"awt\");\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/NativeLibLoader.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -65,4 +65,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n@@ -988,1 +984,0 @@\n-            throws IOException\n@@ -997,0 +992,2 @@\n+        StringBuilder allowedFiles = new StringBuilder(str.length());\n+        String [] uriArray = str.split(\"(\\\\s)+\");\n@@ -998,7 +995,8 @@\n-        try {\n-            return AccessController.doPrivileged((PrivilegedExceptionAction<String>) () -> {\n-\n-                StringBuilder allowedFiles = new StringBuilder(str.length());\n-                String [] uriArray = str.split(\"(\\\\s)+\");\n-\n-                for (String fileName : uriArray)\n+        for (String fileName : uriArray)\n+        {\n+            File file = new File(fileName);\n+            if (file.exists() &&\n+                !(isFileInWebstartedCache(file) ||\n+                isForbiddenToRead(file, userProtectionDomain)))\n+            {\n+                if (0 != allowedFiles.length())\n@@ -1006,12 +1004,1 @@\n-                    File file = new File(fileName);\n-                    if (file.exists() &&\n-                        !(isFileInWebstartedCache(file) ||\n-                        isForbiddenToRead(file, userProtectionDomain)))\n-                    {\n-                        if (0 != allowedFiles.length())\n-                        {\n-                            allowedFiles.append(\"\\\\r\\\\n\");\n-                        }\n-\n-                        allowedFiles.append(fileName);\n-                    }\n+                    allowedFiles.append(\"\\\\r\\\\n\");\n@@ -1020,4 +1007,2 @@\n-                return allowedFiles.toString();\n-            });\n-        } catch (PrivilegedActionException pae) {\n-            throw new IOException(pae.getMessage(), pae);\n+                allowedFiles.append(fileName);\n+            }\n@@ -1025,0 +1010,1 @@\n+        return allowedFiles.toString();\n@@ -1050,18 +1036,11 @@\n-        try {\n-            return AccessController.doPrivileged((PrivilegedExceptionAction<ArrayList<String>>) () -> {\n-                ArrayList<String> fileList = new ArrayList<>();\n-                for (Object fileObject : files)\n-                {\n-                    File file = castToFile(fileObject);\n-                    if (file != null &&\n-                        (null == System.getSecurityManager() ||\n-                        !(isFileInWebstartedCache(file) ||\n-                        isForbiddenToRead(file, userProtectionDomain))))\n-                    {\n-                        fileList.add(file.getCanonicalPath());\n-                    }\n-                }\n-                return fileList;\n-            });\n-        } catch (PrivilegedActionException pae) {\n-            throw new IOException(pae.getMessage());\n+        ArrayList<String> fileList = new ArrayList<>();\n+        for (Object fileObject : files)\n+        {\n+            File file = castToFile(fileObject);\n+            if (file != null &&\n+                (null == System.getSecurityManager() ||\n+                !(isFileInWebstartedCache(file) ||\n+                isForbiddenToRead(file, userProtectionDomain))))\n+            {\n+                fileList.add(file.getCanonicalPath());\n+            }\n@@ -1069,0 +1048,1 @@\n+        return fileList;\n@@ -1422,1 +1402,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -1432,9 +1411,1 @@\n-            Constructor<?>[] constructors;\n-\n-            try {\n-                constructors = AccessController.doPrivileged(\n-                        (PrivilegedAction<Constructor<?>[]>) dfrc::getConstructors);\n-            } catch (SecurityException se) {\n-                throw new IOException(se.getMessage());\n-            }\n-\n+            Constructor<?>[] constructors = dfrc.getConstructors();\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/datatransfer\/DataTransferer.java","additions":27,"deletions":56,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -41,2 +41,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -114,8 +112,1 @@\n-        @SuppressWarnings(\"removal\")\n-        ClassLoader classLoader = AccessController.doPrivileged(\n-            new PrivilegedAction<ClassLoader>() {\n-                public ClassLoader run() {\n-                    return cl.getClassLoader();\n-                }\n-            });\n-\n+        ClassLoader classLoader = cl.getClassLoader();\n@@ -128,8 +119,1 @@\n-        @SuppressWarnings(\"removal\")\n-        ClassLoader classLoader = AccessController.doPrivileged(\n-            new PrivilegedAction<ClassLoader>() {\n-                public ClassLoader run() {\n-                    return cl.getClassLoader();\n-                }\n-            });\n-\n+        ClassLoader classLoader = cl.getClassLoader();\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/datatransfer\/TransferableProxy.java","additions":2,"deletions":18,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -44,4 +44,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n@@ -255,1 +251,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -259,14 +254,5 @@\n-            try {\n-                AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n-                    public Object run() {\n-                        for (InputMethodDescriptor descriptor :\n-                            ServiceLoader.load(InputMethodDescriptor.class,\n-                                               ClassLoader.getSystemClassLoader())) {\n-                            ClassLoader cl = descriptor.getClass().getClassLoader();\n-                            javaInputMethodLocatorList.add(new InputMethodLocator(descriptor, cl, null));\n-                        }\n-                        return null;\n-                    }\n-                });\n-            }  catch (PrivilegedActionException e) {\n-                e.printStackTrace();\n+            for (InputMethodDescriptor descriptor :\n+                ServiceLoader.load(InputMethodDescriptor.class,\n+                                   ClassLoader.getSystemClassLoader())) {\n+                ClassLoader cl = descriptor.getClass().getClassLoader();\n+                javaInputMethodLocatorList.add(new InputMethodLocator(descriptor, cl, null));\n@@ -597,1 +583,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -599,5 +584,1 @@\n-        return AccessController.doPrivileged(new PrivilegedAction<Preferences>() {\n-            public Preferences run() {\n-                return Preferences.userRoot();\n-            }\n-        });\n+        return Preferences.userRoot();\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/im\/ExecutableInputMethodManager.java","additions":6,"deletions":25,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -47,2 +47,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -1039,1 +1037,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -1041,14 +1038,9 @@\n-        AccessController.doPrivileged(new PrivilegedAction<Object>() {\n-            public Object run() {\n-                \/\/ Look in user's tree\n-                Preferences root = Preferences.userRoot();\n-                inputMethodSelectionKey = getInputMethodSelectionKeyStroke(root);\n-\n-                if (inputMethodSelectionKey == null) {\n-                    \/\/ Look in system's tree\n-                    root = Preferences.systemRoot();\n-                    inputMethodSelectionKey = getInputMethodSelectionKeyStroke(root);\n-                }\n-                return null;\n-            }\n-        });\n+        \/\/ Look in user's tree\n+        Preferences root = Preferences.userRoot();\n+        inputMethodSelectionKey = getInputMethodSelectionKeyStroke(root);\n+\n+        if (inputMethodSelectionKey == null) {\n+            \/\/ Look in system's tree\n+            root = Preferences.systemRoot();\n+            inputMethodSelectionKey = getInputMethodSelectionKeyStroke(root);\n+        }\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/im\/InputContext.java","additions":9,"deletions":17,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import java.security.AccessController;\n@@ -75,3 +74,1 @@\n-        @SuppressWarnings(\"removal\")\n-        String inputStyle = AccessController.doPrivileged\n-                (new GetPropertyAction(\"java.awt.im.style\", null));\n+        String inputStyle = System.getProperty(\"java.awt.im.style\");\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/im\/InputMethodContext.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -115,1 +113,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -119,15 +116,12 @@\n-                AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n-                    \/* The thread must be a member of a thread group\n-                     * which will not get GCed before VM exit.\n-                     * Make its parent the top-level thread group.\n-                     *\/\n-                    ThreadGroup rootTG = ThreadGroupUtils.getRootThreadGroup();\n-                    t = new Thread(rootTG, TempFileDeletionHook::runHooks,\n-                                   \"TempFontFileDeleter\", 0, false);\n-                    \/* Set context class loader to null in order to avoid\n-                     * keeping a strong reference to an application classloader.\n-                     *\/\n-                    t.setContextClassLoader(null);\n-                    Runtime.getRuntime().addShutdownHook(t);\n-                    return null;\n-                });\n+                \/* The thread must be a member of a thread group\n+                 * which will not get GCed before VM exit.\n+                 * Make its parent the top-level thread group.\n+                 *\/\n+                ThreadGroup rootTG = ThreadGroupUtils.getRootThreadGroup();\n+                t = new Thread(rootTG, TempFileDeletionHook::runHooks,\n+                               \"TempFontFileDeleter\", 0, false);\n+                \/* Set context class loader to null in order to avoid\n+                 * keeping a strong reference to an application classloader.\n+                 *\/\n+                t.setContextClassLoader(null);\n+                Runtime.getRuntime().addShutdownHook(t);\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/CreatedFontTracker.java","additions":12,"deletions":18,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import java.io.IOException;\n@@ -40,3 +39,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n@@ -255,1 +251,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -257,28 +252,10 @@\n-            java.security.AccessController.doPrivileged(\n-                 new java.security.PrivilegedAction<Object>() {\n-                      public Object run() {\n-                          synchronized (fontFile) {\n-                              count--;\n-                              if (count > 0) {\n-                                  return null;\n-                              }\n-                          }\n-                          if (fontFile != null) {\n-                              try {\n-                                  if (tracker != null) {\n-                                      tracker.subBytes((int)fontFile.length());\n-                                  }\n-                                  \/* REMIND: is it possible that the file is\n-                                   * still open? It will be closed when the\n-                                   * font2D is disposed but could this code\n-                                   * execute first? If so the file would not\n-                                   * be deleted on MS-windows.\n-                                   *\/\n-                                  fontFile.delete();\n-                                  \/* remove from delete on exit hook list : *\/\n-                                  \/\/ FIXME: still need to be refactored\n-                                  SunFontManager.getInstance().tmpFontFiles.remove(fontFile);\n-                              } catch (Exception e) {\n-                              }\n-                          }\n-                          return null;\n+              synchronized (fontFile) {\n+                  count--;\n+                  if (count > 0) {\n+                      return;\n+                  }\n+              }\n+              if (fontFile != null) {\n+                  try {\n+                      if (tracker != null) {\n+                          tracker.subBytes((int)fontFile.length());\n@@ -286,1 +263,13 @@\n-            });\n+                      \/* REMIND: is it possible that the file is\n+                       * still open? It will be closed when the\n+                       * font2D is disposed but could this code\n+                       * execute first? If so the file would not\n+                       * be deleted on MS-windows.\n+                       *\/\n+                      fontFile.delete();\n+                      \/* remove from delete on exit hook list : *\/\n+                      \/\/ FIXME: still need to be refactored\n+                      SunFontManager.getInstance().tmpFontFiles.remove(fontFile);\n+                  } catch (Exception e) {\n+                  }\n+              }\n@@ -290,1 +279,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -292,2 +280,0 @@\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm == null) {\n@@ -295,39 +281,0 @@\n-        }\n-        boolean canReadProperty = true;\n-\n-        try {\n-            sm.checkPropertyAccess(\"java.io.tmpdir\");\n-        } catch (SecurityException e) {\n-            canReadProperty = false;\n-        }\n-\n-        if (canReadProperty) {\n-            return platName;\n-        }\n-\n-        final File f = new File(platName);\n-\n-        Boolean isTmpFile = Boolean.FALSE;\n-        try {\n-            isTmpFile = AccessController.doPrivileged(\n-                new PrivilegedExceptionAction<Boolean>() {\n-                    public Boolean run() {\n-                        File tmp = new File(System.getProperty(\"java.io.tmpdir\"));\n-                        try {\n-                            String tpath = tmp.getCanonicalPath();\n-                            String fpath = f.getCanonicalPath();\n-\n-                            return (fpath == null) || fpath.startsWith(tpath);\n-                        } catch (IOException e) {\n-                            return Boolean.TRUE;\n-                        }\n-                    }\n-                }\n-            );\n-        } catch (PrivilegedActionException e) {\n-            \/\/ unable to verify whether value of java.io.tempdir will be\n-            \/\/ exposed, so return only a name of the font file.\n-            isTmpFile = Boolean.TRUE;\n-        }\n-\n-        return  isTmpFile ? \"temp file\" : platName;\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/FileFont.java","additions":23,"deletions":76,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-@SuppressWarnings({\"removal\", \"restricted\"})\n+@SuppressWarnings(\"restricted\")\n@@ -33,10 +33,7 @@\n-        java.security.AccessController.doPrivileged(\n-                                    new java.security.PrivilegedAction<Object>() {\n-            public Object run() {\n-               \/* REMIND do we really have to load awt here? *\/\n-               System.loadLibrary(\"awt\");\n-               if (OSInfo.getOSType() == OSInfo.OSType.WINDOWS) {\n-                   \/* Ideally fontmanager library should not depend on\n-                      particular implementation of the font scaler.\n-                      However, freetype scaler is basically small wrapper on\n-                      top of freetype library (that is used in binary form).\n+       \/* REMIND do we really have to load awt here? *\/\n+       System.loadLibrary(\"awt\");\n+       if (OSInfo.getOSType() == OSInfo.OSType.WINDOWS) {\n+           \/* Ideally fontmanager library should not depend on\n+              particular implementation of the font scaler.\n+              However, freetype scaler is basically small wrapper on\n+              top of freetype library (that is used in binary form).\n@@ -44,2 +41,2 @@\n-                      This wrapper is compiled into fontmanager and this make\n-                      fontmanger library depending on freetype library.\n+              This wrapper is compiled into fontmanager and this make\n+              fontmanger library depending on freetype library.\n@@ -47,3 +44,3 @@\n-                      On Windows DLL's in the JRE's BIN directory cannot be\n-                      found by windows DLL loading as that directory is not\n-                      on the Windows PATH.\n+              On Windows DLL's in the JRE's BIN directory cannot be\n+              found by windows DLL loading as that directory is not\n+              on the Windows PATH.\n@@ -51,2 +48,2 @@\n-                      To avoid link error we have to load freetype explicitly\n-                      before we load fontmanager.\n+              To avoid link error we have to load freetype explicitly\n+              before we load fontmanager.\n@@ -54,9 +51,5 @@\n-                      NB: consider moving freetype wrapper part to separate\n-                          shared library in order to avoid dependency. *\/\n-                   System.loadLibrary(\"freetype\");\n-               }\n-               System.loadLibrary(\"fontmanager\");\n-\n-               return null;\n-            }\n-        });\n+              NB: consider moving freetype wrapper part to separate\n+                  shared library in order to avoid dependency. *\/\n+           System.loadLibrary(\"freetype\");\n+       }\n+       System.loadLibrary(\"fontmanager\");\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/FontManagerNativeLibrary.java","additions":20,"deletions":27,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.security.AccessController;\n@@ -33,1 +32,0 @@\n-import java.security.PrivilegedAction;\n@@ -62,1 +60,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings(\"deprecation\") \/\/ PlatformLogger.setLevel is deprecated.\n@@ -64,38 +62,15 @@\n-        AccessController.doPrivileged(new PrivilegedAction<Object>() {\n-            @SuppressWarnings(\"deprecation\") \/\/ PlatformLogger.setLevel is deprecated.\n-            @Override\n-            public Object run() {\n-\n-                isLinux = OSInfo.getOSType() == OSInfo.OSType.LINUX;\n-\n-                isMacOSX = OSInfo.getOSType() == OSInfo.OSType.MACOSX;\n-                if (isMacOSX) {\n-                    \/\/ os.version has values like 10.13.6, 10.14.6\n-                    \/\/ If it is not positively recognised as 10.13 or less,\n-                    \/\/ assume it means 10.14 or some later version.\n-                    isMacOSX14 = true;\n-                    String version = System.getProperty(\"os.version\", \"\");\n-                    if (version.startsWith(\"10.\")) {\n-                        version = version.substring(3);\n-                        int periodIndex = version.indexOf('.');\n-                        if (periodIndex != -1) {\n-                            version = version.substring(0, periodIndex);\n-                        }\n-                        try {\n-                            int v = Integer.parseInt(version);\n-                            isMacOSX14 = (v >= 14);\n-                        } catch (NumberFormatException e) {\n-                        }\n-                     }\n-                 }\n-                \/* If set to \"jdk\", use the JDK's scaler rather than\n-                 * the platform one. This may be a no-op on platforms where\n-                 * JDK has been configured so that it always relies on the\n-                 * platform scaler. The principal case where it has an\n-                 * effect is that on Windows, 2D will never use GDI.\n-                 *\/\n-                String scalerStr = System.getProperty(\"sun.java2d.font.scaler\");\n-                if (scalerStr != null) {\n-                    useJDKScaler = \"jdk\".equals(scalerStr);\n-                } else {\n-                    useJDKScaler = false;\n+\n+        isLinux = OSInfo.getOSType() == OSInfo.OSType.LINUX;\n+\n+        isMacOSX = OSInfo.getOSType() == OSInfo.OSType.MACOSX;\n+        if (isMacOSX) {\n+            \/\/ os.version has values like 10.13.6, 10.14.6\n+            \/\/ If it is not positively recognised as 10.13 or less,\n+            \/\/ assume it means 10.14 or some later version.\n+            isMacOSX14 = true;\n+            String version = System.getProperty(\"os.version\", \"\");\n+            if (version.startsWith(\"10.\")) {\n+                version = version.substring(3);\n+                int periodIndex = version.indexOf('.');\n+                if (periodIndex != -1) {\n+                    version = version.substring(0, periodIndex);\n@@ -103,13 +78,4 @@\n-                isWindows = OSInfo.getOSType() == OSInfo.OSType.WINDOWS;\n-                String debugLevel =\n-                    System.getProperty(\"sun.java2d.debugfonts\");\n-\n-                if (debugLevel != null && !debugLevel.equals(\"false\")) {\n-                    debugFonts = true;\n-                    logger = PlatformLogger.getLogger(\"sun.java2d\");\n-                    if (debugLevel.equals(\"warning\")) {\n-                        logger.setLevel(PlatformLogger.Level.WARNING);\n-                    } else if (debugLevel.equals(\"severe\")) {\n-                        logger.setLevel(PlatformLogger.Level.SEVERE);\n-                    }\n-                    logging = logger.isEnabled();\n+                try {\n+                    int v = Integer.parseInt(version);\n+                    isMacOSX14 = (v >= 14);\n+                } catch (NumberFormatException e) {\n@@ -117,2 +83,25 @@\n-\n-                return null;\n+             }\n+         }\n+        \/* If set to \"jdk\", use the JDK's scaler rather than\n+         * the platform one. This may be a no-op on platforms where\n+         * JDK has been configured so that it always relies on the\n+         * platform scaler. The principal case where it has an\n+         * effect is that on Windows, 2D will never use GDI.\n+         *\/\n+        String scalerStr = System.getProperty(\"sun.java2d.font.scaler\");\n+        if (scalerStr != null) {\n+            useJDKScaler = \"jdk\".equals(scalerStr);\n+        } else {\n+            useJDKScaler = false;\n+        }\n+        isWindows = OSInfo.getOSType() == OSInfo.OSType.WINDOWS;\n+        String debugLevel =\n+            System.getProperty(\"sun.java2d.debugfonts\");\n+\n+        if (debugLevel != null && !debugLevel.equals(\"false\")) {\n+            debugFonts = true;\n+            logger = PlatformLogger.getLogger(\"sun.java2d\");\n+            if (debugLevel.equals(\"warning\")) {\n+                logger.setLevel(PlatformLogger.Level.WARNING);\n+            } else if (debugLevel.equals(\"severe\")) {\n+                logger.setLevel(PlatformLogger.Level.SEVERE);\n@@ -120,1 +109,2 @@\n-        });\n+            logging = logger.isEnabled();\n+        }\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/FontUtilities.java","additions":47,"deletions":57,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -266,1 +266,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -274,24 +273,16 @@\n-        java.security.AccessController.doPrivileged(\n-                                    new java.security.PrivilegedAction<Object>() {\n-            public Object run() {\n-\n-               \/* Allow a client to override the reference type used to\n-                * cache strikes. The default is \"soft\" which hints to keep\n-                * the strikes around. This property allows the client to\n-                * override this to \"weak\" which hint to the GC to free\n-                * memory more aggressively.\n-                *\/\n-               String refType =\n-                   System.getProperty(\"sun.java2d.font.reftype\", \"soft\");\n-               cacheRefTypeWeak = refType.equals(\"weak\");\n-\n-                String minStrikesStr =\n-                    System.getProperty(\"sun.java2d.font.minstrikes\");\n-                if (minStrikesStr != null) {\n-                    try {\n-                        MINSTRIKES = Integer.parseInt(minStrikesStr);\n-                        if (MINSTRIKES <= 0) {\n-                            MINSTRIKES = 1;\n-                        }\n-                    } catch (NumberFormatException e) {\n-                    }\n+       \/* Allow a client to override the reference type used to\n+        * cache strikes. The default is \"soft\" which hints to keep\n+        * the strikes around. This property allows the client to\n+        * override this to \"weak\" which hint to the GC to free\n+        * memory more aggressively.\n+        *\/\n+       String refType = System.getProperty(\"sun.java2d.font.reftype\", \"soft\");\n+       cacheRefTypeWeak = refType.equals(\"weak\");\n+\n+        String minStrikesStr =\n+            System.getProperty(\"sun.java2d.font.minstrikes\");\n+        if (minStrikesStr != null) {\n+            try {\n+                MINSTRIKES = Integer.parseInt(minStrikesStr);\n+                if (MINSTRIKES <= 0) {\n+                    MINSTRIKES = 1;\n@@ -299,4 +290,1 @@\n-\n-                recentStrikes = new FontStrike[MINSTRIKES];\n-\n-                return null;\n+            } catch (NumberFormatException e) {\n@@ -304,1 +292,3 @@\n-        });\n+        }\n+\n+        recentStrikes = new FontStrike[MINSTRIKES];\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/StrikeCache.java","additions":20,"deletions":30,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -265,1 +263,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -267,13 +264,1 @@\n-        AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-            public Void run() {\n-                FontManagerNativeLibrary.load();\n-\n-                \/\/ JNI throws an exception if a class\/method\/field is not found,\n-                \/\/ so there's no need to do anything explicit here.\n-                initIDs();\n-\n-                switch (StrikeCache.nativeAddressSize) {\n-                case 8: longAddresses = true; break;\n-                case 4: longAddresses = false; break;\n-                default: throw new RuntimeException(\"Unexpected address size\");\n-                }\n+        FontManagerNativeLibrary.load();\n@@ -281,3 +266,3 @@\n-                noType1Font = \"true\".equals(System.getProperty(\"sun.java2d.noType1Font\"));\n-                jreLibDirName = System.getProperty(\"java.home\",\"\") + File.separator + \"lib\";\n-                jreFontDirName = jreLibDirName + File.separator + \"fonts\";\n+        \/\/ JNI throws an exception if a class\/method\/field is not found,\n+        \/\/ so there's no need to do anything explicit here.\n+        initIDs();\n@@ -285,4 +270,11 @@\n-                maxSoftRefCnt = Integer.getInteger(\"sun.java2d.font.maxSoftRefs\", 10);\n-                return null;\n-            }\n-        });\n+        switch (StrikeCache.nativeAddressSize) {\n+        case 8: longAddresses = true; break;\n+        case 4: longAddresses = false; break;\n+        default: throw new RuntimeException(\"Unexpected address size\");\n+        }\n+\n+        noType1Font = \"true\".equals(System.getProperty(\"sun.java2d.noType1Font\"));\n+        jreLibDirName = System.getProperty(\"java.home\",\"\") + File.separator + \"lib\";\n+        jreFontDirName = jreLibDirName + File.separator + \"fonts\";\n+\n+        maxSoftRefCnt = Integer.getInteger(\"sun.java2d.font.maxSoftRefs\", 10);\n@@ -307,1 +299,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -309,18 +300,13 @@\n-        AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-            public Void run() {\n-                File badFontFile =\n-                    new File(jreFontDirName + File.separator + \"badfonts.txt\");\n-                if (badFontFile.exists()) {\n-                    badFonts = new ArrayList<>();\n-                    try (FileInputStream fis = new FileInputStream(badFontFile);\n-                         BufferedReader br = new BufferedReader(new InputStreamReader(fis))) {\n-                        while (true) {\n-                            String name = br.readLine();\n-                            if (name == null) {\n-                                break;\n-                            } else {\n-                                if (FontUtilities.debugFonts()) {\n-                                    FontUtilities.logWarning(\"read bad font: \" + name);\n-                                }\n-                                badFonts.add(name);\n-                            }\n+        File badFontFile =\n+            new File(jreFontDirName + File.separator + \"badfonts.txt\");\n+        if (badFontFile.exists()) {\n+            badFonts = new ArrayList<>();\n+            try (FileInputStream fis = new FileInputStream(badFontFile);\n+                 BufferedReader br = new BufferedReader(new InputStreamReader(fis))) {\n+                while (true) {\n+                    String name = br.readLine();\n+                    if (name == null) {\n+                        break;\n+                    } else {\n+                        if (FontUtilities.debugFonts()) {\n+                            FontUtilities.logWarning(\"read bad font: \" + name);\n@@ -328,1 +314,1 @@\n-                    } catch (IOException e) {\n+                        badFonts.add(name);\n@@ -331,0 +317,3 @@\n+            } catch (IOException e) {\n+            }\n+        }\n@@ -332,72 +321,16 @@\n-                \/* Here we get the fonts in jre\/lib\/fonts and register\n-                 * them so they are always available and preferred over\n-                 * other fonts. This needs to be registered before the\n-                 * composite fonts as otherwise some native font that\n-                 * corresponds may be found as we don't have a way to\n-                 * handle two fonts of the same name, so the JRE one\n-                 * must be the first one registered. Pass \"true\" to\n-                 * registerFonts method as on-screen these JRE fonts\n-                 * always go through the JDK rasteriser.\n-                 *\/\n-                if (FontUtilities.isLinux) {\n-                    \/* Linux font configuration uses these fonts *\/\n-                    registerFontDir(jreFontDirName);\n-                }\n-                registerFontsInDir(jreFontDirName, true, Font2D.JRE_RANK,\n-                                   true, false);\n-\n-                \/* Create the font configuration and get any font path\n-                 * that might be specified.\n-                 *\/\n-                fontConfig = createFontConfiguration();\n-\n-                String[] fontInfo = getDefaultPlatformFont();\n-                defaultFontName = fontInfo[0];\n-                if (defaultFontName == null && FontUtilities.debugFonts()) {\n-                    FontUtilities.logWarning(\"defaultFontName is null\");\n-                }\n-                defaultFontFileName = fontInfo[1];\n-\n-                String extraFontPath = fontConfig.getExtraFontPath();\n-\n-                \/* In prior releases the debugging font path replaced\n-                 * all normally located font directories except for the\n-                 * JRE fonts dir. This directory is still always located\n-                 * and placed at the head of the path but as an\n-                 * augmentation to the previous behaviour the\n-                 * changes below allow you to additionally append to\n-                 * the font path by starting with append: or prepend by\n-                 * starting with a prepend: sign. Eg: to append\n-                 * -Dsun.java2d.fontpath=append:\/usr\/local\/myfonts\n-                 * and to prepend\n-                 * -Dsun.java2d.fontpath=prepend:\/usr\/local\/myfonts Disp\n-                 *\n-                 * If there is an appendedfontpath it in the font\n-                 * configuration it is used instead of searching the\n-                 * system for dirs.\n-                 * The behaviour of append and prepend is then similar\n-                 * to the normal case. ie it goes after what\n-                 * you prepend and * before what you append. If the\n-                 * sun.java2d.fontpath property is used, but it\n-                 * neither the append or prepend syntaxes is used then\n-                 * as except for the JRE dir the path is replaced and it\n-                 * is up to you to make sure that all the right\n-                 * directories are located. This is platform and\n-                 * locale-specific so its almost impossible to get\n-                 * right, so it should be used with caution.\n-                 *\/\n-                boolean prependToPath = false;\n-                boolean appendToPath = false;\n-                String dbgFontPath = System.getProperty(\"sun.java2d.fontpath\");\n-\n-                if (dbgFontPath != null) {\n-                    if (dbgFontPath.startsWith(\"prepend:\")) {\n-                        prependToPath = true;\n-                        dbgFontPath =\n-                            dbgFontPath.substring(\"prepend:\".length());\n-                    } else if (dbgFontPath.startsWith(\"append:\")) {\n-                        appendToPath = true;\n-                        dbgFontPath =\n-                            dbgFontPath.substring(\"append:\".length());\n-                    }\n-                }\n+        \/* Here we get the fonts in jre\/lib\/fonts and register\n+         * them so they are always available and preferred over\n+         * other fonts. This needs to be registered before the\n+         * composite fonts as otherwise some native font that\n+         * corresponds may be found as we don't have a way to\n+         * handle two fonts of the same name, so the JRE one\n+         * must be the first one registered. Pass \"true\" to\n+         * registerFonts method as on-screen these JRE fonts\n+         * always go through the JDK rasteriser.\n+         *\/\n+        if (FontUtilities.isLinux) {\n+            \/* Linux font configuration uses these fonts *\/\n+            registerFontDir(jreFontDirName);\n+        }\n+        registerFontsInDir(jreFontDirName, true, Font2D.JRE_RANK,\n+                           true, false);\n@@ -405,5 +338,43 @@\n-                if (FontUtilities.debugFonts()) {\n-                    FontUtilities.logInfo(\"JRE font directory: \" + jreFontDirName);\n-                    FontUtilities.logInfo(\"Extra font path: \" + extraFontPath);\n-                    FontUtilities.logInfo(\"Debug font path: \" + dbgFontPath);\n-                }\n+        \/* Create the font configuration and get any font path\n+         * that might be specified.\n+         *\/\n+        fontConfig = createFontConfiguration();\n+\n+        String[] fontInfo = getDefaultPlatformFont();\n+        defaultFontName = fontInfo[0];\n+        if (defaultFontName == null && FontUtilities.debugFonts()) {\n+            FontUtilities.logWarning(\"defaultFontName is null\");\n+        }\n+        defaultFontFileName = fontInfo[1];\n+\n+        String extraFontPath = fontConfig.getExtraFontPath();\n+\n+        \/* In prior releases the debugging font path replaced\n+         * all normally located font directories except for the\n+         * JRE fonts dir. This directory is still always located\n+         * and placed at the head of the path but as an\n+         * augmentation to the previous behaviour the\n+         * changes below allow you to additionally append to\n+         * the font path by starting with append: or prepend by\n+         * starting with a prepend: sign. Eg: to append\n+         * -Dsun.java2d.fontpath=append:\/usr\/local\/myfonts\n+         * and to prepend\n+         * -Dsun.java2d.fontpath=prepend:\/usr\/local\/myfonts Disp\n+         *\n+         * If there is an appendedfontpath it in the font\n+         * configuration it is used instead of searching the\n+         * system for dirs.\n+         * The behaviour of append and prepend is then similar\n+         * to the normal case. ie it goes after what\n+         * you prepend and * before what you append. If the\n+         * sun.java2d.fontpath property is used, but it\n+         * neither the append or prepend syntaxes is used then\n+         * as except for the JRE dir the path is replaced and it\n+         * is up to you to make sure that all the right\n+         * directories are located. This is platform and\n+         * locale-specific so its almost impossible to get\n+         * right, so it should be used with caution.\n+         *\/\n+        boolean prependToPath = false;\n+        boolean appendToPath = false;\n+        String dbgFontPath = System.getProperty(\"sun.java2d.fontpath\");\n@@ -411,5 +382,11 @@\n-                if (dbgFontPath != null) {\n-                    \/* In debugging mode we register all the paths\n-                     * Caution: this is a very expensive call on Solaris:-\n-                     *\/\n-                    fontPath = getPlatformFontPath(noType1Font);\n+        if (dbgFontPath != null) {\n+            if (dbgFontPath.startsWith(\"prepend:\")) {\n+                prependToPath = true;\n+                dbgFontPath =\n+                    dbgFontPath.substring(\"prepend:\".length());\n+            } else if (dbgFontPath.startsWith(\"append:\")) {\n+                appendToPath = true;\n+                dbgFontPath =\n+                    dbgFontPath.substring(\"append:\".length());\n+            }\n+        }\n@@ -417,27 +394,5 @@\n-                    if (extraFontPath != null) {\n-                        fontPath = extraFontPath + File.pathSeparator + fontPath;\n-                    }\n-                    if (appendToPath) {\n-                        fontPath += File.pathSeparator + dbgFontPath;\n-                    } else if (prependToPath) {\n-                        fontPath = dbgFontPath + File.pathSeparator + fontPath;\n-                    } else {\n-                        fontPath = dbgFontPath;\n-                    }\n-                    registerFontDirs(fontPath);\n-                } else if (extraFontPath != null) {\n-                    \/* If the font configuration contains an\n-                     * \"appendedfontpath\" entry, it is interpreted as a\n-                     * set of locations that should always be registered.\n-                     * It may be additional to locations normally found\n-                     * for that place, or it may be locations that need\n-                     * to have all their paths registered to locate all\n-                     * the needed platform names.\n-                     * This is typically when the same .TTF file is\n-                     * referenced from multiple font.dir files and all\n-                     * of these must be read to find all the native\n-                     * (XLFD) names for the font, so that X11 font APIs\n-                     * can be used for as many code points as possible.\n-                     *\/\n-                    registerFontDirs(extraFontPath);\n-                }\n+        if (FontUtilities.debugFonts()) {\n+            FontUtilities.logInfo(\"JRE font directory: \" + jreFontDirName);\n+            FontUtilities.logInfo(\"Extra font path: \" + extraFontPath);\n+            FontUtilities.logInfo(\"Debug font path: \" + dbgFontPath);\n+        }\n@@ -445,1 +400,5 @@\n-                initCompositeFonts(fontConfig, null);\n+        if (dbgFontPath != null) {\n+            \/* In debugging mode we register all the paths\n+             * Caution: this is a very expensive call on Solaris:-\n+             *\/\n+            fontPath = getPlatformFontPath(noType1Font);\n@@ -447,1 +406,2 @@\n-                return null;\n+            if (extraFontPath != null) {\n+                fontPath = extraFontPath + File.pathSeparator + fontPath;\n@@ -449,1 +409,24 @@\n-        });\n+            if (appendToPath) {\n+                fontPath += File.pathSeparator + dbgFontPath;\n+            } else if (prependToPath) {\n+                fontPath = dbgFontPath + File.pathSeparator + fontPath;\n+            } else {\n+                fontPath = dbgFontPath;\n+            }\n+            registerFontDirs(fontPath);\n+        } else if (extraFontPath != null) {\n+            \/* If the font configuration contains an\n+             * \"appendedfontpath\" entry, it is interpreted as a\n+             * set of locations that should always be registered.\n+             * It may be additional to locations normally found\n+             * for that place, or it may be locations that need\n+             * to have all their paths registered to locate all\n+             * the needed platform names.\n+             * This is typically when the same .TTF file is\n+             * referenced from multiple font.dir files and all\n+             * of these must be read to find all the native\n+             * (XLFD) names for the font, so that X11 font APIs\n+             * can be used for as many code points as possible.\n+             *\/\n+            registerFontDirs(extraFontPath);\n+        }\n@@ -451,0 +434,1 @@\n+        initCompositeFonts(fontConfig, null);\n@@ -1098,1 +1082,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -1106,25 +1089,20 @@\n-        return AccessController.doPrivileged(new PrivilegedAction<String[]>() {\n-            public String[] run() {\n-                if (pathDirs.length == 1) {\n-                    File dir = new File(pathDirs[0]);\n-                    String[] files = dir.list(filter);\n-                    if (files == null) {\n-                        return new String[0];\n-                    }\n-                    for (int f=0; f<files.length; f++) {\n-                        files[f] = files[f].toLowerCase();\n-                    }\n-                    return files;\n-                } else {\n-                    ArrayList<String> fileList = new ArrayList<>();\n-                    for (int i = 0; i< pathDirs.length; i++) {\n-                        File dir = new File(pathDirs[i]);\n-                        String[] files = dir.list(filter);\n-                        if (files == null) {\n-                            continue;\n-                        }\n-                        for (int f = 0; f < files.length ; f++) {\n-                            fileList.add(files[f].toLowerCase());\n-                        }\n-                    }\n-                    return fileList.toArray(STR_ARRAY);\n+        if (pathDirs.length == 1) {\n+            File dir = new File(pathDirs[0]);\n+            String[] files = dir.list(filter);\n+            if (files == null) {\n+                return new String[0];\n+            }\n+            for (int f=0; f<files.length; f++) {\n+                files[f] = files[f].toLowerCase();\n+            }\n+            return files;\n+        } else {\n+            ArrayList<String> fileList = new ArrayList<>();\n+            for (int i = 0; i< pathDirs.length; i++) {\n+                File dir = new File(pathDirs[i]);\n+                String[] files = dir.list(filter);\n+                if (files == null) {\n+                    continue;\n+                }\n+                for (int f = 0; f < files.length ; f++) {\n+                    fileList.add(files[f].toLowerCase());\n@@ -1133,1 +1111,2 @@\n-        });\n+            return fileList.toArray(STR_ARRAY);\n+        }\n@@ -1433,1 +1412,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -1527,12 +1505,8 @@\n-        failure = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {\n-             public Boolean run() {\n-                 for (int i=0; i<files.length; i++) {\n-                     if (files[i] == null) {\n-                         continue;\n-                     }\n-                     File f = new File(files[i]);\n-                     if (!f.exists()) {\n-                         return Boolean.TRUE;\n-                     }\n-                 }\n-                 return Boolean.FALSE;\n+         for (int i=0; i<files.length; i++) {\n+             if (files[i] == null) {\n+                 continue;\n+             }\n+             File f = new File(files[i]);\n+             if (!f.exists()) {\n+                 failure = true;\n+                 break;\n@@ -1540,1 +1514,1 @@\n-         });\n+         }\n@@ -1727,15 +1701,5 @@\n-            @SuppressWarnings(\"removal\")\n-            String path = AccessController.doPrivileged(\n-                 new PrivilegedAction<String>() {\n-                     public String run() {\n-                         for (int p = 0; p < pathDirs.length; p++) {\n-                             File f = new File(pathDirs[p] +File.separator+ s);\n-                             if (f.exists()) {\n-                                 return f.getAbsolutePath();\n-                             }\n-                         }\n-                         return null;\n-                     }\n-                });\n-            if (path != null) {\n-                return path;\n+            for (int p = 0; p < pathDirs.length; p++) {\n+                f = new File(pathDirs[p] + File.separator + s);\n+                if (f.exists()) {\n+                    return f.getAbsolutePath();\n+                }\n@@ -2184,1 +2148,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -2232,9 +2195,4 @@\n-                AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-                    public Void run() {\n-                        if (_tracker != null) {\n-                            _tracker.subBytes((int)fFile.length());\n-                        }\n-                        fFile.delete();\n-                        return null;\n-                    }\n-                });\n+                if (_tracker != null) {\n+                    _tracker.subBytes((int)fFile.length());\n+                }\n+                fFile.delete();\n@@ -2256,9 +2214,5 @@\n-                            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-                                public Void run() {\n-                                    for (int i = 0;i < CHANNELPOOLSIZE; i++) {\n-                                        if (fontFileCache[i] != null) {\n-                                            try {\n-                                                fontFileCache[i].close();\n-                                            } catch (Exception e) {\n-                                            }\n-                                        }\n+                            for (int i = 0;i < CHANNELPOOLSIZE; i++) {\n+                                if (fontFileCache[i] != null) {\n+                                    try {\n+                                        fontFileCache[i].close();\n+                                    } catch (Exception e) {\n@@ -2266,9 +2220,9 @@\n-                                    if (tmpFontFiles != null) {\n-                                        File[] files = new File[tmpFontFiles.size()];\n-                                        files = tmpFontFiles.toArray(files);\n-                                        for (int f=0; f<files.length;f++) {\n-                                            try {\n-                                                files[f].delete();\n-                                            } catch (Exception e) {\n-                                            }\n-                                        }\n+                                }\n+                            }\n+                            if (tmpFontFiles != null) {\n+                                File[] files = new File[tmpFontFiles.size()];\n+                                files = tmpFontFiles.toArray(files);\n+                                for (int f=0; f<files.length;f++) {\n+                                    try {\n+                                        files[f].delete();\n+                                    } catch (Exception e) {\n@@ -2276,1 +2230,0 @@\n-                                    return null;\n@@ -2278,1 +2231,1 @@\n-                            });\n+                            }\n@@ -2281,8 +2234,5 @@\n-                    AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n-                        ThreadGroup rootTG = ThreadGroupUtils.getRootThreadGroup();\n-                        fileCloser = new Thread(rootTG, fileCloserRunnable,\n-                                                \"FileCloser\", 0, false);\n-                        fileCloser.setContextClassLoader(null);\n-                        Runtime.getRuntime().addShutdownHook(fileCloser);\n-                        return null;\n-                    });\n+                    ThreadGroup rootTG = ThreadGroupUtils.getRootThreadGroup();\n+                    fileCloser = new Thread(rootTG, fileCloserRunnable,\n+                                            \"FileCloser\", 0, false);\n+                    fileCloser.setContextClassLoader(null);\n+                    Runtime.getRuntime().addShutdownHook(fileCloser);\n@@ -2933,1 +2883,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -2946,20 +2895,13 @@\n-            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-                public Void run() {\n-                    if (fontPath == null) {\n-                        fontPath = getPlatformFontPath(noType1Font);\n-                        registerFontDirs(fontPath);\n-                    }\n-                    if (fontPath != null) {\n-                        \/\/ this will find all fonts including those already\n-                        \/\/ registered. But we have checks in place to prevent\n-                        \/\/ double registration.\n-                        if (! gotFontsFromPlatform()) {\n-                            registerFontsOnPath(fontPath, false,\n-                                                Font2D.UNKNOWN_RANK,\n-                                                false, true);\n-                            loadedAllFontFiles = true;\n-                        }\n-                    }\n-                    registerOtherFontFiles(registeredFontFiles);\n-                    discoveredAllFonts = true;\n-                    return null;\n+            if (fontPath == null) {\n+                fontPath = getPlatformFontPath(noType1Font);\n+                registerFontDirs(fontPath);\n+            }\n+            if (fontPath != null) {\n+                \/\/ this will find all fonts including those already\n+                \/\/ registered. But we have checks in place to prevent\n+                \/\/ double registration.\n+                if (! gotFontsFromPlatform()) {\n+                    registerFontsOnPath(fontPath, false,\n+                                        Font2D.UNKNOWN_RANK,\n+                                        false, true);\n+                    loadedAllFontFiles = true;\n@@ -2967,1 +2909,3 @@\n-            });\n+            }\n+            registerOtherFontFiles(registeredFontFiles);\n+            discoveredAllFonts = true;\n@@ -3051,1 +2995,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -3063,17 +3006,12 @@\n-            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-                public Void run() {\n-                    if (fontPath == null) {\n-                        fontPath = getPlatformFontPath(noType1Font);\n-                    }\n-                    if (fontPath != null) {\n-                        \/\/ this will find all fonts including those already\n-                        \/\/ registered. But we have checks in place to prevent\n-                        \/\/ double registration.\n-                        registerFontsOnPath(fontPath, false,\n-                                            Font2D.UNKNOWN_RANK,\n-                                            false, true);\n-                    }\n-                    loadedAllFontFiles = true;\n-                    return null;\n-                }\n-            });\n+            if (fontPath == null) {\n+                fontPath = getPlatformFontPath(noType1Font);\n+            }\n+            if (fontPath != null) {\n+                \/\/ this will find all fonts including those already\n+                \/\/ registered. But we have checks in place to prevent\n+                \/\/ double registration.\n+                registerFontsOnPath(fontPath, false,\n+                                    Font2D.UNKNOWN_RANK,\n+                                    false, true);\n+            }\n+            loadedAllFontFiles = true;\n@@ -3405,1 +3343,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -3407,8 +3344,2 @@\n-        AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-            public Void run() {\n-                String type1Dir = \"\/usr\/openwin\/lib\/X11\/fonts\/Type1\";\n-                registerFontsInDir(type1Dir, true, Font2D.TYPE1_RANK,\n-                                   false, false);\n-                return null;\n-            }\n-        });\n+        String type1Dir = \"\/usr\/openwin\/lib\/X11\/fonts\/Type1\";\n+        registerFontsInDir(type1Dir, true, Font2D.TYPE1_RANK, false, false);\n@@ -3445,1 +3376,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -3448,24 +3378,20 @@\n-            systemLocale = AccessController.doPrivileged(new PrivilegedAction<Locale>() {\n-                public Locale run() {\n-                    \/* On windows the system locale may be different than the\n-                     * user locale. This is an unsupported configuration, but\n-                     * in that case we want to return a dummy locale that will\n-                     * never cause a match in the usage of this API. This is\n-                     * important because Windows documents that the family\n-                     * names of fonts are enumerated using the language of\n-                     * the system locale. BY returning a dummy locale in that\n-                     * case we do not use the platform API which would not\n-                     * return us the names we want.\n-                     *\/\n-                    String fileEncoding = System.getProperty(\"file.encoding\", \"\");\n-                    String sysEncoding = System.getProperty(\"sun.jnu.encoding\");\n-                    if (sysEncoding != null && !sysEncoding.equals(fileEncoding)) {\n-                        return Locale.ROOT;\n-                    }\n-\n-                    String language = System.getProperty(\"user.language\", \"en\");\n-                    String country  = System.getProperty(\"user.country\",\"\");\n-                    String variant  = System.getProperty(\"user.variant\",\"\");\n-                    return Locale.of(language, country, variant);\n-                }\n-            });\n+            \/* On windows the system locale may be different than the\n+             * user locale. This is an unsupported configuration, but\n+             * in that case we want to return a dummy locale that will\n+             * never cause a match in the usage of this API. This is\n+             * important because Windows documents that the family\n+             * names of fonts are enumerated using the language of\n+             * the system locale. BY returning a dummy locale in that\n+             * case we do not use the platform API which would not\n+             * return us the names we want.\n+             *\/\n+            String fileEncoding = System.getProperty(\"file.encoding\", \"\");\n+            String sysEncoding = System.getProperty(\"sun.jnu.encoding\");\n+            if (sysEncoding != null && !sysEncoding.equals(fileEncoding)) {\n+                systemLocale = Locale.ROOT;\n+            } else {\n+                String language = System.getProperty(\"user.language\", \"en\");\n+                String country  = System.getProperty(\"user.country\",\"\");\n+                String variant  = System.getProperty(\"user.variant\",\"\");\n+                systemLocale = Locale.of(language, country, variant);\n+            }\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/SunFontManager.java","additions":249,"deletions":323,"binary":false,"changes":572,"status":"modified"},{"patch":"@@ -40,2 +40,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -170,4 +168,1 @@\n-        @SuppressWarnings(\"removal\")\n-        String prop = AccessController.doPrivileged(\n-            (PrivilegedAction<String>) () ->\n-               System.getProperty(\"sun.font.layout.ffm\", \"true\"));\n+        String prop = System.getProperty(\"sun.font.layout.ffm\", \"true\");\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/SunLayoutEngine.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -41,3 +41,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n@@ -249,7 +246,1 @@\n-                @SuppressWarnings(\"removal\")\n-                RandomAccessFile raf = AccessController.doPrivileged(\n-                    new PrivilegedExceptionAction<RandomAccessFile>() {\n-                        public RandomAccessFile run() throws FileNotFoundException {\n-                            return new RandomAccessFile(platName, \"r\");\n-                    }\n-                });\n+                RandomAccessFile raf = new RandomAccessFile(platName, \"r\");\n@@ -264,7 +255,0 @@\n-            } catch (PrivilegedActionException e) {\n-                close();\n-                Throwable reason = e.getCause();\n-                if (reason == null) {\n-                    reason = e;\n-                }\n-                throw new FontFormatException(reason.toString());\n@@ -667,1 +651,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -675,2 +658,1 @@\n-            defaultCodePage =\n-                AccessController.doPrivileged(new GetPropertyAction(\"file.encoding\"));\n+            defaultCodePage = System.getProperty(\"file.encoding\");\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/TrueTypeFont.java","additions":2,"deletions":20,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -86,1 +86,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -88,10 +87,3 @@\n-            java.security.AccessController.doPrivileged(\n-                new java.security.PrivilegedAction<Object>() {\n-                    public Object run() {\n-\n-                        if (fileName != null) {\n-                            (new java.io.File(fileName)).delete();\n-                        }\n-                        return null;\n-                    }\n-             });\n+            if (fileName != null) {\n+                (new java.io.File(fileName)).delete();\n+            }\n@@ -194,12 +186,5 @@\n-                @SuppressWarnings(\"removal\")\n-                RandomAccessFile raf = (RandomAccessFile)\n-                java.security.AccessController.doPrivileged(\n-                    new java.security.PrivilegedAction<Object>() {\n-                        public Object run() {\n-                            try {\n-                                return new RandomAccessFile(platName, \"r\");\n-                            } catch (FileNotFoundException ffne) {\n-                            }\n-                            return null;\n-                    }\n-                });\n+                RandomAccessFile raf = null;\n+                try {\n+                    raf = new RandomAccessFile(platName, \"r\");\n+                } catch (FileNotFoundException ffne) {\n+                }\n@@ -230,1 +215,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -238,11 +222,4 @@\n-            raf = (RandomAccessFile)\n-                java.security.AccessController.doPrivileged(\n-                    new java.security.PrivilegedAction<Object>() {\n-                        public Object run() {\n-                            try {\n-                                return new RandomAccessFile(platName, \"r\");\n-                            } catch (FileNotFoundException fnfe) {\n-                            }\n-                            return null;\n-                    }\n-            });\n+            try {\n+                raf = new RandomAccessFile(platName, \"r\");\n+            } catch (FileNotFoundException fnfe) {\n+            }\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/Type1Font.java","additions":12,"deletions":35,"binary":false,"changes":47,"status":"modified"}]}