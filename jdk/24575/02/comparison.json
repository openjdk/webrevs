{"files":[{"patch":"@@ -1397,1 +1397,1 @@\n-      Node* base = new CheckCastPPNode(ctrl, orig_base, orig_base->bottom_type(), ConstraintCastNode::StrongDependency);\n+      Node* base = new CheckCastPPNode(ctrl, orig_base, orig_base->bottom_type(), ConstraintCastNode::NonFloatingNarrowingDependency);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,5 @@\n+const ConstraintCastNode::DependencyType ConstraintCastNode::FloatingNarrowingDependency(true, true, \"floating narrowing dependency\"); \/\/ not pinned, narrows type\n+const ConstraintCastNode::DependencyType ConstraintCastNode::FloatingNonNarrowingDependency(true, false, \"floating non narrowing dependency\"); \/\/ not pinned, doesn't narrow type\n+const ConstraintCastNode::DependencyType ConstraintCastNode::NonFloatingNarrowingDependency(false, true, \"now floating narrowing dependency\"); \/\/ pinned, narrows type\n+const ConstraintCastNode::DependencyType ConstraintCastNode::NonFloatingNonNarrowingDependency(false, false, \"non floating non narrowing dependency\"); \/\/ pinned, doesn't narrow type\n+\n@@ -41,1 +46,1 @@\n-  if (_dependency == UnconditionalDependency) {\n+  if (!_dependency.narrows_type()) {\n@@ -112,1 +117,1 @@\n-  return TypeNode::hash() + (int)_dependency + (_extra_types != nullptr ? _extra_types->hash() : 0);\n+  return TypeNode::hash() + _dependency.hash() + (_extra_types != nullptr ? _extra_types->hash() : 0);\n@@ -120,1 +125,1 @@\n-  if (cast._dependency != _dependency) {\n+  if (!cast._dependency.cmp(_dependency)) {\n@@ -133,1 +138,1 @@\n-Node* ConstraintCastNode::make_cast_for_basic_type(Node* c, Node* n, const Type* t, DependencyType dependency, BasicType bt) {\n+Node* ConstraintCastNode::make_cast_for_basic_type(Node* c, Node* n, const Type* t, const DependencyType& dependency, BasicType bt) {\n@@ -146,1 +151,1 @@\n-  if (_dependency == UnconditionalDependency) {\n+  if (!_dependency.narrows_type()) {\n@@ -208,3 +213,2 @@\n-  if (_dependency != RegularDependency) {\n-    st->print(\" %s dependency\", _dependency == StrongDependency ? \"strong\" : \"unconditional\");\n-  }\n+  st->print(\" \");\n+  _dependency.dump_on(st);\n@@ -214,10 +218,3 @@\n-const Type* CastIINode::Value(PhaseGVN* phase) const {\n-  const Type *res = ConstraintCastNode::Value(phase);\n-  if (res == Type::TOP) {\n-    return Type::TOP;\n-  }\n-  assert(res->isa_int(), \"res must be int\");\n-\n-  \/\/ Similar to ConvI2LNode::Value() for the same reasons\n-  \/\/ see if we can remove type assertion after loop opts\n-  res = widen_type(phase, res, T_INT);\n+CastIINode* CastIINode::make_with(Node* parent, const TypeInteger* type, const DependencyType& dependency) const {\n+  return new CastIINode(in(0), parent, type, dependency, _range_check_dependency, _extra_types);\n+}\n@@ -225,1 +222,2 @@\n-  return res;\n+CastLLNode* CastLLNode::make_with(Node* parent, const TypeInteger* type, const DependencyType& dependency) const {\n+  return new CastLLNode(in(0), parent, type, dependency, _extra_types);\n@@ -228,4 +226,2 @@\n-Node* ConstraintCastNode::find_or_make_integer_cast(PhaseIterGVN* igvn, Node* parent, const TypeInteger* type) const {\n-  Node* n = clone();\n-  n->set_req(1, parent);\n-  n->as_ConstraintCast()->set_type(type);\n+Node* ConstraintCastNode::find_or_make_integer_cast(PhaseIterGVN* igvn, Node* parent, const TypeInteger* type, const DependencyType& dependency) const {\n+  Node* n = make_with(parent, type, dependency);\n@@ -245,2 +241,2 @@\n-  if (can_reshape && !phase->C->post_loop_opts_phase()) {\n-    \/\/ makes sure we run ::Value to potentially remove type assertion after loop opts\n+  if (!phase->C->post_loop_opts_phase()) {\n+    \/\/ makes sure we run widen_type() to potentially common type assertions after loop opts\n@@ -252,1 +248,0 @@\n-  phase->C->record_for_post_loop_opts_igvn(this);\n@@ -282,1 +277,1 @@\n-  assert(_dependency == RegularDependency, \"already pinned\");\n+  assert(depends_only_on_test(), \"already pinned\");\n@@ -284,1 +279,1 @@\n-    return new CastIINode(in(0), in(1), bottom_type(), StrongDependency, has_range_check());\n+    return new CastIINode(in(0), in(1), bottom_type(), _dependency.pinned_dependency(), has_range_check());\n@@ -395,1 +390,1 @@\n-    \/\/ makes sure we run ::Value to potentially remove type assertion after loop opts\n+    \/\/ makes sure we run widen_type() to potentially common type assertions after loop opts\n@@ -546,1 +541,1 @@\n-Node* ConstraintCastNode::make_cast_for_type(Node* c, Node* in, const Type* type, DependencyType dependency,\n+Node* ConstraintCastNode::make_cast_for_type(Node* c, Node* in, const Type* type, const DependencyType& dependency,\n@@ -567,1 +562,1 @@\n-Node* ConstraintCastNode::optimize_integer_cast(PhaseGVN* phase, BasicType bt) {\n+Node* ConstraintCastNode::optimize_integer_cast_of_add(PhaseGVN* phase, BasicType bt) {\n@@ -589,2 +584,8 @@\n-    Node* cx = find_or_make_integer_cast(igvn, x, rx);\n-    Node* cy = find_or_make_integer_cast(igvn, y, ry);\n+    const TypeInteger* tx = phase->type(x)->is_integer(bt);\n+    const TypeInteger* ty = phase->type(y)->is_integer(bt);\n+\n+    \/\/ If both inputs are not constant then, with the Cast pushed through the Add\/Sub, the cast gets less precised types,\n+    \/\/ and the resulting Add\/Sub's type is wider than that of the Cast before pushing.\n+    const DependencyType& dependency = (!tx->is_con() && !ty->is_con()) ? _dependency.widen_type_dependency() : _dependency;\n+    Node* cx = find_or_make_integer_cast(igvn, x, rx, dependency);\n+    Node* cy = find_or_make_integer_cast(igvn, y, ry, dependency);\n@@ -602,2 +603,3 @@\n-const Type* ConstraintCastNode::widen_type(const PhaseGVN* phase, const Type* res, BasicType bt) const {\n-  if (!phase->C->post_loop_opts_phase()) {\n+Node* ConstraintCastNode::optimize_integer_cast(PhaseGVN* phase, BasicType bt) {\n+  Node* res = optimize_integer_cast_of_add(phase, bt);\n+  if (res != nullptr) {\n@@ -606,0 +608,18 @@\n+  const Type* t = Value(phase);\n+  if (t != Type::TOP) {\n+    const Type* bottom_t = bottom_type();\n+    const TypeInteger* wide_t = widen_type(phase, bottom_t, bt);\n+    if (wide_t != bottom_t) {\n+      \/\/ Widening the type of the Cast (to allow some commoning) causes the Cast to change how it can be optimized (if\n+      \/\/ type of its input is narrower than the Cast's type, we can't remove it to not loose the dependency).\n+      return make_with(in(1), wide_t, _dependency.widen_type_dependency());\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+const TypeInteger* ConstraintCastNode::widen_type(const PhaseGVN* phase, const Type* res, BasicType bt) const {\n+  const TypeInteger* this_type = res->is_integer(bt);\n+  if (!phase->C->post_loop_opts_phase()) {\n+    return this_type;\n+  }\n@@ -615,1 +635,1 @@\n-    return res;\n+    return this_type;\n@@ -618,1 +638,0 @@\n-  const TypeInteger* this_type = res->is_integer(bt);\n@@ -639,1 +658,1 @@\n-  return res;\n+  return this_type;\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":57,"deletions":38,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -35,5 +35,58 @@\n-public:\n-  enum DependencyType {\n-    RegularDependency, \/\/ if cast doesn't improve input type, cast can be removed\n-    StrongDependency,  \/\/ leave cast in even if _type doesn't improve input type, can be replaced by stricter dominating cast if one exist\n-    UnconditionalDependency \/\/ leave cast in unconditionally\n+protected:\n+  \/\/ Cast nodes are subject to a few optimizations:\n+  \/\/\n+  \/\/ 1- if the type carried by the Cast doesn't narrow the type of its input, the cast can be replaced by its input.\n+  \/\/ Similarly, if a dominating Cast with the same input and a narrower type constraint is found, it can replace the\n+  \/\/ current cast.\n+  \/\/\n+  \/\/ 2- if the condition that the Cast is control dependent is hoisted, the Cast is hoisted as well\n+  \/\/\n+  \/\/ 1- and 2- are not always applied depending on what constraint are applied to the Cast: there are cases where 1-\n+  \/\/ and 2- apply, where neither 1- nor 2- apply and where one or the other apply. This class abstract away these\n+  \/\/ details.\n+  class DependencyType {\n+  public:\n+    DependencyType(bool depends_on_test, bool narrows_type, const char* desc)\n+      : _floating(depends_on_test),\n+        _narrows_type(narrows_type),\n+        _desc(desc) {\n+    }\n+    NONCOPYABLE(DependencyType);\n+\n+    bool floating() const {\n+      return _floating;\n+    }\n+\n+    bool narrows_type() const {\n+      return _narrows_type;\n+    }\n+    void dump_on(outputStream *st) const {\n+      st->print(\"%s\", _desc);\n+    }\n+\n+    uint hash() const {\n+      return (_floating ? 1 : 0) + (_narrows_type ? 2 : 0);\n+    }\n+\n+    bool cmp(const DependencyType& other) const {\n+      return _floating == other._floating && _narrows_type == other._narrows_type;\n+    }\n+\n+    const DependencyType& widen_type_dependency() const {\n+      if (_floating) {\n+        return FloatingNonNarrowingDependency;\n+      }\n+      return NonFloatingNonNarrowingDependency;\n+    }\n+\n+    const DependencyType& pinned_dependency() const {\n+      if (_narrows_type) {\n+        return NonFloatingNarrowingDependency;\n+      }\n+      return NonFloatingNonNarrowingDependency;\n+    }\n+\n+  private:\n+    const bool _floating; \/\/ Does this Cast depends on its control input or is it pinned?\n+    const bool _narrows_type; \/\/ Does this Cast narrows the type i.e. if input type is narrower can it be removed?\n+    const char* _desc;\n@@ -42,2 +95,19 @@\n-  protected:\n-  const DependencyType _dependency;\n+public:\n+\n+  \/\/ All the possible combinations of floating\/narrowing. Example use cases for each:\n+  \/\/ FloatingNarrowingDependency is used for range checks: the range check CastII is dependent on the range check and if\n+  \/\/ its input's type is narrower than the type of the range check, it's safe to be removed.\n+  \/\/ NonFloatingNonNarrowingDependency is used when a floating node is sunk out of loop: we don't want the cast that\n+  \/\/ forces the node to be out of loop to be removed in any case\n+  \/\/ NonFloatingNarrowingDependency is used when an array access is no longer dependent on a single range check (range\n+  \/\/ check smearing for instance)\n+  \/\/ FloatingNonNarrowingDependency is used after loop opts when Cast nodes' types are widen so Casts that only differ\n+  \/\/ by slightly different types can common. Given the type carried by the Cast is no longer accurate, removing a Cast\n+  \/\/ because its input has a narrower type causes the dependency carried by the Cast to be lost\n+  static const DependencyType FloatingNarrowingDependency;\n+  static const DependencyType FloatingNonNarrowingDependency;\n+  static const DependencyType NonFloatingNarrowingDependency;\n+  static const DependencyType NonFloatingNonNarrowingDependency;\n+\n+protected:\n+  const DependencyType& _dependency;\n@@ -47,2 +117,8 @@\n-  const Type* widen_type(const PhaseGVN* phase, const Type* res, BasicType bt) const;\n-  Node* find_or_make_integer_cast(PhaseIterGVN* igvn, Node* parent, const TypeInteger* type) const;\n+  const TypeInteger* widen_type(const PhaseGVN* phase, const Type* res, BasicType bt) const;\n+\n+  virtual ConstraintCastNode* make_with(Node* parent, const TypeInteger* type, const DependencyType& dependency) const {\n+    ShouldNotReachHere();\n+    return nullptr;\n+  }\n+\n+  Node* find_or_make_integer_cast(PhaseIterGVN* igvn, Node* parent, const TypeInteger* type, const DependencyType& dependency) const;\n@@ -50,1 +126,0 @@\n-  private:\n@@ -58,1 +133,1 @@\n-  ConstraintCastNode(Node* ctrl, Node* n, const Type* t, ConstraintCastNode::DependencyType dependency,\n+  ConstraintCastNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency,\n@@ -70,2 +145,3 @@\n-  virtual bool depends_only_on_test() const { return _dependency == RegularDependency; }\n-  bool carry_dependency() const { return _dependency != RegularDependency; }\n+  bool carry_dependency() const { return !_dependency.cmp(FloatingNarrowingDependency); }\n+  virtual bool depends_only_on_test() const { return _dependency.floating(); }\n+  const DependencyType& dependency() const { return _dependency; }\n@@ -73,1 +149,1 @@\n-  static Node* make_cast_for_basic_type(Node* c, Node* n, const Type* t, DependencyType dependency, BasicType bt);\n+  static Node* make_cast_for_basic_type(Node* c, Node* n, const Type* t, const DependencyType& dependency, BasicType bt);\n@@ -79,1 +155,1 @@\n-  static Node* make_cast_for_type(Node* c, Node* in, const Type* type, DependencyType dependency,\n+  static Node* make_cast_for_type(Node* c, Node* in, const Type* type, const DependencyType& dependency,\n@@ -82,0 +158,1 @@\n+  Node* optimize_integer_cast_of_add(PhaseGVN* phase, BasicType bt);\n@@ -105,1 +182,1 @@\n-  CastIINode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, bool range_check_dependency = false, const TypeTuple* types = nullptr)\n+  CastIINode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = FloatingNarrowingDependency, bool range_check_dependency = false, const TypeTuple* types = nullptr)\n@@ -113,1 +190,1 @@\n-  virtual const Type* Value(PhaseGVN* phase) const;\n+\n@@ -125,0 +202,1 @@\n+  CastIINode* make_with(Node* parent, const TypeInteger* type, const DependencyType& dependency) const;\n@@ -134,1 +212,1 @@\n-  CastLLNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CastLLNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = FloatingNarrowingDependency, const TypeTuple* types = nullptr)\n@@ -150,0 +228,1 @@\n+  CastLLNode* make_with(Node* parent, const TypeInteger* type, const DependencyType& dependency) const;\n@@ -154,1 +233,1 @@\n-  CastHHNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CastHHNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = FloatingNarrowingDependency, const TypeTuple* types = nullptr)\n@@ -165,1 +244,1 @@\n-  CastFFNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CastFFNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = FloatingNarrowingDependency, const TypeTuple* types = nullptr)\n@@ -176,1 +255,1 @@\n-  CastDDNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CastDDNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = FloatingNarrowingDependency, const TypeTuple* types = nullptr)\n@@ -187,1 +266,1 @@\n-  CastVVNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CastVVNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = FloatingNarrowingDependency, const TypeTuple* types = nullptr)\n@@ -201,1 +280,1 @@\n-  CastPPNode (Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CastPPNode (Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = FloatingNarrowingDependency, const TypeTuple* types = nullptr)\n@@ -213,1 +292,1 @@\n-  CheckCastPPNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CheckCastPPNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = FloatingNarrowingDependency, const TypeTuple* types = nullptr)\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":103,"deletions":24,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -2194,1 +2194,1 @@\n-          cast = new CastPPNode(r, uin, phi_type, ConstraintCastNode::StrongDependency, extra_types);\n+          cast = new CastPPNode(r, uin, phi_type, ConstraintCastNode::NonFloatingNarrowingDependency, extra_types);\n@@ -2204,1 +2204,1 @@\n-            cast = new CastPPNode(r, uin, TypePtr::NOTNULL, ConstraintCastNode::StrongDependency, extra_types);\n+            cast = new CastPPNode(r, uin, TypePtr::NOTNULL, ConstraintCastNode::NonFloatingNarrowingDependency, extra_types);\n@@ -2216,1 +2216,1 @@\n-            cast = new CheckCastPPNode(r, n, phi_type, ConstraintCastNode::StrongDependency, extra_types);\n+            cast = new CheckCastPPNode(r, n, phi_type, ConstraintCastNode::NonFloatingNarrowingDependency, extra_types);\n@@ -2219,1 +2219,1 @@\n-            cast = new CastPPNode(r, uin, phi_type, ConstraintCastNode::StrongDependency, extra_types);\n+            cast = new CastPPNode(r, uin, phi_type, ConstraintCastNode::NonFloatingNarrowingDependency, extra_types);\n@@ -2223,1 +2223,1 @@\n-        cast = ConstraintCastNode::make_cast_for_type(r, uin, phi_type, ConstraintCastNode::StrongDependency, extra_types);\n+        cast = ConstraintCastNode::make_cast_for_type(r, uin, phi_type, ConstraintCastNode::NonFloatingNarrowingDependency, extra_types);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -4573,1 +4573,1 @@\n-    value = new CastIINode(ctrl, value, itype, carry_dependency ? ConstraintCastNode::StrongDependency : ConstraintCastNode::RegularDependency, true \/* range check dependency *\/);\n+    value = new CastIINode(ctrl, value, itype, carry_dependency ? ConstraintCastNode::NonFloatingNarrowingDependency : ConstraintCastNode::FloatingNarrowingDependency, true \/* range check dependency *\/);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -736,1 +736,1 @@\n-  return _igvn->transform(ConstraintCastNode::make_cast_for_type(not_eq_control, base, _igvn->type(castpp), ConstraintCastNode::UnconditionalDependency, nullptr));\n+  return _igvn->transform(ConstraintCastNode::make_cast_for_type(not_eq_control, base, _igvn->type(castpp), ConstraintCastNode::NonFloatingNonNarrowingDependency, nullptr));\n@@ -1223,1 +1223,1 @@\n-    nsr_merge_pointer = _igvn->transform(ConstraintCastNode::make_cast_for_type(cast->in(0), cast->in(1), new_t, ConstraintCastNode::RegularDependency, nullptr));\n+    nsr_merge_pointer = _igvn->transform(ConstraintCastNode::make_cast_for_type(cast->in(0), cast->in(1), new_t, ConstraintCastNode::FloatingNarrowingDependency, nullptr));\n@@ -1360,1 +1360,1 @@\n-        Node* new_cast = ConstraintCastNode::make_cast_for_type(out->in(0), out->in(1), out_new_t, ConstraintCastNode::StrongDependency, nullptr);\n+        Node* new_cast = ConstraintCastNode::make_cast_for_type(out->in(0), out->in(1), out_new_t, ConstraintCastNode::NonFloatingNarrowingDependency, nullptr);\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1185,1 +1185,1 @@\n-      ConstraintCastNode::RegularDependency, bt);\n+      ConstraintCastNode::FloatingNarrowingDependency, bt);\n@@ -1215,1 +1215,1 @@\n-      ConstraintCastNode::RegularDependency, bt);\n+      ConstraintCastNode::FloatingNarrowingDependency, bt);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1369,1 +1369,1 @@\n-  Node* castii = new CastIINode(ctrl, incr, TypeInt::INT, ConstraintCastNode::UnconditionalDependency);\n+  Node* castii = new CastIINode(ctrl, incr, TypeInt::INT, ConstraintCastNode::NonFloatingNonNarrowingDependency);\n@@ -3211,1 +3211,1 @@\n-      ConstraintCastNode::UnconditionalDependency, T_INT);\n+      ConstraintCastNode::NonFloatingNonNarrowingDependency, T_INT);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1004,1 +1004,1 @@\n-    inner_iters_actual_int = new CastIINode(outer_head, inner_iters_actual_int, inner_iters_actual_int_range, ConstraintCastNode::UnconditionalDependency);\n+    inner_iters_actual_int = new CastIINode(outer_head, inner_iters_actual_int, inner_iters_actual_int_range, ConstraintCastNode::NonFloatingNonNarrowingDependency);\n@@ -1291,1 +1291,1 @@\n-                                                             ConstraintCastNode::UnconditionalDependency, bt);\n+                                                             ConstraintCastNode::NonFloatingNonNarrowingDependency, bt);\n@@ -1310,1 +1310,1 @@\n-                                                             ConstraintCastNode::UnconditionalDependency, bt);\n+                                                             ConstraintCastNode::NonFloatingNonNarrowingDependency, bt);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1827,1 +1827,1 @@\n-                                                              ConstraintCastNode::UnconditionalDependency, nullptr);\n+                                                              ConstraintCastNode::NonFloatingNonNarrowingDependency, nullptr);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,2 +47,2 @@\n-    final static int length = RANDOM.nextInt(Integer.MAX_VALUE);\n-    final static long llength = RANDOM.nextInt(Integer.MAX_VALUE);\n+    final static int length = RANDOM.nextInt(5, Integer.MAX_VALUE);\n+    final static long llength = RANDOM.nextInt(2, Integer.MAX_VALUE);\n@@ -53,1 +53,1 @@\n-    @IR(counts = { IRNode.CAST_II, \"1\" })\n+    @IR(counts = { IRNode.CAST_II, \"2\" })\n@@ -70,1 +70,1 @@\n-    @IR(counts = { IRNode.CAST_LL, \"1\" })\n+    @IR(counts = { IRNode.CAST_LL, \"2\" })\n@@ -85,0 +85,20 @@\n+\n+    \/\/ Test commoning of Casts after loop opts when they are at the same control\n+    @Test\n+    @IR(counts = { IRNode.CAST_II, \"2\" })\n+    public static int test3() {\n+        int j = Objects.checkIndex(i - 3, length);\n+        j += Objects.checkIndex(i, length);\n+        j += Objects.checkIndex(i - 2, length);\n+        j += Objects.checkIndex(i - 1, length);\n+        return j;\n+    }\n+\n+    @Run(test = \"test3\")\n+    public static void test3_runner() {\n+        i = RANDOM.nextInt(3, length-1);\n+        int res = test3();\n+        if (res != i * 4 - 6) {\n+            throw new RuntimeException(\"incorrect result: \" + res + \" for i = \" + i);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestPushAddThruCast.java","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-        int[] array = new int[100];\n@@ -75,0 +74,7 @@\n+            test14(8, 0, 1, true);\n+            test14(8, 0, 1, false);\n+            inlined14(0, 0);\n+            test15(8, 0, 1, true);\n+            test15(8, 0, 1, false);\n+            inlined15(0, 0);\n+\n@@ -128,0 +134,8 @@\n+        try {\n+            test14(Integer.MAX_VALUE, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test15(Integer.MAX_VALUE, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n@@ -471,0 +485,66 @@\n+    \/\/ Range check cast type widen after loop opts causes control dependency to be lost\n+    private static void test14(int i, int j, int flag, boolean flag2) {\n+        int l = 0;\n+        for (; l < 10; l++);\n+        j = inlined14(j, l);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[10];\n+            newArray[i+j] = 42; \/\/ i+j in [0, 9]\n+            float[] otherArray = new float[i+j]; \/\/ i+j in [0, max]\n+            if (flag == 0) {\n+            }\n+            intField = array[otherArray.length];\n+        } else {\n+            float[] newArray = new float[10];\n+            newArray[i+j] = 42; \/\/ i+j in [0, 9]\n+            float[] otherArray = new float[i+j]; \/\/ i+j in [0, max]\n+            if (flag == 0) {\n+            }\n+            intField = array[otherArray.length];\n+        }\n+    }\n+\n+    private static int inlined14(int j, int l) {\n+        if (l == 10) {\n+            j = 1;\n+        }\n+        return j;\n+    }\n+\n+    private static void test15(int i, int j, int flag, boolean flag2) {\n+        i = Integer.max(i, Integer.MIN_VALUE + 1);\n+        int l = 0;\n+        for (; l < 10; l++);\n+        j = inlined15(j, l);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[10];\n+            newArray[i+j] = 42; \/\/ i+j in [0, 9]\n+            float[] otherArray = new float[i+j]; \/\/ i+j in [0, max]\n+            if (flag == 0) {\n+            }\n+            intField = array[otherArray.length];\n+        } else {\n+            float[] newArray = new float[10];\n+            newArray[i+j] = 42; \/\/ i+j in [0, 9]\n+            float[] otherArray = new float[i+j]; \/\/ i+j in [0, max]\n+            if (flag == 0) {\n+            }\n+            intField = array[otherArray.length];\n+        }\n+    }\n+\n+    private static int inlined15(int j, int l) {\n+        if (l == 10) {\n+            j = Integer.max(j, Integer.MIN_VALUE + 10);\n+        }\n+        return j;\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestArrayAccessAboveRCAfterRCCastIIEliminated.java","additions":81,"deletions":1,"binary":false,"changes":82,"status":"modified"}]}