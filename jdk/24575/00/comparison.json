{"files":[{"patch":"@@ -36,0 +36,5 @@\n+const ConstraintCastNode::DependencyType ConstraintCastNode::RegularDependency(true, true, \"regular dependency\"); \/\/ not pinned, narrows type\n+const ConstraintCastNode::DependencyType ConstraintCastNode::WidenTypeDependency(true, false, \"widen type dependency\"); \/\/ not pinned, doesn't narrow type\n+const ConstraintCastNode::DependencyType ConstraintCastNode::StrongDependency(false, true, \"strong dependency\"); \/\/ pinned, narrows type\n+const ConstraintCastNode::DependencyType ConstraintCastNode::UnconditionalDependency(false, false, \"unconditional dependency\"); \/\/ pinned, doesn't narrow type\n+\n@@ -39,1 +44,1 @@\n-  if (_dependency == UnconditionalDependency) {\n+  if (!_dependency.narrows_type()) {\n@@ -110,1 +115,1 @@\n-  return TypeNode::hash() + (int)_dependency + (_extra_types != nullptr ? _extra_types->hash() : 0);\n+  return TypeNode::hash() + _dependency.hash() + (_extra_types != nullptr ? _extra_types->hash() : 0);\n@@ -118,1 +123,1 @@\n-  if (cast._dependency != _dependency) {\n+  if (!cast._dependency.cmp(_dependency)) {\n@@ -131,1 +136,1 @@\n-Node* ConstraintCastNode::make_cast_for_basic_type(Node* c, Node* n, const Type* t, DependencyType dependency, BasicType bt) {\n+Node* ConstraintCastNode::make_cast_for_basic_type(Node* c, Node* n, const Type* t, const DependencyType& dependency, BasicType bt) {\n@@ -144,1 +149,1 @@\n-  if (_dependency == UnconditionalDependency) {\n+  if (!_dependency.narrows_type()) {\n@@ -206,3 +211,2 @@\n-  if (_dependency != RegularDependency) {\n-    st->print(\" %s dependency\", _dependency == StrongDependency ? \"strong\" : \"unconditional\");\n-  }\n+  st->print(\" \");\n+  _dependency.dump_on(st);\n@@ -212,10 +216,3 @@\n-const Type* CastIINode::Value(PhaseGVN* phase) const {\n-  const Type *res = ConstraintCastNode::Value(phase);\n-  if (res == Type::TOP) {\n-    return Type::TOP;\n-  }\n-  assert(res->isa_int(), \"res must be int\");\n-\n-  \/\/ Similar to ConvI2LNode::Value() for the same reasons\n-  \/\/ see if we can remove type assertion after loop opts\n-  res = widen_type(phase, res, T_INT);\n+CastIINode* CastIINode::make_with(Node* parent, const TypeInteger* type, const DependencyType& dependency) const {\n+  return new CastIINode(in(0), parent, type, dependency, _range_check_dependency, _extra_types);\n+}\n@@ -223,1 +220,2 @@\n-  return res;\n+CastLLNode* CastLLNode::make_with(Node* parent, const TypeInteger* type, const DependencyType& dependency) const {\n+  return new CastLLNode(in(0), parent, type, dependency, _extra_types);\n@@ -226,4 +224,2 @@\n-Node* ConstraintCastNode::find_or_make_integer_cast(PhaseIterGVN* igvn, Node* parent, const TypeInteger* type) const {\n-  Node* n = clone();\n-  n->set_req(1, parent);\n-  n->as_ConstraintCast()->set_type(type);\n+Node* ConstraintCastNode::find_or_make_integer_cast(PhaseIterGVN* igvn, Node* parent, const TypeInteger* type, const DependencyType& dependency) const {\n+  Node* n = make_with(parent, type, dependency);\n@@ -243,2 +239,2 @@\n-  if (can_reshape && !phase->C->post_loop_opts_phase()) {\n-    \/\/ makes sure we run ::Value to potentially remove type assertion after loop opts\n+  if (!phase->C->post_loop_opts_phase()) {\n+    \/\/ makes sure we run widen_type() to potentially common type assertions after loop opts\n@@ -250,1 +246,0 @@\n-  phase->C->record_for_post_loop_opts_igvn(this);\n@@ -280,1 +275,1 @@\n-  assert(_dependency == RegularDependency, \"already pinned\");\n+  assert(depends_only_on_test(), \"already pinned\");\n@@ -282,1 +277,1 @@\n-    return new CastIINode(in(0), in(1), bottom_type(), StrongDependency, has_range_check());\n+    return new CastIINode(in(0), in(1), bottom_type(), _dependency.pinned_dependency(), has_range_check());\n@@ -316,10 +311,0 @@\n-const Type* CastLLNode::Value(PhaseGVN* phase) const {\n-  const Type* res = ConstraintCastNode::Value(phase);\n-  if (res == Type::TOP) {\n-    return Type::TOP;\n-  }\n-  assert(res->isa_long(), \"res must be long\");\n-\n-  return widen_type(phase, res, T_LONG);\n-}\n-\n@@ -332,1 +317,1 @@\n-    \/\/ makes sure we run ::Value to potentially remove type assertion after loop opts\n+    \/\/ makes sure we run widen_type() to potentially common type assertions after loop opts\n@@ -478,1 +463,1 @@\n-Node* ConstraintCastNode::make_cast_for_type(Node* c, Node* in, const Type* type, DependencyType dependency,\n+Node* ConstraintCastNode::make_cast_for_type(Node* c, Node* in, const Type* type, const DependencyType& dependency,\n@@ -499,1 +484,1 @@\n-Node* ConstraintCastNode::optimize_integer_cast(PhaseGVN* phase, BasicType bt) {\n+Node* ConstraintCastNode::optimize_integer_cast_of_add(PhaseGVN* phase, BasicType bt) {\n@@ -517,2 +502,8 @@\n-    Node* cx = find_or_make_integer_cast(igvn, x, rx);\n-    Node* cy = find_or_make_integer_cast(igvn, y, ry);\n+    const TypeInteger* tx = phase->type(x)->is_integer(bt);\n+    const TypeInteger* ty = phase->type(y)->is_integer(bt);\n+\n+    \/\/ If both inputs are not constant then, with the Cast pushed through the Add\/Sub, the cast gets less precised types,\n+    \/\/ and the resulting Add\/Sub's type is wider than that of the Cast before pushing.\n+    const DependencyType& dependency = (!tx->is_con() && !ty->is_con()) ? _dependency.widen_type_dependency() : _dependency;\n+    Node* cx = find_or_make_integer_cast(igvn, x, rx, dependency);\n+    Node* cy = find_or_make_integer_cast(igvn, y, ry, dependency);\n@@ -530,2 +521,3 @@\n-const Type* ConstraintCastNode::widen_type(const PhaseGVN* phase, const Type* res, BasicType bt) const {\n-  if (!phase->C->post_loop_opts_phase()) {\n+Node* ConstraintCastNode::optimize_integer_cast(PhaseGVN* phase, BasicType bt) {\n+  Node* res = optimize_integer_cast_of_add(phase, bt);\n+  if (res != nullptr) {\n@@ -534,0 +526,13 @@\n+  const Type* t = Value(phase);\n+  if (t != Type::TOP) {\n+    const TypeInteger* wide_t = widen_type(phase, t, bt);\n+    if (wide_t != t) {\n+      \/\/ Widening the type of the Cast (to allow some commoning) causes the Cast to change how it can be optimized (if\n+      \/\/ type of its input is narrower than the Cast's type, we can't remove it to not loose the dependency).\n+      return make_with(in(1), wide_t, _dependency.widen_type_dependency());\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+const TypeInteger* ConstraintCastNode::widen_type(const PhaseGVN* phase, const Type* res, BasicType bt) const {\n@@ -535,0 +540,3 @@\n+  if (!phase->C->post_loop_opts_phase()) {\n+    return this_type;\n+  }\n@@ -555,1 +563,1 @@\n-  return res;\n+  return this_type;\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":54,"deletions":46,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -35,5 +35,58 @@\n-public:\n-  enum DependencyType {\n-    RegularDependency, \/\/ if cast doesn't improve input type, cast can be removed\n-    StrongDependency,  \/\/ leave cast in even if _type doesn't improve input type, can be replaced by stricter dominating cast if one exist\n-    UnconditionalDependency \/\/ leave cast in unconditionally\n+protected:\n+  \/\/ Cast nodes are subject to a few optimizations:\n+  \/\/\n+  \/\/ 1- if the type carried by the Cast doesn't narrow the type of its input, the cast can be replaced by its input.\n+  \/\/ Similarly, if a dominating Cast with the same input and a narrower type constraint is found, it can replace the\n+  \/\/ current cast.\n+  \/\/\n+  \/\/ 2- if the condition that the Cast is control dependent is hoisted, the Cast is hoisted as well\n+  \/\/\n+  \/\/ 1- and 2- are not always applied depending on what constraint are applied to the Cast: there are cases where 1-\n+  \/\/ and 2- apply, where neither 1- nor 2- apply and where one or the other apply. This class abstract away these\n+  \/\/ details.\n+  class DependencyType {\n+  public:\n+    DependencyType(bool depends_on_test, bool narrows_type, const char* desc)\n+      : _depends_only_on_test(depends_on_test),\n+        _narrows_type(narrows_type),\n+        _desc(desc) {\n+    }\n+    NONCOPYABLE(DependencyType);\n+\n+    bool depends_only_on_test() const {\n+      return _depends_only_on_test;\n+    }\n+\n+    bool narrows_type() const {\n+      return _narrows_type;\n+    }\n+    void dump_on(outputStream *st) const {\n+      st->print(\"%s\", _desc);\n+    }\n+\n+    uint hash() const {\n+      return (_depends_only_on_test ? 1 : 0) + (_narrows_type ? 2 : 0);\n+    }\n+\n+    bool cmp(const DependencyType& other) const {\n+      return _depends_only_on_test == other._depends_only_on_test && _narrows_type == other._narrows_type;\n+    }\n+\n+    const DependencyType& widen_type_dependency() const {\n+      if (_depends_only_on_test) {\n+        return WidenTypeDependency;\n+      }\n+      return UnconditionalDependency;\n+    }\n+\n+    const DependencyType& pinned_dependency() const {\n+      if (_narrows_type) {\n+        return StrongDependency;\n+      }\n+      return UnconditionalDependency;\n+    }\n+\n+  private:\n+    const bool _depends_only_on_test; \/\/ Does this Cast depends on its control input or is it pinned?\n+    const bool _narrows_type; \/\/ Does this Cast narrows the type i.e. if input type is narrower can it be removed?\n+    const char* _desc;\n@@ -42,0 +95,7 @@\n+public:\n+\n+  static const DependencyType RegularDependency;\n+  static const DependencyType WidenTypeDependency;\n+  static const DependencyType StrongDependency;\n+  static const DependencyType UnconditionalDependency;\n+\n@@ -43,1 +103,1 @@\n-  const DependencyType _dependency;\n+  const DependencyType& _dependency;\n@@ -47,2 +107,8 @@\n-  const Type* widen_type(const PhaseGVN* phase, const Type* res, BasicType bt) const;\n-  Node* find_or_make_integer_cast(PhaseIterGVN* igvn, Node* parent, const TypeInteger* type) const;\n+  const TypeInteger* widen_type(const PhaseGVN* phase, const Type* res, BasicType bt) const;\n+\n+  virtual ConstraintCastNode* make_with(Node* parent, const TypeInteger* type, const DependencyType& dependency) const {\n+    ShouldNotReachHere();\n+    return nullptr;\n+  }\n+\n+  Node* find_or_make_integer_cast(PhaseIterGVN* igvn, Node* parent, const TypeInteger* type, const DependencyType& dependency) const;\n@@ -50,1 +116,0 @@\n-  private:\n@@ -58,1 +123,1 @@\n-  ConstraintCastNode(Node* ctrl, Node* n, const Type* t, ConstraintCastNode::DependencyType dependency,\n+  ConstraintCastNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency,\n@@ -70,2 +135,3 @@\n-  virtual bool depends_only_on_test() const { return _dependency == RegularDependency; }\n-  bool carry_dependency() const { return _dependency != RegularDependency; }\n+  bool carry_dependency() const { return !_dependency.cmp(RegularDependency); }\n+  virtual bool depends_only_on_test() const { return _dependency.depends_only_on_test(); }\n+  const DependencyType& dependency() const { return _dependency; }\n@@ -73,1 +139,1 @@\n-  static Node* make_cast_for_basic_type(Node* c, Node* n, const Type* t, DependencyType dependency, BasicType bt);\n+  static Node* make_cast_for_basic_type(Node* c, Node* n, const Type* t, const DependencyType& dependency, BasicType bt);\n@@ -79,1 +145,1 @@\n-  static Node* make_cast_for_type(Node* c, Node* in, const Type* type, DependencyType dependency,\n+  static Node* make_cast_for_type(Node* c, Node* in, const Type* type, const DependencyType& dependency,\n@@ -82,0 +148,1 @@\n+  Node* optimize_integer_cast_of_add(PhaseGVN* phase, BasicType bt);\n@@ -105,1 +172,1 @@\n-  CastIINode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, bool range_check_dependency = false, const TypeTuple* types = nullptr)\n+  CastIINode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = RegularDependency, bool range_check_dependency = false, const TypeTuple* types = nullptr)\n@@ -113,1 +180,1 @@\n-  virtual const Type* Value(PhaseGVN* phase) const;\n+\n@@ -125,0 +192,1 @@\n+  CastIINode* make_with(Node* parent, const TypeInteger* type, const DependencyType& dependency) const;\n@@ -134,1 +202,1 @@\n-  CastLLNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CastLLNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = RegularDependency, const TypeTuple* types = nullptr)\n@@ -140,1 +208,0 @@\n-  virtual const Type* Value(PhaseGVN* phase) const;\n@@ -144,0 +211,1 @@\n+  CastLLNode* make_with(Node* parent, const TypeInteger* type, const DependencyType& dependency) const;\n@@ -148,1 +216,1 @@\n-  CastHHNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CastHHNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = RegularDependency, const TypeTuple* types = nullptr)\n@@ -159,1 +227,1 @@\n-  CastFFNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CastFFNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = RegularDependency, const TypeTuple* types = nullptr)\n@@ -170,1 +238,1 @@\n-  CastDDNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CastDDNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = RegularDependency, const TypeTuple* types = nullptr)\n@@ -181,1 +249,1 @@\n-  CastVVNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CastVVNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = RegularDependency, const TypeTuple* types = nullptr)\n@@ -195,1 +263,1 @@\n-  CastPPNode (Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CastPPNode (Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = RegularDependency, const TypeTuple* types = nullptr)\n@@ -207,1 +275,1 @@\n-  CheckCastPPNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CheckCastPPNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = RegularDependency, const TypeTuple* types = nullptr)\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":92,"deletions":24,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -47,2 +47,2 @@\n-    final static int length = RANDOM.nextInt(Integer.MAX_VALUE);\n-    final static long llength = RANDOM.nextInt(Integer.MAX_VALUE);\n+    final static int length = RANDOM.nextInt(5, Integer.MAX_VALUE);\n+    final static long llength = RANDOM.nextInt(2, Integer.MAX_VALUE);\n@@ -53,1 +53,1 @@\n-    @IR(counts = { IRNode.CAST_II, \"1\" })\n+    @IR(counts = { IRNode.CAST_II, \"2\" })\n@@ -70,1 +70,1 @@\n-    @IR(counts = { IRNode.CAST_LL, \"1\" })\n+    @IR(counts = { IRNode.CAST_LL, \"2\" })\n@@ -85,0 +85,20 @@\n+\n+    \/\/ Test commoning of Casts after loop opts when they are at the same control\n+    @Test\n+    @IR(counts = { IRNode.CAST_II, \"2\" })\n+    public static int test3() {\n+        int j = Objects.checkIndex(i - 3, length);\n+        j += Objects.checkIndex(i, length);\n+        j += Objects.checkIndex(i - 2, length);\n+        j += Objects.checkIndex(i - 1, length);\n+        return j;\n+    }\n+\n+    @Run(test = \"test3\")\n+    public static void test3_runner() {\n+        i = RANDOM.nextInt(3, length-1);\n+        int res = test3();\n+        if (res != i * 4 - 6) {\n+            throw new RuntimeException(\"incorrect result: \" + res + \" for i = \" + i);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestPushAddThruCast.java","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-        int[] array = new int[100];\n@@ -75,0 +74,7 @@\n+            test14(8, 0, 1, true);\n+            test14(8, 0, 1, false);\n+            inlined14(0, 0);\n+            test15(8, 0, 1, true);\n+            test15(8, 0, 1, false);\n+            inlined15(0, 0);\n+\n@@ -128,0 +134,8 @@\n+        try {\n+            test14(Integer.MAX_VALUE, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test15(Integer.MAX_VALUE, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n@@ -471,0 +485,66 @@\n+    \/\/ Range check cast type widen after loop opts causes control dependency to be lost\n+    private static void test14(int i, int j, int flag, boolean flag2) {\n+        int l = 0;\n+        for (; l < 10; l++);\n+        j = inlined14(j, l);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[10];\n+            newArray[i+j] = 42; \/\/ i+j in [0, 9]\n+            float[] otherArray = new float[i+j]; \/\/ i+j in [0, max]\n+            if (flag == 0) {\n+            }\n+            intField = array[otherArray.length];\n+        } else {\n+            float[] newArray = new float[10];\n+            newArray[i+j] = 42; \/\/ i+j in [0, 9]\n+            float[] otherArray = new float[i+j]; \/\/ i+j in [0, max]\n+            if (flag == 0) {\n+            }\n+            intField = array[otherArray.length];\n+        }\n+    }\n+\n+    private static int inlined14(int j, int l) {\n+        if (l == 10) {\n+            j = 1;\n+        }\n+        return j;\n+    }\n+\n+    private static void test15(int i, int j, int flag, boolean flag2) {\n+        i = Integer.max(i, Integer.MIN_VALUE + 1);\n+        int l = 0;\n+        for (; l < 10; l++);\n+        j = inlined15(j, l);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[10];\n+            newArray[i+j] = 42; \/\/ i+j in [0, 9]\n+            float[] otherArray = new float[i+j]; \/\/ i+j in [0, max]\n+            if (flag == 0) {\n+            }\n+            intField = array[otherArray.length];\n+        } else {\n+            float[] newArray = new float[10];\n+            newArray[i+j] = 42; \/\/ i+j in [0, 9]\n+            float[] otherArray = new float[i+j]; \/\/ i+j in [0, max]\n+            if (flag == 0) {\n+            }\n+            intField = array[otherArray.length];\n+        }\n+    }\n+\n+    private static int inlined15(int j, int l) {\n+        if (l == 10) {\n+            j = Integer.max(j, Integer.MIN_VALUE + 10);\n+        }\n+        return j;\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestArrayAccessAboveRCAfterRCCastIIEliminated.java","additions":81,"deletions":1,"binary":false,"changes":82,"status":"modified"}]}