{"files":[{"patch":"@@ -38,0 +38,5 @@\n+const ConstraintCastNode::DependencyType ConstraintCastNode::RegularDependency(true, true, \"regular dependency\"); \/\/ not pinned, narrows type\n+const ConstraintCastNode::DependencyType ConstraintCastNode::WidenTypeDependency(true, false, \"widen type dependency\"); \/\/ not pinned, doesn't narrow type\n+const ConstraintCastNode::DependencyType ConstraintCastNode::StrongDependency(false, true, \"strong dependency\"); \/\/ pinned, narrows type\n+const ConstraintCastNode::DependencyType ConstraintCastNode::UnconditionalDependency(false, false, \"unconditional dependency\"); \/\/ pinned, doesn't narrow type\n+\n@@ -41,1 +46,1 @@\n-  if (_dependency == UnconditionalDependency) {\n+  if (!_dependency.narrows_type()) {\n@@ -112,1 +117,1 @@\n-  return TypeNode::hash() + (int)_dependency + (_extra_types != nullptr ? _extra_types->hash() : 0);\n+  return TypeNode::hash() + _dependency.hash() + (_extra_types != nullptr ? _extra_types->hash() : 0);\n@@ -120,1 +125,1 @@\n-  if (cast._dependency != _dependency) {\n+  if (!cast._dependency.cmp(_dependency)) {\n@@ -133,1 +138,1 @@\n-Node* ConstraintCastNode::make_cast_for_basic_type(Node* c, Node* n, const Type* t, DependencyType dependency, BasicType bt) {\n+Node* ConstraintCastNode::make_cast_for_basic_type(Node* c, Node* n, const Type* t, const DependencyType& dependency, BasicType bt) {\n@@ -146,1 +151,1 @@\n-  if (_dependency == UnconditionalDependency) {\n+  if (!_dependency.narrows_type()) {\n@@ -208,3 +213,2 @@\n-  if (_dependency != RegularDependency) {\n-    st->print(\" %s dependency\", _dependency == StrongDependency ? \"strong\" : \"unconditional\");\n-  }\n+  st->print(\" \");\n+  _dependency.dump_on(st);\n@@ -214,10 +218,3 @@\n-const Type* CastIINode::Value(PhaseGVN* phase) const {\n-  const Type *res = ConstraintCastNode::Value(phase);\n-  if (res == Type::TOP) {\n-    return Type::TOP;\n-  }\n-  assert(res->isa_int(), \"res must be int\");\n-\n-  \/\/ Similar to ConvI2LNode::Value() for the same reasons\n-  \/\/ see if we can remove type assertion after loop opts\n-  res = widen_type(phase, res, T_INT);\n+CastIINode* CastIINode::make_with(Node* parent, const TypeInteger* type, const DependencyType& dependency) const {\n+  return new CastIINode(in(0), parent, type, dependency, _range_check_dependency, _extra_types);\n+}\n@@ -225,1 +222,2 @@\n-  return res;\n+CastLLNode* CastLLNode::make_with(Node* parent, const TypeInteger* type, const DependencyType& dependency) const {\n+  return new CastLLNode(in(0), parent, type, dependency, _extra_types);\n@@ -228,4 +226,2 @@\n-Node* ConstraintCastNode::find_or_make_integer_cast(PhaseIterGVN* igvn, Node* parent, const TypeInteger* type) const {\n-  Node* n = clone();\n-  n->set_req(1, parent);\n-  n->as_ConstraintCast()->set_type(type);\n+Node* ConstraintCastNode::find_or_make_integer_cast(PhaseIterGVN* igvn, Node* parent, const TypeInteger* type, const DependencyType& dependency) const {\n+  Node* n = make_with(parent, type, dependency);\n@@ -245,2 +241,2 @@\n-  if (can_reshape && !phase->C->post_loop_opts_phase()) {\n-    \/\/ makes sure we run ::Value to potentially remove type assertion after loop opts\n+  if (!phase->C->post_loop_opts_phase()) {\n+    \/\/ makes sure we run widen_type() to potentially common type assertions after loop opts\n@@ -252,1 +248,0 @@\n-  phase->C->record_for_post_loop_opts_igvn(this);\n@@ -282,1 +277,1 @@\n-  assert(_dependency == RegularDependency, \"already pinned\");\n+  assert(depends_only_on_test(), \"already pinned\");\n@@ -284,1 +279,1 @@\n-    return new CastIINode(in(0), in(1), bottom_type(), StrongDependency, has_range_check());\n+    return new CastIINode(in(0), in(1), bottom_type(), _dependency.pinned_dependency(), has_range_check());\n@@ -395,1 +390,1 @@\n-    \/\/ makes sure we run ::Value to potentially remove type assertion after loop opts\n+    \/\/ makes sure we run widen_type() to potentially common type assertions after loop opts\n@@ -546,1 +541,1 @@\n-Node* ConstraintCastNode::make_cast_for_type(Node* c, Node* in, const Type* type, DependencyType dependency,\n+Node* ConstraintCastNode::make_cast_for_type(Node* c, Node* in, const Type* type, const DependencyType& dependency,\n@@ -567,1 +562,1 @@\n-Node* ConstraintCastNode::optimize_integer_cast(PhaseGVN* phase, BasicType bt) {\n+Node* ConstraintCastNode::optimize_integer_cast_of_add(PhaseGVN* phase, BasicType bt) {\n@@ -589,2 +584,8 @@\n-    Node* cx = find_or_make_integer_cast(igvn, x, rx);\n-    Node* cy = find_or_make_integer_cast(igvn, y, ry);\n+    const TypeInteger* tx = phase->type(x)->is_integer(bt);\n+    const TypeInteger* ty = phase->type(y)->is_integer(bt);\n+\n+    \/\/ If both inputs are not constant then, with the Cast pushed through the Add\/Sub, the cast gets less precised types,\n+    \/\/ and the resulting Add\/Sub's type is wider than that of the Cast before pushing.\n+    const DependencyType& dependency = (!tx->is_con() && !ty->is_con()) ? _dependency.widen_type_dependency() : _dependency;\n+    Node* cx = find_or_make_integer_cast(igvn, x, rx, dependency);\n+    Node* cy = find_or_make_integer_cast(igvn, y, ry, dependency);\n@@ -602,2 +603,3 @@\n-const Type* ConstraintCastNode::widen_type(const PhaseGVN* phase, const Type* res, BasicType bt) const {\n-  if (!phase->C->post_loop_opts_phase()) {\n+Node* ConstraintCastNode::optimize_integer_cast(PhaseGVN* phase, BasicType bt) {\n+  Node* res = optimize_integer_cast_of_add(phase, bt);\n+  if (res != nullptr) {\n@@ -606,0 +608,17 @@\n+  const Type* t = Value(phase);\n+  if (t != Type::TOP) {\n+    const TypeInteger* wide_t = widen_type(phase, t, bt);\n+    if (wide_t != t) {\n+      \/\/ Widening the type of the Cast (to allow some commoning) causes the Cast to change how it can be optimized (if\n+      \/\/ type of its input is narrower than the Cast's type, we can't remove it to not loose the dependency).\n+      return make_with(in(1), wide_t, _dependency.widen_type_dependency());\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+const TypeInteger* ConstraintCastNode::widen_type(const PhaseGVN* phase, const Type* res, BasicType bt) const {\n+  const TypeInteger* this_type = res->is_integer(bt);\n+  if (!phase->C->post_loop_opts_phase()) {\n+    return this_type;\n+  }\n@@ -615,1 +634,1 @@\n-    return res;\n+    return this_type;\n@@ -618,1 +637,0 @@\n-  const TypeInteger* this_type = res->is_integer(bt);\n@@ -639,1 +657,1 @@\n-  return res;\n+  return this_type;\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":56,"deletions":38,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -35,5 +35,58 @@\n-public:\n-  enum DependencyType {\n-    RegularDependency, \/\/ if cast doesn't improve input type, cast can be removed\n-    StrongDependency,  \/\/ leave cast in even if _type doesn't improve input type, can be replaced by stricter dominating cast if one exist\n-    UnconditionalDependency \/\/ leave cast in unconditionally\n+protected:\n+  \/\/ Cast nodes are subject to a few optimizations:\n+  \/\/\n+  \/\/ 1- if the type carried by the Cast doesn't narrow the type of its input, the cast can be replaced by its input.\n+  \/\/ Similarly, if a dominating Cast with the same input and a narrower type constraint is found, it can replace the\n+  \/\/ current cast.\n+  \/\/\n+  \/\/ 2- if the condition that the Cast is control dependent is hoisted, the Cast is hoisted as well\n+  \/\/\n+  \/\/ 1- and 2- are not always applied depending on what constraint are applied to the Cast: there are cases where 1-\n+  \/\/ and 2- apply, where neither 1- nor 2- apply and where one or the other apply. This class abstract away these\n+  \/\/ details.\n+  class DependencyType {\n+  public:\n+    DependencyType(bool depends_on_test, bool narrows_type, const char* desc)\n+      : _depends_only_on_test(depends_on_test),\n+        _narrows_type(narrows_type),\n+        _desc(desc) {\n+    }\n+    NONCOPYABLE(DependencyType);\n+\n+    bool depends_only_on_test() const {\n+      return _depends_only_on_test;\n+    }\n+\n+    bool narrows_type() const {\n+      return _narrows_type;\n+    }\n+    void dump_on(outputStream *st) const {\n+      st->print(\"%s\", _desc);\n+    }\n+\n+    uint hash() const {\n+      return (_depends_only_on_test ? 1 : 0) + (_narrows_type ? 2 : 0);\n+    }\n+\n+    bool cmp(const DependencyType& other) const {\n+      return _depends_only_on_test == other._depends_only_on_test && _narrows_type == other._narrows_type;\n+    }\n+\n+    const DependencyType& widen_type_dependency() const {\n+      if (_depends_only_on_test) {\n+        return WidenTypeDependency;\n+      }\n+      return UnconditionalDependency;\n+    }\n+\n+    const DependencyType& pinned_dependency() const {\n+      if (_narrows_type) {\n+        return StrongDependency;\n+      }\n+      return UnconditionalDependency;\n+    }\n+\n+  private:\n+    const bool _depends_only_on_test; \/\/ Does this Cast depends on its control input or is it pinned?\n+    const bool _narrows_type; \/\/ Does this Cast narrows the type i.e. if input type is narrower can it be removed?\n+    const char* _desc;\n@@ -42,0 +95,7 @@\n+public:\n+\n+  static const DependencyType RegularDependency;\n+  static const DependencyType WidenTypeDependency;\n+  static const DependencyType StrongDependency;\n+  static const DependencyType UnconditionalDependency;\n+\n@@ -43,1 +103,1 @@\n-  const DependencyType _dependency;\n+  const DependencyType& _dependency;\n@@ -47,2 +107,8 @@\n-  const Type* widen_type(const PhaseGVN* phase, const Type* res, BasicType bt) const;\n-  Node* find_or_make_integer_cast(PhaseIterGVN* igvn, Node* parent, const TypeInteger* type) const;\n+  const TypeInteger* widen_type(const PhaseGVN* phase, const Type* res, BasicType bt) const;\n+\n+  virtual ConstraintCastNode* make_with(Node* parent, const TypeInteger* type, const DependencyType& dependency) const {\n+    ShouldNotReachHere();\n+    return nullptr;\n+  }\n+\n+  Node* find_or_make_integer_cast(PhaseIterGVN* igvn, Node* parent, const TypeInteger* type, const DependencyType& dependency) const;\n@@ -50,1 +116,0 @@\n-  private:\n@@ -58,1 +123,1 @@\n-  ConstraintCastNode(Node* ctrl, Node* n, const Type* t, ConstraintCastNode::DependencyType dependency,\n+  ConstraintCastNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency,\n@@ -70,2 +135,3 @@\n-  virtual bool depends_only_on_test() const { return _dependency == RegularDependency; }\n-  bool carry_dependency() const { return _dependency != RegularDependency; }\n+  bool carry_dependency() const { return !_dependency.cmp(RegularDependency); }\n+  virtual bool depends_only_on_test() const { return _dependency.depends_only_on_test(); }\n+  const DependencyType& dependency() const { return _dependency; }\n@@ -73,1 +139,1 @@\n-  static Node* make_cast_for_basic_type(Node* c, Node* n, const Type* t, DependencyType dependency, BasicType bt);\n+  static Node* make_cast_for_basic_type(Node* c, Node* n, const Type* t, const DependencyType& dependency, BasicType bt);\n@@ -79,1 +145,1 @@\n-  static Node* make_cast_for_type(Node* c, Node* in, const Type* type, DependencyType dependency,\n+  static Node* make_cast_for_type(Node* c, Node* in, const Type* type, const DependencyType& dependency,\n@@ -82,0 +148,1 @@\n+  Node* optimize_integer_cast_of_add(PhaseGVN* phase, BasicType bt);\n@@ -105,1 +172,1 @@\n-  CastIINode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, bool range_check_dependency = false, const TypeTuple* types = nullptr)\n+  CastIINode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = RegularDependency, bool range_check_dependency = false, const TypeTuple* types = nullptr)\n@@ -113,1 +180,1 @@\n-  virtual const Type* Value(PhaseGVN* phase) const;\n+\n@@ -125,0 +192,1 @@\n+  CastIINode* make_with(Node* parent, const TypeInteger* type, const DependencyType& dependency) const;\n@@ -134,1 +202,1 @@\n-  CastLLNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CastLLNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = RegularDependency, const TypeTuple* types = nullptr)\n@@ -150,0 +218,1 @@\n+  CastLLNode* make_with(Node* parent, const TypeInteger* type, const DependencyType& dependency) const;\n@@ -154,1 +223,1 @@\n-  CastHHNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CastHHNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = RegularDependency, const TypeTuple* types = nullptr)\n@@ -165,1 +234,1 @@\n-  CastFFNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CastFFNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = RegularDependency, const TypeTuple* types = nullptr)\n@@ -176,1 +245,1 @@\n-  CastDDNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CastDDNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = RegularDependency, const TypeTuple* types = nullptr)\n@@ -187,1 +256,1 @@\n-  CastVVNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CastVVNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = RegularDependency, const TypeTuple* types = nullptr)\n@@ -201,1 +270,1 @@\n-  CastPPNode (Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CastPPNode (Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = RegularDependency, const TypeTuple* types = nullptr)\n@@ -213,1 +282,1 @@\n-  CheckCastPPNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CheckCastPPNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = RegularDependency, const TypeTuple* types = nullptr)\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":92,"deletions":23,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -47,2 +47,2 @@\n-    final static int length = RANDOM.nextInt(Integer.MAX_VALUE);\n-    final static long llength = RANDOM.nextInt(Integer.MAX_VALUE);\n+    final static int length = RANDOM.nextInt(5, Integer.MAX_VALUE);\n+    final static long llength = RANDOM.nextInt(2, Integer.MAX_VALUE);\n@@ -53,1 +53,1 @@\n-    @IR(counts = { IRNode.CAST_II, \"1\" })\n+    @IR(counts = { IRNode.CAST_II, \"2\" })\n@@ -70,1 +70,1 @@\n-    @IR(counts = { IRNode.CAST_LL, \"1\" })\n+    @IR(counts = { IRNode.CAST_LL, \"2\" })\n@@ -85,0 +85,20 @@\n+\n+    \/\/ Test commoning of Casts after loop opts when they are at the same control\n+    @Test\n+    @IR(counts = { IRNode.CAST_II, \"2\" })\n+    public static int test3() {\n+        int j = Objects.checkIndex(i - 3, length);\n+        j += Objects.checkIndex(i, length);\n+        j += Objects.checkIndex(i - 2, length);\n+        j += Objects.checkIndex(i - 1, length);\n+        return j;\n+    }\n+\n+    @Run(test = \"test3\")\n+    public static void test3_runner() {\n+        i = RANDOM.nextInt(3, length-1);\n+        int res = test3();\n+        if (res != i * 4 - 6) {\n+            throw new RuntimeException(\"incorrect result: \" + res + \" for i = \" + i);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestPushAddThruCast.java","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-        int[] array = new int[100];\n@@ -75,0 +74,7 @@\n+            test14(8, 0, 1, true);\n+            test14(8, 0, 1, false);\n+            inlined14(0, 0);\n+            test15(8, 0, 1, true);\n+            test15(8, 0, 1, false);\n+            inlined15(0, 0);\n+\n@@ -128,0 +134,8 @@\n+        try {\n+            test14(Integer.MAX_VALUE, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test15(Integer.MAX_VALUE, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n@@ -471,0 +485,66 @@\n+    \/\/ Range check cast type widen after loop opts causes control dependency to be lost\n+    private static void test14(int i, int j, int flag, boolean flag2) {\n+        int l = 0;\n+        for (; l < 10; l++);\n+        j = inlined14(j, l);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[10];\n+            newArray[i+j] = 42; \/\/ i+j in [0, 9]\n+            float[] otherArray = new float[i+j]; \/\/ i+j in [0, max]\n+            if (flag == 0) {\n+            }\n+            intField = array[otherArray.length];\n+        } else {\n+            float[] newArray = new float[10];\n+            newArray[i+j] = 42; \/\/ i+j in [0, 9]\n+            float[] otherArray = new float[i+j]; \/\/ i+j in [0, max]\n+            if (flag == 0) {\n+            }\n+            intField = array[otherArray.length];\n+        }\n+    }\n+\n+    private static int inlined14(int j, int l) {\n+        if (l == 10) {\n+            j = 1;\n+        }\n+        return j;\n+    }\n+\n+    private static void test15(int i, int j, int flag, boolean flag2) {\n+        i = Integer.max(i, Integer.MIN_VALUE + 1);\n+        int l = 0;\n+        for (; l < 10; l++);\n+        j = inlined15(j, l);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[10];\n+            newArray[i+j] = 42; \/\/ i+j in [0, 9]\n+            float[] otherArray = new float[i+j]; \/\/ i+j in [0, max]\n+            if (flag == 0) {\n+            }\n+            intField = array[otherArray.length];\n+        } else {\n+            float[] newArray = new float[10];\n+            newArray[i+j] = 42; \/\/ i+j in [0, 9]\n+            float[] otherArray = new float[i+j]; \/\/ i+j in [0, max]\n+            if (flag == 0) {\n+            }\n+            intField = array[otherArray.length];\n+        }\n+    }\n+\n+    private static int inlined15(int j, int l) {\n+        if (l == 10) {\n+            j = Integer.max(j, Integer.MIN_VALUE + 10);\n+        }\n+        return j;\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestArrayAccessAboveRCAfterRCCastIIEliminated.java","additions":81,"deletions":1,"binary":false,"changes":82,"status":"modified"}]}