{"files":[{"patch":"@@ -1397,1 +1397,1 @@\n-      Node* base = new CheckCastPPNode(ctrl, orig_base, orig_base->bottom_type(), ConstraintCastNode::StrongDependency);\n+      Node* base = new CheckCastPPNode(ctrl, orig_base, orig_base->bottom_type(), ConstraintCastNode::DependencyType::NonFloatingNarrowing);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"castnode.hpp\"\n@@ -38,0 +37,5 @@\n+const ConstraintCastNode::DependencyType ConstraintCastNode::DependencyType::FloatingNarrowing(true, true, \"floating narrowing dependency\"); \/\/ not pinned, narrows type\n+const ConstraintCastNode::DependencyType ConstraintCastNode::DependencyType::FloatingNonNarrowing(true, false, \"floating non-narrowing dependency\"); \/\/ not pinned, doesn't narrow type\n+const ConstraintCastNode::DependencyType ConstraintCastNode::DependencyType::NonFloatingNarrowing(false, true, \"non-floating narrowing dependency\"); \/\/ pinned, narrows type\n+const ConstraintCastNode::DependencyType ConstraintCastNode::DependencyType::NonFloatingNonNarrowing(false, false, \"non-floating non-narrowing dependency\"); \/\/ pinned, doesn't narrow type\n+\n@@ -41,1 +45,2 @@\n-  if (_dependency == UnconditionalDependency) {\n+  if (!_dependency.narrows_type()) {\n+    \/\/ If this cast doesn't carry a type dependency (i.e. not used for type narrowing), we cannot optimize it.\n@@ -44,0 +49,4 @@\n+\n+  \/\/ This cast node carries a type dependency. We can remove it if:\n+  \/\/ - Its input has a narrower type\n+  \/\/ - There's a dominating cast with same input but narrower type\n@@ -112,1 +121,1 @@\n-  return TypeNode::hash() + (int)_dependency + (_extra_types != nullptr ? _extra_types->hash() : 0);\n+  return TypeNode::hash() + _dependency.hash() + (_extra_types != nullptr ? _extra_types->hash() : 0);\n@@ -120,1 +129,1 @@\n-  if (cast._dependency != _dependency) {\n+  if (!cast._dependency.cmp(_dependency)) {\n@@ -133,1 +142,1 @@\n-Node* ConstraintCastNode::make_cast_for_basic_type(Node* c, Node* n, const Type* t, DependencyType dependency, BasicType bt) {\n+Node* ConstraintCastNode::make_cast_for_basic_type(Node* c, Node* n, const Type* t, const DependencyType& dependency, BasicType bt) {\n@@ -146,3 +155,3 @@\n-  if (_dependency == UnconditionalDependency) {\n-    return nullptr;\n-  }\n+  \/\/ See discussion at definition of ConstraintCastNode::DependencyType: replacing this cast with a dominating one is\n+  \/\/ not safe if _dependency.narrows_type() is not true.\n+  assert(_dependency.narrows_type(), \"cast can't be replaced by dominating one\");\n@@ -208,3 +217,2 @@\n-  if (_dependency != RegularDependency) {\n-    st->print(\" %s dependency\", _dependency == StrongDependency ? \"strong\" : \"unconditional\");\n-  }\n+  st->print(\" \");\n+  _dependency.dump_on(st);\n@@ -214,10 +222,3 @@\n-const Type* CastIINode::Value(PhaseGVN* phase) const {\n-  const Type *res = ConstraintCastNode::Value(phase);\n-  if (res == Type::TOP) {\n-    return Type::TOP;\n-  }\n-  assert(res->isa_int(), \"res must be int\");\n-\n-  \/\/ Similar to ConvI2LNode::Value() for the same reasons\n-  \/\/ see if we can remove type assertion after loop opts\n-  res = widen_type(phase, res, T_INT);\n+CastIINode* CastIINode::make_with(Node* parent, const TypeInteger* type, const DependencyType& dependency) const {\n+  return new CastIINode(in(0), parent, type, dependency, _range_check_dependency, _extra_types);\n+}\n@@ -225,1 +226,2 @@\n-  return res;\n+CastLLNode* CastLLNode::make_with(Node* parent, const TypeInteger* type, const DependencyType& dependency) const {\n+  return new CastLLNode(in(0), parent, type, dependency, _extra_types);\n@@ -228,4 +230,2 @@\n-Node* ConstraintCastNode::find_or_make_integer_cast(PhaseIterGVN* igvn, Node* parent, const TypeInteger* type) const {\n-  Node* n = clone();\n-  n->set_req(1, parent);\n-  n->as_ConstraintCast()->set_type(type);\n+Node* ConstraintCastNode::find_or_make_integer_cast(PhaseIterGVN* igvn, Node* parent, const TypeInteger* type, const DependencyType& dependency) const {\n+  Node* n = make_with(parent, type, dependency);\n@@ -245,2 +245,2 @@\n-  if (can_reshape && !phase->C->post_loop_opts_phase()) {\n-    \/\/ makes sure we run ::Value to potentially remove type assertion after loop opts\n+  if (!phase->C->post_loop_opts_phase()) {\n+    \/\/ makes sure we run widen_type() to potentially common type assertions after loop opts\n@@ -252,1 +252,0 @@\n-  phase->C->record_for_post_loop_opts_igvn(this);\n@@ -282,1 +281,1 @@\n-  assert(_dependency == RegularDependency, \"already pinned\");\n+  assert(_dependency.is_floating(), \"already pinned\");\n@@ -284,1 +283,1 @@\n-    return new CastIINode(in(0), in(1), bottom_type(), StrongDependency, has_range_check());\n+    return new CastIINode(in(0), in(1), bottom_type(), _dependency.with_pinned_dependency(), has_range_check());\n@@ -318,10 +317,0 @@\n-const Type* CastLLNode::Value(PhaseGVN* phase) const {\n-  const Type* res = ConstraintCastNode::Value(phase);\n-  if (res == Type::TOP) {\n-    return Type::TOP;\n-  }\n-  assert(res->isa_long(), \"res must be long\");\n-\n-  return widen_type(phase, res, T_LONG);\n-}\n-\n@@ -395,1 +384,1 @@\n-    \/\/ makes sure we run ::Value to potentially remove type assertion after loop opts\n+    \/\/ makes sure we run widen_type() to potentially common type assertions after loop opts\n@@ -546,1 +535,1 @@\n-Node* ConstraintCastNode::make_cast_for_type(Node* c, Node* in, const Type* type, DependencyType dependency,\n+Node* ConstraintCastNode::make_cast_for_type(Node* c, Node* in, const Type* type, const DependencyType& dependency,\n@@ -567,1 +556,1 @@\n-Node* ConstraintCastNode::optimize_integer_cast(PhaseGVN* phase, BasicType bt) {\n+Node* ConstraintCastNode::optimize_integer_cast_of_add(PhaseGVN* phase, BasicType bt) {\n@@ -589,2 +578,36 @@\n-    Node* cx = find_or_make_integer_cast(igvn, x, rx);\n-    Node* cy = find_or_make_integer_cast(igvn, y, ry);\n+    const TypeInteger* tx = phase->type(x)->is_integer(bt);\n+    const TypeInteger* ty = phase->type(y)->is_integer(bt);\n+\n+    \/\/ (Cast (Add x y) tz) is transformed into (Add (Cast x rx) (Cast y ry))\n+    \/\/\n+    \/\/ tz = [tzlo, tzhi]\n+    \/\/ rx = [rxlo, rxhi]\n+    \/\/ ry = [rylo, ryhi]\n+    \/\/ with type of x, tx = [txlo, txhi]\n+    \/\/ with type of y, ty = [tylo, tyhi]\n+    \/\/\n+    \/\/ From Compile::push_thru_add():\n+    \/\/ rxlo = max(tzlo - tyhi, txlo)\n+    \/\/ rxhi = min(tzhi - tylo, txhi)\n+    \/\/ rylo = max(tzlo - txhi, tylo)\n+    \/\/ ryhi = min(tzhi - txlo, tyhi)\n+    \/\/\n+    \/\/ If x is a constant, then txlo = txhi\n+    \/\/ rxlo = txlo, rxhi = txhi\n+    \/\/ The bounds of the type of the Add after transformation then is:\n+    \/\/ rxlo + rylo >= txlo + tzlo - txhi >= tzlo\n+    \/\/ rxhi + ryhi <= txhi + tzhi - txlo <= tzhi\n+    \/\/ The resulting type is not wider than the type of the Cast\n+    \/\/ before transformation\n+    \/\/\n+    \/\/ If neither x nor y are constant then the type of the resulting\n+    \/\/ Add can be wider than the type of the type of the Cast before\n+    \/\/ transformation.\n+    \/\/ For instance, tx = [0, 10], ty = [0, 10], tz = [0, 10]\n+    \/\/ then rx = [0, 10], ry = [0, 10]\n+    \/\/ and rx + ry = [0, 20] which is wider than tz\n+    \/\/\n+    \/\/ Same reasoning applies to (Cast (Sub x y) tz)\n+    const DependencyType& dependency = (!tx->is_con() && !ty->is_con()) ? _dependency.with_non_narrowing() : _dependency;\n+    Node* cx = find_or_make_integer_cast(igvn, x, rx, dependency);\n+    Node* cy = find_or_make_integer_cast(igvn, y, ry, dependency);\n@@ -602,2 +625,3 @@\n-const Type* ConstraintCastNode::widen_type(const PhaseGVN* phase, const Type* res, BasicType bt) const {\n-  if (!phase->C->post_loop_opts_phase()) {\n+Node* ConstraintCastNode::optimize_integer_cast(PhaseGVN* phase, BasicType bt) {\n+  Node* res = optimize_integer_cast_of_add(phase, bt);\n+  if (res != nullptr) {\n@@ -606,0 +630,12 @@\n+  const Type* t = Value(phase);\n+  if (t != Type::TOP && phase->C->post_loop_opts_phase()) {\n+    const Type* bottom_t = bottom_type();\n+    const TypeInteger* wide_t = widen_type(phase, bottom_t, bt);\n+    if (wide_t != bottom_t) {\n+      \/\/ Widening the type of the Cast (to allow some commoning) causes the Cast to change how it can be optimized (if\n+      \/\/ type of its input is narrower than the Cast's type, we can't remove it to not loose the control dependency).\n+      return make_with(in(1), wide_t, _dependency.with_non_narrowing());\n+    }\n+  }\n+  return nullptr;\n+}\n@@ -607,0 +643,2 @@\n+const TypeInteger* ConstraintCastNode::widen_type(const PhaseGVN* phase, const Type* res, BasicType bt) const {\n+  const TypeInteger* this_type = res->is_integer(bt);\n@@ -615,1 +653,1 @@\n-    return res;\n+    return this_type;\n@@ -618,1 +656,0 @@\n-  const TypeInteger* this_type = res->is_integer(bt);\n@@ -639,1 +676,1 @@\n-  return res;\n+  return this_type;\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":88,"deletions":51,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -36,4 +36,95 @@\n-  enum DependencyType {\n-    RegularDependency, \/\/ if cast doesn't improve input type, cast can be removed\n-    StrongDependency,  \/\/ leave cast in even if _type doesn't improve input type, can be replaced by stricter dominating cast if one exist\n-    UnconditionalDependency \/\/ leave cast in unconditionally\n+  \/\/ Cast nodes are subject to a few optimizations:\n+  \/\/\n+  \/\/ 1- if the type carried by the Cast doesn't narrow the type of its input, the cast can be replaced by its input.\n+  \/\/ Similarly, if a dominating Cast with the same input and a narrower type constraint is found, it can replace the\n+  \/\/ current cast.\n+  \/\/\n+  \/\/ 2- if the condition that the Cast is control dependent is hoisted, the Cast is hoisted as well\n+  \/\/\n+  \/\/ 1- and 2- are not always applied depending on what constraint are applied to the Cast: there are cases where 1-\n+  \/\/ and 2- apply, where neither 1- nor 2- apply and where one or the other apply. This class abstract away these\n+  \/\/ details.\n+  \/\/\n+  \/\/ If _narrows_type is true, the cast carries a type dependency: \"after\" the control the cast is dependent on, its data\n+  \/\/ input is known to have a narrower type (stored in the cast node itself). Optimizations 1- above only apply to cast\n+  \/\/ nodes for which _narrows_type is true.\n+  \/\/ if _floating is true, the cast only depends on a single control: its control input. Otherwise, it is pinned at its\n+  \/\/ current location. Optimizations 2- only apply to cast nodes for which _floating is true.\n+  \/\/ The 4 combinations of _narrows_types\/_floating true\/false have some use. See below, at the end of this class\n+  \/\/ definition, for examples.\n+  class DependencyType {\n+  private:\n+    const bool _floating; \/\/ Does this Cast depends on its control input or is it pinned?\n+    const bool _narrows_type; \/\/ Does this Cast narrows the type i.e. if input type is narrower can it be removed?\n+    const char* _desc;\n+    DependencyType(bool depends_on_test, bool narrows_type, const char* desc)\n+      : _floating(depends_on_test),\n+        _narrows_type(narrows_type),\n+        _desc(desc) {\n+    }\n+    NONCOPYABLE(DependencyType);\n+\n+  public:\n+\n+    bool is_floating() const {\n+      return _floating;\n+    }\n+\n+    bool narrows_type() const {\n+      return _narrows_type;\n+    }\n+\n+    void dump_on(outputStream *st) const {\n+      st->print(\"%s\", _desc);\n+    }\n+\n+    uint hash() const {\n+      return (_floating ? 1 : 0) + (_narrows_type ? 2 : 0);\n+    }\n+\n+    bool cmp(const DependencyType& other) const {\n+      return _floating == other._floating && _narrows_type == other._narrows_type;\n+    }\n+\n+    const DependencyType& with_non_narrowing() const {\n+      if (_floating) {\n+        return FloatingNonNarrowing;\n+      }\n+      return NonFloatingNonNarrowing;\n+    }\n+\n+    const DependencyType& with_pinned_dependency() const {\n+      if (_narrows_type) {\n+        return NonFloatingNarrowing;\n+      }\n+      return NonFloatingNonNarrowing;\n+    }\n+\n+    \/\/ All the possible combinations of floating\/narrowing with example use cases:\n+\n+    \/\/ Use case example: Range Check CastII\n+    \/\/ Floating: The Cast is only dependent on the single range check.\n+    \/\/ Narrowing: The Cast narrows the type to a positive index. If the input to the Cast is narrower, we can safely\n+    \/\/            remove the cast because the array access will be safe.\n+    static const DependencyType FloatingNarrowing;\n+    \/\/ Use case example: Widening Cast nodes' types after loop opts: We want to common Casts with slightly different types.\n+    \/\/ Floating: These Casts only depend on the single control.\n+    \/\/ NonNarrowing: Even when the input type is narrower, we are not removing the Cast. Otherwise, the dependency\n+    \/\/               to the single control is lost, and an array access could float above its range check because we\n+    \/\/               just removed the dependency to the range check by removing the Cast. This could lead to an\n+    \/\/               out-of-bounds access.\n+    static const DependencyType FloatingNonNarrowing;\n+    \/\/ Use case example: An array accesses that is no longer dependent on a single range check (e.g. range check smearing).\n+    \/\/ NonFloating: The array access must be pinned below all the checks it depends on. If the check it directly depends\n+    \/\/              on with a control input is hoisted, we do not hoist the Cast as well. If we allowed the Cast to float,\n+    \/\/              we risk that the array access ends up above another check it depends on (we cannot model two control\n+    \/\/              dependencies for a node in the IR). This could lead to an out-of-bounds access.\n+    \/\/ Narrowing: If the Cast does not narrow the input type, then it's safe to remove the cast because the array access\n+    \/\/            will be safe.\n+    static const DependencyType NonFloatingNarrowing;\n+    \/\/ Use case example: Sinking nodes out of a loop\n+    \/\/ Non-Floating & Non-Narrowing: We don't want the Cast that forces the node to be out of loop to be removed in any\n+    \/\/                               case. Otherwise, the sunk node could float back into the loop, undoing the sinking.\n+    \/\/                               This Cast is only used for pinning without caring about narrowing types.\n+    static const DependencyType NonFloatingNonNarrowing;\n+\n@@ -42,2 +133,2 @@\n-  protected:\n-  const DependencyType _dependency;\n+protected:\n+  const DependencyType& _dependency;\n@@ -47,2 +138,8 @@\n-  const Type* widen_type(const PhaseGVN* phase, const Type* res, BasicType bt) const;\n-  Node* find_or_make_integer_cast(PhaseIterGVN* igvn, Node* parent, const TypeInteger* type) const;\n+  const TypeInteger* widen_type(const PhaseGVN* phase, const Type* res, BasicType bt) const;\n+\n+  virtual ConstraintCastNode* make_with(Node* parent, const TypeInteger* type, const DependencyType& dependency) const {\n+    ShouldNotReachHere(); \/\/ Only implemented for CastII and CastLL\n+    return nullptr;\n+  }\n+\n+  Node* find_or_make_integer_cast(PhaseIterGVN* igvn, Node* parent, const TypeInteger* type, const DependencyType& dependency) const;\n@@ -50,1 +147,0 @@\n-  private:\n@@ -58,1 +154,1 @@\n-  ConstraintCastNode(Node* ctrl, Node* n, const Type* t, ConstraintCastNode::DependencyType dependency,\n+  ConstraintCastNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency,\n@@ -70,2 +166,4 @@\n-  virtual bool depends_only_on_test() const { return _dependency == RegularDependency; }\n-  bool carry_dependency() const { return _dependency != RegularDependency; }\n+  bool carry_dependency() const { return !_dependency.cmp(DependencyType::FloatingNarrowing); }\n+  \/\/ A cast node depends_only_on_test if and only if it is floating\n+  virtual bool depends_only_on_test() const { return _dependency.is_floating(); }\n+  const DependencyType& dependency() const { return _dependency; }\n@@ -73,1 +171,1 @@\n-  static Node* make_cast_for_basic_type(Node* c, Node* n, const Type* t, DependencyType dependency, BasicType bt);\n+  static Node* make_cast_for_basic_type(Node* c, Node* n, const Type* t, const DependencyType& dependency, BasicType bt);\n@@ -79,1 +177,1 @@\n-  static Node* make_cast_for_type(Node* c, Node* in, const Type* type, DependencyType dependency,\n+  static Node* make_cast_for_type(Node* c, Node* in, const Type* type, const DependencyType& dependency,\n@@ -82,0 +180,1 @@\n+  Node* optimize_integer_cast_of_add(PhaseGVN* phase, BasicType bt);\n@@ -105,1 +204,1 @@\n-  CastIINode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, bool range_check_dependency = false, const TypeTuple* types = nullptr)\n+  CastIINode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = DependencyType::FloatingNarrowing, bool range_check_dependency = false, const TypeTuple* types = nullptr)\n@@ -113,1 +212,1 @@\n-  virtual const Type* Value(PhaseGVN* phase) const;\n+\n@@ -125,0 +224,1 @@\n+  CastIINode* make_with(Node* parent, const TypeInteger* type, const DependencyType& dependency) const;\n@@ -134,1 +234,1 @@\n-  CastLLNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CastLLNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = DependencyType::FloatingNarrowing, const TypeTuple* types = nullptr)\n@@ -140,2 +240,0 @@\n-  virtual const Type* Value(PhaseGVN* phase) const;\n-\n@@ -150,0 +248,1 @@\n+  CastLLNode* make_with(Node* parent, const TypeInteger* type, const DependencyType& dependency) const;\n@@ -154,1 +253,1 @@\n-  CastHHNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CastHHNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = DependencyType::FloatingNarrowing, const TypeTuple* types = nullptr)\n@@ -165,1 +264,1 @@\n-  CastFFNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CastFFNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = DependencyType::FloatingNarrowing, const TypeTuple* types = nullptr)\n@@ -176,1 +275,1 @@\n-  CastDDNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CastDDNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = DependencyType::FloatingNarrowing, const TypeTuple* types = nullptr)\n@@ -187,1 +286,1 @@\n-  CastVVNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CastVVNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = DependencyType::FloatingNarrowing, const TypeTuple* types = nullptr)\n@@ -201,1 +300,1 @@\n-  CastPPNode (Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CastPPNode (Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = DependencyType::FloatingNarrowing, const TypeTuple* types = nullptr)\n@@ -213,1 +312,1 @@\n-  CheckCastPPNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CheckCastPPNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = DependencyType::FloatingNarrowing, const TypeTuple* types = nullptr)\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":124,"deletions":25,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -2194,1 +2194,1 @@\n-          cast = new CastPPNode(r, uin, phi_type, ConstraintCastNode::StrongDependency, extra_types);\n+          cast = new CastPPNode(r, uin, phi_type, ConstraintCastNode::DependencyType::NonFloatingNarrowing, extra_types);\n@@ -2204,1 +2204,1 @@\n-            cast = new CastPPNode(r, uin, TypePtr::NOTNULL, ConstraintCastNode::StrongDependency, extra_types);\n+            cast = new CastPPNode(r, uin, TypePtr::NOTNULL, ConstraintCastNode::DependencyType::NonFloatingNarrowing, extra_types);\n@@ -2216,1 +2216,1 @@\n-            cast = new CheckCastPPNode(r, n, phi_type, ConstraintCastNode::StrongDependency, extra_types);\n+            cast = new CheckCastPPNode(r, n, phi_type, ConstraintCastNode::DependencyType::NonFloatingNarrowing, extra_types);\n@@ -2219,1 +2219,1 @@\n-            cast = new CastPPNode(r, uin, phi_type, ConstraintCastNode::StrongDependency, extra_types);\n+            cast = new CastPPNode(r, uin, phi_type, ConstraintCastNode::DependencyType::NonFloatingNarrowing, extra_types);\n@@ -2223,1 +2223,1 @@\n-        cast = ConstraintCastNode::make_cast_for_type(r, uin, phi_type, ConstraintCastNode::StrongDependency, extra_types);\n+        cast = ConstraintCastNode::make_cast_for_type(r, uin, phi_type, ConstraintCastNode::DependencyType::NonFloatingNarrowing, extra_types);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -4581,1 +4581,1 @@\n-    value = new CastIINode(ctrl, value, itype, carry_dependency ? ConstraintCastNode::StrongDependency : ConstraintCastNode::RegularDependency, true \/* range check dependency *\/);\n+    value = new CastIINode(ctrl, value, itype, carry_dependency ? ConstraintCastNode::DependencyType::NonFloatingNarrowing : ConstraintCastNode::DependencyType::FloatingNarrowing, true \/* range check dependency *\/);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -751,1 +751,1 @@\n-  return _igvn->transform(ConstraintCastNode::make_cast_for_type(not_eq_control, base, _igvn->type(castpp), ConstraintCastNode::UnconditionalDependency, nullptr));\n+  return _igvn->transform(ConstraintCastNode::make_cast_for_type(not_eq_control, base, _igvn->type(castpp), ConstraintCastNode::DependencyType::NonFloatingNonNarrowing, nullptr));\n@@ -1238,1 +1238,1 @@\n-    nsr_merge_pointer = _igvn->transform(ConstraintCastNode::make_cast_for_type(cast->in(0), cast->in(1), new_t, ConstraintCastNode::RegularDependency, nullptr));\n+    nsr_merge_pointer = _igvn->transform(ConstraintCastNode::make_cast_for_type(cast->in(0), cast->in(1), new_t, ConstraintCastNode::DependencyType::FloatingNarrowing, nullptr));\n@@ -1379,1 +1379,1 @@\n-        Node* new_cast = ConstraintCastNode::make_cast_for_type(out->in(0), out->in(1), out_new_t, ConstraintCastNode::StrongDependency, nullptr);\n+        Node* new_cast = ConstraintCastNode::make_cast_for_type(out->in(0), out->in(1), out_new_t, ConstraintCastNode::DependencyType::NonFloatingNarrowing, nullptr);\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1185,1 +1185,1 @@\n-      ConstraintCastNode::RegularDependency, bt);\n+      ConstraintCastNode::DependencyType::FloatingNarrowing, bt);\n@@ -1215,1 +1215,1 @@\n-      ConstraintCastNode::RegularDependency, bt);\n+      ConstraintCastNode::DependencyType::FloatingNarrowing, bt);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1369,1 +1369,1 @@\n-  Node* castii = new CastIINode(ctrl, incr, TypeInt::INT, ConstraintCastNode::UnconditionalDependency);\n+  Node* castii = new CastIINode(ctrl, incr, TypeInt::INT, ConstraintCastNode::DependencyType::NonFloatingNonNarrowing);\n@@ -3265,1 +3265,1 @@\n-      ConstraintCastNode::UnconditionalDependency, T_INT);\n+      ConstraintCastNode::DependencyType::NonFloatingNonNarrowing, T_INT);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1004,1 +1004,1 @@\n-    inner_iters_actual_int = new CastIINode(outer_head, inner_iters_actual_int, inner_iters_actual_int_range, ConstraintCastNode::UnconditionalDependency);\n+    inner_iters_actual_int = new CastIINode(outer_head, inner_iters_actual_int, inner_iters_actual_int_range, ConstraintCastNode::DependencyType::NonFloatingNonNarrowing);\n@@ -1318,1 +1318,1 @@\n-                                                             ConstraintCastNode::UnconditionalDependency, bt);\n+                                                             ConstraintCastNode::DependencyType::NonFloatingNonNarrowing, bt);\n@@ -1337,1 +1337,1 @@\n-                                                             ConstraintCastNode::UnconditionalDependency, bt);\n+                                                             ConstraintCastNode::DependencyType::NonFloatingNonNarrowing, bt);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1177,1 +1177,1 @@\n-  if (n->is_ConstraintCast()) {\n+  if (n->is_ConstraintCast() && n->as_ConstraintCast()->dependency().narrows_type()) {\n@@ -1840,1 +1840,1 @@\n-                                                              ConstraintCastNode::UnconditionalDependency, nullptr);\n+                                                              ConstraintCastNode::DependencyType::NonFloatingNonNarrowing, nullptr);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -236,1 +236,1 @@\n-  Node* casted_length = new CastLLNode(inline_block, length, inline_range, ConstraintCastNode::RegularDependency);\n+  Node* casted_length = new CastLLNode(inline_block, length, inline_range, ConstraintCastNode::DependencyType::FloatingNarrowing);\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,2 +47,2 @@\n-    final static int length = RANDOM.nextInt(Integer.MAX_VALUE);\n-    final static long llength = RANDOM.nextInt(Integer.MAX_VALUE);\n+    final static int length = RANDOM.nextInt(5, Integer.MAX_VALUE);\n+    final static long llength = RANDOM.nextInt(2, Integer.MAX_VALUE);\n@@ -53,1 +53,1 @@\n-    @IR(counts = { IRNode.CAST_II, \"1\" })\n+    @IR(counts = { IRNode.CAST_II, \"2\" })\n@@ -70,1 +70,1 @@\n-    @IR(counts = { IRNode.CAST_LL, \"1\" })\n+    @IR(counts = { IRNode.CAST_LL, \"2\" })\n@@ -85,0 +85,21 @@\n+\n+    \/\/ Test commoning of Casts after loop opts when they are at the same control\n+    @Test\n+    @IR(phase = CompilePhase.ITER_GVN1, counts = { IRNode.CAST_II, \"4\" })\n+    @IR(phase = CompilePhase.OPTIMIZE_FINISHED, counts = { IRNode.CAST_II, \"2\" })\n+    public static int test3() {\n+        int j = Objects.checkIndex(i - 3, length);\n+        j += Objects.checkIndex(i, length);\n+        j += Objects.checkIndex(i - 2, length);\n+        j += Objects.checkIndex(i - 1, length);\n+        return j;\n+    }\n+\n+    @Run(test = \"test3\")\n+    public static void test3_runner() {\n+        i = RANDOM.nextInt(3, length - 1);\n+        int res = test3();\n+        if (res != i * 4 - 6) {\n+            throw new RuntimeException(\"incorrect result: \" + res + \" for i = \" + i);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestPushAddThruCast.java","additions":25,"deletions":4,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-        int[] array = new int[100];\n@@ -75,0 +74,7 @@\n+            test14(8, 0, 1, true);\n+            test14(8, 0, 1, false);\n+            inlined14(0, 0);\n+            test15(8, 0, 1, true);\n+            test15(8, 0, 1, false);\n+            inlined15(0, 0);\n+\n@@ -128,0 +134,8 @@\n+        try {\n+            test14(Integer.MAX_VALUE, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test15(Integer.MAX_VALUE, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n@@ -471,0 +485,66 @@\n+    \/\/ Range check cast type widen after loop opts causes control dependency to be lost\n+    private static void test14(int i, int j, int flag, boolean flag2) {\n+        int l = 0;\n+        for (; l < 10; l++);\n+        j = inlined14(j, l);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[10];\n+            newArray[i+j] = 42; \/\/ i+j in [0, 9]\n+            float[] otherArray = new float[i+j]; \/\/ i+j in [0, max]\n+            if (flag == 0) {\n+            }\n+            intField = array[otherArray.length];\n+        } else {\n+            float[] newArray = new float[10];\n+            newArray[i+j] = 42; \/\/ i+j in [0, 9]\n+            float[] otherArray = new float[i+j]; \/\/ i+j in [0, max]\n+            if (flag == 0) {\n+            }\n+            intField = array[otherArray.length];\n+        }\n+    }\n+\n+    private static int inlined14(int j, int l) {\n+        if (l == 10) {\n+            j = 1;\n+        }\n+        return j;\n+    }\n+\n+    private static void test15(int i, int j, int flag, boolean flag2) {\n+        i = Integer.max(i, Integer.MIN_VALUE + 1);\n+        int l = 0;\n+        for (; l < 10; l++);\n+        j = inlined15(j, l);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[10];\n+            newArray[i+j] = 42; \/\/ i+j in [0, 9]\n+            float[] otherArray = new float[i+j]; \/\/ i+j in [0, max]\n+            if (flag == 0) {\n+            }\n+            intField = array[otherArray.length];\n+        } else {\n+            float[] newArray = new float[10];\n+            newArray[i+j] = 42; \/\/ i+j in [0, 9]\n+            float[] otherArray = new float[i+j]; \/\/ i+j in [0, max]\n+            if (flag == 0) {\n+            }\n+            intField = array[otherArray.length];\n+        }\n+    }\n+\n+    private static int inlined15(int j, int l) {\n+        if (l == 10) {\n+            j = Integer.max(j, Integer.MIN_VALUE + 10);\n+        }\n+        return j;\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestArrayAccessAboveRCAfterRCCastIIEliminated.java","additions":81,"deletions":1,"binary":false,"changes":82,"status":"modified"}]}