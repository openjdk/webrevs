{"files":[{"patch":"@@ -816,1 +816,1 @@\n-    vn = new VectorReinterpretNode(in1, vt, in1->bottom_type()->is_vect());\n+    vn = new VectorReinterpretNode(in1, in1->bottom_type()->is_vect(), vt);\n","filename":"src\/hotspot\/share\/opto\/vtransform.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,225 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8366845\n+ * @summary Test Reinterpret with Cast cases, where the order of the src\/dst types of Reinterpret matters.\n+ * @modules jdk.incubator.vector\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestReinterpretAndCast\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import jdk.incubator.vector.Float16;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.generators.*;\n+\n+public class TestReinterpretAndCast {\n+    static int SIZE = 1028 * 8;\n+\n+    public static final Generator<Float> GEN_FLOAT = Generators.G.floats();\n+    public static final Generator<Double> GEN_DOUBLE = Generators.G.doubles();\n+    private static final Generator<Short> GEN_FLOAT16 = Generators.G.float16s();\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\");\n+    }\n+\n+    static long[] fillWithDoubles(long[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = Double.doubleToLongBits(GEN_DOUBLE.next());\n+        }\n+        return a;\n+    }\n+\n+    static int[] fillWithFloats(int[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = Float.floatToIntBits(GEN_FLOAT.next());\n+        }\n+        return a;\n+    }\n+\n+    static short[] fillWithFloat16s(short[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = GEN_FLOAT16.next();\n+        }\n+        return a;\n+    }\n+\n+    static void verify(long[] a, long[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+            \/\/ Make sure we remove non-canonical NaN's.\n+            long aa = Double.doubleToLongBits(Double.longBitsToDouble(a[i]));\n+            long bb = Double.doubleToLongBits(Double.longBitsToDouble(b[i]));\n+            if (aa != bb) {\n+                throw new RuntimeException(\"Wrong value: \" + aa + \" vs \" + bb + \" - \" + a[i] + \" vs \" + b[i]);\n+            }\n+        }\n+    }\n+\n+    static void verify(int[] a, int[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+            \/\/ Make sure we remove non-canonical NaN's.\n+            int aa = Float.floatToIntBits(Float.intBitsToFloat(a[i]));\n+            int bb = Float.floatToIntBits(Float.intBitsToFloat(b[i]));\n+            if (aa != bb) {\n+                throw new RuntimeException(\"Wrong value: \" + aa + \" vs \" + bb + \" - \" + a[i] + \" vs \" + b[i]);\n+            }\n+        }\n+    }\n+\n+    static void verify(short[] a, short[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+            \/\/ Make sure we remove non-canonical NaN's.\n+            int aa = Float.floatToIntBits(Float16.shortBitsToFloat16(a[i]).floatValue());\n+            int bb = Float.floatToIntBits(Float16.shortBitsToFloat16(b[i]).floatValue());\n+            if (aa != bb) {\n+                throw new RuntimeException(\"Wrong value: \" + aa + \" vs \" + bb + \" - \" + a[i] + \" vs \" + b[i]);\n+            }\n+        }\n+    }\n+\n+    \/\/ -------------- test1\n+    public static long[] test1_in   = fillWithDoubles(new long[SIZE]);\n+    public static int[]  test1_gold = new int[SIZE];\n+    public static int[]  test1_test = new int[SIZE];\n+\n+    \/\/ Esecute in interpreter, to compare to compiled results later.\n+    static { test1(test1_in, test1_gold); }\n+\n+    @Setup\n+    public static Object[] setup1() {\n+        return new Object[] {test1_in, test1_test};\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup1\")\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,   IRNode.VECTOR_SIZE + \"min(max_int, max_float, max_double, max_long)\", \"> 0\",\n+                  IRNode.VECTOR_CAST_D2F, IRNode.VECTOR_SIZE + \"min(max_int, max_float, max_double, max_long)\", \"> 0\",\n+                  IRNode.STORE_VECTOR,       \"> 0\",\n+                  IRNode.VECTOR_REINTERPRET, \"> 0\"}, \/\/ We have both L2D and F2I\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    public static void test1(long[] a, int[] b) {\n+        for (int i = 0; i < SIZE; i++) {\n+            long   v0 = a[i];\n+            double v1 = Double.longBitsToDouble(v0);\n+            \/\/ Reinterpret: long -> double\n+            \/\/ Before fix:  double -> long (no direct problem)\n+            float  v2 = (float)v1;\n+            \/\/ Cast:        double -> float\n+            \/\/ Before fix:  long -> float  (wrong!)\n+            int    v3 = Float.floatToRawIntBits(v2);\n+            b[i] = v3;\n+        }\n+    }\n+\n+    @Check(test = \"test1\")\n+    public static void check1() {\n+        verify(test1_test, test1_gold);\n+    }\n+\n+    \/\/ -------------- test2\n+    public static int[]   test2_in   = fillWithFloats(new int[SIZE]);\n+    public static short[] test2_gold = new short[SIZE];\n+    public static short[] test2_test = new short[SIZE];\n+\n+    \/\/ Esecute in interpreter, to compare to compiled results later.\n+    static { test2(test2_in, test2_gold); }\n+\n+    @Setup\n+    public static Object[] setup2() {\n+        return new Object[] {test2_in, test2_test};\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup2\")\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,    IRNode.VECTOR_SIZE + \"min(max_int, max_float, max_short)\", \"> 0\",\n+                  IRNode.VECTOR_CAST_F2HF, IRNode.VECTOR_SIZE + \"min(max_int, max_float, max_short)\", \"> 0\",\n+                  IRNode.STORE_VECTOR,       \"> 0\",\n+                  IRNode.VECTOR_REINTERPRET, \"> 0\"}, \/\/ We have at least I2F\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    public static void test2(int[] a, short[] b) {\n+        for (int i = 0; i < SIZE; i++) {\n+            int v0 = a[i];\n+            float v1 = Float.intBitsToFloat(v0);\n+            \/\/ Reinterpret: int -> float\n+            \/\/ Before fix:  float -> int (no direct problem)\n+            short v2 = Float.floatToFloat16(v1);\n+            \/\/ Cast:        float -> float16\/short\n+            \/\/ Before fix:  int ->   float16\/short (wrong!)\n+            b[i] = v2;\n+        }\n+    }\n+\n+    @Check(test = \"test2\")\n+    public static void check2() {\n+        verify(test2_test, test2_gold);\n+    }\n+\n+    \/\/ -------------- test3\n+    public static short[] test3_in   = fillWithFloat16s(new short[SIZE]);\n+    public static long[]  test3_gold = new long[SIZE];\n+    public static long[]  test3_test = new long[SIZE];\n+\n+    \/\/ Esecute in interpreter, to compare to compiled results later.\n+    static { test3(test3_in, test3_gold); }\n+\n+    @Setup\n+    public static Object[] setup3() {\n+        return new Object[] {test3_in, test3_test};\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup3\")\n+    @IR(counts = {IRNode.LOAD_VECTOR_S,    IRNode.VECTOR_SIZE + \"min(max_float, max_short, max_long)\", \"> 0\",\n+                  IRNode.VECTOR_CAST_HF2F, IRNode.VECTOR_SIZE + \"min(max_float, max_short, max_long)\", \"> 0\",\n+                  IRNode.VECTOR_CAST_I2L,  IRNode.VECTOR_SIZE + \"min(max_float, max_short, max_long)\", \"> 0\",\n+                  IRNode.STORE_VECTOR,       \"> 0\",\n+                  IRNode.VECTOR_REINTERPRET, \"> 0\"}, \/\/ We have at least F2I\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    public static void test3(short[] a, long[] b) {\n+        for (int i = 0; i < SIZE; i++) {\n+            short v0 = a[i];\n+            Float16 v1 = Float16.shortBitsToFloat16(v0);\n+            float v2 = v1.floatValue();\n+            int v3 = Float.floatToRawIntBits(v2);\n+            \/\/ Reinterpret: float -> int\n+            \/\/ Before fix:  int -> float\n+            long v4 = v3;\n+            \/\/ Cast:        int -> long\n+            \/\/ Before fix:  float -> long (wrong!)\n+            b[i] = v4;\n+        }\n+    }\n+\n+    @Check(test = \"test3\")\n+    public static void check3() {\n+        verify(test3_test, test3_gold);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestReinterpretAndCast.java","additions":225,"deletions":0,"binary":false,"changes":225,"status":"added"}]}