{"files":[{"patch":"@@ -1467,1 +1467,2 @@\n-  InitializedAssertionPredicate initialized_assertion_predicate(template_assertion_predicate, new_init, new_stride, this);\n+  InitializedAssertionPredicateCreator initialized_assertion_predicate(template_assertion_predicate, new_init,\n+                                                                       new_stride, this);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4322,0 +4322,10 @@\n+\/\/ This visitor marks all visited Parse Predicates useful.\n+class ParsePredicateUsefulMarker : public PredicateVisitor {\n+ public:\n+  using PredicateVisitor::visit;\n+\n+  void visit(const ParsePredicate& parse_predicate) override {\n+    parse_predicate.head()->mark_useful();\n+  }\n+};\n+\n@@ -4324,5 +4334,3 @@\n-  const Predicates predicates(entry);\n-  ParsePredicateIterator iterator(predicates);\n-  while (iterator.has_next()) {\n-    iterator.next()->mark_useful();\n-  }\n+  const PredicateIterator predicate_iterator(entry);\n+  ParsePredicateUsefulMarker useful_marker;\n+  predicate_iterator.for_each(useful_marker);\n@@ -6270,0 +6278,37 @@\n+\/\/ Class to visit all predicates in a predicate chain to find out which are dominated by a given node. Keeps track of\n+\/\/ the entry to the earliest predicate that is still dominated by the given dominator. This class is used when trying to\n+\/\/ legally skip all predicates when figuring out the latest placement such that a node does not interfere with Loop\n+\/\/ Predication or creating a Loop Limit Check Predicate later.\n+class DominatedPredicates : public UnifiedPredicateVisitor {\n+  Node* const _dominator;\n+  Node* _earliest_dominated_predicate_entry;\n+  bool _should_continue;\n+  PhaseIdealLoop* const _phase;\n+\n+ public:\n+  DominatedPredicates(Node* dominator, Node* start_node, PhaseIdealLoop* phase)\n+      : _dominator(dominator),\n+        _earliest_dominated_predicate_entry(start_node),\n+        _should_continue(true),\n+        _phase(phase) {}\n+  NONCOPYABLE(DominatedPredicates);\n+\n+  bool should_continue() const override {\n+    return _should_continue;\n+  }\n+\n+  \/\/ Returns the entry to the earliest predicate that is still dominated by the given dominator (all could be dominated).\n+  Node* earliest_dominated_predicate_entry() const {\n+    return _earliest_dominated_predicate_entry;\n+  }\n+\n+  void visit_predicate(const Predicate& predicate) override {\n+    Node* entry = predicate.entry();\n+    if (_phase->is_strict_dominator(entry, _dominator)) {\n+      _should_continue = false;\n+    } else {\n+      _earliest_dominated_predicate_entry = entry;\n+    }\n+  }\n+};\n+\n@@ -6381,8 +6426,4 @@\n-    PredicateEntryIterator predicate_iterator(least);\n-    while (predicate_iterator.has_next()) {\n-      Node* next_predicate_entry = predicate_iterator.next_entry();\n-      if (is_strict_dominator(next_predicate_entry, early)) {\n-        break;\n-      }\n-      least = next_predicate_entry;\n-    }\n+    const PredicateIterator predicate_iterator(least);\n+    DominatedPredicates dominated_predicates(early, least, this);\n+    predicate_iterator.for_each(dominated_predicates);\n+    least = dominated_predicates.earliest_dominated_predicate_entry();\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":54,"deletions":13,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -76,8 +76,0 @@\n-bool ParsePredicate::is_predicate(Node* maybe_success_proj) {\n-  if (!maybe_success_proj->is_IfProj()) {\n-    return false;\n-  }\n-  IfNode* if_node = maybe_success_proj->in(0)->as_If();\n-  return if_node->is_ParsePredicate();\n-}\n-\n@@ -93,6 +85,2 @@\n-  if (may_be_predicate_if(maybe_success_proj)) {\n-    IfProjNode* success_proj = maybe_success_proj->as_IfProj();\n-    const Deoptimization::DeoptReason deopt_reason = uncommon_trap_reason(success_proj);\n-    return (deopt_reason == Deoptimization::Reason_loop_limit_check ||\n-            deopt_reason == Deoptimization::Reason_predicate ||\n-            deopt_reason == Deoptimization::Reason_profile_predicate);\n+  if (RegularPredicate::may_be_predicate_if(maybe_success_proj)) {\n+    return has_valid_uncommon_trap(maybe_success_proj);\n@@ -104,2 +92,10 @@\n-bool RegularPredicateWithUCT::is_predicate(Node* node, Deoptimization::DeoptReason deopt_reason) {\n-  if (may_be_predicate_if(node)) {\n+bool RegularPredicateWithUCT::has_valid_uncommon_trap(const Node* success_proj) {\n+  assert(RegularPredicate::may_be_predicate_if(success_proj), \"must have been checked before\");\n+  const Deoptimization::DeoptReason deopt_reason = uncommon_trap_reason(success_proj->as_IfProj());\n+  return (deopt_reason == Deoptimization::Reason_loop_limit_check ||\n+          deopt_reason == Deoptimization::Reason_predicate ||\n+          deopt_reason == Deoptimization::Reason_profile_predicate);\n+}\n+\n+bool RegularPredicateWithUCT::is_predicate(const Node* node, Deoptimization::DeoptReason deopt_reason) {\n+  if (RegularPredicate::may_be_predicate_if(node)) {\n@@ -112,2 +108,2 @@\n-\/\/ A Runtime Predicate must have an If or a RangeCheck node, while the If should not be a zero trip guard check.\n-bool RegularPredicateWithUCT::may_be_predicate_if(Node* node) {\n+\/\/ A Regular Predicate must have an If or a RangeCheck node, while the If should not be a zero trip guard check.\n+bool RegularPredicate::may_be_predicate_if(const Node* node) {\n@@ -125,1 +121,7 @@\n-bool RuntimePredicate::is_success_proj(Node* node, Deoptimization::DeoptReason deopt_reason) {\n+\/\/ Runtime Predicates always have an UCT since they could normally fail at runtime. In this case we execute the trap\n+\/\/ on the failing path.\n+bool RuntimePredicate::is_predicate(Node* node) {\n+  return RegularPredicateWithUCT::is_predicate(node);\n+}\n+\n+bool RuntimePredicate::is_predicate(Node* node, Deoptimization::DeoptReason deopt_reason) {\n@@ -129,10 +131,5 @@\n-ParsePredicateIterator::ParsePredicateIterator(const Predicates& predicates) : _current_index(0) {\n-  const PredicateBlock* loop_limit_check_predicate_block = predicates.loop_limit_check_predicate_block();\n-  if (loop_limit_check_predicate_block->has_parse_predicate()) {\n-    _parse_predicates.push(loop_limit_check_predicate_block->parse_predicate());\n-  }\n-  if (UseProfiledLoopPredicate) {\n-    const PredicateBlock* profiled_loop_predicate_block = predicates.profiled_loop_predicate_block();\n-    if (profiled_loop_predicate_block->has_parse_predicate()) {\n-      _parse_predicates.push(profiled_loop_predicate_block->parse_predicate());\n-    }\n+\/\/ A Template Assertion Predicate has an If\/RangeCheckNode and either an UCT or a halt node depending on where it\n+\/\/ was created.\n+bool TemplateAssertionPredicate::is_predicate(Node* node) {\n+  if (!RegularPredicate::may_be_predicate_if(node)) {\n+    return false;\n@@ -140,5 +137,3 @@\n-  if (UseLoopPredicate) {\n-    const PredicateBlock* loop_predicate_block = predicates.loop_predicate_block();\n-    if (loop_predicate_block->has_parse_predicate()) {\n-      _parse_predicates.push(loop_predicate_block->parse_predicate());\n-    }\n+  IfNode* if_node = node->in(0)->as_If();\n+  if (if_node->in(1)->is_Opaque4()) {\n+    return RegularPredicateWithUCT::has_valid_uncommon_trap(node) || AssertionPredicateWithHalt::has_halt(node);\n@@ -146,0 +141,1 @@\n+  return false;\n@@ -148,3 +144,7 @@\n-ParsePredicateNode* ParsePredicateIterator::next() {\n-  assert(has_next(), \"always check has_next() first\");\n-  return _parse_predicates.at(_current_index++);\n+\/\/ Initialized Assertion Predicates always have the dedicated opaque node and a halt node.\n+bool InitializedAssertionPredicate::is_predicate(Node* node) {\n+  if (!AssertionPredicateWithHalt::is_predicate(node)) {\n+    return false;\n+  }\n+  IfNode* if_node = node->in(0)->as_If();\n+  return if_node->in(1)->is_OpaqueInitializedAssertionPredicate();\n@@ -156,2 +156,2 @@\n-void PredicateBlock::verify_block() {\n-  Node* next = _parse_predicate.entry(); \/\/ Skip unique Parse Predicate of this block if present\n+void RegularPredicateBlock::verify_block(Node* tail) {\n+  Node* next = tail;\n@@ -169,11 +169,0 @@\n-\/\/ Walk over all Regular Predicates of this block (if any) and return the first node not belonging to the block\n-\/\/ anymore (i.e. entry to the first Regular Predicate in this block if any or `regular_predicate_proj` otherwise).\n-Node* PredicateBlock::skip_regular_predicates(Node* regular_predicate_proj, Deoptimization::DeoptReason deopt_reason) {\n-  Node* entry = regular_predicate_proj;\n-  while (RuntimePredicate::is_success_proj(entry, deopt_reason)) {\n-    assert(entry->in(0)->as_If(), \"must be If node\");\n-    entry = entry->in(0)->in(0);\n-  }\n-  return entry;\n-}\n-\n@@ -384,2 +373,2 @@\n-InitializedAssertionPredicate::InitializedAssertionPredicate(IfNode* template_assertion_predicate, Node* new_init,\n-                                                             Node* new_stride, PhaseIdealLoop* phase)\n+InitializedAssertionPredicateCreator::InitializedAssertionPredicateCreator(IfNode* template_assertion_predicate, Node* new_init,\n+                                                                           Node* new_stride, PhaseIdealLoop* phase)\n@@ -411,1 +400,1 @@\n-IfTrueNode* InitializedAssertionPredicate::create(Node* control) {\n+IfTrueNode* InitializedAssertionPredicateCreator::create(Node* control) {\n@@ -420,1 +409,1 @@\n-OpaqueInitializedAssertionPredicateNode* InitializedAssertionPredicate::create_assertion_expression(Node* control) {\n+OpaqueInitializedAssertionPredicateNode* InitializedAssertionPredicateCreator::create_assertion_expression(Node* control) {\n@@ -431,3 +420,3 @@\n-IfNode* InitializedAssertionPredicate::create_if_node(Node* control,\n-                                                      OpaqueInitializedAssertionPredicateNode* assertion_expression,\n-                                                      IdealLoopTree* loop) {\n+IfNode* InitializedAssertionPredicateCreator::create_if_node(Node* control,\n+                                                             OpaqueInitializedAssertionPredicateNode* assertion_expression,\n+                                                             IdealLoopTree* loop) {\n@@ -443,1 +432,1 @@\n-IfTrueNode* InitializedAssertionPredicate::create_success_path(IfNode* if_node, IdealLoopTree* loop) {\n+IfTrueNode* InitializedAssertionPredicateCreator::create_success_path(IfNode* if_node, IdealLoopTree* loop) {\n@@ -449,1 +438,1 @@\n-void InitializedAssertionPredicate::create_fail_path(IfNode* if_node, IdealLoopTree* loop) {\n+void InitializedAssertionPredicateCreator::create_fail_path(IfNode* if_node, IdealLoopTree* loop) {\n@@ -455,1 +444,1 @@\n-void InitializedAssertionPredicate::create_halt_node(IfFalseNode* fail_proj, IdealLoopTree* loop) {\n+void InitializedAssertionPredicateCreator::create_halt_node(IfFalseNode* fail_proj, IdealLoopTree* loop) {\n@@ -464,5 +453,35 @@\n-\/\/ Is current node pointed to by iterator a predicate?\n-bool PredicateEntryIterator::has_next() const {\n-    return ParsePredicate::is_predicate(_current) ||\n-           RegularPredicateWithUCT::is_predicate(_current) ||\n-           AssertionPredicateWithHalt::is_predicate(_current);\n+#ifndef PRODUCT\n+void PredicateBlock::dump() const {\n+  dump(\"\");\n+}\n+\n+void PredicateBlock::dump(const char* prefix) const {\n+  if (is_non_empty()) {\n+    PredicatePrinter printer(prefix);\n+    PredicateBlockIterator iterator(_tail, _deopt_reason);\n+    iterator.for_each(printer);\n+  } else {\n+    tty->print_cr(\"%s- <empty>\", prefix);\n+  }\n+}\n+\n+\/\/ Dumps all predicates from the loop to the earliest predicate in a pretty format.\n+void Predicates::dump() const {\n+  if (has_any()) {\n+    Node* loop_head = _tail->unique_ctrl_out();\n+    tty->print_cr(\"%d %s:\", loop_head->_idx, loop_head->Name());\n+    tty->print_cr(\"- Loop Limit Check Predicate Block:\");\n+    _loop_limit_check_predicate_block.dump(\"  \");\n+    tty->print_cr(\"- Profiled Loop Predicate Block:\");\n+    _profiled_loop_predicate_block.dump(\"  \");\n+    tty->print_cr(\"- Loop Predicate Block:\");\n+    _loop_predicate_block.dump(\"  \");\n+    tty->cr();\n+  } else {\n+    tty->print_cr(\"<no predicates>\");\n+  }\n+}\n+\n+void Predicates::dump_at(Node* node) {\n+  Predicates predicates(node);\n+  predicates.dump();\n@@ -471,6 +490,3 @@\n-\/\/ Skip the current predicate pointed to by iterator by returning the input into the predicate. This could possibly be\n-\/\/ a non-predicate node.\n-Node* PredicateEntryIterator::next_entry() {\n-  assert(has_next(), \"current must be predicate\");\n-  _current = _current->in(0)->in(0);\n-  return _current;\n+\/\/ Debug method to dump all predicates that are found above 'loop_node'.\n+void Predicates::dump_for_loop(LoopNode* loop_node) {\n+  dump_at(loop_node->skip_strip_mined()->in(LoopNode::EntryControl));\n@@ -478,0 +494,1 @@\n+#endif \/\/ NOT PRODUCT\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":88,"deletions":71,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -33,0 +33,5 @@\n+class InitializedAssertionPredicate;\n+class ParsePredicate;\n+class PredicateVisitor;\n+class RuntimePredicate;\n+class TemplateAssertionPredicate;\n@@ -155,1 +160,2 @@\n- *\n+ * - Regular Predicate Block: A block that only contains the Regular Predicates of a Predicate Block without the\n+ *                            Parse Predicate.\n@@ -208,0 +214,35 @@\n+\/\/ Interface to represent a C2 predicate. A predicate is always represented by two CFG nodes:\n+\/\/ - An If node (head)\n+\/\/ - An IfProj node representing the success projection of the If node (tail).\n+class Predicate : public StackObj {\n+ public:\n+  \/\/ Return the unique entry CFG node into the predicate.\n+  virtual Node* entry() const = 0;\n+\n+  \/\/ Return the head node of the predicate which is either:\n+  \/\/ - A ParsePredicateNode if the predicate is a Parse Predicate\n+  \/\/ - An IfNode or RangeCheckNode, otherwise.\n+  virtual IfNode* head() const = 0;\n+\n+  \/\/ Return the tail node of the predicate. Runtime Predicates can either have a true of false projection as success\n+  \/\/ projection while Parse Predicates and Assertion Predicates always have a true projection as success projection.\n+  virtual IfProjNode* tail() const = 0;\n+};\n+\n+\/\/ Generic predicate visitor that does nothing. Subclass this visitor to add customized actions for each predicate.\n+\/\/ The visit methods of this visitor are called from the predicate iterator classes which walk the predicate chain.\n+\/\/ Use the UnifiedPredicateVisitor if the type of the predicate does not matter.\n+class PredicateVisitor : StackObj {\n+ public:\n+  virtual void visit(const ParsePredicate& parse_predicate) {}\n+  virtual void visit(const RuntimePredicate& runtime_predicate) {}\n+  virtual void visit(const TemplateAssertionPredicate& template_assertion_predicate) {}\n+  virtual void visit(const InitializedAssertionPredicate& initialized_assertion_predicate) {}\n+\n+  \/\/ This method can be overridden to stop the predicate iterators from visiting more predicates further up in the\n+  \/\/ predicate chain.\n+  virtual bool should_continue() const {\n+    return true;\n+  }\n+};\n+\n@@ -231,1 +272,0 @@\n-  static bool has_halt(const Node* success_proj);\n@@ -234,0 +274,7 @@\n+  static bool has_halt(const Node* success_proj);\n+};\n+\n+\/\/ Utility class representing a Regular Predicate which is either a Runtime Predicate or an Assertion Predicate.\n+class RegularPredicate : public StackObj {\n+ public:\n+  static bool may_be_predicate_if(const Node* node);\n@@ -242,1 +289,0 @@\n-  static bool may_be_predicate_if(Node* node);\n@@ -246,1 +292,2 @@\n-  static bool is_predicate(Node* node, Deoptimization::DeoptReason deopt_reason);\n+  static bool is_predicate(const Node* node, Deoptimization::DeoptReason deopt_reason);\n+  static bool has_valid_uncommon_trap(const Node* success_proj);\n@@ -250,1 +297,1 @@\n-class ParsePredicate : public StackObj {\n+class ParsePredicate : public Predicate {\n@@ -270,1 +317,1 @@\n-  Node* entry() const {\n+  Node* entry() const override {\n@@ -280,1 +327,1 @@\n-  ParsePredicateNode* node() const {\n+  ParsePredicateNode* head() const override {\n@@ -285,1 +332,1 @@\n-  ParsePredicateSuccessProj* success_proj() const {\n+  ParsePredicateSuccessProj* tail() const override {\n@@ -289,0 +336,14 @@\n+};\n+\n+\/\/ Class to represent a Runtime Predicate which always has an associated UCT on the failing path.\n+class RuntimePredicate : public Predicate {\n+  IfProjNode* _success_proj;\n+  IfNode* _if_node;\n+\n+ public:\n+  explicit RuntimePredicate(IfProjNode* success_proj)\n+      : _success_proj(success_proj),\n+        _if_node(success_proj->in(0)->as_If()) {\n+    assert(is_predicate(success_proj), \"must be valid\");\n+  }\n+  NONCOPYABLE(RuntimePredicate);\n@@ -290,0 +351,1 @@\n+ private:\n@@ -291,0 +353,15 @@\n+\n+ public:\n+  Node* entry() const override {\n+    return _if_node->in(0);\n+  }\n+\n+  IfNode* head() const override {\n+    return _if_node;\n+  }\n+\n+  IfProjNode* tail() const override {\n+    return _success_proj;\n+  }\n+\n+  static bool is_predicate(Node* node, Deoptimization::DeoptReason deopt_reason);\n@@ -293,2 +370,5 @@\n-\/\/ Utility class for queries on Runtime Predicates.\n-class RuntimePredicate : public StackObj {\n+\/\/ Class to represent a Template Assertion Predicate.\n+class TemplateAssertionPredicate : public Predicate {\n+  IfTrueNode* _success_proj;\n+  IfNode* _if_node;\n+\n@@ -296,1 +376,47 @@\n-  static bool is_success_proj(Node* node, Deoptimization::DeoptReason deopt_reason);\n+  explicit TemplateAssertionPredicate(IfTrueNode* success_proj)\n+      : _success_proj(success_proj),\n+        _if_node(success_proj->in(0)->as_If()) {\n+    assert(is_predicate(success_proj), \"must be valid\");\n+  }\n+\n+  Node* entry() const override {\n+    return _if_node->in(0);\n+  }\n+\n+  IfNode* head() const override {\n+    return _if_node;\n+  }\n+\n+  IfTrueNode* tail() const override {\n+    return _success_proj;\n+  }\n+\n+  static bool is_predicate(Node* node);\n+};\n+\n+\/\/ Class to represent an Initialized Assertion Predicate which always has a halt node on the failing path.\n+\/\/ This predicate should never fail at runtime by design.\n+class InitializedAssertionPredicate : public Predicate {\n+  IfTrueNode* _success_proj;\n+  IfNode* _if_node;\n+\n+ public:\n+  explicit InitializedAssertionPredicate(IfTrueNode* success_proj)\n+      : _success_proj(success_proj),\n+        _if_node(success_proj->in(0)->as_If()) {\n+    assert(is_predicate(success_proj), \"must be valid\");\n+  }\n+\n+  Node* entry() const override {\n+    return _if_node->in(0);\n+  }\n+\n+  IfNode* head() const override {\n+    return _if_node;\n+  }\n+\n+  IfTrueNode* tail() const override {\n+    return _success_proj;\n+  }\n+\n+  static bool is_predicate(Node* node);\n@@ -398,1 +524,1 @@\n-class InitializedAssertionPredicate : public StackObj {\n+class InitializedAssertionPredicateCreator : public StackObj {\n@@ -405,3 +531,3 @@\n-  InitializedAssertionPredicate(IfNode* template_assertion_predicate, Node* new_init, Node* new_stride,\n-                                PhaseIdealLoop* phase);\n-  NONCOPYABLE(InitializedAssertionPredicate);\n+  InitializedAssertionPredicateCreator(IfNode* template_assertion_predicate, Node* new_init, Node* new_stride,\n+                                       PhaseIdealLoop* phase);\n+  NONCOPYABLE(InitializedAssertionPredicateCreator);\n@@ -419,0 +545,177 @@\n+\/\/ This class iterates through all predicates of a Regular Predicate Block and applies the given visitor to each.\n+class RegularPredicateBlockIterator : public StackObj {\n+  Node* const _start_node;\n+  const Deoptimization::DeoptReason _deopt_reason;\n+\n+ public:\n+  RegularPredicateBlockIterator(Node* start_node, Deoptimization::DeoptReason deopt_reason)\n+      : _start_node(start_node),\n+        _deopt_reason(deopt_reason) {}\n+  NONCOPYABLE(RegularPredicateBlockIterator);\n+\n+  \/\/ Skip all predicates by just following the inputs. We do not call any user provided visitor.\n+  Node* skip_all() const {\n+    PredicateVisitor do_nothing; \/\/ No real visits, just do nothing.\n+    return for_each(do_nothing);\n+  }\n+\n+  \/\/ Walk over all predicates of this block (if any) and apply the given 'predicate_visitor' to each predicate.\n+  \/\/ Returns the entry to the earliest predicate.\n+  Node* for_each(PredicateVisitor& predicate_visitor) const {\n+    Node* current = _start_node;\n+    while (predicate_visitor.should_continue()) {\n+      if (TemplateAssertionPredicate::is_predicate(current)) {\n+        TemplateAssertionPredicate template_assertion_predicate(current->as_IfTrue());\n+        predicate_visitor.visit(template_assertion_predicate);\n+        current = template_assertion_predicate.entry();\n+      } else if (RuntimePredicate::is_predicate(current, _deopt_reason)) {\n+        RuntimePredicate runtime_predicate(current->as_IfProj());\n+        predicate_visitor.visit(runtime_predicate);\n+        current = runtime_predicate.entry();\n+      } else if (InitializedAssertionPredicate::is_predicate(current)) {\n+        InitializedAssertionPredicate initialized_assertion_predicate(current->as_IfTrue());\n+        predicate_visitor.visit(initialized_assertion_predicate);\n+        current = initialized_assertion_predicate.entry();\n+      } else {\n+        \/\/ Either a Parse Predicate or not a Regular Predicate. In both cases, the node does not belong to this block.\n+        break;\n+      }\n+    }\n+    return current;\n+  }\n+};\n+\n+\/\/ This class iterates through all predicates of a Predicate Block and applies the given visitor to each.\n+class PredicateBlockIterator : public StackObj {\n+  Node* const _start_node;\n+  const ParsePredicate _parse_predicate; \/\/ Could be missing.\n+  const RegularPredicateBlockIterator _regular_predicate_block_iterator;\n+\n+ public:\n+  PredicateBlockIterator(Node* start_node, Deoptimization::DeoptReason deopt_reason)\n+      : _start_node(start_node),\n+        _parse_predicate(start_node, deopt_reason),\n+        _regular_predicate_block_iterator(_parse_predicate.entry(), deopt_reason) {}\n+\n+  \/\/ Walk over all predicates of this block (if any) and apply the given 'predicate_visitor' to each predicate.\n+  \/\/ Returns the entry to the earliest predicate.\n+  Node* for_each(PredicateVisitor& predicate_visitor) const {\n+    if (!predicate_visitor.should_continue()) {\n+      return _start_node;\n+    }\n+    if (_parse_predicate.is_valid()) {\n+      predicate_visitor.visit(_parse_predicate);\n+    }\n+    return _regular_predicate_block_iterator.for_each(predicate_visitor);\n+  }\n+};\n+\n+\/\/ Class to walk over all predicates starting at a node, which usually is the loop entry node, and following the inputs.\n+\/\/ At each predicate, a PredicateVisitor is applied which the user can implement freely.\n+class PredicateIterator : public StackObj {\n+  Node* _start_node;\n+\n+ public:\n+  explicit PredicateIterator(Node* start_node)\n+      : _start_node(start_node) {}\n+  NONCOPYABLE(PredicateIterator);\n+\n+  \/\/ Apply the 'predicate_visitor' for each predicate found in the predicate chain started at the provided node.\n+  \/\/ Returns the entry to the earliest predicate.\n+  Node* for_each(PredicateVisitor& predicate_visitor) const {\n+    Node* current = _start_node;\n+    PredicateBlockIterator loop_limit_check_predicate_iterator(current, Deoptimization::Reason_loop_limit_check);\n+    current = loop_limit_check_predicate_iterator.for_each(predicate_visitor);\n+    PredicateBlockIterator profiled_loop_predicate_iterator(current, Deoptimization::Reason_profile_predicate);\n+    current = profiled_loop_predicate_iterator.for_each(predicate_visitor);\n+    PredicateBlockIterator loop_predicate_iterator(current, Deoptimization::Reason_predicate);\n+    return loop_predicate_iterator.for_each(predicate_visitor);\n+  }\n+};\n+\n+\/\/ Unified PredicateVisitor which only provides a single visit method for a generic Predicate. This visitor can be used\n+\/\/ when it does not matter what kind of predicate is visited. Note that we override all normal visit methods from\n+\/\/ PredicateVisitor by calling the unified method. These visit methods are marked final such that they cannot be\n+\/\/ overridden by implementors of this class.\n+class UnifiedPredicateVisitor : public PredicateVisitor {\n+ public:\n+  virtual void visit(const TemplateAssertionPredicate& template_assertion_predicate) override final {\n+    visit_predicate(template_assertion_predicate);\n+  }\n+\n+  virtual void visit(const ParsePredicate& parse_predicate) override final {\n+    visit_predicate(parse_predicate);\n+  }\n+\n+  virtual void visit(const RuntimePredicate& runtime_predicate) override final {\n+    visit_predicate(runtime_predicate);\n+  }\n+\n+  virtual void visit(const InitializedAssertionPredicate& initialized_assertion_predicate) override final {\n+    visit_predicate(initialized_assertion_predicate);\n+  }\n+\n+  virtual void visit_predicate(const Predicate& predicate) = 0;\n+};\n+\n+\/\/ A block of Regular Predicates inside a Predicate Block without its Parse Predicate.\n+class RegularPredicateBlock : public StackObj {\n+  const Deoptimization::DeoptReason _deopt_reason;\n+  Node* const _entry;\n+\n+ public:\n+  RegularPredicateBlock(Node* tail, Deoptimization::DeoptReason deopt_reason)\n+      : _deopt_reason(deopt_reason),\n+        _entry(skip_all(tail)) {\n+    DEBUG_ONLY(verify_block(tail);)\n+  }\n+  NONCOPYABLE(RegularPredicateBlock);\n+\n+ private:\n+  \/\/ Walk over all Regular Predicates of this block (if any) and return the first node not belonging to the block\n+  \/\/ anymore (i.e. entry to the first Regular Predicate in this block if any or `tail` otherwise).\n+  Node* skip_all(Node* tail) const {\n+    RegularPredicateBlockIterator iterator(tail, _deopt_reason);\n+    return iterator.skip_all();\n+  }\n+\n+  DEBUG_ONLY(void verify_block(Node* tail);)\n+\n+ public:\n+  Node* entry() const {\n+    return _entry;\n+  }\n+};\n+\n+#ifndef PRODUCT\n+\/\/ Visitor class to print all the visited predicates. Used by the Predicates class which does the printing starting\n+\/\/ at the loop node and then following the inputs to the earliest predicate.\n+class PredicatePrinter : public PredicateVisitor {\n+  const char* _prefix; \/\/ Prefix added to each dumped string.\n+\n+ public:\n+  explicit PredicatePrinter(const char* prefix) : _prefix(prefix) {}\n+  NONCOPYABLE(PredicatePrinter);\n+\n+  void visit(const ParsePredicate& parse_predicate) override {\n+    print_predicate_node(\"Parse Predicate\", parse_predicate);\n+  }\n+\n+  void visit(const RuntimePredicate& runtime_predicate) override {\n+    print_predicate_node(\"Runtime Predicate\", runtime_predicate);\n+  }\n+\n+  void visit(const TemplateAssertionPredicate& template_assertion_predicate) override {\n+    print_predicate_node(\"Template Assertion Predicate\", template_assertion_predicate);\n+  }\n+\n+  void visit(const InitializedAssertionPredicate& initialized_assertion_predicate) override {\n+    print_predicate_node(\"Initialized Assertion Predicate\", initialized_assertion_predicate);\n+  }\n+\n+ private:\n+  void print_predicate_node(const char* predicate_name, const Predicate& predicate) const {\n+    tty->print_cr(\"%s- %s: %d %s\", _prefix, predicate_name, predicate.head()->_idx, predicate.head()->Name());\n+  }\n+};\n+#endif \/\/ NOT PRODUCT\n@@ -424,5 +727,8 @@\n-  ParsePredicate _parse_predicate; \/\/ Could be missing.\n-  Node* _entry;\n-\n-  static Node* skip_regular_predicates(Node* regular_predicate_proj, Deoptimization::DeoptReason deopt_reason);\n-  DEBUG_ONLY(void verify_block();)\n+  const ParsePredicate _parse_predicate; \/\/ Could be missing.\n+  const RegularPredicateBlock _regular_predicate_block;\n+  Node* const _entry;\n+#ifndef PRODUCT\n+  \/\/ Used for dumping.\n+  Node* const _tail;\n+  const Deoptimization::DeoptReason _deopt_reason;\n+#endif \/\/ NOT PRODUCT\n@@ -431,5 +737,10 @@\n-  PredicateBlock(Node* predicate_proj, Deoptimization::DeoptReason deopt_reason)\n-      : _parse_predicate(predicate_proj, deopt_reason),\n-        _entry(skip_regular_predicates(_parse_predicate.entry(), deopt_reason)) {\n-    DEBUG_ONLY(verify_block();)\n-  }\n+  PredicateBlock(Node* tail, Deoptimization::DeoptReason deopt_reason)\n+      : _parse_predicate(tail, deopt_reason),\n+        _regular_predicate_block(_parse_predicate.entry(), deopt_reason),\n+        _entry(_regular_predicate_block.entry())\n+#ifndef PRODUCT\n+        , _tail(tail)\n+        , _deopt_reason(deopt_reason)\n+#endif \/\/ NOT PRODUCT\n+        {}\n+  NONCOPYABLE(PredicateBlock);\n@@ -456,1 +767,1 @@\n-    return _parse_predicate.node();\n+    return _parse_predicate.head();\n@@ -460,1 +771,1 @@\n-    return _parse_predicate.success_proj();\n+    return _parse_predicate.tail();\n@@ -474,0 +785,5 @@\n+\n+#ifndef PRODUCT\n+  void dump() const;\n+  void dump(const char* prefix) const;\n+#endif \/\/ NOT PRODUCT\n@@ -478,5 +794,5 @@\n-  Node* _loop_entry;\n-  PredicateBlock _loop_limit_check_predicate_block;\n-  PredicateBlock _profiled_loop_predicate_block;\n-  PredicateBlock _loop_predicate_block;\n-  Node* _entry;\n+  Node* const _tail;\n+  const PredicateBlock _loop_limit_check_predicate_block;\n+  const PredicateBlock _profiled_loop_predicate_block;\n+  const PredicateBlock _loop_predicate_block;\n+  Node* const _entry;\n@@ -485,2 +801,2 @@\n-  Predicates(Node* loop_entry)\n-      : _loop_entry(loop_entry),\n+  explicit Predicates(Node* loop_entry)\n+      : _tail(loop_entry),\n@@ -493,0 +809,1 @@\n+  NONCOPYABLE(Predicates);\n@@ -513,1 +830,1 @@\n-    return _entry != _loop_entry;\n+    return _entry != _tail;\n@@ -515,9 +832,0 @@\n-};\n-\n-\/\/ This class iterates over the Parse Predicates of a loop.\n-class ParsePredicateIterator : public StackObj {\n-  GrowableArray<ParsePredicateNode*> _parse_predicates;\n-  int _current_index;\n-\n- public:\n-  ParsePredicateIterator(const Predicates& predicates);\n@@ -525,5 +833,8 @@\n-  bool has_next() const {\n-    return _current_index < _parse_predicates.length();\n-  }\n-\n-  ParsePredicateNode* next();\n+#ifndef PRODUCT\n+  \/*\n+   * Debug printing functions.\n+   *\/\n+  void dump() const;\n+  static void dump_at(Node* node);\n+  static void dump_for_loop(LoopNode* loop_node);\n+#endif \/\/ NOT PRODUCT\n@@ -532,12 +843,0 @@\n-\/\/ Special predicate iterator that can be used to walk through predicate entries, regardless of whether the predicate\n-\/\/ belongs to the same loop or not (i.e. leftovers from already folded nodes). The iterator returns the next entry\n-\/\/ to a predicate.\n-class PredicateEntryIterator : public StackObj {\n-  Node* _current;\n-\n- public:\n-  explicit PredicateEntryIterator(Node* start) : _current(start) {};\n-\n-  bool has_next() const;\n-  Node* next_entry();\n-};\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":360,"deletions":61,"binary":false,"changes":421,"status":"modified"}]}