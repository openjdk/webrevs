{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -468,14 +468,0 @@\n-\n-    @Override @DefinedBy(Api.LANGUAGE_MODEL)\n-    public <A extends Annotation> A getAnnotation(Class<A> annotationType) {\n-        return null;\n-    }\n-\n-\n-    @Override @DefinedBy(Api.LANGUAGE_MODEL)\n-    public <A extends Annotation> A[] getAnnotationsByType(Class<A> annotationType) {\n-        @SuppressWarnings(\"unchecked\")\n-        A[] tmp = (A[]) java.lang.reflect.Array.newInstance(annotationType, 0);\n-        return tmp;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8013852 8031744 8225377\n+ * @bug 8013852 8031744 8225377 8323684\n@@ -45,0 +45,1 @@\n+import java.lang.reflect.Method;\n@@ -47,0 +48,1 @@\n+import java.util.AbstractMap;\n@@ -49,0 +51,1 @@\n+import java.util.Objects;\n@@ -89,0 +92,17 @@\n+    \/\/ Use a compile-time mapping to avoid repeated runtime reflective lookups.\n+    private static final Map<String, Class<? extends Annotation>> nameToAnnotation =\n+        Map.ofEntries(new NameToAnnotationEntry(\"java.lang.Override\", Override.class),\n+                      new NameToAnnotationEntry(\"java.lang.annotation.Repeatable\", Repeatable.class),\n+                      new NameToAnnotationEntry(\"java.lang.annotation.Target\", Target.class),\n+                      new NameToAnnotationEntry(\"BasicAnnoTests.Test\", BasicAnnoTests.Test.class),\n+                      new NameToAnnotationEntry(\"BasicAnnoTests.Tests\",BasicAnnoTests.Tests.class),\n+                      new NameToAnnotationEntry(\"BasicAnnoTests.TA\",   BasicAnnoTests.TA.class),\n+                      new NameToAnnotationEntry(\"BasicAnnoTests.TB\",   BasicAnnoTests.TB.class),\n+                      new NameToAnnotationEntry(\"BasicAnnoTests.TC\",   BasicAnnoTests.TC.class),\n+                      new NameToAnnotationEntry(\"BasicAnnoTests.TCs\",  BasicAnnoTests.TCs.class));\n+\n+    static class NameToAnnotationEntry extends  AbstractMap.SimpleEntry<String, Class<? extends Annotation>> {\n+        public NameToAnnotationEntry(String key, Class<? extends Annotation> entry) {\n+            super(key, entry);\n+        }\n+    }\n@@ -107,1 +127,1 @@\n-        messager.printMessage(Kind.ERROR, msg, e);\n+        messager.printError(msg, e);\n@@ -266,0 +286,1 @@\n+            checkAnnotatedConstructConsistency(e, m);\n@@ -279,0 +300,1 @@\n+            checkAnnotatedConstructConsistency(e, m);\n@@ -293,0 +315,79 @@\n+    \/**\n+     * Verify that an annotation mirror returned by\n+     * getAnnotationMirrors() has a matching annotation from\n+     * getAnnotation and appropriate values are returned by\n+     * getAnnotationsByType.\n+     *\/\n+    static void checkAnnotatedConstructConsistency(AnnotatedConstruct ac, AnnotationMirror m) {\n+        \/\/ For each annotation mirror present, an annotation of the\n+        \/\/ same annotation type should be directly present as well.\n+        String annotationTypeName = ((TypeElement)m.getAnnotationType().asElement()).getQualifiedName().toString();\n+        var annotationClass = Objects.requireNonNull(nameToAnnotation.get(annotationTypeName));\n+        Annotation a = ac.getAnnotation(annotationClass);\n+        Objects.requireNonNull(a, \"Annotation \" + m + \" not found from getAnnotation(\" + annotationTypeName + \")\");\n+\n+        \/\/ For non-repeating annotation types, getAnnotationsByType should\n+        \/\/ wrap a single annotation in an one-element array.\n+        Annotation[] aArray = ac.getAnnotationsByType(annotationClass);\n+        if (aArray.length != 1) {\n+            throw new RuntimeException(\"Annotation \" + m +\n+                                       \" not found from getAnnotationsByType(\" + annotationTypeName + \")\");\n+        }\n+\n+        \/\/ For a container annotation, getAnnotationsByType should\n+        \/\/ \"look through\" and return the contained annotations by\n+        \/\/ their annotation class.\n+        var containedAnnotationClass = containerFor(annotationClass);\n+        if (containedAnnotationClass != null) {\n+            Object wrappedAnnotationValue = extractAnnotationValue(a);\n+            int wrappedCount = -1;\n+            if (wrappedAnnotationValue instanceof Annotation[] wrapped) {\n+                wrappedCount = wrapped.length;\n+            }\n+\n+            Annotation[] containedAnnotations = ac.getAnnotationsByType(containedAnnotationClass);\n+            \/\/ Check number of contained annotations for consistency\n+            \/\/ Given annotation type A and container annotation type As, the result of\n+            \/\/ annotatedConstruct.getAnnotaton(As.class).value().length ==\n+            \/\/ annotatedConstruct.getAnnotationsByType(A.class).length\n+            \/\/ More thorough checking could be done as well, checking\n+            \/\/ the types or value of the constituent annotations\/AnnotationMirrors.\n+            Object annotationValue = extractAnnotationValue(a);\n+            if (annotationValue instanceof Annotation[] objects\n+                && objects.length != wrappedCount) {\n+                throw new RuntimeException(\"\\t\\t\\tmismatched array length : \" + objects.length +\n+                                           \"\\twrapped count\" + wrappedCount);\n+            }\n+        }\n+    }\n+\n+    static Object extractAnnotationValue(Annotation annotation) {\n+        var annotationClass = annotation.annotationType();\n+        try {\n+            \/\/ Call value method of the annotation; expected to return\n+            \/\/ an array of the contained annotation type.\n+            Method valueMethod = annotationClass.getMethod(\"value\", null);\n+            return valueMethod.invoke(annotation);\n+        } catch (ReflectiveOperationException roe) {\n+            throw new RuntimeException(roe);\n+        }\n+    }\n+\n+    static int wrappedAnnotationCount(Annotation a) {\n+        Object value = extractAnnotationValue(a);\n+        if (value instanceof Annotation[] annotationValueArray) {\n+            return annotationValueArray.length;\n+        } else {\n+            return -1;\n+        }\n+    }\n+\n+    static Class<? extends Annotation> containerFor(Class<? extends Annotation> possibleContainer) {\n+        \/\/ Could write this more generally; for now, hard-code particular cases\n+        if (possibleContainer == TCs.class)\n+            return TC.class;\n+        if (possibleContainer == Tests.class)\n+            return Tests.class;\n+        return null;\n+    }\n+\n@@ -405,0 +506,1 @@\n+\n@@ -410,0 +512,11 @@\n+    @Target(ElementType.TYPE_USE)\n+    @Repeatable(TCs.class)\n+    public @interface TC {\n+        int value();\n+    }\n+\n+    @Target(ElementType.TYPE_USE)\n+    @interface TCs {\n+        TC[] value();\n+    }\n+\n@@ -476,0 +589,15 @@\n+    @Test(posn=0, annoType=TC.class, expect=\"1\")\n+    public @TC(1) int f1_repeat0;\n+\n+    \/\/ Containter annotation @TCs({@TC(2), @TC(3)}) created by the compiler\n+    @Test(posn=0, annoType=TCs.class, expect=\"{@BasicAnnoTests.TC(2), @BasicAnnoTests.TC(3)}\")\n+    public @TC(2) @TC(3) int f1_repeat1;\n+\n+    \/\/ Use container explicitly\n+    @Test(posn=0, annoType=TCs.class, expect=\"{@BasicAnnoTests.TC(4)}\")\n+    public @TCs(@TC(4)) int f1_repeat2;\n+\n+    \/\/ Explicit empty container\n+    @Test(posn=0, annoType=TCs.class, expect=\"{}\")\n+    public @TCs({}) int f1_repeat3;\n+\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/type\/BasicAnnoTests.java","additions":131,"deletions":3,"binary":false,"changes":134,"status":"modified"}]}