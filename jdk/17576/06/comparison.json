{"files":[{"patch":"@@ -39,0 +39,3 @@\n+product(bool, UseAllWindowsProcessorGroups, false,                        \\\n+        \"Use all processor groups on supported Windows versions\")         \\\n+                                                                          \\\n","filename":"src\/hotspot\/os\/windows\/globals_windows.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+#include \"utilities\/population_count.hpp\"\n@@ -870,0 +871,24 @@\n+  bool schedules_all_processor_groups = false;\n+  if (UseAllWindowsProcessorGroups) {\n+    \/\/ Starting with Windows 11 and Windows Server 2022, the OS has changed to\n+    \/\/ make processes and their threads span all processors in the system,\n+    \/\/ across all processor groups, by default. Therefore, we will allow all\n+    \/\/ processors to be active processors on these operating systems. However,\n+    \/\/ job objects can be used to restrict processor affinity across the\n+    \/\/ processor groups. In this case, the number of active processors must be\n+    \/\/ obtained from the processor affinity in the job object.\n+    schedules_all_processor_groups = win32::is_windows_11_or_greater() || win32::is_windows_server_2022_or_greater();\n+    if (schedules_all_processor_groups) {\n+      DWORD processors_in_job_object = win32::active_processors_in_job_object();\n+\n+      if (processors_in_job_object > 0) {\n+        return processors_in_job_object;\n+      }\n+    }\n+  }\n+\n+  DWORD logical_processors = 0;\n+  SYSTEM_INFO si;\n+  GetSystemInfo(&si);\n+\n+  \/\/ There is no associated job object so get the number of available logical processors from the process affinity mask\n@@ -872,10 +897,8 @@\n-  int proc_count = processor_count();\n-  if (proc_count <= sizeof(UINT_PTR) * BitsPerByte &&\n-      GetProcessAffinityMask(GetCurrentProcess(), &lpProcessAffinityMask, &lpSystemAffinityMask)) {\n-    \/\/ Nof active processors is number of bits in process affinity mask\n-    int bitcount = 0;\n-    while (lpProcessAffinityMask != 0) {\n-      lpProcessAffinityMask = lpProcessAffinityMask & (lpProcessAffinityMask-1);\n-      bitcount++;\n-    }\n-    return bitcount;\n+  if (GetProcessAffinityMask(GetCurrentProcess(), &lpProcessAffinityMask, &lpSystemAffinityMask)) {\n+    \/\/ Number of active processors is number of bits in process affinity mask\n+    logical_processors = population_count(lpProcessAffinityMask);\n+\n+    if (logical_processors > 0 && logical_processors < si.dwNumberOfProcessors) {\n+      \/\/ Respect the custom processor affinity since it is not equal to all processors in the current processor group\n+      return logical_processors;\n+    }\n@@ -883,1 +906,16 @@\n-    return proc_count;\n+    char buf[512];\n+    size_t buf_len = os::lasterror(buf, sizeof(buf));\n+    warning(\"Attempt to get the process affinity mask failed: %s\", buf_len != 0 ? buf : \"<unknown error>\");\n+  }\n+\n+  if (UseAllWindowsProcessorGroups) {\n+    \/\/ There are no processor affinity restrictions at this point so we can return\n+    \/\/ the overall processor count if the OS automatically schedules threads across\n+    \/\/ all processors on the system. Note that older operating systems can\n+    \/\/ correctly report processor count but will not schedule threads across\n+    \/\/ processor groups unless the application explicitly uses group affinity APIs\n+    \/\/ to assign threads to processor groups. On these older operating systems, we\n+    \/\/ will continue to use the dwNumberOfProcessors field.\n+    if (schedules_all_processor_groups) {\n+      logical_processors = processor_count();\n+    }\n@@ -885,0 +923,2 @@\n+\n+  return logical_processors == 0 ? si.dwNumberOfProcessors : logical_processors;\n@@ -1773,4 +1813,0 @@\n-  VS_FIXEDFILEINFO *file_info;\n-  TCHAR kernel32_path[MAX_PATH];\n-  UINT len, ret;\n-\n@@ -1779,38 +1815,4 @@\n-  \/\/ Get the full path to \\Windows\\System32\\kernel32.dll and use that for\n-  \/\/ determining what version of Windows we're running on.\n-  len = MAX_PATH - (UINT)strlen(\"\\\\kernel32.dll\") - 1;\n-  ret = GetSystemDirectory(kernel32_path, len);\n-  if (ret == 0 || ret > len) {\n-    st->print_cr(\"Call to GetSystemDirectory failed\");\n-    return;\n-  }\n-  strncat(kernel32_path, \"\\\\kernel32.dll\", MAX_PATH - ret);\n-\n-  DWORD version_size = GetFileVersionInfoSize(kernel32_path, nullptr);\n-  if (version_size == 0) {\n-    st->print_cr(\"Call to GetFileVersionInfoSize failed\");\n-    return;\n-  }\n-\n-  LPTSTR version_info = (LPTSTR)os::malloc(version_size, mtInternal);\n-  if (version_info == nullptr) {\n-    st->print_cr(\"Failed to allocate version_info\");\n-    return;\n-  }\n-\n-  if (!GetFileVersionInfo(kernel32_path, 0, version_size, version_info)) {\n-    os::free(version_info);\n-    st->print_cr(\"Call to GetFileVersionInfo failed\");\n-    return;\n-  }\n-\n-  if (!VerQueryValue(version_info, TEXT(\"\\\\\"), (LPVOID*)&file_info, &len)) {\n-    os::free(version_info);\n-    st->print_cr(\"Call to VerQueryValue failed\");\n-    return;\n-  }\n-\n-  int major_version = HIWORD(file_info->dwProductVersionMS);\n-  int minor_version = LOWORD(file_info->dwProductVersionMS);\n-  int build_number = HIWORD(file_info->dwProductVersionLS);\n-  int build_minor = LOWORD(file_info->dwProductVersionLS);\n+  int major_version = windows_major_version();\n+  int minor_version = windows_minor_version();\n+  int build_number = windows_build_number();\n+  int build_minor = windows_build_minor();\n@@ -1818,1 +1820,0 @@\n-  os::free(version_info);\n@@ -1914,0 +1915,6 @@\n+\n+    \/\/ This is the number of logical processors in the current processor group only and is therefore\n+    \/\/ at most 64. The GetLogicalProcessorInformation function is used to compute the total number\n+    \/\/ of processors. However, it requires memory to be allocated for the processor information buffer.\n+    \/\/ Since this method is used in paths where memory allocation should not be done (i.e. after a crash),\n+    \/\/ only the number of processors in the current group will be returned.\n@@ -3981,0 +3988,176 @@\n+int    os::win32::_major_version             = 0;\n+int    os::win32::_minor_version             = 0;\n+int    os::win32::_build_number              = 0;\n+int    os::win32::_build_minor               = 0;\n+\n+void os::win32::initialize_windows_version() {\n+  if (_major_version > 0) {\n+    return; \/\/ nothing to do if the version has already been set\n+  }\n+\n+  VS_FIXEDFILEINFO *file_info;\n+  TCHAR kernel32_path[MAX_PATH];\n+  UINT len, ret;\n+\n+  \/\/ Get the full path to \\Windows\\System32\\kernel32.dll and use that for\n+  \/\/ determining what version of Windows we're running on.\n+  len = MAX_PATH - (UINT)strlen(\"\\\\kernel32.dll\") - 1;\n+  ret = GetSystemDirectory(kernel32_path, len);\n+  if (ret == 0 || ret > len) {\n+    warning(\"GetSystemDirectory() failed: GetLastError->%ld.\", GetLastError());\n+    return;\n+  }\n+  strncat(kernel32_path, \"\\\\kernel32.dll\", MAX_PATH - ret);\n+\n+  DWORD version_size = GetFileVersionInfoSize(kernel32_path, nullptr);\n+  if (version_size == 0) {\n+    warning(\"GetFileVersionInfoSize() failed: GetLastError->%ld.\", GetLastError());\n+    return;\n+  }\n+\n+  LPTSTR version_info = (LPTSTR)os::malloc(version_size, mtInternal);\n+  if (version_info == nullptr) {\n+    warning(\"os::malloc() failed to allocate %ld bytes for GetFileVersionInfo buffer\", version_size);\n+    return;\n+  }\n+\n+  if (!GetFileVersionInfo(kernel32_path, 0, version_size, version_info)) {\n+    os::free(version_info);\n+    warning(\"GetFileVersionInfo() failed: GetLastError->%ld.\", GetLastError());\n+    return;\n+  }\n+\n+  if (!VerQueryValue(version_info, TEXT(\"\\\\\"), (LPVOID*)&file_info, &len)) {\n+    os::free(version_info);\n+    warning(\"VerQueryValue() failed. Cannot determine Windows version.\");\n+    return;\n+  }\n+\n+  _major_version = HIWORD(file_info->dwProductVersionMS);\n+  _minor_version = LOWORD(file_info->dwProductVersionMS);\n+  _build_number  = HIWORD(file_info->dwProductVersionLS);\n+  _build_minor   = LOWORD(file_info->dwProductVersionLS);\n+\n+  os::free(version_info);\n+}\n+\n+bool os::win32::is_windows_11_or_greater() {\n+  \/\/ Windows 11 starts at build 22000 (Version 21H2)\n+  return (windows_major_version() >= 10 && windows_build_number() >= 22000 && !IsWindowsServer());\n+}\n+\n+bool os::win32::is_windows_server_2022_or_greater() {\n+  \/\/ Windows Server 2022 starts at build 20348.169\n+  return (windows_major_version() >= 10 && windows_build_number() >= 20348 && IsWindowsServer());\n+}\n+\n+DWORD os::win32::active_processors_in_job_object() {\n+  BOOL is_in_job_object = false;\n+  if (IsProcessInJob(GetCurrentProcess(), nullptr, &is_in_job_object) == 0) {\n+    char buf[512];\n+    size_t buf_len = os::lasterror(buf, sizeof(buf));\n+    warning(\"Attempt to determine whether the process is running in a job failed: %s\", buf_len != 0 ? buf : \"<unknown error>\");\n+    return 0;\n+  }\n+\n+  if (!is_in_job_object) {\n+    return 0;\n+  }\n+\n+  DWORD processors = 0;\n+\n+  LPVOID job_object_information = nullptr;\n+  DWORD job_object_information_length = 0;\n+\n+  if (QueryInformationJobObject(nullptr, JobObjectGroupInformationEx, nullptr, 0, &job_object_information_length) != 0) {\n+    warning(\"Unexpected QueryInformationJobObject success result.\");\n+    assert(false, \"Unexpected QueryInformationJobObject success result\");\n+    return 0;\n+  }\n+\n+  DWORD last_error = GetLastError();\n+  if (last_error == ERROR_INSUFFICIENT_BUFFER) {\n+    DWORD group_count = job_object_information_length \/ sizeof(GROUP_AFFINITY);\n+\n+    job_object_information = os::malloc(job_object_information_length, mtInternal);\n+    if (job_object_information != nullptr) {\n+        if (QueryInformationJobObject(nullptr, JobObjectGroupInformationEx, job_object_information, job_object_information_length, &job_object_information_length) != 0) {\n+          DWORD groups_found = job_object_information_length \/ sizeof(GROUP_AFFINITY);\n+          if (groups_found != group_count) {\n+            warning(\"Unexpected processor group count: %ld. Expected %ld processor groups.\", groups_found, group_count);\n+            assert(false, \"Unexpected group count\");\n+          }\n+\n+          GROUP_AFFINITY* group_affinity_data = ((GROUP_AFFINITY*)job_object_information);\n+          for (DWORD i = 0; i < groups_found; i++, group_affinity_data++) {\n+            processors += population_count(group_affinity_data->Mask);\n+          }\n+\n+          if (processors == 0) {\n+            warning(\"Could not determine processor count from the job object.\");\n+            assert(false, \"Must find at least 1 logical processor\");\n+          }\n+        } else {\n+          char buf[512];\n+          size_t buf_len = os::lasterror(buf, sizeof(buf));\n+          warning(\"Attempt to query job object information failed: %s\", buf_len != 0 ? buf : \"<unknown error>\");\n+        }\n+\n+        os::free(job_object_information);\n+    } else {\n+        warning(\"os::malloc() failed to allocate %ld bytes for QueryInformationJobObject\", job_object_information_length);\n+    }\n+  } else {\n+    char buf[512];\n+    size_t buf_len = os::lasterror(buf, sizeof(buf));\n+    warning(\"Attempt to query job object information failed: %s\", buf_len != 0 ? buf : \"<unknown error>\");\n+    assert(false, \"Unexpected QueryInformationJobObject error code\");\n+    return 0;\n+  }\n+\n+  return processors;\n+}\n+\n+DWORD os::win32::system_logical_processor_count() {\n+  DWORD logical_processors = 0;\n+  LOGICAL_PROCESSOR_RELATIONSHIP relationship_type = RelationGroup;\n+  PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX system_logical_processor_info = nullptr;\n+  DWORD returned_length = 0;\n+\n+  if (GetLogicalProcessorInformationEx(relationship_type, nullptr, &returned_length) == 0) {\n+    DWORD last_error = GetLastError();\n+\n+    if (last_error == ERROR_INSUFFICIENT_BUFFER) {\n+      system_logical_processor_info = (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX)os::malloc(returned_length, mtInternal);\n+\n+      if (nullptr == system_logical_processor_info) {\n+        warning(\"os::malloc() failed to allocate %ld bytes for GetLogicalProcessorInformationEx buffer\", returned_length);\n+      } else if (GetLogicalProcessorInformationEx(relationship_type, system_logical_processor_info, &returned_length) == 0) {\n+        char buf[512];\n+        size_t buf_len = os::lasterror(buf, sizeof(buf));\n+        warning(\"Attempt to determine logical processor count from GetLogicalProcessorInformationEx() failed: %s\", buf_len != 0 ? buf : \"<unknown error>\");\n+      } else {\n+        DWORD processor_groups = system_logical_processor_info->Group.ActiveGroupCount;\n+\n+        PROCESSOR_GROUP_INFO* group_info = (PROCESSOR_GROUP_INFO*)system_logical_processor_info->Group.GroupInfo;\n+        for (DWORD i = 0; i < processor_groups; i++, group_info++) {\n+          logical_processors += group_info->ActiveProcessorCount;\n+        }\n+\n+        if (logical_processors == 0) {\n+          warning(\"Could not determine logical processor count from GetLogicalProcessorInformationEx()\");\n+          assert(false, \"Must find at least 1 logical processor\");\n+        }\n+      }\n+\n+      os::free(system_logical_processor_info);\n+    } else {\n+      char buf[512];\n+      size_t buf_len = os::lasterror(buf, sizeof(buf));\n+      warning(\"Attempt to determine logical processor count from GetLogicalProcessorInformationEx() failed: %s\", buf_len != 0 ? buf : \"<unknown error>\");\n+    }\n+  }\n+\n+  return logical_processors;\n+}\n+\n@@ -3982,0 +4165,2 @@\n+  initialize_windows_version();\n+\n@@ -3988,1 +4173,8 @@\n-  set_processor_count(si.dwNumberOfProcessors);\n+\n+  DWORD processors = 0;\n+  bool schedules_all_processor_groups = win32::is_windows_11_or_greater() || win32::is_windows_server_2022_or_greater();\n+  if (schedules_all_processor_groups) {\n+    processors = system_logical_processor_count();\n+  }\n+\n+  set_processor_count(processors > 0 ? processors : si.dwNumberOfProcessors);\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":247,"deletions":55,"binary":false,"changes":302,"status":"modified"},{"patch":"@@ -47,0 +47,5 @@\n+  static int    _major_version;\n+  static int    _minor_version;\n+  static int    _build_number;\n+  static int    _build_minor;\n+\n@@ -59,0 +64,19 @@\n+  static bool   is_windows_11_or_greater();\n+  static bool   is_windows_server_2022_or_greater();\n+  static DWORD  system_logical_processor_count();\n+  static int windows_major_version() {\n+    initialize_windows_version();\n+    return _major_version;\n+  }\n+  static int windows_minor_version() {\n+    initialize_windows_version();\n+    return _minor_version;\n+  }\n+  static int windows_build_number() {\n+    initialize_windows_version();\n+    return _build_number;\n+  }\n+  static int windows_build_minor() {\n+    initialize_windows_version();\n+    return _build_minor;\n+  }\n@@ -75,0 +99,2 @@\n+  static void initialize_windows_version();\n+  static DWORD active_processors_in_job_object();\n","filename":"src\/hotspot\/os\/windows\/os_windows.hpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -706,0 +706,19 @@\n+TEST_VM(os_windows, processor_count) {\n+  JVMFlag* flag = JVMFlag::find_flag(\"UseAllWindowsProcessorGroups\");\n+  EXPECT_NE(flag, nullptr) << \"Expected UseAllWindowsProcessorGroups product flag to be available\";\n+\n+  int processors = os::processor_count();\n+  EXPECT_GT(processors, 0) << \"Expected at least 1 processor\";\n+\n+  int active_processors = os::active_processor_count();\n+  EXPECT_GT(active_processors, 0) << \"Expected at least 1 active processor\";\n+\n+  bool schedules_all_processor_groups = os::win32::is_windows_11_or_greater() || os::win32::is_windows_server_2022_or_greater();\n+  if (schedules_all_processor_groups && UseAllWindowsProcessorGroups) {\n+    EXPECT_EQ(active_processors, processors) << \"Expected all processors to be active\";\n+  } else {\n+    \/\/ active_processors should be at most the number of processors in 1 Windows processor group.\n+    EXPECT_LE(active_processors, processors) << \"Expected active processors to not exceed available processors\";\n+  }\n+}\n+\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_windows.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -148,0 +148,1 @@\n+  gtest\/WindowsProcessorGroups.java\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * This runs the os related gtests on Windows with all processor groups enabled.\n+ *\/\n+\n+\/* @test id=use-all-windows-processor-groups\n+ * @summary Run gtests with all Windows processor groups enabled\n+ * @library \/test\/lib\n+ * @requires os.family == \"windows\"\n+ * @run main\/native GTestWrapper --gtest_filter=os* -XX:+UseAllWindowsProcessorGroups\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gtest\/WindowsProcessorGroups.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"}]}