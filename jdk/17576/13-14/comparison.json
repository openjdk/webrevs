{"files":[{"patch":"@@ -911,10 +911,21 @@\n-  \/\/ There is no associated job object so get the number of available logical processors from the process affinity mask\n-  DWORD_PTR lpProcessAffinityMask = 0;\n-  DWORD_PTR lpSystemAffinityMask = 0;\n-  if (GetProcessAffinityMask(GetCurrentProcess(), &lpProcessAffinityMask, &lpSystemAffinityMask)) {\n-    \/\/ Number of active processors is number of bits in process affinity mask\n-    logical_processors = population_count(lpProcessAffinityMask);\n-\n-    if (logical_processors > 0 && logical_processors < si.dwNumberOfProcessors) {\n-      \/\/ Respect the custom processor affinity since it is not equal to all processors in the current processor group\n-      return logical_processors;\n+  USHORT group_count = 0;\n+  bool use_process_affinity_mask = false;\n+  bool got_process_group_affinity = false;\n+\n+  if (GetProcessGroupAffinity(GetCurrentProcess(), &group_count, nullptr) == 0) {\n+    DWORD last_error = GetLastError();\n+    if (last_error == ERROR_INSUFFICIENT_BUFFER) {\n+      if (group_count > 0) {\n+        got_process_group_affinity = true;\n+\n+        if (group_count == 1) {\n+          use_process_affinity_mask = true;\n+        }\n+      } else {\n+        warning(\"Unexpected group count of 0 from GetProcessGroupAffinity.\");\n+        assert(false, \"Group count must not be 0.\");\n+      }\n+    } else {\n+      char buf[512];\n+      size_t buf_len = os::lasterror(buf, sizeof(buf));\n+      warning(\"Attempt to get process group affinity failed: %s\", buf_len != 0 ? buf : \"<unknown error>\");\n@@ -923,3 +934,34 @@\n-    char buf[512];\n-    size_t buf_len = os::lasterror(buf, sizeof(buf));\n-    warning(\"Attempt to get the process affinity mask failed: %s\", buf_len != 0 ? buf : \"<unknown error>\");\n+    warning(\"Unexpected GetProcessGroupAffinity success result.\");\n+    assert(false, \"Unexpected GetProcessGroupAffinity success result\");\n+  }\n+\n+  \/\/ Fall back to SYSTEM_INFO.dwNumberOfProcessors if the process group affinity could not be determined.\n+  if (!got_process_group_affinity) {\n+    return si.dwNumberOfProcessors;\n+  }\n+\n+  \/\/ If the process it not in a job and the process group affinity is exactly 1 group\n+  \/\/ then get the number of available logical processors from the process affinity mask\n+  if (use_process_affinity_mask) {\n+    DWORD_PTR lpProcessAffinityMask = 0;\n+    DWORD_PTR lpSystemAffinityMask = 0;\n+    if (GetProcessAffinityMask(GetCurrentProcess(), &lpProcessAffinityMask, &lpSystemAffinityMask)) {\n+      \/\/ Number of active processors is number of bits in process affinity mask\n+      logical_processors = population_count(lpProcessAffinityMask);\n+\n+      if (logical_processors > 0) {\n+        return logical_processors;\n+      } else {\n+        \/\/ We only check the process affinity mask if GetProcessGroupAffinity determined that there was\n+        \/\/ only 1 active group. In this case, GetProcessAffinityMask will not set the affinity mask to 0.\n+        warning(\"Unexpected process affinity mask of 0 from GetProcessAffinityMask.\");\n+        assert(false, \"Found unexpected process affinity mask: 0\");\n+      }\n+    } else {\n+      char buf[512];\n+      size_t buf_len = os::lasterror(buf, sizeof(buf));\n+      warning(\"Attempt to get the process affinity mask failed: %s\", buf_len != 0 ? buf : \"<unknown error>\");\n+    }\n+\n+    \/\/ Fall back to SYSTEM_INFO.dwNumberOfProcessors if the process affinity mask could not be determined.\n+    return si.dwNumberOfProcessors;\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":55,"deletions":13,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+public class GetAvailableProcessors {\n+  public static void main(String[] args) {\n+    System.out.println(\"Runtime.availableProcessors: \" + Runtime.getRuntime().availableProcessors());\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/6942632\/GetAvailableProcessors.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,159 @@\n+#\n+# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# @test\n+# @bug 6942632\n+# @summary This test ensures that OpenJDK respects the process affinity\n+#          masks set when launched from the Windows command prompt using\n+#          \"start \/affinity HEXAFFINITY java.exe\" when the\n+#          UseAllWindowsProcessorGroups flag is enabled.\n+\n+OS=`uname -s`\n+case \"$OS\" in\n+  Windows* | CYGWIN* )\n+    ;;\n+  * )\n+    echo \"Cannot run a Windows-specific test on $OS\"\n+    exit 1\n+    ;;\n+esac\n+\n+if [ \"${TESTSRC}\" = \"\" ]\n+then\n+  echo \"TESTSRC not set. Test cannot execute.\"\n+  exit 1\n+fi\n+\n+if [ \"${TESTNATIVEPATH}\" = \"\" ]\n+then\n+  echo \"TESTNATIVEPATH not set. Test cannot execute.\"\n+  exit 1\n+fi\n+\n+if [ -z \"${TESTCLASSES}\" ]; then\n+  echo \"TESTCLASSES undefined: defaulting to .\"\n+  TESTCLASSES=.\n+fi\n+\n+echo \"TESTCLASSES:    $TESTCLASSES\"\n+echo \"TESTJAVACOPTS:  $TESTJAVACOPTS\"\n+echo \"TESTTOOLVMOPTS: $TESTTOOLVMOPTS\"\n+\n+JAVAC=\"${TESTJAVA}\/bin\/javac\"\n+\n+SRCFILEBASE=GetAvailableProcessors\n+SRCFILE=\"${TESTSRC}\/$SRCFILEBASE.java\"\n+LOGFILE=\"${TESTCLASSES}\/$SRCFILEBASE.output.log\"\n+$JAVAC ${TESTJAVACOPTS} ${TESTTOOLVMOPTS} -d ${TESTCLASSES} $SRCFILE\n+\n+status=$?\n+if [ ! $status -eq \"0\" ]; then\n+  echo \"Compilation failed: $SRCFILE\";\n+  exit 1\n+fi\n+\n+# Write SYSTEM_INFO.dwNumberOfProcessors to a log file\n+GETPROCINFONAME=GetProcessorInfo\n+GETPROCINFOLOG=\"${TESTCLASSES}\/$GETPROCINFONAME.output.log\"\n+${TESTNATIVEPATH}\/$GETPROCINFONAME > $GETPROCINFOLOG 2>&1\n+\n+# Validate output from GetProcessorInfo.exe\n+processor_info_regex=\"Active processors per group: (\\\\d+,)+\"\n+grep -Po \"$processor_info_regex\" $GETPROCINFOLOG\n+status=$?\n+if [ ! $status -eq \"0\" ]; then\n+  echo \"TESTBUG: $GETPROCINFONAME did not output a processor count.\";\n+  exit 1\n+fi\n+\n+# Write the processor counts to a file\n+NATIVEPROCS=\"${TESTCLASSES}\/processor_count_native.log\"\n+grep -Po \"$processor_info_regex\" $GETPROCINFOLOG   | sed -e 's\/[a-zA-Z: \\.]\/\/g' > $NATIVEPROCS 2>&1\n+group_processor_counts_str=$(<$NATIVEPROCS)\n+IFS=, read -a group_processor_counts <<<\"$group_processor_counts_str\"\n+\n+# Find the smallest processor group because on systems with different processor\n+# group sizes, \"start \/affinity\" can still launch a process in a smaller\n+# processor group than the affinity provided via the \/affinity parameter\n+let dwNumberOfProcessors=64\n+for i in \"${group_processor_counts[@]}\"; do\n+  let group_processor_count=i\n+  echo \"Active processors in group: $group_processor_count\"\n+  if [ $group_processor_count -lt $dwNumberOfProcessors ]; then\n+    dwNumberOfProcessors=$group_processor_count\n+  fi\n+done\n+\n+if [ $dwNumberOfProcessors -le 0 ]; then\n+  echo \"Test failed: $GETPROCINFONAME did not output a valid processor count.\";\n+  exit 1\n+fi\n+\n+if [ $dwNumberOfProcessors -gt 64 ]; then\n+  echo \"Test failed: $GETPROCINFONAME returned an invalid processor count.\";\n+  exit 1\n+fi\n+\n+if [ $dwNumberOfProcessors -lt 64 ]; then\n+  let affinity=$((1 << dwNumberOfProcessors))-1\n+  affinity=$(printf \"%x\" \"$affinity\")\n+else\n+  affinity=0xffffffffffffffff\n+fi\n+\n+# Write Runtime.availableProcessors to a log file\n+javaCmdLine=\"${TESTJAVA}\/bin\/java -XX:+UseAllWindowsProcessorGroups ${TESTVMOPTS} -cp ${TESTCLASSES} $SRCFILEBASE\"\n+commandLine=\"start \/wait \/b \/affinity $affinity $javaCmdLine > $LOGFILE\"\n+\n+echo \"Executing: $commandLine\"\n+cmd \/c $commandLine\n+status=$?\n+if [ ! $status -eq \"0\" ]; then\n+  echo \"Test FAILED: $SRCFILE\";\n+  exit 1\n+fi\n+\n+# Validate output from GetAvailableProcessors.java\n+grep -Po \"Runtime\\\\.availableProcessors: \\\\d+\" $LOGFILE\n+status=$?\n+if [ ! $status -eq \"0\" ]; then\n+  echo \"TESTBUG: $SRCFILE did not output a processor count.\";\n+  exit 1\n+fi\n+\n+# Write the processor count to a file\n+JAVAPROCS=\"${TESTCLASSES}\/processor_count_java.log\"\n+grep -Po \"Runtime\\\\.availableProcessors: \\\\d+\" $LOGFILE | sed -e 's\/[a-zA-Z: \\.]\/\/g' > $JAVAPROCS 2>&1\n+runtimeAvailableProcessors=$(<$JAVAPROCS)\n+\n+# Ensure the processor counts are identical\n+\n+echo \"java.lang.Runtime.availableProcessors: $runtimeAvailableProcessors\"\n+echo \"SYSTEM_INFO.dwNumberOfProcessors:      $dwNumberOfProcessors\"\n+\n+if [ \"$runtimeAvailableProcessors\" != \"$dwNumberOfProcessors\" ]; then\n+  echo \"Test failed: Runtime.availableProcessors ($runtimeAvailableProcessors) != dwNumberOfProcessors ($dwNumberOfProcessors)\"\n+  exit 1\n+else\n+  echo \"Test passed.\"\n+fi\n","filename":"test\/hotspot\/jtreg\/runtime\/6942632\/GetAvailableProcessors.sh","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <Windows.h>\n+#include <stdio.h>\n+#include <malloc.h>\n+\n+int main()\n+{\n+  DWORD active_processor_count = GetActiveProcessorCount(ALL_PROCESSOR_GROUPS);\n+  if (active_processor_count == 0) {\n+      printf(\"GetActiveProcessorCount failed with error: %x\\n\", GetLastError());\n+      return 1;\n+  }\n+\n+  printf(\"Active processor count across all processor groups: %d\\n\", active_processor_count);\n+\n+  USHORT group_count = 0;\n+\n+  if (GetProcessGroupAffinity(GetCurrentProcess(), &group_count, NULL) == 0) {\n+    DWORD last_error = GetLastError();\n+    if (last_error == ERROR_INSUFFICIENT_BUFFER) {\n+      if (group_count == 0) {\n+        printf(\"Unexpected group count of 0 from GetProcessGroupAffinity.\\n\");\n+        return 1;\n+      }\n+    } else {\n+        printf(\"GetActiveProcessorCount failed with error: %x\\n\", GetLastError());\n+        return 1;\n+    }\n+  } else {\n+    printf(\"Unexpected GetProcessGroupAffinity success result.\\n\");\n+    return 1;\n+  }\n+\n+  PUSHORT group_array = (PUSHORT)malloc(group_count * sizeof(USHORT));\n+  if (group_array == NULL) {\n+    printf(\"malloc failed.\\n\");\n+    return 1;\n+  }\n+\n+  printf(\"Active processors per group: \");\n+  for (USHORT i=0; i < group_count; i++) {\n+    DWORD active_processors_in_group = GetActiveProcessorCount(i);\n+    if (active_processors_in_group == 0) {\n+        printf(\"GetActiveProcessorCount(%d) failed with error: %x\\n\", i, GetLastError());\n+        return 1;\n+    }\n+\n+    printf(\"%d,\", active_processors_in_group);\n+  }\n+\n+  free(group_array);\n+  return 0;\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/6942632\/exeGetProcessorInfo.c","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"}]}