{"files":[{"patch":"@@ -38,0 +38,3 @@\n+product(bool, UseAllWindowsProcessorGroups, false,                        \\\n+        \"Use all processor groups on supported Windows versions\")         \\\n+                                                                          \\\n","filename":"src\/hotspot\/os\/windows\/globals_windows.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+#include \"utilities\/population_count.hpp\"\n@@ -883,10 +884,61 @@\n-  DWORD_PTR lpProcessAffinityMask = 0;\n-  DWORD_PTR lpSystemAffinityMask = 0;\n-  int proc_count = processor_count();\n-  if (proc_count <= sizeof(UINT_PTR) * BitsPerByte &&\n-      GetProcessAffinityMask(GetCurrentProcess(), &lpProcessAffinityMask, &lpSystemAffinityMask)) {\n-    \/\/ Nof active processors is number of bits in process affinity mask\n-    int bitcount = 0;\n-    while (lpProcessAffinityMask != 0) {\n-      lpProcessAffinityMask = lpProcessAffinityMask & (lpProcessAffinityMask-1);\n-      bitcount++;\n+  bool schedules_all_processor_groups = win32::is_windows_11_or_greater() || win32::is_windows_server_2022_or_greater();\n+  if (UseAllWindowsProcessorGroups && !schedules_all_processor_groups && !win32::processor_group_warning_displayed()) {\n+    win32::set_processor_group_warning_displayed(true);\n+    FLAG_SET_DEFAULT(UseAllWindowsProcessorGroups, false);\n+    warning(\"The UseAllWindowsProcessorGroups flag is not supported on this Windows version and will be ignored.\");\n+  }\n+\n+  DWORD active_processor_groups = 0;\n+  DWORD processors_in_job_object = win32::active_processors_in_job_object(&active_processor_groups);\n+\n+  if (processors_in_job_object > 0) {\n+    if (schedules_all_processor_groups) {\n+      \/\/ If UseAllWindowsProcessorGroups is enabled then all the processors in the job object\n+      \/\/ can be used. Otherwise, we will fall through to inspecting the process affinity mask.\n+      \/\/ This will result in using only the subset of the processors in the default processor\n+      \/\/ group allowed by the job object i.e. only 1 processor group will be used and only\n+      \/\/ the processors in that group that are allowed by the job object will be used.\n+      \/\/ This preserves the behavior where older OpenJDK versions always used one processor\n+      \/\/ group regardless of whether they were launched in a job object.\n+      if (!UseAllWindowsProcessorGroups && active_processor_groups > 1) {\n+        if (!win32::job_object_processor_group_warning_displayed()) {\n+          win32::set_job_object_processor_group_warning_displayed(true);\n+          warning(\"The Windows job object has enabled multiple processor groups (%d) but the UseAllWindowsProcessorGroups flag is off. Some processors might not be used.\", active_processor_groups);\n+        }\n+      } else {\n+        return processors_in_job_object;\n+      }\n+    } else {\n+      if (active_processor_groups > 1 && !win32::job_object_processor_group_warning_displayed()) {\n+        win32::set_job_object_processor_group_warning_displayed(true);\n+        warning(\"The Windows job object has enabled multiple processor groups (%d) but only 1 is supported on this Windows version. Some processors might not be used.\", active_processor_groups);\n+      }\n+      return processors_in_job_object;\n+    }\n+  }\n+\n+  DWORD logical_processors = 0;\n+  SYSTEM_INFO si;\n+  GetSystemInfo(&si);\n+\n+  USHORT group_count = 0;\n+  bool use_process_affinity_mask = false;\n+  bool got_process_group_affinity = false;\n+\n+  if (GetProcessGroupAffinity(GetCurrentProcess(), &group_count, nullptr) == 0) {\n+    DWORD last_error = GetLastError();\n+    if (last_error == ERROR_INSUFFICIENT_BUFFER) {\n+      if (group_count > 0) {\n+        got_process_group_affinity = true;\n+\n+        if (group_count == 1) {\n+          use_process_affinity_mask = true;\n+        }\n+      } else {\n+        warning(\"Unexpected group count of 0 from GetProcessGroupAffinity.\");\n+        assert(false, \"Group count must not be 0.\");\n+      }\n+    } else {\n+      char buf[512];\n+      size_t buf_len = os::lasterror(buf, sizeof(buf));\n+      warning(\"Attempt to get process group affinity failed: %s\", buf_len != 0 ? buf : \"<unknown error>\");\n@@ -894,1 +946,0 @@\n-    return bitcount;\n@@ -896,1 +947,2 @@\n-    return proc_count;\n+    warning(\"Unexpected GetProcessGroupAffinity success result.\");\n+    assert(false, \"Unexpected GetProcessGroupAffinity success result\");\n@@ -898,0 +950,47 @@\n+\n+  \/\/ Fall back to SYSTEM_INFO.dwNumberOfProcessors if the process group affinity could not be determined.\n+  if (!got_process_group_affinity) {\n+    return si.dwNumberOfProcessors;\n+  }\n+\n+  \/\/ If the process it not in a job and the process group affinity is exactly 1 group\n+  \/\/ then get the number of available logical processors from the process affinity mask\n+  if (use_process_affinity_mask) {\n+    DWORD_PTR lpProcessAffinityMask = 0;\n+    DWORD_PTR lpSystemAffinityMask = 0;\n+    if (GetProcessAffinityMask(GetCurrentProcess(), &lpProcessAffinityMask, &lpSystemAffinityMask)) {\n+      \/\/ Number of active processors is number of bits in process affinity mask\n+      logical_processors = population_count(lpProcessAffinityMask);\n+\n+      if (logical_processors > 0) {\n+        return logical_processors;\n+      } else {\n+        \/\/ We only check the process affinity mask if GetProcessGroupAffinity determined that there was\n+        \/\/ only 1 active group. In this case, GetProcessAffinityMask will not set the affinity mask to 0.\n+        warning(\"Unexpected process affinity mask of 0 from GetProcessAffinityMask.\");\n+        assert(false, \"Found unexpected process affinity mask: 0\");\n+      }\n+    } else {\n+      char buf[512];\n+      size_t buf_len = os::lasterror(buf, sizeof(buf));\n+      warning(\"Attempt to get the process affinity mask failed: %s\", buf_len != 0 ? buf : \"<unknown error>\");\n+    }\n+\n+    \/\/ Fall back to SYSTEM_INFO.dwNumberOfProcessors if the process affinity mask could not be determined.\n+    return si.dwNumberOfProcessors;\n+  }\n+\n+  if (UseAllWindowsProcessorGroups) {\n+    \/\/ There are no processor affinity restrictions at this point so we can return\n+    \/\/ the overall processor count if the OS automatically schedules threads across\n+    \/\/ all processors on the system. Note that older operating systems can\n+    \/\/ correctly report processor count but will not schedule threads across\n+    \/\/ processor groups unless the application explicitly uses group affinity APIs\n+    \/\/ to assign threads to processor groups. On these older operating systems, we\n+    \/\/ will continue to use the dwNumberOfProcessors field.\n+    if (schedules_all_processor_groups) {\n+      logical_processors = processor_count();\n+    }\n+  }\n+\n+  return logical_processors == 0 ? si.dwNumberOfProcessors : logical_processors;\n@@ -1794,4 +1893,0 @@\n-  VS_FIXEDFILEINFO *file_info;\n-  TCHAR kernel32_path[MAX_PATH];\n-  UINT len, ret;\n-\n@@ -1800,38 +1895,4 @@\n-  \/\/ Get the full path to \\Windows\\System32\\kernel32.dll and use that for\n-  \/\/ determining what version of Windows we're running on.\n-  len = MAX_PATH - (UINT)strlen(\"\\\\kernel32.dll\") - 1;\n-  ret = GetSystemDirectory(kernel32_path, len);\n-  if (ret == 0 || ret > len) {\n-    st->print_cr(\"Call to GetSystemDirectory failed\");\n-    return;\n-  }\n-  strncat(kernel32_path, \"\\\\kernel32.dll\", MAX_PATH - ret);\n-\n-  DWORD version_size = GetFileVersionInfoSize(kernel32_path, nullptr);\n-  if (version_size == 0) {\n-    st->print_cr(\"Call to GetFileVersionInfoSize failed\");\n-    return;\n-  }\n-\n-  LPTSTR version_info = (LPTSTR)os::malloc(version_size, mtInternal);\n-  if (version_info == nullptr) {\n-    st->print_cr(\"Failed to allocate version_info\");\n-    return;\n-  }\n-\n-  if (!GetFileVersionInfo(kernel32_path, 0, version_size, version_info)) {\n-    os::free(version_info);\n-    st->print_cr(\"Call to GetFileVersionInfo failed\");\n-    return;\n-  }\n-\n-  if (!VerQueryValue(version_info, TEXT(\"\\\\\"), (LPVOID*)&file_info, &len)) {\n-    os::free(version_info);\n-    st->print_cr(\"Call to VerQueryValue failed\");\n-    return;\n-  }\n-\n-  int major_version = HIWORD(file_info->dwProductVersionMS);\n-  int minor_version = LOWORD(file_info->dwProductVersionMS);\n-  int build_number = HIWORD(file_info->dwProductVersionLS);\n-  int build_minor = LOWORD(file_info->dwProductVersionLS);\n+  int major_version = windows_major_version();\n+  int minor_version = windows_minor_version();\n+  int build_number = windows_build_number();\n+  int build_minor = windows_build_minor();\n@@ -1839,1 +1900,0 @@\n-  os::free(version_info);\n@@ -1935,0 +1995,6 @@\n+\n+    \/\/ This is the number of logical processors in the current processor group only and is therefore\n+    \/\/ at most 64. The GetLogicalProcessorInformation function is used to compute the total number\n+    \/\/ of processors. However, it requires memory to be allocated for the processor information buffer.\n+    \/\/ Since this method is used in paths where memory allocation should not be done (i.e. after a crash),\n+    \/\/ only the number of processors in the current group will be returned.\n@@ -1964,1 +2030,1 @@\n-      st->print_cr(\"Processor Information for all %d processors :\", proc_count);\n+      st->print_cr(\"Processor Information for the first %d processors :\", proc_count);\n@@ -4007,0 +4073,155 @@\n+int    os::win32::_major_version             = 0;\n+int    os::win32::_minor_version             = 0;\n+int    os::win32::_build_number              = 0;\n+int    os::win32::_build_minor               = 0;\n+\n+bool   os::win32::_processor_group_warning_displayed = false;\n+bool   os::win32::_job_object_processor_group_warning_displayed = false;\n+\n+void os::win32::initialize_windows_version() {\n+  assert(_major_version == 0, \"windows version already initialized.\");\n+\n+  VS_FIXEDFILEINFO *file_info;\n+  TCHAR kernel32_path[MAX_PATH];\n+  UINT len, ret;\n+  char error_msg_buffer[512];\n+\n+  \/\/ Get the full path to \\Windows\\System32\\kernel32.dll and use that for\n+  \/\/ determining what version of Windows we're running on.\n+  len = MAX_PATH - (UINT)strlen(\"\\\\kernel32.dll\") - 1;\n+  ret = GetSystemDirectory(kernel32_path, len);\n+  if (ret == 0 || ret > len) {\n+    size_t buf_len = os::lasterror(error_msg_buffer, sizeof(error_msg_buffer));\n+    warning(\"Attempt to determine system directory failed: %s\", buf_len != 0 ? error_msg_buffer : \"<unknown error>\");\n+    return;\n+  }\n+  strncat(kernel32_path, \"\\\\kernel32.dll\", MAX_PATH - ret);\n+\n+  DWORD version_size = GetFileVersionInfoSize(kernel32_path, nullptr);\n+  if (version_size == 0) {\n+    size_t buf_len = os::lasterror(error_msg_buffer, sizeof(error_msg_buffer));\n+    warning(\"Failed to determine whether the OS can retrieve version information from kernel32.dll: %s\", buf_len != 0 ? error_msg_buffer : \"<unknown error>\");\n+    return;\n+  }\n+\n+  LPTSTR version_info = (LPTSTR)os::malloc(version_size, mtInternal);\n+  if (version_info == nullptr) {\n+    warning(\"os::malloc() failed to allocate %ld bytes for GetFileVersionInfo buffer\", version_size);\n+    return;\n+  }\n+\n+  if (!GetFileVersionInfo(kernel32_path, 0, version_size, version_info)) {\n+    os::free(version_info);\n+    size_t buf_len = os::lasterror(error_msg_buffer, sizeof(error_msg_buffer));\n+    warning(\"Attempt to retrieve version information from kernel32.dll failed: %s\", buf_len != 0 ? error_msg_buffer : \"<unknown error>\");\n+    return;\n+  }\n+\n+  if (!VerQueryValue(version_info, TEXT(\"\\\\\"), (LPVOID*)&file_info, &len)) {\n+    os::free(version_info);\n+    size_t buf_len = os::lasterror(error_msg_buffer, sizeof(error_msg_buffer));\n+    warning(\"Attempt to determine Windows version from kernel32.dll failed: %s\", buf_len != 0 ? error_msg_buffer : \"<unknown error>\");\n+    return;\n+  }\n+\n+  _major_version = HIWORD(file_info->dwProductVersionMS);\n+  _minor_version = LOWORD(file_info->dwProductVersionMS);\n+  _build_number  = HIWORD(file_info->dwProductVersionLS);\n+  _build_minor   = LOWORD(file_info->dwProductVersionLS);\n+\n+  os::free(version_info);\n+}\n+\n+bool os::win32::is_windows_11_or_greater() {\n+  if (IsWindowsServer()) {\n+    return false;\n+  }\n+\n+  \/\/ Windows 11 starts at build 22000 (Version 21H2)\n+  return (windows_major_version() == 10 && windows_build_number() >= 22000) || (windows_major_version() > 10);\n+}\n+\n+bool os::win32::is_windows_server_2022_or_greater() {\n+  if (!IsWindowsServer()) {\n+    return false;\n+  }\n+\n+  \/\/ Windows Server 2022 starts at build 20348.169\n+  return (windows_major_version() == 10 && windows_build_number() >= 20348) || (windows_major_version() > 10);\n+}\n+\n+DWORD os::win32::active_processors_in_job_object(DWORD* active_processor_groups) {\n+  if (active_processor_groups != nullptr) {\n+    *active_processor_groups = 0;\n+  }\n+  BOOL is_in_job_object = false;\n+  if (IsProcessInJob(GetCurrentProcess(), nullptr, &is_in_job_object) == 0) {\n+    char buf[512];\n+    size_t buf_len = os::lasterror(buf, sizeof(buf));\n+    warning(\"Attempt to determine whether the process is running in a job failed: %s\", buf_len != 0 ? buf : \"<unknown error>\");\n+    return 0;\n+  }\n+\n+  if (!is_in_job_object) {\n+    return 0;\n+  }\n+\n+  DWORD processors = 0;\n+\n+  LPVOID job_object_information = nullptr;\n+  DWORD job_object_information_length = 0;\n+\n+  if (QueryInformationJobObject(nullptr, JobObjectGroupInformationEx, nullptr, 0, &job_object_information_length) != 0) {\n+    warning(\"Unexpected QueryInformationJobObject success result.\");\n+    assert(false, \"Unexpected QueryInformationJobObject success result\");\n+    return 0;\n+  }\n+\n+  DWORD last_error = GetLastError();\n+  if (last_error == ERROR_INSUFFICIENT_BUFFER) {\n+    DWORD group_count = job_object_information_length \/ sizeof(GROUP_AFFINITY);\n+\n+    job_object_information = os::malloc(job_object_information_length, mtInternal);\n+    if (job_object_information != nullptr) {\n+        if (QueryInformationJobObject(nullptr, JobObjectGroupInformationEx, job_object_information, job_object_information_length, &job_object_information_length) != 0) {\n+          DWORD groups_found = job_object_information_length \/ sizeof(GROUP_AFFINITY);\n+          if (groups_found != group_count) {\n+            warning(\"Unexpected processor group count: %ld. Expected %ld processor groups.\", groups_found, group_count);\n+            assert(false, \"Unexpected group count\");\n+          }\n+\n+          GROUP_AFFINITY* group_affinity_data = ((GROUP_AFFINITY*)job_object_information);\n+          for (DWORD i = 0; i < groups_found; i++, group_affinity_data++) {\n+            DWORD processors_in_group = population_count(group_affinity_data->Mask);\n+            processors += processors_in_group;\n+            if (active_processor_groups != nullptr && processors_in_group > 0) {\n+              (*active_processor_groups)++;\n+            }\n+          }\n+\n+          if (processors == 0) {\n+            warning(\"Could not determine processor count from the job object.\");\n+            assert(false, \"Must find at least 1 logical processor\");\n+          }\n+        } else {\n+          char buf[512];\n+          size_t buf_len = os::lasterror(buf, sizeof(buf));\n+          warning(\"Attempt to query job object information failed: %s\", buf_len != 0 ? buf : \"<unknown error>\");\n+        }\n+\n+        os::free(job_object_information);\n+    } else {\n+        warning(\"os::malloc() failed to allocate %ld bytes for QueryInformationJobObject\", job_object_information_length);\n+    }\n+  } else {\n+    char buf[512];\n+    size_t buf_len = os::lasterror(buf, sizeof(buf));\n+    warning(\"Attempt to query job object information failed: %s\", buf_len != 0 ? buf : \"<unknown error>\");\n+    assert(false, \"Unexpected QueryInformationJobObject error code\");\n+    return 0;\n+  }\n+\n+  log_debug(os)(\"Process is running in a job with %d active processors.\", processors);\n+  return processors;\n+}\n+\n@@ -4014,1 +4235,14 @@\n-  set_processor_count(si.dwNumberOfProcessors);\n+\n+  DWORD processors = 0;\n+  bool schedules_all_processor_groups = win32::is_windows_11_or_greater() || win32::is_windows_server_2022_or_greater();\n+  if (schedules_all_processor_groups) {\n+    processors = GetActiveProcessorCount(ALL_PROCESSOR_GROUPS);\n+    if (processors == 0) {\n+      char buf[512];\n+      size_t buf_len = os::lasterror(buf, sizeof(buf));\n+      warning(\"Attempt to determine the processor count from GetActiveProcessorCount() failed: %s\", buf_len != 0 ? buf : \"<unknown error>\");\n+      assert(false, \"Must find at least 1 logical processor\");\n+    }\n+  }\n+\n+  set_processor_count(processors > 0 ? processors : si.dwNumberOfProcessors);\n@@ -4323,0 +4557,1 @@\n+  win32::initialize_windows_version();\n@@ -4369,0 +4604,6 @@\n+  const char* auto_schedules_message = \"Host Windows OS automatically schedules threads across all processor groups.\";\n+  const char* no_auto_schedules_message = \"Host Windows OS does not automatically schedule threads across all processor groups.\";\n+\n+  bool schedules_all_processor_groups = win32::is_windows_11_or_greater() || win32::is_windows_server_2022_or_greater();\n+  log_debug(os)(schedules_all_processor_groups ? auto_schedules_message : no_auto_schedules_message);\n+  log_debug(os)(\"%d logical processors found.\", processor_count());\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":298,"deletions":57,"binary":false,"changes":355,"status":"modified"},{"patch":"@@ -46,0 +46,7 @@\n+  static bool   _processor_group_warning_displayed;\n+  static bool   _job_object_processor_group_warning_displayed;\n+\n+  static int    _major_version;\n+  static int    _minor_version;\n+  static int    _build_number;\n+  static int    _build_minor;\n@@ -59,0 +66,31 @@\n+  static bool   is_windows_11_or_greater();\n+  static bool   is_windows_server_2022_or_greater();\n+  static int windows_major_version() {\n+    assert(_major_version > 0, \"windows version not initialized.\");\n+    return _major_version;\n+  }\n+  static int windows_minor_version() {\n+    assert(_major_version > 0, \"windows version not initialized.\");\n+    return _minor_version;\n+  }\n+  static int windows_build_number() {\n+    assert(_major_version > 0, \"windows version not initialized.\");\n+    return _build_number;\n+  }\n+  static int windows_build_minor() {\n+    assert(_major_version > 0, \"windows version not initialized.\");\n+    return _build_minor;\n+  }\n+\n+  static void set_processor_group_warning_displayed(bool displayed)  {\n+    _processor_group_warning_displayed = displayed;\n+  }\n+  static bool processor_group_warning_displayed() {\n+    return _processor_group_warning_displayed;\n+  }\n+  static void set_job_object_processor_group_warning_displayed(bool displayed)  {\n+    _job_object_processor_group_warning_displayed = displayed;\n+  }\n+  static bool job_object_processor_group_warning_displayed() {\n+    return _job_object_processor_group_warning_displayed;\n+  }\n@@ -75,0 +113,2 @@\n+  static void initialize_windows_version();\n+  static DWORD active_processors_in_job_object(DWORD* active_processor_groups = nullptr);\n","filename":"src\/hotspot\/os\/windows\/os_windows.hpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -706,0 +706,19 @@\n+TEST_VM(os_windows, processor_count) {\n+  JVMFlag* flag = JVMFlag::find_flag(\"UseAllWindowsProcessorGroups\");\n+  EXPECT_NE(flag, nullptr) << \"Expected UseAllWindowsProcessorGroups product flag to be available\";\n+\n+  int processors = os::processor_count();\n+  EXPECT_GT(processors, 0) << \"Expected at least 1 processor\";\n+\n+  int active_processors = os::active_processor_count();\n+  EXPECT_GT(active_processors, 0) << \"Expected at least 1 active processor\";\n+\n+  bool schedules_all_processor_groups = os::win32::is_windows_11_or_greater() || os::win32::is_windows_server_2022_or_greater();\n+  if (schedules_all_processor_groups && UseAllWindowsProcessorGroups) {\n+    EXPECT_EQ(active_processors, processors) << \"Expected all processors to be active\";\n+  } else {\n+    \/\/ active_processors should be at most the number of processors in 1 Windows processor group.\n+    EXPECT_LE(active_processors, processors) << \"Expected active processors to not exceed available processors\";\n+  }\n+}\n+\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_windows.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -149,0 +149,1 @@\n+  gtest\/WindowsProcessorGroups.java\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * This runs the os related gtests on Windows with all processor groups enabled.\n+ *\/\n+\n+\/* @test id=use-all-windows-processor-groups\n+ * @summary Run gtests with all Windows processor groups enabled\n+ * @library \/test\/lib\n+ * @requires os.family == \"windows\"\n+ * @run main\/native GTestWrapper --gtest_filter=os* -XX:+UseAllWindowsProcessorGroups\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gtest\/WindowsProcessorGroups.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+public class GetAvailableProcessors {\n+  public static void main(String[] args) {\n+    System.out.println(\"Runtime.availableProcessors: \" + Runtime.getRuntime().availableProcessors());\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/6942632\/GetAvailableProcessors.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,159 @@\n+#\n+# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# @test\n+# @bug 6942632\n+# @summary This test ensures that OpenJDK respects the process affinity\n+#          masks set when launched from the Windows command prompt using\n+#          \"start \/affinity HEXAFFINITY java.exe\" when the\n+#          UseAllWindowsProcessorGroups flag is enabled.\n+\n+OS=`uname -s`\n+case \"$OS\" in\n+  Windows* | CYGWIN* )\n+    ;;\n+  * )\n+    echo \"Cannot run a Windows-specific test on $OS\"\n+    exit 1\n+    ;;\n+esac\n+\n+if [ \"${TESTSRC}\" = \"\" ]\n+then\n+  echo \"TESTSRC not set. Test cannot execute.\"\n+  exit 1\n+fi\n+\n+if [ \"${TESTNATIVEPATH}\" = \"\" ]\n+then\n+  echo \"TESTNATIVEPATH not set. Test cannot execute.\"\n+  exit 1\n+fi\n+\n+if [ -z \"${TESTCLASSES}\" ]; then\n+  echo \"TESTCLASSES undefined: defaulting to .\"\n+  TESTCLASSES=.\n+fi\n+\n+echo \"TESTCLASSES:    $TESTCLASSES\"\n+echo \"TESTJAVACOPTS:  $TESTJAVACOPTS\"\n+echo \"TESTTOOLVMOPTS: $TESTTOOLVMOPTS\"\n+\n+JAVAC=\"${TESTJAVA}\/bin\/javac\"\n+\n+SRCFILEBASE=GetAvailableProcessors\n+SRCFILE=\"${TESTSRC}\/$SRCFILEBASE.java\"\n+LOGFILE=\"${TESTCLASSES}\/$SRCFILEBASE.output.log\"\n+$JAVAC ${TESTJAVACOPTS} ${TESTTOOLVMOPTS} -d ${TESTCLASSES} $SRCFILE\n+\n+status=$?\n+if [ ! $status -eq \"0\" ]; then\n+  echo \"Compilation failed: $SRCFILE\";\n+  exit 1\n+fi\n+\n+# Write SYSTEM_INFO.dwNumberOfProcessors to a log file\n+GETPROCINFONAME=GetProcessorInfo\n+GETPROCINFOLOG=\"${TESTCLASSES}\/$GETPROCINFONAME.output.log\"\n+${TESTNATIVEPATH}\/$GETPROCINFONAME > $GETPROCINFOLOG 2>&1\n+\n+# Validate output from GetProcessorInfo.exe\n+processor_info_regex=\"Active processors per group: (\\\\d+,)+\"\n+grep -Po \"$processor_info_regex\" $GETPROCINFOLOG\n+status=$?\n+if [ ! $status -eq \"0\" ]; then\n+  echo \"TESTBUG: $GETPROCINFONAME did not output a processor count.\";\n+  exit 1\n+fi\n+\n+# Write the processor counts to a file\n+NATIVEPROCS=\"${TESTCLASSES}\/processor_count_native.log\"\n+grep -Po \"$processor_info_regex\" $GETPROCINFOLOG   | sed -e 's\/[a-zA-Z: \\.]\/\/g' > $NATIVEPROCS 2>&1\n+group_processor_counts_str=$(<$NATIVEPROCS)\n+IFS=, read -a group_processor_counts <<<\"$group_processor_counts_str\"\n+\n+# Find the smallest processor group because on systems with different processor\n+# group sizes, \"start \/affinity\" can still launch a process in a smaller\n+# processor group than the affinity provided via the \/affinity parameter\n+let dwNumberOfProcessors=64\n+for i in \"${group_processor_counts[@]}\"; do\n+  let group_processor_count=i\n+  echo \"Active processors in group: $group_processor_count\"\n+  if [ $group_processor_count -lt $dwNumberOfProcessors ]; then\n+    dwNumberOfProcessors=$group_processor_count\n+  fi\n+done\n+\n+if [ $dwNumberOfProcessors -le 0 ]; then\n+  echo \"Test failed: $GETPROCINFONAME did not output a valid processor count.\";\n+  exit 1\n+fi\n+\n+if [ $dwNumberOfProcessors -gt 64 ]; then\n+  echo \"Test failed: $GETPROCINFONAME returned an invalid processor count.\";\n+  exit 1\n+fi\n+\n+if [ $dwNumberOfProcessors -lt 64 ]; then\n+  let affinity=$((1 << dwNumberOfProcessors))-1\n+  affinity=$(printf \"%x\" \"$affinity\")\n+else\n+  affinity=0xffffffffffffffff\n+fi\n+\n+# Write Runtime.availableProcessors to a log file\n+javaCmdLine=\"${TESTJAVA}\/bin\/java -XX:+UseAllWindowsProcessorGroups ${TESTVMOPTS} -cp ${TESTCLASSES} $SRCFILEBASE\"\n+commandLine=\"start \/wait \/b \/affinity $affinity $javaCmdLine > $LOGFILE\"\n+\n+echo \"Executing: $commandLine\"\n+cmd \/c $commandLine\n+status=$?\n+if [ ! $status -eq \"0\" ]; then\n+  echo \"Test FAILED: $SRCFILE\";\n+  exit 1\n+fi\n+\n+# Validate output from GetAvailableProcessors.java\n+grep -Po \"Runtime\\\\.availableProcessors: \\\\d+\" $LOGFILE\n+status=$?\n+if [ ! $status -eq \"0\" ]; then\n+  echo \"TESTBUG: $SRCFILE did not output a processor count.\";\n+  exit 1\n+fi\n+\n+# Write the processor count to a file\n+JAVAPROCS=\"${TESTCLASSES}\/processor_count_java.log\"\n+grep -Po \"Runtime\\\\.availableProcessors: \\\\d+\" $LOGFILE | sed -e 's\/[a-zA-Z: \\.]\/\/g' > $JAVAPROCS 2>&1\n+runtimeAvailableProcessors=$(<$JAVAPROCS)\n+\n+# Ensure the processor counts are identical\n+\n+echo \"java.lang.Runtime.availableProcessors: $runtimeAvailableProcessors\"\n+echo \"SYSTEM_INFO.dwNumberOfProcessors:      $dwNumberOfProcessors\"\n+\n+if [ \"$runtimeAvailableProcessors\" != \"$dwNumberOfProcessors\" ]; then\n+  echo \"Test failed: Runtime.availableProcessors ($runtimeAvailableProcessors) != dwNumberOfProcessors ($dwNumberOfProcessors)\"\n+  exit 1\n+else\n+  echo \"Test passed.\"\n+fi\n","filename":"test\/hotspot\/jtreg\/runtime\/6942632\/GetAvailableProcessors.sh","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <Windows.h>\n+#include <stdio.h>\n+#include <malloc.h>\n+\n+int main()\n+{\n+  DWORD active_processor_count = GetActiveProcessorCount(ALL_PROCESSOR_GROUPS);\n+  if (active_processor_count == 0) {\n+      printf(\"GetActiveProcessorCount failed with error: %x\\n\", GetLastError());\n+      return 1;\n+  }\n+\n+  printf(\"Active processor count across all processor groups: %d\\n\", active_processor_count);\n+\n+  USHORT group_count = 0;\n+\n+  if (GetProcessGroupAffinity(GetCurrentProcess(), &group_count, NULL) == 0) {\n+    DWORD last_error = GetLastError();\n+    if (last_error == ERROR_INSUFFICIENT_BUFFER) {\n+      if (group_count == 0) {\n+        printf(\"Unexpected group count of 0 from GetProcessGroupAffinity.\\n\");\n+        return 1;\n+      }\n+    } else {\n+        printf(\"GetActiveProcessorCount failed with error: %x\\n\", GetLastError());\n+        return 1;\n+    }\n+  } else {\n+    printf(\"Unexpected GetProcessGroupAffinity success result.\\n\");\n+    return 1;\n+  }\n+\n+  PUSHORT group_array = (PUSHORT)malloc(group_count * sizeof(USHORT));\n+  if (group_array == NULL) {\n+    printf(\"malloc failed.\\n\");\n+    return 1;\n+  }\n+\n+  printf(\"Active processors per group: \");\n+  for (USHORT i=0; i < group_count; i++) {\n+    DWORD active_processors_in_group = GetActiveProcessorCount(i);\n+    if (active_processors_in_group == 0) {\n+        printf(\"GetActiveProcessorCount(%d) failed with error: %x\\n\", i, GetLastError());\n+        return 1;\n+    }\n+\n+    printf(\"%d,\", active_processors_in_group);\n+  }\n+\n+  free(group_array);\n+  return 0;\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/6942632\/exeGetProcessorInfo.c","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"}]}