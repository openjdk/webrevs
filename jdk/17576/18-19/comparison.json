{"files":[{"patch":"@@ -1515,1 +1515,1 @@\n-  BUILD_HOTSPOT_JTREG_EXCLUDE += libNativeException.c\n+  BUILD_HOTSPOT_JTREG_EXCLUDE += libNativeException.c exeGetProcessorInfo.c\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,176 +0,0 @@\n-#\n-# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-# @test\n-# @bug 6942632\n-# @requires os.family == \"windows\"\n-# @summary This test ensures that OpenJDK respects the process affinity\n-#          masks set when launched from the Windows command prompt using\n-#          \"start \/affinity HEXAFFINITY java.exe\" when the\n-#          UseAllWindowsProcessorGroups flag is enabled.\n-\n-system_root=$SystemRoot\n-if [ \"${system_root}\" = \"\" ]\n-then\n-  echo \"SystemRoot environment variable not set. Checking SYSTEMROOT environment variable.\"\n-  system_root=$SYSTEMROOT\n-fi\n-\n-if [ \"${system_root}\" = \"\" ]\n-then\n-  echo \"The SystemRoot environment variable needs to be set. Test cannot execute.\"\n-  exit 1\n-fi\n-\n-if [ \"${TESTSRC}\" = \"\" ]\n-then\n-  echo \"TESTSRC not set. Test cannot execute.\"\n-  exit 1\n-fi\n-\n-if [ \"${TESTNATIVEPATH}\" = \"\" ]\n-then\n-  echo \"TESTNATIVEPATH not set. Test cannot execute.\"\n-  exit 1\n-fi\n-\n-if [ -z \"${TESTCLASSES}\" ]; then\n-  echo \"TESTCLASSES undefined: defaulting to .\"\n-  TESTCLASSES=.\n-fi\n-\n-echo \"TESTCLASSES:    $TESTCLASSES\"\n-echo \"TESTJAVACOPTS:  $TESTJAVACOPTS\"\n-echo \"TESTTOOLVMOPTS: $TESTTOOLVMOPTS\"\n-\n-javac=\"${TESTJAVA}\/bin\/javac${EXE_SUFFIX}\"\n-\n-src_file_base=GetAvailableProcessors\n-src_file=\"${TESTSRC}\/$src_file_base.java\"\n-log_file=\"$src_file_base.output.log\"\n-$javac ${TESTJAVACOPTS} ${TESTTOOLVMOPTS} -d ${TESTCLASSES} $src_file\n-\n-status=$?\n-if [ ! $status -eq \"0\" ]; then\n-  echo \"Compilation failed: $src_file\";\n-  exit 1\n-fi\n-\n-# Write processor information from Windows APIs to a log file\n-get_proc_info_name=\"GetProcessorInfo${EXE_SUFFIX}\"\n-get_proc_info_path=\"${TESTNATIVEPATH}\/${get_proc_info_name}\"\n-get_proc_info_log=\"$get_proc_info_name.output.log\"\n-$get_proc_info_path > $get_proc_info_log 2>&1\n-\n-status=$?\n-if [ ! $status -eq \"0\" ]; then\n-  echo \"Could not launch $get_proc_info_path\";\n-  exit 1\n-fi\n-\n-# Validate output from GetProcessorInfo.exe\n-unsupported_os_regex=\"Unsupported OS\\\\.\"\n-grep -Po \"$unsupported_os_regex\" $get_proc_info_log\n-status=$?\n-if [ $status -eq \"0\" ]; then\n-  echo \"Test skipped: Unsupported Windows version.\";\n-  exit 0\n-fi\n-\n-processor_info_regex=\"Active processors per group: (\\\\d+,)+\"\n-grep -Po \"$processor_info_regex\" $get_proc_info_log\n-status=$?\n-if [ ! $status -eq \"0\" ]; then\n-  echo \"TESTBUG: $get_proc_info_path did not output a processor count.\";\n-  exit 1\n-fi\n-\n-# Write the processor counts to a file\n-native_procs=\"${TESTCLASSES}\/processor_count_native.log\"\n-grep -Po \"$processor_info_regex\" $get_proc_info_log   | sed -e 's\/[a-zA-Z: \\.]\/\/g' > $native_procs 2>&1\n-group_processor_counts_str=$(<$native_procs)\n-IFS=, read -a group_processor_counts <<<\"$group_processor_counts_str\"\n-\n-# Find the smallest processor group because on systems with different processor\n-# group sizes, \"start \/affinity\" can still launch a process in a smaller\n-# processor group than the affinity provided via the \/affinity parameter\n-let num_processors=64\n-for i in \"${group_processor_counts[@]}\"; do\n-  let group_processor_count=i\n-  echo \"Active processors in group: $group_processor_count\"\n-  if [ $group_processor_count -lt $num_processors ]; then\n-    num_processors=$group_processor_count\n-  fi\n-done\n-\n-if [ $num_processors -le 0 ]; then\n-  echo \"Test failed: $get_proc_info_name did not output a valid processor count.\";\n-  exit 1\n-fi\n-\n-if [ $num_processors -gt 64 ]; then\n-  echo \"Test failed: $get_proc_info_name returned an invalid processor count.\";\n-  exit 1\n-fi\n-\n-if [ $num_processors -lt 64 ]; then\n-  let affinity=$((1 << num_processors))-1\n-  affinity=$(printf \"%x\" \"$affinity\")\n-else\n-  affinity=0xffffffffffffffff\n-fi\n-\n-# Write Runtime.availableProcessors to a log file\n-java_cmd_line=\"${TESTJAVA}\/bin\/java -XX:+UseAllWindowsProcessorGroups ${TESTVMOPTS} -cp ${TESTCLASSES} $src_file_base\"\n-cmd_line=\"$system_root\/System32\/cmd.exe \/\/c start \/\/wait \/\/b \/\/affinity $affinity $java_cmd_line > $log_file\"\n-\n-echo \"Executing: $cmd_line\"\n-$cmd_line\n-status=$?\n-if [ ! $status -eq \"0\" ]; then\n-  echo \"Test FAILED: $src_file\";\n-  exit 1\n-fi\n-\n-# Validate output from GetAvailableProcessors.java\n-available_processors_regex=\"Runtime\\\\.availableProcessors: \\\\d+\"\n-grep -Po \"$available_processors_regex\" $log_file\n-status=$?\n-if [ ! $status -eq \"0\" ]; then\n-  echo \"TESTBUG: $src_file did not output a processor count.\";\n-  exit 1\n-fi\n-\n-# Write the processor count to a file\n-java_procs_log=\"${TESTCLASSES}\/processor_count_java.log\"\n-grep -Po \"$available_processors_regex\" $log_file | sed -e 's\/[a-zA-Z: \\.]\/\/g' > $java_procs_log 2>&1\n-java_runtime_processors=$(<$java_procs_log)\n-\n-# Ensure the processor counts are identical\n-\n-if [ \"$java_runtime_processors\" != \"$num_processors\" ]; then\n-  echo \"Test failed: Runtime.availableProcessors ($java_runtime_processors) != Processor count in smallest group ($num_processors)\"\n-  exit 1\n-fi\n-\n-echo \"Test passed.\"\n","filename":"test\/hotspot\/jtreg\/runtime\/6942632\/GetAvailableProcessors.sh","additions":0,"deletions":176,"binary":false,"changes":176,"status":"deleted"},{"patch":"","filename":"test\/hotspot\/jtreg\/runtime\/os\/windows\/GetAvailableProcessors.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/hotspot\/jtreg\/runtime\/6942632\/GetAvailableProcessors.java","status":"renamed"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6942632\n+ * @requires os.family == \"windows\"\n+ * @summary This test verifies that OpenJDK can use all available\n+ *          processors on Windows 11\/Windows Server 2022 and later.\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @compile GetAvailableProcessors.java\n+ * @run testng TestAvailableProcessors\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+public class TestAvailableProcessors {\n+\n+    private static final String totalProcessorCountMessage = \"Active processor count across all processor groups: \";\n+    private static final String processorCountPerGroupMessage = \"Active processors per group: \";\n+    private static final String isWindowsServerMessage = \"IsWindowsServer: \";\n+\n+    private static final String runtimeAvailableProcessorsMessage = \"Runtime.availableProcessors: \";\n+    private static final String osVersionMessage = \"OS Version: \";\n+    private static final String unsupportedPlatformMessage = \"The UseAllWindowsProcessorGroups flag is not supported on this Windows version and will be ignored.\";\n+\n+    private static String getWindowsVersion() throws IOException {\n+        String systeminfoPath = \"systeminfo.exe\";\n+\n+        var processBuilder = new ProcessBuilder(systeminfoPath);\n+        OutputAnalyzer outputAnalyzer = new OutputAnalyzer(processBuilder.start());\n+        outputAnalyzer.shouldHaveExitValue(0);\n+        outputAnalyzer.shouldContain(osVersionMessage);\n+        List<String> lines = outputAnalyzer.stdoutAsLines();\n+\n+        String osVersion = null;\n+        for (var line: lines) {\n+            if (line.startsWith(osVersionMessage)) {\n+                osVersion = line.substring(osVersionMessage.length()).trim();\n+                break;\n+            }\n+        }\n+\n+        System.out.println(\"Found OS version: \" + osVersion);\n+        return osVersion;\n+    }\n+\n+    private static boolean getSchedulesAllProcessorGroups(boolean isWindowsServer) throws IOException {\n+        String windowsVer = getWindowsVersion();\n+        String[] parts = windowsVer.split(\" \");\n+        String[] versionParts = parts[0].split(\"\\\\.\");\n+\n+        if (versionParts.length != 3) {\n+            throw new RuntimeException(\"Unexpected Windows version format.\");\n+        }\n+\n+        int major = Integer.parseInt(versionParts[0]);\n+        int minor = Integer.parseInt(versionParts[1]);\n+        int build = Integer.parseInt(versionParts[2]);\n+\n+        if (major > 10) {\n+            return true;\n+        }\n+\n+        if (major < 10) {\n+            return false;\n+        }\n+\n+        if (minor > 0) {\n+            return true;\n+        }\n+\n+        if (isWindowsServer) {\n+            return build >= 20348;\n+        } else {\n+            return build >= 22000;\n+        }\n+    }\n+\n+    private static OutputAnalyzer getAvailableProcessorsOutput(boolean productFlagEnabled) throws IOException {\n+        String productFlag = productFlagEnabled ? \"-XX:+UseAllWindowsProcessorGroups\" : \"-XX:-UseAllWindowsProcessorGroups\";\n+\n+        ProcessBuilder processBuilder = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            new String[] {productFlag, \"GetAvailableProcessors\"}\n+        );\n+\n+        var output = new OutputAnalyzer(processBuilder.start());\n+        output.shouldHaveExitValue(0);\n+        output.shouldContain(runtimeAvailableProcessorsMessage);\n+\n+        return output;\n+    }\n+\n+    private static int getAvailableProcessors(OutputAnalyzer outputAnalyzer) {\n+        int runtimeAvailableProcs = 0;\n+        List<String> output = outputAnalyzer.stdoutAsLines();\n+\n+        for (var line: output) {\n+            if (line.startsWith(runtimeAvailableProcessorsMessage)) {\n+                String runtimeAvailableProcsStr = line.substring(runtimeAvailableProcessorsMessage.length());\n+                runtimeAvailableProcs = Integer.parseInt(runtimeAvailableProcsStr);\n+            }\n+        }\n+\n+        return runtimeAvailableProcs;\n+    }\n+\n+    private static int getAvailableProcessors(boolean productFlagEnabled) throws IOException {\n+        OutputAnalyzer outputAnalyzer = getAvailableProcessorsOutput(productFlagEnabled);\n+        return getAvailableProcessors(outputAnalyzer);\n+    }\n+\n+    private static void verifyAvailableProcessorsWithDisabledProductFlag(Set<Integer> processorGroupSizes) throws IOException {\n+        boolean productFlagEnabled = false;\n+        int runtimeAvailableProcs = getAvailableProcessors(productFlagEnabled);\n+\n+        String error = String.format(\"Runtime.availableProcessors (%d) is not a valid processor group size on this machine.\", runtimeAvailableProcs);\n+        Assert.assertTrue(processorGroupSizes.contains(runtimeAvailableProcs), error);\n+    }\n+\n+    private static void verifyAvailableProcessorsWithEnabledProductFlag(boolean schedulesAllProcessorGroups, int totalProcessorCount, Set<Integer> processorGroupSizes) throws IOException {\n+        boolean productFlagEnabled = true;\n+\n+        OutputAnalyzer outputAnalyzer = getAvailableProcessorsOutput(productFlagEnabled);\n+        int runtimeAvailableProcs = getAvailableProcessors(outputAnalyzer);\n+\n+        if (schedulesAllProcessorGroups) {\n+            String error = String.format(\"Runtime.availableProcessors (%d) is not equal to the expected total processor count (%d)\", runtimeAvailableProcs, totalProcessorCount);\n+            Assert.assertEquals(runtimeAvailableProcs, totalProcessorCount, error);\n+        } else {\n+            outputAnalyzer.shouldContain(unsupportedPlatformMessage);\n+\n+            String error = String.format(\"Runtime.availableProcessors (%d) is not a valid processor group size on this machine.\", runtimeAvailableProcs);\n+            Assert.assertTrue(processorGroupSizes.contains(runtimeAvailableProcs), error);\n+        }\n+    }\n+\n+    @Test\n+    private static void testProcessorAvailability() throws IOException {\n+        \/\/ Launch GetProcessorInfo.exe to gather processor counts\n+        Path nativeGetProcessorInfo = Paths.get(Utils.TEST_NATIVE_PATH)\n+            .resolve(\"GetProcessorInfo.exe\")\n+            .toAbsolutePath();\n+\n+        var processBuilder = new ProcessBuilder(nativeGetProcessorInfo.toString());\n+        var outputAnalyzer= new OutputAnalyzer(processBuilder.start());\n+        outputAnalyzer.shouldHaveExitValue(0);\n+        outputAnalyzer.shouldContain(totalProcessorCountMessage);\n+        outputAnalyzer.shouldContain(processorCountPerGroupMessage);\n+        outputAnalyzer.shouldContain(isWindowsServerMessage);\n+\n+        int totalProcessorCount = 0;\n+        boolean isWindowsServer = false;\n+        var processorGroupSizes = new HashSet<Integer>();\n+\n+        List<String> lines = outputAnalyzer.stdoutAsLines();\n+\n+        for (var line: lines) {\n+            if (line.startsWith(totalProcessorCountMessage)) {\n+                String totalProcessorCountStr = line.substring(totalProcessorCountMessage.length());\n+                totalProcessorCount = Integer.parseInt(totalProcessorCountStr);\n+            } else if (line.startsWith(processorCountPerGroupMessage)) {\n+                String processorCountPerGroupStr = line.substring(processorCountPerGroupMessage.length());\n+                String[] processorCountsPerGroup = processorCountPerGroupStr.split(\",\");\n+\n+                for (var processorCountStr: processorCountsPerGroup) {\n+                    int processorCount = Integer.parseInt(processorCountStr);\n+                    processorGroupSizes.add(processorCount);\n+                }\n+            } else if (line.startsWith(isWindowsServerMessage)) {\n+                String isWindowsServerStr = line.substring(isWindowsServerMessage.length());\n+                isWindowsServer = Integer.parseInt(isWindowsServerStr) > 0;\n+            }\n+        }\n+\n+        \/\/ Launch java without the start command and with the product flag disabled\n+        verifyAvailableProcessorsWithDisabledProductFlag(processorGroupSizes);\n+\n+        \/\/ Launch java without the start command and with the product flag enabled\n+        boolean schedulesAllProcessorGroups = getSchedulesAllProcessorGroups(isWindowsServer);\n+        verifyAvailableProcessorsWithEnabledProductFlag(schedulesAllProcessorGroups, totalProcessorCount, processorGroupSizes);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/windows\/TestAvailableProcessors.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -24,1 +24,0 @@\n-#ifdef _WIN64\n@@ -27,1 +26,1 @@\n-#endif\n+#include <versionhelpers.h>\n@@ -32,1 +31,0 @@\n-#ifdef _WIN64\n@@ -39,0 +37,1 @@\n+  printf(\"IsWindowsServer: %d\\n\", IsWindowsServer() ? 1 : 0);\n@@ -78,3 +77,0 @@\n-#else\n-  printf(\"Unsupported OS.\");\n-#endif\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/windows\/exeGetProcessorInfo.c","additions":2,"deletions":6,"binary":false,"changes":8,"previous_filename":"test\/hotspot\/jtreg\/runtime\/6942632\/exeGetProcessorInfo.c","status":"renamed"}]}