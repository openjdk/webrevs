{"files":[{"patch":"@@ -80,3 +80,2 @@\n-\/\/ Scavenges a single oop in a ClassLoaderData.\n-class PSScavengeFromCLDClosure: public OopClosure {\n-private:\n+\/\/ Scavenges the oop in a ClassLoaderData.\n+class PSScavengeCLDClosure: public CLDClosure {\n@@ -84,3 +83,0 @@\n-  \/\/ Used to redirty a scanned cld if it has oops\n-  \/\/ pointing to the young generation after being scanned.\n-  ClassLoaderData*    _scanned_cld;\n@@ -88,7 +84,1 @@\n-  PSScavengeFromCLDClosure(PSPromotionManager* pm) : _pm(pm), _scanned_cld(nullptr) { }\n-  void do_oop(narrowOop* p) { ShouldNotReachHere(); }\n-  void do_oop(oop* p)       {\n-    ParallelScavengeHeap* psh = ParallelScavengeHeap::heap();\n-    assert(!psh->is_in_reserved(p), \"GC barrier needed\");\n-    if (PSScavenge::should_scavenge(p)) {\n-      assert(PSScavenge::should_scavenge(p, true), \"revisiting object?\");\n+  PSScavengeCLDClosure(PSPromotionManager* pm) : _pm(pm) { }\n@@ -96,7 +86,5 @@\n-      oop o = RawAccess<IS_NOT_NULL>::oop_load(p);\n-      oop new_obj = _pm->copy_to_survivor_space<\/*promote_immediately=*\/false>(o);\n-      RawAccess<IS_NOT_NULL>::oop_store(p, new_obj);\n-\n-      if (PSScavenge::is_obj_in_young(new_obj)) {\n-        do_cld_barrier();\n-      }\n+  void do_cld(ClassLoaderData* cld) {\n+    \/\/ If the cld has not been dirtied we know that there are\n+    \/\/ no references into the young gen, so we can skip it.\n+    if (!cld->has_modified_oops()) {\n+      return;\n@@ -104,1 +92,0 @@\n-  }\n@@ -106,4 +93,3 @@\n-  void set_scanned_cld(ClassLoaderData* cld) {\n-    assert(_scanned_cld == nullptr || cld == nullptr, \"Should always only handling one cld at a time\");\n-    _scanned_cld = cld;\n-  }\n+    \/\/ Scavenges a single oop in a ClassLoaderData.\n+    class CLDOopClosure : public OopClosure {\n+      PSPromotionManager* _pm;\n@@ -111,6 +97,3 @@\n-private:\n-  void do_cld_barrier() {\n-    assert(_scanned_cld != nullptr, \"Should not be called without having a scanned cld\");\n-    _scanned_cld->record_modified_oops();\n-  }\n-};\n+    public:\n+      \/\/ Records whether this CLD contains oops pointing into young-gen after scavenging.\n+      bool _has_oop_into_young_gen;\n@@ -118,9 +101,8 @@\n-\/\/ Scavenges the oop in a ClassLoaderData.\n-class PSScavengeCLDClosure: public CLDClosure {\n-private:\n-  PSScavengeFromCLDClosure _oop_closure;\n-public:\n-  PSScavengeCLDClosure(PSPromotionManager* pm) : _oop_closure(pm) { }\n-  void do_cld(ClassLoaderData* cld) {\n-    \/\/ If the cld has not been dirtied we know that there's\n-    \/\/ no references into  the young gen and we can skip it.\n+      CLDOopClosure(PSPromotionManager* pm) : _pm(pm), _has_oop_into_young_gen(false) {}\n+\n+      void do_oop(narrowOop* p) { ShouldNotReachHere(); }\n+      void do_oop(oop* p) {\n+        ParallelScavengeHeap* psh = ParallelScavengeHeap::heap();\n+        assert(!psh->is_in_reserved(p), \"GC barrier needed\");\n+        if (PSScavenge::should_scavenge(p)) {\n+          assert(PSScavenge::should_scavenge(p, true), \"revisiting object?\");\n@@ -128,4 +110,10 @@\n-    if (cld->has_modified_oops()) {\n-      \/\/ Setup the promotion manager to redirty this cld\n-      \/\/ if references are left in the young gen.\n-      _oop_closure.set_scanned_cld(cld);\n+          oop o = RawAccess<IS_NOT_NULL>::oop_load(p);\n+          oop new_obj = _pm->copy_to_survivor_space<\/*promote_immediately=*\/false>(o);\n+          RawAccess<IS_NOT_NULL>::oop_store(p, new_obj);\n+\n+          if (PSScavenge::is_obj_in_young(new_obj) && !_has_oop_into_young_gen) {\n+            _has_oop_into_young_gen = true;\n+          }\n+        }\n+      }\n+    } oop_closure{_pm};\n@@ -133,2 +121,2 @@\n-      \/\/ Clean the cld since we're going to scavenge all the metadata.\n-      cld->oops_do(&_oop_closure, ClassLoaderData::_claim_none, \/*clear_modified_oops*\/true);\n+    \/\/ Clean the cld since we're going to scavenge all the metadata.\n+    cld->oops_do(&oop_closure, ClassLoaderData::_claim_none, \/*clear_modified_oops*\/true);\n@@ -136,1 +124,2 @@\n-      _oop_closure.set_scanned_cld(nullptr);\n+    if (oop_closure._has_oop_into_young_gen) {\n+      cld->record_modified_oops();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psClosure.inline.hpp","additions":36,"deletions":47,"binary":false,"changes":83,"status":"modified"}]}