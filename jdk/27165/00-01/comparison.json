{"files":[{"patch":"@@ -80,1 +80,0 @@\n-\n@@ -83,28 +82,1 @@\n-  \/\/ Scavenges a single oop in a ClassLoaderData.\n-  class PSScavengeFromCLDClosure: public OopClosure {\n-  private:\n-    PSPromotionManager* _pm;\n-  public:\n-    \/\/ Records whether this CLD contains oops pointing into young-gen after scavenging.\n-    bool _has_oop_into_young_gen;\n-\n-    PSScavengeFromCLDClosure(PSPromotionManager* pm) : _pm(pm), _has_oop_into_young_gen(false) { }\n-    void do_oop(narrowOop* p) { ShouldNotReachHere(); }\n-    void do_oop(oop* p)       {\n-      ParallelScavengeHeap* psh = ParallelScavengeHeap::heap();\n-      assert(!psh->is_in_reserved(p), \"GC barrier needed\");\n-      if (PSScavenge::should_scavenge(p)) {\n-        assert(PSScavenge::should_scavenge(p, true), \"revisiting object?\");\n-\n-        oop o = RawAccess<IS_NOT_NULL>::oop_load(p);\n-        oop new_obj = _pm->copy_to_survivor_space<\/*promote_immediately=*\/false>(o);\n-        RawAccess<IS_NOT_NULL>::oop_store(p, new_obj);\n-\n-        if (PSScavenge::is_obj_in_young(new_obj) && !_has_oop_into_young_gen) {\n-          _has_oop_into_young_gen = true;\n-        }\n-      }\n-    }\n-  };\n-\n-  PSScavengeFromCLDClosure _oop_closure;\n+  PSPromotionManager* _pm;\n@@ -112,1 +84,2 @@\n-  PSScavengeCLDClosure(PSPromotionManager* pm) : _oop_closure(pm) { }\n+  PSScavengeCLDClosure(PSPromotionManager* pm) : _pm(pm) { }\n+\n@@ -114,5 +87,5 @@\n-    \/\/ If the cld has not been dirtied we know that there's\n-    \/\/ no references into the young gen and we can skip it.\n-    if (cld->has_modified_oops()) {\n-      \/\/ Reset before iterating oops.\n-      _oop_closure._has_oop_into_young_gen = false;\n+    \/\/ If the cld has not been dirtied we know that there are\n+    \/\/ no references into the young gen, so we can skip it.\n+    if (!cld->has_modified_oops()) {\n+      return;\n+    }\n@@ -120,2 +93,3 @@\n-      \/\/ Clean the cld since we're going to scavenge all the metadata.\n-      cld->oops_do(&_oop_closure, ClassLoaderData::_claim_none, \/*clear_modified_oops*\/true);\n+    \/\/ Scavenges a single oop in a ClassLoaderData.\n+    class CLDOopClosure : public OopClosure {\n+      PSPromotionManager* _pm;\n@@ -123,2 +97,21 @@\n-      if (_oop_closure._has_oop_into_young_gen) {\n-        cld->record_modified_oops();\n+    public:\n+      \/\/ Records whether this CLD contains oops pointing into young-gen after scavenging.\n+      bool _has_oop_into_young_gen;\n+\n+      CLDOopClosure(PSPromotionManager* pm) : _pm(pm), _has_oop_into_young_gen(false) {}\n+\n+      void do_oop(narrowOop* p) { ShouldNotReachHere(); }\n+      void do_oop(oop* p) {\n+        ParallelScavengeHeap* psh = ParallelScavengeHeap::heap();\n+        assert(!psh->is_in_reserved(p), \"GC barrier needed\");\n+        if (PSScavenge::should_scavenge(p)) {\n+          assert(PSScavenge::should_scavenge(p, true), \"revisiting object?\");\n+\n+          oop o = RawAccess<IS_NOT_NULL>::oop_load(p);\n+          oop new_obj = _pm->copy_to_survivor_space<\/*promote_immediately=*\/false>(o);\n+          RawAccess<IS_NOT_NULL>::oop_store(p, new_obj);\n+\n+          if (PSScavenge::is_obj_in_young(new_obj) && !_has_oop_into_young_gen) {\n+            _has_oop_into_young_gen = true;\n+          }\n+        }\n@@ -126,0 +119,7 @@\n+    } oop_closure{_pm};\n+\n+    \/\/ Clean the cld since we're going to scavenge all the metadata.\n+    cld->oops_do(&oop_closure, ClassLoaderData::_claim_none, \/*clear_modified_oops*\/true);\n+\n+    if (oop_closure._has_oop_into_young_gen) {\n+      cld->record_modified_oops();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psClosure.inline.hpp","additions":39,"deletions":39,"binary":false,"changes":78,"status":"modified"}]}