{"files":[{"patch":"@@ -80,19 +80,0 @@\n-\/\/ Scavenges a single oop in a ClassLoaderData.\n-class PSScavengeFromCLDClosure: public OopClosure {\n-private:\n-  PSPromotionManager* _pm;\n-  \/\/ Used to redirty a scanned cld if it has oops\n-  \/\/ pointing to the young generation after being scanned.\n-  ClassLoaderData*    _scanned_cld;\n-public:\n-  PSScavengeFromCLDClosure(PSPromotionManager* pm) : _pm(pm), _scanned_cld(nullptr) { }\n-  void do_oop(narrowOop* p) { ShouldNotReachHere(); }\n-  void do_oop(oop* p)       {\n-    ParallelScavengeHeap* psh = ParallelScavengeHeap::heap();\n-    assert(!psh->is_in_reserved(p), \"GC barrier needed\");\n-    if (PSScavenge::should_scavenge(p)) {\n-      assert(PSScavenge::should_scavenge(p, true), \"revisiting object?\");\n-\n-      oop o = RawAccess<IS_NOT_NULL>::oop_load(p);\n-      oop new_obj = _pm->copy_to_survivor_space<\/*promote_immediately=*\/false>(o);\n-      RawAccess<IS_NOT_NULL>::oop_store(p, new_obj);\n@@ -100,2 +81,25 @@\n-      if (PSScavenge::is_obj_in_young(new_obj)) {\n-        do_cld_barrier();\n+\/\/ Scavenges the oop in a ClassLoaderData.\n+class PSScavengeCLDClosure: public CLDClosure {\n+  \/\/ Scavenges a single oop in a ClassLoaderData.\n+  class PSScavengeFromCLDClosure: public OopClosure {\n+  private:\n+    PSPromotionManager* _pm;\n+  public:\n+    \/\/ Records whether this CLD contains oops pointing into young-gen after scavenging.\n+    bool _has_oop_into_young_gen;\n+\n+    PSScavengeFromCLDClosure(PSPromotionManager* pm) : _pm(pm), _has_oop_into_young_gen(false) { }\n+    void do_oop(narrowOop* p) { ShouldNotReachHere(); }\n+    void do_oop(oop* p)       {\n+      ParallelScavengeHeap* psh = ParallelScavengeHeap::heap();\n+      assert(!psh->is_in_reserved(p), \"GC barrier needed\");\n+      if (PSScavenge::should_scavenge(p)) {\n+        assert(PSScavenge::should_scavenge(p, true), \"revisiting object?\");\n+\n+        oop o = RawAccess<IS_NOT_NULL>::oop_load(p);\n+        oop new_obj = _pm->copy_to_survivor_space<\/*promote_immediately=*\/false>(o);\n+        RawAccess<IS_NOT_NULL>::oop_store(p, new_obj);\n+\n+        if (PSScavenge::is_obj_in_young(new_obj) && !_has_oop_into_young_gen) {\n+          _has_oop_into_young_gen = true;\n+        }\n@@ -104,13 +108,1 @@\n-  }\n-\n-  void set_scanned_cld(ClassLoaderData* cld) {\n-    assert(_scanned_cld == nullptr || cld == nullptr, \"Should always only handling one cld at a time\");\n-    _scanned_cld = cld;\n-  }\n-\n-private:\n-  void do_cld_barrier() {\n-    assert(_scanned_cld != nullptr, \"Should not be called without having a scanned cld\");\n-    _scanned_cld->record_modified_oops();\n-  }\n-};\n+  };\n@@ -118,3 +110,0 @@\n-\/\/ Scavenges the oop in a ClassLoaderData.\n-class PSScavengeCLDClosure: public CLDClosure {\n-private:\n@@ -126,2 +115,1 @@\n-    \/\/ no references into  the young gen and we can skip it.\n-\n+    \/\/ no references into the young gen and we can skip it.\n@@ -129,3 +117,2 @@\n-      \/\/ Setup the promotion manager to redirty this cld\n-      \/\/ if references are left in the young gen.\n-      _oop_closure.set_scanned_cld(cld);\n+      \/\/ Reset before iterating oops.\n+      _oop_closure._has_oop_into_young_gen = false;\n@@ -136,1 +123,3 @@\n-      _oop_closure.set_scanned_cld(nullptr);\n+      if (_oop_closure._has_oop_into_young_gen) {\n+        cld->record_modified_oops();\n+      }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psClosure.inline.hpp","additions":32,"deletions":43,"binary":false,"changes":75,"status":"modified"}]}