{"files":[{"patch":"@@ -133,2 +133,1 @@\n-HeapWord* G1AllocRegion::new_alloc_region_and_allocate(size_t word_size,\n-                                                       bool force) {\n+HeapWord* G1AllocRegion::new_alloc_region_and_allocate(size_t word_size) {\n@@ -139,1 +138,1 @@\n-  HeapRegion* new_alloc_region = allocate_new_region(word_size, force);\n+  HeapRegion* new_alloc_region = allocate_new_region(word_size);\n@@ -261,3 +260,2 @@\n-HeapRegion* MutatorAllocRegion::allocate_new_region(size_t word_size,\n-                                                    bool force) {\n-  return _g1h->new_mutator_alloc_region(word_size, force, _node_index);\n+HeapRegion* MutatorAllocRegion::allocate_new_region(size_t word_size) {\n+  return _g1h->new_mutator_alloc_region(word_size, _node_index);\n@@ -347,3 +345,1 @@\n-HeapRegion* G1GCAllocRegion::allocate_new_region(size_t word_size,\n-                                                 bool force) {\n-  assert(!force, \"not supported for GC alloc regions\");\n+HeapRegion* G1GCAllocRegion::allocate_new_region(size_t word_size) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -86,4 +86,2 @@\n-  \/\/ allocation. The force parameter will be passed on to\n-  \/\/ G1CollectedHeap::allocate_new_alloc_region() and tells it to try\n-  \/\/ to allocate a new region even if the max has been reached.\n-  HeapWord* new_alloc_region_and_allocate(size_t word_size, bool force);\n+  \/\/ allocation.\n+  HeapWord* new_alloc_region_and_allocate(size_t word_size);\n@@ -135,1 +133,1 @@\n-  virtual HeapRegion* allocate_new_region(size_t word_size, bool force) = 0;\n+  virtual HeapRegion* allocate_new_region(size_t word_size) = 0;\n@@ -175,6 +173,0 @@\n-  \/\/ Should be called to allocate a new region even if the max of this\n-  \/\/ type of regions has been reached. Should only be called if other\n-  \/\/ allocation attempts have failed and we are not holding a valid\n-  \/\/ active region.\n-  inline HeapWord* attempt_allocation_force(size_t word_size);\n-\n@@ -216,1 +208,1 @@\n-  virtual HeapRegion* allocate_new_region(size_t word_size, bool force);\n+  virtual HeapRegion* allocate_new_region(size_t word_size);\n@@ -252,1 +244,1 @@\n-  virtual HeapRegion* allocate_new_region(size_t word_size, bool force);\n+  virtual HeapRegion* allocate_new_region(size_t word_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.hpp","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-  HeapWord* result = new_alloc_region_and_allocate(desired_word_size, false \/* force *\/);\n+  HeapWord* result = new_alloc_region_and_allocate(desired_word_size);\n@@ -111,13 +111,0 @@\n-inline HeapWord* G1AllocRegion::attempt_allocation_force(size_t word_size) {\n-  assert_alloc_region(_alloc_region != nullptr, \"not initialized properly\");\n-\n-  trace(\"forcing alloc\", word_size, word_size);\n-  HeapWord* result = new_alloc_region_and_allocate(word_size, true \/* force *\/);\n-  if (result != nullptr) {\n-    trace(\"alloc forced\", word_size, word_size, word_size, result);\n-    return result;\n-  }\n-  trace(\"alloc forced failed\", word_size, word_size);\n-  return nullptr;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.inline.hpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/g1\/g1HeapRegionPrinter.hpp\"\n@@ -121,1 +122,1 @@\n-    _g1h->hr_printer()->reuse(retained_region);\n+    G1HeapRegionPrinter::reuse(retained_region);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -124,2 +124,0 @@\n-  inline HeapWord* attempt_allocation_force(size_t word_size);\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,5 +74,0 @@\n-inline HeapWord* G1Allocator::attempt_allocation_force(size_t word_size) {\n-  uint node_index = current_node_index();\n-  return mutator_alloc_region(node_index)->attempt_allocation_force(word_size);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+#include \"gc\/g1\/g1HeapRegionPrinter.hpp\"\n@@ -328,1 +329,1 @@\n-    _hr_printer.alloc(hr);\n+    G1HeapRegionPrinter::alloc(hr);\n@@ -527,1 +528,1 @@\n-    _hr_printer.alloc(r);\n+    G1HeapRegionPrinter::alloc(r);\n@@ -713,2 +714,0 @@\n-private:\n-  G1HRPrinter* _hr_printer;\n@@ -718,1 +717,1 @@\n-    _hr_printer->post_compaction(hr);\n+    G1HeapRegionPrinter::post_compaction(hr);\n@@ -721,3 +720,0 @@\n-\n-  PostCompactionPrinterClosure(G1HRPrinter* hr_printer)\n-    : _hr_printer(hr_printer) { }\n@@ -731,2 +727,2 @@\n-  if (_hr_printer.is_active()) {\n-    PostCompactionPrinterClosure cl(hr_printer());\n+  if (G1HeapRegionPrinter::is_active()) {\n+    PostCompactionPrinterClosure cl;\n@@ -1155,1 +1151,0 @@\n-  _hr_printer(),\n@@ -2854,1 +2849,0 @@\n-                                                      bool force,\n@@ -2858,1 +2852,1 @@\n-  if (force || should_allocate) {\n+  if (should_allocate) {\n@@ -2865,1 +2859,1 @@\n-      _hr_printer.alloc(new_alloc_region, !should_allocate);\n+      G1HeapRegionPrinter::alloc(new_alloc_region);\n@@ -2881,1 +2875,1 @@\n-  _hr_printer.retire(alloc_region);\n+  G1HeapRegionPrinter::retire(alloc_region);\n@@ -2928,1 +2922,1 @@\n-    _hr_printer.alloc(new_alloc_region);\n+    G1HeapRegionPrinter::alloc(new_alloc_region);\n@@ -2949,1 +2943,1 @@\n-  _hr_printer.retire(alloc_region);\n+  G1HeapRegionPrinter::retire(alloc_region);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":11,"deletions":17,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-#include \"gc\/g1\/g1HRPrinter.hpp\"\n@@ -268,2 +267,0 @@\n-  G1HRPrinter _hr_printer;\n-\n@@ -471,1 +468,1 @@\n-  HeapRegion* new_mutator_alloc_region(size_t word_size, bool force, uint node_index);\n+  HeapRegion* new_mutator_alloc_region(size_t word_size, uint node_index);\n@@ -672,2 +669,0 @@\n-  G1HRPrinter* hr_printer() { return &_hr_printer; }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"gc\/g1\/g1HeapRegionPrinter.hpp\"\n@@ -1320,1 +1321,1 @@\n-      _g1h->hr_printer()->mark_reclaim(&_cleanup_list);\n+      G1HeapRegionPrinter::mark_reclaim(&_cleanup_list);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#include \"gc\/g1\/g1HeapRegionSet.hpp\"\n-#include \"gc\/g1\/g1HRPrinter.hpp\"\n-\n-void G1HRPrinter::mark_reclaim(FreeRegionList* cleanup_list) {\n-  if (is_active()) {\n-    FreeRegionListIterator iter(cleanup_list);\n-    while (iter.more_available()) {\n-      HeapRegion* hr = iter.get_next();\n-      mark_reclaim(hr);\n-    }\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HRPrinter.cpp","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -1,130 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_G1HRPRINTER_HPP\n-#define SHARE_GC_G1_G1HRPRINTER_HPP\n-\n-#include \"gc\/g1\/g1HeapRegion.hpp\"\n-#include \"logging\/log.hpp\"\n-\n-class FreeRegionList;\n-\n-class G1HRPrinter {\n-\n-private:\n-\n-  \/\/ Print an action event.\n-  static void print(const char* action, HeapRegion* hr) {\n-    log_trace(gc, region)(\"G1HR %s(%s) [\" PTR_FORMAT \", \" PTR_FORMAT \", \" PTR_FORMAT \"]\",\n-                          action, hr->get_type_str(), p2i(hr->bottom()), p2i(hr->top()), p2i(hr->end()));\n-  }\n-\n-  void mark_reclaim(HeapRegion* hr) {\n-    print(\"MARK-RECLAIM\", hr);\n-  }\n-\n-public:\n-  \/\/ In some places we iterate over a list in order to generate output\n-  \/\/ for the list's elements. By exposing this we can avoid this\n-  \/\/ iteration if the printer is not active.\n-  bool is_active() { return log_is_enabled(Trace, gc, region); }\n-\n-  \/\/ The methods below are convenient wrappers for the print() method.\n-\n-  void alloc(HeapRegion* hr, bool force = false) {\n-    if (is_active()) {\n-      print((force) ? \"ALLOC-FORCE\" : \"ALLOC\", hr);\n-    }\n-  }\n-\n-  void retire(HeapRegion* hr) {\n-    if (is_active()) {\n-      print(\"RETIRE\", hr);\n-    }\n-  }\n-\n-  void reuse(HeapRegion* hr) {\n-    if (is_active()) {\n-      print(\"REUSE\", hr);\n-    }\n-  }\n-\n-  void cset(HeapRegion* hr) {\n-    if (is_active()) {\n-      print(\"CSET\", hr);\n-    }\n-  }\n-\n-  void evac_failure(HeapRegion* hr) {\n-    if (is_active()) {\n-      print(\"EVAC-FAILURE\", hr);\n-    }\n-  }\n-\n-  void mark_reclaim(FreeRegionList* free_list);\n-\n-  void eager_reclaim(HeapRegion* hr) {\n-    if (is_active()) {\n-      print(\"EAGER-RECLAIM\", hr);\n-    }\n-  }\n-\n-  void evac_reclaim(HeapRegion* hr) {\n-    if (is_active()) {\n-      print(\"EVAC-RECLAIM\", hr);\n-    }\n-  }\n-\n-  void post_compaction(HeapRegion* hr) {\n-    if (is_active()) {\n-      print(\"POST-COMPACTION\", hr);\n-    }\n-  }\n-\n-  void commit(HeapRegion* hr) {\n-    if (is_active()) {\n-      print(\"COMMIT\", hr);\n-    }\n-  }\n-\n-  void active(HeapRegion* hr) {\n-    if (is_active()) {\n-      print(\"ACTIVE\", hr);\n-    }\n-  }\n-\n-  void inactive(HeapRegion* hr) {\n-    if (is_active()) {\n-      print(\"INACTIVE\", hr);\n-    }\n-  }\n-\n-  void uncommit(HeapRegion* hr) {\n-    if (is_active()) {\n-      print(\"UNCOMMIT\", hr);\n-    }\n-  }\n-};\n-\n-#endif \/\/ SHARE_GC_G1_G1HRPRINTER_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HRPrinter.hpp","additions":0,"deletions":130,"binary":false,"changes":130,"status":"deleted"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/g1\/g1HeapRegionPrinter.hpp\"\n@@ -173,1 +174,1 @@\n-    G1CollectedHeap::heap()->hr_printer()->commit(hr);\n+    G1HeapRegionPrinter::commit(hr);\n@@ -196,2 +197,1 @@\n-  G1HRPrinter* printer = G1CollectedHeap::heap()->hr_printer();\n-  if (printer->is_active()) {\n+  if (G1HeapRegionPrinter::is_active()) {\n@@ -202,1 +202,1 @@\n-      printer->uncommit(hr);\n+      G1HeapRegionPrinter::uncommit(hr);\n@@ -226,1 +226,1 @@\n-    G1CollectedHeap::heap()->hr_printer()->active(hr);\n+    G1HeapRegionPrinter::active(hr);\n@@ -253,1 +253,1 @@\n-    G1CollectedHeap::heap()->hr_printer()->inactive(hr);\n+    G1HeapRegionPrinter::inactive(hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/g1\/g1HeapRegionPrinter.hpp\"\n+#include \"gc\/g1\/g1HeapRegionSet.hpp\"\n+\n+void G1HeapRegionPrinter::mark_reclaim(FreeRegionList* cleanup_list) {\n+  if (is_active()) {\n+    FreeRegionListIterator iter(cleanup_list);\n+    while (iter.more_available()) {\n+      HeapRegion* hr = iter.get_next();\n+      mark_reclaim(hr);\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionPrinter.cpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1HEAPREGIONPRINTER_HPP\n+#define SHARE_GC_G1_G1HEAPREGIONPRINTER_HPP\n+\n+#include \"gc\/g1\/g1HeapRegion.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+\n+class FreeRegionList;\n+\n+class G1HeapRegionPrinter : public AllStatic {\n+\n+  \/\/ Print an action event.\n+  static void print(const char* action, HeapRegion* hr) {\n+    log_trace(gc, region)(\"G1HR %s(%s) [\" PTR_FORMAT \", \" PTR_FORMAT \", \" PTR_FORMAT \"]\",\n+                          action, hr->get_type_str(), p2i(hr->bottom()), p2i(hr->top()), p2i(hr->end()));\n+  }\n+\n+  static void mark_reclaim(HeapRegion* hr) {\n+    print(\"MARK-RECLAIM\", hr);\n+  }\n+\n+public:\n+  \/\/ In some places we iterate over a list in order to generate output\n+  \/\/ for the list's elements. By exposing this we can avoid this\n+  \/\/ iteration if the printer is not active.\n+  static bool is_active() { return log_is_enabled(Trace, gc, region); }\n+\n+  \/\/ The methods below are convenient wrappers for the print() method.\n+\n+  static void alloc(HeapRegion* hr)                     { print(\"ALLOC\", hr); }\n+\n+  static void retire(HeapRegion* hr)                    { print(\"RETIRE\", hr); }\n+\n+  static void reuse(HeapRegion* hr)                     { print(\"REUSE\", hr); }\n+\n+  static void cset(HeapRegion* hr)                      { print(\"CSET\", hr); }\n+\n+  static void evac_failure(HeapRegion* hr)              { print(\"EVAC-FAILURE\", hr); }\n+\n+  static void mark_reclaim(FreeRegionList* free_list);\n+\n+  static void eager_reclaim(HeapRegion* hr)             { print(\"EAGER-RECLAIM\", hr); }\n+\n+  static void evac_reclaim(HeapRegion* hr)              { print(\"EVAC-RECLAIM\", hr); }\n+\n+  static void post_compaction(HeapRegion* hr)           { print(\"POST-COMPACTION\", hr); }\n+\n+  static void commit(HeapRegion* hr)                    { print(\"COMMIT\", hr); }\n+\n+  static void active(HeapRegion* hr)                    { print(\"ACTIVE\", hr); }\n+\n+  static void inactive(HeapRegion* hr)                  { print(\"INACTIVE\", hr); }\n+\n+  static void uncommit(HeapRegion* hr)                  { print(\"UNCOMMIT\", hr); }\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1HEAPREGIONPRINTER_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionPrinter.hpp","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/g1\/g1HeapRegionPrinter.hpp\"\n@@ -645,1 +646,1 @@\n-      _g1h->hr_printer()->evac_failure(r);\n+      G1HeapRegionPrinter::evac_failure(r);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-#include \"gc\/g1\/g1HRPrinter.hpp\"\n+#include \"gc\/g1\/g1HeapRegionPrinter.hpp\"\n@@ -219,4 +219,0 @@\n-G1HRPrinter* G1YoungCollector::hr_printer() const {\n-  return _g1h->hr_printer();\n-}\n-\n@@ -267,2 +263,0 @@\n-private:\n-  G1HRPrinter* _hr_printer;\n@@ -270,2 +264,0 @@\n-  G1PrintCollectionSetClosure(G1HRPrinter* hr_printer) : HeapRegionClosure(), _hr_printer(hr_printer) { }\n-\n@@ -273,1 +265,1 @@\n-    _hr_printer->cset(r);\n+    G1HeapRegionPrinter::cset(r);\n@@ -289,2 +281,2 @@\n-  if (hr_printer()->is_active()) {\n-    G1PrintCollectionSetClosure cl(hr_printer());\n+  if (G1HeapRegionPrinter::is_active()) {\n+    G1PrintCollectionSetClosure cl;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-class G1HRPrinter;\n@@ -72,1 +71,0 @@\n-  G1HRPrinter* hr_printer() const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"gc\/g1\/g1HeapRegionPrinter.hpp\"\n@@ -415,1 +416,1 @@\n-      _g1h->hr_printer()->eager_reclaim(r);\n+      G1HeapRegionPrinter::eager_reclaim(r);\n@@ -763,1 +764,1 @@\n-    _g1h->hr_printer()->evac_reclaim(r);\n+    G1HeapRegionPrinter::evac_reclaim(r);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}