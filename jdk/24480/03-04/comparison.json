{"files":[{"patch":"@@ -1471,71 +1471,0 @@\n-\n-  \/\/ Helper for generate_unsafe_setmemory\n-  \/\/\n-  \/\/ Non-atomically fill an array of memory using 1 byte chunk and return.\n-  \/\/ We don't care about atomicity because the address and size are not aligned, So we are\n-  \/\/ free to fill the memory with best possible ways.\n-  static void do_setmemory_atomic_loop_mvc(Register dest, Register size, Register byteVal,\n-                                           MacroAssembler *_masm) {\n-    NearLabel L_loop, L_tail, L_mvc;\n-\n-    __ z_aghi(size, -1); \/\/ -1 because first byte is preset by stc\n-    __ z_bcr(Assembler::bcondLow, Z_R14);   \/\/ result  < 0 means size == 0 => return\n-    __ z_stc(byteVal, Address(dest));       \/\/ initialize first byte\n-    __ z_bcr(Assembler::bcondEqual, Z_R14); \/\/ result == 0 means size == 1 => return\n-\n-    \/\/ handle complete 256 byte blocks\n-    __ bind(L_loop);\n-    __ z_aghi(size, -256);            \/\/ decrement remaining #bytes\n-    __ z_brl(L_tail);                 \/\/ skip loop if no full 256 byte block left\n-\n-    __ z_mvc(1, 255, dest, 0, dest);  \/\/ propagate byte from dest[0+i*256] to dest[1+i*256]\n-    __ z_bcr(Assembler::bcondEqual, Z_R14); \/\/ remaining size == 0 => return (mvc does not touch CC)\n-\n-    __ z_aghi(dest, 256);             \/\/ increment target address\n-    __ z_bru(L_loop);\n-\n-    \/\/ handle remaining bytes. We know 0 < size < 256\n-    __ bind(L_tail);\n-    __ z_aghi(size, +256-1);         \/\/ prepare size value for mvc via exrl\n-    __ z_exrl(size, L_mvc);\n-    __ z_br(Z_R14);\n-\n-    __ bind(L_mvc);\n-    __ z_mvc(1, 0, dest, 0, dest);   \/\/ mvc template, needs to be generated, not executed\n-  }\n-\n-  static void do_setmemory_atomic_loop(int elem_size, Register dest, Register size, Register byteVal,\n-                                       MacroAssembler *_masm) {\n-\n-    NearLabel L_Loop, L_Tail; \/\/ 2x unrolled loop\n-    Register tmp = Z_R1; \/\/ R1 is free at this point\n-\n-    if (elem_size > 1) {\n-      __ rotate_then_insert(byteVal, byteVal, 64 - 2 * 8 , 63 - 8,  8, false);\n-    }\n-\n-    if (elem_size > 2) {\n-      __ rotate_then_insert(byteVal, byteVal, 64 - 2 * 16, 63 - 16, 16, false);\n-    }\n-\n-    if (elem_size > 4) {\n-      __ rotate_then_insert(byteVal, byteVal, 64 - 2 * 32, 63 - 32, 32, false);\n-    }\n-\n-    __ z_risbg(tmp, size, 32, 63, 64 - exact_log2(2 * elem_size), \/* zero_rest *\/ true); \/\/ just do the right shift and set cc\n-    __ z_bre(L_Tail);\n-\n-    __ align(32); \/\/ loop alignment\n-    __ bind(L_Loop);\n-    __ store_sized_value(byteVal, Address(dest, 0), elem_size);\n-    __ store_sized_value(byteVal, Address(dest, elem_size), elem_size);\n-    __ z_aghi(dest, 2 * elem_size);\n-    __ z_brct(tmp, L_Loop);\n-\n-    __ bind(L_Tail);\n-    __ z_nilf(size, elem_size);\n-    __ z_bcr(Assembler::bcondEqual, Z_R14);\n-    __ store_sized_value(byteVal, Address(dest, 0), elem_size);\n-    __ z_br(Z_R14);\n-  }\n-\n@@ -1560,7 +1489,5 @@\n-    {\n-      const Register dest = Z_ARG1;\n-      const Register size = Z_ARG2;\n-      const Register byteVal = Z_ARG3;\n-      const Register rScratch1 = Z_R1_scratch;\n-      NearLabel L_fill8Bytes, L_fill4Bytes, L_fillBytes;\n-      \/\/ fill_to_memory_atomic(unsigned char*, unsigned long, unsigned char)\n+    const Register dest = Z_ARG1;\n+    const Register size = Z_ARG2;\n+    const Register byteVal = Z_ARG3;\n+    NearLabel tail, finished;\n+    \/\/ fill_to_memory_atomic(unsigned char*, unsigned long, unsigned char)\n@@ -1568,2 +1495,2 @@\n-      \/\/ Check for pointer & size alignment\n-      __ z_ogrk(rScratch1, dest, size);\n+    \/\/ Mark remaining code as such which performs Unsafe accesses.\n+    UnsafeMemoryAccessMark umam(this, true, false);\n@@ -1571,2 +1498,2 @@\n-      __ z_nill(rScratch1, 7);\n-      __ z_braz(L_fill8Bytes); \/\/ branch if 0\n+    __ z_vlvgb(Z_V0, byteVal, 0);\n+    __ z_vrepb(Z_V0, Z_V0, 0);\n@@ -1574,2 +1501,2 @@\n-      __ z_nill(rScratch1, 3);\n-      __ z_braz(L_fill4Bytes); \/\/ branch if 0\n+    __ z_aghi(size, -32);\n+    __ z_brl(tail);\n@@ -1577,2 +1504,9 @@\n-      __ z_nill(rScratch1, 1);\n-      __ z_brnaz(L_fillBytes); \/\/ branch if not 0\n+    {\n+      NearLabel again;\n+      __ bind(again);\n+      __ z_vst(Z_V0, Address(dest, 0));\n+      __ z_vst(Z_V0, Address(dest, 16));\n+      __ z_aghi(dest, 32);\n+      __ z_aghi(size, -32);\n+      __ z_brnl(again);\n+    }\n@@ -1580,2 +1514,19 @@\n-      \/\/ Mark remaining code as such which performs Unsafe accesses.\n-      UnsafeMemoryAccessMark umam(this, true, false);\n+    __ bind(tail);\n+\n+    {\n+      NearLabel dont;\n+      __ testbit(size, 4);\n+      __ z_brz(dont);\n+      __ z_vst(Z_V0, Address(dest, 0));\n+      __ z_aghi(dest, 16);\n+      __ bind(dont);\n+    }\n+\n+    {\n+      NearLabel dont;\n+      __ testbit(size, 3);\n+      __ z_brz(dont);\n+      __ z_vsteg(Z_V0, 0, Z_R0, dest, 0);\n+      __ z_aghi(dest, 8);\n+      __ bind(dont);\n+    }\n@@ -1583,3 +1534,2 @@\n-      \/\/ At this point, we know the lower bit of size is zero and a\n-      \/\/ multiple of 2\n-      do_setmemory_atomic_loop(2, dest, size, byteVal, _masm);\n+    __ z_tmll(size, 7);\n+    __ z_brc(Assembler::bcondAllZero, finished);\n@@ -1587,4 +1537,8 @@\n-      __ bind(L_fill8Bytes);\n-      \/\/ At this point, we know the lower 3 bits of size are zero and a\n-      \/\/ multiple of 8\n-      do_setmemory_atomic_loop(8, dest, size, byteVal, _masm);\n+    {\n+      NearLabel dont;\n+      __ testbit(size, 2);\n+      __ z_brz(dont);\n+      __ z_vstef(Z_V0, 0, Z_R0, dest, 0);\n+      __ z_aghi(dest, 4);\n+      __ bind(dont);\n+    }\n@@ -1592,4 +1546,8 @@\n-      __ bind(L_fill4Bytes);\n-      \/\/ At this point, we know the lower 2 bits of size are zero and a\n-      \/\/ multiple of 4\n-      do_setmemory_atomic_loop(4, dest, size, byteVal, _masm);\n+    {\n+      NearLabel dont;\n+      __ testbit(size, 1);\n+      __ z_brz(dont);\n+      __ z_vsteh(Z_V0, 0, Z_R0, dest, 0);\n+      __ z_aghi(dest, 2);\n+      __ bind(dont);\n+    }\n@@ -1597,2 +1555,6 @@\n-      __ bind(L_fillBytes);\n-      do_setmemory_atomic_loop_mvc(dest, size, byteVal, _masm);\n+    {\n+      NearLabel dont;\n+      __ testbit(size, 0);\n+      __ z_brz(dont);\n+      __ z_vsteb(Z_V0, 0, Z_R0, dest, 0);\n+      __ bind(dont);\n@@ -1600,0 +1562,4 @@\n+\n+    __ bind(finished);\n+    __ z_br(Z_R14);\n+\n@@ -1648,1 +1614,3 @@\n-    StubRoutines::_unsafe_setmemory = generate_unsafe_setmemory(StubRoutines::_jbyte_fill);\n+    StubRoutines::_unsafe_setmemory =\n+             VM_Version::has_VectorFacility() ? generate_unsafe_setmemory(StubRoutines::_jbyte_fill) : nullptr;\n+\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":70,"deletions":102,"binary":false,"changes":172,"status":"modified"}]}