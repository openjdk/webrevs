{"files":[{"patch":"@@ -1471,0 +1471,105 @@\n+  \/\/\n+  \/\/  Generate 'unsafe' set memory stub\n+  \/\/  Though just as safe as the other stubs, it takes an unscaled\n+  \/\/  size_t (# bytes) argument instead of an element count.\n+  \/\/\n+  \/\/  Input:\n+  \/\/    Z_ARG1   - destination array address\n+  \/\/    Z_ARG2   - byte count (size_t)\n+  \/\/    Z_ARG3   - byte value\n+  \/\/\n+  address generate_unsafe_setmemory(address unsafe_byte_fill) {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, StubGenStubId::unsafe_setmemory_id);\n+    unsigned int start_off = __ offset();\n+\n+    \/\/ bump this on entry, not on exit:\n+    \/\/ inc_counter_np(SharedRuntime::_unsafe_set_memory_ctr);\n+\n+    const Register dest = Z_ARG1;\n+    const Register size = Z_ARG2;\n+    const Register byteVal = Z_ARG3;\n+    NearLabel tail, finished;\n+    \/\/ fill_to_memory_atomic(unsigned char*, unsigned long, unsigned char)\n+\n+    \/\/ Mark remaining code as such which performs Unsafe accesses.\n+    UnsafeMemoryAccessMark umam(this, true, false);\n+\n+    __ z_vlvgb(Z_V0, byteVal, 0);\n+    __ z_vrepb(Z_V0, Z_V0, 0);\n+\n+    __ z_aghi(size, -32);\n+    __ z_brl(tail);\n+\n+    {\n+      NearLabel again;\n+      __ bind(again);\n+      __ z_vst(Z_V0, Address(dest, 0));\n+      __ z_vst(Z_V0, Address(dest, 16));\n+      __ z_aghi(dest, 32);\n+      __ z_aghi(size, -32);\n+      __ z_brnl(again);\n+    }\n+\n+    __ bind(tail);\n+\n+    {\n+      NearLabel dont;\n+      __ testbit(size, 4);\n+      __ z_brz(dont);\n+      __ z_vst(Z_V0, Address(dest, 0));\n+      __ z_aghi(dest, 16);\n+      __ bind(dont);\n+    }\n+\n+    {\n+      NearLabel dont;\n+      __ testbit(size, 3);\n+      __ z_brz(dont);\n+      __ z_vsteg(Z_V0, 0, Z_R0, dest, 0);\n+      __ z_aghi(dest, 8);\n+      __ bind(dont);\n+    }\n+\n+    __ z_tmll(size, 7);\n+    __ z_brc(Assembler::bcondAllZero, finished);\n+\n+    {\n+      NearLabel dont;\n+      __ testbit(size, 2);\n+      __ z_brz(dont);\n+      __ z_vstef(Z_V0, 0, Z_R0, dest, 0);\n+      __ z_aghi(dest, 4);\n+      __ bind(dont);\n+    }\n+\n+    {\n+      NearLabel dont;\n+      __ testbit(size, 1);\n+      __ z_brz(dont);\n+      __ z_vsteh(Z_V0, 0, Z_R0, dest, 0);\n+      __ z_aghi(dest, 2);\n+      __ bind(dont);\n+    }\n+\n+    {\n+      NearLabel dont;\n+      __ testbit(size, 0);\n+      __ z_brz(dont);\n+      __ z_vsteb(Z_V0, 0, Z_R0, dest, 0);\n+      __ bind(dont);\n+    }\n+\n+    __ bind(finished);\n+    __ z_br(Z_R14);\n+\n+    return __ addr_at(start_off);\n+  }\n+\n+  \/\/ This is common errorexit stub for UnsafeMemoryAccess.\n+  address generate_unsafecopy_common_error_exit() {\n+    unsigned int start_off = __ offset();\n+    __ z_lghi(Z_RET, 0); \/\/ return 0\n+    __ z_br(Z_R14);\n+    return __ addr_at(start_off);\n+  }\n@@ -1476,0 +1581,4 @@\n+\n+    address ucm_common_error_exit       =  generate_unsafecopy_common_error_exit();\n+    UnsafeMemoryAccess::set_common_exit_stub_pc(ucm_common_error_exit);\n+\n@@ -1503,0 +1612,6 @@\n+\n+#ifdef COMPILER2\n+    StubRoutines::_unsafe_setmemory =\n+             VM_Version::has_VectorFacility() ? generate_unsafe_setmemory(StubRoutines::_jbyte_fill) : nullptr;\n+\n+#endif \/\/ COMPILER2\n@@ -3187,0 +3302,4 @@\n+    if (UnsafeMemoryAccess::_table == nullptr) {\n+      UnsafeMemoryAccess::create_table(4); \/\/ 4 for setMemory\n+    }\n+\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":119,"deletions":0,"binary":false,"changes":119,"status":"modified"}]}