{"files":[{"patch":"@@ -1474,1 +1474,36 @@\n-  \/\/ Atomically fill an array of memory using 1-, 2-, 4-, or 8-byte chunks and return.\n+  \/\/ Non-atomically fill an array of memory using 1 byte chunk and return.\n+  \/\/ We don't care about atomicity because the address and size are not aligned, So we are\n+  \/\/ free to fill the memory with best possible ways.\n+  static void do_setmemory_atomic_loop_mvc(Register dest, Register size, Register byteVal,\n+                                       MacroAssembler *_masm) {\n+\n+    NearLabel L_loop, L_tail, L_mvc;\n+\n+    __ z_cghi(size, 256);\n+    __ z_brc(Assembler::bcondLow, L_tail); \/\/ size is <256\n+\n+    \/\/ handle size >= 256\n+    __ bind(L_loop);\n+    __ z_stc(byteVal, Address(dest));\n+    __ z_mvc(1, 254, dest, 0, dest);\n+    __ z_aghi(dest, 256); \/\/ increment the address by 256\n+    __ z_aghi(size, -256);\n+    __ z_cghi(size, 256);\n+    __ z_brh(L_loop);\n+\n+    __ z_ltr(size, size);\n+    __ z_bcr(Assembler::bcondZero, Z_R14); \/\/ size is 0\n+\n+    __ bind(L_tail);\n+    __ z_stc(byteVal, Address(dest));\n+    __ z_aghi(size, -2); \/\/ aghi will set the condition code for \"size==zero\", \"size<zero\", \"size>zero\"\n+    __ z_bcr(Assembler::bcondLow, Z_R14); \/\/ size < 0\n+    __ z_exrl(size, L_mvc);\n+\n+    __ z_br(Z_R14);\n+\n+    __ bind(L_mvc);\n+    __ z_mvc(1, 0, dest, 0, dest); \/\/ mvc template, needs to be generated, not executed\n+\n+  }\n+\n@@ -1529,2 +1564,0 @@\n-      NearLabel L_fill8Bytes, L_fill4Bytes, L_fillBytes;\n-\n@@ -1535,0 +1568,1 @@\n+      NearLabel L_fill8Bytes, L_fill4Bytes, L_fillBytes;\n@@ -1567,1 +1601,1 @@\n-      do_setmemory_atomic_loop(1, dest, size, byteVal, _masm);\n+      do_setmemory_atomic_loop_mvc(dest, size, byteVal, _masm);\n@@ -1569,1 +1603,0 @@\n-\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":38,"deletions":5,"binary":false,"changes":43,"status":"modified"}]}