{"files":[{"patch":"@@ -418,4 +418,7 @@\n-  assert(Immediate::is_uimm(spos3, 6), \"range start out of range\");   \/\/ Could just trim to 6bits wide w\/o assertion.\n-  assert(Immediate::is_uimm(epos4, 6), \"range end   out of range\");   \/\/ Could just trim to 6bits wide w\/o assertion.\n-  assert(Immediate::is_uimm(nrot5, 6), \"rotate amount out of range\"); \/\/ Could just leave it as is. leftmost 2 bits are ignored by instruction.\n-  emit_48( RISBG_ZOPC | regt(r1, 8, len) | regt(r2, 12, len) | uimm6(spos3, 16+2, len) | uimm6(epos4, 24+2, len) | uimm6(nrot5, 32+2, len) | u_field(zero_rest ? 1 : 0, len-24-1, len-24-1));\n+  assert(Immediate::is_uimm(spos3, 8), \"range start out of range\");   \/\/ Could just trim to 6bits wide w\/o assertion.\n+  assert(Immediate::is_uimm(epos4, 8), \"range end   out of range\");   \/\/ Could just trim to 6bits wide w\/o assertion.\n+  assert(Immediate::is_uimm(nrot5, 8), \"rotate amount out of range\"); \/\/ Could just leave it as is. leftmost 2 bits are ignored by instruction.\n+  assert((spos3 & 192) == 0, \"bits 0, 1 of I3 field are reserved\");\n+  assert((epos4 & 64) == 0, \"bit 1 of I4 field is reserved\");\n+  assert((nrot5 & 192) == 0, \"bits 0, 1 of I5 field are ignored by instruction, make sure that will not cause trouble\");\n+  emit_48( RISBG_ZOPC | regt(r1, 8, len) | regt(r2, 12, len) | uimm8(spos3, 16, len) | uimm8(epos4, 24, len) | uimm8(nrot5, 32, len) | u_field(zero_rest ? 1 : 0, len-24-1, len-24-1));\n","filename":"src\/hotspot\/cpu\/s390\/assembler_s390.inline.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1472,0 +1472,113 @@\n+  \/\/ Helper for generate_unsafe_setmemory\n+  \/\/\n+  \/\/ Atomically fill an array of memory using 1-, 2-, 4-, or 8-byte chunks and return.\n+  static void do_setmemory_atomic_loop(int elem_size, Register dest, Register size, Register byteVal,\n+                                       MacroAssembler *_masm) {\n+\n+    NearLabel L_Loop, L_Tail; \/\/ 2x unrolled loop\n+    Register tmp = Z_R1; \/\/ R1 is free at this point\n+\n+    if (elem_size > 1) {\n+      __ rotate_then_insert(byteVal, byteVal, 64 - 2 * 8 , 63 - 8,  8, 0);\n+    }\n+\n+    if (elem_size > 2) {\n+      __ rotate_then_insert(byteVal, byteVal, 64 - 2 * 16, 63 - 16, 16, 0);\n+    }\n+\n+    if (elem_size > 4) {\n+      __ rotate_then_insert(byteVal, byteVal, 64 - 2 * 32, 63 - 32, 32, 0);\n+    }\n+\n+    __ z_risbg(tmp, size, 32, 128\/* risbgz *\/ + 63, 64 - exact_log2(2 * elem_size), 0); \/\/ just do the right shift and set cc\n+    __ z_bre(L_Tail);\n+\n+    __ align(16); \/\/ loop alignment\n+    __ bind(L_Loop);\n+    __ store_sized_value(byteVal, Address(dest, 0), elem_size);\n+    __ store_sized_value(byteVal, Address(dest, elem_size), elem_size);\n+    __ z_agfi(dest, 2 * elem_size);\n+    __ z_brct(tmp, L_Loop);\n+\n+    __ bind(L_Tail);\n+    __ z_nilf(size, elem_size);\n+    __ z_bcr(Assembler::bcondEqual, Z_R14);\n+    __ store_sized_value(byteVal, Address(dest, 0), elem_size);\n+    __ z_br(Z_R14);\n+  }\n+\n+  \/\/\n+  \/\/  Generate 'unsafe' set memory stub\n+  \/\/  Though just as safe as the other stubs, it takes an unscaled\n+  \/\/  size_t (# bytes) argument instead of an element count.\n+  \/\/\n+  \/\/  Input:\n+  \/\/    Z_ARG1   - destination array address\n+  \/\/    Z_ARG2   - byte count (size_t)\n+  \/\/    Z_ARG3   - byte value\n+  \/\/\n+  address generate_unsafe_setmemory(address unsafe_byte_fill) {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, StubGenStubId::unsafe_setmemory_id);\n+    unsigned int start_off = __ offset();\n+\n+    \/\/ bump this on entry, not on exit:\n+    \/\/ inc_counter_np(SharedRuntime::_unsafe_set_memory_ctr);\n+\n+    {\n+      NearLabel L_fill8Bytes, L_fill4Bytes, L_fillBytes, L_exit;\n+\n+      const Register dest = Z_ARG1;\n+      const Register size = Z_ARG2;\n+      const Register byteVal = Z_ARG3;\n+      const Register rScratch1 = Z_R1_scratch;\n+      \/\/ fill_to_memory_atomic(unsigned char*, unsigned long, unsigned char)\n+\n+      \/\/ Check for pointer & size alignment\n+      __ z_ogrk(rScratch1, dest, size);\n+\n+      __ z_nill(rScratch1, 7);\n+      __ z_bre(L_fill8Bytes); \/\/ branch if 0\n+\n+\n+      __ z_nill(rScratch1, 3);\n+      __ z_bre(L_fill4Bytes); \/\/ branch if 0\n+\n+      __ z_nill(rScratch1, 1);\n+      __ z_brne(L_fillBytes); \/\/ branch if not 0\n+\n+      \/\/ Mark remaining code as such which performs Unsafe accesses.\n+      UnsafeMemoryAccessMark umam(this, true, false);\n+\n+      \/\/ At this point, we know the lower bit of size is zero and a\n+      \/\/ multiple of 2\n+      do_setmemory_atomic_loop(2, dest, size, byteVal, _masm);\n+\n+      __ align(16);\n+      __ bind(L_fill8Bytes);\n+      \/\/ At this point, we know the lower 3 bits of size are zero and a\n+      \/\/ multiple of 8\n+      do_setmemory_atomic_loop(8, dest, size, byteVal, _masm);\n+\n+      __ align(16);\n+      __ bind(L_fill4Bytes);\n+      \/\/ At this point, we know the lower 2 bits of size are zero and a\n+      \/\/ multiple of 4\n+      do_setmemory_atomic_loop(4, dest, size, byteVal, _masm);\n+\n+      __ align(16);\n+      __ bind(L_fillBytes);\n+      do_setmemory_atomic_loop(1, dest, size, byteVal, _masm);\n+    }\n+\n+    return __ addr_at(start_off);\n+  }\n+\n+  \/\/ This is common errorexit stub for UnsafeMemoryAccess.\n+  address generate_unsafecopy_common_error_exit() {\n+    unsigned int start_off = __ offset();\n+    __ z_lghi(Z_RET, 0); \/\/ return 0\n+    __ z_br(Z_R14);\n+    return __ addr_at(start_off);\n+  }\n+\n@@ -1476,0 +1589,4 @@\n+\n+    address ucm_common_error_exit       =  generate_unsafecopy_common_error_exit();\n+    UnsafeMemoryAccess::set_common_exit_stub_pc(ucm_common_error_exit);\n+\n@@ -1503,0 +1620,4 @@\n+\n+#ifdef COMPILER2\n+    StubRoutines::_unsafe_setmemory = generate_unsafe_setmemory(StubRoutines::_jbyte_fill);\n+#endif \/\/ COMPILER2\n@@ -3187,0 +3308,4 @@\n+    if (UnsafeMemoryAccess::_table == nullptr) {\n+      UnsafeMemoryAccess::create_table(4); \/\/ 4 for setMemory\n+    }\n+\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":125,"deletions":0,"binary":false,"changes":125,"status":"modified"}]}