{"files":[{"patch":"@@ -188,0 +188,4 @@\n+  if ((t->isa_rawptr() && type()->isa_oopptr()) || (t->isa_oopptr() && type()->isa_rawptr())) {\n+    assert(is_CheckCastPP(), \"unrelated types from %s\", Name());\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2015,0 +2015,4 @@\n+  if (is_mismatched_access()) {\n+    return _type;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -692,6 +692,0 @@\n-\/\/ Compute the meet of 2 types. When dual is true, the subset relation in CT is\n-\/\/ reversed. This means that the result of 2 CTs would be the intersection of\n-\/\/ them if dual is true, and be the union of them if dual is false. The subset\n-\/\/ relation in the Type hierarchy is still the same, however. E.g. the result\n-\/\/ of 1 CT and Type::BOTTOM would always be Type::BOTTOM, and the result of 1\n-\/\/ CT and Type::TOP would always be the CT instance itself.\n@@ -699,25 +693,10 @@\n-const Type* TypeIntHelper::int_type_xmeet(const CT* i1, const Type* t2) {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if (i1 == t2 || t2 == Type::TOP) {\n-    return i1;\n-  }\n-  const CT* i2 = t2->try_cast<CT>();\n-  if (i2 != nullptr) {\n-    assert(i1->_is_dual == i2->_is_dual, \"must have the same duality\");\n-    using S = std::remove_const_t<decltype(CT::_lo)>;\n-    using U = std::remove_const_t<decltype(CT::_ulo)>;\n-\n-    if (!i1->_is_dual) {\n-      \/\/ meet (a.k.a union)\n-      return CT::make_or_top(TypeIntPrototype<S, U>{{MIN2(i1->_lo, i2->_lo), MAX2(i1->_hi, i2->_hi)},\n-                                                    {MIN2(i1->_ulo, i2->_ulo), MAX2(i1->_uhi, i2->_uhi)},\n-                                                    {i1->_bits._zeros & i2->_bits._zeros, i1->_bits._ones & i2->_bits._ones}},\n-                             MAX2(i1->_widen, i2->_widen), false);\n-    } else {\n-      \/\/ join (a.k.a intersection)\n-      return CT::make_or_top(TypeIntPrototype<S, U>{{MAX2(i1->_lo, i2->_lo), MIN2(i1->_hi, i2->_hi)},\n-                                                    {MAX2(i1->_ulo, i2->_ulo), MIN2(i1->_uhi, i2->_uhi)},\n-                                                    {i1->_bits._zeros | i2->_bits._zeros, i1->_bits._ones | i2->_bits._ones}},\n-                             MIN2(i1->_widen, i2->_widen), true);\n-    }\n-  }\n+const Type* TypeIntHelper::int_type_xmeet(const CT* t1, const CT* t2) {\n+  using S = std::remove_const_t<decltype(CT::_lo)>;\n+  using U = std::remove_const_t<decltype(CT::_ulo)>;\n+  return CT::make_or_top(TypeIntPrototype<S, U>{{MIN2(t1->_lo, t2->_lo), MAX2(t1->_hi, t2->_hi)},\n+                                                {MIN2(t1->_ulo, t2->_ulo), MAX2(t1->_uhi, t2->_uhi)},\n+                                                {t1->_bits._zeros & t2->_bits._zeros, t1->_bits._ones & t2->_bits._ones}},\n+                         MAX2(t1->_widen, t2->_widen), false);\n+}\n+template const Type* TypeIntHelper::int_type_xmeet(const TypeInt* i1, const TypeInt* t2);\n+template const Type* TypeIntHelper::int_type_xmeet(const TypeLong* i1, const TypeLong* t2);\n@@ -725,30 +704,8 @@\n-  assert(t2->base() != i1->base(), \"\");\n-  switch (t2->base()) {          \/\/ Switch on original type\n-  case Type::AnyPtr:                  \/\/ Mixing with oops happens when javac\n-  case Type::RawPtr:                  \/\/ reuses local variables\n-  case Type::OopPtr:\n-  case Type::InstPtr:\n-  case Type::AryPtr:\n-  case Type::MetadataPtr:\n-  case Type::KlassPtr:\n-  case Type::InstKlassPtr:\n-  case Type::AryKlassPtr:\n-  case Type::NarrowOop:\n-  case Type::NarrowKlass:\n-  case Type::Int:\n-  case Type::Long:\n-  case Type::HalfFloatTop:\n-  case Type::HalfFloatCon:\n-  case Type::HalfFloatBot:\n-  case Type::FloatTop:\n-  case Type::FloatCon:\n-  case Type::FloatBot:\n-  case Type::DoubleTop:\n-  case Type::DoubleCon:\n-  case Type::DoubleBot:\n-  case Type::Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-  default:                      \/\/ All else is a mistake\n-    i1->typerr(t2);\n-    return nullptr;\n-  }\n+template <class CT>\n+const Type* TypeIntHelper::int_type_xjoin(const CT* t1, const CT* t2) {\n+  using S = std::remove_const_t<decltype(CT::_lo)>;\n+  using U = std::remove_const_t<decltype(CT::_ulo)>;\n+  return CT::make_or_top(TypeIntPrototype<S, U>{{MAX2(t1->_lo, t2->_lo), MIN2(t1->_hi, t2->_hi)},\n+                                                {MAX2(t1->_ulo, t2->_ulo), MIN2(t1->_uhi, t2->_uhi)},\n+                                                {t1->_bits._zeros | t2->_bits._zeros, t1->_bits._ones | t2->_bits._ones}},\n+                         MIN2(t1->_widen, t2->_widen), false);\n@@ -756,2 +713,2 @@\n-template const Type* TypeIntHelper::int_type_xmeet(const TypeInt* i1, const Type* t2);\n-template const Type* TypeIntHelper::int_type_xmeet(const TypeLong* i1, const Type* t2);\n+template const Type* TypeIntHelper::int_type_xjoin(const TypeInt* i1, const TypeInt* t2);\n+template const Type* TypeIntHelper::int_type_xjoin(const TypeLong* i1, const TypeLong* t2);\n","filename":"src\/hotspot\/share\/opto\/rangeinference.cpp","additions":20,"deletions":63,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -160,1 +160,4 @@\n-  static const Type* int_type_xmeet(const CT* i1, const Type* t2);\n+  static const Type* int_type_xmeet(const CT* i1, const CT* t2);\n+\n+  template <class CT>\n+  static const Type* int_type_xjoin(const CT* i1, const CT* t2);\n","filename":"src\/hotspot\/share\/opto\/rangeinference.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1997,2 +1997,3 @@\n-  if (phase->type(in1)->higher_equal(TypeInt::POS) ||\n-      phase->type(in1)->higher_equal(TypeLong::POS)) {\n+  const Type* in_type = phase->type(in1);\n+  if ((in_type->isa_int() && in_type->is_int()->_lo >= 0) ||\n+      (in_type->isa_long() && in_type->is_long()->_lo >= 0)) {\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"ci\/ciObject.hpp\"\n@@ -40,0 +41,1 @@\n+#include \"opto\/compile.hpp\"\n@@ -48,0 +50,2 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n@@ -761,1 +765,1 @@\n-const Type *Type::hashcons(void) {\n+const Type* Type::hashcons() {\n@@ -764,1 +768,1 @@\n-  Dict *tdic = type_dict();\n+  Dict* tdic = type_dict();\n@@ -766,16 +770,1 @@\n-  if( old ) {                   \/\/ Pre-existing Type?\n-    if( old != this )           \/\/ Yes, this guy is not the pre-existing?\n-      delete this;              \/\/ Yes, Nuke this guy\n-    assert( old->_dual, \"\" );\n-    return old;                 \/\/ Return pre-existing\n-  }\n-\n-  \/\/ Every type has a dual (to make my lattice symmetric).\n-  \/\/ Since we just discovered a new Type, compute its dual right now.\n-  assert( !_dual, \"\" );         \/\/ No dual yet\n-  _dual = xdual();              \/\/ Compute the dual\n-  if (equals(this, _dual)) {    \/\/ Handle self-symmetric\n-    if (_dual != this) {\n-      delete _dual;\n-      _dual = this;\n-    }\n+  if (old == nullptr) {\n@@ -784,11 +773,4 @@\n-  assert( !_dual->_dual, \"\" );  \/\/ No reverse dual yet\n-  assert( !(*tdic)[_dual], \"\" ); \/\/ Dual not in type system either\n-  \/\/ New Type, insert into Type table\n-  tdic->Insert((void*)_dual,(void*)_dual);\n-  ((Type*)_dual)->_dual = this; \/\/ Finish up being symmetric\n-#ifdef ASSERT\n-  Type *dual_dual = (Type*)_dual->xdual();\n-  assert( eq(dual_dual), \"xdual(xdual()) should be identity\" );\n-  delete dual_dual;\n-#endif\n-  return this;                  \/\/ Return new Type\n+  if (old != this) {\n+    delete this;\n+  }\n+  return old;\n@@ -866,0 +848,1 @@\n+\n@@ -867,11 +850,16 @@\n-  GrowableArray<VerifyMeetResultEntry> _cache;\n-\n-  \/\/ With verification code, the meet of A and B causes the computation of:\n-  \/\/ 1- meet(A, B)\n-  \/\/ 2- meet(B, A)\n-  \/\/ 3- meet(dual(meet(A, B)), dual(A))\n-  \/\/ 4- meet(dual(meet(A, B)), dual(B))\n-  \/\/ 5- meet(dual(A), dual(B))\n-  \/\/ 6- meet(dual(B), dual(A))\n-  \/\/ 7- meet(dual(meet(dual(A), dual(B))), A)\n-  \/\/ 8- meet(dual(meet(dual(A), dual(B))), B)\n+  GrowableArray<VerifyMeetResultEntry> _meet_cache;\n+  GrowableArray<VerifyMeetResultEntry> _join_cache;\n+\n+  \/\/ With verification code, the meet\/join of A and B causes the computation of:\n+  \/\/ 1-  meet(A, B)\n+  \/\/ 2-  meet(B, A)\n+  \/\/ 3-  join(A, B)\n+  \/\/ 4-  join(B, A)\n+  \/\/ 5-  meet(A, meet(A, B))\n+  \/\/ 6-  meet(B, meet(A, B))\n+  \/\/ 7-  join(A, meet(A, B))\n+  \/\/ 8-  join(B, meet(A, B))\n+  \/\/ 9-  meet(A, join(A, B))\n+  \/\/ 10- meet(B, join(A, B))\n+  \/\/ 11- join(A, join(A, B))\n+  \/\/ 12- join(B, join(A, B))\n@@ -882,9 +870,13 @@\n-  \/\/ 1- meet(A[], B[][)\n-  \/\/   1.1- meet(A, B)\n-  \/\/   1.2- meet(B, A)\n-  \/\/   1.3- meet(dual(meet(A, B)), dual(A))\n-  \/\/   1.4- meet(dual(meet(A, B)), dual(B))\n-  \/\/   1.5- meet(dual(A), dual(B))\n-  \/\/   1.6- meet(dual(B), dual(A))\n-  \/\/   1.7- meet(dual(meet(dual(A), dual(B))), A)\n-  \/\/   1.8- meet(dual(meet(dual(A), dual(B))), B)\n+  \/\/ 1- meet(A[], B[])\n+  \/\/   1.1-  meet(A, B)\n+  \/\/   1.2-  meet(B, A)\n+  \/\/   1.3-  join(A, B)\n+  \/\/   1.4-  join(B, A)\n+  \/\/   1.5-  meet(A, meet(A, B))\n+  \/\/   1.6-  meet(B, meet(A, B))\n+  \/\/   1.7-  join(A, meet(A, B))\n+  \/\/   1.8-  join(B, meet(A, B))\n+  \/\/   1.9-  meet(A, join(A, B))\n+  \/\/   1.10- meet(B, join(A, B))\n+  \/\/   1.11- join(A, join(A, B))\n+  \/\/   1.12- join(B, join(A, B))\n@@ -892,8 +884,12 @@\n-  \/\/   2.1- meet(B, A) = 1.2\n-  \/\/   2.2- meet(A, B) = 1.1\n-  \/\/   2.3- meet(dual(meet(B, A)), dual(B)) = 1.4\n-  \/\/   2.4- meet(dual(meet(B, A)), dual(A)) = 1.3\n-  \/\/   2.5- meet(dual(B), dual(A)) = 1.6\n-  \/\/   2.6- meet(dual(A), dual(B)) = 1.5\n-  \/\/   2.7- meet(dual(meet(dual(B), dual(A))), B) = 1.8\n-  \/\/   2.8- meet(dual(meet(dual(B), dual(A))), B) = 1.7\n+  \/\/   2.1-  meet(B, A) = 1.2\n+  \/\/   2.2-  meet(A, B) = 1.1\n+  \/\/   1.3-  join(B, A) = 1.4\n+  \/\/   1.4-  join(A, B) = 1.3\n+  \/\/   1.5-  meet(B, meet(B, A)) = 1.6\n+  \/\/   1.6-  meet(A, meet(B, A)) = 1.5\n+  \/\/   1.7-  join(B, meet(B, A)) = 1.8\n+  \/\/   1.8-  join(A, meet(B, A)) = 1.7\n+  \/\/   1.9-  meet(B, join(B, A)) = 1.10\n+  \/\/   1.10- meet(A, join(B, A)) = 1.9\n+  \/\/   1.11- join(B, join(B, A)) = 1.12\n+  \/\/   1.12- join(A, join(B, A)) = 1.11\n@@ -901,3 +897,0 @@\n-  \/\/ The number of meet operations performed grows exponentially with the number of dimensions of the arrays but the number\n-  \/\/ of different meet operations is linear in the number of dimensions. The function below caches meet results for the\n-  \/\/ duration of the meet at the root of the recursive calls.\n@@ -905,1 +898,5 @@\n-  const Type* meet(const Type* t1, const Type* t2) {\n+  \/\/ When the dimensions of the arrays increase, the number of performed operations grows\n+  \/\/ exponentially but the number of distinct operations grows linearly. The function below caches\n+  \/\/ the results for the duration of the operation at the root of the recursive calls.\n+  template <class F>\n+  static const Type* meet_join(F op, GrowableArray<VerifyMeetResultEntry>& cache, const Type* t1, const Type* t2) {\n@@ -907,2 +904,2 @@\n-    const VerifyMeetResultEntry meet(t1, t2, nullptr);\n-    int pos = _cache.find_sorted<VerifyMeetResultEntry, VerifyMeetResultEntry::compare>(meet, found);\n+    const VerifyMeetResultEntry entry(t1, t2, nullptr);\n+    int pos = cache.find_sorted<VerifyMeetResultEntry, VerifyMeetResultEntry::compare>(entry, found);\n@@ -911,1 +908,1 @@\n-      res = _cache.at(pos).res();\n+      res = cache.at(pos).res();\n@@ -913,2 +910,2 @@\n-      res = t1->xmeet(t2);\n-      _cache.insert_sorted<VerifyMeetResultEntry::compare>(VerifyMeetResultEntry(t1, t2, res));\n+      res = op(t1, t2);\n+      cache.insert_sorted<VerifyMeetResultEntry::compare>(VerifyMeetResultEntry(t1, t2, res));\n@@ -916,1 +913,1 @@\n-      _cache.find_sorted<VerifyMeetResultEntry, VerifyMeetResultEntry::compare>(meet, found);\n+      cache.find_sorted<VerifyMeetResultEntry, VerifyMeetResultEntry::compare>(entry, found);\n@@ -922,2 +919,12 @@\n-  void add(const Type* t1, const Type* t2, const Type* res) {\n-    _cache.insert_sorted<VerifyMeetResultEntry::compare>(VerifyMeetResultEntry(t1, t2, res));\n+  const Type* meet(const Type* t1, const Type* t2) {\n+    auto op = [](const Type* t1, const Type* t2) {\n+      return Type::xmeet(t1, t2);\n+    };\n+    return meet_join(op, _meet_cache, t1, t2);\n+  }\n+\n+  const Type* join(const Type* t1, const Type* t2) {\n+    auto op = [](const Type* t1, const Type* t2) {\n+      return Type::xjoin(t1, t2);\n+    };\n+    return meet_join(op, _join_cache, t1, t2);\n@@ -926,2 +933,8 @@\n-  bool empty_cache() const {\n-    return _cache.length() == 0;\n+  bool cache_is_empty() const {\n+    assert(_meet_cache.is_empty() == _join_cache.is_empty(), \"must be simultaneously empty or non-empty\");\n+    return _meet_cache.is_empty();\n+  }\n+\n+  void empty_cache() {\n+    _meet_cache.trunc_to(0);\n+    _join_cache.trunc_to(0);\n@@ -930,2 +943,3 @@\n-  VerifyMeetResult(Compile* C) :\n-          _depth(0), _cache(C->comp_arena(), 2, 0, VerifyMeetResultEntry()) {\n+  VerifyMeetResult(Compile* C) : _depth(0),\n+                                 _meet_cache(C->comp_arena(), 2, 0, VerifyMeetResultEntry()),\n+                                 _join_cache(C->comp_arena(), 2, 0, VerifyMeetResultEntry()) {\n@@ -935,4 +949,0 @@\n-void Type::assert_type_verify_empty() const {\n-  assert(Compile::current()->_type_verify == nullptr || Compile::current()->_type_verify->empty_cache(), \"cache should have been discarded\");\n-}\n-\n@@ -954,1 +964,1 @@\n-      _C->_type_verify->_cache.trunc_to(0);\n+      _C->_type_verify->empty_cache();\n@@ -958,1 +968,1 @@\n-  const Type* meet(const Type* t1, const Type* t2) const {\n+  const Type* meet(const Type* t1, const Type* t2) {\n@@ -962,2 +972,2 @@\n-  void add(const Type* t1, const Type* t2, const Type* res) const {\n-    _C->_type_verify->add(t1, t2, res);\n+  const Type* join(const Type* t1, const Type* t2) {\n+    return _C->_type_verify->join(t1, t2);\n@@ -967,1 +977,1 @@\n-void Type::check_symmetrical(const Type* t, const Type* mt, const VerifyMeet& verify) const {\n+void Type::check_symmetrical(const Type* t1, const Type* t2, VerifyMeet& verify) {\n@@ -969,2 +979,3 @@\n-  const Type* mt2 = verify.meet(t, this);\n-  if (mt != mt2) {\n+  const Type* mt1 = verify.meet(t1, t2);\n+  const Type* mt2 = verify.meet(t2, t1);\n+  if (mt1 != mt2) {\n@@ -972,4 +983,4 @@\n-    tty->print(\"t           = \");   t->dump(); tty->cr();\n-    tty->print(\"this        = \");      dump(); tty->cr();\n-    tty->print(\"t meet this = \"); mt2->dump(); tty->cr();\n-    tty->print(\"this meet t = \");  mt->dump(); tty->cr();\n+    tty->print(\"t1          = \");  t1->dump(); tty->cr();\n+    tty->print(\"t2          = \");  t2->dump(); tty->cr();\n+    tty->print(\"t1 meets t2 = \"); mt1->dump(); tty->cr();\n+    tty->print(\"t2 meets t1 = \"); mt2->dump(); tty->cr();\n@@ -978,17 +989,0 @@\n-  const Type* dual_join = mt->_dual;\n-  const Type* t2t    = verify.meet(dual_join,t->_dual);\n-  const Type* t2this = verify.meet(dual_join,this->_dual);\n-\n-  \/\/ Interface meet Oop is Not Symmetric:\n-  \/\/ Interface:AnyNull meet Oop:AnyNull == Interface:AnyNull\n-  \/\/ Interface:NotNull meet Oop:NotNull == java\/lang\/Object:NotNull\n-\n-  if (t2t != t->_dual || t2this != this->_dual) {\n-    tty->print_cr(\"=== Meet Not Symmetric ===\");\n-    tty->print(\"t   =                   \");              t->dump(); tty->cr();\n-    tty->print(\"this=                   \");                 dump(); tty->cr();\n-    tty->print(\"mt=(t meet this)=       \");             mt->dump(); tty->cr();\n-\n-    tty->print(\"t_dual=                 \");       t->_dual->dump(); tty->cr();\n-    tty->print(\"this_dual=              \");          _dual->dump(); tty->cr();\n-    tty->print(\"mt_dual=                \");      mt->_dual->dump(); tty->cr();\n@@ -996,4 +990,41 @@\n-    tty->print(\"mt_dual meet t_dual=    \"); t2t           ->dump(); tty->cr();\n-    tty->print(\"mt_dual meet this_dual= \"); t2this        ->dump(); tty->cr();\n-\n-    fatal(\"meet not symmetric\");\n+  const Type* jt1 = verify.join(t1, t2);\n+  const Type* jt2 = verify.join(t2, t1);\n+  if (jt1 != jt2) {\n+    tty->print_cr(\"=== Join Not Commutative ===\");\n+    tty->print(\"t1          = \");  t1->dump(); tty->cr();\n+    tty->print(\"t2          = \");  t2->dump(); tty->cr();\n+    tty->print(\"t1 joins t2 = \"); jt1->dump(); tty->cr();\n+    tty->print(\"t2 joins t1 = \"); jt2->dump(); tty->cr();\n+    fatal(\"join not commutative\");\n+  }\n+\n+  const Type* mt = mt1;\n+  const Type* jt = jt1;\n+\n+  const Type* t1mmt = verify.meet(t1, mt);\n+  const Type* t2mmt = verify.meet(t2, mt);\n+  const Type* t1jmt = verify.join(t1, mt);\n+  const Type* t2jmt = verify.join(t2, mt);\n+  const Type* t1mjt = verify.meet(t1, jt);\n+  const Type* t2mjt = verify.meet(t2, jt);\n+  const Type* t1jjt = verify.join(t1, jt);\n+  const Type* t2jjt = verify.join(t2, jt);\n+\n+  if (t1mmt != mt || t2mmt != mt || t1jmt != t1 || t2jmt != t2 ||\n+      t1mjt != t1 || t2mjt != t2 || t1jjt != jt || t2jjt != jt) {\n+    tty->print_cr(\"=== Fundamental Laws Violation ===\");\n+    tty->print(\"t1               = \"); t1->dump(); tty->cr();\n+    tty->print(\"t2               = \"); t2->dump(); tty->cr();\n+    tty->print(\"mt = t1 meets t2 = \"); mt->dump(); tty->cr();\n+    tty->print(\"jt = t1 joins t2 = \"); jt->dump(); tty->cr();\n+\n+    tty->print(\"t1 meets mt      = \"); t1mmt->dump(); tty->cr();\n+    tty->print(\"t2 meets mt      = \"); t2mmt->dump(); tty->cr();\n+    tty->print(\"t1 joins mt      = \"); t1jmt->dump(); tty->cr();\n+    tty->print(\"t2 joins mt      = \"); t2jmt->dump(); tty->cr();\n+    tty->print(\"t1 meets jt      = \"); t1mjt->dump(); tty->cr();\n+    tty->print(\"t2 meets jt      = \"); t2mjt->dump(); tty->cr();\n+    tty->print(\"t1 joins jt      = \"); t1jjt->dump(); tty->cr();\n+    tty->print(\"t2 joins jt      = \"); t2jjt->dump(); tty->cr();\n+\n+    fatal(\"Fundamental Laws Violation\");\n@@ -1004,6 +1035,4 @@\n-\/\/------------------------------meet-------------------------------------------\n-\/\/ Compute the MEET of two types.  NOT virtual.  It enforces that meet is\n-\/\/ commutative and the lattice is symmetric.\n-const Type *Type::meet_helper(const Type *t, bool include_speculative) const {\n-  if (isa_narrowoop() && t->isa_narrowoop()) {\n-    const Type* result = make_ptr()->meet_helper(t->make_ptr(), include_speculative);\n+template <class F>\n+const Type* Type::meet_join_helper(F op, const Type* t1, const Type* t2, bool include_speculative) {\n+  if (t1->isa_narrowoop() && t2->isa_narrowoop()) {\n+    const Type* result = meet_join_helper(op, t1->make_ptr(), t2->make_ptr(), include_speculative);\n@@ -1012,2 +1041,2 @@\n-  if (isa_narrowklass() && t->isa_narrowklass()) {\n-    const Type* result = make_ptr()->meet_helper(t->make_ptr(), include_speculative);\n+  if (t1->isa_narrowklass() && t2->isa_narrowklass()) {\n+    const Type* result = meet_join_helper(op, t1->make_ptr(), t2->make_ptr(), include_speculative);\n@@ -1017,0 +1046,4 @@\n+  t1 = t1->maybe_remove_speculative(include_speculative);\n+  t2 = t2->maybe_remove_speculative(include_speculative);\n+  const Type* rt = op(t1, t2);\n+\n@@ -1020,0 +1053,1 @@\n+  check_symmetrical(t1, t2, verify);\n@@ -1022,17 +1056,1 @@\n-  const Type *this_t = maybe_remove_speculative(include_speculative);\n-  t = t->maybe_remove_speculative(include_speculative);\n-\n-  const Type *mt = this_t->xmeet(t);\n-#ifdef ASSERT\n-  verify.add(this_t, t, mt);\n-  if (isa_narrowoop() || t->isa_narrowoop()) {\n-    return mt;\n-  }\n-  if (isa_narrowklass() || t->isa_narrowklass()) {\n-    return mt;\n-  }\n-  this_t->check_symmetrical(t, mt, verify);\n-  const Type *mt_dual = verify.meet(this_t->_dual, t->_dual);\n-  this_t->_dual->check_symmetrical(t->_dual, mt_dual, verify);\n-#endif\n-  return mt;\n+  return rt;\n@@ -1041,11 +1059,9 @@\n-\/\/------------------------------xmeet------------------------------------------\n-\/\/ Compute the MEET of two types.  It returns a new Type object.\n-const Type *Type::xmeet( const Type *t ) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n-\n-  \/\/ Meeting TOP with anything?\n-  if( _base == Top ) return t;\n-\n-  \/\/ Meeting BOTTOM with anything?\n-  if( _base == Bottom ) return BOTTOM;\n+\/\/------------------------------meet-------------------------------------------\n+\/\/ Compute the MEET of two types.  NOT virtual.  It enforces that meet is\n+\/\/ commutative and the lattice is symmetric.\n+const Type *Type::meet_helper(const Type *t, bool include_speculative) const {\n+  auto op = [](const Type* t1, const Type* t2) {\n+    return xmeet(t1, t2);\n+  };\n+  return meet_join_helper(op, this, t, include_speculative);\n+}\n@@ -1053,3 +1069,6 @@\n-  \/\/ Current \"this->_base\" is one of: Bad, Multi, Control, Top,\n-  \/\/ Abio, Abstore, Floatxxx, Doublexxx, Bottom, lastype.\n-  switch (t->base()) {  \/\/ Switch on original type\n+const Type* Type::join_helper(const Type* t, bool include_speculative) const {\n+  auto op = [](const Type* t1, const Type* t2) {\n+    return xjoin(t1, t2);\n+  };\n+  return meet_join_helper(op, this, t, include_speculative);\n+}\n@@ -1057,8 +1076,11 @@\n-  \/\/ Cut in half the number of cases I must handle.  Only need cases for when\n-  \/\/ the given enum \"t->type\" is less than or equal to the local enum \"type\".\n-  case HalfFloatCon:\n-  case FloatCon:\n-  case DoubleCon:\n-  case Int:\n-  case Long:\n-    return t->xmeet(this);\n+const Type* Type::xmeet(const Type* t1, const Type* t2) {\n+  if (t1 == t2) {\n+    return t1;\n+  }\n+  if (t1 == Type::TOP) {\n+    return t2;\n+  } else if (t2 == Type::TOP) {\n+    return t1;\n+  } else if (t1 == Type::BOTTOM || t2 == Type::BOTTOM) {\n+    return Type::BOTTOM;\n+  }\n@@ -1066,2 +1088,2 @@\n-  case OopPtr:\n-    return t->xmeet(this);\n+  return t1->xmeet(t2);\n+}\n@@ -1069,2 +1091,11 @@\n-  case InstPtr:\n-    return t->xmeet(this);\n+const Type* Type::xjoin(const Type* t1, const Type* t2) {\n+  if (t1 == t2) {\n+    return t1;\n+  }\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  } else if (t1 == Type::BOTTOM) {\n+    return t2;\n+  } else if (t2 == Type::BOTTOM) {\n+    return t1;\n+  }\n@@ -1072,5 +1103,2 @@\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-    return t->xmeet(this);\n+  return t1->xjoin(t2);\n+}\n@@ -1078,2 +1106,18 @@\n-  case AryPtr:\n-    return t->xmeet(this);\n+\/\/------------------------------xmeet------------------------------------------\n+\/\/ Compute the MEET of two types. It returns a new Type object.\n+const Type* Type::xmeet(const Type* t) const {\n+  \/\/ Current \"this->_base\" is one of: Floatxxx, Doublexxx. For Bad, Multi, Control, Abio, Abstore,\n+  \/\/ should have been handled by Type::xmeet(const Type* t1, const Type* t2) since their types are\n+  \/\/ singleton and t1 must always be equal to t2.\n+  switch (base()) {\n+    default:\n+      typerr(t);\n+\n+    case HalfFloatTop:\n+    case HalfFloatBot:\n+    case FloatTop:\n+    case FloatBot:\n+    case DoubleTop:\n+    case DoubleBot:\n+      break;\n+  }\n@@ -1081,2 +1125,16 @@\n-  case NarrowOop:\n-    return t->xmeet(this);\n+  switch (t->base()) {  \/\/ Switch on original type\n+    case HalfFloatCon:\n+    case FloatCon:\n+    case DoubleCon:\n+      return t->xmeet(this);\n+\n+    case HalfFloatTop:\n+      if (base() == HalfFloatTop || base() == HalfFloatBot) {\n+        return this;\n+      }\n+      typerr(t);\n+    case HalfFloatBot:\n+      if (base() == HalfFloatTop || base() == HalfFloatBot) {\n+        return t;\n+      }\n+      typerr(t);\n@@ -1084,2 +1142,10 @@\n-  case NarrowKlass:\n-    return t->xmeet(this);\n+    case FloatTop:\n+      if (base() == FloatTop || base() == FloatBot) {\n+        return this;\n+      }\n+      typerr(t);\n+    case FloatBot:\n+      if (base() == FloatTop || base() == FloatBot) {\n+        return t;\n+      }\n+      typerr(t);\n@@ -1087,4 +1153,10 @@\n-  case Bad:                     \/\/ Type check\n-  default:                      \/\/ Bogus type not in lattice\n-    typerr(t);\n-    return Type::BOTTOM;\n+    case DoubleTop:\n+      if (base() == DoubleTop || base() == DoubleBot) {\n+        return this;\n+      }\n+      typerr(t);\n+    case DoubleBot:\n+      if (base() == DoubleTop || base() == DoubleBot) {\n+        return t;\n+      }\n+      typerr(t);\n@@ -1092,2 +1164,4 @@\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return t;\n+    default:\n+      typerr(t);\n+  }\n+}\n@@ -1095,8 +1169,14 @@\n-  case HalfFloatTop:\n-    if (_base == HalfFloatTop) { return this; }\n-  case HalfFloatBot:            \/\/ Half Float\n-    if (_base == HalfFloatBot || _base == HalfFloatTop) { return HALF_FLOAT; }\n-    if (_base == FloatBot || _base == FloatTop) { return Type::BOTTOM; }\n-    if (_base == DoubleTop || _base == DoubleBot) { return Type::BOTTOM; }\n-    typerr(t);\n-    return Type::BOTTOM;\n+\/\/ Compute the JOIN of two types. This is similar to xmeet above.\n+const Type* Type::xjoin(const Type* t) const {\n+  switch (base()) {\n+    default:\n+      typerr(t);\n+\n+    case HalfFloatTop:\n+    case HalfFloatBot:\n+    case FloatTop:\n+    case FloatBot:\n+    case DoubleTop:\n+    case DoubleBot:\n+      break;\n+  }\n@@ -1104,8 +1184,16 @@\n-  case FloatTop:\n-    if (_base == FloatTop ) { return this; }\n-  case FloatBot:                \/\/ Float\n-    if (_base == FloatBot || _base == FloatTop) { return FLOAT; }\n-    if (_base == HalfFloatTop || _base == HalfFloatBot) { return Type::BOTTOM; }\n-    if (_base == DoubleTop || _base == DoubleBot) { return Type::BOTTOM; }\n-    typerr(t);\n-    return Type::BOTTOM;\n+  switch (t->base()) {  \/\/ Switch on original type\n+    case HalfFloatCon:\n+    case FloatCon:\n+    case DoubleCon:\n+      return t->xjoin(this);\n+\n+    case HalfFloatTop:\n+      if (base() == HalfFloatTop || base() == HalfFloatBot) {\n+        return t;\n+      }\n+      typerr(t);\n+    case HalfFloatBot:\n+      if (base() == HalfFloatTop || base() == HalfFloatBot) {\n+        return this;\n+      }\n+      typerr(t);\n@@ -1113,8 +1201,10 @@\n-  case DoubleTop:\n-    if (_base == DoubleTop) { return this; }\n-  case DoubleBot:               \/\/ Double\n-    if (_base == DoubleBot || _base == DoubleTop) { return DOUBLE; }\n-    if (_base == HalfFloatTop || _base == HalfFloatBot) { return Type::BOTTOM; }\n-    if (_base == FloatTop || _base == FloatBot) { return Type::BOTTOM; }\n-    typerr(t);\n-    return Type::BOTTOM;\n+    case FloatTop:\n+      if (base() == FloatTop || base() == FloatBot) {\n+        return t;\n+      }\n+      typerr(t);\n+    case FloatBot:\n+      if (base() == FloatTop || base() == FloatBot) {\n+        return this;\n+      }\n+      typerr(t);\n@@ -1122,7 +1212,10 @@\n-  \/\/ These next few cases must match exactly or it is a compile-time error.\n-  case Control:                 \/\/ Control of code\n-  case Abio:                    \/\/ State of world outside of program\n-  case Memory:\n-    if (_base == t->_base)  { return this; }\n-    typerr(t);\n-    return Type::BOTTOM;\n+    case DoubleTop:\n+      if (base() == DoubleTop || base() == DoubleBot) {\n+        return t;\n+      }\n+      typerr(t);\n+    case DoubleBot:\n+      if (base() == DoubleTop || base() == DoubleBot) {\n+        return this;\n+      }\n+      typerr(t);\n@@ -1130,2 +1223,2 @@\n-  case Top:                     \/\/ Top of the lattice\n-    return this;\n+    default:\n+      typerr(t);\n@@ -1133,3 +1226,0 @@\n-\n-  \/\/ The type is unchanged\n-  return this;\n@@ -1146,7 +1236,0 @@\n-\/\/------------------------------xdual------------------------------------------\n-const Type *Type::xdual() const {\n-  \/\/ Note: the base() accessor asserts the sanity of _base.\n-  assert(_type_info[base()].dual_type != Bad, \"implement with v-call\");\n-  return new Type(_type_info[_base].dual_type);\n-}\n-\n@@ -1350,6 +1433,1 @@\n-\/\/------------------------------meet-------------------------------------------\n-\/\/ Compute the MEET of two types.  It returns a new Type object.\n-const Type *TypeF::xmeet( const Type *t ) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n-\n+const Type* TypeF::xmeet(const Type* t) const {\n@@ -1357,38 +1435,10 @@\n-  switch (t->base()) {          \/\/ Switch on original type\n-  case AnyPtr:                  \/\/ Mixing with oops happens when javac\n-  case RawPtr:                  \/\/ reuses local variables\n-  case OopPtr:\n-  case InstPtr:\n-  case AryPtr:\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-  case NarrowOop:\n-  case NarrowKlass:\n-  case Int:\n-  case Long:\n-  case HalfFloatTop:\n-  case HalfFloatCon:\n-  case HalfFloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-\n-  case FloatBot:\n-    return t;\n-\n-  default:                      \/\/ All else is a mistake\n-    typerr(t);\n-\n-  case FloatCon:                \/\/ Float-constant vs Float-constant?\n-    if( jint_cast(_f) != jint_cast(t->getf()) )         \/\/ unequal constants?\n-                                \/\/ must compare bitwise as positive zero, negative zero and NaN have\n-                                \/\/ all the same representation in C++\n-      return FLOAT;             \/\/ Return generic float\n-                                \/\/ Equal constants\n-  case Top:\n-  case FloatTop:\n-    break;                      \/\/ Return the float constant\n+  switch (t->base()) {\n+    case FloatTop:\n+      return this;\n+    case FloatCon:\n+      assert(jint_cast(_f) != jint_cast(t->getf()), \"Equivalent instances should not appear here\");\n+      return Type::FLOAT;\n+    case FloatBot:\n+      return t;\n+    default:\n+      typerr(t);\n@@ -1396,1 +1446,0 @@\n-  return this;                  \/\/ Return the float constant\n@@ -1399,4 +1448,13 @@\n-\/\/------------------------------xdual------------------------------------------\n-\/\/ Dual: symmetric\n-const Type *TypeF::xdual() const {\n-  return this;\n+const Type* TypeF::xjoin(const Type* t) const {\n+  \/\/ Current \"this->_base\" is FloatCon\n+  switch (t->base()) {\n+    case FloatTop:\n+      return t;\n+    case FloatCon:\n+      assert(jint_cast(_f) != jint_cast(t->getf()), \"Equivalent instances should not appear here\");\n+      return Type::make(FloatTop);\n+    case FloatBot:\n+      return this;\n+    default:\n+      typerr(t);\n+  }\n@@ -1473,2 +1531,0 @@\n-\/\/------------------------------xmeet-------------------------------------------\n-\/\/ Compute the MEET of two types.  It returns a new Type object.\n@@ -1476,3 +1532,0 @@\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if (this == t) return this;  \/\/ Meeting same type-rep?\n-\n@@ -1480,38 +1533,10 @@\n-  switch (t->base()) {          \/\/ Switch on original type\n-  case AnyPtr:                  \/\/ Mixing with oops happens when javac\n-  case RawPtr:                  \/\/ reuses local variables\n-  case OopPtr:\n-  case InstPtr:\n-  case AryPtr:\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-  case NarrowOop:\n-  case NarrowKlass:\n-  case Int:\n-  case Long:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-\n-  case HalfFloatBot:\n-    return t;\n-\n-  default:                      \/\/ All else is a mistake\n-    typerr(t);\n-\n-  case HalfFloatCon:            \/\/ Half float-constant vs Half float-constant?\n-    if (_f != t->geth()) {      \/\/ unequal constants?\n-                                \/\/ must compare bitwise as positive zero, negative zero and NaN have\n-                                \/\/ all the same representation in C++\n-      return HALF_FLOAT;        \/\/ Return generic float\n-    }                           \/\/ Equal constants\n-  case Top:\n-  case HalfFloatTop:\n-    break;                      \/\/ Return the Half float constant\n+  switch (t->base()) {\n+    case HalfFloatTop:\n+      return this;\n+    case HalfFloatCon:\n+      assert(_f != t->is_half_float_constant()->_f, \"Equivalent instances should not appear here\");\n+      return Type::HALF_FLOAT;\n+    case HalfFloatBot:\n+      return t;\n+    default:\n+      typerr(t);\n@@ -1519,1 +1544,0 @@\n-  return this;                  \/\/ Return the Half float constant\n@@ -1522,4 +1546,13 @@\n-\/\/------------------------------xdual------------------------------------------\n-\/\/ Dual: symmetric\n-const Type* TypeH::xdual() const {\n-  return this;\n+const Type* TypeH::xjoin(const Type* t) const {\n+  \/\/ Current \"this->_base\" is FloatCon\n+  switch (t->base()) {\n+    case HalfFloatTop:\n+      return t;\n+    case HalfFloatCon:\n+      assert(_f != t->is_half_float_constant()->_f, \"Equivalent instances should not appear here\");\n+      return Type::make(HalfFloatTop);\n+    case HalfFloatBot:\n+      return this;\n+    default:\n+      typerr(t);\n+  }\n@@ -1598,42 +1631,12 @@\n-\/\/------------------------------meet-------------------------------------------\n-\/\/ Compute the MEET of two types.  It returns a new Type object.\n-const Type *TypeD::xmeet( const Type *t ) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n-\n-  \/\/ Current \"this->_base\" is DoubleCon\n-  switch (t->base()) {          \/\/ Switch on original type\n-  case AnyPtr:                  \/\/ Mixing with oops happens when javac\n-  case RawPtr:                  \/\/ reuses local variables\n-  case OopPtr:\n-  case InstPtr:\n-  case AryPtr:\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-  case NarrowOop:\n-  case NarrowKlass:\n-  case Int:\n-  case Long:\n-  case HalfFloatTop:\n-  case HalfFloatCon:\n-  case HalfFloatBot:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-\n-  case DoubleBot:\n-    return t;\n-\n-  default:                      \/\/ All else is a mistake\n-    typerr(t);\n-\n-  case DoubleCon:               \/\/ Double-constant vs Double-constant?\n-    if( jlong_cast(_d) != jlong_cast(t->getd()) )       \/\/ unequal constants? (see comment in TypeF::xmeet)\n-      return DOUBLE;            \/\/ Return generic double\n-  case Top:\n-  case DoubleTop:\n-    break;\n+const Type* TypeD::xmeet(const Type* t) const {\n+  \/\/ Current \"this->_base\" is FloatCon\n+  switch (t->base()) {\n+    case DoubleTop:\n+      return this;\n+    case DoubleCon:\n+      assert(jlong_cast(_d) != jlong_cast(t->getd()), \"Equivalent instances should not appear here\");\n+      return Type::DOUBLE;\n+    case DoubleBot:\n+      return t;\n+    default:\n+      typerr(t);\n@@ -1641,1 +1644,0 @@\n-  return this;                  \/\/ Return the double constant\n@@ -1644,4 +1646,13 @@\n-\/\/------------------------------xdual------------------------------------------\n-\/\/ Dual: symmetric\n-const Type *TypeD::xdual() const {\n-  return this;\n+const Type* TypeD::xjoin(const Type* t) const {\n+  \/\/ Current \"this->_base\" is FloatCon\n+  switch (t->base()) {\n+    case DoubleTop:\n+      return t;\n+    case DoubleCon:\n+      assert(jlong_cast(_d) != jlong_cast(t->getd()), \"Equivalent instances should not appear here\");\n+      return Type::make(DoubleTop);\n+    case DoubleBot:\n+      return this;\n+    default:\n+      typerr(t);\n+  }\n@@ -1818,1 +1829,4 @@\n-  return TypeIntHelper::int_type_xmeet(this, t);\n+  if (base() != Int || t->base() != Int) {\n+    typerr(t);\n+  }\n+  return TypeIntHelper::int_type_xmeet(this, t->is_int());\n@@ -1821,3 +1835,5 @@\n-const Type* TypeInt::xdual() const {\n-  return new TypeInt(TypeIntPrototype<jint, juint>{{_lo, _hi}, {_ulo, _uhi}, _bits},\n-                     _widen, !_is_dual);\n+const Type* TypeInt::xjoin(const Type* t) const {\n+  if (base() != Int || t->base() != Int) {\n+    typerr(t);\n+  }\n+  return TypeIntHelper::int_type_xjoin(this, t->is_int());\n@@ -1946,1 +1962,4 @@\n-  return TypeIntHelper::int_type_xmeet(this, t);\n+  if (base() != Long || t->base() != Long) {\n+    typerr(t);\n+  }\n+  return TypeIntHelper::int_type_xmeet(this, t->is_long());\n@@ -1949,3 +1968,5 @@\n-const Type* TypeLong::xdual() const {\n-  return new TypeLong(TypeIntPrototype<jlong, julong>{{_lo, _hi}, {_ulo, _uhi}, _bits},\n-                      _widen, !_is_dual);\n+const Type* TypeLong::xjoin(const Type* t) const {\n+  if (base() != Long || t->base() != Long) {\n+    typerr(t);\n+  }\n+  return TypeIntHelper::int_type_xjoin(this, t->is_long());\n@@ -2152,23 +2173,6 @@\n-const Type *TypeTuple::xmeet( const Type *t ) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n-\n-  \/\/ Current \"this->_base\" is Tuple\n-  switch (t->base()) {          \/\/ switch on original type\n-\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return t;\n-\n-  default:                      \/\/ All else is a mistake\n-    typerr(t);\n-\n-  case Tuple: {                 \/\/ Meeting 2 signatures?\n-    const TypeTuple *x = t->is_tuple();\n-    assert( _cnt == x->_cnt, \"\" );\n-    const Type **fields = (const Type **)(Compile::current()->type_arena()->AmallocWords( _cnt*sizeof(Type*) ));\n-    for( uint i=0; i<_cnt; i++ )\n-      fields[i] = field_at(i)->xmeet( x->field_at(i) );\n-    return TypeTuple::make(_cnt,fields);\n-  }\n-  case Top:\n-    break;\n+const Type* TypeTuple::xmeet(const Type* t) const {\n+  const TypeTuple* x = t->is_tuple();\n+  assert(_cnt == x->_cnt, \"mismatched shape: %d != %d\", _cnt, x->_cnt);\n+  const Type** fields = (const Type**)(Compile::current()->type_arena()->AmallocWords(_cnt * sizeof(Type*)));\n+  for (uint i = 0; i < _cnt; i++) {\n+    fields[i] = field_at(i)->meet_speculative(x->field_at(i));\n@@ -2176,1 +2180,1 @@\n-  return this;                  \/\/ Return the double constant\n+  return TypeTuple::make(_cnt, fields);\n@@ -2179,7 +2183,8 @@\n-\/\/------------------------------xdual------------------------------------------\n-\/\/ Dual: compute field-by-field dual\n-const Type *TypeTuple::xdual() const {\n-  const Type **fields = (const Type **)(Compile::current()->type_arena()->AmallocWords( _cnt*sizeof(Type*) ));\n-  for( uint i=0; i<_cnt; i++ )\n-    fields[i] = _fields[i]->dual();\n-  return new TypeTuple(_cnt,fields);\n+const Type* TypeTuple::xjoin(const Type* t) const {\n+  const TypeTuple* x = t->is_tuple();\n+  assert(_cnt == x->_cnt, \"mismatched shape: %d != %d\", _cnt, x->_cnt);\n+  const Type** fields = (const Type**)(Compile::current()->type_arena()->AmallocWords(_cnt * sizeof(Type*)));\n+  for (uint i = 0; i < _cnt; i++) {\n+    fields[i] = field_at(i)->join_speculative(x->field_at(i));\n+  }\n+  return TypeTuple::make(_cnt, fields);\n@@ -2272,9 +2277,5 @@\n-const Type *TypeAry::xmeet( const Type *t ) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n-\n-  \/\/ Current \"this->_base\" is Ary\n-  switch (t->base()) {          \/\/ switch on original type\n-\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return t;\n+const Type* TypeAry::xmeet(const Type* t) const {\n+  const TypeAry* a = t->is_ary();\n+  const TypeInt* size = _size->meet(a->_size)->is_int();\n+  return TypeAry::make(meet_elem(_elem, a->_elem), size, _stable && a->_stable);\n+}\n@@ -2282,2 +2283,12 @@\n-  default:                      \/\/ All else is a mistake\n-    typerr(t);\n+const Type* TypeAry::xjoin(const Type* t) const {\n+  const TypeAry* a = t->is_ary();\n+  const Type* size = _size->join(a->_size);\n+  if (size == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  const Type* elem = join_elem(_elem, a->_elem);\n+  if (elem->empty()) {\n+    return Type::TOP;\n+  }\n+  return TypeAry::make(elem, size->is_int(), _stable || a->_stable);\n+}\n@@ -2285,10 +2296,7 @@\n-  case Array: {                 \/\/ Meeting 2 arrays?\n-    const TypeAry* a = t->is_ary();\n-    const Type* size = _size->xmeet(a->_size);\n-    const TypeInt* isize = size->isa_int();\n-    if (isize == nullptr) {\n-      assert(size == Type::TOP || size == Type::BOTTOM, \"\");\n-      return size;\n-    }\n-    return TypeAry::make(_elem->meet_speculative(a->_elem),\n-                         isize, _stable && a->_stable);\n+\/\/ These help us avoid implementing meet and join of unrelated type in Type::xmeet\/xjoin. This is\n+\/\/ useful to narrow the scope of this uncommon interaction between unrelated types.\n+const Type* TypeAry::meet_elem(const Type* elem_type1, const Type* elem_type2) {\n+  if (elem_type1 == Type::TOP) {\n+    return elem_type2;\n+  } else if (elem_type2 == Type::TOP) {\n+    return elem_type1;\n@@ -2296,2 +2304,2 @@\n-  case Top:\n-    break;\n+  if (elem_type1 == Type::BOTTOM || elem_type2 == Type::BOTTOM) {\n+    return Type::BOTTOM;\n@@ -2299,1 +2307,6 @@\n-  return this;                  \/\/ Return the double constant\n+  BasicType bt1 = elem_type1->basic_type();\n+  BasicType bt2 = elem_type2->basic_type();\n+  if (bt1 == bt2 || (!is_java_primitive(bt1) && !is_java_primitive(bt2))) {\n+    return elem_type1->meet_speculative(elem_type2);\n+  }\n+  return Type::BOTTOM;\n@@ -2302,6 +2315,15 @@\n-\/\/------------------------------xdual------------------------------------------\n-\/\/ Dual: compute field-by-field dual\n-const Type *TypeAry::xdual() const {\n-  const TypeInt* size_dual = _size->dual()->is_int();\n-  size_dual = normalize_array_size(size_dual);\n-  return new TypeAry(_elem->dual(), size_dual, !_stable);\n+const Type* TypeAry::join_elem(const Type* elem_type1, const Type* elem_type2) {\n+  if (elem_type1 == Type::BOTTOM) {\n+    return elem_type2;\n+  } else if (elem_type2 == Type::BOTTOM) {\n+    return elem_type1;\n+  }\n+  if (elem_type1 == Type::TOP || elem_type2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  BasicType bt1 = elem_type1->basic_type();\n+  BasicType bt2 = elem_type2->basic_type();\n+  if (bt1 == bt2 || (is_reference_type(bt1, true) && is_reference_type(bt2, true))) {\n+    return elem_type1->join_speculative(elem_type2);\n+  }\n+  return Type::TOP;\n@@ -2453,42 +2475,0 @@\n-\/\/------------------------------meet-------------------------------------------\n-\/\/ Compute the MEET of two types. Since each TypeVect is the only instance of\n-\/\/ its species, meeting often returns itself\n-const Type* TypeVect::xmeet(const Type* t) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if (this == t) {\n-    return this;\n-  }\n-\n-  \/\/ Current \"this->_base\" is Vector\n-  switch (t->base()) {          \/\/ switch on original type\n-\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return t;\n-\n-  default:                      \/\/ All else is a mistake\n-    typerr(t);\n-  case VectorMask:\n-  case VectorA:\n-  case VectorS:\n-  case VectorD:\n-  case VectorX:\n-  case VectorY:\n-  case VectorZ: {                \/\/ Meeting 2 vectors?\n-    const TypeVect* v = t->is_vect();\n-    assert(base() == v->base(), \"\");\n-    assert(length() == v->length(), \"\");\n-    assert(element_basic_type() == v->element_basic_type(), \"\");\n-    return this;\n-  }\n-  case Top:\n-    break;\n-  }\n-  return this;\n-}\n-\n-\/\/------------------------------xdual------------------------------------------\n-\/\/ Since each TypeVect is the only instance of its species, it is self-dual\n-const Type* TypeVect::xdual() const {\n-  return this;\n-}\n-\n@@ -2611,3 +2591,4 @@\n-const Type *TypePtr::xmeet_helper(const Type *t) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n+const Type* TypePtr::xmeet_helper(const Type* t) const {\n+  if (base() != AnyPtr) {\n+    typerr(t);\n+  }\n@@ -2615,19 +2596,21 @@\n-  \/\/ Current \"this->_base\" is AnyPtr\n-  switch (t->base()) {          \/\/ switch on original type\n-  case Int:                     \/\/ Mixing ints & oops happens when javac\n-  case Long:                    \/\/ reuses local variables\n-  case HalfFloatTop:\n-  case HalfFloatCon:\n-  case HalfFloatBot:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case NarrowOop:\n-  case NarrowKlass:\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-  case Top:\n-    return this;\n+  switch (t->base()) {\n+    case AnyPtr: {\n+      const TypePtr* tp = t->is_ptr();\n+      const TypePtr* speculative = xmeet_speculative(tp);\n+      int depth = meet_inline_depth(tp->inline_depth());\n+      return make(AnyPtr, meet_ptr(tp->ptr()), meet_offset(tp->offset()), speculative, depth);\n+    }\n+    case RawPtr:\n+    case OopPtr:\n+    case InstPtr:\n+    case AryPtr:\n+    case MetadataPtr:\n+    case KlassPtr:\n+    case InstKlassPtr:\n+    case AryKlassPtr:\n+      \/\/ Call in reverse direction\n+      return t->is_ptr()->xmeet(this);\n+    default:\n+      typerr(t);\n+  }\n+}\n@@ -2635,5 +2618,4 @@\n-  case AnyPtr: {                \/\/ Meeting to AnyPtrs\n-    const TypePtr *tp = t->is_ptr();\n-    const TypePtr* speculative = xmeet_speculative(tp);\n-    int depth = meet_inline_depth(tp->inline_depth());\n-    return make(AnyPtr, meet_ptr(tp->ptr()), meet_offset(tp->offset()), speculative, depth);\n+const Type* TypePtr::xjoin(const Type* t) const {\n+  const Type* res = xjoin_helper(t);\n+  if (res->isa_ptr() == nullptr) {\n+    return res;\n@@ -2641,10 +2623,19 @@\n-  case RawPtr:                  \/\/ For these, flip the call around to cut down\n-  case OopPtr:\n-  case InstPtr:                 \/\/ on the cases I have to handle.\n-  case AryPtr:\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-    return t->xmeet(this);      \/\/ Call in reverse direction\n-  default:                      \/\/ All else is a mistake\n+\n+  const TypePtr* res_ptr = res->is_ptr();\n+  if (res_ptr->speculative() != nullptr) {\n+    \/\/ type->speculative() is null means that speculation is no better\n+    \/\/ than type, i.e. type->speculative() == type. So there are 2\n+    \/\/ ways to represent the fact that we have no useful speculative\n+    \/\/ data and we should use a single one to be able to test for\n+    \/\/ equality between types. Check whether type->speculative() ==\n+    \/\/ type and set speculative to null if it is the case.\n+    if (res_ptr->remove_speculative() == res_ptr->speculative()) {\n+      return res_ptr->remove_speculative();\n+    }\n+  }\n+\n+  return res;\n+}\n+\n+const Type* TypePtr::xjoin_helper(const Type* t) const {\n+  if (base() != AnyPtr) {\n@@ -2652,0 +2643,1 @@\n+  }\n@@ -2653,0 +2645,19 @@\n+  switch (t->base()) {\n+    case AnyPtr: {\n+      const TypePtr* tp = t->is_ptr();\n+      const TypePtr* speculative = xjoin_speculative(tp);\n+      int depth = join_inline_depth(tp->inline_depth());\n+      return make(AnyPtr, join_ptr(tp->ptr()), join_offset(tp->offset()), speculative, depth);\n+    }\n+    case RawPtr:\n+    case OopPtr:\n+    case InstPtr:\n+    case AryPtr:\n+    case MetadataPtr:\n+    case KlassPtr:\n+    case InstKlassPtr:\n+    case AryKlassPtr:\n+      \/\/ Call in reverse direction\n+      return t->is_ptr()->xjoin(this);\n+    default:\n+      typerr(t);\n@@ -2654,1 +2665,0 @@\n-  return this;\n@@ -2667,5 +2677,11 @@\n-\/\/------------------------------dual_offset------------------------------------\n-int TypePtr::dual_offset( ) const {\n-  if( _offset == OffsetTop ) return OffsetBot;\/\/ Map 'TOP' into 'BOTTOM'\n-  if( _offset == OffsetBot ) return OffsetTop;\/\/ Map 'BOTTOM' into 'TOP'\n-  return _offset;               \/\/ Map everything else into self\n+int TypePtr::join_offset(int o) const {\n+  if (_offset == OffsetBot) {\n+    return o;\n+  } else if (o == OffsetBot) {\n+    return _offset;\n+  }\n+  if (_offset != o) {\n+    return OffsetTop;\n+  } else {\n+    return _offset;\n+  }\n@@ -2679,3 +2695,0 @@\n-const Type *TypePtr::xdual() const {\n-  return new TypePtr(AnyPtr, dual_ptr(), dual_offset(), dual_speculative(), dual_inline_depth());\n-}\n@@ -2760,10 +2773,0 @@\n-\/**\n- * dual of the speculative part of the type\n- *\/\n-const TypePtr* TypePtr::dual_speculative() const {\n-  if (_speculative == nullptr) {\n-    return nullptr;\n-  }\n-  return _speculative->dual()->is_ptr();\n-}\n-\n@@ -2803,5 +2806,26 @@\n-\/**\n- * dual of the inline depth for this type (used for speculation)\n- *\/\n-int TypePtr::dual_inline_depth() const {\n-  return -inline_depth();\n+const TypePtr* TypePtr::xjoin_speculative(const TypePtr* other) const {\n+  bool this_has_spec = (_speculative != nullptr);\n+  bool other_has_spec = (other->speculative() != nullptr);\n+\n+  if (!this_has_spec && !other_has_spec) {\n+    return nullptr;\n+  }\n+\n+  \/\/ If we are at a point where control flow meets and one branch has\n+  \/\/ a speculative type and the other has not, we join the speculative\n+  \/\/ type of one branch with the actual type of the other. If the\n+  \/\/ actual type is exact and the speculative is as well, then the\n+  \/\/ result is a speculative type which is exact and we can continue\n+  \/\/ speculation further.\n+  const TypePtr* this_spec = _speculative;\n+  const TypePtr* other_spec = other->speculative();\n+\n+  if (!this_has_spec) {\n+    this_spec = this;\n+  }\n+\n+  if (!other_has_spec) {\n+    other_spec = other;\n+  }\n+\n+  return this_spec->join(other_spec)->is_ptr();\n@@ -2819,0 +2843,4 @@\n+int TypePtr::join_inline_depth(int depth) const {\n+  return MIN2(inline_depth(), depth);\n+}\n+\n@@ -3062,4 +3090,1 @@\n-const Type *TypeRawPtr::xmeet( const Type *t ) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n-\n+const Type* TypeRawPtr::xmeet(const Type* t) const {\n@@ -3067,6 +3092,2 @@\n-  switch( t->base() ) {         \/\/ switch on original type\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return t;\n-  case Top:\n-    return this;\n-  case AnyPtr:                  \/\/ Meeting to AnyPtrs\n+  switch (t->base()) {\n+  case AnyPtr:\n@@ -3074,1 +3095,1 @@\n-  case RawPtr: {                \/\/ might be top, bot, any\/not or constant\n+  case RawPtr: {\n@@ -3077,1 +3098,2 @@\n-    if( ptr == Constant ) {     \/\/ Cannot be equal constants, so...\n+    if( ptr == Constant ) {\n+      \/\/ Same constant cases have been handled in Type::xmeet(const Type*, const Type*)\n@@ -3085,8 +3107,0 @@\n-  case OopPtr:\n-  case InstPtr:\n-  case AryPtr:\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-    return TypePtr::BOTTOM;     \/\/ Oop meet raw is not well defined\n@@ -3114,4 +3128,42 @@\n-\/\/------------------------------xdual------------------------------------------\n-\/\/ Dual: compute field-by-field dual\n-const Type *TypeRawPtr::xdual() const {\n-  return new TypeRawPtr( dual_ptr(), _bits );\n+const Type* TypeRawPtr::xjoin(const Type* t) const {\n+  \/\/ Current \"this->_base\" is RawPtr\n+  switch (t->base()) {\n+    case AnyPtr: {\n+      const TypePtr* tp = t->is_ptr();\n+      PTR ptr = join_ptr(tp->ptr());\n+      switch (tp->ptr()) {\n+        case TopPTR:\n+        case Null:\n+          return TypePtr::make(AnyPtr, ptr, tp->offset(), tp->speculative(), tp->inline_depth());\n+        case NotNull:\n+        case BotPTR:\n+          return this->ptr() == Constant ? this : make(ptr);\n+        default:\n+          typerr(t);\n+      }\n+    }\n+\n+    case RawPtr: {\n+      const TypeRawPtr* tp = t->is_rawptr();\n+      enum PTR ptr = join_ptr(tp->ptr());\n+      \/\/ this->ptr() can only be Constant, NotNull, BotPTR\n+      if (ptr != Constant) {\n+        \/\/ Neither is a constant\n+        return make(ptr);\n+      }\n+\n+      \/\/ At least 1 is a constant\n+      if (this->ptr() == Constant && tp->ptr() == Constant) {\n+        assert(this->_bits != tp->_bits, \"should have been handled in Type::xjoin\");\n+        return TypePtr::make(AnyPtr, TopPTR, 0);\n+      } else if (this->ptr() == Constant) {\n+        return this;\n+      } else {\n+        assert(tp->ptr() == Constant, \"\");\n+        return tp;\n+      }\n+    }\n+\n+    default:\n+      typerr(t);\n+  }\n@@ -3255,4 +3307,0 @@\n-const Type* TypeInterfaces::xdual() const {\n-  return this;\n-}\n-\n@@ -3414,6 +3462,0 @@\n-\/\/ Can't be implemented because there's no way to know if the type is above or below the center line.\n-const Type* TypeInterfaces::xmeet(const Type* t) const {\n-  ShouldNotReachHere();\n-  return Type::xmeet(t);\n-}\n-\n@@ -3558,26 +3600,2 @@\n-const Type *TypeOopPtr::xmeet_helper(const Type *t) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n-\n-  \/\/ Current \"this->_base\" is OopPtr\n-  switch (t->base()) {          \/\/ switch on original type\n-\n-  case Int:                     \/\/ Mixing ints & oops happens when javac\n-  case Long:                    \/\/ reuses local variables\n-  case HalfFloatTop:\n-  case HalfFloatCon:\n-  case HalfFloatBot:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case NarrowOop:\n-  case NarrowKlass:\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-  case Top:\n-    return this;\n-\n-  default:                      \/\/ All else is a mistake\n+const Type* TypeOopPtr::xmeet_helper(const Type *t) const {\n+  if (base() != OopPtr) {\n@@ -3585,8 +3603,2 @@\n-\n-  case RawPtr:\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-    return TypePtr::BOTTOM;     \/\/ Oop meet raw is not well defined\n-\n+  }\n+  switch (t->base()) {          \/\/ switch on original type\n@@ -3626,1 +3638,1 @@\n-    return t->xmeet(this);      \/\/ Call in reverse direction\n+    return t->is_oopptr()->xmeet_helper(this);      \/\/ Call in reverse direction\n@@ -3628,2 +3640,3 @@\n-  } \/\/ End of switch\n-  return this;                  \/\/ Return the double constant\n+  default:\n+    typerr(t);\n+  }\n@@ -3632,0 +3645,4 @@\n+const Type* TypeOopPtr::xjoin_helper(const Type* t) const {\n+  if (base() != OopPtr) {\n+    typerr(t);\n+  }\n@@ -3633,6 +3650,36 @@\n-\/\/------------------------------xdual------------------------------------------\n-\/\/ Dual of a pure heap pointer.  No relevant klass or oop information.\n-const Type *TypeOopPtr::xdual() const {\n-  assert(klass() == Compile::current()->env()->Object_klass(), \"no klasses here\");\n-  assert(const_oop() == nullptr,             \"no constants here\");\n-  return new TypeOopPtr(_base, dual_ptr(), klass(), _interfaces, klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n+  switch (t->base()) {\n+    case AnyPtr: {\n+      const TypePtr* tp = t->is_ptr();\n+      int offset = join_offset(tp->offset());\n+      PTR ptr = join_ptr(tp->ptr());\n+      const TypePtr* speculative = xjoin_speculative(tp);\n+      int depth = join_inline_depth(tp->inline_depth());\n+      switch (tp->ptr()) {\n+        case Null:\n+        case TopPTR:\n+          return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);\n+        case BotPTR:\n+        case NotNull: {\n+          int instance_id = join_instance_id(InstanceBot);\n+          return make(ptr, offset, instance_id, speculative, depth);\n+        }\n+        default:\n+          typerr(t);\n+      }\n+    }\n+\n+    case OopPtr: {\n+      const TypeOopPtr* tp = t->is_oopptr();\n+      int instance_id = join_instance_id(tp->instance_id());\n+      const TypePtr* speculative = xjoin_speculative(tp);\n+      int depth = join_inline_depth(tp->inline_depth());\n+      return make(join_ptr(tp->ptr()), join_offset(tp->offset()), instance_id, speculative, depth);\n+    }\n+\n+    case InstPtr:\n+    case AryPtr:\n+      return t->is_oopptr()->xjoin_helper(this);\n+\n+    default:\n+      typerr(t);\n+  }\n@@ -3893,5 +3940,11 @@\n-\/\/------------------------------dual_instance_id--------------------------------\n-int TypeOopPtr::dual_instance_id( ) const {\n-  if( _instance_id == InstanceTop ) return InstanceBot; \/\/ Map TOP into BOTTOM\n-  if( _instance_id == InstanceBot ) return InstanceTop; \/\/ Map BOTTOM into TOP\n-  return _instance_id;              \/\/ Map everything else into self\n+int TypeOopPtr::join_instance_id(int uid) const {\n+  if (_instance_id == InstanceBot) {\n+    return uid;\n+  } else if (uid == InstanceBot) {\n+    return _instance_id;\n+  }\n+  if (_instance_id != uid) {\n+    return InstanceTop;\n+  } else {\n+    return _instance_id;\n+  }\n@@ -3900,1 +3953,0 @@\n-\n@@ -3902,6 +3954,9 @@\n-  if (above_centerline(_ptr) && above_centerline(other->_ptr)) {\n-    return _interfaces->union_with(other->_interfaces);\n-  } else if (above_centerline(_ptr) && !above_centerline(other->_ptr)) {\n-    return other->_interfaces;\n-  } else if (above_centerline(other->_ptr) && !above_centerline(_ptr)) {\n-    return _interfaces;\n+  if (above_centerline(ptr()) || above_centerline(other->ptr())) {\n+    typerr(other);\n+  }\n+  return interfaces()->intersection_with(other->interfaces());\n+}\n+\n+const TypeInterfaces* TypeOopPtr::join_interfaces(const TypeOopPtr* other) const {\n+  if (above_centerline(ptr()) || above_centerline(other->ptr())) {\n+    typerr(other);\n@@ -3909,1 +3964,1 @@\n-  return _interfaces->intersection_with(other->_interfaces);\n+  return interfaces()->union_with(other->interfaces());\n@@ -4127,4 +4182,1 @@\n-const Type *TypeInstPtr::xmeet_helper(const Type *t) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n-\n+const Type* TypeInstPtr::xmeet_helper(const Type* t) const {\n@@ -4133,19 +4185,0 @@\n-\n-  case Int:                     \/\/ Mixing ints & oops happens when javac\n-  case Long:                    \/\/ reuses local variables\n-  case HalfFloatTop:\n-  case HalfFloatCon:\n-  case HalfFloatBot:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case NarrowOop:\n-  case NarrowKlass:\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-  case Top:\n-    return this;\n-\n@@ -4155,6 +4188,0 @@\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-  case RawPtr: return TypePtr::BOTTOM;\n-\n@@ -4296,1 +4323,0 @@\n-  return this;                  \/\/ Return the double constant\n@@ -4393,1 +4419,36 @@\n-  interfaces = this_interfaces->intersection_with(other_interfaces);\n+  interfaces = this_interfaces->intersection_with(other_interfaces);\n+\n+  \/\/ Now we find the LCA of Java classes\n+  ciKlass* k = this_klass->least_common_ancestor(other_klass);\n+\n+  res_klass = k;\n+  res_xk = false;\n+\n+  return LCA;\n+}\n+\n+const Type* TypeInstPtr::xjoin_helper(const Type* t) const {\n+  if (base() != InstPtr) {\n+    typerr(t);\n+  }\n+\n+  switch (t->base()) {\n+    case AnyPtr: {\n+      const TypePtr* tp = t->is_ptr();\n+      PTR ptr = join_ptr(tp->ptr());\n+      int offset = join_offset(tp->offset());\n+      const TypePtr* speculative = xjoin_speculative(tp);\n+      int depth = join_inline_depth(tp->inline_depth());\n+      switch (tp->ptr()) {\n+        case TopPTR:\n+        case Null:\n+          return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);\n+        case NotNull:\n+        case BotPTR: {\n+          int instance_id = join_instance_id(InstanceBot);\n+          return make(ptr, klass(), interfaces(), klass_is_exact(), const_oop(), offset, instance_id, speculative, depth);\n+        }\n+        default:\n+          typerr(t);\n+      }\n+    }\n@@ -4395,2 +4456,15 @@\n-  \/\/ Now we find the LCA of Java classes\n-  ciKlass* k = this_klass->least_common_ancestor(other_klass);\n+    case OopPtr: {\n+      const TypeOopPtr* tp = t->is_oopptr();\n+      PTR ptr = join_ptr(tp->ptr());\n+      int offset = join_offset(tp->offset());\n+      int instance_id = join_instance_id(tp->instance_id());\n+      const TypePtr* speculative = xjoin_speculative(tp);\n+      int depth = join_inline_depth(tp->inline_depth());\n+      switch (tp->ptr()) {\n+        case NotNull:\n+        case BotPTR:\n+          return make(ptr, klass(), interfaces(), klass_is_exact(), const_oop(), offset, instance_id, speculative, depth);\n+        default:\n+          typerr(t);\n+      }\n+    }\n@@ -4398,2 +4472,17 @@\n-  res_klass = k;\n-  res_xk = false;\n+    case InstPtr: {\n+      const TypeInstPtr* tp = t->is_instptr();\n+      PTR ptr = join_ptr(tp->ptr());\n+      int offset = join_offset(tp->offset());\n+      int instance_id = join_instance_id(tp->instance_id());\n+      const TypePtr* speculative = xjoin_speculative(tp);\n+      int depth = join_inline_depth(tp->inline_depth());\n+      const TypeInterfaces* interfaces = join_interfaces(tp);\n+\n+      \/\/ Join 2 constants\n+      if (const_oop() != nullptr && tp->const_oop() != nullptr) {\n+        if (const_oop() != tp->const_oop()) {\n+          return TypePtr::make(AnyPtr, TopPTR, offset, speculative, depth);\n+        } else {\n+          return make(Constant, klass(), interfaces, true, const_oop(), offset, instance_id, speculative, depth);\n+        }\n+      }\n@@ -4401,1 +4490,70 @@\n-  return LCA;\n+      \/\/ From here, at least one of the operand is not constant\n+      ciObject* oop = const_oop() != nullptr ? const_oop() : tp->const_oop();\n+      \/\/ For TypeInstPtr, klass() must return a non-null ciInstanceKlass\n+      ciInstanceKlass* klass1 = instance_klass();\n+      ciInstanceKlass* klass2 = tp->instance_klass();\n+      bool xk1 = klass_is_exact();\n+      bool xk2 = tp->klass_is_exact();\n+\n+      if (xk1 && xk2) {\n+        if (exact_klass() == tp->exact_klass()) {\n+          return make(ptr, klass1, interfaces, true, oop, offset, instance_id, speculative, depth);\n+        } else {\n+          return TypePtr::make(AnyPtr, ptr == BotPTR ? Null : TopPTR, offset, speculative, depth);\n+        }\n+      } else if (xk1) {\n+        assert(klass1->is_loaded(), \"pointer to an exact type must be loaded\");\n+        \/\/ We can have a TypeInstPtr of an exact interface. In that case, klass() is Object and\n+        \/\/ interfaces() will be not empty. Very confusing.\n+        if ((klass1->is_java_lang_Object() && klass2->is_java_lang_Object() && this->interfaces() == interfaces) ||\n+            (klass2->is_loaded() && klass1->is_subtype_of(klass2) && interfaces->eq(klass1))) {\n+          \/\/ Supertypes of a loaded class should also be loaded\n+          return make(ptr, klass1, interfaces, true, oop, offset, instance_id, speculative, depth);\n+        } else {\n+          return TypePtr::make(AnyPtr, ptr == BotPTR ? Null : TopPTR, offset, speculative, depth);\n+        }\n+      } else if (xk2) {\n+        assert(klass2->is_loaded(), \"pointer to an exact type must be loaded\");\n+        if ((klass2->is_java_lang_Object() && klass1->is_java_lang_Object() && tp->interfaces() == interfaces) ||\n+            (klass1->is_loaded() && klass2->is_subtype_of(klass1) && interfaces->eq(klass2))) {\n+          return make(ptr, klass2, interfaces, true, oop, offset, instance_id, speculative, depth);\n+        } else {\n+          return TypePtr::make(AnyPtr, ptr == BotPTR ? Null : TopPTR, offset, speculative, depth);\n+        }\n+      }\n+\n+      if (!klass1->is_loaded() || !klass2->is_loaded()) {\n+        if (klass1->is_java_lang_Object()) {\n+          \/\/ Everything subtypes object, so the join would return the other type regardless\n+          return make(ptr, klass2, interfaces, false, oop, offset, instance_id, speculative, depth);\n+        } else if (klass2->is_java_lang_Object()) {\n+          return make(ptr, klass1, interfaces, false, oop, offset, instance_id, speculative, depth);\n+        } else if (klass1 == klass2) {\n+          return make(ptr, klass1, interfaces, false, oop, offset, instance_id, speculative, depth);\n+        } else {\n+          \/\/ The current behavior is saying that no non-null instance satisfy this join, this seems\n+          \/\/ only correct if we recompile when the unloaded classes get loaded\n+          return TypePtr::make(AnyPtr, ptr == BotPTR ? Null : TopPTR, offset, speculative, depth);\n+        }\n+      }\n+\n+      \/\/ There is no opposite of LCA, there exists a non-null object o subtyping both A and B iff A\n+      \/\/ is a subtype of B or B is a subtype of A\n+      assert(oop == nullptr, \"const oop should have exact klass\");\n+      ciKlass* res_klass;\n+      if (klass1->is_subtype_of(klass2)) {\n+        res_klass = klass1;\n+      } else if (klass2->is_subtype_of(klass1)) {\n+        res_klass = klass2;\n+      } else {\n+        return TypePtr::make(AnyPtr, ptr == BotPTR ? Null : TopPTR, offset, speculative, depth);\n+      }\n+\n+      return make(ptr, res_klass, interfaces, false, nullptr, offset, instance_id, speculative, depth);\n+    }\n+\n+    case AryPtr:\n+      return t->is_oopptr()->xjoin_helper(this);\n+    default:\n+      typerr(t);\n+  }\n@@ -4415,8 +4573,0 @@\n-\n-\/\/------------------------------xdual------------------------------------------\n-\/\/ Dual: do NOT dual on klasses.  This means I do NOT understand the Java\n-\/\/ inheritance mechanism.\n-const Type *TypeInstPtr::xdual() const {\n-  return new TypeInstPtr(dual_ptr(), klass(), _interfaces, klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n-}\n-\n@@ -4810,2 +4960,3 @@\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n+  if (base() != AryPtr) {\n+    typerr(t);\n+  }\n@@ -4814,20 +4965,0 @@\n-\n-  \/\/ Mixing ints & oops happens when javac reuses local variables\n-  case Int:\n-  case Long:\n-  case HalfFloatTop:\n-  case HalfFloatCon:\n-  case HalfFloatBot:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case NarrowOop:\n-  case NarrowKlass:\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-  case Top:\n-    return this;\n-\n@@ -4856,1 +4987,2 @@\n-    default: ShouldNotReachHere();\n+    default:\n+      typerr(t);\n@@ -4885,6 +5017,0 @@\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-  case RawPtr: return TypePtr::BOTTOM;\n-\n@@ -4987,1 +5113,0 @@\n-  return this;                  \/\/ Lint noise\n@@ -5084,0 +5209,25 @@\n+const Type* TypeAryPtr::xjoin_helper(const Type* t) const {\n+  if (base() != AryPtr) {\n+    typerr(t);\n+  }\n+\n+  switch (t->base()) {\n+    case AnyPtr: {\n+      const TypePtr* tp = t->is_ptr();\n+      PTR ptr = join_ptr(tp->ptr());\n+      int offset = join_offset(tp->offset());\n+      const TypePtr* speculative = xjoin_speculative(tp);\n+      int depth = join_inline_depth(tp->inline_depth());\n+      switch (tp->ptr()) {\n+        case TopPTR:\n+        case Null:\n+          return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);\n+        case NotNull:\n+        case BotPTR: {\n+          int instance_id = join_instance_id(InstanceBot);\n+          return make(ptr, const_oop(), _ary, klass(), klass_is_exact(), offset, instance_id, speculative, depth, is_autobox_cache());\n+        }\n+        default:\n+          typerr(t);\n+      }\n+    }\n@@ -5085,4 +5235,105 @@\n-\/\/------------------------------xdual------------------------------------------\n-\/\/ Dual: compute field-by-field dual\n-const Type *TypeAryPtr::xdual() const {\n-  return new TypeAryPtr(dual_ptr(), _const_oop, _ary->dual()->is_ary(),_klass, _klass_is_exact, dual_offset(), dual_instance_id(), is_autobox_cache(), dual_speculative(), dual_inline_depth());\n+    case OopPtr: {\n+      const TypeOopPtr* tp = t->is_oopptr();\n+      PTR ptr = join_ptr(tp->ptr());\n+      int offset = join_offset(tp->offset());\n+      int instance_id = join_instance_id(tp->instance_id());\n+      const TypePtr* speculative = xjoin_speculative(tp);\n+      int depth = join_inline_depth(tp->inline_depth());\n+      switch (tp->ptr()) {\n+        case NotNull:\n+        case BotPTR:\n+          return make(ptr, const_oop(), _ary, klass(), klass_is_exact(), offset, instance_id, speculative, depth, is_autobox_cache());\n+        default:\n+          typerr(t);\n+      }\n+    }\n+\n+    case InstPtr: {\n+      const TypeInstPtr* tp = t->is_instptr();\n+      PTR ptr = join_ptr(tp->ptr());\n+      int offset = join_offset(tp->offset());\n+      int instance_id = join_instance_id(tp->instance_id());\n+      const TypePtr* speculative = xjoin_speculative(tp);\n+      int depth = join_inline_depth(tp->inline_depth());\n+      if (tp->klass()->is_java_lang_Object() && !tp->klass_is_exact() && _array_interfaces->contains(tp->interfaces())) {\n+        return make(ptr, const_oop(), _ary, klass(), klass_is_exact(), offset, instance_id, speculative, depth, is_autobox_cache());\n+      } else {\n+        return TypePtr::make(AnyPtr, ptr == BotPTR ? Null : TopPTR, offset, speculative, depth);\n+      }\n+    }\n+\n+    case AryPtr: {\n+      const TypeAryPtr* tp = t->is_aryptr();\n+      PTR ptr = join_ptr(tp->ptr());\n+      int offset = join_offset(tp->offset());\n+      int instance_id = join_instance_id(tp->instance_id());\n+      const TypePtr* speculative = xjoin_speculative(tp);\n+      int depth = join_inline_depth(tp->inline_depth());\n+\n+      \/\/ Join of 2 constants\n+      if (const_oop() != nullptr && tp->const_oop() != nullptr) {\n+        if (const_oop() == tp->const_oop()) {\n+          return make(ptr, const_oop(), _ary, klass(), true, offset, instance_id, speculative, depth);\n+        } else {\n+          return TypePtr::make(AnyPtr, TopPTR, offset, speculative, depth);\n+        }\n+      }\n+\n+      const Type* elem1 = elem();\n+      const Type* elem2 = tp->elem();\n+      const Type* ary_elem = TypeAry::join_elem(elem1, elem2);\n+      if (ary_elem->empty() || (ary_elem->make_ptr() != nullptr && ary_elem->make_ptr()->ptr() == Null)) {\n+        return TypePtr::make(AnyPtr, ptr == BotPTR ? Null : TopPTR, offset, speculative, depth);\n+      }\n+\n+      const TypeInt* ary_size = _ary->_size->join(tp->_ary->_size)->isa_int();\n+      if (ary_size == nullptr) {\n+        return TypePtr::make(AnyPtr, ptr == BotPTR ? Null : TopPTR, offset, speculative, depth);\n+      }\n+\n+      ciObject* oop = const_oop() != nullptr ? const_oop() : tp->const_oop();\n+      const TypeAry* ary = TypeAry::make(ary_elem, ary_size, _ary->_stable || tp->_ary->_stable);\n+      bool xk = this->klass_is_exact() || tp->klass_is_exact();\n+      bool autobox_cache = this->is_autobox_cache() || tp->is_autobox_cache();\n+\n+      if (elem1 == Type::BOTTOM || elem2 == Type::BOTTOM) {\n+        return make(ptr, oop, ary, elem1 == Type::BOTTOM ? tp->klass() : klass(), xk, offset, instance_id, speculative, depth, autobox_cache);\n+      } else if (is_java_primitive(elem1->basic_type()) || is_java_primitive(elem2->basic_type())) {\n+        \/\/ One of the operand is a primitive array\n+        if (elem()->isa_int() && tp->elem()->isa_int()) {\n+          \/\/ Maybe we are joining an int[] and a char[]\n+          if (klass() == tp->klass()) {\n+            return make(ptr, oop, ary, klass(), xk, offset, instance_id, speculative, depth, autobox_cache);\n+          } else {\n+            return TypePtr::make(AnyPtr, ptr == BotPTR ? Null : TopPTR, offset, speculative, depth);\n+          }\n+        }\n+\n+        return make(ptr, oop, ary, nullptr, xk, offset, instance_id, speculative, depth, autobox_cache);\n+      }\n+\n+      const TypeKlassPtr* elem1_klass = elem1->make_ptr()->is_oopptr()->as_klass_type(false);\n+      const TypeKlassPtr* elem2_klass = elem2->make_ptr()->is_oopptr()->as_klass_type(false);\n+      bool xk1 = klass_is_exact();\n+      bool xk2 = tp->klass_is_exact();\n+\n+      if (xk1 && xk2) {\n+        if (elem1_klass != elem2_klass) {\n+          return TypePtr::make(AnyPtr, ptr == BotPTR ? Null : TopPTR, offset, speculative, depth);\n+        }\n+      } else if (xk1) {\n+        if (!elem1_klass->higher_equal(elem2_klass)) {\n+          return TypePtr::make(AnyPtr, ptr == BotPTR ? Null : TopPTR, offset, speculative, depth);\n+        }\n+      } else if (xk2) {\n+        if (!elem2_klass->higher_equal(elem1_klass)) {\n+          return TypePtr::make(AnyPtr, ptr == BotPTR ? Null : TopPTR, offset, speculative, depth);\n+        }\n+      }\n+\n+      return make(ptr, oop, ary, nullptr, xk, offset, instance_id, speculative, depth, autobox_cache);\n+    }\n+\n+    default:\n+      typerr(t);\n+  }\n@@ -5211,6 +5462,0 @@\n-const Type *TypeNarrowPtr::xdual() const {    \/\/ Compute dual right now.\n-  const TypePtr* odual = _ptrtype->dual()->is_ptr();\n-  return make_same_narrowptr(odual);\n-}\n-\n-\n@@ -5236,53 +5481,0 @@\n-\/\/------------------------------xmeet------------------------------------------\n-\/\/ Compute the MEET of two types.  It returns a new Type object.\n-const Type *TypeNarrowPtr::xmeet( const Type *t ) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n-\n-  if (t->base() == base()) {\n-    const Type* result = _ptrtype->xmeet(t->make_ptr());\n-    if (result->isa_ptr()) {\n-      return make_hash_same_narrowptr(result->is_ptr());\n-    }\n-    return result;\n-  }\n-\n-  \/\/ Current \"this->_base\" is NarrowKlass or NarrowOop\n-  switch (t->base()) {          \/\/ switch on original type\n-\n-  case Int:                     \/\/ Mixing ints & oops happens when javac\n-  case Long:                    \/\/ reuses local variables\n-  case HalfFloatTop:\n-  case HalfFloatCon:\n-  case HalfFloatBot:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case AnyPtr:\n-  case RawPtr:\n-  case OopPtr:\n-  case InstPtr:\n-  case AryPtr:\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-  case NarrowOop:\n-  case NarrowKlass:\n-\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-  case Top:\n-    return this;\n-\n-  default:                      \/\/ All else is a mistake\n-    typerr(t);\n-\n-  } \/\/ End of switch\n-\n-  return this;\n-}\n-\n@@ -5405,2 +5597,3 @@\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n+  if (base() != MetadataPtr) {\n+    typerr(t);\n+  }\n@@ -5410,19 +5603,0 @@\n-\n-  case Int:                     \/\/ Mixing ints & oops happens when javac\n-  case Long:                    \/\/ reuses local variables\n-  case HalfFloatTop:\n-  case HalfFloatCon:\n-  case HalfFloatBot:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case NarrowOop:\n-  case NarrowKlass:\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-  case Top:\n-    return this;\n-\n@@ -5452,9 +5626,0 @@\n-  case RawPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-  case OopPtr:\n-  case InstPtr:\n-  case AryPtr:\n-    return TypePtr::BOTTOM;     \/\/ Oop meet raw is not well defined\n-\n@@ -5481,1 +5646,0 @@\n-  return this;                  \/\/ Return the double constant\n@@ -5484,0 +5648,4 @@\n+const Type* TypeMetadataPtr::xjoin(const Type* t) const {\n+  if (base() != MetadataPtr) {\n+    typerr(t);\n+  }\n@@ -5485,4 +5653,36 @@\n-\/\/------------------------------xdual------------------------------------------\n-\/\/ Dual of a pure metadata pointer.\n-const Type *TypeMetadataPtr::xdual() const {\n-  return new TypeMetadataPtr(dual_ptr(), metadata(), dual_offset());\n+  switch (t->base()) {\n+    case AnyPtr: {\n+      const TypePtr* tp = t->is_ptr();\n+      PTR ptr = join_ptr(tp->ptr());\n+      int offset = join_offset(tp->offset());\n+      switch (tp->ptr()) {\n+        case TopPTR:\n+        case Null:\n+          return TypePtr::make(AnyPtr, ptr, offset, tp->speculative(), tp->inline_depth());\n+        case NotNull:\n+        case BotPTR:\n+          return make(ptr, _metadata, offset);\n+        default:\n+          typerr(t);\n+      }\n+    }\n+\n+    case MetadataPtr: {\n+      const TypeMetadataPtr* tp = t->is_metadataptr();\n+      PTR ptr = join_ptr(tp->ptr());\n+      int offset = join_offset(tp->offset());\n+      ciMetadata* metadata = this->metadata();\n+      if (tp->metadata() != nullptr) {\n+        if (metadata == nullptr) {\n+          metadata = tp->metadata();\n+        } else {\n+          return TypePtr::make(AnyPtr, TopPTR, offset);\n+        }\n+      }\n+\n+      return make(ptr, metadata, offset);\n+    }\n+\n+    default:\n+      typerr(t);\n+  }\n@@ -5617,6 +5817,9 @@\n-  if (above_centerline(_ptr) && above_centerline(other->_ptr)) {\n-    return _interfaces->union_with(other->_interfaces);\n-  } else if (above_centerline(_ptr) && !above_centerline(other->_ptr)) {\n-    return other->_interfaces;\n-  } else if (above_centerline(other->_ptr) && !above_centerline(_ptr)) {\n-    return _interfaces;\n+  if (above_centerline(ptr()) || above_centerline(other->ptr())) {\n+    typerr(other);\n+  }\n+  return interfaces()->intersection_with(other->interfaces());\n+}\n+\n+const TypeInterfaces* TypeKlassPtr::join_interfaces(const TypeKlassPtr* other) const {\n+  if (above_centerline(ptr()) || above_centerline(other->ptr())) {\n+    typerr(other);\n@@ -5624,1 +5827,1 @@\n-  return _interfaces->intersection_with(other->_interfaces);\n+  return interfaces()->union_with(other->interfaces());\n@@ -5779,3 +5982,4 @@\n-const Type    *TypeInstKlassPtr::xmeet( const Type *t ) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n+const Type* TypeInstKlassPtr::xmeet(const Type* t) const {\n+  if (base() != InstKlassPtr) {\n+    typerr(t);\n+  }\n@@ -5785,19 +5989,0 @@\n-\n-  case Int:                     \/\/ Mixing ints & oops happens when javac\n-  case Long:                    \/\/ reuses local variables\n-  case HalfFloatTop:\n-  case HalfFloatCon:\n-  case HalfFloatBot:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case NarrowOop:\n-  case NarrowKlass:\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-  case Top:\n-    return this;\n-\n@@ -5826,7 +6011,0 @@\n-  case RawPtr:\n-  case MetadataPtr:\n-  case OopPtr:\n-  case AryPtr:                  \/\/ Meet with AryPtr\n-  case InstPtr:                 \/\/ Meet with InstPtr\n-    return TypePtr::BOTTOM;\n-\n@@ -5924,4 +6102,77 @@\n-\/\/------------------------------xdual------------------------------------------\n-\/\/ Dual: compute field-by-field dual\n-const Type    *TypeInstKlassPtr::xdual() const {\n-  return new TypeInstKlassPtr(dual_ptr(), klass(), _interfaces, dual_offset());\n+const Type* TypeInstKlassPtr::xjoin(const Type* t) const {\n+  if (base() != InstKlassPtr) {\n+    typerr(t);\n+  }\n+\n+  switch (t->base()) {\n+    case AnyPtr: {\n+      const TypePtr* tp = t->is_ptr();\n+      PTR ptr = join_ptr(tp->ptr());\n+      int offset = join_offset(tp->offset());\n+      switch (tp->ptr()) {\n+        case TopPTR:\n+        case Null:\n+          return TypePtr::make(AnyPtr, ptr, offset, tp->speculative(), tp->inline_depth());\n+        case NotNull:\n+        case BotPTR:\n+          return make(ptr, klass(), interfaces(), offset);\n+        default:\n+          typerr(t);\n+      }\n+    }\n+\n+    case InstKlassPtr: {\n+      const TypeInstKlassPtr* tp = t->is_instklassptr();\n+      PTR ptr = join_ptr(tp->ptr());\n+      int offset = join_offset(tp->offset());\n+      const TypeInterfaces* interfaces = join_interfaces(tp);\n+\n+      \/\/ For TypeInstKlassPtr, klass() must return a non-null ciInstanceKlass\n+      ciInstanceKlass* klass1 = instance_klass();\n+      ciInstanceKlass* klass2 = tp->instance_klass();\n+      bool xk1 = klass_is_exact();\n+      bool xk2 = tp->klass_is_exact();\n+      if (xk1 && xk2) {\n+        if (klass1 == klass2) {\n+          return make(ptr, klass1, interfaces, offset);\n+        } else {\n+          return TypePtr::make(AnyPtr, TopPTR, offset);\n+        }\n+      } else if (xk1) {\n+        \/\/ When the exact klass pointer is an interface, the klass() is Object and the interfaces()\n+        \/\/ is not empty\n+        if ((klass1->is_java_lang_Object() && klass2->is_java_lang_Object() && this->interfaces() == interfaces) ||\n+            (klass1->is_subtype_of(klass2) && interfaces->eq(klass1))) {\n+          return make(ptr, klass1, interfaces, offset);\n+        } else {\n+          return TypePtr::make(AnyPtr, TopPTR, offset);\n+        }\n+      } else if (xk2) {\n+        if ((klass2->is_java_lang_Object() && klass1->is_java_lang_Object() && tp->interfaces() == interfaces) ||\n+            (klass2->is_subtype_of(klass1) && interfaces->eq(klass2))) {\n+          return make(ptr, klass2, interfaces, offset);\n+        } else {\n+          return TypePtr::make(AnyPtr, TopPTR, offset);\n+        }\n+      } else {\n+        \/\/ There is no opposite of LCA, there exists a type subtyping both A and B iff A is a\n+        \/\/ subtype of B or B is a subtype of A\n+        ciKlass* subklass;\n+        if (klass1->is_subtype_of(klass2)) {\n+          subklass = klass1;\n+        } else if (klass2->is_subtype_of(klass1)) {\n+          subklass = klass2;\n+        } else {\n+          return TypePtr::make(AnyPtr, ptr == BotPTR ? Null : TopPTR, offset);\n+        }\n+\n+        return make(ptr, subklass, interfaces, offset);\n+      }\n+    }\n+\n+    case AryKlassPtr:\n+      return t->is_aryklassptr()->xjoin(this);\n+\n+    default:\n+      typerr(t);\n+  }\n@@ -6042,1 +6293,5 @@\n-const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, const Type* elem, ciKlass* k, int offset) {\n+const TypeAryKlassPtr* TypeAryKlassPtr::make(PTR ptr, const Type* elem, ciKlass* k, int offset) {\n+  if (ptr == Constant && elem->isa_klassptr()) {\n+    elem = elem->is_klassptr()->cast_to_exactness(true);\n+  }\n+\n@@ -6119,1 +6374,1 @@\n-  if( this != TypeAryPtr::OOPS && this->dual() != TypeAryPtr::OOPS ) {\n+  if (this != TypeAryPtr::OOPS) {\n@@ -6203,1 +6458,1 @@\n-const TypeOopPtr* TypeAryKlassPtr::as_instance_type(bool klass_change) const {\n+const TypeAryPtr* TypeAryKlassPtr::as_instance_type(bool klass_change) const {\n@@ -6219,4 +6474,1 @@\n-const Type    *TypeAryKlassPtr::xmeet( const Type *t ) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n-\n+const Type* TypeAryKlassPtr::xmeet(const Type* t) const {\n@@ -6225,19 +6477,0 @@\n-\n-  case Int:                     \/\/ Mixing ints & oops happens when javac\n-  case Long:                    \/\/ reuses local variables\n-  case HalfFloatTop:\n-  case HalfFloatCon:\n-  case HalfFloatBot:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case NarrowOop:\n-  case NarrowKlass:\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-  case Top:\n-    return this;\n-\n@@ -6266,7 +6499,0 @@\n-  case RawPtr:\n-  case MetadataPtr:\n-  case OopPtr:\n-  case AryPtr:                  \/\/ Meet with AryPtr\n-  case InstPtr:                 \/\/ Meet with InstPtr\n-    return TypePtr::BOTTOM;\n-\n@@ -6292,1 +6518,1 @@\n-    const Type* elem = _elem->meet(tap->_elem);\n+    const Type* elem = TypeAry::meet_elem(_elem, tap->_elem);\n@@ -6354,0 +6580,63 @@\n+const Type* TypeAryKlassPtr::xjoin(const Type* t) const {\n+  if (base() != AryKlassPtr) {\n+    typerr(t);\n+  }\n+\n+  switch (t->base()) {\n+    case AnyPtr: {\n+      const TypePtr* tp = t->is_ptr();\n+      PTR ptr = join_ptr(tp->ptr());\n+      int offset = join_offset(tp->offset());\n+      switch (tp->ptr()) {\n+        case TopPTR:\n+        case Null:\n+          return TypePtr::make(AnyPtr, ptr, offset, tp->speculative(), tp->inline_depth());\n+        case NotNull:\n+        case BotPTR:\n+          return make(ptr, elem(), klass(), offset);\n+        default:\n+          typerr(t);\n+      }\n+    }\n+\n+    case InstKlassPtr: {\n+      const TypeInstKlassPtr* tp = t->is_instklassptr();\n+      PTR ptr = join_ptr(tp->ptr());\n+      int offset = join_offset(tp->offset());\n+\n+      if (tp->klass()->is_java_lang_Object() && !tp->klass_is_exact() && _array_interfaces->contains(tp->interfaces())) {\n+        return make(ptr, elem(), klass(), offset);\n+      } else {\n+        return TypePtr::make(AnyPtr, ptr == BotPTR ? Null : TopPTR, offset);\n+      }\n+    }\n+\n+    case AryKlassPtr: {\n+      const TypeAryKlassPtr* tp = t->is_aryklassptr();\n+      PTR ptr = join_ptr(tp->ptr());\n+      int offset = join_offset(tp->offset());\n+\n+      const Type* elem1 = elem();\n+      const Type* elem2 = tp->elem();\n+      if (elem1->isa_int() && elem2->isa_int()) {\n+        \/\/ There may be cases that we are joining int[] and char[]\n+        if (klass() == tp->klass()) {\n+          return make(ptr, elem1->join(elem2), klass(), offset);\n+        } else {\n+          return TypePtr::make(AnyPtr, ptr == BotPTR ? Null : TopPTR, offset);\n+        }\n+      }\n+\n+      const Type* res_elem = TypeAry::join_elem(elem1, elem2);\n+      if (res_elem->empty() || (res_elem->isa_ptr() && !res_elem->isa_klassptr())) {\n+        return TypePtr::make(AnyPtr, ptr == BotPTR ? Null : TopPTR, offset);\n+      }\n+\n+      return make(ptr, res_elem, nullptr, offset);\n+    }\n+\n+    default:\n+      typerr(t);\n+  }\n+}\n+\n@@ -6472,6 +6761,0 @@\n-\/\/------------------------------xdual------------------------------------------\n-\/\/ Dual: compute field-by-field dual\n-const Type    *TypeAryKlassPtr::xdual() const {\n-  return new TypeAryKlassPtr(dual_ptr(), elem()->dual(), klass(), dual_offset());\n-}\n-\n@@ -6578,27 +6861,0 @@\n-\/\/------------------------------meet-------------------------------------------\n-\/\/ Compute the MEET of two types.  It returns a new Type object.\n-const Type *TypeFunc::xmeet( const Type *t ) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n-\n-  \/\/ Current \"this->_base\" is Func\n-  switch (t->base()) {          \/\/ switch on original type\n-\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return t;\n-\n-  default:                      \/\/ All else is a mistake\n-    typerr(t);\n-\n-  case Top:\n-    break;\n-  }\n-  return this;                  \/\/ Return the double constant\n-}\n-\n-\/\/------------------------------xdual------------------------------------------\n-\/\/ Dual: compute field-by-field dual\n-const Type *TypeFunc::xdual() const {\n-  return this;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":1161,"deletions":905,"binary":false,"changes":2066,"status":"modified"},{"patch":"@@ -177,4 +177,2 @@\n-  \/\/ DUAL operation: reflect around lattice centerline.  Used instead of\n-  \/\/ join to ensure my lattice is symmetric up and down.  Dual is computed\n-  \/\/ lazily, on demand, and cached in _dual.\n-  const Type *_dual;            \/\/ Cached dual value\n+  template <class F>\n+  static const Type* meet_join_helper(F op, const Type* t1, const Type* t2, bool include_speculative);\n@@ -182,0 +180,1 @@\n+  const Type* meet_helper(const Type* t, bool include_speculative) const;\n@@ -183,2 +182,10 @@\n-  const Type *meet_helper(const Type *t, bool include_speculative) const;\n-  void check_symmetrical(const Type* t, const Type* mt, const VerifyMeet& verify) const NOT_DEBUG_RETURN;\n+  static void check_symmetrical(const Type* t1, const Type* t2, VerifyMeet& verify) NOT_DEBUG_RETURN;\n+\n+  static const Type* xmeet(const Type* t1, const Type* t2);\n+  static const Type* xjoin(const Type* t1, const Type* t2);\n+\n+  \/\/ Compute meet dependent on base type\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xjoin(const Type* t) const;\n+\n+friend class VerifyMeetResult;\n@@ -188,10 +195,1 @@\n-  const TYPES _base;            \/\/ Enum of Types type\n-\n-  Type( TYPES t ) : _dual(nullptr),  _base(t) {} \/\/ Simple types\n-  \/\/ ~Type();                   \/\/ Use fast deallocation\n-  const Type *hashcons();       \/\/ Hash-cons the type\n-  virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;\n-  const Type *join_helper(const Type *t, bool include_speculative) const {\n-    assert_type_verify_empty();\n-    return dual()->meet_helper(t->dual(), include_speculative)->dual();\n-  }\n+  const TYPES _base;          \/\/ Enum of Types type\n@@ -199,1 +197,5 @@\n-  void assert_type_verify_empty() const NOT_DEBUG_RETURN;\n+  Type(TYPES t) : _base(t) {} \/\/ Simple types\n+  \/\/ ~Type();                 \/\/ Use fast deallocation\n+  const Type* hashcons();     \/\/ Hash-cons the type\n+  virtual const Type* filter_helper(const Type *kills, bool include_speculative) const;\n+  const Type* join_helper(const Type *t, bool include_speculative) const;\n@@ -238,1 +240,1 @@\n-  \/\/ MEET operation; lower in lattice.\n+  \/\/ MEET operations\n@@ -252,10 +254,1 @@\n-  \/\/ DUAL operation: reflect around lattice centerline.  Used instead of\n-  \/\/ join to ensure my lattice is symmetric up and down.\n-  const Type *dual() const { return _dual; }\n-\n-  \/\/ Compute meet dependent on base type\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n-\n-  \/\/ JOIN operation; higher in lattice.  Done by finding the dual of the\n-  \/\/ meet of the dual of the 2 inputs.\n+  \/\/ JOIN operations\n@@ -272,1 +265,1 @@\n-  \/\/ Normalizes all empty values to TOP.  Does not kill _widen bits.\n+  \/\/ Normalizes all empty values to TOP. Does not kill _widen bits.\n@@ -406,1 +399,1 @@\n-  void typerr(const Type *t) const; \/\/ Mixing types error\n+  [[noreturn]] void typerr(const Type *t) const; \/\/ Mixing types error\n@@ -527,2 +520,2 @@\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xjoin(const Type* t) const;\n@@ -560,1 +553,1 @@\n-  virtual const Type* xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* xjoin(const Type* t) const;\n@@ -590,2 +583,2 @@\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xjoin(const Type* t) const;\n@@ -814,1 +807,1 @@\n-  virtual const Type* xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* xjoin(const Type* t) const;\n@@ -901,1 +894,1 @@\n-  virtual const Type* xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* xjoin(const Type* t) const;\n@@ -962,2 +955,2 @@\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xjoin(const Type* t) const;\n@@ -1002,2 +995,4 @@\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xjoin(const Type* t) const;\n+  static const Type* meet_elem(const Type* elem_type1, const Type* elem_type2);\n+  static const Type* join_elem(const Type* elem_type1, const Type* elem_type2);\n@@ -1037,3 +1032,0 @@\n-  virtual const Type* xmeet( const Type *t) const;\n-  virtual const Type* xdual() const;     \/\/ Compute dual right now.\n-\n@@ -1112,1 +1104,0 @@\n-  const Type *xdual() const;\n@@ -1127,2 +1118,0 @@\n-  const Type* xmeet(const Type* t) const;\n-\n@@ -1150,2 +1139,5 @@\n-    Type(t), _speculative(speculative), _inline_depth(inline_depth), _offset(offset),\n-    _ptr(ptr) {}\n+    Type(t), _speculative(speculative), _inline_depth(inline_depth), _offset(offset), _ptr(ptr) {\n+    assert(t == AnyPtr || (ptr != TopPTR && ptr != Null), \"Top and Null must be AnyPtr\");\n+    assert(ptr != AnyNull, \"Nonsensical PTR\");\n+    assert(static_cast<uint>(ptr) < static_cast<uint>(lastPTR), \"out of bounds\");\n+  }\n@@ -1173,1 +1165,0 @@\n-  const TypePtr* dual_speculative() const;\n@@ -1175,0 +1166,1 @@\n+  const TypePtr* xjoin_speculative(const TypePtr* other) const;\n@@ -1184,1 +1176,0 @@\n-  int dual_inline_depth() const;\n@@ -1186,0 +1177,1 @@\n+  int join_inline_depth(int depth) const;\n@@ -1204,0 +1196,2 @@\n+  template<class T> static MeetResult join_instptr(PTR& ptr, const TypeInterfaces*& interfaces, const T* this_type,\n+                                                   const T* other_type, ciKlass*& res_klass, bool& res_xk);\n@@ -1240,5 +1234,6 @@\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xmeet_helper( const Type *t ) const;\n-  int meet_offset( int offset ) const;\n-  int dual_offset( ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xmeet_helper(const Type* t) const;\n+  virtual const Type* xjoin(const Type* t) const;\n+  virtual const Type* xjoin_helper(const Type* t) const;\n+  int meet_offset(int offset) const;\n+  int join_offset(int offset) const;\n@@ -1246,1 +1241,1 @@\n-  \/\/ meet, dual and join over pointer equivalence sets\n+  \/\/ meet and join over pointer equivalence sets\n@@ -1306,2 +1301,2 @@\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xjoin(const Type* t) const;\n@@ -1356,1 +1351,0 @@\n-  int dual_instance_id() const;\n@@ -1358,0 +1352,1 @@\n+  int join_instance_id(int uid) const;\n@@ -1360,0 +1355,1 @@\n+  const TypeInterfaces* join_interfaces(const TypeOopPtr* other) const;\n@@ -1455,1 +1451,0 @@\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n@@ -1457,1 +1452,2 @@\n-  virtual const Type *xmeet_helper(const Type *t) const;\n+  virtual const Type *xmeet_helper(const Type* t) const;\n+  virtual const Type *xjoin_helper(const Type* t) const;\n@@ -1578,3 +1574,3 @@\n-  virtual const Type *xmeet_helper(const Type *t) const;\n-  virtual const TypeInstPtr *xmeet_unloaded(const TypeInstPtr *tinst, const TypeInterfaces* interfaces) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* xmeet_helper(const Type *t) const;\n+  virtual const TypeInstPtr* xmeet_unloaded(const TypeInstPtr *tinst, const TypeInterfaces* interfaces) const;\n+  virtual const Type* xjoin_helper(const Type *t) const;\n@@ -1691,2 +1687,2 @@\n-  virtual const Type *xmeet_helper(const Type *t) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* xmeet_helper(const Type* t) const;\n+  virtual const Type* xjoin_helper(const Type *t) const;\n@@ -1755,2 +1751,2 @@\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xjoin(const Type* t) const;\n@@ -1789,0 +1785,1 @@\n+  const TypeInterfaces* join_interfaces(const TypeKlassPtr* other) const;\n@@ -1825,3 +1822,3 @@\n-  virtual const TypePtr *add_offset( intptr_t offset ) const { ShouldNotReachHere(); return nullptr; }\n-  virtual const Type    *xmeet( const Type *t ) const { ShouldNotReachHere(); return nullptr; }\n-  virtual const Type    *xdual() const { ShouldNotReachHere(); return nullptr; }\n+  virtual const TypePtr* add_offset(intptr_t offset) const { ShouldNotReachHere(); return nullptr; }\n+  virtual const Type*    xmeet(const Type* t)        const { ShouldNotReachHere(); return nullptr; }\n+  virtual const Type*    xjoin(const Type* t)        const { ShouldNotReachHere(); return nullptr; }\n@@ -1908,2 +1905,2 @@\n-  virtual const Type    *xmeet( const Type *t ) const;\n-  virtual const Type    *xdual() const;\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xjoin(const Type* t) const;\n@@ -1967,1 +1964,1 @@\n-  virtual const TypeOopPtr* as_instance_type(bool klass_change = true) const;\n+  virtual const TypeAryPtr* as_instance_type(bool klass_change = true) const;\n@@ -1969,3 +1966,3 @@\n-  virtual const TypePtr *add_offset( intptr_t offset ) const;\n-  virtual const Type    *xmeet( const Type *t ) const;\n-  virtual const Type    *xdual() const;      \/\/ Compute dual right now.\n+  virtual const TypePtr* add_offset(intptr_t offset) const;\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xjoin(const Type* t) const;\n@@ -2008,3 +2005,0 @@\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n-\n@@ -2142,3 +2136,0 @@\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n-\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":75,"deletions":84,"binary":false,"changes":159,"status":"modified"}]}