{"files":[{"patch":"@@ -696,4 +696,11 @@\n-  return CT::make_or_top(TypeIntPrototype<S, U>{{MIN2(t1->_lo, t2->_lo), MAX2(t1->_hi, t2->_hi)},\n-                                                {MIN2(t1->_ulo, t2->_ulo), MAX2(t1->_uhi, t2->_uhi)},\n-                                                {t1->_bits._zeros & t2->_bits._zeros, t1->_bits._ones & t2->_bits._ones}},\n-                         MAX2(t1->_widen, t2->_widen), false);\n+  if (!t1->_is_dual) {\n+    return CT::make_or_top(TypeIntPrototype<S, U>{{MIN2(t1->_lo, t2->_lo), MAX2(t1->_hi, t2->_hi)},\n+                                                  {MIN2(t1->_ulo, t2->_ulo), MAX2(t1->_uhi, t2->_uhi)},\n+                                                  {t1->_bits._zeros & t2->_bits._zeros, t1->_bits._ones & t2->_bits._ones}},\n+                           MAX2(t1->_widen, t2->_widen), false);\n+  } else {\n+    return CT::make_or_top(TypeIntPrototype<S, U>{{MAX2(t1->_lo, t2->_lo), MIN2(t1->_hi, t2->_hi)},\n+                                                  {MAX2(t1->_ulo, t2->_ulo), MIN2(t1->_uhi, t2->_uhi)},\n+                                                  {t1->_bits._zeros | t2->_bits._zeros, t1->_bits._ones | t2->_bits._ones}},\n+                           MIN2(t1->_widen, t2->_widen), true);\n+  }\n","filename":"src\/hotspot\/share\/opto\/rangeinference.cpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -765,1 +765,1 @@\n-const Type* Type::hashcons() {\n+const Type *Type::hashcons(void) {\n@@ -768,1 +768,1 @@\n-  Dict* tdic = type_dict();\n+  Dict *tdic = type_dict();\n@@ -770,1 +770,16 @@\n-  if (old == nullptr) {\n+  if( old ) {                   \/\/ Pre-existing Type?\n+    if( old != this )           \/\/ Yes, this guy is not the pre-existing?\n+      delete this;              \/\/ Yes, Nuke this guy\n+    assert( old->_dual, \"\" );\n+    return old;                 \/\/ Return pre-existing\n+  }\n+\n+  \/\/ Every type has a dual (to make my lattice symmetric).\n+  \/\/ Since we just discovered a new Type, compute its dual right now.\n+  assert( !_dual, \"\" );         \/\/ No dual yet\n+  _dual = xdual();              \/\/ Compute the dual\n+  if (equals(this, _dual)) {    \/\/ Handle self-symmetric\n+    if (_dual != this) {\n+      delete _dual;\n+      _dual = this;\n+    }\n@@ -773,4 +788,11 @@\n-  if (old != this) {\n-    delete this;\n-  }\n-  return old;\n+  assert( !_dual->_dual, \"\" );  \/\/ No reverse dual yet\n+  assert( !(*tdic)[_dual], \"\" ); \/\/ Dual not in type system either\n+  \/\/ New Type, insert into Type table\n+  tdic->Insert((void*)_dual,(void*)_dual);\n+  ((Type*)_dual)->_dual = this; \/\/ Finish up being symmetric\n+#ifdef ASSERT\n+  Type *dual_dual = (Type*)_dual->xdual();\n+  assert( eq(dual_dual), \"xdual(xdual()) should be identity\" );\n+  delete dual_dual;\n+#endif\n+  return this;                  \/\/ Return new Type\n@@ -849,0 +871,1 @@\n+  bool _is_disable;\n@@ -943,1 +966,1 @@\n-  VerifyMeetResult(Compile* C) : _depth(0),\n+  VerifyMeetResult(Compile* C) : _is_disable(false), _depth(0),\n@@ -975,0 +998,12 @@\n+\n+  bool is_disabled() const {\n+    return _C->_type_verify->_is_disable;\n+  }\n+\n+  void disable() {\n+    _C->_type_verify->_is_disable = true;\n+  }\n+\n+  void enable() {\n+    _C->_type_verify->_is_disable = false;\n+  }\n@@ -977,2 +1012,5 @@\n-void Type::check_symmetrical(const Type* t1, const Type* t2, VerifyMeet& verify) {\n-  Compile* C = Compile::current();\n+void Type::check_fundamental_laws(const Type* t1, const Type* t2, VerifyMeet& verify) {\n+  if (verify.is_disabled()) {\n+    return;\n+  }\n+\n@@ -1001,0 +1039,25 @@\n+  if (t1->isa_ptr() && t1->maybe_null() && t2->isa_ptr() && t2->maybe_null() && jt1->empty()) {\n+    tty->print_cr(\"=== Join of Nullable Pointers Cannot Be Empty ===\");\n+    tty->print(\"t1          = \");  t1->dump(); tty->cr();\n+    tty->print(\"t2          = \");  t2->dump(); tty->cr();\n+    tty->print(\"t1 joins t2 = \"); jt1->dump(); tty->cr();\n+    fatal(\"incorrect join\");\n+  }\n+\n+  \/\/ Do not do Type::check_fundamental_laws since we do not implement join for dual types\n+  verify.disable();\n+  const Type* mdt = verify.meet(t1->dual(), t2->dual())->dual();\n+  verify.enable();\n+\n+  if (jt1->remove_speculative() != mdt->remove_speculative() && (!jt1->empty() || !mdt->empty())) {\n+    bool excluded_case = t1->isa_ptr() && t1->maybe_null() && t2->isa_ptr() && t2->maybe_null() && mdt->empty() && jt1->is_ptr()->ptr() == TypePtr::Null;\n+    if (!excluded_case) {\n+      tty->print_cr(\"=== Join May Be Incorrect ===\");\n+      tty->print(\"t1                                    = \");  t1->dump(); tty->cr();\n+      tty->print(\"t2                                    = \");  t2->dump(); tty->cr();\n+      tty->print(\"t1 joins t2                           = \"); jt1->dump(); tty->cr();\n+      tty->print(\"(t1->dual() meets t2->dual())->dual() = \"); mdt->dump(); tty->cr();\n+      fatal(\"join may be incorrect\");\n+    }\n+  }\n+\n@@ -1030,1 +1093,1 @@\n-    fatal(\"Fundamental Laws Violation\");\n+    fatal(\"fundamental laws violation\");\n@@ -1053,1 +1116,1 @@\n-  check_symmetrical(t1, t2, verify);\n+  check_fundamental_laws(t1, t2, verify);\n@@ -1236,0 +1299,7 @@\n+\/\/------------------------------xdual------------------------------------------\n+const Type *Type::xdual() const {\n+  \/\/ Note: the base() accessor asserts the sanity of _base.\n+  assert(_type_info[base()].dual_type != Bad, \"implement with v-call\");\n+  return new Type(_type_info[_base].dual_type);\n+}\n+\n@@ -1463,0 +1533,6 @@\n+\/\/------------------------------xdual------------------------------------------\n+\/\/ Dual: symmetric\n+const Type *TypeF::xdual() const {\n+  return this;\n+}\n+\n@@ -1561,0 +1637,6 @@\n+\/\/------------------------------xdual------------------------------------------\n+\/\/ Dual: symmetric\n+const Type* TypeH::xdual() const {\n+  return this;\n+}\n+\n@@ -1661,0 +1743,6 @@\n+\/\/------------------------------xdual------------------------------------------\n+\/\/ Dual: symmetric\n+const Type *TypeD::xdual() const {\n+  return this;\n+}\n+\n@@ -1842,0 +1930,5 @@\n+const Type* TypeInt::xdual() const {\n+  return new TypeInt(TypeIntPrototype<jint, juint>{{_lo, _hi}, {_ulo, _uhi}, _bits},\n+                     _widen, !_is_dual);\n+}\n+\n@@ -1975,0 +2068,5 @@\n+const Type* TypeLong::xdual() const {\n+  return new TypeLong(TypeIntPrototype<jlong, julong>{{_lo, _hi}, {_ulo, _uhi}, _bits},\n+                      _widen, !_is_dual);\n+}\n+\n@@ -2193,0 +2291,9 @@\n+\/\/------------------------------xdual------------------------------------------\n+\/\/ Dual: compute field-by-field dual\n+const Type *TypeTuple::xdual() const {\n+  const Type **fields = (const Type **)(Compile::current()->type_arena()->AmallocWords( _cnt*sizeof(Type*) ));\n+  for( uint i=0; i<_cnt; i++ )\n+    fields[i] = _fields[i]->dual();\n+  return new TypeTuple(_cnt,fields);\n+}\n+\n@@ -2279,2 +2386,6 @@\n-  const TypeInt* size = _size->meet(a->_size)->is_int();\n-  return TypeAry::make(meet_elem(_elem, a->_elem), size, _stable && a->_stable);\n+  const Type* size = _size->meet(a->_size);\n+  if (!size->isa_int()) {\n+    assert(size == Type::TOP || size == Type::BOTTOM, \"\");\n+    return size;\n+  }\n+  return TypeAry::make(meet_elem(_elem, a->_elem), size->is_int(), _stable && a->_stable);\n@@ -2290,1 +2401,1 @@\n-  if (elem->empty()) {\n+  if (elem->empty() || (elem->make_ptr() != nullptr && elem->make_ptr()->ptr() == TypePtr::Null)) {\n@@ -2332,0 +2443,8 @@\n+\/\/------------------------------xdual------------------------------------------\n+\/\/ Dual: compute field-by-field dual\n+const Type *TypeAry::xdual() const {\n+  const TypeInt* size_dual = _size->dual()->is_int();\n+  size_dual = normalize_array_size(size_dual);\n+  return new TypeAry(_elem->dual(), size_dual, !_stable);\n+}\n+\n@@ -2475,0 +2594,6 @@\n+\/\/------------------------------xdual------------------------------------------\n+\/\/ Since each TypeVect is the only instance of its species, it is self-dual\n+const Type* TypeVect::xdual() const {\n+  return this;\n+}\n+\n@@ -2690,0 +2815,7 @@\n+\/\/------------------------------dual_offset------------------------------------\n+int TypePtr::dual_offset( ) const {\n+  if( _offset == OffsetTop ) return OffsetBot;\/\/ Map 'TOP' into 'BOTTOM'\n+  if( _offset == OffsetBot ) return OffsetTop;\/\/ Map 'BOTTOM' into 'TOP'\n+  return _offset;               \/\/ Map everything else into self\n+}\n+\n@@ -2695,0 +2827,3 @@\n+const Type *TypePtr::xdual() const {\n+  return new TypePtr(AnyPtr, dual_ptr(), dual_offset(), dual_speculative(), dual_inline_depth());\n+}\n@@ -2773,0 +2908,10 @@\n+\/**\n+ * dual of the speculative part of the type\n+ *\/\n+const TypePtr* TypePtr::dual_speculative() const {\n+  if (_speculative == nullptr) {\n+    return nullptr;\n+  }\n+  return _speculative->dual()->is_ptr();\n+}\n+\n@@ -2834,0 +2979,7 @@\n+\/**\n+ * dual of the inline depth for this type (used for speculation)\n+ *\/\n+int TypePtr::dual_inline_depth() const {\n+  return -inline_depth();\n+}\n+\n@@ -3172,0 +3324,6 @@\n+\/\/------------------------------xdual------------------------------------------\n+\/\/ Dual: compute field-by-field dual\n+const Type *TypeRawPtr::xdual() const {\n+  return new TypeRawPtr( dual_ptr(), _bits );\n+}\n+\n@@ -3307,0 +3465,4 @@\n+const Type* TypeInterfaces::xdual() const {\n+  return this;\n+}\n+\n@@ -3688,0 +3850,8 @@\n+\/\/------------------------------xdual------------------------------------------\n+\/\/ Dual of a pure heap pointer.  No relevant klass or oop information.\n+const Type *TypeOopPtr::xdual() const {\n+  assert(klass() == Compile::current()->env()->Object_klass(), \"no klasses here\");\n+  assert(const_oop() == nullptr,             \"no constants here\");\n+  return new TypeOopPtr(_base, dual_ptr(), klass(), _interfaces, klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n+}\n+\n@@ -3953,0 +4123,7 @@\n+\/\/------------------------------dual_instance_id--------------------------------\n+int TypeOopPtr::dual_instance_id( ) const {\n+  if( _instance_id == InstanceTop ) return InstanceBot; \/\/ Map TOP into BOTTOM\n+  if( _instance_id == InstanceBot ) return InstanceTop; \/\/ Map BOTTOM into TOP\n+  return _instance_id;              \/\/ Map everything else into self\n+}\n+\n@@ -3954,2 +4131,6 @@\n-  if (above_centerline(ptr()) || above_centerline(other->ptr())) {\n-    typerr(other);\n+  if (above_centerline(_ptr) && above_centerline(other->_ptr)) {\n+    return _interfaces->union_with(other->_interfaces);\n+  } else if (above_centerline(_ptr) && !above_centerline(other->_ptr)) {\n+    return other->_interfaces;\n+  } else if (above_centerline(other->_ptr) && !above_centerline(_ptr)) {\n+    return _interfaces;\n@@ -3957,1 +4138,1 @@\n-  return interfaces()->intersection_with(other->interfaces());\n+  return _interfaces->intersection_with(other->_interfaces);\n@@ -4573,0 +4754,7 @@\n+\/\/------------------------------xdual------------------------------------------\n+\/\/ Dual: do NOT dual on klasses.  This means I do NOT understand the Java\n+\/\/ inheritance mechanism.\n+const Type *TypeInstPtr::xdual() const {\n+  return new TypeInstPtr(dual_ptr(), klass(), _interfaces, klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n+}\n+\n@@ -5342,0 +5530,6 @@\n+\/\/------------------------------xdual------------------------------------------\n+\/\/ Dual: compute field-by-field dual\n+const Type *TypeAryPtr::xdual() const {\n+  return new TypeAryPtr(dual_ptr(), _const_oop, _ary->dual()->is_ary(),_klass, _klass_is_exact, dual_offset(), dual_instance_id(), is_autobox_cache(), dual_speculative(), dual_inline_depth());\n+}\n+\n@@ -5462,0 +5656,6 @@\n+const Type *TypeNarrowPtr::xdual() const {    \/\/ Compute dual right now.\n+  const TypePtr* odual = _ptrtype->dual()->is_ptr();\n+  return make_same_narrowptr(odual);\n+}\n+\n+\n@@ -5691,0 +5891,7 @@\n+\/\/------------------------------xdual------------------------------------------\n+\/\/ Dual of a pure metadata pointer.\n+const Type *TypeMetadataPtr::xdual() const {\n+  return new TypeMetadataPtr(dual_ptr(), metadata(), dual_offset());\n+}\n+\n+\n@@ -5817,2 +6024,6 @@\n-  if (above_centerline(ptr()) || above_centerline(other->ptr())) {\n-    typerr(other);\n+  if (above_centerline(_ptr) && above_centerline(other->_ptr)) {\n+    return _interfaces->union_with(other->_interfaces);\n+  } else if (above_centerline(_ptr) && !above_centerline(other->_ptr)) {\n+    return other->_interfaces;\n+  } else if (above_centerline(other->_ptr) && !above_centerline(_ptr)) {\n+    return _interfaces;\n@@ -5820,1 +6031,1 @@\n-  return interfaces()->intersection_with(other->interfaces());\n+  return _interfaces->intersection_with(other->_interfaces);\n@@ -6181,0 +6392,6 @@\n+\/\/------------------------------xdual------------------------------------------\n+\/\/ Dual: compute field-by-field dual\n+const Type    *TypeInstKlassPtr::xdual() const {\n+  return new TypeInstKlassPtr(dual_ptr(), klass(), _interfaces, dual_offset());\n+}\n+\n@@ -6374,1 +6591,1 @@\n-  if (this != TypeAryPtr::OOPS) {\n+  if( this != TypeAryPtr::OOPS && this->dual() != TypeAryPtr::OOPS ) {\n@@ -6761,0 +6978,6 @@\n+\/\/------------------------------xdual------------------------------------------\n+\/\/ Dual: compute field-by-field dual\n+const Type    *TypeAryKlassPtr::xdual() const {\n+  return new TypeAryKlassPtr(dual_ptr(), elem()->dual(), klass(), dual_offset());\n+}\n+\n@@ -6861,0 +7084,6 @@\n+\/\/------------------------------xdual------------------------------------------\n+\/\/ Dual: compute field-by-field dual\n+const Type *TypeFunc::xdual() const {\n+  return this;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":251,"deletions":22,"binary":false,"changes":273,"status":"modified"},{"patch":"@@ -177,0 +177,6 @@\n+  \/\/ DUAL operation: reflect around lattice centerline.  Used instead of\n+  \/\/ join to ensure my lattice is symmetric up and down.  Dual is computed\n+  \/\/ lazily, on demand, and cached in _dual. Use to verify the result of the\n+  \/\/ new implementation of JOIN, to be removed later.\n+  const Type *_dual; \/\/ Cached dual value\n+\n@@ -182,1 +188,1 @@\n-  static void check_symmetrical(const Type* t1, const Type* t2, VerifyMeet& verify) NOT_DEBUG_RETURN;\n+  static void check_fundamental_laws(const Type* t1, const Type* t2, VerifyMeet& verify) NOT_DEBUG_RETURN;\n@@ -190,0 +196,1 @@\n+  virtual const Type* xdual() const; \/\/ Compute dual right now\n@@ -195,1 +202,1 @@\n-  const TYPES _base;          \/\/ Enum of Types type\n+  const TYPES _base;            \/\/ Enum of Types type\n@@ -197,4 +204,4 @@\n-  Type(TYPES t) : _base(t) {} \/\/ Simple types\n-  \/\/ ~Type();                 \/\/ Use fast deallocation\n-  const Type* hashcons();     \/\/ Hash-cons the type\n-  virtual const Type* filter_helper(const Type *kills, bool include_speculative) const;\n+  Type( TYPES t ) : _dual(nullptr),  _base(t) {} \/\/ Simple types\n+  \/\/ ~Type();                   \/\/ Use fast deallocation\n+  const Type *hashcons();       \/\/ Hash-cons the type\n+  virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;\n@@ -254,0 +261,4 @@\n+  \/\/ DUAL operation: reflect around lattice centerline.  Used instead of\n+  \/\/ join to ensure my lattice is symmetric up and down.\n+  const Type *dual() const { return _dual; }\n+\n@@ -522,0 +533,1 @@\n+  virtual const Type* xdual() const; \/\/ Compute dual right now\n@@ -554,0 +566,1 @@\n+  virtual const Type* xdual() const; \/\/ Compute dual right now\n@@ -585,0 +598,1 @@\n+  virtual const Type* xdual() const; \/\/ Compute dual right now\n@@ -808,0 +822,1 @@\n+  virtual const Type* xdual() const; \/\/ Compute dual right now\n@@ -895,0 +910,1 @@\n+  virtual const Type* xdual() const; \/\/ Compute dual right now\n@@ -957,0 +973,1 @@\n+  virtual const Type* xdual() const; \/\/ Compute dual right now\n@@ -997,0 +1014,1 @@\n+  virtual const Type* xdual() const; \/\/ Compute dual right now\n@@ -1032,0 +1050,2 @@\n+  virtual const Type* xdual() const; \/\/ Compute dual right now\n+\n@@ -1104,0 +1124,1 @@\n+  const Type* xdual() const;\n@@ -1139,5 +1160,2 @@\n-    Type(t), _speculative(speculative), _inline_depth(inline_depth), _offset(offset), _ptr(ptr) {\n-    assert(t == AnyPtr || (ptr != TopPTR && ptr != Null), \"Top and Null must be AnyPtr\");\n-    assert(ptr != AnyNull, \"Nonsensical PTR\");\n-    assert(static_cast<uint>(ptr) < static_cast<uint>(lastPTR), \"out of bounds\");\n-  }\n+    Type(t), _speculative(speculative), _inline_depth(inline_depth), _offset(offset),\n+    _ptr(ptr) {}\n@@ -1165,0 +1183,1 @@\n+  const TypePtr* dual_speculative() const;\n@@ -1176,0 +1195,1 @@\n+  int dual_inline_depth() const;\n@@ -1238,0 +1258,1 @@\n+  virtual const Type* xdual() const;\n@@ -1240,0 +1261,1 @@\n+  int dual_offset() const;\n@@ -1303,0 +1325,1 @@\n+  virtual const Type* xdual() const;\n@@ -1351,0 +1374,1 @@\n+  int dual_instance_id() const;\n@@ -1451,0 +1475,1 @@\n+  virtual const Type* xdual() const;\n@@ -1452,2 +1477,2 @@\n-  virtual const Type *xmeet_helper(const Type* t) const;\n-  virtual const Type *xjoin_helper(const Type* t) const;\n+  virtual const Type* xmeet_helper(const Type* t) const;\n+  virtual const Type* xjoin_helper(const Type* t) const;\n@@ -1577,0 +1602,1 @@\n+  virtual const Type* xdual() const;\n@@ -1689,0 +1715,1 @@\n+  virtual const Type* xdual() const;\n@@ -1753,0 +1780,1 @@\n+  virtual const Type* xdual() const;\n@@ -1825,0 +1853,1 @@\n+  virtual const Type*    xdual()                     const { ShouldNotReachHere(); return nullptr; }\n@@ -1907,0 +1936,1 @@\n+  virtual const Type* xdual() const;\n@@ -1969,0 +1999,1 @@\n+  virtual const Type* xdual() const;\n@@ -2005,0 +2036,2 @@\n+  virtual const Type* xdual() const;\n+\n@@ -2136,0 +2169,2 @@\n+  virtual const Type* xdual() const;\n+\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":48,"deletions":13,"binary":false,"changes":61,"status":"modified"}]}