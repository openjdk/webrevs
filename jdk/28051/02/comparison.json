{"files":[{"patch":"@@ -188,0 +188,4 @@\n+  if ((t->isa_rawptr() && type()->isa_oopptr()) || (t->isa_oopptr() && type()->isa_rawptr())) {\n+    assert(is_CheckCastPP(), \"unrelated types from %s\", Name());\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2015,0 +2015,4 @@\n+  if (is_mismatched_access()) {\n+    return _type;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -692,6 +692,0 @@\n-\/\/ Compute the meet of 2 types. When dual is true, the subset relation in CT is\n-\/\/ reversed. This means that the result of 2 CTs would be the intersection of\n-\/\/ them if dual is true, and be the union of them if dual is false. The subset\n-\/\/ relation in the Type hierarchy is still the same, however. E.g. the result\n-\/\/ of 1 CT and Type::BOTTOM would always be Type::BOTTOM, and the result of 1\n-\/\/ CT and Type::TOP would always be the CT instance itself.\n@@ -699,24 +693,13 @@\n-const Type* TypeIntHelper::int_type_xmeet(const CT* i1, const Type* t2) {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if (i1 == t2 || t2 == Type::TOP) {\n-    return i1;\n-  }\n-  const CT* i2 = t2->try_cast<CT>();\n-  if (i2 != nullptr) {\n-    assert(i1->_is_dual == i2->_is_dual, \"must have the same duality\");\n-    using S = std::remove_const_t<decltype(CT::_lo)>;\n-    using U = std::remove_const_t<decltype(CT::_ulo)>;\n-\n-    if (!i1->_is_dual) {\n-      \/\/ meet (a.k.a union)\n-      return CT::make_or_top(TypeIntPrototype<S, U>{{MIN2(i1->_lo, i2->_lo), MAX2(i1->_hi, i2->_hi)},\n-                                                    {MIN2(i1->_ulo, i2->_ulo), MAX2(i1->_uhi, i2->_uhi)},\n-                                                    {i1->_bits._zeros & i2->_bits._zeros, i1->_bits._ones & i2->_bits._ones}},\n-                             MAX2(i1->_widen, i2->_widen), false);\n-    } else {\n-      \/\/ join (a.k.a intersection)\n-      return CT::make_or_top(TypeIntPrototype<S, U>{{MAX2(i1->_lo, i2->_lo), MIN2(i1->_hi, i2->_hi)},\n-                                                    {MAX2(i1->_ulo, i2->_ulo), MIN2(i1->_uhi, i2->_uhi)},\n-                                                    {i1->_bits._zeros | i2->_bits._zeros, i1->_bits._ones | i2->_bits._ones}},\n-                             MIN2(i1->_widen, i2->_widen), true);\n-    }\n+const Type* TypeIntHelper::int_type_xmeet(const CT* t1, const CT* t2) {\n+  using S = std::remove_const_t<decltype(CT::_lo)>;\n+  using U = std::remove_const_t<decltype(CT::_ulo)>;\n+  if (!t1->_is_dual) {\n+    return CT::make_or_top(TypeIntPrototype<S, U>{{MIN2(t1->_lo, t2->_lo), MAX2(t1->_hi, t2->_hi)},\n+                                                  {MIN2(t1->_ulo, t2->_ulo), MAX2(t1->_uhi, t2->_uhi)},\n+                                                  {t1->_bits._zeros & t2->_bits._zeros, t1->_bits._ones & t2->_bits._ones}},\n+                           MAX2(t1->_widen, t2->_widen), false);\n+  } else {\n+    return CT::make_or_top(TypeIntPrototype<S, U>{{MAX2(t1->_lo, t2->_lo), MIN2(t1->_hi, t2->_hi)},\n+                                                  {MAX2(t1->_ulo, t2->_ulo), MIN2(t1->_uhi, t2->_uhi)},\n+                                                  {t1->_bits._zeros | t2->_bits._zeros, t1->_bits._ones | t2->_bits._ones}},\n+                           MIN2(t1->_widen, t2->_widen), true);\n@@ -724,0 +707,3 @@\n+}\n+template const Type* TypeIntHelper::int_type_xmeet(const TypeInt* i1, const TypeInt* t2);\n+template const Type* TypeIntHelper::int_type_xmeet(const TypeLong* i1, const TypeLong* t2);\n@@ -725,30 +711,8 @@\n-  assert(t2->base() != i1->base(), \"\");\n-  switch (t2->base()) {          \/\/ Switch on original type\n-  case Type::AnyPtr:                  \/\/ Mixing with oops happens when javac\n-  case Type::RawPtr:                  \/\/ reuses local variables\n-  case Type::OopPtr:\n-  case Type::InstPtr:\n-  case Type::AryPtr:\n-  case Type::MetadataPtr:\n-  case Type::KlassPtr:\n-  case Type::InstKlassPtr:\n-  case Type::AryKlassPtr:\n-  case Type::NarrowOop:\n-  case Type::NarrowKlass:\n-  case Type::Int:\n-  case Type::Long:\n-  case Type::HalfFloatTop:\n-  case Type::HalfFloatCon:\n-  case Type::HalfFloatBot:\n-  case Type::FloatTop:\n-  case Type::FloatCon:\n-  case Type::FloatBot:\n-  case Type::DoubleTop:\n-  case Type::DoubleCon:\n-  case Type::DoubleBot:\n-  case Type::Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-  default:                      \/\/ All else is a mistake\n-    i1->typerr(t2);\n-    return nullptr;\n-  }\n+template <class CT>\n+const Type* TypeIntHelper::int_type_xjoin(const CT* t1, const CT* t2) {\n+  using S = std::remove_const_t<decltype(CT::_lo)>;\n+  using U = std::remove_const_t<decltype(CT::_ulo)>;\n+  return CT::make_or_top(TypeIntPrototype<S, U>{{MAX2(t1->_lo, t2->_lo), MIN2(t1->_hi, t2->_hi)},\n+                                                {MAX2(t1->_ulo, t2->_ulo), MIN2(t1->_uhi, t2->_uhi)},\n+                                                {t1->_bits._zeros | t2->_bits._zeros, t1->_bits._ones | t2->_bits._ones}},\n+                         MIN2(t1->_widen, t2->_widen), false);\n@@ -756,2 +720,2 @@\n-template const Type* TypeIntHelper::int_type_xmeet(const TypeInt* i1, const Type* t2);\n-template const Type* TypeIntHelper::int_type_xmeet(const TypeLong* i1, const Type* t2);\n+template const Type* TypeIntHelper::int_type_xjoin(const TypeInt* i1, const TypeInt* t2);\n+template const Type* TypeIntHelper::int_type_xjoin(const TypeLong* i1, const TypeLong* t2);\n","filename":"src\/hotspot\/share\/opto\/rangeinference.cpp","additions":26,"deletions":62,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -160,1 +160,4 @@\n-  static const Type* int_type_xmeet(const CT* i1, const Type* t2);\n+  static const Type* int_type_xmeet(const CT* i1, const CT* t2);\n+\n+  template <class CT>\n+  static const Type* int_type_xjoin(const CT* i1, const CT* t2);\n","filename":"src\/hotspot\/share\/opto\/rangeinference.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1997,2 +1997,3 @@\n-  if (phase->type(in1)->higher_equal(TypeInt::POS) ||\n-      phase->type(in1)->higher_equal(TypeLong::POS)) {\n+  const Type* in_type = phase->type(in1);\n+  if ((in_type->isa_int() && in_type->is_int()->_lo >= 0) ||\n+      (in_type->isa_long() && in_type->is_long()->_lo >= 0)) {\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"ci\/ciObject.hpp\"\n@@ -40,0 +41,1 @@\n+#include \"opto\/compile.hpp\"\n@@ -48,0 +50,2 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n@@ -761,1 +765,1 @@\n-const Type *Type::hashcons(void) {\n+const Type* Type::hashcons() {\n@@ -764,1 +768,1 @@\n-  Dict *tdic = type_dict();\n+  Dict* tdic = type_dict();\n@@ -766,5 +770,6 @@\n-  if( old ) {                   \/\/ Pre-existing Type?\n-    if( old != this )           \/\/ Yes, this guy is not the pre-existing?\n-      delete this;              \/\/ Yes, Nuke this guy\n-    assert( old->_dual, \"\" );\n-    return old;                 \/\/ Return pre-existing\n+  if (old != nullptr) {\n+    if (old != this) {\n+      delete this;\n+    }\n+    assert(old->_dual, \"\");\n+    return old;\n@@ -773,0 +778,1 @@\n+#ifdef ASSERT\n@@ -789,1 +795,0 @@\n-#ifdef ASSERT\n@@ -793,2 +798,3 @@\n-#endif\n-  return this;                  \/\/ Return new Type\n+#endif \/\/ ASSERT\n+\n+  return this;\n@@ -866,0 +872,2 @@\n+\n+  bool _is_disable;\n@@ -867,11 +875,16 @@\n-  GrowableArray<VerifyMeetResultEntry> _cache;\n-\n-  \/\/ With verification code, the meet of A and B causes the computation of:\n-  \/\/ 1- meet(A, B)\n-  \/\/ 2- meet(B, A)\n-  \/\/ 3- meet(dual(meet(A, B)), dual(A))\n-  \/\/ 4- meet(dual(meet(A, B)), dual(B))\n-  \/\/ 5- meet(dual(A), dual(B))\n-  \/\/ 6- meet(dual(B), dual(A))\n-  \/\/ 7- meet(dual(meet(dual(A), dual(B))), A)\n-  \/\/ 8- meet(dual(meet(dual(A), dual(B))), B)\n+  GrowableArray<VerifyMeetResultEntry> _meet_cache;\n+  GrowableArray<VerifyMeetResultEntry> _join_cache;\n+\n+  \/\/ With verification code, the meet\/join of A and B causes the computation of:\n+  \/\/ 1-  meet(A, B)\n+  \/\/ 2-  meet(B, A)\n+  \/\/ 3-  join(A, B)\n+  \/\/ 4-  join(B, A)\n+  \/\/ 5-  meet(A, meet(A, B))\n+  \/\/ 6-  meet(B, meet(A, B))\n+  \/\/ 7-  join(A, meet(A, B))\n+  \/\/ 8-  join(B, meet(A, B))\n+  \/\/ 9-  meet(A, join(A, B))\n+  \/\/ 10- meet(B, join(A, B))\n+  \/\/ 11- join(A, join(A, B))\n+  \/\/ 12- join(B, join(A, B))\n@@ -882,9 +895,13 @@\n-  \/\/ 1- meet(A[], B[][)\n-  \/\/   1.1- meet(A, B)\n-  \/\/   1.2- meet(B, A)\n-  \/\/   1.3- meet(dual(meet(A, B)), dual(A))\n-  \/\/   1.4- meet(dual(meet(A, B)), dual(B))\n-  \/\/   1.5- meet(dual(A), dual(B))\n-  \/\/   1.6- meet(dual(B), dual(A))\n-  \/\/   1.7- meet(dual(meet(dual(A), dual(B))), A)\n-  \/\/   1.8- meet(dual(meet(dual(A), dual(B))), B)\n+  \/\/ 1- meet(A[], B[])\n+  \/\/   1.1-  meet(A, B)\n+  \/\/   1.2-  meet(B, A)\n+  \/\/   1.3-  join(A, B)\n+  \/\/   1.4-  join(B, A)\n+  \/\/   1.5-  meet(A, meet(A, B))\n+  \/\/   1.6-  meet(B, meet(A, B))\n+  \/\/   1.7-  join(A, meet(A, B))\n+  \/\/   1.8-  join(B, meet(A, B))\n+  \/\/   1.9-  meet(A, join(A, B))\n+  \/\/   1.10- meet(B, join(A, B))\n+  \/\/   1.11- join(A, join(A, B))\n+  \/\/   1.12- join(B, join(A, B))\n@@ -892,8 +909,12 @@\n-  \/\/   2.1- meet(B, A) = 1.2\n-  \/\/   2.2- meet(A, B) = 1.1\n-  \/\/   2.3- meet(dual(meet(B, A)), dual(B)) = 1.4\n-  \/\/   2.4- meet(dual(meet(B, A)), dual(A)) = 1.3\n-  \/\/   2.5- meet(dual(B), dual(A)) = 1.6\n-  \/\/   2.6- meet(dual(A), dual(B)) = 1.5\n-  \/\/   2.7- meet(dual(meet(dual(B), dual(A))), B) = 1.8\n-  \/\/   2.8- meet(dual(meet(dual(B), dual(A))), B) = 1.7\n+  \/\/   2.1-  meet(B, A) = 1.2\n+  \/\/   2.2-  meet(A, B) = 1.1\n+  \/\/   1.3-  join(B, A) = 1.4\n+  \/\/   1.4-  join(A, B) = 1.3\n+  \/\/   1.5-  meet(B, meet(B, A)) = 1.6\n+  \/\/   1.6-  meet(A, meet(B, A)) = 1.5\n+  \/\/   1.7-  join(B, meet(B, A)) = 1.8\n+  \/\/   1.8-  join(A, meet(B, A)) = 1.7\n+  \/\/   1.9-  meet(B, join(B, A)) = 1.10\n+  \/\/   1.10- meet(A, join(B, A)) = 1.9\n+  \/\/   1.11- join(B, join(B, A)) = 1.12\n+  \/\/   1.12- join(A, join(B, A)) = 1.11\n@@ -901,3 +922,0 @@\n-  \/\/ The number of meet operations performed grows exponentially with the number of dimensions of the arrays but the number\n-  \/\/ of different meet operations is linear in the number of dimensions. The function below caches meet results for the\n-  \/\/ duration of the meet at the root of the recursive calls.\n@@ -905,1 +923,5 @@\n-  const Type* meet(const Type* t1, const Type* t2) {\n+  \/\/ When the dimensions of the arrays increase, the number of performed operations grows\n+  \/\/ exponentially but the number of distinct operations grows linearly. The function below caches\n+  \/\/ the results for the duration of the operation at the root of the recursive calls.\n+  template <class F>\n+  static const Type* meet_join(F op, GrowableArray<VerifyMeetResultEntry>& cache, const Type* t1, const Type* t2) {\n@@ -907,2 +929,2 @@\n-    const VerifyMeetResultEntry meet(t1, t2, nullptr);\n-    int pos = _cache.find_sorted<VerifyMeetResultEntry, VerifyMeetResultEntry::compare>(meet, found);\n+    const VerifyMeetResultEntry entry(t1, t2, nullptr);\n+    int pos = cache.find_sorted<VerifyMeetResultEntry, VerifyMeetResultEntry::compare>(entry, found);\n@@ -911,1 +933,1 @@\n-      res = _cache.at(pos).res();\n+      res = cache.at(pos).res();\n@@ -913,2 +935,2 @@\n-      res = t1->xmeet(t2);\n-      _cache.insert_sorted<VerifyMeetResultEntry::compare>(VerifyMeetResultEntry(t1, t2, res));\n+      res = op(t1, t2);\n+      cache.insert_sorted<VerifyMeetResultEntry::compare>(VerifyMeetResultEntry(t1, t2, res));\n@@ -916,1 +938,1 @@\n-      _cache.find_sorted<VerifyMeetResultEntry, VerifyMeetResultEntry::compare>(meet, found);\n+      cache.find_sorted<VerifyMeetResultEntry, VerifyMeetResultEntry::compare>(entry, found);\n@@ -922,2 +944,12 @@\n-  void add(const Type* t1, const Type* t2, const Type* res) {\n-    _cache.insert_sorted<VerifyMeetResultEntry::compare>(VerifyMeetResultEntry(t1, t2, res));\n+  const Type* meet(const Type* t1, const Type* t2) {\n+    auto op = [](const Type* t1, const Type* t2) {\n+      return Type::xmeet(t1, t2);\n+    };\n+    return meet_join(op, _meet_cache, t1, t2);\n+  }\n+\n+  const Type* join(const Type* t1, const Type* t2) {\n+    auto op = [](const Type* t1, const Type* t2) {\n+      return Type::xjoin(t1, t2);\n+    };\n+    return meet_join(op, _join_cache, t1, t2);\n@@ -926,2 +958,8 @@\n-  bool empty_cache() const {\n-    return _cache.length() == 0;\n+  bool cache_is_empty() const {\n+    assert(_meet_cache.is_empty() == _join_cache.is_empty(), \"must be simultaneously empty or non-empty\");\n+    return _meet_cache.is_empty();\n+  }\n+\n+  void empty_cache() {\n+    _meet_cache.trunc_to(0);\n+    _join_cache.trunc_to(0);\n@@ -930,2 +968,3 @@\n-  VerifyMeetResult(Compile* C) :\n-          _depth(0), _cache(C->comp_arena(), 2, 0, VerifyMeetResultEntry()) {\n+  VerifyMeetResult(Compile* C) : _is_disable(false), _depth(0),\n+                                 _meet_cache(C->comp_arena(), 2, 0, VerifyMeetResultEntry()),\n+                                 _join_cache(C->comp_arena(), 2, 0, VerifyMeetResultEntry()) {\n@@ -935,4 +974,0 @@\n-void Type::assert_type_verify_empty() const {\n-  assert(Compile::current()->_type_verify == nullptr || Compile::current()->_type_verify->empty_cache(), \"cache should have been discarded\");\n-}\n-\n@@ -954,1 +989,1 @@\n-      _C->_type_verify->_cache.trunc_to(0);\n+      _C->_type_verify->empty_cache();\n@@ -958,1 +993,1 @@\n-  const Type* meet(const Type* t1, const Type* t2) const {\n+  const Type* meet(const Type* t1, const Type* t2) {\n@@ -962,2 +997,14 @@\n-  void add(const Type* t1, const Type* t2, const Type* res) const {\n-    _C->_type_verify->add(t1, t2, res);\n+  const Type* join(const Type* t1, const Type* t2) {\n+    return _C->_type_verify->join(t1, t2);\n+  }\n+\n+  bool is_disabled() const {\n+    return _C->_type_verify->_is_disable;\n+  }\n+\n+  void disable() {\n+    _C->_type_verify->_is_disable = true;\n+  }\n+\n+  void enable() {\n+    _C->_type_verify->_is_disable = false;\n@@ -967,4 +1014,8 @@\n-void Type::check_symmetrical(const Type* t, const Type* mt, const VerifyMeet& verify) const {\n-  Compile* C = Compile::current();\n-  const Type* mt2 = verify.meet(t, this);\n-  if (mt != mt2) {\n+void Type::check_fundamental_laws(const Type* t1, const Type* t2, VerifyMeet& verify) {\n+  if (verify.is_disabled()) {\n+    return;\n+  }\n+\n+  const Type* mt1 = verify.meet(t1, t2);\n+  const Type* mt2 = verify.meet(t2, t1);\n+  if (mt1 != mt2) {\n@@ -972,4 +1023,4 @@\n-    tty->print(\"t           = \");   t->dump(); tty->cr();\n-    tty->print(\"this        = \");      dump(); tty->cr();\n-    tty->print(\"t meet this = \"); mt2->dump(); tty->cr();\n-    tty->print(\"this meet t = \");  mt->dump(); tty->cr();\n+    tty->print(\"t1          = \");  t1->dump(); tty->cr();\n+    tty->print(\"t2          = \");  t2->dump(); tty->cr();\n+    tty->print(\"t1 meets t2 = \"); mt1->dump(); tty->cr();\n+    tty->print(\"t2 meets t1 = \"); mt2->dump(); tty->cr();\n@@ -978,3 +1029,0 @@\n-  const Type* dual_join = mt->_dual;\n-  const Type* t2t    = verify.meet(dual_join,t->_dual);\n-  const Type* t2this = verify.meet(dual_join,this->_dual);\n@@ -982,3 +1030,38 @@\n-  \/\/ Interface meet Oop is Not Symmetric:\n-  \/\/ Interface:AnyNull meet Oop:AnyNull == Interface:AnyNull\n-  \/\/ Interface:NotNull meet Oop:NotNull == java\/lang\/Object:NotNull\n+  const Type* jt1 = verify.join(t1, t2);\n+  const Type* jt2 = verify.join(t2, t1);\n+  if (jt1 != jt2) {\n+    tty->print_cr(\"=== Join Not Commutative ===\");\n+    tty->print(\"t1          = \");  t1->dump(); tty->cr();\n+    tty->print(\"t2          = \");  t2->dump(); tty->cr();\n+    tty->print(\"t1 joins t2 = \"); jt1->dump(); tty->cr();\n+    tty->print(\"t2 joins t1 = \"); jt2->dump(); tty->cr();\n+    fatal(\"join not commutative\");\n+  }\n+\n+  if (t1->isa_ptr() && t1->maybe_null() && t2->isa_ptr() && t2->maybe_null() && jt1->empty()) {\n+    tty->print_cr(\"=== Join of Nullable Pointers Cannot Be Empty ===\");\n+    tty->print(\"t1          = \");  t1->dump(); tty->cr();\n+    tty->print(\"t2          = \");  t2->dump(); tty->cr();\n+    tty->print(\"t1 joins t2 = \"); jt1->dump(); tty->cr();\n+    fatal(\"incorrect join\");\n+  }\n+\n+  \/\/ Do not do Type::check_fundamental_laws since we do not implement join for dual types\n+  verify.disable();\n+  const Type* mdt = verify.meet(t1->dual(), t2->dual())->dual();\n+  verify.enable();\n+\n+  if (jt1->remove_speculative() != mdt->remove_speculative() && (!jt1->empty() || !mdt->empty())) {\n+    bool excluded_case = t1->isa_ptr() && t1->maybe_null() && t2->isa_ptr() && t2->maybe_null() && mdt->empty() && jt1->is_ptr()->ptr() == TypePtr::Null;\n+    if (!excluded_case) {\n+      tty->print_cr(\"=== Join May Be Incorrect ===\");\n+      tty->print(\"t1                                    = \");  t1->dump(); tty->cr();\n+      tty->print(\"t2                                    = \");  t2->dump(); tty->cr();\n+      tty->print(\"t1 joins t2                           = \"); jt1->dump(); tty->cr();\n+      tty->print(\"(t1->dual() meets t2->dual())->dual() = \"); mdt->dump(); tty->cr();\n+      fatal(\"join may be incorrect\");\n+    }\n+  }\n+\n+  const Type* mt = mt1;\n+  const Type* jt = jt1;\n@@ -986,5 +1069,8 @@\n-  if (t2t != t->_dual || t2this != this->_dual) {\n-    tty->print_cr(\"=== Meet Not Symmetric ===\");\n-    tty->print(\"t   =                   \");              t->dump(); tty->cr();\n-    tty->print(\"this=                   \");                 dump(); tty->cr();\n-    tty->print(\"mt=(t meet this)=       \");             mt->dump(); tty->cr();\n+  const Type* t1mmt = verify.meet(t1, mt);\n+  const Type* t2mmt = verify.meet(t2, mt);\n+  const Type* t1jmt = verify.join(t1, mt);\n+  const Type* t2jmt = verify.join(t2, mt);\n+  const Type* t1mjt = verify.meet(t1, jt);\n+  const Type* t2mjt = verify.meet(t2, jt);\n+  const Type* t1jjt = verify.join(t1, jt);\n+  const Type* t2jjt = verify.join(t2, jt);\n@@ -992,3 +1078,7 @@\n-    tty->print(\"t_dual=                 \");       t->_dual->dump(); tty->cr();\n-    tty->print(\"this_dual=              \");          _dual->dump(); tty->cr();\n-    tty->print(\"mt_dual=                \");      mt->_dual->dump(); tty->cr();\n+  if (t1mmt != mt || t2mmt != mt || t1jmt != t1 || t2jmt != t2 ||\n+      t1mjt != t1 || t2mjt != t2 || t1jjt != jt || t2jjt != jt) {\n+    tty->print_cr(\"=== Fundamental Laws Violation ===\");\n+    tty->print(\"t1               = \"); t1->dump(); tty->cr();\n+    tty->print(\"t2               = \"); t2->dump(); tty->cr();\n+    tty->print(\"mt = t1 meets t2 = \"); mt->dump(); tty->cr();\n+    tty->print(\"jt = t1 joins t2 = \"); jt->dump(); tty->cr();\n@@ -996,2 +1086,8 @@\n-    tty->print(\"mt_dual meet t_dual=    \"); t2t           ->dump(); tty->cr();\n-    tty->print(\"mt_dual meet this_dual= \"); t2this        ->dump(); tty->cr();\n+    tty->print(\"t1 meets mt      = \"); t1mmt->dump(); tty->cr();\n+    tty->print(\"t2 meets mt      = \"); t2mmt->dump(); tty->cr();\n+    tty->print(\"t1 joins mt      = \"); t1jmt->dump(); tty->cr();\n+    tty->print(\"t2 joins mt      = \"); t2jmt->dump(); tty->cr();\n+    tty->print(\"t1 meets jt      = \"); t1mjt->dump(); tty->cr();\n+    tty->print(\"t2 meets jt      = \"); t2mjt->dump(); tty->cr();\n+    tty->print(\"t1 joins jt      = \"); t1jjt->dump(); tty->cr();\n+    tty->print(\"t2 joins jt      = \"); t2jjt->dump(); tty->cr();\n@@ -999,1 +1095,1 @@\n-    fatal(\"meet not symmetric\");\n+    fatal(\"fundamental laws violation\");\n@@ -1004,6 +1100,4 @@\n-\/\/------------------------------meet-------------------------------------------\n-\/\/ Compute the MEET of two types.  NOT virtual.  It enforces that meet is\n-\/\/ commutative and the lattice is symmetric.\n-const Type *Type::meet_helper(const Type *t, bool include_speculative) const {\n-  if (isa_narrowoop() && t->isa_narrowoop()) {\n-    const Type* result = make_ptr()->meet_helper(t->make_ptr(), include_speculative);\n+template <class F>\n+const Type* Type::meet_join_helper(F op, const Type* t1, const Type* t2, bool include_speculative) {\n+  if (t1->isa_narrowoop() && t2->isa_narrowoop()) {\n+    const Type* result = meet_join_helper(op, t1->make_ptr(), t2->make_ptr(), include_speculative);\n@@ -1012,2 +1106,2 @@\n-  if (isa_narrowklass() && t->isa_narrowklass()) {\n-    const Type* result = make_ptr()->meet_helper(t->make_ptr(), include_speculative);\n+  if (t1->isa_narrowklass() && t2->isa_narrowklass()) {\n+    const Type* result = meet_join_helper(op, t1->make_ptr(), t2->make_ptr(), include_speculative);\n@@ -1017,0 +1111,4 @@\n+  t1 = t1->maybe_remove_speculative(include_speculative);\n+  t2 = t2->maybe_remove_speculative(include_speculative);\n+  const Type* rt = op(t1, t2);\n+\n@@ -1020,0 +1118,1 @@\n+  check_fundamental_laws(t1, t2, verify);\n@@ -1022,17 +1121,1 @@\n-  const Type *this_t = maybe_remove_speculative(include_speculative);\n-  t = t->maybe_remove_speculative(include_speculative);\n-\n-  const Type *mt = this_t->xmeet(t);\n-#ifdef ASSERT\n-  verify.add(this_t, t, mt);\n-  if (isa_narrowoop() || t->isa_narrowoop()) {\n-    return mt;\n-  }\n-  if (isa_narrowklass() || t->isa_narrowklass()) {\n-    return mt;\n-  }\n-  this_t->check_symmetrical(t, mt, verify);\n-  const Type *mt_dual = verify.meet(this_t->_dual, t->_dual);\n-  this_t->_dual->check_symmetrical(t->_dual, mt_dual, verify);\n-#endif\n-  return mt;\n+  return rt;\n@@ -1041,11 +1124,9 @@\n-\/\/------------------------------xmeet------------------------------------------\n-\/\/ Compute the MEET of two types.  It returns a new Type object.\n-const Type *Type::xmeet( const Type *t ) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n-\n-  \/\/ Meeting TOP with anything?\n-  if( _base == Top ) return t;\n-\n-  \/\/ Meeting BOTTOM with anything?\n-  if( _base == Bottom ) return BOTTOM;\n+\/\/------------------------------meet-------------------------------------------\n+\/\/ Compute the MEET of two types.  NOT virtual.  It enforces that meet is\n+\/\/ commutative and the lattice is symmetric.\n+const Type *Type::meet_helper(const Type *t, bool include_speculative) const {\n+  auto op = [](const Type* t1, const Type* t2) {\n+    return xmeet(t1, t2);\n+  };\n+  return meet_join_helper(op, this, t, include_speculative);\n+}\n@@ -1053,3 +1134,6 @@\n-  \/\/ Current \"this->_base\" is one of: Bad, Multi, Control, Top,\n-  \/\/ Abio, Abstore, Floatxxx, Doublexxx, Bottom, lastype.\n-  switch (t->base()) {  \/\/ Switch on original type\n+const Type* Type::join_helper(const Type* t, bool include_speculative) const {\n+  auto op = [](const Type* t1, const Type* t2) {\n+    return xjoin(t1, t2);\n+  };\n+  return meet_join_helper(op, this, t, include_speculative);\n+}\n@@ -1057,8 +1141,11 @@\n-  \/\/ Cut in half the number of cases I must handle.  Only need cases for when\n-  \/\/ the given enum \"t->type\" is less than or equal to the local enum \"type\".\n-  case HalfFloatCon:\n-  case FloatCon:\n-  case DoubleCon:\n-  case Int:\n-  case Long:\n-    return t->xmeet(this);\n+const Type* Type::xmeet(const Type* t1, const Type* t2) {\n+  if (t1 == t2) {\n+    return t1;\n+  }\n+  if (t1 == Type::TOP) {\n+    return t2;\n+  } else if (t2 == Type::TOP) {\n+    return t1;\n+  } else if (t1 == Type::BOTTOM || t2 == Type::BOTTOM) {\n+    return Type::BOTTOM;\n+  }\n@@ -1066,2 +1153,2 @@\n-  case OopPtr:\n-    return t->xmeet(this);\n+  return t1->xmeet(t2);\n+}\n@@ -1069,2 +1156,11 @@\n-  case InstPtr:\n-    return t->xmeet(this);\n+const Type* Type::xjoin(const Type* t1, const Type* t2) {\n+  if (t1 == t2) {\n+    return t1;\n+  }\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  } else if (t1 == Type::BOTTOM) {\n+    return t2;\n+  } else if (t2 == Type::BOTTOM) {\n+    return t1;\n+  }\n@@ -1072,5 +1168,2 @@\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-    return t->xmeet(this);\n+  return t1->xjoin(t2);\n+}\n@@ -1078,2 +1171,18 @@\n-  case AryPtr:\n-    return t->xmeet(this);\n+\/\/------------------------------xmeet------------------------------------------\n+\/\/ Compute the MEET of two types. It returns a new Type object.\n+const Type* Type::xmeet(const Type* t) const {\n+  \/\/ Current \"this->_base\" is one of: Floatxxx, Doublexxx. For Bad, Multi, Control, Abio, Abstore,\n+  \/\/ should have been handled by Type::xmeet(const Type* t1, const Type* t2) since their types are\n+  \/\/ singleton and t1 must always be equal to t2.\n+  switch (base()) {\n+    default:\n+      typerr(t);\n+\n+    case HalfFloatTop:\n+    case HalfFloatBot:\n+    case FloatTop:\n+    case FloatBot:\n+    case DoubleTop:\n+    case DoubleBot:\n+      break;\n+  }\n@@ -1081,2 +1190,16 @@\n-  case NarrowOop:\n-    return t->xmeet(this);\n+  switch (t->base()) {  \/\/ Switch on original type\n+    case HalfFloatCon:\n+    case FloatCon:\n+    case DoubleCon:\n+      return t->xmeet(this);\n+\n+    case HalfFloatTop:\n+      if (base() == HalfFloatTop || base() == HalfFloatBot) {\n+        return this;\n+      }\n+      typerr(t);\n+    case HalfFloatBot:\n+      if (base() == HalfFloatTop || base() == HalfFloatBot) {\n+        return t;\n+      }\n+      typerr(t);\n@@ -1084,2 +1207,10 @@\n-  case NarrowKlass:\n-    return t->xmeet(this);\n+    case FloatTop:\n+      if (base() == FloatTop || base() == FloatBot) {\n+        return this;\n+      }\n+      typerr(t);\n+    case FloatBot:\n+      if (base() == FloatTop || base() == FloatBot) {\n+        return t;\n+      }\n+      typerr(t);\n@@ -1087,4 +1218,10 @@\n-  case Bad:                     \/\/ Type check\n-  default:                      \/\/ Bogus type not in lattice\n-    typerr(t);\n-    return Type::BOTTOM;\n+    case DoubleTop:\n+      if (base() == DoubleTop || base() == DoubleBot) {\n+        return this;\n+      }\n+      typerr(t);\n+    case DoubleBot:\n+      if (base() == DoubleTop || base() == DoubleBot) {\n+        return t;\n+      }\n+      typerr(t);\n@@ -1092,2 +1229,4 @@\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return t;\n+    default:\n+      typerr(t);\n+  }\n+}\n@@ -1095,8 +1234,14 @@\n-  case HalfFloatTop:\n-    if (_base == HalfFloatTop) { return this; }\n-  case HalfFloatBot:            \/\/ Half Float\n-    if (_base == HalfFloatBot || _base == HalfFloatTop) { return HALF_FLOAT; }\n-    if (_base == FloatBot || _base == FloatTop) { return Type::BOTTOM; }\n-    if (_base == DoubleTop || _base == DoubleBot) { return Type::BOTTOM; }\n-    typerr(t);\n-    return Type::BOTTOM;\n+\/\/ Compute the JOIN of two types. This is similar to xmeet above.\n+const Type* Type::xjoin(const Type* t) const {\n+  switch (base()) {\n+    default:\n+      typerr(t);\n+\n+    case HalfFloatTop:\n+    case HalfFloatBot:\n+    case FloatTop:\n+    case FloatBot:\n+    case DoubleTop:\n+    case DoubleBot:\n+      break;\n+  }\n@@ -1104,8 +1249,16 @@\n-  case FloatTop:\n-    if (_base == FloatTop ) { return this; }\n-  case FloatBot:                \/\/ Float\n-    if (_base == FloatBot || _base == FloatTop) { return FLOAT; }\n-    if (_base == HalfFloatTop || _base == HalfFloatBot) { return Type::BOTTOM; }\n-    if (_base == DoubleTop || _base == DoubleBot) { return Type::BOTTOM; }\n-    typerr(t);\n-    return Type::BOTTOM;\n+  switch (t->base()) {  \/\/ Switch on original type\n+    case HalfFloatCon:\n+    case FloatCon:\n+    case DoubleCon:\n+      return t->xjoin(this);\n+\n+    case HalfFloatTop:\n+      if (base() == HalfFloatTop || base() == HalfFloatBot) {\n+        return t;\n+      }\n+      typerr(t);\n+    case HalfFloatBot:\n+      if (base() == HalfFloatTop || base() == HalfFloatBot) {\n+        return this;\n+      }\n+      typerr(t);\n@@ -1113,8 +1266,10 @@\n-  case DoubleTop:\n-    if (_base == DoubleTop) { return this; }\n-  case DoubleBot:               \/\/ Double\n-    if (_base == DoubleBot || _base == DoubleTop) { return DOUBLE; }\n-    if (_base == HalfFloatTop || _base == HalfFloatBot) { return Type::BOTTOM; }\n-    if (_base == FloatTop || _base == FloatBot) { return Type::BOTTOM; }\n-    typerr(t);\n-    return Type::BOTTOM;\n+    case FloatTop:\n+      if (base() == FloatTop || base() == FloatBot) {\n+        return t;\n+      }\n+      typerr(t);\n+    case FloatBot:\n+      if (base() == FloatTop || base() == FloatBot) {\n+        return this;\n+      }\n+      typerr(t);\n@@ -1122,7 +1277,10 @@\n-  \/\/ These next few cases must match exactly or it is a compile-time error.\n-  case Control:                 \/\/ Control of code\n-  case Abio:                    \/\/ State of world outside of program\n-  case Memory:\n-    if (_base == t->_base)  { return this; }\n-    typerr(t);\n-    return Type::BOTTOM;\n+    case DoubleTop:\n+      if (base() == DoubleTop || base() == DoubleBot) {\n+        return t;\n+      }\n+      typerr(t);\n+    case DoubleBot:\n+      if (base() == DoubleTop || base() == DoubleBot) {\n+        return this;\n+      }\n+      typerr(t);\n@@ -1130,2 +1288,2 @@\n-  case Top:                     \/\/ Top of the lattice\n-    return this;\n+    default:\n+      typerr(t);\n@@ -1133,3 +1291,0 @@\n-\n-  \/\/ The type is unchanged\n-  return this;\n@@ -1146,0 +1301,1 @@\n+#ifdef ASSERT\n@@ -1152,0 +1308,1 @@\n+#endif \/\/ ASSERT\n@@ -1350,6 +1507,1 @@\n-\/\/------------------------------meet-------------------------------------------\n-\/\/ Compute the MEET of two types.  It returns a new Type object.\n-const Type *TypeF::xmeet( const Type *t ) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n-\n+const Type* TypeF::xmeet(const Type* t) const {\n@@ -1357,28 +1509,12 @@\n-  switch (t->base()) {          \/\/ Switch on original type\n-  case AnyPtr:                  \/\/ Mixing with oops happens when javac\n-  case RawPtr:                  \/\/ reuses local variables\n-  case OopPtr:\n-  case InstPtr:\n-  case AryPtr:\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-  case NarrowOop:\n-  case NarrowKlass:\n-  case Int:\n-  case Long:\n-  case HalfFloatTop:\n-  case HalfFloatCon:\n-  case HalfFloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-\n-  case FloatBot:\n-    return t;\n-\n-  default:                      \/\/ All else is a mistake\n-    typerr(t);\n+  switch (t->base()) {\n+    case FloatTop:\n+      return this;\n+    case FloatCon:\n+      assert(jint_cast(_f) != jint_cast(t->getf()), \"Equivalent instances should not appear here\");\n+      return Type::FLOAT;\n+    case FloatBot:\n+      return t;\n+    default:\n+      typerr(t);\n+  }\n+}\n@@ -1386,9 +1522,12 @@\n-  case FloatCon:                \/\/ Float-constant vs Float-constant?\n-    if( jint_cast(_f) != jint_cast(t->getf()) )         \/\/ unequal constants?\n-                                \/\/ must compare bitwise as positive zero, negative zero and NaN have\n-                                \/\/ all the same representation in C++\n-      return FLOAT;             \/\/ Return generic float\n-                                \/\/ Equal constants\n-  case Top:\n-  case FloatTop:\n-    break;                      \/\/ Return the float constant\n+const Type* TypeF::xjoin(const Type* t) const {\n+  \/\/ Current \"this->_base\" is FloatCon\n+  switch (t->base()) {\n+    case FloatTop:\n+      return t;\n+    case FloatCon:\n+      assert(jint_cast(_f) != jint_cast(t->getf()), \"Equivalent instances should not appear here\");\n+      return Type::make(FloatTop);\n+    case FloatBot:\n+      return this;\n+    default:\n+      typerr(t);\n@@ -1396,1 +1535,0 @@\n-  return this;                  \/\/ Return the float constant\n@@ -1399,0 +1537,1 @@\n+#ifdef ASSERT\n@@ -1404,0 +1543,1 @@\n+#endif \/\/ ASSERT\n@@ -1473,2 +1613,0 @@\n-\/\/------------------------------xmeet-------------------------------------------\n-\/\/ Compute the MEET of two types.  It returns a new Type object.\n@@ -1476,3 +1614,0 @@\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if (this == t) return this;  \/\/ Meeting same type-rep?\n-\n@@ -1480,28 +1615,12 @@\n-  switch (t->base()) {          \/\/ Switch on original type\n-  case AnyPtr:                  \/\/ Mixing with oops happens when javac\n-  case RawPtr:                  \/\/ reuses local variables\n-  case OopPtr:\n-  case InstPtr:\n-  case AryPtr:\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-  case NarrowOop:\n-  case NarrowKlass:\n-  case Int:\n-  case Long:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-\n-  case HalfFloatBot:\n-    return t;\n-\n-  default:                      \/\/ All else is a mistake\n-    typerr(t);\n+  switch (t->base()) {\n+    case HalfFloatTop:\n+      return this;\n+    case HalfFloatCon:\n+      assert(_f != t->is_half_float_constant()->_f, \"Equivalent instances should not appear here\");\n+      return Type::HALF_FLOAT;\n+    case HalfFloatBot:\n+      return t;\n+    default:\n+      typerr(t);\n+  }\n+}\n@@ -1509,9 +1628,12 @@\n-  case HalfFloatCon:            \/\/ Half float-constant vs Half float-constant?\n-    if (_f != t->geth()) {      \/\/ unequal constants?\n-                                \/\/ must compare bitwise as positive zero, negative zero and NaN have\n-                                \/\/ all the same representation in C++\n-      return HALF_FLOAT;        \/\/ Return generic float\n-    }                           \/\/ Equal constants\n-  case Top:\n-  case HalfFloatTop:\n-    break;                      \/\/ Return the Half float constant\n+const Type* TypeH::xjoin(const Type* t) const {\n+  \/\/ Current \"this->_base\" is FloatCon\n+  switch (t->base()) {\n+    case HalfFloatTop:\n+      return t;\n+    case HalfFloatCon:\n+      assert(_f != t->is_half_float_constant()->_f, \"Equivalent instances should not appear here\");\n+      return Type::make(HalfFloatTop);\n+    case HalfFloatBot:\n+      return this;\n+    default:\n+      typerr(t);\n@@ -1519,1 +1641,0 @@\n-  return this;                  \/\/ Return the Half float constant\n@@ -1522,0 +1643,1 @@\n+#ifdef ASSERT\n@@ -1527,0 +1649,1 @@\n+#endif \/\/ ASSERT\n@@ -1598,35 +1721,14 @@\n-\/\/------------------------------meet-------------------------------------------\n-\/\/ Compute the MEET of two types.  It returns a new Type object.\n-const Type *TypeD::xmeet( const Type *t ) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n-\n-  \/\/ Current \"this->_base\" is DoubleCon\n-  switch (t->base()) {          \/\/ Switch on original type\n-  case AnyPtr:                  \/\/ Mixing with oops happens when javac\n-  case RawPtr:                  \/\/ reuses local variables\n-  case OopPtr:\n-  case InstPtr:\n-  case AryPtr:\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-  case NarrowOop:\n-  case NarrowKlass:\n-  case Int:\n-  case Long:\n-  case HalfFloatTop:\n-  case HalfFloatCon:\n-  case HalfFloatBot:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-\n-  case DoubleBot:\n-    return t;\n-\n-  default:                      \/\/ All else is a mistake\n-    typerr(t);\n+const Type* TypeD::xmeet(const Type* t) const {\n+  \/\/ Current \"this->_base\" is FloatCon\n+  switch (t->base()) {\n+    case DoubleTop:\n+      return this;\n+    case DoubleCon:\n+      assert(jlong_cast(_d) != jlong_cast(t->getd()), \"Equivalent instances should not appear here\");\n+      return Type::DOUBLE;\n+    case DoubleBot:\n+      return t;\n+    default:\n+      typerr(t);\n+  }\n+}\n@@ -1634,6 +1736,12 @@\n-  case DoubleCon:               \/\/ Double-constant vs Double-constant?\n-    if( jlong_cast(_d) != jlong_cast(t->getd()) )       \/\/ unequal constants? (see comment in TypeF::xmeet)\n-      return DOUBLE;            \/\/ Return generic double\n-  case Top:\n-  case DoubleTop:\n-    break;\n+const Type* TypeD::xjoin(const Type* t) const {\n+  \/\/ Current \"this->_base\" is FloatCon\n+  switch (t->base()) {\n+    case DoubleTop:\n+      return t;\n+    case DoubleCon:\n+      assert(jlong_cast(_d) != jlong_cast(t->getd()), \"Equivalent instances should not appear here\");\n+      return Type::make(DoubleTop);\n+    case DoubleBot:\n+      return this;\n+    default:\n+      typerr(t);\n@@ -1641,1 +1749,0 @@\n-  return this;                  \/\/ Return the double constant\n@@ -1644,0 +1751,1 @@\n+#ifdef ASSERT\n@@ -1649,0 +1757,1 @@\n+#endif \/\/ ASSERT\n@@ -1818,1 +1927,11 @@\n-  return TypeIntHelper::int_type_xmeet(this, t);\n+  if (base() != Int || t->base() != Int) {\n+    typerr(t);\n+  }\n+  return TypeIntHelper::int_type_xmeet(this, t->is_int());\n+}\n+\n+const Type* TypeInt::xjoin(const Type* t) const {\n+  if (base() != Int || t->base() != Int) {\n+    typerr(t);\n+  }\n+  return TypeIntHelper::int_type_xjoin(this, t->is_int());\n@@ -1821,0 +1940,1 @@\n+#ifdef ASSERT\n@@ -1825,0 +1945,1 @@\n+#endif \/\/ ASSERT\n@@ -1946,1 +2067,4 @@\n-  return TypeIntHelper::int_type_xmeet(this, t);\n+  if (base() != Long || t->base() != Long) {\n+    typerr(t);\n+  }\n+  return TypeIntHelper::int_type_xmeet(this, t->is_long());\n@@ -1949,0 +2073,8 @@\n+const Type* TypeLong::xjoin(const Type* t) const {\n+  if (base() != Long || t->base() != Long) {\n+    typerr(t);\n+  }\n+  return TypeIntHelper::int_type_xjoin(this, t->is_long());\n+}\n+\n+#ifdef ASSERT\n@@ -1953,0 +2085,1 @@\n+#endif \/\/ ASSERT\n@@ -2152,20 +2285,6 @@\n-const Type *TypeTuple::xmeet( const Type *t ) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n-\n-  \/\/ Current \"this->_base\" is Tuple\n-  switch (t->base()) {          \/\/ switch on original type\n-\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return t;\n-\n-  default:                      \/\/ All else is a mistake\n-    typerr(t);\n-\n-  case Tuple: {                 \/\/ Meeting 2 signatures?\n-    const TypeTuple *x = t->is_tuple();\n-    assert( _cnt == x->_cnt, \"\" );\n-    const Type **fields = (const Type **)(Compile::current()->type_arena()->AmallocWords( _cnt*sizeof(Type*) ));\n-    for( uint i=0; i<_cnt; i++ )\n-      fields[i] = field_at(i)->xmeet( x->field_at(i) );\n-    return TypeTuple::make(_cnt,fields);\n+const Type* TypeTuple::xmeet(const Type* t) const {\n+  const TypeTuple* x = t->is_tuple();\n+  assert(_cnt == x->_cnt, \"mismatched shape: %d != %d\", _cnt, x->_cnt);\n+  const Type** fields = (const Type**)(Compile::current()->type_arena()->AmallocWords(_cnt * sizeof(Type*)));\n+  for (uint i = 0; i < _cnt; i++) {\n+    fields[i] = field_at(i)->meet_speculative(x->field_at(i));\n@@ -2173,2 +2292,9 @@\n-  case Top:\n-    break;\n+  return TypeTuple::make(_cnt, fields);\n+}\n+\n+const Type* TypeTuple::xjoin(const Type* t) const {\n+  const TypeTuple* x = t->is_tuple();\n+  assert(_cnt == x->_cnt, \"mismatched shape: %d != %d\", _cnt, x->_cnt);\n+  const Type** fields = (const Type**)(Compile::current()->type_arena()->AmallocWords(_cnt * sizeof(Type*)));\n+  for (uint i = 0; i < _cnt; i++) {\n+    fields[i] = field_at(i)->join_speculative(x->field_at(i));\n@@ -2176,1 +2302,1 @@\n-  return this;                  \/\/ Return the double constant\n+  return TypeTuple::make(_cnt, fields);\n@@ -2179,0 +2305,1 @@\n+#ifdef ASSERT\n@@ -2187,0 +2314,1 @@\n+#endif \/\/ ASSERT\n@@ -2272,6 +2400,9 @@\n-const Type *TypeAry::xmeet( const Type *t ) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n-\n-  \/\/ Current \"this->_base\" is Ary\n-  switch (t->base()) {          \/\/ switch on original type\n+const Type* TypeAry::xmeet(const Type* t) const {\n+  const TypeAry* a = t->is_ary();\n+  const Type* size = _size->meet(a->_size);\n+  if (!size->isa_int()) {\n+    assert(size == Type::TOP || size == Type::BOTTOM, \"\");\n+    return size;\n+  }\n+  return TypeAry::make(meet_elem(_elem, a->_elem), size->is_int(), _stable && a->_stable);\n+}\n@@ -2279,2 +2410,12 @@\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return t;\n+const Type* TypeAry::xjoin(const Type* t) const {\n+  const TypeAry* a = t->is_ary();\n+  const Type* size = _size->join(a->_size);\n+  if (size == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  const Type* elem = join_elem(_elem, a->_elem);\n+  if (elem->empty() || (elem->make_ptr() != nullptr && elem->make_ptr()->ptr() == TypePtr::Null)) {\n+    return Type::TOP;\n+  }\n+  return TypeAry::make(elem, size->is_int(), _stable || a->_stable);\n+}\n@@ -2282,2 +2423,18 @@\n-  default:                      \/\/ All else is a mistake\n-    typerr(t);\n+\/\/ These help us avoid implementing meet and join of unrelated type in Type::xmeet\/xjoin. This is\n+\/\/ useful to narrow the scope of this uncommon interaction between unrelated types.\n+const Type* TypeAry::meet_elem(const Type* elem_type1, const Type* elem_type2) {\n+  if (elem_type1 == Type::TOP) {\n+    return elem_type2;\n+  } else if (elem_type2 == Type::TOP) {\n+    return elem_type1;\n+  }\n+  if (elem_type1 == Type::BOTTOM || elem_type2 == Type::BOTTOM) {\n+    return Type::BOTTOM;\n+  }\n+  BasicType bt1 = elem_type1->basic_type();\n+  BasicType bt2 = elem_type2->basic_type();\n+  if (bt1 == bt2 || (!is_java_primitive(bt1) && !is_java_primitive(bt2))) {\n+    return elem_type1->meet_speculative(elem_type2);\n+  }\n+  return Type::BOTTOM;\n+}\n@@ -2285,10 +2442,5 @@\n-  case Array: {                 \/\/ Meeting 2 arrays?\n-    const TypeAry* a = t->is_ary();\n-    const Type* size = _size->xmeet(a->_size);\n-    const TypeInt* isize = size->isa_int();\n-    if (isize == nullptr) {\n-      assert(size == Type::TOP || size == Type::BOTTOM, \"\");\n-      return size;\n-    }\n-    return TypeAry::make(_elem->meet_speculative(a->_elem),\n-                         isize, _stable && a->_stable);\n+const Type* TypeAry::join_elem(const Type* elem_type1, const Type* elem_type2) {\n+  if (elem_type1 == Type::BOTTOM) {\n+    return elem_type2;\n+  } else if (elem_type2 == Type::BOTTOM) {\n+    return elem_type1;\n@@ -2296,2 +2448,2 @@\n-  case Top:\n-    break;\n+  if (elem_type1 == Type::TOP || elem_type2 == Type::TOP) {\n+    return Type::TOP;\n@@ -2299,1 +2451,6 @@\n-  return this;                  \/\/ Return the double constant\n+  BasicType bt1 = elem_type1->basic_type();\n+  BasicType bt2 = elem_type2->basic_type();\n+  if (bt1 == bt2 || (is_reference_type(bt1, true) && is_reference_type(bt2, true))) {\n+    return elem_type1->join_speculative(elem_type2);\n+  }\n+  return Type::TOP;\n@@ -2302,0 +2459,1 @@\n+#ifdef ASSERT\n@@ -2309,0 +2467,1 @@\n+#endif \/\/ ASSERT\n@@ -2453,36 +2612,1 @@\n-\/\/------------------------------meet-------------------------------------------\n-\/\/ Compute the MEET of two types. Since each TypeVect is the only instance of\n-\/\/ its species, meeting often returns itself\n-const Type* TypeVect::xmeet(const Type* t) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if (this == t) {\n-    return this;\n-  }\n-\n-  \/\/ Current \"this->_base\" is Vector\n-  switch (t->base()) {          \/\/ switch on original type\n-\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return t;\n-\n-  default:                      \/\/ All else is a mistake\n-    typerr(t);\n-  case VectorMask:\n-  case VectorA:\n-  case VectorS:\n-  case VectorD:\n-  case VectorX:\n-  case VectorY:\n-  case VectorZ: {                \/\/ Meeting 2 vectors?\n-    const TypeVect* v = t->is_vect();\n-    assert(base() == v->base(), \"\");\n-    assert(length() == v->length(), \"\");\n-    assert(element_basic_type() == v->element_basic_type(), \"\");\n-    return this;\n-  }\n-  case Top:\n-    break;\n-  }\n-  return this;\n-}\n-\n+#ifdef ASSERT\n@@ -2494,0 +2618,1 @@\n+#endif \/\/ ASSERT\n@@ -2611,3 +2736,4 @@\n-const Type *TypePtr::xmeet_helper(const Type *t) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n+const Type* TypePtr::xmeet_helper(const Type* t) const {\n+  if (base() != AnyPtr) {\n+    typerr(t);\n+  }\n@@ -2615,19 +2741,21 @@\n-  \/\/ Current \"this->_base\" is AnyPtr\n-  switch (t->base()) {          \/\/ switch on original type\n-  case Int:                     \/\/ Mixing ints & oops happens when javac\n-  case Long:                    \/\/ reuses local variables\n-  case HalfFloatTop:\n-  case HalfFloatCon:\n-  case HalfFloatBot:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case NarrowOop:\n-  case NarrowKlass:\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-  case Top:\n-    return this;\n+  switch (t->base()) {\n+    case AnyPtr: {\n+      const TypePtr* tp = t->is_ptr();\n+      const TypePtr* speculative = xmeet_speculative(tp);\n+      int depth = meet_inline_depth(tp->inline_depth());\n+      return make(AnyPtr, meet_ptr(tp->ptr()), meet_offset(tp->offset()), speculative, depth);\n+    }\n+    case RawPtr:\n+    case OopPtr:\n+    case InstPtr:\n+    case AryPtr:\n+    case MetadataPtr:\n+    case KlassPtr:\n+    case InstKlassPtr:\n+    case AryKlassPtr:\n+      \/\/ Call in reverse direction\n+      return t->is_ptr()->xmeet(this);\n+    default:\n+      typerr(t);\n+  }\n+}\n@@ -2635,5 +2763,4 @@\n-  case AnyPtr: {                \/\/ Meeting to AnyPtrs\n-    const TypePtr *tp = t->is_ptr();\n-    const TypePtr* speculative = xmeet_speculative(tp);\n-    int depth = meet_inline_depth(tp->inline_depth());\n-    return make(AnyPtr, meet_ptr(tp->ptr()), meet_offset(tp->offset()), speculative, depth);\n+const Type* TypePtr::xjoin(const Type* t) const {\n+  const Type* res = xjoin_helper(t);\n+  if (res->isa_ptr() == nullptr) {\n+    return res;\n@@ -2641,10 +2768,19 @@\n-  case RawPtr:                  \/\/ For these, flip the call around to cut down\n-  case OopPtr:\n-  case InstPtr:                 \/\/ on the cases I have to handle.\n-  case AryPtr:\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-    return t->xmeet(this);      \/\/ Call in reverse direction\n-  default:                      \/\/ All else is a mistake\n+\n+  const TypePtr* res_ptr = res->is_ptr();\n+  if (res_ptr->speculative() != nullptr) {\n+    \/\/ type->speculative() is null means that speculation is no better\n+    \/\/ than type, i.e. type->speculative() == type. So there are 2\n+    \/\/ ways to represent the fact that we have no useful speculative\n+    \/\/ data and we should use a single one to be able to test for\n+    \/\/ equality between types. Check whether type->speculative() ==\n+    \/\/ type and set speculative to null if it is the case.\n+    if (res_ptr->remove_speculative() == res_ptr->speculative()) {\n+      return res_ptr->remove_speculative();\n+    }\n+  }\n+\n+  return res;\n+}\n+\n+const Type* TypePtr::xjoin_helper(const Type* t) const {\n+  if (base() != AnyPtr) {\n@@ -2652,0 +2788,1 @@\n+  }\n@@ -2653,0 +2790,19 @@\n+  switch (t->base()) {\n+    case AnyPtr: {\n+      const TypePtr* tp = t->is_ptr();\n+      const TypePtr* speculative = xjoin_speculative(tp);\n+      int depth = join_inline_depth(tp->inline_depth());\n+      return make(AnyPtr, join_ptr(tp->ptr()), join_offset(tp->offset()), speculative, depth);\n+    }\n+    case RawPtr:\n+    case OopPtr:\n+    case InstPtr:\n+    case AryPtr:\n+    case MetadataPtr:\n+    case KlassPtr:\n+    case InstKlassPtr:\n+    case AryKlassPtr:\n+      \/\/ Call in reverse direction\n+      return t->is_ptr()->xjoin(this);\n+    default:\n+      typerr(t);\n@@ -2654,1 +2810,0 @@\n-  return this;\n@@ -2667,0 +2822,13 @@\n+int TypePtr::join_offset(int o) const {\n+  if (_offset == OffsetBot) {\n+    return o;\n+  } else if (o == OffsetBot) {\n+    return _offset;\n+  }\n+  if (_offset != o) {\n+    return OffsetTop;\n+  } else {\n+    return _offset;\n+  }\n+}\n+\n@@ -2679,0 +2847,2 @@\n+\n+#ifdef ASSERT\n@@ -2682,0 +2852,1 @@\n+#endif \/\/ ASSERT\n@@ -2760,0 +2931,1 @@\n+#ifdef ASSERT\n@@ -2769,0 +2941,1 @@\n+#endif \/\/ ASSERT\n@@ -2803,0 +2976,28 @@\n+const TypePtr* TypePtr::xjoin_speculative(const TypePtr* other) const {\n+  bool this_has_spec = (_speculative != nullptr);\n+  bool other_has_spec = (other->speculative() != nullptr);\n+\n+  if (!this_has_spec && !other_has_spec) {\n+    return nullptr;\n+  }\n+\n+  \/\/ If we are at a point where control flow meets and one branch has\n+  \/\/ a speculative type and the other has not, we join the speculative\n+  \/\/ type of one branch with the actual type of the other. If the\n+  \/\/ actual type is exact and the speculative is as well, then the\n+  \/\/ result is a speculative type which is exact and we can continue\n+  \/\/ speculation further.\n+  const TypePtr* this_spec = _speculative;\n+  const TypePtr* other_spec = other->speculative();\n+\n+  if (!this_has_spec) {\n+    this_spec = this;\n+  }\n+\n+  if (!other_has_spec) {\n+    other_spec = other;\n+  }\n+\n+  return this_spec->join(other_spec)->is_ptr();\n+}\n+\n@@ -2819,0 +3020,4 @@\n+int TypePtr::join_inline_depth(int depth) const {\n+  return MIN2(inline_depth(), depth);\n+}\n+\n@@ -3062,4 +3267,1 @@\n-const Type *TypeRawPtr::xmeet( const Type *t ) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n-\n+const Type* TypeRawPtr::xmeet(const Type* t) const {\n@@ -3067,6 +3269,2 @@\n-  switch( t->base() ) {         \/\/ switch on original type\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return t;\n-  case Top:\n-    return this;\n-  case AnyPtr:                  \/\/ Meeting to AnyPtrs\n+  switch (t->base()) {\n+  case AnyPtr:\n@@ -3074,1 +3272,1 @@\n-  case RawPtr: {                \/\/ might be top, bot, any\/not or constant\n+  case RawPtr: {\n@@ -3077,1 +3275,2 @@\n-    if( ptr == Constant ) {     \/\/ Cannot be equal constants, so...\n+    if( ptr == Constant ) {\n+      \/\/ Same constant cases have been handled in Type::xmeet(const Type*, const Type*)\n@@ -3085,8 +3284,0 @@\n-  case OopPtr:\n-  case InstPtr:\n-  case AryPtr:\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-    return TypePtr::BOTTOM;     \/\/ Oop meet raw is not well defined\n@@ -3114,0 +3305,45 @@\n+const Type* TypeRawPtr::xjoin(const Type* t) const {\n+  \/\/ Current \"this->_base\" is RawPtr\n+  switch (t->base()) {\n+    case AnyPtr: {\n+      const TypePtr* tp = t->is_ptr();\n+      PTR ptr = join_ptr(tp->ptr());\n+      switch (tp->ptr()) {\n+        case TopPTR:\n+        case Null:\n+          return TypePtr::make(AnyPtr, ptr, tp->offset(), tp->speculative(), tp->inline_depth());\n+        case NotNull:\n+        case BotPTR:\n+          return this->ptr() == Constant ? this : make(ptr);\n+        default:\n+          typerr(t);\n+      }\n+    }\n+\n+    case RawPtr: {\n+      const TypeRawPtr* tp = t->is_rawptr();\n+      enum PTR ptr = join_ptr(tp->ptr());\n+      \/\/ this->ptr() can only be Constant, NotNull, BotPTR\n+      if (ptr != Constant) {\n+        \/\/ Neither is a constant\n+        return make(ptr);\n+      }\n+\n+      \/\/ At least 1 is a constant\n+      if (this->ptr() == Constant && tp->ptr() == Constant) {\n+        assert(this->_bits != tp->_bits, \"should have been handled in Type::xjoin\");\n+        return TypePtr::make(AnyPtr, TopPTR, 0);\n+      } else if (this->ptr() == Constant) {\n+        return this;\n+      } else {\n+        assert(tp->ptr() == Constant, \"\");\n+        return tp;\n+      }\n+    }\n+\n+    default:\n+      typerr(t);\n+  }\n+}\n+\n+#ifdef ASSERT\n@@ -3119,0 +3355,1 @@\n+#endif \/\/ ASSERT\n@@ -3255,0 +3492,1 @@\n+#ifdef ASSERT\n@@ -3258,0 +3496,1 @@\n+#endif \/\/ ASSERT\n@@ -3414,6 +3653,0 @@\n-\/\/ Can't be implemented because there's no way to know if the type is above or below the center line.\n-const Type* TypeInterfaces::xmeet(const Type* t) const {\n-  ShouldNotReachHere();\n-  return Type::xmeet(t);\n-}\n-\n@@ -3558,26 +3791,2 @@\n-const Type *TypeOopPtr::xmeet_helper(const Type *t) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n-\n-  \/\/ Current \"this->_base\" is OopPtr\n-  switch (t->base()) {          \/\/ switch on original type\n-\n-  case Int:                     \/\/ Mixing ints & oops happens when javac\n-  case Long:                    \/\/ reuses local variables\n-  case HalfFloatTop:\n-  case HalfFloatCon:\n-  case HalfFloatBot:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case NarrowOop:\n-  case NarrowKlass:\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-  case Top:\n-    return this;\n-\n-  default:                      \/\/ All else is a mistake\n+const Type* TypeOopPtr::xmeet_helper(const Type *t) const {\n+  if (base() != OopPtr) {\n@@ -3585,8 +3794,2 @@\n-\n-  case RawPtr:\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-    return TypePtr::BOTTOM;     \/\/ Oop meet raw is not well defined\n-\n+  }\n+  switch (t->base()) {          \/\/ switch on original type\n@@ -3626,1 +3829,1 @@\n-    return t->xmeet(this);      \/\/ Call in reverse direction\n+    return t->is_oopptr()->xmeet_helper(this);      \/\/ Call in reverse direction\n@@ -3628,2 +3831,3 @@\n-  } \/\/ End of switch\n-  return this;                  \/\/ Return the double constant\n+  default:\n+    typerr(t);\n+  }\n@@ -3632,0 +3836,42 @@\n+const Type* TypeOopPtr::xjoin_helper(const Type* t) const {\n+  if (base() != OopPtr) {\n+    typerr(t);\n+  }\n+\n+  switch (t->base()) {\n+    case AnyPtr: {\n+      const TypePtr* tp = t->is_ptr();\n+      int offset = join_offset(tp->offset());\n+      PTR ptr = join_ptr(tp->ptr());\n+      const TypePtr* speculative = xjoin_speculative(tp);\n+      int depth = join_inline_depth(tp->inline_depth());\n+      switch (tp->ptr()) {\n+        case Null:\n+        case TopPTR:\n+          return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);\n+        case BotPTR:\n+        case NotNull: {\n+          int instance_id = join_instance_id(InstanceBot);\n+          return make(ptr, offset, instance_id, speculative, depth);\n+        }\n+        default:\n+          typerr(t);\n+      }\n+    }\n+\n+    case OopPtr: {\n+      const TypeOopPtr* tp = t->is_oopptr();\n+      int instance_id = join_instance_id(tp->instance_id());\n+      const TypePtr* speculative = xjoin_speculative(tp);\n+      int depth = join_inline_depth(tp->inline_depth());\n+      return make(join_ptr(tp->ptr()), join_offset(tp->offset()), instance_id, speculative, depth);\n+    }\n+\n+    case InstPtr:\n+    case AryPtr:\n+      return t->is_oopptr()->xjoin_helper(this);\n+\n+    default:\n+      typerr(t);\n+  }\n+}\n@@ -3633,0 +3879,1 @@\n+#ifdef ASSERT\n@@ -3640,0 +3887,1 @@\n+#endif \/\/ ASSERT\n@@ -3893,0 +4141,13 @@\n+int TypeOopPtr::join_instance_id(int uid) const {\n+  if (_instance_id == InstanceBot) {\n+    return uid;\n+  } else if (uid == InstanceBot) {\n+    return _instance_id;\n+  }\n+  if (_instance_id != uid) {\n+    return InstanceTop;\n+  } else {\n+    return _instance_id;\n+  }\n+}\n+\n@@ -3900,1 +4161,0 @@\n-\n@@ -3912,0 +4172,7 @@\n+const TypeInterfaces* TypeOopPtr::join_interfaces(const TypeOopPtr* other) const {\n+  if (above_centerline(ptr()) || above_centerline(other->ptr())) {\n+    typerr(other);\n+  }\n+  return interfaces()->union_with(other->interfaces());\n+}\n+\n@@ -4125,27 +4392,5 @@\n-\/\/------------------------------meet-------------------------------------------\n-\/\/ Compute the MEET of two types.  It returns a new Type object.\n-const Type *TypeInstPtr::xmeet_helper(const Type *t) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n-\n-  \/\/ Current \"this->_base\" is Pointer\n-  switch (t->base()) {          \/\/ switch on original type\n-\n-  case Int:                     \/\/ Mixing ints & oops happens when javac\n-  case Long:                    \/\/ reuses local variables\n-  case HalfFloatTop:\n-  case HalfFloatCon:\n-  case HalfFloatBot:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case NarrowOop:\n-  case NarrowKlass:\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-  case Top:\n-    return this;\n-\n+\/\/------------------------------meet-------------------------------------------\n+\/\/ Compute the MEET of two types.  It returns a new Type object.\n+const Type* TypeInstPtr::xmeet_helper(const Type* t) const {\n+  \/\/ Current \"this->_base\" is Pointer\n+  switch (t->base()) {          \/\/ switch on original type\n@@ -4155,6 +4400,0 @@\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-  case RawPtr: return TypePtr::BOTTOM;\n-\n@@ -4296,1 +4535,0 @@\n-  return this;                  \/\/ Return the double constant\n@@ -4404,0 +4642,132 @@\n+const Type* TypeInstPtr::xjoin_helper(const Type* t) const {\n+  if (base() != InstPtr) {\n+    typerr(t);\n+  }\n+\n+  switch (t->base()) {\n+    case AnyPtr: {\n+      const TypePtr* tp = t->is_ptr();\n+      PTR ptr = join_ptr(tp->ptr());\n+      int offset = join_offset(tp->offset());\n+      const TypePtr* speculative = xjoin_speculative(tp);\n+      int depth = join_inline_depth(tp->inline_depth());\n+      switch (tp->ptr()) {\n+        case TopPTR:\n+        case Null:\n+          return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);\n+        case NotNull:\n+        case BotPTR: {\n+          int instance_id = join_instance_id(InstanceBot);\n+          return make(ptr, klass(), interfaces(), klass_is_exact(), const_oop(), offset, instance_id, speculative, depth);\n+        }\n+        default:\n+          typerr(t);\n+      }\n+    }\n+\n+    case OopPtr: {\n+      const TypeOopPtr* tp = t->is_oopptr();\n+      PTR ptr = join_ptr(tp->ptr());\n+      int offset = join_offset(tp->offset());\n+      int instance_id = join_instance_id(tp->instance_id());\n+      const TypePtr* speculative = xjoin_speculative(tp);\n+      int depth = join_inline_depth(tp->inline_depth());\n+      switch (tp->ptr()) {\n+        case NotNull:\n+        case BotPTR:\n+          return make(ptr, klass(), interfaces(), klass_is_exact(), const_oop(), offset, instance_id, speculative, depth);\n+        default:\n+          typerr(t);\n+      }\n+    }\n+\n+    case InstPtr: {\n+      const TypeInstPtr* tp = t->is_instptr();\n+      PTR ptr = join_ptr(tp->ptr());\n+      int offset = join_offset(tp->offset());\n+      int instance_id = join_instance_id(tp->instance_id());\n+      const TypePtr* speculative = xjoin_speculative(tp);\n+      int depth = join_inline_depth(tp->inline_depth());\n+      const TypeInterfaces* interfaces = join_interfaces(tp);\n+\n+      \/\/ Join 2 constants\n+      if (const_oop() != nullptr && tp->const_oop() != nullptr) {\n+        if (const_oop() != tp->const_oop()) {\n+          return TypePtr::make(AnyPtr, TopPTR, offset, speculative, depth);\n+        } else {\n+          return make(Constant, klass(), interfaces, true, const_oop(), offset, instance_id, speculative, depth);\n+        }\n+      }\n+\n+      \/\/ From here, at least one of the operand is not constant\n+      ciObject* oop = const_oop() != nullptr ? const_oop() : tp->const_oop();\n+      \/\/ For TypeInstPtr, klass() must return a non-null ciInstanceKlass\n+      ciInstanceKlass* klass1 = instance_klass();\n+      ciInstanceKlass* klass2 = tp->instance_klass();\n+      bool xk1 = klass_is_exact();\n+      bool xk2 = tp->klass_is_exact();\n+\n+      if (xk1 && xk2) {\n+        if (exact_klass() == tp->exact_klass()) {\n+          return make(ptr, klass1, interfaces, true, oop, offset, instance_id, speculative, depth);\n+        } else {\n+          return TypePtr::make(AnyPtr, ptr == BotPTR ? Null : TopPTR, offset, speculative, depth);\n+        }\n+      } else if (xk1) {\n+        assert(klass1->is_loaded(), \"pointer to an exact type must be loaded\");\n+        \/\/ We can have a TypeInstPtr of an exact interface. In that case, klass() is Object and\n+        \/\/ interfaces() will be not empty. Very confusing.\n+        if ((klass1->is_java_lang_Object() && klass2->is_java_lang_Object() && this->interfaces() == interfaces) ||\n+            (klass2->is_loaded() && klass1->is_subtype_of(klass2) && interfaces->eq(klass1))) {\n+          \/\/ Supertypes of a loaded class should also be loaded\n+          return make(ptr, klass1, interfaces, true, oop, offset, instance_id, speculative, depth);\n+        } else {\n+          return TypePtr::make(AnyPtr, ptr == BotPTR ? Null : TopPTR, offset, speculative, depth);\n+        }\n+      } else if (xk2) {\n+        assert(klass2->is_loaded(), \"pointer to an exact type must be loaded\");\n+        if ((klass2->is_java_lang_Object() && klass1->is_java_lang_Object() && tp->interfaces() == interfaces) ||\n+            (klass1->is_loaded() && klass2->is_subtype_of(klass1) && interfaces->eq(klass2))) {\n+          return make(ptr, klass2, interfaces, true, oop, offset, instance_id, speculative, depth);\n+        } else {\n+          return TypePtr::make(AnyPtr, ptr == BotPTR ? Null : TopPTR, offset, speculative, depth);\n+        }\n+      }\n+\n+      if (!klass1->is_loaded() || !klass2->is_loaded()) {\n+        if (klass1->is_java_lang_Object()) {\n+          \/\/ Everything subtypes object, so the join would return the other type regardless\n+          return make(ptr, klass2, interfaces, false, oop, offset, instance_id, speculative, depth);\n+        } else if (klass2->is_java_lang_Object()) {\n+          return make(ptr, klass1, interfaces, false, oop, offset, instance_id, speculative, depth);\n+        } else if (klass1 == klass2) {\n+          return make(ptr, klass1, interfaces, false, oop, offset, instance_id, speculative, depth);\n+        } else {\n+          \/\/ The current behavior is saying that no non-null instance satisfy this join, this seems\n+          \/\/ only correct if we recompile when the unloaded classes get loaded\n+          return TypePtr::make(AnyPtr, ptr == BotPTR ? Null : TopPTR, offset, speculative, depth);\n+        }\n+      }\n+\n+      \/\/ There is no opposite of LCA, there exists a non-null object o subtyping both A and B iff A\n+      \/\/ is a subtype of B or B is a subtype of A\n+      assert(oop == nullptr, \"const oop should have exact klass\");\n+      ciKlass* res_klass;\n+      if (klass1->is_subtype_of(klass2)) {\n+        res_klass = klass1;\n+      } else if (klass2->is_subtype_of(klass1)) {\n+        res_klass = klass2;\n+      } else {\n+        return TypePtr::make(AnyPtr, ptr == BotPTR ? Null : TopPTR, offset, speculative, depth);\n+      }\n+\n+      return make(ptr, res_klass, interfaces, false, nullptr, offset, instance_id, speculative, depth);\n+    }\n+\n+    case AryPtr:\n+      return t->is_oopptr()->xjoin_helper(this);\n+    default:\n+      typerr(t);\n+  }\n+}\n+\n@@ -4415,1 +4785,1 @@\n-\n+#ifdef ASSERT\n@@ -4422,0 +4792,1 @@\n+#endif \/\/ ASSERT\n@@ -4810,2 +5181,3 @@\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n+  if (base() != AryPtr) {\n+    typerr(t);\n+  }\n@@ -4814,20 +5186,0 @@\n-\n-  \/\/ Mixing ints & oops happens when javac reuses local variables\n-  case Int:\n-  case Long:\n-  case HalfFloatTop:\n-  case HalfFloatCon:\n-  case HalfFloatBot:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case NarrowOop:\n-  case NarrowKlass:\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-  case Top:\n-    return this;\n-\n@@ -4856,1 +5208,2 @@\n-    default: ShouldNotReachHere();\n+    default:\n+      typerr(t);\n@@ -4885,6 +5238,0 @@\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-  case RawPtr: return TypePtr::BOTTOM;\n-\n@@ -4987,1 +5334,0 @@\n-  return this;                  \/\/ Lint noise\n@@ -5084,0 +5430,132 @@\n+const Type* TypeAryPtr::xjoin_helper(const Type* t) const {\n+  if (base() != AryPtr) {\n+    typerr(t);\n+  }\n+\n+  switch (t->base()) {\n+    case AnyPtr: {\n+      const TypePtr* tp = t->is_ptr();\n+      PTR ptr = join_ptr(tp->ptr());\n+      int offset = join_offset(tp->offset());\n+      const TypePtr* speculative = xjoin_speculative(tp);\n+      int depth = join_inline_depth(tp->inline_depth());\n+      switch (tp->ptr()) {\n+        case TopPTR:\n+        case Null:\n+          return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);\n+        case NotNull:\n+        case BotPTR: {\n+          int instance_id = join_instance_id(InstanceBot);\n+          return make(ptr, const_oop(), _ary, klass(), klass_is_exact(), offset, instance_id, speculative, depth, is_autobox_cache());\n+        }\n+        default:\n+          typerr(t);\n+      }\n+    }\n+\n+    case OopPtr: {\n+      const TypeOopPtr* tp = t->is_oopptr();\n+      PTR ptr = join_ptr(tp->ptr());\n+      int offset = join_offset(tp->offset());\n+      int instance_id = join_instance_id(tp->instance_id());\n+      const TypePtr* speculative = xjoin_speculative(tp);\n+      int depth = join_inline_depth(tp->inline_depth());\n+      switch (tp->ptr()) {\n+        case NotNull:\n+        case BotPTR:\n+          return make(ptr, const_oop(), _ary, klass(), klass_is_exact(), offset, instance_id, speculative, depth, is_autobox_cache());\n+        default:\n+          typerr(t);\n+      }\n+    }\n+\n+    case InstPtr: {\n+      const TypeInstPtr* tp = t->is_instptr();\n+      PTR ptr = join_ptr(tp->ptr());\n+      int offset = join_offset(tp->offset());\n+      int instance_id = join_instance_id(tp->instance_id());\n+      const TypePtr* speculative = xjoin_speculative(tp);\n+      int depth = join_inline_depth(tp->inline_depth());\n+      if (tp->klass()->is_java_lang_Object() && !tp->klass_is_exact() && _array_interfaces->contains(tp->interfaces())) {\n+        return make(ptr, const_oop(), _ary, klass(), klass_is_exact(), offset, instance_id, speculative, depth, is_autobox_cache());\n+      } else {\n+        return TypePtr::make(AnyPtr, ptr == BotPTR ? Null : TopPTR, offset, speculative, depth);\n+      }\n+    }\n+\n+    case AryPtr: {\n+      const TypeAryPtr* tp = t->is_aryptr();\n+      PTR ptr = join_ptr(tp->ptr());\n+      int offset = join_offset(tp->offset());\n+      int instance_id = join_instance_id(tp->instance_id());\n+      const TypePtr* speculative = xjoin_speculative(tp);\n+      int depth = join_inline_depth(tp->inline_depth());\n+\n+      \/\/ Join of 2 constants\n+      if (const_oop() != nullptr && tp->const_oop() != nullptr) {\n+        if (const_oop() == tp->const_oop()) {\n+          return make(ptr, const_oop(), _ary, klass(), true, offset, instance_id, speculative, depth);\n+        } else {\n+          return TypePtr::make(AnyPtr, TopPTR, offset, speculative, depth);\n+        }\n+      }\n+\n+      const Type* elem1 = elem();\n+      const Type* elem2 = tp->elem();\n+      const Type* ary_elem = TypeAry::join_elem(elem1, elem2);\n+      if (ary_elem->empty() || (ary_elem->make_ptr() != nullptr && ary_elem->make_ptr()->ptr() == Null)) {\n+        return TypePtr::make(AnyPtr, ptr == BotPTR ? Null : TopPTR, offset, speculative, depth);\n+      }\n+\n+      const TypeInt* ary_size = _ary->_size->join(tp->_ary->_size)->isa_int();\n+      if (ary_size == nullptr) {\n+        return TypePtr::make(AnyPtr, ptr == BotPTR ? Null : TopPTR, offset, speculative, depth);\n+      }\n+\n+      ciObject* oop = const_oop() != nullptr ? const_oop() : tp->const_oop();\n+      const TypeAry* ary = TypeAry::make(ary_elem, ary_size, _ary->_stable || tp->_ary->_stable);\n+      bool xk = this->klass_is_exact() || tp->klass_is_exact();\n+      bool autobox_cache = this->is_autobox_cache() || tp->is_autobox_cache();\n+\n+      if (elem1 == Type::BOTTOM || elem2 == Type::BOTTOM) {\n+        return make(ptr, oop, ary, elem1 == Type::BOTTOM ? tp->klass() : klass(), xk, offset, instance_id, speculative, depth, autobox_cache);\n+      } else if (is_java_primitive(elem1->basic_type()) || is_java_primitive(elem2->basic_type())) {\n+        \/\/ One of the operand is a primitive array\n+        if (elem()->isa_int() && tp->elem()->isa_int()) {\n+          \/\/ Maybe we are joining an int[] and a char[]\n+          if (klass() == tp->klass()) {\n+            return make(ptr, oop, ary, klass(), xk, offset, instance_id, speculative, depth, autobox_cache);\n+          } else {\n+            return TypePtr::make(AnyPtr, ptr == BotPTR ? Null : TopPTR, offset, speculative, depth);\n+          }\n+        }\n+\n+        return make(ptr, oop, ary, nullptr, xk, offset, instance_id, speculative, depth, autobox_cache);\n+      }\n+\n+      const TypeKlassPtr* elem1_klass = elem1->make_ptr()->is_oopptr()->as_klass_type(false);\n+      const TypeKlassPtr* elem2_klass = elem2->make_ptr()->is_oopptr()->as_klass_type(false);\n+      bool xk1 = klass_is_exact();\n+      bool xk2 = tp->klass_is_exact();\n+\n+      if (xk1 && xk2) {\n+        if (elem1_klass != elem2_klass) {\n+          return TypePtr::make(AnyPtr, ptr == BotPTR ? Null : TopPTR, offset, speculative, depth);\n+        }\n+      } else if (xk1) {\n+        if (!elem1_klass->higher_equal(elem2_klass)) {\n+          return TypePtr::make(AnyPtr, ptr == BotPTR ? Null : TopPTR, offset, speculative, depth);\n+        }\n+      } else if (xk2) {\n+        if (!elem2_klass->higher_equal(elem1_klass)) {\n+          return TypePtr::make(AnyPtr, ptr == BotPTR ? Null : TopPTR, offset, speculative, depth);\n+        }\n+      }\n+\n+      return make(ptr, oop, ary, nullptr, xk, offset, instance_id, speculative, depth, autobox_cache);\n+    }\n+\n+    default:\n+      typerr(t);\n+  }\n+}\n@@ -5085,0 +5563,1 @@\n+#ifdef ASSERT\n@@ -5090,0 +5569,1 @@\n+#endif \/\/ ASSERT\n@@ -5211,0 +5691,1 @@\n+#ifdef ASSERT\n@@ -5215,0 +5696,1 @@\n+#endif \/\/ ASSERT\n@@ -5236,53 +5718,0 @@\n-\/\/------------------------------xmeet------------------------------------------\n-\/\/ Compute the MEET of two types.  It returns a new Type object.\n-const Type *TypeNarrowPtr::xmeet( const Type *t ) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n-\n-  if (t->base() == base()) {\n-    const Type* result = _ptrtype->xmeet(t->make_ptr());\n-    if (result->isa_ptr()) {\n-      return make_hash_same_narrowptr(result->is_ptr());\n-    }\n-    return result;\n-  }\n-\n-  \/\/ Current \"this->_base\" is NarrowKlass or NarrowOop\n-  switch (t->base()) {          \/\/ switch on original type\n-\n-  case Int:                     \/\/ Mixing ints & oops happens when javac\n-  case Long:                    \/\/ reuses local variables\n-  case HalfFloatTop:\n-  case HalfFloatCon:\n-  case HalfFloatBot:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case AnyPtr:\n-  case RawPtr:\n-  case OopPtr:\n-  case InstPtr:\n-  case AryPtr:\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-  case NarrowOop:\n-  case NarrowKlass:\n-\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-  case Top:\n-    return this;\n-\n-  default:                      \/\/ All else is a mistake\n-    typerr(t);\n-\n-  } \/\/ End of switch\n-\n-  return this;\n-}\n-\n@@ -5405,2 +5834,3 @@\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n+  if (base() != MetadataPtr) {\n+    typerr(t);\n+  }\n@@ -5410,19 +5840,0 @@\n-\n-  case Int:                     \/\/ Mixing ints & oops happens when javac\n-  case Long:                    \/\/ reuses local variables\n-  case HalfFloatTop:\n-  case HalfFloatCon:\n-  case HalfFloatBot:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case NarrowOop:\n-  case NarrowKlass:\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-  case Top:\n-    return this;\n-\n@@ -5452,9 +5863,0 @@\n-  case RawPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-  case OopPtr:\n-  case InstPtr:\n-  case AryPtr:\n-    return TypePtr::BOTTOM;     \/\/ Oop meet raw is not well defined\n-\n@@ -5481,1 +5883,0 @@\n-  return this;                  \/\/ Return the double constant\n@@ -5484,0 +5885,42 @@\n+const Type* TypeMetadataPtr::xjoin(const Type* t) const {\n+  if (base() != MetadataPtr) {\n+    typerr(t);\n+  }\n+\n+  switch (t->base()) {\n+    case AnyPtr: {\n+      const TypePtr* tp = t->is_ptr();\n+      PTR ptr = join_ptr(tp->ptr());\n+      int offset = join_offset(tp->offset());\n+      switch (tp->ptr()) {\n+        case TopPTR:\n+        case Null:\n+          return TypePtr::make(AnyPtr, ptr, offset, tp->speculative(), tp->inline_depth());\n+        case NotNull:\n+        case BotPTR:\n+          return make(ptr, _metadata, offset);\n+        default:\n+          typerr(t);\n+      }\n+    }\n+\n+    case MetadataPtr: {\n+      const TypeMetadataPtr* tp = t->is_metadataptr();\n+      PTR ptr = join_ptr(tp->ptr());\n+      int offset = join_offset(tp->offset());\n+      ciMetadata* metadata = this->metadata();\n+      if (tp->metadata() != nullptr) {\n+        if (metadata == nullptr) {\n+          metadata = tp->metadata();\n+        } else {\n+          return TypePtr::make(AnyPtr, TopPTR, offset);\n+        }\n+      }\n+\n+      return make(ptr, metadata, offset);\n+    }\n+\n+    default:\n+      typerr(t);\n+  }\n+}\n@@ -5485,0 +5928,1 @@\n+#ifdef ASSERT\n@@ -5490,0 +5934,1 @@\n+#endif \/\/ ASSERT\n@@ -5627,0 +6072,7 @@\n+const TypeInterfaces* TypeKlassPtr::join_interfaces(const TypeKlassPtr* other) const {\n+  if (above_centerline(ptr()) || above_centerline(other->ptr())) {\n+    typerr(other);\n+  }\n+  return interfaces()->union_with(other->interfaces());\n+}\n+\n@@ -5779,3 +6231,4 @@\n-const Type    *TypeInstKlassPtr::xmeet( const Type *t ) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n+const Type* TypeInstKlassPtr::xmeet(const Type* t) const {\n+  if (base() != InstKlassPtr) {\n+    typerr(t);\n+  }\n@@ -5785,19 +6238,0 @@\n-\n-  case Int:                     \/\/ Mixing ints & oops happens when javac\n-  case Long:                    \/\/ reuses local variables\n-  case HalfFloatTop:\n-  case HalfFloatCon:\n-  case HalfFloatBot:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case NarrowOop:\n-  case NarrowKlass:\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-  case Top:\n-    return this;\n-\n@@ -5826,7 +6260,0 @@\n-  case RawPtr:\n-  case MetadataPtr:\n-  case OopPtr:\n-  case AryPtr:                  \/\/ Meet with AryPtr\n-  case InstPtr:                 \/\/ Meet with InstPtr\n-    return TypePtr::BOTTOM;\n-\n@@ -5924,0 +6351,80 @@\n+const Type* TypeInstKlassPtr::xjoin(const Type* t) const {\n+  if (base() != InstKlassPtr) {\n+    typerr(t);\n+  }\n+\n+  switch (t->base()) {\n+    case AnyPtr: {\n+      const TypePtr* tp = t->is_ptr();\n+      PTR ptr = join_ptr(tp->ptr());\n+      int offset = join_offset(tp->offset());\n+      switch (tp->ptr()) {\n+        case TopPTR:\n+        case Null:\n+          return TypePtr::make(AnyPtr, ptr, offset, tp->speculative(), tp->inline_depth());\n+        case NotNull:\n+        case BotPTR:\n+          return make(ptr, klass(), interfaces(), offset);\n+        default:\n+          typerr(t);\n+      }\n+    }\n+\n+    case InstKlassPtr: {\n+      const TypeInstKlassPtr* tp = t->is_instklassptr();\n+      PTR ptr = join_ptr(tp->ptr());\n+      int offset = join_offset(tp->offset());\n+      const TypeInterfaces* interfaces = join_interfaces(tp);\n+\n+      \/\/ For TypeInstKlassPtr, klass() must return a non-null ciInstanceKlass\n+      ciInstanceKlass* klass1 = instance_klass();\n+      ciInstanceKlass* klass2 = tp->instance_klass();\n+      bool xk1 = klass_is_exact();\n+      bool xk2 = tp->klass_is_exact();\n+      if (xk1 && xk2) {\n+        if (klass1 == klass2) {\n+          return make(ptr, klass1, interfaces, offset);\n+        } else {\n+          return TypePtr::make(AnyPtr, TopPTR, offset);\n+        }\n+      } else if (xk1) {\n+        \/\/ When the exact klass pointer is an interface, the klass() is Object and the interfaces()\n+        \/\/ is not empty\n+        if ((klass1->is_java_lang_Object() && klass2->is_java_lang_Object() && this->interfaces() == interfaces) ||\n+            (klass1->is_subtype_of(klass2) && interfaces->eq(klass1))) {\n+          return make(ptr, klass1, interfaces, offset);\n+        } else {\n+          return TypePtr::make(AnyPtr, TopPTR, offset);\n+        }\n+      } else if (xk2) {\n+        if ((klass2->is_java_lang_Object() && klass1->is_java_lang_Object() && tp->interfaces() == interfaces) ||\n+            (klass2->is_subtype_of(klass1) && interfaces->eq(klass2))) {\n+          return make(ptr, klass2, interfaces, offset);\n+        } else {\n+          return TypePtr::make(AnyPtr, TopPTR, offset);\n+        }\n+      } else {\n+        \/\/ There is no opposite of LCA, there exists a type subtyping both A and B iff A is a\n+        \/\/ subtype of B or B is a subtype of A\n+        ciKlass* subklass;\n+        if (klass1->is_subtype_of(klass2)) {\n+          subklass = klass1;\n+        } else if (klass2->is_subtype_of(klass1)) {\n+          subklass = klass2;\n+        } else {\n+          return TypePtr::make(AnyPtr, ptr == BotPTR ? Null : TopPTR, offset);\n+        }\n+\n+        return make(ptr, subklass, interfaces, offset);\n+      }\n+    }\n+\n+    case AryKlassPtr:\n+      return t->is_aryklassptr()->xjoin(this);\n+\n+    default:\n+      typerr(t);\n+  }\n+}\n+\n+#ifdef ASSERT\n@@ -5929,0 +6436,1 @@\n+#endif \/\/ ASSERT\n@@ -6042,1 +6550,5 @@\n-const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, const Type* elem, ciKlass* k, int offset) {\n+const TypeAryKlassPtr* TypeAryKlassPtr::make(PTR ptr, const Type* elem, ciKlass* k, int offset) {\n+  if (ptr == Constant && elem->isa_klassptr()) {\n+    elem = elem->is_klassptr()->cast_to_exactness(true);\n+  }\n+\n@@ -6119,1 +6631,1 @@\n-  if( this != TypeAryPtr::OOPS && this->dual() != TypeAryPtr::OOPS ) {\n+  if (this != TypeAryPtr::OOPS DEBUG_ONLY(&& this->dual() != TypeAryPtr::OOPS)) {\n@@ -6203,1 +6715,1 @@\n-const TypeOopPtr* TypeAryKlassPtr::as_instance_type(bool klass_change) const {\n+const TypeAryPtr* TypeAryKlassPtr::as_instance_type(bool klass_change) const {\n@@ -6219,4 +6731,1 @@\n-const Type    *TypeAryKlassPtr::xmeet( const Type *t ) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n-\n+const Type* TypeAryKlassPtr::xmeet(const Type* t) const {\n@@ -6225,19 +6734,0 @@\n-\n-  case Int:                     \/\/ Mixing ints & oops happens when javac\n-  case Long:                    \/\/ reuses local variables\n-  case HalfFloatTop:\n-  case HalfFloatCon:\n-  case HalfFloatBot:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case NarrowOop:\n-  case NarrowKlass:\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-  case Top:\n-    return this;\n-\n@@ -6266,7 +6756,0 @@\n-  case RawPtr:\n-  case MetadataPtr:\n-  case OopPtr:\n-  case AryPtr:                  \/\/ Meet with AryPtr\n-  case InstPtr:                 \/\/ Meet with InstPtr\n-    return TypePtr::BOTTOM;\n-\n@@ -6292,1 +6775,1 @@\n-    const Type* elem = _elem->meet(tap->_elem);\n+    const Type* elem = TypeAry::meet_elem(_elem, tap->_elem);\n@@ -6354,0 +6837,63 @@\n+const Type* TypeAryKlassPtr::xjoin(const Type* t) const {\n+  if (base() != AryKlassPtr) {\n+    typerr(t);\n+  }\n+\n+  switch (t->base()) {\n+    case AnyPtr: {\n+      const TypePtr* tp = t->is_ptr();\n+      PTR ptr = join_ptr(tp->ptr());\n+      int offset = join_offset(tp->offset());\n+      switch (tp->ptr()) {\n+        case TopPTR:\n+        case Null:\n+          return TypePtr::make(AnyPtr, ptr, offset, tp->speculative(), tp->inline_depth());\n+        case NotNull:\n+        case BotPTR:\n+          return make(ptr, elem(), klass(), offset);\n+        default:\n+          typerr(t);\n+      }\n+    }\n+\n+    case InstKlassPtr: {\n+      const TypeInstKlassPtr* tp = t->is_instklassptr();\n+      PTR ptr = join_ptr(tp->ptr());\n+      int offset = join_offset(tp->offset());\n+\n+      if (tp->klass()->is_java_lang_Object() && !tp->klass_is_exact() && _array_interfaces->contains(tp->interfaces())) {\n+        return make(ptr, elem(), klass(), offset);\n+      } else {\n+        return TypePtr::make(AnyPtr, ptr == BotPTR ? Null : TopPTR, offset);\n+      }\n+    }\n+\n+    case AryKlassPtr: {\n+      const TypeAryKlassPtr* tp = t->is_aryklassptr();\n+      PTR ptr = join_ptr(tp->ptr());\n+      int offset = join_offset(tp->offset());\n+\n+      const Type* elem1 = elem();\n+      const Type* elem2 = tp->elem();\n+      if (elem1->isa_int() && elem2->isa_int()) {\n+        \/\/ There may be cases that we are joining int[] and char[]\n+        if (klass() == tp->klass()) {\n+          return make(ptr, elem1->join(elem2), klass(), offset);\n+        } else {\n+          return TypePtr::make(AnyPtr, ptr == BotPTR ? Null : TopPTR, offset);\n+        }\n+      }\n+\n+      const Type* res_elem = TypeAry::join_elem(elem1, elem2);\n+      if (res_elem->empty() || (res_elem->isa_ptr() && !res_elem->isa_klassptr())) {\n+        return TypePtr::make(AnyPtr, ptr == BotPTR ? Null : TopPTR, offset);\n+      }\n+\n+      return make(ptr, res_elem, nullptr, offset);\n+    }\n+\n+    default:\n+      typerr(t);\n+  }\n+}\n+\n@@ -6472,0 +7018,1 @@\n+#ifdef ASSERT\n@@ -6477,0 +7024,1 @@\n+#endif \/\/ ASSERT\n@@ -6578,21 +7126,1 @@\n-\/\/------------------------------meet-------------------------------------------\n-\/\/ Compute the MEET of two types.  It returns a new Type object.\n-const Type *TypeFunc::xmeet( const Type *t ) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n-\n-  \/\/ Current \"this->_base\" is Func\n-  switch (t->base()) {          \/\/ switch on original type\n-\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return t;\n-\n-  default:                      \/\/ All else is a mistake\n-    typerr(t);\n-\n-  case Top:\n-    break;\n-  }\n-  return this;                  \/\/ Return the double constant\n-}\n-\n+#ifdef ASSERT\n@@ -6604,0 +7132,1 @@\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":1268,"deletions":739,"binary":false,"changes":2007,"status":"modified"},{"patch":"@@ -177,0 +177,1 @@\n+#ifdef ASSERT\n@@ -179,2 +180,11 @@\n-  \/\/ lazily, on demand, and cached in _dual.\n-  const Type *_dual;            \/\/ Cached dual value\n+  \/\/ lazily, on demand, and cached in _dual. Use to verify the result of the\n+  \/\/ new implementation of JOIN, to be removed later.\n+  const Type *_dual; \/\/ Cached dual value\n+#endif\n+\n+  template <class F>\n+  static const Type* meet_join_helper(F op, const Type* t1, const Type* t2, bool include_speculative);\n+\n+  const Type* meet_helper(const Type* t, bool include_speculative) const;\n+\n+  static void check_fundamental_laws(const Type* t1, const Type* t2, VerifyMeet& verify) NOT_DEBUG_RETURN;\n@@ -182,0 +192,7 @@\n+  static const Type* xmeet(const Type* t1, const Type* t2);\n+  static const Type* xjoin(const Type* t1, const Type* t2);\n+\n+  \/\/ Compute meet dependent on base type\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xjoin(const Type* t) const;\n+  DEBUG_ONLY(virtual const Type* xdual() const;)\n@@ -183,2 +200,1 @@\n-  const Type *meet_helper(const Type *t, bool include_speculative) const;\n-  void check_symmetrical(const Type* t, const Type* mt, const VerifyMeet& verify) const NOT_DEBUG_RETURN;\n+friend class VerifyMeetResult;\n@@ -190,1 +206,1 @@\n-  Type( TYPES t ) : _dual(nullptr),  _base(t) {} \/\/ Simple types\n+  Type(TYPES t) : DEBUG_ONLY(_dual(nullptr) COMMA)  _base(t) {} \/\/ Simple types\n@@ -194,6 +210,1 @@\n-  const Type *join_helper(const Type *t, bool include_speculative) const {\n-    assert_type_verify_empty();\n-    return dual()->meet_helper(t->dual(), include_speculative)->dual();\n-  }\n-\n-  void assert_type_verify_empty() const NOT_DEBUG_RETURN;\n+  const Type* join_helper(const Type *t, bool include_speculative) const;\n@@ -238,1 +249,1 @@\n-  \/\/ MEET operation; lower in lattice.\n+  \/\/ MEET operations\n@@ -252,0 +263,1 @@\n+#ifdef ASSERT\n@@ -255,0 +267,1 @@\n+#endif \/\/ ASSERT\n@@ -256,6 +269,1 @@\n-  \/\/ Compute meet dependent on base type\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n-\n-  \/\/ JOIN operation; higher in lattice.  Done by finding the dual of the\n-  \/\/ meet of the dual of the 2 inputs.\n+  \/\/ JOIN operations\n@@ -272,1 +280,1 @@\n-  \/\/ Normalizes all empty values to TOP.  Does not kill _widen bits.\n+  \/\/ Normalizes all empty values to TOP. Does not kill _widen bits.\n@@ -406,1 +414,1 @@\n-  void typerr(const Type *t) const; \/\/ Mixing types error\n+  [[noreturn]] void typerr(const Type *t) const; \/\/ Mixing types error\n@@ -527,2 +535,3 @@\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xjoin(const Type* t) const;\n+  DEBUG_ONLY(virtual const Type* xdual() const;)\n@@ -560,1 +569,2 @@\n-  virtual const Type* xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* xjoin(const Type* t) const;\n+  DEBUG_ONLY(virtual const Type* xdual() const;)\n@@ -590,2 +600,3 @@\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xjoin(const Type* t) const;\n+  DEBUG_ONLY(virtual const Type* xdual() const;)\n@@ -814,1 +825,2 @@\n-  virtual const Type* xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* xjoin(const Type* t) const;\n+  DEBUG_ONLY(virtual const Type* xdual() const;)\n@@ -901,1 +913,2 @@\n-  virtual const Type* xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* xjoin(const Type* t) const;\n+  DEBUG_ONLY(virtual const Type* xdual() const;)\n@@ -962,2 +975,3 @@\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xjoin(const Type* t) const;\n+  DEBUG_ONLY(virtual const Type* xdual() const;)\n@@ -1002,2 +1016,5 @@\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xjoin(const Type* t) const;\n+  DEBUG_ONLY(virtual const Type* xdual() const;)\n+  static const Type* meet_elem(const Type* elem_type1, const Type* elem_type2);\n+  static const Type* join_elem(const Type* elem_type1, const Type* elem_type2);\n@@ -1037,2 +1054,1 @@\n-  virtual const Type* xmeet( const Type *t) const;\n-  virtual const Type* xdual() const;     \/\/ Compute dual right now.\n+  DEBUG_ONLY(virtual const Type* xdual() const;)\n@@ -1112,1 +1128,1 @@\n-  const Type *xdual() const;\n+  DEBUG_ONLY(virtual const Type* xdual() const;)\n@@ -1127,2 +1143,0 @@\n-  const Type* xmeet(const Type* t) const;\n-\n@@ -1175,0 +1189,1 @@\n+  const TypePtr* xjoin_speculative(const TypePtr* other) const;\n@@ -1186,0 +1201,1 @@\n+  int join_inline_depth(int depth) const;\n@@ -1204,0 +1220,2 @@\n+  template<class T> static MeetResult join_instptr(PTR& ptr, const TypeInterfaces*& interfaces, const T* this_type,\n+                                                   const T* other_type, ciKlass*& res_klass, bool& res_xk);\n@@ -1240,7 +1258,10 @@\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xmeet_helper( const Type *t ) const;\n-  int meet_offset( int offset ) const;\n-  int dual_offset( ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n-\n-  \/\/ meet, dual and join over pointer equivalence sets\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xmeet_helper(const Type* t) const;\n+  virtual const Type* xjoin(const Type* t) const;\n+  virtual const Type* xjoin_helper(const Type* t) const;\n+  DEBUG_ONLY(virtual const Type* xdual() const;)\n+  int meet_offset(int offset) const;\n+  int join_offset(int offset) const;\n+  int dual_offset() const;\n+\n+  \/\/ meet and join over pointer equivalence sets\n@@ -1306,2 +1327,3 @@\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xjoin(const Type* t) const;\n+  DEBUG_ONLY(virtual const Type* xdual() const;)\n@@ -1358,0 +1380,1 @@\n+  int join_instance_id(int uid) const;\n@@ -1360,0 +1383,1 @@\n+  const TypeInterfaces* join_interfaces(const TypeOopPtr* other) const;\n@@ -1455,1 +1479,1 @@\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n+  DEBUG_ONLY(virtual const Type* xdual() const;)\n@@ -1457,1 +1481,2 @@\n-  virtual const Type *xmeet_helper(const Type *t) const;\n+  virtual const Type* xmeet_helper(const Type* t) const;\n+  virtual const Type* xjoin_helper(const Type* t) const;\n@@ -1578,3 +1603,4 @@\n-  virtual const Type *xmeet_helper(const Type *t) const;\n-  virtual const TypeInstPtr *xmeet_unloaded(const TypeInstPtr *tinst, const TypeInterfaces* interfaces) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* xmeet_helper(const Type *t) const;\n+  virtual const TypeInstPtr* xmeet_unloaded(const TypeInstPtr *tinst, const TypeInterfaces* interfaces) const;\n+  virtual const Type* xjoin_helper(const Type *t) const;\n+  DEBUG_ONLY(virtual const Type* xdual() const;)\n@@ -1691,2 +1717,3 @@\n-  virtual const Type *xmeet_helper(const Type *t) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* xmeet_helper(const Type* t) const;\n+  virtual const Type* xjoin_helper(const Type *t) const;\n+  DEBUG_ONLY(virtual const Type* xdual() const;)\n@@ -1755,2 +1782,3 @@\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xjoin(const Type* t) const;\n+  DEBUG_ONLY(virtual const Type* xdual() const;)\n@@ -1789,0 +1817,1 @@\n+  const TypeInterfaces* join_interfaces(const TypeKlassPtr* other) const;\n@@ -1825,3 +1854,4 @@\n-  virtual const TypePtr *add_offset( intptr_t offset ) const { ShouldNotReachHere(); return nullptr; }\n-  virtual const Type    *xmeet( const Type *t ) const { ShouldNotReachHere(); return nullptr; }\n-  virtual const Type    *xdual() const { ShouldNotReachHere(); return nullptr; }\n+  virtual const TypePtr* add_offset(intptr_t offset) const { ShouldNotReachHere(); return nullptr; }\n+  virtual const Type*    xmeet(const Type* t)        const { ShouldNotReachHere(); return nullptr; }\n+  virtual const Type*    xjoin(const Type* t)        const { ShouldNotReachHere(); return nullptr; }\n+  DEBUG_ONLY(virtual const Type* xdual()             const { ShouldNotReachHere(); return nullptr; })\n@@ -1908,2 +1938,3 @@\n-  virtual const Type    *xmeet( const Type *t ) const;\n-  virtual const Type    *xdual() const;\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xjoin(const Type* t) const;\n+  DEBUG_ONLY(virtual const Type* xdual() const;)\n@@ -1967,1 +1998,1 @@\n-  virtual const TypeOopPtr* as_instance_type(bool klass_change = true) const;\n+  virtual const TypeAryPtr* as_instance_type(bool klass_change = true) const;\n@@ -1969,3 +2000,4 @@\n-  virtual const TypePtr *add_offset( intptr_t offset ) const;\n-  virtual const Type    *xmeet( const Type *t ) const;\n-  virtual const Type    *xdual() const;      \/\/ Compute dual right now.\n+  virtual const TypePtr* add_offset(intptr_t offset) const;\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xjoin(const Type* t) const;\n+  DEBUG_ONLY(virtual const Type* xdual() const;)\n@@ -2008,2 +2040,1 @@\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n+  DEBUG_ONLY(virtual const Type* xdual() const;)\n@@ -2142,2 +2173,1 @@\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n+  DEBUG_ONLY(virtual const Type* xdual() const;)\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":97,"deletions":67,"binary":false,"changes":164,"status":"modified"}]}