{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,1 @@\n+import static sun.security.ssl.SSLExtension.SH_PRE_SHARED_KEY;\n@@ -345,0 +346,4 @@\n+                    \/\/ this server is disallowing this session resumption,\n+                    \/\/ so don't include the pre-shared key in the\n+                    \/\/ ServerHello handshake message\n+                    shc.handshakeExtensions.remove(SH_PRE_SHARED_KEY);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ServerNameExtension.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,247 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import javax.net.ssl.SNIHostName;\n+import javax.net.ssl.SNIMatcher;\n+import javax.net.ssl.SNIServerName;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.SSLEngineResult;\n+import javax.net.ssl.SSLEngineResult.HandshakeStatus;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.StandardConstants;\n+\n+\/*\n+ * @test\n+ * @bug 8301686\n+ * @summary verifies that if the server rejects session resumption due to SNI\n+ *          mismatch, during TLS handshake, then the subsequent communication\n+ *          between the server and the client happens correctly without any\n+ *          errors\n+ * @library \/javax\/net\/ssl\/templates\n+ * @run main\/othervm -Djavax.net.debug=all\n+ *                   ServerNameRejectedTLSSessionResumption\n+ *\/\n+public class ServerNameRejectedTLSSessionResumption\n+        extends SSLContextTemplate {\n+\n+    private static final String CLIENT_REQUESTED_SNI = \"client.local\";\n+    \/\/ dummy host, no connection is attempted in this test\n+    private static final String PEER_HOST = \"foobar\";\n+    \/\/ dummy port, no connection is attempted in this test\n+    private static final int PEER_PORT = 12345;\n+\n+    public static void main(final String[] args) throws Exception {\n+        new ServerNameRejectedTLSSessionResumption().runTest();\n+    }\n+\n+    private void runTest() throws Exception {\n+        final SSLContext clientSSLContext = createClientSSLContext();\n+        final SSLContext serverSSLContext = createServerSSLContext();\n+        \/\/ create client and server SSLEngine(s)\n+        final SSLEngine clientEngine = createClientSSLEngine(clientSSLContext);\n+        \/\/ use a SNIMatcher on the server's SSLEngine which accepts the\n+        \/\/ SNI name presented by the client SSLEngine\n+        final SSLEngine serverEngine = createServerSSLEngine(serverSSLContext,\n+                new TestSNIMatcher(CLIENT_REQUESTED_SNI));\n+        \/\/ establish communication, which involves TLS handshake, between the\n+        \/\/ client and server engines. this communication expected to be\n+        \/\/ successful.\n+        communicate(clientEngine, serverEngine);\n+        \/\/ now that the communication has been successful, we expect the client\n+        \/\/ SSLContext's (internal) cache to have created and cached a\n+        \/\/ SSLSession against the peer host:port\n+\n+        \/\/ now create the SSLEngine(s) again with the same SSLContext\n+        \/\/ instances as before, so that the SSLContext instance attempts\n+        \/\/ to reuse the cached SSLSession against the peer host:port\n+        final SSLEngine secondClientEngine =\n+                createClientSSLEngine(clientSSLContext);\n+        \/\/ the newly created SSLEngine for the server will not use any\n+        \/\/ SNIMatcher so as to reject the session resumption (of the\n+        \/\/ cached SSLSession)\n+        final SSLEngine secondServerEngine =\n+                createServerSSLEngine(serverSSLContext, null);\n+        \/\/ attempt communication, which again involves TLS handshake\n+        \/\/ since these are new engine instances. The session resumption\n+        \/\/ should be rejected and a fresh session should get created and\n+        \/\/ communication should succeed without any errors\n+        communicate(secondClientEngine, secondServerEngine);\n+    }\n+\n+    private static void communicate(final SSLEngine clientEngine,\n+                                    final SSLEngine serverEngine)\n+            throws Exception {\n+\n+        final ByteBuffer msgFromClient =\n+                ByteBuffer.wrap(\"Hi Server, I'm Client\".getBytes());\n+        final ByteBuffer msgFromServer =\n+                ByteBuffer.wrap(\"Hello Client, I'm Server\".getBytes());\n+        final ByteBuffer clientBuffer = ByteBuffer.allocate(1 << 15);\n+        final ByteBuffer serverBuffer = ByteBuffer.allocate(1 << 15);\n+        \/*\n+         * For data transport, this test uses local ByteBuffers\n+         *\/\n+        final ByteBuffer clientToServerTransport =\n+                ByteBuffer.allocateDirect(1 << 16);\n+        final ByteBuffer serverToClientTransport =\n+                ByteBuffer.allocateDirect(1 << 16);\n+        boolean isClientToServer = true;\n+        while (true) {\n+            if (isClientToServer) {\n+                \/\/ send client's message over the transport, will initiate a\n+                \/\/ TLS handshake if necessary\n+                SSLEngineResult result = clientEngine.wrap(msgFromClient,\n+                        clientToServerTransport);\n+                \/\/ run any delegated tasks\n+                final HandshakeStatus hsStatus = checkAndRunTasks(clientEngine,\n+                        result.getHandshakeStatus());\n+                clientToServerTransport.flip(); \/\/ will now contain the\n+                \/\/ network data from\n+                \/\/ client to server\n+\n+                \/\/ read from the client generated network data into\n+                \/\/ server's buffer\n+                result = serverEngine.unwrap(clientToServerTransport,\n+                        serverBuffer);\n+                checkAndRunTasks(serverEngine, result.getHandshakeStatus());\n+                clientToServerTransport.compact();\n+\n+                if (hsStatus == HandshakeStatus.NEED_UNWRAP) {\n+                    isClientToServer = false;\n+                } else if (hsStatus == HandshakeStatus.FINISHED) {\n+                    break;\n+                } else if (hsStatus != HandshakeStatus.NEED_WRAP) {\n+                    throw new Exception(\"Unexpected handshake result \"\n+                            + result);\n+                }\n+            } else {\n+                \/\/ send server's message over the transport\n+                SSLEngineResult result = serverEngine.wrap(msgFromServer,\n+                        serverToClientTransport);\n+                \/\/ run any delegated tasks on the server side\n+                final HandshakeStatus hsStatus = checkAndRunTasks(serverEngine,\n+                        result.getHandshakeStatus());\n+                serverToClientTransport.flip(); \/\/ will now contain the\n+                \/\/ network data from\n+                \/\/ server to client\n+\n+                \/\/ read from the server generated network data into\n+                \/\/ client's buffer\n+                result = clientEngine.unwrap(serverToClientTransport,\n+                        clientBuffer);\n+                \/\/ run any delegated tasks on the client side\n+                checkAndRunTasks(clientEngine, result.getHandshakeStatus());\n+                serverToClientTransport.compact();\n+\n+                if (hsStatus == HandshakeStatus.NEED_UNWRAP) {\n+                    isClientToServer = true;\n+                } else if (hsStatus == HandshakeStatus.FINISHED) {\n+                    break;\n+                } else if (hsStatus != HandshakeStatus.NEED_WRAP) {\n+                    throw new Exception(\"Unexpected handshake result \"\n+                            + result);\n+                }\n+            }\n+        }\n+        serverEngine.wrap(msgFromServer, serverToClientTransport);\n+        serverToClientTransport.flip();\n+        clientEngine.unwrap(serverToClientTransport, clientBuffer);\n+        serverToClientTransport.compact();\n+    }\n+\n+    private static SSLEngine createServerSSLEngine(\n+            final SSLContext sslContext, final SNIMatcher sniMatcher) {\n+        final SSLEngine serverEngine = sslContext.createSSLEngine();\n+        serverEngine.setUseClientMode(false);\n+        if (sniMatcher != null) {\n+            final SSLParameters sslParameters =\n+                    serverEngine.getSSLParameters(); \/\/ returns a copy\n+            sslParameters.setSNIMatchers(List.of(sniMatcher));\n+            \/\/ use the updated params\n+            serverEngine.setSSLParameters(sslParameters);\n+        }\n+        return serverEngine;\n+    }\n+\n+    private static SSLEngine createClientSSLEngine(\n+            final SSLContext sslContext) {\n+        final SSLEngine clientEngine = sslContext.createSSLEngine(PEER_HOST,\n+                PEER_PORT);\n+        clientEngine.setUseClientMode(true);\n+        final SSLParameters params =\n+                clientEngine.getSSLParameters(); \/\/ returns a copy\n+        \/\/ setup SNI name that will be used by the client during TLS handshake\n+        params.setServerNames(List.of(new SNIHostName(CLIENT_REQUESTED_SNI)));\n+        clientEngine.setSSLParameters(params); \/\/ use the updated params\n+        return clientEngine;\n+    }\n+\n+    private static HandshakeStatus checkAndRunTasks(\n+            final SSLEngine engine, final HandshakeStatus handshakeStatus) {\n+        if (handshakeStatus != HandshakeStatus.NEED_TASK) {\n+            return handshakeStatus;\n+        }\n+        Runnable runnable;\n+        while ((runnable = engine.getDelegatedTask()) != null) {\n+            System.out.println(\"Running task \" + runnable);\n+            runnable.run();\n+        }\n+        return engine.getHandshakeStatus();\n+    }\n+\n+    private static final class TestSNIMatcher extends SNIMatcher {\n+\n+        private final String recognizedSNIServerName;\n+\n+        private TestSNIMatcher(final String recognizedSNIServerName) {\n+            super(StandardConstants.SNI_HOST_NAME);\n+            this.recognizedSNIServerName = recognizedSNIServerName;\n+        }\n+\n+        @Override\n+        public boolean matches(final SNIServerName clientRequestedSNI) {\n+            Objects.requireNonNull(clientRequestedSNI);\n+            System.out.println(\"Attempting SNI match against client\" +\n+                    \" request SNI name: \" + clientRequestedSNI +\n+                    \" against server recognized SNI name \"\n+                    + recognizedSNIServerName);\n+            if (!SNIHostName.class.isInstance(clientRequestedSNI)) {\n+                System.out.println(\"SNI match failed - client request\" +\n+                        \" SNI isn't a SNIHostName\");\n+                \/\/ we only support SNIHostName type\n+                return false;\n+            }\n+            final String requestedName =\n+                    ((SNIHostName) clientRequestedSNI).getAsciiName();\n+            final boolean matches =\n+                    recognizedSNIServerName.equals(requestedName);\n+            System.out.println(\"SNI match \" + (matches ? \"passed\" : \"failed\"));\n+            return matches;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLSession\/ServerNameRejectedTLSSessionResumption.java","additions":247,"deletions":0,"binary":false,"changes":247,"status":"added"}]}