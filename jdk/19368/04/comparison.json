{"files":[{"patch":"@@ -2125,0 +2125,287 @@\n+\/\/ scans count pointer sized words at [addr] for occurrence of value,\n+\/\/ generic (count must be >0)\n+\/\/ iff found: CR0 eq, scratch == 0\n+void MacroAssembler::repne_scan(Register addr, Register value, Register count, Register scratch) {\n+  Label Lloop, Lexit;\n+\n+#ifdef ASSERT\n+  {\n+    Label ok;\n+    cmpdi(CCR0, count, 0);\n+    bgt(CCR0, ok);\n+    stop(\"count must be positive\");\n+    bind(ok);\n+  }\n+#endif\n+\n+  mtctr(count);\n+\n+  bind(Lloop);\n+  ld(scratch, 0 , addr);\n+  xor_(scratch, scratch, value);\n+  beq(CCR0, Lexit);\n+  addi(addr, addr, wordSize);\n+  bdnz(Lloop);\n+\n+  bind(Lexit);\n+}\n+\n+\/\/ Ensure that the inline code and the stub are using the same registers.\n+#define LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS                       \\\n+do {                                                                  \\\n+  assert(r_super_klass  == R3_ARG1                                 && \\\n+         r_array_base   == R4_ARG2                                 && \\\n+         r_array_length == R5_ARG3                                 && \\\n+         (r_array_index == R6_ARG4      || r_array_index == noreg) && \\\n+         (r_sub_klass   == R7_ARG5      || r_sub_klass   == noreg) && \\\n+         (r_bitmap      == R11_scratch1 || r_bitmap      == noreg) && \\\n+         (result        == R8_ARG6      || result        == noreg), \"registers must match ppc64.ad\"); \\\n+} while(0)\n+\n+\/\/ Return true: we succeeded in generating this code\n+bool MacroAssembler::lookup_secondary_supers_table(Register r_sub_klass,\n+                                                   Register r_super_klass,\n+                                                   Register temp1,\n+                                                   Register temp2,\n+                                                   Register temp3,\n+                                                   Register temp4,\n+                                                   Register result,\n+                                                   u1 super_klass_slot) {\n+  assert_different_registers(r_sub_klass, r_super_klass, temp1, temp2, temp3, temp4, result);\n+\n+  Label L_fallthrough;\n+\n+  BLOCK_COMMENT(\"lookup_secondary_supers_table {\");\n+\n+  const Register\n+    r_array_base   = temp1,\n+    r_array_length = temp2,\n+    r_array_index  = temp3,\n+    r_bitmap       = temp4;\n+\n+  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+\n+  ld(r_bitmap, in_bytes(Klass::bitmap_offset()), r_sub_klass);\n+\n+  \/\/ First check the bitmap to see if super_klass might be present. If\n+  \/\/ the bit is zero, we are certain that super_klass is not one of\n+  \/\/ the secondary supers.\n+  u1 bit = super_klass_slot;\n+  int shift_count = Klass::SECONDARY_SUPERS_TABLE_MASK - bit;\n+\n+  \/\/ if (shift_count == 0) this is used for comparing with 0:\n+  sldi_(r_array_index, r_bitmap, shift_count);\n+\n+  li(result, 1); \/\/ failure\n+  \/\/ We test the MSB of r_array_index, i.e. its sign bit\n+  bge(CCR0, L_fallthrough);\n+\n+  \/\/ We will consult the secondary-super array.\n+  ld(r_array_base, in_bytes(Klass::secondary_supers_offset()), r_sub_klass);\n+\n+  \/\/ The value i in r_array_index is >= 1, so even though r_array_base\n+  \/\/ points to the length, we don't need to adjust it to point to the\n+  \/\/ data.\n+  assert(Array<Klass*>::base_offset_in_bytes() == wordSize, \"Adjust this code\");\n+\n+  \/\/ Get the first array index that can contain super_klass.\n+  if (bit != 0) {\n+    popcntd(r_array_index, r_array_index);\n+    \/\/ NB! r_array_index is off by 1. It is compensated by keeping r_array_base off by 1 word.\n+    sldi(r_array_index, r_array_index, LogBytesPerWord); \/\/ scale\n+    ldx(result, r_array_base, r_array_index);\n+  } else {\n+    \/\/ Actually use index 0, but r_array_base and r_array_index are off by 1 word\n+    \/\/ such that the sum is precise.\n+    ld(result, BytesPerWord, r_array_base);\n+    li(r_array_index, BytesPerWord); \/\/ for slow path (scaled)\n+  }\n+\n+  xor_(result, result, r_super_klass);\n+  beq(CCR0, L_fallthrough); \/\/ Found a match (result == 0)\n+\n+  \/\/ Is there another entry to check? Consult the bitmap.\n+  testbitdi(CCR0, \/* temp *\/ r_array_length, r_bitmap, (bit + 1) & Klass::SECONDARY_SUPERS_TABLE_MASK);\n+  beq(CCR0, L_fallthrough); \/\/ (result != 0)\n+\n+  \/\/ Linear probe. Rotate the bitmap so that the next bit to test is\n+  \/\/ in Bit 1.\n+  if (bit != 0) {\n+    rldicl(r_bitmap, r_bitmap, 64 - bit, 0);\n+  }\n+\n+  \/\/ Calls into the stub generated by lookup_secondary_supers_table_slow_path.\n+  \/\/ Arguments: r_super_klass, r_array_base, r_array_index, r_bitmap.\n+  \/\/ Kills: r_array_length.\n+  \/\/ Returns: result.\n+  address stub = StubRoutines::lookup_secondary_supers_table_slow_path_stub();\n+  Register r_stub_addr = r_array_length;\n+  add_const_optimized(r_stub_addr, R29_TOC, MacroAssembler::offset_to_global_toc(stub), R0);\n+  mtctr(r_stub_addr);\n+  bctrl();\n+\n+  bind(L_fallthrough);\n+  BLOCK_COMMENT(\"} lookup_secondary_supers_table\");\n+\n+  if (VerifySecondarySupers) {\n+    verify_secondary_supers_table(r_sub_klass, r_super_klass, result,\n+                                  temp1, temp2, temp3);\n+  }\n+  return true;\n+}\n+\n+\/\/ Called by code generated by check_klass_subtype_slow_path\n+\/\/ above. This is called when there is a collision in the hashed\n+\/\/ lookup in the secondary supers array.\n+void MacroAssembler::lookup_secondary_supers_table_slow_path(Register r_super_klass,\n+                                                             Register r_array_base,\n+                                                             Register r_array_index,\n+                                                             Register r_bitmap,\n+                                                             Register result,\n+                                                             Register temp1) {\n+  assert_different_registers(r_super_klass, r_array_base, r_array_index, r_bitmap, result, temp1);\n+\n+  const Register\n+    r_array_length = temp1,\n+    r_sub_klass    = noreg;\n+\n+  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+\n+  Label L_fallthrough;\n+\n+  \/\/ Load the array length.\n+  lwa(r_array_length, Array<Klass*>::length_offset_in_bytes(), r_array_base);\n+  \/\/ And adjust the array base to point to the data.\n+  \/\/ NB! Effectively increments current slot index by 1.\n+  assert(Array<Klass*>::base_offset_in_bytes() == wordSize, \"\");\n+  addi(r_array_base, r_array_base, Array<Klass*>::base_offset_in_bytes());\n+\n+  \/\/ Linear probe\n+  Label L_huge;\n+\n+  \/\/ The bitmap is full to bursting.\n+  \/\/ Implicit invariant: BITMAP_FULL implies (length > 0)\n+  assert(Klass::SECONDARY_SUPERS_BITMAP_FULL == ~uintx(0), \"\");\n+  cmpdi(CCR0, r_bitmap, -1);\n+  beq(CCR0, L_huge);\n+\n+  \/\/ NB! Our caller has checked bits 0 and 1 in the bitmap. The\n+  \/\/ current slot (at secondary_supers[r_array_index]) has not yet\n+  \/\/ been inspected, and r_array_index may be out of bounds if we\n+  \/\/ wrapped around the end of the array.\n+\n+  { \/\/ This is conventional linear probing, but instead of terminating\n+    \/\/ when a null entry is found in the table, we maintain a bitmap\n+    \/\/ in which a 0 indicates missing entries.\n+    \/\/ The check above guarantees there are 0s in the bitmap, so the loop\n+    \/\/ eventually terminates.\n+\n+#ifdef ASSERT\n+    {\n+      \/\/ We should only reach here after having found a bit in the bitmap.\n+      \/\/ Invariant: array_length == popcount(bitmap)\n+      Label ok;\n+      cmpdi(CCR0, r_array_length, 0);\n+      bgt(CCR0, ok);\n+      stop(\"array_length must be positive\");\n+      bind(ok);\n+    }\n+#endif\n+\n+    \/\/ Compute limit in r_array_length\n+    addi(r_array_length, r_array_length, -1);\n+    sldi(r_array_length, r_array_length, LogBytesPerWord);\n+\n+    Label L_loop;\n+    bind(L_loop);\n+\n+    \/\/ Check for wraparound.\n+    cmpd(CCR0, r_array_index, r_array_length);\n+    isel_0(r_array_index, CCR0, Assembler::greater);\n+\n+    ldx(result, r_array_base, r_array_index);\n+    xor_(result, result, r_super_klass);\n+    beq(CCR0, L_fallthrough);\n+\n+    \/\/ look-ahead check (Bit 2); result is non-zero\n+    testbitdi(CCR0, R0, r_bitmap, 2);\n+    beq(CCR0, L_fallthrough); \/\/ fail (result != 0)\n+\n+    rldicl(r_bitmap, r_bitmap, 64 - 1, 0);\n+    addi(r_array_index, r_array_index, BytesPerWord);\n+    b(L_loop);\n+  }\n+\n+  { \/\/ Degenerate case: more than 64 secondary supers.\n+    \/\/ FIXME: We could do something smarter here, maybe a vectorized\n+    \/\/ comparison or a binary search, but is that worth any added\n+    \/\/ complexity?\n+    bind(L_huge);\n+    repne_scan(r_array_base, r_super_klass, r_array_length, result);\n+  }\n+\n+  bind(L_fallthrough);\n+}\n+\n+\/\/ Make sure that the hashed lookup and a linear scan agree.\n+void MacroAssembler::verify_secondary_supers_table(Register r_sub_klass,\n+                                                   Register r_super_klass,\n+                                                   Register result,\n+                                                   Register temp1,\n+                                                   Register temp2,\n+                                                   Register temp3) {\n+  assert_different_registers(r_sub_klass, r_super_klass, result, temp1, temp2, temp3);\n+\n+  const Register\n+    r_array_base   = temp1,\n+    r_array_length = temp2,\n+    r_array_index  = temp3,\n+    r_bitmap       = noreg; \/\/ unused\n+\n+  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+\n+  BLOCK_COMMENT(\"verify_secondary_supers_table {\");\n+\n+  Label passed, failure;\n+\n+  \/\/ We will consult the secondary-super array.\n+  ld(r_array_base, in_bytes(Klass::secondary_supers_offset()), r_sub_klass);\n+  \/\/ Load the array length.\n+  lwa(r_array_length, Array<Klass*>::length_offset_in_bytes(), r_array_base);\n+  \/\/ And adjust the array base to point to the data.\n+  addi(r_array_base, r_array_base, Array<Klass*>::base_offset_in_bytes());\n+\n+  \/\/ convert !=0 to 1\n+  neg(R0, result);\n+  orr(result, result, R0);\n+  srdi(result, result, 63);\n+\n+  const Register linear_result = r_array_index; \/\/ reuse\n+  li(linear_result, 1);\n+  cmpdi(CCR0, r_array_length, 0);\n+  ble(CCR0, failure);\n+  repne_scan(r_array_base, r_super_klass, r_array_length, linear_result);\n+  bind(failure);\n+\n+  \/\/ convert !=0 to 1\n+  neg(R0, linear_result);\n+  orr(linear_result, linear_result, R0);\n+  srdi(linear_result, linear_result, 63);\n+\n+  cmpd(CCR0, result, linear_result);\n+  beq(CCR0, passed);\n+\n+  mr_if_needed(R3_ARG1, r_super_klass);\n+  mr_if_needed(R4_ARG2, r_sub_klass);\n+  neg(R5_ARG3, linear_result);\n+  neg(R6_ARG4, result);\n+  const char* msg = \"mismatch\";\n+  load_const_optimized(R7_ARG5, (intptr_t)msg, R0);\n+  call_VM_leaf(CAST_FROM_FN_PTR(address, Klass::on_secondary_supers_verification_failure));\n+  should_not_reach_here();\n+\n+  bind(passed);\n+\n+  BLOCK_COMMENT(\"} verify_secondary_supers_table\");\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":287,"deletions":0,"binary":false,"changes":287,"status":"modified"},{"patch":"@@ -605,0 +605,27 @@\n+  void repne_scan(Register addr, Register value, Register count, Register scratch);\n+\n+  \/\/ As above, but with a constant super_klass.\n+  \/\/ The result is in Register result, not the condition codes.\n+  bool lookup_secondary_supers_table(Register r_sub_klass,\n+                                     Register r_super_klass,\n+                                     Register temp1,\n+                                     Register temp2,\n+                                     Register temp3,\n+                                     Register temp4,\n+                                     Register result,\n+                                     u1 super_klass_slot);\n+\n+  void verify_secondary_supers_table(Register r_sub_klass,\n+                                     Register r_super_klass,\n+                                     Register result,\n+                                     Register temp1,\n+                                     Register temp2,\n+                                     Register temp3);\n+\n+  void lookup_secondary_supers_table_slow_path(Register r_super_klass,\n+                                               Register r_array_base,\n+                                               Register r_array_index,\n+                                               Register r_bitmap,\n+                                               Register result,\n+                                               Register temp1);\n+\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -644,0 +644,2 @@\n+reg_class rarg5_bits64_reg(R7_H, R7);\n+reg_class rarg6_bits64_reg(R8_H, R8);\n@@ -4356,0 +4358,2 @@\n+  match(rarg5RegP);\n+  match(rarg6RegP);\n@@ -4411,0 +4415,14 @@\n+operand rarg5RegP() %{\n+  constraint(ALLOC_IN_RC(rarg5_bits64_reg));\n+  match(iRegPdst);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand rarg6RegP() %{\n+  constraint(ALLOC_IN_RC(rarg6_bits64_reg));\n+  match(iRegPdst);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -12026,0 +12044,30 @@\n+instruct partialSubtypeCheckConstSuper(rarg5RegP sub, rarg1RegP super_reg, immP super_con, rarg6RegP result,\n+                                       rarg2RegP tempR1, rarg3RegP tempR2, rarg4RegP tempR3, rscratch1RegP tempR4,\n+                                       flagsRegCR0 cr0, regCTR ctr)\n+%{\n+  match(Set result (PartialSubtypeCheck sub (Binary super_reg super_con)));\n+  predicate(UseSecondarySupersTable);\n+  effect(KILL cr0, KILL ctr, TEMP tempR1, TEMP tempR2, TEMP tempR3, TEMP tempR4);\n+\n+  ins_cost(DEFAULT_COST*8);  \/\/ smaller than the other version\n+  format %{ \"partialSubtypeCheck $result, $sub, $super_reg\" %}\n+\n+  ins_encode %{\n+    bool success = false;\n+    u1 super_klass_slot = ((Klass*)$super_con$$constant)->hash_slot();\n+    if (InlineSecondarySupersTest) {\n+      success = __ lookup_secondary_supers_table($sub$$Register, $super_reg$$Register,\n+                                                 $tempR1$$Register, $tempR2$$Register, $tempR3$$Register, $tempR4$$Register,\n+                                                 $result$$Register, super_klass_slot);\n+    } else {\n+      address stub = StubRoutines::lookup_secondary_supers_table_stub(super_klass_slot);\n+      Register r_stub_addr = $tempR1$$Register;\n+      __ add_const_optimized(r_stub_addr, R29_TOC, MacroAssembler::offset_to_global_toc(stub), R0);\n+      __ mtctr(r_stub_addr);\n+      __ bctrl();\n+    }\n+  %}\n+\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -4537,0 +4537,40 @@\n+address generate_lookup_secondary_supers_table_stub(u1 super_klass_index) {\n+    StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table\");\n+\n+    address start = __ pc();\n+    const Register\n+      r_super_klass  = R3_ARG1,\n+      r_array_base   = R4_ARG2,\n+      r_array_length = R5_ARG3,\n+      r_array_index  = R6_ARG4,\n+      r_sub_klass    = R7_ARG5,\n+      r_bitmap       = R11_scratch1,\n+      result         = R8_ARG6;\n+\n+    __ lookup_secondary_supers_table(r_sub_klass, r_super_klass,\n+                                     r_array_base, r_array_length, r_array_index,\n+                                     r_bitmap, result, super_klass_index);\n+    __ blr();\n+\n+    return start;\n+  }\n+\n+  \/\/ Slow path implementation for UseSecondarySupersTable.\n+  address generate_lookup_secondary_supers_table_slow_path_stub() {\n+    StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table_slow_path\");\n+\n+    address start = __ pc();\n+    const Register\n+      r_super_klass  = R3_ARG1,\n+      r_array_base   = R4_ARG2,\n+      temp1          = R5_ARG3,\n+      r_array_index  = R6_ARG4,\n+      r_bitmap       = R11_scratch1,\n+      result         = R8_ARG6;\n+\n+    __ lookup_secondary_supers_table_slow_path(r_super_klass, r_array_base, r_array_index, r_bitmap, result, temp1);\n+    __ blr();\n+\n+    return start;\n+  }\n+\n@@ -4813,0 +4853,10 @@\n+    if (UseSecondarySupersTable) {\n+      StubRoutines::_lookup_secondary_supers_table_slow_path_stub = generate_lookup_secondary_supers_table_slow_path_stub();\n+      if (!InlineSecondarySupersTest) {\n+        for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n+          StubRoutines::_lookup_secondary_supers_table_stubs[slot]\n+            = generate_lookup_secondary_supers_table_stub(slot);\n+        }\n+      }\n+    }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -98,0 +98,1 @@\n+  constexpr static bool supports_secondary_supers_table() { return true; }\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}