{"files":[{"patch":"@@ -27,1 +27,0 @@\n-#include \"opto\/loopnode.hpp\"\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -765,1 +765,1 @@\n-  const uint first_node_index_in_cloned_loop_body = Compile::current()->unique();\n+  const uint first_node_index_in_post_loop_body = Compile::current()->unique();\n@@ -819,1 +819,1 @@\n-                                                    first_node_index_in_cloned_loop_body, old_new);\n+                                                    first_node_index_in_post_loop_body, old_new);\n@@ -1316,77 +1316,0 @@\n-\/\/ Make two copies of each Template Assertion Predicate before the pre-loop and add them to the main-loop. One remains\n-\/\/ a template while the other one is initialized with the initial value of the loop induction variable. The Initialized\n-\/\/ Assertion Predicates ensures that the main-loop is removed if some type ranges of Cast or Convert nodes become\n-\/\/ impossible and are replaced by top (i.e. a sign that the main-loop is dead).\n-void PhaseIdealLoop::copy_assertion_predicates_to_main_loop_helper(const PredicateBlock* predicate_block, Node* init,\n-                                                                   Node* stride, IdealLoopTree* outer_loop,\n-                                                                   LoopNode* outer_main_head, const uint dd_main_head,\n-                                                                   const uint idx_before_pre_post,\n-                                                                   const uint idx_after_post_before_pre,\n-                                                                   Node* zero_trip_guard_proj_main,\n-                                                                   Node* zero_trip_guard_proj_post,\n-                                                                   const Node_List &old_new) {\n-  if (predicate_block->has_parse_predicate()) {\n-#ifdef ASSERT\n-    ensure_zero_trip_guard_proj(zero_trip_guard_proj_main, true);\n-    ensure_zero_trip_guard_proj(zero_trip_guard_proj_post, false);\n-#endif\n-    Node* predicate_proj = predicate_block->parse_predicate_success_proj();\n-    IfNode* iff = predicate_proj->in(0)->as_If();\n-    ProjNode* uncommon_proj = iff->proj_out(1 - predicate_proj->as_Proj()->_con);\n-    Node* rgn = uncommon_proj->unique_ctrl_out();\n-    assert(rgn->is_Region() || rgn->is_Call(), \"must be a region or call uct\");\n-    predicate_proj = iff->in(0);\n-    Node* current_proj = outer_main_head->in(LoopNode::EntryControl);\n-    Node* prev_proj = current_proj;\n-    Node* opaque_init = new OpaqueLoopInitNode(C, init);\n-    register_new_node(opaque_init, outer_main_head->in(LoopNode::EntryControl));\n-    Node* opaque_stride = new OpaqueLoopStrideNode(C, stride);\n-    register_new_node(opaque_stride, outer_main_head->in(LoopNode::EntryControl));\n-\n-    while (predicate_proj != nullptr && predicate_proj->is_Proj() && predicate_proj->in(0)->is_If()) {\n-      iff = predicate_proj->in(0)->as_If();\n-      uncommon_proj = iff->proj_out(1 - predicate_proj->as_Proj()->_con);\n-      if (uncommon_proj->unique_ctrl_out() != rgn)\n-        break;\n-      Node* bol = iff->in(1);\n-      assert(!bol->is_OpaqueInitializedAssertionPredicate(), \"should not find an Initialized Assertion Predicate\");\n-      if (bol->is_OpaqueTemplateAssertionPredicate()) {\n-        \/\/ Clone the Assertion Predicate twice and initialize one with the initial\n-        \/\/ value of the loop induction variable. Leave the other predicate\n-        \/\/ to be initialized when increasing the stride during loop unrolling.\n-        prev_proj = clone_template_assertion_predicate(iff, opaque_init, predicate_proj, uncommon_proj,\n-                                                       current_proj, outer_loop, prev_proj);\n-        prev_proj = create_initialized_assertion_predicate(iff, init, stride, prev_proj);\n-\n-        \/\/ Rewire any control inputs from the cloned Assertion Predicates down to the main and post loop for data nodes\n-        \/\/ that are part of the main loop (and were cloned to the pre and post loop).\n-        for (DUIterator i = predicate_proj->outs(); predicate_proj->has_out(i); i++) {\n-          Node* loop_node = predicate_proj->out(i);\n-          Node* pre_loop_node = old_new[loop_node->_idx];\n-          \/\/ Change the control if 'loop_node' is part of the main loop. If there is an old->new mapping and the index of\n-          \/\/ 'pre_loop_node' is greater than idx_before_pre_post, then we know that 'loop_node' was cloned and is part of\n-          \/\/ the main loop (and 'pre_loop_node' is part of the pre loop).\n-          if (!loop_node->is_CFG() && (pre_loop_node != nullptr && pre_loop_node->_idx > idx_after_post_before_pre)) {\n-            \/\/ 'loop_node' is a data node and part of the main loop. Rewire the control to the projection of the zero-trip guard if node\n-            \/\/ of the main loop that is immediately preceding the cloned predicates.\n-            _igvn.replace_input_of(loop_node, 0, zero_trip_guard_proj_main);\n-            --i;\n-          } else if (loop_node->_idx > idx_before_pre_post && loop_node->_idx < idx_after_post_before_pre) {\n-            \/\/ 'loop_node' is a data node and part of the post loop. Rewire the control to the projection of the zero-trip guard if node\n-            \/\/ of the post loop that is immediately preceding the post loop header node (there are no cloned predicates for the post loop).\n-            assert(pre_loop_node == nullptr, \"a node belonging to the post loop should not have an old_new mapping at this stage\");\n-            _igvn.replace_input_of(loop_node, 0, zero_trip_guard_proj_post);\n-            --i;\n-          }\n-        }\n-\n-        \/\/ Remove the Assertion Predicate from the pre-loop\n-        _igvn.replace_input_of(iff, 1, _igvn.intcon(1));\n-      }\n-      predicate_proj = predicate_proj->in(0)->in(0);\n-    }\n-    _igvn.replace_input_of(outer_main_head, LoopNode::EntryControl, prev_proj);\n-    set_idom(outer_main_head, prev_proj, dd_main_head);\n-  }\n-}\n-\n@@ -1467,41 +1390,0 @@\n-\/\/ Clone the Template Assertion Predicate and set a new OpaqueLoopInitNode to create a new Template Assertion Predicate.\n-\/\/ This is done when creating a new Template Assertion Predicate for the main loop which requires a new init node.\n-\/\/ We keep the OpaqueTemplateAssertionPredicate node since it's still a template. Since the templates are eventually\n-\/\/ removed after loop opts, these are never executed. We therefore insert a Halt node instead of an uncommon trap.\n-Node* PhaseIdealLoop::clone_template_assertion_predicate(IfNode* iff, Node* new_init, Node* predicate, Node* uncommon_proj,\n-                                                         Node* control, IdealLoopTree* outer_loop, Node* new_control) {\n-  assert(assertion_predicate_has_loop_opaque_node(iff), \"must find OpaqueLoop* nodes for Template Assertion Predicate\");\n-  TemplateAssertionExpression template_assertion_expression(iff->in(1)->as_OpaqueTemplateAssertionPredicate());\n-  assert(new_init->is_OpaqueLoopInit(), \"only for creating new Template Assertion Predicates\");\n-  OpaqueTemplateAssertionPredicateNode* new_opaque_node =\n-      template_assertion_expression.clone_and_replace_init(new_init, control, this);\n-  AssertionPredicateIfCreator assertion_predicate_if_creator(this);\n-  IfTrueNode* success_proj =\n-      assertion_predicate_if_creator.create_for_template(new_control, iff->Opcode(), new_opaque_node\n-                                                         NOT_PRODUCT(COMMA iff->assertion_predicate_type()));\n-  assert(assertion_predicate_has_loop_opaque_node(success_proj->in(0)->as_If()),\n-         \"Template Assertion Predicates must have OpaqueLoop* nodes in the bool expression\");\n-  return success_proj;\n-}\n-\n-void PhaseIdealLoop::copy_assertion_predicates_to_main_loop(CountedLoopNode* pre_head, Node* init, Node* stride,\n-                                                            IdealLoopTree* outer_loop, LoopNode* outer_main_head,\n-                                                            const uint dd_main_head, const uint idx_before_pre_post,\n-                                                            const uint idx_after_post_before_pre,\n-                                                            Node* zero_trip_guard_proj_main,\n-                                                            Node* zero_trip_guard_proj_post,\n-                                                            const Node_List &old_new) {\n-  if (UseLoopPredicate) {\n-    Node* entry = pre_head->in(LoopNode::EntryControl);\n-    const Predicates predicates(entry);\n-    copy_assertion_predicates_to_main_loop_helper(predicates.loop_predicate_block(), init, stride, outer_loop,\n-                                                  outer_main_head, dd_main_head, idx_before_pre_post,\n-                                                  idx_after_post_before_pre, zero_trip_guard_proj_main,\n-                                                  zero_trip_guard_proj_post, old_new);\n-    copy_assertion_predicates_to_main_loop_helper(predicates.profiled_loop_predicate_block(), init, stride,\n-                                                  outer_loop, outer_main_head, dd_main_head, idx_before_pre_post,\n-                                                  idx_after_post_before_pre, zero_trip_guard_proj_main,\n-                                                  zero_trip_guard_proj_post, old_new);\n-  }\n-}\n-\n@@ -1556,1 +1438,0 @@\n-  const uint idx_before_pre_post = Compile::current()->unique();\n@@ -1560,1 +1441,0 @@\n-  const uint idx_after_post_before_pre = Compile::current()->unique();\n@@ -1575,0 +1455,2 @@\n+\n+  const uint first_node_index_in_pre_loop_body = Compile::current()->unique();\n@@ -1653,4 +1535,4 @@\n-  copy_assertion_predicates_to_main_loop(pre_head, pre_incr, stride, outer_loop, outer_main_head, dd_main_head,\n-                                         idx_before_pre_post, idx_after_post_before_pre, min_taken, post_head->in(1),\n-                                         old_new);\n-  copy_assertion_predicates_to_post_loop(outer_main_head, post_head, stride);\n+  DEBUG_ONLY(ensure_zero_trip_guard_proj(outer_main_head->in(LoopNode::EntryControl), true);)\n+  if (UseLoopPredicate) {\n+    initialize_assertion_predicates_for_main_loop(pre_head, main_head, first_node_index_in_pre_loop_body, old_new);\n+  }\n@@ -1781,1 +1663,0 @@\n-  copy_assertion_predicates_to_post_loop(main_head->skip_strip_mined(), post_head, main_head->stride());\n@@ -1816,0 +1697,1 @@\n+  const uint first_node_index_in_cloned_loop_body = C->unique();\n@@ -1884,0 +1766,4 @@\n+  DEBUG_ONLY(ensure_zero_trip_guard_proj(post_head->in(LoopNode::EntryControl), false);)\n+  if (UseLoopPredicate) {\n+    initialize_assertion_predicates_for_post_loop(main_head, post_head, first_node_index_in_cloned_loop_body);\n+  }\n@@ -1940,30 +1826,2 @@\n-\/\/ Go over the Assertion Predicates of the main loop and make a copy for the post loop with its initial iv value and\n-\/\/ stride as inputs.\n-void PhaseIdealLoop::copy_assertion_predicates_to_post_loop(LoopNode* main_loop_head, CountedLoopNode* post_loop_head,\n-                                                            Node* stride) {\n-  Node* opaq = post_loop_head->is_canonical_loop_entry();\n-  Node* init = opaq->in(1);\n-  Node* post_loop_entry = post_loop_head->in(LoopNode::EntryControl);\n-  Node* main_loop_entry = main_loop_head->in(LoopNode::EntryControl);\n-  IdealLoopTree* post_loop = get_loop(post_loop_head);\n-\n-  Node* ctrl = main_loop_entry;\n-  Node* prev_proj = post_loop_entry;\n-  while (ctrl != nullptr && ctrl->is_Proj() && ctrl->in(0)->is_If()) {\n-    IfNode* iff = ctrl->in(0)->as_If();\n-    ProjNode* proj = iff->proj_out(1 - ctrl->as_Proj()->_con);\n-    if (!proj->unique_ctrl_out()->is_Halt()) {\n-      break;\n-    }\n-    if (iff->in(1)->is_OpaqueTemplateAssertionPredicate()) {\n-      \/\/ Initialize from Template Assertion Predicate.\n-      prev_proj = create_initialized_assertion_predicate(iff, init, stride, prev_proj);\n-    }\n-    ctrl = ctrl->in(0)->in(0);\n-  }\n-  if (prev_proj != post_loop_entry) {\n-    _igvn.replace_input_of(post_loop_head, LoopNode::EntryControl, prev_proj);\n-    set_idom(post_loop_head, prev_proj, dom_depth(post_loop_head));\n-  }\n-}\n-\n+\/\/ Source Loop: Cloned   - peeled_loop_head\n+\/\/ Target Loop: Original - remaining_loop_head\n@@ -1975,1 +1833,20 @@\n-  create_assertion_predicates_at_loop(peeled_loop_head, remaining_loop_head, node_in_original_loop_body);\n+  create_assertion_predicates_at_loop(peeled_loop_head, remaining_loop_head, node_in_original_loop_body, false);\n+}\n+\n+\/\/ Source Loop: Cloned   - pre_loop_head\n+\/\/ Target Loop: Original - main_loop_head\n+void PhaseIdealLoop::initialize_assertion_predicates_for_main_loop(CountedLoopNode* pre_loop_head,\n+                                                                   CountedLoopNode* main_loop_head,\n+                                                                   const uint first_node_index_in_cloned_loop_body,\n+                                                                   const Node_List& old_new) {\n+  const NodeInOriginalLoopBody node_in_original_loop_body(first_node_index_in_cloned_loop_body, old_new);\n+  create_assertion_predicates_at_loop(pre_loop_head, main_loop_head, node_in_original_loop_body, true);\n+}\n+\n+\/\/ Source Loop: Original - main_loop_head\n+\/\/ Target Loop: Cloned   - post_loop_head\n+void PhaseIdealLoop::initialize_assertion_predicates_for_post_loop(CountedLoopNode* main_loop_head,\n+                                                                   CountedLoopNode* post_loop_head,\n+                                                                   const uint first_node_index_in_cloned_loop_body) {\n+  const NodeInClonedLoopBody node_in_cloned_loop_body(first_node_index_in_cloned_loop_body);\n+  create_assertion_predicates_at_loop(main_loop_head, post_loop_head, node_in_cloned_loop_body, false);\n@@ -1979,2 +1856,3 @@\n-                                                         CountedLoopNode* target_loop_head,\n-                                                         const NodeInLoopBody& _node_in_loop_body) {\n+                                                          CountedLoopNode* target_loop_head,\n+                                                          const NodeInLoopBody& _node_in_loop_body,\n+                                                          const bool clone_template) {\n@@ -1986,1 +1864,1 @@\n-                                                                       _node_in_loop_body);\n+                                                                       _node_in_loop_body, clone_template);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":39,"deletions":161,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -942,1 +942,1 @@\n-  void ensure_zero_trip_guard_proj(Node* node, bool is_main_loop);\n+  static void ensure_zero_trip_guard_proj(Node* node, bool is_main_loop);\n@@ -944,11 +944,0 @@\n-  void copy_assertion_predicates_to_main_loop_helper(const PredicateBlock* predicate_block, Node* init, Node* stride,\n-                                                     IdealLoopTree* outer_loop, LoopNode* outer_main_head,\n-                                                     uint dd_main_head, uint idx_before_pre_post,\n-                                                     uint idx_after_post_before_pre, Node* zero_trip_guard_proj_main,\n-                                                     Node* zero_trip_guard_proj_post, const Node_List &old_new);\n-  void copy_assertion_predicates_to_main_loop(CountedLoopNode* pre_head, Node* init, Node* stride, IdealLoopTree* outer_loop,\n-                                              LoopNode* outer_main_head, uint dd_main_head, uint idx_before_pre_post,\n-                                              uint idx_after_post_before_pre, Node* zero_trip_guard_proj_main,\n-                                              Node* zero_trip_guard_proj_post, const Node_List& old_new);\n-  Node* clone_template_assertion_predicate(IfNode* iff, Node* new_init, Node* predicate, Node* uncommon_proj, Node* control,\n-                                           IdealLoopTree* outer_loop, Node* new_control);\n@@ -958,0 +947,1 @@\n+  DEBUG_ONLY(static bool assertion_predicate_has_loop_opaque_node(IfNode* iff);)\n@@ -960,1 +950,0 @@\n-  DEBUG_ONLY(static bool assertion_predicate_has_loop_opaque_node(IfNode* iff);)\n@@ -963,2 +952,0 @@\n-  void copy_assertion_predicates_to_post_loop(LoopNode* main_loop_head, CountedLoopNode* post_loop_head,\n-                                              Node* stride);\n@@ -969,0 +956,6 @@\n+  void initialize_assertion_predicates_for_main_loop(CountedLoopNode* pre_loop_head,\n+                                                     CountedLoopNode* main_loop_head,\n+                                                     uint first_node_index_in_cloned_loop_body,\n+                                                     const Node_List& old_new);\n+  void initialize_assertion_predicates_for_post_loop(CountedLoopNode* main_loop_head, CountedLoopNode* post_loop_head,\n+                                                     uint first_node_index_in_cloned_loop_body);\n@@ -970,1 +963,1 @@\n-                                           const NodeInLoopBody& _node_in_loop_body);\n+                                           const NodeInLoopBody& _node_in_loop_body, bool clone_template);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":9,"deletions":16,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -165,0 +165,17 @@\n+\/\/ Clone this Template Assertion Predicate and replace the OpaqueLoopInitNode with the provided 'new_opaque_init' node.\n+IfTrueNode* TemplateAssertionPredicate::clone_and_replace_init(Node* new_control, OpaqueLoopInitNode* new_opaque_init,\n+                                                               PhaseIdealLoop* phase) const {\n+  assert(PhaseIdealLoop::assertion_predicate_has_loop_opaque_node(_if_node),\n+         \"must find OpaqueLoop* nodes for Template Assertion Predicate\");\n+  TemplateAssertionExpression template_assertion_expression(opaque_node());\n+  OpaqueTemplateAssertionPredicateNode* new_opaque_node =\n+      template_assertion_expression.clone_and_replace_init(new_opaque_init, new_control, phase);\n+  AssertionPredicateIfCreator assertion_predicate_if_creator(phase);\n+  IfTrueNode* success_proj = assertion_predicate_if_creator.create_for_template(new_control, _if_node->Opcode(),\n+                                                                                new_opaque_node NOT_PRODUCT(COMMA\n+                                                                                _if_node->assertion_predicate_type()));\n+  assert(PhaseIdealLoop::assertion_predicate_has_loop_opaque_node(success_proj->in(0)->as_If()),\n+         \"Template Assertion Predicates must have OpaqueLoop* nodes in the bool expression\");\n+  return success_proj;\n+}\n+\n@@ -746,0 +763,9 @@\n+  if (_clone_template) {\n+    _new_control = clone_template_and_replace_init_input(template_assertion_predicate);\n+  }\n+  _new_control = initialize_from_template(template_assertion_predicate);\n+}\n+\n+\/\/ Create an Initialized Assertion Predicate from the provided Template Assertion Predicate.\n+IfTrueNode* CreateAssertionPredicatesVisitor::initialize_from_template(\n+const TemplateAssertionPredicate& template_assertion_predicate) const {\n@@ -750,1 +776,9 @@\n-  _new_control = initialized_predicate;\n+  return initialized_predicate;\n+}\n+\n+\/\/ Clone the provided 'template_assertion_predicate' and set '_init' as new input for the OpaqueLoopInitNode.\n+IfTrueNode* CreateAssertionPredicatesVisitor::clone_template_and_replace_init_input(\n+    const TemplateAssertionPredicate& template_assertion_predicate) {\n+  OpaqueLoopInitNode* opaque_init = new OpaqueLoopInitNode(_phase->C, _init);\n+  _phase->register_new_node(opaque_init, _new_control);\n+  return template_assertion_predicate.clone_and_replace_init(_new_control, opaque_init, _phase);\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -394,0 +394,4 @@\n+  OpaqueTemplateAssertionPredicateNode* opaque_node() const {\n+    return _if_node->in(1)->as_OpaqueTemplateAssertionPredicate();\n+  }\n+\n@@ -402,0 +406,1 @@\n+  IfTrueNode* clone_and_replace_init(Node* new_control, OpaqueLoopInitNode* new_opaque_init, PhaseIdealLoop* phase) const;\n@@ -944,0 +949,16 @@\n+\/\/ This class checks whether a node is in the cloned loop body and not the original one from which the loop was cloned.\n+class NodeInClonedLoopBody : public NodeInLoopBody {\n+  const uint _first_node_index_in_cloned_loop_body;\n+\n+ public:\n+  explicit NodeInClonedLoopBody(const uint first_node_index_in_cloned_loop_body)\n+      : _first_node_index_in_cloned_loop_body(first_node_index_in_cloned_loop_body) {}\n+  NONCOPYABLE(NodeInClonedLoopBody);\n+\n+  \/\/ Check if 'node' is a clone. This can easily be achieved by comparing its node index to the first node index\n+  \/\/ inside the cloned loop body (all of them are clones).\n+  bool check(Node* node) const override {\n+    return node->_idx >= _first_node_index_in_cloned_loop_body;\n+  }\n+};\n+\n@@ -954,0 +975,4 @@\n+  const bool _clone_template;\n+\n+  IfTrueNode* clone_template_and_replace_init_input(const TemplateAssertionPredicate& template_assertion_predicate);\n+  IfTrueNode* initialize_from_template(const TemplateAssertionPredicate& template_assertion_predicate) const;\n@@ -957,1 +982,1 @@\n-                                   const NodeInLoopBody& node_in_loop_body)\n+                                   const NodeInLoopBody& node_in_loop_body, const bool clone_template)\n@@ -964,1 +989,2 @@\n-        _node_in_loop_body(node_in_loop_body) {}\n+        _node_in_loop_body(node_in_loop_body),\n+        _clone_template(clone_template) {}\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"}]}