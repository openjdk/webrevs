{"files":[{"patch":"@@ -2396,4 +2396,0 @@\n-  \/\/ invokehandle uses an index into the resolved references array\n-  __ ldr(method, Address(cache, in_bytes(ResolvedMethodEntry::method_offset())));\n-  __ load_unsigned_short(ref_index, Address(cache, in_bytes(ResolvedMethodEntry::resolved_references_index_offset())));\n-\n@@ -2403,0 +2399,2 @@\n+  \/\/ invokehandle uses an index into the resolved references array\n+  __ load_unsigned_short(ref_index, Address(cache, in_bytes(ResolvedMethodEntry::resolved_references_index_offset())));\n@@ -2406,5 +2404,3 @@\n-  __ push(method);\n-  __ mov(method, ref_index);\n-  __ load_resolved_reference_at_index(ref_index, method);\n-  __ pop(method);\n-  __ push(ref_index);  \/\/ push appendix (MethodType, CallSite, etc.)\n+  Register appendix = method;\n+  __ load_resolved_reference_at_index(appendix, ref_index);\n+  __ push(appendix);  \/\/ push appendix (MethodType, CallSite, etc.)\n@@ -2412,0 +2408,2 @@\n+\n+  __ ldr(method, Address(cache, in_bytes(ResolvedMethodEntry::method_offset())));\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -87,2 +87,0 @@\n-  void load_resolved_method_at_index(int byte_no, Register cache, Register method);\n-\n@@ -129,1 +127,0 @@\n-  void get_cache_and_index_at_bcp(Register cache, int bcp_offset, size_t index_size = sizeof(u2));\n@@ -132,0 +129,1 @@\n+  void load_method_entry(Register cache, Register index, int bcp_offset = 1);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"oops\/resolvedMethodEntry.hpp\"\n@@ -456,7 +457,0 @@\n-void InterpreterMacroAssembler::get_cache_and_index_at_bcp(Register cache, int bcp_offset,\n-                                                           size_t index_size) {\n-  get_cache_index_at_bcp(cache, bcp_offset, index_size);\n-  sldi(cache, cache, exact_log2(in_words(ConstantPoolCacheEntry::size()) * BytesPerWord));\n-  add(cache, R27_constPoolCache, cache);\n-}\n-\n@@ -487,1 +481,1 @@\n-  \/\/ Get index out of bytecode pointer, get_cache_entry_pointer_at_bcp\n+  \/\/ Get index out of bytecode pointer\n@@ -494,0 +488,1 @@\n+  addi(cache, cache, Array<ResolvedIndyEntry>::base_offset_in_bytes());\n@@ -514,0 +509,12 @@\n+void InterpreterMacroAssembler::load_method_entry(Register cache, Register index, int bcp_offset) {\n+  \/\/ Get index out of bytecode pointer\n+  get_cache_index_at_bcp(index, bcp_offset, sizeof(u2));\n+  \/\/ Scale the index to be the entry index * sizeof(ResolvedMethodEntry)\n+  mulli(index, index, sizeof(ResolvedMethodEntry));\n+\n+  \/\/ Get address of field entries array\n+  ld_ptr(cache, ConstantPoolCache::method_entries_offset(), R27_constPoolCache);\n+  addi(cache, cache, Array<ResolvedMethodEntry>::base_offset_in_bytes());\n+  add(cache, cache, index); \/\/ method_entries + base_offset + scaled index\n+}\n+\n@@ -567,12 +574,0 @@\n-void InterpreterMacroAssembler::load_resolved_method_at_index(int byte_no,\n-                                                              Register cache,\n-                                                              Register method) {\n-  const int method_offset = in_bytes(\n-    ConstantPoolCache::base_offset() +\n-      ((byte_no == TemplateTable::f2_byte)\n-       ? ConstantPoolCacheEntry::f2_offset()\n-       : ConstantPoolCacheEntry::f1_offset()));\n-\n-  ld(method, method_offset, cache); \/\/ get f1 Method*\n-}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":15,"deletions":20,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"oops\/resolvedMethodEntry.hpp\"\n@@ -650,1 +651,1 @@\n-    __ lhz(size, Array<ResolvedIndyEntry>::base_offset_in_bytes() + in_bytes(ResolvedIndyEntry::num_parameters_offset()), cache);\n+    __ lhz(size, in_bytes(ResolvedIndyEntry::num_parameters_offset()), cache);\n@@ -652,8 +653,3 @@\n-    __ get_cache_and_index_at_bcp(cache, 1, index_size);\n-\n-    \/\/ Get least significant byte of 64 bit value:\n-#if defined(VM_LITTLE_ENDIAN)\n-    __ lbz(size, in_bytes(ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset()), cache);\n-#else\n-    __ lbz(size, in_bytes(ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset()) + 7, cache);\n-#endif\n+    assert(index_size == sizeof(u2), \"Can only be u2\");\n+    __ load_method_entry(cache, size \/* tmp *\/);\n+    __ lhz(size, in_bytes(ResolvedMethodEntry::num_parameters_offset()), cache);\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,3 +29,2 @@\n-  static void prepare_invoke(int byte_no, Register Rmethod, Register Rret_addr, Register Rindex, Register Rrecv, Register Rflags,\n-                             Register Rscratch1, Register Rscratch2);\n-  static void invokevfinal_helper(Register Rmethod, Register Rflags, Register Rscratch1, Register Rscratch2);\n+  static void prepare_invoke(Register Rcache, Register Rret_addr, Register Rrecv, Register Rscratch);\n+  static void invokevfinal_helper(Register Rcache, Register Rscratch1, Register Rscratch2, Register Rscratch3);\n@@ -33,1 +32,1 @@\n-  static void invokeinterface_object_method(Register Rrecv_klass, Register Rret, Register Rflags, Register Rindex, Register Rtemp, Register Rtemp2);\n+  static void invokeinterface_object_method(Register Rrecv_klass, Register Rret, Register Rflags, Register Rcache, Register Rtemp, Register Rtemp2);\n","filename":"src\/hotspot\/cpu\/ppc\/templateTable_ppc.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"oops\/resolvedMethodEntry.hpp\"\n@@ -392,1 +393,1 @@\n-  __ andi(off, flags, ConstantPoolCacheEntry::field_index_mask);\n+  __ andi(off, flags, ConstantPoolCache::field_index_mask);\n@@ -395,1 +396,1 @@\n-  __ rldicl(flags, flags, 64-ConstantPoolCacheEntry::tos_state_shift, 64-ConstantPoolCacheEntry::tos_state_bits);\n+  __ rldicl(flags, flags, 64-ConstantPoolCache::tos_state_shift, 64-ConstantPoolCache::tos_state_bits);\n@@ -2194,1 +2195,0 @@\n-\/\/   - Rresult: Either noreg or output for f1\/f2.\n@@ -2198,3 +2198,2 @@\n-void TemplateTable::resolve_cache_and_index(int byte_no, Register Rcache, Register Rscratch, size_t index_size) {\n-\n-  __ get_cache_and_index_at_bcp(Rcache, 1, index_size);\n+void TemplateTable::resolve_cache_and_index_for_method(int byte_no, Register Rcache, Register Rscratch) {\n+  assert(byte_no == f1_byte || byte_no == f2_byte, \"byte_no out of range\");\n@@ -2202,0 +2201,1 @@\n+  Register Rindex = Rscratch;\n@@ -2211,7 +2211,5 @@\n-  assert(byte_no == f1_byte || byte_no == f2_byte, \"byte_no out of range\");\n-  \/\/ We are resolved if the indices offset contains the current bytecode.\n-#if defined(VM_LITTLE_ENDIAN)\n-  __ lbz(Rscratch, in_bytes(ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::indices_offset()) + byte_no + 1, Rcache);\n-#else\n-  __ lbz(Rscratch, in_bytes(ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::indices_offset()) + 7 - (byte_no + 1), Rcache);\n-#endif\n+  const int bytecode_offset = (byte_no == f1_byte) ? in_bytes(ResolvedMethodEntry::bytecode1_offset())\n+                                                   : in_bytes(ResolvedMethodEntry::bytecode2_offset());\n+  __ load_method_entry(Rcache, Rindex);\n+  \/\/ Load-acquire the bytecode to match store-release in InterpreterRuntime\n+  __ lbz(Rscratch, bytecode_offset, Rcache);\n@@ -2230,1 +2228,1 @@\n-  __ get_cache_and_index_at_bcp(Rcache, 1, index_size);\n+  __ load_method_entry(Rcache, Rindex);\n@@ -2241,1 +2239,1 @@\n-    __ load_resolved_method_at_index(byte_no, Rcache, method);\n+    __ ld(method, in_bytes(ResolvedMethodEntry::method_offset()), Rcache);\n@@ -2311,16 +2309,4 @@\n-\/\/ Load the constant pool cache entry at field accesses into registers.\n-\/\/ The Rcache and Rindex registers must be set before call.\n-\/\/ Input:\n-\/\/   - Rcache, Rindex\n-\/\/ Output:\n-\/\/   - Robj, Roffset, Rflags\n-\/\/ Kills:\n-\/\/   - R11, R12\n-void TemplateTable::load_field_cp_cache_entry(Register Robj,\n-                                              Register Rcache,\n-                                              Register Rindex \/* unused on PPC64 *\/,\n-                                              Register Roffset,\n-                                              Register Rflags,\n-                                              bool is_static) {\n-  assert_different_registers(Rcache, Rflags, Roffset, R11_scratch1, R12_scratch2);\n-  assert(Rindex == noreg, \"parameter not used on PPC64\");\n+void TemplateTable::load_resolved_method_entry_special_or_static(Register cache,\n+                                                                 Register method,\n+                                                                 Register flags) {\n+  assert_different_registers(cache, method, flags);\n@@ -2328,8 +2314,4 @@\n-  ByteSize cp_base_offset = ConstantPoolCache::base_offset();\n-  __ ld(Rflags, in_bytes(cp_base_offset) + in_bytes(ConstantPoolCacheEntry::flags_offset()), Rcache);\n-  __ ld(Roffset, in_bytes(cp_base_offset) + in_bytes(ConstantPoolCacheEntry::f2_offset()), Rcache);\n-  if (is_static) {\n-    __ ld(Robj, in_bytes(cp_base_offset) + in_bytes(ConstantPoolCacheEntry::f1_offset()), Rcache);\n-    __ ld(Robj, in_bytes(Klass::java_mirror_offset()), Robj);\n-    __ resolve_oop_handle(Robj, R11_scratch1, R12_scratch2, MacroAssembler::PRESERVATION_NONE);\n-    \/\/ Acquire not needed here. Following access has an address dependency on this value.\n+  \/\/ determine constant pool cache field offsets\n+  resolve_cache_and_index_for_method(f1_byte, cache, method \/* tmp *\/);\n+  if (flags != noreg) {\n+    __ lbz(flags, in_bytes(ResolvedMethodEntry::flags_offset()), cache);\n@@ -2337,0 +2319,57 @@\n+  __ ld(method, in_bytes(ResolvedMethodEntry::method_offset()), cache);\n+}\n+\n+void TemplateTable::load_resolved_method_entry_handle(Register cache,\n+                                                      Register method,\n+                                                      Register ref_index,\n+                                                      Register flags) {\n+  \/\/ setup registers\n+  assert_different_registers(cache, method, ref_index, flags);\n+\n+  \/\/ determine constant pool cache field offsets\n+  resolve_cache_and_index_for_method(f1_byte, cache, method \/* tmp *\/);\n+  __ lbz(flags, in_bytes(ResolvedMethodEntry::flags_offset()), cache);\n+\n+  \/\/ maybe push appendix to arguments (just before return address)\n+  Label L_no_push;\n+  __ testbitdi(CCR0, R0, flags, ResolvedMethodEntry::has_appendix_shift);\n+  __ bfalse(CCR0, L_no_push);\n+  \/\/ invokehandle uses an index into the resolved references array\n+  __ lhz(ref_index, in_bytes(ResolvedMethodEntry::resolved_references_index_offset()), cache);\n+  \/\/ Push the appendix as a trailing parameter.\n+  \/\/ This must be done before we get the receiver,\n+  \/\/ since the parameter_size includes it.\n+  Register appendix = method;\n+  assert(cache->is_nonvolatile(), \"C-call in resolve_oop_handle\");\n+  __ load_resolved_reference_at_index(appendix, ref_index, R11_scratch1, R12_scratch2);\n+  __ verify_oop(appendix);\n+  __ push_ptr(appendix); \/\/ push appendix (MethodType, CallSite, etc.)\n+  __ bind(L_no_push);\n+\n+  __ ld(method, in_bytes(ResolvedMethodEntry::method_offset()), cache);\n+}\n+\n+void TemplateTable::load_resolved_method_entry_interface(Register cache,\n+                                                         Register klass,\n+                                                         Register method_or_table_index,\n+                                                         Register flags) {\n+  \/\/ setup registers\n+  assert_different_registers(method_or_table_index, cache, flags);\n+  assert(klass == noreg, \"to be determined by caller\");\n+  assert(method_or_table_index == noreg, \"to be determined by caller\");\n+\n+  \/\/ determine constant pool cache field offsets\n+  resolve_cache_and_index_for_method(f1_byte, cache, flags \/* tmp *\/);\n+  __ lbz(flags, in_bytes(ResolvedMethodEntry::flags_offset()), cache);\n+}\n+\n+void TemplateTable::load_resolved_method_entry_virtual(Register cache,\n+                                                       Register method_or_table_index,\n+                                                       Register flags) {\n+  \/\/ setup registers\n+  assert_different_registers(cache, flags);\n+  assert(method_or_table_index == noreg, \"to be determined by caller\");\n+\n+  \/\/ determine constant pool cache field offsets\n+  resolve_cache_and_index_for_method(f2_byte, cache, flags \/* tmp *\/);\n+  __ lbz(flags, in_bytes(ResolvedMethodEntry::flags_offset()), cache);\n@@ -2351,1 +2390,0 @@\n-  const int array_base_offset = Array<ResolvedIndyEntry>::base_offset_in_bytes();\n@@ -2357,1 +2395,1 @@\n-  __ ld_ptr(method, array_base_offset + in_bytes(ResolvedIndyEntry::method_offset()), cache);\n+  __ ld_ptr(method, in_bytes(ResolvedIndyEntry::method_offset()), cache);\n@@ -2371,1 +2409,1 @@\n-  __ ld_ptr(method, array_base_offset + in_bytes(ResolvedIndyEntry::method_offset()), cache);\n+  __ ld_ptr(method, in_bytes(ResolvedIndyEntry::method_offset()), cache);\n@@ -2380,1 +2418,1 @@\n-  __ lbz(index, array_base_offset + in_bytes(ResolvedIndyEntry::flags_offset()), cache);\n+  __ lbz(index, in_bytes(ResolvedIndyEntry::flags_offset()), cache);\n@@ -2385,1 +2423,1 @@\n-  __ lhz(index, array_base_offset + in_bytes(ResolvedIndyEntry::resolved_references_index_offset()), cache);\n+  __ lhz(index, in_bytes(ResolvedIndyEntry::resolved_references_index_offset()), cache);\n@@ -2399,1 +2437,1 @@\n-    __ lbz(index, array_base_offset + in_bytes(ResolvedIndyEntry::result_type_offset()), cache);\n+    __ lbz(index, in_bytes(ResolvedIndyEntry::result_type_offset()), cache);\n@@ -2407,48 +2445,0 @@\n-\/\/ Load the constant pool cache entry at invokes into registers.\n-\/\/ Resolve if necessary.\n-\n-\/\/ Input Registers:\n-\/\/   - None, bcp is used, though\n-\/\/\n-\/\/ Return registers:\n-\/\/   - Rmethod       (f1 field or f2 if invokevirtual)\n-\/\/   - Ritable_index (f2 field)\n-\/\/   - Rflags        (flags field)\n-\/\/\n-\/\/ Kills:\n-\/\/   - R21\n-\/\/\n-void TemplateTable::load_invoke_cp_cache_entry(int byte_no,\n-                                               Register Rmethod,\n-                                               Register Ritable_index,\n-                                               Register Rflags,\n-                                               bool is_invokevirtual,\n-                                               bool is_invokevfinal,\n-                                               bool is_invokedynamic \/*unused*\/) {\n-\n-  ByteSize cp_base_offset = ConstantPoolCache::base_offset();\n-  \/\/ Determine constant pool cache field offsets.\n-  assert(is_invokevirtual == (byte_no == f2_byte), \"is_invokevirtual flag redundant\");\n-  const int method_offset = in_bytes(cp_base_offset + (is_invokevirtual ? ConstantPoolCacheEntry::f2_offset() : ConstantPoolCacheEntry::f1_offset()));\n-  const int flags_offset  = in_bytes(cp_base_offset + ConstantPoolCacheEntry::flags_offset());\n-  \/\/ Access constant pool cache fields.\n-  const int index_offset  = in_bytes(cp_base_offset + ConstantPoolCacheEntry::f2_offset());\n-\n-  Register Rcache = R21_tmp1; \/\/ Note: same register as R21_sender_SP.\n-\n-  if (is_invokevfinal) {\n-    assert(Ritable_index == noreg, \"register not used\");\n-    \/\/ Already resolved.\n-    __ get_cache_and_index_at_bcp(Rcache, 1);\n-  } else {\n-    resolve_cache_and_index(byte_no, Rcache, \/* temp *\/ Rmethod, sizeof(u2));\n-  }\n-\n-  __ ld(Rmethod, method_offset, Rcache);\n-  __ ld(Rflags, flags_offset, Rcache);\n-\n-  if (Ritable_index != noreg) {\n-    __ ld(Ritable_index, index_offset, Rcache);\n-  }\n-}\n-\n@@ -3425,17 +3415,1 @@\n-\/\/ Common code for invoke\n-\/\/\n-\/\/ Input:\n-\/\/   - byte_no\n-\/\/\n-\/\/ Output:\n-\/\/   - Rmethod:        The method to invoke next or i-klass (invokeinterface).\n-\/\/   - Rret_addr:      The return address to return to.\n-\/\/   - Rindex:         MethodType (invokehandle), CallSite obj (invokedynamic) or Method (invokeinterface)\n-\/\/   - Rrecv:          Cache for \"this\" pointer, might be noreg if static call.\n-\/\/   - Rflags:         Method flags from const pool cache.\n-\/\/\n-\/\/  Kills:\n-\/\/   - Rscratch1\n-\/\/\n-void TemplateTable::prepare_invoke(int byte_no,\n-                                   Register Rmethod,  \/\/ linked method (or i-klass)\n+void TemplateTable::prepare_invoke(Register Rcache,\n@@ -3443,1 +3417,0 @@\n-                                   Register Rindex,   \/\/ itable index, MethodType, Method, etc.\n@@ -3445,3 +3418,1 @@\n-                                   Register Rflags,   \/\/ If caller wants to test it.\n-                                   Register Rscratch1,\n-                                   Register Rscratch2\n+                                   Register Rscratch\n@@ -3451,6 +3422,1 @@\n-  const bool is_invokeinterface  = code == Bytecodes::_invokeinterface;\n-  const bool is_invokedynamic    = false; \/\/ should not reach here with invokedynamic\n-  const bool is_invokehandle     = code == Bytecodes::_invokehandle;\n-  const bool is_invokevirtual    = code == Bytecodes::_invokevirtual;\n-  const bool is_invokespecial    = code == Bytecodes::_invokespecial;\n-  const bool load_receiver       = (Rrecv != noreg);\n+  const bool load_receiver = (Rrecv != noreg);\n@@ -3459,25 +3425,0 @@\n-  assert_different_registers(Rmethod, Rindex, Rflags, Rscratch1);\n-  assert_different_registers(Rmethod, Rrecv, Rflags, Rscratch1);\n-  assert_different_registers(Rret_addr, Rscratch1);\n-\n-  load_invoke_cp_cache_entry(byte_no, Rmethod, Rindex, Rflags, is_invokevirtual, false, is_invokedynamic);\n-\n-  \/\/ Saving of SP done in call_from_interpreter.\n-\n-  \/\/ Maybe push \"appendix\" to arguments.\n-  if (is_invokehandle) {\n-    Label Ldone;\n-    Register reference = Rscratch1;\n-\n-    __ rldicl_(R0, Rflags, 64-ConstantPoolCacheEntry::has_appendix_shift, 63);\n-    __ beq(CCR0, Ldone);\n-    \/\/ Push \"appendix\" (MethodType, CallSite, etc.).\n-    \/\/ This must be done before we get the receiver,\n-    \/\/ since the parameter_size includes it.\n-    __ load_resolved_reference_at_index(reference, Rindex, \/* temp *\/ Rret_addr, Rscratch2);\n-    __ verify_oop(reference);\n-    __ push_ptr(reference);\n-\n-    __ bind(Ldone);\n-  }\n-\n@@ -3486,2 +3427,2 @@\n-    Register Rparam_count = Rscratch1;\n-    __ andi(Rparam_count, Rflags, ConstantPoolCacheEntry::parameter_size_mask);\n+    Register Rparam_count = Rscratch;\n+    __ lhz(Rparam_count, in_bytes(ResolvedMethodEntry::num_parameters_offset()), Rcache);\n@@ -3494,1 +3435,1 @@\n-    Register Rtable_addr = Rscratch1;\n+    Register Rtable_addr = Rscratch;\n@@ -3498,2 +3439,1 @@\n-    \/\/ Get return type. It's coded into the upper 4 bits of the lower half of the 64 bit value.\n-    __ rldicl(Rret_type, Rflags, 64-ConstantPoolCacheEntry::tos_state_shift, 64-ConstantPoolCacheEntry::tos_state_bits);\n+    __ lbz(Rret_type, in_bytes(ResolvedMethodEntry::type_offset()), Rcache);\n@@ -3530,3 +3470,1 @@\n-  Register Rtable_addr = R11_scratch1,\n-           Rret_type = R12_scratch2,\n-           Rret_addr = R5_ARG3,\n+  Register Rret_addr = R5_ARG3,\n@@ -3537,2 +3475,2 @@\n-           Rnum_params = R4_ARG2,\n-           Rnew_bc = R6_ARG4;\n+           Rnew_bc = R6_ARG4,\n+           Rcache = R7_ARG5;\n@@ -3542,1 +3480,1 @@\n-  load_invoke_cp_cache_entry(byte_no, Rvtableindex_or_method, noreg, Rflags, \/*virtual*\/ true, false, false);\n+  load_resolved_method_entry_virtual(Rcache, noreg, Rflags);\n@@ -3544,1 +3482,2 @@\n-  __ testbitdi(CCR0, R0, Rflags, ConstantPoolCacheEntry::is_vfinal_shift);\n+  \/\/ Handle final method separately.\n+  __ testbitdi(CCR0, R0, Rflags, ResolvedMethodEntry::is_vfinal_shift);\n@@ -3550,1 +3489,1 @@\n-  invokevfinal_helper(Rvtableindex_or_method, Rflags, R11_scratch1, R12_scratch2);\n+  invokevfinal_helper(Rcache, R11_scratch1, R12_scratch2, Rflags \/* tmp *\/);\n@@ -3554,4 +3493,1 @@\n-  \/\/ Load \"this\" pointer (receiver).\n-  __ rldicl(Rnum_params, Rflags, 64, 48);\n-  __ load_receiver(Rnum_params, Rrecv);\n-  __ verify_oop(Rrecv);\n+  prepare_invoke(Rcache, Rret_addr, Rrecv, R11_scratch1);\n@@ -3559,5 +3495,4 @@\n-  \/\/ Get return type. It's coded into the upper 4 bits of the lower half of the 64 bit value.\n-  __ rldicl(Rret_type, Rflags, 64-ConstantPoolCacheEntry::tos_state_shift, 64-ConstantPoolCacheEntry::tos_state_bits);\n-  __ load_dispatch_table(Rtable_addr, Interpreter::invoke_return_entry_table());\n-  __ sldi(Rret_type, Rret_type, LogBytesPerWord);\n-  __ ldx(Rret_addr, Rret_type, Rtable_addr);\n+  \/\/ Get vtable index.\n+  __ lhz(Rvtableindex_or_method, in_bytes(ResolvedMethodEntry::table_index_offset()), Rcache);\n+\n+  \/\/ Get receiver klass.\n@@ -3575,4 +3510,3 @@\n-  Register Rflags  = R22_tmp2,\n-           Rmethod = R31;\n-  load_invoke_cp_cache_entry(byte_no, Rmethod, noreg, Rflags, \/*virtual*\/ true, \/*is_invokevfinal*\/ true, false);\n-  invokevfinal_helper(Rmethod, Rflags, R11_scratch1, R12_scratch2);\n+  Register Rcache  = R31;\n+  __ load_method_entry(Rcache, R11_scratch1);\n+  invokevfinal_helper(Rcache, R11_scratch1, R12_scratch2, R22_tmp2);\n@@ -3581,1 +3515,1 @@\n-void TemplateTable::invokevfinal_helper(Register Rmethod, Register Rflags, Register Rscratch1, Register Rscratch2) {\n+void TemplateTable::invokevfinal_helper(Register Rcache, Register Rscratch1, Register Rscratch2, Register Rscratch3) {\n@@ -3583,1 +3517,1 @@\n-  assert_different_registers(Rmethod, Rflags, Rscratch1, Rscratch2);\n+  assert_different_registers(Rcache, Rscratch1, Rscratch2, Rscratch3);\n@@ -3586,5 +3520,2 @@\n-  Register Rrecv = Rscratch2;\n-  Register Rnum_params = Rrecv;\n-\n-  __ ld(Rnum_params, in_bytes(Method::const_offset()), Rmethod);\n-  __ lhz(Rnum_params \/* number of params *\/, in_bytes(ConstMethod::size_of_parameters_offset()), Rnum_params);\n+  Register Rmethod = Rscratch3;\n+  __ ld(Rmethod, in_bytes(ResolvedMethodEntry::method_offset()), Rcache);\n@@ -3593,3 +3524,3 @@\n-  Register Rtable_addr = Rscratch1,\n-           Rret_addr   = Rflags,\n-           Rret_type   = Rret_addr;\n+  Register Rtable_addr = Rscratch2,\n+           Rret_addr   = Rcache,\n+           Rret_type   = Rscratch1;\n@@ -3597,1 +3528,1 @@\n-  __ rldicl(Rret_type, Rflags, 64-ConstantPoolCacheEntry::tos_state_shift, 64-ConstantPoolCacheEntry::tos_state_bits);\n+  __ lbz(Rret_type, in_bytes(ResolvedMethodEntry::type_offset()), Rcache);\n@@ -3600,1 +3531,6 @@\n-  __ ldx(Rret_addr, Rret_type, Rtable_addr);\n+  __ ldx(Rret_addr, Rret_type, Rtable_addr); \/\/ kills Rcache\n+\n+  Register Rnum_params = Rscratch2,\n+           Rrecv       = Rscratch2;\n+  __ ld(Rnum_params, in_bytes(Method::const_offset()), Rmethod);\n+  __ lhz(Rnum_params \/* number of params *\/, in_bytes(ConstMethod::size_of_parameters_offset()), Rnum_params);\n@@ -3618,1 +3554,1 @@\n-  Register Rtable_addr = R3_ARG1,\n+  Register Rcache      = R3_ARG1,\n@@ -3620,2 +3556,1 @@\n-           Rflags      = R5_ARG3,\n-           Rreceiver   = R6_ARG4,\n+           Rreceiver   = R5_ARG3,\n@@ -3624,1 +3559,4 @@\n-  prepare_invoke(byte_no, Rmethod, Rret_addr, noreg, Rreceiver, Rflags, R11_scratch1, R12_scratch2);\n+  load_resolved_method_entry_special_or_static(Rcache,  \/\/ ResolvedMethodEntry*\n+                                               Rmethod, \/\/ Method* or itable index\n+                                               noreg);  \/\/ flags\n+  prepare_invoke(Rcache, Rret_addr, Rreceiver, R11_scratch1); \/\/ recv\n@@ -3639,3 +3577,2 @@\n-  Register Rtable_addr = R3_ARG1,\n-           Rret_addr   = R4_ARG2,\n-           Rflags      = R5_ARG3;\n+  Register Rcache    = R3_ARG1,\n+           Rret_addr = R4_ARG2;\n@@ -3643,1 +3580,4 @@\n-  prepare_invoke(byte_no, R19_method, Rret_addr, noreg, noreg, Rflags, R11_scratch1, R12_scratch2);\n+  load_resolved_method_entry_special_or_static(Rcache,  \/\/ ResolvedMethodEntry*\n+                                               R19_method, \/\/ Method* or itable index\n+                                               noreg); \/\/ flags\n+  prepare_invoke(Rcache, Rret_addr, noreg, R11_scratch1); \/\/ recv\n@@ -3654,1 +3594,1 @@\n-                                                  Register Rmethod,\n+                                                  Register Rcache,\n@@ -3658,1 +3598,1 @@\n-  assert_different_registers(Rmethod, Rret, Rrecv_klass, Rflags, Rtemp1, Rtemp2);\n+  assert_different_registers(Rcache, Rret, Rrecv_klass, Rflags, Rtemp1, Rtemp2);\n@@ -3662,1 +3602,1 @@\n-  __ testbitdi(CCR0, R0, Rflags, ConstantPoolCacheEntry::is_vfinal_shift);\n+  __ testbitdi(CCR0, R0, Rflags, ResolvedMethodEntry::is_vfinal_shift);\n@@ -3665,1 +3605,3 @@\n-  Register Rscratch = Rflags; \/\/ Rflags is dead now.\n+  Register Rscratch = Rflags, \/\/ Rflags is dead now.\n+           Rmethod  = Rtemp2,\n+           Rindex   = Rtemp2;\n@@ -3670,0 +3612,1 @@\n+  __ ld(Rmethod, in_bytes(ResolvedMethodEntry::method_offset()), Rcache);\n@@ -3676,0 +3619,1 @@\n+  __ lhz(Rindex, in_bytes(ResolvedMethodEntry::table_index_offset()), Rcache);\n@@ -3677,1 +3621,1 @@\n-  generate_vtable_call(Rrecv_klass, Rmethod, Rret, Rscratch);\n+  generate_vtable_call(Rrecv_klass, Rindex, Rret, Rscratch);\n@@ -3686,5 +3630,0 @@\n-                 Rmethod          = R6_ARG4,\n-                 Rmethod2         = R9_ARG7,\n-                 Rinterface_klass = R5_ARG3,\n-                 Rret_addr        = R8_ARG6,\n-                 Rindex           = R10_ARG8,\n@@ -3693,1 +3632,7 @@\n-                 Rflags           = R7_ARG5;\n+                 Rinterface_klass = R5_ARG3,\n+                 Rmethod          = R6_ARG4,\n+                 Rmethod2         = R7_ARG5,\n+                 Rret_addr        = R8_ARG6,\n+                 Rindex           = R9_ARG7,\n+                 Rflags           = R10_ARG8,\n+                 Rcache           = R31;\n@@ -3695,1 +3640,2 @@\n-  prepare_invoke(byte_no, Rinterface_klass, Rret_addr, Rmethod, Rreceiver, Rflags, Rscratch1, \/* temp *\/ Rrecv_klass);\n+  load_resolved_method_entry_interface(Rcache, noreg, noreg, Rflags);\n+  prepare_invoke(Rcache, Rret_addr, Rreceiver, Rscratch1); \/\/ recv\n@@ -3705,1 +3651,1 @@\n-  \/\/ java.lang.Object. See ConstantPoolCacheEntry::set_method() for details:\n+  \/\/ java.lang.Object. See ResolvedMethodEntry for details:\n@@ -3710,1 +3656,1 @@\n-  __ testbitdi(CCR0, R0, Rflags, ConstantPoolCacheEntry::is_forced_virtual_shift);\n+  __ testbitdi(CCR0, R0, Rflags, ResolvedMethodEntry::is_forced_virtual_shift);\n@@ -3712,1 +3658,1 @@\n-  invokeinterface_object_method(Rrecv_klass, Rret_addr, Rflags, Rmethod, Rscratch1, Rscratch2);\n+  invokeinterface_object_method(Rrecv_klass, Rret_addr, Rflags, Rcache, Rscratch1, Rscratch2);\n@@ -3715,0 +3661,3 @@\n+  __ ld(Rinterface_klass, in_bytes(ResolvedMethodEntry::klass_offset()), Rcache);\n+  __ ld(Rmethod, in_bytes(ResolvedMethodEntry::method_offset()), Rcache);\n+\n@@ -3718,1 +3667,1 @@\n-  __ testbitdi(CCR0, R0, Rflags, ConstantPoolCacheEntry::is_vfinal_shift);\n+  __ testbitdi(CCR0, R0, Rflags, ResolvedMethodEntry::is_vfinal_shift);\n@@ -3736,1 +3685,0 @@\n-\n@@ -3803,1 +3751,1 @@\n-                 Rflags    = R31,\n+                 Rflags    = R12_scratch2,\n@@ -3808,1 +3756,1 @@\n-                 Rscratch3 = R12_scratch2;\n+                 Rcache    = R31;\n@@ -3810,1 +3758,5 @@\n-  prepare_invoke(byte_no, Rmethod, Rret_addr, Rscratch1, Rrecv, Rflags, Rscratch2, Rscratch3);\n+  load_resolved_method_entry_handle(Rcache,  \/\/ ResolvedMethodEntry*\n+                                    Rmethod, \/\/ Method* or itable index\n+                                    Rscratch1,\n+                                    Rflags);\n+  prepare_invoke(Rcache, Rret_addr, Rrecv, Rscratch1);\n","filename":"src\/hotspot\/cpu\/ppc\/templateTable_ppc_64.cpp","additions":163,"deletions":211,"binary":false,"changes":374,"status":"modified"},{"patch":"@@ -2865,4 +2865,0 @@\n-  \/\/ invokehandle uses an index into the resolved references array\n-  __ movptr(method, Address(cache, in_bytes(ResolvedMethodEntry::method_offset())));\n-  __ load_unsigned_short(ref_index, Address(cache, in_bytes(ResolvedMethodEntry::resolved_references_index_offset())));\n-\n@@ -2873,0 +2869,2 @@\n+  \/\/ invokehandle uses an index into the resolved references array\n+  __ load_unsigned_short(ref_index, Address(cache, in_bytes(ResolvedMethodEntry::resolved_references_index_offset())));\n@@ -2876,5 +2874,3 @@\n-  __ push(method);\n-  __ mov(method, ref_index);\n-  __ load_resolved_reference_at_index(ref_index, method);\n-  __ pop(method);\n-  __ push(ref_index);  \/\/ push appendix (MethodType, CallSite, etc.)\n+  Register appendix = method;\n+  __ load_resolved_reference_at_index(appendix, ref_index);\n+  __ push(appendix);  \/\/ push appendix (MethodType, CallSite, etc.)\n@@ -2882,0 +2878,2 @@\n+\n+  __ movptr(method, Address(cache, in_bytes(ResolvedMethodEntry::method_offset())));\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"}]}