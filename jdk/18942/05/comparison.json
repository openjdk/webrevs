{"files":[{"patch":"@@ -659,11 +659,13 @@\n-#define INSN(NAME, op)                                                                \\\n-  void NAME(Register Rd, const int32_t offset) {                                      \\\n-    guarantee(is_simm21(offset) && ((offset % 2) == 0), \"offset is invalid.\");        \\\n-    unsigned insn = 0;                                                                \\\n-    patch((address)&insn, 6, 0, op);                                                  \\\n-    patch_reg((address)&insn, 7, Rd);                                                 \\\n-    patch((address)&insn, 19, 12, (uint32_t)((offset >> 12) & 0xff));                 \\\n-    patch((address)&insn, 20, (uint32_t)((offset >> 11) & 0x1));                      \\\n-    patch((address)&insn, 30, 21, (uint32_t)((offset >> 1) & 0x3ff));                 \\\n-    patch((address)&insn, 31, (uint32_t)((offset >> 20) & 0x1));                      \\\n-    emit(insn);                                                                       \\\n+ private:\n+  \/\/ All calls and jumps must go via MASM.\n+  \/\/ Format J-type\n+  void _jal(Register Rd, const int32_t offset) {\n+    guarantee(is_simm21(offset) && ((offset % 2) == 0), \"offset is invalid.\");\n+    unsigned insn = 0;\n+    patch((address)&insn, 6, 0, 0b1101111);\n+    patch_reg((address)&insn, 7, Rd);\n+    patch((address)&insn, 19, 12, (uint32_t)((offset >> 12) & 0xff));\n+    patch((address)&insn, 20, (uint32_t)((offset >> 11) & 0x1));\n+    patch((address)&insn, 30, 21, (uint32_t)((offset >> 1) & 0x3ff));\n+    patch((address)&insn, 31, (uint32_t)((offset >> 20) & 0x1));\n+    emit(insn);\n@@ -672,15 +674,11 @@\n-  INSN(jal, 0b1101111);\n-\n-#undef INSN\n-\n-#define INSN(NAME, op, funct)                                                         \\\n-  void NAME(Register Rd, Register Rs, const int32_t offset) {                         \\\n-    guarantee(is_simm12(offset), \"offset is invalid.\");                               \\\n-    unsigned insn = 0;                                                                \\\n-    patch((address)&insn, 6, 0, op);                                                  \\\n-    patch_reg((address)&insn, 7, Rd);                                                 \\\n-    patch((address)&insn, 14, 12, funct);                                             \\\n-    patch_reg((address)&insn, 15, Rs);                                                \\\n-    int32_t val = offset & 0xfff;                                                     \\\n-    patch((address)&insn, 31, 20, val);                                               \\\n-    emit(insn);                                                                       \\\n+  \/\/ Format I-type\n+  void _jalr(Register Rd, Register Rs, const int32_t offset) {\n+    guarantee(is_simm12(offset), \"offset is invalid.\");\n+    unsigned insn = 0;\n+    patch((address)&insn, 6, 0, 0b1100111);\n+    patch_reg((address)&insn, 7, Rd);\n+    patch((address)&insn, 14, 12, 0b000);\n+    patch_reg((address)&insn, 15, Rs);\n+    int32_t val = offset & 0xfff;\n+    patch((address)&insn, 31, 20, val);\n+    emit(insn);\n@@ -689,3 +687,1 @@\n-  INSN(_jalr, 0b1100111, 0b000);\n-\n-#undef INSN\n+ public:\n@@ -2288,9 +2284,13 @@\n-#define INSN(NAME, funct4, op)                                                               \\\n-  void NAME(Register Rs1) {                                                                  \\\n-    assert_cond(Rs1 != x0);                                                                  \\\n-    uint16_t insn = 0;                                                                       \\\n-    c_patch((address)&insn, 1, 0, op);                                                       \\\n-    c_patch_reg((address)&insn, 2, x0);                                                      \\\n-    c_patch_reg((address)&insn, 7, Rs1);                                                     \\\n-    c_patch((address)&insn, 15, 12, funct4);                                                 \\\n-    emit_int16(insn);                                                                        \\\n+ private:\n+  \/\/ All calls and jumps must go via MASM.\n+  \/\/ Format CR, c.jr\/c.jalr\n+  \/\/ Note C instruction can't be changed, i.e. relocation patching.\n+  template <uint8_t InstructionType, uint8_t FunctionType>\n+  void c_cr_if(Register Rs1) {\n+    assert_cond(Rs1 != x0);\n+    uint16_t insn = 0;\n+    c_patch((address)&insn, 1, 0, FunctionType);\n+    c_patch_reg((address)&insn, 2, x0);\n+    c_patch_reg((address)&insn, 7, Rs1);\n+    c_patch((address)&insn, 15, 12, InstructionType);\n+    emit_int16(insn);\n@@ -2299,4 +2299,2 @@\n-  INSN(c_jr,   0b1000, 0b10);\n-  INSN(c_jalr, 0b1001, 0b10);\n-\n-#undef INSN\n+  void c_jr(Register Rs1)   { c_cr_if<0b1000, 0b10>(Rs1); }\n+  void c_jalr(Register Rs1) { c_cr_if<0b1001, 0b10>(Rs1); }\n@@ -2325,24 +2323,16 @@\n-#define INSN(NAME, funct3, op)                                                               \\\n-  void NAME(int32_t offset) {                                                                \\\n-    assert(is_simm12(offset) && ((offset % 2) == 0), \"invalid encoding\");                    \\\n-    uint16_t insn = 0;                                                                       \\\n-    c_patch((address)&insn, 1, 0, op);                                                       \\\n-    c_patch((address)&insn, 2, 2, (offset & nth_bit(5)) >> 5);                               \\\n-    c_patch((address)&insn, 5, 3, (offset & right_n_bits(4)) >> 1);                          \\\n-    c_patch((address)&insn, 6, 6, (offset & nth_bit(7)) >> 7);                               \\\n-    c_patch((address)&insn, 7, 7, (offset & nth_bit(6)) >> 6);                               \\\n-    c_patch((address)&insn, 8, 8, (offset & nth_bit(10)) >> 10);                             \\\n-    c_patch((address)&insn, 10, 9, (offset & right_n_bits(10)) >> 8);                        \\\n-    c_patch((address)&insn, 11, 11, (offset & nth_bit(4)) >> 4);                             \\\n-    c_patch((address)&insn, 12, 12, (offset & nth_bit(11)) >> 11);                           \\\n-    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n-    emit_int16(insn);                                                                        \\\n-  }                                                                                          \\\n-  void NAME(address dest) {                                                                  \\\n-    assert_cond(dest != nullptr);                                                            \\\n-    int64_t distance = dest - pc();                                                          \\\n-    assert(is_simm12(distance) && ((distance % 2) == 0), \"invalid encoding\");                \\\n-    c_j(distance);                                                                           \\\n-  }                                                                                          \\\n-  void NAME(Label &L) {                                                                      \\\n-    wrap_label(L, &Assembler::NAME);                                                         \\\n+  \/\/ Format CJ, c.j (c.jal)\n+  \/\/ Note C instruction can't be changed, i.e. relocation patching.\n+  void c_j(int32_t offset) {\n+    assert(is_simm12(offset) && ((offset % 2) == 0), \"invalid encoding\");\n+    uint16_t insn = 0;\n+    c_patch((address)&insn, 1, 0, 0b01);\n+    c_patch((address)&insn, 2, 2, (offset & nth_bit(5)) >> 5);\n+    c_patch((address)&insn, 5, 3, (offset & right_n_bits(4)) >> 1);\n+    c_patch((address)&insn, 6, 6, (offset & nth_bit(7)) >> 7);\n+    c_patch((address)&insn, 7, 7, (offset & nth_bit(6)) >> 6);\n+    c_patch((address)&insn, 8, 8, (offset & nth_bit(10)) >> 10);\n+    c_patch((address)&insn, 10, 9, (offset & right_n_bits(10)) >> 8);\n+    c_patch((address)&insn, 11, 11, (offset & nth_bit(4)) >> 4);\n+    c_patch((address)&insn, 12, 12, (offset & nth_bit(11)) >> 11);\n+    c_patch((address)&insn, 15, 13, 0b101);\n+    emit_int16(insn);\n@@ -2351,1 +2341,6 @@\n-  INSN(c_j, 0b101, 0b01);\n+  void c_j(address dest) {\n+    assert_cond(dest != nullptr);\n+    int64_t distance = dest - pc();\n+    assert(is_simm12(distance) && ((distance % 2) == 0), \"invalid encoding\");\n+    c_j(distance);\n+  }\n@@ -2353,1 +2348,5 @@\n-#undef INSN\n+  void c_j(Label &L) {\n+    wrap_label(L, &Assembler::c_j);\n+  }\n+\n+  public:\n@@ -2806,13 +2805,14 @@\n-#define INSN(NAME)                                                                           \\\n-  void NAME(Register Rd, Register Rs, const int32_t offset) {                                \\\n-    \/* jalr -> c.jr\/c.jalr *\/                                                                \\\n-    if (do_compress() && (offset == 0 && Rs != x0)) {                                        \\\n-      if (Rd == x1) {                                                                        \\\n-        c_jalr(Rs);                                                                          \\\n-        return;                                                                              \\\n-      } else if (Rd == x0) {                                                                 \\\n-        c_jr(Rs);                                                                            \\\n-        return;                                                                              \\\n-      }                                                                                      \\\n-    }                                                                                        \\\n-    _jalr(Rd, Rs, offset);                                                                   \\\n+ protected:\n+  \/\/ All calls and jumps must go via MASM.\n+  void jalr(Register Rd, Register Rs, const int32_t offset) {\n+    \/* jalr -> c.jr\/c.jalr *\/\n+    if (do_compress() && (offset == 0 && Rs != x0)) {\n+      if (Rd == x1) {\n+        c_jalr(Rs);\n+        return;\n+      } else if (Rd == x0) {\n+        c_jr(Rs);\n+        return;\n+      }\n+    }\n+    _jalr(Rd, Rs, offset);\n@@ -2821,1 +2821,8 @@\n-  INSN(jalr);\n+  void jal(Register Rd, const int32_t offset) {\n+    \/* jal -> c.j, note c.jal is RV32C only *\/\n+    if (do_compress() &&\n+        Rd == x0 &&\n+        is_simm12(offset) && ((offset % 2) == 0)) {\n+      c_j(offset);\n+      return;\n+    }\n@@ -2823,1 +2830,4 @@\n-#undef INSN\n+    _jal(Rd, offset);\n+  }\n+\n+  public:\n@@ -3003,12 +3013,0 @@\n-\/\/ ---------------------------------------------------------------------------------------\n-\n-#define INSN(NAME, REGISTER)                       \\\n-  void NAME(Register Rs) {                         \\\n-    jalr(REGISTER, Rs, 0);                         \\\n-  }\n-\n-  INSN(jr,   x0);\n-  INSN(jalr, x1);\n-\n-#undef INSN\n-\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":93,"deletions":95,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -1844,11 +1844,1 @@\n-  CodeBlob *cb = CodeCache::find_blob(dest);\n-  if (cb != nullptr) {\n-    __ far_call(RuntimeAddress(dest));\n-  } else {\n-    RuntimeAddress target(dest);\n-    __ relocate(target.rspec(), [&] {\n-      int32_t offset;\n-      __ movptr(t0, target.target(), offset);\n-      __ jalr(x1, t0, offset);\n-    });\n-  }\n+  __ rt_call(dest);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -303,1 +303,1 @@\n-  __ call(target);\n+  __ rt_call(target);\n@@ -706,1 +706,1 @@\n-  __ call(target);\n+  __ rt_call(target);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shenandoah\/shenandoahBarrierSetAssembler_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -178,3 +178,1 @@\n-      int32_t offset;\n-      __ la(t0, target.target(), offset);\n-      __ jalr(x1, t0, offset);\n+      __ call(target.target());\n","filename":"src\/hotspot\/cpu\/riscv\/jniFastGetField_riscv.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -342,1 +342,1 @@\n-      jalr(x0, t0, offset);\n+      jr(t0, offset);\n@@ -644,1 +644,1 @@\n-  jalr(x0, t0, offset);\n+  jr(t0, offset);\n@@ -650,0 +650,1 @@\n+  int32_t offset = 0;\n@@ -651,1 +652,2 @@\n-  call(entry_point);\n+  mv(t0, entry_point, offset);\n+  Assembler::jalr(x1, t0, offset);\n@@ -719,7 +721,3 @@\n-  int64_t offset = addr - pc();\n-  if (is_valid_32bit_offset(offset)) {\n-    auipc(Rd, (int32_t)offset + 0x800);  \/\/0x800, Note:the 11th sign bit\n-    addi(Rd, Rd, ((int64_t)offset << 52) >> 52);\n-  } else {\n-    movptr(Rd, addr);\n-  }\n+  int32_t offset;\n+  la(Rd, addr, offset);\n+  addi(Rd, Rd, offset);\n@@ -729,14 +727,3 @@\n-  assert((uintptr_t)addr < (1ull << 48), \"bad address\");\n-\n-  unsigned long target_address = (uintptr_t)addr;\n-  unsigned long low_address = (uintptr_t)CodeCache::low_bound();\n-  unsigned long high_address = (uintptr_t)CodeCache::high_bound();\n-  long offset_low = target_address - low_address;\n-  long offset_high = target_address - high_address;\n-\n-  \/\/ RISC-V doesn't compute a page-aligned address, in order to partially\n-  \/\/ compensate for the use of *signed* offsets in its base+disp12\n-  \/\/ addressing mode (RISC-V's PC-relative reach remains asymmetric\n-  \/\/ [-(2G + 2K), 2G - 2K).\n-  if (offset_high >= -((1L << 31) + (1L << 11)) && offset_low < (1L << 31) - (1L << 11)) {\n-    int64_t distance = addr - pc();\n+  int64_t distance = addr - pc();\n+  if (is_32bit_offset_from_codecache((int64_t)addr)) {\n+    assert(is_valid_32bit_offset(distance), \"Must be\");\n@@ -746,1 +733,5 @@\n-    movptr(Rd, addr, offset);\n+    assert(!CodeCache::contains(addr), \"Must be\");\n+    \/\/ The load of the address will be generated with\n+    \/\/ position independent instruction.\n+    \/\/ Hence relocations will not change them.\n+    mv(Rd, addr, offset); \/\/ li\n@@ -862,18 +853,12 @@\n-#define INSN(NAME, REGISTER)                                       \\\n-  void MacroAssembler::NAME(const address dest, Register temp) {   \\\n-    assert_cond(dest != nullptr);                                  \\\n-    int64_t distance = dest - pc();                                \\\n-    if (is_simm21(distance) && ((distance % 2) == 0)) {            \\\n-      Assembler::jal(REGISTER, distance);                          \\\n-    } else {                                                       \\\n-      assert(temp != noreg, \"expecting a register\");               \\\n-      int32_t offset = 0;                                          \\\n-      movptr(temp, dest, offset);                                  \\\n-      Assembler::jalr(REGISTER, temp, offset);                     \\\n-    }                                                              \\\n-  }                                                                \\\n-\n-  INSN(j,   x0);\n-  INSN(jal, x1);\n-\n-#undef INSN\n+void MacroAssembler::jump_link(const address dest, Register temp) {\n+  assert_cond(dest != nullptr);\n+  int64_t distance = dest - pc();\n+  if (is_simm21(distance) && ((distance % 2) == 0)) {\n+    Assembler::jal(x1, distance);\n+  } else {\n+    assert(temp != noreg && temp != x0, \"expecting a register\");\n+    int32_t offset = 0;\n+    movptr(temp, dest, offset);\n+    Assembler::jalr(x1, temp, offset);\n+  }\n+}\n@@ -881,22 +866,18 @@\n-#define INSN(NAME, REGISTER)                                       \\\n-  void MacroAssembler::NAME(const Address &adr, Register temp) {   \\\n-    switch (adr.getMode()) {                                       \\\n-      case Address::literal: {                                     \\\n-        relocate(adr.rspec(), [&] {                                \\\n-          NAME(adr.target(), temp);                                \\\n-        });                                                        \\\n-        break;                                                     \\\n-      }                                                            \\\n-      case Address::base_plus_offset: {                            \\\n-        int32_t offset = ((int32_t)adr.offset() << 20) >> 20;      \\\n-        la(temp, Address(adr.base(), adr.offset() - offset));      \\\n-        Assembler::jalr(REGISTER, temp, offset);                   \\\n-        break;                                                     \\\n-      }                                                            \\\n-      default:                                                     \\\n-        ShouldNotReachHere();                                      \\\n-    }                                                              \\\n-  }\n-\n-  INSN(j,   x0);\n-  INSN(jal, x1);\n+void MacroAssembler::jump_link(const Address &adr, Register temp) {\n+  switch (adr.getMode()) {\n+    case Address::literal: {\n+      relocate(adr.rspec(), [&] {\n+        jump_link(adr.target(), temp);\n+      });\n+      break;\n+    }\n+    case Address::base_plus_offset: {\n+      int32_t offset = ((int32_t)adr.offset() << 20) >> 20;\n+      la(temp, Address(adr.base(), adr.offset() - offset));\n+      Assembler::jalr(x1, temp, offset);\n+      break;\n+    }\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n@@ -904,1 +885,4 @@\n-#undef INSN\n+void MacroAssembler::j(const address dest, Register temp) {\n+  assert(CodeCache::contains(dest), \"Must be\");\n+  assert_cond(dest != nullptr);\n+  int64_t distance = dest - pc();\n@@ -906,16 +890,9 @@\n-#define INSN(NAME)                                                                    \\\n-  void MacroAssembler::NAME(Register Rd, const address dest, Register temp) {         \\\n-    assert_cond(dest != nullptr);                                                     \\\n-    int64_t distance = dest - pc();                                                   \\\n-    if (is_simm21(distance) && ((distance % 2) == 0)) {                               \\\n-      Assembler::NAME(Rd, distance);                                                  \\\n-    } else {                                                                          \\\n-      assert_different_registers(Rd, temp);                                           \\\n-      int32_t offset = 0;                                                             \\\n-      movptr(temp, dest, offset);                                                     \\\n-      jalr(Rd, temp, offset);                                                         \\\n-    }                                                                                 \\\n-  }                                                                                   \\\n-  void MacroAssembler::NAME(Register Rd, Label &L, Register temp) {                   \\\n-    assert_different_registers(Rd, temp);                                             \\\n-    wrap_label(Rd, L, temp, &MacroAssembler::NAME);                                   \\\n+  \/\/ We can't patch C, i.e. if Label wasn't bound we need to patch this jump.\n+  IncompressibleRegion ir(this);\n+  if (is_simm21(distance) && ((distance % 2) == 0)) {\n+    Assembler::jal(x0, distance);\n+  } else {\n+    assert(temp != noreg && temp != x0, \"expecting a register\");\n+    int32_t offset = 0;\n+    la(temp, dest, offset);\n+    jr(temp, offset);\n@@ -923,0 +900,1 @@\n+}\n@@ -924,1 +902,18 @@\n-  INSN(jal);\n+void MacroAssembler::j(const Address &adr, Register temp) {\n+  switch (adr.getMode()) {\n+    case Address::literal: {\n+      relocate(adr.rspec(), [&] {\n+        j(adr.target(), temp);\n+      });\n+      break;\n+    }\n+    case Address::base_plus_offset: {\n+      int32_t offset = ((int32_t)adr.offset() << 20) >> 20;\n+      la(temp, Address(adr.base(), adr.offset() - offset));\n+      jr(temp, offset);\n+      break;\n+    }\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n@@ -926,1 +921,9 @@\n-#undef INSN\n+void MacroAssembler::j(Label &lab, Register temp) {\n+  assert_different_registers(x0, temp);\n+  if (lab.is_bound()) {\n+    MacroAssembler::j(target(lab), temp);\n+  } else {\n+    lab.add_patch_at(code(), locator());\n+    MacroAssembler::j(pc(), temp);\n+  }\n+}\n@@ -928,4 +931,4 @@\n-#define INSN(NAME, REGISTER)                                       \\\n-  void MacroAssembler::NAME(Label &l, Register temp) {             \\\n-    jal(REGISTER, l, temp);                                        \\\n-  }                                                                \\\n+void MacroAssembler::jr(Register Rd, int32_t offset) {\n+  assert(Rd != noreg, \"expecting a register\");\n+  Assembler::jalr(x0, Rd, offset);\n+}\n@@ -933,2 +936,7 @@\n-  INSN(j,   x0);\n-  INSN(jal, x1);\n+void MacroAssembler::call(const address dest, Register temp) {\n+  assert_cond(dest != nullptr);\n+  assert(temp != noreg, \"expecting a register\");\n+  int32_t offset = 0;\n+  la(temp, dest, offset);\n+  Assembler::jalr(x1, temp, offset);\n+}\n@@ -936,1 +944,4 @@\n-#undef INSN\n+void MacroAssembler::jalr(Register Rs, int32_t offset) {\n+  assert(Rs != noreg, \"expecting a register\");\n+  Assembler::jalr(x1, Rs, offset);\n+}\n@@ -938,3 +949,5 @@\n-void MacroAssembler::wrap_label(Register Rt, Label &L, Register tmp, load_insn_by_temp insn) {\n-  if (L.is_bound()) {\n-    (this->*insn)(Rt, target(L), tmp);\n+void MacroAssembler::rt_call(address dest, Register tmp) {\n+  CodeBlob *cb = CodeCache::find_blob(dest);\n+  RuntimeAddress target(dest);\n+  if (cb) {\n+    far_call(target, tmp);\n@@ -942,2 +955,5 @@\n-    L.add_patch_at(code(), locator());\n-    (this->*insn)(Rt, pc(), tmp);\n+    relocate(target.rspec(), [&] {\n+      int32_t offset;\n+      movptr(tmp, target.target(), offset);\n+      Assembler::jalr(x1, tmp, offset);\n+    });\n@@ -3172,1 +3188,0 @@\n-  assert(ReservedCodeCacheSize < 4*G, \"branch out of range\");\n@@ -3182,1 +3197,1 @@\n-    jalr(x0, tmp, offset);\n+    jr(tmp, offset);\n@@ -3187,1 +3202,0 @@\n-  assert(ReservedCodeCacheSize < 4*G, \"branch out of range\");\n@@ -3197,3 +3211,2 @@\n-    int32_t offset;\n-    la(tmp, entry.target(), offset);\n-    jalr(x1, tmp, offset); \/\/ link\n+    assert(is_valid_32bit_offset(entry.target() - pc()), \"Far call using wrong instructions.\");\n+    call(entry.target(), tmp);\n@@ -3455,1 +3468,1 @@\n-      jalr(x0, t0, offset);\n+      jr(t0, offset);\n@@ -3537,1 +3550,1 @@\n-    jal(target);\n+    jump_link(target, t0);\n@@ -4376,1 +4389,1 @@\n-      jal(zero_blocks);\n+      jump_link(zero_blocks, t0);\n@@ -5021,14 +5034,0 @@\n-void MacroAssembler::rt_call(address dest, Register tmp) {\n-  CodeBlob *cb = CodeCache::find_blob(dest);\n-  RuntimeAddress target(dest);\n-  if (cb) {\n-    far_call(target, tmp);\n-  } else {\n-    relocate(target.rspec(), [&] {\n-      int32_t offset;\n-      movptr(tmp, target.target(), offset);\n-      jalr(x1, tmp, offset);\n-    });\n-  }\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":118,"deletions":119,"binary":false,"changes":237,"status":"modified"},{"patch":"@@ -595,1 +595,12 @@\n-  void j(Label &l, Register temp = t0);\n+ private:\n+  void jump_link(const address dest, Register temp);\n+  void jump_link(const Address &adr, Register temp);\n+ public:\n+  \/\/ We try to follow risc-v asm menomics.\n+  \/\/ But as we don't layout a reachable GOT,\n+  \/\/ we often need to resort to movptr, li <48imm>.\n+  \/\/ https:\/\/github.com\/riscv-non-isa\/riscv-asm-manual\/blob\/master\/riscv-asm.md\n+\n+  \/\/ jump: jal x0, offset\n+  \/\/ For long reach uses temp register for:\n+  \/\/ la + jr\n@@ -598,5 +609,20 @@\n-  void jal(Label &l, Register temp = t0);\n-  void jal(const address dest, Register temp = t0);\n-  void jal(const Address &adr, Register temp = t0);\n-  void jal(Register Rd, Label &L, Register temp = t0);\n-  void jal(Register Rd, const address dest, Register temp = t0);\n+  void j(Label &l, Register temp = t0);\n+\n+  \/\/ jump register: jalr x0, offset(rs)\n+  void jr(Register Rd, int32_t offset = 0);\n+\n+  \/\/ call: la + jalr x1\n+  void call(const address dest, Register temp = t0);\n+\n+  \/\/ jalr: jalr x1, offset(rs)\n+  void jalr(Register Rs, int32_t offset = 0);\n+\n+  \/\/ Emit a runtime call. Only invalidates the tmp register which\n+  \/\/ is used to keep the entry address for jalr\/movptr.\n+  \/\/ Uses call() for intra code cache, else movptr + jalr.\n+  void rt_call(address dest, Register tmp = t0);\n+\n+  \/\/ ret: jalr x0, 0(x1)\n+  inline void ret() {\n+    Assembler::jalr(x0, x1, 0);\n+  }\n@@ -692,0 +718,6 @@\n+  bool is_32bit_offset_from_codecache(int64_t x) {\n+    int64_t low  = (int64_t)CodeCache::low_bound();\n+    int64_t high = (int64_t)CodeCache::high_bound();\n+    return is_valid_32bit_offset(x - low) && is_valid_32bit_offset(x - high);\n+  }\n+\n@@ -738,1 +770,0 @@\n-  void wrap_label(Register r, Label &L, Register t, load_insn_by_temp insn);\n@@ -744,0 +775,1 @@\n+  \/\/ la will use movptr instead of GOT when not in reach for auipc.\n@@ -1472,15 +1504,0 @@\n-  \/\/ Emit a runtime call. Only invalidates the tmp register which\n-  \/\/ is used to keep the entry address for jalr\/movptr.\n-  void rt_call(address dest, Register tmp = t0);\n-\n-  void call(const address dest, Register temp = t0) {\n-    assert_cond(dest != nullptr);\n-    assert(temp != noreg, \"expecting a register\");\n-    int32_t offset = 0;\n-    mv(temp, dest, offset);\n-    jalr(x1, temp, offset);\n-  }\n-\n-  inline void ret() {\n-    jalr(x0, x1, 0);\n-  }\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":39,"deletions":22,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -403,1 +403,1 @@\n-  a.jalr(x0, t0, offset); \/\/ jalr\n+  a.jr(t0, offset); \/\/ jalr\n@@ -413,1 +413,0 @@\n-\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -655,1 +655,1 @@\n-    __ call(CAST_FROM_FN_PTR(address, MacroAssembler::debug64));\n+    __ rt_call(CAST_FROM_FN_PTR(address, MacroAssembler::debug64));\n@@ -5453,1 +5453,1 @@\n-    __ call(runtime_entry);\n+    __ rt_call(runtime_entry);\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1209,1 +1209,1 @@\n-    __ call(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans));\n+    __ rt_call(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans));\n@@ -1258,1 +1258,1 @@\n-    __ call(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages));\n+    __ rt_call(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages));\n@@ -1818,1 +1818,1 @@\n-  __ jal(Interpreter::trace_code(t->tos_in()));\n+  __ call(Interpreter::trace_code(t->tos_in()));\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}