{"files":[{"patch":"@@ -97,0 +97,6 @@\n+static void requireNotInHotSpot(const char* caller, JVMCI_TRAPS) {\n+    if (JVMCIENV->is_hotspot()) {\n+        JVMCI_THROW_MSG(IllegalStateException, err_msg(\"Cannot call %s from HotSpot\", caller));\n+    }\n+}\n+\n@@ -705,0 +711,11 @@\n+C2V_VMENTRY_0(jlong, getJObjectValue, (JNIEnv* env, jobject, jobject constant_jobject))\n+    requireNotInHotSpot(\"getJObjectValue\", JVMCI_CHECK_0);\n+    if (!THREAD->has_last_Java_frame()) {\n+        JVMCI_THROW_MSG_0(IllegalStateException, err_msg(\"Cannot call getJObjectValue without Java frame anchor\"));\n+    }\n+    JVMCIObject constant = JVMCIENV->wrap(constant_jobject);\n+    Handle constant_value = JVMCIENV->asConstant(constant, JVMCI_CHECK_0);\n+    jobject jni_handle = JNIHandles::make_local(THREAD, constant_value());\n+    return reinterpret_cast<jlong>(jni_handle);\n+C2V_END\n+\n@@ -3257,0 +3274,1 @@\n+  {CC \"getJObjectValue\",                              CC \"(\" OBJECTCONSTANT \")J\",                                                           FN_PTR(getJObjectValue)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -292,0 +292,6 @@\n+    \/**\n+     * Gets the {@code jobject} value wrapped by {@code peerObject}.\n+     * Must not be called if {@link Services#IS_IN_NATIVE_IMAGE} is {@code false}.\n+     *\/\n+    native long getJObjectValue(HotSpotObjectConstantImpl peerObject);\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -928,5 +928,4 @@\n-     * Gets the {@code jobject} value wrapped by {@code peerObject}. The returned \"naked\" value is\n-     * only valid as long as {@code peerObject} is valid. Note that the latter may be shorter than\n-     * the lifetime of {@code peerObject}. As such, this method should only be used to pass an\n-     * object parameter across a JNI call from the JVMCI shared library to HotSpot. This method must\n-     * only be called from within the JVMCI shared library.\n+     * Gets the {@code jobject} value wrapped by {@code peerObject}. The returned value is\n+     * a JNI local reference whose lifetime is scoped by the nearest Java caller (from\n+     * HotSpot's perspective). The current thread's state must be {@code _thread_in_native}.\n+     * A call from the JVMCI shared library (e.g. libgraal) is in such a state.\n@@ -934,2 +933,2 @@\n-     * @param peerObject a reference to an object in the peer runtime\n-     * @return the {@code jobject} value wrapped by {@code peerObject}\n+     * @param peerObject a reference to an object in the HotSpot heap\n+     * @return the {@code jobject} value unpacked from {@code peerObject}\n@@ -937,1 +936,4 @@\n-     *             {@code peerObject} is not a peer object reference\n+     *             {@code peerObject} is not a HotSpot heap object reference\n+     * @throws IllegalStateException if not called from within the JVMCI shared library\n+     *         or if there is no Java caller frame on the stack\n+     *         (i.e., JavaThread::has_last_Java_frame returns false)\n@@ -940,5 +942,1 @@\n-        if (peerObject instanceof IndirectHotSpotObjectConstantImpl) {\n-            IndirectHotSpotObjectConstantImpl remote = (IndirectHotSpotObjectConstantImpl) peerObject;\n-            return remote.getHandle();\n-        }\n-        throw new IllegalArgumentException(\"Cannot get jobject value for \" + peerObject + \" (\" + peerObject.getClass().getName() + \")\");\n+        return compilerToVm.getJObjectValue((HotSpotObjectConstantImpl)peerObject);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"}]}