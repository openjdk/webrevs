{"files":[{"patch":"@@ -39,0 +39,1 @@\n+import java.nio.channels.NetworkChannel;\n@@ -1446,1 +1447,0 @@\n-        \/\/ Extract debug data from the GOAWAY frame\n@@ -1452,1 +1452,0 @@\n-        \/\/ Create a meaningful error message with the error code and debug data\n@@ -1464,1 +1463,0 @@\n-        \/\/ Create the termination cause with the error information\n@@ -1467,3 +1465,0 @@\n-        \/\/ Fail all streams appropriately:\n-        \/\/ - Streams with ID > lastProcessedStream were not processed and can be retried\n-        \/\/ - Streams with ID <= lastProcessedStream were being processed and should fail with the error\n@@ -1475,1 +1470,0 @@\n-                \/\/ Stream was not processed by the peer - mark as unprocessed for retry\n@@ -1479,3 +1473,1 @@\n-                \/\/ Stream was being processed - fail it with the connection error\n-                final IOException error = new IOException(errorMsg);\n-                stream.connectionClosing(error);\n+                stream.connectionClosing(cause.getCloseCause());\n@@ -1491,1 +1483,0 @@\n-        \/\/ Terminate the connection immediately\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import java.util.List;\n-import java.util.Objects;\n@@ -36,1 +34,0 @@\n-import java.util.concurrent.atomic.AtomicReference;\n@@ -77,1 +74,0 @@\n-    static AtomicReference<String> allowedConnectionKey;\n@@ -84,1 +80,0 @@\n-        allowedConnectionKey = new AtomicReference<>();\n@@ -88,4 +83,0 @@\n-        server.setRequestApprover(key -> {\n-            String allowed = allowedConnectionKey.get();\n-            return allowed == null || allowed.equals(key);\n-        });\n@@ -127,1 +118,4 @@\n-        CompletableFuture.allOf(first, second)\n+        CompletableFuture<HttpResponse<String>> third = client.sendAsync(\n+                request, HttpResponse.BodyHandlers.ofString());\n+\n+        CompletableFuture.allOf(first, second, third)\n@@ -132,27 +126,25 @@\n-        List<Throwable> failures = List.of(first, second).stream()\n-                .map(f -> f.handle((r, ex) -> ex).join())\n-                .map(ex -> {\n-                    if (ex instanceof CompletionException ce && ce.getCause() != null) {\n-                        return ce.getCause();\n-                    }\n-                    return ex;\n-                })\n-                .filter(Objects::nonNull)\n-                .toList();\n-\n-        assertFalse(failures.isEmpty(), \"At least one request should fail due to GOAWAY\");\n-\n-        boolean hasGoAwayInfo = failures.stream()\n-                .map(Throwable::getMessage)\n-                .filter(Objects::nonNull)\n-                .peek(msg -> System.out.println(\"Failure message: \" + msg))\n-                .anyMatch(msg ->\n-                        msg.contains(\"GOAWAY\")\n-                                && msg.contains(\"Protocol error\")\n-                                && msg.contains(\"0x1\")\n-                                && msg.contains(DEBUG_MESSAGE));\n-\n-        assertTrue(hasGoAwayInfo,\n-                \"Exception message should contain GOAWAY error code and debug data: \" + failures);\n-\n-        assertFalse(secondRequestHandled.get(), \"Second request should not reach server after GOAWAY\");\n+        Throwable firstError = first.handle((r, ex) -> ex).join();\n+        if (firstError instanceof CompletionException ce && ce.getCause() != null) {\n+            firstError = ce.getCause();\n+        }\n+\n+        assertTrue(firstError != null && firstError.getMessage() != null,\n+                \"First request should fail with GOAWAY error\");\n+        assertTrue(firstError.getMessage().contains(\"GOAWAY\")\n+                        && firstError.getMessage().contains(\"Protocol error\")\n+                        && firstError.getMessage().contains(\"0x1\")\n+                        && firstError.getMessage().contains(DEBUG_MESSAGE),\n+                \"First request should contain GOAWAY error details: \" + firstError.getMessage());\n+\n+        HttpResponse<String> secondResponse = second.handle((r, ex) -> r).join();\n+        HttpResponse<String> thirdResponse = third.handle((r, ex) -> r).join();\n+\n+        assertTrue(secondResponse != null && secondResponse.statusCode() == 200,\n+                \"Second request (unprocessed stream) should be retried and succeed\");\n+        assertTrue(thirdResponse != null && thirdResponse.statusCode() == 200,\n+                \"Third request (unprocessed stream) should be retried and succeed\");\n+\n+        assertTrue(secondRequestHandled.get(),\n+                \"Second and third requests should reach server after being retried\");\n+\n+        System.out.println(\"Test passed: GOAWAY error details preserved and unprocessed streams retried\");\n@@ -170,2 +162,1 @@\n-                allowedConnectionKey.compareAndSet(null, impl.getConnectionKey());\n-                System.out.println(\"Handler: sending GOAWAY(PROTOCOL_ERROR) and closing connection\");\n+                System.out.println(\"Handler: sending GOAWAY(PROTOCOL_ERROR, lastStreamId=1) and closing connection\");\n@@ -173,1 +164,1 @@\n-                impl.getServerConnection().sendGoAway(Integer.MAX_VALUE, PROTOCOL_ERROR, DEBUG_DATA);\n+                impl.getServerConnection().sendGoAway(1, PROTOCOL_ERROR, DEBUG_DATA);\n@@ -180,1 +171,3 @@\n-            throw new IOException(\"Second request should not have reached server after GOAWAY\");\n+            System.out.println(\"Handler: successfully handling retried request\");\n+            exchange.sendResponseHeaders(200, 0);\n+            exchange.getResponseBody().close();\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/GoAwayWithErrorTest.java","additions":34,"deletions":41,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -254,18 +254,1 @@\n-        boolean send = false;\n-        int currentGoAwayReqStrmId = goAwayRequestStreamId.get();\n-        \/\/ update the last processed stream id and send a goaway frame if the new last processed\n-        \/\/ stream id is lesser than the last processed stream id sent in\n-        \/\/ a previous goaway frame (if any)\n-        while (currentGoAwayReqStrmId == -1 || maxProcessedStreamId < currentGoAwayReqStrmId) {\n-            if (goAwayRequestStreamId.compareAndSet(currentGoAwayReqStrmId, maxProcessedStreamId)) {\n-                send = true;\n-                break;\n-            }\n-            currentGoAwayReqStrmId = goAwayRequestStreamId.get();\n-        }\n-        if (!send) {\n-            return;\n-        }\n-        final GoAwayFrame frame = new GoAwayFrame(maxProcessedStreamId, error);\n-        outputQ.put(frame);\n-        System.err.println(server.name + \": Sending GOAWAY frame \" + frame + \" from server connection \" + this);\n+        sendGoAway(maxProcessedStreamId, error, new byte[0]);\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestServerConnection.java","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"}]}