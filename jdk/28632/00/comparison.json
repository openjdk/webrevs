{"files":[{"patch":"@@ -1381,0 +1381,2 @@\n+        final int errorCode = frame.getErrorCode();\n+\n@@ -1402,1 +1404,10 @@\n-        handlePeerUnprocessedStreams(lastProcessedStreamInGoAway.get());\n+\n+        \/\/ RFC 9113 section 5.4.1: A GOAWAY frame with a non-zero error code indicates\n+        \/\/ a connection error. The server MUST close the TCP connection after sending\n+        \/\/ the GOAWAY frame. We should fail all pending requests with the error information\n+        \/\/ from the GOAWAY frame rather than waiting for \"Connection closed by peer\".\n+        if (errorCode != ErrorFrame.NO_ERROR) {\n+            handleGoAwayWithError(frame, lastProcessedStreamInGoAway.get(), errorCode);\n+        } else {\n+            handlePeerUnprocessedStreams(lastProcessedStreamInGoAway.get());\n+        }\n@@ -1422,0 +1433,62 @@\n+    \/**\n+     * Handles a GOAWAY frame that was received with a non-zero error code, indicating\n+     * a connection error. Per RFC 9113 section 5.4.1, the server will close the TCP\n+     * connection after sending such a GOAWAY frame. This method fails all pending\n+     * requests with meaningful error information from the GOAWAY frame.\n+     *\n+     * @param frame the GOAWAY frame received\n+     * @param lastProcessedStream the last stream ID processed by the peer\n+     * @param errorCode the HTTP\/2 error code from the GOAWAY frame\n+     *\/\n+    private void handleGoAwayWithError(final GoAwayFrame frame,\n+                                       final long lastProcessedStream,\n+                                       final int errorCode) {\n+        \/\/ Extract debug data from the GOAWAY frame\n+        final byte[] debugData = frame.getDebugData();\n+        final String debugInfo = debugData.length > 0\n+                ? new String(debugData, UTF_8)\n+                : \"\";\n+\n+        \/\/ Create a meaningful error message with the error code and debug data\n+        final String errorName = ErrorFrame.stringForCode(errorCode);\n+        final String errorMsg = debugInfo.isEmpty()\n+                ? String.format(\"Received GOAWAY with error code %s (0x%x)\",\n+                        errorName, errorCode)\n+                : String.format(\"Received GOAWAY with error code %s (0x%x): %s\",\n+                        errorName, errorCode, debugInfo);\n+\n+        if (debug.on()) {\n+            debug.log(\"Handling GOAWAY with error: %s\", errorMsg);\n+        }\n+\n+        \/\/ Create the termination cause with the error information\n+        final Http2TerminationCause cause = Http2TerminationCause.forH2Error(errorCode, errorMsg);\n+\n+        \/\/ Fail all streams appropriately:\n+        \/\/ - Streams with ID > lastProcessedStream were not processed and can be retried\n+        \/\/ - Streams with ID <= lastProcessedStream were being processed and should fail with the error\n+        final AtomicInteger numUnprocessed = new AtomicInteger();\n+        final AtomicInteger numFailed = new AtomicInteger();\n+\n+        streams.forEach((id, stream) -> {\n+            if (id > lastProcessedStream) {\n+                \/\/ Stream was not processed by the peer - mark as unprocessed for retry\n+                stream.closeAsUnprocessed();\n+                numUnprocessed.incrementAndGet();\n+            } else {\n+                \/\/ Stream was being processed - fail it with the connection error\n+                final IOException error = new IOException(errorMsg);\n+                stream.connectionClosing(error);\n+                numFailed.incrementAndGet();\n+            }\n+        });\n+\n+        if (debug.on()) {\n+            debug.log(\"%d stream(s) marked as unprocessed, %d stream(s) failed due to GOAWAY error\",\n+                    numUnprocessed.get(), numFailed.get());\n+        }\n+\n+        \/\/ Terminate the connection immediately\n+        close(cause);\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":74,"deletions":1,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.net.ssl.SSLContext;\n+\n+import jdk.httpclient.test.lib.http2.Http2Handler;\n+import jdk.httpclient.test.lib.http2.Http2TestExchange;\n+import jdk.httpclient.test.lib.http2.Http2TestExchangeImpl;\n+import jdk.httpclient.test.lib.http2.Http2TestServer;\n+import jdk.internal.net.http.frame.ErrorFrame;\n+import jdk.test.lib.net.SimpleSSLContext;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8371903\n+ * @summary Verify that HTTP\/2 client properly handles GOAWAY frames with error codes\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext\n+ *        jdk.httpclient.test.lib.http2.Http2TestServer\n+ *        jdk.httpclient.test.lib.http2.Http2TestExchange\n+ *        jdk.httpclient.test.lib.http2.Http2TestExchangeImpl\n+ * @run junit GoAwayWithErrorTest\n+ *\/\n+\n+public class GoAwayWithErrorTest {\n+\n+    static final int PROTOCOL_ERROR = ErrorFrame.PROTOCOL_ERROR;\n+    static final String DEBUG_MESSAGE = \"Test GOAWAY error from server\";\n+    static final byte[] DEBUG_DATA = DEBUG_MESSAGE.getBytes(UTF_8);\n+    static SSLContext sslContext;\n+    static Http2TestServer server;\n+    static int port;\n+    static AtomicBoolean firstRequestHandled;\n+    static AtomicBoolean secondRequestHandled;\n+    static AtomicReference<String> allowedConnectionKey;\n+    static CountDownLatch goAwaySentLatch;\n+\n+    @BeforeAll\n+    static void setup() throws Exception {\n+        firstRequestHandled = new AtomicBoolean(false);\n+        secondRequestHandled = new AtomicBoolean(false);\n+        allowedConnectionKey = new AtomicReference<>();\n+        goAwaySentLatch = new CountDownLatch(1);\n+        sslContext = new SimpleSSLContext().get();\n+        server = new Http2TestServer(true, 0, null, sslContext);\n+        server.setRequestApprover(key -> {\n+            String allowed = allowedConnectionKey.get();\n+            return allowed == null || allowed.equals(key);\n+        });\n+        server.addHandler(new GoAwayHandler(), \"\/\");\n+        server.start();\n+        port = server.getAddress().getPort();\n+        System.out.println(\"Server started on port: \" + port);\n+    }\n+\n+    @AfterAll\n+    static void teardown() {\n+        if (server != null) {\n+            server.stop();\n+        }\n+    }\n+\n+    @Test\n+    public void testGoAwayWithProtocolError() throws Exception {\n+        HttpClient client = HttpClient.newBuilder()\n+                .sslContext(sslContext)\n+                .version(HTTP_2)\n+                .build();\n+\n+        URI uri = URI.create(\"https:\/\/localhost:\" + port + \"\/test\");\n+        HttpRequest request = HttpRequest.newBuilder(uri)\n+                .GET()\n+                .build();\n+\n+        CompletableFuture<HttpResponse<String>> first = client.sendAsync(\n+                request, HttpResponse.BodyHandlers.ofString());\n+\n+        if (!goAwaySentLatch.await(5, TimeUnit.SECONDS)) {\n+            throw new AssertionError(\"GOAWAY not sent in time\");\n+        }\n+\n+        CompletableFuture<HttpResponse<String>> second = client.sendAsync(\n+                request, HttpResponse.BodyHandlers.ofString());\n+\n+        CompletableFuture.allOf(first, second)\n+                .orTimeout(20, TimeUnit.SECONDS)\n+                .exceptionally(ex -> null)\n+                .join();\n+\n+        List<Throwable> failures = List.of(first, second).stream()\n+                .map(f -> f.handle((r, ex) -> ex).join())\n+                .map(ex -> {\n+                    if (ex instanceof CompletionException ce && ce.getCause() != null) {\n+                        return ce.getCause();\n+                    }\n+                    return ex;\n+                })\n+                .filter(Objects::nonNull)\n+                .toList();\n+\n+        assertFalse(failures.isEmpty(), \"At least one request should fail due to GOAWAY\");\n+\n+        boolean hasGoAwayInfo = failures.stream()\n+                .map(Throwable::getMessage)\n+                .filter(Objects::nonNull)\n+                .peek(msg -> System.out.println(\"Failure message: \" + msg))\n+                .anyMatch(msg ->\n+                        msg.contains(\"GOAWAY\")\n+                                && msg.contains(\"Protocol error\")\n+                                && msg.contains(\"0x1\")\n+                                && msg.contains(DEBUG_MESSAGE));\n+\n+        assertTrue(hasGoAwayInfo,\n+                \"Exception message should contain GOAWAY error code and debug data: \" + failures);\n+\n+        assertFalse(secondRequestHandled.get(), \"Second request should not reach server after GOAWAY\");\n+    }\n+\n+    static class GoAwayHandler implements Http2Handler {\n+\n+        @Override\n+        public void handle(Http2TestExchange exchange) throws IOException {\n+            System.out.println(\"Handler: received request for \" + exchange.getRequestURI());\n+\n+            Http2TestExchangeImpl impl = (Http2TestExchangeImpl) exchange;\n+\n+            if (!firstRequestHandled.getAndSet(true)) {\n+                allowedConnectionKey.compareAndSet(null, impl.getConnectionKey());\n+                System.out.println(\"Handler: sending GOAWAY(PROTOCOL_ERROR) and closing connection\");\n+\n+                impl.getServerConnection().sendGoAway(Integer.MAX_VALUE, PROTOCOL_ERROR, DEBUG_DATA);\n+                impl.getServerConnection().close(PROTOCOL_ERROR);\n+                goAwaySentLatch.countDown();\n+                return;\n+            }\n+\n+            secondRequestHandled.set(true);\n+            throw new IOException(\"Second request should not have reached server after GOAWAY\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/GoAwayWithErrorTest.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"},{"patch":"@@ -247,0 +247,4 @@\n+    public Http2TestServerConnection getServerConnection() {\n+        return conn;\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestExchangeImpl.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -274,0 +274,30 @@\n+    \/**\n+     * Sends a GOAWAY frame with the specified error code and debug data.\n+     * This is useful for testing error handling scenarios.\n+     *\n+     * @param lastStreamId the last stream ID that was or might be processed\n+     * @param errorCode the HTTP\/2 error code\n+     * @param debugData optional debug data (may be empty but not null)\n+     * @throws IOException if an I\/O error occurs\n+     *\/\n+    public void sendGoAway(int lastStreamId, int errorCode, byte[] debugData) throws IOException {\n+        boolean send = false;\n+        int currentGoAwayReqStrmId = goAwayRequestStreamId.get();\n+        \/\/ update the last processed stream id and send a goaway frame if the new last processed\n+        \/\/ stream id is lesser than the last processed stream id sent in\n+        \/\/ a previous goaway frame (if any)\n+        while (currentGoAwayReqStrmId == -1 || lastStreamId < currentGoAwayReqStrmId) {\n+            if (goAwayRequestStreamId.compareAndSet(currentGoAwayReqStrmId, lastStreamId)) {\n+                send = true;\n+                break;\n+            }\n+            currentGoAwayReqStrmId = goAwayRequestStreamId.get();\n+        }\n+        if (!send) {\n+            return;\n+        }\n+        final GoAwayFrame frame = new GoAwayFrame(lastStreamId, errorCode, debugData);\n+        outputQ.put(frame);\n+        System.err.println(server.name + \": Sending GOAWAY frame \" + frame + \" from server connection \" + this);\n+    }\n+\n@@ -327,1 +357,1 @@\n-    void close(int error) {\n+    public void close(int error) {\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestServerConnection.java","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"}]}