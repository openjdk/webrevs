{"files":[{"patch":"@@ -358,1 +358,0 @@\n-  _previous_gc_allocated(0),\n@@ -364,1 +363,20 @@\n-double ShenandoahAllocationRate::sample(size_t allocated) {\n+double ShenandoahAllocationRate::force_sample(size_t allocated, size_t &unaccounted_bytes_allocated) {\n+  const double MinSampleTime = 0.002;    \/\/ Do not sample if time since last update is less than 2 ms\n+  double now = os::elapsedTime();\n+  double time_since_last_update = now -_last_sample_time;\n+  if (time_since_last_update < MinSampleTime) {\n+    unaccounted_bytes_allocated = allocated - _last_sample_value;\n+    _last_sample_value = 0;\n+    return 0.0;\n+  } else {\n+    double rate = instantaneous_rate(now, allocated);\n+    _rate.add(rate);\n+    _rate_avg.add(_rate.avg());\n+    _last_sample_time = now;\n+    _last_sample_value = allocated;\n+    unaccounted_bytes_allocated = 0;\n+    return rate;\n+  }\n+}\n+\n+double ShenandoahAllocationRate::sample(size_t allocated, bool force_update) {\n@@ -368,4 +386,1 @@\n-    \/\/ _previous_gc_allocated will be non-zero only on the first sample added since the start of the current GC.  In the\n-    \/\/ event that no data was sampled during the preceding cycle, _previous_gc_allocated will represent the accumalation\n-    \/\/ of multiple GCs.\n-    rate = instantaneous_rate(now, _previous_gc_allocated + allocated);\n+    rate = instantaneous_rate(now, allocated);\n@@ -376,1 +391,0 @@\n-    _previous_gc_allocated = 0;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -40,1 +40,2 @@\n-  double sample(size_t allocated);\n+  double force_sample(size_t allocated, size_t &unaccounted_bytes_allocated);\n+  double sample(size_t allocated, bool force_update = false);\n@@ -45,7 +46,0 @@\n-  void recalibrate(size_t bytes_allocated) {\n-    \/\/ Under normal conditions, _previous_gc_allocated equals zero on entry to this function.  It will only be non-zero\n-    \/\/ if allocation rate was never sampled during previous GC cycle.\n-    _previous_gc_allocated += bytes_allocated - _last_sample_value;\n-    _last_sample_value = 0;\n-  }\n-\n@@ -58,1 +52,0 @@\n-  size_t _previous_gc_allocated;\n@@ -164,2 +157,4 @@\n-  virtual void recalibrate_alloc_rate_last_sample(size_t bytes_allocated) override {\n-    _allocation_rate.recalibrate(bytes_allocated);\n+  virtual size_t force_alloc_rate_sample(size_t bytes_allocated) override {\n+    size_t unaccounted_bytes;\n+    _allocation_rate.force_sample(bytes_allocated, unaccounted_bytes);\n+    return unaccounted_bytes;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -242,1 +242,3 @@\n-  virtual void recalibrate_alloc_rate_last_sample(size_t bytes_allocated) {\n+  double elapsed_cycle_time() const;\n+\n+  virtual size_t force_alloc_rate_sample(size_t bytes_allocated) {\n@@ -244,0 +246,1 @@\n+    return 0;\n@@ -246,2 +249,0 @@\n-  double elapsed_cycle_time() const;\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -44,0 +44,4 @@\n+\n+  \/\/ Return an approximation of the bytes allocated since GC start.  The value returned is monotonically non-decreasing\n+  \/\/ in time within each GC cycle.  For certain GC cycles, the value returned may include some bytes allocated before\n+  \/\/ the start of the current GC cycle.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahSpaceInfo.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -154,2 +154,2 @@\n-void ShenandoahGeneration::reset_bytes_allocated_since_gc_start() {\n-  AtomicAccess::store(&_bytes_allocated_since_gc_start, (size_t)0);\n+void ShenandoahGeneration::reset_bytes_allocated_since_gc_start(size_t initial_bytes_allocated) {\n+  AtomicAccess::store(&_bytes_allocated_since_gc_start, initial_bytes_allocated);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-  void reset_bytes_allocated_since_gc_start();\n+  void reset_bytes_allocated_since_gc_start(size_t initial_bytes_allocated);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2322,0 +2322,9 @@\n+  \/\/ It is important to force_alloc_rate_sample() before the associated generation's bytes_allocated has been reset.\n+  \/\/ Note that there is no lock to prevent additional alloations between sampling bytes_allocated_since_gc_start() and\n+  \/\/ reset_bytes_allocated_since_gc_start().  If additional allocations happen, they will be ignored in the average\n+  \/\/ allocation rate computations.  This effect is considered to be be negligible.\n+\n+  \/\/ unaccounted_bytes is the bytes not accounted for by our forced sample.  If the sample interval is too short,\n+  \/\/ the \"forced sample\" will not happen, and any recently allocated bytes are \"unaccounted for\".  We pretend these\n+  \/\/ bytes are allocated after the start of subsequent gc.\n+  size_t unaccounted_bytes;\n@@ -2324,3 +2333,4 @@\n-    young_generation()->reset_bytes_allocated_since_gc_start();\n-    old_generation()->reset_bytes_allocated_since_gc_start();\n-    young_generation()->heuristics()->recalibrate_alloc_rate_last_sample(bytes_allocated);\n+    unaccounted_bytes = young_generation()->heuristics()->force_alloc_rate_sample(bytes_allocated);\n+    young_generation()->reset_bytes_allocated_since_gc_start(unaccounted_bytes);\n+    unaccounted_bytes = 0;\n+    old_generation()->reset_bytes_allocated_since_gc_start(unaccounted_bytes);\n@@ -2329,1 +2339,2 @@\n-    heuristics()->recalibrate_alloc_rate_last_sample(bytes_allocated);\n+    \/\/ Single-gen Shenandoah uses global heuristics.\n+    unaccounted_bytes = heuristics()->force_alloc_rate_sample(bytes_allocated);\n@@ -2331,1 +2342,1 @@\n-  global_generation()->reset_bytes_allocated_since_gc_start();\n+  global_generation()->reset_bytes_allocated_since_gc_start(unaccounted_bytes);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"}]}