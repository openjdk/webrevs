{"files":[{"patch":"@@ -2077,0 +2077,46 @@\n+PrintClassClosure::PrintClassClosure(outputStream* st, bool verbose)\n+  :_st(st), _verbose(verbose) {\n+  ResourceMark rm;\n+  _st->print(\"%-18s  \", \"KlassAddr\");\n+  _st->print(\"%-4s  \", \"Size\");\n+  _st->print(\"%-20s  \", \"State\");\n+  _st->print(\"%-7s  \", \"Flags\");\n+  _st->print(\"%-5s  \", \"ClassName\");\n+  _st->cr();\n+}\n+\n+void PrintClassClosure::do_klass(Klass* k)  {\n+  ResourceMark rm;\n+  \/\/ klass pointer\n+  _st->print(INTPTR_FORMAT \"  \", p2i(k));\n+  \/\/ klass size\n+  _st->print(\"%-4d  \", k->size());\n+  \/\/ initialization state\n+  if (k->is_instance_klass()) {\n+    _st->print(\"%-20s  \",InstanceKlass::cast(k)->init_state_name());\n+  } else {\n+    _st->print(\"%-20s  \",\"\");\n+  }\n+  \/\/ misc flags(Changes should synced with ClassesDCmd::ClassesDCmd help doc)\n+  char buf[10];\n+  int i = 0;\n+  if (k->has_finalizer()) buf[i++] = 'F';\n+  if (k->has_final_method()) buf[i++] = 'f';\n+  if (k->is_instance_klass()) {\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    if (ik->is_rewritten()) buf[i++] = 'W';\n+    if (ik->is_contended()) buf[i++] = 'C';\n+    if (ik->has_been_redefined()) buf[i++] = 'R';\n+    if (ik->is_shared()) buf[i++] = 'S';\n+  }\n+  buf[i++] = '\\0';\n+  _st->print(\"%-7s  \", buf);\n+  \/\/ klass name\n+  _st->print(\"%-5s  \", k->external_name());\n+  \/\/ end\n+  _st->cr();\n+  if (_verbose) {\n+    k->print_on(_st);\n+  }\n+}\n+\n@@ -3396,0 +3442,4 @@\n+const char* InstanceKlass::init_state_name() const {\n+  return state_names[_init_state];\n+}\n+\n@@ -3403,1 +3453,1 @@\n-  st->print(BULLET\"state:             \"); st->print_cr(\"%s\", state_names[_init_state]);\n+  st->print(BULLET\"state:             \"); st->print_cr(\"%s\", init_state_name());\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":51,"deletions":1,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -550,0 +550,1 @@\n+  const char* init_state_name() const;\n@@ -1280,0 +1281,9 @@\n+class PrintClassClosure : public KlassClosure {\n+private:\n+  outputStream* _st;\n+  bool _verbose;\n+public:\n+  PrintClassClosure(outputStream* st, bool verbose);\n+\n+  void do_klass(Klass* k);\n+};\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -98,0 +98,1 @@\n+  template(PrintClasses)                          \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"classfile\/classLoaderDataGraph.hpp\"\n@@ -105,0 +106,1 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<ClassesDCmd>(full_export, true, false));\n@@ -957,0 +959,35 @@\n+ClassesDCmd::ClassesDCmd(outputStream* output, bool heap) :\n+                                     DCmdWithParser(output, heap),\n+  _verbose(\"-verbose\",\n+           \"Dump the detailed content of a Java class. \"\n+           \"Some classes are annotated with flags: \"\n+           \"F = has finalize method, \"\n+           \"f = has final method, \"\n+           \"W = methods rewritten, \"\n+           \"C = marked with @Contended annotation, \"\n+           \"R = has been redefined, \"\n+           \"S = is shared class\",\n+           \"BOOLEAN\", false, \"false\") {\n+  _dcmdparser.add_dcmd_option(&_verbose);\n+}\n+\n+class VM_PrintClasses : public VM_Operation {\n+private:\n+  outputStream* _out;\n+  bool _verbose;\n+public:\n+  VM_PrintClasses(outputStream* out, bool verbose) : _out(out), _verbose(verbose) {}\n+\n+  virtual VMOp_Type type() const { return VMOp_PrintClasses; }\n+\n+  virtual void doit() {\n+    PrintClassClosure closure(_out, _verbose);\n+    ClassLoaderDataGraph::classes_do(&closure);\n+  }\n+};\n+\n+void ClassesDCmd::execute(DCmdSource source, TRAPS) {\n+  VM_PrintClasses vmop(output(), _verbose.is_set());\n+  VMThread::execute(&vmop);\n+}\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -861,0 +861,22 @@\n+class ClassesDCmd : public DCmdWithParser {\n+protected:\n+  DCmdArgument<bool> _verbose;\n+public:\n+  ClassesDCmd(outputStream* output, bool heap);\n+  static const char* name() {\n+    return \"VM.classes\";\n+  }\n+  static const char* description() {\n+    return \"Print all loaded classes\";\n+  }\n+  static const char* impact() {\n+      return \"Medium: Depends on number of loaded classes.\";\n+  }\n+  static const JavaPermission permission() {\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n+                        \"monitor\", NULL};\n+    return p;\n+  }\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2022, Alibaba Group Holding Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @bug 8275775\n+ * @summary Test jcmd VM.classes\n+ * @library \/test\/lib\n+ * @run main\/othervm PrintClasses\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.JDKToolFinder;\n+\n+public class PrintClasses {\n+  public static void main(String args[]) throws Exception {\n+    var pid = Long.toString(ProcessHandle.current().pid());\n+    var pb = new ProcessBuilder();\n+\n+    pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.classes\"});\n+    var output = new OutputAnalyzer(pb.start());\n+    output.shouldNotContain(\"instance size\");\n+    output.shouldContain(PrintClasses.class.getSimpleName());\n+\n+    pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.classes\", \"-verbose\"});\n+    output = new OutputAnalyzer(pb.start());\n+    output.shouldContain(\"instance size\");\n+    output.shouldContain(PrintClasses.class.getSimpleName());\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/PrintClasses.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"}]}