{"files":[{"patch":"@@ -26,0 +26,2 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -28,0 +30,2 @@\n+import java.io.InputStream;\n+import java.net.InetAddress;\n@@ -29,0 +33,1 @@\n+import java.net.ServerSocket;\n@@ -34,0 +39,4 @@\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n@@ -58,1 +67,1 @@\n-    void verifyUnresolvedAddress() {\n+    void testUnresolvedAddress() {\n@@ -62,41 +71,8 @@\n-    \/\/ Socket should be closed when `unboundSocket.connect()` fails \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-    @Test\n-    void unboundSocketShouldBeClosedWhenConnectFails() throws Exception {\n-        unboundSocketShouldBeClosedWhenConnectFails(ConnectFailTest::createUnboundSocket);\n-    }\n-\n-    @Test\n-    void unboundNioSocketShouldBeClosedWhenConnectFails() throws Exception {\n-        unboundSocketShouldBeClosedWhenConnectFails(ConnectFailTest::createUnboundNioSocket);\n-    }\n-\n-    private static void unboundSocketShouldBeClosedWhenConnectFails(\n-            ThrowingSupplier<Socket> unboundSocketFactory)\n-            throws Exception {\n-        try (Socket socket = unboundSocketFactory.get()) {\n-            assertFalse(socket.isBound());\n-            assertFalse(socket.isConnected());\n-            assertThrows(IOException.class, () -> socket.connect(REFUSING_SOCKET_ADDRESS));\n-            assertTrue(socket.isClosed());\n-        }\n-    }\n-\n-    \/\/ Socket should be closed when `boundSocket.connect()` fails \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-    @Test\n-    void boundSocketShouldBeClosedWhenConnectFails() throws Exception {\n-        boundSocketShouldBeClosedWhenConnectFails(\n-                ConnectFailTest::createBoundSocket);\n-    }\n-\n-    @Test\n-    void boundNioSocketShouldBeClosedWhenConnectFails() throws Exception {\n-        boundSocketShouldBeClosedWhenConnectFails(\n-                ConnectFailTest::createBoundNioSocket);\n-    }\n-\n-    private static void boundSocketShouldBeClosedWhenConnectFails(\n-            ThrowingSupplier<Socket> boundSocketFactory)\n-            throws Exception {\n-        try (Socket socket = boundSocketFactory.get()) {\n+    \/**\n+     * Verifies socket is closed when {@code unboundSocket.connect()} fails.\n+     * @param socket an unbound socket\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"boundSockets\")\n+    void testBoundSocket(Socket socket) throws IOException {\n+        try (socket) {\n@@ -110,2 +86,0 @@\n-    \/\/ Socket should *NOT* be closed when `connectedSocket.connect()` fails \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n@@ -113,2 +87,2 @@\n-    void connectedSocketShouldNotBeClosedWhenConnectFails() throws Exception {\n-        connectedSocketShouldNotBeClosedWhenConnectFails(\n+    void testConnectedSocket() throws Exception {\n+        testConnectedSocket(\n@@ -123,2 +97,2 @@\n-    void connectedNioSocketShouldNotBeClosedWhenConnectFails() throws Exception {\n-        connectedSocketShouldNotBeClosedWhenConnectFails(\n+    void testConnectedNioSocket() throws Exception {\n+        testConnectedSocket(\n@@ -129,1 +103,6 @@\n-    private static void connectedSocketShouldNotBeClosedWhenConnectFails(\n+    \/**\n+     * Verifies socket is not closed when {@code `connectedSocket.connect()`} fails.\n+     * @param connectedSocketFactory a connected socket factory\n+     * @param reconnectFailureVerifier a consumer verifying the thrown reconnect failure\n+     *\/\n+    private static void testConnectedSocket(\n@@ -133,1 +112,1 @@\n-        ServerSocketTestUtil.withEphemeralServerSocket(serverSocket -> {\n+        withEphemeralServerSocket(serverSocket -> {\n@@ -146,27 +125,8 @@\n-    \/\/ Socket should be closed when `unboundSocket.connect(unresolvedAddress)` fails \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-    @Test\n-    void unboundSocketShouldBeClosedWhenConnectWithUnresolvedAddressFails() throws Exception {\n-        unboundSocketShouldBeClosedWhenConnectWithUnresolvedAddressFails(\n-                ConnectFailTest::createUnboundSocket);\n-    }\n-\n-    private static Socket createUnboundSocket() {\n-        return new Socket();\n-    }\n-\n-    @Test\n-    void unboundNioSocketShouldBeClosedWhenConnectWithUnresolvedAddressFails() throws Exception {\n-        unboundSocketShouldBeClosedWhenConnectWithUnresolvedAddressFails(\n-                ConnectFailTest::createUnboundNioSocket);\n-    }\n-\n-    @SuppressWarnings(\"resource\")\n-    private static Socket createUnboundNioSocket() throws IOException {\n-        return SocketChannel.open().socket();\n-    }\n-\n-    private static void unboundSocketShouldBeClosedWhenConnectWithUnresolvedAddressFails(\n-            ThrowingSupplier<Socket> unboundSocketFactory)\n-            throws Exception {\n-        try (Socket socket = unboundSocketFactory.get()) {\n+    \/**\n+     * Verifies socket is closed when {@code unboundSocket.connect(unresolvedAddress)} fails.\n+     * @param socket an unbound socket\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"unboundSockets\")\n+    void testUnboundSocketWithUnresolvedAddress(Socket socket) throws IOException {\n+        try (socket) {\n@@ -180,20 +140,0 @@\n-    \/\/ Socket should be closed when `boundSocket.connect(unresolvedAddress)` fails \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-    @Test\n-    void boundSocketShouldBeClosedWhenConnectWithUnresolvedAddressFails() throws Exception {\n-        boundSocketShouldBeClosedWhenConnectWithUnresolvedAddressFails(\n-                ConnectFailTest::createBoundSocket);\n-    }\n-\n-    private static Socket createBoundSocket() throws IOException {\n-        Socket socket = new Socket();\n-        socket.bind(new InetSocketAddress(0));\n-        return socket;\n-    }\n-\n-    @Test\n-    void boundNioSocketShouldBeClosedWhenConnectWithUnresolvedAddressFails() throws Exception {\n-        boundSocketShouldBeClosedWhenConnectWithUnresolvedAddressFails(\n-                ConnectFailTest::createBoundNioSocket);\n-    }\n-\n@@ -201,4 +141,4 @@\n-    private static Socket createBoundNioSocket() throws IOException {\n-        SocketChannel channel = SocketChannel.open();\n-        channel.bind(new InetSocketAddress(0));\n-        return channel.socket();\n+    static List<Socket> unboundSockets() throws IOException {\n+        return List.of(\n+                new Socket(),\n+                SocketChannel.open().socket());\n@@ -207,4 +147,8 @@\n-    private static void boundSocketShouldBeClosedWhenConnectWithUnresolvedAddressFails(\n-            ThrowingSupplier<Socket> boundSocketFactory)\n-            throws Exception {\n-        try (Socket socket = boundSocketFactory.get()) {\n+    \/**\n+     * Verifies socket is closed when {@code boundSocket.connect(unresolvedAddress)} fails.\n+     * @param socket a bound socket\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"boundSockets\")\n+    void testBoundSocketWithUnresolvedAddress(Socket socket) throws IOException {\n+        try (socket) {\n@@ -218,1 +162,17 @@\n-    \/\/ Socket should *NOT* be closed when `connectedSocket.connect(unresolvedAddress)` fails \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    @SuppressWarnings(\"resource\")\n+    static List<Socket> boundSockets() throws IOException {\n+        List<Socket> sockets = new ArrayList<>();\n+        \/\/ Socket\n+        {\n+            Socket socket = new Socket();\n+            socket.bind(new InetSocketAddress(0));\n+            sockets.add(socket);\n+        }\n+        \/\/ NIO Socket\n+        {\n+            SocketChannel channel = SocketChannel.open();\n+            channel.bind(new InetSocketAddress(0));\n+            sockets.add(channel.socket());\n+        }\n+        return sockets;\n+    }\n@@ -220,4 +180,24 @@\n-    @Test\n-    void connectedSocketShouldNotBeClosedWhenConnectWithUnresolvedAddressFails() throws Exception {\n-        connectedSocketShouldNotBeClosedWhenConnectWithUnresolvedAddressFails(\n-                ConnectFailTest::createConnectedSocket);\n+    \/**\n+     * Verifies socket is not closed when {@code connectedSocket.connect(unresolvedAddress)} fails.\n+     * @param connectedSocketFactory a connected socket factory\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"connectedSocketFactories\")\n+    void testConnectedSocketWithUnresolvedAddress(\n+            ThrowingFunction<SocketAddress, Socket> connectedSocketFactory)\n+            throws Exception {\n+        withEphemeralServerSocket(serverSocket -> {\n+            SocketAddress serverSocketAddress = serverSocket.getLocalSocketAddress();\n+            try (Socket socket = connectedSocketFactory.apply(serverSocketAddress)) {\n+                assertTrue(socket.isBound());\n+                assertTrue(socket.isConnected());\n+                assertThrows(IOException.class, () -> socket.connect(UNRESOLVED_ADDRESS));\n+                assertFalse(socket.isClosed());\n+            }\n+        });\n+    }\n+\n+    static List<ThrowingFunction<SocketAddress, Socket>> connectedSocketFactories() {\n+        return List.of(\n+                ConnectFailTest::createConnectedSocket,\n+                ConnectFailTest::createConnectedNioSocket);\n@@ -231,6 +211,0 @@\n-    @Test\n-    void connectedNioSocketShouldNotBeClosedWhenConnectWithUnresolvedAddressFails() throws Exception {\n-        connectedSocketShouldNotBeClosedWhenConnectWithUnresolvedAddressFails(\n-                ConnectFailTest::createConnectedNioSocket);\n-    }\n-\n@@ -242,10 +216,33 @@\n-    private static void connectedSocketShouldNotBeClosedWhenConnectWithUnresolvedAddressFails(\n-            ThrowingFunction<SocketAddress, Socket> connectedSocketFactory)\n-            throws Exception {\n-        ServerSocketTestUtil.withEphemeralServerSocket(serverSocket -> {\n-            SocketAddress serverSocketAddress = serverSocket.getLocalSocketAddress();\n-            try (Socket socket = connectedSocketFactory.apply(serverSocketAddress)) {\n-                assertTrue(socket.isBound());\n-                assertTrue(socket.isConnected());\n-                assertThrows(IOException.class, () -> socket.connect(UNRESOLVED_ADDRESS));\n-                assertFalse(socket.isClosed());\n+    private static void withEphemeralServerSocket(ThrowingConsumer<ServerSocket> serverSocketConsumer) throws Exception {\n+        try (ExecutorService executorService = Executors.newVirtualThreadPerTaskExecutor();\n+             ServerSocket serverSocket = new ServerSocket(0, 0, InetAddress.getLoopbackAddress())) {\n+            \/\/ Accept connections in the background to avoid blocking the caller\n+            executorService.submit(() -> acceptConnections(serverSocket));\n+            serverSocketConsumer.accept(serverSocket);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"ResultOfMethodCallIgnored\")\n+    private static void acceptConnections(ServerSocket serverSocket) {\n+        System.err.println(\"[Test socket server] Starting accepting connections\");\n+        while (true) {\n+            try {\n+\n+                \/\/ Accept the connection\n+                Socket clientSocket = serverSocket.accept();\n+                System.err.format(\n+                        \"[Test socket server] Accepted port %d to port %d%n\",\n+                        ((InetSocketAddress) clientSocket.getRemoteSocketAddress()).getPort(),\n+                        clientSocket.getLocalPort());\n+\n+                \/\/ Instead of directly closing the socket, we try to read some to block. Directly closing\n+                \/\/ the socket will invalidate the client socket tests checking the established connection\n+                \/\/ status.\n+                try (clientSocket; InputStream inputStream = clientSocket.getInputStream()) {\n+                    inputStream.read();\n+                } catch (IOException _) {\n+                    \/\/ Do nothing\n+                }\n+\n+            } catch (IOException _) {\n+                break;\n@@ -253,1 +250,3 @@\n-        });\n+\n+        }\n+        System.err.println(\"[Test socket server] Stopping accepting connections\");\n@@ -257,1 +256,1 @@\n-    private interface ThrowingRunnable {\n+    private interface ThrowingConsumer<V> {\n@@ -259,1 +258,1 @@\n-        void run() throws Exception;\n+        void accept(V value) throws Exception;\n@@ -264,1 +263,1 @@\n-    private interface ThrowingSupplier<V> {\n+    private interface ThrowingRunnable {\n@@ -266,1 +265,1 @@\n-        V get() throws Exception;\n+        void run() throws Exception;\n","filename":"test\/jdk\/java\/net\/Socket\/ConnectFailTest.java","additions":130,"deletions":131,"binary":false,"changes":261,"status":"modified"},{"patch":"@@ -1,84 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.net.InetAddress;\n-import java.net.InetSocketAddress;\n-import java.net.ServerSocket;\n-import java.net.Socket;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-\n-\/**\n- * Test utilities for {@link ServerSocket}s.\n- *\/\n-final class ServerSocketTestUtil {\n-\n-    static void withEphemeralServerSocket(ThrowingConsumer<ServerSocket> serverSocketConsumer) throws Exception {\n-        try (ExecutorService executorService = Executors.newVirtualThreadPerTaskExecutor();\n-             ServerSocket serverSocket = new ServerSocket(0, 0, InetAddress.getLoopbackAddress())) {\n-            \/\/ Accept connections in the background to avoid blocking the caller\n-            executorService.submit(() -> acceptConnections(serverSocket));\n-            serverSocketConsumer.accept(serverSocket);\n-        }\n-    }\n-\n-    @SuppressWarnings(\"ResultOfMethodCallIgnored\")\n-    private static void acceptConnections(ServerSocket serverSocket) {\n-        System.err.println(\"[Test socket server] Starting accepting connections\");\n-        while (true) {\n-            try {\n-\n-                \/\/ Accept the connection\n-                Socket clientSocket = serverSocket.accept();\n-                System.err.format(\n-                        \"[Test socket server] Accepted port %d to port %d%n\",\n-                        ((InetSocketAddress) clientSocket.getRemoteSocketAddress()).getPort(),\n-                        clientSocket.getLocalPort());\n-\n-                \/\/ Instead of directly closing the socket, we try to read some to block. Directly closing\n-                \/\/ the socket will invalidate the client socket tests checking the established connection\n-                \/\/ status.\n-                try (clientSocket; InputStream inputStream = clientSocket.getInputStream()) {\n-                    inputStream.read();\n-                } catch (IOException _) {\n-                    \/\/ Do nothing\n-                }\n-\n-            } catch (IOException _) {\n-                break;\n-            }\n-\n-        }\n-        System.err.println(\"[Test socket server] Stopping accepting connections\");\n-    }\n-\n-    @FunctionalInterface\n-    interface ThrowingConsumer<V> {\n-\n-        void accept(V value) throws Exception;\n-\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/net\/Socket\/ServerSocketTestUtil.java","additions":0,"deletions":84,"binary":false,"changes":84,"status":"deleted"},{"patch":"@@ -1,107 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.net.*;\n-\n-\/**\n- * A {@link SocketImpl} implementation where all methods throw {@link UnsupportedOperationException}.\n- * This class is intended to be subclassed by tests, which override its methods to mock certain behaviour.\n- *\/\n-class ThrowingSocketImpl extends SocketImpl {\n-\n-    ThrowingSocketImpl() {}\n-\n-    @Override\n-    protected void create(boolean stream) throws IOException {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    protected void connect(String host, int port) throws IOException {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    protected void connect(InetAddress address, int port) throws IOException {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    protected void connect(SocketAddress address, int timeout) throws IOException {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    protected void bind(InetAddress host, int port) throws IOException {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    protected void listen(int backlog) throws IOException {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    protected void accept(SocketImpl s) throws IOException {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    protected InputStream getInputStream() throws IOException {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    protected OutputStream getOutputStream() throws IOException {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    protected int available() throws IOException {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    protected void close() throws IOException {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    protected void sendUrgentData(int data) throws IOException {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    public void setOption(int optID, Object value) throws SocketException {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    public Object getOption(int optID) throws SocketException {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/net\/Socket\/ThrowingSocketImpl.java","additions":0,"deletions":107,"binary":false,"changes":107,"status":"deleted"}]}