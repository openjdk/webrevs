{"files":[{"patch":"@@ -617,3 +617,1 @@\n-     * connection attempt fails with a checked exception that is neither\n-     * {@linkplain UnknownHostException an address resolution failure} nor\n-     * {@linkplain InterruptedIOException an I\/O interruption}.\n+     * connection attempt fails with an {@link IOException}.\n@@ -624,0 +622,3 @@\n+     * @throws  UnknownHostException if the endpoint address is\n+     *          {@linkplain InetSocketAddress#isUnresolved() not resolved},\n+     *          the socket is closed\n@@ -655,3 +656,1 @@\n-     * connection attempt fails with a {@link SocketTimeoutException} or a checked\n-     * exception that is neither {@linkplain UnknownHostException an address resolution\n-     * failure} nor {@linkplain InterruptedIOException an I\/O interruption}.\n+     * connection attempt fails with an {@link IOException}.\n@@ -663,1 +662,5 @@\n-     * @throws  SocketTimeoutException if timeout expires before connecting\n+     * @throws  SocketTimeoutException if timeout expires before connecting,\n+     *          the socket is closed\n+     * @throws  UnknownHostException if the endpoint address is\n+     *          {@linkplain InetSocketAddress#isUnresolved() not resolved},\n+     *          the socket is closed\n@@ -703,14 +706,0 @@\n-        } catch (SocketTimeoutException error) {\n-            closeQuietly(error);\n-            throw error;\n-        } catch (InterruptedIOException error) {\n-            Thread thread = Thread.currentThread();\n-            if (thread.isVirtual() && thread.isInterrupted()) {\n-                close();\n-                throw new SocketException(\"Closed by interrupt\");\n-            }\n-            throw error;\n-        } catch (UnknownHostException error) {\n-            \/\/ `UnknownHostException` implies that a connection attempt hasn't been made yet.\n-            \/\/ Hence, the state can be kept as is, no need to close the socket.\n-            throw error;\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":10,"deletions":21,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -567,1 +567,1 @@\n-            throw new UnknownHostException(isa.getHostName());\n+            throw new UnknownHostException(\"Unresolved address: \" + isa.getHostName());\n@@ -612,1 +612,1 @@\n-                throw ioe;\n+                throw new SocketException(\"Closed by interrupt\");\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/NioSocketImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.io.InterruptedIOException;\n@@ -38,1 +37,0 @@\n-import java.net.SocketException;\n@@ -40,2 +38,0 @@\n-import java.net.SocketTimeoutException;\n-import java.net.UnknownHostException;\n@@ -46,1 +42,0 @@\n-import static org.junit.jupiter.api.Assertions.assertInstanceOf;\n@@ -49,1 +44,0 @@\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -56,1 +50,1 @@\n- * @run junit\/othervm --add-opens java.base\/java.net=ALL-UNNAMED CloseOnConnectFailureTest\n+ * @run junit\/othervm --add-opens java.base\/java.net=ALL-UNNAMED CloseOnFailureTest\n@@ -131,1 +125,0 @@\n-        testCase.runner.accept(() -> {\n@@ -133,15 +126,2 @@\n-            \/\/ Create a socket using the mock `SocketImpl` configured to fail\n-            withSocketImplFactory(() -> testCase.socketImpl, () -> {\n-\n-                \/\/ Trigger the failure\n-                Exception error = assertThrows(Exception.class, () -> {\n-                    InetAddress address = InetAddress.getLoopbackAddress();\n-                    \/\/ Address and port are mostly ineffective.\n-                    \/\/ They just need to be _valid enough_ to reach to the point where both `SocketImpl#bind()` and `SocketImpl#connect()` are invoked.\n-                    \/\/ Failure will be triggered by the injected `SocketImpl`.\n-                    new Socket(address, 0xDEAD, address, 0xBEEF);\n-                });\n-\n-                \/\/ Run verifications\n-                testCase.caughtErrorVerifier.accept(error);\n-                testCase.socketImplVerifier.run();\n+        \/\/ Create a socket using the mock `SocketImpl` configured to fail\n+        withSocketImplFactory(() -> testCase.socketImpl, () -> {\n@@ -149,0 +129,7 @@\n+            \/\/ Trigger the failure\n+            Exception error = assertThrows(Exception.class, () -> {\n+                InetAddress address = InetAddress.getLoopbackAddress();\n+                \/\/ Address and port are mostly ineffective.\n+                \/\/ They just need to be _valid enough_ to reach to the point where both `SocketImpl#bind()` and `SocketImpl#connect()` are invoked.\n+                \/\/ Failure will be triggered by the injected `SocketImpl`.\n+                new Socket(address, 0xDEAD, address, 0xBEEF);\n@@ -151,0 +138,4 @@\n+            \/\/ Run verifications\n+            testCase.caughtErrorVerifier.accept(error);\n+            testCase.socketImplVerifier.run();\n+\n@@ -152,0 +143,1 @@\n+\n@@ -157,3 +149,0 @@\n-                TestCase.ForConnectFailure.ofInterruptedIOExceptionInInterruptedVirtualThread(),\n-                TestCase.ForConnectFailure.ofInterruptedIOException(1),\n-                TestCase.ForConnectFailure.ofSocketTimeoutException(),\n@@ -161,1 +150,0 @@\n-                TestCase.ForConnectFailure.ofUnknownHostException(1),\n@@ -169,1 +157,0 @@\n-        testCase.runner.accept(() -> {\n@@ -171,2 +158,2 @@\n-            \/\/ Create a socket using the mock `SocketImpl` configured to fail\n-            try (Socket socket = new Socket(testCase.socketImpl) {}) {\n+        \/\/ Create a socket using the mock `SocketImpl` configured to fail\n+        try (Socket socket = new Socket(testCase.socketImpl) {}) {\n@@ -174,8 +161,8 @@\n-                \/\/ Trigger the failure\n-                Exception error = assertThrows(Exception.class, () -> {\n-                    SocketAddress address = Utils.refusingEndpoint();\n-                    \/\/ Address and timeout are mostly ineffective.\n-                    \/\/ They just need to be _valid enough_ to reach to the `SocketImpl#connect()` invocation.\n-                    \/\/ Failure will be triggered by the injected `SocketImpl`.\n-                    socket.connect(address, 10_000);\n-                });\n+            \/\/ Trigger the failure\n+            Exception error = assertThrows(Exception.class, () -> {\n+                SocketAddress address = Utils.refusingEndpoint();\n+                \/\/ Address and timeout are mostly ineffective.\n+                \/\/ They just need to be _valid enough_ to reach to the `SocketImpl#connect()` invocation.\n+                \/\/ Failure will be triggered by the injected `SocketImpl`.\n+                socket.connect(address, 10_000);\n+            });\n@@ -183,4 +170,4 @@\n-                \/\/ Run verifications\n-                testCase.caughtErrorVerifier.accept(error);\n-                testCase.socketImplVerifier.run();\n-                testCase.socketVerifier.accept(socket);\n+            \/\/ Run verifications\n+            testCase.caughtErrorVerifier.accept(error);\n+            testCase.socketImplVerifier.run();\n+            testCase.socketVerifier.accept(socket);\n@@ -188,1 +175,1 @@\n-            }\n+        }\n@@ -190,1 +177,0 @@\n-        });\n@@ -195,3 +181,0 @@\n-                TestCase.ForConnectFailure.ofInterruptedIOExceptionInInterruptedVirtualThread(),\n-                TestCase.ForConnectFailure.ofInterruptedIOException(0),\n-                TestCase.ForConnectFailure.ofSocketTimeoutException(),\n@@ -199,1 +182,0 @@\n-                TestCase.ForConnectFailure.ofUnknownHostException(0),\n@@ -206,1 +188,0 @@\n-            ThrowingConsumer<ThrowingRunnable> runner,\n@@ -225,1 +206,0 @@\n-                        ThrowingRunnable::run,\n@@ -236,67 +216,0 @@\n-            private static TestCase ofInterruptedIOExceptionInInterruptedVirtualThread() {\n-\n-                \/\/ Runner executing the body in an interrupted virtual thread\n-                ThrowingConsumer<ThrowingRunnable> interruptedVirtualThreadRunner =\n-                        runnable -> Thread.ofVirtual().start(() -> {\n-                            Thread.currentThread().interrupt();\n-                            try {\n-                                runnable.run();\n-                            } catch (Throwable error) {\n-                                throw new RuntimeException(error);\n-                            }\n-                        });\n-\n-                \/\/ Return a case for `InterruptedIOException` in an interrupted virtual thread\n-                Exception connectError = new InterruptedIOException(ERROR_MESSAGE);\n-                MockSocketImpl socketImpl = new MockSocketImpl(null, connectError);\n-                String description = String.format(\n-                        \"%s.%s (using interrupted virtual thread runner)\",\n-                        ForConnectFailure.class.getSimpleName(),\n-                        connectError.getClass().getSimpleName());\n-                return new TestCase(\n-                        description,\n-                        interruptedVirtualThreadRunner,\n-                        socketImpl,\n-                        caughtError -> {\n-                            assertEquals(\"Closed by interrupt\", caughtError.getMessage());\n-                            assertInstanceOf(SocketException.class, caughtError);\n-                        },\n-                        () -> assertEquals(1, socketImpl.closeInvocationCounter.get()),\n-                        socket -> assertTrue(socket.isClosed()));\n-\n-            }\n-\n-            private static TestCase ofInterruptedIOException(int expectedCloseInvocationCount) {\n-                Exception connectError = new InterruptedIOException(ERROR_MESSAGE);\n-                MockSocketImpl socketImpl = new MockSocketImpl(null, connectError);\n-                String description = String.format(\n-                        \"%s.%s\",\n-                        ForConnectFailure.class.getSimpleName(),\n-                        connectError.getClass().getSimpleName());\n-                return new TestCase(\n-                        description,\n-                        ThrowingRunnable::run,\n-                        socketImpl,\n-                        caughtError -> assertSame(connectError, caughtError),\n-                        () -> assertEquals(\n-                                expectedCloseInvocationCount,\n-                                socketImpl.closeInvocationCounter.get()),\n-                        socket -> assertTrue(expectedCloseInvocationCount == 0 || socket.isClosed()));\n-            }\n-\n-            private static TestCase ofSocketTimeoutException() {\n-                Exception connectError = new SocketTimeoutException(ERROR_MESSAGE);\n-                MockSocketImpl socketImpl = new MockSocketImpl(null, connectError);\n-                String description = String.format(\n-                        \"%s.%s\",\n-                        ForConnectFailure.class.getSimpleName(),\n-                        connectError.getClass().getSimpleName());\n-                return new TestCase(\n-                        description,\n-                        ThrowingRunnable::run,\n-                        socketImpl,\n-                        caughtError -> assertSame(connectError, caughtError),\n-                        () -> assertEquals(1, socketImpl.closeInvocationCounter.get()),\n-                        socket -> assertTrue(socket.isClosed()));\n-            }\n-\n@@ -312,1 +225,0 @@\n-                        ThrowingRunnable::run,\n@@ -319,18 +231,0 @@\n-            private static TestCase ofUnknownHostException(int expectedCloseInvocationCount) {\n-                Exception connectError = new UnknownHostException(ERROR_MESSAGE);\n-                MockSocketImpl socketImpl = new MockSocketImpl(null, connectError);\n-                String description = String.format(\n-                        \"%s.%s\",\n-                        ForConnectFailure.class.getSimpleName(),\n-                        connectError.getClass().getSimpleName());\n-                return new TestCase(\n-                        description,\n-                        ThrowingRunnable::run,\n-                        socketImpl,\n-                        caughtError -> assertSame(connectError, caughtError),\n-                        () -> assertEquals(\n-                                expectedCloseInvocationCount,\n-                                socketImpl.closeInvocationCounter.get()),\n-                        _ -> {});\n-            }\n-\n@@ -346,1 +240,0 @@\n-                        ThrowingRunnable::run,\n@@ -365,1 +258,0 @@\n-                        ThrowingRunnable::run,\n","filename":"test\/jdk\/java\/net\/Socket\/CloseOnFailureTest.java","additions":30,"deletions":138,"binary":false,"changes":168,"status":"modified"}]}