{"files":[{"patch":"@@ -457,0 +457,1 @@\n+        assert address instanceof InetSocketAddress;\n@@ -466,1 +467,1 @@\n-            if (localAddr != null)\n+            if (localAddr != null) {\n@@ -468,6 +469,0 @@\n-            connect(address);\n-        } catch (IOException | IllegalArgumentException e) {\n-            try {\n-                close();\n-            } catch (IOException ce) {\n-                e.addSuppressed(ce);\n@@ -475,1 +470,4 @@\n-            throw e;\n+            connect(address);\n+        } catch (Throwable throwable) {\n+            closeSuppressingExceptions(throwable);\n+            throw throwable;\n@@ -574,0 +572,4 @@\n+     * <p> If the endpoint is an unresolved {@link InetSocketAddress}, or the\n+     * connection cannot be established, then the socket is closed, and an\n+     * {@link IOException} is thrown.\n+     *\n@@ -592,0 +594,2 @@\n+     * @throws  UnknownHostException if the endpoint is an unresolved\n+     *          {@link InetSocketAddress}\n@@ -608,0 +612,5 @@\n+     * <p> If the endpoint is an unresolved {@link InetSocketAddress}, the\n+     * connection cannot be established, or the timeout expires before the\n+     * connection is established, then the socket is closed, and an\n+     * {@link IOException} is thrown.\n+     *\n@@ -628,0 +637,2 @@\n+     * @throws  UnknownHostException if the endpoint is an unresolved\n+     *          {@link InetSocketAddress}\n@@ -652,0 +663,6 @@\n+        if (epoint.isUnresolved()) {\n+            var uhe = new UnknownHostException(epoint.getHostName() + \" is unresolved\");\n+            closeSuppressingExceptions(uhe);\n+            throw uhe;\n+        }\n+\n@@ -653,1 +670,0 @@\n-        int port = epoint.getPort();\n@@ -658,9 +674,3 @@\n-        } catch (SocketTimeoutException e) {\n-            throw e;\n-        } catch (InterruptedIOException e) {\n-            Thread thread = Thread.currentThread();\n-            if (thread.isVirtual() && thread.isInterrupted()) {\n-                close();\n-                throw new SocketException(\"Closed by interrupt\");\n-            }\n-            throw e;\n+        } catch (IOException error) {\n+            closeSuppressingExceptions(error);\n+            throw error;\n@@ -1592,0 +1602,8 @@\n+    private void closeSuppressingExceptions(Throwable parentException) {\n+        try {\n+            close();\n+        } catch (IOException exception) {\n+            parentException.addSuppressed(exception);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":36,"deletions":18,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.nio.channels.AlreadyConnectedException;\n@@ -169,0 +170,2 @@\n+        else if (x instanceof AlreadyConnectedException)\n+            nx = newSocketException(\"already connected\");\n@@ -193,4 +196,1 @@\n-    static void translateException(Exception x,\n-                                   boolean unknownHostForUnresolved)\n-        throws IOException\n-    {\n+    static void translateException(Exception x) throws IOException {\n@@ -199,7 +199,0 @@\n-        \/\/ Throw UnknownHostException from here since it cannot\n-        \/\/ be thrown as a SocketException\n-        if (unknownHostForUnresolved &&\n-            (x instanceof UnresolvedAddressException))\n-        {\n-             throw new UnknownHostException();\n-        }\n@@ -209,10 +202,0 @@\n-    static void translateException(Exception x)\n-        throws IOException\n-    {\n-        translateException(x, false);\n-    }\n-\n-    private static InetSocketAddress getLoopbackAddress(int port) {\n-        return new InetSocketAddress(InetAddress.getLoopbackAddress(), port);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Net.java","additions":4,"deletions":21,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -602,1 +602,1 @@\n-            if (ioe instanceof InterruptedIOException) {\n+            if (ioe instanceof SocketTimeoutException) {\n@@ -604,0 +604,3 @@\n+            } else if (ioe instanceof InterruptedIOException) {\n+                assert Thread.currentThread().isVirtual();\n+                throw new SocketException(\"Closed by interrupt\");\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/NioSocketImpl.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.net.UnknownHostException;\n@@ -88,0 +89,8 @@\n+        if (remote instanceof InetSocketAddress isa && isa.isUnresolved()) {\n+            if (!sc.isOpen())\n+                throw new SocketException(\"Socket is closed\");\n+            if (sc.isConnected())\n+                throw new SocketException(\"Already connected\");\n+            close();\n+            throw new UnknownHostException(remote.toString());\n+        }\n@@ -98,1 +107,1 @@\n-            Net.translateException(e, true);\n+            Net.translateException(e);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketAdaptor.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.net.UnknownHostException;\n+import java.nio.channels.SocketChannel;\n+import java.util.List;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8343791\n+ * @summary verifies that `connect()` failures throw expected exception and leave both `Socket` and the underlying\n+ *          `SocketImpl` at the same expected state\n+ * @library \/test\/lib\n+ * @run junit ConnectFailTest\n+ *\/\n+class ConnectFailTest {\n+\n+    private static final int DEAD_SERVER_PORT = 0xDEAD;\n+\n+    private static final InetSocketAddress REFUSING_SOCKET_ADDRESS = Utils.refusingEndpoint();\n+\n+    private static final InetSocketAddress UNRESOLVED_ADDRESS =\n+            InetSocketAddress.createUnresolved(\"no.such.host\", DEAD_SERVER_PORT);\n+\n+    @Test\n+    void testUnresolvedAddress() {\n+        assertTrue(UNRESOLVED_ADDRESS.isUnresolved());\n+    }\n+\n+    \/**\n+     * Verifies socket is closed when {@code unboundSocket.connect()} fails.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"sockets\")\n+    void testUnboundSocket(Socket socket) throws IOException {\n+        try (socket) {\n+            assertFalse(socket.isBound());\n+            assertFalse(socket.isConnected());\n+            assertThrows(IOException.class, () -> socket.connect(REFUSING_SOCKET_ADDRESS));\n+            assertTrue(socket.isClosed());\n+        }\n+    }\n+\n+    \/**\n+     * Verifies socket is closed when {@code boundSocket.connect()} fails.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"sockets\")\n+    void testBoundSocket(Socket socket) throws IOException {\n+        try (socket) {\n+            socket.bind(new InetSocketAddress(0));\n+            assertTrue(socket.isBound());\n+            assertFalse(socket.isConnected());\n+            assertThrows(IOException.class, () -> socket.connect(REFUSING_SOCKET_ADDRESS));\n+            assertTrue(socket.isClosed());\n+        }\n+    }\n+\n+    \/**\n+     * Verifies socket is not closed when {@code `connectedSocket.connect()`} fails.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"sockets\")\n+    void testConnectedSocket(Socket socket) throws Throwable {\n+        try (socket; ServerSocket serverSocket = createEphemeralServerSocket()) {\n+            socket.connect(serverSocket.getLocalSocketAddress());\n+            try (Socket _ = serverSocket.accept()) {\n+                assertTrue(socket.isBound());\n+                assertTrue(socket.isConnected());\n+                SocketException exception = assertThrows(\n+                        SocketException.class,\n+                        () -> socket.connect(REFUSING_SOCKET_ADDRESS));\n+                assertEquals(\"already connected\", exception.getMessage());\n+                assertFalse(socket.isClosed());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Verifies socket is closed when {@code unboundSocket.connect(unresolvedAddress)} fails.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"sockets\")\n+    void testUnboundSocketWithUnresolvedAddress(Socket socket) throws IOException {\n+        try (socket) {\n+            assertFalse(socket.isBound());\n+            assertFalse(socket.isConnected());\n+            assertThrows(UnknownHostException.class, () -> socket.connect(UNRESOLVED_ADDRESS));\n+            assertTrue(socket.isClosed());\n+        }\n+    }\n+\n+    \/**\n+     * Verifies socket is closed when {@code boundSocket.connect(unresolvedAddress)} fails.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"sockets\")\n+    void testBoundSocketWithUnresolvedAddress(Socket socket) throws IOException {\n+        try (socket) {\n+            socket.bind(new InetSocketAddress(0));\n+            assertTrue(socket.isBound());\n+            assertFalse(socket.isConnected());\n+            assertThrows(UnknownHostException.class, () -> socket.connect(UNRESOLVED_ADDRESS));\n+            assertTrue(socket.isClosed());\n+        }\n+    }\n+\n+    \/**\n+     * Verifies socket is not closed when {@code connectedSocket.connect(unresolvedAddress)} fails.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"sockets\")\n+    void testConnectedSocketWithUnresolvedAddress(Socket socket) throws Throwable {\n+        try (socket; ServerSocket serverSocket = createEphemeralServerSocket()) {\n+            socket.connect(serverSocket.getLocalSocketAddress());\n+            try (Socket _ = serverSocket.accept()) {\n+                assertTrue(socket.isBound());\n+                assertTrue(socket.isConnected());\n+                assertThrows(IOException.class, () -> socket.connect(UNRESOLVED_ADDRESS));\n+                assertFalse(socket.isClosed());\n+            }\n+        }\n+    }\n+\n+    static List<Socket> sockets() throws Exception {\n+        Socket socket = new Socket();\n+        @SuppressWarnings(\"resource\")\n+        Socket channelSocket = SocketChannel.open().socket();\n+        return List.of(socket, channelSocket);\n+    }\n+\n+    private static ServerSocket createEphemeralServerSocket() throws IOException {\n+        return new ServerSocket(0, 0, InetAddress.getLoopbackAddress());\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/Socket\/ConnectFailTest.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"}]}