{"files":[{"patch":"@@ -488,0 +488,1 @@\n+        assert address instanceof InetSocketAddress isa && !isa.isUnresolved();\n@@ -496,5 +497,1 @@\n-        try {\n-            if (localAddr != null)\n-                bind(localAddr);\n-            connect(address);\n-        } catch (IOException | IllegalArgumentException | SecurityException e) {\n+        if (localAddr != null) {\n@@ -502,3 +499,4 @@\n-                close();\n-            } catch (IOException ce) {\n-                e.addSuppressed(ce);\n+                    bind(localAddr);\n+            } catch (Throwable throwable) {\n+                closeQuietly(throwable);\n+                throw throwable;\n@@ -506,1 +504,0 @@\n-            throw e;\n@@ -508,0 +505,1 @@\n+        connect(address);   \/\/ `connect()` closes the socket if it throws\n@@ -605,0 +603,4 @@\n+     * <p> If the endpoint is an unresolved {@link InetSocketAddress}, or the\n+     * connection cannot be established, then the socket is closed and an\n+     * {@link IOException} is thrown.\n+     *\n@@ -623,0 +625,2 @@\n+     * @throws  UnknownHostException if the endpoint is an unresolved\n+     *          {@link InetSocketAddress}\n@@ -639,0 +643,5 @@\n+     * <p> If the endpoint is an unresolved {@link InetSocketAddress}, the\n+     * connection cannot be established, or the timeout expires before the\n+     * connection is established, then the socket is closed and an\n+     * {@link IOException} is thrown.\n+     *\n@@ -658,1 +667,2 @@\n-     * @throws  SocketTimeoutException if timeout expires before connecting\n+     * @throws  UnknownHostException if the endpoint is an unresolved\n+     *          {@link InetSocketAddress}\n@@ -683,0 +693,5 @@\n+        if (epoint.isUnresolved()) {\n+            close();\n+            throw new UnknownHostException(epoint.getHostName() + \" is unresolved\");\n+        }\n+\n@@ -698,9 +713,3 @@\n-        } catch (SocketTimeoutException e) {\n-            throw e;\n-        } catch (InterruptedIOException e) {\n-            Thread thread = Thread.currentThread();\n-            if (thread.isVirtual() && thread.isInterrupted()) {\n-                close();\n-                throw new SocketException(\"Closed by interrupt\");\n-            }\n-            throw e;\n+        } catch (IOException error) {\n+            closeQuietly(error);\n+            throw error;\n@@ -1643,0 +1652,10 @@\n+    private void closeQuietly(Throwable parentError) {\n+        try {\n+            close();\n+        } catch (IOException error) {\n+            if (error != parentError) {\n+                parentError.addSuppressed(error);\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":38,"deletions":19,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -567,1 +567,1 @@\n-            throw new UnknownHostException(isa.getHostName());\n+            throw new UnknownHostException(\"Unresolved address: \" + isa.getHostName());\n@@ -612,1 +612,1 @@\n-                throw ioe;\n+                throw new SocketException(\"Closed by interrupt\");\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/NioSocketImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,268 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import org.junit.function.ThrowingRunnable;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.function.ThrowingConsumer;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Field;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketAddress;\n+import java.net.SocketImplFactory;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8343791\n+ * @summary verifies the socket is closed on `connect()` failures\n+ * @library \/test\/lib\n+ * @run junit\/othervm --add-opens java.base\/java.net=ALL-UNNAMED CloseOnFailureTest\n+ *\/\n+class CloseOnFailureTest {\n+\n+    private static final VarHandle SOCKET_IMPL_FACTORY_HANDLE = createSocketImplFactoryHandle();\n+\n+    private static VarHandle createSocketImplFactoryHandle() {\n+        try {\n+            Field field = Socket.class.getDeclaredField(\"factory\");\n+            field.setAccessible(true);\n+            return MethodHandles\n+                    .privateLookupIn(Socket.class, MethodHandles.lookup())\n+                    .findStaticVarHandle(Socket.class, \"factory\", SocketImplFactory.class);\n+        } catch (NoSuchFieldException | IllegalAccessException error) {\n+            throw new RuntimeException(error);\n+        }\n+    }\n+\n+    private static void withSocketImplFactory(SocketImplFactory newFactory, ThrowingRunnable runnable) throws Throwable {\n+        SocketImplFactory oldFactory = (SocketImplFactory) SOCKET_IMPL_FACTORY_HANDLE.getAndSet(newFactory);\n+        try {\n+            runnable.run();\n+        } finally {\n+            SOCKET_IMPL_FACTORY_HANDLE.set(oldFactory);\n+        }\n+    }\n+\n+    private static final class MockSocketImpl extends ThrowingSocketImpl {\n+\n+        private final AtomicInteger closeInvocationCounter = new AtomicInteger(0);\n+\n+        private final Exception bindError;\n+\n+        private final Exception connectError;\n+\n+        private MockSocketImpl(Exception bindError, Exception connectError) {\n+            this.bindError = bindError;\n+            this.connectError = connectError;\n+        }\n+\n+        @Override\n+        protected void create(boolean stream) {}\n+\n+        @Override\n+        protected void bind(InetAddress host, int port) throws IOException {\n+            throwIfPresent(bindError);\n+        }\n+\n+        @Override\n+        protected void connect(SocketAddress address, int timeoutMillis) throws IOException {\n+            throwIfPresent(connectError);\n+        }\n+\n+        private void throwIfPresent(Exception connectError) throws IOException {\n+            if (connectError != null) {\n+                switch (connectError) {\n+                    case IOException error -> throw error;\n+                    case RuntimeException error -> throw error;\n+                    default -> throw new IllegalStateException(\n+                            \"unknown connectError type: \" + connectError.getClass().getCanonicalName());\n+                }\n+            }\n+        }\n+\n+        @Override\n+        protected void close() {\n+            closeInvocationCounter.incrementAndGet();\n+        }\n+\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"ctor_should_close_on_failures\")\n+    @SuppressWarnings(\"resource\")\n+    void ctor_should_close_on_failures(TestCase testCase) throws Throwable {\n+\n+        \/\/ Create a socket using the mock `SocketImpl` configured to fail\n+        withSocketImplFactory(() -> testCase.socketImpl, () -> {\n+\n+            \/\/ Trigger the failure\n+            Exception error = assertThrows(Exception.class, () -> {\n+                InetAddress address = InetAddress.getLoopbackAddress();\n+                \/\/ Address and port are mostly ineffective.\n+                \/\/ They just need to be _valid enough_ to reach to the point where both `SocketImpl#bind()` and `SocketImpl#connect()` are invoked.\n+                \/\/ Failure will be triggered by the injected `SocketImpl`.\n+                new Socket(address, 0xDEAD, address, 0xBEEF);\n+            });\n+\n+            \/\/ Run verifications\n+            testCase.caughtErrorVerifier.accept(error);\n+            testCase.socketImplVerifier.run();\n+\n+        });\n+\n+    }\n+\n+    static List<TestCase> ctor_should_close_on_failures() {\n+        return List.of(TestCase.ForBindFailure.ofIOException());\n+    }\n+\n+    @Test\n+    void connect_should_close_on_unresolved_address() throws IOException {\n+        MockSocketImpl socketImpl = new MockSocketImpl(null, null);\n+        try (Socket socket = new Socket(socketImpl) {}) {\n+            InetSocketAddress address = InetSocketAddress.createUnresolved(\"no.such.host\", 0xBEEF);\n+            assertTrue(address.isUnresolved());\n+            assertThrows(\n+                    UnknownHostException.class,\n+                    () -> socket.connect(address, 10_000),\n+                    () -> address.getHostName() + \" is unresolved\");\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"connect_should_close_on_failures\")\n+    void connect_should_close_on_failures(TestCase testCase) throws Throwable {\n+\n+        \/\/ Create a socket using the mock `SocketImpl` configured to fail\n+        try (Socket socket = new Socket(testCase.socketImpl) {}) {\n+\n+            \/\/ Trigger the failure\n+            Exception error = assertThrows(Exception.class, () -> {\n+                SocketAddress address = Utils.refusingEndpoint();\n+                \/\/ Address and timeout are mostly ineffective.\n+                \/\/ They just need to be _valid enough_ to reach to the `SocketImpl#connect()` invocation.\n+                \/\/ Failure will be triggered by the injected `SocketImpl`.\n+                socket.connect(address, 10_000);\n+            });\n+\n+            \/\/ Run verifications\n+            testCase.caughtErrorVerifier.accept(error);\n+            testCase.socketImplVerifier.run();\n+            testCase.socketVerifier.accept(socket);\n+\n+        }\n+\n+    }\n+\n+    static List<TestCase> connect_should_close_on_failures() {\n+        return List.of(\n+                TestCase.ForConnectFailure.ofIOException(),\n+                TestCase.ForConnectFailure.ofIllegalArgumentException());\n+    }\n+\n+    private record TestCase(\n+            String description,\n+            MockSocketImpl socketImpl,\n+            ThrowingConsumer<Exception> caughtErrorVerifier,\n+            ThrowingRunnable socketImplVerifier,\n+            ThrowingConsumer<Socket> socketVerifier) {\n+\n+        private static final String ERROR_MESSAGE = \"intentional test failure\";\n+\n+        private static final class ForBindFailure {\n+\n+            private static TestCase ofIOException() {\n+                Exception bindError = new IOException(ERROR_MESSAGE);\n+                MockSocketImpl socketImpl = new MockSocketImpl(bindError, null);\n+                String description = String.format(\n+                        \"%s.%s\",\n+                        ForBindFailure.class.getSimpleName(),\n+                        bindError.getClass().getSimpleName());\n+                return new TestCase(\n+                        description,\n+                        socketImpl,\n+                        caughtError -> assertSame(bindError, caughtError),\n+                        () -> assertEquals(1, socketImpl.closeInvocationCounter.get()),\n+                        _ -> {});\n+            }\n+\n+        }\n+\n+        private static final class ForConnectFailure {\n+\n+            private static TestCase ofIOException() {\n+                Exception connectError = new IOException(ERROR_MESSAGE);\n+                MockSocketImpl socketImpl = new MockSocketImpl(null, connectError);\n+                String description = String.format(\n+                        \"%s.%s\",\n+                        ForConnectFailure.class.getSimpleName(),\n+                        connectError.getClass().getSimpleName());\n+                return new TestCase(\n+                        description,\n+                        socketImpl,\n+                        caughtError -> assertSame(connectError, caughtError),\n+                        () -> assertEquals(1, socketImpl.closeInvocationCounter.get()),\n+                        _ -> {});\n+            }\n+\n+            private static TestCase ofIllegalArgumentException() {\n+                Exception connectError = new IllegalArgumentException(ERROR_MESSAGE);\n+                MockSocketImpl socketImpl = new MockSocketImpl(null, connectError);\n+                String description = String.format(\n+                        \"%s.%s\",\n+                        ForConnectFailure.class.getSimpleName(),\n+                        connectError.getClass().getSimpleName());\n+                return new TestCase(\n+                        description,\n+                        socketImpl,\n+                        caughtError -> assertSame(connectError, caughtError),\n+                        () -> assertEquals(0, socketImpl.closeInvocationCounter.get()),\n+                        _ -> {\n+                        });\n+            }\n+\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return description;\n+        }\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/Socket\/CloseOnFailureTest.java","additions":268,"deletions":0,"binary":false,"changes":268,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.*;\n+\n+\/**\n+ * A {@link SocketImpl} implementation where all methods throw {@link UnsupportedOperationException}.\n+ * This class is intended to be subclassed by tests, which override its methods to mock certain behaviour.\n+ *\/\n+class ThrowingSocketImpl extends SocketImpl {\n+\n+    ThrowingSocketImpl() {}\n+\n+    @Override\n+    protected void create(boolean stream) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected void connect(String host, int port) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected void connect(InetAddress address, int port) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected void connect(SocketAddress address, int timeout) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected void bind(InetAddress host, int port) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected void listen(int backlog) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected void accept(SocketImpl s) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected InputStream getInputStream() throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected OutputStream getOutputStream() throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected int available() throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected void close() throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected void sendUrgentData(int data) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void setOption(int optID, Object value) throws SocketException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Object getOption(int optID) throws SocketException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/Socket\/ThrowingSocketImpl.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"}]}