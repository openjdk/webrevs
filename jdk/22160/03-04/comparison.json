{"files":[{"patch":"@@ -488,0 +488,1 @@\n+        assert address instanceof InetSocketAddress isa && !isa.isUnresolved();\n@@ -496,8 +497,7 @@\n-        try {\n-            if (localAddr != null)\n-                bind(localAddr);\n-            connect(address);\n-        } catch (Throwable throwable) {\n-            \/\/ `connect()` already closes the socket on failures, yet `bind()` doesn't, and hence:\n-            closeQuietly(throwable);\n-            throw throwable;\n+        if (localAddr != null) {\n+            try {\n+                    bind(localAddr);\n+            } catch (Throwable throwable) {\n+                closeQuietly(throwable);\n+                throw throwable;\n+            }\n@@ -505,0 +505,1 @@\n+        connect(address);   \/\/ `connect()` closes the socket if it throws\n@@ -625,1 +626,1 @@\n-     *          {@link InetSocketAddress}, the socket is closed\n+     *          {@link InetSocketAddress}\n@@ -661,2 +662,0 @@\n-     * <p> Besides above noted cases, the socket will also be closed when a\n-     * connection attempt fails with an {@link IOException}.\n@@ -668,2 +667,0 @@\n-     * @throws  SocketTimeoutException if timeout expires before connecting,\n-     *          the socket is closed\n@@ -671,1 +668,1 @@\n-     *          {@link InetSocketAddress}, the socket is closed\n+     *          {@link InetSocketAddress}\n@@ -696,0 +693,5 @@\n+        if (epoint.isUnresolved()) {\n+            close();\n+            throw new UnknownHostException(epoint.getHostName() + \" is unresolved\");\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import org.junit.jupiter.api.Test;\n@@ -35,0 +36,1 @@\n+import java.net.InetSocketAddress;\n@@ -38,0 +40,1 @@\n+import java.net.UnknownHostException;\n@@ -44,0 +47,1 @@\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -147,5 +151,14 @@\n-        return List.of(\n-                TestCase.ForBindFailure.ofIOException(),\n-                TestCase.ForConnectFailure.ofIOException(),\n-                TestCase.ForConnectFailure.ofIllegalArgumentException(1),\n-                TestCase.ForConnectFailure.ofSecurityException(1));\n+        return List.of(TestCase.ForBindFailure.ofIOException());\n+    }\n+\n+    @Test\n+    void connect_should_close_on_unresolved_address() throws IOException {\n+        MockSocketImpl socketImpl = new MockSocketImpl(null, null);\n+        try (Socket socket = new Socket(socketImpl) {}) {\n+            InetSocketAddress address = InetSocketAddress.createUnresolved(\"no.such.host\", 0xBEEF);\n+            assertTrue(address.isUnresolved());\n+            assertThrows(\n+                    UnknownHostException.class,\n+                    () -> socket.connect(address, 10_000),\n+                    () -> address.getHostName() + \" is unresolved\");\n+        }\n@@ -182,2 +195,1 @@\n-                TestCase.ForConnectFailure.ofIllegalArgumentException(0),\n-                TestCase.ForConnectFailure.ofSecurityException(0));\n+                TestCase.ForConnectFailure.ofIllegalArgumentException());\n@@ -231,1 +243,1 @@\n-            private static TestCase ofIllegalArgumentException(int expectedCloseInvocationCount) {\n+            private static TestCase ofIllegalArgumentException() {\n@@ -242,3 +254,1 @@\n-                        () -> assertEquals(\n-                                expectedCloseInvocationCount,\n-                                socketImpl.closeInvocationCounter.get()),\n+                        () -> assertEquals(0, socketImpl.closeInvocationCounter.get()),\n@@ -249,17 +259,0 @@\n-            private static TestCase ofSecurityException(int expectedCloseInvocationCount) {\n-                Exception connectError = new SecurityException(ERROR_MESSAGE);\n-                MockSocketImpl socketImpl = new MockSocketImpl(null, connectError);\n-                String description = String.format(\n-                        \"%s.%s\",\n-                        ForConnectFailure.class.getSimpleName(),\n-                        connectError.getClass().getSimpleName());\n-                return new TestCase(\n-                        description,\n-                        socketImpl,\n-                        caughtError -> assertSame(connectError, caughtError),\n-                        () -> assertEquals(\n-                                expectedCloseInvocationCount,\n-                                socketImpl.closeInvocationCounter.get()),\n-                        _ -> {});\n-            }\n-\n","filename":"test\/jdk\/java\/net\/Socket\/CloseOnFailureTest.java","additions":21,"deletions":28,"binary":false,"changes":49,"status":"modified"}]}