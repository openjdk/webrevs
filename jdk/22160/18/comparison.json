{"files":[{"patch":"@@ -457,0 +457,1 @@\n+        assert address instanceof InetSocketAddress;\n@@ -466,1 +467,1 @@\n-            if (localAddr != null)\n+            if (localAddr != null) {\n@@ -468,6 +469,0 @@\n-            connect(address);\n-        } catch (IOException | IllegalArgumentException e) {\n-            try {\n-                close();\n-            } catch (IOException ce) {\n-                e.addSuppressed(ce);\n@@ -475,1 +470,4 @@\n-            throw e;\n+            connect(address);\n+        } catch (Throwable throwable) {\n+            closeSuppressingExceptions(throwable);\n+            throw throwable;\n@@ -574,0 +572,4 @@\n+     * <p> If the endpoint is an unresolved {@link InetSocketAddress}, or the\n+     * connection cannot be established, then the socket is closed, and an\n+     * {@link IOException} is thrown.\n+     *\n@@ -592,0 +594,2 @@\n+     * @throws  UnknownHostException if the endpoint is an unresolved\n+     *          {@link InetSocketAddress}\n@@ -608,0 +612,5 @@\n+     * <p> If the endpoint is an unresolved {@link InetSocketAddress}, the\n+     * connection cannot be established, or the timeout expires before the\n+     * connection is established, then the socket is closed, and an\n+     * {@link IOException} is thrown.\n+     *\n@@ -628,0 +637,2 @@\n+     * @throws  UnknownHostException if the endpoint is an unresolved\n+     *          {@link InetSocketAddress}\n@@ -652,0 +663,6 @@\n+        if (epoint.isUnresolved()) {\n+            var uhe = new UnknownHostException(epoint.getHostName() + \" is unresolved\");\n+            closeSuppressingExceptions(uhe);\n+            throw uhe;\n+        }\n+\n@@ -653,1 +670,0 @@\n-        int port = epoint.getPort();\n@@ -658,9 +674,3 @@\n-        } catch (SocketTimeoutException e) {\n-            throw e;\n-        } catch (InterruptedIOException e) {\n-            Thread thread = Thread.currentThread();\n-            if (thread.isVirtual() && thread.isInterrupted()) {\n-                close();\n-                throw new SocketException(\"Closed by interrupt\");\n-            }\n-            throw e;\n+        } catch (IOException error) {\n+            closeSuppressingExceptions(error);\n+            throw error;\n@@ -1592,0 +1602,8 @@\n+    private void closeSuppressingExceptions(Throwable parentException) {\n+        try {\n+            close();\n+        } catch (IOException exception) {\n+            parentException.addSuppressed(exception);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":36,"deletions":18,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -193,4 +193,1 @@\n-    static void translateException(Exception x,\n-                                   boolean unknownHostForUnresolved)\n-        throws IOException\n-    {\n+    static void translateException(Exception x) throws IOException {\n@@ -199,7 +196,0 @@\n-        \/\/ Throw UnknownHostException from here since it cannot\n-        \/\/ be thrown as a SocketException\n-        if (unknownHostForUnresolved &&\n-            (x instanceof UnresolvedAddressException))\n-        {\n-             throw new UnknownHostException();\n-        }\n@@ -209,10 +199,0 @@\n-    static void translateException(Exception x)\n-        throws IOException\n-    {\n-        translateException(x, false);\n-    }\n-\n-    private static InetSocketAddress getLoopbackAddress(int port) {\n-        return new InetSocketAddress(InetAddress.getLoopbackAddress(), port);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Net.java","additions":1,"deletions":21,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -611,1 +611,1 @@\n-            if (ioe instanceof InterruptedIOException) {\n+            if (ioe instanceof SocketTimeoutException) {\n@@ -613,0 +613,3 @@\n+            } else if (ioe instanceof InterruptedIOException) {\n+                assert Thread.currentThread().isVirtual();\n+                throw new SocketException(\"Closed by interrupt\");\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/NioSocketImpl.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.net.UnknownHostException;\n@@ -88,0 +89,8 @@\n+        if (remote instanceof InetSocketAddress isa && isa.isUnresolved()) {\n+            if (!sc.isOpen())\n+                throw new SocketException(\"Socket is closed\");\n+            if (sc.isConnected())\n+                throw new SocketException(\"Already connected\");\n+            close();\n+            throw new UnknownHostException(remote.toString());\n+        }\n@@ -98,1 +107,1 @@\n-            Net.translateException(e, true);\n+            Net.translateException(e);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketAdaptor.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,277 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketAddress;\n+import java.net.SocketException;\n+import java.nio.channels.AlreadyConnectedException;\n+import java.nio.channels.SocketChannel;\n+import java.util.function.Consumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8343791\n+ * @summary verifies the socket state after `connect()` failures\n+ * @library \/test\/lib\n+ * @run junit\/othervm --add-opens java.base\/java.net=ALL-UNNAMED ConnectFailTest\n+ *\/\n+class ConnectFailTest {\n+\n+    private static final int DEAD_SERVER_PORT = 0xDEAD;\n+\n+    private static final InetSocketAddress REFUSING_SOCKET_ADDRESS = Utils.refusingEndpoint();\n+\n+    private static final InetSocketAddress UNRESOLVED_ADDRESS =\n+            InetSocketAddress.createUnresolved(\"no.such.host\", DEAD_SERVER_PORT);\n+\n+    @Test\n+    void verifyUnresolvedAddress() {\n+        assertTrue(UNRESOLVED_ADDRESS.isUnresolved());\n+    }\n+\n+    \/\/ Socket should be closed when `unboundSocket.connect()` fails \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    @Test\n+    void unboundSocketShouldBeClosedWhenConnectFails() throws Exception {\n+        unboundSocketShouldBeClosedWhenConnectFails(ConnectFailTest::createUnboundSocket);\n+    }\n+\n+    @Test\n+    void unboundNioSocketShouldBeClosedWhenConnectFails() throws Exception {\n+        unboundSocketShouldBeClosedWhenConnectFails(ConnectFailTest::createUnboundNioSocket);\n+    }\n+\n+    private static void unboundSocketShouldBeClosedWhenConnectFails(\n+            ThrowingSupplier<Socket> unboundSocketFactory)\n+            throws Exception {\n+        try (Socket socket = unboundSocketFactory.get()) {\n+            assertFalse(socket.isBound());\n+            assertFalse(socket.isConnected());\n+            assertThrows(IOException.class, () -> socket.connect(REFUSING_SOCKET_ADDRESS));\n+            assertTrue(socket.isClosed());\n+        }\n+    }\n+\n+    \/\/ Socket should be closed when `boundSocket.connect()` fails \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    @Test\n+    void boundSocketShouldBeClosedWhenConnectFails() throws Exception {\n+        boundSocketShouldBeClosedWhenConnectFails(\n+                ConnectFailTest::createBoundSocket);\n+    }\n+\n+    @Test\n+    void boundNioSocketShouldBeClosedWhenConnectFails() throws Exception {\n+        boundSocketShouldBeClosedWhenConnectFails(\n+                ConnectFailTest::createBoundNioSocket);\n+    }\n+\n+    private static void boundSocketShouldBeClosedWhenConnectFails(\n+            ThrowingSupplier<Socket> boundSocketFactory)\n+            throws Exception {\n+        try (Socket socket = boundSocketFactory.get()) {\n+            assertTrue(socket.isBound());\n+            assertFalse(socket.isConnected());\n+            assertThrows(IOException.class, () -> socket.connect(REFUSING_SOCKET_ADDRESS));\n+            assertTrue(socket.isClosed());\n+        }\n+    }\n+\n+    \/\/ Socket should *NOT* be closed when `connectedSocket.connect()` fails \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    @Test\n+    void connectedSocketShouldNotBeClosedWhenConnectFails() throws Exception {\n+        connectedSocketShouldNotBeClosedWhenConnectFails(\n+                ConnectFailTest::createConnectedSocket,\n+                runnable -> {\n+                    SocketException exception = assertThrows(SocketException.class, runnable::run);\n+                    assertEquals(\"already connected\", exception.getMessage());\n+                });\n+    }\n+\n+    @Test\n+    void connectedNioSocketShouldNotBeClosedWhenConnectFails() throws Exception {\n+        connectedSocketShouldNotBeClosedWhenConnectFails(\n+                ConnectFailTest::createConnectedNioSocket,\n+                runnable -> assertThrows(AlreadyConnectedException.class, runnable::run));\n+    }\n+\n+    private static void connectedSocketShouldNotBeClosedWhenConnectFails(\n+            ThrowingFunction<SocketAddress, Socket> connectedSocketFactory,\n+            Consumer<ThrowingRunnable> reconnectFailureVerifier)\n+            throws Exception {\n+        ServerSocketTestUtil.withEphemeralServerSocket(serverSocket -> {\n+            SocketAddress serverSocketAddress = serverSocket.getLocalSocketAddress();\n+            try (Socket socket = connectedSocketFactory.apply(serverSocketAddress)) {\n+                assertTrue(socket.isBound());\n+                assertTrue(socket.isConnected());\n+                \/\/ `Socket` and `SocketChannel` differ in how they fail on re-connection attempts on an already\n+                \/\/ connected socket. Hence, we delegate this particular check:\n+                reconnectFailureVerifier.accept(() -> socket.connect(REFUSING_SOCKET_ADDRESS));\n+                assertFalse(socket.isClosed());\n+            }\n+        });\n+    }\n+\n+    \/\/ Socket should be closed when `unboundSocket.connect(unresolvedAddress)` fails \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    @Test\n+    void unboundSocketShouldBeClosedWhenConnectWithUnresolvedAddressFails() throws Exception {\n+        unboundSocketShouldBeClosedWhenConnectWithUnresolvedAddressFails(\n+                ConnectFailTest::createUnboundSocket);\n+    }\n+\n+    private static Socket createUnboundSocket() {\n+        return new Socket();\n+    }\n+\n+    @Test\n+    void unboundNioSocketShouldBeClosedWhenConnectWithUnresolvedAddressFails() throws Exception {\n+        unboundSocketShouldBeClosedWhenConnectWithUnresolvedAddressFails(\n+                ConnectFailTest::createUnboundNioSocket);\n+    }\n+\n+    @SuppressWarnings(\"resource\")\n+    private static Socket createUnboundNioSocket() throws IOException {\n+        return SocketChannel.open().socket();\n+    }\n+\n+    private static void unboundSocketShouldBeClosedWhenConnectWithUnresolvedAddressFails(\n+            ThrowingSupplier<Socket> unboundSocketFactory)\n+            throws Exception {\n+        try (Socket socket = unboundSocketFactory.get()) {\n+            assertFalse(socket.isBound());\n+            assertFalse(socket.isConnected());\n+            assertThrows(IOException.class, () -> socket.connect(UNRESOLVED_ADDRESS));\n+            assertTrue(socket.isClosed());\n+        }\n+    }\n+\n+    \/\/ Socket should be closed when `boundSocket.connect(unresolvedAddress)` fails \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    @Test\n+    void boundSocketShouldBeClosedWhenConnectWithUnresolvedAddressFails() throws Exception {\n+        boundSocketShouldBeClosedWhenConnectWithUnresolvedAddressFails(\n+                ConnectFailTest::createBoundSocket);\n+    }\n+\n+    private static Socket createBoundSocket() throws IOException {\n+        Socket socket = new Socket();\n+        socket.bind(new InetSocketAddress(0));\n+        return socket;\n+    }\n+\n+    @Test\n+    void boundNioSocketShouldBeClosedWhenConnectWithUnresolvedAddressFails() throws Exception {\n+        boundSocketShouldBeClosedWhenConnectWithUnresolvedAddressFails(\n+                ConnectFailTest::createBoundNioSocket);\n+    }\n+\n+    @SuppressWarnings(\"resource\")\n+    private static Socket createBoundNioSocket() throws IOException {\n+        SocketChannel channel = SocketChannel.open();\n+        channel.bind(new InetSocketAddress(0));\n+        return channel.socket();\n+    }\n+\n+    private static void boundSocketShouldBeClosedWhenConnectWithUnresolvedAddressFails(\n+            ThrowingSupplier<Socket> boundSocketFactory)\n+            throws Exception {\n+        try (Socket socket = boundSocketFactory.get()) {\n+            assertTrue(socket.isBound());\n+            assertFalse(socket.isConnected());\n+            assertThrows(IOException.class, () -> socket.connect(UNRESOLVED_ADDRESS));\n+            assertTrue(socket.isClosed());\n+        }\n+    }\n+\n+    \/\/ Socket should *NOT* be closed when `connectedSocket.connect(unresolvedAddress)` fails \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    @Test\n+    void connectedSocketShouldNotBeClosedWhenConnectWithUnresolvedAddressFails() throws Exception {\n+        connectedSocketShouldNotBeClosedWhenConnectWithUnresolvedAddressFails(\n+                ConnectFailTest::createConnectedSocket);\n+    }\n+\n+    private static Socket createConnectedSocket(SocketAddress address) throws IOException {\n+        InetSocketAddress inetAddress = (InetSocketAddress) address;\n+        return new Socket(inetAddress.getAddress(), inetAddress.getPort());\n+    }\n+\n+    @Test\n+    void connectedNioSocketShouldNotBeClosedWhenConnectWithUnresolvedAddressFails() throws Exception {\n+        connectedSocketShouldNotBeClosedWhenConnectWithUnresolvedAddressFails(\n+                ConnectFailTest::createConnectedNioSocket);\n+    }\n+\n+    @SuppressWarnings(\"resource\")\n+    private static Socket createConnectedNioSocket(SocketAddress address) throws IOException {\n+        return SocketChannel.open(address).socket();\n+    }\n+\n+    private static void connectedSocketShouldNotBeClosedWhenConnectWithUnresolvedAddressFails(\n+            ThrowingFunction<SocketAddress, Socket> connectedSocketFactory)\n+            throws Exception {\n+        ServerSocketTestUtil.withEphemeralServerSocket(serverSocket -> {\n+            SocketAddress serverSocketAddress = serverSocket.getLocalSocketAddress();\n+            try (Socket socket = connectedSocketFactory.apply(serverSocketAddress)) {\n+                assertTrue(socket.isBound());\n+                assertTrue(socket.isConnected());\n+                assertThrows(IOException.class, () -> socket.connect(UNRESOLVED_ADDRESS));\n+                assertFalse(socket.isClosed());\n+            }\n+        });\n+    }\n+\n+    @FunctionalInterface\n+    private interface ThrowingRunnable {\n+\n+        void run() throws Exception;\n+\n+    }\n+\n+    @FunctionalInterface\n+    private interface ThrowingSupplier<V> {\n+\n+        V get() throws Exception;\n+\n+    }\n+\n+    @FunctionalInterface\n+    private interface ThrowingFunction<I, O> {\n+\n+        O apply(I input) throws Exception;\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/Socket\/ConnectFailTest.java","additions":277,"deletions":0,"binary":false,"changes":277,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+\/**\n+ * Test utilities for {@link ServerSocket}s.\n+ *\/\n+final class ServerSocketTestUtil {\n+\n+    static void withEphemeralServerSocket(ThrowingConsumer<ServerSocket> serverSocketConsumer) throws Exception {\n+        try (ExecutorService executorService = Executors.newVirtualThreadPerTaskExecutor();\n+             ServerSocket serverSocket = new ServerSocket(0)) {\n+            \/\/ Accept connections in the background to avoid blocking the caller\n+            executorService.submit(() -> acceptConnections(serverSocket));\n+            serverSocketConsumer.accept(serverSocket);\n+        }\n+    }\n+\n+    @SuppressWarnings({\"ResultOfMethodCallIgnored\"})\n+    private static void acceptConnections(ServerSocket serverSocket) {\n+        System.err.println(\"[Test socket server] Starting accepting connections\");\n+        while (true) {\n+            try {\n+\n+                \/\/ Accept the connection\n+                Socket clientSocket = serverSocket.accept();\n+                System.err.format(\n+                        \"[Test socket server] Accepted port %d to port %d%n\",\n+                        ((InetSocketAddress) clientSocket.getRemoteSocketAddress()).getPort(),\n+                        clientSocket.getLocalPort());\n+\n+                \/\/ Instead of directly closing the socket, we try to read some to block. Directly closing\n+                \/\/ the socket will invalidate the client socket tests checking the established connection\n+                \/\/ status.\n+                try (clientSocket; InputStream inputStream = clientSocket.getInputStream()) {\n+                    inputStream.read();\n+                } catch (IOException _) {\n+                    \/\/ Do nothing\n+                }\n+\n+            } catch (IOException _) {\n+                break;\n+            }\n+\n+        }\n+        System.err.println(\"[Test socket server] Stopping accepting connections\");\n+    }\n+\n+    @FunctionalInterface\n+    interface ThrowingConsumer<V> {\n+\n+        void accept(V value) throws Exception;\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/Socket\/ServerSocketTestUtil.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.*;\n+\n+\/**\n+ * A {@link SocketImpl} implementation where all methods throw {@link UnsupportedOperationException}.\n+ * This class is intended to be subclassed by tests, which override its methods to mock certain behaviour.\n+ *\/\n+class ThrowingSocketImpl extends SocketImpl {\n+\n+    ThrowingSocketImpl() {}\n+\n+    @Override\n+    protected void create(boolean stream) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected void connect(String host, int port) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected void connect(InetAddress address, int port) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected void connect(SocketAddress address, int timeout) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected void bind(InetAddress host, int port) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected void listen(int backlog) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected void accept(SocketImpl s) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected InputStream getInputStream() throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected OutputStream getOutputStream() throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected int available() throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected void close() throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected void sendUrgentData(int data) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void setOption(int optID, Object value) throws SocketException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Object getOption(int optID) throws SocketException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/Socket\/ThrowingSocketImpl.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"}]}