{"files":[{"patch":"@@ -457,0 +457,1 @@\n+        assert address instanceof InetSocketAddress;\n@@ -466,1 +467,1 @@\n-            if (localAddr != null)\n+            if (localAddr != null) {\n@@ -468,6 +469,0 @@\n-            connect(address);\n-        } catch (IOException | IllegalArgumentException e) {\n-            try {\n-                close();\n-            } catch (IOException ce) {\n-                e.addSuppressed(ce);\n@@ -475,1 +470,4 @@\n-            throw e;\n+            connect(address);\n+        } catch (Throwable throwable) {\n+            closeSuppressingExceptions(throwable);\n+            throw throwable;\n@@ -574,0 +572,4 @@\n+     * <p> If the endpoint is an unresolved {@link InetSocketAddress}, or the\n+     * connection cannot be established, then the socket is closed, and an\n+     * {@link IOException} is thrown.\n+     *\n@@ -592,0 +594,2 @@\n+     * @throws  UnknownHostException if the endpoint is an unresolved\n+     *          {@link InetSocketAddress}\n@@ -608,0 +612,5 @@\n+     * <p> If the endpoint is an unresolved {@link InetSocketAddress}, the\n+     * connection cannot be established, or the timeout expires before the\n+     * connection is established, then the socket is closed, and an\n+     * {@link IOException} is thrown.\n+     *\n@@ -628,0 +637,2 @@\n+     * @throws  UnknownHostException if the endpoint is an unresolved\n+     *          {@link InetSocketAddress}\n@@ -652,0 +663,6 @@\n+        if (epoint.isUnresolved()) {\n+            var uhe = new UnknownHostException(epoint.getHostName() + \" is unresolved\");\n+            closeSuppressingExceptions(uhe);\n+            throw uhe;\n+        }\n+\n@@ -653,1 +670,0 @@\n-        int port = epoint.getPort();\n@@ -658,9 +674,3 @@\n-        } catch (SocketTimeoutException e) {\n-            throw e;\n-        } catch (InterruptedIOException e) {\n-            Thread thread = Thread.currentThread();\n-            if (thread.isVirtual() && thread.isInterrupted()) {\n-                close();\n-                throw new SocketException(\"Closed by interrupt\");\n-            }\n-            throw e;\n+        } catch (IOException error) {\n+            closeSuppressingExceptions(error);\n+            throw error;\n@@ -1592,0 +1602,8 @@\n+    private void closeSuppressingExceptions(Throwable parentException) {\n+        try {\n+            close();\n+        } catch (IOException exception) {\n+            parentException.addSuppressed(exception);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":36,"deletions":18,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -193,4 +193,1 @@\n-    static void translateException(Exception x,\n-                                   boolean unknownHostForUnresolved)\n-        throws IOException\n-    {\n+    static void translateException(Exception x) throws IOException {\n@@ -199,7 +196,0 @@\n-        \/\/ Throw UnknownHostException from here since it cannot\n-        \/\/ be thrown as a SocketException\n-        if (unknownHostForUnresolved &&\n-            (x instanceof UnresolvedAddressException))\n-        {\n-             throw new UnknownHostException();\n-        }\n@@ -209,10 +199,0 @@\n-    static void translateException(Exception x)\n-        throws IOException\n-    {\n-        translateException(x, false);\n-    }\n-\n-    private static InetSocketAddress getLoopbackAddress(int port) {\n-        return new InetSocketAddress(InetAddress.getLoopbackAddress(), port);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Net.java","additions":1,"deletions":21,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -611,1 +611,1 @@\n-            if (ioe instanceof InterruptedIOException) {\n+            if (ioe instanceof SocketTimeoutException) {\n@@ -613,0 +613,3 @@\n+            } else if (ioe instanceof InterruptedIOException) {\n+                assert Thread.currentThread().isVirtual();\n+                throw new SocketException(\"Closed by interrupt\");\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/NioSocketImpl.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.net.UnknownHostException;\n@@ -88,0 +89,8 @@\n+        if (remote instanceof InetSocketAddress isa && isa.isUnresolved()) {\n+            if (!sc.isOpen())\n+                throw new SocketException(\"Socket is closed\");\n+            if (sc.isConnected())\n+                throw new SocketException(\"Already connected\");\n+            close();\n+            throw new UnknownHostException(remote.toString());\n+        }\n@@ -98,1 +107,1 @@\n-            Net.translateException(e, true);\n+            Net.translateException(e);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketAdaptor.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,276 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.SocketAddress;\n+import java.net.SocketException;\n+import java.nio.channels.AlreadyConnectedException;\n+import java.nio.channels.SocketChannel;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.function.Consumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8343791\n+ * @summary verifies the socket state after `connect()` failures\n+ * @library \/test\/lib\n+ * @run junit\/othervm --add-opens java.base\/java.net=ALL-UNNAMED ConnectFailTest\n+ *\/\n+class ConnectFailTest {\n+\n+    private static final int DEAD_SERVER_PORT = 0xDEAD;\n+\n+    private static final InetSocketAddress REFUSING_SOCKET_ADDRESS = Utils.refusingEndpoint();\n+\n+    private static final InetSocketAddress UNRESOLVED_ADDRESS =\n+            InetSocketAddress.createUnresolved(\"no.such.host\", DEAD_SERVER_PORT);\n+\n+    @Test\n+    void testUnresolvedAddress() {\n+        assertTrue(UNRESOLVED_ADDRESS.isUnresolved());\n+    }\n+\n+    \/**\n+     * Verifies socket is closed when {@code unboundSocket.connect()} fails.\n+     * @param socket an unbound socket\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"boundSockets\")\n+    void testBoundSocket(Socket socket) throws IOException {\n+        try (socket) {\n+            assertTrue(socket.isBound());\n+            assertFalse(socket.isConnected());\n+            assertThrows(IOException.class, () -> socket.connect(REFUSING_SOCKET_ADDRESS));\n+            assertTrue(socket.isClosed());\n+        }\n+    }\n+\n+    @Test\n+    void testConnectedSocket() throws Exception {\n+        testConnectedSocket(\n+                ConnectFailTest::createConnectedSocket,\n+                runnable -> {\n+                    SocketException exception = assertThrows(SocketException.class, runnable::run);\n+                    assertEquals(\"already connected\", exception.getMessage());\n+                });\n+    }\n+\n+    @Test\n+    void testConnectedNioSocket() throws Exception {\n+        testConnectedSocket(\n+                ConnectFailTest::createConnectedNioSocket,\n+                runnable -> assertThrows(AlreadyConnectedException.class, runnable::run));\n+    }\n+\n+    \/**\n+     * Verifies socket is not closed when {@code `connectedSocket.connect()`} fails.\n+     * @param connectedSocketFactory a connected socket factory\n+     * @param reconnectFailureVerifier a consumer verifying the thrown reconnect failure\n+     *\/\n+    private static void testConnectedSocket(\n+            ThrowingFunction<SocketAddress, Socket> connectedSocketFactory,\n+            Consumer<ThrowingRunnable> reconnectFailureVerifier)\n+            throws Exception {\n+        withEphemeralServerSocket(serverSocket -> {\n+            SocketAddress serverSocketAddress = serverSocket.getLocalSocketAddress();\n+            try (Socket socket = connectedSocketFactory.apply(serverSocketAddress)) {\n+                assertTrue(socket.isBound());\n+                assertTrue(socket.isConnected());\n+                \/\/ `Socket` and `SocketChannel` differ in how they fail on re-connection attempts on an already\n+                \/\/ connected socket. Hence, we delegate this particular check:\n+                reconnectFailureVerifier.accept(() -> socket.connect(REFUSING_SOCKET_ADDRESS));\n+                assertFalse(socket.isClosed());\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Verifies socket is closed when {@code unboundSocket.connect(unresolvedAddress)} fails.\n+     * @param socket an unbound socket\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"unboundSockets\")\n+    void testUnboundSocketWithUnresolvedAddress(Socket socket) throws IOException {\n+        try (socket) {\n+            assertFalse(socket.isBound());\n+            assertFalse(socket.isConnected());\n+            assertThrows(IOException.class, () -> socket.connect(UNRESOLVED_ADDRESS));\n+            assertTrue(socket.isClosed());\n+        }\n+    }\n+\n+    @SuppressWarnings(\"resource\")\n+    static List<Socket> unboundSockets() throws IOException {\n+        return List.of(\n+                new Socket(),\n+                SocketChannel.open().socket());\n+    }\n+\n+    \/**\n+     * Verifies socket is closed when {@code boundSocket.connect(unresolvedAddress)} fails.\n+     * @param socket a bound socket\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"boundSockets\")\n+    void testBoundSocketWithUnresolvedAddress(Socket socket) throws IOException {\n+        try (socket) {\n+            assertTrue(socket.isBound());\n+            assertFalse(socket.isConnected());\n+            assertThrows(IOException.class, () -> socket.connect(UNRESOLVED_ADDRESS));\n+            assertTrue(socket.isClosed());\n+        }\n+    }\n+\n+    @SuppressWarnings(\"resource\")\n+    static List<Socket> boundSockets() throws IOException {\n+        List<Socket> sockets = new ArrayList<>();\n+        \/\/ Socket\n+        {\n+            Socket socket = new Socket();\n+            socket.bind(new InetSocketAddress(0));\n+            sockets.add(socket);\n+        }\n+        \/\/ NIO Socket\n+        {\n+            SocketChannel channel = SocketChannel.open();\n+            channel.bind(new InetSocketAddress(0));\n+            sockets.add(channel.socket());\n+        }\n+        return sockets;\n+    }\n+\n+    \/**\n+     * Verifies socket is not closed when {@code connectedSocket.connect(unresolvedAddress)} fails.\n+     * @param connectedSocketFactory a connected socket factory\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"connectedSocketFactories\")\n+    void testConnectedSocketWithUnresolvedAddress(\n+            ThrowingFunction<SocketAddress, Socket> connectedSocketFactory)\n+            throws Exception {\n+        withEphemeralServerSocket(serverSocket -> {\n+            SocketAddress serverSocketAddress = serverSocket.getLocalSocketAddress();\n+            try (Socket socket = connectedSocketFactory.apply(serverSocketAddress)) {\n+                assertTrue(socket.isBound());\n+                assertTrue(socket.isConnected());\n+                assertThrows(IOException.class, () -> socket.connect(UNRESOLVED_ADDRESS));\n+                assertFalse(socket.isClosed());\n+            }\n+        });\n+    }\n+\n+    static List<ThrowingFunction<SocketAddress, Socket>> connectedSocketFactories() {\n+        return List.of(\n+                ConnectFailTest::createConnectedSocket,\n+                ConnectFailTest::createConnectedNioSocket);\n+    }\n+\n+    private static Socket createConnectedSocket(SocketAddress address) throws IOException {\n+        InetSocketAddress inetAddress = (InetSocketAddress) address;\n+        return new Socket(inetAddress.getAddress(), inetAddress.getPort());\n+    }\n+\n+    @SuppressWarnings(\"resource\")\n+    private static Socket createConnectedNioSocket(SocketAddress address) throws IOException {\n+        return SocketChannel.open(address).socket();\n+    }\n+\n+    private static void withEphemeralServerSocket(ThrowingConsumer<ServerSocket> serverSocketConsumer) throws Exception {\n+        try (ExecutorService executorService = Executors.newVirtualThreadPerTaskExecutor();\n+             ServerSocket serverSocket = new ServerSocket(0, 0, InetAddress.getLoopbackAddress())) {\n+            \/\/ Accept connections in the background to avoid blocking the caller\n+            executorService.submit(() -> acceptConnections(serverSocket));\n+            serverSocketConsumer.accept(serverSocket);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"ResultOfMethodCallIgnored\")\n+    private static void acceptConnections(ServerSocket serverSocket) {\n+        System.err.println(\"[Test socket server] Starting accepting connections\");\n+        while (true) {\n+            try {\n+\n+                \/\/ Accept the connection\n+                Socket clientSocket = serverSocket.accept();\n+                System.err.format(\n+                        \"[Test socket server] Accepted port %d to port %d%n\",\n+                        ((InetSocketAddress) clientSocket.getRemoteSocketAddress()).getPort(),\n+                        clientSocket.getLocalPort());\n+\n+                \/\/ Instead of directly closing the socket, we try to read some to block. Directly closing\n+                \/\/ the socket will invalidate the client socket tests checking the established connection\n+                \/\/ status.\n+                try (clientSocket; InputStream inputStream = clientSocket.getInputStream()) {\n+                    inputStream.read();\n+                } catch (IOException _) {\n+                    \/\/ Do nothing\n+                }\n+\n+            } catch (IOException _) {\n+                break;\n+            }\n+\n+        }\n+        System.err.println(\"[Test socket server] Stopping accepting connections\");\n+    }\n+\n+    @FunctionalInterface\n+    private interface ThrowingConsumer<V> {\n+\n+        void accept(V value) throws Exception;\n+\n+    }\n+\n+    @FunctionalInterface\n+    private interface ThrowingRunnable {\n+\n+        void run() throws Exception;\n+\n+    }\n+\n+    @FunctionalInterface\n+    private interface ThrowingFunction<I, O> {\n+\n+        O apply(I input) throws Exception;\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/Socket\/ConnectFailTest.java","additions":276,"deletions":0,"binary":false,"changes":276,"status":"added"}]}