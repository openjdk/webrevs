{"files":[{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8343791\n+ * @summary using a `SocketImpl` mock, verifies that the socket is closed on `connect()` failures\n+ * @library \/test\/lib\n+ * @run junit\/othervm --add-opens java.base\/java.net=ALL-UNNAMED CloseOnConnectFailureMockTest\n+ *\/\n+class CloseOnConnectFailureMockTest {\n+\n+    private static final int DEAD_SERVER_PORT = 0xDEAD;\n+\n+    private static final InetSocketAddress REFUSING_SOCKET_ADDRESS = Utils.refusingEndpoint();\n+\n+    @Test\n+    void connectShouldCloseOnUnresolvedAddress() throws IOException {\n+        CloseOnFailureMockTestBase.MockSocketImpl socketImpl =\n+                new CloseOnFailureMockTestBase.MockSocketImpl(null, null);\n+        try (Socket socket = new Socket(socketImpl) {}) {\n+            InetSocketAddress address = InetSocketAddress.createUnresolved(\"no.such.host\", DEAD_SERVER_PORT);\n+            assertTrue(address.isUnresolved());\n+            assertThrows(\n+                    UnknownHostException.class,\n+                    () -> socket.connect(address, 10_000),\n+                    () -> address.getHostName() + \" is unresolved\");\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"connectShouldCloseOnFailuresTestCases\")\n+    void connectShouldCloseOnFailures(CloseOnFailureMockTestBase.TestCase testCase) throws Throwable {\n+\n+        \/\/ Create a socket using the mock `SocketImpl` configured to fail\n+        try (Socket socket = new Socket(testCase.socketImpl()) {}) {\n+\n+            \/\/ Trigger the failure\n+            Exception exception = assertThrows(Exception.class, () -> {\n+                \/\/ Address and timeout are mostly ineffective.\n+                \/\/ They just need to be _valid enough_ to reach to the `SocketImpl#connect()` invocation.\n+                \/\/ Failure will be triggered by the injected `SocketImpl`.\n+                socket.connect(REFUSING_SOCKET_ADDRESS, 10_000);\n+            });\n+\n+            \/\/ Run verifications\n+            testCase.caughtExceptionVerifier().accept(exception);\n+            testCase.socketImplVerifier().run();\n+            testCase.socketVerifier().accept(socket);\n+\n+        }\n+\n+    }\n+\n+    static List<CloseOnFailureMockTestBase.TestCase> connectShouldCloseOnFailuresTestCases() {\n+        return List.of(\n+                CloseOnFailureMockTestBase.TestCase.ConnectFailureFactory.iOExceptionTestCase(),\n+                CloseOnFailureMockTestBase.TestCase.ConnectFailureFactory.illegalArgumentExceptionTestCase(0));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/Socket\/CloseOnConnectFailureMockTest.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.function.Executable;\n+\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.SocketAddress;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/**\n+ * Base class containing tests against <em>real sockets<\/em> and verifying the socket close after connect failures.\n+ *\n+ * @see CloseOnOioConnectFailureTest\n+ * @see CloseOnNioConnectFailureTest\n+ *\/\n+abstract class CloseOnConnectFailureTestBase {\n+\n+    private static final int DEAD_SERVER_PORT = 0xDEAD;\n+\n+    private static final InetSocketAddress REFUSING_SOCKET_ADDRESS = Utils.refusingEndpoint();\n+\n+    private static final InetSocketAddress UNRESOLVED_ADDRESS =\n+            InetSocketAddress.createUnresolved(\"no.such.host\", DEAD_SERVER_PORT);\n+\n+    @Test\n+    void verifyUnresolvedAddress() {\n+        assertTrue(UNRESOLVED_ADDRESS.isUnresolved());\n+    }\n+\n+    @Test\n+    void verifyUnboundSocket() throws IOException {\n+        try (Socket socket = createUnboundSocket()) {\n+            assertFalse(socket.isBound());\n+            assertFalse(socket.isConnected());\n+        }\n+    }\n+\n+    @Test\n+    void verifyBoundSocket() throws IOException {\n+        try (Socket socket = createBoundSocket()) {\n+            assertTrue(socket.isBound());\n+            assertFalse(socket.isConnected());\n+        }\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"resource\")\n+    void verifyConnectedSocket() throws IOException {\n+        SocketAddress serverSocketAddress = serverSocket().getLocalSocketAddress();\n+        try (Socket socket = createConnectedSocket(serverSocketAddress)) {\n+            assertTrue(socket.isBound());\n+            assertTrue(socket.isConnected());\n+        }\n+    }\n+\n+    @Test\n+    void socketShouldBeClosedWhenConnectFailsUsingUnboundSocket() throws IOException {\n+        try (Socket socket = createUnboundSocket()) {\n+            assertThrows(IOException.class, () -> socket.connect(REFUSING_SOCKET_ADDRESS));\n+            assertTrue(socket.isClosed());\n+        }\n+    }\n+\n+    @Test\n+    void socketShouldBeClosedWhenConnectFailsUsingBoundSocket() throws IOException {\n+        try (Socket socket = createBoundSocket()) {\n+            assertThrows(IOException.class, () -> socket.connect(REFUSING_SOCKET_ADDRESS));\n+            assertTrue(socket.isClosed());\n+        }\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"resource\")\n+    void socketShouldNotBeClosedWhenConnectFailsUsingConnectedSocket() throws IOException {\n+        SocketAddress serverSocketAddress = serverSocket().getLocalSocketAddress();\n+        try (Socket socket = createConnectedSocket(serverSocketAddress)) {\n+            \/\/ OIO and NIO differ in how they fail on re-connection attempts on an already connected socket.\n+            \/\/ Hence, we delegate that check:\n+            assertReconnectFailure(() -> socket.connect(REFUSING_SOCKET_ADDRESS));\n+            assertFalse(socket.isClosed());\n+        }\n+    }\n+\n+    @Test\n+    void socketShouldBeClosedWhenConnectWithUnresolvedAddressFailsUsingUnboundSocket() throws IOException {\n+        try (Socket socket = createUnboundSocket()) {\n+            assertThrows(IOException.class, () -> socket.connect(UNRESOLVED_ADDRESS));\n+            assertTrue(socket.isClosed());\n+        }\n+    }\n+\n+    @Test\n+    void socketShouldBeClosedWhenConnectWithUnresolvedAddressFailsUsingBoundSocket() throws IOException {\n+        try (Socket socket = createBoundSocket()) {\n+            assertThrows(IOException.class, () -> socket.connect(UNRESOLVED_ADDRESS));\n+            assertTrue(socket.isClosed());\n+        }\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"resource\")\n+    void socketShouldNotBeClosedWhenConnectWithUnresolvedAddressFailsUsingConnectedSocket() throws IOException {\n+        SocketAddress serverSocketAddress = serverSocket().getLocalSocketAddress();\n+        try (Socket socket = createConnectedSocket(serverSocketAddress)) {\n+            assertThrows(IOException.class, () -> socket.connect(UNRESOLVED_ADDRESS));\n+            assertFalse(socket.isClosed());\n+        }\n+    }\n+\n+    abstract ServerSocket serverSocket();\n+\n+    abstract Socket createUnboundSocket() throws IOException;\n+\n+    abstract Socket createBoundSocket() throws IOException;\n+\n+    abstract Socket createConnectedSocket(SocketAddress address) throws IOException;\n+\n+    abstract void assertReconnectFailure(Executable executable);\n+\n+}\n","filename":"test\/jdk\/java\/net\/Socket\/CloseOnConnectFailureTestBase.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.junit.function.ThrowingRunnable;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Field;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.net.SocketImplFactory;\n+import java.util.List;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+\/*\n+ * @test\n+ * @bug 8343791\n+ * @summary using a `SocketImpl` mock, verifies that the socket is closed on constructor failures\n+ * @library \/test\/lib\n+ * @run junit\/othervm --add-opens java.base\/java.net=ALL-UNNAMED CloseOnCtorFailureMockTest\n+ *\/\n+class CloseOnCtorFailureMockTest {\n+\n+    private static final VarHandle SOCKET_IMPL_FACTORY_HANDLE = createSocketImplFactoryHandle();\n+\n+    private static final int DEAD_SERVER_PORT = 0xDEAD;\n+\n+    private static VarHandle createSocketImplFactoryHandle() {\n+        try {\n+            Field field = Socket.class.getDeclaredField(\"factory\");\n+            field.setAccessible(true);\n+            return MethodHandles\n+                    .privateLookupIn(Socket.class, MethodHandles.lookup())\n+                    .findStaticVarHandle(Socket.class, \"factory\", SocketImplFactory.class);\n+        } catch (NoSuchFieldException | IllegalAccessException exception) {\n+            throw new RuntimeException(exception);\n+        }\n+    }\n+\n+    private static void withSocketImplFactory(SocketImplFactory newFactory, ThrowingRunnable runnable) throws Throwable {\n+        SocketImplFactory oldFactory = (SocketImplFactory) SOCKET_IMPL_FACTORY_HANDLE.getAndSet(newFactory);\n+        try {\n+            runnable.run();\n+        } finally {\n+            SOCKET_IMPL_FACTORY_HANDLE.set(oldFactory);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"ctorShouldCloseOnFailuresTestCases\")\n+    @SuppressWarnings(\"resource\")\n+    void ctorShouldCloseOnFailures(CloseOnFailureMockTestBase.TestCase testCase) throws Throwable {\n+\n+        \/\/ Create a socket using the mock `SocketImpl` configured to fail\n+        withSocketImplFactory(testCase::socketImpl, () -> {\n+\n+            \/\/ Trigger the failure\n+            Exception exception = assertThrows(Exception.class, () -> {\n+                \/\/ Address and port are mostly ineffective.\n+                \/\/ They just need to be _valid enough_ to reach to the point where both `SocketImpl#bind()` and `SocketImpl#connect()` are invoked.\n+                \/\/ Failure will be triggered by the injected `SocketImpl`.\n+                InetAddress serverAddress = InetAddress.getLoopbackAddress();\n+                new Socket(serverAddress, DEAD_SERVER_PORT, null, 0);\n+            });\n+\n+            \/\/ Run verifications\n+            testCase.caughtExceptionVerifier().accept(exception);\n+            testCase.socketImplVerifier().run();\n+\n+        });\n+\n+    }\n+\n+    static List<CloseOnFailureMockTestBase.TestCase> ctorShouldCloseOnFailuresTestCases() {\n+        return List.of(\n+                CloseOnFailureMockTestBase.TestCase.BindFailureFactory.iOExceptionTestCase(),\n+                CloseOnFailureMockTestBase.TestCase.ConnectFailureFactory.iOExceptionTestCase(),\n+                CloseOnFailureMockTestBase.TestCase.ConnectFailureFactory.illegalArgumentExceptionTestCase(1));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/Socket\/CloseOnCtorFailureMockTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.junit.function.ThrowingRunnable;\n+import org.junit.jupiter.api.function.ThrowingConsumer;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.net.SocketAddress;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+\n+\/**\n+ * Base class containing tests against <em>mocked sockets<\/em> and verifying the socket close after connect failures.\n+ *\n+ * @see CloseOnConnectFailureMockTest\n+ * @see CloseOnCtorFailureMockTest\n+ *\/\n+final class CloseOnFailureMockTestBase {\n+\n+    static final class MockSocketImpl extends ThrowingSocketImpl {\n+\n+        private final AtomicInteger closeInvocationCounter = new AtomicInteger(0);\n+\n+        private final Exception bindException;\n+\n+        private final Exception connectException;\n+\n+        MockSocketImpl(Exception bindException, Exception connectException) {\n+            this.bindException = bindException;\n+            this.connectException = connectException;\n+        }\n+\n+        @Override\n+        protected void create(boolean stream) {\n+        }\n+\n+        @Override\n+        protected void bind(InetAddress host, int port) throws IOException {\n+            throwIfPresent(bindException);\n+        }\n+\n+        @Override\n+        protected void connect(SocketAddress address, int timeoutMillis) throws IOException {\n+            throwIfPresent(connectException);\n+        }\n+\n+        private void throwIfPresent(Exception exception) throws IOException {\n+            if (exception != null) {\n+                switch (exception) {\n+                    case IOException error -> throw error;\n+                    case RuntimeException error -> throw error;\n+                    default -> throw new IllegalStateException(\n+                            \"unknown exception type: \" + exception.getClass().getCanonicalName());\n+                }\n+            }\n+        }\n+\n+        @Override\n+        protected void close() {\n+            closeInvocationCounter.incrementAndGet();\n+        }\n+\n+    }\n+\n+    record TestCase(\n+            String description,\n+            MockSocketImpl socketImpl,\n+            ThrowingConsumer<Exception> caughtExceptionVerifier,\n+            ThrowingRunnable socketImplVerifier,\n+            ThrowingConsumer<Socket> socketVerifier) {\n+\n+        private static final String EXCEPTION_MESSAGE = \"intentional test failure\";\n+\n+        static final class BindFailureFactory {\n+\n+            static CloseOnFailureMockTestBase.TestCase iOExceptionTestCase() {\n+                Exception bindException = new IOException(EXCEPTION_MESSAGE);\n+                MockSocketImpl socketImpl = new MockSocketImpl(bindException, null);\n+                String description = String.format(\n+                        \"%s.%s\",\n+                        BindFailureFactory.class.getSimpleName(),\n+                        bindException.getClass().getSimpleName());\n+                return new CloseOnFailureMockTestBase.TestCase(\n+                        description,\n+                        socketImpl,\n+                        caughtException -> assertSame(bindException, caughtException),\n+                        () -> assertEquals(1, socketImpl.closeInvocationCounter.get()),\n+                        _ -> {\n+                        });\n+            }\n+\n+        }\n+\n+        static final class ConnectFailureFactory {\n+\n+            static CloseOnFailureMockTestBase.TestCase iOExceptionTestCase() {\n+                Exception connectException = new IOException(EXCEPTION_MESSAGE);\n+                MockSocketImpl socketImpl = new MockSocketImpl(null, connectException);\n+                String description = String.format(\n+                        \"%s.%s\",\n+                        ConnectFailureFactory.class.getSimpleName(),\n+                        connectException.getClass().getSimpleName());\n+                return new CloseOnFailureMockTestBase.TestCase(\n+                        description,\n+                        socketImpl,\n+                        caughtException -> assertSame(connectException, caughtException),\n+                        () -> assertEquals(1, socketImpl.closeInvocationCounter.get()),\n+                        _ -> {\n+                        });\n+            }\n+\n+            static CloseOnFailureMockTestBase.TestCase illegalArgumentExceptionTestCase(int expectedCloseInvocationCount) {\n+                Exception connectException = new IllegalArgumentException(EXCEPTION_MESSAGE);\n+                MockSocketImpl socketImpl = new MockSocketImpl(null, connectException);\n+                String description = String.format(\n+                        \"%s.%s\",\n+                        ConnectFailureFactory.class.getSimpleName(),\n+                        connectException.getClass().getSimpleName());\n+                return new CloseOnFailureMockTestBase.TestCase(\n+                        description,\n+                        socketImpl,\n+                        caughtException -> assertSame(connectException, caughtException),\n+                        () -> assertEquals(expectedCloseInvocationCount, socketImpl.closeInvocationCounter.get()),\n+                        _ -> {\n+                        });\n+            }\n+\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return description;\n+        }\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/Socket\/CloseOnFailureMockTestBase.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -1,519 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.test.lib.Utils;\n-import org.junit.function.ThrowingRunnable;\n-import org.junit.jupiter.api.Nested;\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.extension.AfterAllCallback;\n-import org.junit.jupiter.api.extension.BeforeAllCallback;\n-import org.junit.jupiter.api.extension.ExtensionContext;\n-import org.junit.jupiter.api.extension.RegisterExtension;\n-import org.junit.jupiter.api.function.Executable;\n-import org.junit.jupiter.api.function.ThrowingConsumer;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.lang.reflect.Field;\n-import java.net.InetAddress;\n-import java.net.InetSocketAddress;\n-import java.net.ServerSocket;\n-import java.net.Socket;\n-import java.net.SocketAddress;\n-import java.net.SocketException;\n-import java.net.SocketImplFactory;\n-import java.net.UnknownHostException;\n-import java.nio.channels.AlreadyConnectedException;\n-import java.nio.channels.SocketChannel;\n-import java.util.List;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertSame;\n-import static org.junit.jupiter.api.Assertions.assertThrows;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-\n-\/*\n- * @test\n- * @bug 8343791\n- * @summary verifies the socket is closed on `connect()` failures\n- * @library \/test\/lib\n- * @run junit\/othervm --add-opens java.base\/java.net=ALL-UNNAMED CloseOnFailureTest\n- *\/\n-class CloseOnFailureTest {\n-\n-    private static final VarHandle SOCKET_IMPL_FACTORY_HANDLE = createSocketImplFactoryHandle();\n-\n-    private static final int DEAD_SERVER_PORT = 0xDEAD;\n-\n-    private static final InetSocketAddress REFUSING_SOCKET_ADDRESS = Utils.refusingEndpoint();\n-\n-    private static VarHandle createSocketImplFactoryHandle() {\n-        try {\n-            Field field = Socket.class.getDeclaredField(\"factory\");\n-            field.setAccessible(true);\n-            return MethodHandles\n-                    .privateLookupIn(Socket.class, MethodHandles.lookup())\n-                    .findStaticVarHandle(Socket.class, \"factory\", SocketImplFactory.class);\n-        } catch (NoSuchFieldException | IllegalAccessException exception) {\n-            throw new RuntimeException(exception);\n-        }\n-    }\n-\n-    private static void withSocketImplFactory(SocketImplFactory newFactory, ThrowingRunnable runnable) throws Throwable {\n-        SocketImplFactory oldFactory = (SocketImplFactory) SOCKET_IMPL_FACTORY_HANDLE.getAndSet(newFactory);\n-        try {\n-            runnable.run();\n-        } finally {\n-            SOCKET_IMPL_FACTORY_HANDLE.set(oldFactory);\n-        }\n-    }\n-\n-    private static final class MockSocketImpl extends ThrowingSocketImpl {\n-\n-        private final AtomicInteger closeInvocationCounter = new AtomicInteger(0);\n-\n-        private final Exception bindException;\n-\n-        private final Exception connectException;\n-\n-        private MockSocketImpl(Exception bindException, Exception connectException) {\n-            this.bindException = bindException;\n-            this.connectException = connectException;\n-        }\n-\n-        @Override\n-        protected void create(boolean stream) {}\n-\n-        @Override\n-        protected void bind(InetAddress host, int port) throws IOException {\n-            throwIfPresent(bindException);\n-        }\n-\n-        @Override\n-        protected void connect(SocketAddress address, int timeoutMillis) throws IOException {\n-            throwIfPresent(connectException);\n-        }\n-\n-        private void throwIfPresent(Exception exception) throws IOException {\n-            if (exception != null) {\n-                switch (exception) {\n-                    case IOException error -> throw error;\n-                    case RuntimeException error -> throw error;\n-                    default -> throw new IllegalStateException(\n-                            \"unknown exception type: \" + exception.getClass().getCanonicalName());\n-                }\n-            }\n-        }\n-\n-        @Override\n-        protected void close() {\n-            closeInvocationCounter.incrementAndGet();\n-        }\n-\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(\"ctorShouldCloseOnFailuresTestCases\")\n-    @SuppressWarnings(\"resource\")\n-    void ctorShouldCloseOnFailures(TestCase testCase) throws Throwable {\n-\n-        \/\/ Create a socket using the mock `SocketImpl` configured to fail\n-        withSocketImplFactory(() -> testCase.socketImpl, () -> {\n-\n-            \/\/ Trigger the failure\n-            Exception exception = assertThrows(Exception.class, () -> {\n-                \/\/ Address and port are mostly ineffective.\n-                \/\/ They just need to be _valid enough_ to reach to the point where both `SocketImpl#bind()` and `SocketImpl#connect()` are invoked.\n-                \/\/ Failure will be triggered by the injected `SocketImpl`.\n-                InetAddress serverAddress = InetAddress.getLoopbackAddress();\n-                new Socket(serverAddress, DEAD_SERVER_PORT, null, 0);\n-            });\n-\n-            \/\/ Run verifications\n-            testCase.caughtExceptionVerifier.accept(exception);\n-            testCase.socketImplVerifier.run();\n-\n-        });\n-\n-    }\n-\n-    static List<TestCase> ctorShouldCloseOnFailuresTestCases() {\n-        return List.of(\n-                TestCase.BindFailureFactory.iOExceptionTestCase(),\n-                TestCase.ConnectFailureFactory.iOExceptionTestCase(),\n-                TestCase.ConnectFailureFactory.illegalArgumentExceptionTestCase(1));\n-    }\n-\n-    @Test\n-    void connectShouldCloseOnUnresolvedAddress() throws IOException {\n-        MockSocketImpl socketImpl = new MockSocketImpl(null, null);\n-        try (Socket socket = new Socket(socketImpl) {}) {\n-            InetSocketAddress address = InetSocketAddress.createUnresolved(\"no.such.host\", DEAD_SERVER_PORT);\n-            assertTrue(address.isUnresolved());\n-            assertThrows(\n-                    UnknownHostException.class,\n-                    () -> socket.connect(address, 10_000),\n-                    () -> address.getHostName() + \" is unresolved\");\n-        }\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(\"connectShouldCloseOnFailuresTestCases\")\n-    void connectShouldCloseOnFailures(TestCase testCase) throws Throwable {\n-\n-        \/\/ Create a socket using the mock `SocketImpl` configured to fail\n-        try (Socket socket = new Socket(testCase.socketImpl) {}) {\n-\n-            \/\/ Trigger the failure\n-            Exception exception = assertThrows(Exception.class, () -> {\n-                \/\/ Address and timeout are mostly ineffective.\n-                \/\/ They just need to be _valid enough_ to reach to the `SocketImpl#connect()` invocation.\n-                \/\/ Failure will be triggered by the injected `SocketImpl`.\n-                socket.connect(REFUSING_SOCKET_ADDRESS, 10_000);\n-            });\n-\n-            \/\/ Run verifications\n-            testCase.caughtExceptionVerifier.accept(exception);\n-            testCase.socketImplVerifier.run();\n-            testCase.socketVerifier.accept(socket);\n-\n-        }\n-\n-    }\n-\n-    static List<TestCase> connectShouldCloseOnFailuresTestCases() {\n-        return List.of(\n-                TestCase.ConnectFailureFactory.iOExceptionTestCase(),\n-                TestCase.ConnectFailureFactory.illegalArgumentExceptionTestCase(0));\n-    }\n-\n-    private record TestCase(\n-            String description,\n-            MockSocketImpl socketImpl,\n-            ThrowingConsumer<Exception> caughtExceptionVerifier,\n-            ThrowingRunnable socketImplVerifier,\n-            ThrowingConsumer<Socket> socketVerifier) {\n-\n-        private static final String EXCEPTION_MESSAGE = \"intentional test failure\";\n-\n-        private static final class BindFailureFactory {\n-\n-            private static TestCase iOExceptionTestCase() {\n-                Exception bindException = new IOException(EXCEPTION_MESSAGE);\n-                MockSocketImpl socketImpl = new MockSocketImpl(bindException, null);\n-                String description = String.format(\n-                        \"%s.%s\",\n-                        BindFailureFactory.class.getSimpleName(),\n-                        bindException.getClass().getSimpleName());\n-                return new TestCase(\n-                        description,\n-                        socketImpl,\n-                        caughtException -> assertSame(bindException, caughtException),\n-                        () -> assertEquals(1, socketImpl.closeInvocationCounter.get()),\n-                        _ -> {});\n-            }\n-\n-        }\n-\n-        private static final class ConnectFailureFactory {\n-\n-            private static TestCase iOExceptionTestCase() {\n-                Exception connectException = new IOException(EXCEPTION_MESSAGE);\n-                MockSocketImpl socketImpl = new MockSocketImpl(null, connectException);\n-                String description = String.format(\n-                        \"%s.%s\",\n-                        ConnectFailureFactory.class.getSimpleName(),\n-                        connectException.getClass().getSimpleName());\n-                return new TestCase(\n-                        description,\n-                        socketImpl,\n-                        caughtException -> assertSame(connectException, caughtException),\n-                        () -> assertEquals(1, socketImpl.closeInvocationCounter.get()),\n-                        _ -> {});\n-            }\n-\n-            private static TestCase illegalArgumentExceptionTestCase(int expectedCloseInvocationCount) {\n-                Exception connectException = new IllegalArgumentException(EXCEPTION_MESSAGE);\n-                MockSocketImpl socketImpl = new MockSocketImpl(null, connectException);\n-                String description = String.format(\n-                        \"%s.%s\",\n-                        ConnectFailureFactory.class.getSimpleName(),\n-                        connectException.getClass().getSimpleName());\n-                return new TestCase(\n-                        description,\n-                        socketImpl,\n-                        caughtException -> assertSame(connectException, caughtException),\n-                        () -> assertEquals(expectedCloseInvocationCount, socketImpl.closeInvocationCounter.get()),\n-                        _ -> {\n-                        });\n-            }\n-\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return description;\n-        }\n-\n-    }\n-\n-    private static abstract class AbstractRealSocketTest {\n-\n-        private static final InetSocketAddress UNRESOLVED_ADDRESS =\n-                InetSocketAddress.createUnresolved(\"no.such.host\", DEAD_SERVER_PORT);\n-\n-        @Test\n-        void verifyUnresolvedAddress() {\n-            assertTrue(UNRESOLVED_ADDRESS.isUnresolved());\n-        }\n-\n-        @Test\n-        void verifyUnboundSocket() throws IOException {\n-            try (Socket socket = createUnboundSocket()) {\n-                assertFalse(socket.isBound());\n-                assertFalse(socket.isConnected());\n-            }\n-        }\n-\n-        @Test\n-        void verifyBoundSocket() throws IOException {\n-            try (Socket socket = createBoundSocket()) {\n-                assertTrue(socket.isBound());\n-                assertFalse(socket.isConnected());\n-            }\n-        }\n-\n-        @Test\n-        @SuppressWarnings(\"resource\")\n-        void verifyConnectedSocket() throws IOException {\n-            SocketAddress serverSocketAddress = serverSocket().getLocalSocketAddress();\n-            try (Socket socket = createConnectedSocket(serverSocketAddress)) {\n-                assertTrue(socket.isBound());\n-                assertTrue(socket.isConnected());\n-            }\n-        }\n-\n-        @Test\n-        void socketShouldBeClosedWhenConnectFailsUsingUnboundSocket() throws IOException {\n-            try (Socket socket = createUnboundSocket()) {\n-                assertThrows(IOException.class, () -> socket.connect(REFUSING_SOCKET_ADDRESS));\n-                assertTrue(socket.isClosed());\n-            }\n-        }\n-\n-        @Test\n-        void socketShouldBeClosedWhenConnectFailsUsingBoundSocket() throws IOException {\n-            try (Socket socket = createBoundSocket()) {\n-                assertThrows(IOException.class, () -> socket.connect(REFUSING_SOCKET_ADDRESS));\n-                assertTrue(socket.isClosed());\n-            }\n-        }\n-\n-        @Test\n-        @SuppressWarnings(\"resource\")\n-        void socketShouldNotBeClosedWhenConnectFailsUsingConnectedSocket() throws IOException {\n-            SocketAddress serverSocketAddress = serverSocket().getLocalSocketAddress();\n-            try (Socket socket = createConnectedSocket(serverSocketAddress)) {\n-                assertReconnectFailure(() -> socket.connect(REFUSING_SOCKET_ADDRESS));\n-                assertFalse(socket.isClosed());\n-            }\n-        }\n-\n-        @Test\n-        void socketShouldBeClosedWhenConnectWithUnresolvedAddressFailsUsingUnboundSocket() throws IOException {\n-            try (Socket socket = createUnboundSocket()) {\n-                assertThrows(IOException.class, () -> socket.connect(UNRESOLVED_ADDRESS));\n-                assertTrue(socket.isClosed());\n-            }\n-        }\n-\n-        @Test\n-        void socketShouldBeClosedWhenConnectWithUnresolvedAddressFailsUsingBoundSocket() throws IOException {\n-            try (Socket socket = createBoundSocket()) {\n-                assertThrows(IOException.class, () -> socket.connect(UNRESOLVED_ADDRESS));\n-                assertTrue(socket.isClosed());\n-            }\n-        }\n-\n-        @Test\n-        @SuppressWarnings(\"resource\")\n-        void socketShouldNotBeClosedWhenConnectWithUnresolvedAddressFailsUsingConnectedSocket() throws IOException {\n-            SocketAddress serverSocketAddress = serverSocket().getLocalSocketAddress();\n-            try (Socket socket = createConnectedSocket(serverSocketAddress)) {\n-                assertThrows(IOException.class, () -> socket.connect(UNRESOLVED_ADDRESS));\n-                assertFalse(socket.isClosed());\n-            }\n-        }\n-\n-        abstract ServerSocket serverSocket();\n-\n-        abstract Socket createUnboundSocket() throws IOException;\n-\n-        abstract Socket createBoundSocket() throws IOException;\n-\n-        abstract Socket createConnectedSocket(SocketAddress address) throws IOException;\n-\n-        abstract void assertReconnectFailure(Executable executable);\n-\n-    }\n-\n-    \/**\n-     * Tests using {@link Socket} instances created using {@link SocketChannel#socket()}.\n-     *\/\n-    @Nested\n-    @SuppressWarnings(\"resource\")\n-    class RealSocketUsingSocketChannelTest extends AbstractRealSocketTest {\n-\n-        @RegisterExtension\n-        static final ServerSocketExtension SERVER_SOCKET_EXTENSION = new ServerSocketExtension();\n-\n-        @Override\n-        ServerSocket serverSocket() {\n-            return SERVER_SOCKET_EXTENSION.serverSocket;\n-        }\n-\n-        Socket createUnboundSocket() throws IOException {\n-            return SocketChannel.open().socket();\n-        }\n-\n-        Socket createBoundSocket() throws IOException {\n-            SocketChannel channel = SocketChannel.open();\n-            channel.bind(new InetSocketAddress(0));\n-            return channel.socket();\n-        }\n-\n-        Socket createConnectedSocket(SocketAddress address) throws IOException {\n-            return SocketChannel.open(address).socket();\n-        }\n-\n-        @Override\n-        void assertReconnectFailure(Executable executable) {\n-            assertThrows(AlreadyConnectedException.class, executable);\n-        }\n-\n-    }\n-\n-    \/**\n-     * Tests using {@link Socket} instances created using {@link Socket} constructors.\n-     *\/\n-    @Nested\n-    class RealSocketUsingSocketTest extends AbstractRealSocketTest {\n-\n-        @RegisterExtension\n-        static final ServerSocketExtension SERVER_SOCKET_EXTENSION = new ServerSocketExtension();\n-\n-        @Override\n-        ServerSocket serverSocket() {\n-            return SERVER_SOCKET_EXTENSION.serverSocket;\n-        }\n-\n-        @Override\n-        Socket createUnboundSocket() {\n-            return new Socket();\n-        }\n-\n-        @Override\n-        Socket createBoundSocket() throws IOException {\n-            Socket socket = new Socket();\n-            socket.bind(new InetSocketAddress(0));\n-            return socket;\n-        }\n-\n-        @Override\n-        Socket createConnectedSocket(SocketAddress address) throws IOException {\n-            InetSocketAddress inetAddress = (InetSocketAddress) address;\n-            return new Socket(inetAddress.getAddress(), inetAddress.getPort());\n-        }\n-\n-        @Override\n-        void assertReconnectFailure(Executable executable) {\n-            SocketException exception = assertThrows(SocketException.class, executable);\n-            assertEquals(\"already connected\", exception.getMessage());\n-        }\n-\n-    }\n-\n-    private static final class ServerSocketExtension implements BeforeAllCallback, AfterAllCallback {\n-\n-        private final ExecutorService executorService = Executors.newVirtualThreadPerTaskExecutor();\n-\n-        private ServerSocket serverSocket;\n-\n-        @Override\n-        public void beforeAll(ExtensionContext extensionContext) throws Exception {\n-            serverSocket = new ServerSocket();\n-            serverSocket.bind(new InetSocketAddress(0));\n-            \/\/ Avoid blocking the JUnit pipeline; accept connections on a separate thread\n-            executorService.submit(() -> acceptConnections(executorService, serverSocket));\n-        }\n-\n-        @SuppressWarnings({\"ResultOfMethodCallIgnored\"})\n-        private static void acceptConnections(ExecutorService executorService, ServerSocket serverSocket) {\n-            System.err.println(\"[Test socket server] Accepting connections\");\n-            while (true) {\n-                try {\n-\n-                    Socket clientSocket = serverSocket.accept();\n-                    System.err.format(\n-                            \"[Test socket server] Accepted port %d to port %d%n\",\n-                            ((InetSocketAddress) clientSocket.getRemoteSocketAddress()).getPort(),\n-                            clientSocket.getLocalPort());\n-\n-                    \/\/ Server is shared by multiple tests, hence don't block the `accept()` loop.\n-                    \/\/ Consume the established connections on a separate thread.\n-                    executorService.submit(() -> {\n-                        try (clientSocket; InputStream inputStream = clientSocket.getInputStream()) {\n-                            \/\/ Instead of directly closing the socket, we try to read some to block. Directly closing\n-                            \/\/ the socket will invalidate the client socket tests checking the established connection\n-                            \/\/ status.\n-                            inputStream.read();\n-                        } catch (IOException _) {\n-                            \/\/ Do nothing\n-                        }\n-                        \/\/ Do nothing\n-                    });\n-\n-                } catch (IOException _) {\n-                    break;\n-                }\n-            }\n-        }\n-\n-        @Override\n-        public void afterAll(ExtensionContext extensionContext) throws Exception {\n-            System.err.println(\"[Test socket server] Shutting down\");\n-            executorService.shutdownNow();\n-            serverSocket.close();\n-        }\n-\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/net\/Socket\/CloseOnFailureTest.java","additions":0,"deletions":519,"binary":false,"changes":519,"status":"deleted"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+import org.junit.jupiter.api.function.Executable;\n+\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.SocketAddress;\n+import java.nio.channels.AlreadyConnectedException;\n+import java.nio.channels.SocketChannel;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+\/*\n+ * @test\n+ * @bug 8343791\n+ * @summary verifies the socket obtained from `SocketChannel.open().socket()` (i.e., `SocketAdaptor`) is closed on `connect()` failures\n+ * @library \/test\/lib\n+ * @run junit\/othervm --add-opens java.base\/java.net=ALL-UNNAMED CloseOnNioConnectFailureTest\n+ *\/\n+@SuppressWarnings(\"resource\")\n+class CloseOnNioConnectFailureTest extends CloseOnConnectFailureTestBase {\n+\n+    @RegisterExtension\n+    static final ServerSocketExtension SERVER_SOCKET_EXTENSION = new ServerSocketExtension();\n+\n+    @Override\n+    ServerSocket serverSocket() {\n+        return SERVER_SOCKET_EXTENSION.serverSocket;\n+    }\n+\n+    Socket createUnboundSocket() throws IOException {\n+        return SocketChannel.open().socket();\n+    }\n+\n+    Socket createBoundSocket() throws IOException {\n+        SocketChannel channel = SocketChannel.open();\n+        channel.bind(new InetSocketAddress(0));\n+        return channel.socket();\n+    }\n+\n+    Socket createConnectedSocket(SocketAddress address) throws IOException {\n+        return SocketChannel.open(address).socket();\n+    }\n+\n+    @Override\n+    void assertReconnectFailure(Executable executable) {\n+        assertThrows(AlreadyConnectedException.class, executable);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/Socket\/CloseOnNioConnectFailureTest.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+import org.junit.jupiter.api.function.Executable;\n+\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.SocketAddress;\n+import java.net.SocketException;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+\/*\n+ * @test\n+ * @bug 8343791\n+ * @summary verifies the socket obtained from `Socket` constructors is closed on `connect()` failures\n+ * @library \/test\/lib\n+ * @run junit\/othervm --add-opens java.base\/java.net=ALL-UNNAMED CloseOnOioConnectFailureTest\n+ *\/\n+class CloseOnOioConnectFailureTest extends CloseOnConnectFailureTestBase {\n+\n+    @RegisterExtension\n+    static final ServerSocketExtension SERVER_SOCKET_EXTENSION = new ServerSocketExtension();\n+\n+    @Override\n+    ServerSocket serverSocket() {\n+        return SERVER_SOCKET_EXTENSION.serverSocket;\n+    }\n+\n+    @Override\n+    Socket createUnboundSocket() {\n+        return new Socket();\n+    }\n+\n+    @Override\n+    Socket createBoundSocket() throws IOException {\n+        Socket socket = new Socket();\n+        socket.bind(new InetSocketAddress(0));\n+        return socket;\n+    }\n+\n+    @Override\n+    Socket createConnectedSocket(SocketAddress address) throws IOException {\n+        InetSocketAddress inetAddress = (InetSocketAddress) address;\n+        return new Socket(inetAddress.getAddress(), inetAddress.getPort());\n+    }\n+\n+    @Override\n+    void assertReconnectFailure(Executable executable) {\n+        SocketException exception = assertThrows(SocketException.class, executable);\n+        assertEquals(\"already connected\", exception.getMessage());\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/Socket\/CloseOnOioConnectFailureTest.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.junit.jupiter.api.extension.AfterAllCallback;\n+import org.junit.jupiter.api.extension.BeforeAllCallback;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+\/**\n+ * A JUnit extension containing an ephemeral {@link ServerSocket} that tests can use to verify connectivity-related issues.\n+ *\/\n+final class ServerSocketExtension implements BeforeAllCallback, AfterAllCallback {\n+\n+    private final ExecutorService executorService = Executors.newVirtualThreadPerTaskExecutor();\n+\n+    ServerSocket serverSocket;\n+\n+    @Override\n+    public void beforeAll(ExtensionContext extensionContext) throws Exception {\n+        serverSocket = new ServerSocket();\n+        serverSocket.bind(new InetSocketAddress(0));\n+        \/\/ Avoid blocking the JUnit pipeline; accept connections on a separate thread\n+        executorService.submit(() -> acceptConnections(executorService, serverSocket));\n+    }\n+\n+    @SuppressWarnings({\"ResultOfMethodCallIgnored\"})\n+    private static void acceptConnections(ExecutorService executorService, ServerSocket serverSocket) {\n+        System.err.println(\"[Test socket server] Accepting connections\");\n+        while (true) {\n+            try {\n+\n+                Socket clientSocket = serverSocket.accept();\n+                System.err.format(\n+                        \"[Test socket server] Accepted port %d to port %d%n\",\n+                        ((InetSocketAddress) clientSocket.getRemoteSocketAddress()).getPort(),\n+                        clientSocket.getLocalPort());\n+\n+                \/\/ Server is shared by multiple tests, hence don't block the `accept()` loop.\n+                \/\/ Consume the established connections on a separate thread.\n+                executorService.submit(() -> {\n+                    try (clientSocket; InputStream inputStream = clientSocket.getInputStream()) {\n+                        \/\/ Instead of directly closing the socket, we try to read some to block. Directly closing\n+                        \/\/ the socket will invalidate the client socket tests checking the established connection\n+                        \/\/ status.\n+                        inputStream.read();\n+                    } catch (IOException _) {\n+                        \/\/ Do nothing\n+                    }\n+                    \/\/ Do nothing\n+                });\n+\n+            } catch (IOException _) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void afterAll(ExtensionContext extensionContext) throws Exception {\n+        System.err.println(\"[Test socket server] Shutting down\");\n+        executorService.shutdownNow();\n+        serverSocket.close();\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/Socket\/ServerSocketExtension.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"}]}