{"files":[{"patch":"@@ -673,1 +673,0 @@\n-  vmassert(last_Java_pc() == nullptr, \"already walkable\");\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,47 @@\n+#if INCLUDE_JFR\n+\n+\/\/ Static helper routines\n+\n+inline address frame::interpreter_bcp(const intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return reinterpret_cast<address>(fp[frame::interpreter_frame_bcp_offset]);\n+}\n+\n+inline address frame::interpreter_return_address(const intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return reinterpret_cast<address>(fp[frame::return_addr_offset]);\n+}\n+\n+inline intptr_t* frame::interpreter_sender_sp(const intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return reinterpret_cast<intptr_t*>(fp[frame::interpreter_frame_sender_sp_offset]);\n+}\n+\n+inline bool frame::is_interpreter_frame_setup_at(const intptr_t* fp, const void* sp) {\n+  assert(fp != nullptr, \"invariant\");\n+  assert(sp != nullptr, \"invariant\");\n+  return sp <= fp + frame::interpreter_frame_initial_sp_offset;\n+}\n+\n+inline intptr_t* frame::sender_sp(intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return fp + frame::sender_sp_offset;\n+}\n+\n+inline intptr_t* frame::link(const intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return reinterpret_cast<intptr_t*>(fp[frame::link_offset]);\n+}\n+\n+inline address frame::return_address(const intptr_t* sp) {\n+  assert(sp != nullptr, \"invariant\");\n+  return reinterpret_cast<address>(sp[-1]);\n+}\n+\n+inline intptr_t* frame::fp(const intptr_t* sp) {\n+  assert(sp != nullptr, \"invariant\");\n+  return reinterpret_cast<intptr_t*>(sp[-2]);\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.inline.hpp","additions":47,"deletions":0,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -500,1 +500,0 @@\n-\/\/ Apply stack watermark barrier.\n@@ -503,0 +502,2 @@\n+\/\/ Apply stack watermark barrier.\n+\/\/ Notify JVMTI.\n@@ -512,5 +513,4 @@\n-void InterpreterMacroAssembler::remove_activation(\n-                                TosState state,\n-                                bool throw_monitor_exception,\n-                                bool install_monitor_exception,\n-                                bool notify_jvmdi) {\n+void InterpreterMacroAssembler::remove_activation(TosState state,\n+                                                  bool throw_monitor_exception,\n+                                                  bool install_monitor_exception,\n+                                                  bool notify_jvmdi) {\n@@ -521,17 +521,0 @@\n-  \/\/ The below poll is for the stack watermark barrier. It allows fixing up frames lazily,\n-  \/\/ that would normally not be safe to use. Such bad returns into unsafe territory of\n-  \/\/ the stack, will call InterpreterRuntime::at_unwind.\n-  Label slow_path;\n-  Label fast_path;\n-  safepoint_poll(slow_path, true \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n-  j(fast_path);\n-\n-  bind(slow_path);\n-  push(state);\n-  set_last_Java_frame(esp, fp, (address)pc(), t0);\n-  super_call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind), xthread);\n-  reset_last_Java_frame(true);\n-  pop(state);\n-\n-  bind(fast_path);\n-\n@@ -658,3 +641,17 @@\n-  \/\/ jvmti support\n-  if (notify_jvmdi) {\n-    notify_method_exit(state, NotifyJVMTI);    \/\/ preserve TOSCA\n+  JFR_ONLY(enter_jfr_critical_section();)\n+\n+  \/\/ The below poll is for the stack watermark barrier. It allows fixing up frames lazily,\n+  \/\/ that would normally not be safe to use. Such bad returns into unsafe territory of\n+  \/\/ the stack, will call InterpreterRuntime::at_unwind.\n+  Label slow_path;\n+  Label fast_path;\n+  safepoint_poll(slow_path, true \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n+  j(fast_path);\n+\n+  bind(slow_path);\n+  push(state);\n+  set_last_Java_frame(esp, fp, pc(), t0);\n+  super_call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind), xthread);\n+  reset_last_Java_frame(true);\n+  pop(state);\n+  bind(fast_path);\n@@ -662,0 +659,3 @@\n+  \/\/ JVMTI support. Make sure the safepoint poll test is issued prior.\n+  if (notify_jvmdi) {\n+    notify_method_exit(state, NotifyJVMTI); \/\/ preserve TOSCA\n@@ -680,0 +680,2 @@\n+    \/\/ look for an overflow into the stack reserved zone, i.e.\n+    \/\/ interpreter_frame_sender_sp <= JavaThread::reserved_stack_activation\n@@ -683,0 +685,2 @@\n+    JFR_ONLY(leave_jfr_critical_section();)\n+\n@@ -692,0 +696,5 @@\n+  \/\/ remove frame anchor\n+  leave();\n+\n+  JFR_ONLY(leave_jfr_critical_section();)\n+\n@@ -695,2 +704,0 @@\n-  \/\/ remove frame anchor\n-  leave();\n@@ -704,0 +711,13 @@\n+#if INCLUDE_JFR\n+void InterpreterMacroAssembler::enter_jfr_critical_section() {\n+  const Address sampling_critical_section(xthread, in_bytes(SAMPLING_CRITICAL_SECTION_OFFSET_JFR));\n+  mv(t0, true);\n+  sb(t0, sampling_critical_section);\n+}\n+\n+void InterpreterMacroAssembler::leave_jfr_critical_section() {\n+  const Address sampling_critical_section(xthread, in_bytes(SAMPLING_CRITICAL_SECTION_OFFSET_JFR));\n+  sb(zr, sampling_critical_section);\n+}\n+#endif \/\/ INCLUDE_JFR\n+\n@@ -1518,1 +1538,1 @@\n-  \/\/ Note: No need to save\/restore rbcp & rlocals pointer since these\n+  \/\/ Note: No need to save\/restore xbcp & xlocals pointer since these\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":49,"deletions":29,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -293,0 +293,3 @@\n+  JFR_ONLY(void enter_jfr_critical_section();)\n+  JFR_ONLY(void leave_jfr_critical_section();)\n+\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3742,2 +3742,2 @@\n-void MacroAssembler::safepoint_poll(Label& slow_path, bool at_return, bool acquire, bool in_nmethod) {\n-  ld(t0, Address(xthread, JavaThread::polling_word_offset()));\n+void MacroAssembler::safepoint_poll(Label& slow_path, bool at_return, bool acquire, bool in_nmethod, Register tmp_reg) {\n+  ld(tmp_reg, Address(xthread, JavaThread::polling_word_offset()));\n@@ -3748,1 +3748,1 @@\n-    bgtu(in_nmethod ? sp : fp, t0, slow_path, \/* is_far *\/ true);\n+    bgtu(in_nmethod ? sp : fp, tmp_reg, slow_path, \/* is_far *\/ true);\n@@ -3750,2 +3750,2 @@\n-    test_bit(t0, t0, exact_log2(SafepointMechanism::poll_bit()));\n-    bnez(t0, slow_path, true \/* is_far *\/);\n+    test_bit(tmp_reg, tmp_reg, exact_log2(SafepointMechanism::poll_bit()));\n+    bnez(tmp_reg, slow_path, \/* is_far *\/ true);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-  void safepoint_poll(Label& slow_path, bool at_return, bool acquire, bool in_nmethod);\n+  void safepoint_poll(Label& slow_path, bool at_return, bool acquire, bool in_nmethod, Register tmp_reg = t0);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1897,0 +1897,18 @@\n+  #if INCLUDE_JFR\n+  \/\/ We need to do a poll test after unwind in case the sampler\n+  \/\/ managed to sample the native frame after returning to Java.\n+  Label L_return;\n+  __ ld(t0, Address(xthread, JavaThread::polling_word_offset()));\n+  address poll_test_pc = __ pc();\n+  __ relocate(relocInfo::poll_return_type);\n+  __ test_bit(t0, t0, log2i_exact(SafepointMechanism::poll_bit()));\n+  __ beqz(t0, L_return);\n+  assert(SharedRuntime::polling_page_return_handler_blob() != nullptr,\n+         \"polling page return stub not created yet\");\n+  address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n+  __ la(t0, InternalAddress(poll_test_pc));\n+  __ sd(t0, Address(xthread, JavaThread::saved_exception_pc_offset()));\n+  __ far_jump(RuntimeAddress(stub));\n+  __ bind(L_return);\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1375,0 +1375,25 @@\n+  #if INCLUDE_JFR\n+  __ enter_jfr_critical_section();\n+\n+  \/\/ This poll test is to uphold the invariant that a JFR sampled frame\n+  \/\/ must not return to its caller without a prior safepoint poll check.\n+  \/\/ The earlier poll check in this routine is insufficient for this purpose\n+  \/\/ because the thread has transitioned back to Java.\n+\n+  Label slow_path;\n+  Label fast_path;\n+  __ safepoint_poll(slow_path, true \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n+  __ j(fast_path);\n+\n+  __ bind(slow_path);\n+  __ push(dtos);\n+  __ push(ltos);\n+  __ set_last_Java_frame(esp, fp, __ pc(), t0);\n+  __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind), xthread);\n+  __ reset_last_Java_frame(true);\n+  __ pop(ltos);\n+  __ pop(dtos);\n+  __ bind(fast_path);\n+\n+#endif \/\/ INCLUDE_JFR\n+\n@@ -1388,1 +1413,2 @@\n-  __ ld(esp, Address(fp, frame::interpreter_frame_sender_sp_offset * wordSize)); \/\/ get sender sp\n+  \/\/ get sender sp\n+  __ ld(esp, Address(fp, frame::interpreter_frame_sender_sp_offset * wordSize));\n@@ -1392,0 +1418,2 @@\n+  JFR_ONLY(__ leave_jfr_critical_section();)\n+\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1760,0 +1760,2 @@\n+    JFR_ONLY(__ enter_jfr_critical_section();)\n+\n@@ -1768,1 +1770,1 @@\n-        Address(fp, frame::interpreter_frame_sender_sp_offset * wordSize));\n+          Address(fp, frame::interpreter_frame_sender_sp_offset * wordSize));\n@@ -1771,0 +1773,3 @@\n+\n+    JFR_ONLY(__ leave_jfr_critical_section();)\n+\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+#define REG_BCP      22\n@@ -161,2 +162,4 @@\n-  Unimplemented();\n-  return nullptr;\n+  assert(ucVoid != nullptr, \"invariant\");\n+  const ucontext_t* uc = (const ucontext_t*)ucVoid;\n+  assert(os::Posix::ucontext_is_interpreter(uc), \"invariant\");\n+  return reinterpret_cast<intptr_t*>(uc->uc_mcontext.__gregs[REG_BCP]);\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/os_linux_riscv.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"}]}