{"files":[{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/continuationEntry.hpp\"\n@@ -505,5 +506,4 @@\n-void InterpreterMacroAssembler::remove_activation(\n-        TosState state,\n-        bool throw_monitor_exception,\n-        bool install_monitor_exception,\n-        bool notify_jvmdi) {\n+void InterpreterMacroAssembler::remove_activation(TosState state,\n+                                                  bool throw_monitor_exception,\n+                                                  bool install_monitor_exception,\n+                                                  bool notify_jvmdi) {\n@@ -672,1 +672,1 @@\n-  \/\/ we must save the current rbp in a temporary register, current_fp, for use\n+  \/\/ we must save the current rfp in a temporary register, this_fp, for use\n@@ -676,19 +676,2 @@\n-  const Register current_fp = rscratch2;\n-  const Register return_addr = rscratch2;\n-  const Register continuation_return_pc = rscratch1;\n-  const Register sender_sp = rscratch1;\n-  ldr(return_addr, Address(rfp, wordSize)); \/\/ return address\n-  \/\/ Load address of ContinuationEntry return pc\n-  lea(continuation_return_pc, ExternalAddress(ContinuationEntry::return_pc_address()));\n-  \/\/ Load the ContinuationEntry return pc\n-  ldr(continuation_return_pc, Address(continuation_return_pc));\n-  Label L_continuation, L_end;\n-  cmp(continuation_return_pc, return_addr);\n-  mov(current_fp, rfp); \/\/ Save current fp in temporary register.\n-  br(Assembler::EQ, L_continuation);\n-  ldr(rfp, Address(rfp)); \/\/ Update the frame link.\n-  b(L_end);\n-  bind(L_continuation);\n-  lea(sender_sp, Address(rfp, frame::sender_sp_offset * wordSize));\n-  ldr(rfp, Address(sender_sp, (int)(ContinuationEntry::size()))); \/\/ Update the frame link.\n-  bind(L_end);\n+  const Register this_fp = rscratch2;\n+  make_sender_fp_current(this_fp, rscratch1);\n@@ -704,1 +687,1 @@\n-  safepoint_poll(slow_path, current_fp, true \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n+  safepoint_poll(slow_path, this_fp, true \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n@@ -707,1 +690,1 @@\n-  save_bcp(current_fp); \/\/ need to save bcp but not restore it.\n+  save_bcp(this_fp); \/\/ need to save bcp but not restore it.\n@@ -709,1 +692,1 @@\n-  set_last_Java_frame_with_sender_fp(esp, current_fp, (address)pc(), rscratch1);\n+  set_last_Java_frame_with_sender_fp(esp, this_fp, (address)pc(), rscratch1);\n@@ -711,1 +694,1 @@\n-  reset_last_Java_frame_with_sender_fp(current_fp);\n+  reset_last_Java_frame_with_sender_fp(this_fp);\n@@ -715,2 +698,2 @@\n-  ldr(esp, Address(current_fp, frame::interpreter_frame_sender_sp_offset * wordSize));\n-  ldr(lr, Address(current_fp, wordSize));\n+  ldr(esp, Address(this_fp, frame::interpreter_frame_sender_sp_offset * wordSize));\n+  ldr(lr, Address(this_fp, wordSize));\n@@ -718,1 +701,1 @@\n-  lea(sp, Address(current_fp, 2 * wordSize));\n+  lea(sp, Address(this_fp, 2 * wordSize));\n@@ -727,0 +710,21 @@\n+void InterpreterMacroAssembler::make_sender_fp_current(Register save_this_fp, Register tmp) {\n+  const Register return_addr = save_this_fp;\n+  const Register continuation_return_pc = tmp;\n+  const Register sender_sp = tmp;\n+  ldr(return_addr, Address(rfp, wordSize)); \/\/ return address\n+  \/\/ Load address of ContinuationEntry return pc\n+  lea(continuation_return_pc, ExternalAddress(ContinuationEntry::return_pc_address()));\n+  \/\/ Load the ContinuationEntry return pc\n+  ldr(continuation_return_pc, Address(continuation_return_pc));\n+  Label L_continuation, L_end;\n+  cmp(continuation_return_pc, return_addr);\n+  mov(save_this_fp, rfp); \/\/ Save current fp in temporary register.\n+  br(Assembler::EQ, L_continuation);\n+  ldr(rfp, Address(rfp)); \/\/ Update the frame link.\n+  b(L_end);\n+  bind(L_continuation);\n+  lea(sender_sp, Address(rfp, frame::sender_sp_offset * wordSize));\n+  ldr(rfp, Address(sender_sp, (int)(ContinuationEntry::size()))); \/\/ Update the frame link.\n+  bind(L_end);\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":36,"deletions":32,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -241,0 +241,2 @@\n+  void make_sender_fp_current(Register save_this_fp, Register tmp);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-#include \"runtime\/continuationEntry.hpp\"\n@@ -1618,2 +1617,2 @@\n-  \/\/ updating the frame link. But since we are unwinding the current frame,\n-  \/\/ we must save the current rbp in a temporary register, current_fp, for use\n+  \/\/ updating the frame link (fp). But since we are unwinding the current frame,\n+  \/\/ we must save the current rfp in a temporary register, this_fp, for use\n@@ -1621,1 +1620,1 @@\n-  \/\/ The asynchronous profiler will only see the updated rbp, either using the\n+  \/\/ The asynchronous profiler will only see the updated rfp, either using the\n@@ -1623,19 +1622,2 @@\n-  const Register current_fp = rscratch2;\n-  const Register return_addr = rscratch2;\n-  const Register continuation_return_pc = rscratch1;\n-  const Register sender_sp = rscratch1;\n-  __ ldr(return_addr, Address(rfp, wordSize)); \/\/ return address\n-  \/\/ Load address of ContinuationEntry return pc\n-  __ lea(continuation_return_pc, ExternalAddress(ContinuationEntry::return_pc_address()));\n-  \/\/ Load the ContinuationEntry return pc\n-  __ ldr(continuation_return_pc, Address(continuation_return_pc));\n-  Label L_continuation, L_end;\n-  __ cmp(continuation_return_pc, return_addr);\n-  __ mov(current_fp, rfp); \/\/ Save current fp in temporary register.\n-  __ br(Assembler::EQ, L_continuation);\n-  __ ldr(rfp, Address(rfp)); \/\/ Update the frame link.\n-  __ b(L_end);\n-  __ bind(L_continuation);\n-  __ lea(sender_sp, Address(rfp, frame::sender_sp_offset* wordSize));\n-  __ ldr(rfp, Address(sender_sp, (int)(ContinuationEntry::size()))); \/\/ Update the frame link.\n-  __ bind(L_end);\n+  const Register this_fp = rscratch2;\n+  __ make_sender_fp_current(this_fp, rscratch1);\n@@ -1651,1 +1633,1 @@\n-  __ safepoint_poll(slow_path, current_fp, true \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n+  __ safepoint_poll(slow_path, this_fp, true \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n@@ -1656,1 +1638,1 @@\n-  __ set_last_Java_frame_with_sender_fp(esp, current_fp, (address)__ pc(), rscratch1);\n+  __ set_last_Java_frame_with_sender_fp(esp, this_fp, (address)__ pc(), rscratch1);\n@@ -1658,1 +1640,1 @@\n-  __ reset_last_Java_frame_with_sender_fp(current_fp);\n+  __ reset_last_Java_frame_with_sender_fp(this_fp);\n@@ -1663,2 +1645,2 @@\n-  __ ldr(esp, Address(current_fp, frame::interpreter_frame_sender_sp_offset* wordSize));\n-  __ ldr(lr, Address(current_fp, wordSize));\n+  __ ldr(esp, Address(this_fp, frame::interpreter_frame_sender_sp_offset* wordSize));\n+  __ ldr(lr, Address(this_fp, wordSize));\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":10,"deletions":28,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-#include \"runtime\/continuationEntry.hpp\"\n@@ -1898,2 +1897,2 @@\n-    \/\/ updating the frame link. But since we are unwinding the current frame,\n-    \/\/ we must save the current rbp in a temporary register, current_fp, for use\n+    \/\/ updating the frame link (fp). But since we are unwinding the current frame,\n+    \/\/ we must save the current rfp in a temporary register, this_fp, for use\n@@ -1903,19 +1902,2 @@\n-    const Register current_fp = rscratch2;\n-    const Register return_addr = rscratch2;\n-    const Register continuation_return_pc = rscratch1;\n-    const Register sender_sp = rscratch1;\n-    __ ldr(return_addr, Address(rfp, wordSize)); \/\/ return address\n-    \/\/ Load address of ContinuationEntry return pc\n-    __ lea(continuation_return_pc, ExternalAddress(ContinuationEntry::return_pc_address()));\n-    \/\/ Load the ContinuationEntry return pc\n-    __ ldr(continuation_return_pc, Address(continuation_return_pc));\n-    Label L_continuation, L_end;\n-    __ cmp(continuation_return_pc, return_addr);\n-    __ mov(current_fp, rfp); \/\/ Save current fp in temporary register.\n-    __ br(Assembler::EQ, L_continuation);\n-    __ ldr(rfp, Address(rfp)); \/\/ Update the frame link.\n-    __ b(L_end);\n-    __ bind(L_continuation);\n-    __ lea(sender_sp, Address(rfp, frame::sender_sp_offset* wordSize));\n-    __ ldr(rfp, Address(sender_sp, (int)(ContinuationEntry::size()))); \/\/ Update the frame link.\n-    __ bind(L_end);\n+    const Register this_fp = rscratch2;\n+    __ make_sender_fp_current(this_fp, rscratch1);\n@@ -1926,2 +1908,2 @@\n-    __ save_bcp(current_fp); \/\/ need to save bcp but not restore it.\n-    __ set_last_Java_frame_with_sender_fp(esp, current_fp, (address)__ pc(), rscratch1);\n+    __ save_bcp(this_fp); \/\/ need to save bcp but not restore it.\n+    __ set_last_Java_frame_with_sender_fp(esp, this_fp, (address)__ pc(), rscratch1);\n@@ -1931,1 +1913,1 @@\n-    __ reset_last_Java_frame_with_sender_fp(current_fp);\n+    __ reset_last_Java_frame_with_sender_fp(this_fp);\n@@ -1935,2 +1917,2 @@\n-    __ ldr(esp, Address(current_fp, frame::interpreter_frame_sender_sp_offset* wordSize));\n-    __ ldr(lr, Address(current_fp, wordSize));\n+    __ ldr(esp, Address(this_fp, frame::interpreter_frame_sender_sp_offset* wordSize));\n+    __ ldr(lr, Address(this_fp, wordSize));\n@@ -1938,1 +1920,1 @@\n-    __ lea(sp, Address(current_fp, 2 * wordSize));\n+    __ lea(sp, Address(this_fp, 2 * wordSize));\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":10,"deletions":28,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -791,1 +791,1 @@\n-  mov(c_rarg0, r15_thread);\n+  movptr(c_rarg0, r15_thread);\n@@ -840,6 +840,5 @@\n-void InterpreterMacroAssembler::remove_activation(\n-        TosState state,\n-        Register ret_addr,\n-        bool throw_monitor_exception,\n-        bool install_monitor_exception,\n-        bool notify_jvmdi) {\n+void InterpreterMacroAssembler::remove_activation(TosState state,\n+                                                  Register ret_addr,\n+                                                  bool throw_monitor_exception,\n+                                                  bool install_monitor_exception,\n+                                                  bool notify_jvmdi) {\n@@ -1012,2 +1011,2 @@\n-  \/\/ updating the frame link. But since we are unwinding the current frame,\n-  \/\/ we must save the current rbp in a temporary register, current_fp, for use\n+  \/\/ updating the frame link (fp). But since we are unwinding the current frame,\n+  \/\/ we must save the current rbp in a temporary register, this_fp, for use\n@@ -1017,19 +1016,2 @@\n-  const Register current_fp = rscratch2;\n-  const Register return_addr = rscratch2;\n-  const Register continuation_return_pc = rscratch1;\n-  const Register sender_sp = rscratch1;\n-  movptr(return_addr, Address(rbp, wordSize)); \/\/ return address\n-  \/\/ Load address of ContinuationEntry return pc\n-  lea(continuation_return_pc, ExternalAddress(ContinuationEntry::return_pc_address()));\n-  \/\/ Load the ContinuationEntry return pc\n-  movptr(continuation_return_pc, Address(continuation_return_pc));\n-  Label L_continuation, L_end;\n-  cmpptr(continuation_return_pc, return_addr);\n-  movptr(current_fp, rbp); \/\/ Save current fp in temporary register.\n-  jcc(Assembler::equal, L_continuation);\n-  movptr(rbp, Address(rbp, frame::link_offset)); \/\/ Update the frame link.\n-  jmp(L_end);\n-  bind(L_continuation);\n-  lea(sender_sp, Address(rbp, frame::sender_sp_offset* wordSize));\n-  movptr(rbp, Address(sender_sp, (int)(ContinuationEntry::size()))); \/\/ Update the frame link.\n-  bind(L_end);\n+  const Register this_fp = rscratch2;\n+  make_sender_fp_current(this_fp, rscratch1);\n@@ -1045,2 +1027,2 @@\n-  safepoint_poll(slow_path, rthread, current_fp, true \/* at_return *\/, false \/* in_nmethod *\/);\n-  jmp(fast_path);\n+  safepoint_poll(slow_path, r15_thread, this_fp, true \/* at_return *\/, false \/* in_nmethod *\/);\n+  jmpb(fast_path);\n@@ -1049,2 +1031,2 @@\n-  \/\/ Special call to save also the sender fp (the now updated rbp) and using the temporary current_fp register as the last_java_fp.\n-  call_VM_with_sender_Java_fp_entry(current_fp, rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind));\n+  \/\/ Special call to save also the sender fp (the now updated rbp) and using the temporary this_fp register as the last_java_fp.\n+  call_VM_with_sender_Java_fp_entry(this_fp, rscratch1, CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind));\n@@ -1055,1 +1037,1 @@\n-  movptr(ret_addr, Address(current_fp, wordSize)); \/\/ return address\n+  movptr(ret_addr, Address(this_fp, wordSize)); \/\/ return address\n@@ -1061,0 +1043,21 @@\n+void InterpreterMacroAssembler::make_sender_fp_current(Register save_this_fp, Register tmp) {\n+  const Register return_addr = save_this_fp;\n+  const Register continuation_return_pc = tmp;\n+  const Register sender_sp = tmp;\n+  movptr(return_addr, Address(rbp, wordSize)); \/\/ return address\n+  \/\/ Load address of ContinuationEntry return pc\n+  lea(continuation_return_pc, ExternalAddress(ContinuationEntry::return_pc_address()));\n+  \/\/ Load the ContinuationEntry return pc\n+  movptr(continuation_return_pc, Address(continuation_return_pc));\n+  Label L_continuation, L_end;\n+  cmpptr(continuation_return_pc, return_addr);\n+  movptr(save_this_fp, rbp); \/\/ Save current fp in temporary register.\n+  jccb(Assembler::equal, L_continuation);\n+  movptr(rbp, Address(rbp, frame::link_offset)); \/\/ Update the frame link.\n+  jmpb(L_end);\n+  bind(L_continuation);\n+  lea(sender_sp, Address(rbp, frame::sender_sp_offset * wordSize));\n+  movptr(rbp, Address(sender_sp, (int)(ContinuationEntry::size()))); \/\/ Update the frame link.\n+  bind(L_end);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":36,"deletions":33,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -213,0 +213,3 @@\n+\n+  void make_sender_fp_current(Register save_this_fp, Register tmp);\n+\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1164,2 +1164,2 @@\n-  \/\/ updating the frame link. But since we are unwinding the current frame,\n-  \/\/ we must save the current rbp in a temporary register, current_fp, for use\n+  \/\/ updating the frame link (fp). But since we are unwinding the current frame,\n+  \/\/ we must save the current rbp in a temporary register, this_fp, for use\n@@ -1169,19 +1169,2 @@\n-  const Register current_fp = rscratch2;\n-  const Register return_addr = rscratch2;\n-  const Register continuation_return_pc = rscratch1;\n-  const Register sender_sp = rscratch1;\n-  __ movptr(return_addr, Address(rbp, wordSize)); \/\/ return address\n-  \/\/ Load address of ContinuationEntry return pc\n-  __ lea(continuation_return_pc, ExternalAddress(ContinuationEntry::return_pc_address()));\n-  \/\/ Load the ContinuationEntry return pc\n-  __ movptr(continuation_return_pc, Address(continuation_return_pc));\n-  Label L_continuation, L_end;\n-  __ cmpptr(continuation_return_pc, return_addr);\n-  __ movptr(current_fp, rbp); \/\/ Save current fp in temporary register.\n-  __ jcc(Assembler::equal, L_continuation);\n-  __ movptr(rbp, Address(rbp, frame::link_offset)); \/\/ Update the frame link.\n-  __ jmp(L_end);\n-  __ bind(L_continuation);\n-  __ lea(sender_sp, Address(rbp, frame::sender_sp_offset* wordSize));\n-  __ movptr(rbp, Address(sender_sp, (int)(ContinuationEntry::size()))); \/\/ Update the frame link.\n-  __ bind(L_end);\n+  const Register this_fp = rscratch2;\n+  __ make_sender_fp_current(this_fp, rscratch1);\n@@ -1197,1 +1180,1 @@\n-  __ safepoint_poll(slow_path, thread, current_fp, true, false);\n+  __ safepoint_poll(slow_path, thread, this_fp, true, false);\n@@ -1202,1 +1185,1 @@\n-  __ call_VM_with_sender_Java_fp_entry(current_fp, rscratch1, CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind), false \/* save_bcp *\/);\n+  __ call_VM_with_sender_Java_fp_entry(this_fp, rscratch1, CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind), false \/* save_bcp *\/);\n@@ -1208,2 +1191,2 @@\n-  __ movptr(rdi, Address(current_fp, wordSize)); \/\/ get return address\n-  __ movptr(rsp, Address(current_fp, frame::interpreter_frame_sender_sp_offset* wordSize)); \/\/ get sender sp\n+  __ movptr(rdi, Address(this_fp, wordSize)); \/\/ get return address\n+  __ movptr(rsp, Address(this_fp, frame::interpreter_frame_sender_sp_offset* wordSize)); \/\/ get sender sp\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":8,"deletions":25,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1861,2 +1861,2 @@\n-      \/\/ updating the frame link. But since we are unwinding the current frame,\n-      \/\/ we must save the current rbp in a temporary register, current_fp, for use\n+      \/\/ updating the frame link (fp). But since we are unwinding the current frame,\n+      \/\/ we must save the current rbp in a temporary register, this_fp, for use\n@@ -1866,19 +1866,2 @@\n-      const Register current_fp = rscratch2;\n-      const Register return_addr = rscratch2;\n-      const Register continuation_return_pc = rax;\n-      const Register sender_sp = rax;\n-      __ movptr(return_addr, Address(rbp, wordSize)); \/\/ return address\n-      \/\/ Load address of ContinuationEntry return pc\n-      __ lea(continuation_return_pc, ExternalAddress(ContinuationEntry::return_pc_address()));\n-      \/\/ Load the ContinuationEntry return pc\n-      __ movptr(continuation_return_pc, Address(continuation_return_pc));\n-      Label L_continuation, L_end;\n-      __ cmpptr(continuation_return_pc, return_addr);\n-      __ movptr(current_fp, rbp); \/\/ Save current fp in temporary register.\n-      __ jcc(Assembler::equal, L_continuation);\n-      __ movptr(rbp, Address(rbp, frame::link_offset)); \/\/ Update the frame link.\n-      __ jmp(L_end);\n-      __ bind(L_continuation);\n-      __ lea(sender_sp, Address(rbp, frame::sender_sp_offset* wordSize));\n-      __ movptr(rbp, Address(sender_sp, (int)(ContinuationEntry::size()))); \/\/ Update the frame link.\n-      __ bind(L_end);\n+      const Register this_fp = rscratch2;\n+      __ make_sender_fp_current(this_fp, rax);\n@@ -1888,1 +1871,1 @@\n-      __ call_VM_with_sender_Java_fp_entry(current_fp, rax, CAST_FROM_FN_PTR(address, SharedRuntime::OSR_migration_begin));\n+      __ call_VM_with_sender_Java_fp_entry(this_fp, rax, CAST_FROM_FN_PTR(address, SharedRuntime::OSR_migration_begin));\n@@ -1899,2 +1882,2 @@\n-      __ movptr(retaddr, Address(current_fp, frame::return_addr_offset * wordSize)); \/\/ get return address\n-      __ movptr(rsp, Address(current_fp, frame::interpreter_frame_sender_sp_offset* wordSize)); \/\/ get sender sp\n+      __ movptr(retaddr, Address(this_fp, frame::return_addr_offset * wordSize)); \/\/ get return address\n+      __ movptr(rsp, Address(this_fp, frame::interpreter_frame_sender_sp_offset* wordSize)); \/\/ get sender sp\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":7,"deletions":24,"binary":false,"changes":31,"status":"modified"}]}