{"files":[{"patch":"@@ -44,4 +44,0 @@\n-    assert(SharedRuntime::polling_page_return_handler_blob() != nullptr,\n-           \"polling page return stub not created yet\");\n-    address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n-\n@@ -49,14 +45,1 @@\n-    \/\/ Using pc relative address computation.\n-    {\n-      Label next_pc;\n-      __ bl(next_pc);\n-      __ bind(next_pc);\n-    }\n-    int current_offset = __ offset();\n-    __ mflr(R12);\n-    __ add_const_optimized(R12, R12, safepoint_offset() - current_offset);\n-    __ std(R12, in_bytes(JavaThread::saved_exception_pc_offset()), R16_thread);\n-\n-    __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(stub));\n-    __ mtctr(R0);\n-    __ bctr();\n+    __ jump_to_polling_page_return_handler_blob(safepoint_offset());\n","filename":"src\/hotspot\/cpu\/ppc\/c1_CodeStubs_ppc.cpp","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2021, 2022, SAP SE. All rights reserved.\n+ * Copyright (c) 2021, 2025 SAP SE. All rights reserved.\n@@ -37,4 +37,0 @@\n-  assert(SharedRuntime::polling_page_return_handler_blob() != nullptr,\n-         \"polling page return stub not created yet\");\n-  address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n-\n@@ -42,7 +38,0 @@\n-  \/\/ Using pc relative address computation.\n-  {\n-    Label next_pc;\n-    __ bl(next_pc);\n-    __ bind(next_pc);\n-  }\n-  int current_offset = __ offset();\n@@ -50,8 +39,1 @@\n-  __ load_const32(R12, _safepoint_offset - current_offset);\n-  __ mflr(R0);\n-  __ add(R12, R12, R0);\n-  __ std(R12, in_bytes(JavaThread::saved_exception_pc_offset()), R16_thread);\n-\n-  __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(stub));\n-  __ mtctr(R0);\n-  __ bctr();\n+  __ jump_to_polling_page_return_handler_blob(_safepoint_offset, true);\n","filename":"src\/hotspot\/cpu\/ppc\/c2_CodeStubs_ppc.cpp","additions":2,"deletions":20,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -366,1 +366,1 @@\n-  inline frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, const ImmutableOopMap* oop_map);\n+  inline frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, const ImmutableOopMap* oop_map = nullptr);\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025 SAP SE. All rights reserved.\n@@ -394,0 +394,39 @@\n+#if INCLUDE_JFR\n+\n+\/\/ Static helper routines\n+inline intptr_t* frame::sender_sp(intptr_t* fp) { return fp; }\n+\n+\/\/ Extract common_abi parts.\n+inline intptr_t* frame::fp(const intptr_t* sp) {\n+  assert(sp != nullptr, \"invariant\");\n+  return reinterpret_cast<intptr_t*>(((common_abi*)sp)->callers_sp);\n+}\n+\n+inline intptr_t* frame::link(const intptr_t* fp) { return frame::fp(fp); }\n+\n+inline address frame::return_address(const intptr_t* sp) {\n+  assert(sp != nullptr, \"invariant\");\n+  return reinterpret_cast<address>(((common_abi*)sp)->lr);\n+}\n+\n+inline address frame::interpreter_return_address(const intptr_t* fp) { return frame::return_address(fp); }\n+\n+\/\/ Extract java interpreter state parts.\n+inline address frame::interpreter_bcp(const intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return reinterpret_cast<address>(*(fp + ijava_idx(bcp)));\n+}\n+\n+inline intptr_t* frame::interpreter_sender_sp(const intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return reinterpret_cast<intptr_t*>(*(fp + ijava_idx(sender_sp)));\n+}\n+\n+inline bool frame::is_interpreter_frame_setup_at(const intptr_t* fp, const void* sp) {\n+  assert(fp != nullptr, \"invariant\");\n+  assert(sp != nullptr, \"invariant\");\n+  return sp <= fp - ((frame::ijava_state_size + frame::top_ijava_frame_abi_size) >> LogBytesPerWord);\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.inline.hpp","additions":41,"deletions":2,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025 SAP SE. All rights reserved.\n@@ -173,1 +173,5 @@\n-  void merge_frames(Register Rtop_frame_sp, Register return_pc, Register Rscratch1, Register Rscratch2); \/\/ merge top frames\n+  JFR_ONLY(void enter_jfr_critical_section();)\n+  JFR_ONLY(void leave_jfr_critical_section();)\n+  void load_fp(Register fp);\n+  void remove_top_frame_given_fp(Register fp, Register sender_sp, Register sender_fp, Register return_pc, Register temp);\n+  void merge_frames(Register sender_sp, Register return_pc, Register temp1, Register temp2); \/\/ merge top frames\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -796,8 +796,11 @@\n-void InterpreterMacroAssembler::merge_frames(Register Rsender_sp, Register return_pc,\n-                                             Register Rscratch1, Register Rscratch2) {\n-  \/\/ Pop interpreter frame.\n-  ld(Rscratch1, 0, R1_SP); \/\/ *SP\n-  ld(Rsender_sp, _ijava_state_neg(sender_sp), Rscratch1); \/\/ top_frame_sp\n-  ld(Rscratch2, 0, Rscratch1); \/\/ **SP\n-  if (return_pc!=noreg) {\n-    ld(return_pc, _abi0(lr), Rscratch1); \/\/ LR\n+void InterpreterMacroAssembler::load_fp(Register fp) {\n+  ld(fp, _abi0(callers_sp), R1_SP); \/\/ *SP\n+}\n+\n+void InterpreterMacroAssembler::remove_top_frame_given_fp(Register fp, Register sender_sp, Register sender_fp,\n+                                                          Register return_pc, Register temp) {\n+  assert_different_registers(sender_sp, sender_fp, return_pc, temp);\n+  ld(sender_sp, _ijava_state_neg(sender_sp), fp);\n+  ld(sender_fp, _abi0(callers_sp), fp); \/\/ **SP\n+  if (return_pc != noreg) {\n+    ld(return_pc, _abi0(lr), fp); \/\/ last usage of fp, register can be reused\n@@ -805,0 +808,3 @@\n+  subf(temp, R1_SP, sender_sp);   \/\/ sender_sp - SP\n+  stdux(sender_fp, R1_SP, temp);  \/\/ atomically set *(SP = sender_sp) = sender_fp\n+}\n@@ -806,3 +812,5 @@\n-  \/\/ Merge top frames.\n-  subf(Rscratch1, R1_SP, Rsender_sp); \/\/ top_frame_sp - SP\n-  stdux(Rscratch2, R1_SP, Rscratch1); \/\/ atomically set *(SP = top_frame_sp) = **SP\n+void InterpreterMacroAssembler::merge_frames(Register sender_sp, Register return_pc,\n+                                             Register temp1, Register temp2) {\n+  Register fp = temp1, sender_fp = temp2;\n+  load_fp(fp);\n+  remove_top_frame_given_fp(fp, sender_sp, sender_fp, return_pc, \/* temp *\/ fp);\n@@ -867,0 +875,2 @@\n+  unlock_if_synchronized_method(state, throw_monitor_exception, install_monitor_exception);\n+\n@@ -870,2 +880,5 @@\n-  Label slow_path;\n-  Label fast_path;\n+  Label slow_path, fast_path;\n+  Register fp = R22_tmp2;\n+  load_fp(fp);\n+\n+  JFR_ONLY(enter_jfr_critical_section();)\n@@ -883,2 +896,0 @@\n-  unlock_if_synchronized_method(state, throw_monitor_exception, install_monitor_exception);\n-\n@@ -904,2 +915,1 @@\n-    ld_ptr(R11_scratch1, _abi0(callers_sp), R1_SP); \/\/ Load frame pointer.\n-    cmpld(CR0, R11_scratch1, R0);\n+    cmpld(CR0, fp, R0);\n@@ -908,0 +918,2 @@\n+    JFR_ONLY(leave_jfr_critical_section();)\n+\n@@ -919,1 +931,1 @@\n-  merge_frames(\/*top_frame_sp*\/ R21_sender_SP, \/*return_pc*\/ R0, R11_scratch1, R12_scratch2);\n+  remove_top_frame_given_fp(fp, R21_sender_SP, R23_tmp3, \/*return_pc*\/ R0, R11_scratch1);\n@@ -922,0 +934,2 @@\n+  JFR_ONLY(leave_jfr_critical_section();)\n+\n@@ -925,0 +939,12 @@\n+#if INCLUDE_JFR\n+void InterpreterMacroAssembler::enter_jfr_critical_section() {\n+  li(R0, 1);\n+  stb(R0, in_bytes(SAMPLING_CRITICAL_SECTION_OFFSET_JFR), R16_thread);\n+}\n+\n+void InterpreterMacroAssembler::leave_jfr_critical_section() {\n+  li(R0, 0);\n+  stb(R0, in_bytes(SAMPLING_CRITICAL_SECTION_OFFSET_JFR), R16_thread);\n+}\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":44,"deletions":18,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2014 SAP SE. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025 SAP SE. All rights reserved.\n@@ -76,0 +76,2 @@\n+  intptr_t* last_Java_fp() const      { return *(intptr_t**)_last_Java_sp; }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/javaFrameAnchor_ppc.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3345,0 +3345,29 @@\n+void MacroAssembler::jump_to_polling_page_return_handler_blob(int safepoint_offset, bool fixed_size) {\n+  assert(SharedRuntime::polling_page_return_handler_blob() != nullptr,\n+         \"polling page return stub not created yet\");\n+  address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n+\n+  \/\/ Determine saved exception pc using pc relative address computation.\n+  {\n+    Label next_pc;\n+    bl(next_pc);\n+    bind(next_pc);\n+  }\n+  int current_offset = offset();\n+\n+  if (fixed_size) {\n+    \/\/ Code size must not depend on offsets.\n+    load_const32(R12, safepoint_offset - current_offset);\n+    mflr(R0);\n+    add(R12, R12, R0);\n+  } else {\n+    mflr(R12);\n+    add_const_optimized(R12, R12, safepoint_offset - current_offset);\n+  }\n+  std(R12, in_bytes(JavaThread::saved_exception_pc_offset()), R16_thread);\n+\n+  add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(stub));\n+  mtctr(R0);\n+  bctr();\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -734,0 +734,1 @@\n+  void jump_to_polling_page_return_handler_blob(int safepoint_offset, bool fixed_size = false);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2743,0 +2743,15 @@\n+  \/\/ Prepare for return\n+  \/\/ --------------------------------------------------------------------------\n+  __ pop_frame();\n+  __ restore_LR(R11);\n+\n+#if INCLUDE_JFR\n+  \/\/ We need to do a poll test after unwind in case the sampler\n+  \/\/ managed to sample the native frame after returning to Java.\n+  Label L_stub;\n+  int safepoint_offset = __ offset();\n+  if (!UseSIGTRAP) {\n+    __ relocate(relocInfo::poll_return_type);\n+  }\n+  __ safepoint_poll(L_stub, r_temp_2, true \/* at_return *\/, true \/* in_nmethod: frame already popped *\/);\n+#endif \/\/ INCLUDE_JFR\n@@ -2750,5 +2765,1 @@\n-  \/\/ Return\n-  \/\/ --------------------------------------------------------------------------\n-\n-  __ pop_frame();\n-  __ restore_LR(R11);\n+  \/\/ Return.\n@@ -2757,0 +2768,7 @@\n+  \/\/ Handler for return safepoint (out-of-line).\n+#if INCLUDE_JFR\n+  if (!UseSIGTRAP) {\n+    __ bind(L_stub);\n+    __ jump_to_polling_page_return_handler_blob(safepoint_offset);\n+  }\n+#endif \/\/ INCLUDE_JFR\n@@ -2764,3 +2782,0 @@\n-\n-  __ pop_frame();\n-  __ restore_LR(R11);\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":23,"deletions":8,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1587,0 +1587,18 @@\n+  #if INCLUDE_JFR\n+  __ enter_jfr_critical_section();\n+\n+  \/\/ This poll test is to uphold the invariant that a JFR sampled frame\n+  \/\/ must not return to its caller without a prior safepoint poll check.\n+  \/\/ The earlier poll check in this routine is insufficient for this purpose\n+  \/\/ because the thread has transitioned back to Java.\n+\n+  Label slow_path, fast_path;\n+  __ safepoint_poll(slow_path, R11_scratch1, true \/* at_return *\/, false \/* in_nmethod *\/);\n+  __ b(fast_path);\n+  __ bind(slow_path);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind), R16_thread);\n+  __ align(32);\n+  __ bind(fast_path);\n+\n+#endif \/\/ INCLUDE_JFR\n+\n@@ -1628,1 +1646,2 @@\n-  __ merge_frames(\/*top_frame_sp*\/ R21_sender_SP, \/*return_pc*\/ R0, R11_scratch1, R12_scratch2);\n+  __ merge_frames(\/*top_frame_sp*\/ R21_sender_SP, \/*return_pc*\/ R12_scratch2, R11_scratch1, R0);\n+  JFR_ONLY(__ leave_jfr_critical_section();)\n@@ -1632,1 +1651,1 @@\n-  __ mtlr(R0);\n+  __ mtlr(R12_scratch2);\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1751,0 +1751,1 @@\n+    JFR_ONLY(__ enter_jfr_critical_section();)\n@@ -1756,1 +1757,2 @@\n-    __ merge_frames(\/*top_frame_sp*\/ R21_sender_SP, \/*return_pc*\/ R0, R11_scratch1, R12_scratch2);\n+    __ merge_frames(\/*top_frame_sp*\/ R21_sender_SP, \/*return_pc*\/ R12_scratch2, R11_scratch1, R0);\n+    JFR_ONLY(__ leave_jfr_critical_section();)\n@@ -1760,1 +1762,1 @@\n-    __ mtlr(R0);\n+    __ mtlr(R12_scratch2);\n","filename":"src\/hotspot\/cpu\/ppc\/templateTable_ppc_64.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -142,2 +142,4 @@\n-  Unimplemented();\n-  return nullptr;\n+  assert(ucVoid != nullptr, \"invariant\");\n+  const ucontext_t* uc = (const ucontext_t*)ucVoid;\n+  assert(os::Posix::ucontext_is_interpreter(uc), \"invariant\");\n+  return reinterpret_cast<intptr_t*>(uc->uc_mcontext.jmp_context.gpr[14]); \/\/ R14_bcp\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/os_aix_ppc.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -174,2 +174,4 @@\n-  Unimplemented();\n-  return nullptr;\n+  assert(ucVoid != nullptr, \"invariant\");\n+  const ucontext_t* uc = (const ucontext_t*)ucVoid;\n+  assert(os::Posix::ucontext_is_interpreter(uc), \"invariant\");\n+  return reinterpret_cast<intptr_t*>(uc->uc_mcontext.regs->gpr[14]); \/\/ R14_bcp\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/os_linux_ppc.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}