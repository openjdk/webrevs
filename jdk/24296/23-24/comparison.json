{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-#include \"runtime\/continuationEntry.hpp\"\n@@ -460,32 +459,0 @@\n-void InterpreterMacroAssembler::call_VM_with_sender_Java_fp_entry(address entry_point) {\n-  mov(c_rarg0, rthread);\n-  MacroAssembler::call_VM_leaf_base(entry_point, 0);\n-}\n-\n-void InterpreterMacroAssembler::set_last_Java_frame_with_sender_fp(Register last_java_sp,\n-                                                                   Register last_java_fp,\n-                                                                   address last_java_pc,\n-                                                                   Register scratch) {\n-  assert_different_registers(last_java_fp, rfp);\n-\n-#if INCLUDE_JFR\n-  Label L_ljf, L_valid_rfp;\n-  cbnz(rfp, L_valid_rfp);\n-  mov(scratch, 1);\n-  str(scratch, Address(rthread, JavaThread::last_sender_Java_fp_offset()));\n-  b(L_ljf);\n-  bind(L_valid_rfp);\n-  str(rfp, Address(rthread, JavaThread::last_sender_Java_fp_offset()));\n-  bind(L_ljf);\n-#endif\n-\n-  set_last_Java_frame(last_java_sp, last_java_fp, last_java_pc, scratch);\n-}\n-\n-void InterpreterMacroAssembler::reset_last_Java_frame_with_sender_fp(Register fp_reg) {\n-  \/\/ Restore the fp_reg.\n-  ldr(fp_reg, Address(rthread, JavaThread::last_Java_fp_offset()));\n-  reset_last_Java_frame(true);\n-  JFR_ONLY(str(zr, Address(rthread, JavaThread::last_sender_Java_fp_offset()));)\n-}\n-\n@@ -497,0 +464,1 @@\n+\/\/ Notify JVMTI.\n@@ -631,1 +599,18 @@\n-  \/\/ jvmti support\n+  JFR_ONLY(enter_jfr_critical_section();)\n+\n+  \/\/ The below poll is for the stack watermark barrier. It allows fixing up frames lazily,\n+  \/\/ that would normally not be safe to use. Such bad returns into unsafe territory of\n+  \/\/ the stack, will call InterpreterRuntime::at_unwind.\n+  Label slow_path;\n+  Label fast_path;\n+  safepoint_poll(slow_path, true \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n+  br(Assembler::AL, fast_path);\n+  bind(slow_path);\n+  push(state);\n+  set_last_Java_frame(esp, rfp, pc(), rscratch1);\n+  super_call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind), rthread);\n+  reset_last_Java_frame(true);\n+  pop(state);\n+  bind(fast_path);\n+\n+  \/\/ JVMTI support. Make sure the safepoint poll test is issued prior.\n@@ -667,36 +652,4 @@\n-  \/\/ For asynchronous profiling to work correctly, we must remove the\n-  \/\/ activation frame _before_ we test the method return safepoint poll.\n-  \/\/ This is equivalent to how it is done for compiled frames.\n-  \/\/ Removing an interpreter activation frame from a sampling perspective means\n-  \/\/ updating the frame link. But since we are unwinding the current frame,\n-  \/\/ we must save the current rfp in a temporary register, this_fp, for use\n-  \/\/ as the last java fp should we decide to unwind.\n-  \/\/ The asynchronous profiler will only see the updated rfp, either using the\n-  \/\/ CPU context or by reading the last_sender_Java_fp() field as part of the ljf.\n-  const Register this_fp = rscratch2;\n-  make_sender_fp_current(this_fp, rscratch1);\n-\n-  \/\/ The interpreter frame is now unwound from a sampling perspective,\n-  \/\/ meaning it sees the sender frame as the current frame from this point onwards.\n-\n-  \/\/ The below poll is for the stack watermark barrier. It allows fixing up frames lazily,\n-  \/\/ that would normally not be safe to use. Such bad returns into unsafe territory of\n-  \/\/ the stack, will call InterpreterRuntime::at_unwind.\n-  Label slow_path;\n-  Label fast_path;\n-  safepoint_poll(slow_path, this_fp, true \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n-  br(Assembler::AL, fast_path);\n-  bind(slow_path);\n-  save_bcp(this_fp); \/\/ need to save bcp but not restore it.\n-  push(state);\n-  set_last_Java_frame_with_sender_fp(esp, this_fp, (address)pc(), rscratch1);\n-  call_VM_with_sender_Java_fp_entry(CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind));\n-  reset_last_Java_frame_with_sender_fp(this_fp);\n-  pop(state);\n-  bind(fast_path);\n-\n-  ldr(esp, Address(this_fp, frame::interpreter_frame_sender_sp_offset * wordSize));\n-  ldr(lr, Address(this_fp, wordSize));\n-  authenticate_return_address();\n-  lea(sp, Address(this_fp, 2 * wordSize));\n-\n+  \/\/ restore sender esp\n+  mov(esp, rscratch2);\n+  \/\/ remove frame anchor\n+  leave();\n@@ -708,0 +661,10 @@\n+\n+  JFR_ONLY(leave_jfr_critical_section();)\n+}\n+\n+#if INCLUDE_JFR\n+void InterpreterMacroAssembler::enter_jfr_critical_section() {\n+  const Address sampling_critical_section(rthread, in_bytes(SAMPLING_CRITICAL_SECTION_OFFSET_JFR));\n+  mov(rscratch1, true);\n+  strb(rscratch1, sampling_critical_section);\n+  membar(Assembler::StoreLoad);\n@@ -710,19 +673,4 @@\n-void InterpreterMacroAssembler::make_sender_fp_current(Register save_this_fp, Register tmp) {\n-  const Register return_addr = save_this_fp;\n-  const Register continuation_return_pc = tmp;\n-  const Register sender_sp = tmp;\n-  ldr(return_addr, Address(rfp, wordSize)); \/\/ return address\n-  \/\/ Load address of ContinuationEntry return pc\n-  lea(continuation_return_pc, ExternalAddress(ContinuationEntry::return_pc_address()));\n-  \/\/ Load the ContinuationEntry return pc\n-  ldr(continuation_return_pc, Address(continuation_return_pc));\n-  Label L_continuation, L_end;\n-  cmp(continuation_return_pc, return_addr);\n-  mov(save_this_fp, rfp); \/\/ Save current fp in temporary register.\n-  br(Assembler::EQ, L_continuation);\n-  ldr(rfp, Address(rfp)); \/\/ Update the frame link.\n-  b(L_end);\n-  bind(L_continuation);\n-  lea(sender_sp, Address(rfp, frame::sender_sp_offset * wordSize));\n-  ldr(rfp, Address(sender_sp, (int)(ContinuationEntry::size()))); \/\/ Update the frame link.\n-  bind(L_end);\n+void InterpreterMacroAssembler::leave_jfr_critical_section() {\n+  const Address sampling_critical_section(rthread, in_bytes(SAMPLING_CRITICAL_SECTION_OFFSET_JFR));\n+  membar(Assembler::StoreStore);\n+  strb(zr, sampling_critical_section);\n@@ -730,0 +678,1 @@\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":38,"deletions":89,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -66,9 +66,0 @@\n-  void call_VM_with_sender_Java_fp_entry(address entry_point);\n-\n-  void set_last_Java_frame_with_sender_fp(Register last_java_sp,\n-                                          Register last_java_fp,\n-                                          address last_java_pc,\n-                                          Register scratch);\n-\n-  void reset_last_Java_frame_with_sender_fp(Register fp_reg);\n-\n@@ -82,5 +73,1 @@\n-    save_bcp(rfp);\n-  }\n-\n-  void save_bcp(Register fp_register) {\n-    str(rbcp, Address(fp_register, frame::interpreter_frame_bcp_offset * wordSize));\n+    str(rbcp, Address(rfp, frame::interpreter_frame_bcp_offset * wordSize));\n@@ -241,2 +228,0 @@\n-  void make_sender_fp_current(Register save_this_fp, Register tmp);\n-\n@@ -328,0 +313,3 @@\n+  JFR_ONLY(void enter_jfr_critical_section();)\n+  JFR_ONLY(void leave_jfr_critical_section();)\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":4,"deletions":16,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-  JFR_ONLY(intptr_t* volatile _last_sender_Java_fp;) \/\/ specialized field for when JFR samples an interpreter frame\n@@ -48,1 +47,0 @@\n-    JFR_ONLY(_last_sender_Java_fp = nullptr;)\n@@ -64,1 +62,0 @@\n-    JFR_ONLY(_last_sender_Java_fp = src->_last_sender_Java_fp;)\n@@ -78,1 +75,1 @@\n- public:\n+  static ByteSize last_Java_fp_offset()          { return byte_offset_of(JavaFrameAnchor, _last_Java_fp); }\n@@ -86,6 +83,0 @@\n-  JFR_ONLY(intptr_t* last_sender_Java_fp() const { return _last_sender_Java_fp; })\n-\n-  static ByteSize last_Java_fp_offset() { return byte_offset_of(JavaFrameAnchor, _last_Java_fp); }\n-\n-  JFR_ONLY(static ByteSize last_sender_Java_fp_offset() { return byte_offset_of(JavaFrameAnchor, _last_sender_Java_fp); })\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/javaFrameAnchor_aarch64.hpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -557,5 +557,0 @@\n-  safepoint_poll(slow_path, rfp, at_return, acquire, in_nmethod, tmp);\n-}\n-\n-void MacroAssembler::safepoint_poll(Label& slow_path, Register fp_reg, bool at_return, bool acquire, bool in_nmethod, Register tmp) {\n-  assert(fp_reg != tmp, \"invariant\");\n@@ -571,1 +566,1 @@\n-    cmp(in_nmethod ? sp : fp_reg, tmp);\n+    cmp(in_nmethod ? sp : rfp, tmp);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -124,2 +124,0 @@\n-  void safepoint_poll(Label& slow_path, Register fp_reg, bool at_return, bool acquire, bool in_nmethod, Register tmp = rscratch1);\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1987,0 +1987,17 @@\n+  #if INCLUDE_JFR\n+  \/\/ We need to do a poll test after unwind in case the sampler\n+  \/\/ managed to sample the native frame after returning to Java.\n+  Label L_return;\n+  __ ldr(rscratch1, Address(rthread, JavaThread::polling_word_offset()));\n+  address poll_test_pc = __ pc();\n+  __ relocate(relocInfo::poll_return_type);\n+  __ tbz(rscratch1, log2i_exact(SafepointMechanism::poll_bit()), L_return);\n+  assert(SharedRuntime::polling_page_return_handler_blob() != nullptr,\n+    \"polling page return stub not created yet\");\n+  address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n+  __ adr(rscratch1, InternalAddress(poll_test_pc));\n+  __ str(rscratch1, Address(rthread, JavaThread::saved_exception_pc_offset()));\n+  __ far_jump(RuntimeAddress(stub));\n+  __ bind(L_return);\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1596,0 +1596,24 @@\n+  #if INCLUDE_JFR\n+  __ enter_jfr_critical_section();\n+\n+  \/\/ This poll test is to uphold the invariant that a JFR sampled frame\n+  \/\/ must not return to its caller without a prior safepoint poll check.\n+  \/\/ The earlier poll check in this routine is insufficient for this purpose\n+  \/\/ because the thread has transitioned back to Java.\n+\n+  Label slow_path;\n+  Label fast_path;\n+  __ safepoint_poll(slow_path, true \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n+  __ br(Assembler::AL, fast_path);\n+  __ bind(slow_path);\n+  __ push(dtos);\n+  __ push(ltos);\n+  __ set_last_Java_frame(esp, rfp, __ pc(), rscratch1);\n+  __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind), rthread);\n+  __ reset_last_Java_frame(true);\n+  __ pop(ltos);\n+  __ pop(dtos);\n+  __ bind(fast_path);\n+\n+#endif \/\/ INCLUDE_JFR\n+\n@@ -1612,0 +1636,5 @@\n+  __ ldr(esp, Address(rfp,\n+                    frame::interpreter_frame_sender_sp_offset *\n+                    wordSize)); \/\/ get sender sp\n+  \/\/ remove frame anchor\n+  __ leave();\n@@ -1613,35 +1642,0 @@\n-  \/\/ For asynchronous profiling to work correctly, we must remove the\n-  \/\/ activation frame _before_ we test the method return safepoint poll.\n-  \/\/ This is equivalent to how it is done for compiled frames.\n-  \/\/ Removing an interpreter activation frame from a sampling perspective means\n-  \/\/ updating the frame link (fp). But since we are unwinding the current frame,\n-  \/\/ we must save the current rfp in a temporary register, this_fp, for use\n-  \/\/ as the last java fp should we decide to unwind.\n-  \/\/ The asynchronous profiler will only see the updated rfp, either using the\n-  \/\/ CPU context or by reading the last_sender_Java_fp() field as part of the ljf.\n-  const Register this_fp = rscratch2;\n-  __ make_sender_fp_current(this_fp, rscratch1);\n-\n-  \/\/ The interpreter frame is now unwound from a sampling perspective,\n-  \/\/ meaning it sees the sender frame as the current frame from this point onwards.\n-\n-  \/\/ The below poll is for the stack watermark barrier. It allows fixing up frames lazily,\n-  \/\/ that would normally not be safe to use. Such bad returns into unsafe territory of\n-  \/\/ the stack, will call InterpreterRuntime::at_unwind.\n-  Label slow_path;\n-  Label fast_path;\n-  __ safepoint_poll(slow_path, this_fp, true \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n-  __ br(Assembler::AL, fast_path);\n-  __ bind(slow_path);\n-  __ push(dtos);\n-  __ push(ltos);\n-  __ set_last_Java_frame_with_sender_fp(esp, this_fp, (address)__ pc(), rscratch1);\n-  __ call_VM_with_sender_Java_fp_entry(CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind));\n-  __ reset_last_Java_frame_with_sender_fp(this_fp);\n-  __ pop(ltos);\n-  __ pop(dtos);\n-  __ bind(fast_path);\n-\n-  __ ldr(esp, Address(this_fp, frame::interpreter_frame_sender_sp_offset* wordSize));\n-  __ ldr(lr, Address(this_fp, wordSize));\n-  __ authenticate_return_address();\n@@ -1651,0 +1645,2 @@\n+  JFR_ONLY(__ leave_jfr_critical_section();)\n+\n@@ -1920,1 +1916,0 @@\n-    __ restore_bcp();\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":31,"deletions":36,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -1893,18 +1893,4 @@\n-    \/\/ For asynchronous profiling to work correctly, we must remove the\n-    \/\/ activation frame _before_ we test the method return safepoint poll.\n-    \/\/ This is equivalent to how it is done for compiled frames.\n-    \/\/ Removing an interpreter activation frame from a sampling perspective means\n-    \/\/ updating the frame link (fp). But since we are unwinding the current frame,\n-    \/\/ we must save the current rfp in a temporary register, this_fp, for use\n-    \/\/ as the last java fp should we decide to unwind.\n-    \/\/ The asynchronous profiler will only see the updated rfp, either using the\n-    \/\/ CPU context or by reading the last_sender_Java_fp() field as part of the ljf.\n-    const Register this_fp = rscratch2;\n-    __ make_sender_fp_current(this_fp, rscratch1);\n-\n-    \/\/ The interpreter frame is now unwound from a sampling perspective,\n-    \/\/ meaning it sees the sender frame as the current frame from this point onwards.\n-\n-    __ save_bcp(this_fp); \/\/ need to save bcp but not restore it.\n-    __ set_last_Java_frame_with_sender_fp(esp, this_fp, (address)__ pc(), rscratch1);\n-    __ call_VM_with_sender_Java_fp_entry(CAST_FROM_FN_PTR(address, SharedRuntime::OSR_migration_begin));\n+    JFR_ONLY(__ enter_jfr_critical_section();)\n+\n+    call_VM(noreg, CAST_FROM_FN_PTR(address, SharedRuntime::OSR_migration_begin));\n+\n@@ -1913,1 +1899,0 @@\n-    __ reset_last_Java_frame_with_sender_fp(this_fp);\n@@ -1917,4 +1902,4 @@\n-    __ ldr(esp, Address(this_fp, frame::interpreter_frame_sender_sp_offset* wordSize));\n-    __ ldr(lr, Address(this_fp, wordSize));\n-    __ authenticate_return_address();\n-    __ lea(sp, Address(this_fp, 2 * wordSize));\n+    __ ldr(esp,\n+        Address(rfp, frame::interpreter_frame_sender_sp_offset * wordSize));\n+    \/\/ remove frame anchor\n+    __ leave();\n@@ -1924,0 +1909,2 @@\n+    JFR_ONLY(__ leave_jfr_critical_section();)\n+\n@@ -1930,0 +1917,1 @@\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":11,"deletions":23,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-  JFR_ONLY(intptr_t* volatile _last_sender_Java_fp;) \/\/ specialized field for when JFR samples an interpreter frame\n@@ -47,1 +46,0 @@\n-    JFR_ONLY(_last_sender_Java_fp = nullptr;)\n@@ -58,1 +56,1 @@\n-    if (_last_Java_sp != src->_last_Java_sp) {\n+    if (_last_Java_sp != src->_last_Java_sp)\n@@ -60,1 +58,0 @@\n-    }\n@@ -63,1 +60,0 @@\n-    JFR_ONLY(_last_sender_Java_fp = src->_last_sender_Java_fp;)\n@@ -88,3 +84,0 @@\n-  JFR_ONLY(intptr_t* last_sender_Java_fp() const { return _last_sender_Java_fp; })\n-  JFR_ONLY(static ByteSize last_sender_Java_fp_offset() { return byte_offset_of(JavaFrameAnchor, _last_sender_Java_fp); })\n-\n","filename":"src\/hotspot\/cpu\/arm\/javaFrameAnchor_arm.hpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-#include \"runtime\/continuationEntry.hpp\"\n@@ -780,45 +779,0 @@\n-void InterpreterMacroAssembler::call_VM_with_sender_Java_fp(Register fp_reg, Register tmp, address entry_point, bool store_bcp) {\n-  if (store_bcp) {\n-    save_bcp(fp_reg); \/\/ We must save the bcp, but need not restore it. This is because we have already popped the fp.\n-  }\n-  \/\/ Adjust sp as we now have a return address on stack.\n-  \/\/ We've pushed one address, correct last_Java_sp\n-  Register last_java_sp = tmp;\n-  lea(last_java_sp, Address(rsp, wordSize));\n-\n-  \/\/ Thread argument\n-  movptr(c_rarg0, r15_thread);\n-\n-#if INCLUDE_JFR\n-  Label L_ljf, L_valid_rbp;\n-  testptr(rbp, rbp);\n-  jccb(Assembler::notZero, L_valid_rbp);\n-  Address last_sender_Java_fp_offset(r15_thread, JavaThread::frame_anchor_offset() + JavaFrameAnchor::last_sender_Java_fp_offset());\n-  movptr(last_sender_Java_fp_offset, 1);\n-  jmpb(L_ljf);\n-  bind(L_valid_rbp);\n-  movptr(last_sender_Java_fp_offset, rbp);\n-  bind(L_ljf);\n-#endif\n-\n-  Address last_java_fp_offset(r15_thread, JavaThread::last_Java_fp_offset());\n-  movptr(last_java_fp_offset, fp_reg);\n-  movptr(fp_reg, Address(rsp, 0)); \/\/ last_java_pc\n-  movptr(Address(r15_thread, JavaThread::last_Java_pc_offset()), fp_reg);\n-  movptr(Address(r15_thread, JavaThread::last_Java_sp_offset()), last_java_sp);\n-  MacroAssembler::call_VM_leaf_base(entry_point, 0);\n-  movptr(fp_reg, last_java_fp_offset); \/\/ restore fp_reg\n-  reset_last_Java_frame(true);\n-  JFR_ONLY(movptr(last_sender_Java_fp_offset, NULL_WORD);)\n-}\n-\n-void InterpreterMacroAssembler::call_VM_with_sender_Java_fp_entry(Register fp_reg, Register tmp, address entry_point, bool store_bcp \/* true *\/) {\n-  Label C, E;\n-  call(C, relocInfo::none);\n-  jmp(E);\n-  bind(C);\n-  call_VM_with_sender_Java_fp(fp_reg, tmp, entry_point, store_bcp);\n-  ret(0);\n-  bind(E);\n-}\n-\n@@ -830,0 +784,1 @@\n+\/\/ Notify JVMTI.\n@@ -973,1 +928,18 @@\n-  \/\/ jvmti support\n+  JFR_ONLY(enter_jfr_critical_section();)\n+\n+  \/\/ The below poll is for the stack watermark barrier. It allows fixing up frames lazily,\n+  \/\/ that would normally not be safe to use. Such bad returns into unsafe territory of\n+  \/\/ the stack, will call InterpreterRuntime::at_unwind.\n+  Label slow_path;\n+  Label fast_path;\n+  safepoint_poll(slow_path, true \/* at_return *\/, false \/* in_nmethod *\/);\n+  jmp(fast_path);\n+  bind(slow_path);\n+  push(state);\n+  set_last_Java_frame(noreg, rbp, (address)pc(), rscratch1);\n+  super_call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind), r15_thread);\n+  reset_last_Java_frame(true);\n+  pop(state);\n+  bind(fast_path);\n+\n+  \/\/ JVMTI support. Make sure the safepoint poll test is issued prior.\n@@ -1006,28 +978,4 @@\n-  \/\/ For asynchronous profiling to work correctly, we must remove the\n-  \/\/ activation frame _before_ we test the method return safepoint poll.\n-  \/\/ This is equivalent to how it is done for compiled frames.\n-  \/\/ Removing an interpreter activation frame from a sampling perspective means\n-  \/\/ updating the frame link (fp). But since we are unwinding the current frame,\n-  \/\/ we must save the current rbp in a temporary register, this_fp, for use\n-  \/\/ as the last java fp should we decide to unwind.\n-  \/\/ The asynchronous profiler will only see the updated rbp, either using the\n-  \/\/ CPU context or by reading the last_sender_Java_fp() field as part of the ljf.\n-  const Register this_fp = rscratch2;\n-  make_sender_fp_current(this_fp, rscratch1);\n-\n-  \/\/ The interpreter frame is now unwound from a sampling perspective,\n-  \/\/ meaning it sees the sender frame as the current frame from this point onwards.\n-\n-  \/\/ The below poll is for the stack watermark barrier. It allows fixing up frames lazily,\n-  \/\/ that would normally not be safe to use. Such bad returns into unsafe territory of\n-  \/\/ the stack, will call InterpreterRuntime::at_unwind.\n-  Label slow_path;\n-  Label fast_path;\n-  safepoint_poll(slow_path, this_fp, true \/* at_return *\/, false \/* in_nmethod *\/);\n-  jmp(fast_path);\n-  bind(slow_path);\n-  push(state);\n-  \/\/ Special call to save also the sender fp (the now updated rbp) and using the temporary this_fp register as the last_java_fp.\n-  call_VM_with_sender_Java_fp_entry(this_fp, rscratch1, CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind));\n-  pop(state);\n-  bind(fast_path);\n+  leave();                           \/\/ remove frame anchor\n+  pop(ret_addr);                     \/\/ get return address\n+  mov(rsp, rbx);                     \/\/ set sp to sender sp\n+  pop_cont_fastpath();\n@@ -1035,3 +983,2 @@\n-  \/\/ Finalize remove activation by getting the return address and the caller sp.\n-  movptr(ret_addr, Address(this_fp, wordSize)); \/\/ return address\n-  movptr(rsp, rbx); \/\/ sender sp\n+  JFR_ONLY(leave_jfr_critical_section();)\n+}\n@@ -1039,1 +986,5 @@\n-  pop_cont_fastpath();\n+#if INCLUDE_JFR\n+void InterpreterMacroAssembler::enter_jfr_critical_section() {\n+  const Address sampling_critical_section(r15_thread, in_bytes(SAMPLING_CRITICAL_SECTION_OFFSET_JFR));\n+  movbool(sampling_critical_section, true);\n+  membar(Assembler::StoreLoad);\n@@ -1042,19 +993,4 @@\n-void InterpreterMacroAssembler::make_sender_fp_current(Register save_this_fp, Register tmp) {\n-  const Register return_addr = save_this_fp;\n-  const Register continuation_return_pc = tmp;\n-  const Register sender_sp = tmp;\n-  movptr(return_addr, Address(rbp, wordSize)); \/\/ return address\n-  \/\/ Load address of ContinuationEntry return pc\n-  lea(continuation_return_pc, ExternalAddress(ContinuationEntry::return_pc_address()));\n-  \/\/ Load the ContinuationEntry return pc\n-  movptr(continuation_return_pc, Address(continuation_return_pc));\n-  Label L_continuation, L_end;\n-  cmpptr(continuation_return_pc, return_addr);\n-  movptr(save_this_fp, rbp); \/\/ Save current fp in temporary register.\n-  jccb(Assembler::equal, L_continuation);\n-  movptr(rbp, Address(rbp, frame::link_offset)); \/\/ Update the frame link.\n-  jmpb(L_end);\n-  bind(L_continuation);\n-  lea(sender_sp, Address(rbp, frame::sender_sp_offset * wordSize));\n-  movptr(rbp, Address(sender_sp, (int)(ContinuationEntry::size()))); \/\/ Update the frame link.\n-  bind(L_end);\n+void InterpreterMacroAssembler::leave_jfr_critical_section() {\n+  const Address sampling_critical_section(r15_thread, in_bytes(SAMPLING_CRITICAL_SECTION_OFFSET_JFR));\n+  membar(Assembler::StoreStore);\n+  movbool(sampling_critical_section, false);\n@@ -1062,0 +998,1 @@\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":35,"deletions":98,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -42,5 +42,0 @@\n-  void call_VM_with_sender_Java_fp_entry(Register fp_reg,\n-                                         Register tmp,\n-                                         address entry_point,\n-                                         bool store_bcp = true);\n-\n@@ -77,5 +72,1 @@\n-    save_bcp(rbp);\n-  }\n-\n-  void save_bcp(Register fp_register) {\n-    movptr(Address(fp_register, frame::interpreter_frame_bcp_offset * wordSize), _bcp_register);\n+    movptr(Address(rbp, frame::interpreter_frame_bcp_offset * wordSize), _bcp_register);\n@@ -212,3 +203,0 @@\n-\n-  void make_sender_fp_current(Register save_this_fp, Register tmp);\n-\n@@ -280,0 +268,3 @@\n+  JFR_ONLY(void enter_jfr_critical_section();)\n+  JFR_ONLY(void leave_jfr_critical_section();)\n+\n@@ -285,5 +276,0 @@\n-  void call_VM_with_sender_Java_fp(Register fp_reg,\n-                                   Register tmp,\n-                                   address entry_point,\n-                                   bool store_bcp);\n-\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":4,"deletions":18,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- private:\n+private:\n@@ -32,1 +32,0 @@\n-  JFR_ONLY(intptr_t* volatile _last_sender_Java_fp;) \/\/ specialized field for when JFR samples an interpreter frame\n@@ -34,1 +33,1 @@\n- public:\n+public:\n@@ -47,1 +46,0 @@\n-    JFR_ONLY(_last_sender_Java_fp = nullptr;)\n@@ -62,1 +60,0 @@\n-    JFR_ONLY(_last_sender_Java_fp = src->_last_sender_Java_fp;)\n@@ -75,1 +72,1 @@\n- public:\n+  static ByteSize last_Java_fp_offset()          { return byte_offset_of(JavaFrameAnchor, _last_Java_fp); }\n@@ -83,6 +80,0 @@\n-  JFR_ONLY(intptr_t* last_sender_Java_fp() const { return _last_sender_Java_fp;})\n-\n-  static ByteSize last_Java_fp_offset()          { return byte_offset_of(JavaFrameAnchor, _last_Java_fp); }\n-\n-  JFR_ONLY(static ByteSize last_sender_Java_fp_offset()   { return byte_offset_of(JavaFrameAnchor, _last_sender_Java_fp); })\n-\n","filename":"src\/hotspot\/cpu\/x86\/javaFrameAnchor_x86.hpp","additions":4,"deletions":13,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2459,4 +2459,0 @@\n-  return safepoint_poll(slow_path, rbp, at_return, in_nmethod);\n-}\n-\n-void MacroAssembler::safepoint_poll(Label& slow_path, Register fp_reg, bool at_return, bool in_nmethod) {\n@@ -2466,1 +2462,1 @@\n-    cmpptr(in_nmethod ? rsp : fp_reg, Address(r15_thread, JavaThread::polling_word_offset()));\n+    cmpptr(in_nmethod ? rsp : rbp, Address(r15_thread, JavaThread::polling_word_offset()));\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -746,2 +746,0 @@\n-  void safepoint_poll(Label& slow_path, Register fp_reg, bool at_return, bool in_nmethod);\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2428,3 +2428,3 @@\n-  \/\/ We need to do a poll test after unwind\n-  \/\/ in case the sampler managed to sample the native frame.\n-  Label L_after_unwind, L_return;\n+  \/\/ We need to do a poll test after unwind in case the sampler\n+  \/\/ managed to sample the native frame after returning to Java.\n+  Label L_return;\n@@ -2433,2 +2433,2 @@\n-  __ testptr(Address(r15_thread, JavaThread::polling_word_offset()), 1);\n-  __ jcc(Assembler::zero, L_return);\n+  __ testb(Address(r15_thread, JavaThread::polling_word_offset()), SafepointMechanism::poll_bit());\n+  __ jccb(Assembler::zero, L_return);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1150,0 +1150,24 @@\n+#if INCLUDE_JFR\n+  __ enter_jfr_critical_section();\n+\n+  \/\/ This poll test is to uphold the invariant that a JFR sampled frame\n+  \/\/ must not return to its caller without a prior safepoint poll check.\n+  \/\/ The earlier poll check in this routine is insufficient for this purpose\n+  \/\/ because the thread has transitioned back to Java.\n+\n+  Label slow_path;\n+  Label fast_path;\n+  __ safepoint_poll(slow_path, true \/* at_return *\/, false \/* in_nmethod *\/);\n+  __ jmp(fast_path);\n+  __ bind(slow_path);\n+  __ push(dtos);\n+  __ push(ltos);\n+  __ set_last_Java_frame(noreg, rbp, (address)__ pc(), rscratch1);\n+  __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind), r15_thread);\n+  __ reset_last_Java_frame(true);\n+  __ pop(ltos);\n+  __ pop(dtos);\n+  __ bind(fast_path);\n+\n+#endif \/\/ INCLUDE_JFR\n+\n@@ -1167,32 +1191,0 @@\n-  \/\/ Remove activation\n-\n-  \/\/ For asynchronous profiling to work correctly, we must remove the\n-  \/\/ activation frame _before_ we test the method return safepoint poll.\n-  \/\/ This is equivalent to how it is done for compiled frames.\n-  \/\/ Removing an interpreter activation frame from a sampling perspective means\n-  \/\/ updating the frame link (fp). But since we are unwinding the current frame,\n-  \/\/ we must save the current rbp in a temporary register, this_fp, for use\n-  \/\/ as the last java fp should we decide to unwind.\n-  \/\/ The asynchronous profiler will only see the updated rfp, either using the\n-  \/\/ CPU context or by reading the last_sender_Java_fp() field as part of the ljf.\n-  const Register this_fp = rscratch2;\n-  __ make_sender_fp_current(this_fp, rscratch1);\n-\n-  \/\/ The interpreter frame is now unwound from a sampling perspective,\n-  \/\/ meaning it sees the sender frame as the current frame from this point onwards.\n-\n-  \/\/ The below poll is for the stack watermark barrier. It allows fixing up frames lazily,\n-  \/\/ that would normally not be safe to use. Such bad returns into unsafe territory of\n-  \/\/ the stack, will call InterpreterRuntime::at_unwind.\n-  Label slow_path;\n-  Label fast_path;\n-  __ safepoint_poll(slow_path, this_fp, true, false);\n-  __ jmp(fast_path);\n-  __ bind(slow_path);\n-  __ push(dtos);\n-  __ push(ltos);\n-  __ call_VM_with_sender_Java_fp_entry(this_fp, rscratch1, CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind), false \/* save_bcp *\/);\n-  __ pop(ltos);\n-  __ pop(dtos);\n-  __ bind(fast_path);\n-\n@@ -1200,2 +1192,9 @@\n-  __ movptr(rdi, Address(this_fp, wordSize)); \/\/ get return address\n-  __ movptr(rsp, Address(this_fp, frame::interpreter_frame_sender_sp_offset* wordSize)); \/\/ get sender sp\n+  __ movptr(t, Address(rbp,\n+                       frame::interpreter_frame_sender_sp_offset *\n+                       wordSize)); \/\/ get sender sp\n+  __ leave();                                \/\/ remove frame anchor\n+  __ pop(rdi);                               \/\/ get return address\n+  __ mov(rsp, t);                            \/\/ set sp to sender sp\n+\n+  JFR_ONLY(__ leave_jfr_critical_section();)\n+\n@@ -1468,1 +1467,0 @@\n-    __ restore_bcp();\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":33,"deletions":35,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -1828,15 +1828,3 @@\n-      \/\/ For asynchronous profiling to work correctly, we must remove the\n-      \/\/ activation frame _before_ we test the method return safepoint poll.\n-      \/\/ This is equivalent to how it is done for compiled frames.\n-      \/\/ Removing an interpreter activation frame from a sampling perspective means\n-      \/\/ updating the frame link (fp). But since we are unwinding the current frame,\n-      \/\/ we must save the current rbp in a temporary register, this_fp, for use\n-      \/\/ as the last java fp should we decide to unwind.\n-      \/\/ The asynchronous profiler will only see the updated rbp, either using the\n-      \/\/ CPU context or by reading the last_sender_Java_fp() field as part of the ljf.\n-      const Register this_fp = rscratch2;\n-      __ make_sender_fp_current(this_fp, rax);\n-\n-      \/\/ The interpreter frame is now unwound from a sampling perspective,\n-      \/\/ meaning it sees the sender frame as the current frame from this point onwards.\n-      __ call_VM_with_sender_Java_fp_entry(this_fp, rax, CAST_FROM_FN_PTR(address, SharedRuntime::OSR_migration_begin));\n+      JFR_ONLY(__ enter_jfr_critical_section();)\n+\n+      call_VM(noreg, CAST_FROM_FN_PTR(address, SharedRuntime::OSR_migration_begin));\n@@ -1851,0 +1839,1 @@\n+      const Register sender_sp = j_rarg1;\n@@ -1852,3 +1841,5 @@\n-      \/\/ pop the rest of the interpreter frame\n-      __ movptr(retaddr, Address(this_fp, frame::return_addr_offset * wordSize)); \/\/ get return address\n-      __ movptr(rsp, Address(this_fp, frame::interpreter_frame_sender_sp_offset* wordSize)); \/\/ get sender sp\n+      \/\/ pop the interpreter frame\n+      __ movptr(sender_sp, Address(rbp, frame::interpreter_frame_sender_sp_offset * wordSize)); \/\/ get sender sp\n+      __ leave();                                \/\/ remove frame anchor\n+      __ pop(retaddr);                           \/\/ get return address\n+      __ mov(rsp, sender_sp);                    \/\/ set sp to sender sp\n@@ -1858,0 +1849,2 @@\n+      JFR_ONLY(__ leave_jfr_critical_section();)\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":11,"deletions":18,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-  intptr_t* volatile _last_Java_fp;\n+  ZeroFrame* volatile _last_Java_fp;\n@@ -53,1 +53,1 @@\n-  void set(intptr_t* sp, address pc, intptr_t* fp) {\n+  void set(intptr_t* sp, address pc, ZeroFrame* fp) {\n@@ -84,1 +84,1 @@\n-  intptr_t* last_Java_fp() const {\n+  ZeroFrame* last_Java_fp() const {\n","filename":"src\/hotspot\/cpu\/zero\/javaFrameAnchor_zero.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,4 +42,0 @@\n-  JFR_ONLY(static ByteSize last_sender_Java_fp_offset() {\n-    return byte_offset_of(JavaThread, _anchor) + JavaFrameAnchor::last_sender_Java_fp_offset();\n-  })\n-\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/javaThread_bsd_aarch64.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,4 +42,0 @@\n-  JFR_ONLY(static ByteSize last_sender_Java_fp_offset() {\n-    return byte_offset_of(JavaThread, _anchor) + JavaFrameAnchor::last_sender_Java_fp_offset();\n-  })\n-\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/javaThread_linux_aarch64.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,4 +40,0 @@\n-  JFR_ONLY(static ByteSize last_sender_Java_fp_offset() {\n-    return byte_offset_of(JavaThread, _anchor) + JavaFrameAnchor::last_sender_Java_fp_offset();\n-  })\n-\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/javaThread_linux_x86.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-    frame_anchor()->set(sp, nullptr, (intptr_t*)fp);\n+    frame_anchor()->set(sp, nullptr, fp);\n@@ -76,1 +76,1 @@\n-    return (ZeroFrame*)(frame_anchor()->last_Java_fp());\n+    return frame_anchor()->last_Java_fp();\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/javaThread_linux_zero.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,4 +41,0 @@\n-  JFR_ONLY(static ByteSize last_sender_Java_fp_offset() {\n-    return byte_offset_of(JavaThread, _anchor) + JavaFrameAnchor::last_sender_Java_fp_offset();\n-  })\n-\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/javaThread_windows_aarch64.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,3 +47,0 @@\n-  JFR_ONLY(static ByteSize last_sender_Java_fp_offset() {\n-    return byte_offset_of(JavaThread, _anchor) + JavaFrameAnchor::last_sender_Java_fp_offset(); })\n-\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/javaThread_windows_x86.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -84,18 +84,0 @@\n-static inline intptr_t* continuation_frame_sender_fp(void* sp) {\n-  assert(sp != nullptr, \"invariant\");\n-  return reinterpret_cast<intptr_t*>(static_cast<address>(sp) + (ContinuationEntry::size()));\n-}\n-\n-static inline address continuation_frame_sender_pc(void* sp) {\n-  assert(sp != nullptr, \"invariant\");\n-  return static_cast<address>(sp) + (ContinuationEntry::size() + wordSize);\n-}\n-\n-static inline void update_continuation_frame_sender_pc(JfrSampleRequest& request) {\n-  request._sample_pc = continuation_frame_sender_pc(request._sample_sp);\n-}\n-\n-static inline void update_continuation_frame_sender_sp(JfrSampleRequest& request) {\n-  request._sample_sp = static_cast<address>(request._sample_sp) + (ContinuationEntry::size() + 2 * wordSize);\n-}\n-\n@@ -149,13 +131,0 @@\n-static void update_continuation_frame_sender(JfrSampleRequest& request, intptr_t* last_fp) {\n-  assert(last_fp != nullptr, \"invariant\");\n-  update_frame_sender_sp(request, last_fp);\n-  update_continuation_frame_sender_pc(request);\n-  update_continuation_frame_sender_sp(request);\n-}\n-\n-static intptr_t* update_continuation_frame_sender(JfrSampleRequest& request) {\n-  update_continuation_frame_sender(request, static_cast<intptr_t*>(request._sample_bcp));\n-  request._sample_bcp = nullptr;\n-  return continuation_frame_sender_fp(request._sample_sp);\n-}\n-\n@@ -165,1 +134,2 @@\n-    return update_continuation_frame_sender(request);\n+    request._sample_pc = nullptr;\n+    return nullptr;\n@@ -180,0 +150,1 @@\n+  assert(jt != nullptr, \"invariant\");\n@@ -214,3 +185,1 @@\n-    if (cb->is_nmethod()) {\n-      return true;\n-    }\n+    return cb->is_nmethod();\n@@ -227,25 +196,0 @@\n-\/\/ We have logically unwound the interpreter frame at the sensitive safepoint poll site,\n-\/\/ by updating the fp link, and the sender frame is represented by sender_Java_fp.\n-\/\/ We need to use sender_Java_fp as the last fp in these contexts, else we would\n-\/\/ re-sample an interpreter frame whose poll return check we are currently processing, causing a race.\n-static inline intptr_t* process_sender_Java_fp(JfrSampleRequest& request, intptr_t* sender_Java_fp, intptr_t* last_fp, JavaThread* jt) {\n-  assert(sender_Java_fp != nullptr, \"invariant\");\n-  assert(last_fp != nullptr, \"invariant\");\n-  assert(in_stack(last_fp, jt), \"invariant\");\n-  assert(jt != nullptr, \"invariant\");\n-  assert(jt->has_last_Java_frame(), \"invariant\");\n-  if (p2i(sender_Java_fp) == 1) {\n-    \/\/ A marker that the fp of the sender is undetermined, which implies\n-    \/\/ the sender is a compiled frame to be used instead.\n-    update_interpreter_frame_sender_pc(request, last_fp); \/\/ pick up return address\n-    update_frame_sender_sp(request, last_fp); \/\/ sender sp\n-    return nullptr;\n-  }\n-  if (JfrThreadLocal::is_vthread(jt)) {\n-    if (is_continuation_frame(frame::interpreter_return_address(last_fp))) {\n-      update_continuation_frame_sender(request, last_fp);\n-    }\n-  }\n-  return sender_Java_fp;\n-}\n-\n@@ -256,1 +200,0 @@\n-\n@@ -267,17 +210,1 @@\n-\n-  intptr_t* last_fp = jt->last_Java_fp();\n-  if (last_fp == nullptr) {\n-    if (is_interpreter(request)) {\n-      intptr_t* unused_sp;\n-      os::fetch_frame_from_context(context.ucontext(), &unused_sp, &last_fp);\n-    }\n-    return build(request, last_fp, jt);\n-  }\n-\n-  \/\/ last fp indicates an interpreter frame. If sender_Java_fp exists,\n-  \/\/ this ljf represents a sensitive method return safepoint poll site in the interpreter.\n-  intptr_t* const sender_Java_fp = jt->sender_Java_fp();\n-  if (sender_Java_fp != nullptr) {\n-    last_fp = process_sender_Java_fp(request, sender_Java_fp, last_fp, jt);\n-  }\n-  return build(request, last_fp, jt);\n+  return build(request, jt->last_Java_fp(), jt);\n@@ -324,0 +251,4 @@\n+  if (tl->in_sampling_critical_section()) {\n+    return set_biased_java_sample(request, tl, jt);\n+  }\n+\n@@ -326,0 +257,1 @@\n+\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrSampleRequest.cpp","additions":10,"deletions":78,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-      if (!method->is_native() && !method->contains(static_cast<address>(request._sample_bcp))) {\n+      if (!method->is_native() &&  !method->contains(static_cast<address>(request._sample_bcp))) {\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampling.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,0 +70,3 @@\n+#define SAMPLING_CRITICAL_SECTION_OFFSET_JFR \\\n+  JfrThreadLocal::sampling_critical_section_offset() + THREAD_LOCAL_OFFSET_JFR\n+\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadExtension.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-  _sample_thread_state(_thread_uninitialized),\n@@ -279,0 +278,4 @@\n+ByteSize JfrThreadLocal::sampling_critical_section_offset() {\n+  return byte_offset_of(JfrThreadLocal, _sampling_critical_section);\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadLocal.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-  JavaThreadState _sample_thread_state;\n@@ -81,0 +80,1 @@\n+  bool _sampling_critical_section;\n@@ -223,8 +223,0 @@\n-  void set_sample_thread_state(JavaThreadState state) {\n-    _sample_thread_state = state;\n-  }\n-\n-  JavaThreadState sample_thread_state() const {\n-    return _sample_thread_state;\n-  }\n-\n@@ -334,0 +326,4 @@\n+  bool in_sampling_critical_section() const {\n+    return _sampling_critical_section;\n+  }\n+\n@@ -363,0 +359,1 @@\n+  static ByteSize sampling_critical_section_offset();\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadLocal.hpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1084,0 +1084,1 @@\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -601,3 +601,0 @@\n-  \/\/ This is used by JFR when sampling interpreter frames.\n-  JFR_ONLY(intptr_t* sender_Java_fp() const      { return _anchor.last_sender_Java_fp(); })\n-\n@@ -605,0 +602,1 @@\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}