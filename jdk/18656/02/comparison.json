{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,2 +104,1 @@\n-            List<DistributionPoint> points =\n-                    ext.getDistributionPoints();\n+            List<DistributionPoint> points = ext.getDistributionPoints();\n@@ -107,0 +106,1 @@\n+            CertStoreException savedCSE = null;\n@@ -109,5 +109,17 @@\n-                DistributionPoint point = t.next();\n-                Collection<X509CRL> crls = getCRLs(selector, certImpl,\n-                    point, reasonsMask, signFlag, prevKey, prevCert, provider,\n-                    certStores, trustAnchors, validity, variant, anchor);\n-                results.addAll(crls);\n+                try {\n+                    DistributionPoint point = t.next();\n+                    Collection<X509CRL> crls = getCRLs(selector, certImpl,\n+                        point, reasonsMask, signFlag, prevKey, prevCert, provider,\n+                        certStores, trustAnchors, validity, variant, anchor);\n+                    results.addAll(crls);\n+                } catch (CertStoreException cse) {\n+                    if (savedCSE == null) {\n+                        savedCSE = cse;\n+                    } else {\n+                        savedCSE.addSuppressed(cse);\n+                    }\n+                }\n+            }\n+            \/\/ only throw CertStoreException if no CRLs are retrieved\n+            if (results.isEmpty() && savedCSE != null) {\n+                throw savedCSE;\n@@ -185,1 +197,5 @@\n-                savedCSE = cse;\n+                if (savedCSE == null) {\n+                    savedCSE = cse;\n+                } else {\n+                    savedCSE.addSuppressed(cse);\n+                }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/DistributionPointFetcher.java","additions":25,"deletions":9,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,231 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.math.BigInteger;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.PublicKey;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.CertPath;\n+import java.security.cert.CertPathValidator;\n+import java.security.cert.CertPathValidatorException;\n+import java.security.cert.CertPathValidatorException.BasicReason;\n+import java.security.cert.PKIXParameters;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.security.cert.X509CRL;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import sun.security.x509.AuthorityKeyIdentifierExtension;\n+import sun.security.x509.CRLDistributionPointsExtension;\n+import sun.security.x509.CRLExtensions;\n+import sun.security.x509.CRLNumberExtension;\n+import sun.security.x509.DistributionPoint;\n+import sun.security.x509.Extension;\n+import sun.security.x509.GeneralName;\n+import sun.security.x509.GeneralNames;\n+import sun.security.x509.KeyIdentifier;\n+import sun.security.x509.URIName;\n+import sun.security.x509.X500Name;\n+import sun.security.x509.X509CRLEntryImpl;\n+import sun.security.x509.X509CRLImpl;\n+import static sun.security.x509.X509CRLImpl.TBSCertList;\n+import sun.security.testlibrary.CertificateBuilder;\n+\n+\/*\n+ * @test\n+ * @bug 8200566\n+ * @summary Check that CRL validation continues to check other CRLs in\n+ *          CRLDP extension after CRL fetching errors and exhibits same\n+ *          behavior (fails because cert is revoked) whether CRL cache is\n+ *          fresh or stale.\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.util\n+ * @library ..\/..\/..\/..\/..\/java\/security\/testlibrary\n+ * @build CertificateBuilder CheckAllCRLs\n+ * @run main\/othervm -Dcom.sun.security.enableCRLDP=true CheckAllCRLs\n+ *\/\n+public class CheckAllCRLs {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        CertificateBuilder cb = new CertificateBuilder();\n+\n+        \/\/ Create CA cert\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\n+        KeyPair rootKeyPair = kpg.genKeyPair();\n+        X509Certificate rootCert = createCert(cb, \"CN=Root CA\",\n+            rootKeyPair, rootKeyPair, null, \"SHA384withRSA\", true, false);\n+\n+        \/\/ Create EE cert. This EE cert will contain a CRL Distribution\n+        \/\/ Points extension with two DistributionPoints - one will be a HTTP\n+        \/\/ URL to a non-existant HTTP server, and the other will be a File\n+        \/\/ URL to a file containing the CRL.\n+        KeyPair eeKeyPair = kpg.genKeyPair();\n+        X509Certificate eeCert1 = createCert(cb, \"CN=End Entity\",\n+            rootKeyPair, eeKeyPair, rootCert, \"SHA384withRSA\", false, true);\n+\n+        \/\/ Create another EE cert. This EE cert is similar in that it contains\n+        \/\/ a CRL Distribution Points extension but with one DistributionPoint\n+        \/\/ containing 2 GeneralName URLs as above.\n+        X509Certificate eeCert2 = createCert(cb, \"CN=End Entity\",\n+            rootKeyPair, eeKeyPair, rootCert, \"SHA384withRSA\", false, false);\n+\n+        \/\/ Create a CRL with no revoked certificates and store it in a file\n+        X509CRL crl = createCRL(new X500Name(\"CN=Root CA\"), rootKeyPair,\n+            \"SHA384withRSA\");\n+        Files.write(Path.of(\"root.crl\"), crl.getEncoded());\n+\n+        \/\/ Validate path containing eeCert1\n+        System.out.println(\"Validating cert with CRLDP containing one \"\n+            + \"DistributionPoint with 2 entries, the first non-existent\");\n+        validatePath(eeCert1, rootCert);\n+\n+        \/\/ Validate path containing eeCert2\n+        System.out.println(\"Validating cert with CRLDP containing two \"\n+            + \"DistributionPoints with 1 entry each, the first non-existent\");\n+        validatePath(eeCert2, rootCert);\n+    }\n+\n+    private static X509Certificate createCert(CertificateBuilder cb,\n+            String subjectDN, KeyPair issuerKeyPair, KeyPair subjectKeyPair,\n+            X509Certificate issuerCert, String sigAlg, boolean isCA,\n+            boolean twoDPs) throws Exception {\n+        cb.setSubjectName(subjectDN);\n+        cb.setPublicKey(subjectKeyPair.getPublic());\n+        cb.setSerialNumber(new BigInteger(\"1\"));\n+\n+        if (isCA) {\n+            \/\/ Make a 3 year validity starting from 60 days ago\n+            long start = System.currentTimeMillis() - TimeUnit.DAYS.toMillis(60);\n+            long end = start + TimeUnit.DAYS.toMillis(1085);\n+            cb.setValidity(new Date(start), new Date(end));\n+            cb.addBasicConstraintsExt(true, true, -1);\n+            cb.addKeyUsageExt(new boolean[]\n+                {false, false, false, false, false, true, true, false, false});\n+        } else {\n+            \/\/ Make a 1 year validity starting from 7 days ago\n+            long start = System.currentTimeMillis() - TimeUnit.DAYS.toMillis(7);\n+            long end = start + TimeUnit.DAYS.toMillis(365);\n+            cb.setValidity(new Date(start), new Date(end));\n+            cb.addAuthorityKeyIdExt(issuerKeyPair.getPublic());\n+            cb.addKeyUsageExt(new boolean[]\n+                {true, false, false, false, false, false, false, false, false});\n+            cb.addExtendedKeyUsageExt(List.of(\"1.3.6.1.5.5.7.3.1\"));\n+            GeneralName first = new GeneralName(new URIName(\n+                    \"http:\/\/127.0.0.1:48180\/crl\/will\/always\/fail\/root.crl\"));\n+            GeneralName second = new GeneralName(new URIName(\"file:.\/root.crl\"));\n+            if (twoDPs) {\n+                GeneralNames gn1 = new GeneralNames().add(first);\n+                DistributionPoint dp1 = new DistributionPoint(gn1, null, null);\n+                GeneralNames gn2 = new GeneralNames().add(second);\n+                DistributionPoint dp2 = new DistributionPoint(gn2, null, null);\n+                cb.addExtension(new CRLDistributionPointsExtension(List.of(dp1, dp2)));\n+            } else {\n+                GeneralNames gn = new GeneralNames().add(first).add(second);\n+                DistributionPoint dp = new DistributionPoint(gn, null, null);\n+                cb.addExtension(new CRLDistributionPointsExtension(List.of(dp)));\n+            }\n+        }\n+        cb.addSubjectKeyIdExt(subjectKeyPair.getPublic());\n+\n+        \/\/ return signed cert\n+        return cb.build(issuerCert, issuerKeyPair.getPrivate(), sigAlg);\n+    }\n+\n+    private static X509CRL createCRL(X500Name caIssuer, KeyPair caKeyPair,\n+            String sigAlg) throws Exception {\n+\n+        CRLExtensions crlExts = new CRLExtensions();\n+\n+        \/\/ add AuthorityKeyIdentifier extension\n+        KeyIdentifier kid = new KeyIdentifier(caKeyPair.getPublic());\n+        Extension ext = new AuthorityKeyIdentifierExtension(kid, null, null);\n+        crlExts.setExtension(ext.getId(),\n+            new AuthorityKeyIdentifierExtension(kid, null, null));\n+\n+        \/\/ add CRLNumber extension\n+        ext = new CRLNumberExtension(1);\n+        crlExts.setExtension(ext.getId(), ext);\n+\n+        \/\/ revoke cert\n+        X509CRLEntryImpl crlEntry =\n+            new X509CRLEntryImpl(new BigInteger(\"1\"), new Date());\n+\n+        \/\/ Create a 1 year validity CRL starting from 7 days ago\n+        long start = System.currentTimeMillis() - TimeUnit.DAYS.toMillis(7);\n+        long end = start + TimeUnit.DAYS.toMillis(365);\n+        TBSCertList tcl = new TBSCertList(caIssuer, new Date(start),\n+            new Date(end), new X509CRLEntryImpl[]{ crlEntry }, crlExts);\n+\n+        \/\/ return signed CRL\n+        return X509CRLImpl.newSigned(tcl, caKeyPair.getPrivate(), sigAlg);\n+    }\n+\n+    private static void validatePath(X509Certificate eeCert,\n+            X509Certificate rootCert) throws Exception {\n+\n+        \/\/ Create certification path and set up PKIXParameters.\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+        CertPath cp = cf.generateCertPath(List.of(eeCert));\n+        PKIXParameters pp =\n+            new PKIXParameters(Set.of(new TrustAnchor(rootCert, null)));\n+        pp.setRevocationEnabled(true);\n+\n+        CertPathValidator cpv = CertPathValidator.getInstance(\"PKIX\");\n+\n+        \/\/ Validate path twice in succession, making sure we get consistent\n+        \/\/ results the second time when the CRL cache is fresh.\n+        System.out.println(\"First time validating path\");\n+        validate(cpv, cp, pp);\n+        System.out.println(\"Second time validating path\");\n+        validate(cpv, cp, pp);\n+\n+        \/\/ CRL lookup cache time is 30s. Sleep for 35 seconds to ensure\n+        \/\/ cache is stale, and validate one more time to ensure we get\n+        \/\/ consistent results.\n+        System.out.println(\"Waiting for CRL cache to be cleared\");\n+        Thread.sleep(30500);\n+\n+        System.out.println(\"Third time validating path\");\n+        validate(cpv, cp, pp);\n+    }\n+\n+    private static void validate(CertPathValidator cpv, CertPath cp,\n+            PKIXParameters pp) throws Exception {\n+\n+        try {\n+            cpv.validate(cp, pp);\n+            throw new Exception(\"Validation passed unexpectedly\");\n+        } catch (CertPathValidatorException cpve) {\n+            if (cpve.getReason() != BasicReason.REVOKED) {\n+                throw new Exception(\"Validation failed with unexpected reason\", cpve);\n+            }\n+            System.out.println(\"Validation failed as expected: \" + cpve);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/cert\/CertPathValidator\/crlDP\/CheckAllCRLs.java","additions":231,"deletions":0,"binary":false,"changes":231,"status":"added"}]}