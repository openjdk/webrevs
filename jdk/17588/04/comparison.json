{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+#include <dirent.h>\n+#include <errno.h>\n@@ -27,0 +29,1 @@\n+#include <sys\/resource.h>\n@@ -30,0 +33,1 @@\n+#include \"log_messages.h\"\n@@ -47,0 +51,99 @@\n+#if defined(_AIX)\n+  \/* AIX does not understand '\/proc\/self' - it requires the real process ID *\/\n+  #define FD_DIR aix_fd_dir\n+  #define DIR DIR64\n+  #define dirent dirent64\n+  #define opendir opendir64\n+  #define readdir readdir64\n+  #define closedir closedir64\n+#elif defined(_ALLBSD_SOURCE)\n+  #define FD_DIR \"\/dev\/fd\"\n+#else\n+  #define FD_DIR \"\/proc\/self\/fd\"\n+#endif\n+\n+\/\/ Closes every file descriptor that is listed as a directory\n+\/\/ entry in \"\/proc\/self\/fd\" (or its equivalent). Standard\n+\/\/ input\/output\/error file descriptors will not be closed\n+\/\/ by this function. This function returns 0 on failure\n+\/\/ and 1 on success.\n+int\n+closeDescriptors(void)\n+{\n+    DIR *dp;\n+    struct dirent *dirp;\n+    \/* leave out standard input\/output\/error descriptors *\/\n+    int from_fd = STDERR_FILENO + 1;\n+\n+    \/* We're trying to close all file descriptors, but opendir() might\n+     * itself be implemented using a file descriptor, and we certainly\n+     * don't want to close that while it's in use.  We assume that if\n+     * opendir() is implemented using a file descriptor, then it uses\n+     * the lowest numbered file descriptor, just like open().  So\n+     * before calling opendir(), we close a couple explicitly, so that\n+     * opendir() can then use these lowest numbered closed file\n+     * descriptors afresh.   *\/\n+\n+    close(from_fd);          \/* for possible use by opendir() *\/\n+    close(from_fd + 1);      \/* another one for good luck *\/\n+    from_fd += 2; \/* leave out the 2 we just closed, which the opendir() may use *\/\n+\n+#if defined(_AIX)\n+    \/* set FD_DIR for AIX which does not understand '\/proc\/self' - it\n+     * requires the real process ID *\/\n+    char aix_fd_dir[32];     \/* the pid has at most 19 digits *\/\n+    snprintf(aix_fd_dir, 32, \"\/proc\/%d\/fd\", getpid());\n+#endif\n+\n+    if ((dp = opendir(FD_DIR)) == NULL) {\n+        LOG_MISC((\"warning: failed to open dir %s while determining\"\n+                  \" file descriptors to close for process %d\", FD_DIR, getpid()));\n+        return 0; \/\/ failure\n+    }\n+\n+    while ((dirp = readdir(dp)) != NULL) {\n+        if (!isdigit(dirp->d_name[0])) {\n+            continue;\n+        }\n+        const long fd = strtol(dirp->d_name, NULL, 10);\n+        if (fd <= INT_MAX && fd >= from_fd) {\n+            (void)close((int)fd);\n+        }\n+    }\n+\n+    (void)closedir(dp);\n+\n+    return 1; \/\/ success\n+}\n+\n+\/\/ Does necessary housekeeping of a forked child process\n+\/\/ (like closing copied file descriptors) before\n+\/\/ execing the child process. This function never returns.\n+void\n+forkedChildProcess(const char *file, char *const argv[])\n+{\n+    \/* Close all file descriptors that have been copied over\n+     * from the parent process due to fork(). *\/\n+    if (closeDescriptors() == 0) { \/* failed,  close the old way *\/\n+        \/* Find max allowed file descriptors for a process\n+         * and assume all were opened for the parent process and\n+         * copied over to this child process. We close them all. *\/\n+        const rlim_t max_fd = sysconf(_SC_OPEN_MAX);\n+        JDI_ASSERT(max_fd != (rlim_t)-1); \/\/ -1 represents error\n+        \/* close(), that we subsequently call, takes only int values *\/\n+        JDI_ASSERT(max_fd <= INT_MAX);\n+        \/* leave out standard input\/output\/error file descriptors *\/\n+        rlim_t i = STDERR_FILENO + 1;\n+        LOG_MISC((\"warning: failed to close file descriptors of\"\n+                  \" child process optimally, falling back to closing\"\n+                  \" %d file descriptors sequentially\", (max_fd - i + 1)));\n+        for (; i < max_fd; i++) {\n+            (void)close(i);\n+        }\n+    }\n+\n+    (void)execvp(file, argv); \/* not expected to return *\/\n+\n+    exit(errno); \/* errno will have been set by the failed execvp *\/\n+}\n+\n@@ -96,14 +199,2 @@\n-        \/* Child process *\/\n-        int i;\n-        long max_fd;\n-\n-        \/* close everything *\/\n-        max_fd = sysconf(_SC_OPEN_MAX);\n-        \/*LINTED*\/\n-        for (i = 3; i < (int)max_fd; i++) {\n-            (void)close(i);\n-        }\n-\n-        (void)execvp(argv[0], argv);\n-\n-        exit(-1);\n+        \/\/ manage the child process\n+        forkedChildProcess(argv[0], argv);\n@@ -111,0 +202,2 @@\n+    \/\/ call to forkedChildProcess(...) will never return for a forked process\n+    JDI_ASSERT(pid != 0);\n","filename":"src\/jdk.jdwp.agent\/unix\/native\/libjdwp\/exec_md.c","additions":108,"deletions":15,"binary":false,"changes":123,"status":"modified"}]}