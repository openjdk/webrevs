{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+#include <dirent.h>\n+#include <errno.h>\n@@ -27,0 +29,1 @@\n+#include <sys\/resource.h>\n@@ -47,0 +50,93 @@\n+int\n+isAsciiDigit(char c)\n+{\n+  return c >= '0' && c <= '9';\n+}\n+\n+#if defined(_AIX)\n+  \/* AIX does not understand '\/proc\/self' - it requires the real process ID *\/\n+  #define FD_DIR aix_fd_dir\n+  #define DIR DIR64\n+  #define dirent dirent64\n+  #define opendir opendir64\n+  #define readdir readdir64\n+  #define closedir closedir64\n+#elif defined(_ALLBSD_SOURCE)\n+  #define FD_DIR \"\/dev\/fd\"\n+#else\n+  #define FD_DIR \"\/proc\/self\/fd\"\n+#endif\n+\n+\/\/ closes every file descriptor that is listed as a directory\n+\/\/ entry in \"\/proc\/self\/fd\" (or its equivalent). standard\n+\/\/ input\/output\/error file descriptors will not be closed\n+\/\/ by this function. this function returns 0 on failure\n+\/\/ and 1 on success\n+int\n+closeDescriptors(void)\n+{\n+    DIR *dp;\n+    struct dirent *dirp;\n+    \/* leave out standard input\/output\/error descriptors *\/\n+    int from_fd = STDERR_FILENO + 1;\n+\n+    \/* We're trying to close all file descriptors, but opendir() might\n+     * itself be implemented using a file descriptor, and we certainly\n+     * don't want to close that while it's in use.  We assume that if\n+     * opendir() is implemented using a file descriptor, then it uses\n+     * the lowest numbered file descriptor, just like open().  So we\n+     * close a couple explicitly, so that opendir() can then use\n+     * these lowest numbered closed file descriptors afresh.   *\/\n+\n+    close(from_fd);          \/* for possible use by opendir() *\/\n+    close(from_fd + 1);      \/* another one for good luck *\/\n+    from_fd += 2; \/* leave out the 2 we just closed, which the opendir() may use *\/\n+\n+#if defined(_AIX)\n+    \/* set FD_DIR for AIX which does not understand '\/proc\/self' - it\n+     * requires the real process ID *\/\n+    char aix_fd_dir[32];     \/* the pid has at most 19 digits *\/\n+    snprintf(aix_fd_dir, 32, \"\/proc\/%d\/fd\", getpid());\n+#endif\n+\n+    if ((dp = opendir(FD_DIR)) == NULL)\n+        return 0; \/\/ failure\n+\n+    while ((dirp = readdir(dp)) != NULL) {\n+        int fd;\n+        if (isAsciiDigit(dirp->d_name[0]) &&\n+            (fd = strtol(dirp->d_name, NULL, 10)) >= from_fd)\n+            close(fd);\n+    }\n+\n+    closedir(dp);\n+\n+    return 1; \/\/ success\n+}\n+\n+\/\/ does necessary housekeeping of a forked child process\n+\/\/ (like closing copied file descriptors) before\n+\/\/ execing the child process. this function never returns\n+void\n+forkedChildProcess(const char *file, char *const argv[])\n+{\n+    \/* close all file descriptors that have been copied over\n+     * from the parent process due to fork() *\/\n+    if (closeDescriptors() == 0) { \/* failed,  close the old way *\/\n+        \/* find max allowed file descriptors for a process\n+         * and assume all were opened for the parent process and\n+         * copied over to this child process. we close them all *\/\n+        const rlim_t max_fd = sysconf(_SC_OPEN_MAX);\n+        JDI_ASSERT(max_fd != (rlim_t)-1);\n+        \/* leave out standard input\/output\/error file descriptors *\/\n+        rlim_t i = STDERR_FILENO + 1;\n+        for (; i < max_fd; i++) {\n+            (void)close(i);\n+        }\n+    }\n+\n+    (void)execvp(file, argv); \/* not expected to return *\/\n+\n+    exit(errno); \/* errno will have been set by the failed execvp *\/\n+}\n+\n@@ -96,14 +192,2 @@\n-        \/* Child process *\/\n-        int i;\n-        long max_fd;\n-\n-        \/* close everything *\/\n-        max_fd = sysconf(_SC_OPEN_MAX);\n-        \/*LINTED*\/\n-        for (i = 3; i < (int)max_fd; i++) {\n-            (void)close(i);\n-        }\n-\n-        (void)execvp(argv[0], argv);\n-\n-        exit(-1);\n+        \/\/ manage the child process\n+        forkedChildProcess(argv[0], argv);\n@@ -111,0 +195,2 @@\n+    \/\/ call to forkedChildProcess(...) will never return for a forked process\n+    JDI_ASSERT(pid != 0);\n","filename":"src\/jdk.jdwp.agent\/unix\/native\/libjdwp\/exec_md.c","additions":101,"deletions":15,"binary":false,"changes":116,"status":"modified"}]}