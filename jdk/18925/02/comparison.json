{"files":[{"patch":"@@ -41,0 +41,1 @@\n+#include \"gc\/shared\/memAllocator.hpp\"\n@@ -1399,0 +1400,1 @@\n+    InternalOOMEMark iom(THREAD);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-  if (!_thread->in_retryable_allocation()) {\n+  if (!_thread->is_in_internal_oome_mark()) {\n@@ -129,1 +129,0 @@\n-\n@@ -135,0 +134,1 @@\n+\n@@ -140,1 +140,1 @@\n-    THROW_OOP_(Universe::out_of_memory_error_retry(), true);\n+    THROW_OOP_(Universe::out_of_memory_error_java_heap_without_backtrace(), true);\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -121,0 +121,33 @@\n+\/\/ Manages a scope where a failed heap allocation results in\n+\/\/ suppression of JVMTI \"resource exhausted\" events and\n+\/\/ throwing a shared, backtrace-less OOME instance.\n+\/\/ Used for OOMEs that will not be propagated to user code.\n+class InternalOOMEMark: public StackObj {\n+ private:\n+  bool _outer;\n+  JavaThread* _thread;\n+\n+ public:\n+  explicit InternalOOMEMark(JavaThread* thread) {\n+    if (thread != nullptr) {\n+      _outer = thread->is_in_internal_oome_mark();\n+      thread->set_is_in_internal_oome_mark(true);\n+      _thread = thread;\n+    } else {\n+      _outer = false;\n+      _thread = nullptr;\n+    }\n+  }\n+\n+  ~InternalOOMEMark() {\n+    if (_thread != nullptr) {\n+      \/\/ Check that only InternalOOMEMark sets\n+      \/\/ JavaThread::_is_in_internal_oome_mark\n+      assert(_thread->is_in_internal_oome_mark(), \"must be\");\n+      _thread->set_is_in_internal_oome_mark(_outer);\n+    }\n+  }\n+\n+  JavaThread* thread() const  { return _thread; }\n+};\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.hpp","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/memAllocator.hpp\"\n@@ -95,1 +96,1 @@\n-\/\/ If there is a pending nonasync exception upon closing the scope and the runtime\n+\/\/ If there is a pending OutOfMemoryError upon closing the scope and the runtime\n@@ -98,1 +99,1 @@\n-\/\/   1. The pending nonasync exception is cleared\n+\/\/   1. The pending OutOfMemoryError is cleared\n@@ -100,2 +101,1 @@\n-\/\/   3. Checks that an OutOfMemoryError is Universe::out_of_memory_error_retry().\n-class RetryableAllocationMark: public StackObj {\n+class RetryableAllocationMark {\n@@ -103,1 +103,1 @@\n-  JavaThread* _thread;\n+   InternalOOMEMark _iom;\n@@ -105,9 +105,1 @@\n-  RetryableAllocationMark(JavaThread* thread, bool activate) {\n-    if (activate) {\n-      assert(!thread->in_retryable_allocation(), \"retryable allocation scope is non-reentrant\");\n-      _thread = thread;\n-      _thread->set_in_retryable_allocation(true);\n-    } else {\n-      _thread = nullptr;\n-    }\n-  }\n+  RetryableAllocationMark(JavaThread* thread, bool activate) : _iom(activate ? thread : nullptr) {}\n@@ -115,3 +107,2 @@\n-    if (_thread != nullptr) {\n-      _thread->set_in_retryable_allocation(false);\n-      JavaThread* THREAD = _thread; \/\/ For exception macros.\n+    JavaThread* THREAD = _iom.thread(); \/\/ For exception macros.\n+    if (THREAD != nullptr) {\n@@ -120,6 +111,3 @@\n-        \/\/ Do not clear probable async exceptions.\n-        CLEAR_PENDING_NONASYNC_EXCEPTION;\n-        oop retry_oome = Universe::out_of_memory_error_retry();\n-        if (ex->is_a(retry_oome->klass()) && retry_oome != ex) {\n-          ResourceMark rm;\n-          fatal(\"Unexpected exception in scope of retryable allocation: \" INTPTR_FORMAT \" of type %s\", p2i(ex), ex->klass()->external_name());\n+        THREAD->set_vm_result(nullptr);\n+        if (ex->is_a(vmClasses::OutOfMemoryError_klass())) {\n+          CLEAR_PENDING_EXCEPTION;\n@@ -127,1 +115,0 @@\n-        _thread->set_vm_result(nullptr);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":11,"deletions":24,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -138,1 +138,0 @@\n-                           _oom_retry,\n@@ -658,0 +657,4 @@\n+oop Universe::out_of_memory_error_java_heap_without_backtrace() {\n+  return out_of_memory_errors()->obj_at(_oom_java_heap);\n+}\n+\n@@ -682,3 +685,0 @@\n-\/\/ Throw default _out_of_memory_error_retry object as it will never propagate out of the VM\n-oop Universe::out_of_memory_error_retry()              { return out_of_memory_errors()->obj_at(_oom_retry);  }\n-\n@@ -788,3 +788,0 @@\n-  msg = java_lang_String::create_from_str(\"Java heap space: failed retryable allocation\", CHECK);\n-  java_lang_Throwable::set_message(oom_array->obj_at(_oom_retry), msg());\n-\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -275,0 +275,1 @@\n+  static oop out_of_memory_error_java_heap_without_backtrace();\n@@ -282,2 +283,0 @@\n-  \/\/ Throw default _out_of_memory_error_retry object as it will never propagate out of the VM\n-  static oop out_of_memory_error_retry();\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -876,1 +876,1 @@\n-    if (!THREAD->in_retryable_allocation()) {\n+    if (!THREAD->is_in_internal_oome_mark()) {\n@@ -881,1 +881,1 @@\n-      THROW_OOP(Universe::out_of_memory_error_retry());\n+      THROW_OOP(Universe::out_of_memory_error_java_heap_without_backtrace());\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"gc\/shared\/memAllocator.hpp\"\n@@ -1253,0 +1254,1 @@\n+        InternalOOMEMark iom(THREAD);\n@@ -1267,0 +1269,1 @@\n+      InternalOOMEMark iom(THREAD);\n@@ -1270,0 +1273,1 @@\n+      InternalOOMEMark iom(THREAD);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -458,0 +458,1 @@\n+  _is_in_internal_oome_mark(false),\n@@ -462,1 +463,0 @@\n-  _in_retryable_allocation(false),\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+class InternalOOMEMark;\n@@ -337,0 +338,2 @@\n+  \/\/ In scope of an InternalOOMEMark?\n+  bool _is_in_internal_oome_mark;\n@@ -352,4 +355,0 @@\n-  \/\/ True if in a runtime call from compiled code that will deoptimize\n-  \/\/ and re-execute a failed heap allocation in the interpreter.\n-  bool      _in_retryable_allocation;\n-\n@@ -717,0 +716,4 @@\n+  \/\/ Is thread in scope of an InternalOOMEMark?\n+  bool is_in_internal_oome_mark() const          { return _is_in_internal_oome_mark; }\n+  void set_is_in_internal_oome_mark(bool b)      { _is_in_internal_oome_mark = b;    }\n+\n@@ -726,3 +729,0 @@\n-  virtual bool in_retryable_allocation() const    { return _in_retryable_allocation; }\n-  void set_in_retryable_allocation(bool b)        { _in_retryable_allocation = b; }\n-\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -213,8 +213,0 @@\n-  \/\/ Determines if a heap allocation failure will be retried\n-  \/\/ (e.g., by deoptimizing and re-executing in the interpreter).\n-  \/\/ In this case, the failed allocation must raise\n-  \/\/ Universe::out_of_memory_error_retry() and omit side effects\n-  \/\/ such as JVMTI events and handling -XX:+HeapDumpOnOutOfMemoryError\n-  \/\/ and -XX:OnOutOfMemoryError.\n-  virtual bool in_retryable_allocation() const { return false; }\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"}]}