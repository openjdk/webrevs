{"files":[{"patch":"@@ -41,0 +41,1 @@\n+#include \"gc\/shared\/memAllocator.hpp\"\n@@ -1399,0 +1400,1 @@\n+    SandboxedOOMEMark som(THREAD);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -126,3 +126,2 @@\n-  if (!_thread->in_retryable_allocation()) {\n-    \/\/ -XX:+HeapDumpOnOutOfMemoryError and -XX:OnOutOfMemoryError support\n-    report_java_out_of_memory(message);\n+  \/\/ -XX:+HeapDumpOnOutOfMemoryError and -XX:OnOutOfMemoryError support\n+  report_java_out_of_memory(message);\n@@ -130,0 +129,1 @@\n+  if (!_thread->in_sandboxed_oome_mark()) {\n@@ -135,0 +135,1 @@\n+\n@@ -140,1 +141,1 @@\n-    THROW_OOP_(Universe::out_of_memory_error_retry(), true);\n+    THROW_OOP_(Universe::out_of_memory_error_java_heap(\/* omit_backtrace*\/ true), true);\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -121,0 +121,34 @@\n+\/\/ Manages a scope where a failed heap allocation results in\n+\/\/ suppression of JVMTI \"resource exhausted\" events and\n+\/\/ throwing a shared, backtrace-less OOME instance.\n+\/\/ Used for OOMEs that will not be propagated to user code.\n+class SandboxedOOMEMark: public StackObj {\n+ private:\n+  bool _outer;\n+  JavaThread* _thread;\n+\n+ public:\n+  SandboxedOOMEMark(JavaThread* thread) {\n+    if (thread != nullptr) {\n+      _outer = thread->in_sandboxed_oome_mark();\n+      thread->set_in_sandboxed_oome_mark(true);\n+      _thread = thread;\n+    } else {\n+      _outer = false;\n+      _thread = nullptr;\n+    }\n+  }\n+\n+  ~SandboxedOOMEMark() {\n+    if (_thread != nullptr) {\n+      \/\/ Check that only SandboxedOOMEMark sets\n+      \/\/ JavaThread::_in_sandboxed_oome_mark\n+      assert(_thread->in_sandboxed_oome_mark(), \"must be\");\n+      _thread->set_in_sandboxed_oome_mark(_outer);\n+    }\n+  }\n+\n+  \/\/ Returns nullptr iff `activate` was false in the constructor.\n+  JavaThread* thread() const  { return _thread; }\n+};\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.hpp","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/memAllocator.hpp\"\n@@ -95,1 +96,1 @@\n-\/\/ If there is a pending nonasync exception upon closing the scope and the runtime\n+\/\/ If there is a pending OutOfMemoryError upon closing the scope and the runtime\n@@ -98,1 +99,1 @@\n-\/\/   1. The pending nonasync exception is cleared\n+\/\/   1. The pending OutOfMemoryError is cleared\n@@ -100,2 +101,1 @@\n-\/\/   3. Checks that an OutOfMemoryError is Universe::out_of_memory_error_retry().\n-class RetryableAllocationMark: public StackObj {\n+class RetryableAllocationMark {\n@@ -103,1 +103,1 @@\n-  JavaThread* _thread;\n+   SandboxedOOMEMark _som;\n@@ -105,9 +105,1 @@\n-  RetryableAllocationMark(JavaThread* thread, bool activate) {\n-    if (activate) {\n-      assert(!thread->in_retryable_allocation(), \"retryable allocation scope is non-reentrant\");\n-      _thread = thread;\n-      _thread->set_in_retryable_allocation(true);\n-    } else {\n-      _thread = nullptr;\n-    }\n-  }\n+  RetryableAllocationMark(JavaThread* thread, bool activate) : _som(activate ? thread : nullptr) {}\n@@ -115,3 +107,2 @@\n-    if (_thread != nullptr) {\n-      _thread->set_in_retryable_allocation(false);\n-      JavaThread* THREAD = _thread; \/\/ For exception macros.\n+    JavaThread* THREAD = _som.thread();\n+    if (THREAD != nullptr) {\n@@ -120,6 +111,3 @@\n-        \/\/ Do not clear probable async exceptions.\n-        CLEAR_PENDING_NONASYNC_EXCEPTION;\n-        oop retry_oome = Universe::out_of_memory_error_retry();\n-        if (ex->is_a(retry_oome->klass()) && retry_oome != ex) {\n-          ResourceMark rm;\n-          fatal(\"Unexpected exception in scope of retryable allocation: \" INTPTR_FORMAT \" of type %s\", p2i(ex), ex->klass()->external_name());\n+        THREAD->set_vm_result(nullptr);\n+        if (ex->is_a(vmClasses::OutOfMemoryError_klass())) {\n+          CLEAR_PENDING_EXCEPTION;\n@@ -127,1 +115,0 @@\n-        _thread->set_vm_result(nullptr);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":11,"deletions":24,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -138,1 +138,0 @@\n-                           _oom_retry,\n@@ -654,2 +653,6 @@\n-oop Universe::out_of_memory_error_java_heap() {\n-  return gen_out_of_memory_error(out_of_memory_errors()->obj_at(_oom_java_heap));\n+oop Universe::out_of_memory_error_java_heap(bool omit_backtrace) {\n+  oop oome = out_of_memory_errors()->obj_at(_oom_java_heap);\n+  if (!omit_backtrace) {\n+    oome = gen_out_of_memory_error(oome);\n+  }\n+  return oome;\n@@ -682,3 +685,0 @@\n-\/\/ Throw default _out_of_memory_error_retry object as it will never propagate out of the VM\n-oop Universe::out_of_memory_error_retry()              { return out_of_memory_errors()->obj_at(_oom_retry);  }\n-\n@@ -788,3 +788,0 @@\n-  msg = java_lang_String::create_from_str(\"Java heap space: failed retryable allocation\", CHECK);\n-  java_lang_Throwable::set_message(oom_array->obj_at(_oom_retry), msg());\n-\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -274,1 +274,1 @@\n-  static oop out_of_memory_error_java_heap();\n+  static oop out_of_memory_error_java_heap(bool omit_backtrace=false);\n@@ -282,2 +282,0 @@\n-  \/\/ Throw default _out_of_memory_error_retry object as it will never propagate out of the VM\n-  static oop out_of_memory_error_retry();\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -876,2 +876,2 @@\n-    if (!THREAD->in_retryable_allocation()) {\n-      report_java_out_of_memory(\"Requested array size exceeds VM limit\");\n+    report_java_out_of_memory(\"Requested array size exceeds VM limit\");\n+    if (!THREAD->in_sandboxed_oome_mark()) {\n@@ -881,1 +881,1 @@\n-      THROW_OOP(Universe::out_of_memory_error_retry());\n+      THROW_OOP(Universe::out_of_memory_error_java_heap(\/* omit_backtrace*\/ true));\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"gc\/shared\/memAllocator.hpp\"\n@@ -1253,0 +1254,1 @@\n+        SandboxedOOMEMark som(THREAD);\n@@ -1267,0 +1269,1 @@\n+      SandboxedOOMEMark som(THREAD);\n@@ -1270,0 +1273,1 @@\n+      SandboxedOOMEMark som(THREAD);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -458,0 +458,1 @@\n+  _in_sandboxed_oome_mark(false),\n@@ -462,1 +463,0 @@\n-  _in_retryable_allocation(false),\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+class SandboxedOOMEMark;\n@@ -337,0 +338,2 @@\n+  \/\/ In scope of a SandboxedOOMEMark?\n+  bool _in_sandboxed_oome_mark;\n@@ -352,4 +355,0 @@\n-  \/\/ True if in a runtime call from compiled code that will deoptimize\n-  \/\/ and re-execute a failed heap allocation in the interpreter.\n-  bool      _in_retryable_allocation;\n-\n@@ -717,0 +716,3 @@\n+  bool in_sandboxed_oome_mark() const            { return _in_sandboxed_oome_mark; }\n+  void set_in_sandboxed_oome_mark(bool b)        { _in_sandboxed_oome_mark = b;    }\n+\n@@ -726,3 +728,0 @@\n-  virtual bool in_retryable_allocation() const    { return _in_retryable_allocation; }\n-  void set_in_retryable_allocation(bool b)        { _in_retryable_allocation = b; }\n-\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -213,8 +213,0 @@\n-  \/\/ Determines if a heap allocation failure will be retried\n-  \/\/ (e.g., by deoptimizing and re-executing in the interpreter).\n-  \/\/ In this case, the failed allocation must raise\n-  \/\/ Universe::out_of_memory_error_retry() and omit side effects\n-  \/\/ such as JVMTI events and handling -XX:+HeapDumpOnOutOfMemoryError\n-  \/\/ and -XX:OnOutOfMemoryError.\n-  virtual bool in_retryable_allocation() const { return false; }\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"}]}