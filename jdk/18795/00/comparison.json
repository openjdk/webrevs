{"files":[{"patch":"@@ -101,0 +101,1 @@\n+      _cl->dump_bfs(100, _cl_exit, \"c-\");\n@@ -496,0 +497,10 @@\n+  \/\/ If two invariants have the same summands but in different orders, we end up with\n+  \/\/ different _invar nodes. Canonicalize by sorting the summands and thus reordering\n+  \/\/ the sum.\n+  Node* new_invar = sort_sum(_invar);\n+#ifdef ASSERT\n+  \/\/ We are changing the invar, and the debug info may no longer be accurate.\n+  if (new_invar != _invar) { _debug_invar = NodeSentinel; }\n+#endif\n+  _invar = new_invar;\n+\n@@ -515,0 +526,96 @@\n+\/\/ Summand of a add\/sub sum. Used to sort all summands.\n+class Summand {\n+private:\n+  Node* _node;\n+  bool _negate;\n+\n+public:\n+  Summand(Node* node, bool negate) : _node(node), _negate(negate) {};\n+  Summand() : Summand(nullptr, false) {};\n+  static Summand positive(Node* node) { return Summand(node, false); }\n+\n+  Node* node() const { return _node; }\n+  bool negate() const { return _negate; }\n+\n+  \/\/ Compare by negate, and by idx. Used to sort summands.\n+  static int cmp(Summand* s1, Summand* s2) {\n+    if (s1->negate() != s2->negate()) {\n+      return (s1->negate() ? 1 : 0) - (s2->negate() ? 1 : 0);\n+    }\n+    return s1->node()->_idx - s2->node()->_idx;\n+  }\n+};\n+\n+\/\/ Sometimes, nodes compute the same sum, except that they have different add\/sub orders.\n+\/\/ We decompose a sum into its summands, sort the summands and recombine the sum.\n+\/\/ This allows us to convert different add\/sub orders to a unique node.\n+Node* VPointer::sort_sum(Node* sum) {\n+  if (sum == nullptr) { return nullptr; }\n+\n+  BasicType bt = sum->bottom_type()->basic_type();\n+\n+  ResourceMark rm;\n+  GrowableArray<Summand> summands;\n+  GrowableArray<Summand> traversal;\n+\n+  traversal.append(Summand::positive(sum));\n+  for (int i = 0; i < traversal.length(); i++) {\n+    Node* n           = traversal.at(i).node();\n+    const bool negate = traversal.at(i).negate();\n+\n+    int opc = n->Opcode();\n+    if ((opc == Op_AddL && bt == T_LONG) || (opc == Op_AddI && bt == T_INT)) {\n+      traversal.append(Summand(n->in(1), negate));\n+      traversal.append(Summand(n->in(2), negate));\n+    } else if ((opc == Op_SubL && bt == T_LONG) || (opc == Op_SubI && bt == T_INT)) {\n+      traversal.append(Summand(n->in(1), negate));\n+      traversal.append(Summand(n->in(2), !negate));\n+    } else if (opc == Op_CastLL || opc == Op_CastII) {\n+      traversal.append(Summand(n->in(1), negate));\n+    } else if (opc == Op_ConvI2L) {\n+      \/\/ Sort the int-sum separately. We should not flatten int adds to long adds,\n+      \/\/ so that int-overflows inside the invariant are preserved.\n+      Node* int_sum = sort_sum(n->in(1));\n+      Node* convI2L_int_sum = register_if_new(new ConvI2LNode(int_sum));\n+      summands.append(Summand(convI2L_int_sum, negate));\n+    } else if (((opc == Op_LShiftL && bt == T_LONG) || (opc == Op_LShiftI && bt == T_INT)) &&\n+               n->in(2)->is_ConI() &&\n+               n->in(2)->as_ConI()->get_int() >= 0) {\n+      \/\/ For index computations with types larger than byte, we often scale an inner sum by the type size.\n+      Node* inner_sum = sort_sum(n->in(1));\n+      Node* shifted_inner_sum = register_if_new(LShiftNode::make(inner_sum, n->in(2), bt));\n+      summands.append(Summand(shifted_inner_sum, negate));\n+    } else {\n+      summands.append(Summand(n, negate));\n+    }\n+    if (traversal.length() > 20) {\n+      \/\/ Since we traverse all paths, the number can explode\n+      \/\/ exponentially. We return the unsorted input sum.\n+      return sum;\n+    }\n+  }\n+\n+  \/\/ Sort by negate and idx.\n+  summands.sort(Summand::cmp);\n+\n+  \/\/ Recombine the sum.\n+  Node* new_sum = summands.at(0).node();\n+  if (summands.at(0).negate()) {\n+    Node* zero = phase()->igvn().zerocon(bt);\n+    phase()->set_ctrl(zero, phase()->C->root());\n+    new_sum = register_if_new(SubNode::make(zero, new_sum, bt));\n+  }\n+\n+  for (int i = 1; i < summands.length(); i++) {\n+    Node* n           = summands.at(i).node();\n+    const bool negate = summands.at(i).negate();\n+    if (negate) {\n+      new_sum = register_if_new(SubNode::make(new_sum, n, bt));\n+    } else {\n+      new_sum = register_if_new(AddNode::make(new_sum, n, bt));\n+    }\n+  }\n+\n+  return new_sum;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":107,"deletions":0,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -726,0 +726,3 @@\n+  Node* convI2L(Node* n);\n+  Node* sort_sum(Node* sum);\n+\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,952 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Utils;\n+import jdk.internal.misc.Unsafe;\n+import java.lang.reflect.Array;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Random;\n+import java.lang.foreign.*;\n+\n+\/*\n+ * @test\n+ * @bug 8330274\n+ * @summary Test vectorization with various invariants that are equivalent, but not trivially so,\n+ *          i.e. where the invariants have the same summands, but in different order.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestEquivalentInvariants\n+ *\/\n+\n+public class TestEquivalentInvariants {\n+    static int RANGE = 1024*64;\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    \/\/ Inputs\n+    byte[] aB;\n+    byte[] bB;\n+    int[] aI;\n+    int[] bI;\n+    long[] aL;\n+    long[] bL;\n+\n+    \/\/ List of tests\n+    Map<String,TestFunction> tests = new HashMap<String,TestFunction>();\n+\n+    \/\/ List of gold, the results from the first run before compilation\n+    Map<String,Object[]> golds = new HashMap<String,Object[]>();\n+\n+    interface TestFunction {\n+        Object[] run();\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework framework = new TestFramework(TestEquivalentInvariants.class);\n+        framework.addFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\");\n+        framework.start();\n+    }\n+\n+    public TestEquivalentInvariants() {\n+        \/\/ Generate input once\n+        aB = generateB();\n+        bB = generateB();\n+        aI = generateI();\n+        bI = generateI();\n+        aL = generateL();\n+        bL = generateL();\n+\n+        \/\/ Add all tests to list\n+        tests.put(\"testArrayBB\", () -> {\n+          return testArrayBB(aB.clone(), bB.clone());\n+        });\n+        tests.put(\"testArrayBBInvar3\", () -> {\n+          return testArrayBBInvar3(aB.clone(), bB.clone(), 0, 0, 0);\n+        });\n+        tests.put(\"testMemorySegmentB\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aB.clone());\n+          return testMemorySegmentB(data);\n+        });\n+        tests.put(\"testMemorySegmentBInvarI\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aB.clone());\n+          return testMemorySegmentBInvarI(data, 101, RANGE-200);\n+        });\n+        tests.put(\"testMemorySegmentBInvarL\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aB.clone());\n+          return testMemorySegmentBInvarL(data, 101, RANGE-200);\n+        });\n+        tests.put(\"testMemorySegmentBInvarIAdr\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aB.clone());\n+          return testMemorySegmentBInvarIAdr(data, 101, RANGE-200);\n+        });\n+        tests.put(\"testMemorySegmentBInvarLAdr\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aB.clone());\n+          return testMemorySegmentBInvarLAdr(data, 101, RANGE-200);\n+        });\n+        tests.put(\"testMemorySegmentBInvarI3a\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aB.clone());\n+          return testMemorySegmentBInvarI3a(data, 1, 2, 3, RANGE-200);\n+        });\n+        tests.put(\"testMemorySegmentBInvarI3b\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aB.clone());\n+          return testMemorySegmentBInvarI3b(data, 1, 2, 3, RANGE-200);\n+        });\n+        tests.put(\"testMemorySegmentBInvarI3c\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aB.clone());\n+          return testMemorySegmentBInvarI3c(data, 1, 2, 3, RANGE-200);\n+        });\n+        tests.put(\"testMemorySegmentBInvarI3d\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aB.clone());\n+          return testMemorySegmentBInvarI3d(data, 1, 2, 3, RANGE-200);\n+        });\n+        tests.put(\"testMemorySegmentBInvarI3e\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aB.clone());\n+          return testMemorySegmentBInvarI3e(data, 1, 2, 3, RANGE-200);\n+        });\n+        tests.put(\"testMemorySegmentBInvarI3f\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aB.clone());\n+          return testMemorySegmentBInvarI3f(data, 1, 2, 3, RANGE-200);\n+        });\n+        tests.put(\"testMemorySegmentBInvarL3g\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aB.clone());\n+          return testMemorySegmentBInvarL3g(data, 1, 2, 3, RANGE-200);\n+        });\n+        tests.put(\"testMemorySegmentBInvarL3h\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aB.clone());\n+          return testMemorySegmentBInvarL3h(data, -1, -2, -3, RANGE-200);\n+        });\n+        tests.put(\"testMemorySegmentBInvarL3k\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aB.clone());\n+          return testMemorySegmentBInvarL3k(data, 1, 2, 3, RANGE-200);\n+        });\n+        tests.put(\"testMemorySegmentIInvarL3a\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aI.clone());\n+          return testMemorySegmentIInvarL3a(data, 1, 2, 3, RANGE-200);\n+        });\n+        tests.put(\"testMemorySegmentIInvarL3b\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aI.clone());\n+          return testMemorySegmentIInvarL3b(data, -1, -2, -3, RANGE-200);\n+        });\n+        tests.put(\"testMemorySegmentIInvarL3c\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aI.clone());\n+          return testMemorySegmentIInvarL3c(data, 1, 2, 3, RANGE-200);\n+        });\n+        tests.put(\"testMemorySegmentIInvarL3d\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aI.clone());\n+          return testMemorySegmentIInvarL3d(data, 1, 2, 3, RANGE-200);\n+        });\n+        tests.put(\"testMemorySegmentIInvarL3d2\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aI.clone());\n+          return testMemorySegmentIInvarL3d2(data, 1, 2, 3, RANGE-200);\n+        });\n+        tests.put(\"testMemorySegmentIInvarL3d3\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aI.clone());\n+          return testMemorySegmentIInvarL3d3(data, RANGE-200);\n+        });\n+        tests.put(\"testMemorySegmentIInvarL3e\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aI.clone());\n+          return testMemorySegmentIInvarL3e(data, 1, 2, 3, RANGE-200);\n+        });\n+        tests.put(\"testMemorySegmentIInvarL3f\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aI.clone());\n+          return testMemorySegmentIInvarL3f(data, 1, 2, 3, RANGE-200);\n+        });\n+        tests.put(\"testMemorySegmentLInvarL3a\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aL.clone());\n+          return testMemorySegmentLInvarL3a(data, 1, 2, 3, RANGE-200);\n+        });\n+        tests.put(\"testMemorySegmentLInvarL3b\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aL.clone());\n+          return testMemorySegmentLInvarL3b(data, -1, -2, -3, RANGE-200);\n+        });\n+        tests.put(\"testMemorySegmentLInvarL3c\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aL.clone());\n+          return testMemorySegmentLInvarL3c(data, 1, 2, 3, RANGE-200);\n+        });\n+        tests.put(\"testMemorySegmentLInvarL3d\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aL.clone());\n+          return testMemorySegmentLInvarL3d(data, 1, 2, 3, RANGE-200);\n+        });\n+        tests.put(\"testMemorySegmentLInvarL3d2\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aL.clone());\n+          return testMemorySegmentLInvarL3d2(data, 1, 2, 3, RANGE-200);\n+        });\n+        tests.put(\"testMemorySegmentLInvarL3d3\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aL.clone());\n+          return testMemorySegmentLInvarL3d3(data, RANGE-200);\n+        });\n+        tests.put(\"testMemorySegmentLInvarL3e\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aL.clone());\n+          return testMemorySegmentLInvarL3e(data, 1, 2, 3, RANGE-200);\n+        });\n+        tests.put(\"testMemorySegmentLInvarL3f\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aL.clone());\n+          return testMemorySegmentLInvarL3f(data, 1, 2, 3, RANGE-200);\n+        });\n+        tests.put(\"testLargeInvariantSum\", () -> {\n+          return testLargeInvariantSum(aB.clone(), 0, 0, 0, RANGE-200);\n+        });\n+\n+        \/\/ Compute gold value for all test methods before compilation\n+        for (Map.Entry<String,TestFunction> entry : tests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            Object[] gold = test.run();\n+            golds.put(name, gold);\n+        }\n+    }\n+\n+    @Warmup(100)\n+    @Run(test = {\"testArrayBB\",\n+                 \"testArrayBBInvar3\",\n+                 \"testMemorySegmentB\",\n+                 \"testMemorySegmentBInvarI\",\n+                 \"testMemorySegmentBInvarL\",\n+                 \"testMemorySegmentBInvarIAdr\",\n+                 \"testMemorySegmentBInvarLAdr\",\n+                 \"testMemorySegmentBInvarI3a\",\n+                 \"testMemorySegmentBInvarI3b\",\n+                 \"testMemorySegmentBInvarI3c\",\n+                 \"testMemorySegmentBInvarI3d\",\n+                 \"testMemorySegmentBInvarI3e\",\n+                 \"testMemorySegmentBInvarI3f\",\n+                 \"testMemorySegmentBInvarL3g\",\n+                 \"testMemorySegmentBInvarL3h\",\n+                 \"testMemorySegmentBInvarL3k\",\n+                 \"testMemorySegmentIInvarL3a\",\n+                 \"testMemorySegmentIInvarL3b\",\n+                 \"testMemorySegmentIInvarL3c\",\n+                 \"testMemorySegmentIInvarL3d\",\n+                 \"testMemorySegmentIInvarL3d2\",\n+                 \"testMemorySegmentIInvarL3d3\",\n+                 \"testMemorySegmentIInvarL3e\",\n+                 \"testMemorySegmentIInvarL3f\",\n+                 \"testMemorySegmentLInvarL3a\",\n+                 \"testMemorySegmentLInvarL3b\",\n+                 \"testMemorySegmentLInvarL3c\",\n+                 \"testMemorySegmentLInvarL3d\",\n+                 \"testMemorySegmentLInvarL3d2\",\n+                 \"testMemorySegmentLInvarL3d3\",\n+                 \"testMemorySegmentLInvarL3e\",\n+                 \"testMemorySegmentLInvarL3f\",\n+                 \"testLargeInvariantSum\"})\n+    public void runTests() {\n+        for (Map.Entry<String,TestFunction> entry : tests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            \/\/ Recall gold value from before compilation\n+            Object[] gold = golds.get(name);\n+            \/\/ Compute new result\n+            Object[] result = test.run();\n+            \/\/ Compare gold and new result\n+            verify(name, gold, result);\n+        }\n+    }\n+\n+    static byte[] generateB() {\n+        byte[] a = new byte[RANGE];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (byte)RANDOM.nextInt();\n+        }\n+        return a;\n+    }\n+\n+    static short[] generateS() {\n+        short[] a = new short[RANGE];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (short)RANDOM.nextInt();\n+        }\n+        return a;\n+    }\n+\n+    static int[] generateI() {\n+        int[] a = new int[RANGE];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = RANDOM.nextInt();\n+        }\n+        return a;\n+    }\n+\n+    static long[] generateL() {\n+        long[] a = new long[RANGE];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = RANDOM.nextLong();\n+        }\n+        return a;\n+    }\n+\n+    static void verify(String name, Object[] gold, Object[] result) {\n+        if (gold.length != result.length) {\n+            throw new RuntimeException(\"verify \" + name + \": not the same number of outputs: gold.length = \" +\n+                                       gold.length + \", result.length = \" + result.length);\n+        }\n+        for (int i = 0; i < gold.length; i++) {\n+            Object g = gold[i];\n+            Object r = result[i];\n+            if (g == r) {\n+                throw new RuntimeException(\"verify \" + name + \": should be two separate objects (with identical content):\" +\n+                                           \" gold[\" + i + \"] == result[\" + i + \"]\");\n+            }\n+\n+            \/\/ Wrap everything in MemorySegments, this allows simple value verification of Array as well as MemorySegment.\n+            MemorySegment mg = null;\n+            MemorySegment mr = null;\n+            if (g.getClass().isArray()) {\n+                if (g.getClass() != r.getClass() || !g.getClass().isArray() || !r.getClass().isArray()) {\n+                    throw new RuntimeException(\"verify \" + name + \": must both be array of same type:\" +\n+                                               \" gold[\" + i + \"].getClass() = \" + g.getClass().getSimpleName() +\n+                                               \" result[\" + i + \"].getClass() = \" + r.getClass().getSimpleName());\n+                }\n+                if (Array.getLength(g) != Array.getLength(r)) {\n+                    throw new RuntimeException(\"verify \" + name + \": arrays must have same length:\" +\n+                                           \" gold[\" + i + \"].length = \" + Array.getLength(g) +\n+                                           \" result[\" + i + \"].length = \" + Array.getLength(r));\n+                }\n+                Class c = g.getClass().getComponentType();\n+                if (c == byte.class) {\n+                    mg = MemorySegment.ofArray((byte[])g);\n+                    mr = MemorySegment.ofArray((byte[])r);\n+                } else if (c == int.class) {\n+                    mg = MemorySegment.ofArray((int[])g);\n+                    mr = MemorySegment.ofArray((int[])r);\n+                } else if (c == long.class) {\n+                    mg = MemorySegment.ofArray((long[])g);\n+                    mr = MemorySegment.ofArray((long[])r);\n+                } else {\n+                    throw new RuntimeException(\"verify \" + name + \": array type not supported for verify:\" +\n+                                           \" gold[\" + i + \"].getClass() = \" + g.getClass().getSimpleName() +\n+                                           \" result[\" + i + \"].getClass() = \" + r.getClass().getSimpleName());\n+                }\n+            } else if (g instanceof MemorySegment) {\n+                mg = (MemorySegment)g;\n+                if (!(r instanceof MemorySegment)) {\n+                    throw new RuntimeException(\"verify \" + name + \": was not both MemorySegment:\" +\n+                                           \" gold[\" + i + \"].getClass() = \" + g.getClass().getSimpleName() +\n+                                           \" result[\" + i + \"].getClass() = \" + r.getClass().getSimpleName());\n+                }\n+                mr = (MemorySegment)r;\n+            }\n+\n+            if (mg.byteSize() != mr.byteSize()) {\n+                throw new RuntimeException(\"verify \" + name + \": memory segment must have same length:\" +\n+                                       \" gold[\" + i + \"].length = \" + mg.byteSize() +\n+                                       \" result[\" + i + \"].length = \" + mr.byteSize());\n+            }\n+            verifyMS(name, i, mg, mr);\n+        }\n+    }\n+\n+    static void verifyMS(String name, int i, MemorySegment g, MemorySegment r) {\n+        for (long j = 0; j < g.byteSize(); j++) {\n+            byte vg = g.get(ValueLayout.JAVA_BYTE, j);\n+            byte vr = r.get(ValueLayout.JAVA_BYTE, j);\n+            if (vg != vr) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + vg +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + vr);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testArrayBB(byte[] a, byte[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+            b[i+0] = (byte)(a[i] + 1);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Same int invariant summands, but added in a different order.\n+    static Object[] testArrayBBInvar3(byte[] a, byte[] b, int invar1, int invar2, int invar3) {\n+        int i1 = invar1 + invar2 + invar3;\n+        int i2 = invar2 + invar3 + invar1;\n+        for (int i = 0; i < a.length; i++) {\n+            b[i + i1] = (byte)(a[i + i2] + 1);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Just a simple pattern, without any (explicit) invariant.\n+    static Object[] testMemorySegmentB(MemorySegment m) {\n+        for (int i = 0; i < (int)m.byteSize(); i++) {\n+            byte v = m.get(ValueLayout.JAVA_BYTE, i);\n+            m.set(ValueLayout.JAVA_BYTE, i, (byte)(v + 1));\n+        }\n+        return new Object[]{ m };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Does not vectorize: RangeChecks are not eliminated.\n+    \/\/ Filed RFE: JDK-8327209\n+    static Object[] testMemorySegmentBInvarI(MemorySegment m, int invar, int size) {\n+        for (int i = 0; i < size; i++) {\n+            byte v = m.get(ValueLayout.JAVA_BYTE, i + invar);\n+            m.set(ValueLayout.JAVA_BYTE, i + invar, (byte)(v + 1));\n+        }\n+        return new Object[]{ m };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Has different invariants, before sorting:\n+    \/\/\n+    \/\/   3125 AddL = ((CastLL(Param 11) + ConvI2L(1460  Phi)) + 530  LoadL)\n+    \/\/   3127 AddL = (ConvI2L(1460  Phi) + (11 Param + 530  LoadL))\n+    \/\/\n+    static Object[] testMemorySegmentBInvarL(MemorySegment m, long invar, int size) {\n+        for (int i = 0; i < size; i++) {\n+            byte v = m.get(ValueLayout.JAVA_BYTE, i + invar);\n+            m.set(ValueLayout.JAVA_BYTE, i + invar, (byte)(v + 1));\n+        }\n+        return new Object[]{ m };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Does not vectorize: RangeChecks are not eliminated.\n+    \/\/ Filed RFE: JDK-8327209\n+    static Object[] testMemorySegmentBInvarIAdr(MemorySegment m, int invar, int size) {\n+        for (int i = 0; i < size; i++) {\n+            long adr = i + invar;\n+            byte v = m.get(ValueLayout.JAVA_BYTE, adr);\n+            m.set(ValueLayout.JAVA_BYTE, adr, (byte)(v + 1));\n+        }\n+        return new Object[]{ m };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Since we add \"i + invar\", the invariant is already equivalent without sorting.\n+    static Object[] testMemorySegmentBInvarLAdr(MemorySegment m, long invar, int size) {\n+        for (int i = 0; i < size; i++) {\n+            long adr = i + invar;\n+            byte v = m.get(ValueLayout.JAVA_BYTE, adr);\n+            m.set(ValueLayout.JAVA_BYTE, adr, (byte)(v + 1));\n+        }\n+        return new Object[]{ m };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testMemorySegmentBInvarI3a(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n+        long i1 = (long)(invar1 + invar2 + invar3);\n+        long i2 = (long)(invar2 + invar3 + invar1); \/\/ equivalent\n+        for (int i = 0; i < size; i++) {\n+            byte v = m.get(ValueLayout.JAVA_BYTE, i + i1);\n+            m.set(ValueLayout.JAVA_BYTE, i + i2, (byte)(v + 1));\n+        }\n+        return new Object[]{ m };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testMemorySegmentBInvarI3b(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n+        long i1 = (long)(invar1 + invar2 + invar3);\n+        long i2 = (long)(invar2 + invar3 + invar1); \/\/ equivalent\n+        for (int i = 0; i < size; i+=2) {\n+            byte v0 = m.get(ValueLayout.JAVA_BYTE, i + i1 + 0);\n+            byte v1 = m.get(ValueLayout.JAVA_BYTE, i + i2 + 1);\n+            m.set(ValueLayout.JAVA_BYTE, i + i1 + 0, (byte)(v0 + 1));\n+            m.set(ValueLayout.JAVA_BYTE, i + i2 + 1, (byte)(v1 + 1));\n+        }\n+        return new Object[]{ m };\n+    }\n+\n+    @Test\n+    \/\/ Currently, we don't vectorize. But we may vectorize this, once we implement something like aliasing analysis,\n+    \/\/ though in this particular case we know that the values at runtime will alias.\n+    static Object[] testMemorySegmentBInvarI3c(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n+        long i1 = (long)(invar1 + invar2 + invar3);\n+        long i2 = (long)(invar2 + invar3) + (long)(invar1); \/\/ not equivalent!\n+        for (int i = 0; i < size; i++) {\n+            byte v = m.get(ValueLayout.JAVA_BYTE, i + i1);\n+            m.set(ValueLayout.JAVA_BYTE, i + i2, (byte)(v + 1));\n+        }\n+        return new Object[]{ m };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Should never vectorize, because \"adjacent\" looking loads and stores might not be adjacent if there is an int-overflow!\n+    static Object[] testMemorySegmentBInvarI3d(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n+        long i1 = (long)(invar1 + invar2 + invar3);\n+        long i2 = (long)(invar2 + invar3) + (long)(invar1); \/\/ not equivalent!\n+        \/\/ invar1 = invar2 = minint\n+        \/\/ invar3 = 0\n+        \/\/ i1 = 0           -> int-overflow, before ConvI2L.\n+        \/\/ i2 = 2 * minint  -> first ConvI2L, then no overflow.\n+        for (int i = 0; i < size; i+=2) {\n+            byte v0 = m.get(ValueLayout.JAVA_BYTE, i + i1 + 0);\n+            byte v1 = m.get(ValueLayout.JAVA_BYTE, i + i2 + 1);\n+            m.set(ValueLayout.JAVA_BYTE, i + i1 + 0, (byte)(v0 + 1));\n+            m.set(ValueLayout.JAVA_BYTE, i + i2 + 1, (byte)(v1 + 1));\n+        }\n+        return new Object[]{ m };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testMemorySegmentBInvarI3e(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n+        long i1 = (long)(invar1 + invar2 - invar3);\n+        long i2 = (long)(invar2 - invar3 + invar1); \/\/ equivalent\n+        for (int i = 0; i < size; i++) {\n+            byte v = m.get(ValueLayout.JAVA_BYTE, i + i1);\n+            m.set(ValueLayout.JAVA_BYTE, i + i2, (byte)(v + 1));\n+        }\n+        return new Object[]{ m };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testMemorySegmentBInvarI3f(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n+        long i1 = (long)(invar1 - (invar2 - invar3));\n+        long i2 = (long)(-invar2 + invar3 + invar1); \/\/ equivalent\n+        for (int i = 0; i < size; i++) {\n+            byte v = m.get(ValueLayout.JAVA_BYTE, i + i1);\n+            m.set(ValueLayout.JAVA_BYTE, i + i2, (byte)(v + 1));\n+        }\n+        return new Object[]{ m };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testMemorySegmentBInvarL3g(MemorySegment m, long invar1, long invar2, long invar3, int size) {\n+        long i1 = invar1 - (invar2 - invar3);\n+        long i2 = -invar2 + invar3 + invar1; \/\/ equivalent\n+        for (int i = 0; i < size; i++) {\n+            byte v = m.get(ValueLayout.JAVA_BYTE, i + i1);\n+            m.set(ValueLayout.JAVA_BYTE, i + i2, (byte)(v + 1));\n+        }\n+        return new Object[]{ m };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testMemorySegmentBInvarL3h(MemorySegment m, long invar1, long invar2, long invar3, int size) {\n+        long i1 = -invar1 - invar2 - invar3;\n+        long i2 = -invar2 - invar3 - invar1; \/\/ equivalent\n+        for (int i = 0; i < size; i++) {\n+            byte v = m.get(ValueLayout.JAVA_BYTE, i + i1);\n+            m.set(ValueLayout.JAVA_BYTE, i + i2, (byte)(v + 1));\n+        }\n+        return new Object[]{ m };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testMemorySegmentBInvarL3k(MemorySegment m, long invar1, long invar2, long invar3, int size) {\n+        long i1 = -invar1 + invar2 + invar3;\n+        long i2 = invar2 + invar3 - invar1; \/\/ equivalent\n+        for (int i = 0; i < size; i++) {\n+            byte v = m.get(ValueLayout.JAVA_BYTE, i + i1);\n+            m.set(ValueLayout.JAVA_BYTE, i + i2, (byte)(v + 1));\n+        }\n+        return new Object[]{ m };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VI,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testMemorySegmentIInvarL3a(MemorySegment m, long invar1, long invar2, long invar3, int size) {\n+        long i1 = invar1 + invar2 + invar3;\n+        long i2 = invar2 + invar3 + invar1; \/\/ equivalent\n+        for (int i = 0; i < size; i++) {\n+            int v = m.getAtIndex(ValueLayout.JAVA_INT, i + i1);\n+            m.setAtIndex(ValueLayout.JAVA_INT, i + i2, v + 1);\n+        }\n+        return new Object[]{ m };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VI,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testMemorySegmentIInvarL3b(MemorySegment m, long invar1, long invar2, long invar3, int size) {\n+        long i1 = -invar1 - invar2 - invar3;\n+        long i2 = -invar2 - invar3 - invar1; \/\/ equivalent\n+        for (int i = 0; i < size; i++) {\n+            int v = m.getAtIndex(ValueLayout.JAVA_INT, i + i1);\n+            m.setAtIndex(ValueLayout.JAVA_INT, i + i2, v + 1);\n+        }\n+        return new Object[]{ m };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VI,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testMemorySegmentIInvarL3c(MemorySegment m, long invar1, long invar2, long invar3, int size) {\n+        long i1 = -invar1 + invar2 + invar3;\n+        long i2 = invar2 + invar3 - invar1; \/\/ equivalent\n+        for (int i = 0; i < size; i++) {\n+            int v = m.getAtIndex(ValueLayout.JAVA_INT, i + i1);\n+            m.setAtIndex(ValueLayout.JAVA_INT, i + i2, v + 1);\n+        }\n+        return new Object[]{ m };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Would be nice if it vectorized.\n+    \/\/ Fails because of control flow. Somehow the \"offsetPlain\" check (checks for alignment) is not folded away.\n+    static Object[] testMemorySegmentIInvarL3d(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n+        long i1 = (long)(-invar1 + invar2 + invar3);\n+        long i2 = (long)(invar2 + invar3 - invar1); \/\/ equivalent\n+        for (int i = 0; i < size; i+=2) {\n+            int v0 = m.getAtIndex(ValueLayout.JAVA_INT, i + i1 + 0);\n+            int v1 = m.getAtIndex(ValueLayout.JAVA_INT, i + i2 + 1);\n+            m.setAtIndex(ValueLayout.JAVA_INT, i + i1 + 0, v0 + 1);\n+            m.setAtIndex(ValueLayout.JAVA_INT, i + i2 + 1, v1 + 1);\n+        }\n+        return new Object[]{ m };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Would be nice if it vectorized.\n+    \/\/ Fails because of control flow. Somehow the \"offsetPlain\" check (checks for alignment) is not folded away.\n+    static Object[] testMemorySegmentIInvarL3d2(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n+        long i1 = (long)(-invar1 + invar2 + invar3);\n+        for (int i = 0; i < size; i+=2) {\n+            int v0 = m.getAtIndex(ValueLayout.JAVA_INT, i + i1 + 0);\n+            int v1 = m.getAtIndex(ValueLayout.JAVA_INT, i + i1 + 1);\n+            m.setAtIndex(ValueLayout.JAVA_INT, i + i1 + 0, v0 + 1);\n+            m.setAtIndex(ValueLayout.JAVA_INT, i + i1 + 1, v1 + 1);\n+        }\n+        return new Object[]{ m };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VI,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ But here the \"offsetPlain\" is folded away\n+    static Object[] testMemorySegmentIInvarL3d3(MemorySegment m, int size) {\n+        for (int i = 0; i < size; i+=2) {\n+            int v0 = m.getAtIndex(ValueLayout.JAVA_INT, i + 0);\n+            int v1 = m.getAtIndex(ValueLayout.JAVA_INT, i + 1);\n+            m.setAtIndex(ValueLayout.JAVA_INT, i + 0, v0 + 1);\n+            m.setAtIndex(ValueLayout.JAVA_INT, i + 1, v1 + 1);\n+        }\n+        return new Object[]{ m };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Should never vectorize, since i1 and i2 are not guaranteed to be adjacent\n+    static Object[] testMemorySegmentIInvarL3e(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n+        long i1 = (long)(-invar1 + invar2 + invar3);\n+        long i2 = (long)(invar2 + invar3) - (long)(invar1); \/\/ not equivalent\n+        for (int i = 0; i < size; i+=2) {\n+            int v0 = m.getAtIndex(ValueLayout.JAVA_INT, i + i1 + 0);\n+            int v1 = m.getAtIndex(ValueLayout.JAVA_INT, i + i2 + 1);\n+            m.setAtIndex(ValueLayout.JAVA_INT, i + i1 + 0, v0 + 1);\n+            m.setAtIndex(ValueLayout.JAVA_INT, i + i2 + 1, v1 + 1);\n+        }\n+        return new Object[]{ m };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VI,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testMemorySegmentIInvarL3f(MemorySegment m, long invar1, long invar2, long invar3, int size) {\n+        long i1 = -invar1 + invar2 + invar3;\n+        long i2 = invar2 + invar3 - invar1; \/\/ equivalent\n+        for (int i = 0; i < size; i++) {\n+            \/\/ Scale the index manually\n+            int v = m.get(ValueLayout.JAVA_INT, 4 * (i + i1));\n+            m.set(ValueLayout.JAVA_INT, 4 * (i + i2), v + 1);\n+        }\n+        return new Object[]{ m };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.ADD_VL,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testMemorySegmentLInvarL3a(MemorySegment m, long invar1, long invar2, long invar3, int size) {\n+        long i1 = invar1 + invar2 + invar3;\n+        long i2 = invar2 + invar3 + invar1; \/\/ equivalent\n+        for (int i = 0; i < size; i++) {\n+            long v = m.getAtIndex(ValueLayout.JAVA_LONG, i + i1);\n+            m.setAtIndex(ValueLayout.JAVA_LONG, i + i2, v + 1);\n+        }\n+        return new Object[]{ m };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.ADD_VL,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testMemorySegmentLInvarL3b(MemorySegment m, long invar1, long invar2, long invar3, int size) {\n+        long i1 = -invar1 - invar2 - invar3;\n+        long i2 = -invar2 - invar3 - invar1; \/\/ equivalent\n+        for (int i = 0; i < size; i++) {\n+            long v = m.getAtIndex(ValueLayout.JAVA_LONG, i + i1);\n+            m.setAtIndex(ValueLayout.JAVA_LONG, i + i2, v + 1);\n+        }\n+        return new Object[]{ m };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.ADD_VL,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testMemorySegmentLInvarL3c(MemorySegment m, long invar1, long invar2, long invar3, int size) {\n+        long i1 = -invar1 + invar2 + invar3;\n+        long i2 = invar2 + invar3 - invar1; \/\/ equivalent\n+        for (int i = 0; i < size; i++) {\n+            long v = m.getAtIndex(ValueLayout.JAVA_LONG, i + i1);\n+            m.setAtIndex(ValueLayout.JAVA_LONG, i + i2, v + 1);\n+        }\n+        return new Object[]{ m };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Would be nice if it vectorized.\n+    \/\/ Fails because of control flow. Somehow the \"offsetPlain\" check (checks for alignment) is not folded away.\n+    static Object[] testMemorySegmentLInvarL3d(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n+        long i1 = (long)(-invar1 + invar2 + invar3);\n+        long i2 = (long)(invar2 + invar3 - invar1); \/\/ equivalent\n+        for (int i = 0; i < size; i+=2) {\n+            long v0 = m.getAtIndex(ValueLayout.JAVA_LONG, i + i1 + 0);\n+            long v1 = m.getAtIndex(ValueLayout.JAVA_LONG, i + i2 + 1);\n+            m.setAtIndex(ValueLayout.JAVA_LONG, i + i1 + 0, v0 + 1);\n+            m.setAtIndex(ValueLayout.JAVA_LONG, i + i2 + 1, v1 + 1);\n+        }\n+        return new Object[]{ m };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Would be nice if it vectorized.\n+    \/\/ Fails because of control flow. Somehow the \"offsetPlain\" check (checks for alignment) is not folded away.\n+    static Object[] testMemorySegmentLInvarL3d2(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n+        long i1 = (long)(-invar1 + invar2 + invar3);\n+        for (int i = 0; i < size; i+=2) {\n+            long v0 = m.getAtIndex(ValueLayout.JAVA_LONG, i + i1 + 0);\n+            long v1 = m.getAtIndex(ValueLayout.JAVA_LONG, i + i1 + 1);\n+            m.setAtIndex(ValueLayout.JAVA_LONG, i + i1 + 0, v0 + 1);\n+            m.setAtIndex(ValueLayout.JAVA_LONG, i + i1 + 1, v1 + 1);\n+        }\n+        return new Object[]{ m };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.ADD_VL,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ But here the \"offsetPlain\" is folded away\n+    static Object[] testMemorySegmentLInvarL3d3(MemorySegment m, int size) {\n+        for (int i = 0; i < size; i+=2) {\n+            long v0 = m.getAtIndex(ValueLayout.JAVA_LONG, i + 0);\n+            long v1 = m.getAtIndex(ValueLayout.JAVA_LONG, i + 1);\n+            m.setAtIndex(ValueLayout.JAVA_LONG, i + 0, v0 + 1);\n+            m.setAtIndex(ValueLayout.JAVA_LONG, i + 1, v1 + 1);\n+        }\n+        return new Object[]{ m };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Should never vectorize, since i1 and i2 are not guaranteed to be adjacent\n+    static Object[] testMemorySegmentLInvarL3e(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n+        long i1 = (long)(-invar1 + invar2 + invar3);\n+        long i2 = (long)(invar2 + invar3) - (long)(invar1); \/\/ not equivalent\n+        for (int i = 0; i < size; i+=2) {\n+            long v0 = m.getAtIndex(ValueLayout.JAVA_LONG, i + i1 + 0);\n+            long v1 = m.getAtIndex(ValueLayout.JAVA_LONG, i + i2 + 1);\n+            m.setAtIndex(ValueLayout.JAVA_LONG, i + i1 + 0, v0 + 1);\n+            m.setAtIndex(ValueLayout.JAVA_LONG, i + i2 + 1, v1 + 1);\n+        }\n+        return new Object[]{ m };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.ADD_VL,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testMemorySegmentLInvarL3f(MemorySegment m, long invar1, long invar2, long invar3, int size) {\n+        long i1 = -invar1 + invar2 + invar3;\n+        long i2 = invar2 + invar3 - invar1; \/\/ equivalent\n+        for (int i = 0; i < size; i++) {\n+            \/\/ Scale the index manually\n+            long v = m.get(ValueLayout.JAVA_LONG, 8 * (i + i1));\n+            m.set(ValueLayout.JAVA_LONG, 8 * (i + i2), v + 1);\n+        }\n+        return new Object[]{ m };\n+    }\n+\n+    @Test\n+    \/\/ Traversal through AddI would explode in exponentially many paths, exhausing the node limit.\n+    \/\/ For this, we have a traversal size limit.\n+    static Object[] testLargeInvariantSum(byte[] a, int invar1, int invar2, int invar3, int size) {\n+        int e = invar1;\n+        e = ((e + invar2) + (e + invar3));\n+        e = ((e + invar2) + (e + invar3));\n+        e = ((e + invar2) + (e + invar3));\n+        e = ((e + invar2) + (e + invar3));\n+        e = ((e + invar2) + (e + invar3));\n+        e = ((e + invar2) + (e + invar3));\n+        e = ((e + invar2) + (e + invar3));\n+        e = ((e + invar2) + (e + invar3));\n+        e = ((e + invar2) + (e + invar3));\n+        e = ((e + invar2) + (e + invar3));\n+        e = ((e + invar2) + (e + invar3));\n+        e = ((e + invar2) + (e + invar3));\n+        e = ((e + invar2) + (e + invar3));\n+        e = ((e + invar2) + (e + invar3));\n+        e = ((e + invar2) + (e + invar3));\n+        e = ((e + invar2) + (e + invar3));\n+        e = ((e + invar2) + (e + invar3));\n+        e = ((e + invar2) + (e + invar3));\n+        e = ((e + invar2) + (e + invar3));\n+        e = ((e + invar2) + (e + invar3));\n+        e = ((e + invar2) + (e + invar3));\n+        e = ((e + invar2) + (e + invar3));\n+        e = ((e + invar2) + (e + invar3));\n+        for (int i = 0; i < size; i++) {\n+            a[i + e] += 1;\n+        }\n+        return new Object[]{ a };\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestEquivalentInvariants.java","additions":952,"deletions":0,"binary":false,"changes":952,"status":"added"}]}