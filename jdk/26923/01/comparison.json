{"files":[{"patch":"@@ -78,0 +78,3 @@\n+<li><a href=\"#trailing-return-type-syntax-for-functions\"\n+id=\"toc-trailing-return-type-syntax-for-functions\">Trailing return type\n+syntax for functions<\/a><\/li>\n@@ -722,1 +725,3 @@\n-<li><p>Function return type deduction (<a\n+<\/ul>\n+<p><a name=\"function-return-type-deduction\"><\/a> * Function return type\n+deduction (<a\n@@ -725,2 +730,3 @@\n-statements, and generally relatively little other code.<\/p><\/li>\n-<li><p>Class template argument deduction (<a\n+statements, and generally relatively little other code.<\/p>\n+<ul>\n+<li>Class template argument deduction (<a\n@@ -739,1 +745,1 @@\n-this<\/p><\/li>\n+this<\/li>\n@@ -774,0 +780,38 @@\n+<h3 id=\"trailing-return-type-syntax-for-functions\">Trailing return type\n+syntax for functions<\/h3>\n+<p>A function's return type may be specified after the parameters and\n+qualifiers (<a\n+href=\"http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2008\/n2541.htm\">n2541<\/a>).\n+In such a declaration the normal return type is <code>auto<\/code> and\n+the return type is indicated by <code>-&gt;<\/code> followed by the type.\n+Although both use <code>auto<\/code> in the \"normal\" leading return type\n+position, this differs from <a\n+href=\"#function-return-type-deduction\">function return type\n+deduction<\/a>, in that the return type is explicit rather than deduced,\n+but specified in a trailing position.<\/p>\n+<p>Use of trailing return types is permitted. However, the normal,\n+leading position for the return type is preferred. A trailing return\n+type should only be used where it provides some benefit. Such benefits\n+usually arise because a trailing return type is in a different scope\n+than a leading return type.<\/p>\n+<ul>\n+<li><p>If the function identifier is a nested name specifier, then the\n+trailing return type occurs in the nested scope. This may permit simpler\n+naming in the return type because of the different name lookup\n+context.<\/p><\/li>\n+<li><p>The trailing return type is in the scope of the parameters,\n+making their types accessible via <code>decltype<\/code>. For\n+example<\/p><\/li>\n+<\/ul>\n+<pre><code>template&lt;typename T, typename U&gt; auto add(T t, U u) -&gt; decltype(t + u);<\/code><\/pre>\n+<p>rather than<\/p>\n+<pre><code>template&lt;typename T, typename U&gt; decltype((*(T*)0) + (*(U*)0)) add(T t, U u);<\/code><\/pre>\n+<ul>\n+<li>Complex calculated leading return types may obscure the normal\n+syntactic boundaries, making it more difficult for a reader to find the\n+function name and parameters. This is particularly common in cases where\n+the return type is being used for <a\n+href=\"https:\/\/en.cppreference.com\/w\/cpp\/language\/sfinae\"\n+title=\"Substitution Failure Is Not An Error\">SFINAE<\/a>. A trailing\n+return type may be preferable in such situations.<\/li>\n+<\/ul>\n","filename":"doc\/hotspot-style.html","additions":48,"deletions":4,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -645,0 +645,1 @@\n+<a name=\"function-return-type-deduction\"><\/a>\n@@ -694,0 +695,36 @@\n+### Trailing return type syntax for functions\n+\n+A function's return type may be specified after the parameters and qualifiers\n+([n2541](http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2008\/n2541.htm)).\n+In such a declaration the normal return type is `auto` and the return type is\n+indicated by `->` followed by the type.  Although both use `auto` in the\n+\"normal\" leading return type position, this differs from\n+[function return type deduction](#function-return-type-deduction),\n+in that the return type is explicit rather than deduced, but specified in a\n+trailing position.\n+\n+Use of trailing return types is permitted.  However, the normal, leading\n+position for the return type is preferred. A trailing return type should only\n+be used where it provides some benefit. Such benefits usually arise because a\n+trailing return type is in a different scope than a leading return type.\n+\n+* If the function identifier is a nested name specifier, then the trailing\n+return type occurs in the nested scope. This may permit simpler naming in the\n+return type because of the different name lookup context.\n+\n+* The trailing return type is in the scope of the parameters, making their\n+types accessible via `decltype`. For example\n+```\n+template<typename T, typename U> auto add(T t, U u) -> decltype(t + u);\n+```\n+rather than\n+```\n+template<typename T, typename U> decltype((*(T*)0) + (*(U*)0)) add(T t, U u);\n+```\n+\n+* Complex calculated leading return types may obscure the normal syntactic\n+boundaries, making it more difficult for a reader to find the function name and\n+parameters. This is particularly common in cases where the return type is\n+being used for [SFINAE]. A trailing return type may be preferable in such\n+situations.\n+\n","filename":"doc\/hotspot-style.md","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"}]}