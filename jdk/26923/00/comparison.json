{"files":[{"patch":"@@ -75,0 +75,3 @@\n+<li><a href=\"#trailing-return-type-syntax-for-functions\"\n+id=\"toc-trailing-return-type-syntax-for-functions\">Trailing return type\n+syntax for functions<\/a><\/li>\n@@ -655,1 +658,3 @@\n-<li><p>Function return type deduction (<a\n+<\/ul>\n+<p><a name=\"function-return-type-deduction\"><\/a> * Function return type\n+deduction (<a\n@@ -658,3 +663,3 @@\n-statements, and generally relatively little other code.<\/p><\/li>\n-<li><p>Also see <a href=\"#lambdaexpressions\">lambda\n-expressions<\/a>.<\/p><\/li>\n+statements, and generally relatively little other code.<\/p>\n+<ul>\n+<li>Also see <a href=\"#lambdaexpressions\">lambda expressions<\/a>.<\/li>\n@@ -685,0 +690,38 @@\n+<h3 id=\"trailing-return-type-syntax-for-functions\">Trailing return type\n+syntax for functions<\/h3>\n+<p>A function's return type may be specified after the parameters and\n+qualifiers (<a\n+href=\"http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2008\/n2541.htm\">n2541<\/a>).\n+In such a declaration the normal return type is <code>auto<\/code> and\n+the return type is indicated by <code>-&gt;<\/code> followed by the type.\n+Although both use <code>auto<\/code> in the \"normal\" leading return type\n+position, this differs from <a\n+href=\"#function-return-type-deduction\">function return type\n+deduction<\/a>, in that the return type is explicit rather than deduced,\n+but specified in a trailing position.<\/p>\n+<p>Use of trailing return types is permitted. However, the normal,\n+leading position for the return type is preferred. A trailing return\n+type should only be used where it provides some benefit. Such benefits\n+usually arise because a trailing return type is in a different scope\n+than a leading return type.<\/p>\n+<ul>\n+<li><p>If the function identifier is a nested name specifier, then the\n+trailing return type occurs in the nested scope. This may permit simpler\n+naming in the return type because of the different name lookup\n+context.<\/p><\/li>\n+<li><p>The trailing return type is in the scope of the parameters,\n+making their types accessible via <code>decltype<\/code>. For\n+example<\/p><\/li>\n+<\/ul>\n+<pre><code>template&lt;typename T, typename U&gt; auto add(T t, U u) -&gt; decltype(t + u);<\/code><\/pre>\n+<p>rather than<\/p>\n+<pre><code>template&lt;typename T, typename U&gt; decltype((*(T*)0) + (*(U*)0)) add(T t, U u);<\/code><\/pre>\n+<ul>\n+<li>Complex calculated leading return types may obscure the normal\n+syntactic boundaries, making it more difficult for a reader to find the\n+function name and parameters. This is particularly common in cases where\n+the return type is being used for <a\n+href=\"https:\/\/en.cppreference.com\/w\/cpp\/language\/sfinae\"\n+title=\"Substitution Failure Is Not An Error\">SFINAE<\/a>. A trailing\n+return type may be preferable in such situations.<\/li>\n+<\/ul>\n@@ -1297,2 +1340,0 @@\n-<li><p>Trailing return type syntax for functions (<a\n-href=\"http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2008\/n2541.htm\">n2541<\/a>)<\/p><\/li>\n","filename":"doc\/hotspot-style.html","additions":47,"deletions":6,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -627,0 +627,1 @@\n+<a name=\"function-return-type-deduction\"><\/a>\n@@ -655,0 +656,36 @@\n+### Trailing return type syntax for functions\n+\n+A function's return type may be specified after the parameters and qualifiers\n+([n2541](http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2008\/n2541.htm)).\n+In such a declaration the normal return type is `auto` and the return type is\n+indicated by `->` followed by the type.  Although both use `auto` in the\n+\"normal\" leading return type position, this differs from\n+[function return type deduction](#function-return-type-deduction),\n+in that the return type is explicit rather than deduced, but specified in a\n+trailing position.\n+\n+Use of trailing return types is permitted.  However, the normal, leading\n+position for the return type is preferred. A trailing return type should only\n+be used where it provides some benefit. Such benefits usually arise because a\n+trailing return type is in a different scope than a leading return type.\n+\n+* If the function identifier is a nested name specifier, then the trailing\n+return type occurs in the nested scope. This may permit simpler naming in the\n+return type because of the different name lookup context.\n+\n+* The trailing return type is in the scope of the parameters, making their\n+types accessible via `decltype`. For example\n+```\n+template<typename T, typename U> auto add(T t, U u) -> decltype(t + u);\n+```\n+rather than\n+```\n+template<typename T, typename U> decltype((*(T*)0) + (*(U*)0)) add(T t, U u);\n+```\n+\n+* Complex calculated leading return types may obscure the normal syntactic\n+boundaries, making it more difficult for a reader to find the function name and\n+parameters. This is particularly common in cases where the return type is\n+being used for [SFINAE]. A trailing return type may be preferable in such\n+situations.\n+\n@@ -1294,3 +1331,0 @@\n-* Trailing return type syntax for functions\n-([n2541](http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2008\/n2541.htm))\n-\n","filename":"doc\/hotspot-style.md","additions":37,"deletions":3,"binary":false,"changes":40,"status":"modified"}]}