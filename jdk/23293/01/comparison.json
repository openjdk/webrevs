{"files":[{"patch":"@@ -60,0 +60,1 @@\n+#include \"utilities\/globalCounter.inline.hpp\"\n@@ -944,6 +945,3 @@\n-    \/\/ Note that the counter is not protected by a lock or updated by atomics.\n-    \/\/ That is by design - we trade \"lossy\" counters which are exposed to\n-    \/\/ races during updates for a lower probe effect.\n-    \/\/ This PerfData object can be used in parallel with a safepoint.\n-    \/\/ See the work around in PerfDataManager::destroy().\n-    OM_PERFDATA_OP(FutileWakeups, inc());\n+    \/\/ We are in safepoint safe state, so shutdown can remove the counter\n+    \/\/ under our feet. Make sure we make this access safely.\n+    OM_PERFDATA_SAFE_OP(FutileWakeups, inc());\n@@ -1073,5 +1071,0 @@\n-    \/\/ Note that the counter is not protected by a lock or updated by atomics.\n-    \/\/ That is by design - we trade \"lossy\" counters which are exposed to\n-    \/\/ races during updates for a lower probe effect.\n-    \/\/ This PerfData object can be used in parallel with a safepoint.\n-    \/\/ See the work around in PerfDataManager::destroy().\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -205,4 +205,0 @@\n-  \/\/ Only perform a PerfData operation if the PerfData object has been\n-  \/\/ allocated and if the PerfDataManager has not freed the PerfData\n-  \/\/ objects which can happen at normal VM shutdown.\n-  \/\/\n@@ -211,2 +207,1 @@\n-      if (ObjectMonitor::_sync_ ## f != nullptr &&  \\\n-          PerfDataManager::has_PerfData()) {        \\\n+      if (ObjectMonitor::_sync_ ## f != nullptr) {  \\\n@@ -217,0 +212,14 @@\n+  \/\/ Only perform a PerfData operation if the PerfData object has been\n+  \/\/ allocated and if the PerfDataManager has not freed the PerfData\n+  \/\/ objects which can happen at normal VM shutdown. Additionally, we\n+  \/\/ have to enter the critical section to resolve the deletion races.\n+  #define OM_PERFDATA_SAFE_OP(f, op_str)            \\\n+    do {                                            \\\n+      if (ObjectMonitor::_sync_ ## f != nullptr) {  \\\n+        GlobalCounter::CriticalSection cs(Thread::current()); \\\n+        if (PerfDataManager::has_PerfData()) {      \\\n+          ObjectMonitor::_sync_ ## f->op_str;       \\\n+        }                                           \\\n+      }                                             \\\n+    } while (0)\n+\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"utilities\/globalCounter.inline.hpp\"\n@@ -260,9 +261,7 @@\n-  \/\/ Clear the flag before we free the PerfData counters. Thus begins\n-  \/\/ the race between this thread and another thread that has just\n-  \/\/ queried PerfDataManager::has_PerfData() and gotten back 'true'.\n-  \/\/ The hope is that the other thread will finish its PerfData\n-  \/\/ manipulation before we free the memory. The two alternatives are\n-  \/\/ 1) leak the PerfData memory or 2) do some form of synchronized\n-  \/\/ access or check before every PerfData operation.\n-  _has_PerfData = false;\n-  os::naked_short_sleep(1);  \/\/ 1ms sleep to let other thread(s) run\n+  \/\/ About to delete the counters than might still be accessed by other threads.\n+  \/\/ The shutdown is performed in two stages: a) clear the flag to notify future\n+  \/\/ counter users that we are at shutdown; b) sync up with current users, waiting\n+  \/\/ for them to finish with counters.\n+  \/\/\n+  Atomic::store(&_has_PerfData, false);\n+  GlobalCounter::write_synchronize();\n@@ -295,1 +294,1 @@\n-    _has_PerfData = true;\n+    Atomic::release_store(&_has_PerfData, true);\n","filename":"src\/hotspot\/share\/runtime\/perfData.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -247,0 +248,12 @@\n+ * There are possible shutdown races between counter uses and counter\n+ * destruction code. Normal shutdown happens with taking VM_Exit safepoint\n+ * operation, so in the vast majority of uses this is not an issue. On the\n+ * paths where a concurrent access can still happen when VM is at safepoint,\n+ * use the following pattern to coordinate with shutdown:\n+ *\n+ * {\n+ *   GlobalCounter::CriticalSection cs(Thread::current());\n+ *   if (PerfDataManager::has_PerfData()) {\n+ *     <update-counter>\n+ *   }\n+ * }\n@@ -791,1 +804,1 @@\n-    static bool has_PerfData() { return _has_PerfData; }\n+    static bool has_PerfData() { return Atomic::load_acquire(&_has_PerfData); }\n","filename":"src\/hotspot\/share\/runtime\/perfData.hpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+#include \"utilities\/globalCounter.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}