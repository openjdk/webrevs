{"files":[{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/aotReferenceObjSupport.hpp\"\n@@ -76,0 +77,1 @@\n+  AOTReferenceObjSupport::init_keep_alive_objs_table();\n","filename":"src\/hotspot\/share\/cds\/aotArtifactFinder.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -341,1 +341,2 @@\n-         ik == vmClasses::ConcurrentHashMap_klass();\n+         ik == vmClasses::ConcurrentHashMap_klass() ||\n+         ik == vmClasses::Reference_klass();\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,240 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"cds\/aotReferenceObjSupport.hpp\"\n+#include \"cds\/heapShared.hpp\"\n+#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"oops\/oopHandle.inline.hpp\"\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n+#include \"runtime\/javaCalls.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n+\n+\/\/ Handling of java.lang.ref.Reference objects in the AOT cache\n+\/\/ ============================================================\n+\/\/\n+\/\/ When AOTArtifactFinder finds an oop which is a instance of java.lang.ref.Reference:\n+\/\/\n+\/\/ - We check if the oop is eligible to be stored in the AOT cache. If not, the AOT cache\n+\/\/   creation fails -- see AOTReferenceObjSupport::check_if_ref_obj()\n+\/\/\n+\/\/ - Otherwise, we store the oop into the AOT cache, but we unconditionally reset its\n+\/\/   \"next\" and \"discovered\" fields to null. Otherwise, if AOTArtifactFinder follows these\n+\/\/   fields, it may found unrelated objects that we don't intend to cache.\n+\/\/\n+\/\/ Eligibility\n+\/\/ ===========\n+\/\/\n+\/\/ [1] A reference that does not require special clean up (i.e., Reference::queue == ReferenceQueue.NULL_QUEUE)\n+\/\/     is eligible.\n+\/\/\n+\/\/ [2] A reference that REQUIRE specials clean up (i.e., Reference::queue != ReferenceQueue.NULL_QUEUE)\n+\/\/     is eligible ONLY if its referent is not null.\n+\/\/\n+\/\/ As of this version, the only oops in group [2] that can be found by AOTArtifactFinder are\n+\/\/ the keys used by ReferencedKeyMap in the implementation of MethodType::internTable.\n+\/\/ stabilize_cached_reference_objects() ensures that all keys found by AOTArtifactFinder are eligible.\n+\/\/\n+\/\/ The purpose of the error check in check_if_ref_obj() is to guard against changes in the JDK core\n+\/\/ libs that might introduce new types of oops in group [2] into the AOT cache.\n+\/\/\n+\/\/ Reasons for the eligibility restrictions\n+\/\/ ========================================\n+\/\/\n+\/\/ Reference handling is complex. In this version, we implement only enough functionality to support\n+\/\/ the use of Weak\/Soft references used by java.lang.invoke.\n+\/\/\n+\/\/ We intend to evolve the implementation in the future by\n+\/\/ -- implementing more assemblySetup() operations for other use cases, and\/or\n+\/\/ -- relaxing the eligibility restrictions.\n+\/\/\n+\/\/\n+\/\/ null referents for group [1]\n+\/\/ ============================\n+\/\/\n+\/\/ Any cached reference R1 of group [1] is allowed to have a null referent.\n+\/\/ This can happen in the following situations:\n+\/\/    (a) R1.clear() was called by Java code during the assembly phase.\n+\/\/    (b) The referent has been collected, and R1 is in the \"pending\" state.\n+\/\/ In case (b), the \"next\" and \"discovered\" fields of the cached copy of R1 will\n+\/\/ be set to null. During the production run:\n+\/\/    - It would appear to the Java program as if immediately during VM start-up, the referent\n+\/\/      was collected and ReferenceThread completed processing of R1.\n+\/\/    - It would appear to the GC as if immediately during VM start-up, the Java program called\n+\/\/      R1.clear().\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+\n+class KeepAliveObjectsTable : public ResourceHashtable<oop, bool,\n+    36137, \/\/ prime number\n+    AnyObj::C_HEAP,\n+    mtClassShared,\n+    HeapShared::oop_hash> {};\n+\n+static KeepAliveObjectsTable* _keep_alive_objs_table;\n+static OopHandle _keep_alive_objs_array;\n+static OopHandle _null_queue;\n+\n+bool AOTReferenceObjSupport::is_enabled() {\n+  \/\/ For simplicity, AOTReferenceObjSupport is enabled only when dumping method handles.\n+  \/\/ Otherwise we won't see Reference objects in the AOT cache. Let's be conservative now.\n+  return CDSConfig::is_dumping_method_handles();\n+}\n+\n+void AOTReferenceObjSupport::initialize(TRAPS) {\n+  if (!AOTReferenceObjSupport::is_enabled()) {\n+    return;\n+  }\n+\n+  TempNewSymbol class_name = SymbolTable::new_symbol(\"java\/lang\/ref\/ReferenceQueue\");\n+  Klass* k = SystemDictionary::resolve_or_fail(class_name, true, CHECK);\n+  InstanceKlass* ik = InstanceKlass::cast(k);\n+  ik->initialize(CHECK);\n+\n+  TempNewSymbol field_name = SymbolTable::new_symbol(\"NULL_QUEUE\");\n+  fieldDescriptor fd;\n+  bool found = ik->find_local_field(field_name, vmSymbols::referencequeue_signature(), &fd);\n+  precond(found);\n+  precond(fd.is_static());\n+\n+  _null_queue = OopHandle(Universe::vm_global(), ik->java_mirror()->obj_field(fd.offset()));\n+}\n+\n+\/\/ Ensure that all group [2] references found by AOTArtifactFinder are eligible.\n+void AOTReferenceObjSupport::stabilize_cached_reference_objects(TRAPS) {\n+  if (AOTReferenceObjSupport::is_enabled()) {\n+    \/\/ This assert means that the MethodType and MethodTypeForm tables won't be\n+    \/\/ updated concurrently, so we can remove GC'ed entries ...\n+    assert(CDSConfig::allow_only_single_java_thread(), \"Required\");\n+\n+    {\n+      TempNewSymbol method_name = SymbolTable::new_symbol(\"assemblySetup\");\n+      JavaValue result(T_VOID);\n+      JavaCalls::call_static(&result, vmClasses::MethodType_klass(),\n+                           method_name,\n+                           vmSymbols::void_method_signature(),\n+                           CHECK);\n+    }\n+\n+    {\n+      Symbol* cds_name  = vmSymbols::jdk_internal_misc_CDS();\n+      Klass* cds_klass = SystemDictionary::resolve_or_fail(cds_name, true \/*throw error*\/,  CHECK);\n+      TempNewSymbol method_name = SymbolTable::new_symbol(\"getKeepAliveObjects\");\n+      TempNewSymbol method_sig = SymbolTable::new_symbol(\"()[Ljava\/lang\/Object;\");\n+      JavaValue result(T_OBJECT);\n+      JavaCalls::call_static(&result, cds_klass, method_name, method_sig, CHECK);\n+\n+      _keep_alive_objs_array = OopHandle(Universe::vm_global(), result.get_oop());\n+    }\n+  }\n+}\n+\n+void AOTReferenceObjSupport::init_keep_alive_objs_table() {\n+  assert_at_safepoint(); \/\/ _keep_alive_objs_table uses raw oops\n+  oop a = _keep_alive_objs_array.resolve();\n+  if (a != nullptr) {\n+    precond(a->is_objArray());\n+    precond(AOTReferenceObjSupport::is_enabled());\n+    objArrayOop array = objArrayOop(a);\n+\n+    _keep_alive_objs_table = new (mtClass)KeepAliveObjectsTable();\n+    for (int i = 0; i < array->length(); i++) {\n+      oop obj = array->obj_at(i);\n+      _keep_alive_objs_table->put(obj, true); \/\/ The array may have duplicated entries but that's OK.\n+    }\n+  }\n+}\n+\n+\/\/ Returns true IFF obj is an instance of java.lang.ref.Reference. If so, perform extra eligibility checks.\n+bool AOTReferenceObjSupport::check_if_ref_obj(oop obj) {\n+  \/\/ We have a single Java thread. This means java.lang.ref.Reference$ReferenceHandler thread\n+  \/\/ is not running. Otherwise the checks for next\/discovered may not work.\n+  precond(CDSConfig::allow_only_single_java_thread());\n+  assert_at_safepoint(); \/\/ _keep_alive_objs_table uses raw oops\n+\n+  if (obj->klass()->is_subclass_of(vmClasses::Reference_klass())) {\n+    precond(AOTReferenceObjSupport::is_enabled());\n+    precond(JavaClasses::is_supported_for_archiving(obj));\n+    precond(_keep_alive_objs_table != nullptr);\n+\n+    \/\/ GC needs to know about this load, It will keep referent alive until the current safepoint ends.\n+    oop referent = HeapAccess<ON_UNKNOWN_OOP_REF>::oop_load_at(obj, java_lang_ref_Reference::referent_offset());\n+\n+    oop queue = obj->obj_field(java_lang_ref_Reference::queue_offset());\n+    oop next = java_lang_ref_Reference::next(obj);\n+    oop discovered = java_lang_ref_Reference::discovered(obj);\n+    bool needs_special_cleanup = (queue != _null_queue.resolve());\n+\n+    \/\/ If you see the errors below, you probably modified the implementation of java.lang.invoke.\n+    \/\/ Please check the comments at the top of this file.\n+    if (needs_special_cleanup && (referent == nullptr || !_keep_alive_objs_table->contains(referent))) {\n+      ResourceMark rm;\n+\n+      log_error(cds, heap)(\"Cannot archive reference object \" PTR_FORMAT \" of class %s\",\n+                           p2i(obj), obj->klass()->external_name());\n+      log_error(cds, heap)(\"referent = \" PTR_FORMAT\n+                           \", queue = \" PTR_FORMAT\n+                           \", next = \" PTR_FORMAT\n+                           \", discovered = \" PTR_FORMAT,\n+                           p2i(referent), p2i(queue), p2i(next), p2i(discovered));\n+      log_error(cds, heap)(\"This object requires special clean up as its queue is not ReferenceQueue::N\" \"ULL (\"\n+                           PTR_FORMAT \")\", p2i(_null_queue.resolve()));\n+      log_error(cds, heap)(\"%s\", (referent == nullptr) ?\n+                           \"referent cannot be null\" : \"referent is not registered with CDS.keepAlive()\");\n+      HeapShared::debug_trace();\n+      MetaspaceShared::unrecoverable_writing_error();\n+    }\n+\n+    if (log_is_enabled(Info, cds, ref)) {\n+      ResourceMark rm;\n+      log_info(cds, ref)(\"Reference obj:\"\n+                         \" r=\" PTR_FORMAT\n+                         \" q=\" PTR_FORMAT\n+                         \" n=\" PTR_FORMAT\n+                         \" d=\" PTR_FORMAT\n+                         \" %s\",\n+                         p2i(referent),\n+                         p2i(queue),\n+                         p2i(next),\n+                         p2i(discovered),\n+                         obj->klass()->external_name());\n+    }\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+bool AOTReferenceObjSupport::skip_field(int field_offset) {\n+  return (field_offset == java_lang_ref_Reference::next_offset() ||\n+          field_offset == java_lang_ref_Reference::discovered_offset());\n+}\n+\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n","filename":"src\/hotspot\/share\/cds\/aotReferenceObjSupport.cpp","additions":240,"deletions":0,"binary":false,"changes":240,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_AOTREFERENCEOBJSUPPORT_HPP\n+#define SHARE_CDS_AOTREFERENCEOBJSUPPORT_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n+\n+\/\/ Support for ahead-of-time allocated instances of java.lang.ref.Reference\n+\n+class AOTReferenceObjSupport : AllStatic {\n+\n+public:\n+  static void initialize(TRAPS);\n+  static void stabilize_cached_reference_objects(TRAPS);\n+  static void init_keep_alive_objs_table() NOT_CDS_JAVA_HEAP_RETURN;\n+  static bool check_if_ref_obj(oop obj);\n+  static bool skip_field(int field_offset);\n+  static bool is_enabled();\n+};\n+\n+#endif \/\/ SHARE_CDS_AOTREFERENCEOBJSUPPORT_HPP\n","filename":"src\/hotspot\/share\/cds\/aotReferenceObjSupport.hpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotReferenceObjSupport.hpp\"\n@@ -610,1 +611,1 @@\n-\n+  bool _is_java_lang_ref;\n@@ -613,1 +614,4 @@\n-    _src_obj(src_obj), _buffered_obj(buffered_obj), _oopmap(oopmap) {}\n+    _src_obj(src_obj), _buffered_obj(buffered_obj), _oopmap(oopmap)\n+  {\n+    _is_java_lang_ref = AOTReferenceObjSupport::check_if_ref_obj(src_obj);\n+  }\n@@ -620,2 +624,8 @@\n-    size_t field_offset = pointer_delta(p, _src_obj, sizeof(char));\n-    ArchiveHeapWriter::relocate_field_in_buffer<T>((T*)(_buffered_obj + field_offset), _oopmap);\n+    int field_offset = pointer_delta_as_int((char*)p, cast_from_oop<char*>(_src_obj));\n+    T* field_addr = (T*)(_buffered_obj + field_offset);\n+    if (_is_java_lang_ref && AOTReferenceObjSupport::skip_field(field_offset)) {\n+      \/\/ Do not copy these fields. Set them to null\n+      *field_addr = (T)0x0;\n+    } else {\n+      ArchiveHeapWriter::relocate_field_in_buffer<T>(field_addr, _oopmap);\n+    }\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -539,3 +539,0 @@\n-\n-    \/\/ Don't use SoftReferences so that objects used by java.lang.invoke tables can be archived.\n-    Arguments::PropertyList_add(new SystemProperty(\"java.lang.invoke.MethodHandleNatives.USE_SOFT_CACHE\", \"false\", false));\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/aotReferenceObjSupport.hpp\"\n@@ -1366,2 +1367,3 @@\n-\/\/ Push all oops that are referenced by _referencing_obj onto the _stack.\n-class HeapShared::ReferentPusher: public BasicOopIterateClosure {\n+\/\/ Push all oop fields (or oop array elemenets in case of an objArray) in\n+\/\/ _referencing_obj onto the _stack.\n+class HeapShared::OopFieldPusher: public BasicOopIterateClosure {\n@@ -1374,0 +1376,1 @@\n+  bool _is_java_lang_ref;\n@@ -1375,5 +1378,5 @@\n-  ReferentPusher(PendingOopStack* stack,\n-                           int level,\n-                           bool record_klasses_only,\n-                           KlassSubGraphInfo* subgraph_info,\n-                           oop orig) :\n+  OopFieldPusher(PendingOopStack* stack,\n+                 int level,\n+                 bool record_klasses_only,\n+                 KlassSubGraphInfo* subgraph_info,\n+                 oop orig) :\n@@ -1386,0 +1389,1 @@\n+    _is_java_lang_ref = AOTReferenceObjSupport::check_if_ref_obj(orig);\n@@ -1387,2 +1391,2 @@\n-  void do_oop(narrowOop *p) { ReferentPusher::do_oop_work(p); }\n-  void do_oop(      oop *p) { ReferentPusher::do_oop_work(p); }\n+  void do_oop(narrowOop *p) { OopFieldPusher::do_oop_work(p); }\n+  void do_oop(      oop *p) { OopFieldPusher::do_oop_work(p); }\n@@ -1390,1 +1394,1 @@\n-  ~ReferentPusher() {\n+  ~OopFieldPusher() {\n@@ -1393,1 +1397,1 @@\n-      \/\/ of ReferentPusher that recurses on the C stack -- a depth-first search,\n+      \/\/ of OopFieldPusher that recurses on the C stack -- a depth-first search,\n@@ -1402,1 +1406,2 @@\n-    oop obj = RawAccess<>::oop_load(p);\n+    int field_offset = pointer_delta_as_int((char*)p, cast_from_oop<char*>(_referencing_obj));\n+    oop obj = HeapAccess<ON_UNKNOWN_OOP_REF>::oop_load_at(_referencing_obj, field_offset);\n@@ -1404,1 +1409,4 @@\n-      size_t field_delta = pointer_delta(p, _referencing_obj, sizeof(char));\n+      if (_is_java_lang_ref && AOTReferenceObjSupport::skip_field(field_offset)) {\n+        \/\/ Do not follow these fields. They will be cleared to null.\n+        return;\n+      }\n@@ -1408,2 +1416,2 @@\n-        log_debug(cds, heap)(\"(%d) %s[%zu] ==> \" PTR_FORMAT \" size %zu %s\", _level,\n-                             _referencing_obj->klass()->external_name(), field_delta,\n+        log_debug(cds, heap)(\"(%d) %s[%d] ==> \" PTR_FORMAT \" size %zu %s\", _level,\n+                             _referencing_obj->klass()->external_name(), field_offset,\n@@ -1589,1 +1597,1 @@\n-    ReferentPusher pusher(stack, level, record_klasses_only, subgraph_info, orig_obj);\n+    OopFieldPusher pusher(stack, level, record_klasses_only, subgraph_info, orig_obj);\n@@ -1616,1 +1624,1 @@\n-\/\/ The Java heap object sub-graph archiving process (see ReferentPusher):\n+\/\/ The Java heap object sub-graph archiving process (see OopFieldPusher):\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":25,"deletions":17,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -167,1 +167,0 @@\n-  static void debug_trace();\n@@ -169,0 +168,1 @@\n+  static void debug_trace();\n@@ -360,1 +360,1 @@\n-  class ReferentPusher;\n+  class OopFieldPusher;\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"cds\/aotReferenceObjSupport.hpp\"\n@@ -965,0 +966,1 @@\n+\n@@ -970,11 +972,2 @@\n-    if (CDSConfig::is_dumping_method_handles()) {\n-      \/\/ This assert means that the MethodType and MethodTypeForm tables won't be\n-      \/\/ updated concurrently when we are saving their contents into a side table.\n-      assert(CDSConfig::allow_only_single_java_thread(), \"Required\");\n-\n-      JavaValue result(T_VOID);\n-      JavaCalls::call_static(&result, vmClasses::MethodType_klass(),\n-                             vmSymbols::createArchivedObjects(),\n-                             vmSymbols::void_method_signature(),\n-                             CHECK);\n-    }\n+    AOTReferenceObjSupport::initialize(CHECK);\n+    AOTReferenceObjSupport::stabilize_cached_reference_objects(CHECK);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotReferenceObjSupport.hpp\"\n@@ -5463,3 +5464,1 @@\n-  if (klass->is_subclass_of(vmClasses::Reference_klass())) {\n-    \/\/ It's problematic to archive Reference objects. One of the reasons is that\n-    \/\/ Reference::discovered may pull in unwanted objects (see JDK-8284336)\n+  if (!AOTReferenceObjSupport::is_enabled() && klass->is_subclass_of(vmClasses::Reference_klass())) {\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -722,1 +722,0 @@\n-  template(createArchivedObjects,                           \"createArchivedObjects\")                              \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import static java.lang.invoke.MethodHandleNatives.USE_SOFT_CACHE;\n@@ -93,2 +92,1 @@\n-    private static final class Transform {\n-        final Object cache;\n+    private static final class Transform extends SoftReference<LambdaForm> {\n@@ -99,5 +97,1 @@\n-            if (USE_SOFT_CACHE) {\n-                cache = new SoftReference<LambdaForm>(result);\n-            } else {\n-                cache = result;\n-            }\n+            super(result);\n@@ -144,9 +138,0 @@\n-\n-        @SuppressWarnings(\"unchecked\")\n-        public LambdaForm get() {\n-            if (cache instanceof LambdaForm lf) {\n-                return lf;\n-            } else {\n-                return ((SoftReference<LambdaForm>)cache).get();\n-            }\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaFormEditor.java","additions":2,"deletions":17,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -668,18 +668,0 @@\n-\n-    \/\/--- AOTCache support\n-\n-    \/**\n-     * In normal execution, this is set to true, so that LambdaFormEditor and MethodTypeForm will\n-     * use soft references to allow class unloading.\n-     *\n-     * When dumping the AOTCache, this is set to false so that no cached heap objects will\n-     * contain soft references (which are not yet supported by AOTCache - see JDK-8341587). AOTCache\n-     * only stores LambdaFormEditors and MethodTypeForms for classes in the boot\/platform\/app loaders.\n-     * Such classes will never be unloaded, so it's OK to use hard references.\n-     *\/\n-    static final boolean USE_SOFT_CACHE;\n-\n-    static {\n-        USE_SOFT_CACHE = Boolean.parseBoolean(\n-                System.getProperty(\"java.lang.invoke.MethodHandleNatives.USE_SOFT_CACHE\", \"true\"));\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":1,"deletions":19,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,0 @@\n-import java.util.HashMap;\n-import java.util.Iterator;\n@@ -45,1 +43,0 @@\n-import jdk.internal.misc.CDS;\n@@ -397,11 +394,0 @@\n-        if (archivedMethodTypes != null) {\n-            \/\/ If this JVM process reads from archivedMethodTypes, it never\n-            \/\/ modifies the table. So there's no need for synchronization.\n-            \/\/ See copyInternTable() below.\n-            assert CDS.isUsingArchive();\n-            MethodType mt = archivedMethodTypes.get(primordialMT);\n-            if (mt != null) {\n-                return mt;\n-            }\n-        }\n-\n@@ -428,1 +414,0 @@\n-    private static @Stable HashMap<MethodType,MethodType> archivedMethodTypes;\n@@ -1400,11 +1385,0 @@\n-    static HashMap<MethodType,MethodType> copyInternTable() {\n-        HashMap<MethodType,MethodType> copy = new HashMap<>();\n-\n-        for (Iterator<MethodType> i = internTable.iterator(); i.hasNext(); ) {\n-            MethodType t = i.next();\n-            copy.put(t, t);\n-        }\n-\n-        return copy;\n-    }\n-\n@@ -1413,11 +1387,2 @@\n-    static void createArchivedObjects() {\n-        \/\/ After the archivedMethodTypes field is assigned, this table\n-        \/\/ is never modified. So we don't need synchronization when reading from\n-        \/\/ it (which happens only in a future JVM process, never in the current process).\n-        \/\/\n-        \/\/ @implNote CDS.isDumpingStaticArchive() is mutually exclusive with\n-        \/\/ CDS.isUsingArchive(); at most one of them can return true for any given JVM\n-        \/\/ process.\n-        assert CDS.isDumpingStaticArchive();\n-        archivedMethodTypes = copyInternTable();\n-        internTable.clear();\n+    private static void assemblySetup() {\n+        internTable.prepareForAOTCache();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodType.java","additions":3,"deletions":38,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import static java.lang.invoke.MethodHandleNatives.USE_SOFT_CACHE;\n@@ -55,1 +54,1 @@\n-    private final Object[] methodHandles;\n+    private final SoftReference<MethodHandle>[] methodHandles;\n@@ -65,1 +64,1 @@\n-    private final Object[] lambdaForms;\n+    private final SoftReference<LambdaForm>[] lambdaForms;\n@@ -114,1 +113,0 @@\n-    @SuppressWarnings(\"unchecked\")\n@@ -116,8 +114,2 @@\n-        Object entry = methodHandles[which];\n-        if (entry == null) {\n-            return null;\n-        } else if (entry instanceof MethodHandle mh) {\n-            return mh;\n-        } else {\n-            return ((SoftReference<MethodHandle>)entry).get();\n-        }\n+        SoftReference<MethodHandle> entry = methodHandles[which];\n+        return (entry != null) ? entry.get() : null;\n@@ -132,5 +124,1 @@\n-        if (USE_SOFT_CACHE) {\n-            methodHandles[which] = new SoftReference<>(mh);\n-        } else {\n-            methodHandles[which] = mh;\n-        }\n+        methodHandles[which] = new SoftReference<>(mh);\n@@ -140,1 +128,0 @@\n-    @SuppressWarnings(\"unchecked\")\n@@ -142,8 +129,2 @@\n-        Object entry = lambdaForms[which];\n-        if (entry == null) {\n-            return null;\n-        } else if (entry instanceof LambdaForm lf) {\n-            return lf;\n-        } else {\n-            return ((SoftReference<LambdaForm>)entry).get();\n-        }\n+        SoftReference<LambdaForm> entry = lambdaForms[which];\n+        return (entry != null) ? entry.get() : null;\n@@ -158,5 +139,1 @@\n-        if (USE_SOFT_CACHE) {\n-            lambdaForms[which] = new SoftReference<>(form);\n-        } else {\n-            lambdaForms[which] = form;\n-        }\n+        lambdaForms[which] = new SoftReference<>(form);\n@@ -184,0 +161,1 @@\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n@@ -224,2 +202,2 @@\n-            this.lambdaForms   = new Object[LF_LIMIT];\n-            this.methodHandles = new Object[MH_LIMIT];\n+            this.lambdaForms   = new SoftReference[LF_LIMIT];\n+            this.methodHandles = new SoftReference[MH_LIMIT];\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodTypeForm.java","additions":11,"deletions":33,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-     *   queue = ReferenceQueue.NULL; next = this.\n+     *   queue = ReferenceQueue.NULL_QUEUE; next = this.\n@@ -82,1 +82,1 @@\n-     *   queue = ReferenceQueue.NULL.\n+     *   queue = ReferenceQueue.NULL_QUEUE.\n@@ -164,2 +164,2 @@\n-     *        dequeued: ReferenceQueue.NULL\n-     *    unregistered: ReferenceQueue.NULL\n+     *        dequeued: ReferenceQueue.NULL_QUEUE\n+     *    unregistered: ReferenceQueue.NULL_QUEUE\n@@ -235,1 +235,1 @@\n-        if (q != ReferenceQueue.NULL) q.enqueue(this);\n+        if (q != ReferenceQueue.NULL_QUEUE) q.enqueue(this);\n@@ -309,0 +309,1 @@\n+    \/\/ Called from JVM when loading an AOT cache\n@@ -310,0 +311,4 @@\n+        runtimeSetup();\n+    }\n+\n+    private static void runtimeSetup() {\n@@ -543,1 +548,1 @@\n-        this.queue = (queue == null) ? ReferenceQueue.NULL : queue;\n+        this.queue = (queue == null) ? ReferenceQueue.NULL_QUEUE : queue;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-    static final ReferenceQueue<Object> NULL = new Null();\n+    static final ReferenceQueue<Object> NULL_QUEUE = new Null();\n@@ -77,1 +77,1 @@\n-        if ((queue == NULL) || (queue == ENQUEUED)) {\n+        if ((queue == NULL_QUEUE) || (queue == ENQUEUED)) {\n@@ -99,1 +99,1 @@\n-            r.queue = NULL;\n+            r.queue = NULL_QUEUE;\n@@ -251,1 +251,1 @@\n-                    \/\/ already dequeued: r.queue == NULL; ->\n+                    \/\/ already dequeued: r.queue == NULL_QUEUE; ->\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/ReferenceQueue.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -85,0 +85,4 @@\n+    public static boolean isSingleThreadVM() {\n+        return isDumpingStaticArchive();\n+    }\n+\n@@ -88,0 +92,23 @@\n+\n+    \/\/ Used only when dumping static archive to keep weak references alive to\n+    \/\/ ensure that Soft\/Weak Reference objects can be reliably archived.\n+    private static ArrayList<Object> keepAliveList;\n+\n+    public static void keepAlive(Object s) {\n+        assert isSingleThreadVM(); \/\/ no need for synchronization\n+        assert isDumpingStaticArchive();\n+        if (keepAliveList == null) {\n+            keepAliveList = new ArrayList<>();\n+        }\n+        keepAliveList.add(s);\n+    }\n+\n+    \/\/ This is called by native JVM code at the very end of Java execution before\n+    \/\/ dumping the static archive.\n+    \/\/ It collects the objects from keepAliveList so that they can be easily processed\n+    \/\/ by the native JVM code to check that any Reference objects that need special\n+    \/\/ clean up must have been registed with keepAlive()\n+    private static Object[] getKeepAliveObjects() {\n+        return keepAliveList.toArray();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CDS.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,1 @@\n+import jdk.internal.misc.CDS;\n@@ -339,0 +340,34 @@\n+    @SuppressWarnings(\"unchecked\")\n+    public void prepareForAOTCache() {\n+        \/\/ We are running the AOT assembly phase. The JVM has a single Java thread, so\n+        \/\/ we don't have any concurrent threads that may modify the map while we are\n+        \/\/ iterating its keys.\n+        \/\/\n+        \/\/ Also, the java.lang.ref.Reference$ReferenceHandler thread is not running,\n+        \/\/ so even if the GC has put some of the keys on the pending ReferencePendingList,\n+        \/\/ none of the keys would have been added to the stale queue yet.\n+        assert CDS.isSingleThreadVM();\n+\n+        for (ReferenceKey<K> key : map.keySet()) {\n+            Object referent = key.get();\n+            if (referent == null) {\n+                \/\/ We don't need this key anymore. Add to stale queue\n+                ((Reference)key).enqueue();\n+            } else {\n+                \/\/ Make sure the referent cannot be collected. Otherwise, when\n+                \/\/ the referent is collected, the GC may push the key onto\n+                \/\/ Universe::reference_pending_list() at an unpredictable time,\n+                \/\/ making it difficult to correctly serialize the key's\n+                \/\/ state into the CDS archive.\n+                \/\/\n+                \/\/ See aotReferenceObjSupport.cpp for more info.\n+                CDS.keepAlive(referent);\n+            }\n+            Reference.reachabilityFence(referent);\n+        }\n+\n+        \/\/ Remove all keys enqueued above\n+        removeStaleReferences();\n+    }\n+\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ReferencedKeyMap.java","additions":36,"deletions":1,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -196,0 +196,4 @@\n+\n+    public void prepareForAOTCache() {\n+        map.prepareForAOTCache();\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ReferencedKeySet.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary This is a test case for creating an AOT cache using the setup_aot\/TestSetupAOT.java program, which\n+ *          is used for running HotSpot tests in the \"AOT mode\"\n+ *          (E.g., make test JTREG=AOT_JDK=true TEST=open\/test\/hotspot\/jtreg\/runtime\/invokedynamic)\n+ * @requires vm.cds\n+ * @comment work around JDK-8345635\n+ * @requires !vm.jvmci.enabled\n+ * @library \/test\/lib \/test\/setup_aot\n+ * @build TestSetupAOTTest JavacBenchApp TestSetupAOT\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller\n+ *                 TestSetupAOT\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar\n+ *                 TestSetupAOT\n+ *                 TestSetupAOT$ToolOutput\n+ *                 JavacBenchApp\n+ *                 JavacBenchApp$ClassFile\n+ *                 JavacBenchApp$FileManager\n+ *                 JavacBenchApp$SourceFile\n+ * @run driver TestSetupAOTTest\n+ *\/\n+\n+import jdk.test.lib.cds.SimpleCDSAppTester;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class TestSetupAOTTest {\n+    public static void main(String... args) throws Exception {\n+        SimpleCDSAppTester.of(\"TestSetupAOT\")\n+            .classpath(\"app.jar\")\n+            .appCommandLine(\"TestSetupAOT\", \".\")\n+            .runAOTWorkflow();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/TestSetupAOTTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,306 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test various test cases for archived WeakReference objects.\n+ * @requires vm.cds.write.archived.java.heap\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @requires vm.debug\n+ * @comment work around JDK-8345635\n+ * @requires !vm.jvmci.enabled\n+ * @library \/test\/jdk\/lib\/testlibrary \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @build WeakReferenceTest\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar weakref.jar\n+ *             WeakReferenceTestApp WeakReferenceTestApp$Inner ShouldNotBeAOTInited ShouldNotBeArchived SharedQueue\n+ *             WeakReferenceTestBadApp1 WeakReferenceTestBadApp2\n+ * @run driver WeakReferenceTest AOT\n+ *\/\n+\n+import java.lang.ref.WeakReference;\n+import java.lang.ref.ReferenceQueue;\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jtreg.SkippedException;\n+\n+public class WeakReferenceTest {\n+    static final String appJar = ClassFileInstaller.getJarPath(\"weakref.jar\");\n+\n+    static final String goodApp = \"WeakReferenceTestApp\";\n+    static final String badApp1 = \"WeakReferenceTestBadApp1\";\n+    static final String badApp2 = \"WeakReferenceTestBadApp2\";\n+\n+    public static void main(String[] args) throws Exception {\n+        new Tester(goodApp).run(args);\n+\n+        runBadApp(badApp1, args);\n+        runBadApp(badApp2, args);\n+    }\n+\n+    static void runBadApp(String badApp, String[] args) throws Exception {\n+        try {\n+            new Tester(badApp).run(args);\n+            throw new RuntimeException(badApp + \" did not fail in assembly phase as expected\");\n+        } catch (SkippedException e) {\n+            System.out.println(\"Negative test: expected SkippedException\");\n+        }\n+    }\n+\n+    static class Tester extends CDSAppTester {\n+        String mainClass;\n+        public Tester(String mainClass) {\n+            super(mainClass);\n+            this.mainClass = mainClass;\n+\n+            if (mainClass != goodApp) {\n+                setCheckExitValue(false);\n+            }\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            return appJar;\n+        }\n+\n+        @Override\n+        public String[] vmArgs(RunMode runMode) {\n+            if (runMode == RunMode.ASSEMBLY) {\n+                return new String[] {\n+                    \"-Xlog:gc,cds+class=debug\",\n+                    \"-XX:AOTInitTestClass=\" + mainClass,\n+                    \"-Xlog:cds+map,cds+map+oops=trace:file=cds.oops.txt:none:filesize=0\",\n+                };\n+            } else {\n+                return new String[] {\n+                    \"-Xlog:gc\",\n+                };\n+            }\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            return new String[] {\n+                mainClass,\n+                runMode.toString(),\n+            };\n+        }\n+\n+        @Override\n+        public void checkExecution(OutputAnalyzer out, RunMode runMode) throws Exception {\n+            if (runMode == RunMode.ASSEMBLY && mainClass != goodApp) {\n+                out.shouldNotHaveExitValue(0);\n+                out.shouldMatch(\"Cannot archive reference object .* of class java.lang.ref.WeakReference\");\n+                if (mainClass == badApp1) {\n+                    out.shouldContain(\"referent cannot be null\");\n+                } else {\n+                    out.shouldContain(\"referent is not registered with CDS.keepAlive()\");\n+                }\n+                throw new SkippedException(\"Assembly phase expected to fail\");\n+            }\n+\n+            out.shouldHaveExitValue(0);\n+            out.shouldNotContain(\"Unexpected exception:\");\n+        }\n+    }\n+}\n+\n+class WeakReferenceTestApp {\n+    static class Inner { \/\/ This class is NOT aot-initialized\n+        static boolean WeakReferenceTestApp_clinit_executed;\n+    }\n+\n+    static {\n+        Inner.WeakReferenceTestApp_clinit_executed = true;\n+\n+        \/\/ This static {} block is executed the training run (which uses no AOT cache).\n+        \/\/\n+        \/\/ During the assembly phase, this static {} block of is also executed\n+        \/\/ (triggered by the -XX:AOTInitTestClass=WeakReferenceTestApp flag).\n+        \/\/ It runs the aot_init_for_testXXX() method to set up the aot-initialized data structures\n+        \/\/ that are used by  each testXXX() function.\n+        \/\/\n+        \/\/ This block is NOT executed during the production run, because WeakReferenceTestApp\n+        \/\/ is aot-initialized.\n+\n+        aot_init_for_testCollectedInAssembly();\n+        aot_init_for_testWeakReferenceCollection();\n+    }\n+\n+    public static void main(String[] args) {\n+        try {\n+            runTests(args);\n+        } catch (Throwable t) {\n+            System.err.println(\"Unexpected exception:\");\n+            t.printStackTrace();\n+            System.exit(1);\n+        }\n+    }\n+\n+    static void runTests(String[] args) throws Exception {\n+        boolean isProduction = args[0].equals(\"PRODUCTION\");\n+\n+        if (isProduction && Inner.WeakReferenceTestApp_clinit_executed) {\n+            throw new RuntimeException(\"WeakReferenceTestApp should have been aot-inited\");\n+        }\n+\n+        if (isProduction) {\n+            \/\/ A GC should have happened before the heap objects are written into\n+            \/\/ the AOT cache. So any unreachable referents should have been collected.\n+        } else {\n+            \/\/ We are in the training run. Simulate the GC mentioned in the above comment,\n+            \/\/ so the test cases should observe the same states as in the production run.\n+            System.gc();\n+        }\n+\n+        testCollectedInAssembly(isProduction);\n+        testWeakReferenceCollection(isProduction);\n+    }\n+\n+    \/\/----------------------------------------------------------------------\n+    \/\/ Set up for testCollectedInAssembly()\n+    static WeakReference refToCollectedObj;\n+\n+    static void aot_init_for_testCollectedInAssembly() {\n+        \/\/ The referent will be GC-ed in the assembly run when the JVM forces a full GC.\n+        refToCollectedObj = new WeakReference(new String(\"collected in assembly\"));\n+    }\n+\n+    \/\/ [TEST CASE] Test the storage of a WeakReference whose referent has been collected during the assembly phase.\n+    static void testCollectedInAssembly(boolean isProduction) {\n+        System.out.println(\"refToCollectedObj.get() = \" + refToCollectedObj.get());\n+\n+        if (refToCollectedObj.get() != null) {\n+            throw new RuntimeException(\"refToCollectedObj.get() should have been GC'ed\");\n+        }\n+    }\n+\n+    \/\/----------------------------------------------------------------------\n+    \/\/ Set up for testWeakReferenceCollection()\n+    static Object root;\n+    static WeakReference ref;\n+\n+    static void aot_init_for_testWeakReferenceCollection() {\n+        root = new String(\"to be collected in production\");\n+        ref = makeRef();\n+    }\n+\n+    static WeakReference makeRef() {\n+        System.out.println(\"WeakReferenceTestApp::makeRef() is executed\");\n+        WeakReference r = new WeakReference(root);\n+        System.out.println(\"r.get() = \" + r.get());\n+\n+        ShouldNotBeAOTInited.doit();\n+        return r;\n+    }\n+\n+    static WeakReference makeRef2() {\n+        return new WeakReference(new String(\"to be collected in production\"));\n+    }\n+\n+\n+    \/\/ [TEST CASE] A WeakReference allocated in assembly phase should be collectable in the production run\n+    static void testWeakReferenceCollection(boolean isProduction) {\n+        WeakReference ref2 = makeRef2();\n+        System.out.println(\"ref.get() = \" + ref.get());   \/\/ created during assembly phase\n+        System.out.println(\"ref2.get() = \" + ref2.get()); \/\/ created during production run\n+\n+        if (ref.get() == null) {\n+            throw new RuntimeException(\"ref.get() should not be null\");\n+        }\n+\n+        System.out.println(\"... running GC ...\");\n+        root = null; \/\/ make ref.referent() eligible for collection\n+        System.gc();\n+\n+        System.out.println(\"ref.get() = \" + ref.get());\n+        System.out.println(\"ref2.get() = \" + ref2.get());\n+\n+        if (ref.get() != null) {\n+            throw new RuntimeException(\"ref.get() should be null\");\n+        }\n+        if (ref2.get() != null) {\n+            throw new RuntimeException(\"ref2.get() should be null\");\n+        }\n+\n+        System.out.println(\"ShouldNotBeAOTInited.doit_executed = \" + ShouldNotBeAOTInited.doit_executed);\n+        if (isProduction && ShouldNotBeAOTInited.doit_executed) {\n+            throw new RuntimeException(\"ShouldNotBeAOTInited should not have been aot-inited\");\n+        }\n+    }\n+}\n+\n+class ShouldNotBeAOTInited {\n+    static WeakReference ref;\n+    static boolean doit_executed;\n+    static {\n+        System.out.println(\"ShouldNotBeAOTInited.<clinit> called\");\n+    }\n+    static void doit() {\n+        System.out.println(\"ShouldNotBeAOTInited.doit()> called\");\n+        doit_executed = true;\n+        ref = new WeakReference(new ShouldNotBeAOTInited());\n+    }\n+}\n+\n+class ShouldNotBeArchived {\n+    static ShouldNotBeArchived instance = new ShouldNotBeArchived();\n+    static WeakReference ref;\n+    static int state = 1;\n+}\n+\n+class SharedQueue {\n+    static SharedQueue sharedQueueInstance = new SharedQueue();\n+    private ReferenceQueue<Object> theQueue = new ReferenceQueue<Object>();\n+\n+    static ReferenceQueue<Object> queue() {\n+        return sharedQueueInstance.theQueue;\n+    }\n+}\n+\n+class WeakReferenceTestBadApp1 {\n+    static WeakReference refWithQueue;\n+    static SharedQueue sharedQueueInstance;\n+\n+    static {\n+        \/\/ See comments in aotReferenceObjSupport.cpp: group [2] references cannot have null referent.\n+        sharedQueueInstance = SharedQueue.sharedQueueInstance;\n+        refWithQueue = new WeakReference(String.class, SharedQueue.queue());\n+        refWithQueue.clear();\n+    }\n+\n+    public static void main(String args[]) {}\n+}\n+\n+class WeakReferenceTestBadApp2 {\n+    static WeakReference refWithQueue;\n+    static SharedQueue sharedQueueInstance;\n+\n+    static {\n+        \/\/ See comments in aotReferenceObjSupport.cpp: group [2] references must be registered with CDS.keepAlive()\n+        sharedQueueInstance = SharedQueue.sharedQueueInstance;\n+        refWithQueue = new WeakReference(String.class, SharedQueue.queue());\n+    }\n+\n+    public static void main(String args[]) {}\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/WeakReferenceTest.java","additions":306,"deletions":0,"binary":false,"changes":306,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+import java.io.ByteArrayOutputStream;\n@@ -27,0 +28,2 @@\n+import java.io.PrintStream;\n+import java.nio.charset.StandardCharsets;\n@@ -32,0 +35,2 @@\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -63,0 +68,36 @@\n+    static class ToolOutput {\n+        ByteArrayOutputStream baos;\n+        PrintStream ps;\n+        String output;\n+\n+        ToolOutput() throws Exception {\n+            baos = new ByteArrayOutputStream();\n+            ps = new PrintStream(baos, true, StandardCharsets.UTF_8.name());\n+        }\n+        void finish() throws Exception {\n+            output = baos.toString(StandardCharsets.UTF_8.name());\n+            System.out.println(output);\n+        }\n+\n+        ToolOutput shouldContain(String... substrings) {\n+            for (String s : substrings) {\n+                if (!output.contains(s)) {\n+                    throw new RuntimeException(\"\\\"\" + s + \"\\\" missing from tool output\");\n+                }\n+            }\n+\n+            return this;\n+        }\n+\n+        ToolOutput shouldMatch(String... regexps) {\n+            for (String regexp : regexps) {\n+                Pattern pattern = Pattern.compile(regexp, Pattern.MULTILINE);\n+                if (!pattern.matcher(output).find()) {\n+                    throw new RuntimeException(\"Pattern \\\"\" + regexp + \"\\\" missing from tool output\");\n+                }\n+            }\n+\n+            return this;\n+        }\n+    }\n+\n@@ -71,1 +112,2 @@\n-        execTool(\"javac\", \"--help\");\n+        execTool(\"javac\", \"--help\")\n+            .shouldContain(\"Usage: javac <options> <source files>\");\n@@ -78,1 +120,2 @@\n-        execTool(\"javap\", \"--help\");\n+        execTool(\"javap\", \"--help\")\n+            .shouldContain(\"Show package\/protected\/public classes\");\n@@ -82,1 +125,3 @@\n-                 \"jdk.internal.module.ModuleBootstrap\");\n+                 \"jdk.internal.module.ModuleBootstrap\")\n+            .shouldContain(\"Compiled from \\\"System.java\\\"\",\n+                           \"public static java.io.Console console()\");\n@@ -89,2 +134,5 @@\n-        execTool(\"jlink\", \"--help\");\n-        execTool(\"jlink\", \"--list-plugins\");\n+        execTool(\"jlink\", \"--help\")\n+            .shouldContain(\"Compression to use in compressing resources\");\n+        execTool(\"jlink\", \"--list-plugins\")\n+            .shouldContain(\"List of available plugins\",\n+                           \"--generate-cds-archive \");\n@@ -101,1 +149,2 @@\n-        execTool(\"jar\", \"--help\");\n+        execTool(\"jar\", \"--help\")\n+            .shouldContain(\"--main-class=CLASSNAME\");\n@@ -104,4 +153,8 @@\n-        execTool(\"jar\", \"cvf\", jarOutput, \"TestSetupAOT.class\");\n-        execTool(\"jar\", \"uvf\", jarOutput, \"TestSetupAOT.class\");\n-        execTool(\"jar\", \"tvf\", jarOutput);\n-        execTool(\"jar\", \"--describe-module\", \"--file=\" + jarOutput);\n+        execTool(\"jar\", \"cvf\", jarOutput, \"TestSetupAOT.class\")\n+            .shouldContain(\"adding: TestSetupAOT.class\");\n+        execTool(\"jar\", \"uvf\", jarOutput, \"TestSetupAOT.class\")\n+            .shouldContain(\"adding: TestSetupAOT.class\");\n+        execTool(\"jar\", \"tvf\", jarOutput)\n+            .shouldContain(\"META-INF\/MANIFEST.MF\");\n+        execTool(\"jar\", \"--describe-module\", \"--file=\" + jarOutput)\n+            .shouldMatch(\"Unable to derive module descriptor for: .*tmp.jar\");\n@@ -113,2 +166,4 @@\n-        execTool(\"jdeps\", \"--help\");\n-        execTool(\"jdeps\", \"-v\", \"TestSetupAOT.class\");\n+        execTool(\"jdeps\", \"--help\")\n+            .shouldContain(\"--ignore-missing-deps\");\n+        execTool(\"jdeps\", \"-v\", \"TestSetupAOT.class\")\n+            .shouldContain(\"-> JavacBenchApp\");\n@@ -132,1 +187,1 @@\n-    static void execTool(String tool, String... args) throws Throwable {\n+    static ToolOutput execTool(String tool, String... args) throws Throwable {\n@@ -141,0 +196,1 @@\n+        ToolOutput output = new ToolOutput();\n@@ -143,1 +199,4 @@\n-        t.run(System.out, System.out, args);\n+        t.run(output.ps, output.ps, args);\n+\n+        output.finish();\n+        return output;\n","filename":"test\/setup_aot\/TestSetupAOT.java","additions":73,"deletions":14,"binary":false,"changes":87,"status":"modified"}]}