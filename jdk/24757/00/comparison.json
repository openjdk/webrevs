{"files":[{"patch":"@@ -341,1 +341,2 @@\n-         ik == vmClasses::ConcurrentHashMap_klass();\n+         ik == vmClasses::ConcurrentHashMap_klass() ||\n+         ik == vmClasses::Reference_klass();\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"cds\/aotReferenceObjSupport.hpp\"\n+#include \"cds\/heapShared.hpp\"\n+#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"oops\/oopHandle.inline.hpp\"\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n+\n+\/\/ Handling of java.lang.ref.Reference objects in the AOT cache\n+\/\/ ============================================================\n+\/\/\n+\/\/ When AOTArtifactFinder finds an oop which is a instance of java.lang.ref.Reference:\n+\/\/\n+\/\/ - We check if the oop is eligible to be stored in the AOT cache. If not, the AOT cache\n+\/\/   creation fails -- see AOTReferenceObjSupport::check_if_ref_obj()\n+\/\/\n+\/\/ - Otherwise, we store the oop into the AOT cache, but we unconditionally reset its\n+\/\/   \"next\" and \"discovered\" fields to null. Otherwise, if AOTArtifactFinder follows these\n+\/\/   fields, it may found unrelated objects that we don't intent to cache.\n+\/\/\n+\/\/ Eligibility\n+\/\/ ===========\n+\/\/\n+\/\/ [1] A reference that does not require special clean up (i.e., Reference::queue == ReferenceQueue::NULL)\n+\/\/     is eligible.\n+\/\/\n+\/\/ [2] A reference that REQUIRE specials clean up (i.e., Reference::queue != ReferenceQueue::NULL)\n+\/\/     is eligible ONLY if it has not been put into the \"pending\" state by the GC (See Reference.java).\n+\/\/\n+\/\/ AOTReferenceObjSupport::check_if_ref_obj() detects the \"pending\" state by checking the \"next\" and\n+\/\/ \"discovered\" fields of the oop.\n+\/\/\n+\/\/ As of this version, the only oops in group [2] that can be found by AOTArtifactFinder are\n+\/\/ the keys used by ReferencedKeyMap in the implementation of MethodType::internTable.\n+\/\/ ReferencedKeyMap::prepareForAOTCache ensures that all keys found by AOTArtifactFinder are eligible.\n+\/\/\n+\/\/ The purpose of the error check in check_if_ref_obj() is to guard against changes in the JDK core\n+\/\/ libs that might introduce new types of oops in group [2] into the AOT cache.\n+\/\/\n+\/\/\n+\/\/ Reasons for the eligibility restrictions\n+\/\/ ========================================\n+\/\/\n+\/\/ Reference handling is complex. In this version, we implement only enough functionality to support\n+\/\/ the use of Weak\/Soft references used by java.lang.invoke.\n+\/\/\n+\/\/ We intent to evolve the implementation in the future by\n+\/\/ -- implementing more prepareForAOTCache() operations for other use cases, and\/or\n+\/\/ -- relaxing the eligibility restrictions.\n+\n+static OopHandle _null_queue;\n+\n+void AOTReferenceObjSupport::initialize(TRAPS) {\n+  TempNewSymbol class_name = SymbolTable::new_symbol(\"java\/lang\/ref\/ReferenceQueue\");\n+  Klass* k = SystemDictionary::resolve_or_fail(class_name, true, CHECK);\n+  InstanceKlass* ik = InstanceKlass::cast(k);\n+  ik->initialize(CHECK);\n+\n+  TempNewSymbol field_name = SymbolTable::new_symbol(\"NULL\");\n+  fieldDescriptor fd;\n+  bool found = ik->find_local_field(field_name, vmSymbols::referencequeue_signature(), &fd);\n+  precond(found);\n+  precond(fd.is_static());\n+\n+  _null_queue = OopHandle(Universe::vm_global(), ik->java_mirror()->obj_field(fd.offset()));\n+}\n+\n+bool AOTReferenceObjSupport::check_if_ref_obj(oop obj) {\n+  \/\/ We have a single Java thread. This means java.lang.ref.Reference$ReferenceHandler thread\n+  \/\/ is not running. Otherwise the checks for next\/discovered may not work.\n+  precond(CDSConfig::allow_only_single_java_thread());\n+\n+  if (obj->klass()->is_subclass_of(vmClasses::Reference_klass())) {\n+    oop referent = obj->obj_field(java_lang_ref_Reference::referent_offset());\n+    oop queue = obj->obj_field(java_lang_ref_Reference::queue_offset());\n+    oop next = java_lang_ref_Reference::next(obj);\n+    oop discovered = java_lang_ref_Reference::discovered(obj);\n+\n+    if (next != nullptr || discovered != nullptr) {\n+      if (queue != _null_queue.resolve()) {\n+        ResourceMark rm;\n+        log_error(cds, heap)(\"Cannot archive reference object \" PTR_FORMAT \" of class %s\",\n+                             p2i(obj), obj->klass()->external_name());\n+        log_error(cds, heap)(\"referent = \" PTR_FORMAT\n+                             \", queue = \" PTR_FORMAT\n+                             \", next = \" PTR_FORMAT\n+                             \", discovered = \" PTR_FORMAT,\n+                             p2i(referent), p2i(queue), p2i(next), p2i(discovered));\n+        log_error(cds, heap)(\"This object requires special clean up as its queue is not ReferenceQueue::NULL (\"\n+                             PTR_FORMAT \")\", p2i(_null_queue.resolve()));\n+        HeapShared::debug_trace();\n+        MetaspaceShared::unrecoverable_writing_error();\n+      }\n+    }\n+\n+    if (log_is_enabled(Info, cds, ref)) {\n+      ResourceMark rm;\n+      log_info(cds, ref)(\"Reference obj:\"\n+                         \" r=\" PTR_FORMAT\n+                         \" q=\" PTR_FORMAT\n+                         \" n=\" PTR_FORMAT\n+                         \" d=\" PTR_FORMAT\n+                         \" %s\",\n+                         p2i(referent),\n+                         p2i(queue),\n+                         p2i(next),\n+                         p2i(discovered),\n+                         obj->klass()->external_name());\n+    }\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+bool AOTReferenceObjSupport::skip_field(int field_offset) {\n+  return (field_offset == java_lang_ref_Reference::next_offset() ||\n+          field_offset == java_lang_ref_Reference::discovered_offset());\n+}\n","filename":"src\/hotspot\/share\/cds\/aotReferenceObjSupport.cpp","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_AOTREFERENCEOBJSUPPORT_HPP\n+#define SHARE_CDS_AOTREFERENCEOBJSUPPORT_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n+\n+\/\/ Support for ahead-of-time allocated instances of java.lang.ref.Reference\n+\n+class AOTReferenceObjSupport : AllStatic {\n+\n+public:\n+  static void initialize(TRAPS);\n+  static bool check_if_ref_obj(oop obj);\n+  static bool skip_field(int field_offset);\n+};\n+\n+#endif \/\/ SHARE_CDS_AOTREFERENCEOBJSUPPORT_HPP\n","filename":"src\/hotspot\/share\/cds\/aotReferenceObjSupport.hpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotReferenceObjSupport.hpp\"\n@@ -610,1 +611,1 @@\n-\n+  bool _is_java_lang_ref;\n@@ -613,1 +614,4 @@\n-    _src_obj(src_obj), _buffered_obj(buffered_obj), _oopmap(oopmap) {}\n+    _src_obj(src_obj), _buffered_obj(buffered_obj), _oopmap(oopmap)\n+  {\n+    _is_java_lang_ref = AOTReferenceObjSupport::check_if_ref_obj(src_obj);\n+  }\n@@ -620,2 +624,8 @@\n-    size_t field_offset = pointer_delta(p, _src_obj, sizeof(char));\n-    ArchiveHeapWriter::relocate_field_in_buffer<T>((T*)(_buffered_obj + field_offset), _oopmap);\n+    int field_offset = pointer_delta_as_int((char*)p, cast_from_oop<char*>(_src_obj));\n+    T* field_addr = (T*)(_buffered_obj + field_offset);\n+    if (_is_java_lang_ref && AOTReferenceObjSupport::skip_field(field_offset)) {\n+      \/\/ Do not copy these fields. Set them to null\n+      *field_addr = (T)0x0;\n+    } else {\n+      ArchiveHeapWriter::relocate_field_in_buffer<T>(field_addr, _oopmap);\n+    }\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -539,3 +539,0 @@\n-\n-    \/\/ Don't use SoftReferences so that objects used by java.lang.invoke tables can be archived.\n-    Arguments::PropertyList_add(new SystemProperty(\"java.lang.invoke.MethodHandleNatives.USE_SOFT_CACHE\", \"false\", false));\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/aotReferenceObjSupport.hpp\"\n@@ -1366,2 +1367,3 @@\n-\/\/ Push all oops that are referenced by _referencing_obj onto the _stack.\n-class HeapShared::ReferentPusher: public BasicOopIterateClosure {\n+\/\/ Push all oop fields (or oop array elemenets in case of an objArray) in\n+\/\/ _referencing_obj onto the _stack.\n+class HeapShared::OopFieldPusher: public BasicOopIterateClosure {\n@@ -1374,0 +1376,1 @@\n+  bool _is_java_lang_ref;\n@@ -1375,5 +1378,5 @@\n-  ReferentPusher(PendingOopStack* stack,\n-                           int level,\n-                           bool record_klasses_only,\n-                           KlassSubGraphInfo* subgraph_info,\n-                           oop orig) :\n+  OopFieldPusher(PendingOopStack* stack,\n+                 int level,\n+                 bool record_klasses_only,\n+                 KlassSubGraphInfo* subgraph_info,\n+                 oop orig) :\n@@ -1386,0 +1389,1 @@\n+    _is_java_lang_ref = AOTReferenceObjSupport::check_if_ref_obj(orig);\n@@ -1387,2 +1391,2 @@\n-  void do_oop(narrowOop *p) { ReferentPusher::do_oop_work(p); }\n-  void do_oop(      oop *p) { ReferentPusher::do_oop_work(p); }\n+  void do_oop(narrowOop *p) { OopFieldPusher::do_oop_work(p); }\n+  void do_oop(      oop *p) { OopFieldPusher::do_oop_work(p); }\n@@ -1390,1 +1394,1 @@\n-  ~ReferentPusher() {\n+  ~OopFieldPusher() {\n@@ -1393,1 +1397,1 @@\n-      \/\/ of ReferentPusher that recurses on the C stack -- a depth-first search,\n+      \/\/ of OopFieldPusher that recurses on the C stack -- a depth-first search,\n@@ -1404,1 +1408,6 @@\n-      size_t field_delta = pointer_delta(p, _referencing_obj, sizeof(char));\n+      int field_offset = pointer_delta_as_int((char*)p, cast_from_oop<char*>(_referencing_obj));\n+\n+      if (_is_java_lang_ref && AOTReferenceObjSupport::skip_field(field_offset)) {\n+        \/\/ Do not follow these fields. They will be cleared to null.\n+        return;\n+      }\n@@ -1408,2 +1417,2 @@\n-        log_debug(cds, heap)(\"(%d) %s[%zu] ==> \" PTR_FORMAT \" size %zu %s\", _level,\n-                             _referencing_obj->klass()->external_name(), field_delta,\n+        log_debug(cds, heap)(\"(%d) %s[%d] ==> \" PTR_FORMAT \" size %zu %s\", _level,\n+                             _referencing_obj->klass()->external_name(), field_offset,\n@@ -1589,1 +1598,1 @@\n-    ReferentPusher pusher(stack, level, record_klasses_only, subgraph_info, orig_obj);\n+    OopFieldPusher pusher(stack, level, record_klasses_only, subgraph_info, orig_obj);\n@@ -1616,1 +1625,1 @@\n-\/\/ The Java heap object sub-graph archiving process (see ReferentPusher):\n+\/\/ The Java heap object sub-graph archiving process (see OopFieldPusher):\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":25,"deletions":16,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -167,1 +167,0 @@\n-  static void debug_trace();\n@@ -169,0 +168,1 @@\n+  static void debug_trace();\n@@ -360,1 +360,1 @@\n-  class ReferentPusher;\n+  class OopFieldPusher;\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"cds\/aotReferenceObjSupport.hpp\"\n@@ -965,0 +966,1 @@\n+    AOTReferenceObjSupport::initialize(CHECK);\n@@ -972,1 +974,1 @@\n-      \/\/ updated concurrently when we are saving their contents into a side table.\n+      \/\/ updated concurrently, so we can remove GC'ed entries ...\n@@ -975,0 +977,1 @@\n+      TempNewSymbol method_name = SymbolTable::new_symbol(\"prepareForAOTCache\");\n@@ -977,1 +980,1 @@\n-                             vmSymbols::createArchivedObjects(),\n+                             method_name,\n@@ -982,0 +985,1 @@\n+\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -5463,6 +5463,0 @@\n-  if (klass->is_subclass_of(vmClasses::Reference_klass())) {\n-    \/\/ It's problematic to archive Reference objects. One of the reasons is that\n-    \/\/ Reference::discovered may pull in unwanted objects (see JDK-8284336)\n-    return false;\n-  }\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -722,1 +722,0 @@\n-  template(createArchivedObjects,                           \"createArchivedObjects\")                              \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import static java.lang.invoke.MethodHandleNatives.USE_SOFT_CACHE;\n@@ -93,2 +92,1 @@\n-    private static final class Transform {\n-        final Object cache;\n+    private static final class Transform extends SoftReference<LambdaForm> {\n@@ -99,5 +97,1 @@\n-            if (USE_SOFT_CACHE) {\n-                cache = new SoftReference<LambdaForm>(result);\n-            } else {\n-                cache = result;\n-            }\n+            super(result);\n@@ -144,9 +138,0 @@\n-\n-        @SuppressWarnings(\"unchecked\")\n-        public LambdaForm get() {\n-            if (cache instanceof LambdaForm lf) {\n-                return lf;\n-            } else {\n-                return ((SoftReference<LambdaForm>)cache).get();\n-            }\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaFormEditor.java","additions":2,"deletions":17,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -668,18 +668,0 @@\n-\n-    \/\/--- AOTCache support\n-\n-    \/**\n-     * In normal execution, this is set to true, so that LambdaFormEditor and MethodTypeForm will\n-     * use soft references to allow class unloading.\n-     *\n-     * When dumping the AOTCache, this is set to false so that no cached heap objects will\n-     * contain soft references (which are not yet supported by AOTCache - see JDK-8341587). AOTCache\n-     * only stores LambdaFormEditors and MethodTypeForms for classes in the boot\/platform\/app loaders.\n-     * Such classes will never be unloaded, so it's OK to use hard references.\n-     *\/\n-    static final boolean USE_SOFT_CACHE;\n-\n-    static {\n-        USE_SOFT_CACHE = Boolean.parseBoolean(\n-                System.getProperty(\"java.lang.invoke.MethodHandleNatives.USE_SOFT_CACHE\", \"true\"));\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":1,"deletions":19,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,0 @@\n-import java.util.HashMap;\n-import java.util.Iterator;\n@@ -45,1 +43,0 @@\n-import jdk.internal.misc.CDS;\n@@ -397,11 +394,0 @@\n-        if (archivedMethodTypes != null) {\n-            \/\/ If this JVM process reads from archivedMethodTypes, it never\n-            \/\/ modifies the table. So there's no need for synchronization.\n-            \/\/ See copyInternTable() below.\n-            assert CDS.isUsingArchive();\n-            MethodType mt = archivedMethodTypes.get(primordialMT);\n-            if (mt != null) {\n-                return mt;\n-            }\n-        }\n-\n@@ -428,1 +414,0 @@\n-    private static @Stable HashMap<MethodType,MethodType> archivedMethodTypes;\n@@ -1400,11 +1385,0 @@\n-    static HashMap<MethodType,MethodType> copyInternTable() {\n-        HashMap<MethodType,MethodType> copy = new HashMap<>();\n-\n-        for (Iterator<MethodType> i = internTable.iterator(); i.hasNext(); ) {\n-            MethodType t = i.next();\n-            copy.put(t, t);\n-        }\n-\n-        return copy;\n-    }\n-\n@@ -1413,11 +1387,2 @@\n-    static void createArchivedObjects() {\n-        \/\/ After the archivedMethodTypes field is assigned, this table\n-        \/\/ is never modified. So we don't need synchronization when reading from\n-        \/\/ it (which happens only in a future JVM process, never in the current process).\n-        \/\/\n-        \/\/ @implNote CDS.isDumpingStaticArchive() is mutually exclusive with\n-        \/\/ CDS.isUsingArchive(); at most one of them can return true for any given JVM\n-        \/\/ process.\n-        assert CDS.isDumpingStaticArchive();\n-        archivedMethodTypes = copyInternTable();\n-        internTable.clear();\n+    private static void prepareForAOTCache() {\n+        internTable.prepareForAOTCache();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodType.java","additions":3,"deletions":38,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import static java.lang.invoke.MethodHandleNatives.USE_SOFT_CACHE;\n@@ -55,1 +54,1 @@\n-    private final Object[] methodHandles;\n+    private final SoftReference<MethodHandle>[] methodHandles;\n@@ -65,1 +64,1 @@\n-    private final Object[] lambdaForms;\n+    private final SoftReference<LambdaForm>[] lambdaForms;\n@@ -114,1 +113,0 @@\n-    @SuppressWarnings(\"unchecked\")\n@@ -116,8 +114,2 @@\n-        Object entry = methodHandles[which];\n-        if (entry == null) {\n-            return null;\n-        } else if (entry instanceof MethodHandle mh) {\n-            return mh;\n-        } else {\n-            return ((SoftReference<MethodHandle>)entry).get();\n-        }\n+        SoftReference<MethodHandle> entry = methodHandles[which];\n+        return (entry != null) ? entry.get() : null;\n@@ -132,5 +124,1 @@\n-        if (USE_SOFT_CACHE) {\n-            methodHandles[which] = new SoftReference<>(mh);\n-        } else {\n-            methodHandles[which] = mh;\n-        }\n+        methodHandles[which] = new SoftReference<>(mh);\n@@ -140,1 +128,0 @@\n-    @SuppressWarnings(\"unchecked\")\n@@ -142,8 +129,2 @@\n-        Object entry = lambdaForms[which];\n-        if (entry == null) {\n-            return null;\n-        } else if (entry instanceof LambdaForm lf) {\n-            return lf;\n-        } else {\n-            return ((SoftReference<LambdaForm>)entry).get();\n-        }\n+        SoftReference<LambdaForm> entry = lambdaForms[which];\n+        return (entry != null) ? entry.get() : null;\n@@ -158,5 +139,1 @@\n-        if (USE_SOFT_CACHE) {\n-            lambdaForms[which] = new SoftReference<>(form);\n-        } else {\n-            lambdaForms[which] = form;\n-        }\n+        lambdaForms[which] = new SoftReference<>(form);\n@@ -184,0 +161,1 @@\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n@@ -224,2 +202,2 @@\n-            this.lambdaForms   = new Object[LF_LIMIT];\n-            this.methodHandles = new Object[MH_LIMIT];\n+            this.lambdaForms   = new SoftReference[LF_LIMIT];\n+            this.methodHandles = new SoftReference[MH_LIMIT];\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodTypeForm.java","additions":11,"deletions":33,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -310,0 +310,4 @@\n+        runtimeSetup();\n+    }\n+\n+    private static void runtimeSetup() {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -85,0 +85,4 @@\n+    public static boolean isSingleThreadVM() {\n+        return isDumpingStaticArchive();\n+    }\n+\n@@ -88,0 +92,11 @@\n+\n+    private static ArrayList<Object> keepAliveList;\n+\n+    public static void keepAlive(Object s) {\n+        assert isSingleThreadVM();\n+        if (keepAliveList == null) {\n+            keepAliveList = new ArrayList<>();\n+        }\n+        keepAliveList.add(s);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CDS.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import jdk.internal.misc.CDS;\n@@ -339,0 +340,34 @@\n+    @SuppressWarnings(\"unchecked\")\n+    public void prepareForAOTCache() {\n+        \/\/ We are running the AOT assembly phase. The JVM has a single Java thread, so\n+        \/\/ we don't have any concurrent threads that may modify the map while we are\n+        \/\/ iterating its keys.\n+        \/\/\n+        \/\/ Also, the java.lang.ref.Reference$ReferenceHandler thread is not running,\n+        \/\/ so even if the GC has put some of the keys on the pending ReferencePendingList,\n+        \/\/ none of the keys would have been added to the stale queue yet.\n+        assert CDS.isSingleThreadVM();\n+\n+        for (ReferenceKey<K> key : map.keySet()) {\n+            Object referent = key.get();\n+            if (referent == null) {\n+                \/\/ We don't need this key anymore. Add to stale queue\n+                ((Reference)key).enqueue();\n+            } else {\n+                \/\/ Make sure the referent cannot be collected. Otherwise, when\n+                \/\/ the referent is collected, the GC may push the key onto\n+                \/\/ Universe::reference_pending_list() at an unpredictable time,\n+                \/\/ making it difficult to correctly serialize the key's\n+                \/\/ state into the CDS archive.\n+                \/\/\n+                \/\/ See aotReferenceObjSupport.cpp for more info.\n+                CDS.keepAlive(referent);\n+            }\n+            Reference.reachabilityFence(referent);\n+        }\n+\n+        \/\/ Remove all keys enqueued above\n+        removeStaleReferences();\n+    }\n+\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ReferencedKeyMap.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -196,0 +196,4 @@\n+\n+    public void prepareForAOTCache() {\n+        map.prepareForAOTCache();\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ReferencedKeySet.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary This is a test case for creating an AOT cache using the setup_aot\/TestSetupAOT.java program, which\n+ *          is used for running HotSpot tests in the \"AOT mode\"\n+ *          (E.g., make test JTREG=AOT_JDK=true TEST=open\/test\/hotspot\/jtreg\/runtime\/invokedynamic)\n+ * @requires vm.cds\n+ * @comment work around JDK-8345635\n+ * @requires !vm.jvmci.enabled\n+ * @library \/test\/lib \/test\/setup_aot\n+ * @build TestSetupAOTTest JavacBenchApp TestSetupAOT\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller\n+ *                 TestSetupAOT\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar\n+ *                 TestSetupAOT\n+ *                 TestSetupAOT$ToolOutput\n+ *                 JavacBenchApp\n+ *                 JavacBenchApp$ClassFile\n+ *                 JavacBenchApp$FileManager\n+ *                 JavacBenchApp$SourceFile\n+ * @run driver TestSetupAOTTest\n+ *\/\n+\n+import jdk.test.lib.cds.SimpleCDSAppTester;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class TestSetupAOTTest {\n+    public static void main(String... args) throws Exception {\n+        SimpleCDSAppTester.of(\"TestSetupAOT\")\n+            .classpath(\"app.jar\")\n+            .appCommandLine(\"TestSetupAOT\", \".\")\n+            .runAOTWorkflow();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/TestSetupAOTTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,250 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test various test cases for archived WeakReference objects.\n+ * @requires vm.cds.write.archived.java.heap\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @requires vm.debug\n+ * @comment work around JDK-8345635\n+ * @requires !vm.jvmci.enabled\n+ * @library \/test\/jdk\/lib\/testlibrary \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @build WeakReferenceTest\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar weakref.jar\n+ *             WeakReferenceTestApp WeakReferenceTestApp$Inner ShouldNotBeAOTInited ShouldNotBeArchived SharedQueue\n+ * @run driver WeakReferenceTest AOT\n+ *\/\n+\n+import java.lang.ref.WeakReference;\n+import java.lang.ref.ReferenceQueue;\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+\n+public class WeakReferenceTest {\n+    static final String appJar = ClassFileInstaller.getJarPath(\"weakref.jar\");\n+    static final String mainClass = \"WeakReferenceTestApp\";\n+\n+    public static void main(String[] args) throws Exception {\n+        Tester t = new Tester();\n+        t.run(args);\n+    }\n+\n+    static class Tester extends CDSAppTester {\n+        public Tester() {\n+            super(mainClass);\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            return appJar;\n+        }\n+\n+        @Override\n+        public String[] vmArgs(RunMode runMode) {\n+            if (runMode == RunMode.ASSEMBLY) {\n+                return new String[] {\n+                    \"-Xlog:gc,cds+class=debug\",\n+                    \"-XX:AOTInitTestClass=WeakReferenceTestApp\",\n+                    \"-Xlog:cds+map,cds+map+oops=trace:file=cds.oops.txt:none:filesize=0\",\n+                };\n+            } else {\n+                return new String[] {\n+                    \"-Xlog:gc\",\n+                };\n+            }\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            return new String[] {\n+                mainClass,\n+                runMode.toString(),\n+            };\n+        }\n+\n+        @Override\n+        public void checkExecution(OutputAnalyzer out, RunMode runMode) throws Exception {\n+            out.shouldHaveExitValue(0);\n+            out.shouldNotContain(\"Unexpected exception:\");\n+        }\n+    }\n+}\n+\n+class WeakReferenceTestApp {\n+    \/\/ This class is NOT aot-initialized\n+    static class Inner {\n+        static boolean WeakReferenceTestApp_clinit_executed;\n+    }\n+\n+    static {\n+        Inner.WeakReferenceTestApp_clinit_executed = true;\n+\n+        \/\/ This static {} block is executed the training run (which uses no AOT cache).\n+        \/\/\n+        \/\/ During the assembly phase, this static {} block of is also executed\n+        \/\/ (triggered by the -XX:AOTInitTestClass=WeakReferenceTestApp flag).\n+        \/\/ It runs the aot_init_for_testXXX() method to set up the aot-initialized data structures\n+        \/\/ that are used by  each testXXX() function.\n+        \/\/\n+        \/\/ This block is NOT executed during the production run, because WeakReferenceTestApp\n+        \/\/ is aot-initialized.\n+\n+        aot_init_for_testCollectedInAssembly();\n+        aot_init_for_testWeakReferenceCollection();\n+    }\n+\n+    public static void main(String[] args) {\n+        try {\n+            runTests(args);\n+        } catch (Throwable t) {\n+            System.err.println(\"Unexpected exception:\");\n+            t.printStackTrace();\n+            System.exit(1);\n+        }\n+    }\n+\n+    static void runTests(String[] args) throws Exception {\n+        boolean isProduction = args[0].equals(\"PRODUCTION\");\n+\n+        if (isProduction && Inner.WeakReferenceTestApp_clinit_executed) {\n+            throw new RuntimeException(\"WeakReferenceTestApp should have been aot-inited\");\n+        }\n+\n+        if (isProduction) {\n+            \/\/ A GC should have happened before the heap objects are written into\n+            \/\/ the AOT cache. So any unreachable referents should have been collected.\n+        } else {\n+            \/\/ We are in the training run. Simulate the GC mentioned in the above comment,\n+            \/\/ so the test cases should observe the same states as in the production run.\n+            System.gc();\n+        }\n+\n+        testCollectedInAssembly(isProduction);\n+        testWeakReferenceCollection(isProduction);\n+    }\n+\n+    \/\/----------------------------------------------------------------------\n+    \/\/ Set up for testCollectedInAssembly()\n+    static WeakReference refToCollectedObj;\n+\n+    static void aot_init_for_testCollectedInAssembly() {\n+        \/\/ The referent will be GC-ed in the assembly run when the JVM forces a full GC.\n+        refToCollectedObj = new WeakReference(new String(\"collected in assembly\"));\n+    }\n+\n+    \/\/ [TEST CASE] Test the storage of a WeakReference whose referent has been collected during the assembly phase.\n+    static void testCollectedInAssembly(boolean isProduction) {\n+        System.out.println(\"refToCollectedObj.get() = \" + refToCollectedObj.get());\n+\n+        if (refToCollectedObj.get() != null) {\n+            throw new RuntimeException(\"refToCollectedObj.get() should have been GC'ed\");\n+        }\n+    }\n+\n+    \/\/----------------------------------------------------------------------\n+    \/\/ Set up for testWeakReferenceCollection()\n+    static Object root;\n+    static WeakReference ref;\n+\n+    static void aot_init_for_testWeakReferenceCollection() {\n+        root = new String(\"to be collected in production\");\n+        ref = makeRef();\n+    }\n+\n+    static WeakReference makeRef() {\n+        System.out.println(\"WeakReferenceTestApp::makeRef() is executed\");\n+        WeakReference r = new WeakReference(root);\n+        System.out.println(\"r.get() = \" + r.get());\n+\n+        ShouldNotBeAOTInited.doit();\n+        return r;\n+    }\n+\n+    static WeakReference makeRef2() {\n+        return new WeakReference(new String(\"to be collected in production\"));\n+    }\n+\n+\n+    \/\/ [TEST CASE] A WeakReference allocated in assembly phase should be collectable in the production run\n+    static void testWeakReferenceCollection(boolean isProduction) {\n+        WeakReference ref2 = makeRef2();\n+        System.out.println(\"ref.get() = \" + ref.get());   \/\/ created during assembly phase\n+        System.out.println(\"ref2.get() = \" + ref2.get()); \/\/ created during production run\n+\n+        if (ref.get() == null) {\n+            throw new RuntimeException(\"ref.get() should not be null\");\n+        }\n+        if (ref2.get() == null) {\n+            throw new RuntimeException(\"ref2.get() should not be null\");\n+        }\n+\n+        System.out.println(\"... running GC ...\");\n+        root = null; \/\/ make ref.referent() eligible for collection\n+        System.gc();\n+\n+        System.out.println(\"ref.get() = \" + ref.get());\n+        System.out.println(\"ref2.get() = \" + ref2.get());\n+\n+        if (ref.get() != null) {\n+            throw new RuntimeException(\"ref.get() should be null\");\n+        }\n+        if (ref2.get() != null) {\n+            throw new RuntimeException(\"ref2.get() should be null\");\n+        }\n+\n+        System.out.println(\"ShouldNotBeAOTInited.doit_executed = \" + ShouldNotBeAOTInited.doit_executed);\n+        if (isProduction && ShouldNotBeAOTInited.doit_executed) {\n+            throw new RuntimeException(\"ShouldNotBeAOTInited should not have been aot-inited\");\n+        }\n+    }\n+}\n+\n+class ShouldNotBeAOTInited {\n+    static WeakReference ref;\n+    static boolean doit_executed;\n+    static {\n+        System.out.println(\"ShouldNotBeAOTInited.<clinit> called\");\n+    }\n+    static void doit() {\n+        System.out.println(\"ShouldNotBeAOTInited.doit()> called\");\n+        doit_executed = true;\n+        ref = new WeakReference(new ShouldNotBeAOTInited());\n+    }\n+}\n+\n+class ShouldNotBeArchived {\n+    static ShouldNotBeArchived instance = new ShouldNotBeArchived();\n+    static WeakReference ref;\n+    static int state = 1;\n+}\n+\n+class SharedQueue {\n+    static SharedQueue sharedQueueInstance = new SharedQueue();\n+    private ReferenceQueue<Object> theQueue = new ReferenceQueue<Object>();\n+\n+    static ReferenceQueue<Object> queue() {\n+        return sharedQueueInstance.theQueue;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/WeakReferenceTest.java","additions":250,"deletions":0,"binary":false,"changes":250,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+import java.io.ByteArrayOutputStream;\n@@ -27,0 +28,2 @@\n+import java.io.PrintStream;\n+import java.nio.charset.StandardCharsets;\n@@ -63,0 +66,25 @@\n+    static class ToolOutput {\n+        ByteArrayOutputStream baos;\n+        PrintStream ps;\n+        String output;\n+\n+        ToolOutput() throws Exception {\n+            baos = new ByteArrayOutputStream();\n+            ps = new PrintStream(baos, true, StandardCharsets.UTF_8.name());\n+        }\n+        void finish() throws Exception {\n+            output = baos.toString(StandardCharsets.UTF_8.name());\n+            System.out.println(output);\n+        }\n+\n+        ToolOutput shouldContain(String... substrings) {\n+            for (String s : substrings) {\n+                if (!output.contains(s)) {\n+                    throw new RuntimeException(\"\\\"\" + s + \"\\\" missing from tool output\");\n+                }\n+            }\n+\n+            return this;\n+        }\n+    }\n+\n@@ -71,1 +99,2 @@\n-        execTool(\"javac\", \"--help\");\n+        execTool(\"javac\", \"--help\")\n+            .shouldContain(\"Usage: javac <options> <source files>\");\n@@ -78,1 +107,2 @@\n-        execTool(\"javap\", \"--help\");\n+        execTool(\"javap\", \"--help\")\n+            .shouldContain(\"Show package\/protected\/public classes\");\n@@ -82,1 +112,3 @@\n-                 \"jdk.internal.module.ModuleBootstrap\");\n+                 \"jdk.internal.module.ModuleBootstrap\")\n+            .shouldContain(\"Compiled from \\\"System.java\\\"\",\n+                           \"public static java.io.Console console()\");\n@@ -89,2 +121,5 @@\n-        execTool(\"jlink\", \"--help\");\n-        execTool(\"jlink\", \"--list-plugins\");\n+        execTool(\"jlink\", \"--help\")\n+            .shouldContain(\"Compression to use in compressing resources\");\n+        execTool(\"jlink\", \"--list-plugins\")\n+            .shouldContain(\"List of available plugins\",\n+                           \"--generate-cds-archive \");\n@@ -101,1 +136,2 @@\n-        execTool(\"jar\", \"--help\");\n+        execTool(\"jar\", \"--help\")\n+            .shouldContain(\"--main-class=CLASSNAME\");\n@@ -104,4 +140,8 @@\n-        execTool(\"jar\", \"cvf\", jarOutput, \"TestSetupAOT.class\");\n-        execTool(\"jar\", \"uvf\", jarOutput, \"TestSetupAOT.class\");\n-        execTool(\"jar\", \"tvf\", jarOutput);\n-        execTool(\"jar\", \"--describe-module\", \"--file=\" + jarOutput);\n+        execTool(\"jar\", \"cvf\", jarOutput, \"TestSetupAOT.class\")\n+            .shouldContain(\"adding: TestSetupAOT.class\");\n+        execTool(\"jar\", \"uvf\", jarOutput, \"TestSetupAOT.class\")\n+            .shouldContain(\"adding: TestSetupAOT.class\");\n+        execTool(\"jar\", \"tvf\", jarOutput)\n+            .shouldContain(\"META-INF\/MANIFEST.MF\");\n+        execTool(\"jar\", \"--describe-module\", \"--file=\" + jarOutput)\n+            .shouldContain(\"Unable to derive module descriptor for: .\/tmp.jar\");\n@@ -113,2 +153,4 @@\n-        execTool(\"jdeps\", \"--help\");\n-        execTool(\"jdeps\", \"-v\", \"TestSetupAOT.class\");\n+        execTool(\"jdeps\", \"--help\")\n+            .shouldContain(\"--ignore-missing-deps\");\n+        execTool(\"jdeps\", \"-v\", \"TestSetupAOT.class\")\n+            .shouldContain(\"-> JavacBenchApp\");\n@@ -132,1 +174,1 @@\n-    static void execTool(String tool, String... args) throws Throwable {\n+    static ToolOutput execTool(String tool, String... args) throws Throwable {\n@@ -141,0 +183,1 @@\n+        ToolOutput output = new ToolOutput();\n@@ -143,1 +186,4 @@\n-        t.run(System.out, System.out, args);\n+        t.run(output.ps, output.ps, args);\n+\n+        output.finish();\n+        return output;\n","filename":"test\/setup_aot\/TestSetupAOT.java","additions":60,"deletions":14,"binary":false,"changes":74,"status":"modified"}]}