{"files":[{"patch":"@@ -106,0 +106,6 @@\n+bool AOTReferenceObjSupport::is_enabled() {\n+  \/\/ For simplicity, AOTReferenceObjSupport is enabled only when dumping method handles.\n+  \/\/ Otherwise we won't see Reference objects in the AOT cache. Let's be conservative now.\n+  return CDSConfig::is_dumping_method_handles();\n+}\n+\n@@ -107,0 +113,4 @@\n+  if (!AOTReferenceObjSupport::is_enabled()) {\n+    return;\n+  }\n+\n@@ -123,1 +133,1 @@\n-  if (CDSConfig::is_dumping_method_handles()) {\n+  if (AOTReferenceObjSupport::is_enabled()) {\n@@ -155,1 +165,1 @@\n-    precond(CDSConfig::is_dumping_method_handles());\n+    precond(AOTReferenceObjSupport::is_enabled());\n@@ -174,1 +184,7 @@\n-    oop referent = obj->obj_field(java_lang_ref_Reference::referent_offset());\n+    precond(AOTReferenceObjSupport::is_enabled());\n+    precond(JavaClasses::is_supported_for_archiving(obj));\n+    precond(_keep_alive_objs_table != nullptr);\n+\n+    \/\/ GC needs to know about this load, It will keep referent alive until the current safepoint ends.\n+    oop referent = HeapAccess<ON_UNKNOWN_OOP_REF>::oop_load_at(obj, java_lang_ref_Reference::referent_offset());\n+\n","filename":"src\/hotspot\/share\/cds\/aotReferenceObjSupport.cpp","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+  static bool is_enabled();\n","filename":"src\/hotspot\/share\/cds\/aotReferenceObjSupport.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotReferenceObjSupport.hpp\"\n@@ -5463,0 +5464,4 @@\n+  if (!AOTReferenceObjSupport::is_enabled() && klass->is_subclass_of(vmClasses::Reference_klass())) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}