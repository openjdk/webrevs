{"files":[{"patch":"@@ -37,0 +37,1 @@\n+#include \"runtime\/javaCalls.hpp\"\n@@ -53,1 +54,1 @@\n-\/\/ [1] A reference that does not require special clean up (i.e., Reference::queue == ReferenceQueue::NULL)\n+\/\/ [1] A reference that does not require special clean up (i.e., Reference::queue == _null_queue.resolve())\n@@ -56,1 +57,1 @@\n-\/\/ [2] A reference that REQUIRE specials clean up (i.e., Reference::queue != ReferenceQueue::NULL)\n+\/\/ [2] A reference that REQUIRE specials clean up (i.e., Reference::queue != _null_queue.resolve())\n@@ -64,1 +65,1 @@\n-\/\/ ReferencedKeyMap::prepareForAOTCache ensures that all keys found by AOTArtifactFinder are eligible.\n+\/\/ stabilize_cached_reference_objects() ensures that all keys found by AOTArtifactFinder are eligible.\n@@ -69,1 +70,0 @@\n-\/\/\n@@ -80,0 +80,2 @@\n+#if INCLUDE_CDS_JAVA_HEAP\n+\n@@ -88,1 +90,1 @@\n-  TempNewSymbol field_name = SymbolTable::new_symbol(\"NULL\");\n+  TempNewSymbol field_name = SymbolTable::new_symbol(\"N\"\"ULL\");\n@@ -97,0 +99,16 @@\n+\/\/ Ensure that all group [2] references found by AOTArtifactFinder are eligible.\n+void AOTReferenceObjSupport::stabilize_cached_reference_objects(TRAPS) {\n+  if (CDSConfig::is_dumping_method_handles()) {\n+    \/\/ This assert means that the MethodType and MethodTypeForm tables won't be\n+    \/\/ updated concurrently, so we can remove GC'ed entries ...\n+    assert(CDSConfig::allow_only_single_java_thread(), \"Required\");\n+\n+    TempNewSymbol method_name = SymbolTable::new_symbol(\"prepareForAOTCache\");\n+    JavaValue result(T_VOID);\n+    JavaCalls::call_static(&result, vmClasses::MethodType_klass(),\n+                           method_name,\n+                           vmSymbols::void_method_signature(),\n+                           CHECK);\n+  }\n+}\n+\n@@ -118,1 +136,1 @@\n-        log_error(cds, heap)(\"This object requires special clean up as its queue is not ReferenceQueue::NULL (\"\n+        log_error(cds, heap)(\"This object requires special clean up as its queue is not ReferenceQueue::N\" \"ULL (\"\n@@ -149,0 +167,2 @@\n+\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n","filename":"src\/hotspot\/share\/cds\/aotReferenceObjSupport.cpp","additions":26,"deletions":6,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+  static void stabilize_cached_reference_objects(TRAPS);\n","filename":"src\/hotspot\/share\/cds\/aotReferenceObjSupport.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -966,1 +966,1 @@\n-    AOTReferenceObjSupport::initialize(CHECK);\n+\n@@ -972,13 +972,2 @@\n-    if (CDSConfig::is_dumping_method_handles()) {\n-      \/\/ This assert means that the MethodType and MethodTypeForm tables won't be\n-      \/\/ updated concurrently, so we can remove GC'ed entries ...\n-      assert(CDSConfig::allow_only_single_java_thread(), \"Required\");\n-\n-      TempNewSymbol method_name = SymbolTable::new_symbol(\"prepareForAOTCache\");\n-      JavaValue result(T_VOID);\n-      JavaCalls::call_static(&result, vmClasses::MethodType_klass(),\n-                             method_name,\n-                             vmSymbols::void_method_signature(),\n-                             CHECK);\n-    }\n-\n+    AOTReferenceObjSupport::initialize(CHECK);\n+    AOTReferenceObjSupport::stabilize_cached_reference_objects(CHECK);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":3,"deletions":14,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -89,0 +91,11 @@\n+\n+        ToolOutput shouldMatch(String... regexps) {\n+            for (String regexp : regexps) {\n+                Pattern pattern = Pattern.compile(regexp, Pattern.MULTILINE);\n+                if (!pattern.matcher(output).find()) {\n+                    throw new RuntimeException(\"Pattern \\\"\" + regexp + \"\\\" missing from tool output\");\n+                }\n+            }\n+\n+            return this;\n+        }\n@@ -147,1 +160,1 @@\n-            .shouldContain(\"Unable to derive module descriptor for: .\/tmp.jar\");\n+            .shouldMatch(\"Unable to derive module descriptor for: .*\/tmp.jar\");\n","filename":"test\/setup_aot\/TestSetupAOT.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"}]}