{"files":[{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/aotReferenceObjSupport.hpp\"\n@@ -76,0 +77,1 @@\n+  AOTReferenceObjSupport::init_keep_alive_objs_table();\n","filename":"src\/hotspot\/share\/cds\/aotArtifactFinder.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"utilities\/resourceHash.hpp\"\n@@ -58,4 +59,1 @@\n-\/\/     is eligible ONLY if it has not been put into the \"pending\" state by the GC (See Reference.java).\n-\/\/\n-\/\/ AOTReferenceObjSupport::check_if_ref_obj() detects the \"pending\" state by checking the \"next\" and\n-\/\/ \"discovered\" fields of the oop.\n+\/\/     is eligible ONLY if its referent is not null.\n@@ -77,1 +75,1 @@\n-\/\/ -- implementing more prepareForAOTCache() operations for other use cases, and\/or\n+\/\/ -- implementing more assemblySetup() operations for other use cases, and\/or\n@@ -79,0 +77,15 @@\n+\/\/\n+\/\/\n+\/\/ null referents for group [1]\n+\/\/ ============================\n+\/\/\n+\/\/ Any cached reference R1 of group [1] is allowed to have a null referent.\n+\/\/ This can happen in the following situations:\n+\/\/    (a) R1.clear() was called by Java code during the assembly phase.\n+\/\/    (b) The referent has been collected, and R1 is in the \"pending\" state.\n+\/\/ In case (b), the \"next\" and \"discovered\" fields of the cached copy of R1 will\n+\/\/ be set to null. During the production run:\n+\/\/    - It would appear to the Java program as if immediately during VM start-up, the referent\n+\/\/      was collected and ReferenceThread completed processing of R1.\n+\/\/    - It would appear to the GC as if immediately during VM start-up, the Java program called\n+\/\/      R1.clear().\n@@ -82,0 +95,9 @@\n+\n+class KeepAliveObjectsTable : public ResourceHashtable<oop, bool,\n+    36137, \/\/ prime number\n+    AnyObj::C_HEAP,\n+    mtClassShared,\n+    HeapShared::oop_hash> {};\n+\n+static KeepAliveObjectsTable* _keep_alive_objs_table;\n+static OopHandle _keep_alive_objs_array;\n@@ -106,3 +128,4 @@\n-    TempNewSymbol method_name = SymbolTable::new_symbol(\"prepareForAOTCache\");\n-    JavaValue result(T_VOID);\n-    JavaCalls::call_static(&result, vmClasses::MethodType_klass(),\n+    {\n+      TempNewSymbol method_name = SymbolTable::new_symbol(\"assemblySetup\");\n+      JavaValue result(T_VOID);\n+      JavaCalls::call_static(&result, vmClasses::MethodType_klass(),\n@@ -112,0 +135,28 @@\n+    }\n+\n+    {\n+      Symbol* cds_name  = vmSymbols::jdk_internal_misc_CDS();\n+      Klass* cds_klass = SystemDictionary::resolve_or_fail(cds_name, true \/*throw error*\/,  CHECK);\n+      TempNewSymbol method_name = SymbolTable::new_symbol(\"getKeepAliveObjects\");\n+      TempNewSymbol method_sig = SymbolTable::new_symbol(\"()[Ljava\/lang\/Object;\");\n+      JavaValue result(T_OBJECT);\n+      JavaCalls::call_static(&result, cds_klass, method_name, method_sig, CHECK);\n+\n+      _keep_alive_objs_array = OopHandle(Universe::vm_global(), result.get_oop());\n+    }\n+  }\n+}\n+\n+void AOTReferenceObjSupport::init_keep_alive_objs_table() {\n+  assert_at_safepoint(); \/\/ _keep_alive_objs_table uses raw oops\n+  oop a = _keep_alive_objs_array.resolve();\n+  if (a != nullptr) {\n+    precond(a->is_objArray());\n+    precond(CDSConfig::is_dumping_method_handles());\n+    objArrayOop array = objArrayOop(a);\n+\n+    _keep_alive_objs_table = new (mtClass)KeepAliveObjectsTable();\n+    for (int i = 0; i < array->length(); i++) {\n+      oop obj = array->obj_at(i);\n+      _keep_alive_objs_table->put(obj, true); \/\/ The array may have duplicated entries but that's OK.\n+    }\n@@ -115,0 +166,1 @@\n+\/\/ Returns true IFF obj is an instance of java.lang.ref.Reference. If so, perform extra eligibility checks.\n@@ -119,0 +171,1 @@\n+  assert_at_safepoint(); \/\/ _keep_alive_objs_table uses raw oops\n@@ -125,0 +178,6 @@\n+    bool needs_special_cleanup = (queue != _null_queue.resolve());\n+\n+    \/\/ If you see the errors below, you probably modified the implementation of java.lang.invoke.\n+    \/\/ Please check the comments at the top of this file.\n+    if (needs_special_cleanup && (referent == nullptr || !_keep_alive_objs_table->contains(referent))) {\n+      ResourceMark rm;\n@@ -126,15 +185,13 @@\n-    if (next != nullptr || discovered != nullptr) {\n-      if (queue != _null_queue.resolve()) {\n-        ResourceMark rm;\n-        log_error(cds, heap)(\"Cannot archive reference object \" PTR_FORMAT \" of class %s\",\n-                             p2i(obj), obj->klass()->external_name());\n-        log_error(cds, heap)(\"referent = \" PTR_FORMAT\n-                             \", queue = \" PTR_FORMAT\n-                             \", next = \" PTR_FORMAT\n-                             \", discovered = \" PTR_FORMAT,\n-                             p2i(referent), p2i(queue), p2i(next), p2i(discovered));\n-        log_error(cds, heap)(\"This object requires special clean up as its queue is not ReferenceQueue::N\" \"ULL (\"\n-                             PTR_FORMAT \")\", p2i(_null_queue.resolve()));\n-        HeapShared::debug_trace();\n-        MetaspaceShared::unrecoverable_writing_error();\n-      }\n+      log_error(cds, heap)(\"Cannot archive reference object \" PTR_FORMAT \" of class %s\",\n+                           p2i(obj), obj->klass()->external_name());\n+      log_error(cds, heap)(\"referent = \" PTR_FORMAT\n+                           \", queue = \" PTR_FORMAT\n+                           \", next = \" PTR_FORMAT\n+                           \", discovered = \" PTR_FORMAT,\n+                           p2i(referent), p2i(queue), p2i(next), p2i(discovered));\n+      log_error(cds, heap)(\"This object requires special clean up as its queue is not ReferenceQueue::N\" \"ULL (\"\n+                           PTR_FORMAT \")\", p2i(_null_queue.resolve()));\n+      log_error(cds, heap)(\"%s\", (referent == nullptr) ?\n+                           \"referent cannot be null\" : \"referent is not registered with CDS.keepAlive()\");\n+      HeapShared::debug_trace();\n+      MetaspaceShared::unrecoverable_writing_error();\n","filename":"src\/hotspot\/share\/cds\/aotReferenceObjSupport.cpp","additions":80,"deletions":23,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+  static void init_keep_alive_objs_table();\n","filename":"src\/hotspot\/share\/cds\/aotReferenceObjSupport.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1387,1 +1387,1 @@\n-    private static void prepareForAOTCache() {\n+    private static void assemblySetup() {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -106,0 +106,9 @@\n+    \/\/ This is called by native JVM code at the very end of Java execution before\n+    \/\/ dumping the static archive.\n+    \/\/ It collects the objects from keepAliveList so that they can be easily processed\n+    \/\/ by the native JVM code to check that any Reference objects that need special\n+    \/\/ clean up must have been registed with keepAlive()\n+    private static Object[] getKeepAliveObjects() {\n+        return keepAliveList.toArray();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CDS.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+ *             WeakReferenceTestBadApp1 WeakReferenceTestBadApp2\n@@ -44,0 +45,1 @@\n+import jtreg.SkippedException;\n@@ -47,1 +49,4 @@\n-    static final String mainClass = \"WeakReferenceTestApp\";\n+\n+    static final String goodApp = \"WeakReferenceTestApp\";\n+    static final String badApp1 = \"WeakReferenceTestBadApp1\";\n+    static final String badApp2 = \"WeakReferenceTestBadApp2\";\n@@ -50,2 +55,13 @@\n-        Tester t = new Tester();\n-        t.run(args);\n+        new Tester(goodApp).run(args);\n+\n+        runBadApp(badApp1, args);\n+        runBadApp(badApp2, args);\n+    }\n+\n+    static void runBadApp(String badApp, String[] args) throws Exception {\n+        try {\n+            new Tester(badApp).run(args);\n+            throw new RuntimeException(badApp + \" did not fail in assembly phase as expected\");\n+        } catch (SkippedException e) {\n+            System.out.println(\"Negative test: expected SkippedException\");\n+        }\n@@ -55,1 +71,2 @@\n-        public Tester() {\n+        String mainClass;\n+        public Tester(String mainClass) {\n@@ -57,0 +74,5 @@\n+            this.mainClass = mainClass;\n+\n+            if (mainClass != goodApp) {\n+                setCheckExitValue(false);\n+            }\n@@ -69,1 +91,1 @@\n-                    \"-XX:AOTInitTestClass=WeakReferenceTestApp\",\n+                    \"-XX:AOTInitTestClass=\" + mainClass,\n@@ -89,0 +111,11 @@\n+            if (runMode == RunMode.ASSEMBLY && mainClass != goodApp) {\n+                out.shouldNotHaveExitValue(0);\n+                out.shouldMatch(\"Cannot archive reference object .* of class java.lang.ref.WeakReference\");\n+                if (mainClass == badApp1) {\n+                    out.shouldContain(\"referent cannot be null\");\n+                } else {\n+                    out.shouldContain(\"referent is not registered with CDS.keepAlive()\");\n+                }\n+                throw new SkippedException(\"Assembly phase expected to fail\");\n+            }\n+\n@@ -96,2 +129,1 @@\n-    \/\/ This class is NOT aot-initialized\n-    static class Inner {\n+    static class Inner { \/\/ This class is NOT aot-initialized\n@@ -251,0 +283,27 @@\n+\n+class WeakReferenceTestBadApp1 {\n+    static WeakReference refWithQueue;\n+    static SharedQueue sharedQueueInstance;\n+\n+    static {\n+        \/\/ See comments in aotReferenceObjSupport.cpp: group [2] references cannot have null referent.\n+        sharedQueueInstance = SharedQueue.sharedQueueInstance;\n+        refWithQueue = new WeakReference(String.class, SharedQueue.queue());\n+        refWithQueue.clear();\n+    }\n+\n+    public static void main(String args[]) {}\n+}\n+\n+class WeakReferenceTestBadApp2 {\n+    static WeakReference refWithQueue;\n+    static SharedQueue sharedQueueInstance;\n+\n+    static {\n+        \/\/ See comments in aotReferenceObjSupport.cpp: group [2] references must be registered with CDS.keepAlive()\n+        sharedQueueInstance = SharedQueue.sharedQueueInstance;\n+        refWithQueue = new WeakReference(String.class, SharedQueue.queue());\n+    }\n+\n+    public static void main(String args[]) {}\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/WeakReferenceTest.java","additions":66,"deletions":7,"binary":false,"changes":73,"status":"modified"}]}