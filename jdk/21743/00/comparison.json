{"files":[{"patch":"@@ -676,1 +676,2 @@\n-                writer.writeLoadConstant(op, constantEntry());\n+                \/\/ We have writer.canWriteDirect(constantEntry().constantPool()) == false\n+                writer.writeAdaptLoadConstant(op, constantEntry());\n@@ -1349,1 +1350,6 @@\n-            writer.writeLoadConstant(op, constant);\n+            var constant = this.constant;\n+            if (writer.canWriteDirect(constant.constantPool()))\n+                \/\/ Allows writing ldc_w small index constants upon user request\n+                writer.writeDirectLoadConstant(op, constant);\n+            else\n+                writer.writeAdaptLoadConstant(op, constant);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractInstruction.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -673,8 +673,8 @@\n-    public void writeLoadConstant(Opcode opcode, LoadableConstantEntry value) {\n-        \/\/ Make sure Long and Double have LDC2_W and\n-        \/\/ rewrite to _W if index is >= 256\n-        int index = AbstractPoolEntry.maybeClone(constantPool, value).index();\n-        if (value instanceof LongEntry || value instanceof DoubleEntry) {\n-            opcode = Opcode.LDC2_W;\n-        } else if (index >= 256)\n-            opcode = Opcode.LDC_W;\n+    \/\/ value may not be writable to this constant pool\n+    public void writeAdaptLoadConstant(Opcode opcode, LoadableConstantEntry value) {\n+        var pe = AbstractPoolEntry.maybeClone(constantPool, value);\n+        int index = pe.index();\n+        if (pe != value && opcode != Opcode.LDC2_W) {\n+            \/\/ rewrite ldc\/ldc_w if external entry; ldc2_w never needs rewrites\n+            opcode = index <= 0xFF ? Opcode.LDC : Opcode.LDC_W;\n+        }\n@@ -682,1 +682,7 @@\n-        assert !opcode.isWide();\n+        writeDirectLoadConstant(opcode, pe);\n+    }\n+\n+    \/\/ the loadable entry is writable to this constant pool\n+    public void writeDirectLoadConstant(Opcode opcode, LoadableConstantEntry pe) {\n+        assert !opcode.isWide() && canWriteDirect(pe.constantPool());\n+        int index = pe.index();\n@@ -1657,1 +1663,2 @@\n-        writeLoadConstant(BytecodeHelpers.ldcOpcode(entry), entry);\n+        var direct = AbstractPoolEntry.maybeClone(constantPool, entry);\n+        writeDirectLoadConstant(BytecodeHelpers.ldcOpcode(direct), direct);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+ * @bug 8342458\n+ * @library \/test\/lib\n@@ -29,1 +31,0 @@\n-import java.lang.constant.ClassDesc;\n@@ -31,6 +32,5 @@\n-import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n-import static java.lang.classfile.ClassFile.ACC_STATIC;\n-import static java.lang.constant.ConstantDescs.*;\n-import java.lang.constant.MethodTypeDesc;\n-\n-import java.lang.classfile.*;\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.Instruction;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.attribute.CodeAttribute;\n@@ -38,0 +38,1 @@\n+import java.lang.classfile.constantpool.LongEntry;\n@@ -39,0 +40,6 @@\n+import java.lang.classfile.instruction.ConstantInstruction;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -40,1 +47,3 @@\n-import static org.junit.jupiter.api.Assertions.*;\n+import java.util.List;\n+\n+import jdk.test.lib.ByteCodeLoader;\n@@ -42,1 +51,2 @@\n-import static helpers.TestConstants.MTD_VOID;\n+\n+import static java.lang.classfile.ClassFile.*;\n@@ -44,1 +54,2 @@\n-import java.lang.classfile.instruction.ConstantInstruction;\n+import static java.lang.constant.ConstantDescs.*;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -48,11 +59,9 @@\n-    void testLDCisConvertedToLDCW() throws Exception {\n-        var cc = ClassFile.of();\n-        byte[] bytes = cc.build(ClassDesc.of(\"MyClass\"), cb -> {\n-            cb.withFlags(AccessFlag.PUBLIC);\n-            cb.withVersion(52, 0);\n-            cb.withMethod(\"<init>\", MethodTypeDesc.of(CD_void), 0, mb -> mb\n-                      .withCode(codeb -> codeb.aload(0)\n-                                              .invokespecial(CD_Object, \"<init>\", MTD_VOID, false)\n-                                              .return_()\n-                      )\n-              )\n+    void loadConstantGeneralTest() throws Exception {\n+        var otherCp = ConstantPoolBuilder.of();\n+        var narrowString131 = otherCp.stringEntry(\"string131\");\n+        assertTrue(narrowString131.index() <= 0xFF);\n+        for (int i = 0; i < 0xFF; i++) {\n+            var unused = otherCp.intEntry(i);\n+        }\n+        var wideString0 = otherCp.stringEntry(\"string0\");\n+        assertTrue(wideString0.index() > 0xFF);\n@@ -60,18 +69,43 @@\n-              .withMethod(\"main\", MethodTypeDesc.of(CD_void, CD_String.arrayType()),\n-                          ACC_PUBLIC | ACC_STATIC,\n-                          mb -> mb.withCode(c0 -> {\n-                                  ConstantPoolBuilder cpb = cb.constantPool();\n-                                  for (int i = 0; i <= 256\/2 + 2; i++) { \/\/ two entries per String\n-                                      StringEntry s = cpb.stringEntry(\"string\" + i);\n-                                  }\n-                                  c0.ldc(\"string0\")\n-                                    .ldc(\"string131\")\n-                                    .ldc(\"string50\")\n-                                    .loadConstant(-0.0f)\n-                                    .loadConstant(-0.0d)\n-                                    \/\/non-LDC test cases\n-                                    .loadConstant(0.0f)\n-                                    .loadConstant(0.0d)\n-                                    .return_();\n-                              }));\n-        });\n+        var cc = ClassFile.of();\n+        var cd = ClassDesc.of(\"MyClass\");\n+        MethodTypeDesc bsmType = MethodTypeDesc.of(CD_double, CD_MethodHandles_Lookup, CD_String, CD_Class);\n+        byte[] bytes = cc.build(cd, cb -> cb\n+                .withFlags(AccessFlag.PUBLIC)\n+                .withVersion(JAVA_11_VERSION, 0) \/\/ condy support required\n+                .withMethodBody(\"bsm\", bsmType, ACC_STATIC, cob -> cob\n+                    .dconst_1()\n+                    .dreturn())\n+                .withMethodBody(\"main\", MethodTypeDesc.of(CD_void, CD_String.arrayType()),\n+                        ACC_PUBLIC | ACC_STATIC, c0 -> {\n+                            ConstantPoolBuilder cpb = cb.constantPool();\n+                            LongEntry l42 = cpb.longEntry(42);\n+                            assertTrue(l42.index() <= 0xFF);\n+                            for (int i = 0; i <= 256 \/ 2 + 2; i++) { \/\/ two entries per String\n+                                StringEntry s = cpb.stringEntry(\"string\" + i);\n+                            }\n+                            var wideCondy = cpb.constantDynamicEntry(DynamicConstantDesc.of(MethodHandleDesc.ofMethod(\n+                                    DirectMethodHandleDesc.Kind.STATIC, cd, \"bsm\", bsmType)));\n+                            assertTrue(wideCondy.index() > 0xFF);\n+                            var s0 = cpb.stringEntry(\"string0\");\n+                            assertTrue(s0.index() <= 0xFF);\n+                            \/\/ use line number to match case numbers; pop ensures verification passes\n+                            c0.ldc(\"string0\").pop() \/\/ regular ldc\n+                              .ldc(wideString0).pop() \/\/ adaption - narrowed\n+                              .with(ConstantInstruction.ofLoad(LDC, wideString0)).pop() \/\/ adaption\n+                              .with(ConstantInstruction.ofLoad(LDC_W, wideString0)).pop() \/\/ adaption - narrowed\n+                              .with(ConstantInstruction.ofLoad(LDC_W, s0)).pop() \/\/ explicit ldc_w - local\n+                              .ldc(\"string131\").pop() \/\/ ldc_w\n+                              .ldc(narrowString131).pop() \/\/ adaption - widened\n+                              .with(ConstantInstruction.ofLoad(LDC, narrowString131)).pop() \/\/ adaption - widened\n+                              .with(ConstantInstruction.ofLoad(LDC_W, narrowString131)).pop() \/\/ adaption\n+                              .ldc(\"string50\").pop()\n+                              .ldc(l42).pop2() \/\/ long cases\n+                              .loadConstant(l42.longValue()).pop2()\n+                              .loadConstant(Long.valueOf(l42.longValue())).pop2()\n+                              .loadConstant(-0.0f).pop() \/\/ floating cases\n+                              .loadConstant(-0.0d).pop2()\n+                              .loadConstant(0.0f).pop() \/\/ intrinsic cases\n+                              .loadConstant(0.0d).pop2()\n+                              .ldc(wideCondy).pop2() \/\/ no wrong \"widening\" of condy\n+                              .return_();\n+                        }));\n@@ -79,8 +113,7 @@\n-        var model = cc.parse(bytes);\n-        var code = model.elementStream()\n-                .filter(e -> e instanceof MethodModel)\n-                .map(e -> (MethodModel) e)\n-                .filter(e -> e.methodName().stringValue().equals(\"main\"))\n-                .flatMap(MethodModel::elementStream)\n-                .filter(e -> e instanceof CodeModel)\n-                .map(e -> (CodeModel) e)\n+        var cm = cc.parse(bytes);\n+        var code = cm.elementStream()\n+                .<CodeAttribute>mapMulti((ce, sink) -> {\n+                    if (ce instanceof MethodModel mm && mm.methodName().equalsString(\"main\")) {\n+                        sink.accept(mm.findAttribute(Attributes.code()).orElseThrow());\n+                    }\n+                })\n@@ -89,4 +122,7 @@\n-        var opcodes = code.elementList().stream()\n-                          .filter(e -> e instanceof Instruction)\n-                          .map(e -> (Instruction)e)\n-                          .toList();\n+        var instructions = code.elementList().stream()\n+                .<ConstantInstruction>mapMulti((ce, sink) -> {\n+                    if (ce instanceof ConstantInstruction i) {\n+                        sink.accept(i);\n+                    }\n+                })\n+                .toList();\n@@ -94,4 +130,28 @@\n-        assertEquals(opcodes.size(), 8);\n-        assertEquals(opcodes.get(0).opcode(), LDC);\n-        assertEquals(opcodes.get(1).opcode(), LDC_W);\n-        assertEquals(opcodes.get(2).opcode(), LDC);\n+        assertIterableEquals(List.of(\n+                LDC, \/\/ string0\n+                LDC,\n+                LDC,\n+                LDC,\n+                LDC_W,\n+                LDC_W, \/\/ string131\n+                LDC_W,\n+                LDC_W,\n+                LDC_W,\n+                LDC, \/\/ string50\n+                LDC2_W, \/\/ long cases\n+                LDC2_W,\n+                LDC2_W,\n+                LDC_W, \/\/ floating cases\n+                LDC2_W,\n+                FCONST_0, \/\/ intrinsic cases\n+                DCONST_0,\n+                LDC2_W \/\/ wide condy\n+        ), instructions.stream().map(Instruction::opcode).toList());\n+\n+        int longCaseStart = 10;\n+        for (int longCaseIndex = longCaseStart; longCaseIndex < longCaseStart + 3; longCaseIndex++) {\n+            var message = \"Case \" + longCaseIndex;\n+            assertEquals(42, (long) instructions.get(longCaseIndex).constantValue(), message);\n+        }\n+\n+        int floatingCaseStart = longCaseStart + 3;\n@@ -99,1 +159,1 @@\n-                Float.floatToRawIntBits((float)((ConstantInstruction)opcodes.get(3)).constantValue()),\n+                Float.floatToRawIntBits((float) instructions.get(floatingCaseStart).constantValue()),\n@@ -102,1 +162,1 @@\n-                Double.doubleToRawLongBits((double)((ConstantInstruction)opcodes.get(4)).constantValue()),\n+                Double.doubleToRawLongBits((double) instructions.get(floatingCaseStart + 1).constantValue()),\n@@ -104,4 +164,0 @@\n-        assertEquals(opcodes.get(5).opcode(), FCONST_0);\n-        assertEquals(opcodes.get(6).opcode(), DCONST_0);\n-        assertEquals(opcodes.get(7).opcode(), RETURN);\n-    }\n@@ -109,2 +165,3 @@\n-    \/\/ TODO test for explicit LDC_W?\n-}\n\\ No newline at end of file\n+        assertDoesNotThrow(() -> ByteCodeLoader.load(\"MyClass\", bytes), \"Invalid LDC bytecode generated\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/LDCTest.java","additions":120,"deletions":63,"binary":false,"changes":183,"status":"modified"}]}