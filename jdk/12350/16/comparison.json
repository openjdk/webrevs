{"files":[{"patch":"@@ -542,0 +542,2 @@\n+    DEBUG_ONLY(verify_packs();)\n+\n@@ -645,45 +647,3 @@\n-    bool create_pack = true;\n-    if (memory_alignment(mem_ref, best_iv_adjustment) == 0 || _do_vector_loop) {\n-      if (vectors_should_be_aligned()) {\n-        int vw = vector_width(mem_ref);\n-        int vw_best = vector_width(best_align_to_mem_ref);\n-        if (vw > vw_best) {\n-          \/\/ Do not vectorize a memory access with more elements per vector\n-          \/\/ if unaligned memory access is not allowed because number of\n-          \/\/ iterations in pre-loop will be not enough to align it.\n-          create_pack = false;\n-        } else {\n-          SWPointer p2(best_align_to_mem_ref, this, NULL, false);\n-          if (!align_to_ref_p.invar_equals(p2)) {\n-            \/\/ Do not vectorize memory accesses with different invariants\n-            \/\/ if unaligned memory accesses are not allowed.\n-            create_pack = false;\n-          }\n-        }\n-      }\n-    } else {\n-      if (same_velt_type(mem_ref, best_align_to_mem_ref)) {\n-        \/\/ Can't allow vectorization of unaligned memory accesses with the\n-        \/\/ same type since it could be overlapped accesses to the same array.\n-        create_pack = false;\n-      } else {\n-        \/\/ Allow independent (different type) unaligned memory operations\n-        \/\/ if HW supports them.\n-        if (vectors_should_be_aligned()) {\n-          create_pack = false;\n-        } else {\n-          \/\/ Check if packs of the same memory type but\n-          \/\/ with a different alignment were created before.\n-          for (uint i = 0; i < align_to_refs.size(); i++) {\n-            MemNode* mr = align_to_refs.at(i)->as_Mem();\n-            if (mr == mem_ref) {\n-              \/\/ Skip when we are looking at same memory operation.\n-              continue;\n-            }\n-            if (same_velt_type(mr, mem_ref) &&\n-                memory_alignment(mr, iv_adjustment) != 0)\n-              create_pack = false;\n-          }\n-        }\n-      }\n-    }\n+    bool create_pack = is_mem_ref_alignment_ok(mem_ref, iv_adjustment, align_to_ref_p,\n+                                               best_align_to_mem_ref, best_iv_adjustment,\n+                                               align_to_refs);\n@@ -797,0 +757,78 @@\n+\/\/ Check if alignment of mem_ref permissible on hardware, and if it is consistent with\n+\/\/ the other packs of same velt type.\n+bool SuperWord::is_mem_ref_alignment_ok(MemNode* mem_ref, int iv_adjustment, SWPointer &align_to_ref_p,\n+                                        MemNode* best_align_to_mem_ref, int best_iv_adjustment,\n+                                        Node_List &align_to_refs) {\n+  bool is_aligned_with_best = memory_alignment(mem_ref, best_iv_adjustment) == 0;\n+\n+  if (vectors_should_be_aligned()) {\n+    \/\/ All vectors need to be vector length aligned. We use best_align_to_mem_ref to adjust\n+    \/\/ the pre-loop limit such that all vector memory accesses are vector aligned. Hence, we\n+    \/\/ must ensure that all mem_refs that we vectorize are aligned with best_align_to_mem_ref.\n+    \/\/ These 3 conditions must be fulfilled:\n+    \/\/ (1) All packs are aligned with best_align_to_mem_ref.\n+    if (!is_aligned_with_best) {\n+      return false;\n+    }\n+    \/\/ (2) All other vectors have vector_size less or equal to that of best_align_to_mem_ref.\n+    int vw = vector_width(mem_ref);\n+    int vw_best = vector_width(best_align_to_mem_ref);\n+    if (vw > vw_best) {\n+      \/\/ Do not vectorize a memory access with more elements per vector\n+      \/\/ if unaligned memory access is not allowed because number of\n+      \/\/ iterations in pre-loop will be not enough to align it.\n+      return false;\n+    }\n+    \/\/ (3) Ensure that all vectors have the same invariant. We model memory accesses like this\n+    \/\/     address = base + k*iv + constant [+ invar]\n+    \/\/     memory_alignment ignores the invariant.\n+    SWPointer p2(best_align_to_mem_ref, this, nullptr, false);\n+    if (!align_to_ref_p.invar_equals(p2)) {\n+      \/\/ Do not vectorize memory accesses with different invariants\n+      \/\/ if unaligned memory accesses are not allowed.\n+      return false;\n+    }\n+    return true;\n+  } else {\n+    \/\/ Alignment is not required by the hardware. However, we still have to make sure that\n+    \/\/ the memory accesses do not form a cyclic dependency.\n+\n+    \/\/ We have a compiler hint, so do not check alignment with other packs. For now we trust\n+    \/\/ the hint. We may create cyclic dependencies (packs that are not independent). Later\n+    \/\/ we will filter out packs that are not internally independent.\n+    \/\/ This allows us to vectorize cases like this (forward read):\n+    \/\/ for (int i ...) { v[i] = v[i + 1] + 5; }\n+    \/\/ And the filtering still removes non-vectorizable cases like this (forward write):\n+    \/\/ for (int i ...) { v[i + 1] = v[i] + 5; }\n+    if (_do_vector_loop) {\n+      return true;\n+    }\n+\n+    \/\/ An easy way to prevent cyclic dependencies is to require all mem_refs of the same type\n+    \/\/ to be exactly aligned. This allows us to vectorize these cases:\n+    \/\/ for (int i ...) { v[i] = v[i] + 5; }      \/\/ same alignment\n+    \/\/ for (int i ...) { v[i] = v[i + 32] + 5; } \/\/ alignment modulo vector size\n+    if (same_velt_type(mem_ref, best_align_to_mem_ref)) {\n+      return is_aligned_with_best;\n+    } else {\n+      return is_mem_ref_aligned_with_same_velt_type(mem_ref, iv_adjustment, align_to_refs);\n+    }\n+  }\n+}\n+\n+\/\/ Check if alignment of mem_ref is consistent with the other packs of same velt type.\n+bool SuperWord::is_mem_ref_aligned_with_same_velt_type(MemNode* mem_ref, int iv_adjustment,\n+                                                       Node_List &align_to_refs) {\n+  for (uint i = 0; i < align_to_refs.size(); i++) {\n+    MemNode* mr = align_to_refs.at(i)->as_Mem();\n+    if (mr != mem_ref &&\n+        same_velt_type(mr, mem_ref) &&\n+        memory_alignment(mr, iv_adjustment) != 0) {\n+      \/\/ mem_ref is misaligned with mr, another ref of the same velt type.\n+      return false;\n+    }\n+  }\n+  \/\/ No misalignment found.\n+  return true;\n+}\n+\n@@ -1329,0 +1367,38 @@\n+\/\/------------------------------find_dependence---------------------\n+\/\/ Is any s1 in p dependent on any s2 in p? Yes: return such a s2. No: return nullptr.\n+\/\/ We could query independent(s1, s2) for all pairs, but that results\n+\/\/ in O(p.size * p.size) graph traversals. We can do it all in one BFS!\n+\/\/ Start the BFS traversal at all nodes from the pack. Traverse DepPreds\n+\/\/ recursively, for nodes that have at least depth min_d, which is the\n+\/\/ smallest depth of all nodes from the pack. Once we have traversed all\n+\/\/ those nodes, and have not found another node from the pack, we know\n+\/\/ that all nodes in the pack are independent.\n+Node* SuperWord::find_dependence(Node_List* p) {\n+  if (p->at(0)->is_reduction()) {\n+    return nullptr; \/\/ ignore reductions\n+  }\n+  ResourceMark rm;\n+  Unique_Node_List worklist; \/\/ traversal queue\n+  int min_d = depth(p->at(0));\n+  visited_clear();\n+  for (uint k = 0; k < p->size(); k++) {\n+    Node* n = p->at(k);\n+    min_d = MIN2(min_d, depth(n));\n+    worklist.push(n); \/\/ start traversal at all nodes in p\n+    visited_set(n); \/\/ mark node\n+  }\n+  for (uint i = 0; i < worklist.size(); i++) {\n+    Node* n = worklist.at(i);\n+    for (DepPreds preds(n, _dg); !preds.done(); preds.next()) {\n+      Node* pred = preds.current();\n+      if (in_bb(pred) && depth(pred) >= min_d) {\n+        if (visited_test(pred)) { \/\/ marked as in p?\n+          return pred;\n+        }\n+        worklist.push(pred);\n+      }\n+    }\n+  }\n+  return nullptr;\n+}\n+\n@@ -1486,1 +1562,2 @@\n-    if (!in_bb(t1) || !in_bb(t2))\n+    if (!in_bb(t1) || !in_bb(t2) || t1->is_Mem() || t2->is_Mem())  {\n+      \/\/ Only follow non-memory nodes in block - we do not want to resurrect misaligned packs.\n@@ -1488,0 +1565,1 @@\n+    }\n@@ -1525,1 +1603,4 @@\n-    if (!in_bb(t1)) continue;\n+    if (!in_bb(t1) || t1->is_Mem()) {\n+      \/\/ Only follow non-memory nodes in block - we do not want to resurrect misaligned packs.\n+      continue;\n+    }\n@@ -1528,1 +1609,4 @@\n-      if (!in_bb(t2)) continue;\n+      if (!in_bb(t2) || t2->is_Mem()) {\n+        \/\/ Only follow non-memory nodes in block - we do not want to resurrect misaligned packs.\n+        continue;\n+      }\n@@ -1717,1 +1801,0 @@\n-        if (i == j) continue;\n@@ -1758,0 +1841,26 @@\n+  if (_do_vector_loop) {\n+    \/\/ Since we did not enforce exact alignment of the packsets, we only know that there\n+    \/\/ is no dependence with distance 1, because we have checked independent(s1, s2) for\n+    \/\/ all adjacent memops. But there could be a dependence of a different distance.\n+    \/\/ Hence: remove the pack if there is a dependence.\n+    for (int i = 0; i < _packset.length(); i++) {\n+      Node_List* p = _packset.at(i);\n+      if (p != nullptr) {\n+        Node* dependence = find_dependence(p);\n+        if (dependence != nullptr) {\n+#ifndef PRODUCT\n+          if (TraceSuperWord) {\n+            tty->cr();\n+            tty->print_cr(\"WARNING: Found dependency.\");\n+            tty->print_cr(\"Cannot vectorize despite compile directive Vectorize.\");\n+            dependence->dump();\n+            tty->print_cr(\"In pack[%d]\", i);\n+            print_pack(p);\n+          }\n+#endif\n+          _packset.at_put(i, nullptr);\n+        }\n+      }\n+    }\n+  }\n+\n@@ -1776,1 +1885,0 @@\n-  Node_List* rslt = NULL;\n@@ -2206,0 +2314,23 @@\n+#ifdef ASSERT\n+void SuperWord::verify_packs() {\n+  for (int i = 0; i < _packset.length(); i++) {\n+    Node_List* p = _packset.at(i);\n+    Node* dependence = find_dependence(p);\n+    if (dependence != nullptr) {\n+      tty->print_cr(\"Other nodes in pack have dependence on:\");\n+      dependence->dump();\n+      tty->print_cr(\"The following nodes are not independent:\");\n+      for (uint k = 0; k < p->size(); k++) {\n+        Node* n = p->at(k);\n+        if (!independent(n, dependence)) {\n+          n->dump();\n+        }\n+      }\n+      tty->print_cr(\"They are all from pack[%d]\", i);\n+      print_pack(p);\n+    }\n+    assert(dependence == nullptr, \"all nodes in pack must be mutually independent\");\n+  }\n+}\n+#endif\n+\n@@ -4026,1 +4157,5 @@\n-    print_pack(p);\n+    if (p == nullptr) {\n+      tty->print_cr(\"  nullptr\");\n+    } else {\n+      print_pack(p);\n+    }\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":186,"deletions":51,"binary":false,"changes":237,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -478,0 +478,6 @@\n+  \/\/ Check if alignment of mem_ref permissible on hardware, and if it is consistent with the other packs of same velt type.\n+  bool is_mem_ref_alignment_ok(MemNode* mem_ref, int iv_adjustment, SWPointer &align_to_ref_p,\n+                               MemNode* best_align_to_mem_ref, int best_iv_adjustment,\n+                               Node_List &align_to_refs);\n+  \/\/ Check if alignment of mem_ref is consistent with the other packs of same velt type.\n+  bool is_mem_ref_aligned_with_same_velt_type(MemNode* mem_ref, int iv_adjustment, Node_List &align_to_refs);\n@@ -514,0 +520,2 @@\n+  \/\/ Is any s1 in p dependent on any s2 in p? Yes: return such a s2. No: return nullptr.\n+  Node* find_dependence(Node_List* p);\n@@ -545,0 +553,2 @@\n+  \/\/ Verify that for every pack, all nodes are mutually independent\n+  DEBUG_ONLY(void verify_packs();)\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -169,0 +169,5 @@\n+    public static final String ADD_VF = PREFIX + \"ADD_VF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ADD_VF, \"AddVF\");\n+    }\n+\n@@ -184,0 +189,5 @@\n+    public static final String ADD_REDUCTION_VI = PREFIX + \"ADD_REDUCTION_VI\" + POSTFIX;\n+    static {\n+        superWordNodes(ADD_REDUCTION_VI, \"AddReductionVI\");\n+    }\n+\n@@ -702,0 +712,5 @@\n+    public static final String MUL_VI = PREFIX + \"MUL_VI\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_VI, \"MulVI\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,399 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8298935\n+ * @summary Writing forward on array creates cyclic dependency\n+ *          which leads to wrong result, when ignored.\n+ * @requires vm.compiler2.enabled\n+ * @library \/test\/lib \/\n+ * @run driver TestCyclicDependency\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+public class TestCyclicDependency {\n+    static final int RANGE = 512;\n+    static final int ITER  = 100;\n+    int[] goldI0 = new int[RANGE];\n+    float[] goldF0 = new float[RANGE];\n+    int[] goldI1 = new int[RANGE];\n+    float[] goldF1 = new float[RANGE];\n+    int[] goldI2 = new int[RANGE];\n+    float[] goldF2 = new float[RANGE];\n+    int[] goldI3 = new int[RANGE];\n+    float[] goldF3 = new float[RANGE];\n+    int[] goldI4 = new int[RANGE];\n+    float[] goldF4 = new float[RANGE];\n+    int[] goldI5a = new int[RANGE];\n+    float[] goldF5a = new float[RANGE];\n+    int[] goldI5b = new int[RANGE];\n+    float[] goldF5b = new float[RANGE];\n+    int[] goldI6a = new int[RANGE];\n+    float[] goldF6a = new float[RANGE];\n+    int[] goldI6b = new int[RANGE];\n+    float[] goldF6b = new float[RANGE];\n+    int[] goldI7 = new int[RANGE];\n+    float[] goldF7 = new float[RANGE];\n+    int[] goldI8 = new int[RANGE];\n+    float[] goldF8 = new float[RANGE];\n+    int[] goldI9 = new int[RANGE];\n+    float[] goldF9 = new float[RANGE];\n+\n+    public static void main(String args[]) {\n+        TestFramework.runWithFlags(\"-XX:CompileCommand=compileonly,TestCyclicDependency::test*\");\n+    }\n+\n+    TestCyclicDependency() {\n+        \/\/ compute the gold standard in interpreter mode\n+        \/\/ test0\n+        init(goldI0, goldF0);\n+        test0(goldI0, goldF0);\n+        \/\/ test1\n+        init(goldI1, goldF1);\n+        test1(goldI1, goldF1);\n+        \/\/ test2\n+        init(goldI2, goldF2);\n+        test2(goldI2, goldF2);\n+        \/\/ test3\n+        init(goldI3, goldF3);\n+        test3(goldI3, goldF3);\n+        \/\/ test4\n+        init(goldI4, goldF4);\n+        test4(goldI4, goldF4);\n+        \/\/ test5a\n+        init(goldI5a, goldF5a);\n+        test5a(goldI5a, goldF5a);\n+        \/\/ test5b\n+        init(goldI5b, goldF5b);\n+        test5b(goldI5b, goldF5b);\n+        \/\/ test6a\n+        init(goldI6a, goldF6a);\n+        test6a(goldI6a, goldF6a);\n+        \/\/ test6b\n+        init(goldI6b, goldF6b);\n+        test6b(goldI6b, goldF6b);\n+        \/\/ test7\n+        init(goldI7, goldF7);\n+        test7(goldI7, goldF7);\n+        \/\/ test8\n+        init(goldI8, goldF8);\n+        test8(goldI8, goldF8);\n+        \/\/ test9\n+        init(goldI9, goldF9);\n+        test9(goldI9, goldF9);\n+    }\n+\n+    @Run(test = \"test0\")\n+    @Warmup(100)\n+    public void runTest0() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test0(dataI, dataF);\n+        verifyI(\"test0\", dataI, goldI0);\n+        verifyF(\"test0\", dataF, goldF0);\n+    }\n+\n+    @Run(test = \"test1\")\n+    @Warmup(100)\n+    public void runTest1() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test1(dataI, dataF);\n+        verifyI(\"test1\", dataI, goldI1);\n+        verifyF(\"test1\", dataF, goldF1);\n+    }\n+\n+    @Run(test = \"test2\")\n+    @Warmup(100)\n+    public void runTest2() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test2(dataI, dataF);\n+        verifyI(\"test2\", dataI, goldI2);\n+        verifyF(\"test2\", dataF, goldF2);\n+    }\n+\n+    @Run(test = \"test3\")\n+    @Warmup(100)\n+    public void runTest3() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test3(dataI, dataF);\n+        verifyI(\"test3\", dataI, goldI3);\n+        verifyF(\"test3\", dataF, goldF3);\n+    }\n+\n+    @Run(test = \"test4\")\n+    @Warmup(100)\n+    public void runTest4() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test4(dataI, dataF);\n+        verifyI(\"test4\", dataI, goldI4);\n+        verifyF(\"test4\", dataF, goldF4);\n+    }\n+\n+    @Run(test = \"test5a\")\n+    @Warmup(100)\n+    public void runTest5a() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test5a(dataI, dataF);\n+        verifyI(\"test5a\", dataI, goldI5a);\n+        verifyF(\"test5a\", dataF, goldF5a);\n+    }\n+\n+    @Run(test = \"test5b\")\n+    @Warmup(100)\n+    public void runTest5b() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test5b(dataI, dataF);\n+        verifyI(\"test5b\", dataI, goldI5b);\n+        verifyF(\"test5b\", dataF, goldF5b);\n+    }\n+\n+    @Run(test = \"test6a\")\n+    @Warmup(100)\n+    public void runTest6a() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test6a(dataI, dataF);\n+        verifyI(\"test6a\", dataI, goldI6a);\n+        verifyF(\"test6a\", dataF, goldF6a);\n+    }\n+\n+    @Run(test = \"test6b\")\n+    @Warmup(100)\n+    public void runTest6b() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test6b(dataI, dataF);\n+        verifyI(\"test6b\", dataI, goldI6b);\n+        verifyF(\"test6b\", dataF, goldF6b);\n+    }\n+\n+    @Run(test = \"test7\")\n+    @Warmup(100)\n+    public void runTest7() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test7(dataI, dataF);\n+        verifyI(\"test7\", dataI, goldI7);\n+        verifyF(\"test7\", dataF, goldF7);\n+    }\n+\n+    @Run(test = \"test8\")\n+    @Warmup(100)\n+    public void runTest8() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test8(dataI, dataF);\n+        verifyI(\"test8\", dataI, goldI8);\n+        verifyF(\"test8\", dataF, goldF8);\n+    }\n+\n+    @Run(test = \"test9\")\n+    @Warmup(100)\n+    public void runTest9() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test9(dataI, dataF);\n+        verifyI(\"test9\", dataI, goldI9);\n+        verifyF(\"test9\", dataF, goldF9);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test0(int[] dataI, float[] dataF) {\n+        for (int i = 0; i < RANGE; i++) {\n+            \/\/ All perfectly aligned, expect vectorization\n+            int v = dataI[i];\n+            dataI[i] = v + 5;\n+        }\n+    }\n+\n+    @Test\n+    static void test1(int[] dataI, float[] dataF) {\n+        for (int i = 0; i < RANGE - 1; i++) {\n+            \/\/ dataI has cyclic dependency of distance 1\n+            int v = dataI[i];\n+            dataI[i + 1] = v;\n+            dataF[i] = v; \/\/ let's not get confused by another type\n+        }\n+    }\n+\n+    @Test\n+    static void test2(int[] dataI, float[] dataF) {\n+        for (int i = 0; i < RANGE - 2; i++) {\n+            \/\/ dataI has cyclic dependency of distance 2\n+            int v = dataI[i];\n+            dataI[i + 2] = v;\n+            dataF[i] = v; \/\/ let's not get confused by another type\n+        }\n+    }\n+\n+    @Test\n+    static void test3(int[] dataI, float[] dataF) {\n+        for (int i = 0; i < RANGE - 3; i++) {\n+            \/\/ dataI has cyclic dependency of distance 3\n+            int v = dataI[i];\n+            dataI[i + 3] = v;\n+            dataF[i] = v; \/\/ let's not get confused by another type\n+        }\n+    }\n+\n+    @Test\n+    static void test4(int[] dataI, float[] dataF) {\n+        for (int i = 1; i < RANGE - 1; i++) {\n+            \/\/ dataI has cyclic dependency of distance 2\n+            int v = dataI[i - 1];\n+            dataI[i + 1] = v;\n+            dataF[i] = v; \/\/ let's not get confused by another type\n+        }\n+    }\n+\n+    @Test\n+    static void test5a(int[] dataI, float[] dataF) {\n+        for (int i = 2; i < RANGE; i++) {\n+            \/\/ dataI has read \/ write distance 1, but no cyclic dependency\n+            int v = dataI[i];\n+            dataI[i - 1] = v + 5;\n+        }\n+    }\n+\n+    @Test\n+    static void test5b(int[] dataI, float[] dataF) {\n+        for (int i = 1; i < RANGE; i++) {\n+            \/\/ dataI has read \/ write distance 1, but no cyclic dependency\n+            int v = dataI[i];\n+            dataI[i - 1] = v;\n+            dataF[i] = v; \/\/ let's not get confused by another type\n+        }\n+    }\n+\n+    @Test\n+    static void test6a(int[] dataI, float[] dataF) {\n+        for (int i = 2; i < RANGE; i++) {\n+            \/\/ dataI has read \/ write distance 2, but no cyclic dependency\n+            int v = dataI[i];\n+            dataI[i - 2] = v + 5;\n+        }\n+    }\n+\n+    @Test\n+    static void test6b(int[] dataI, float[] dataF) {\n+        for (int i = 2; i < RANGE; i++) {\n+            \/\/ dataI has read \/ write distance 2, but no cyclic dependency\n+            int v = dataI[i];\n+            dataI[i - 2] = v;\n+            dataF[i] = v; \/\/ let's not get confused by another type\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Some aarch64 machines have AlignVector == true, like ThunderX2\n+    static void test7(int[] dataI, float[] dataF) {\n+        for (int i = 0; i < RANGE - 32; i++) {\n+            \/\/ write forward 32 -> more than vector size -> can vectorize\n+            \/\/ write forward 3 -> cannot vectorize\n+            \/\/ separate types should make decision separately if they vectorize or not\n+            int v = dataI[i];\n+            dataI[i + 32] = v + 5;\n+            float f = dataF[i];\n+            dataF[i + 3] = f + 3.5f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VF, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Some aarch64 machines have AlignVector == true, like ThunderX2\n+    static void test8(int[] dataI, float[] dataF) {\n+        for (int i = 0; i < RANGE - 32; i++) {\n+            \/\/ write forward 32 -> more than vector size -> can vectorize\n+            \/\/ write forward 3 -> cannot vectorize\n+            \/\/ separate types should make decision separately if they vectorize or not\n+            int v = dataI[i];\n+            dataI[i + 3] = v + 5;\n+            float f = dataF[i];\n+            dataF[i + 32] = f + 3.5f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_REDUCTION_VI, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test9(int[] dataI, float[] dataF) {\n+        int sI = 666;\n+        for (int i = 0; i < RANGE; i++) {\n+            \/\/ self-cycle allowed for reduction\n+            sI += dataI[i] * 2; \/\/ factor necessary to make it profitable\n+        }\n+        dataI[0] = sI; \/\/ write back\n+    }\n+\n+    public static void init(int[] dataI, float[] dataF) {\n+        for (int j = 0; j < RANGE; j++) {\n+            dataI[j] = j;\n+            dataF[j] = j * 0.5f;\n+        }\n+    }\n+\n+    static void verifyI(String name, int[] data, int[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + name + \" result: dataI[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+\n+    static void verifyF(String name, float[] data, float[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + name + \" result: dataF[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestCyclicDependency.java","additions":399,"deletions":0,"binary":false,"changes":399,"status":"added"},{"patch":"@@ -0,0 +1,11205 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8298935\n+ * @summary Test SuperWord vectorization with different access offsets\n+ *          and various MaxVectorSize values, and +- AlignVector.\n+ *          Note: CompileCommand Option Vectorize is enabled.\n+ * @requires vm.compiler2.enabled\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets\n+ *\/\n+\n+package compiler.loopopts.superword;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * Note: this test is auto-generated. Please modify \/ generate with script:\n+ *       https:\/\/bugs.openjdk.org\/browse\/JDK-8298935\n+ *\n+ * Types: int, long, short, char, byte, float, double\n+ * Offsets: 0, -1, 1, -2, 2, -3, 3, -4, 4, -7, 7, -8, 8, -15, 15, -16, 16, -31, 31, -32, 32, -63, 63, -64, 64, -65, 65, -128, 128, -129, 129, -192, 192\n+ *\n+ * Checking if we should vectorize is a bit complicated. It depends on\n+ * Matcher::vector_width_in_bytes, of the respective platforms (eg. x86.ad)\n+ * This vector_width can be further constrained by MaxVectorSize.\n+ *\n+ * Generally, we vectorize if:\n+ *  - Vectors have at least 4 bytes:    vector_width >= 4\n+ *  - Vectors hold at least 2 elements: vector_width >= 2 * sizeofop(velt_type)\n+ *  - No cyclic dependency:\n+ *    - Access: data[i + offset] = data[i] * fac;\n+ *    - byte_offset = offset * sizeofop(type)\n+ *    - Cyclic dependency if: 0 < byte_offset < vector_width\n+ *\n+ * Note: sizeofop(type) = sizeof(type), except sizeofop(char) = 2\n+ *\n+ * Different types can lead to different vector_width. This depends on\n+ * the CPU-features. Thus, we have a positive and negative IR rule per\n+ * CPU-feature for each test.\n+*\/\n+\n+public class TestDependencyOffsets {\n+    static final int RANGE = 512;\n+\n+    static int[] goldIntP0 = new int[RANGE];\n+    static int[] goldIntM1 = new int[RANGE];\n+    static int[] goldIntP1 = new int[RANGE];\n+    static int[] goldIntM2 = new int[RANGE];\n+    static int[] goldIntP2 = new int[RANGE];\n+    static int[] goldIntM3 = new int[RANGE];\n+    static int[] goldIntP3 = new int[RANGE];\n+    static int[] goldIntM4 = new int[RANGE];\n+    static int[] goldIntP4 = new int[RANGE];\n+    static int[] goldIntM7 = new int[RANGE];\n+    static int[] goldIntP7 = new int[RANGE];\n+    static int[] goldIntM8 = new int[RANGE];\n+    static int[] goldIntP8 = new int[RANGE];\n+    static int[] goldIntM15 = new int[RANGE];\n+    static int[] goldIntP15 = new int[RANGE];\n+    static int[] goldIntM16 = new int[RANGE];\n+    static int[] goldIntP16 = new int[RANGE];\n+    static int[] goldIntM31 = new int[RANGE];\n+    static int[] goldIntP31 = new int[RANGE];\n+    static int[] goldIntM32 = new int[RANGE];\n+    static int[] goldIntP32 = new int[RANGE];\n+    static int[] goldIntM63 = new int[RANGE];\n+    static int[] goldIntP63 = new int[RANGE];\n+    static int[] goldIntM64 = new int[RANGE];\n+    static int[] goldIntP64 = new int[RANGE];\n+    static int[] goldIntM65 = new int[RANGE];\n+    static int[] goldIntP65 = new int[RANGE];\n+    static int[] goldIntM128 = new int[RANGE];\n+    static int[] goldIntP128 = new int[RANGE];\n+    static int[] goldIntM129 = new int[RANGE];\n+    static int[] goldIntP129 = new int[RANGE];\n+    static int[] goldIntM192 = new int[RANGE];\n+    static int[] goldIntP192 = new int[RANGE];\n+    static long[] goldLongP0 = new long[RANGE];\n+    static long[] goldLongM1 = new long[RANGE];\n+    static long[] goldLongP1 = new long[RANGE];\n+    static long[] goldLongM2 = new long[RANGE];\n+    static long[] goldLongP2 = new long[RANGE];\n+    static long[] goldLongM3 = new long[RANGE];\n+    static long[] goldLongP3 = new long[RANGE];\n+    static long[] goldLongM4 = new long[RANGE];\n+    static long[] goldLongP4 = new long[RANGE];\n+    static long[] goldLongM7 = new long[RANGE];\n+    static long[] goldLongP7 = new long[RANGE];\n+    static long[] goldLongM8 = new long[RANGE];\n+    static long[] goldLongP8 = new long[RANGE];\n+    static long[] goldLongM15 = new long[RANGE];\n+    static long[] goldLongP15 = new long[RANGE];\n+    static long[] goldLongM16 = new long[RANGE];\n+    static long[] goldLongP16 = new long[RANGE];\n+    static long[] goldLongM31 = new long[RANGE];\n+    static long[] goldLongP31 = new long[RANGE];\n+    static long[] goldLongM32 = new long[RANGE];\n+    static long[] goldLongP32 = new long[RANGE];\n+    static long[] goldLongM63 = new long[RANGE];\n+    static long[] goldLongP63 = new long[RANGE];\n+    static long[] goldLongM64 = new long[RANGE];\n+    static long[] goldLongP64 = new long[RANGE];\n+    static long[] goldLongM65 = new long[RANGE];\n+    static long[] goldLongP65 = new long[RANGE];\n+    static long[] goldLongM128 = new long[RANGE];\n+    static long[] goldLongP128 = new long[RANGE];\n+    static long[] goldLongM129 = new long[RANGE];\n+    static long[] goldLongP129 = new long[RANGE];\n+    static long[] goldLongM192 = new long[RANGE];\n+    static long[] goldLongP192 = new long[RANGE];\n+    static short[] goldShortP0 = new short[RANGE];\n+    static short[] goldShortM1 = new short[RANGE];\n+    static short[] goldShortP1 = new short[RANGE];\n+    static short[] goldShortM2 = new short[RANGE];\n+    static short[] goldShortP2 = new short[RANGE];\n+    static short[] goldShortM3 = new short[RANGE];\n+    static short[] goldShortP3 = new short[RANGE];\n+    static short[] goldShortM4 = new short[RANGE];\n+    static short[] goldShortP4 = new short[RANGE];\n+    static short[] goldShortM7 = new short[RANGE];\n+    static short[] goldShortP7 = new short[RANGE];\n+    static short[] goldShortM8 = new short[RANGE];\n+    static short[] goldShortP8 = new short[RANGE];\n+    static short[] goldShortM15 = new short[RANGE];\n+    static short[] goldShortP15 = new short[RANGE];\n+    static short[] goldShortM16 = new short[RANGE];\n+    static short[] goldShortP16 = new short[RANGE];\n+    static short[] goldShortM31 = new short[RANGE];\n+    static short[] goldShortP31 = new short[RANGE];\n+    static short[] goldShortM32 = new short[RANGE];\n+    static short[] goldShortP32 = new short[RANGE];\n+    static short[] goldShortM63 = new short[RANGE];\n+    static short[] goldShortP63 = new short[RANGE];\n+    static short[] goldShortM64 = new short[RANGE];\n+    static short[] goldShortP64 = new short[RANGE];\n+    static short[] goldShortM65 = new short[RANGE];\n+    static short[] goldShortP65 = new short[RANGE];\n+    static short[] goldShortM128 = new short[RANGE];\n+    static short[] goldShortP128 = new short[RANGE];\n+    static short[] goldShortM129 = new short[RANGE];\n+    static short[] goldShortP129 = new short[RANGE];\n+    static short[] goldShortM192 = new short[RANGE];\n+    static short[] goldShortP192 = new short[RANGE];\n+    static char[] goldCharP0 = new char[RANGE];\n+    static char[] goldCharM1 = new char[RANGE];\n+    static char[] goldCharP1 = new char[RANGE];\n+    static char[] goldCharM2 = new char[RANGE];\n+    static char[] goldCharP2 = new char[RANGE];\n+    static char[] goldCharM3 = new char[RANGE];\n+    static char[] goldCharP3 = new char[RANGE];\n+    static char[] goldCharM4 = new char[RANGE];\n+    static char[] goldCharP4 = new char[RANGE];\n+    static char[] goldCharM7 = new char[RANGE];\n+    static char[] goldCharP7 = new char[RANGE];\n+    static char[] goldCharM8 = new char[RANGE];\n+    static char[] goldCharP8 = new char[RANGE];\n+    static char[] goldCharM15 = new char[RANGE];\n+    static char[] goldCharP15 = new char[RANGE];\n+    static char[] goldCharM16 = new char[RANGE];\n+    static char[] goldCharP16 = new char[RANGE];\n+    static char[] goldCharM31 = new char[RANGE];\n+    static char[] goldCharP31 = new char[RANGE];\n+    static char[] goldCharM32 = new char[RANGE];\n+    static char[] goldCharP32 = new char[RANGE];\n+    static char[] goldCharM63 = new char[RANGE];\n+    static char[] goldCharP63 = new char[RANGE];\n+    static char[] goldCharM64 = new char[RANGE];\n+    static char[] goldCharP64 = new char[RANGE];\n+    static char[] goldCharM65 = new char[RANGE];\n+    static char[] goldCharP65 = new char[RANGE];\n+    static char[] goldCharM128 = new char[RANGE];\n+    static char[] goldCharP128 = new char[RANGE];\n+    static char[] goldCharM129 = new char[RANGE];\n+    static char[] goldCharP129 = new char[RANGE];\n+    static char[] goldCharM192 = new char[RANGE];\n+    static char[] goldCharP192 = new char[RANGE];\n+    static byte[] goldByteP0 = new byte[RANGE];\n+    static byte[] goldByteM1 = new byte[RANGE];\n+    static byte[] goldByteP1 = new byte[RANGE];\n+    static byte[] goldByteM2 = new byte[RANGE];\n+    static byte[] goldByteP2 = new byte[RANGE];\n+    static byte[] goldByteM3 = new byte[RANGE];\n+    static byte[] goldByteP3 = new byte[RANGE];\n+    static byte[] goldByteM4 = new byte[RANGE];\n+    static byte[] goldByteP4 = new byte[RANGE];\n+    static byte[] goldByteM7 = new byte[RANGE];\n+    static byte[] goldByteP7 = new byte[RANGE];\n+    static byte[] goldByteM8 = new byte[RANGE];\n+    static byte[] goldByteP8 = new byte[RANGE];\n+    static byte[] goldByteM15 = new byte[RANGE];\n+    static byte[] goldByteP15 = new byte[RANGE];\n+    static byte[] goldByteM16 = new byte[RANGE];\n+    static byte[] goldByteP16 = new byte[RANGE];\n+    static byte[] goldByteM31 = new byte[RANGE];\n+    static byte[] goldByteP31 = new byte[RANGE];\n+    static byte[] goldByteM32 = new byte[RANGE];\n+    static byte[] goldByteP32 = new byte[RANGE];\n+    static byte[] goldByteM63 = new byte[RANGE];\n+    static byte[] goldByteP63 = new byte[RANGE];\n+    static byte[] goldByteM64 = new byte[RANGE];\n+    static byte[] goldByteP64 = new byte[RANGE];\n+    static byte[] goldByteM65 = new byte[RANGE];\n+    static byte[] goldByteP65 = new byte[RANGE];\n+    static byte[] goldByteM128 = new byte[RANGE];\n+    static byte[] goldByteP128 = new byte[RANGE];\n+    static byte[] goldByteM129 = new byte[RANGE];\n+    static byte[] goldByteP129 = new byte[RANGE];\n+    static byte[] goldByteM192 = new byte[RANGE];\n+    static byte[] goldByteP192 = new byte[RANGE];\n+    static float[] goldFloatP0 = new float[RANGE];\n+    static float[] goldFloatM1 = new float[RANGE];\n+    static float[] goldFloatP1 = new float[RANGE];\n+    static float[] goldFloatM2 = new float[RANGE];\n+    static float[] goldFloatP2 = new float[RANGE];\n+    static float[] goldFloatM3 = new float[RANGE];\n+    static float[] goldFloatP3 = new float[RANGE];\n+    static float[] goldFloatM4 = new float[RANGE];\n+    static float[] goldFloatP4 = new float[RANGE];\n+    static float[] goldFloatM7 = new float[RANGE];\n+    static float[] goldFloatP7 = new float[RANGE];\n+    static float[] goldFloatM8 = new float[RANGE];\n+    static float[] goldFloatP8 = new float[RANGE];\n+    static float[] goldFloatM15 = new float[RANGE];\n+    static float[] goldFloatP15 = new float[RANGE];\n+    static float[] goldFloatM16 = new float[RANGE];\n+    static float[] goldFloatP16 = new float[RANGE];\n+    static float[] goldFloatM31 = new float[RANGE];\n+    static float[] goldFloatP31 = new float[RANGE];\n+    static float[] goldFloatM32 = new float[RANGE];\n+    static float[] goldFloatP32 = new float[RANGE];\n+    static float[] goldFloatM63 = new float[RANGE];\n+    static float[] goldFloatP63 = new float[RANGE];\n+    static float[] goldFloatM64 = new float[RANGE];\n+    static float[] goldFloatP64 = new float[RANGE];\n+    static float[] goldFloatM65 = new float[RANGE];\n+    static float[] goldFloatP65 = new float[RANGE];\n+    static float[] goldFloatM128 = new float[RANGE];\n+    static float[] goldFloatP128 = new float[RANGE];\n+    static float[] goldFloatM129 = new float[RANGE];\n+    static float[] goldFloatP129 = new float[RANGE];\n+    static float[] goldFloatM192 = new float[RANGE];\n+    static float[] goldFloatP192 = new float[RANGE];\n+    static double[] goldDoubleP0 = new double[RANGE];\n+    static double[] goldDoubleM1 = new double[RANGE];\n+    static double[] goldDoubleP1 = new double[RANGE];\n+    static double[] goldDoubleM2 = new double[RANGE];\n+    static double[] goldDoubleP2 = new double[RANGE];\n+    static double[] goldDoubleM3 = new double[RANGE];\n+    static double[] goldDoubleP3 = new double[RANGE];\n+    static double[] goldDoubleM4 = new double[RANGE];\n+    static double[] goldDoubleP4 = new double[RANGE];\n+    static double[] goldDoubleM7 = new double[RANGE];\n+    static double[] goldDoubleP7 = new double[RANGE];\n+    static double[] goldDoubleM8 = new double[RANGE];\n+    static double[] goldDoubleP8 = new double[RANGE];\n+    static double[] goldDoubleM15 = new double[RANGE];\n+    static double[] goldDoubleP15 = new double[RANGE];\n+    static double[] goldDoubleM16 = new double[RANGE];\n+    static double[] goldDoubleP16 = new double[RANGE];\n+    static double[] goldDoubleM31 = new double[RANGE];\n+    static double[] goldDoubleP31 = new double[RANGE];\n+    static double[] goldDoubleM32 = new double[RANGE];\n+    static double[] goldDoubleP32 = new double[RANGE];\n+    static double[] goldDoubleM63 = new double[RANGE];\n+    static double[] goldDoubleP63 = new double[RANGE];\n+    static double[] goldDoubleM64 = new double[RANGE];\n+    static double[] goldDoubleP64 = new double[RANGE];\n+    static double[] goldDoubleM65 = new double[RANGE];\n+    static double[] goldDoubleP65 = new double[RANGE];\n+    static double[] goldDoubleM128 = new double[RANGE];\n+    static double[] goldDoubleP128 = new double[RANGE];\n+    static double[] goldDoubleM129 = new double[RANGE];\n+    static double[] goldDoubleP129 = new double[RANGE];\n+    static double[] goldDoubleM192 = new double[RANGE];\n+    static double[] goldDoubleP192 = new double[RANGE];\n+\n+    static {\n+        \/\/ compute the gold standard in interpreter mode\n+        init(goldIntP0);\n+        testIntP0(goldIntP0);\n+        init(goldIntM1);\n+        testIntM1(goldIntM1);\n+        init(goldIntP1);\n+        testIntP1(goldIntP1);\n+        init(goldIntM2);\n+        testIntM2(goldIntM2);\n+        init(goldIntP2);\n+        testIntP2(goldIntP2);\n+        init(goldIntM3);\n+        testIntM3(goldIntM3);\n+        init(goldIntP3);\n+        testIntP3(goldIntP3);\n+        init(goldIntM4);\n+        testIntM4(goldIntM4);\n+        init(goldIntP4);\n+        testIntP4(goldIntP4);\n+        init(goldIntM7);\n+        testIntM7(goldIntM7);\n+        init(goldIntP7);\n+        testIntP7(goldIntP7);\n+        init(goldIntM8);\n+        testIntM8(goldIntM8);\n+        init(goldIntP8);\n+        testIntP8(goldIntP8);\n+        init(goldIntM15);\n+        testIntM15(goldIntM15);\n+        init(goldIntP15);\n+        testIntP15(goldIntP15);\n+        init(goldIntM16);\n+        testIntM16(goldIntM16);\n+        init(goldIntP16);\n+        testIntP16(goldIntP16);\n+        init(goldIntM31);\n+        testIntM31(goldIntM31);\n+        init(goldIntP31);\n+        testIntP31(goldIntP31);\n+        init(goldIntM32);\n+        testIntM32(goldIntM32);\n+        init(goldIntP32);\n+        testIntP32(goldIntP32);\n+        init(goldIntM63);\n+        testIntM63(goldIntM63);\n+        init(goldIntP63);\n+        testIntP63(goldIntP63);\n+        init(goldIntM64);\n+        testIntM64(goldIntM64);\n+        init(goldIntP64);\n+        testIntP64(goldIntP64);\n+        init(goldIntM65);\n+        testIntM65(goldIntM65);\n+        init(goldIntP65);\n+        testIntP65(goldIntP65);\n+        init(goldIntM128);\n+        testIntM128(goldIntM128);\n+        init(goldIntP128);\n+        testIntP128(goldIntP128);\n+        init(goldIntM129);\n+        testIntM129(goldIntM129);\n+        init(goldIntP129);\n+        testIntP129(goldIntP129);\n+        init(goldIntM192);\n+        testIntM192(goldIntM192);\n+        init(goldIntP192);\n+        testIntP192(goldIntP192);\n+        init(goldLongP0);\n+        testLongP0(goldLongP0);\n+        init(goldLongM1);\n+        testLongM1(goldLongM1);\n+        init(goldLongP1);\n+        testLongP1(goldLongP1);\n+        init(goldLongM2);\n+        testLongM2(goldLongM2);\n+        init(goldLongP2);\n+        testLongP2(goldLongP2);\n+        init(goldLongM3);\n+        testLongM3(goldLongM3);\n+        init(goldLongP3);\n+        testLongP3(goldLongP3);\n+        init(goldLongM4);\n+        testLongM4(goldLongM4);\n+        init(goldLongP4);\n+        testLongP4(goldLongP4);\n+        init(goldLongM7);\n+        testLongM7(goldLongM7);\n+        init(goldLongP7);\n+        testLongP7(goldLongP7);\n+        init(goldLongM8);\n+        testLongM8(goldLongM8);\n+        init(goldLongP8);\n+        testLongP8(goldLongP8);\n+        init(goldLongM15);\n+        testLongM15(goldLongM15);\n+        init(goldLongP15);\n+        testLongP15(goldLongP15);\n+        init(goldLongM16);\n+        testLongM16(goldLongM16);\n+        init(goldLongP16);\n+        testLongP16(goldLongP16);\n+        init(goldLongM31);\n+        testLongM31(goldLongM31);\n+        init(goldLongP31);\n+        testLongP31(goldLongP31);\n+        init(goldLongM32);\n+        testLongM32(goldLongM32);\n+        init(goldLongP32);\n+        testLongP32(goldLongP32);\n+        init(goldLongM63);\n+        testLongM63(goldLongM63);\n+        init(goldLongP63);\n+        testLongP63(goldLongP63);\n+        init(goldLongM64);\n+        testLongM64(goldLongM64);\n+        init(goldLongP64);\n+        testLongP64(goldLongP64);\n+        init(goldLongM65);\n+        testLongM65(goldLongM65);\n+        init(goldLongP65);\n+        testLongP65(goldLongP65);\n+        init(goldLongM128);\n+        testLongM128(goldLongM128);\n+        init(goldLongP128);\n+        testLongP128(goldLongP128);\n+        init(goldLongM129);\n+        testLongM129(goldLongM129);\n+        init(goldLongP129);\n+        testLongP129(goldLongP129);\n+        init(goldLongM192);\n+        testLongM192(goldLongM192);\n+        init(goldLongP192);\n+        testLongP192(goldLongP192);\n+        init(goldShortP0);\n+        testShortP0(goldShortP0);\n+        init(goldShortM1);\n+        testShortM1(goldShortM1);\n+        init(goldShortP1);\n+        testShortP1(goldShortP1);\n+        init(goldShortM2);\n+        testShortM2(goldShortM2);\n+        init(goldShortP2);\n+        testShortP2(goldShortP2);\n+        init(goldShortM3);\n+        testShortM3(goldShortM3);\n+        init(goldShortP3);\n+        testShortP3(goldShortP3);\n+        init(goldShortM4);\n+        testShortM4(goldShortM4);\n+        init(goldShortP4);\n+        testShortP4(goldShortP4);\n+        init(goldShortM7);\n+        testShortM7(goldShortM7);\n+        init(goldShortP7);\n+        testShortP7(goldShortP7);\n+        init(goldShortM8);\n+        testShortM8(goldShortM8);\n+        init(goldShortP8);\n+        testShortP8(goldShortP8);\n+        init(goldShortM15);\n+        testShortM15(goldShortM15);\n+        init(goldShortP15);\n+        testShortP15(goldShortP15);\n+        init(goldShortM16);\n+        testShortM16(goldShortM16);\n+        init(goldShortP16);\n+        testShortP16(goldShortP16);\n+        init(goldShortM31);\n+        testShortM31(goldShortM31);\n+        init(goldShortP31);\n+        testShortP31(goldShortP31);\n+        init(goldShortM32);\n+        testShortM32(goldShortM32);\n+        init(goldShortP32);\n+        testShortP32(goldShortP32);\n+        init(goldShortM63);\n+        testShortM63(goldShortM63);\n+        init(goldShortP63);\n+        testShortP63(goldShortP63);\n+        init(goldShortM64);\n+        testShortM64(goldShortM64);\n+        init(goldShortP64);\n+        testShortP64(goldShortP64);\n+        init(goldShortM65);\n+        testShortM65(goldShortM65);\n+        init(goldShortP65);\n+        testShortP65(goldShortP65);\n+        init(goldShortM128);\n+        testShortM128(goldShortM128);\n+        init(goldShortP128);\n+        testShortP128(goldShortP128);\n+        init(goldShortM129);\n+        testShortM129(goldShortM129);\n+        init(goldShortP129);\n+        testShortP129(goldShortP129);\n+        init(goldShortM192);\n+        testShortM192(goldShortM192);\n+        init(goldShortP192);\n+        testShortP192(goldShortP192);\n+        init(goldCharP0);\n+        testCharP0(goldCharP0);\n+        init(goldCharM1);\n+        testCharM1(goldCharM1);\n+        init(goldCharP1);\n+        testCharP1(goldCharP1);\n+        init(goldCharM2);\n+        testCharM2(goldCharM2);\n+        init(goldCharP2);\n+        testCharP2(goldCharP2);\n+        init(goldCharM3);\n+        testCharM3(goldCharM3);\n+        init(goldCharP3);\n+        testCharP3(goldCharP3);\n+        init(goldCharM4);\n+        testCharM4(goldCharM4);\n+        init(goldCharP4);\n+        testCharP4(goldCharP4);\n+        init(goldCharM7);\n+        testCharM7(goldCharM7);\n+        init(goldCharP7);\n+        testCharP7(goldCharP7);\n+        init(goldCharM8);\n+        testCharM8(goldCharM8);\n+        init(goldCharP8);\n+        testCharP8(goldCharP8);\n+        init(goldCharM15);\n+        testCharM15(goldCharM15);\n+        init(goldCharP15);\n+        testCharP15(goldCharP15);\n+        init(goldCharM16);\n+        testCharM16(goldCharM16);\n+        init(goldCharP16);\n+        testCharP16(goldCharP16);\n+        init(goldCharM31);\n+        testCharM31(goldCharM31);\n+        init(goldCharP31);\n+        testCharP31(goldCharP31);\n+        init(goldCharM32);\n+        testCharM32(goldCharM32);\n+        init(goldCharP32);\n+        testCharP32(goldCharP32);\n+        init(goldCharM63);\n+        testCharM63(goldCharM63);\n+        init(goldCharP63);\n+        testCharP63(goldCharP63);\n+        init(goldCharM64);\n+        testCharM64(goldCharM64);\n+        init(goldCharP64);\n+        testCharP64(goldCharP64);\n+        init(goldCharM65);\n+        testCharM65(goldCharM65);\n+        init(goldCharP65);\n+        testCharP65(goldCharP65);\n+        init(goldCharM128);\n+        testCharM128(goldCharM128);\n+        init(goldCharP128);\n+        testCharP128(goldCharP128);\n+        init(goldCharM129);\n+        testCharM129(goldCharM129);\n+        init(goldCharP129);\n+        testCharP129(goldCharP129);\n+        init(goldCharM192);\n+        testCharM192(goldCharM192);\n+        init(goldCharP192);\n+        testCharP192(goldCharP192);\n+        init(goldByteP0);\n+        testByteP0(goldByteP0);\n+        init(goldByteM1);\n+        testByteM1(goldByteM1);\n+        init(goldByteP1);\n+        testByteP1(goldByteP1);\n+        init(goldByteM2);\n+        testByteM2(goldByteM2);\n+        init(goldByteP2);\n+        testByteP2(goldByteP2);\n+        init(goldByteM3);\n+        testByteM3(goldByteM3);\n+        init(goldByteP3);\n+        testByteP3(goldByteP3);\n+        init(goldByteM4);\n+        testByteM4(goldByteM4);\n+        init(goldByteP4);\n+        testByteP4(goldByteP4);\n+        init(goldByteM7);\n+        testByteM7(goldByteM7);\n+        init(goldByteP7);\n+        testByteP7(goldByteP7);\n+        init(goldByteM8);\n+        testByteM8(goldByteM8);\n+        init(goldByteP8);\n+        testByteP8(goldByteP8);\n+        init(goldByteM15);\n+        testByteM15(goldByteM15);\n+        init(goldByteP15);\n+        testByteP15(goldByteP15);\n+        init(goldByteM16);\n+        testByteM16(goldByteM16);\n+        init(goldByteP16);\n+        testByteP16(goldByteP16);\n+        init(goldByteM31);\n+        testByteM31(goldByteM31);\n+        init(goldByteP31);\n+        testByteP31(goldByteP31);\n+        init(goldByteM32);\n+        testByteM32(goldByteM32);\n+        init(goldByteP32);\n+        testByteP32(goldByteP32);\n+        init(goldByteM63);\n+        testByteM63(goldByteM63);\n+        init(goldByteP63);\n+        testByteP63(goldByteP63);\n+        init(goldByteM64);\n+        testByteM64(goldByteM64);\n+        init(goldByteP64);\n+        testByteP64(goldByteP64);\n+        init(goldByteM65);\n+        testByteM65(goldByteM65);\n+        init(goldByteP65);\n+        testByteP65(goldByteP65);\n+        init(goldByteM128);\n+        testByteM128(goldByteM128);\n+        init(goldByteP128);\n+        testByteP128(goldByteP128);\n+        init(goldByteM129);\n+        testByteM129(goldByteM129);\n+        init(goldByteP129);\n+        testByteP129(goldByteP129);\n+        init(goldByteM192);\n+        testByteM192(goldByteM192);\n+        init(goldByteP192);\n+        testByteP192(goldByteP192);\n+        init(goldFloatP0);\n+        testFloatP0(goldFloatP0);\n+        init(goldFloatM1);\n+        testFloatM1(goldFloatM1);\n+        init(goldFloatP1);\n+        testFloatP1(goldFloatP1);\n+        init(goldFloatM2);\n+        testFloatM2(goldFloatM2);\n+        init(goldFloatP2);\n+        testFloatP2(goldFloatP2);\n+        init(goldFloatM3);\n+        testFloatM3(goldFloatM3);\n+        init(goldFloatP3);\n+        testFloatP3(goldFloatP3);\n+        init(goldFloatM4);\n+        testFloatM4(goldFloatM4);\n+        init(goldFloatP4);\n+        testFloatP4(goldFloatP4);\n+        init(goldFloatM7);\n+        testFloatM7(goldFloatM7);\n+        init(goldFloatP7);\n+        testFloatP7(goldFloatP7);\n+        init(goldFloatM8);\n+        testFloatM8(goldFloatM8);\n+        init(goldFloatP8);\n+        testFloatP8(goldFloatP8);\n+        init(goldFloatM15);\n+        testFloatM15(goldFloatM15);\n+        init(goldFloatP15);\n+        testFloatP15(goldFloatP15);\n+        init(goldFloatM16);\n+        testFloatM16(goldFloatM16);\n+        init(goldFloatP16);\n+        testFloatP16(goldFloatP16);\n+        init(goldFloatM31);\n+        testFloatM31(goldFloatM31);\n+        init(goldFloatP31);\n+        testFloatP31(goldFloatP31);\n+        init(goldFloatM32);\n+        testFloatM32(goldFloatM32);\n+        init(goldFloatP32);\n+        testFloatP32(goldFloatP32);\n+        init(goldFloatM63);\n+        testFloatM63(goldFloatM63);\n+        init(goldFloatP63);\n+        testFloatP63(goldFloatP63);\n+        init(goldFloatM64);\n+        testFloatM64(goldFloatM64);\n+        init(goldFloatP64);\n+        testFloatP64(goldFloatP64);\n+        init(goldFloatM65);\n+        testFloatM65(goldFloatM65);\n+        init(goldFloatP65);\n+        testFloatP65(goldFloatP65);\n+        init(goldFloatM128);\n+        testFloatM128(goldFloatM128);\n+        init(goldFloatP128);\n+        testFloatP128(goldFloatP128);\n+        init(goldFloatM129);\n+        testFloatM129(goldFloatM129);\n+        init(goldFloatP129);\n+        testFloatP129(goldFloatP129);\n+        init(goldFloatM192);\n+        testFloatM192(goldFloatM192);\n+        init(goldFloatP192);\n+        testFloatP192(goldFloatP192);\n+        init(goldDoubleP0);\n+        testDoubleP0(goldDoubleP0);\n+        init(goldDoubleM1);\n+        testDoubleM1(goldDoubleM1);\n+        init(goldDoubleP1);\n+        testDoubleP1(goldDoubleP1);\n+        init(goldDoubleM2);\n+        testDoubleM2(goldDoubleM2);\n+        init(goldDoubleP2);\n+        testDoubleP2(goldDoubleP2);\n+        init(goldDoubleM3);\n+        testDoubleM3(goldDoubleM3);\n+        init(goldDoubleP3);\n+        testDoubleP3(goldDoubleP3);\n+        init(goldDoubleM4);\n+        testDoubleM4(goldDoubleM4);\n+        init(goldDoubleP4);\n+        testDoubleP4(goldDoubleP4);\n+        init(goldDoubleM7);\n+        testDoubleM7(goldDoubleM7);\n+        init(goldDoubleP7);\n+        testDoubleP7(goldDoubleP7);\n+        init(goldDoubleM8);\n+        testDoubleM8(goldDoubleM8);\n+        init(goldDoubleP8);\n+        testDoubleP8(goldDoubleP8);\n+        init(goldDoubleM15);\n+        testDoubleM15(goldDoubleM15);\n+        init(goldDoubleP15);\n+        testDoubleP15(goldDoubleP15);\n+        init(goldDoubleM16);\n+        testDoubleM16(goldDoubleM16);\n+        init(goldDoubleP16);\n+        testDoubleP16(goldDoubleP16);\n+        init(goldDoubleM31);\n+        testDoubleM31(goldDoubleM31);\n+        init(goldDoubleP31);\n+        testDoubleP31(goldDoubleP31);\n+        init(goldDoubleM32);\n+        testDoubleM32(goldDoubleM32);\n+        init(goldDoubleP32);\n+        testDoubleP32(goldDoubleP32);\n+        init(goldDoubleM63);\n+        testDoubleM63(goldDoubleM63);\n+        init(goldDoubleP63);\n+        testDoubleP63(goldDoubleP63);\n+        init(goldDoubleM64);\n+        testDoubleM64(goldDoubleM64);\n+        init(goldDoubleP64);\n+        testDoubleP64(goldDoubleP64);\n+        init(goldDoubleM65);\n+        testDoubleM65(goldDoubleM65);\n+        init(goldDoubleP65);\n+        testDoubleP65(goldDoubleP65);\n+        init(goldDoubleM128);\n+        testDoubleM128(goldDoubleM128);\n+        init(goldDoubleP128);\n+        testDoubleP128(goldDoubleP128);\n+        init(goldDoubleM129);\n+        testDoubleM129(goldDoubleM129);\n+        init(goldDoubleP129);\n+        testDoubleP129(goldDoubleP129);\n+        init(goldDoubleM192);\n+        testDoubleM192(goldDoubleM192);\n+        init(goldDoubleP192);\n+        testDoubleP192(goldDoubleP192);\n+    }\n+\n+    public static void main(String args[]) {\n+        TestDependencyOffsets x = new TestDependencyOffsets();\n+        TestFramework framework = new TestFramework(TestDependencyOffsets.class);\n+        framework.addFlags(\"-XX:-TieredCompilation\",\n+                           \"-XX:CompileCommand=option,compiler.loopopts.superword.TestDependencyOffsets::test*,Vectorize\",\n+                           \"-XX:CompileCommand=compileonly,compiler.loopopts.superword.TestDependencyOffsets::init\",\n+                           \"-XX:CompileCommand=compileonly,compiler.loopopts.superword.TestDependencyOffsets::test*\",\n+                           \"-XX:CompileCommand=compileonly,compiler.loopopts.superword.TestDependencyOffsets::verify\",\n+                           \"-XX:LoopUnrollLimit=250\");\n+\n+        int i = 0;\n+        Scenario[] scenarios = new Scenario[8];\n+        for (int maxVectorSize : new int[] {1, 2, 4, 8, 16, 32, 64, 128}) {\n+            for (String alignVectorSign : new String[] {\"-\"}) { \/\/ TODO\n+                scenarios[i] = new Scenario(i, \"-XX:\" + alignVectorSign + \"AlignVector\",\n+                                               \"-XX:MaxVectorSize=\" + maxVectorSize);\n+                i++;\n+            }\n+        }\n+        framework.addScenarios(scenarios);\n+        framework.start();\n+    }\n+\n+    \/\/ ------------------- Tests -------------------\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP0(int[] data) {\n+        for (int j = 0; j < RANGE; j++) {\n+            data[j + 0] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP0\")\n+    @Warmup(0)\n+    public static void runIntP0() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP0(data);\n+        verify(\"testIntP0\", data, goldIntP0);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntM1(int[] data) {\n+        for (int j = 1; j < RANGE; j++) {\n+            data[j + -1] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntM1\")\n+    @Warmup(0)\n+    public static void runIntM1() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntM1(data);\n+        verify(\"testIntM1\", data, goldIntM1);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    \/\/ positive byte_offset 4 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 8\n+    \/\/ positive byte_offset 4 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    \/\/ positive byte_offset 4 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 4\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    \/\/ positive byte_offset 4 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP1(int[] data) {\n+        for (int j = 0; j < RANGE - 1; j++) {\n+            data[j + 1] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP1\")\n+    @Warmup(0)\n+    public static void runIntP1() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP1(data);\n+        verify(\"testIntP1\", data, goldIntP1);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntM2(int[] data) {\n+        for (int j = 2; j < RANGE; j++) {\n+            data[j + -2] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntM2\")\n+    @Warmup(0)\n+    public static void runIntM2() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntM2(data);\n+        verify(\"testIntM2\", data, goldIntM2);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    \/\/ positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 8\n+    \/\/ positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    \/\/ positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    \/\/ positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP2(int[] data) {\n+        for (int j = 0; j < RANGE - 2; j++) {\n+            data[j + 2] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP2\")\n+    @Warmup(0)\n+    public static void runIntP2() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP2(data);\n+        verify(\"testIntP2\", data, goldIntP2);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntM3(int[] data) {\n+        for (int j = 3; j < RANGE; j++) {\n+            data[j + -3] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntM3\")\n+    @Warmup(0)\n+    public static void runIntM3() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntM3(data);\n+        verify(\"testIntM3\", data, goldIntM3);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    \/\/ positive byte_offset 12 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 12\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 8\n+    \/\/ positive byte_offset 12 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 12\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    \/\/ positive byte_offset 12 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 12\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    \/\/ positive byte_offset 12 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 12\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP3(int[] data) {\n+        for (int j = 0; j < RANGE - 3; j++) {\n+            data[j + 3] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP3\")\n+    @Warmup(0)\n+    public static void runIntP3() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP3(data);\n+        verify(\"testIntP3\", data, goldIntP3);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntM4(int[] data) {\n+        for (int j = 4; j < RANGE; j++) {\n+            data[j + -4] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntM4\")\n+    @Warmup(0)\n+    public static void runIntM4() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntM4(data);\n+        verify(\"testIntM4\", data, goldIntM4);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 8\n+    \/\/ positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    \/\/ positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    \/\/ positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP4(int[] data) {\n+        for (int j = 0; j < RANGE - 4; j++) {\n+            data[j + 4] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP4\")\n+    @Warmup(0)\n+    public static void runIntP4() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP4(data);\n+        verify(\"testIntP4\", data, goldIntP4);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntM7(int[] data) {\n+        for (int j = 7; j < RANGE; j++) {\n+            data[j + -7] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntM7\")\n+    @Warmup(0)\n+    public static void runIntM7() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntM7(data);\n+        verify(\"testIntM7\", data, goldIntM7);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 8\n+    \/\/ positive byte_offset 28 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 28\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    \/\/ positive byte_offset 28 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 28\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    \/\/ positive byte_offset 28 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 28\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP7(int[] data) {\n+        for (int j = 0; j < RANGE - 7; j++) {\n+            data[j + 7] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP7\")\n+    @Warmup(0)\n+    public static void runIntP7() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP7(data);\n+        verify(\"testIntP7\", data, goldIntP7);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntM8(int[] data) {\n+        for (int j = 8; j < RANGE; j++) {\n+            data[j + -8] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntM8\")\n+    @Warmup(0)\n+    public static void runIntM8() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntM8(data);\n+        verify(\"testIntM8\", data, goldIntM8);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    \/\/ positive byte_offset 32 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 32\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP8(int[] data) {\n+        for (int j = 0; j < RANGE - 8; j++) {\n+            data[j + 8] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP8\")\n+    @Warmup(0)\n+    public static void runIntP8() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP8(data);\n+        verify(\"testIntP8\", data, goldIntP8);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntM15(int[] data) {\n+        for (int j = 15; j < RANGE; j++) {\n+            data[j + -15] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntM15\")\n+    @Warmup(0)\n+    public static void runIntM15() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntM15(data);\n+        verify(\"testIntM15\", data, goldIntM15);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    \/\/ positive byte_offset 60 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 60\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 60\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP15(int[] data) {\n+        for (int j = 0; j < RANGE - 15; j++) {\n+            data[j + 15] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP15\")\n+    @Warmup(0)\n+    public static void runIntP15() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP15(data);\n+        verify(\"testIntP15\", data, goldIntP15);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntM16(int[] data) {\n+        for (int j = 16; j < RANGE; j++) {\n+            data[j + -16] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntM16\")\n+    @Warmup(0)\n+    public static void runIntM16() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntM16(data);\n+        verify(\"testIntM16\", data, goldIntM16);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP16(int[] data) {\n+        for (int j = 0; j < RANGE - 16; j++) {\n+            data[j + 16] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP16\")\n+    @Warmup(0)\n+    public static void runIntP16() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP16(data);\n+        verify(\"testIntP16\", data, goldIntP16);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntM31(int[] data) {\n+        for (int j = 31; j < RANGE; j++) {\n+            data[j + -31] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntM31\")\n+    @Warmup(0)\n+    public static void runIntM31() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntM31(data);\n+        verify(\"testIntM31\", data, goldIntM31);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP31(int[] data) {\n+        for (int j = 0; j < RANGE - 31; j++) {\n+            data[j + 31] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP31\")\n+    @Warmup(0)\n+    public static void runIntP31() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP31(data);\n+        verify(\"testIntP31\", data, goldIntP31);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntM32(int[] data) {\n+        for (int j = 32; j < RANGE; j++) {\n+            data[j + -32] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntM32\")\n+    @Warmup(0)\n+    public static void runIntM32() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntM32(data);\n+        verify(\"testIntM32\", data, goldIntM32);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP32(int[] data) {\n+        for (int j = 0; j < RANGE - 32; j++) {\n+            data[j + 32] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP32\")\n+    @Warmup(0)\n+    public static void runIntP32() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP32(data);\n+        verify(\"testIntP32\", data, goldIntP32);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntM63(int[] data) {\n+        for (int j = 63; j < RANGE; j++) {\n+            data[j + -63] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntM63\")\n+    @Warmup(0)\n+    public static void runIntM63() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntM63(data);\n+        verify(\"testIntM63\", data, goldIntM63);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP63(int[] data) {\n+        for (int j = 0; j < RANGE - 63; j++) {\n+            data[j + 63] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP63\")\n+    @Warmup(0)\n+    public static void runIntP63() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP63(data);\n+        verify(\"testIntP63\", data, goldIntP63);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntM64(int[] data) {\n+        for (int j = 64; j < RANGE; j++) {\n+            data[j + -64] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntM64\")\n+    @Warmup(0)\n+    public static void runIntM64() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntM64(data);\n+        verify(\"testIntM64\", data, goldIntM64);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP64(int[] data) {\n+        for (int j = 0; j < RANGE - 64; j++) {\n+            data[j + 64] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP64\")\n+    @Warmup(0)\n+    public static void runIntP64() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP64(data);\n+        verify(\"testIntP64\", data, goldIntP64);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntM65(int[] data) {\n+        for (int j = 65; j < RANGE; j++) {\n+            data[j + -65] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntM65\")\n+    @Warmup(0)\n+    public static void runIntM65() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntM65(data);\n+        verify(\"testIntM65\", data, goldIntM65);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP65(int[] data) {\n+        for (int j = 0; j < RANGE - 65; j++) {\n+            data[j + 65] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP65\")\n+    @Warmup(0)\n+    public static void runIntP65() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP65(data);\n+        verify(\"testIntP65\", data, goldIntP65);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntM128(int[] data) {\n+        for (int j = 128; j < RANGE; j++) {\n+            data[j + -128] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntM128\")\n+    @Warmup(0)\n+    public static void runIntM128() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntM128(data);\n+        verify(\"testIntM128\", data, goldIntM128);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP128(int[] data) {\n+        for (int j = 0; j < RANGE - 128; j++) {\n+            data[j + 128] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP128\")\n+    @Warmup(0)\n+    public static void runIntP128() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP128(data);\n+        verify(\"testIntP128\", data, goldIntP128);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntM129(int[] data) {\n+        for (int j = 129; j < RANGE; j++) {\n+            data[j + -129] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntM129\")\n+    @Warmup(0)\n+    public static void runIntM129() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntM129(data);\n+        verify(\"testIntM129\", data, goldIntM129);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP129(int[] data) {\n+        for (int j = 0; j < RANGE - 129; j++) {\n+            data[j + 129] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP129\")\n+    @Warmup(0)\n+    public static void runIntP129() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP129(data);\n+        verify(\"testIntP129\", data, goldIntP129);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntM192(int[] data) {\n+        for (int j = 192; j < RANGE; j++) {\n+            data[j + -192] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntM192\")\n+    @Warmup(0)\n+    public static void runIntM192() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntM192(data);\n+        verify(\"testIntM192\", data, goldIntM192);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP192(int[] data) {\n+        for (int j = 0; j < RANGE - 192; j++) {\n+            data[j + 192] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP192\")\n+    @Warmup(0)\n+    public static void runIntP192() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP192(data);\n+        verify(\"testIntP192\", data, goldIntP192);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP0(long[] data) {\n+        for (int j = 0; j < RANGE; j++) {\n+            data[j + 0] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP0\")\n+    @Warmup(0)\n+    public static void runLongP0() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP0(data);\n+        verify(\"testLongP0\", data, goldLongP0);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongM1(long[] data) {\n+        for (int j = 1; j < RANGE; j++) {\n+            data[j + -1] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongM1\")\n+    @Warmup(0)\n+    public static void runLongM1() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongM1(data);\n+        verify(\"testLongM1\", data, goldLongM1);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    \/\/ positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 16\", \"MaxVectorSize\", \"> 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 4\n+    \/\/ positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 16\", \"MaxVectorSize\", \"> 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    \/\/ positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 16\", \"MaxVectorSize\", \"> 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    \/\/ positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 16\", \"MaxVectorSize\", \"> 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP1(long[] data) {\n+        for (int j = 0; j < RANGE - 1; j++) {\n+            data[j + 1] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP1\")\n+    @Warmup(0)\n+    public static void runLongP1() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP1(data);\n+        verify(\"testLongP1\", data, goldLongP1);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongM2(long[] data) {\n+        for (int j = 2; j < RANGE; j++) {\n+            data[j + -2] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongM2\")\n+    @Warmup(0)\n+    public static void runLongM2() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongM2(data);\n+        verify(\"testLongM2\", data, goldLongM2);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 4\n+    \/\/ positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 16\", \"MaxVectorSize\", \"> 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    \/\/ positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 16\", \"MaxVectorSize\", \"> 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    \/\/ positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 16\", \"MaxVectorSize\", \"> 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP2(long[] data) {\n+        for (int j = 0; j < RANGE - 2; j++) {\n+            data[j + 2] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP2\")\n+    @Warmup(0)\n+    public static void runLongP2() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP2(data);\n+        verify(\"testLongP2\", data, goldLongP2);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongM3(long[] data) {\n+        for (int j = 3; j < RANGE; j++) {\n+            data[j + -3] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongM3\")\n+    @Warmup(0)\n+    public static void runLongM3() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongM3(data);\n+        verify(\"testLongM3\", data, goldLongM3);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 4\n+    \/\/ positive byte_offset 24 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 16\", \"MaxVectorSize\", \"> 24\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    \/\/ positive byte_offset 24 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 16\", \"MaxVectorSize\", \"> 24\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    \/\/ positive byte_offset 24 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 16\", \"MaxVectorSize\", \"> 24\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP3(long[] data) {\n+        for (int j = 0; j < RANGE - 3; j++) {\n+            data[j + 3] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP3\")\n+    @Warmup(0)\n+    public static void runLongP3() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP3(data);\n+        verify(\"testLongP3\", data, goldLongP3);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongM4(long[] data) {\n+        for (int j = 4; j < RANGE; j++) {\n+            data[j + -4] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongM4\")\n+    @Warmup(0)\n+    public static void runLongM4() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongM4(data);\n+        verify(\"testLongM4\", data, goldLongM4);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    \/\/ positive byte_offset 32 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 16\", \"MaxVectorSize\", \"> 32\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP4(long[] data) {\n+        for (int j = 0; j < RANGE - 4; j++) {\n+            data[j + 4] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP4\")\n+    @Warmup(0)\n+    public static void runLongP4() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP4(data);\n+        verify(\"testLongP4\", data, goldLongP4);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongM7(long[] data) {\n+        for (int j = 7; j < RANGE; j++) {\n+            data[j + -7] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongM7\")\n+    @Warmup(0)\n+    public static void runLongM7() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongM7(data);\n+        verify(\"testLongM7\", data, goldLongM7);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    \/\/ positive byte_offset 56 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 56\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 16\", \"MaxVectorSize\", \"> 56\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP7(long[] data) {\n+        for (int j = 0; j < RANGE - 7; j++) {\n+            data[j + 7] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP7\")\n+    @Warmup(0)\n+    public static void runLongP7() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP7(data);\n+        verify(\"testLongP7\", data, goldLongP7);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongM8(long[] data) {\n+        for (int j = 8; j < RANGE; j++) {\n+            data[j + -8] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongM8\")\n+    @Warmup(0)\n+    public static void runLongM8() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongM8(data);\n+        verify(\"testLongM8\", data, goldLongM8);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP8(long[] data) {\n+        for (int j = 0; j < RANGE - 8; j++) {\n+            data[j + 8] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP8\")\n+    @Warmup(0)\n+    public static void runLongP8() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP8(data);\n+        verify(\"testLongP8\", data, goldLongP8);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongM15(long[] data) {\n+        for (int j = 15; j < RANGE; j++) {\n+            data[j + -15] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongM15\")\n+    @Warmup(0)\n+    public static void runLongM15() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongM15(data);\n+        verify(\"testLongM15\", data, goldLongM15);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP15(long[] data) {\n+        for (int j = 0; j < RANGE - 15; j++) {\n+            data[j + 15] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP15\")\n+    @Warmup(0)\n+    public static void runLongP15() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP15(data);\n+        verify(\"testLongP15\", data, goldLongP15);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongM16(long[] data) {\n+        for (int j = 16; j < RANGE; j++) {\n+            data[j + -16] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongM16\")\n+    @Warmup(0)\n+    public static void runLongM16() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongM16(data);\n+        verify(\"testLongM16\", data, goldLongM16);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP16(long[] data) {\n+        for (int j = 0; j < RANGE - 16; j++) {\n+            data[j + 16] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP16\")\n+    @Warmup(0)\n+    public static void runLongP16() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP16(data);\n+        verify(\"testLongP16\", data, goldLongP16);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongM31(long[] data) {\n+        for (int j = 31; j < RANGE; j++) {\n+            data[j + -31] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongM31\")\n+    @Warmup(0)\n+    public static void runLongM31() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongM31(data);\n+        verify(\"testLongM31\", data, goldLongM31);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP31(long[] data) {\n+        for (int j = 0; j < RANGE - 31; j++) {\n+            data[j + 31] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP31\")\n+    @Warmup(0)\n+    public static void runLongP31() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP31(data);\n+        verify(\"testLongP31\", data, goldLongP31);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongM32(long[] data) {\n+        for (int j = 32; j < RANGE; j++) {\n+            data[j + -32] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongM32\")\n+    @Warmup(0)\n+    public static void runLongM32() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongM32(data);\n+        verify(\"testLongM32\", data, goldLongM32);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP32(long[] data) {\n+        for (int j = 0; j < RANGE - 32; j++) {\n+            data[j + 32] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP32\")\n+    @Warmup(0)\n+    public static void runLongP32() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP32(data);\n+        verify(\"testLongP32\", data, goldLongP32);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongM63(long[] data) {\n+        for (int j = 63; j < RANGE; j++) {\n+            data[j + -63] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongM63\")\n+    @Warmup(0)\n+    public static void runLongM63() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongM63(data);\n+        verify(\"testLongM63\", data, goldLongM63);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP63(long[] data) {\n+        for (int j = 0; j < RANGE - 63; j++) {\n+            data[j + 63] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP63\")\n+    @Warmup(0)\n+    public static void runLongP63() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP63(data);\n+        verify(\"testLongP63\", data, goldLongP63);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongM64(long[] data) {\n+        for (int j = 64; j < RANGE; j++) {\n+            data[j + -64] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongM64\")\n+    @Warmup(0)\n+    public static void runLongM64() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongM64(data);\n+        verify(\"testLongM64\", data, goldLongM64);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP64(long[] data) {\n+        for (int j = 0; j < RANGE - 64; j++) {\n+            data[j + 64] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP64\")\n+    @Warmup(0)\n+    public static void runLongP64() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP64(data);\n+        verify(\"testLongP64\", data, goldLongP64);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongM65(long[] data) {\n+        for (int j = 65; j < RANGE; j++) {\n+            data[j + -65] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongM65\")\n+    @Warmup(0)\n+    public static void runLongM65() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongM65(data);\n+        verify(\"testLongM65\", data, goldLongM65);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP65(long[] data) {\n+        for (int j = 0; j < RANGE - 65; j++) {\n+            data[j + 65] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP65\")\n+    @Warmup(0)\n+    public static void runLongP65() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP65(data);\n+        verify(\"testLongP65\", data, goldLongP65);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongM128(long[] data) {\n+        for (int j = 128; j < RANGE; j++) {\n+            data[j + -128] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongM128\")\n+    @Warmup(0)\n+    public static void runLongM128() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongM128(data);\n+        verify(\"testLongM128\", data, goldLongM128);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP128(long[] data) {\n+        for (int j = 0; j < RANGE - 128; j++) {\n+            data[j + 128] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP128\")\n+    @Warmup(0)\n+    public static void runLongP128() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP128(data);\n+        verify(\"testLongP128\", data, goldLongP128);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongM129(long[] data) {\n+        for (int j = 129; j < RANGE; j++) {\n+            data[j + -129] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongM129\")\n+    @Warmup(0)\n+    public static void runLongM129() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongM129(data);\n+        verify(\"testLongM129\", data, goldLongM129);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP129(long[] data) {\n+        for (int j = 0; j < RANGE - 129; j++) {\n+            data[j + 129] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP129\")\n+    @Warmup(0)\n+    public static void runLongP129() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP129(data);\n+        verify(\"testLongP129\", data, goldLongP129);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongM192(long[] data) {\n+        for (int j = 192; j < RANGE; j++) {\n+            data[j + -192] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongM192\")\n+    @Warmup(0)\n+    public static void runLongM192() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongM192(data);\n+        verify(\"testLongM192\", data, goldLongM192);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP192(long[] data) {\n+        for (int j = 0; j < RANGE - 192; j++) {\n+            data[j + 192] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP192\")\n+    @Warmup(0)\n+    public static void runLongP192() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP192(data);\n+        verify(\"testLongP192\", data, goldLongP192);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP0(short[] data) {\n+        for (int j = 0; j < RANGE; j++) {\n+            data[j + 0] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP0\")\n+    @Warmup(0)\n+    public static void runShortP0() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP0(data);\n+        verify(\"testShortP0\", data, goldShortP0);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortM1(short[] data) {\n+        for (int j = 1; j < RANGE; j++) {\n+            data[j + -1] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortM1\")\n+    @Warmup(0)\n+    public static void runShortM1() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortM1(data);\n+        verify(\"testShortM1\", data, goldShortM1);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    \/\/ positive byte_offset 2 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 2\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    \/\/ positive byte_offset 2 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 2\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/ positive byte_offset 2 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 2\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    \/\/ positive byte_offset 2 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 2\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP1(short[] data) {\n+        for (int j = 0; j < RANGE - 1; j++) {\n+            data[j + 1] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP1\")\n+    @Warmup(0)\n+    public static void runShortP1() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP1(data);\n+        verify(\"testShortP1\", data, goldShortP1);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortM2(short[] data) {\n+        for (int j = 2; j < RANGE; j++) {\n+            data[j + -2] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortM2\")\n+    @Warmup(0)\n+    public static void runShortM2() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortM2(data);\n+        verify(\"testShortM2\", data, goldShortM2);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    \/\/ positive byte_offset 4 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    \/\/ positive byte_offset 4 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/ positive byte_offset 4 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    \/\/ positive byte_offset 4 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP2(short[] data) {\n+        for (int j = 0; j < RANGE - 2; j++) {\n+            data[j + 2] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP2\")\n+    @Warmup(0)\n+    public static void runShortP2() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP2(data);\n+        verify(\"testShortP2\", data, goldShortP2);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortM3(short[] data) {\n+        for (int j = 3; j < RANGE; j++) {\n+            data[j + -3] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortM3\")\n+    @Warmup(0)\n+    public static void runShortM3() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortM3(data);\n+        verify(\"testShortM3\", data, goldShortM3);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    \/\/ positive byte_offset 6 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 6\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    \/\/ positive byte_offset 6 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 6\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/ positive byte_offset 6 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 6\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    \/\/ positive byte_offset 6 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 6\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP3(short[] data) {\n+        for (int j = 0; j < RANGE - 3; j++) {\n+            data[j + 3] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP3\")\n+    @Warmup(0)\n+    public static void runShortP3() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP3(data);\n+        verify(\"testShortP3\", data, goldShortP3);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortM4(short[] data) {\n+        for (int j = 4; j < RANGE; j++) {\n+            data[j + -4] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortM4\")\n+    @Warmup(0)\n+    public static void runShortM4() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortM4(data);\n+        verify(\"testShortM4\", data, goldShortM4);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    \/\/ positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    \/\/ positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/ positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 8\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    \/\/ positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP4(short[] data) {\n+        for (int j = 0; j < RANGE - 4; j++) {\n+            data[j + 4] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP4\")\n+    @Warmup(0)\n+    public static void runShortP4() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP4(data);\n+        verify(\"testShortP4\", data, goldShortP4);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortM7(short[] data) {\n+        for (int j = 7; j < RANGE; j++) {\n+            data[j + -7] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortM7\")\n+    @Warmup(0)\n+    public static void runShortM7() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortM7(data);\n+        verify(\"testShortM7\", data, goldShortM7);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    \/\/ positive byte_offset 14 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 14\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    \/\/ positive byte_offset 14 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 14\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/ positive byte_offset 14 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 14\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    \/\/ positive byte_offset 14 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 14\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP7(short[] data) {\n+        for (int j = 0; j < RANGE - 7; j++) {\n+            data[j + 7] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP7\")\n+    @Warmup(0)\n+    public static void runShortP7() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP7(data);\n+        verify(\"testShortP7\", data, goldShortP7);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortM8(short[] data) {\n+        for (int j = 8; j < RANGE; j++) {\n+            data[j + -8] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortM8\")\n+    @Warmup(0)\n+    public static void runShortM8() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortM8(data);\n+        verify(\"testShortM8\", data, goldShortM8);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    \/\/ positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/ positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 16\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    \/\/ positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP8(short[] data) {\n+        for (int j = 0; j < RANGE - 8; j++) {\n+            data[j + 8] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP8\")\n+    @Warmup(0)\n+    public static void runShortP8() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP8(data);\n+        verify(\"testShortP8\", data, goldShortP8);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortM15(short[] data) {\n+        for (int j = 15; j < RANGE; j++) {\n+            data[j + -15] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortM15\")\n+    @Warmup(0)\n+    public static void runShortM15() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortM15(data);\n+        verify(\"testShortM15\", data, goldShortM15);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    \/\/ positive byte_offset 30 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 30\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 30\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/ positive byte_offset 30 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 30\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 30\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    \/\/ positive byte_offset 30 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 30\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 30\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP15(short[] data) {\n+        for (int j = 0; j < RANGE - 15; j++) {\n+            data[j + 15] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP15\")\n+    @Warmup(0)\n+    public static void runShortP15() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP15(data);\n+        verify(\"testShortP15\", data, goldShortP15);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortM16(short[] data) {\n+        for (int j = 16; j < RANGE; j++) {\n+            data[j + -16] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortM16\")\n+    @Warmup(0)\n+    public static void runShortM16() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortM16(data);\n+        verify(\"testShortM16\", data, goldShortM16);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/ positive byte_offset 32 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 32\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP16(short[] data) {\n+        for (int j = 0; j < RANGE - 16; j++) {\n+            data[j + 16] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP16\")\n+    @Warmup(0)\n+    public static void runShortP16() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP16(data);\n+        verify(\"testShortP16\", data, goldShortP16);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortM31(short[] data) {\n+        for (int j = 31; j < RANGE; j++) {\n+            data[j + -31] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortM31\")\n+    @Warmup(0)\n+    public static void runShortM31() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortM31(data);\n+        verify(\"testShortM31\", data, goldShortM31);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/ positive byte_offset 62 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 62\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 62\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP31(short[] data) {\n+        for (int j = 0; j < RANGE - 31; j++) {\n+            data[j + 31] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP31\")\n+    @Warmup(0)\n+    public static void runShortP31() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP31(data);\n+        verify(\"testShortP31\", data, goldShortP31);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortM32(short[] data) {\n+        for (int j = 32; j < RANGE; j++) {\n+            data[j + -32] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortM32\")\n+    @Warmup(0)\n+    public static void runShortM32() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortM32(data);\n+        verify(\"testShortM32\", data, goldShortM32);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP32(short[] data) {\n+        for (int j = 0; j < RANGE - 32; j++) {\n+            data[j + 32] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP32\")\n+    @Warmup(0)\n+    public static void runShortP32() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP32(data);\n+        verify(\"testShortP32\", data, goldShortP32);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortM63(short[] data) {\n+        for (int j = 63; j < RANGE; j++) {\n+            data[j + -63] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortM63\")\n+    @Warmup(0)\n+    public static void runShortM63() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortM63(data);\n+        verify(\"testShortM63\", data, goldShortM63);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP63(short[] data) {\n+        for (int j = 0; j < RANGE - 63; j++) {\n+            data[j + 63] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP63\")\n+    @Warmup(0)\n+    public static void runShortP63() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP63(data);\n+        verify(\"testShortP63\", data, goldShortP63);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortM64(short[] data) {\n+        for (int j = 64; j < RANGE; j++) {\n+            data[j + -64] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortM64\")\n+    @Warmup(0)\n+    public static void runShortM64() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortM64(data);\n+        verify(\"testShortM64\", data, goldShortM64);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP64(short[] data) {\n+        for (int j = 0; j < RANGE - 64; j++) {\n+            data[j + 64] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP64\")\n+    @Warmup(0)\n+    public static void runShortP64() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP64(data);\n+        verify(\"testShortP64\", data, goldShortP64);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortM65(short[] data) {\n+        for (int j = 65; j < RANGE; j++) {\n+            data[j + -65] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortM65\")\n+    @Warmup(0)\n+    public static void runShortM65() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortM65(data);\n+        verify(\"testShortM65\", data, goldShortM65);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP65(short[] data) {\n+        for (int j = 0; j < RANGE - 65; j++) {\n+            data[j + 65] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP65\")\n+    @Warmup(0)\n+    public static void runShortP65() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP65(data);\n+        verify(\"testShortP65\", data, goldShortP65);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortM128(short[] data) {\n+        for (int j = 128; j < RANGE; j++) {\n+            data[j + -128] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortM128\")\n+    @Warmup(0)\n+    public static void runShortM128() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortM128(data);\n+        verify(\"testShortM128\", data, goldShortM128);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP128(short[] data) {\n+        for (int j = 0; j < RANGE - 128; j++) {\n+            data[j + 128] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP128\")\n+    @Warmup(0)\n+    public static void runShortP128() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP128(data);\n+        verify(\"testShortP128\", data, goldShortP128);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortM129(short[] data) {\n+        for (int j = 129; j < RANGE; j++) {\n+            data[j + -129] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortM129\")\n+    @Warmup(0)\n+    public static void runShortM129() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortM129(data);\n+        verify(\"testShortM129\", data, goldShortM129);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP129(short[] data) {\n+        for (int j = 0; j < RANGE - 129; j++) {\n+            data[j + 129] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP129\")\n+    @Warmup(0)\n+    public static void runShortP129() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP129(data);\n+        verify(\"testShortP129\", data, goldShortP129);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortM192(short[] data) {\n+        for (int j = 192; j < RANGE; j++) {\n+            data[j + -192] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortM192\")\n+    @Warmup(0)\n+    public static void runShortM192() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortM192(data);\n+        verify(\"testShortM192\", data, goldShortM192);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP192(short[] data) {\n+        for (int j = 0; j < RANGE - 192; j++) {\n+            data[j + 192] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP192\")\n+    @Warmup(0)\n+    public static void runShortP192() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP192(data);\n+        verify(\"testShortP192\", data, goldShortP192);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP0(char[] data) {\n+        for (int j = 0; j < RANGE; j++) {\n+            data[j + 0] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP0\")\n+    @Warmup(0)\n+    public static void runCharP0() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP0(data);\n+        verify(\"testCharP0\", data, goldCharP0);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharM1(char[] data) {\n+        for (int j = 1; j < RANGE; j++) {\n+            data[j + -1] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharM1\")\n+    @Warmup(0)\n+    public static void runCharM1() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharM1(data);\n+        verify(\"testCharM1\", data, goldCharM1);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    \/\/ positive byte_offset 2 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 2\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    \/\/ positive byte_offset 2 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 2\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/ positive byte_offset 2 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 2\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    \/\/ positive byte_offset 2 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 2\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP1(char[] data) {\n+        for (int j = 0; j < RANGE - 1; j++) {\n+            data[j + 1] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP1\")\n+    @Warmup(0)\n+    public static void runCharP1() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP1(data);\n+        verify(\"testCharP1\", data, goldCharP1);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharM2(char[] data) {\n+        for (int j = 2; j < RANGE; j++) {\n+            data[j + -2] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharM2\")\n+    @Warmup(0)\n+    public static void runCharM2() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharM2(data);\n+        verify(\"testCharM2\", data, goldCharM2);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    \/\/ positive byte_offset 4 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    \/\/ positive byte_offset 4 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/ positive byte_offset 4 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    \/\/ positive byte_offset 4 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP2(char[] data) {\n+        for (int j = 0; j < RANGE - 2; j++) {\n+            data[j + 2] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP2\")\n+    @Warmup(0)\n+    public static void runCharP2() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP2(data);\n+        verify(\"testCharP2\", data, goldCharP2);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharM3(char[] data) {\n+        for (int j = 3; j < RANGE; j++) {\n+            data[j + -3] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharM3\")\n+    @Warmup(0)\n+    public static void runCharM3() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharM3(data);\n+        verify(\"testCharM3\", data, goldCharM3);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    \/\/ positive byte_offset 6 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 6\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    \/\/ positive byte_offset 6 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 6\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/ positive byte_offset 6 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 6\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    \/\/ positive byte_offset 6 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 6\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP3(char[] data) {\n+        for (int j = 0; j < RANGE - 3; j++) {\n+            data[j + 3] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP3\")\n+    @Warmup(0)\n+    public static void runCharP3() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP3(data);\n+        verify(\"testCharP3\", data, goldCharP3);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharM4(char[] data) {\n+        for (int j = 4; j < RANGE; j++) {\n+            data[j + -4] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharM4\")\n+    @Warmup(0)\n+    public static void runCharM4() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharM4(data);\n+        verify(\"testCharM4\", data, goldCharM4);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    \/\/ positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    \/\/ positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/ positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 8\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    \/\/ positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP4(char[] data) {\n+        for (int j = 0; j < RANGE - 4; j++) {\n+            data[j + 4] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP4\")\n+    @Warmup(0)\n+    public static void runCharP4() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP4(data);\n+        verify(\"testCharP4\", data, goldCharP4);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharM7(char[] data) {\n+        for (int j = 7; j < RANGE; j++) {\n+            data[j + -7] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharM7\")\n+    @Warmup(0)\n+    public static void runCharM7() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharM7(data);\n+        verify(\"testCharM7\", data, goldCharM7);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    \/\/ positive byte_offset 14 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 14\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    \/\/ positive byte_offset 14 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 14\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/ positive byte_offset 14 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 14\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    \/\/ positive byte_offset 14 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 14\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP7(char[] data) {\n+        for (int j = 0; j < RANGE - 7; j++) {\n+            data[j + 7] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP7\")\n+    @Warmup(0)\n+    public static void runCharP7() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP7(data);\n+        verify(\"testCharP7\", data, goldCharP7);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharM8(char[] data) {\n+        for (int j = 8; j < RANGE; j++) {\n+            data[j + -8] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharM8\")\n+    @Warmup(0)\n+    public static void runCharM8() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharM8(data);\n+        verify(\"testCharM8\", data, goldCharM8);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    \/\/ positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/ positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 16\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    \/\/ positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP8(char[] data) {\n+        for (int j = 0; j < RANGE - 8; j++) {\n+            data[j + 8] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP8\")\n+    @Warmup(0)\n+    public static void runCharP8() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP8(data);\n+        verify(\"testCharP8\", data, goldCharP8);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharM15(char[] data) {\n+        for (int j = 15; j < RANGE; j++) {\n+            data[j + -15] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharM15\")\n+    @Warmup(0)\n+    public static void runCharM15() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharM15(data);\n+        verify(\"testCharM15\", data, goldCharM15);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    \/\/ positive byte_offset 30 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 30\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 30\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/ positive byte_offset 30 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 30\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 30\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    \/\/ positive byte_offset 30 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 30\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 30\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP15(char[] data) {\n+        for (int j = 0; j < RANGE - 15; j++) {\n+            data[j + 15] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP15\")\n+    @Warmup(0)\n+    public static void runCharP15() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP15(data);\n+        verify(\"testCharP15\", data, goldCharP15);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharM16(char[] data) {\n+        for (int j = 16; j < RANGE; j++) {\n+            data[j + -16] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharM16\")\n+    @Warmup(0)\n+    public static void runCharM16() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharM16(data);\n+        verify(\"testCharM16\", data, goldCharM16);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/ positive byte_offset 32 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 32\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP16(char[] data) {\n+        for (int j = 0; j < RANGE - 16; j++) {\n+            data[j + 16] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP16\")\n+    @Warmup(0)\n+    public static void runCharP16() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP16(data);\n+        verify(\"testCharP16\", data, goldCharP16);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharM31(char[] data) {\n+        for (int j = 31; j < RANGE; j++) {\n+            data[j + -31] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharM31\")\n+    @Warmup(0)\n+    public static void runCharM31() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharM31(data);\n+        verify(\"testCharM31\", data, goldCharM31);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/ positive byte_offset 62 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 62\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 62\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP31(char[] data) {\n+        for (int j = 0; j < RANGE - 31; j++) {\n+            data[j + 31] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP31\")\n+    @Warmup(0)\n+    public static void runCharP31() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP31(data);\n+        verify(\"testCharP31\", data, goldCharP31);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharM32(char[] data) {\n+        for (int j = 32; j < RANGE; j++) {\n+            data[j + -32] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharM32\")\n+    @Warmup(0)\n+    public static void runCharM32() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharM32(data);\n+        verify(\"testCharM32\", data, goldCharM32);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP32(char[] data) {\n+        for (int j = 0; j < RANGE - 32; j++) {\n+            data[j + 32] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP32\")\n+    @Warmup(0)\n+    public static void runCharP32() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP32(data);\n+        verify(\"testCharP32\", data, goldCharP32);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharM63(char[] data) {\n+        for (int j = 63; j < RANGE; j++) {\n+            data[j + -63] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharM63\")\n+    @Warmup(0)\n+    public static void runCharM63() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharM63(data);\n+        verify(\"testCharM63\", data, goldCharM63);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP63(char[] data) {\n+        for (int j = 0; j < RANGE - 63; j++) {\n+            data[j + 63] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP63\")\n+    @Warmup(0)\n+    public static void runCharP63() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP63(data);\n+        verify(\"testCharP63\", data, goldCharP63);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharM64(char[] data) {\n+        for (int j = 64; j < RANGE; j++) {\n+            data[j + -64] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharM64\")\n+    @Warmup(0)\n+    public static void runCharM64() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharM64(data);\n+        verify(\"testCharM64\", data, goldCharM64);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP64(char[] data) {\n+        for (int j = 0; j < RANGE - 64; j++) {\n+            data[j + 64] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP64\")\n+    @Warmup(0)\n+    public static void runCharP64() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP64(data);\n+        verify(\"testCharP64\", data, goldCharP64);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharM65(char[] data) {\n+        for (int j = 65; j < RANGE; j++) {\n+            data[j + -65] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharM65\")\n+    @Warmup(0)\n+    public static void runCharM65() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharM65(data);\n+        verify(\"testCharM65\", data, goldCharM65);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP65(char[] data) {\n+        for (int j = 0; j < RANGE - 65; j++) {\n+            data[j + 65] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP65\")\n+    @Warmup(0)\n+    public static void runCharP65() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP65(data);\n+        verify(\"testCharP65\", data, goldCharP65);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharM128(char[] data) {\n+        for (int j = 128; j < RANGE; j++) {\n+            data[j + -128] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharM128\")\n+    @Warmup(0)\n+    public static void runCharM128() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharM128(data);\n+        verify(\"testCharM128\", data, goldCharM128);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP128(char[] data) {\n+        for (int j = 0; j < RANGE - 128; j++) {\n+            data[j + 128] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP128\")\n+    @Warmup(0)\n+    public static void runCharP128() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP128(data);\n+        verify(\"testCharP128\", data, goldCharP128);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharM129(char[] data) {\n+        for (int j = 129; j < RANGE; j++) {\n+            data[j + -129] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharM129\")\n+    @Warmup(0)\n+    public static void runCharM129() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharM129(data);\n+        verify(\"testCharM129\", data, goldCharM129);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP129(char[] data) {\n+        for (int j = 0; j < RANGE - 129; j++) {\n+            data[j + 129] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP129\")\n+    @Warmup(0)\n+    public static void runCharP129() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP129(data);\n+        verify(\"testCharP129\", data, goldCharP129);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharM192(char[] data) {\n+        for (int j = 192; j < RANGE; j++) {\n+            data[j + -192] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharM192\")\n+    @Warmup(0)\n+    public static void runCharM192() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharM192(data);\n+        verify(\"testCharM192\", data, goldCharM192);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP192(char[] data) {\n+        for (int j = 0; j < RANGE - 192; j++) {\n+            data[j + 192] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP192\")\n+    @Warmup(0)\n+    public static void runCharP192() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP192(data);\n+        verify(\"testCharP192\", data, goldCharP192);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteP0(byte[] data) {\n+        for (int j = 0; j < RANGE; j++) {\n+            data[j + 0] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP0\")\n+    @Warmup(0)\n+    public static void runByteP0() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP0(data);\n+        verify(\"testByteP0\", data, goldByteP0);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteM1(byte[] data) {\n+        for (int j = 1; j < RANGE; j++) {\n+            data[j + -1] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteM1\")\n+    @Warmup(0)\n+    public static void runByteM1() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteM1(data);\n+        verify(\"testByteM1\", data, goldByteM1);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    \/\/ positive byte_offset 1 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 1\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 1\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    \/\/ positive byte_offset 1 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 1\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 1\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    \/\/ positive byte_offset 1 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 1\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 1\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 32\n+    \/\/ positive byte_offset 1 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 1\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 1\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteP1(byte[] data) {\n+        for (int j = 0; j < RANGE - 1; j++) {\n+            data[j + 1] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP1\")\n+    @Warmup(0)\n+    public static void runByteP1() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP1(data);\n+        verify(\"testByteP1\", data, goldByteP1);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteM2(byte[] data) {\n+        for (int j = 2; j < RANGE; j++) {\n+            data[j + -2] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteM2\")\n+    @Warmup(0)\n+    public static void runByteM2() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteM2(data);\n+        verify(\"testByteM2\", data, goldByteM2);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    \/\/ positive byte_offset 2 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 2\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    \/\/ positive byte_offset 2 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 2\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    \/\/ positive byte_offset 2 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 2\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 32\n+    \/\/ positive byte_offset 2 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 2\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteP2(byte[] data) {\n+        for (int j = 0; j < RANGE - 2; j++) {\n+            data[j + 2] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP2\")\n+    @Warmup(0)\n+    public static void runByteP2() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP2(data);\n+        verify(\"testByteP2\", data, goldByteP2);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteM3(byte[] data) {\n+        for (int j = 3; j < RANGE; j++) {\n+            data[j + -3] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteM3\")\n+    @Warmup(0)\n+    public static void runByteM3() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteM3(data);\n+        verify(\"testByteM3\", data, goldByteM3);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    \/\/ positive byte_offset 3 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 3\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 3\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    \/\/ positive byte_offset 3 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 3\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 3\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    \/\/ positive byte_offset 3 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 3\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 3\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 32\n+    \/\/ positive byte_offset 3 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 3\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 3\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteP3(byte[] data) {\n+        for (int j = 0; j < RANGE - 3; j++) {\n+            data[j + 3] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP3\")\n+    @Warmup(0)\n+    public static void runByteP3() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP3(data);\n+        verify(\"testByteP3\", data, goldByteP3);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteM4(byte[] data) {\n+        for (int j = 4; j < RANGE; j++) {\n+            data[j + -4] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteM4\")\n+    @Warmup(0)\n+    public static void runByteM4() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteM4(data);\n+        verify(\"testByteM4\", data, goldByteM4);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    \/\/ positive byte_offset 4 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    \/\/ positive byte_offset 4 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    \/\/ positive byte_offset 4 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 32\n+    \/\/ positive byte_offset 4 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteP4(byte[] data) {\n+        for (int j = 0; j < RANGE - 4; j++) {\n+            data[j + 4] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP4\")\n+    @Warmup(0)\n+    public static void runByteP4() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP4(data);\n+        verify(\"testByteP4\", data, goldByteP4);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteM7(byte[] data) {\n+        for (int j = 7; j < RANGE; j++) {\n+            data[j + -7] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteM7\")\n+    @Warmup(0)\n+    public static void runByteM7() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteM7(data);\n+        verify(\"testByteM7\", data, goldByteM7);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    \/\/ positive byte_offset 7 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 7\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 7\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    \/\/ positive byte_offset 7 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 7\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 7\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    \/\/ positive byte_offset 7 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 7\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 7\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 32\n+    \/\/ positive byte_offset 7 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 7\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 7\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteP7(byte[] data) {\n+        for (int j = 0; j < RANGE - 7; j++) {\n+            data[j + 7] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP7\")\n+    @Warmup(0)\n+    public static void runByteP7() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP7(data);\n+        verify(\"testByteP7\", data, goldByteP7);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteM8(byte[] data) {\n+        for (int j = 8; j < RANGE; j++) {\n+            data[j + -8] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteM8\")\n+    @Warmup(0)\n+    public static void runByteM8() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteM8(data);\n+        verify(\"testByteM8\", data, goldByteM8);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    \/\/ positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    \/\/ positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    \/\/ positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 8\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 32\n+    \/\/ positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteP8(byte[] data) {\n+        for (int j = 0; j < RANGE - 8; j++) {\n+            data[j + 8] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP8\")\n+    @Warmup(0)\n+    public static void runByteP8() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP8(data);\n+        verify(\"testByteP8\", data, goldByteP8);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteM15(byte[] data) {\n+        for (int j = 15; j < RANGE; j++) {\n+            data[j + -15] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteM15\")\n+    @Warmup(0)\n+    public static void runByteM15() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteM15(data);\n+        verify(\"testByteM15\", data, goldByteM15);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    \/\/ positive byte_offset 15 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 15\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 15\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    \/\/ positive byte_offset 15 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 15\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 15\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    \/\/ positive byte_offset 15 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 15\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 15\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 32\n+    \/\/ positive byte_offset 15 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 15\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 15\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteP15(byte[] data) {\n+        for (int j = 0; j < RANGE - 15; j++) {\n+            data[j + 15] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP15\")\n+    @Warmup(0)\n+    public static void runByteP15() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP15(data);\n+        verify(\"testByteP15\", data, goldByteP15);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteM16(byte[] data) {\n+        for (int j = 16; j < RANGE; j++) {\n+            data[j + -16] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteM16\")\n+    @Warmup(0)\n+    public static void runByteM16() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteM16(data);\n+        verify(\"testByteM16\", data, goldByteM16);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    \/\/ positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    \/\/ positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 16\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 32\n+    \/\/ positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteP16(byte[] data) {\n+        for (int j = 0; j < RANGE - 16; j++) {\n+            data[j + 16] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP16\")\n+    @Warmup(0)\n+    public static void runByteP16() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP16(data);\n+        verify(\"testByteP16\", data, goldByteP16);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteM31(byte[] data) {\n+        for (int j = 31; j < RANGE; j++) {\n+            data[j + -31] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteM31\")\n+    @Warmup(0)\n+    public static void runByteM31() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteM31(data);\n+        verify(\"testByteM31\", data, goldByteM31);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    \/\/ positive byte_offset 31 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 31\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 31\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    \/\/ positive byte_offset 31 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 31\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 31\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 32\n+    \/\/ positive byte_offset 31 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 31\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 31\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteP31(byte[] data) {\n+        for (int j = 0; j < RANGE - 31; j++) {\n+            data[j + 31] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP31\")\n+    @Warmup(0)\n+    public static void runByteP31() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP31(data);\n+        verify(\"testByteP31\", data, goldByteP31);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteM32(byte[] data) {\n+        for (int j = 32; j < RANGE; j++) {\n+            data[j + -32] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteM32\")\n+    @Warmup(0)\n+    public static void runByteM32() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteM32(data);\n+        verify(\"testByteM32\", data, goldByteM32);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    \/\/ positive byte_offset 32 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 32\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteP32(byte[] data) {\n+        for (int j = 0; j < RANGE - 32; j++) {\n+            data[j + 32] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP32\")\n+    @Warmup(0)\n+    public static void runByteP32() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP32(data);\n+        verify(\"testByteP32\", data, goldByteP32);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteM63(byte[] data) {\n+        for (int j = 63; j < RANGE; j++) {\n+            data[j + -63] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteM63\")\n+    @Warmup(0)\n+    public static void runByteM63() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteM63(data);\n+        verify(\"testByteM63\", data, goldByteM63);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    \/\/ positive byte_offset 63 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 63\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 4\", \"MaxVectorSize\", \"> 63\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteP63(byte[] data) {\n+        for (int j = 0; j < RANGE - 63; j++) {\n+            data[j + 63] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP63\")\n+    @Warmup(0)\n+    public static void runByteP63() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP63(data);\n+        verify(\"testByteP63\", data, goldByteP63);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteM64(byte[] data) {\n+        for (int j = 64; j < RANGE; j++) {\n+            data[j + -64] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteM64\")\n+    @Warmup(0)\n+    public static void runByteM64() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteM64(data);\n+        verify(\"testByteM64\", data, goldByteM64);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteP64(byte[] data) {\n+        for (int j = 0; j < RANGE - 64; j++) {\n+            data[j + 64] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP64\")\n+    @Warmup(0)\n+    public static void runByteP64() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP64(data);\n+        verify(\"testByteP64\", data, goldByteP64);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteM65(byte[] data) {\n+        for (int j = 65; j < RANGE; j++) {\n+            data[j + -65] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteM65\")\n+    @Warmup(0)\n+    public static void runByteM65() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteM65(data);\n+        verify(\"testByteM65\", data, goldByteM65);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteP65(byte[] data) {\n+        for (int j = 0; j < RANGE - 65; j++) {\n+            data[j + 65] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP65\")\n+    @Warmup(0)\n+    public static void runByteP65() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP65(data);\n+        verify(\"testByteP65\", data, goldByteP65);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteM128(byte[] data) {\n+        for (int j = 128; j < RANGE; j++) {\n+            data[j + -128] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteM128\")\n+    @Warmup(0)\n+    public static void runByteM128() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteM128(data);\n+        verify(\"testByteM128\", data, goldByteM128);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteP128(byte[] data) {\n+        for (int j = 0; j < RANGE - 128; j++) {\n+            data[j + 128] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP128\")\n+    @Warmup(0)\n+    public static void runByteP128() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP128(data);\n+        verify(\"testByteP128\", data, goldByteP128);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteM129(byte[] data) {\n+        for (int j = 129; j < RANGE; j++) {\n+            data[j + -129] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteM129\")\n+    @Warmup(0)\n+    public static void runByteM129() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteM129(data);\n+        verify(\"testByteM129\", data, goldByteM129);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteP129(byte[] data) {\n+        for (int j = 0; j < RANGE - 129; j++) {\n+            data[j + 129] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP129\")\n+    @Warmup(0)\n+    public static void runByteP129() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP129(data);\n+        verify(\"testByteP129\", data, goldByteP129);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteM192(byte[] data) {\n+        for (int j = 192; j < RANGE; j++) {\n+            data[j + -192] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteM192\")\n+    @Warmup(0)\n+    public static void runByteM192() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteM192(data);\n+        verify(\"testByteM192\", data, goldByteM192);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ cpu: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ cpu: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteP192(byte[] data) {\n+        for (int j = 0; j < RANGE - 192; j++) {\n+            data[j + 192] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP192\")\n+    @Warmup(0)\n+    public static void runByteP192() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP192(data);\n+        verify(\"testByteP192\", data, goldByteP192);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP0(float[] data) {\n+        for (int j = 0; j < RANGE; j++) {\n+            data[j + 0] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP0\")\n+    @Warmup(0)\n+    public static void runFloatP0() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP0(data);\n+        verify(\"testFloatP0\", data, goldFloatP0);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatM1(float[] data) {\n+        for (int j = 1; j < RANGE; j++) {\n+            data[j + -1] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatM1\")\n+    @Warmup(0)\n+    public static void runFloatM1() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatM1(data);\n+        verify(\"testFloatM1\", data, goldFloatM1);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    \/\/ positive byte_offset 4 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    \/\/ positive byte_offset 4 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 4\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    \/\/ positive byte_offset 4 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 4\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    \/\/ positive byte_offset 4 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP1(float[] data) {\n+        for (int j = 0; j < RANGE - 1; j++) {\n+            data[j + 1] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP1\")\n+    @Warmup(0)\n+    public static void runFloatP1() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP1(data);\n+        verify(\"testFloatP1\", data, goldFloatP1);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatM2(float[] data) {\n+        for (int j = 2; j < RANGE; j++) {\n+            data[j + -2] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatM2\")\n+    @Warmup(0)\n+    public static void runFloatM2() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatM2(data);\n+        verify(\"testFloatM2\", data, goldFloatM2);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    \/\/ positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    \/\/ positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    \/\/ positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    \/\/ positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP2(float[] data) {\n+        for (int j = 0; j < RANGE - 2; j++) {\n+            data[j + 2] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP2\")\n+    @Warmup(0)\n+    public static void runFloatP2() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP2(data);\n+        verify(\"testFloatP2\", data, goldFloatP2);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatM3(float[] data) {\n+        for (int j = 3; j < RANGE; j++) {\n+            data[j + -3] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatM3\")\n+    @Warmup(0)\n+    public static void runFloatM3() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatM3(data);\n+        verify(\"testFloatM3\", data, goldFloatM3);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    \/\/ positive byte_offset 12 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 12\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    \/\/ positive byte_offset 12 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 12\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    \/\/ positive byte_offset 12 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 12\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    \/\/ positive byte_offset 12 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 12\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP3(float[] data) {\n+        for (int j = 0; j < RANGE - 3; j++) {\n+            data[j + 3] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP3\")\n+    @Warmup(0)\n+    public static void runFloatP3() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP3(data);\n+        verify(\"testFloatP3\", data, goldFloatP3);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatM4(float[] data) {\n+        for (int j = 4; j < RANGE; j++) {\n+            data[j + -4] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatM4\")\n+    @Warmup(0)\n+    public static void runFloatM4() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatM4(data);\n+        verify(\"testFloatM4\", data, goldFloatM4);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    \/\/ positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    \/\/ positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    \/\/ positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP4(float[] data) {\n+        for (int j = 0; j < RANGE - 4; j++) {\n+            data[j + 4] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP4\")\n+    @Warmup(0)\n+    public static void runFloatP4() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP4(data);\n+        verify(\"testFloatP4\", data, goldFloatP4);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatM7(float[] data) {\n+        for (int j = 7; j < RANGE; j++) {\n+            data[j + -7] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatM7\")\n+    @Warmup(0)\n+    public static void runFloatM7() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatM7(data);\n+        verify(\"testFloatM7\", data, goldFloatM7);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    \/\/ positive byte_offset 28 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 28\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    \/\/ positive byte_offset 28 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 28\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    \/\/ positive byte_offset 28 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 28\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP7(float[] data) {\n+        for (int j = 0; j < RANGE - 7; j++) {\n+            data[j + 7] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP7\")\n+    @Warmup(0)\n+    public static void runFloatP7() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP7(data);\n+        verify(\"testFloatP7\", data, goldFloatP7);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatM8(float[] data) {\n+        for (int j = 8; j < RANGE; j++) {\n+            data[j + -8] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatM8\")\n+    @Warmup(0)\n+    public static void runFloatM8() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatM8(data);\n+        verify(\"testFloatM8\", data, goldFloatM8);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    \/\/ positive byte_offset 32 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 32\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP8(float[] data) {\n+        for (int j = 0; j < RANGE - 8; j++) {\n+            data[j + 8] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP8\")\n+    @Warmup(0)\n+    public static void runFloatP8() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP8(data);\n+        verify(\"testFloatP8\", data, goldFloatP8);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatM15(float[] data) {\n+        for (int j = 15; j < RANGE; j++) {\n+            data[j + -15] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatM15\")\n+    @Warmup(0)\n+    public static void runFloatM15() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatM15(data);\n+        verify(\"testFloatM15\", data, goldFloatM15);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    \/\/ positive byte_offset 60 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 60\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 8\", \"MaxVectorSize\", \"> 60\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP15(float[] data) {\n+        for (int j = 0; j < RANGE - 15; j++) {\n+            data[j + 15] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP15\")\n+    @Warmup(0)\n+    public static void runFloatP15() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP15(data);\n+        verify(\"testFloatP15\", data, goldFloatP15);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatM16(float[] data) {\n+        for (int j = 16; j < RANGE; j++) {\n+            data[j + -16] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatM16\")\n+    @Warmup(0)\n+    public static void runFloatM16() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatM16(data);\n+        verify(\"testFloatM16\", data, goldFloatM16);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP16(float[] data) {\n+        for (int j = 0; j < RANGE - 16; j++) {\n+            data[j + 16] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP16\")\n+    @Warmup(0)\n+    public static void runFloatP16() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP16(data);\n+        verify(\"testFloatP16\", data, goldFloatP16);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatM31(float[] data) {\n+        for (int j = 31; j < RANGE; j++) {\n+            data[j + -31] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatM31\")\n+    @Warmup(0)\n+    public static void runFloatM31() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatM31(data);\n+        verify(\"testFloatM31\", data, goldFloatM31);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP31(float[] data) {\n+        for (int j = 0; j < RANGE - 31; j++) {\n+            data[j + 31] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP31\")\n+    @Warmup(0)\n+    public static void runFloatP31() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP31(data);\n+        verify(\"testFloatP31\", data, goldFloatP31);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatM32(float[] data) {\n+        for (int j = 32; j < RANGE; j++) {\n+            data[j + -32] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatM32\")\n+    @Warmup(0)\n+    public static void runFloatM32() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatM32(data);\n+        verify(\"testFloatM32\", data, goldFloatM32);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP32(float[] data) {\n+        for (int j = 0; j < RANGE - 32; j++) {\n+            data[j + 32] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP32\")\n+    @Warmup(0)\n+    public static void runFloatP32() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP32(data);\n+        verify(\"testFloatP32\", data, goldFloatP32);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatM63(float[] data) {\n+        for (int j = 63; j < RANGE; j++) {\n+            data[j + -63] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatM63\")\n+    @Warmup(0)\n+    public static void runFloatM63() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatM63(data);\n+        verify(\"testFloatM63\", data, goldFloatM63);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP63(float[] data) {\n+        for (int j = 0; j < RANGE - 63; j++) {\n+            data[j + 63] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP63\")\n+    @Warmup(0)\n+    public static void runFloatP63() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP63(data);\n+        verify(\"testFloatP63\", data, goldFloatP63);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatM64(float[] data) {\n+        for (int j = 64; j < RANGE; j++) {\n+            data[j + -64] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatM64\")\n+    @Warmup(0)\n+    public static void runFloatM64() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatM64(data);\n+        verify(\"testFloatM64\", data, goldFloatM64);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP64(float[] data) {\n+        for (int j = 0; j < RANGE - 64; j++) {\n+            data[j + 64] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP64\")\n+    @Warmup(0)\n+    public static void runFloatP64() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP64(data);\n+        verify(\"testFloatP64\", data, goldFloatP64);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatM65(float[] data) {\n+        for (int j = 65; j < RANGE; j++) {\n+            data[j + -65] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatM65\")\n+    @Warmup(0)\n+    public static void runFloatM65() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatM65(data);\n+        verify(\"testFloatM65\", data, goldFloatM65);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP65(float[] data) {\n+        for (int j = 0; j < RANGE - 65; j++) {\n+            data[j + 65] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP65\")\n+    @Warmup(0)\n+    public static void runFloatP65() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP65(data);\n+        verify(\"testFloatP65\", data, goldFloatP65);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatM128(float[] data) {\n+        for (int j = 128; j < RANGE; j++) {\n+            data[j + -128] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatM128\")\n+    @Warmup(0)\n+    public static void runFloatM128() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatM128(data);\n+        verify(\"testFloatM128\", data, goldFloatM128);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP128(float[] data) {\n+        for (int j = 0; j < RANGE - 128; j++) {\n+            data[j + 128] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP128\")\n+    @Warmup(0)\n+    public static void runFloatP128() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP128(data);\n+        verify(\"testFloatP128\", data, goldFloatP128);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatM129(float[] data) {\n+        for (int j = 129; j < RANGE; j++) {\n+            data[j + -129] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatM129\")\n+    @Warmup(0)\n+    public static void runFloatM129() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatM129(data);\n+        verify(\"testFloatM129\", data, goldFloatM129);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP129(float[] data) {\n+        for (int j = 0; j < RANGE - 129; j++) {\n+            data[j + 129] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP129\")\n+    @Warmup(0)\n+    public static void runFloatP129() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP129(data);\n+        verify(\"testFloatP129\", data, goldFloatP129);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatM192(float[] data) {\n+        for (int j = 192; j < RANGE; j++) {\n+            data[j + -192] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatM192\")\n+    @Warmup(0)\n+    public static void runFloatM192() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatM192(data);\n+        verify(\"testFloatM192\", data, goldFloatM192);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP192(float[] data) {\n+        for (int j = 0; j < RANGE - 192; j++) {\n+            data[j + 192] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP192\")\n+    @Warmup(0)\n+    public static void runFloatP192() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP192(data);\n+        verify(\"testFloatP192\", data, goldFloatP192);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP0(double[] data) {\n+        for (int j = 0; j < RANGE; j++) {\n+            data[j + 0] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP0\")\n+    @Warmup(0)\n+    public static void runDoubleP0() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP0(data);\n+        verify(\"testDoubleP0\", data, goldDoubleP0);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleM1(double[] data) {\n+        for (int j = 1; j < RANGE; j++) {\n+            data[j + -1] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleM1\")\n+    @Warmup(0)\n+    public static void runDoubleM1() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleM1(data);\n+        verify(\"testDoubleM1\", data, goldDoubleM1);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    \/\/ positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 16\", \"MaxVectorSize\", \"> 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    \/\/ positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 16\", \"MaxVectorSize\", \"> 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    \/\/ positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 16\", \"MaxVectorSize\", \"> 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    \/\/ positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 16\", \"MaxVectorSize\", \"> 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP1(double[] data) {\n+        for (int j = 0; j < RANGE - 1; j++) {\n+            data[j + 1] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP1\")\n+    @Warmup(0)\n+    public static void runDoubleP1() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP1(data);\n+        verify(\"testDoubleP1\", data, goldDoubleP1);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleM2(double[] data) {\n+        for (int j = 2; j < RANGE; j++) {\n+            data[j + -2] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleM2\")\n+    @Warmup(0)\n+    public static void runDoubleM2() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleM2(data);\n+        verify(\"testDoubleM2\", data, goldDoubleM2);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    \/\/ positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 16\", \"MaxVectorSize\", \"> 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    \/\/ positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 16\", \"MaxVectorSize\", \"> 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    \/\/ positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 16\", \"MaxVectorSize\", \"> 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP2(double[] data) {\n+        for (int j = 0; j < RANGE - 2; j++) {\n+            data[j + 2] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP2\")\n+    @Warmup(0)\n+    public static void runDoubleP2() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP2(data);\n+        verify(\"testDoubleP2\", data, goldDoubleP2);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleM3(double[] data) {\n+        for (int j = 3; j < RANGE; j++) {\n+            data[j + -3] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleM3\")\n+    @Warmup(0)\n+    public static void runDoubleM3() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleM3(data);\n+        verify(\"testDoubleM3\", data, goldDoubleM3);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    \/\/ positive byte_offset 24 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 16\", \"MaxVectorSize\", \"> 24\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    \/\/ positive byte_offset 24 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 16\", \"MaxVectorSize\", \"> 24\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    \/\/ positive byte_offset 24 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 16\", \"MaxVectorSize\", \"> 24\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP3(double[] data) {\n+        for (int j = 0; j < RANGE - 3; j++) {\n+            data[j + 3] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP3\")\n+    @Warmup(0)\n+    public static void runDoubleP3() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP3(data);\n+        verify(\"testDoubleP3\", data, goldDoubleP3);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleM4(double[] data) {\n+        for (int j = 4; j < RANGE; j++) {\n+            data[j + -4] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleM4\")\n+    @Warmup(0)\n+    public static void runDoubleM4() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleM4(data);\n+        verify(\"testDoubleM4\", data, goldDoubleM4);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    \/\/ positive byte_offset 32 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 16\", \"MaxVectorSize\", \"> 32\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP4(double[] data) {\n+        for (int j = 0; j < RANGE - 4; j++) {\n+            data[j + 4] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP4\")\n+    @Warmup(0)\n+    public static void runDoubleP4() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP4(data);\n+        verify(\"testDoubleP4\", data, goldDoubleP4);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleM7(double[] data) {\n+        for (int j = 7; j < RANGE; j++) {\n+            data[j + -7] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleM7\")\n+    @Warmup(0)\n+    public static void runDoubleM7() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleM7(data);\n+        verify(\"testDoubleM7\", data, goldDoubleM7);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    \/\/ positive byte_offset 56 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 56\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIfOr = {\"MaxVectorSize\", \"< 16\", \"MaxVectorSize\", \"> 56\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP7(double[] data) {\n+        for (int j = 0; j < RANGE - 7; j++) {\n+            data[j + 7] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP7\")\n+    @Warmup(0)\n+    public static void runDoubleP7() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP7(data);\n+        verify(\"testDoubleP7\", data, goldDoubleP7);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleM8(double[] data) {\n+        for (int j = 8; j < RANGE; j++) {\n+            data[j + -8] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleM8\")\n+    @Warmup(0)\n+    public static void runDoubleM8() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleM8(data);\n+        verify(\"testDoubleM8\", data, goldDoubleM8);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP8(double[] data) {\n+        for (int j = 0; j < RANGE - 8; j++) {\n+            data[j + 8] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP8\")\n+    @Warmup(0)\n+    public static void runDoubleP8() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP8(data);\n+        verify(\"testDoubleP8\", data, goldDoubleP8);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleM15(double[] data) {\n+        for (int j = 15; j < RANGE; j++) {\n+            data[j + -15] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleM15\")\n+    @Warmup(0)\n+    public static void runDoubleM15() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleM15(data);\n+        verify(\"testDoubleM15\", data, goldDoubleM15);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP15(double[] data) {\n+        for (int j = 0; j < RANGE - 15; j++) {\n+            data[j + 15] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP15\")\n+    @Warmup(0)\n+    public static void runDoubleP15() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP15(data);\n+        verify(\"testDoubleP15\", data, goldDoubleP15);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleM16(double[] data) {\n+        for (int j = 16; j < RANGE; j++) {\n+            data[j + -16] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleM16\")\n+    @Warmup(0)\n+    public static void runDoubleM16() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleM16(data);\n+        verify(\"testDoubleM16\", data, goldDoubleM16);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP16(double[] data) {\n+        for (int j = 0; j < RANGE - 16; j++) {\n+            data[j + 16] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP16\")\n+    @Warmup(0)\n+    public static void runDoubleP16() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP16(data);\n+        verify(\"testDoubleP16\", data, goldDoubleP16);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleM31(double[] data) {\n+        for (int j = 31; j < RANGE; j++) {\n+            data[j + -31] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleM31\")\n+    @Warmup(0)\n+    public static void runDoubleM31() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleM31(data);\n+        verify(\"testDoubleM31\", data, goldDoubleM31);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP31(double[] data) {\n+        for (int j = 0; j < RANGE - 31; j++) {\n+            data[j + 31] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP31\")\n+    @Warmup(0)\n+    public static void runDoubleP31() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP31(data);\n+        verify(\"testDoubleP31\", data, goldDoubleP31);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleM32(double[] data) {\n+        for (int j = 32; j < RANGE; j++) {\n+            data[j + -32] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleM32\")\n+    @Warmup(0)\n+    public static void runDoubleM32() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleM32(data);\n+        verify(\"testDoubleM32\", data, goldDoubleM32);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP32(double[] data) {\n+        for (int j = 0; j < RANGE - 32; j++) {\n+            data[j + 32] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP32\")\n+    @Warmup(0)\n+    public static void runDoubleP32() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP32(data);\n+        verify(\"testDoubleP32\", data, goldDoubleP32);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleM63(double[] data) {\n+        for (int j = 63; j < RANGE; j++) {\n+            data[j + -63] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleM63\")\n+    @Warmup(0)\n+    public static void runDoubleM63() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleM63(data);\n+        verify(\"testDoubleM63\", data, goldDoubleM63);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP63(double[] data) {\n+        for (int j = 0; j < RANGE - 63; j++) {\n+            data[j + 63] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP63\")\n+    @Warmup(0)\n+    public static void runDoubleP63() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP63(data);\n+        verify(\"testDoubleP63\", data, goldDoubleP63);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleM64(double[] data) {\n+        for (int j = 64; j < RANGE; j++) {\n+            data[j + -64] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleM64\")\n+    @Warmup(0)\n+    public static void runDoubleM64() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleM64(data);\n+        verify(\"testDoubleM64\", data, goldDoubleM64);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP64(double[] data) {\n+        for (int j = 0; j < RANGE - 64; j++) {\n+            data[j + 64] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP64\")\n+    @Warmup(0)\n+    public static void runDoubleP64() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP64(data);\n+        verify(\"testDoubleP64\", data, goldDoubleP64);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleM65(double[] data) {\n+        for (int j = 65; j < RANGE; j++) {\n+            data[j + -65] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleM65\")\n+    @Warmup(0)\n+    public static void runDoubleM65() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleM65(data);\n+        verify(\"testDoubleM65\", data, goldDoubleM65);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP65(double[] data) {\n+        for (int j = 0; j < RANGE - 65; j++) {\n+            data[j + 65] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP65\")\n+    @Warmup(0)\n+    public static void runDoubleP65() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP65(data);\n+        verify(\"testDoubleP65\", data, goldDoubleP65);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleM128(double[] data) {\n+        for (int j = 128; j < RANGE; j++) {\n+            data[j + -128] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleM128\")\n+    @Warmup(0)\n+    public static void runDoubleM128() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleM128(data);\n+        verify(\"testDoubleM128\", data, goldDoubleM128);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP128(double[] data) {\n+        for (int j = 0; j < RANGE - 128; j++) {\n+            data[j + 128] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP128\")\n+    @Warmup(0)\n+    public static void runDoubleP128() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP128(data);\n+        verify(\"testDoubleP128\", data, goldDoubleP128);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleM129(double[] data) {\n+        for (int j = 129; j < RANGE; j++) {\n+            data[j + -129] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleM129\")\n+    @Warmup(0)\n+    public static void runDoubleM129() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleM129(data);\n+        verify(\"testDoubleM129\", data, goldDoubleM129);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP129(double[] data) {\n+        for (int j = 0; j < RANGE - 129; j++) {\n+            data[j + 129] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP129\")\n+    @Warmup(0)\n+    public static void runDoubleP129() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP129(data);\n+        verify(\"testDoubleP129\", data, goldDoubleP129);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleM192(double[] data) {\n+        for (int j = 192; j < RANGE; j++) {\n+            data[j + -192] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleM192\")\n+    @Warmup(0)\n+    public static void runDoubleM192() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleM192(data);\n+        verify(\"testDoubleM192\", data, goldDoubleM192);\n+    }\n+\n+    @Test\n+    \/\/ cpu: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ cpu: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ cpu: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ cpu: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"MaxVectorSize\", \"< 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP192(double[] data) {\n+        for (int j = 0; j < RANGE - 192; j++) {\n+            data[j + 192] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP192\")\n+    @Warmup(0)\n+    public static void runDoubleP192() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP192(data);\n+        verify(\"testDoubleP192\", data, goldDoubleP192);\n+    }\n+\n+    \/\/ ------------------- Initialization -------------------\n+\n+    static void init(int[] data) {\n+        for (int j = 0; j < RANGE; j++) {\n+            data[j] = (int)j;\n+        }\n+    }\n+\n+    static void init(long[] data) {\n+        for (int j = 0; j < RANGE; j++) {\n+            data[j] = (long)j;\n+        }\n+    }\n+\n+    static void init(short[] data) {\n+        for (int j = 0; j < RANGE; j++) {\n+            data[j] = (short)j;\n+        }\n+    }\n+\n+    static void init(char[] data) {\n+        for (int j = 0; j < RANGE; j++) {\n+            data[j] = (char)j;\n+        }\n+    }\n+\n+    static void init(byte[] data) {\n+        for (int j = 0; j < RANGE; j++) {\n+            data[j] = (byte)j;\n+        }\n+    }\n+\n+    static void init(float[] data) {\n+        for (int j = 0; j < RANGE; j++) {\n+            data[j] = (float)j;\n+        }\n+    }\n+\n+    static void init(double[] data) {\n+        for (int j = 0; j < RANGE; j++) {\n+            data[j] = (double)j;\n+        }\n+    }\n+\n+    \/\/ ------------------- Verification -------------------\n+\n+    static void verify(String context, int[] data, int[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + context + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+    static void verify(String context, long[] data, long[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + context + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+    static void verify(String context, short[] data, short[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + context + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+    static void verify(String context, char[] data, char[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + context + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+    static void verify(String context, byte[] data, byte[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + context + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+    static void verify(String context, float[] data, float[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + context + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+    static void verify(String context, double[] data, double[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + context + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestDependencyOffsets.java","additions":11205,"deletions":0,"binary":false,"changes":11205,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,4 +30,6 @@\n- * @run main compiler.vectorization.TestForEachRem test1\n- * @run main compiler.vectorization.TestForEachRem test2\n- * @run main compiler.vectorization.TestForEachRem test3\n- * @run main compiler.vectorization.TestForEachRem test4\n+ * @run main\/othervm -Xbatch compiler.vectorization.TestForEachRem test1\n+ * @run main\/othervm -Xbatch compiler.vectorization.TestForEachRem test2\n+ * @run main\/othervm -Xbatch compiler.vectorization.TestForEachRem test3\n+ * @run main\/othervm -Xbatch compiler.vectorization.TestForEachRem test4\n+ * @run main\/othervm -Xbatch compiler.vectorization.TestForEachRem test5\n+ * @run main\/othervm -Xbatch compiler.vectorization.TestForEachRem test6\n@@ -68,0 +70,19 @@\n+    static void test5(int[] data) {\n+       IntStream.range(0, RANGE - 2).forEach(j -> {\n+           data[j + 2] = data[j];\n+       });\n+    }\n+\n+    static void initByte(byte[] data) {\n+       IntStream.range(0, RANGE).parallel().forEach(j -> {\n+           data[j] = (byte)j;\n+       });\n+    }\n+\n+    static void test6(byte[] data) {\n+       \/\/ 2-byte offset -> can only vectorize if alignment not required by hardware\n+       IntStream.range(0, RANGE - 2).forEach(j -> {\n+           data[j] = data[j + 2];\n+       });\n+    }\n+\n@@ -76,0 +97,8 @@\n+    static void verify(String name, byte[] data, byte[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + name + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+\n@@ -79,0 +108,2 @@\n+        byte[] dataB = new byte[RANGE];\n+        byte[] goldB = new byte[RANGE];\n@@ -81,1 +112,1 @@\n-            throw new RuntimeException(\" Missing test name: test1, test2, test3, test4\");\n+            throw new RuntimeException(\" Missing test name: test1, test2, test3, test4, test5\");\n@@ -129,0 +160,25 @@\n+\n+        if (args[0].equals(\"test5\")) {\n+            System.out.println(\" Run test5 ...\");\n+            test1(gold); \/\/ reset\n+            test5(gold);\n+            for (int i = 0; i < ITER; i++) {\n+                test1(data); \/\/ reset\n+                test5(data);\n+            }\n+            verify(\"test5\", data, gold);\n+            System.out.println(\" Finished test5.\");\n+        }\n+\n+        if (args[0].equals(\"test6\")) {\n+            System.out.println(\" Run test6 ...\");\n+            initByte(goldB); \/\/ reset\n+            test6(goldB);\n+            for (int i = 0; i < ITER; i++) {\n+                initByte(dataB); \/\/ reset\n+                test6(dataB);\n+            }\n+            verify(\"test6\", dataB, goldB);\n+            System.out.println(\" Finished test6.\");\n+        }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestForEachRem.java","additions":62,"deletions":6,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -0,0 +1,805 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8298935\n+ * @summary Test forced vectorization, and check IR for vector instructions\n+ * @requires vm.compiler2.enabled\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorization.TestOptionVectorizeIR\n+ *\/\n+\n+package compiler.vectorization;\n+import compiler.lib.ir_framework.*;\n+\n+public class TestOptionVectorizeIR {\n+    static final int RANGE = 512;\n+    static final int ITER  = 100;\n+    int[] gold1 = new int[RANGE];\n+    int[] gold2 = new int[RANGE];\n+    int[] gold3 = new int[RANGE];\n+    int[] gold4 = new int[RANGE];\n+    int[] gold5 = new int[RANGE];\n+    int[] gold6 = new int[RANGE];\n+\n+    long[] gold10 = new long[RANGE];\n+    long[] gold11 = new long[RANGE];\n+    long[] gold12 = new long[RANGE];\n+    long[] gold13 = new long[RANGE];\n+\n+    short[] gold20 = new short[RANGE];\n+    short[] gold21 = new short[RANGE];\n+    short[] gold22 = new short[RANGE];\n+    short[] gold23 = new short[RANGE];\n+\n+    byte[] gold30 = new byte[RANGE];\n+    byte[] gold31 = new byte[RANGE];\n+    byte[] gold32 = new byte[RANGE];\n+    byte[] gold33 = new byte[RANGE];\n+\n+    char[] gold40 = new char[RANGE];\n+    char[] gold41 = new char[RANGE];\n+    char[] gold42 = new char[RANGE];\n+    char[] gold43 = new char[RANGE];\n+\n+    float[] gold50 = new float[RANGE];\n+    float[] gold51 = new float[RANGE];\n+    float[] gold52 = new float[RANGE];\n+    float[] gold53 = new float[RANGE];\n+\n+    double[] gold60 = new double[RANGE];\n+    double[] gold61 = new double[RANGE];\n+    double[] gold62 = new double[RANGE];\n+    double[] gold63 = new double[RANGE];\n+\n+    public static void main(String args[]) {\n+        TestFramework.runWithFlags(\"-XX:CompileCommand=option,compiler.vectorization.TestOptionVectorizeIR::test*,Vectorize\");\n+    }\n+\n+    TestOptionVectorizeIR() {\n+        \/\/ compute the gold standard in interpreter mode\n+        \/\/ test1\n+        test1(gold1);\n+        \/\/ test2\n+        test1(gold2);\n+        test2(gold2);\n+        \/\/ test3\n+        test1(gold3);\n+        test3(gold3, 2, 3);\n+        \/\/ test4\n+        test1(gold4);\n+        test4(gold4);\n+        \/\/ test5\n+        test1(gold5);\n+        test5(gold5);\n+        \/\/ test6\n+        test1(gold6);\n+        test6(gold6);\n+\n+        \/\/ long\n+        init(gold10);\n+        test10(gold10);\n+        init(gold11);\n+        test11(gold11);\n+        init(gold12);\n+        test12(gold12);\n+        init(gold13);\n+        test13(gold13);\n+\n+        \/\/ short\n+        init(gold20);\n+        test20(gold20);\n+        init(gold21);\n+        test21(gold21);\n+        init(gold22);\n+        test22(gold22);\n+        init(gold23);\n+        test23(gold23);\n+\n+        \/\/ byte\n+        init(gold30);\n+        test30(gold30);\n+        init(gold31);\n+        test31(gold31);\n+        init(gold32);\n+        test32(gold32);\n+        init(gold33);\n+        test33(gold33);\n+\n+        \/\/ char\n+        init(gold40);\n+        test40(gold40);\n+        init(gold41);\n+        test41(gold41);\n+        init(gold42);\n+        test42(gold42);\n+        init(gold43);\n+        test43(gold43);\n+\n+        \/\/ float\n+        init(gold50);\n+        test50(gold50);\n+        init(gold51);\n+        test51(gold51);\n+        init(gold52);\n+        test52(gold52);\n+        init(gold53);\n+        test53(gold53);\n+\n+        \/\/ double\n+        init(gold60);\n+        test60(gold60);\n+        init(gold61);\n+        test61(gold61);\n+        init(gold62);\n+        test62(gold62);\n+        init(gold63);\n+        test63(gold63);\n+    }\n+\n+    @Run(test = \"test1\")\n+    @Warmup(100)\n+    public void runTest1() {\n+        int[] data = new int[RANGE];\n+        test1(data);\n+        verify(\"test1\", data, gold1);\n+    }\n+\n+    @Run(test = \"test2\")\n+    @Warmup(100)\n+    public void runTest2() {\n+        int[] data = new int[RANGE];\n+        test1(data);\n+        test2(data);\n+        verify(\"test2\", data, gold2);\n+    }\n+\n+    @Run(test = \"test3\")\n+    @Warmup(100)\n+    public void runTest3() {\n+        int[] data = new int[RANGE];\n+        test1(data);\n+        test3(data, 2, 3);\n+        verify(\"test3\", data, gold3);\n+    }\n+\n+    @Run(test = \"test4\")\n+    @Warmup(100)\n+    public void runTest4() {\n+        int[] data = new int[RANGE];\n+        test1(data);\n+        test4(data);\n+        verify(\"test4\", data, gold4);\n+    }\n+\n+    @Run(test = \"test5\")\n+    @Warmup(100)\n+    public void runTest5() {\n+        int[] data = new int[RANGE];\n+        test1(data);\n+        test5(data);\n+        verify(\"test5\", data, gold5);\n+    }\n+\n+    @Run(test = \"test6\")\n+    @Warmup(100)\n+    public void runTest6() {\n+        int[] data = new int[RANGE];\n+        test1(data);\n+        test6(data);\n+        verify(\"test6\", data, gold6);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.POPULATE_INDEX, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    static void test1(int[] data) {\n+       for (int j = 0; j < RANGE; j++) {\n+           \/\/ Vectorizes even if it is not forced\n+           data[j] = j;\n+       }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test2(int[] data) {\n+       for (int j = 0; j < RANGE - 1; j++) {\n+           \/\/ Only vectorizes if forced, because of offset by 1\n+           data[j] = data[j] + data[j + 1];\n+       }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.REPLICATE_I, \"> 0\", IRNode.ADD_VI, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test3(int[] data, int A, int B) {\n+       for (int j = 0; j < RANGE - 1; j++) {\n+           \/\/ Only vectorizes if forced, because of offset by 1\n+           data[j] = A * data[j] + B * data[j + 1];\n+       }\n+    }\n+\n+    @Test\n+    static void test4(int[] data) {\n+       for (int j = 0; j < RANGE - 1; j++) {\n+           \/\/ write forward -> cyclic dependency -> cannot vectorize\n+           \/\/ independent(s1, s2) for adjacent loads should detect this\n+           data[j + 1] = data[j];\n+       }\n+    }\n+\n+    @Test\n+    static void test5(int[] data) {\n+       for (int j = 0; j < RANGE - 3; j++) {\n+           \/\/ write forward -> cyclic dependency -> cannot vectorize\n+           \/\/ independent(s1, s2) for adjacent loads cannot detect this\n+           \/\/ Checks with memory_alignment are disabled via compile option\n+           data[j + 2] = data[j];\n+       }\n+    }\n+\n+    @Test\n+    static void test6(int[] data) {\n+       for (int j = 0; j < RANGE - 3; j++) {\n+           \/\/ write forward -> cyclic dependency -> cannot vectorize\n+           \/\/ independent(s1, s2) for adjacent loads cannot detect this\n+           \/\/ Checks with memory_alignment are disabled via compile option\n+           data[j + 3] = data[j];\n+       }\n+    }\n+\n+    \/\/ ------------------------- Long -----------------------------\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test10(long[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j + 2];\n+       }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test11(long[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j + 1];\n+       }\n+    }\n+\n+    @Test\n+    static void test12(long[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j - 1];\n+       }\n+    }\n+\n+    @Test\n+    static void test13(long[] data) {\n+       \/\/ 128-bit vectors -> can vectorize because only 2 elements\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j - 2];\n+       }\n+    }\n+\n+    @Run(test = \"test10\")\n+    @Warmup(100)\n+    public void runTest10() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        test10(data);\n+        verify(\"test10\", data, gold10);\n+    }\n+\n+    @Run(test = \"test11\")\n+    @Warmup(100)\n+    public void runTest11() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        test11(data);\n+        verify(\"test11\", data, gold11);\n+    }\n+\n+    @Run(test = \"test12\")\n+    @Warmup(100)\n+    public void runTest12() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        test12(data);\n+        verify(\"test12\", data, gold12);\n+    }\n+\n+    @Run(test = \"test13\")\n+    @Warmup(100)\n+    public void runTest13() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        test13(data);\n+        verify(\"test13\", data, gold13);\n+    }\n+\n+\n+    \/\/ ------------------------- Short -----------------------------\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test20(short[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j + 2];\n+       }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test21(short[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j + 1];\n+       }\n+    }\n+\n+    @Test\n+    static void test22(short[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j - 1];\n+       }\n+    }\n+\n+    @Test\n+    static void test23(short[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j - 2];\n+       }\n+    }\n+\n+    @Run(test = \"test20\")\n+    @Warmup(100)\n+    public void runTest20() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        test20(data);\n+        verify(\"test20\", data, gold20);\n+    }\n+\n+    @Run(test = \"test21\")\n+    @Warmup(100)\n+    public void runTest21() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        test21(data);\n+        verify(\"test21\", data, gold21);\n+    }\n+\n+    @Run(test = \"test22\")\n+    @Warmup(100)\n+    public void runTest22() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        test22(data);\n+        verify(\"test22\", data, gold22);\n+    }\n+\n+    @Run(test = \"test23\")\n+    @Warmup(100)\n+    public void runTest23() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        test23(data);\n+        verify(\"test23\", data, gold23);\n+    }\n+\n+\n+    \/\/ ------------------------- Byte -----------------------------\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test30(byte[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j + 2];\n+       }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test31(byte[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j + 1];\n+       }\n+    }\n+\n+    @Test\n+    static void test32(byte[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j - 1];\n+       }\n+    }\n+\n+    @Test\n+    static void test33(byte[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j - 2];\n+       }\n+    }\n+\n+    @Run(test = \"test30\")\n+    @Warmup(100)\n+    public void runTest30() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        test30(data);\n+        verify(\"test30\", data, gold30);\n+    }\n+\n+    @Run(test = \"test31\")\n+    @Warmup(100)\n+    public void runTest31() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        test31(data);\n+        verify(\"test31\", data, gold31);\n+    }\n+\n+    @Run(test = \"test32\")\n+    @Warmup(100)\n+    public void runTest32() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        test32(data);\n+        verify(\"test32\", data, gold32);\n+    }\n+\n+    @Run(test = \"test33\")\n+    @Warmup(100)\n+    public void runTest33() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        test33(data);\n+        verify(\"test33\", data, gold33);\n+    }\n+\n+\n+    \/\/ ------------------------- Char -----------------------------\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test40(char[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j + 2];\n+       }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test41(char[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j + 1];\n+       }\n+    }\n+\n+    @Test\n+    static void test42(char[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j - 1];\n+       }\n+    }\n+\n+    @Test\n+    static void test43(char[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j - 2];\n+       }\n+    }\n+\n+    @Run(test = \"test40\")\n+    @Warmup(100)\n+    public void runTest40() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        test40(data);\n+        verify(\"test40\", data, gold40);\n+    }\n+\n+    @Run(test = \"test41\")\n+    @Warmup(100)\n+    public void runTest41() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        test41(data);\n+        verify(\"test41\", data, gold41);\n+    }\n+\n+    @Run(test = \"test42\")\n+    @Warmup(100)\n+    public void runTest42() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        test42(data);\n+        verify(\"test42\", data, gold42);\n+    }\n+\n+    @Run(test = \"test43\")\n+    @Warmup(100)\n+    public void runTest43() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        test43(data);\n+        verify(\"test43\", data, gold43);\n+    }\n+\n+    \/\/ ------------------------- Float -----------------------------\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test50(float[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j + 2];\n+       }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test51(float[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j + 1];\n+       }\n+    }\n+\n+    @Test\n+    static void test52(float[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j - 1];\n+       }\n+    }\n+\n+    @Test\n+    static void test53(float[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j - 2];\n+       }\n+    }\n+\n+    @Run(test = \"test50\")\n+    @Warmup(100)\n+    public void runTest50() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        test50(data);\n+        verify(\"test50\", data, gold50);\n+    }\n+\n+    @Run(test = \"test51\")\n+    @Warmup(100)\n+    public void runTest51() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        test51(data);\n+        verify(\"test51\", data, gold51);\n+    }\n+\n+    @Run(test = \"test52\")\n+    @Warmup(100)\n+    public void runTest52() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        test52(data);\n+        verify(\"test52\", data, gold52);\n+    }\n+\n+    @Run(test = \"test53\")\n+    @Warmup(100)\n+    public void runTest53() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        test53(data);\n+        verify(\"test53\", data, gold53);\n+    }\n+\n+    \/\/ ------------------------- Double -----------------------------\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test60(double[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j + 2];\n+       }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test61(double[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j + 1];\n+       }\n+    }\n+\n+    @Test\n+    static void test62(double[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j - 1];\n+       }\n+    }\n+\n+    @Test\n+    static void test63(double[] data) {\n+       \/\/ 128-bit vectors -> can vectorize because only 2 elements\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j - 2];\n+       }\n+    }\n+\n+    @Run(test = \"test60\")\n+    @Warmup(100)\n+    public void runTest60() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        test60(data);\n+        verify(\"test60\", data, gold60);\n+    }\n+\n+    @Run(test = \"test61\")\n+    @Warmup(100)\n+    public void runTest61() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        test61(data);\n+        verify(\"test61\", data, gold61);\n+    }\n+\n+    @Run(test = \"test62\")\n+    @Warmup(100)\n+    public void runTest62() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        test62(data);\n+        verify(\"test62\", data, gold62);\n+    }\n+\n+    @Run(test = \"test63\")\n+    @Warmup(100)\n+    public void runTest63() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        test63(data);\n+        verify(\"test63\", data, gold63);\n+    }\n+\n+    static void init(long[] data) {\n+       for (int j = 0; j < RANGE; j++) {\n+           data[j] = j;\n+       }\n+    }\n+\n+    static void init(short[] data) {\n+       for (int j = 0; j < RANGE; j++) {\n+           data[j] = (short)j;\n+       }\n+    }\n+\n+    static void init(byte[] data) {\n+       for (int j = 0; j < RANGE; j++) {\n+           data[j] = (byte)j;\n+       }\n+    }\n+\n+    static void init(char[] data) {\n+       for (int j = 0; j < RANGE; j++) {\n+           data[j] = (char)j;\n+       }\n+    }\n+\n+\n+    static void init(float[] data) {\n+       for (int j = 0; j < RANGE; j++) {\n+           data[j] = j;\n+       }\n+    }\n+\n+\n+    static void init(double[] data) {\n+       for (int j = 0; j < RANGE; j++) {\n+           data[j] = j;\n+       }\n+    }\n+\n+    static void verify(String name, int[] data, int[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + name + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+\n+    static void verify(String name, long[] data, long[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + name + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+\n+    static void verify(String name, short[] data, short[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + name + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+\n+    static void verify(String name, byte[] data, byte[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + name + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+\n+    static void verify(String name, char[] data, char[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + name + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+\n+    static void verify(String name, float[] data, float[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + name + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+\n+    static void verify(String name, double[] data, double[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + name + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestOptionVectorizeIR.java","additions":805,"deletions":0,"binary":false,"changes":805,"status":"added"}]}