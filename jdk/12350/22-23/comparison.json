{"files":[{"patch":"@@ -645,6 +645,4 @@\n-    \/\/ Create initial pack pairs of memory operations for which\n-    \/\/ alignment is set and vectors will be aligned.\n-    bool create_pack = is_mem_ref_alignment_ok(mem_ref, iv_adjustment, align_to_ref_p,\n-                                               best_align_to_mem_ref, best_iv_adjustment,\n-                                               align_to_refs);\n-    if (create_pack) {\n+    if (can_create_pairs(mem_ref, iv_adjustment, align_to_ref_p,\n+                         best_align_to_mem_ref, best_iv_adjustment,\n+                         align_to_refs)) {\n+      \/\/ Create initial pack pairs of memory operations for which alignment was set.\n@@ -670,1 +668,3 @@\n-    } else { \/\/ Don't create unaligned pack\n+    } else {\n+      \/\/ Cannot create pairs for mem_ref. Reject all related memops forever.\n+\n@@ -757,5 +757,7 @@\n-\/\/ Check if alignment of mem_ref permissible on hardware, and if it is consistent with\n-\/\/ the other packs of the same memory slice.\n-bool SuperWord::is_mem_ref_alignment_ok(MemNode* mem_ref, int iv_adjustment, SWPointer &align_to_ref_p,\n-                                        MemNode* best_align_to_mem_ref, int best_iv_adjustment,\n-                                        Node_List &align_to_refs) {\n+\/\/ Check if we can create the pack pairs for mem_ref:\n+\/\/ If required, enforce strict alignment requirements of hardware.\n+\/\/ Else, check that we create no pair over the \"alignment boundary\" of\n+\/\/ the memory slice, so that the indepencence of the pack is guaranteed.\n+bool SuperWord::can_create_pairs(MemNode* mem_ref, int iv_adjustment, SWPointer &align_to_ref_p,\n+                                 MemNode* best_align_to_mem_ref, int best_iv_adjustment,\n+                                 Node_List &align_to_refs) {\n@@ -765,4 +767,8 @@\n-    \/\/ All vectors need to be vector length aligned. We use best_align_to_mem_ref to adjust\n-    \/\/ the pre-loop limit such that all vector memory accesses are vector aligned. Hence, we\n-    \/\/ must ensure that all mem_refs that we vectorize are aligned with best_align_to_mem_ref.\n-    \/\/ These 3 conditions must be fulfilled:\n+    \/\/ All vectors need to be memory aligned, modulo their vector_width. This is more strict\n+    \/\/ than the hardware probably requires. Most hardware at most requires 4-byte alignment.\n+    \/\/\n+    \/\/ In the pre-loop, we align best_align_to_mem_ref to its vector_length. To ensure that\n+    \/\/ all mem_ref's are memory aligned modulo their vector_width, we only need to check that\n+    \/\/ they are all aligned to best_align_to_mem_ref, modulo their vector_width. For that,\n+    \/\/ we check the following 3 conditions.\n+\n@@ -777,3 +783,2 @@\n-      \/\/ Do not vectorize a memory access with more elements per vector\n-      \/\/ if unaligned memory access is not allowed because number of\n-      \/\/ iterations in pre-loop will be not enough to align it.\n+      \/\/ We only align to vector_width of best_align_to_mem_ref during pre-loop.\n+      \/\/ A mem_ref with a larger vector_width might thus not be vector_width aligned.\n@@ -793,10 +798,5 @@\n-    \/\/ Alignment is not required by the hardware. However, we still have to make sure that\n-    \/\/ the memory accesses do not form a cyclic dependency.\n-\n-    \/\/ We have a compiler hint, so do not check alignment with other packs. For now we trust\n-    \/\/ the hint. We may create cyclic dependencies (packs that are not independent). Later\n-    \/\/ we will filter out packs that are not internally independent.\n-    \/\/ This allows us to vectorize cases like this (forward read):\n-    \/\/ for (int i ...) { v[i] = v[i + 1] + 5; }\n-    \/\/ And the filtering still removes non-vectorizable cases like this (forward write):\n-    \/\/ for (int i ...) { v[i + 1] = v[i] + 5; }\n+    \/\/ Alignment is not required by the hardware.\n+\n+    \/\/ However, we need to ensure that the pack for mem_ref is independent, i.e. all members\n+    \/\/ of the pack are mutually independent.\n+\n@@ -804,0 +804,6 @@\n+      \/\/ Wait until combine_packs to check independence of packs. For now we just know that\n+      \/\/ the adjacent pairs are independent. This allows us to vectorize when we do not have\n+      \/\/ alignment modulo vector_width. For example (forward read):\n+      \/\/ for (int i ...) { v[i] = v[i + 1] + 5; }\n+      \/\/ The following will be filtered out in combine_packs (forward write):\n+      \/\/ for (int i ...) { v[i + 1] = v[i] + 5; }\n@@ -807,2 +813,8 @@\n-    \/\/ An easy way to prevent cyclic dependencies is to require all mem_refs of the same slice\n-    \/\/ to be exactly aligned. This allows us to vectorize these cases:\n+    \/\/ If all mem_ref's are modulo vector_width aligned with all other mem_ref's of their\n+    \/\/ memory slice, then the VectorLoad \/ VectorStore regions are either exactly overlapping\n+    \/\/ or completely non-overlapping. This ensures that there cannot be memory-dependencies\n+    \/\/ between different vector \"lanes\".\n+    \/\/ During SuperWord::filter_packs -> SuperWord::profitable -> SuperWord::is_vector_use,\n+    \/\/ we check that all inputs are vectors that match on every element (with some reasonable\n+    \/\/ exceptions). This ensures that every \"lane\" is isomorpic and independent to all other\n+    \/\/ \"lanes\". This allows us to vectorize these cases:\n@@ -810,1 +822,1 @@\n-    \/\/ for (int i ...) { v[i] = v[i + 32] + 5; } \/\/ alignment modulo vector size\n+    \/\/ for (int i ...) { v[i] = v[i + 32] + 5; } \/\/ alignment modulo vector_width\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":44,"deletions":32,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -479,5 +479,7 @@\n-  \/\/ Check if alignment of mem_ref permissible on hardware,\n-  \/\/ and if it is consistent with the other packs of the .\n-  bool is_mem_ref_alignment_ok(MemNode* mem_ref, int iv_adjustment, SWPointer &align_to_ref_p,\n-                               MemNode* best_align_to_mem_ref, int best_iv_adjustment,\n-                               Node_List &align_to_refs);\n+  \/\/ Check if we can create the pack pairs for mem_ref:\n+  \/\/ If required, enforce strict alignment requirements of hardware.\n+  \/\/ Else, check that we create no pair over the \"alignment boundary\" of\n+  \/\/ the memory slice, so that the indepencence of the pack is guaranteed.\n+  bool can_create_pairs(MemNode* mem_ref, int iv_adjustment, SWPointer &align_to_ref_p,\n+                        MemNode* best_align_to_mem_ref, int best_iv_adjustment,\n+                        Node_List &align_to_refs);\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"}]}