{"files":[{"patch":"@@ -63,0 +63,1 @@\n+    private static final double TWO24    = 0x1.0p24; \/\/ 1.67772160000000000000e+07\n@@ -116,0 +117,904 @@\n+    \/** sin(x)\n+     * Return sine function of x.\n+     *\n+     * kernel function:\n+     *      __kernel_sin            ... sine function on [-pi\/4,pi\/4]\n+     *      __kernel_cos            ... cose function on [-pi\/4,pi\/4]\n+     *      __ieee754_rem_pio2      ... argument reduction routine\n+     *\n+     * Method.\n+     *      Let S,C and T denote the sin, cos and tan respectively on\n+     *      [-PI\/4, +PI\/4]. Reduce the argument x to y1+y2 = x-k*pi\/2\n+     *      in [-pi\/4 , +pi\/4], and let n = k mod 4.\n+     *      We have\n+     *\n+     *          n        sin(x)      cos(x)        tan(x)\n+     *     ----------------------------------------------------------\n+     *          0          S           C             T\n+     *          1          C          -S            -1\/T\n+     *          2         -S          -C             T\n+     *          3         -C           S            -1\/T\n+     *     ----------------------------------------------------------\n+     *\n+     * Special cases:\n+     *      Let trig be any of sin, cos, or tan.\n+     *      trig(+-INF)  is NaN, with signals;\n+     *      trig(NaN)    is that NaN;\n+     *\n+     * Accuracy:\n+     *      TRIG(x) returns trig(x) nearly rounded\n+     *\/\n+    static class Sin {\n+        private Sin() {throw new UnsupportedOperationException();}\n+\n+        static double compute(double x) {\n+            double[] y = new double[2];\n+            double z = 0.0;\n+            int n, ix;\n+\n+            \/\/ High word of x.\n+            ix = __HI(x);\n+\n+            \/\/ |x| ~< pi\/4\n+            ix &= 0x7fff_ffff;\n+            if (ix <= 0x3fe9_21fb) {\n+                return __kernel_sin(x, z, 0);\n+            } else if (ix>=0x7ff0_0000) {  \/\/ sin(Inf or NaN) is NaN\n+                return x - x;\n+            } else { \/\/ argument reduction needed\n+                n = RemPio2.__ieee754_rem_pio2(x, y);\n+                switch(n & 3) {\n+                case 0: return  Sin.__kernel_sin(y[0], y[1], 1);\n+                case 1: return  Cos.__kernel_cos(y[0], y[1]);\n+                case 2: return -Sin.__kernel_sin(y[0], y[1], 1);\n+                default:\n+                    return -Cos.__kernel_cos(y[0], y[1]);\n+                }\n+            }\n+        }\n+\n+        \/** __kernel_sin( x, y, iy)\n+         * kernel sin function on [-pi\/4, pi\/4], pi\/4 ~ 0.7854\n+         * Input x is assumed to be bounded by ~pi\/4 in magnitude.\n+         * Input y is the tail of x.\n+         * Input iy indicates whether y is 0. (if iy=0, y assume to be 0).\n+         *\n+         * Algorithm\n+         *      1. Since sin(-x) = -sin(x), we need only to consider positive x.\n+         *      2. if x < 2^-27 (hx<0x3e400000 0), return x with inexact if x!=0.\n+         *      3. sin(x) is approximated by a polynomial of degree 13 on\n+         *         [0,pi\/4]\n+         *                               3            13\n+         *              sin(x) ~ x + S1*x + ... + S6*x\n+         *         where\n+         *\n+         *      |sin(x)         2     4     6     8     10     12  |     -58\n+         *      |----- - (1+S1*x +S2*x +S3*x +S4*x +S5*x  +S6*x   )| <= 2\n+         *      |  x                                               |\n+         *\n+         *      4. sin(x+y) = sin(x) + sin'(x')*y\n+         *                  ~ sin(x) + (1-x*x\/2)*y\n+         *         For better accuracy, let\n+         *                   3      2      2      2      2\n+         *              r = x *(S2+x *(S3+x *(S4+x *(S5+x *S6))))\n+         *         then                   3    2\n+         *              sin(x) = x + (S1*x + (x *(r-y\/2)+y))\n+         *\/\n+        private static final double\n+            S1  = -0x1.5555555555549p-3,  \/\/ -1.66666666666666324348e-01\n+            S2  =  0x1.111111110f8a6p-7,  \/\/  8.33333333332248946124e-03\n+            S3  = -0x1.a01a019c161d5p-13, \/\/ -1.98412698298579493134e-04\n+            S4  =  0x1.71de357b1fe7dp-19, \/\/  2.75573137070700676789e-06\n+            S5  = -0x1.ae5e68a2b9cebp-26, \/\/ -2.50507602534068634195e-08\n+            S6  =  0x1.5d93a5acfd57cp-33; \/\/  1.58969099521155010221e-10\n+\n+        static double __kernel_sin(double x, double y, int iy) {\n+            double z, r, v;\n+            int ix;\n+            ix = __HI(x) & 0x7fff_ffff;        \/\/ high word of x\n+            if (ix < 0x3e40_0000) {            \/\/ |x| < 2**-27\n+                if ((int)x == 0)               \/\/ generate inexact\n+                    return x;\n+            }\n+            z       =  x*x;\n+            v       =  z*x;\n+            r       =  S2 + z*(S3 + z*(S4 + z*(S5 + z*S6)));\n+            if (iy == 0) {\n+                return x + v*(S1 + z*r);\n+            } else {\n+                return x - ((z*(0.5*y - v*r) - y) - v*S1);\n+            }\n+        }\n+    }\n+\n+    \/** cos(x)\n+     * Return cosine function of x.\n+     *\n+     * kernel function:\n+     *      __kernel_sin            ... sine function on [-pi\/4,pi\/4]\n+     *      __kernel_cos            ... cosine function on [-pi\/4,pi\/4]\n+     *      __ieee754_rem_pio2      ... argument reduction routine\n+     *\n+     * Method.\n+     *      Let S,C and T denote the sin, cos and tan respectively on\n+     *      [-PI\/4, +PI\/4]. Reduce the argument x to y1+y2 = x-k*pi\/2\n+     *      in [-pi\/4 , +pi\/4], and let n = k mod 4.\n+     *      We have\n+     *\n+     *          n        sin(x)      cos(x)        tan(x)\n+     *     ----------------------------------------------------------\n+     *          0          S           C             T\n+     *          1          C          -S            -1\/T\n+     *          2         -S          -C             T\n+     *          3         -C           S            -1\/T\n+     *     ----------------------------------------------------------\n+     *\n+     * Special cases:\n+     *      Let trig be any of sin, cos, or tan.\n+     *      trig(+-INF)  is NaN, with signals;\n+     *      trig(NaN)    is that NaN;\n+     *\n+     * Accuracy:\n+     *      TRIG(x) returns trig(x) nearly rounded\n+     *\/\n+    static class Cos {\n+        private Cos() {throw new UnsupportedOperationException();}\n+\n+        static double compute(double x) {\n+            double[] y = new double[2];\n+            double z = 0.0;\n+            int n, ix;\n+\n+            \/\/ High word of x.\n+            ix = __HI(x);\n+\n+            \/\/ |x| ~< pi\/4\n+            ix &= 0x7fff_ffff;\n+            if (ix <= 0x3fe9_21fb) {\n+                return __kernel_cos(x, z);\n+            } else if (ix >= 0x7ff0_0000) { \/\/ cos(Inf or NaN) is NaN\n+                return x-x;\n+            } else { \/\/ argument reduction needed\n+                n = RemPio2.__ieee754_rem_pio2(x,y);\n+                switch (n & 3) {\n+                case 0: return  Cos.__kernel_cos(y[0], y[1]);\n+                case 1: return -Sin.__kernel_sin(y[0], y[1],1);\n+                case 2: return -Cos.__kernel_cos(y[0], y[1]);\n+                default:\n+                    return  Sin.__kernel_sin(y[0], y[1], 1);\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * __kernel_cos( x,  y )\n+         * kernel cos function on [-pi\/4, pi\/4], pi\/4 ~ 0.785398164\n+         * Input x is assumed to be bounded by ~pi\/4 in magnitude.\n+         * Input y is the tail of x.\n+         *\n+         * Algorithm\n+         *      1. Since cos(-x) = cos(x), we need only to consider positive x.\n+         *      2. if x < 2^-27 (hx < 0x3e4000000), return 1 with inexact if x != 0.\n+         *      3. cos(x) is approximated by a polynomial of degree 14 on\n+         *         [0,pi\/4]\n+         *                                       4            14\n+         *              cos(x) ~ 1 - x*x\/2 + C1*x + ... + C6*x\n+         *         where the remez error is\n+         *\n+         *      |              2     4     6     8     10    12     14 |     -58\n+         *      |cos(x)-(1-.5*x +C1*x +C2*x +C3*x +C4*x +C5*x  +C6*x  )| <= 2\n+         *      |                                                      |\n+         *\n+         *                     4     6     8     10    12     14\n+         *      4. let r = C1*x +C2*x +C3*x +C4*x +C5*x  +C6*x  , then\n+         *             cos(x) = 1 - x*x\/2 + r\n+         *         since cos(x+y) ~ cos(x) - sin(x)*y\n+         *                        ~ cos(x) - x*y,\n+         *         a correction term is necessary in cos(x) and hence\n+         *              cos(x+y) = 1 - (x*x\/2 - (r - x*y))\n+         *         For better accuracy when x > 0.3, let qx = |x|\/4 with\n+         *         the last 32 bits mask off, and if x > 0.78125, let qx = 0.28125.\n+         *         Then\n+         *              cos(x+y) = (1-qx) - ((x*x\/2-qx) - (r-x*y)).\n+         *         Note that 1-qx and (x*x\/2-qx) is EXACT here, and the\n+         *         magnitude of the latter is at least a quarter of x*x\/2,\n+         *         thus, reducing the rounding error in the subtraction.\n+         *\/\n+        private static final double\n+            C1  =  0x1.555555555554cp-5,  \/\/  4.16666666666666019037e-02\n+            C2  = -0x1.6c16c16c15177p-10, \/\/ -1.38888888888741095749e-03\n+            C3  =  0x1.a01a019cb159p-16,  \/\/  2.48015872894767294178e-05\n+            C4  = -0x1.27e4f809c52adp-22, \/\/ -2.75573143513906633035e-07\n+            C5  =  0x1.1ee9ebdb4b1c4p-29, \/\/  2.08757232129817482790e-09\n+            C6  = -0x1.8fae9be8838d4p-37; \/\/ -1.13596475577881948265e-11\n+\n+        static double __kernel_cos(double x, double y) {\n+            double a, hz, z, r, qx = 0.0;\n+            int ix;\n+            ix = __HI(x) & 0x7fff_ffff;       \/\/ ix = |x|'s high word\n+            if (ix < 0x3e40_0000) {           \/\/ if x < 2**27\n+                if (((int)x) == 0) {          \/\/ generate inexact\n+                    return 1.0;\n+                }\n+            }\n+            z  = x*x;\n+            r  = z*(C1 + z*(C2 + z*(C3 + z*(C4 + z*(C5 + z*C6)))));\n+            if (ix < 0x3FD3_3333) {                    \/\/ if |x| < 0.3\n+                return 1.0 - (0.5*z - (z*r - x*y));\n+            } else {\n+                if (ix > 0x3fe9_0000) {               \/\/ x > 0.78125\n+                    qx = 0.28125;\n+                } else {\n+                    qx = __HI_LO(ix - 0x0020_0000, 0);\n+                }\n+                hz = 0.5*z - qx;\n+                a  = 1.0 - qx;\n+                return a - (hz - (z*r - x*y));\n+            }\n+        }\n+    }\n+\n+    \/** tan(x)\n+     * Return tangent function of x.\n+     *\n+     * kernel function:\n+     *      __kernel_tan            ... tangent function on [-pi\/4,pi\/4]\n+     *      __ieee754_rem_pio2      ... argument reduction routine\n+     *\n+     * Method.\n+     *      Let S,C and T denote the sin, cos and tan respectively on\n+     *      [-PI\/4, +PI\/4]. Reduce the argument x to y1+y2 = x-k*pi\/2\n+     *      in [-pi\/4 , +pi\/4], and let n = k mod 4.\n+     *      We have\n+     *\n+     *          n        sin(x)      cos(x)        tan(x)\n+     *     ----------------------------------------------------------\n+     *          0          S           C             T\n+     *          1          C          -S            -1\/T\n+     *          2         -S          -C             T\n+     *          3         -C           S            -1\/T\n+     *     ----------------------------------------------------------\n+     *\n+     * Special cases:\n+     *      Let trig be any of sin, cos, or tan.\n+     *      trig(+-INF)  is NaN, with signals;\n+     *      trig(NaN)    is that NaN;\n+     *\n+     * Accuracy:\n+     *      TRIG(x) returns trig(x) nearly rounded\n+     *\/\n+    static class Tan {\n+        private Tan() {throw new UnsupportedOperationException();}\n+\n+        static double compute(double x) {\n+            double[] y = new double[2];\n+            double z = 0.0;\n+            int n, ix;\n+\n+            \/\/ High word of x.\n+            ix = __HI(x);\n+\n+            \/\/ |x| ~< pi\/4\n+            ix &= 0x7fff_ffff;\n+            if (ix <= 0x3fe9_21fb) {\n+                return __kernel_tan(x, z, 1);\n+            } else if (ix >= 0x7ff0_0000) { \/\/ tan(Inf or NaN) is NaN\n+                return x-x;            \/\/ NaN\n+            } else {           \/\/ argument reduction needed\n+                n = RemPio2.__ieee754_rem_pio2(x, y);\n+                return __kernel_tan(y[0], y[1], 1 - ((n & 1) << 1)); \/\/ 1 -- n even; -1 -- n odd\n+            }\n+        }\n+\n+        \/** __kernel_tan( x, y, k )\n+         * kernel tan function on [-pi\/4, pi\/4], pi\/4 ~ 0.7854\n+         * Input x is assumed to be bounded by ~pi\/4 in magnitude.\n+         * Input y is the tail of x.\n+         * Input k indicates whether tan (if k=1) or\n+         * -1\/tan (if k= -1) is returned.\n+         *\n+         * Algorithm\n+         *      1. Since tan(-x) = -tan(x), we need only to consider positive x.\n+         *      2. if x < 2^-28 (hx < 0x3e300000 0), return x with inexact if x != 0.\n+         *      3. tan(x) is approximated by a odd polynomial of degree 27 on\n+         *         [0, 0.67434]\n+         *                               3             27\n+         *              tan(x) ~ x + T1*x + ... + T13*x\n+         *         where\n+         *\n+         *              |tan(x)         2     4            26   |     -59.2\n+         *              |----- - (1+T1*x +T2*x +.... +T13*x    )| <= 2\n+         *              |  x                                    |\n+         *\n+         *         Note: tan(x+y) = tan(x) + tan'(x)*y\n+         *                        ~ tan(x) + (1+x*x)*y\n+         *         Therefore, for better accuracy in computing tan(x+y), let\n+         *                   3      2      2       2       2\n+         *              r = x *(T2+x *(T3+x *(...+x *(T12+x *T13))))\n+         *         then\n+         *                                  3    2\n+         *              tan(x+y) = x + (T1*x + (x *(r+y)+y))\n+         *\n+         *      4. For x in [0.67434,pi\/4],  let y = pi\/4 - x, then\n+         *              tan(x) = tan(pi\/4-y) = (1-tan(y))\/(1+tan(y))\n+         *                     = 1 - 2*(tan(y) - (tan(y)^2)\/(1+tan(y)))\n+         *\/\n+        private static final double\n+            pio4  =  0x1.921fb54442d18p-1,  \/\/ 7.85398163397448278999e-01\n+            pio4lo=  0x1.1a62633145c07p-55, \/\/ 3.06161699786838301793e-17\n+            T[] =  {\n+             0x1.5555555555563p-2,  \/\/  3.33333333333334091986e-01\n+             0x1.111111110fe7ap-3,  \/\/  1.33333333333201242699e-01\n+             0x1.ba1ba1bb341fep-5,  \/\/  5.39682539762260521377e-02\n+             0x1.664f48406d637p-6,  \/\/  2.18694882948595424599e-02\n+             0x1.226e3e96e8493p-7,  \/\/  8.86323982359930005737e-03\n+             0x1.d6d22c9560328p-9,  \/\/  3.59207910759131235356e-03\n+             0x1.7dbc8fee08315p-10, \/\/  1.45620945432529025516e-03\n+             0x1.344d8f2f26501p-11, \/\/  5.88041240820264096874e-04\n+             0x1.026f71a8d1068p-12, \/\/  2.46463134818469906812e-04\n+             0x1.47e88a03792a6p-14, \/\/  7.81794442939557092300e-05\n+             0x1.2b80f32f0a7e9p-14, \/\/  7.14072491382608190305e-05\n+            -0x1.375cbdb605373p-16, \/\/ -1.85586374855275456654e-05\n+             0x1.b2a7074bf7ad4p-16, \/\/  2.59073051863633712884e-05\n+        };\n+\n+        static double __kernel_tan(double x, double y, int iy) {\n+            double z, r, v, w, s;\n+            int ix, hx;\n+            hx = __HI(x);   \/\/ high word of x\n+            ix = hx&0x7fff_ffff;     \/\/ high word of |x|\n+            if (ix < 0x3e30_0000) {  \/\/ x < 2**-28\n+                if ((int)x == 0) {   \/\/ generate inexact\n+                    if (((ix | __LO(x)) | (iy + 1)) == 0) {\n+                        return 1.0 \/ Math.abs(x);\n+                    } else {\n+                        if (iy == 1) {\n+                            return x;\n+                        } else {    \/\/ compute -1 \/ (x+y) carefully\n+                            double a, t;\n+\n+                            z = w = x + y;\n+                            z= __LO(z, 0);\n+                            v = y - (z - x);\n+                            t = a = -1.0 \/ w;\n+                            t = __LO(t, 0);\n+                            s = 1.0 + t * z;\n+                            return t + a * (s + t * v);\n+                        }\n+                    }\n+                }\n+            }\n+            if (ix >= 0x3FE5_9428) {  \/\/ |x| >= 0.6744\n+                if ( hx < 0) {\n+                    x = -x;\n+                    y = -y;\n+                }\n+                z = pio4 - x;\n+                w = pio4lo - y;\n+                x = z + w;\n+                y = 0.0;\n+            }\n+            z       =  x*x;\n+            w       =  z*z;\n+            \/* Break x^5*(T[1]+x^2*T[2]+...) into\n+             *    x^5(T[1]+x^4*T[3]+...+x^20*T[11]) +\n+             *    x^5(x^2*(T[2]+x^4*T[4]+...+x^22*[T12]))\n+             *\/\n+            r =    T[1] + w*(T[3] + w*(T[5] + w*(T[7] + w*(T[9]  + w*T[11]))));\n+            v = z*(T[2] + w*(T[4] + w*(T[6] + w*(T[8] + w*(T[10] + w*T[12])))));\n+            s = z*x;\n+            r = y + z*(s*(r + v) + y);\n+            r += T[0]*s;\n+            w = x + r;\n+            if (ix >= 0x3FE5_9428) {\n+                v = (double)iy;\n+                return (double)(1-((hx >> 30) & 2))*(v - 2.0*(x - (w*w\/(w + v) - r)));\n+            }\n+            if (iy == 1) {\n+                return w;\n+            } else { \/* if were to allow error up to 2 ulp,\n+                        could simply return -1.0\/(x + r) here *\/\n+                \/\/  compute -1.0\/(x + r) accurately\n+                double a,t;\n+                z  = w;\n+                z = __LO(z, 0);\n+                v  = r - (z - x);   \/\/ z + v = r + x\n+                t = a  = -1.0\/w;    \/\/ a = -1.0\/w\n+                t = __LO(t, 0);\n+                s  = 1.0 + t*z;\n+                return t + a*(s + t*v);\n+            }\n+        }\n+    }\n+\n+    \/** __ieee754_rem_pio2(x,y)\n+     *\n+     * return the remainder of x rem pi\/2 in y[0]+y[1]\n+     * use __kernel_rem_pio2()\n+     *\/\n+    static class RemPio2 {\n+        \/*\n+         * Table of constants for 2\/pi, 396 Hex digits (476 decimal) of 2\/pi\n+         *\/\n+        private static final int[] two_over_pi = {\n+            0xA2F983, 0x6E4E44, 0x1529FC, 0x2757D1, 0xF534DD, 0xC0DB62,\n+            0x95993C, 0x439041, 0xFE5163, 0xABDEBB, 0xC561B7, 0x246E3A,\n+            0x424DD2, 0xE00649, 0x2EEA09, 0xD1921C, 0xFE1DEB, 0x1CB129,\n+            0xA73EE8, 0x8235F5, 0x2EBB44, 0x84E99C, 0x7026B4, 0x5F7E41,\n+            0x3991D6, 0x398353, 0x39F49C, 0x845F8B, 0xBDF928, 0x3B1FF8,\n+            0x97FFDE, 0x05980F, 0xEF2F11, 0x8B5A0A, 0x6D1F6D, 0x367ECF,\n+            0x27CB09, 0xB74F46, 0x3F669E, 0x5FEA2D, 0x7527BA, 0xC7EBE5,\n+            0xF17B3D, 0x0739F7, 0x8A5292, 0xEA6BFB, 0x5FB11F, 0x8D5D08,\n+            0x560330, 0x46FC7B, 0x6BABF0, 0xCFBC20, 0x9AF436, 0x1DA9E3,\n+            0x91615E, 0xE61B08, 0x659985, 0x5F14A0, 0x68408D, 0xFFD880,\n+            0x4D7327, 0x310606, 0x1556CA, 0x73A8C9, 0x60E27B, 0xC08C6B,\n+        };\n+\n+        private static final int[] npio2_hw = {\n+            0x3FF921FB, 0x400921FB, 0x4012D97C, 0x401921FB, 0x401F6A7A, 0x4022D97C,\n+            0x4025FDBB, 0x402921FB, 0x402C463A, 0x402F6A7A, 0x4031475C, 0x4032D97C,\n+            0x40346B9C, 0x4035FDBB, 0x40378FDB, 0x403921FB, 0x403AB41B, 0x403C463A,\n+            0x403DD85A, 0x403F6A7A, 0x40407E4C, 0x4041475C, 0x4042106C, 0x4042D97C,\n+            0x4043A28C, 0x40446B9C, 0x404534AC, 0x4045FDBB, 0x4046C6CB, 0x40478FDB,\n+            0x404858EB, 0x404921FB,\n+        };\n+\n+        \/*\n+         * invpio2:  53 bits of 2\/pi\n+         * pio2_1:   first  33 bit of pi\/2\n+         * pio2_1t:  pi\/2 - pio2_1\n+         * pio2_2:   second 33 bit of pi\/2\n+         * pio2_2t:  pi\/2 - (pio2_1+pio2_2)\n+         * pio2_3:   third  33 bit of pi\/2\n+         * pio2_3t:  pi\/2 - (pio2_1+pio2_2+pio2_3)\n+         *\/\n+\n+        private static final double\n+            invpio2 =  0x1.45f306dc9c883p-1,   \/\/ 6.36619772367581382433e-01\n+            pio2_1  =  0x1.921fb544p0,         \/\/ 1.57079632673412561417e+00\n+            pio2_1t =  0x1.0b4611a626331p-34,  \/\/ 6.07710050650619224932e-11\n+            pio2_2  =  0x1.0b4611a6p-34,       \/\/ 6.07710050630396597660e-11\n+            pio2_2t =  0x1.3198a2e037073p-69,  \/\/ 2.02226624879595063154e-21\n+            pio2_3  =  0x1.3198a2ep-69,        \/\/ 2.02226624871116645580e-21\n+            pio2_3t =  0x1.b839a252049c1p-104; \/\/ 8.47842766036889956997e-32\n+\n+        static int __ieee754_rem_pio2(double x, double[] y) {\n+            double z = 0.0, w, t, r, fn;\n+            double[] tx = new double[3];\n+            int e0, i, j, nx, n, ix, hx;\n+\n+            hx = __HI(x);           \/\/ high word of x\n+            ix = hx & 0x7fff_ffff;\n+            if (ix <= 0x3fe9_21fb) {   \/\/ |x| ~<= pi\/4 , no need for reduction\n+                y[0] = x;\n+                y[1] = 0;\n+                return 0;\n+            }\n+            if (ix < 0x4002_d97c) {  \/\/ |x| < 3pi\/4, special case with n=+-1\n+                if (hx > 0) {\n+                    z = x - pio2_1;\n+                    if (ix != 0x3ff9_21fb) {    \/\/ 33+53 bit pi is good enough\n+                        y[0] = z - pio2_1t;\n+                        y[1] = (z - y[0]) - pio2_1t;\n+                    } else {                \/\/ near pi\/2, use 33+33+53 bit pi\n+                        z -= pio2_2;\n+                        y[0] = z - pio2_2t;\n+                        y[1] = (z-y[0])-pio2_2t;\n+                    }\n+                    return 1;\n+                } else {    \/\/ negative x\n+                    z = x + pio2_1;\n+                    if (ix != 0x3ff_921fb) {    \/\/ 33+53 bit pi is good enough\n+                        y[0] = z + pio2_1t;\n+                        y[1] = (z - y[0]) + pio2_1t;\n+                    } else {                \/\/ near pi\/2, use 33+33+53 bit pi\n+                        z += pio2_2;\n+                        y[0] = z + pio2_2t;\n+                        y[1] = (z - y[0]) + pio2_2t;\n+                    }\n+                    return -1;\n+                }\n+            }\n+            if (ix <= 0x4139_21fb) { \/\/ |x| ~<= 2^19*(pi\/2), medium size\n+                t  = Math.abs(x);\n+                n  = (int) (t*invpio2 + 0.5);\n+                fn = (double)n;\n+                r  = t - fn*pio2_1;\n+                w  = fn*pio2_1t;    \/\/ 1st round good to 85 bit\n+                if (n < 32 && ix != npio2_hw[n - 1]) {\n+                    y[0] = r - w;     \/\/ quick check no cancellation\n+                } else {\n+                    j  = ix >> 20;\n+                    y[0] = r - w;\n+                    i = j - (((__HI(y[0])) >> 20) & 0x7ff);\n+                    if (i > 16) {  \/\/ 2nd iteration needed, good to 118\n+                        t  = r;\n+                        w  = fn*pio2_2;\n+                        r  = t - w;\n+                        w  = fn*pio2_2t - ((t - r) - w);\n+                        y[0] = r - w;\n+                        i = j - (((__HI(y[0])) >> 20) & 0x7ff);\n+                        if (i > 49)  { \/\/ 3rd iteration need, 151 bits acc\n+                            t  = r; \/\/ will cover all possible cases\n+                            w  = fn*pio2_3;\n+                            r  = t - w;\n+                            w  = fn*pio2_3t - ((t - r) - w);\n+                            y[0] = r - w;\n+                        }\n+                    }\n+                }\n+                y[1] = (r - y[0]) - w;\n+                if (hx < 0) {\n+                    y[0] = -y[0];\n+                    y[1] = -y[1];\n+                    return -n;\n+                } else {\n+                    return n;\n+                }\n+            }\n+            \/*\n+             * all other (large) arguments\n+             *\/\n+            if (ix >= 0x7ff0_0000) {            \/\/ x is inf or NaN\n+                y[0] = y[1] = x - x;\n+                return 0;\n+            }\n+            \/\/ set z = scalbn(|x|,ilogb(x)-23)\n+            z = __LO(z, __LO(x));\n+            e0  = (ix >> 20) - 1046;        \/* e0 = ilogb(z)-23; *\/\n+            z = __HI(z, ix - (e0 << 20));\n+            for (i=0; i < 2; i++) {\n+                tx[i] = (double)((int)(z));\n+                z     = (z - tx[i])*TWO24;\n+            }\n+            tx[2] = z;\n+            nx = 3;\n+            while (tx[nx - 1] == 0.0) { \/\/ skip zero term\n+                nx--;\n+            }\n+            n  =  KernelRemPio2.__kernel_rem_pio2(tx, y, e0, nx, 2, two_over_pi);\n+            if (hx < 0) {\n+                y[0] = -y[0];\n+                y[1] = -y[1];\n+                return -n;\n+            }\n+            return n;\n+        }\n+    }\n+\n+    \/**\n+     * __kernel_rem_pio2(x,y,e0,nx,prec,ipio2)\n+     * double x[],y[]; int e0,nx,prec; int ipio2[];\n+     *\n+     * __kernel_rem_pio2 return the last three digits of N with\n+     *              y = x - N*pi\/2\n+     * so that |y| < pi\/2.\n+     *\n+     * The method is to compute the integer (mod 8) and fraction parts of\n+     * (2\/pi)*x without doing the full multiplication. In general we\n+     * skip the part of the product that are known to be a huge integer (\n+     * more accurately, = 0 mod 8 ). Thus the number of operations are\n+     * independent of the exponent of the input.\n+     *\n+     * (2\/pi) is represented by an array of 24-bit integers in ipio2[].\n+     *\n+     * Input parameters:\n+     *      x[]     The input value (must be positive) is broken into nx\n+     *              pieces of 24-bit integers in double precision format.\n+     *              x[i] will be the i-th 24 bit of x. The scaled exponent\n+     *              of x[0] is given in input parameter e0 (i.e., x[0]*2^e0\n+     *              match x's up to 24 bits.\n+     *\n+     *              Example of breaking a double positive z into x[0]+x[1]+x[2]:\n+     *                      e0 = ilogb(z)-23\n+     *                      z  = scalbn(z,-e0)\n+     *              for i = 0,1,2\n+     *                      x[i] = floor(z)\n+     *                      z    = (z-x[i])*2**24\n+     *\n+     *\n+     *      y[]     output result in an array of double precision numbers.\n+     *              The dimension of y[] is:\n+     *                      24-bit  precision       1\n+     *                      53-bit  precision       2\n+     *                      64-bit  precision       2\n+     *                      113-bit precision       3\n+     *              The actual value is the sum of them. Thus for 113-bit\n+     *              precision, one may have to do something like:\n+     *\n+     *              long double t,w,r_head, r_tail;\n+     *              t = (long double)y[2] + (long double)y[1];\n+     *              w = (long double)y[0];\n+     *              r_head = t+w;\n+     *              r_tail = w - (r_head - t);\n+     *\n+     *      e0      The exponent of x[0]\n+     *\n+     *      nx      dimension of x[]\n+     *\n+     *      prec    an integer indicating the precision:\n+     *                      0       24  bits (single)\n+     *                      1       53  bits (double)\n+     *                      2       64  bits (extended)\n+     *                      3       113 bits (quad)\n+     *\n+     *      ipio2[]\n+     *              integer array, contains the (24*i)-th to (24*i+23)-th\n+     *              bit of 2\/pi after binary point. The corresponding\n+     *              floating value is\n+     *\n+     *                      ipio2[i] * 2^(-24(i+1)).\n+     *\n+     * External function:\n+     *      double scalbn(), floor();\n+     *\n+     *\n+     * Here is the description of some local variables:\n+     *\n+     *      jk      jk+1 is the initial number of terms of ipio2[] needed\n+     *              in the computation. The recommended value is 2,3,4,\n+     *              6 for single, double, extended,and quad.\n+     *\n+     *      jz      local integer variable indicating the number of\n+     *              terms of ipio2[] used.\n+     *\n+     *      jx      nx - 1\n+     *\n+     *      jv      index for pointing to the suitable ipio2[] for the\n+     *              computation. In general, we want\n+     *                      ( 2^e0*x[0] * ipio2[jv-1]*2^(-24jv) )\/8\n+     *              is an integer. Thus\n+     *                      e0-3-24*jv >= 0 or (e0-3)\/24 >= jv\n+     *              Hence jv = max(0,(e0-3)\/24).\n+     *\n+     *      jp      jp+1 is the number of terms in PIo2[] needed, jp = jk.\n+     *\n+     *      q[]     double array with integral value, representing the\n+     *              24-bits chunk of the product of x and 2\/pi.\n+     *\n+     *      q0      the corresponding exponent of q[0]. Note that the\n+     *              exponent for q[i] would be q0-24*i.\n+     *\n+     *      PIo2[]  double precision array, obtained by cutting pi\/2\n+     *              into 24 bits chunks.\n+     *\n+     *      f[]     ipio2[] in floating point\n+     *\n+     *      iq[]    integer array by breaking up q[] in 24-bits chunk.\n+     *\n+     *      fq[]    final product of x*(2\/pi) in fq[0],..,fq[jk]\n+     *\n+     *      ih      integer. If >0 it indicates q[] is >= 0.5, hence\n+     *              it also indicates the *sign* of the result.\n+     *\n+     *\/\n+    static class KernelRemPio2 {\n+        \/*\n+         * Constants:\n+         * The hexadecimal values are the intended ones for the following\n+         * constants. The decimal values may be used, provided that the\n+         * compiler will convert from decimal to binary accurately enough\n+         * to produce the hexadecimal values shown.\n+         *\/\n+\n+        private static final int init_jk[] = {2, 3, 4, 6}; \/\/ initial value for jk\n+\n+        private static final double PIo2[] = {\n+            0x1.921fb4p0,    \/\/ 1.57079625129699707031e+00\n+            0x1.4442dp-24,   \/\/ 7.54978941586159635335e-08\n+            0x1.846988p-48,  \/\/ 5.39030252995776476554e-15\n+            0x1.8cc516p-72,  \/\/ 3.28200341580791294123e-22\n+            0x1.01b838p-96,  \/\/ 1.27065575308067607349e-29\n+            0x1.a25204p-120, \/\/ 1.22933308981111328932e-36\n+            0x1.382228p-145, \/\/ 2.73370053816464559624e-44\n+            0x1.9f31dp-169,  \/\/ 2.16741683877804819444e-51\n+        };\n+\n+        static final double\n+            twon24  = 0x1.0p-24; \/\/ 5.96046447753906250000e-08\n+\n+        static int __kernel_rem_pio2(double[] x, double[] y, int e0, int nx, int prec, final int[] ipio2) {\n+            int jz, jx, jv, jp, jk, carry, n, i, j, k, m, q0, ih;\n+            int[] iq = new int[20];\n+            double z,fw;\n+            double [] f = new double[20];\n+            double [] fq= new double[20];\n+            double [] q = new double[20];\n+\n+            \/\/ initialize jk\n+            jk = init_jk[prec];\n+            jp = jk;\n+\n+            \/\/ determine jx, jv, q0, note that 3 > q0\n+            jx =  nx - 1;\n+            jv = (e0 - 3)\/24;\n+            if (jv < 0) {\n+                jv = 0;\n+            }\n+            q0 =  e0 - 24*(jv + 1);\n+\n+            \/\/ set up f[0] to f[jx+jk] where f[jx+jk] = ipio2[jv+jk]\n+            j = jv - jx;\n+            m = jx + jk;\n+            for (i = 0; i <= m; i++, j++) {\n+                f[i] = (j < 0) ? 0.0 : (double) ipio2[j];\n+            }\n+\n+            \/\/ compute q[0],q[1],...q[jk]\n+            for (i=0; i <= jk; i++) {\n+                for(j = 0, fw = 0.0; j <= jx; j++) {\n+                    fw += x[j]*f[jx + i - j];\n+                }\n+                q[i] = fw;\n+            }\n+\n+            jz = jk;\n+            while(true) {\n+                \/\/ distill q[] into iq[] reversingly\n+                for(i=0, j=jz, z=q[jz]; j > 0; i++, j--) {\n+                    fw    =  (double)((int)(twon24* z));\n+                    iq[i] =  (int)(z - TWO24*fw);\n+                    z     =  q[j - 1] + fw;\n+                }\n+\n+                \/\/ compute n\n+                z  = Math.scalb(z, q0);              \/\/ actual value of z\n+                z -= 8.0*Math.floor(z*0.125);           \/\/ trim off integer >= 8\n+                n  = (int) z;\n+                z -= (double)n;\n+                ih = 0;\n+                if (q0 > 0) {      \/\/ need iq[jz - 1] to determine n\n+                    i  = (iq[jz - 1] >> (24 - q0));\n+                    n += i;\n+                    iq[jz - 1] -= i << (24 - q0);\n+                    ih = iq[jz - 1] >> (23 - q0);\n+                } else if (q0 == 0) {\n+                    ih = iq[jz-1]>>23;\n+                } else if (z >= 0.5) {\n+                    ih=2;\n+                }\n+\n+                if ( ih > 0) {      \/\/ q > 0.5\n+                    n += 1;\n+                    carry = 0;\n+                    for (i=0; i < jz; i++) {        \/\/ compute 1-q\n+                        j = iq[i];\n+                        if(carry == 0) {\n+                            if (j != 0) {\n+                                carry = 1;\n+                                iq[i] = 0x100_0000 - j;\n+                            }\n+                        } else {\n+                            iq[i] = 0xff_ffff - j;\n+                        }\n+                    }\n+                    if (q0 > 0) {          \/\/ rare case: chance is 1 in 12\n+                        switch(q0) {\n+                        case 1:\n+                            iq[jz-1] &= 0x7f_ffff;\n+                            break;\n+                        case 2:\n+                            iq[jz-1] &= 0x3f_ffff;\n+                            break;\n+                        }\n+                    }\n+                    if (ih == 2) {\n+                        z = 1.0 - z;\n+                        if (carry != 0) {\n+                            z -= Math.scalb(1.0, q0);\n+                        }\n+                    }\n+                }\n+\n+                \/\/ check if recomputation is needed\n+                if (z == 0.0) {\n+                    j = 0;\n+                    for (i = jz - 1; i >= jk; i--) {\n+                        j |= iq[i];\n+                    }\n+                    if (j == 0) { \/\/ need recomputation\n+                        for(k=1; iq[jk - k] == 0; k++);   \/\/ k = no. of terms needed\n+\n+                        for(i = jz + 1; i <= jz + k; i++) {   \/\/ add q[jz+1] to q[jz+k]\n+                            f[jx + i] = (double) ipio2[jv + i];\n+                            for (j=0, fw = 0.0; j <= jx; j++) {\n+                                fw += x[j]*f[jx + i - j];\n+                            }\n+                            q[i] = fw;\n+                        }\n+                        jz += k;\n+                        continue;\n+                    } else {\n+                        break;\n+                    }\n+                } else {\n+                    break;\n+                }\n+            }\n+\n+            \/\/ chop off zero terms\n+            if (z == 0.0) {\n+                jz -= 1;\n+                q0 -= 24;\n+                while (iq[jz] == 0) {\n+                    jz--;\n+                    q0-=24;\n+                }\n+            } else { \/\/ break z into 24-bit if necessary\n+                z = Math.scalb(z, -q0);\n+                if (z >= TWO24) {\n+                    fw = (double)((int)(twon24*z));\n+                    iq[jz] = (int)(z - TWO24*fw);\n+                    jz += 1;\n+                    q0 += 24;\n+                    iq[jz] = (int) fw;\n+                } else {\n+                    iq[jz] = (int) z;\n+                }\n+            }\n+\n+            \/\/ convert integer \"bit\" chunk to floating-point value\n+            fw = Math.scalb(1.0, q0);\n+            for(i = jz; i>=0; i--) {\n+                q[i] = fw*(double)iq[i];\n+                fw *= twon24;\n+            }\n+\n+            \/\/ compute PIo2[0,...,jp]*q[jz,...,0]\n+            for(i = jz; i>=0; i--) {\n+                for (fw = 0.0, k = 0; k <= jp && k <= jz-i; k++) {\n+                    fw += PIo2[k]*q[i + k];\n+                }\n+                fq[jz - i] = fw;\n+            }\n+\n+            \/\/ compress fq[] into y[]\n+            switch(prec) {\n+            case 0:\n+                fw = 0.0;\n+                for (i = jz; i >=0; i--) {\n+                    fw += fq[i];\n+                }\n+                y[0] = (ih == 0)? fw: -fw;\n+                break;\n+            case 1:\n+            case 2:\n+                fw = 0.0;\n+                for (i = jz; i>=0; i--) {\n+                    fw += fq[i];\n+                }\n+                y[0] = (ih == 0) ? fw: -fw;\n+                fw = fq[0] - fw;\n+                for (i = 1; i <= jz; i++) {\n+                    fw += fq[i];\n+                }\n+                y[1] = (ih == 0)? fw: -fw;\n+                break;\n+            case 3:     \/\/ painful\n+                for (i = jz; i > 0; i--) {\n+                    fw      = fq[i - 1] + fq[i];\n+                    fq[i]  += fq[i - 1] - fw;\n+                    fq[i - 1] = fw;\n+                }\n+                for (i = jz; i>1; i--) {\n+                    fw      = fq[i - 1] + fq[i];\n+                    fq[i]  += fq[i - 1] - fw;\n+                    fq[i-1] = fw;\n+                }\n+                for (fw = 0.0, i = jz; i >= 2; i--) {\n+                    fw += fq[i];\n+                }\n+                if (ih == 0) {\n+                    y[0] =  fq[0];\n+                    y[1] =  fq[1];\n+                    y[2] =  fw;\n+                } else {\n+                    y[0] = -fq[0];\n+                    y[1] = -fq[1];\n+                    y[2] = -fw;\n+                }\n+            }\n+            return n & 7;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/FdLibm.java","additions":905,"deletions":0,"binary":false,"changes":905,"status":"modified"},{"patch":"@@ -130,1 +130,3 @@\n-    public static native double sin(double a);\n+    public static double sin(double a) {\n+        return FdLibm.Sin.compute(a);\n+    }\n@@ -142,1 +144,3 @@\n-    public static native double cos(double a);\n+    public static double cos(double a) {\n+        return FdLibm.Cos.compute(a);\n+    }\n@@ -154,1 +158,3 @@\n-    public static native double tan(double a);\n+    public static double tan(double a) {\n+        return FdLibm.Tan.compute(a);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StrictMath.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build Tests\n+ * @run main SinCosTests\n+ * @bug 8302040\n+ * @summary Tests for {Math, StrictMath}.sqrt\n+ *\/\n+\n+public class SinCosTests {\n+    private SinCosTests(){}\n+\n+    public static void main(String... argv) {\n+        int failures = 0;\n+\n+        failures += testSin();\n+        failures += testCos();\n+\n+        if (failures > 0) {\n+            System.err.println(\"Testing sin and cos incurred \"\n+                               + failures + \" failures.\");\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    private static final double InfinityD = Double.POSITIVE_INFINITY;\n+    private static final double NaNd      = Double.NaN;\n+\n+    \/**\n+     * \"Special cases:\n+     *\n+     * If the argument is NaN or an infinity, then the result is NaN.\n+     *\n+     * If the argument is zero, then the result is a zero with the\n+     * same sign as the argument.\"\n+     *\/\n+    private static int testSin() {\n+        int failures = 0;\n+\n+        for(double nan : Tests.NaNs) {\n+            failures += testSinCase(nan, NaNd);\n+        }\n+\n+        double [][] testCases = {\n+            {+InfinityD,  NaNd},\n+            {-InfinityD,  NaNd},\n+\n+            {+0.0,        +0.0},\n+            {-0.0,        -0.0},\n+\n+        };\n+\n+        for(int i = 0; i < testCases.length; i++) {\n+            failures += testSinCase(testCases[i][0], testCases[i][1]);\n+        }\n+\n+        return failures;\n+    }\n+\n+    \/**\n+     * \"Special cases:\n+     *\n+     * If the argument is NaN or an infinity, then the result is NaN.\n+     * If the argument is zero, then the result is 1.0.\"\n+     *\/\n+    private static int testCos() {\n+        int failures = 0;\n+\n+        for(double nan : Tests.NaNs) {\n+            failures += testCosCase(nan, NaNd);\n+        }\n+\n+        double [][] testCases = {\n+            {+InfinityD,  NaNd},\n+            {-InfinityD,  NaNd},\n+\n+            {+0.0,        +1.0},\n+            {-0.0,        +1.0},\n+\n+        };\n+\n+        for(int i = 0; i < testCases.length; i++) {\n+            failures += testCosCase(testCases[i][0], testCases[i][1]);\n+        }\n+\n+        return failures;\n+    }\n+\n+    private static int testSinCase(double input, double expected) {\n+        int failures=0;\n+\n+        failures+=Tests.test(\"Math.sin\",        input, Math::sin,        expected);\n+        failures+=Tests.test(\"StrictMath.sin\",  input, StrictMath::sin,  expected);\n+\n+        return failures;\n+    }\n+\n+    private static int testCosCase(double input, double expected) {\n+        int failures=0;\n+\n+        failures+=Tests.test(\"Math.cos\",        input, Math::cos,        expected);\n+        failures+=Tests.test(\"StrictMath.cos\",  input, StrictMath::cos,  expected);\n+\n+        return failures;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Math\/SinCosTests.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -26,1 +26,3 @@\n- * @bug 5033578\n+ * @bug 5033578 8302027\n+ * @build Tests\n+ * @run main TanTests\n@@ -33,1 +35,18 @@\n-    static int testTanCase(double input, double expected, double ulps) {\n+    private static final double NaNd = Double.NaN;\n+    private static final double InfinityD = Double.POSITIVE_INFINITY;\n+\n+    public static void main(String... argv) {\n+        int failures = 0;\n+\n+        failures += testTanNaN();\n+        failures += testTanCardinal();\n+        failures += testTan();\n+\n+        if (failures > 0) {\n+            System.err.println(\"Testing tan incurred \"\n+                               + failures + \" failures.\");\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    private static int testTanCase(double input, double expected, double ulps) {\n@@ -40,1 +59,35 @@\n-    static int testTan() {\n+    private static int testTanNaN() {\n+        int failures = 0;\n+\n+        \/\/ \"If the argument is NaN or an infinity, then the result is NaN.\"\n+        for(double nan : Tests.NaNs) {\n+            failures += Tests.test(\"StrictMath.tan\", nan, StrictMath::tan, NaNd);\n+            failures += Tests.test(\"Math.tan\",       nan, Math::tan,       NaNd);\n+        }\n+\n+        return failures;\n+    }\n+\n+    private static int testTanCardinal() {\n+        int failures = 0;\n+\n+        double [][] testCases = {\n+            \/\/ \"If the argument is NaN or an infinity, then the result is NaN.\"\n+            { InfinityD, NaNd},\n+            {-InfinityD, NaNd},\n+\n+            \/\/ \"If the argument is zero, then the result is a zero\n+            \/\/ with the same sign as the argument.\"\n+            {-0.0, -0.0},\n+            {+0.0, +0.0},\n+        };\n+\n+        for(double[] testCase : testCases) {\n+            failures += Tests.test(\"StrictMath.tan\", testCase[0], StrictMath::tan, testCase[1]);\n+            failures += Tests.test(\"Math.tan\",       testCase[0], Math::tan,       testCase[1]);\n+        }\n+\n+        return failures;\n+    }\n+\n+    private static int testTan() {\n@@ -172,12 +225,0 @@\n-\n-    public static void main(String... argv) {\n-        int failures = 0;\n-\n-        failures += testTan();\n-\n-        if (failures > 0) {\n-            System.err.println(\"Testing tan incurred \"\n-                               + failures + \" failures.\");\n-            throw new RuntimeException();\n-        }\n-    }\n","filename":"test\/jdk\/java\/lang\/Math\/TanTests.java","additions":56,"deletions":15,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8301833 8302026 8301444 8302028 8302040\n+ * @bug 8301833 8302026 8301444 8302028 8302040 8302027\n@@ -87,3 +87,3 @@\n-         \/\/ new UnaryTestCase(\"sin\",   FdlibmTranslit::sin,   StrictMath::sin,   DEFAULT_SHIFT),\n-         \/\/ new UnaryTestCase(\"cos\",   FdlibmTranslit::cos,   StrictMath::cos,   DEFAULT_SHIFT),\n-         \/\/ new UnaryTestCase(\"tan\",   FdlibmTranslit::tan,   StrictMath::tan,   DEFAULT_SHIFT),\n+            new UnaryTestCase(\"sin\",   FdlibmTranslit::sin,   StrictMath::sin,   DEFAULT_SHIFT),\n+            new UnaryTestCase(\"cos\",   FdlibmTranslit::cos,   StrictMath::cos,   DEFAULT_SHIFT),\n+            new UnaryTestCase(\"tan\",   FdlibmTranslit::tan,   StrictMath::tan,   DEFAULT_SHIFT),\n","filename":"test\/jdk\/java\/lang\/StrictMath\/ExhaustingTests.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -73,0 +73,12 @@\n+    public static double sin(double x) {\n+        return Sin.compute(x);\n+    }\n+\n+    public static double cos(double x) {\n+        return Cos.compute(x);\n+    }\n+\n+    public static double tan(double x) {\n+        return Tan.compute(x);\n+    }\n+\n@@ -133,0 +145,849 @@\n+    \/\/ -----------------------------------------------------------------------------------------\n+\n+    \/** sin(x)\n+     * Return sine function of x.\n+     *\n+     * kernel function:\n+     *      __kernel_sin            ... sine function on [-pi\/4,pi\/4]\n+     *      __kernel_cos            ... cose function on [-pi\/4,pi\/4]\n+     *      __ieee754_rem_pio2      ... argument reduction routine\n+     *\n+     * Method.\n+     *      Let S,C and T denote the sin, cos and tan respectively on\n+     *      [-PI\/4, +PI\/4]. Reduce the argument x to y1+y2 = x-k*pi\/2\n+     *      in [-pi\/4 , +pi\/4], and let n = k mod 4.\n+     *      We have\n+     *\n+     *          n        sin(x)      cos(x)        tan(x)\n+     *     ----------------------------------------------------------\n+     *          0          S           C             T\n+     *          1          C          -S            -1\/T\n+     *          2         -S          -C             T\n+     *          3         -C           S            -1\/T\n+     *     ----------------------------------------------------------\n+     *\n+     * Special cases:\n+     *      Let trig be any of sin, cos, or tan.\n+     *      trig(+-INF)  is NaN, with signals;\n+     *      trig(NaN)    is that NaN;\n+     *\n+     * Accuracy:\n+     *      TRIG(x) returns trig(x) nearly rounded\n+     *\/\n+    static class Sin {\n+        static double compute(double x) {\n+            double[] y = new double[2];\n+            double z=0.0;\n+            int n, ix;\n+\n+            \/* High word of x. *\/\n+            ix = __HI(x);\n+\n+            \/* |x| ~< pi\/4 *\/\n+            ix &= 0x7fffffff;\n+            if(ix <= 0x3fe921fb) return __kernel_sin(x,z,0);\n+\n+            \/* sin(Inf or NaN) is NaN *\/\n+            else if (ix>=0x7ff00000) return x-x;\n+\n+            \/* argument reduction needed *\/\n+            else {\n+                n = RemPio2.__ieee754_rem_pio2(x,y);\n+                switch(n&3) {\n+                case 0: return  Sin.__kernel_sin(y[0],y[1],1);\n+                case 1: return  Cos.__kernel_cos(y[0],y[1]);\n+                case 2: return -Sin.__kernel_sin(y[0],y[1],1);\n+                default:\n+                    return -Cos.__kernel_cos(y[0],y[1]);\n+                }\n+            }\n+        }\n+\n+        \/** __kernel_sin( x, y, iy)\n+         * kernel sin function on [-pi\/4, pi\/4], pi\/4 ~ 0.7854\n+         * Input x is assumed to be bounded by ~pi\/4 in magnitude.\n+         * Input y is the tail of x.\n+         * Input iy indicates whether y is 0. (if iy=0, y assume to be 0).\n+         *\n+         * Algorithm\n+         *      1. Since sin(-x) = -sin(x), we need only to consider positive x.\n+         *      2. if x < 2^-27 (hx<0x3e400000 0), return x with inexact if x!=0.\n+         *      3. sin(x) is approximated by a polynomial of degree 13 on\n+         *         [0,pi\/4]\n+         *                               3            13\n+         *              sin(x) ~ x + S1*x + ... + S6*x\n+         *         where\n+         *\n+         *      |sin(x)         2     4     6     8     10     12  |     -58\n+         *      |----- - (1+S1*x +S2*x +S3*x +S4*x +S5*x  +S6*x   )| <= 2\n+         *      |  x                                               |\n+         *\n+         *      4. sin(x+y) = sin(x) + sin'(x')*y\n+         *                  ~ sin(x) + (1-x*x\/2)*y\n+         *         For better accuracy, let\n+         *                   3      2      2      2      2\n+         *              r = x *(S2+x *(S3+x *(S4+x *(S5+x *S6))))\n+         *         then                   3    2\n+         *              sin(x) = x + (S1*x + (x *(r-y\/2)+y))\n+         *\/\n+        private static final double\n+            half =  5.00000000000000000000e-01, \/* 0x3FE00000, 0x00000000 *\/\n+            S1  = -1.66666666666666324348e-01, \/* 0xBFC55555, 0x55555549 *\/\n+            S2  =  8.33333333332248946124e-03, \/* 0x3F811111, 0x1110F8A6 *\/\n+            S3  = -1.98412698298579493134e-04, \/* 0xBF2A01A0, 0x19C161D5 *\/\n+            S4  =  2.75573137070700676789e-06, \/* 0x3EC71DE3, 0x57B1FE7D *\/\n+            S5  = -2.50507602534068634195e-08, \/* 0xBE5AE5E6, 0x8A2B9CEB *\/\n+            S6  =  1.58969099521155010221e-10; \/* 0x3DE5D93A, 0x5ACFD57C *\/\n+\n+        static double __kernel_sin(double x, double y, int iy) {\n+            double z,r,v;\n+            int ix;\n+            ix = __HI(x)&0x7fffffff;        \/* high word of x *\/\n+            if(ix<0x3e400000)                       \/* |x| < 2**-27 *\/\n+                {if((int)x==0) return x;}            \/* generate inexact *\/\n+            z       =  x*x;\n+            v       =  z*x;\n+            r       =  S2+z*(S3+z*(S4+z*(S5+z*S6)));\n+            if(iy==0) return x+v*(S1+z*r);\n+            else      return x-((z*(half*y-v*r)-y)-v*S1);\n+        }\n+    }\n+\n+\n+    \/** cos(x)\n+     * Return cosine function of x.\n+     *\n+     * kernel function:\n+     *      __kernel_sin            ... sine function on [-pi\/4,pi\/4]\n+     *      __kernel_cos            ... cosine function on [-pi\/4,pi\/4]\n+     *      __ieee754_rem_pio2      ... argument reduction routine\n+     *\n+     * Method.\n+     *      Let S,C and T denote the sin, cos and tan respectively on\n+     *      [-PI\/4, +PI\/4]. Reduce the argument x to y1+y2 = x-k*pi\/2\n+     *      in [-pi\/4 , +pi\/4], and let n = k mod 4.\n+     *      We have\n+     *\n+     *          n        sin(x)      cos(x)        tan(x)\n+     *     ----------------------------------------------------------\n+     *          0          S           C             T\n+     *          1          C          -S            -1\/T\n+     *          2         -S          -C             T\n+     *          3         -C           S            -1\/T\n+     *     ----------------------------------------------------------\n+     *\n+     * Special cases:\n+     *      Let trig be any of sin, cos, or tan.\n+     *      trig(+-INF)  is NaN, with signals;\n+     *      trig(NaN)    is that NaN;\n+     *\n+     * Accuracy:\n+     *      TRIG(x) returns trig(x) nearly rounded\n+     *\/\n+    static class Cos {\n+        static double compute(double x) {\n+            double[] y = new double[2];\n+            double z=0.0;\n+            int n, ix;\n+\n+            \/* High word of x. *\/\n+            ix = __HI(x);\n+\n+            \/* |x| ~< pi\/4 *\/\n+            ix &= 0x7fffffff;\n+            if(ix <= 0x3fe921fb) return __kernel_cos(x,z);\n+\n+            \/* cos(Inf or NaN) is NaN *\/\n+            else if (ix>=0x7ff00000) return x-x;\n+\n+            \/* argument reduction needed *\/\n+            else {\n+                n = RemPio2.__ieee754_rem_pio2(x,y);\n+                switch(n&3) {\n+                case 0: return  Cos.__kernel_cos(y[0],y[1]);\n+                case 1: return -Sin.__kernel_sin(y[0],y[1],1);\n+                case 2: return -Cos.__kernel_cos(y[0],y[1]);\n+                default:\n+                    return  Sin.__kernel_sin(y[0],y[1],1);\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * __kernel_cos( x,  y )\n+         * kernel cos function on [-pi\/4, pi\/4], pi\/4 ~ 0.785398164\n+         * Input x is assumed to be bounded by ~pi\/4 in magnitude.\n+         * Input y is the tail of x.\n+         *\n+         * Algorithm\n+         *      1. Since cos(-x) = cos(x), we need only to consider positive x.\n+         *      2. if x < 2^-27 (hx<0x3e400000 0), return 1 with inexact if x!=0.\n+         *      3. cos(x) is approximated by a polynomial of degree 14 on\n+         *         [0,pi\/4]\n+         *                                       4            14\n+         *              cos(x) ~ 1 - x*x\/2 + C1*x + ... + C6*x\n+         *         where the remez error is\n+         *\n+         *      |              2     4     6     8     10    12     14 |     -58\n+         *      |cos(x)-(1-.5*x +C1*x +C2*x +C3*x +C4*x +C5*x  +C6*x  )| <= 2\n+         *      |                                                      |\n+         *\n+         *                     4     6     8     10    12     14\n+         *      4. let r = C1*x +C2*x +C3*x +C4*x +C5*x  +C6*x  , then\n+         *             cos(x) = 1 - x*x\/2 + r\n+         *         since cos(x+y) ~ cos(x) - sin(x)*y\n+         *                        ~ cos(x) - x*y,\n+         *         a correction term is necessary in cos(x) and hence\n+         *              cos(x+y) = 1 - (x*x\/2 - (r - x*y))\n+         *         For better accuracy when x > 0.3, let qx = |x|\/4 with\n+         *         the last 32 bits mask off, and if x > 0.78125, let qx = 0.28125.\n+         *         Then\n+         *              cos(x+y) = (1-qx) - ((x*x\/2-qx) - (r-x*y)).\n+         *         Note that 1-qx and (x*x\/2-qx) is EXACT here, and the\n+         *         magnitude of the latter is at least a quarter of x*x\/2,\n+         *         thus, reducing the rounding error in the subtraction.\n+         *\/\n+        private static final double\n+            one =  1.00000000000000000000e+00, \/* 0x3FF00000, 0x00000000 *\/\n+            C1  =  4.16666666666666019037e-02, \/* 0x3FA55555, 0x5555554C *\/\n+            C2  = -1.38888888888741095749e-03, \/* 0xBF56C16C, 0x16C15177 *\/\n+            C3  =  2.48015872894767294178e-05, \/* 0x3EFA01A0, 0x19CB1590 *\/\n+            C4  = -2.75573143513906633035e-07, \/* 0xBE927E4F, 0x809C52AD *\/\n+            C5  =  2.08757232129817482790e-09, \/* 0x3E21EE9E, 0xBDB4B1C4 *\/\n+            C6  = -1.13596475577881948265e-11; \/* 0xBDA8FAE9, 0xBE8838D4 *\/\n+\n+        static double __kernel_cos(double x, double y) {\n+            double a,hz,z,r,qx = 0.0;\n+            int ix;\n+            ix = __HI(x)&0x7fffffff;        \/* ix = |x|'s high word*\/\n+            if(ix<0x3e400000) {                     \/* if x < 2**27 *\/\n+                if(((int)x)==0) return one;         \/* generate inexact *\/\n+            }\n+            z  = x*x;\n+            r  = z*(C1+z*(C2+z*(C3+z*(C4+z*(C5+z*C6)))));\n+            if(ix < 0x3FD33333)                     \/* if |x| < 0.3 *\/\n+                return one - (0.5*z - (z*r - x*y));\n+            else {\n+                if(ix > 0x3fe90000) {               \/* x > 0.78125 *\/\n+                    qx = 0.28125;\n+                } else {\n+                    \/\/__HI(qx) = ix-0x00200000;       \/* x\/4 *\/\n+                    qx = __HI(qx, ix-0x00200000);\n+                    \/\/ __LO(qx) = 0;\n+                    qx = __LO(qx, 0);\n+                }\n+                hz = 0.5*z-qx;\n+                a  = one-qx;\n+                return a - (hz - (z*r-x*y));\n+            }\n+        }\n+    }\n+\n+    \/** tan(x)\n+     * Return tangent function of x.\n+     *\n+     * kernel function:\n+     *      __kernel_tan            ... tangent function on [-pi\/4,pi\/4]\n+     *      __ieee754_rem_pio2      ... argument reduction routine\n+     *\n+     * Method.\n+     *      Let S,C and T denote the sin, cos and tan respectively on\n+     *      [-PI\/4, +PI\/4]. Reduce the argument x to y1+y2 = x-k*pi\/2\n+     *      in [-pi\/4 , +pi\/4], and let n = k mod 4.\n+     *      We have\n+     *\n+     *          n        sin(x)      cos(x)        tan(x)\n+     *     ----------------------------------------------------------\n+     *          0          S           C             T\n+     *          1          C          -S            -1\/T\n+     *          2         -S          -C             T\n+     *          3         -C           S            -1\/T\n+     *     ----------------------------------------------------------\n+     *\n+     * Special cases:\n+     *      Let trig be any of sin, cos, or tan.\n+     *      trig(+-INF)  is NaN, with signals;\n+     *      trig(NaN)    is that NaN;\n+     *\n+     * Accuracy:\n+     *      TRIG(x) returns trig(x) nearly rounded\n+     *\/\n+    static class Tan {\n+        static double compute(double x) {\n+            double[] y= new double[2];\n+            double z=0.0;\n+            int n, ix;\n+\n+            \/* High word of x. *\/\n+            ix = __HI(x);\n+\n+            \/* |x| ~< pi\/4 *\/\n+            ix &= 0x7fffffff;\n+            if(ix <= 0x3fe921fb) return __kernel_tan(x,z,1);\n+\n+            \/* tan(Inf or NaN) is NaN *\/\n+            else if (ix>=0x7ff00000) return x-x;            \/* NaN *\/\n+\n+            \/* argument reduction needed *\/\n+            else {\n+                n = RemPio2.__ieee754_rem_pio2(x,y);\n+                return __kernel_tan(y[0],y[1],1-((n&1)<<1)); \/*   1 -- n even\n+                                                                  -1 -- n odd *\/\n+            }\n+        }\n+\n+        \/** __kernel_tan( x, y, k )\n+         * kernel tan function on [-pi\/4, pi\/4], pi\/4 ~ 0.7854\n+         * Input x is assumed to be bounded by ~pi\/4 in magnitude.\n+         * Input y is the tail of x.\n+         * Input k indicates whether tan (if k=1) or\n+         * -1\/tan (if k= -1) is returned.\n+         *\n+         * Algorithm\n+         *      1. Since tan(-x) = -tan(x), we need only to consider positive x.\n+         *      2. if x < 2^-28 (hx<0x3e300000 0), return x with inexact if x!=0.\n+         *      3. tan(x) is approximated by a odd polynomial of degree 27 on\n+         *         [0,0.67434]\n+         *                               3             27\n+         *              tan(x) ~ x + T1*x + ... + T13*x\n+         *         where\n+         *\n+         *              |tan(x)         2     4            26   |     -59.2\n+         *              |----- - (1+T1*x +T2*x +.... +T13*x    )| <= 2\n+         *              |  x                                    |\n+         *\n+         *         Note: tan(x+y) = tan(x) + tan'(x)*y\n+         *                        ~ tan(x) + (1+x*x)*y\n+         *         Therefore, for better accuracy in computing tan(x+y), let\n+         *                   3      2      2       2       2\n+         *              r = x *(T2+x *(T3+x *(...+x *(T12+x *T13))))\n+         *         then\n+         *                                  3    2\n+         *              tan(x+y) = x + (T1*x + (x *(r+y)+y))\n+         *\n+         *      4. For x in [0.67434,pi\/4],  let y = pi\/4 - x, then\n+         *              tan(x) = tan(pi\/4-y) = (1-tan(y))\/(1+tan(y))\n+         *                     = 1 - 2*(tan(y) - (tan(y)^2)\/(1+tan(y)))\n+         *\/\n+        private static final double\n+            one   =  1.00000000000000000000e+00, \/* 0x3FF00000, 0x00000000 *\/\n+            pio4  =  7.85398163397448278999e-01, \/* 0x3FE921FB, 0x54442D18 *\/\n+            pio4lo=  3.06161699786838301793e-17, \/* 0x3C81A626, 0x33145C07 *\/\n+            T[] =  {\n+            3.33333333333334091986e-01, \/* 0x3FD55555, 0x55555563 *\/\n+            1.33333333333201242699e-01, \/* 0x3FC11111, 0x1110FE7A *\/\n+            5.39682539762260521377e-02, \/* 0x3FABA1BA, 0x1BB341FE *\/\n+            2.18694882948595424599e-02, \/* 0x3F9664F4, 0x8406D637 *\/\n+            8.86323982359930005737e-03, \/* 0x3F8226E3, 0xE96E8493 *\/\n+            3.59207910759131235356e-03, \/* 0x3F6D6D22, 0xC9560328 *\/\n+            1.45620945432529025516e-03, \/* 0x3F57DBC8, 0xFEE08315 *\/\n+            5.88041240820264096874e-04, \/* 0x3F4344D8, 0xF2F26501 *\/\n+            2.46463134818469906812e-04, \/* 0x3F3026F7, 0x1A8D1068 *\/\n+            7.81794442939557092300e-05, \/* 0x3F147E88, 0xA03792A6 *\/\n+            7.14072491382608190305e-05, \/* 0x3F12B80F, 0x32F0A7E9 *\/\n+            -1.85586374855275456654e-05, \/* 0xBEF375CB, 0xDB605373 *\/\n+            2.59073051863633712884e-05, \/* 0x3EFB2A70, 0x74BF7AD4 *\/\n+        };\n+\n+        static double __kernel_tan(double x, double y, int iy) {\n+            double z,r,v,w,s;\n+            int ix,hx;\n+            hx = __HI(x);   \/* high word of x *\/\n+            ix = hx&0x7fffffff;     \/* high word of |x| *\/\n+            if(ix<0x3e300000) {                     \/* x < 2**-28 *\/\n+                if((int)x==0) {                       \/* generate inexact *\/\n+                    if (((ix | __LO(x)) | (iy + 1)) == 0)\n+                        return one \/ Math.abs(x);\n+                    else {\n+                        if (iy == 1)\n+                            return x;\n+                        else {    \/* compute -1 \/ (x+y) carefully *\/\n+                            double a, t;\n+\n+                            z = w = x + y;\n+                            \/\/ __LO(z) = 0;\n+                            z= __LO(z, 0);\n+                            v = y - (z - x);\n+                            t = a = -one \/ w;\n+                            \/\/__LO(t) = 0;\n+                            t = __LO(t, 0);\n+                            s = one + t * z;\n+                            return t + a * (s + t * v);\n+                        }\n+                    }\n+                }\n+            }\n+            if(ix>=0x3FE59428) {                    \/* |x|>=0.6744 *\/\n+                if(hx<0) {x = -x; y = -y;}\n+                z = pio4-x;\n+                w = pio4lo-y;\n+                x = z+w; y = 0.0;\n+            }\n+            z       =  x*x;\n+            w       =  z*z;\n+            \/* Break x^5*(T[1]+x^2*T[2]+...) into\n+             *    x^5(T[1]+x^4*T[3]+...+x^20*T[11]) +\n+             *    x^5(x^2*(T[2]+x^4*T[4]+...+x^22*[T12]))\n+             *\/\n+            r = T[1]+w*(T[3]+w*(T[5]+w*(T[7]+w*(T[9]+w*T[11]))));\n+            v = z*(T[2]+w*(T[4]+w*(T[6]+w*(T[8]+w*(T[10]+w*T[12])))));\n+            s = z*x;\n+            r = y + z*(s*(r+v)+y);\n+            r += T[0]*s;\n+            w = x+r;\n+            if(ix>=0x3FE59428) {\n+                v = (double)iy;\n+                return (double)(1-((hx>>30)&2))*(v-2.0*(x-(w*w\/(w+v)-r)));\n+            }\n+            if(iy==1) return w;\n+            else {          \/* if allow error up to 2 ulp,\n+                               simply return -1.0\/(x+r) here *\/\n+                \/*  compute -1.0\/(x+r) accurately *\/\n+                double a,t;\n+                z  = w;\n+                \/\/ __LO(z) = 0;\n+                z = __LO(z, 0);\n+                v  = r-(z - x);     \/* z+v = r+x *\/\n+                t = a  = -1.0\/w;    \/* a = -1.0\/w *\/\n+                \/\/ __LO(t) = 0;\n+                t = __LO(t, 0);\n+                s  = 1.0+t*z;\n+                return t+a*(s+t*v);\n+            }\n+        }\n+    }\n+\n+    \/** __ieee754_rem_pio2(x,y)\n+     *\n+     * return the remainder of x rem pi\/2 in y[0]+y[1]\n+     * use __kernel_rem_pio2()\n+     *\/\n+    static class RemPio2 {\n+        \/*\n+         * Table of constants for 2\/pi, 396 Hex digits (476 decimal) of 2\/pi\n+         *\/\n+        private static final int[] two_over_pi = {\n+            0xA2F983, 0x6E4E44, 0x1529FC, 0x2757D1, 0xF534DD, 0xC0DB62,\n+            0x95993C, 0x439041, 0xFE5163, 0xABDEBB, 0xC561B7, 0x246E3A,\n+            0x424DD2, 0xE00649, 0x2EEA09, 0xD1921C, 0xFE1DEB, 0x1CB129,\n+            0xA73EE8, 0x8235F5, 0x2EBB44, 0x84E99C, 0x7026B4, 0x5F7E41,\n+            0x3991D6, 0x398353, 0x39F49C, 0x845F8B, 0xBDF928, 0x3B1FF8,\n+            0x97FFDE, 0x05980F, 0xEF2F11, 0x8B5A0A, 0x6D1F6D, 0x367ECF,\n+            0x27CB09, 0xB74F46, 0x3F669E, 0x5FEA2D, 0x7527BA, 0xC7EBE5,\n+            0xF17B3D, 0x0739F7, 0x8A5292, 0xEA6BFB, 0x5FB11F, 0x8D5D08,\n+            0x560330, 0x46FC7B, 0x6BABF0, 0xCFBC20, 0x9AF436, 0x1DA9E3,\n+            0x91615E, 0xE61B08, 0x659985, 0x5F14A0, 0x68408D, 0xFFD880,\n+            0x4D7327, 0x310606, 0x1556CA, 0x73A8C9, 0x60E27B, 0xC08C6B,\n+        };\n+\n+        private static final int[] npio2_hw = {\n+            0x3FF921FB, 0x400921FB, 0x4012D97C, 0x401921FB, 0x401F6A7A, 0x4022D97C,\n+            0x4025FDBB, 0x402921FB, 0x402C463A, 0x402F6A7A, 0x4031475C, 0x4032D97C,\n+            0x40346B9C, 0x4035FDBB, 0x40378FDB, 0x403921FB, 0x403AB41B, 0x403C463A,\n+            0x403DD85A, 0x403F6A7A, 0x40407E4C, 0x4041475C, 0x4042106C, 0x4042D97C,\n+            0x4043A28C, 0x40446B9C, 0x404534AC, 0x4045FDBB, 0x4046C6CB, 0x40478FDB,\n+            0x404858EB, 0x404921FB,\n+        };\n+\n+        \/*\n+         * invpio2:  53 bits of 2\/pi\n+         * pio2_1:   first  33 bit of pi\/2\n+         * pio2_1t:  pi\/2 - pio2_1\n+         * pio2_2:   second 33 bit of pi\/2\n+         * pio2_2t:  pi\/2 - (pio2_1+pio2_2)\n+         * pio2_3:   third  33 bit of pi\/2\n+         * pio2_3t:  pi\/2 - (pio2_1+pio2_2+pio2_3)\n+         *\/\n+\n+        private static final double\n+            zero =  0.00000000000000000000e+00, \/* 0x00000000, 0x00000000 *\/\n+            half =  5.00000000000000000000e-01, \/* 0x3FE00000, 0x00000000 *\/\n+            two24 =  1.67772160000000000000e+07, \/* 0x41700000, 0x00000000 *\/\n+            invpio2 =  6.36619772367581382433e-01, \/* 0x3FE45F30, 0x6DC9C883 *\/\n+            pio2_1  =  1.57079632673412561417e+00, \/* 0x3FF921FB, 0x54400000 *\/\n+            pio2_1t =  6.07710050650619224932e-11, \/* 0x3DD0B461, 0x1A626331 *\/\n+            pio2_2  =  6.07710050630396597660e-11, \/* 0x3DD0B461, 0x1A600000 *\/\n+            pio2_2t =  2.02226624879595063154e-21, \/* 0x3BA3198A, 0x2E037073 *\/\n+            pio2_3  =  2.02226624871116645580e-21, \/* 0x3BA3198A, 0x2E000000 *\/\n+            pio2_3t =  8.47842766036889956997e-32; \/* 0x397B839A, 0x252049C1 *\/\n+\n+        static int __ieee754_rem_pio2(double x, double[] y) {\n+            double z = 0.0,w,t,r,fn;\n+            double[] tx = new double[3];\n+            int e0,i,j,nx,n,ix,hx;\n+\n+            hx = __HI(x);           \/* high word of x *\/\n+            ix = hx&0x7fffffff;\n+            if(ix<=0x3fe921fb)   \/* |x| ~<= pi\/4 , no need for reduction *\/\n+                {y[0] = x; y[1] = 0; return 0;}\n+            if(ix<0x4002d97c) {  \/* |x| < 3pi\/4, special case with n=+-1 *\/\n+                if(hx>0) {\n+                    z = x - pio2_1;\n+                    if(ix!=0x3ff921fb) {    \/* 33+53 bit pi is good enough *\/\n+                        y[0] = z - pio2_1t;\n+                        y[1] = (z-y[0])-pio2_1t;\n+                    } else {                \/* near pi\/2, use 33+33+53 bit pi *\/\n+                        z -= pio2_2;\n+                        y[0] = z - pio2_2t;\n+                        y[1] = (z-y[0])-pio2_2t;\n+                    }\n+                    return 1;\n+                } else {    \/* negative x *\/\n+                    z = x + pio2_1;\n+                    if(ix!=0x3ff921fb) {    \/* 33+53 bit pi is good enough *\/\n+                        y[0] = z + pio2_1t;\n+                        y[1] = (z-y[0])+pio2_1t;\n+                    } else {                \/* near pi\/2, use 33+33+53 bit pi *\/\n+                        z += pio2_2;\n+                        y[0] = z + pio2_2t;\n+                        y[1] = (z-y[0])+pio2_2t;\n+                    }\n+                    return -1;\n+                }\n+            }\n+            if(ix<=0x413921fb) { \/* |x| ~<= 2^19*(pi\/2), medium size *\/\n+                t  = Math.abs(x);\n+                n  = (int) (t*invpio2+half);\n+                fn = (double)n;\n+                r  = t-fn*pio2_1;\n+                w  = fn*pio2_1t;    \/* 1st round good to 85 bit *\/\n+                if(n<32&&ix!=npio2_hw[n-1]) {\n+                    y[0] = r-w;     \/* quick check no cancellation *\/\n+                } else {\n+                    j  = ix>>20;\n+                    y[0] = r-w;\n+                    i = j-(((__HI(y[0]))>>20)&0x7ff);\n+                    if(i>16) {  \/* 2nd iteration needed, good to 118 *\/\n+                        t  = r;\n+                        w  = fn*pio2_2;\n+                        r  = t-w;\n+                        w  = fn*pio2_2t-((t-r)-w);\n+                        y[0] = r-w;\n+                        i = j-(((__HI(y[0]))>>20)&0x7ff);\n+                        if(i>49)  { \/* 3rd iteration need, 151 bits acc *\/\n+                            t  = r; \/* will cover all possible cases *\/\n+                            w  = fn*pio2_3;\n+                            r  = t-w;\n+                            w  = fn*pio2_3t-((t-r)-w);\n+                            y[0] = r-w;\n+                        }\n+                    }\n+                }\n+                y[1] = (r-y[0])-w;\n+                if(hx<0)    {y[0] = -y[0]; y[1] = -y[1]; return -n;}\n+                else         return n;\n+            }\n+            \/*\n+             * all other (large) arguments\n+             *\/\n+            if(ix>=0x7ff00000) {            \/* x is inf or NaN *\/\n+                y[0]=y[1]=x-x; return 0;\n+            }\n+            \/* set z = scalbn(|x|,ilogb(x)-23) *\/\n+            \/\/ __LO(z) = __LO(x);\n+            z = __LO(z, __LO(x));\n+            e0      = (ix>>20)-1046;        \/* e0 = ilogb(z)-23; *\/\n+            \/\/ __HI(z) = ix - (e0<<20);\n+            z = __HI(z, ix - (e0<<20));\n+            for(i=0;i<2;i++) {\n+                tx[i] = (double)((int)(z));\n+                z     = (z-tx[i])*two24;\n+            }\n+            tx[2] = z;\n+            nx = 3;\n+            while(tx[nx-1]==zero) nx--;     \/* skip zero term *\/\n+            n  =  KernelRemPio2.__kernel_rem_pio2(tx,y,e0,nx,2,two_over_pi);\n+            if(hx<0) {y[0] = -y[0]; y[1] = -y[1]; return -n;}\n+            return n;\n+        }\n+\n+    }\n+\n+    \/**\n+     * __kernel_rem_pio2(x,y,e0,nx,prec,ipio2)\n+     * double x[],y[]; int e0,nx,prec; int ipio2[];\n+     *\n+     * __kernel_rem_pio2 return the last three digits of N with\n+     *              y = x - N*pi\/2\n+     * so that |y| < pi\/2.\n+     *\n+     * The method is to compute the integer (mod 8) and fraction parts of\n+     * (2\/pi)*x without doing the full multiplication. In general we\n+     * skip the part of the product that are known to be a huge integer (\n+     * more accurately, = 0 mod 8 ). Thus the number of operations are\n+     * independent of the exponent of the input.\n+     *\n+     * (2\/pi) is represented by an array of 24-bit integers in ipio2[].\n+     *\n+     * Input parameters:\n+     *      x[]     The input value (must be positive) is broken into nx\n+     *              pieces of 24-bit integers in double precision format.\n+     *              x[i] will be the i-th 24 bit of x. The scaled exponent\n+     *              of x[0] is given in input parameter e0 (i.e., x[0]*2^e0\n+     *              match x's up to 24 bits.\n+     *\n+     *              Example of breaking a double positive z into x[0]+x[1]+x[2]:\n+     *                      e0 = ilogb(z)-23\n+     *                      z  = scalbn(z,-e0)\n+     *              for i = 0,1,2\n+     *                      x[i] = floor(z)\n+     *                      z    = (z-x[i])*2**24\n+     *\n+     *\n+     *      y[]     output result in an array of double precision numbers.\n+     *              The dimension of y[] is:\n+     *                      24-bit  precision       1\n+     *                      53-bit  precision       2\n+     *                      64-bit  precision       2\n+     *                      113-bit precision       3\n+     *              The actual value is the sum of them. Thus for 113-bit\n+     *              precision, one may have to do something like:\n+     *\n+     *              long double t,w,r_head, r_tail;\n+     *              t = (long double)y[2] + (long double)y[1];\n+     *              w = (long double)y[0];\n+     *              r_head = t+w;\n+     *              r_tail = w - (r_head - t);\n+     *\n+     *      e0      The exponent of x[0]\n+     *\n+     *      nx      dimension of x[]\n+     *\n+     *      prec    an integer indicating the precision:\n+     *                      0       24  bits (single)\n+     *                      1       53  bits (double)\n+     *                      2       64  bits (extended)\n+     *                      3       113 bits (quad)\n+     *\n+     *      ipio2[]\n+     *              integer array, contains the (24*i)-th to (24*i+23)-th\n+     *              bit of 2\/pi after binary point. The corresponding\n+     *              floating value is\n+     *\n+     *                      ipio2[i] * 2^(-24(i+1)).\n+     *\n+     * External function:\n+     *      double scalbn(), floor();\n+     *\n+     *\n+     * Here is the description of some local variables:\n+     *\n+     *      jk      jk+1 is the initial number of terms of ipio2[] needed\n+     *              in the computation. The recommended value is 2,3,4,\n+     *              6 for single, double, extended,and quad.\n+     *\n+     *      jz      local integer variable indicating the number of\n+     *              terms of ipio2[] used.\n+     *\n+     *      jx      nx - 1\n+     *\n+     *      jv      index for pointing to the suitable ipio2[] for the\n+     *              computation. In general, we want\n+     *                      ( 2^e0*x[0] * ipio2[jv-1]*2^(-24jv) )\/8\n+     *              is an integer. Thus\n+     *                      e0-3-24*jv >= 0 or (e0-3)\/24 >= jv\n+     *              Hence jv = max(0,(e0-3)\/24).\n+     *\n+     *      jp      jp+1 is the number of terms in PIo2[] needed, jp = jk.\n+     *\n+     *      q[]     double array with integral value, representing the\n+     *              24-bits chunk of the product of x and 2\/pi.\n+     *\n+     *      q0      the corresponding exponent of q[0]. Note that the\n+     *              exponent for q[i] would be q0-24*i.\n+     *\n+     *      PIo2[]  double precision array, obtained by cutting pi\/2\n+     *              into 24 bits chunks.\n+     *\n+     *      f[]     ipio2[] in floating point\n+     *\n+     *      iq[]    integer array by breaking up q[] in 24-bits chunk.\n+     *\n+     *      fq[]    final product of x*(2\/pi) in fq[0],..,fq[jk]\n+     *\n+     *      ih      integer. If >0 it indicates q[] is >= 0.5, hence\n+     *              it also indicates the *sign* of the result.\n+     *\n+     *\/\n+    static class KernelRemPio2 {\n+        \/*\n+         * Constants:\n+         * The hexadecimal values are the intended ones for the following\n+         * constants. The decimal values may be used, provided that the\n+         * compiler will convert from decimal to binary accurately enough\n+         * to produce the hexadecimal values shown.\n+         *\/\n+\n+        private static final int[] init_jk = {2,3,4,6}; \/* initial value for jk *\/\n+\n+        private static final double[] PIo2 = {\n+            1.57079625129699707031e+00, \/* 0x3FF921FB, 0x40000000 *\/\n+            7.54978941586159635335e-08, \/* 0x3E74442D, 0x00000000 *\/\n+            5.39030252995776476554e-15, \/* 0x3CF84698, 0x80000000 *\/\n+            3.28200341580791294123e-22, \/* 0x3B78CC51, 0x60000000 *\/\n+            1.27065575308067607349e-29, \/* 0x39F01B83, 0x80000000 *\/\n+            1.22933308981111328932e-36, \/* 0x387A2520, 0x40000000 *\/\n+            2.73370053816464559624e-44, \/* 0x36E38222, 0x80000000 *\/\n+            2.16741683877804819444e-51, \/* 0x3569F31D, 0x00000000 *\/\n+        };\n+        static final double\n+            zero   = 0.0,\n+            one    = 1.0,\n+            two24   =  1.67772160000000000000e+07, \/* 0x41700000, 0x00000000 *\/\n+            twon24  =  5.96046447753906250000e-08; \/* 0x3E700000, 0x00000000 *\/\n+\n+        static int __kernel_rem_pio2(double[] x, double[] y, int e0, int nx, int prec, final int[] ipio2) {\n+            int jz,jx,jv,jp,jk,carry,n,i,j,k,m,q0,ih;\n+            int[] iq = new int[20];\n+            double z,fw;\n+            double [] f = new double[20];\n+            double [] fq= new double[20];\n+            double [] q = new double[20];\n+\n+            \/* initialize jk*\/\n+            jk = init_jk[prec];\n+            jp = jk;\n+\n+            \/* determine jx,jv,q0, note that 3>q0 *\/\n+            jx =  nx-1;\n+            jv = (e0-3)\/24; if(jv<0) jv=0;\n+            q0 =  e0-24*(jv+1);\n+\n+            \/* set up f[0] to f[jx+jk] where f[jx+jk] = ipio2[jv+jk] *\/\n+            j = jv-jx; m = jx+jk;\n+            for(i=0;i<=m;i++,j++) f[i] = (j<0)? zero : (double) ipio2[j];\n+\n+            \/* compute q[0],q[1],...q[jk] *\/\n+            for (i=0;i<=jk;i++) {\n+                for(j=0,fw=0.0;j<=jx;j++) fw += x[j]*f[jx+i-j];\n+                q[i] = fw;\n+            }\n+\n+            jz = jk;\n+            while(true) {\n+                \/* distill q[] into iq[] reversingly *\/\n+                for(i=0,j=jz,z=q[jz];j>0;i++,j--) {\n+                    fw    =  (double)((int)(twon24* z));\n+                    iq[i] =  (int)(z-two24*fw);\n+                    z     =  q[j-1]+fw;\n+                }\n+\n+                \/* compute n *\/\n+                z  = Math.scalb(z,q0);              \/* actual value of z *\/\n+                z -= 8.0*Math.floor(z*0.125);           \/* trim off integer >= 8 *\/\n+                n  = (int) z;\n+                z -= (double)n;\n+                ih = 0;\n+                if(q0>0) {      \/* need iq[jz-1] to determine n *\/\n+                    i  = (iq[jz-1]>>(24-q0)); n += i;\n+                    iq[jz-1] -= i<<(24-q0);\n+                    ih = iq[jz-1]>>(23-q0);\n+                }\n+                else if(q0==0) ih = iq[jz-1]>>23;\n+                else if(z>=0.5) ih=2;\n+\n+                if(ih>0) {      \/* q > 0.5 *\/\n+                    n += 1; carry = 0;\n+                    for(i=0;i<jz ;i++) {        \/* compute 1-q *\/\n+                        j = iq[i];\n+                        if(carry==0) {\n+                            if(j!=0) {\n+                                carry = 1; iq[i] = 0x1000000- j;\n+                            }\n+                        } else  iq[i] = 0xffffff - j;\n+                    }\n+                    if(q0>0) {          \/* rare case: chance is 1 in 12 *\/\n+                        switch(q0) {\n+                        case 1:\n+                            iq[jz-1] &= 0x7fffff; break;\n+                        case 2:\n+                            iq[jz-1] &= 0x3fffff; break;\n+                        }\n+                    }\n+                    if(ih==2) {\n+                        z = one - z;\n+                        if(carry!=0) z -= Math.scalb(one,q0);\n+                    }\n+                }\n+\n+                \/* check if recomputation is needed *\/\n+                if(z==zero) {\n+                    j = 0;\n+                    for (i=jz-1;i>=jk;i--) j |= iq[i];\n+                    if(j==0) { \/* need recomputation *\/\n+                        for(k=1;iq[jk-k]==0;k++);   \/* k = no. of terms needed *\/\n+\n+                        for(i=jz+1;i<=jz+k;i++) {   \/* add q[jz+1] to q[jz+k] *\/\n+                            f[jx+i] = (double) ipio2[jv+i];\n+                            for(j=0,fw=0.0;j<=jx;j++) fw += x[j]*f[jx+i-j];\n+                            q[i] = fw;\n+                        }\n+                        jz += k;\n+                        continue;\n+                    } else { break;}\n+                } else {break;}\n+            }\n+\n+            \/* chop off zero terms *\/\n+            if(z==0.0) {\n+                jz -= 1; q0 -= 24;\n+                while(iq[jz]==0) { jz--; q0-=24;}\n+            } else { \/* break z into 24-bit if necessary *\/\n+                z = Math.scalb(z,-q0);\n+                if(z>=two24) {\n+                    fw = (double)((int)(twon24*z));\n+                    iq[jz] = (int)(z-two24*fw);\n+                    jz += 1; q0 += 24;\n+                    iq[jz] = (int) fw;\n+                } else iq[jz] = (int) z ;\n+            }\n+\n+            \/* convert integer \"bit\" chunk to floating-point value *\/\n+            fw = Math.scalb(one,q0);\n+            for(i=jz;i>=0;i--) {\n+                q[i] = fw*(double)iq[i]; fw*=twon24;\n+            }\n+\n+            \/* compute PIo2[0,...,jp]*q[jz,...,0] *\/\n+            for(i=jz;i>=0;i--) {\n+                for(fw=0.0,k=0;k<=jp&&k<=jz-i;k++) fw += PIo2[k]*q[i+k];\n+                fq[jz-i] = fw;\n+            }\n+\n+            \/* compress fq[] into y[] *\/\n+            switch(prec) {\n+            case 0:\n+                fw = 0.0;\n+                for (i=jz;i>=0;i--) fw += fq[i];\n+                y[0] = (ih==0)? fw: -fw;\n+                break;\n+            case 1:\n+            case 2:\n+                fw = 0.0;\n+                for (i=jz;i>=0;i--) fw += fq[i];\n+                y[0] = (ih==0)? fw: -fw;\n+                fw = fq[0]-fw;\n+                for (i=1;i<=jz;i++) fw += fq[i];\n+                y[1] = (ih==0)? fw: -fw;\n+                break;\n+            case 3:     \/* painful *\/\n+                for (i=jz;i>0;i--) {\n+                    fw      = fq[i-1]+fq[i];\n+                    fq[i]  += fq[i-1]-fw;\n+                    fq[i-1] = fw;\n+                }\n+                for (i=jz;i>1;i--) {\n+                    fw      = fq[i-1]+fq[i];\n+                    fq[i]  += fq[i-1]-fw;\n+                    fq[i-1] = fw;\n+                }\n+                for (fw=0.0,i=jz;i>=2;i--) fw += fq[i];\n+                if(ih==0) {\n+                    y[0] =  fq[0]; y[1] =  fq[1]; y[2] =  fw;\n+                } else {\n+                    y[0] = -fq[0]; y[1] = -fq[1]; y[2] = -fw;\n+                }\n+            }\n+            return n&7;\n+        }\n+    }\n","filename":"test\/jdk\/java\/lang\/StrictMath\/FdlibmTranslit.java","additions":861,"deletions":0,"binary":false,"changes":861,"status":"modified"}]}