{"files":[{"patch":"@@ -0,0 +1,231 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import jdk.test.lib.RandomFactory;\n+import java.util.function.DoubleUnaryOperator;\n+\n+\/*\n+ * @test\n+ * @bug 8302027\n+ * @key randomness\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @build Tests\n+ * @build FdlibmTranslit\n+ * @build TrigTests\n+ * @run main TrigTests\n+ * @summary Tests for StrictMath.{sin, cos, tan}\n+ *\/\n+\n+\/**\n+ * The tests in ..\/Math\/{TanTests.java, SinCosTests.java} test\n+ * properties that should hold for any implementation of the trig\n+ * functions sin, cos, and tan, including the FDLIBM-based ones\n+ * required by the StrictMath class.  Therefore, the test cases in\n+ * ..\/Math\/{TanTests.java, SinCosTests.java} are run against both the\n+ * Math and StrictMath versions of the trig methods.  The role of this\n+ * test is to verify that the FDLIBM algorithms are being used by\n+ * running golden file tests on values that may vary from one\n+ * conforming implementation of the trig functions to another.\n+ *\/\n+\n+public class TrigTests {\n+    private TrigTests(){}\n+\n+    public static void main(String... args) {\n+        int failures = 0;\n+\n+        failures += testAgainstTranslitCommon();\n+\n+        failures += testAgainstTranslitSin();\n+        failures += testAgainstTranslitCos();\n+        failures += testAgainstTranslitTan();\n+\n+        if (failures > 0) {\n+            System.err.println(\"Testing the trig functions incurred \"\n+                               + failures + \" failures.\");\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    \/**\n+     * Bundle together groups of testing methods.\n+     *\/\n+    private static enum TrigTest {\n+        SIN(TrigTests::testSinCase, FdlibmTranslit::sin),\n+        COS(TrigTests::testCosCase, FdlibmTranslit::cos),\n+        TAN(TrigTests::testTanCase, FdlibmTranslit::tan);\n+\n+        private DoubleDoubleToInt testCase;\n+        private DoubleUnaryOperator transliteration;\n+\n+        TrigTest(DoubleDoubleToInt testCase, DoubleUnaryOperator transliteration) {\n+            this.testCase = testCase;\n+            this.transliteration = transliteration;\n+        }\n+\n+        public DoubleDoubleToInt testCase() {return testCase;}\n+        public DoubleUnaryOperator transliteration() {return transliteration;}\n+    }\n+\n+    \/\/ Initialize shared random number generator\n+    private static java.util.Random random = RandomFactory.getRandom();\n+\n+    \/**\n+     * Test against shared points of interest.\n+     *\/\n+    private static int testAgainstTranslitCommon() {\n+        int failures = 0;\n+        double[] pointsOfInterest = {\n+             Math.PI\/4.0,\n+            -Math.PI\/4.0,\n+\n+             Math.PI\/2.0,\n+            -Math.PI\/2.0,\n+\n+             3.0*Math.PI\/2.0,\n+            -3.0*Math.PI\/2.0,\n+\n+             Math.PI,\n+            -Math.PI,\n+\n+             2.0*Math.PI,\n+            -2.0*Math.PI,\n+\n+             Double.MIN_NORMAL,\n+             1.0,\n+             Tests.createRandomDouble(random),\n+        };\n+\n+        for (var testMethods : TrigTest.values()) {\n+            for (double testPoint : pointsOfInterest) {\n+                failures += testRangeMidpoint(testPoint, Math.ulp(testPoint), 1000, testMethods);\n+            }\n+        }\n+\n+        return failures;\n+    }\n+\n+    \/**\n+     * Test StrictMath.sin against transliteration port of sin.\n+     *\/\n+    private static int testAgainstTranslitSin() {\n+        int failures = 0;\n+\n+        \/\/ Probe near decision points in the FDLIBM algorithm.\n+        double[] decisionPoints = {\n+             0x1.0p-27,\n+            -0x1.0p-27,\n+        };\n+\n+        for (double testPoint : decisionPoints) {\n+            failures += testRangeMidpoint(testPoint, Math.ulp(testPoint), 1000, TrigTest.SIN);\n+        }\n+\n+        return failures;\n+    }\n+\n+    \/**\n+     * Test StrictMath.cos against transliteration port of cos.\n+     *\/\n+    private static int testAgainstTranslitCos() {\n+        int failures = 0;\n+\n+        \/\/ Probe near decision points in the FDLIBM algorithm.\n+        double[] decisionPoints = {\n+             0x1.0p27,\n+            -0x1.0p27,\n+\n+             0.78125,\n+            -0.78125,\n+        };\n+\n+        for (double testPoint : decisionPoints) {\n+            failures += testRangeMidpoint(testPoint, Math.ulp(testPoint), 1000, TrigTest.COS);\n+        }\n+\n+        return failures;\n+    }\n+\n+    \/**\n+     * Test StrictMath.tan against transliteration port of tan\n+     *\/\n+    private static int testAgainstTranslitTan() {\n+        int failures = 0;\n+\n+        \/\/ Probe near decision points in the FDLIBM algorithm.\n+        double[] decisionPoints = {\n+             0x1.0p-28,\n+            -0x1.0p-28,\n+\n+             0.6744,\n+            -0.6744,\n+        };\n+\n+        for (double testPoint : decisionPoints) {\n+            failures += testRangeMidpoint(testPoint, Math.ulp(testPoint), 1000,  TrigTest.TAN);\n+        }\n+\n+        return failures;\n+    }\n+\n+    private interface DoubleDoubleToInt {\n+        int apply(double x, double y);\n+    }\n+\n+    private static int testRange(double start, double increment, int count,\n+                             TrigTest testMethods) {\n+        int failures = 0;\n+        double x = start;\n+        for (int i = 0; i < count; i++, x += increment) {\n+            failures +=\n+                testMethods.testCase().apply(x, testMethods.transliteration().applyAsDouble(x));\n+        }\n+        return failures;\n+    }\n+\n+    private static int testRangeMidpoint(double midpoint, double increment, int count,\n+                                         TrigTest testMethods) {\n+        int failures = 0;\n+        double x = midpoint - increment*(count \/ 2) ;\n+        for (int i = 0; i < count; i++, x += increment) {\n+            failures +=\n+                testMethods.testCase().apply(x, testMethods.transliteration().applyAsDouble(x));\n+        }\n+        return failures;\n+    }\n+\n+    private static int testSinCase(double input, double expected) {\n+        return Tests.test(\"StrictMath.sin(double)\", input,\n+                          StrictMath::sin, expected);\n+    }\n+\n+    private static int testCosCase(double input, double expected) {\n+        return Tests.test(\"StrictMath.cos(double)\", input,\n+                          StrictMath::cos, expected);\n+    }\n+\n+    private static int testTanCase(double input, double expected) {\n+        return Tests.test(\"StrictMath.tan(double)\", input,\n+                          StrictMath::tan, expected);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/StrictMath\/TrigTests.java","additions":231,"deletions":0,"binary":false,"changes":231,"status":"added"}]}