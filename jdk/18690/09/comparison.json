{"files":[{"patch":"@@ -31,2 +31,0 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n@@ -37,0 +35,7 @@\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.TypeKind;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n@@ -38,0 +43,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -40,0 +46,1 @@\n+import java.util.function.Consumer;\n@@ -43,1 +50,0 @@\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n@@ -367,1 +373,1 @@\n-            if (concatType.parameterCount() < HIGH_ARITY_THRESHOLD) {\n+            if (concatType.parameterCount() <= HIGH_ARITY_THRESHOLD) {\n@@ -1057,1 +1063,0 @@\n-        static final int CLASSFILE_VERSION = 52; \/\/ JDK 8\n@@ -1059,2 +1064,1 @@\n-        \/\/ ClassFileDumper replaced java.lang.invoke.ProxyClassDumper in JDK 21\n-        \/\/ -- see JDK-8304846\n+        static final ClassDesc STRING_BUILDER = ClassDesc.ofDescriptor(\"Ljava\/lang\/StringBuilder;\");\n@@ -1063,0 +1067,10 @@\n+        static final MethodTypeDesc APPEND_BOOLEAN_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_boolean);\n+        static final MethodTypeDesc APPEND_CHAR_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_char);\n+        static final MethodTypeDesc APPEND_DOUBLE_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_double);\n+        static final MethodTypeDesc APPEND_FLOAT_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_float);\n+        static final MethodTypeDesc APPEND_INT_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_int);\n+        static final MethodTypeDesc APPEND_LONG_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_long);\n+        static final MethodTypeDesc APPEND_OBJECT_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_Object);\n+        static final MethodTypeDesc APPEND_STRING_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_String);\n+        static final MethodTypeDesc INT_CONSTRUCTOR_TYPE = MethodTypeDesc.of(ConstantDescs.CD_void, ConstantDescs.CD_int);\n+        static final MethodTypeDesc TO_STRING_TYPE = MethodTypeDesc.of(ConstantDescs.CD_String);\n@@ -1078,59 +1092,0 @@\n-            ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);\n-\n-            cw.visit(CLASSFILE_VERSION,\n-                    ACC_SUPER + ACC_PUBLIC + ACC_FINAL + ACC_SYNTHETIC,\n-                    className,\n-                    null,\n-                    \"java\/lang\/Object\",\n-                    null\n-            );\n-\n-            MethodVisitor mv = cw.visitMethod(\n-                    ACC_PUBLIC + ACC_STATIC + ACC_FINAL,\n-                    METHOD_NAME,\n-                    args.toMethodDescriptorString(),\n-                    null,\n-                    null);\n-\n-            mv.visitCode();\n-\n-\n-            \/\/ Prepare StringBuilder instance\n-            mv.visitTypeInsn(NEW, \"java\/lang\/StringBuilder\");\n-            mv.visitInsn(DUP);\n-\n-            int len = 0;\n-            for (String constant : constants) {\n-                if (constant != null) {\n-                    len += constant.length();\n-                }\n-            }\n-            len += args.parameterCount() * ARGUMENT_SIZE_FACTOR;\n-            iconst(mv, len);\n-            mv.visitMethodInsn(\n-                    INVOKESPECIAL,\n-                    \"java\/lang\/StringBuilder\",\n-                    \"<init>\",\n-                    \"(I)V\",\n-                    false\n-            );\n-\n-            \/\/ At this point, we have a blank StringBuilder on stack, fill it in with .append calls.\n-            {\n-                int off = 0;\n-                for (int c = 0; c < args.parameterCount(); c++) {\n-                    if (constants[c] != null) {\n-                        mv.visitLdcInsn(constants[c]);\n-                        sbAppend(mv, \"(Ljava\/lang\/String;)Ljava\/lang\/StringBuilder;\");\n-                    }\n-                    Class<?> cl = args.parameterType(c);\n-                    mv.visitVarInsn(getLoadOpcode(cl), off);\n-                    off += getParameterSize(cl);\n-                    String desc = getSBAppendDesc(cl);\n-                    sbAppend(mv, desc);\n-                }\n-                if (constants[constants.length - 1] != null) {\n-                    mv.visitLdcInsn(constants[constants.length - 1]);\n-                    sbAppend(mv, \"(Ljava\/lang\/String;)Ljava\/lang\/StringBuilder;\");\n-                }\n-            }\n@@ -1138,15 +1093,10 @@\n-            mv.visitMethodInsn(\n-                    INVOKEVIRTUAL,\n-                    \"java\/lang\/StringBuilder\",\n-                    \"toString\",\n-                    \"()Ljava\/lang\/String;\",\n-                    false\n-            );\n-\n-            mv.visitInsn(ARETURN);\n-\n-            mv.visitMaxs(-1, -1);\n-            mv.visitEnd();\n-            cw.visitEnd();\n-\n-            byte[] classBytes = cw.toByteArray();\n+            byte[] classBytes = ClassFile.of().build(ClassDesc.of(className),\n+                    new Consumer<ClassBuilder>() {\n+                        @Override\n+                        public void accept(ClassBuilder clb) {\n+                            clb.withFlags(AccessFlag.FINAL, AccessFlag.SUPER, AccessFlag.SYNTHETIC)\n+                                .withMethodBody(METHOD_NAME,\n+                                        MethodTypeDesc.ofDescriptor(args.toMethodDescriptorString()),\n+                                        ClassFile.ACC_FINAL | ClassFile.ACC_PRIVATE | ClassFile.ACC_STATIC,\n+                                        generateMethod(constants, args));\n+                    }});\n@@ -1163,8 +1113,42 @@\n-        private static void sbAppend(MethodVisitor mv, String desc) {\n-            mv.visitMethodInsn(\n-                    INVOKEVIRTUAL,\n-                    \"java\/lang\/StringBuilder\",\n-                    \"append\",\n-                    desc,\n-                    false\n-            );\n+        private static Consumer<CodeBuilder> generateMethod(String[] constants, MethodType args) {\n+            return new Consumer<CodeBuilder>() {\n+                @Override\n+                public void accept(CodeBuilder cb) {\n+                    cb.new_(STRING_BUILDER);\n+                    cb.dup();\n+\n+                    int len = 0;\n+                    for (String constant : constants) {\n+                        if (constant != null) {\n+                            len += constant.length();\n+                        }\n+                    }\n+                    len += args.parameterCount() * ARGUMENT_SIZE_FACTOR;\n+                    cb.constantInstruction(len);\n+                    cb.invokespecial(STRING_BUILDER, \"<init>\", INT_CONSTRUCTOR_TYPE);\n+\n+                    \/\/ At this point, we have a blank StringBuilder on stack, fill it in with .append calls.\n+                    {\n+                        int off = 0;\n+                        for (int c = 0; c < args.parameterCount(); c++) {\n+                            if (constants[c] != null) {\n+                                cb.ldc(constants[c]);\n+                                cb.invokevirtual(STRING_BUILDER, \"append\", APPEND_STRING_TYPE);\n+                            }\n+                            Class<?> cl = args.parameterType(c);\n+                            TypeKind kind = TypeKind.from(cl);\n+                            cb.loadInstruction(kind, off);\n+                            off += kind.slotSize();\n+                            MethodTypeDesc desc = getSBAppendDesc(cl);\n+                            cb.invokevirtual(STRING_BUILDER, \"append\", desc);\n+                        }\n+                        if (constants[constants.length - 1] != null) {\n+                            cb.ldc(constants[constants.length - 1]);\n+                            cb.invokevirtual(STRING_BUILDER, \"append\", APPEND_STRING_TYPE);\n+                        }\n+                    }\n+\n+                    cb.invokevirtual(STRING_BUILDER, \"toString\", TO_STRING_TYPE);\n+                    cb.areturn();\n+                }\n+            };\n@@ -1181,1 +1165,1 @@\n-            return name.replace('.', '\/') + \"$$StringConcat\";\n+            return name + \"$$StringConcat\";\n@@ -1184,1 +1168,1 @@\n-        private static String getSBAppendDesc(Class<?> cl) {\n+        private static MethodTypeDesc getSBAppendDesc(Class<?> cl) {\n@@ -1187,1 +1171,1 @@\n-                    return \"(I)Ljava\/lang\/StringBuilder;\";\n+                    return APPEND_INT_TYPE;\n@@ -1189,1 +1173,1 @@\n-                    return \"(Z)Ljava\/lang\/StringBuilder;\";\n+                    return APPEND_BOOLEAN_TYPE;\n@@ -1191,1 +1175,1 @@\n-                    return \"(C)Ljava\/lang\/StringBuilder;\";\n+                    return APPEND_CHAR_TYPE;\n@@ -1193,1 +1177,1 @@\n-                    return \"(D)Ljava\/lang\/StringBuilder;\";\n+                    return APPEND_DOUBLE_TYPE;\n@@ -1195,1 +1179,1 @@\n-                    return \"(F)Ljava\/lang\/StringBuilder;\";\n+                    return APPEND_FLOAT_TYPE;\n@@ -1197,1 +1181,1 @@\n-                    return \"(J)Ljava\/lang\/StringBuilder;\";\n+                    return APPEND_LONG_TYPE;\n@@ -1202,43 +1186,1 @@\n-                return \"(Ljava\/lang\/String;)Ljava\/lang\/StringBuilder;\";\n-            } else {\n-                return \"(Ljava\/lang\/Object;)Ljava\/lang\/StringBuilder;\";\n-            }\n-        }\n-\n-        private static String getStringValueOfDesc(Class<?> cl) {\n-            if (cl.isPrimitive()) {\n-                if (cl == Integer.TYPE || cl == Byte.TYPE || cl == Short.TYPE) {\n-                    return \"(I)Ljava\/lang\/String;\";\n-                } else if (cl == Boolean.TYPE) {\n-                    return \"(Z)Ljava\/lang\/String;\";\n-                } else if (cl == Character.TYPE) {\n-                    return \"(C)Ljava\/lang\/String;\";\n-                } else if (cl == Double.TYPE) {\n-                    return \"(D)Ljava\/lang\/String;\";\n-                } else if (cl == Float.TYPE) {\n-                    return \"(F)Ljava\/lang\/String;\";\n-                } else if (cl == Long.TYPE) {\n-                    return \"(J)Ljava\/lang\/String;\";\n-                } else {\n-                    throw new IllegalStateException(\"Unhandled String.valueOf: \" + cl);\n-                }\n-            } else if (cl == String.class) {\n-                return \"(Ljava\/lang\/String;)Ljava\/lang\/String;\";\n-            } else {\n-                return \"(Ljava\/lang\/Object;)Ljava\/lang\/String;\";\n-            }\n-        }\n-\n-        \/**\n-         * The following method is copied from\n-         * org.objectweb.asm.commons.InstructionAdapter. Part of ASM: a very small\n-         * and fast Java bytecode manipulation framework.\n-         * Copyright (c) 2000-2005 INRIA, France Telecom All rights reserved.\n-         *\/\n-        private static void iconst(MethodVisitor mv, final int cst) {\n-            if (cst >= -1 && cst <= 5) {\n-                mv.visitInsn(ICONST_0 + cst);\n-            } else if (cst >= Byte.MIN_VALUE && cst <= Byte.MAX_VALUE) {\n-                mv.visitIntInsn(BIPUSH, cst);\n-            } else if (cst >= Short.MIN_VALUE && cst <= Short.MAX_VALUE) {\n-                mv.visitIntInsn(SIPUSH, cst);\n+                return APPEND_STRING_TYPE;\n@@ -1246,31 +1188,1 @@\n-                mv.visitLdcInsn(cst);\n-            }\n-        }\n-\n-        private static int getLoadOpcode(Class<?> c) {\n-            if (c == Void.TYPE) {\n-                throw new InternalError(\"Unexpected void type of load opcode\");\n-            }\n-            return ILOAD + getOpcodeOffset(c);\n-        }\n-\n-        private static int getOpcodeOffset(Class<?> c) {\n-            if (c.isPrimitive()) {\n-                if (c == Long.TYPE) {\n-                    return 1;\n-                } else if (c == Float.TYPE) {\n-                    return 2;\n-                } else if (c == Double.TYPE) {\n-                    return 3;\n-                }\n-                return 0;\n-            } else {\n-                return 4;\n-            }\n-        }\n-\n-        private static int getParameterSize(Class<?> c) {\n-            if (c == Void.TYPE) {\n-                return 0;\n-            } else if (c == Long.TYPE || c == Double.TYPE) {\n-                return 2;\n+                return APPEND_OBJECT_TYPE;\n@@ -1278,1 +1190,0 @@\n-            return 1;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":83,"deletions":172,"binary":false,"changes":255,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -195,0 +195,27 @@\n+\n+    @Benchmark\n+    public String concat23StringConst() {\n+        return f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + \"\"\"\n+                A really long constant string. Such as a copyright header:\n+                 * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+                 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+                 *\n+                 * This code is free software; you can redistribute it and\/or modify it\n+                 * under the terms of the GNU General Public License version 2 only, as\n+                 * published by the Free Software Foundation.\n+                 *\n+                 * This code is distributed in the hope that it will be useful, but WITHOUT\n+                 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+                 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+                 * version 2 for more details (a copy is included in the LICENSE file that\n+                 * accompanied this code).\n+                 *\n+                 * You should have received a copy of the GNU General Public License version\n+                 * 2 along with this work; if not, write to the Free Software Foundation,\n+                 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+                 *\n+                 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+                 * or visit www.oracle.com if you need additional information or have any\n+                 * questions.\n+                \"\"\";\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringConcat.java","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"}]}