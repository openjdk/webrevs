{"files":[{"patch":"@@ -31,0 +31,2 @@\n+import jdk.internal.misc.VM;\n+import jdk.internal.util.ClassFileDumper;\n@@ -35,0 +37,6 @@\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.TypeKind;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -36,0 +44,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -40,0 +49,1 @@\n+import java.util.function.Consumer;\n@@ -41,0 +51,1 @@\n+import static java.lang.invoke.MethodHandles.Lookup.ClassOption.STRONG;\n@@ -102,0 +113,7 @@\n+    private static final int HIGH_ARITY_THRESHOLD;\n+\n+    static {\n+        String highArity = VM.getSavedProperty(\"java.lang.invoke.StringConcat.highArityThreshold\");\n+        HIGH_ARITY_THRESHOLD = Integer.parseInt(highArity != null ? highArity : \"20\");\n+    }\n+\n@@ -364,3 +382,8 @@\n-            return new ConstantCallSite(\n-                    generateMHInlineCopy(concatType, constantStrings)\n-                            .viewAsType(concatType, true));\n+            if (concatType.parameterCount() <= HIGH_ARITY_THRESHOLD) {\n+                return new ConstantCallSite(\n+                        generateMHInlineCopy(concatType, constantStrings)\n+                                .viewAsType(concatType, true));\n+            } else {\n+                return new ConstantCallSite(\n+                        SimpleStringBuilderStrategy.generate(lookup, concatType, constantStrings));\n+            }\n@@ -1349,0 +1372,140 @@\n+\n+    \/**\n+     * Bytecode StringBuilder strategy.\n+     *\n+     * <p>This strategy emits StringBuilder chains as similar as possible\n+     * to what javac would. No exact sizing of parameters or estimates.\n+     *\/\n+    private static final class SimpleStringBuilderStrategy {\n+        static final String METHOD_NAME = \"concat\";\n+        static final ClassDesc STRING_BUILDER = ClassDesc.of(\"java.lang.StringBuilder\");\n+        static final ClassFileDumper DUMPER;\n+        static final MethodTypeDesc APPEND_BOOLEAN_TYPE = MethodTypeDesc.ofDescriptor(\"(Z)Ljava\/lang\/StringBuilder;\");\n+        static final MethodTypeDesc APPEND_CHAR_TYPE = MethodTypeDesc.ofDescriptor(\"(C)Ljava\/lang\/StringBuilder;\");\n+        static final MethodTypeDesc APPEND_DOUBLE_TYPE = MethodTypeDesc.ofDescriptor(\"(D)Ljava\/lang\/StringBuilder;\");\n+        static final MethodTypeDesc APPEND_FLOAT_TYPE = MethodTypeDesc.ofDescriptor(\"(F)Ljava\/lang\/StringBuilder;\");\n+        static final MethodTypeDesc APPEND_INT_TYPE = MethodTypeDesc.ofDescriptor(\"(I)Ljava\/lang\/StringBuilder;\");\n+        static final MethodTypeDesc APPEND_LONG_TYPE = MethodTypeDesc.ofDescriptor(\"(J)Ljava\/lang\/StringBuilder;\");\n+        static final MethodTypeDesc APPEND_OBJECT_TYPE = MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/Object;)Ljava\/lang\/StringBuilder;\");\n+        static final MethodTypeDesc APPEND_STRING_TYPE = MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/String;)Ljava\/lang\/StringBuilder;\");\n+        static final MethodTypeDesc INT_VOID_TYPE = MethodTypeDesc.ofDescriptor(\"(I)V\");\n+\n+        \/**\n+         * Ensure a capacity in the initial StringBuilder to accommodate all constants plus this factor times the number\n+         * of arguments.\n+         *\/\n+        static final int ARGUMENT_SIZE_FACTOR = 4;\n+\n+        static {\n+            DUMPER = ClassFileDumper.getInstance(\"java.lang.invoke.StringConcatFactory.dump\", \"stringConcatClasses\");\n+        }\n+\n+        private SimpleStringBuilderStrategy() {\n+            \/\/ no instantiation\n+        }\n+\n+        private static MethodHandle generate(Lookup lookup, MethodType args, String[] constants) throws Exception {\n+            String className = getClassName(lookup.lookupClass());\n+\n+            byte[] classBytes = ClassFile.of().build(ClassDesc.of(className),\n+                    new Consumer<ClassBuilder>() {\n+                        @Override\n+                        public void accept(ClassBuilder clb) {\n+                            clb.withFlags(AccessFlag.FINAL, AccessFlag.SUPER, AccessFlag.SYNTHETIC)\n+                                .withMethodBody(METHOD_NAME,\n+                                        MethodTypeDesc.ofDescriptor(args.toMethodDescriptorString()),\n+                                        ClassFile.ACC_FINAL | ClassFile.ACC_PRIVATE | ClassFile.ACC_STATIC,\n+                                        generateMethod(constants, args));\n+                    }});\n+\n+            try {\n+                Lookup hiddenLookup = lookup.defineHiddenClass(classBytes, true, STRONG);\n+                Class<?> innerClass = hiddenLookup.lookupClass();\n+                DUMPER.dumpClass(className, innerClass, classBytes);\n+                MethodHandle mh = hiddenLookup.findStatic(innerClass, METHOD_NAME, args);\n+                return mh;\n+            } catch (Exception e) {\n+                DUMPER.dumpFailedClass(className, classBytes);\n+                throw new StringConcatException(\"Exception while spinning the class\", e);\n+            }\n+        }\n+\n+        private static Consumer<CodeBuilder> generateMethod(String[] constants, MethodType args) {\n+            return new Consumer<CodeBuilder>() {\n+                @Override\n+                public void accept(CodeBuilder cb) {\n+                    cb.new_(STRING_BUILDER);\n+                    cb.dup();\n+\n+                    int len = 0;\n+                    for (int c = 0; c < constants.length; c++) {\n+                        if (constants[c] != null)\n+                            len += constants[c].length();\n+                    }\n+                    len += args.parameterCount() * ARGUMENT_SIZE_FACTOR;\n+                    cb.constantInstruction(len);\n+                    cb.invokespecial(STRING_BUILDER, \"<init>\", INT_VOID_TYPE);\n+\n+                    \/\/ At this point, we have a blank StringBuilder on stack, fill it in with .append calls.\n+                    {\n+                        int off = 0;\n+                        for (int c = 0; c < args.parameterCount(); c++) {\n+                            if (constants[c] != null) {\n+                                cb.ldc(constants[c]);\n+                                cb.invokevirtual(STRING_BUILDER, \"append\", APPEND_STRING_TYPE);\n+                            }\n+                            Class<?> cl = args.parameterType(c);\n+                            TypeKind kind = TypeKind.from(cl);\n+                            cb.loadInstruction(kind, off);\n+                            off += kind.slotSize();\n+                            MethodTypeDesc desc = getSBAppendDesc(cl);\n+                            cb.invokevirtual(STRING_BUILDER, \"append\", desc);\n+                        }\n+                        if (constants[constants.length - 1] != null) {\n+                            cb.ldc(constants[constants.length - 1]);\n+                            cb.invokevirtual(STRING_BUILDER, \"append\", APPEND_STRING_TYPE);\n+                        }\n+                    }\n+\n+                    cb.invokevirtual(STRING_BUILDER, \"toString\", MethodTypeDesc.ofDescriptor(\"()Ljava\/lang\/String;\"));\n+                    cb.areturn();\n+                }\n+            };\n+        }\n+\n+        \/**\n+         * The generated class is in the same package as the host class as\n+         * it's the implementation of the string concatenation for the host\n+         * class.\n+         *\/\n+        private static String getClassName(Class<?> hostClass) {\n+            String name = hostClass.isHidden() ? hostClass.getName().replace('\/', '_')\n+                    : hostClass.getName();\n+            return name + \"$$StringConcat\";\n+        }\n+\n+        private static MethodTypeDesc getSBAppendDesc(Class<?> cl) {\n+            if (cl.isPrimitive()) {\n+                if (cl == Integer.TYPE || cl == Byte.TYPE || cl == Short.TYPE) {\n+                    return APPEND_INT_TYPE;\n+                } else if (cl == Boolean.TYPE) {\n+                    return APPEND_BOOLEAN_TYPE;\n+                } else if (cl == Character.TYPE) {\n+                    return APPEND_CHAR_TYPE;\n+                } else if (cl == Double.TYPE) {\n+                    return APPEND_DOUBLE_TYPE;\n+                } else if (cl == Float.TYPE) {\n+                    return APPEND_FLOAT_TYPE;\n+                } else if (cl == Long.TYPE) {\n+                    return APPEND_LONG_TYPE;\n+                } else {\n+                    throw new IllegalStateException(\"Unhandled primitive StringBuilder.append: \" + cl);\n+                }\n+            } else if (cl == String.class) {\n+                return APPEND_STRING_TYPE;\n+            } else {\n+                return APPEND_OBJECT_TYPE;\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":166,"deletions":3,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -152,0 +152,70 @@\n+    private String\n+            f0=\"1\", f1=\"1\", f2=\"1\", f3=\"1\", f4=\"1\", f5=\"1\", f6=\"1\", f7=\"1\", f8=\"1\", f9=\"1\",\n+            f10=\"1\", f11=\"1\", f12=\"1\", f13=\"1\", f14=\"1\", f15=\"1\", f16=\"1\", f17=\"1\", f18=\"1\", f19=\"1\",\n+            f20=\"1\", f21=\"1\", f22=\"1\", f23=\"1\", f24=\"1\", f25=\"1\", f26=\"1\", f27=\"1\", f28=\"1\", f29=\"1\",\n+            f30=\"1\", f31=\"1\", f32=\"1\", f33=\"1\", f34=\"1\", f35=\"1\", f36=\"1\", f37=\"1\", f38=\"1\", f39=\"1\",\n+            f40=\"1\", f41=\"1\", f42=\"1\", f43=\"1\", f44=\"1\", f45=\"1\", f46=\"1\", f47=\"1\", f48=\"1\", f49=\"1\",\n+            f50=\"1\", f51=\"1\", f52=\"1\", f53=\"1\", f54=\"1\", f55=\"1\", f56=\"1\", f57=\"1\", f58=\"1\", f59=\"1\",\n+            f60=\"1\", f61=\"1\", f62=\"1\", f63=\"1\", f64=\"1\", f65=\"1\", f66=\"1\", f67=\"1\", f68=\"1\", f69=\"1\",\n+            f70=\"1\", f71=\"1\", f72=\"1\", f73=\"1\", f74=\"1\", f75=\"1\", f76=\"1\", f77=\"1\", f78=\"1\", f79=\"1\",\n+            f80=\"1\", f81=\"1\", f82=\"1\", f83=\"1\", f84=\"1\", f85=\"1\", f86=\"1\", f87=\"1\", f88=\"1\", f89=\"1\",\n+            f90=\"1\", f91=\"1\", f92=\"1\", f93=\"1\", f94=\"1\", f95=\"1\", f96=\"1\", f97=\"1\", f98=\"1\", f99=\"1\",\n+            f100=\"1\",f101=\"1\",f102=\"1\",f103=\"1\",f104=\"1\",f105=\"1\",f106=\"1\",f107=\"1\",f108=\"1\",f109=\"1\",\n+            f110=\"1\",f111=\"1\",f112=\"1\",f113=\"1\",f114=\"1\",f115=\"1\",f116=\"1\",f117=\"1\",f118=\"1\",f119=\"1\",\n+            f120=\"1\",f121=\"1\",f122=\"1\";\n+\n+    @Benchmark\n+    public String concat13String() {\n+        return f0 + \",\"+ f1 + \",\"+ f2 + \",\"+ f3 + \",\"+ f4 + \",\"+ f5 + \",\"+ f6 + \",\"+ f7 + \",\"+ f8 + \",\"+ f9 + \",\"\n+                + f10 + \",\"+ f11 + \",\"+ f12;\n+    }\n+\n+    @Benchmark\n+    public String concat23String() {\n+        return f0 + \",\"+ f1 + \",\"+ f2 + \",\"+ f3 + \",\"+ f4 + \",\"+ f5 + \",\"+ f6 + \",\"+ f7 + \",\"+ f8 + \",\"+ f9 + \",\"\n+                + f10 + \",\"+ f11 + \",\"+ f12 + \",\"+ f13 + \",\"+ f14 + \",\"+ f15 + \",\"+ f16 + \",\"+ f17 + \",\"+ f18 + \",\"+ f19 + \",\"\n+                + f20 + \",\"+ f21 + \",\"+ f22;\n+    }\n+    @Benchmark\n+    public String concat123String() {\n+        return f0 + \",\"+ f1 + \",\"+ f2 + \",\"+ f3 + \",\"+ f4 + \",\"+ f5 + \",\"+ f6 + \",\"+ f7 + \",\"+ f8 + \",\"+ f9 + \",\"\n+                + f10 + \",\"+ f11 + \",\"+ f12 + \",\"+ f13 + \",\"+ f14 + \",\"+ f15 + \",\"+ f16 + \",\"+ f17 + \",\"+ f18 + \",\"+ f19 + \",\"\n+                + f20 + \",\"+ f21 + \",\"+ f22 + \",\"+ f23 + \",\"+ f24 + \",\"+ f25 + \",\"+ f26 + \",\"+ f27 + \",\"+ f28 + \",\"+ f29 + \",\"\n+                + f30 + \",\"+ f31 + \",\"+ f32 + \",\"+ f33 + \",\"+ f34 + \",\"+ f35 + \",\"+ f36 + \",\"+ f37 + \",\"+ f38 + \",\"+ f39 + \",\"\n+                + f40 + \",\"+ f41 + \",\"+ f42 + \",\"+ f43 + \",\"+ f44 + \",\"+ f45 + \",\"+ f46 + \",\"+ f47 + \",\"+ f48 + \",\"+ f49 + \",\"\n+                + f50 + \",\"+ f51 + \",\"+ f52 + \",\"+ f53 + \",\"+ f54 + \",\"+ f55 + \",\"+ f56 + \",\"+ f57 + \",\"+ f58 + \",\"+ f59 + \",\"\n+                + f60 + \",\"+ f61 + \",\"+ f62 + \",\"+ f63 + \",\"+ f64 + \",\"+ f65 + \",\"+ f66 + \",\"+ f67 + \",\"+ f68 + \",\"+ f69 + \",\"\n+                + f70 + \",\"+ f71 + \",\"+ f72 + \",\"+ f73 + \",\"+ f74 + \",\"+ f75 + \",\"+ f76 + \",\"+ f77 + \",\"+ f78 + \",\"+ f79 + \",\"\n+                + f80 + \",\"+ f81 + \",\"+ f82 + \",\"+ f83 + \",\"+ f84 + \",\"+ f85 + \",\"+ f86 + \",\"+ f87 + \",\"+ f88 + \",\"+ f89 + \",\"\n+                + f90 + \",\"+ f91 + \",\"+ f92 + \",\"+ f93 + \",\"+ f94 + \",\"+ f95 + \",\"+ f96 + \",\"+ f97 + \",\"+ f98 + \",\"+ f99 + \",\"\n+                +f100 + \",\"+f101 + \",\"+f102 + \",\"+f103 + \",\"+f104 + \",\"+f105 + \",\"+f106 + \",\"+f107 + \",\"+f108 + \",\"+f109 + \",\"\n+                +f110 + \",\"+f111 + \",\"+f112 + \",\"+f113 + \",\"+f114 + \",\"+f115 + \",\"+f116 + \",\"+f117 + \",\"+f118 + \",\"+f119 + \",\"\n+                +f120 + \",\"+f121 + \",\"+f122;\n+    }\n+\n+    @Benchmark\n+    public String concat23StringConst() {\n+        return f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + \"\"\"\n+                A really long constant string. Such as a copyright header:\n+                 * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+                 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+                 *\n+                 * This code is free software; you can redistribute it and\/or modify it\n+                 * under the terms of the GNU General Public License version 2 only, as\n+                 * published by the Free Software Foundation.\n+                 *\n+                 * This code is distributed in the hope that it will be useful, but WITHOUT\n+                 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+                 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+                 * version 2 for more details (a copy is included in the LICENSE file that\n+                 * accompanied this code).\n+                 *\n+                 * You should have received a copy of the GNU General Public License version\n+                 * 2 along with this work; if not, write to the Free Software Foundation,\n+                 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+                 *\n+                 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+                 * or visit www.oracle.com if you need additional information or have any\n+                 * questions.\n+                \"\"\";\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringConcat.java","additions":71,"deletions":1,"binary":false,"changes":72,"status":"modified"}]}