{"files":[{"patch":"@@ -629,0 +629,1 @@\n+#if 0\n@@ -638,0 +639,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1653,0 +1653,12 @@\n+void ObjectMonitor::post_monitor_wait(JavaThread *current, jlong millis) {\n+  if (JvmtiExport::should_post_monitor_wait()) {\n+    JvmtiExport::post_monitor_wait(current, object(), millis);\n+\n+    \/\/ The current thread already owns the monitor and it has not yet\n+    \/\/ been added to the wait queue so the current thread cannot be\n+    \/\/ made the successor. This means that the JVMTI_EVENT_MONITOR_WAIT\n+    \/\/ event handler cannot accidentally consume an unpark() meant for\n+    \/\/ the ParkEvent associated with this ObjectMonitor.\n+  }\n+}\n+\n@@ -1671,0 +1683,1 @@\n+    post_monitor_wait(current, millis);\n@@ -1696,0 +1709,3 @@\n+    if (interruptible) {\n+      post_monitor_wait(current, millis);\n+    }\n@@ -1708,0 +1724,3 @@\n+    if (interruptible) {\n+      post_monitor_wait(current, millis);\n+    }\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -381,0 +381,1 @@\n+  void      post_monitor_wait(JavaThread *current, jlong millis);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}