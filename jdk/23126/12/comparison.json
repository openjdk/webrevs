{"files":[{"patch":"@@ -629,10 +629,0 @@\n-  JavaThreadInObjectWaitState jtiows(thread, ms != 0);\n-  if (JvmtiExport::should_post_monitor_wait()) {\n-    JvmtiExport::post_monitor_wait(thread, obj(), ms);\n-\n-    \/\/ The current thread already owns the monitor and it has not yet\n-    \/\/ been added to the wait queue so the current thread cannot be\n-    \/\/ made the successor. This means that the JVMTI_EVENT_MONITOR_WAIT\n-    \/\/ event handler cannot accidentally consume an unpark() meant for\n-    \/\/ the ParkEvent associated with this ObjectMonitor.\n-  }\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1670,0 +1670,5 @@\n+    JavaThreadInObjectWaitState jtiows(current, millis != 0, interruptible);\n+\n+    if (JvmtiExport::should_post_monitor_wait()) {\n+      JvmtiExport::post_monitor_wait(current, object(), millis);\n+    }\n@@ -1691,2 +1696,0 @@\n-  current->set_current_waiting_monitor(this);\n-\n@@ -1695,1 +1698,6 @@\n-  if (ce != nullptr && ce->is_virtual_thread()) {\n+  bool is_virtual = ce != nullptr && ce->is_virtual_thread();\n+  if (is_virtual) {\n+    if (interruptible && JvmtiExport::should_post_monitor_wait()) {\n+      JvmtiExport::post_monitor_wait(current, object(), millis);\n+    }\n+    current->set_current_waiting_monitor(this);\n@@ -1703,1 +1711,15 @@\n-\n+  \/\/ The jtiows does nothing for non-interruptible.\n+  JavaThreadInObjectWaitState jtiows(current, millis != 0, interruptible);\n+\n+  if (!is_virtual) { \/\/ it was already set for virtual thread\n+    if (interruptible && JvmtiExport::should_post_monitor_wait()) {\n+      JvmtiExport::post_monitor_wait(current, object(), millis);\n+\n+      \/\/ The current thread already owns the monitor and it has not yet\n+      \/\/ been added to the wait queue so the current thread cannot be\n+      \/\/ made the successor. This means that the JVMTI_EVENT_MONITOR_WAIT\n+      \/\/ event handler cannot accidentally consume an unpark() meant for\n+      \/\/ the ParkEvent associated with this ObjectMonitor.\n+    }\n+    current->set_current_waiting_monitor(this);\n+  }\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":26,"deletions":4,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -490,1 +490,9 @@\n-  JavaThreadInObjectWaitState(JavaThread *java_thread, bool timed) :\n+  \/\/ Sets the java.lang.Thread state of the given JavaThread to reflect it is doing a regular,\n+  \/\/ or timed, Object.wait call.\n+  \/\/\n+  \/\/ The interruptible parameter, if false, indicates an internal uninterruptible wait,\n+  \/\/ in which case we do not update the java.lang.Thread state. We do that by passing\n+  \/\/ the current state to the JavaThreadStatusChanger so no actual change is observable,\n+  \/\/ and skip the statistics updates. This avoids having to duplicate code paths for\n+  \/\/ the interruptible and non-interruptible cases in the caller.\n+  JavaThreadInObjectWaitState(JavaThread *java_thread, bool timed, bool interruptible) :\n@@ -492,2 +500,3 @@\n-                            timed ? JavaThreadStatus::IN_OBJECT_WAIT_TIMED : JavaThreadStatus::IN_OBJECT_WAIT) {\n-    if (is_alive()) {\n+                            interruptible ? (timed ? JavaThreadStatus::IN_OBJECT_WAIT_TIMED : JavaThreadStatus::IN_OBJECT_WAIT)\n+                                          : java_lang_Thread::get_thread_status(java_thread->threadObj())) {\n+    if (is_alive() && interruptible) { \/\/ in non-interruptible case we set _active = false below\n","filename":"src\/hotspot\/share\/services\/threadService.hpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"}]}