{"files":[{"patch":"@@ -37,1 +37,0 @@\n-#ifdef _LP64\n@@ -39,1 +38,0 @@\n-#endif\n@@ -47,1 +45,0 @@\n-#ifdef _LP64\n@@ -53,3 +50,0 @@\n-#else\n-#define DEFAULT_PADDING_SIZE DEFAULT_CACHE_LINE_SIZE\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/globalDefinitions_x86.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-#ifdef _LP64\n@@ -66,2 +65,1 @@\n-\/\/ stack if compiled for unix and LP64. To pass stack overflow tests we need\n-\/\/ 20 shadow pages.\n+\/\/ stack if compiled for unix. To pass stack overflow tests we need 20 shadow pages.\n@@ -72,4 +70,0 @@\n-#else\n-#define DEFAULT_STACK_SHADOW_PAGES (4 DEBUG_ONLY(+5))\n-#define MIN_STACK_SHADOW_PAGES DEFAULT_STACK_SHADOW_PAGES\n-#endif \/\/ _LP64\n@@ -82,1 +76,0 @@\n-#ifdef _LP64\n@@ -84,3 +77,0 @@\n-#else\n-define_pd_global(bool, VMContinuations, false);\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -75,2 +75,0 @@\n-#ifdef _LP64\n-\n@@ -90,1 +88,0 @@\n-#endif\n@@ -110,1 +107,0 @@\n-#if defined(_LP64)\n@@ -129,1 +125,0 @@\n-#endif\n@@ -154,1 +149,1 @@\n-    \/\/ LP64: rcx and rdx are first and second argument registers on windows\n+    \/\/ rcx and rdx are first and second argument registers on windows\n@@ -157,1 +152,0 @@\n-#ifdef _LP64\n@@ -159,3 +153,0 @@\n-#else\n-    __ movptr(rbp, Address(rsp, 8)); \/\/ cpuid_info address\n-#endif\n@@ -421,1 +412,0 @@\n-#if defined(_LP64)\n@@ -456,1 +446,0 @@\n-#endif\n@@ -530,1 +519,0 @@\n-#ifdef _LP64\n@@ -533,1 +521,0 @@\n-#endif\n@@ -559,1 +546,0 @@\n-#ifdef _LP64\n@@ -562,1 +548,0 @@\n-#endif\n@@ -603,1 +588,0 @@\n-#ifdef _LP64\n@@ -606,1 +590,0 @@\n-#endif\n@@ -631,1 +614,0 @@\n-#ifdef _LP64\n@@ -634,1 +616,0 @@\n-#endif\n@@ -690,1 +671,0 @@\n-#ifdef _LP64\n@@ -693,4 +673,0 @@\n-#else\n-    __ movptr(rax, Address(rsp, 16)); \/\/ CPUID leaf\n-    __ movptr(rsi, Address(rsp, 20)); \/\/ register array address\n-#endif\n@@ -737,1 +713,1 @@\n-    \/\/ LP64: rcx and rdx are first and second argument registers on windows\n+    \/\/ rcx and rdx are first and second argument registers on windows\n@@ -740,1 +716,0 @@\n-#ifdef _LP64\n@@ -742,3 +717,0 @@\n-#else\n-    __ movptr(rbp, Address(rsp, 8)); \/\/ cpuid_info address\n-#endif\n@@ -892,2 +864,2 @@\n-  LP64_ONLY(_supports_atomic_getset8 = true);\n-  LP64_ONLY(_supports_atomic_getadd8 = true);\n+  _supports_atomic_getset8 = true;\n+  _supports_atomic_getadd8 = true;\n@@ -895,1 +867,0 @@\n-#ifdef _LP64\n@@ -902,1 +873,0 @@\n-#endif\n@@ -904,1 +874,0 @@\n-#ifdef AMD64\n@@ -916,1 +885,0 @@\n-#endif\n@@ -918,1 +886,0 @@\n-#ifdef _LP64\n@@ -927,1 +894,0 @@\n-#endif\n@@ -1209,1 +1175,0 @@\n-#ifdef _LP64\n@@ -1220,6 +1185,0 @@\n-#else\n-  if (UseAdler32Intrinsics) {\n-    warning(\"Adler32Intrinsics not available on this CPU.\");\n-    FLAG_SET_DEFAULT(UseAdler32Intrinsics, false);\n-  }\n-#endif\n@@ -1249,1 +1208,0 @@\n-#ifdef _LP64\n@@ -1265,7 +1223,0 @@\n-#else\n-  \/\/ No support currently for ChaCha20 intrinsics on 32-bit platforms\n-  if (UseChaCha20Intrinsics) {\n-      warning(\"ChaCha20 intrinsics are not available on this CPU.\");\n-      FLAG_SET_DEFAULT(UseChaCha20Intrinsics, false);\n-  }\n-#endif \/\/ _LP64\n@@ -1275,1 +1226,0 @@\n-#ifdef _LP64\n@@ -1280,3 +1230,1 @@\n-  } else\n-#endif\n-   if (UseDilithiumIntrinsics) {\n+  } else if (UseDilithiumIntrinsics) {\n@@ -1311,1 +1259,1 @@\n-  if (supports_sha() LP64_ONLY(|| (supports_avx2() && supports_bmi2()))) {\n+  if (supports_sha() || (supports_avx2() && supports_bmi2())) {\n@@ -1338,2 +1286,0 @@\n-#ifdef _LP64\n-  \/\/ These are only supported on 64-bit\n@@ -1344,3 +1290,1 @@\n-  } else\n-#endif\n-  if (UseSHA512Intrinsics) {\n+  } else if (UseSHA512Intrinsics) {\n@@ -1351,1 +1295,0 @@\n-#ifdef _LP64\n@@ -1356,3 +1299,1 @@\n-  } else\n-#endif\n-   if (UseSHA3Intrinsics) {\n+  } else if (UseSHA3Intrinsics) {\n@@ -1380,1 +1321,0 @@\n-#ifdef _LP64\n@@ -1382,3 +1322,0 @@\n-#else\n-  int min_vector_size = 0;\n-#endif\n@@ -1408,1 +1345,1 @@\n-      int nreg = 2 LP64_ONLY(+2);\n+      int nreg = 4;\n@@ -1421,1 +1358,0 @@\n-#ifdef _LP64\n@@ -1426,3 +1362,1 @@\n-  } else\n-#endif\n-  if (UsePoly1305Intrinsics) {\n+  } else if (UsePoly1305Intrinsics) {\n@@ -1433,1 +1367,0 @@\n-#ifdef _LP64\n@@ -1438,3 +1371,1 @@\n-  } else\n-#endif\n-  if (UseIntPolyIntrinsics) {\n+  } else if (UseIntPolyIntrinsics) {\n@@ -1445,1 +1376,0 @@\n-#ifdef _LP64\n@@ -1461,32 +1391,0 @@\n-#else\n-  if (UseMultiplyToLenIntrinsic) {\n-    if (!FLAG_IS_DEFAULT(UseMultiplyToLenIntrinsic)) {\n-      warning(\"multiplyToLen intrinsic is not available in 32-bit VM\");\n-    }\n-    FLAG_SET_DEFAULT(UseMultiplyToLenIntrinsic, false);\n-  }\n-  if (UseMontgomeryMultiplyIntrinsic) {\n-    if (!FLAG_IS_DEFAULT(UseMontgomeryMultiplyIntrinsic)) {\n-      warning(\"montgomeryMultiply intrinsic is not available in 32-bit VM\");\n-    }\n-    FLAG_SET_DEFAULT(UseMontgomeryMultiplyIntrinsic, false);\n-  }\n-  if (UseMontgomerySquareIntrinsic) {\n-    if (!FLAG_IS_DEFAULT(UseMontgomerySquareIntrinsic)) {\n-      warning(\"montgomerySquare intrinsic is not available in 32-bit VM\");\n-    }\n-    FLAG_SET_DEFAULT(UseMontgomerySquareIntrinsic, false);\n-  }\n-  if (UseSquareToLenIntrinsic) {\n-    if (!FLAG_IS_DEFAULT(UseSquareToLenIntrinsic)) {\n-      warning(\"squareToLen intrinsic is not available in 32-bit VM\");\n-    }\n-    FLAG_SET_DEFAULT(UseSquareToLenIntrinsic, false);\n-  }\n-  if (UseMulAddIntrinsic) {\n-    if (!FLAG_IS_DEFAULT(UseMulAddIntrinsic)) {\n-      warning(\"mulAdd intrinsic is not available in 32-bit VM\");\n-    }\n-    FLAG_SET_DEFAULT(UseMulAddIntrinsic, false);\n-  }\n-#endif \/\/ _LP64\n@@ -1769,1 +1667,0 @@\n-#ifdef _LP64\n@@ -1786,14 +1683,0 @@\n-#else\n-  if (UseVectorizedMismatchIntrinsic) {\n-    if (!FLAG_IS_DEFAULT(UseVectorizedMismatchIntrinsic)) {\n-      warning(\"vectorizedMismatch intrinsic is not available in 32-bit VM\");\n-    }\n-    FLAG_SET_DEFAULT(UseVectorizedMismatchIntrinsic, false);\n-  }\n-  if (UseVectorizedHashCodeIntrinsic) {\n-    if (!FLAG_IS_DEFAULT(UseVectorizedHashCodeIntrinsic)) {\n-      warning(\"vectorizedHashCode intrinsic is not available in 32-bit VM\");\n-    }\n-    FLAG_SET_DEFAULT(UseVectorizedHashCodeIntrinsic, false);\n-  }\n-#endif \/\/ _LP64\n@@ -1948,1 +1831,0 @@\n-#ifdef _LP64\n@@ -1967,1 +1849,0 @@\n-#endif\n@@ -2198,1 +2079,0 @@\n-#if defined(_LP64)\n@@ -2202,1 +2082,0 @@\n-#endif\n@@ -2220,2 +2099,0 @@\n-\n-#if defined(_LP64)\n@@ -2224,1 +2101,0 @@\n-#endif\n@@ -2227,1 +2103,1 @@\n-  LP64_ONLY(Assembler::precompute_instructions();)\n+  Assembler::precompute_instructions();\n@@ -2994,1 +2870,0 @@\n-#ifdef _LP64\n@@ -2999,1 +2874,0 @@\n-#endif\n@@ -3171,1 +3045,1 @@\n-  int nreg = 2 LP64_ONLY(+2);\n+  int nreg = 4;\n@@ -3327,1 +3201,0 @@\n-#ifdef _LP64\n@@ -3329,3 +3202,0 @@\n-#else\n-        return 320;\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":13,"deletions":143,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -645,1 +645,1 @@\n-  LP64_ONLY(static void clear_apx_test_state());\n+  static void clear_apx_test_state();\n@@ -842,1 +842,1 @@\n-    return LP64_ONLY(true) NOT_LP64(false); \/\/ not implemented on x86_32\n+    return true;\n@@ -847,1 +847,1 @@\n-    return LP64_ONLY(true) NOT_LP64(false); \/\/ not implemented on x86_32\n+    return true;\n@@ -882,1 +882,0 @@\n-#ifdef _LP64\n@@ -884,3 +883,0 @@\n-#else\n-  static bool supports_clflush() { return  ((_features & CPU_FLUSH) != 0); }\n-#endif \/\/ _LP64\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"}]}