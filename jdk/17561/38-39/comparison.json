{"files":[{"patch":"@@ -29,1 +29,0 @@\n-#include \"gc\/shenandoah\/shenandoahFreeSet.inline.hpp\"\n@@ -33,0 +32,2 @@\n+#include \"gc\/shenandoah\/shenandoahSimpleBitMap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahSimpleBitMap.inline.hpp\"\n@@ -39,3 +40,3 @@\n-    case NotFree: return \"NotFree\";\n-    case Mutator: return \"Mutator\";\n-    case Collector: return \"Collector\";\n+    case ShenandoahFreeSetPartitionId::NotFree: return \"NotFree\";\n+    case ShenandoahFreeSetPartitionId::Mutator: return \"Mutator\";\n+    case ShenandoahFreeSetPartitionId::Collector: return \"Collector\";\n@@ -46,195 +47,0 @@\n-size_t ShenandoahSimpleBitMap::count_leading_ones(ssize_t start_idx) const {\n-  assert((start_idx >= 0) && (start_idx < _num_bits), \"precondition\");\n-  size_t array_idx = start_idx >> LogBitsPerWord;\n-  uintx element_bits = _bitmap[array_idx];\n-  uintx bit_number = start_idx & right_n_bits(LogBitsPerWord);\n-  uintx omit_mask = right_n_bits(bit_number);\n-  uintx mask = ((uintx) 0 - 1) & ~omit_mask;\n-  if ((element_bits & mask) == mask) {\n-    size_t counted_ones = BitsPerWord - bit_number;\n-    return counted_ones + count_leading_ones(start_idx - counted_ones);\n-  } else {\n-    \/\/ Return number of consecutive ones starting with the_bit and including more significant bits.\n-    uintx aligned = element_bits >> bit_number;\n-    uintx complement = ~aligned;;\n-    return count_trailing_zeros<uintx>(complement);\n-  }\n-}\n-\n-size_t ShenandoahSimpleBitMap::count_trailing_ones(ssize_t last_idx) const {\n-  assert((last_idx >= 0) && (last_idx < _num_bits), \"precondition\");\n-  size_t array_idx = last_idx >> LogBitsPerWord;\n-  uintx element_bits = _bitmap[array_idx];\n-  uintx bit_number = last_idx & right_n_bits(LogBitsPerWord);\n-  \/\/ All ones from bit 0 to the_bit\n-  uintx mask = right_n_bits(bit_number + 1);\n-  if ((element_bits & mask) == mask) {\n-    size_t counted_ones = bit_number + 1;\n-    return counted_ones + count_trailing_ones(last_idx - counted_ones);\n-  } else {\n-    \/\/ Return number of consecutive ones starting with the_bit and including less significant bits\n-    uintx aligned = element_bits << (BitsPerWord - (bit_number + 1));\n-    uintx complement = ~aligned;\n-    return count_leading_zeros<uintx>(complement);\n-  }\n-}\n-\n-bool ShenandoahSimpleBitMap::is_forward_consecutive_ones(ssize_t start_idx, ssize_t count) const {\n-  assert((start_idx >= 0) && (start_idx < _num_bits), \"precondition: start_idx: \" SSIZE_FORMAT \", count: \" SSIZE_FORMAT,\n-         start_idx, count);\n-  assert(start_idx + count <= (ssize_t) _num_bits, \"precondition\");\n-  size_t array_idx = start_idx >> LogBitsPerWord;\n-  uintx bit_number = start_idx & right_n_bits(LogBitsPerWord);\n-  uintx element_bits = _bitmap[array_idx];\n-  uintx bits_to_examine  = BitsPerWord - bit_number;\n-  element_bits >>= bit_number;\n-  uintx complement = ~element_bits;\n-  uintx trailing_ones;\n-  if (complement) {\n-    trailing_ones = count_trailing_zeros<uintx>(complement);\n-  } else {\n-    trailing_ones = bits_to_examine;\n-  }\n-  if (trailing_ones >= (uintx) count) {\n-    return true;\n-  } else if (trailing_ones == bits_to_examine) {\n-     \/\/ Tail recursion\n-    return is_forward_consecutive_ones(start_idx + bits_to_examine, count - bits_to_examine);\n-  } else {\n-    return false;\n-  }\n-}\n-\n-bool ShenandoahSimpleBitMap::is_backward_consecutive_ones(ssize_t last_idx, ssize_t count) const {\n-  assert((last_idx >= 0) && (last_idx < _num_bits), \"precondition\");\n-  assert(last_idx - count >= -1, \"precondition\");\n-  size_t array_idx = last_idx >> LogBitsPerWord;\n-  uintx bit_number = last_idx & right_n_bits(LogBitsPerWord);\n-  uintx element_bits = _bitmap[array_idx];\n-  uintx bits_to_examine = bit_number + 1;\n-  element_bits <<= (BitsPerWord - bits_to_examine);\n-  uintx complement = ~element_bits;\n-  uintx leading_ones;\n-  if (complement) {\n-    leading_ones = count_leading_zeros<uintx>(complement);\n-  } else {\n-    leading_ones = bits_to_examine;\n-  }\n-  if (leading_ones >= (uintx) count) {\n-    return true;\n-  } else if (leading_ones == bits_to_examine) {\n-    \/\/ Tail recursion\n-    return is_backward_consecutive_ones(last_idx - leading_ones, count - leading_ones);\n-  } else {\n-    return false;\n-  }\n-}\n-\n-ssize_t ShenandoahSimpleBitMap::find_next_consecutive_bits(size_t num_bits, ssize_t start_idx, ssize_t boundary_idx) const {\n-  assert((start_idx >= 0) && (start_idx < _num_bits), \"precondition\");\n-\n-  \/\/ Stop looking if there are not num_bits remaining in probe space.\n-  ssize_t start_boundary = boundary_idx - num_bits;\n-  if (start_idx > start_boundary) {\n-    return boundary_idx;\n-  }\n-  uintx array_idx = start_idx >> LogBitsPerWord;\n-  uintx bit_number = start_idx & right_n_bits(LogBitsPerWord);\n-  uintx element_bits = _bitmap[array_idx];\n-  if (bit_number > 0) {\n-    uintx mask_out = right_n_bits(bit_number);\n-    element_bits &= ~mask_out;\n-  }\n-  while (true) {\n-    if (!element_bits) {\n-      \/\/ move to the next element\n-      start_idx += BitsPerWord - bit_number;\n-      if (start_idx > start_boundary) {\n-        \/\/ No match found.\n-        return boundary_idx;\n-      }\n-      array_idx++;\n-      bit_number = 0;\n-      element_bits = _bitmap[array_idx];\n-    } else if (is_forward_consecutive_ones(start_idx, num_bits)) {\n-      return start_idx;\n-    } else {\n-      \/\/ There is at least one non-zero bit within the masked element_bits.  Find it.\n-      uintx next_set_bit = count_trailing_zeros<uintx>(element_bits);\n-      uintx next_start_candidate_1 = (array_idx << LogBitsPerWord) + next_set_bit;\n-\n-      \/\/ There is at least one zero bit in this span.  Align the next probe at the start of trailing ones for probed span.\n-      size_t trailing_ones = count_trailing_ones(start_idx + num_bits - 1);\n-      uintx next_start_candidate_2 = start_idx + num_bits - trailing_ones;\n-\n-      start_idx = MAX2(next_start_candidate_1, next_start_candidate_2);\n-      if (start_idx > start_boundary) {\n-        \/\/ No match found.\n-        return boundary_idx;\n-      }\n-      array_idx = start_idx >> LogBitsPerWord;\n-      element_bits = _bitmap[array_idx];\n-      bit_number = start_idx & right_n_bits(LogBitsPerWord);\n-      if (bit_number > 0) {\n-        size_t mask_out = right_n_bits(bit_number);\n-        element_bits &= ~mask_out;\n-      }\n-    }\n-  }\n-}\n-\n-ssize_t ShenandoahSimpleBitMap::find_prev_consecutive_bits(\n-  const size_t num_bits, ssize_t last_idx, const ssize_t boundary_idx) const {\n-  assert((last_idx >= 0) && (last_idx < _num_bits), \"precondition\");\n-\n-  \/\/ Stop looking if there are not num_bits remaining in probe space.\n-  ssize_t last_boundary = boundary_idx + num_bits;\n-  if (last_idx < last_boundary) {\n-    return boundary_idx;\n-  }\n-\n-  size_t array_idx = last_idx >> LogBitsPerWord;\n-  uintx bit_number = last_idx & right_n_bits(LogBitsPerWord);\n-  uintx element_bits = _bitmap[array_idx];\n-  if (bit_number < BitsPerWord - 1) {\n-    uintx mask_in = right_n_bits(bit_number + 1);\n-    element_bits &= mask_in;\n-  }\n-  while (true) {\n-    if (!element_bits) {\n-      \/\/ move to the previous element\n-      last_idx -= bit_number + 1;\n-      if (last_idx < last_boundary) {\n-        \/\/ No match found.\n-        return boundary_idx;\n-      }\n-      array_idx--;\n-      bit_number = BitsPerWord - 1;\n-      element_bits = _bitmap[array_idx];\n-    } else if (is_backward_consecutive_ones(last_idx, num_bits)) {\n-      return last_idx + 1 - num_bits;\n-    } else {\n-      \/\/ There is at least one non-zero bit within the masked element_bits.  Find it.\n-      uintx next_set_bit = BitsPerWord - (1 + count_leading_zeros<uintx>(element_bits));\n-      uintx next_last_candidate_1 = (array_idx << LogBitsPerWord) + next_set_bit;\n-\n-      \/\/ There is at least one zero bit in this span.  Align the next probe at the end of leading ones for probed span.\n-      size_t leading_ones = count_leading_ones(last_idx - (num_bits - 1));\n-      uintx next_last_candidate_2 = last_idx - (num_bits - leading_ones);\n-\n-      last_idx = MIN2(next_last_candidate_1, next_last_candidate_2);\n-      if (last_idx < last_boundary) {\n-        \/\/ No match found.\n-        return boundary_idx;\n-      }\n-      array_idx = last_idx >> LogBitsPerWord;\n-      bit_number = last_idx & right_n_bits(LogBitsPerWord);\n-      element_bits = _bitmap[array_idx];\n-      if (bit_number < BitsPerWord - 1){\n-        size_t mask_in = right_n_bits(bit_number + 1);\n-        element_bits &= mask_in;\n-      }\n-    }\n-  }\n-}\n-\n@@ -243,1 +49,4 @@\n-               _leftmosts[Mutator], _rightmosts[Mutator], _leftmosts[Collector], _rightmosts[Collector]);\n+               _leftmosts[int(ShenandoahFreeSetPartitionId::Mutator)],\n+               _rightmosts[int(ShenandoahFreeSetPartitionId::Mutator)],\n+               _leftmosts[int(ShenandoahFreeSetPartitionId::Collector)],\n+               _rightmosts[int(ShenandoahFreeSetPartitionId::Collector)]);\n@@ -246,2 +55,4 @@\n-               _leftmosts_empty[Mutator], _rightmosts_empty[Mutator],\n-               _leftmosts_empty[Collector], _rightmosts_empty[Collector]);\n+               _leftmosts_empty[int(ShenandoahFreeSetPartitionId::Mutator)],\n+               _rightmosts_empty[int(ShenandoahFreeSetPartitionId::Mutator)],\n+               _leftmosts_empty[int(ShenandoahFreeSetPartitionId::Collector)],\n+               _rightmosts_empty[int(ShenandoahFreeSetPartitionId::Collector)]);\n@@ -260,3 +71,3 @@\n-  ssize_t aligned_start = _membership[Mutator].aligned_index(start_idx);\n-  ssize_t aligned_end = _membership[Mutator].aligned_index(end_idx);\n-  ssize_t alignment = _membership[Mutator].alignment();\n+  ssize_t aligned_start = _membership[int(ShenandoahFreeSetPartitionId::Mutator)].aligned_index(start_idx);\n+  ssize_t aligned_end = _membership[int(ShenandoahFreeSetPartitionId::Mutator)].aligned_index(end_idx);\n+  ssize_t alignment = _membership[int(ShenandoahFreeSetPartitionId::Mutator)].alignment();\n@@ -271,3 +82,3 @@\n-  ssize_t aligned_idx = _membership[Mutator].aligned_index(idx);\n-  uintx mutator_bits = _membership[Mutator].bits_at(aligned_idx);\n-  uintx collector_bits = _membership[Collector].bits_at(aligned_idx);\n+  ssize_t aligned_idx = _membership[int(ShenandoahFreeSetPartitionId::Mutator)].aligned_index(idx);\n+  uintx mutator_bits = _membership[int(ShenandoahFreeSetPartitionId::Mutator)].bits_at(aligned_idx);\n+  uintx collector_bits = _membership[int(ShenandoahFreeSetPartitionId::Collector)].bits_at(aligned_idx);\n@@ -320,2 +131,2 @@\n-  assert (which_partition < NumPartitions, \"selected free partition must be valid\");\n-  ssize_t idx = _leftmosts[which_partition];\n+  assert (int(which_partition) < NumPartitions, \"selected free partition must be valid\");\n+  ssize_t idx = _leftmosts[int(which_partition)];\n@@ -331,2 +142,2 @@\n-  assert (which_partition < NumPartitions, \"selected free partition must be valid\");\n-  ssize_t idx = _rightmosts[which_partition];\n+  assert (int(which_partition) < NumPartitions, \"selected free partition must be valid\");\n+  ssize_t idx = _rightmosts[int(which_partition)];\n@@ -347,1 +158,1 @@\n-  _region_counts[Mutator] = _region_counts[Collector] = 0;\n+  _region_counts[int(ShenandoahFreeSetPartitionId::Mutator)] = _region_counts[int(ShenandoahFreeSetPartitionId::Collector)] = 0;\n@@ -353,18 +164,18 @@\n-  _region_counts[Mutator] = mutator_region_count;\n-  _leftmosts[Mutator] = mutator_leftmost;\n-  _rightmosts[Mutator] = mutator_rightmost;\n-  _leftmosts_empty[Mutator] = mutator_leftmost_empty;\n-  _rightmosts_empty[Mutator] = mutator_rightmost_empty;\n-\n-  _region_counts[Mutator] = mutator_region_count;\n-  _used[Mutator] = mutator_used;\n-  _capacity[Mutator] = mutator_region_count * _region_size_bytes;\n-\n-  _leftmosts[Collector] = _max;\n-  _rightmosts[Collector] = -1;\n-  _leftmosts_empty[Collector] = _max;\n-  _rightmosts_empty[Collector] = -1;\n-\n-  _region_counts[Collector] = 0;\n-  _used[Collector] = 0;\n-  _capacity[Collector] = 0;\n+  _region_counts[int(ShenandoahFreeSetPartitionId::Mutator)] = mutator_region_count;\n+  _leftmosts[int(ShenandoahFreeSetPartitionId::Mutator)] = mutator_leftmost;\n+  _rightmosts[int(ShenandoahFreeSetPartitionId::Mutator)] = mutator_rightmost;\n+  _leftmosts_empty[int(ShenandoahFreeSetPartitionId::Mutator)] = mutator_leftmost_empty;\n+  _rightmosts_empty[int(ShenandoahFreeSetPartitionId::Mutator)] = mutator_rightmost_empty;\n+\n+  _region_counts[int(ShenandoahFreeSetPartitionId::Mutator)] = mutator_region_count;\n+  _used[int(ShenandoahFreeSetPartitionId::Mutator)] = mutator_used;\n+  _capacity[int(ShenandoahFreeSetPartitionId::Mutator)] = mutator_region_count * _region_size_bytes;\n+\n+  _leftmosts[int(ShenandoahFreeSetPartitionId::Collector)] = _max;\n+  _rightmosts[int(ShenandoahFreeSetPartitionId::Collector)] = -1;\n+  _leftmosts_empty[int(ShenandoahFreeSetPartitionId::Collector)] = _max;\n+  _rightmosts_empty[int(ShenandoahFreeSetPartitionId::Collector)] = -1;\n+\n+  _region_counts[int(ShenandoahFreeSetPartitionId::Collector)] = 0;\n+  _used[int(ShenandoahFreeSetPartitionId::Collector)] = 0;\n+  _capacity[int(ShenandoahFreeSetPartitionId::Collector)] = 0;\n@@ -374,3 +185,3 @@\n-  assert (which_partition < NumPartitions, \"Partition must be valid\");\n-  _used[which_partition] += bytes;\n-  assert (_used[which_partition] <= _capacity[which_partition],\n+  assert (int(which_partition) < NumPartitions, \"Partition must be valid\");\n+  _used[int(which_partition)] += bytes;\n+  assert (_used[int(which_partition)] <= _capacity[int(which_partition)],\n@@ -378,1 +189,1 @@\n-          _used[which_partition], _capacity[which_partition], bytes);\n+          _used[int(which_partition)], _capacity[int(which_partition)], bytes);\n@@ -385,1 +196,1 @@\n-    assert (!_membership[partition].is_set(low_idx), \"Do not shrink interval if region not removed\");\n+    assert (!_membership[int(partition)].is_set(low_idx), \"Do not shrink interval if region not removed\");\n@@ -387,1 +198,1 @@\n-      _leftmosts[partition] = _max;\n+      _leftmosts[int(partition)] = _max;\n@@ -389,1 +200,1 @@\n-      _leftmosts[partition] = find_index_of_next_available_region(partition, high_idx + 1);\n+      _leftmosts[int(partition)] = find_index_of_next_available_region(partition, high_idx + 1);\n@@ -393,1 +204,1 @@\n-      _leftmosts_empty[partition] = leftmost(partition);\n+      _leftmosts_empty[int(partition)] = leftmost(partition);\n@@ -397,1 +208,1 @@\n-    assert (!_membership[partition].is_set(high_idx), \"Do not shrink interval if region not removed\");\n+    assert (!_membership[int(partition)].is_set(high_idx), \"Do not shrink interval if region not removed\");\n@@ -399,1 +210,1 @@\n-      _rightmosts[partition] = -1;\n+      _rightmosts[int(partition)] = -1;\n@@ -401,1 +212,1 @@\n-      _rightmosts[partition] = find_index_of_previous_available_region(partition, low_idx - 1);\n+      _rightmosts[int(partition)] = find_index_of_previous_available_region(partition, low_idx - 1);\n@@ -405,1 +216,1 @@\n-      _rightmosts_empty[partition] = rightmost(partition);\n+      _rightmosts_empty[int(partition)] = rightmost(partition);\n@@ -409,4 +220,4 @@\n-    _leftmosts[partition] = _max;\n-    _rightmosts[partition] = -1;\n-    _leftmosts_empty[partition] = _max;\n-    _rightmosts_empty[partition] = -1;\n+    _leftmosts[int(partition)] = _max;\n+    _rightmosts[int(partition)] = -1;\n+    _leftmosts_empty[int(partition)] = _max;\n+    _rightmosts_empty[int(partition)] = -1;\n@@ -419,1 +230,1 @@\n-    assert (!_membership[partition].is_set(idx), \"Do not shrink interval if region not removed\");\n+    assert (!_membership[int(partition)].is_set(idx), \"Do not shrink interval if region not removed\");\n@@ -421,1 +232,1 @@\n-      _leftmosts[partition] = _max;\n+      _leftmosts[int(partition)] = _max;\n@@ -423,1 +234,1 @@\n-      _leftmosts[partition] = find_index_of_next_available_region(partition, idx + 1);\n+      _leftmosts[int(partition)] = find_index_of_next_available_region(partition, idx + 1);\n@@ -427,1 +238,1 @@\n-      _leftmosts_empty[partition] = leftmost(partition);\n+      _leftmosts_empty[int(partition)] = leftmost(partition);\n@@ -431,1 +242,1 @@\n-    assert (!_membership[partition].is_set(idx), \"Do not shrink interval if region not removed\");\n+    assert (!_membership[int(partition)].is_set(idx), \"Do not shrink interval if region not removed\");\n@@ -433,1 +244,1 @@\n-      _rightmosts[partition] = -1;\n+      _rightmosts[int(partition)] = -1;\n@@ -435,1 +246,1 @@\n-      _rightmosts[partition] = find_index_of_previous_available_region(partition, idx - 1);\n+      _rightmosts[int(partition)] = find_index_of_previous_available_region(partition, idx - 1);\n@@ -439,1 +250,1 @@\n-      _rightmosts_empty[partition] = rightmost(partition);\n+      _rightmosts_empty[int(partition)] = rightmost(partition);\n@@ -443,4 +254,4 @@\n-    _leftmosts[partition] = _max;\n-    _rightmosts[partition] = -1;\n-    _leftmosts_empty[partition] = _max;\n-    _rightmosts_empty[partition] = -1;\n+    _leftmosts[int(partition)] = _max;\n+    _rightmosts[int(partition)] = -1;\n+    _leftmosts_empty[int(partition)] = _max;\n+    _rightmosts_empty[int(partition)] = -1;\n@@ -453,1 +264,1 @@\n-    _leftmosts[partition] = idx;\n+    _leftmosts[int(partition)] = idx;\n@@ -456,1 +267,1 @@\n-    _rightmosts[partition] = idx;\n+    _rightmosts[int(partition)] = idx;\n@@ -460,1 +271,1 @@\n-      _leftmosts_empty[partition] = idx;\n+      _leftmosts_empty[int(partition)] = idx;\n@@ -463,1 +274,1 @@\n-      _rightmosts_empty[partition] = idx;\n+      _rightmosts_empty[int(partition)] = idx;\n@@ -474,1 +285,1 @@\n-  assert (partition < NumPartitions, \"Cannot remove from free partitions if not already free\");\n+  assert (int(partition) < NumPartitions, \"Cannot remove from free partitions if not already free\");\n@@ -478,1 +289,1 @@\n-    _membership[partition].clear_bit(idx);\n+    _membership[int(partition)].clear_bit(idx);\n@@ -480,1 +291,1 @@\n-  _region_counts[partition] -= high_idx + 1 - low_idx;\n+  _region_counts[int(partition)] -= high_idx + 1 - low_idx;\n@@ -488,1 +299,1 @@\n-  assert (partition < NumPartitions, \"Cannot remove from free partitions if not already free\");\n+  assert (int(partition) < NumPartitions, \"Cannot remove from free partitions if not already free\");\n@@ -495,1 +306,1 @@\n-  _membership[partition].clear_bit(idx);\n+  _membership[int(partition)].clear_bit(idx);\n@@ -497,1 +308,1 @@\n-  _region_counts[partition]--;\n+  _region_counts[int(partition)]--;\n@@ -502,2 +313,2 @@\n-  assert (membership(idx) == NotFree, \"Cannot make free if already free\");\n-  assert (which_partition < NumPartitions, \"selected free partition must be valid\");\n+  assert (membership(idx) == ShenandoahFreeSetPartitionId::NotFree, \"Cannot make free if already free\");\n+  assert (int(which_partition) < NumPartitions, \"selected free partition must be valid\");\n@@ -506,3 +317,3 @@\n-  _membership[which_partition].set_bit(idx);\n-  _capacity[which_partition] += _region_size_bytes;\n-  _used[which_partition] += _region_size_bytes - available;\n+  _membership[int(which_partition)].set_bit(idx);\n+  _capacity[int(which_partition)] += _region_size_bytes;\n+  _used[int(which_partition)] += _region_size_bytes - available;\n@@ -511,1 +322,1 @@\n-  _region_counts[which_partition]++;\n+  _region_counts[int(which_partition)]++;\n@@ -517,2 +328,2 @@\n-  assert (orig_partition < NumPartitions, \"Original partition must be valid\");\n-  assert (new_partition < NumPartitions, \"New partition must be valid\");\n+  assert (int(orig_partition) < NumPartitions, \"Original partition must be valid\");\n+  assert (int(new_partition) < NumPartitions, \"New partition must be valid\");\n@@ -526,2 +337,2 @@\n-           (((orig_partition == Mutator) && (new_partition == Collector)) ||\n-            ((orig_partition == Collector) && (new_partition == Mutator)))) ||\n+           (((orig_partition == ShenandoahFreeSetPartitionId::Mutator) && (new_partition == ShenandoahFreeSetPartitionId::Collector)) ||\n+            ((orig_partition == ShenandoahFreeSetPartitionId::Collector) && (new_partition == ShenandoahFreeSetPartitionId::Mutator)))) ||\n@@ -529,1 +340,1 @@\n-           ((orig_partition == Mutator) && (new_partition == Collector))), \"Unexpected movement between partitions\");\n+           ((orig_partition == ShenandoahFreeSetPartitionId::Mutator) && (new_partition == ShenandoahFreeSetPartitionId::Collector))), \"Unexpected movement between partitions\");\n@@ -534,2 +345,2 @@\n-  _membership[orig_partition].clear_bit(idx);\n-  _membership[new_partition].set_bit(idx);\n+  _membership[int(orig_partition)].clear_bit(idx);\n+  _membership[int(new_partition)].set_bit(idx);\n@@ -537,2 +348,2 @@\n-  _capacity[orig_partition] -= _region_size_bytes;\n-  _used[orig_partition] -= used;\n+  _capacity[int(orig_partition)] -= _region_size_bytes;\n+  _used[int(orig_partition)] -= used;\n@@ -541,2 +352,2 @@\n-  _capacity[new_partition] += _region_size_bytes;;\n-  _used[new_partition] += used;\n+  _capacity[int(new_partition)] += _region_size_bytes;;\n+  _used[int(new_partition)] += used;\n@@ -545,2 +356,2 @@\n-  _region_counts[orig_partition]--;\n-  _region_counts[new_partition]++;\n+  _region_counts[int(orig_partition)]--;\n+  _region_counts[int(new_partition)]++;\n@@ -551,1 +362,1 @@\n-  ShenandoahFreeSetPartitionId result = NotFree;\n+  ShenandoahFreeSetPartitionId result = ShenandoahFreeSetPartitionId::NotFree;\n@@ -554,1 +365,1 @@\n-      assert(result == NotFree, \"Region should reside in only one partition\");\n+      assert(result == ShenandoahFreeSetPartitionId::NotFree, \"Region should reside in only one partition\");\n@@ -565,1 +376,1 @@\n-  ShenandoahFreeSetPartitionId result = NotFree;\n+  ShenandoahFreeSetPartitionId result = ShenandoahFreeSetPartitionId::NotFree;\n@@ -568,1 +379,1 @@\n-      assert(result == NotFree, \"Region should reside in only one partition\");\n+      assert(result == ShenandoahFreeSetPartitionId::NotFree, \"Region should reside in only one partition\");\n@@ -577,1 +388,1 @@\n-  assert (test_partition < NotFree, \"must be a valid partition\");\n+  assert (test_partition < ShenandoahFreeSetPartitionId::NotFree, \"must be a valid partition\");\n@@ -584,1 +395,1 @@\n-  assert (which_partition < NumPartitions, \"selected free partition must be valid\");\n+  assert (int(which_partition) < NumPartitions, \"selected free partition must be valid\");\n@@ -596,1 +407,1 @@\n-  ssize_t result = _membership[which_partition].find_next_set_bit(start_index, rightmost_idx + 1);\n+  ssize_t result = _membership[int(which_partition)].find_next_set_bit(start_index, rightmost_idx + 1);\n@@ -609,1 +420,1 @@\n-  ssize_t result = _membership[which_partition].find_prev_set_bit(last_index, -1);\n+  ssize_t result = _membership[int(which_partition)].find_prev_set_bit(last_index, -1);\n@@ -618,1 +429,1 @@\n-  ssize_t result = _membership[which_partition].find_next_consecutive_bits(cluster_size, start_index, rightmost_idx + 1);\n+  ssize_t result = _membership[int(which_partition)].find_next_consecutive_bits(cluster_size, start_index, rightmost_idx + 1);\n@@ -627,1 +438,1 @@\n-  ssize_t result = _membership[which_partition].find_prev_consecutive_bits(cluster_size, last_index, leftmost_idx - 1);\n+  ssize_t result = _membership[int(which_partition)].find_prev_consecutive_bits(cluster_size, last_index, leftmost_idx - 1);\n@@ -632,1 +443,1 @@\n-  assert (which_partition < NumPartitions, \"selected free partition must be valid\");\n+  assert (int(which_partition) < NumPartitions, \"selected free partition must be valid\");\n@@ -634,1 +445,1 @@\n-  if (_leftmosts_empty[which_partition] == _max) {\n+  if (_leftmosts_empty[int(which_partition)] == _max) {\n@@ -637,1 +448,1 @@\n-  for (ssize_t idx = find_index_of_next_available_region(which_partition, _leftmosts_empty[which_partition]);\n+  for (ssize_t idx = find_index_of_next_available_region(which_partition, _leftmosts_empty[int(which_partition)]);\n@@ -641,1 +452,1 @@\n-      _leftmosts_empty[which_partition] = idx;\n+      _leftmosts_empty[int(which_partition)] = idx;\n@@ -646,2 +457,2 @@\n-  _leftmosts_empty[which_partition] = _max;\n-  _rightmosts_empty[which_partition] = -1;\n+  _leftmosts_empty[int(which_partition)] = _max;\n+  _rightmosts_empty[int(which_partition)] = -1;\n@@ -652,2 +463,2 @@\n-  assert (which_partition < NumPartitions, \"selected free partition must be valid\");\n-  if (_rightmosts_empty[which_partition] < 0) {\n+  assert (int(which_partition) < NumPartitions, \"selected free partition must be valid\");\n+  if (_rightmosts_empty[int(which_partition)] < 0) {\n@@ -656,1 +467,1 @@\n-  for (ssize_t idx = find_index_of_previous_available_region(which_partition, _rightmosts_empty[which_partition]); idx >= 0; ) {\n+  for (ssize_t idx = find_index_of_previous_available_region(which_partition, _rightmosts_empty[int(which_partition)]); idx >= 0; ) {\n@@ -659,1 +470,1 @@\n-      _rightmosts_empty[which_partition] = idx;\n+      _rightmosts_empty[int(which_partition)] = idx;\n@@ -664,2 +475,2 @@\n-  _leftmosts_empty[which_partition] = _max;\n-  _rightmosts_empty[which_partition] = -1;\n+  _leftmosts_empty[int(which_partition)] = _max;\n+  _rightmosts_empty[int(which_partition)] = -1;\n@@ -688,1 +499,1 @@\n-      case NotFree:\n+      case ShenandoahFreeSetPartitionId::NotFree:\n@@ -691,2 +502,2 @@\n-      case Mutator:\n-      case Collector:\n+      case ShenandoahFreeSetPartitionId::Mutator:\n+      case ShenandoahFreeSetPartitionId::Collector:\n@@ -697,2 +508,2 @@\n-        if (i < leftmosts[partition]) {\n-          leftmosts[partition] = i;\n+        if (i < leftmosts[int(partition)]) {\n+          leftmosts[int(partition)] = i;\n@@ -700,2 +511,2 @@\n-        if (is_empty && (i < empty_leftmosts[partition])) {\n-          empty_leftmosts[partition] = i;\n+        if (is_empty && (i < empty_leftmosts[int(partition)])) {\n+          empty_leftmosts[int(partition)] = i;\n@@ -703,2 +514,2 @@\n-        if (i > rightmosts[partition]) {\n-          rightmosts[partition] = i;\n+        if (i > rightmosts[int(partition)]) {\n+          rightmosts[int(partition)] = i;\n@@ -706,2 +517,2 @@\n-        if (is_empty && (i > empty_rightmosts[partition])) {\n-          empty_rightmosts[partition] = i;\n+        if (is_empty && (i > empty_rightmosts[int(partition)])) {\n+          empty_rightmosts[int(partition)] = i;\n@@ -718,2 +529,2 @@\n-  assert (leftmost(Mutator) <= _max, \"leftmost in bounds: \"  SSIZE_FORMAT \" < \" SSIZE_FORMAT, leftmost(Mutator),  _max);\n-  assert (rightmost(Mutator) < _max, \"rightmost in bounds: \"  SSIZE_FORMAT \" < \" SSIZE_FORMAT, rightmost(Mutator),  _max);\n+  assert (leftmost(ShenandoahFreeSetPartitionId::Mutator) <= _max, \"leftmost in bounds: \"  SSIZE_FORMAT \" < \" SSIZE_FORMAT, leftmost(ShenandoahFreeSetPartitionId::Mutator),  _max);\n+  assert (rightmost(ShenandoahFreeSetPartitionId::Mutator) < _max, \"rightmost in bounds: \"  SSIZE_FORMAT \" < \" SSIZE_FORMAT, rightmost(ShenandoahFreeSetPartitionId::Mutator),  _max);\n@@ -721,4 +532,4 @@\n-  assert (leftmost(Mutator) == _max || partition_id_matches(leftmost(Mutator), Mutator),\n-          \"leftmost region should be free: \" SSIZE_FORMAT,  leftmost(Mutator));\n-  assert (leftmost(Mutator) == _max || partition_id_matches(rightmost(Mutator), Mutator),\n-          \"rightmost region should be free: \" SSIZE_FORMAT, rightmost(Mutator));\n+  assert (leftmost(ShenandoahFreeSetPartitionId::Mutator) == _max || partition_id_matches(leftmost(ShenandoahFreeSetPartitionId::Mutator), ShenandoahFreeSetPartitionId::Mutator),\n+          \"leftmost region should be free: \" SSIZE_FORMAT,  leftmost(ShenandoahFreeSetPartitionId::Mutator));\n+  assert (leftmost(ShenandoahFreeSetPartitionId::Mutator) == _max || partition_id_matches(rightmost(ShenandoahFreeSetPartitionId::Mutator), ShenandoahFreeSetPartitionId::Mutator),\n+          \"rightmost region should be free: \" SSIZE_FORMAT, rightmost(ShenandoahFreeSetPartitionId::Mutator));\n@@ -728,13 +539,13 @@\n-  ssize_t beg_off = leftmosts[Mutator];\n-  ssize_t end_off = rightmosts[Mutator];\n-  assert (beg_off >= leftmost(Mutator),\n-          \"free regions before the leftmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT, beg_off, leftmost(Mutator));\n-  assert (end_off <= rightmost(Mutator),\n-          \"free regions past the rightmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,  end_off, rightmost(Mutator));\n-\n-  beg_off = empty_leftmosts[Mutator];\n-  end_off = empty_rightmosts[Mutator];\n-  assert (beg_off >= leftmost_empty(Mutator),\n-          \"free empty regions before the leftmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT, beg_off, leftmost_empty(Mutator));\n-  assert (end_off <= rightmost_empty(Mutator),\n-          \"free empty regions past the rightmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,  end_off, rightmost_empty(Mutator));\n+  ssize_t beg_off = leftmosts[int(ShenandoahFreeSetPartitionId::Mutator)];\n+  ssize_t end_off = rightmosts[int(ShenandoahFreeSetPartitionId::Mutator)];\n+  assert (beg_off >= leftmost(ShenandoahFreeSetPartitionId::Mutator),\n+          \"free regions before the leftmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT, beg_off, leftmost(ShenandoahFreeSetPartitionId::Mutator));\n+  assert (end_off <= rightmost(ShenandoahFreeSetPartitionId::Mutator),\n+          \"free regions past the rightmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,  end_off, rightmost(ShenandoahFreeSetPartitionId::Mutator));\n+\n+  beg_off = empty_leftmosts[int(ShenandoahFreeSetPartitionId::Mutator)];\n+  end_off = empty_rightmosts[int(ShenandoahFreeSetPartitionId::Mutator)];\n+  assert (beg_off >= leftmost_empty(ShenandoahFreeSetPartitionId::Mutator),\n+          \"free empty regions before the leftmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT, beg_off, leftmost_empty(ShenandoahFreeSetPartitionId::Mutator));\n+  assert (end_off <= rightmost_empty(ShenandoahFreeSetPartitionId::Mutator),\n+          \"free empty regions past the rightmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,  end_off, rightmost_empty(ShenandoahFreeSetPartitionId::Mutator));\n@@ -743,2 +554,2 @@\n-  assert (leftmost(Collector) <= _max, \"leftmost in bounds: \"  SSIZE_FORMAT \" < \" SSIZE_FORMAT, leftmost(Collector),  _max);\n-  assert (rightmost(Collector) < _max, \"rightmost in bounds: \"  SSIZE_FORMAT \" < \" SSIZE_FORMAT, rightmost(Collector),  _max);\n+  assert (leftmost(ShenandoahFreeSetPartitionId::Collector) <= _max, \"leftmost in bounds: \"  SSIZE_FORMAT \" < \" SSIZE_FORMAT, leftmost(ShenandoahFreeSetPartitionId::Collector),  _max);\n+  assert (rightmost(ShenandoahFreeSetPartitionId::Collector) < _max, \"rightmost in bounds: \"  SSIZE_FORMAT \" < \" SSIZE_FORMAT, rightmost(ShenandoahFreeSetPartitionId::Collector),  _max);\n@@ -746,4 +557,4 @@\n-  assert (leftmost(Collector) == _max || partition_id_matches(leftmost(Collector), Collector),\n-          \"leftmost region should be free: \" SSIZE_FORMAT,  leftmost(Collector));\n-  assert (leftmost(Collector) == _max || partition_id_matches(rightmost(Collector), Collector),\n-          \"rightmost region should be free: \" SSIZE_FORMAT, rightmost(Collector));\n+  assert (leftmost(ShenandoahFreeSetPartitionId::Collector) == _max || partition_id_matches(leftmost(ShenandoahFreeSetPartitionId::Collector), ShenandoahFreeSetPartitionId::Collector),\n+          \"leftmost region should be free: \" SSIZE_FORMAT,  leftmost(ShenandoahFreeSetPartitionId::Collector));\n+  assert (leftmost(ShenandoahFreeSetPartitionId::Collector) == _max || partition_id_matches(rightmost(ShenandoahFreeSetPartitionId::Collector), ShenandoahFreeSetPartitionId::Collector),\n+          \"rightmost region should be free: \" SSIZE_FORMAT, rightmost(ShenandoahFreeSetPartitionId::Collector));\n@@ -753,13 +564,13 @@\n-  beg_off = leftmosts[Collector];\n-  end_off = rightmosts[Collector];\n-  assert (beg_off >= leftmost(Collector),\n-          \"free regions before the leftmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT, beg_off, leftmost(Collector));\n-  assert (end_off <= rightmost(Collector),\n-          \"free regions past the rightmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,  end_off, rightmost(Collector));\n-\n-  beg_off = empty_leftmosts[Collector];\n-  end_off = empty_rightmosts[Collector];\n-  assert (beg_off >= _leftmosts_empty[Collector],\n-          \"free empty regions before the leftmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT, beg_off, leftmost_empty(Collector));\n-  assert (end_off <= _rightmosts_empty[Collector],\n-          \"free empty regions past the rightmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,  end_off, rightmost_empty(Collector));\n+  beg_off = leftmosts[int(ShenandoahFreeSetPartitionId::Collector)];\n+  end_off = rightmosts[int(ShenandoahFreeSetPartitionId::Collector)];\n+  assert (beg_off >= leftmost(ShenandoahFreeSetPartitionId::Collector),\n+          \"free regions before the leftmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT, beg_off, leftmost(ShenandoahFreeSetPartitionId::Collector));\n+  assert (end_off <= rightmost(ShenandoahFreeSetPartitionId::Collector),\n+          \"free regions past the rightmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,  end_off, rightmost(ShenandoahFreeSetPartitionId::Collector));\n+\n+  beg_off = empty_leftmosts[int(ShenandoahFreeSetPartitionId::Collector)];\n+  end_off = empty_rightmosts[int(ShenandoahFreeSetPartitionId::Collector)];\n+  assert (beg_off >= _leftmosts_empty[int(ShenandoahFreeSetPartitionId::Collector)],\n+          \"free empty regions before the leftmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT, beg_off, leftmost_empty(ShenandoahFreeSetPartitionId::Collector));\n+  assert (end_off <= _rightmosts_empty[int(ShenandoahFreeSetPartitionId::Collector)],\n+          \"free empty regions past the rightmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,  end_off, rightmost_empty(ShenandoahFreeSetPartitionId::Collector));\n@@ -813,2 +624,2 @@\n-        ssize_t non_empty_on_left = _partitions.leftmost_empty(Mutator) - _partitions.leftmost(Mutator);\n-        ssize_t non_empty_on_right = _partitions.rightmost(Mutator) - _partitions.rightmost_empty(Mutator);\n+        ssize_t non_empty_on_left = _partitions.leftmost_empty(ShenandoahFreeSetPartitionId::Mutator) - _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator);\n+        ssize_t non_empty_on_right = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator) - _partitions.rightmost_empty(ShenandoahFreeSetPartitionId::Mutator);\n@@ -820,1 +631,1 @@\n-        if (!_partitions.is_empty(Mutator)) {\n+        if (!_partitions.is_empty(ShenandoahFreeSetPartitionId::Mutator)) {\n@@ -822,3 +633,3 @@\n-          ssize_t leftmost = _partitions.leftmost(Mutator);\n-          for (ssize_t idx = _partitions.rightmost(Mutator); idx >= leftmost; ) {\n-            assert(_partitions.in_free_set(Mutator, idx), \"Boundaries or find_prev_set_bit failed: \" SSIZE_FORMAT, idx);\n+          ssize_t leftmost = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator);\n+          for (ssize_t idx = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator); idx >= leftmost; ) {\n+            assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, idx), \"Boundaries or find_prev_set_bit failed: \" SSIZE_FORMAT, idx);\n@@ -832,1 +643,1 @@\n-            idx = _partitions.find_index_of_previous_available_region(Mutator, idx - 1);\n+            idx = _partitions.find_index_of_previous_available_region(ShenandoahFreeSetPartitionId::Mutator, idx - 1);\n@@ -839,1 +650,1 @@\n-        if (!_partitions.is_empty(Mutator)) {\n+        if (!_partitions.is_empty(ShenandoahFreeSetPartitionId::Mutator)) {\n@@ -841,3 +652,3 @@\n-          ssize_t rightmost = _partitions.rightmost(Mutator);\n-          for (ssize_t idx = _partitions.leftmost(Mutator); idx <= rightmost; ) {\n-            assert(_partitions.in_free_set(Mutator, idx), \"Boundaries or find_prev_set_bit failed: \" SSIZE_FORMAT, idx);\n+          ssize_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator);\n+          for (ssize_t idx = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator); idx <= rightmost; ) {\n+            assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, idx), \"Boundaries or find_prev_set_bit failed: \" SSIZE_FORMAT, idx);\n@@ -851,1 +662,1 @@\n-            idx = _partitions.find_index_of_next_available_region(Mutator, idx + 1);\n+            idx = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Mutator, idx + 1);\n@@ -863,3 +674,3 @@\n-      ssize_t leftmost_collector = _partitions.leftmost(Collector);\n-      for (ssize_t idx = _partitions.rightmost(Collector); idx >= leftmost_collector; ) {\n-        assert(_partitions.in_free_set(Collector, idx), \"Boundaries or find_prev_set_bit failed: \" SSIZE_FORMAT, idx);\n+      ssize_t leftmost_collector = _partitions.leftmost(ShenandoahFreeSetPartitionId::Collector);\n+      for (ssize_t idx = _partitions.rightmost(ShenandoahFreeSetPartitionId::Collector); idx >= leftmost_collector; ) {\n+        assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Collector, idx), \"Boundaries or find_prev_set_bit failed: \" SSIZE_FORMAT, idx);\n@@ -870,1 +681,1 @@\n-        idx = _partitions.find_index_of_previous_available_region(Collector, idx - 1);\n+        idx = _partitions.find_index_of_previous_available_region(ShenandoahFreeSetPartitionId::Collector, idx - 1);\n@@ -879,3 +690,3 @@\n-      ssize_t leftmost_mutator_empty = _partitions.leftmost_empty(Mutator);\n-      for (ssize_t idx = _partitions.rightmost_empty(Mutator); idx >= leftmost_mutator_empty; ) {\n-        assert(_partitions.in_free_set(Mutator, idx), \"Boundaries or find_prev_set_bit failed: \" SSIZE_FORMAT, idx);\n+      ssize_t leftmost_mutator_empty = _partitions.leftmost_empty(ShenandoahFreeSetPartitionId::Mutator);\n+      for (ssize_t idx = _partitions.rightmost_empty(ShenandoahFreeSetPartitionId::Mutator); idx >= leftmost_mutator_empty; ) {\n+        assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, idx), \"Boundaries or find_prev_set_bit failed: \" SSIZE_FORMAT, idx);\n@@ -891,1 +702,1 @@\n-        idx = _partitions.find_index_of_previous_available_region(Mutator, idx - 1);\n+        idx = _partitions.find_index_of_previous_available_region(ShenandoahFreeSetPartitionId::Mutator, idx - 1);\n@@ -955,1 +766,1 @@\n-      _partitions.increase_used(Mutator, req.actual_size() * HeapWordSize);\n+      _partitions.increase_used(ShenandoahFreeSetPartitionId::Mutator, req.actual_size() * HeapWordSize);\n@@ -976,1 +787,1 @@\n-    _partitions.retire_from_partition(req.is_mutator_alloc()? Mutator: Collector, idx, r->used());\n+    _partitions.retire_from_partition(req.is_mutator_alloc()? ShenandoahFreeSetPartitionId::Mutator: ShenandoahFreeSetPartitionId::Collector, idx, r->used());\n@@ -990,1 +801,1 @@\n-  if (num > (ssize_t) _partitions.count(Mutator)) {\n+  if (num > (ssize_t) _partitions.count(ShenandoahFreeSetPartitionId::Mutator)) {\n@@ -994,2 +805,2 @@\n-  ssize_t start_range = _partitions.leftmost_empty(Mutator);\n-  ssize_t end_range = _partitions.rightmost_empty(Mutator) + 1;\n+  ssize_t start_range = _partitions.leftmost_empty(ShenandoahFreeSetPartitionId::Mutator);\n+  ssize_t end_range = _partitions.rightmost_empty(ShenandoahFreeSetPartitionId::Mutator) + 1;\n@@ -1000,1 +811,1 @@\n-  ssize_t beg = _partitions.find_index_of_next_available_cluster_of_regions(Mutator, start_range, num);\n+  ssize_t beg = _partitions.find_index_of_next_available_cluster_of_regions(ShenandoahFreeSetPartitionId::Mutator, start_range, num);\n@@ -1019,2 +830,2 @@\n-        if (!_partitions.in_free_set(Mutator, span_end)) {\n-          beg = _partitions.find_index_of_next_available_cluster_of_regions(Mutator, span_end + 1, num);\n+        if (!_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, span_end)) {\n+          beg = _partitions.find_index_of_next_available_cluster_of_regions(ShenandoahFreeSetPartitionId::Mutator, span_end + 1, num);\n@@ -1076,1 +887,1 @@\n-  _partitions.retire_range_from_partition(Mutator, beg, end);\n+  _partitions.retire_range_from_partition(ShenandoahFreeSetPartitionId::Mutator, beg, end);\n@@ -1079,1 +890,1 @@\n-  _partitions.increase_used(Mutator, total_humongous_size);\n+  _partitions.increase_used(ShenandoahFreeSetPartitionId::Mutator, total_humongous_size);\n@@ -1109,1 +920,1 @@\n-  assert(_partitions.partition_id_matches(idx, Mutator), \"Should be in mutator view\");\n+  assert(_partitions.partition_id_matches(idx, ShenandoahFreeSetPartitionId::Mutator), \"Should be in mutator view\");\n@@ -1113,1 +924,1 @@\n-  _partitions.move_from_partition_to_partition(idx, Mutator, Collector, ac);\n+  _partitions.move_from_partition_to_partition(idx, ShenandoahFreeSetPartitionId::Mutator, ShenandoahFreeSetPartitionId::Collector, ac);\n@@ -1156,1 +967,1 @@\n-        _partitions.raw_set_membership(idx, Mutator);\n+        _partitions.raw_set_membership(idx, ShenandoahFreeSetPartitionId::Mutator);\n@@ -1192,1 +1003,1 @@\n-  if ((max_xfer_regions > 0) && (_partitions.leftmost_empty(Collector) <= _partitions.rightmost_empty(Collector))) {\n+  if ((max_xfer_regions > 0) && (_partitions.leftmost_empty(ShenandoahFreeSetPartitionId::Collector) <= _partitions.rightmost_empty(ShenandoahFreeSetPartitionId::Collector))) {\n@@ -1194,3 +1005,3 @@\n-    ssize_t rightmost = _partitions.rightmost_empty(Collector);\n-    for (ssize_t idx = _partitions.leftmost_empty(Collector); (max_xfer_regions > 0) && (idx <= rightmost); ) {\n-      assert(_partitions.in_free_set(Collector, idx), \"Boundaries or find_next_set_bit failed: \" SSIZE_FORMAT, idx);\n+    ssize_t rightmost = _partitions.rightmost_empty(ShenandoahFreeSetPartitionId::Collector);\n+    for (ssize_t idx = _partitions.leftmost_empty(ShenandoahFreeSetPartitionId::Collector); (max_xfer_regions > 0) && (idx <= rightmost); ) {\n+      assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Collector, idx), \"Boundaries or find_next_set_bit failed: \" SSIZE_FORMAT, idx);\n@@ -1199,1 +1010,1 @@\n-        _partitions.move_from_partition_to_partition(idx, Collector, Mutator, region_size_bytes);\n+        _partitions.move_from_partition_to_partition(idx, ShenandoahFreeSetPartitionId::Collector, ShenandoahFreeSetPartitionId::Mutator, region_size_bytes);\n@@ -1203,1 +1014,1 @@\n-      idx = _partitions.find_index_of_next_available_region(Collector, idx + 1);\n+      idx = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Collector, idx + 1);\n@@ -1208,1 +1019,1 @@\n-  if ((max_xfer_regions > 0) && (_partitions.leftmost(Collector) <= _partitions.rightmost(Collector))) {\n+  if ((max_xfer_regions > 0) && (_partitions.leftmost(ShenandoahFreeSetPartitionId::Collector) <= _partitions.rightmost(ShenandoahFreeSetPartitionId::Collector))) {\n@@ -1210,3 +1021,3 @@\n-    ssize_t rightmost = _partitions.rightmost(Collector);\n-    for (ssize_t idx = _partitions.leftmost(Collector); (max_xfer_regions > 0) && (idx <= rightmost); ) {\n-      assert(_partitions.in_free_set(Collector, idx), \"Boundaries or find_next_set_bit failed: \" SSIZE_FORMAT, idx);\n+    ssize_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Collector);\n+    for (ssize_t idx = _partitions.leftmost(ShenandoahFreeSetPartitionId::Collector); (max_xfer_regions > 0) && (idx <= rightmost); ) {\n+      assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Collector, idx), \"Boundaries or find_next_set_bit failed: \" SSIZE_FORMAT, idx);\n@@ -1215,1 +1026,1 @@\n-        _partitions.move_from_partition_to_partition(idx, Collector, Mutator, ac);\n+        _partitions.move_from_partition_to_partition(idx, ShenandoahFreeSetPartitionId::Collector, ShenandoahFreeSetPartitionId::Mutator, ac);\n@@ -1219,1 +1030,1 @@\n-      idx = _partitions.find_index_of_next_available_region(Collector, idx + 1);\n+      idx = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Collector, idx + 1);\n@@ -1244,1 +1055,1 @@\n-  size_t available_in_collector_partition = _partitions.capacity_of(Collector) - _partitions.used_by(Collector);\n+  size_t available_in_collector_partition = _partitions.capacity_of(ShenandoahFreeSetPartitionId::Collector) - _partitions.used_by(ShenandoahFreeSetPartitionId::Collector);\n@@ -1268,1 +1079,1 @@\n-    if (!_partitions.in_free_set(Mutator, idx)) {\n+    if (!_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, idx)) {\n@@ -1275,1 +1086,1 @@\n-    bool move_to_collector = _partitions.available_in(Collector) < to_reserve;\n+    bool move_to_collector = _partitions.available_in(ShenandoahFreeSetPartitionId::Collector) < to_reserve;\n@@ -1290,1 +1101,1 @@\n-      _partitions.move_from_partition_to_partition(idx, Mutator, Collector, ac);\n+      _partitions.move_from_partition_to_partition(idx, ShenandoahFreeSetPartitionId::Mutator, ShenandoahFreeSetPartitionId::Collector, ac);\n@@ -1296,1 +1107,1 @@\n-    size_t reserve = _partitions.capacity_of(Collector);\n+    size_t reserve = _partitions.capacity_of(ShenandoahFreeSetPartitionId::Collector);\n@@ -1325,2 +1136,2 @@\n-                        _partitions.leftmost(Mutator), _partitions.rightmost(Mutator),\n-                        _partitions.leftmost(Collector), _partitions.rightmost(Collector));\n+                        _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator), _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator),\n+                        _partitions.leftmost(ShenandoahFreeSetPartitionId::Collector), _partitions.rightmost(ShenandoahFreeSetPartitionId::Collector));\n@@ -1334,1 +1145,1 @@\n-      if (_partitions.in_free_set(Mutator, i)) {\n+      if (_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, i)) {\n@@ -1339,1 +1150,1 @@\n-      } else if (_partitions.in_free_set(Collector, i)) {\n+      } else if (_partitions.in_free_set(ShenandoahFreeSetPartitionId::Collector, i)) {\n@@ -1375,2 +1186,2 @@\n-      for (ssize_t idx = _partitions.leftmost(Mutator); idx <= _partitions.rightmost(Mutator); idx++) {\n-        if (_partitions.in_free_set(Mutator, idx)) {\n+      for (ssize_t idx = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator); idx <= _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator); idx++) {\n+        if (_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, idx)) {\n@@ -1421,2 +1232,2 @@\n-      if (_partitions.count(Mutator) > 0) {\n-        frag_int = (100 * (total_used \/ _partitions.count(Mutator)) \/ ShenandoahHeapRegion::region_size_bytes());\n+      if (_partitions.count(ShenandoahFreeSetPartitionId::Mutator) > 0) {\n+        frag_int = (100 * (total_used \/ _partitions.count(ShenandoahFreeSetPartitionId::Mutator)) \/ ShenandoahHeapRegion::region_size_bytes());\n@@ -1428,1 +1239,1 @@\n-               byte_size_in_proper_unit(total_used), proper_unit_for_byte_size(total_used), _partitions.count(Mutator));\n+               byte_size_in_proper_unit(total_used), proper_unit_for_byte_size(total_used), _partitions.count(ShenandoahFreeSetPartitionId::Mutator));\n@@ -1436,2 +1247,2 @@\n-      for (ssize_t idx = _partitions.leftmost(Collector); idx <= _partitions.rightmost(Collector); idx++) {\n-        if (_partitions.in_free_set(Collector, idx)) {\n+      for (ssize_t idx = _partitions.leftmost(ShenandoahFreeSetPartitionId::Collector); idx <= _partitions.rightmost(ShenandoahFreeSetPartitionId::Collector); idx++) {\n+        if (_partitions.in_free_set(ShenandoahFreeSetPartitionId::Collector, idx)) {\n@@ -1477,4 +1288,4 @@\n-  out->print_cr(\"Mutator Free Set: \" SIZE_FORMAT \"\", _partitions.count(Mutator));\n-  ssize_t rightmost = _partitions.rightmost(Mutator);\n-  for (ssize_t index = _partitions.leftmost(Mutator); index <= rightmost; ) {\n-    assert(_partitions.in_free_set(Mutator, index), \"Boundaries or find_next_set_bit failed: \" SSIZE_FORMAT, index);\n+  out->print_cr(\"Mutator Free Set: \" SIZE_FORMAT \"\", _partitions.count(ShenandoahFreeSetPartitionId::Mutator));\n+  ssize_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator);\n+  for (ssize_t index = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator); index <= rightmost; ) {\n+    assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, index), \"Boundaries or find_next_set_bit failed: \" SSIZE_FORMAT, index);\n@@ -1482,1 +1293,1 @@\n-    index = _partitions.find_index_of_next_available_region(Mutator, index + 1);\n+    index = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Mutator, index + 1);\n@@ -1484,4 +1295,4 @@\n-  out->print_cr(\"Collector Free Set: \" SIZE_FORMAT \"\", _partitions.count(Collector));\n-  rightmost = _partitions.rightmost(Collector);\n-  for (ssize_t index = _partitions.leftmost(Collector); index <= rightmost; ) {\n-    assert(_partitions.in_free_set(Collector, index), \"Boundaries or find_next_set_bit failed: \" SSIZE_FORMAT, index);\n+  out->print_cr(\"Collector Free Set: \" SIZE_FORMAT \"\", _partitions.count(ShenandoahFreeSetPartitionId::Collector));\n+  rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Collector);\n+  for (ssize_t index = _partitions.leftmost(ShenandoahFreeSetPartitionId::Collector); index <= rightmost; ) {\n+    assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Collector, index), \"Boundaries or find_next_set_bit failed: \" SSIZE_FORMAT, index);\n@@ -1489,1 +1300,1 @@\n-    index = _partitions.find_index_of_next_available_region(Collector, index + 1);\n+    index = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Collector, index + 1);\n@@ -1498,3 +1309,3 @@\n-  ssize_t rightmost = _partitions.rightmost(Mutator);\n-  for (ssize_t index = _partitions.leftmost(Mutator); index <= rightmost; ) {\n-    assert(_partitions.in_free_set(Mutator, index), \"Boundaries or find_next_set_bit failed: \" SSIZE_FORMAT, index);\n+  ssize_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator);\n+  for (ssize_t index = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator); index <= rightmost; ) {\n+    assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, index), \"Boundaries or find_next_set_bit failed: \" SSIZE_FORMAT, index);\n@@ -1506,1 +1317,1 @@\n-    index = _partitions.find_index_of_next_available_region(Mutator, index + 1);\n+    index = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Mutator, index + 1);\n@@ -1524,3 +1335,3 @@\n-  ssize_t rightmost = _partitions.rightmost(Mutator);\n-  for (ssize_t index = _partitions.leftmost(Mutator); index <= rightmost; ) {\n-    assert(_partitions.in_free_set(Mutator, index), \"Boundaries or find_next_set_bit failed: \" SSIZE_FORMAT, index);\n+  ssize_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator);\n+  for (ssize_t index = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator); index <= rightmost; ) {\n+    assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, index), \"Boundaries or find_next_set_bit failed: \" SSIZE_FORMAT, index);\n@@ -1540,1 +1351,1 @@\n-    index = _partitions.find_index_of_next_available_region(Mutator, index + 1);\n+    index = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Mutator, index + 1);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":249,"deletions":438,"binary":false,"changes":687,"status":"modified"},{"patch":"@@ -31,132 +31,1 @@\n-\n-\/\/ The API and internal implementation of ShenandoahSimpleBitMap and ShenandoahRegionPartitions use ssize_t to\n-\/\/ represent index, even though index is \"inherently\" unsigned.  There are two reasons for this choice:\n-\/\/  1. We use -1 as a sentinel value to represent empty partitions.  This same value may be used to represent\n-\/\/     failure to find a previous set bit or previous range of set bits.\n-\/\/  2. Certain loops are written most naturally if the iterator, which may hold the sentinel -1 value, can be\n-\/\/     declared as signed and the terminating condition can be < 0.\n-\n-\n-\n-\/\/ ShenandoahSimpleBitMap resembles CHeapBitMap but adds missing support for find_next_consecutive_bits() and\n-\/\/ find_prev_contiguous_bits.  An alternative refactoring of code would subclass CHeapBitMap, but this might\n-\/\/ break abstraction rules, because efficient implementation requires assumptions about superclass internals that\n-\/\/ might be violatee through future software maintenance.\n-class ShenandoahSimpleBitMap {\n-  const ssize_t _num_bits;\n-  const size_t _num_words;\n-  uintx* const _bitmap;\n-\n-public:\n-  ShenandoahSimpleBitMap(size_t num_bits) :\n-      _num_bits(num_bits),\n-      _num_words((num_bits + (BitsPerWord - 1)) \/ BitsPerWord),\n-      _bitmap(NEW_C_HEAP_ARRAY(uintx, _num_words, mtGC))\n-  {\n-    clear_all();\n-  }\n-\n-  ~ShenandoahSimpleBitMap() {\n-    if (_bitmap != nullptr) {\n-      FREE_C_HEAP_ARRAY(uintx, _bitmap);\n-    }\n-  }\n-  void clear_all() {\n-    for (size_t i = 0; i < _num_words; i++) {\n-      _bitmap[i] = 0;\n-    }\n-  }\n-\n-private:\n-\n-  \/\/ Count consecutive ones in forward order, starting from start_idx.  Requires that there is at least one zero\n-  \/\/ between start_idx and index value (_num_bits - 1), inclusive.\n-  size_t count_leading_ones(ssize_t start_idx) const;\n-\n-  \/\/ Count consecutive ones in reverse order, starting from last_idx.  Requires that there is at least one zero\n-  \/\/ between last_idx and index value zero, inclusive.\n-  size_t count_trailing_ones(ssize_t last_idx) const;\n-\n-  bool is_forward_consecutive_ones(ssize_t start_idx, ssize_t count) const;\n-  bool is_backward_consecutive_ones(ssize_t last_idx, ssize_t count) const;\n-\n-public:\n-\n-  inline ssize_t aligned_index(ssize_t idx) const {\n-    assert((idx >= 0) && (idx < _num_bits), \"precondition\");\n-    ssize_t array_idx = idx & ~right_n_bits(LogBitsPerWord);\n-    return array_idx;\n-  }\n-\n-  inline ssize_t alignment() const {\n-    return BitsPerWord;\n-  }\n-\n-  \/\/ For testing\n-  inline ssize_t number_of_bits() const {\n-    return _num_bits;\n-  }\n-\n-  inline uintx bits_at(ssize_t idx) const {\n-    assert((idx >= 0) && (idx < _num_bits), \"precondition\");\n-    ssize_t array_idx = idx >> LogBitsPerWord;\n-    return _bitmap[array_idx];\n-  }\n-\n-  inline void set_bit(ssize_t idx) {\n-    assert((idx >= 0) && (idx < _num_bits), \"precondition\");\n-    size_t array_idx = idx >> LogBitsPerWord;\n-    uintx bit_number = idx & right_n_bits(LogBitsPerWord);\n-    uintx the_bit = nth_bit(bit_number);\n-    _bitmap[array_idx] |= the_bit;\n-  }\n-\n-  inline void clear_bit(ssize_t idx) {\n-    assert((idx >= 0) && (idx < _num_bits), \"precondition\");\n-    assert(idx >= 0, \"precondition\");\n-    size_t array_idx = idx >> LogBitsPerWord;\n-    uintx bit_number = idx & right_n_bits(LogBitsPerWord);\n-    uintx the_bit = nth_bit(bit_number);\n-    _bitmap[array_idx] &= ~the_bit;\n-  }\n-\n-  inline bool is_set(ssize_t idx) const {\n-    assert((idx >= 0) && (idx < _num_bits), \"precondition\");\n-    assert(idx >= 0, \"precondition\");\n-    size_t array_idx = idx >> LogBitsPerWord;\n-    uintx bit_number = idx & right_n_bits(LogBitsPerWord);\n-    uintx the_bit = nth_bit(bit_number);\n-    return (_bitmap[array_idx] & the_bit)? true: false;\n-  }\n-\n-  \/\/ Return the index of the first set bit which is greater or equal to start_idx.  If not found, return _num_bits.\n-  inline ssize_t find_next_set_bit(ssize_t start_idx) const;\n-\n-  \/\/ Return the index of the first set bit which is greater or equal to start_idx and less than boundary_idx.\n-  \/\/ If not found, return boundary_idx\n-  inline ssize_t find_next_set_bit(ssize_t start_idx, ssize_t boundary_idx) const;\n-\n-  \/\/ Return the index of the last set bit which is less or equal to start_idx.  If not found, return -1.\n-  inline ssize_t find_prev_set_bit(ssize_t last_idx) const;\n-\n-  \/\/ Return the index of the last set bit which is less or equal to start_idx and greater than boundary_idx.\n-  \/\/ If not found, return boundary_idx.\n-  inline ssize_t find_prev_set_bit(ssize_t last_idx, ssize_t boundary_idx) const;\n-\n-  \/\/ Return the smallest index at which a run of num_bits consecutive ones is found, where return value is >= start_idx\n-  \/\/ and return value < _num_bits.  If no run of num_bits consecutive ones is found within the target range, return _num_bits.\n-  inline ssize_t find_next_consecutive_bits(size_t num_bits, ssize_t start_idx) const;\n-\n-  \/\/ Return the smallest index at which a run of num_bits consecutive ones is found, where return value is >= start_idx\n-  \/\/ and return value < boundary_idx.  If no run of num_bits consecutive ones is found within the target range,\n-  \/\/ return boundary_idx.\n-  ssize_t find_next_consecutive_bits(size_t num_bits, ssize_t start_idx, ssize_t boundary_idx) const;\n-\n-  \/\/ Return the largest index at which a run of num_bits consecutive ones is found, where return value is <= last_idx and > -1.\n-  \/\/ If no run of num_bits consecutive ones is found within the target range, return -1.\n-  inline ssize_t find_prev_consecutive_bits(size_t num_bits, ssize_t last_idx) const;\n-\n-  \/\/ Return the largest index at which a run of num_bits consecutive ones is found, where return value is <= last_idx and > -1.\n-  \/\/ If no run of num_bits consecutive ones is found within the target range, return -1.\n-  ssize_t find_prev_consecutive_bits(size_t num_bits, ssize_t last_idx, ssize_t boundary_idx) const;\n-};\n+#include \"gc\/shenandoah\/shenandoahSimpleBitMap.hpp\"\n@@ -165,1 +34,1 @@\n-enum ShenandoahFreeSetPartitionId : uint8_t {\n+enum class ShenandoahFreeSetPartitionId : uint8_t {\n@@ -173,1 +42,1 @@\n-#define NumPartitions NotFree\n+#define NumPartitions int(ShenandoahFreeSetPartitionId::NotFree)\n@@ -230,1 +99,1 @@\n-    _membership[p].set_bit(idx);\n+    _membership[int(p)].set_bit(idx);\n@@ -274,1 +143,1 @@\n-    return _membership[which_partition].is_set(idx);\n+    return _membership[int(which_partition)].is_set(idx);\n@@ -308,2 +177,2 @@\n-    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n-    return _capacity[which_partition];\n+    assert (int(which_partition) < NumPartitions, \"selected free set must be valid\");\n+    return _capacity[int(which_partition)];\n@@ -313,2 +182,2 @@\n-    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n-    return _used[which_partition];\n+    assert (int(which_partition) < NumPartitions, \"selected free set must be valid\");\n+    return _used[int(which_partition)];\n@@ -318,2 +187,2 @@\n-    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n-    return _capacity[which_partition] - _used[which_partition];\n+    assert (int(which_partition) < NumPartitions, \"selected free set must be valid\");\n+    return _capacity[int(which_partition)] - _used[int(which_partition)];\n@@ -323,2 +192,2 @@\n-    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n-    _capacity[which_partition] = value;\n+    assert (int(which_partition) < NumPartitions, \"selected free set must be valid\");\n+    _capacity[int(which_partition)] = value;\n@@ -328,2 +197,2 @@\n-    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n-    _used[which_partition] = value;\n+    assert (int(which_partition) < NumPartitions, \"selected free set must be valid\");\n+    _used[int(which_partition)] = value;\n@@ -332,1 +201,1 @@\n-  inline size_t count(ShenandoahFreeSetPartitionId which_partition) const { return _region_counts[which_partition]; }\n+  inline size_t count(ShenandoahFreeSetPartitionId which_partition) const { return _region_counts[int(which_partition)]; }\n@@ -469,2 +338,2 @@\n-  inline size_t capacity()  const { return _partitions.capacity_of(Mutator); }\n-  inline size_t used()      const { return _partitions.used_by(Mutator);     }\n+  inline size_t capacity()  const { return _partitions.capacity_of(ShenandoahFreeSetPartitionId::Mutator); }\n+  inline size_t used()      const { return _partitions.used_by(ShenandoahFreeSetPartitionId::Mutator);     }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":18,"deletions":149,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2016, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shenandoah\/shenandoahSimpleBitMap.hpp\"\n+\n+size_t ShenandoahSimpleBitMap::count_leading_ones(ssize_t start_idx) const {\n+  assert((start_idx >= 0) && (start_idx < _num_bits), \"precondition\");\n+  size_t array_idx = start_idx >> LogBitsPerWord;\n+  uintx element_bits = _bitmap[array_idx];\n+  uintx bit_number = start_idx & right_n_bits(LogBitsPerWord);\n+  uintx omit_mask = right_n_bits(bit_number);\n+  uintx mask = ((uintx) 0 - 1) & ~omit_mask;\n+  if ((element_bits & mask) == mask) {\n+    size_t counted_ones = BitsPerWord - bit_number;\n+    return counted_ones + count_leading_ones(start_idx - counted_ones);\n+  } else {\n+    \/\/ Return number of consecutive ones starting with the_bit and including more significant bits.\n+    uintx aligned = element_bits >> bit_number;\n+    uintx complement = ~aligned;;\n+    return count_trailing_zeros<uintx>(complement);\n+  }\n+}\n+\n+size_t ShenandoahSimpleBitMap::count_trailing_ones(ssize_t last_idx) const {\n+  assert((last_idx >= 0) && (last_idx < _num_bits), \"precondition\");\n+  size_t array_idx = last_idx >> LogBitsPerWord;\n+  uintx element_bits = _bitmap[array_idx];\n+  uintx bit_number = last_idx & right_n_bits(LogBitsPerWord);\n+  \/\/ All ones from bit 0 to the_bit\n+  uintx mask = right_n_bits(bit_number + 1);\n+  if ((element_bits & mask) == mask) {\n+    size_t counted_ones = bit_number + 1;\n+    return counted_ones + count_trailing_ones(last_idx - counted_ones);\n+  } else {\n+    \/\/ Return number of consecutive ones starting with the_bit and including less significant bits\n+    uintx aligned = element_bits << (BitsPerWord - (bit_number + 1));\n+    uintx complement = ~aligned;\n+    return count_leading_zeros<uintx>(complement);\n+  }\n+}\n+\n+bool ShenandoahSimpleBitMap::is_forward_consecutive_ones(ssize_t start_idx, ssize_t count) const {\n+  assert((start_idx >= 0) && (start_idx < _num_bits), \"precondition: start_idx: \" SSIZE_FORMAT \", count: \" SSIZE_FORMAT,\n+         start_idx, count);\n+  assert(start_idx + count <= (ssize_t) _num_bits, \"precondition\");\n+  size_t array_idx = start_idx >> LogBitsPerWord;\n+  uintx bit_number = start_idx & right_n_bits(LogBitsPerWord);\n+  uintx element_bits = _bitmap[array_idx];\n+  uintx bits_to_examine  = BitsPerWord - bit_number;\n+  element_bits >>= bit_number;\n+  uintx complement = ~element_bits;\n+  uintx trailing_ones;\n+  if (complement) {\n+    trailing_ones = count_trailing_zeros<uintx>(complement);\n+  } else {\n+    trailing_ones = bits_to_examine;\n+  }\n+  if (trailing_ones >= (uintx) count) {\n+    return true;\n+  } else if (trailing_ones == bits_to_examine) {\n+     \/\/ Tail recursion\n+    return is_forward_consecutive_ones(start_idx + bits_to_examine, count - bits_to_examine);\n+  } else {\n+    return false;\n+  }\n+}\n+\n+bool ShenandoahSimpleBitMap::is_backward_consecutive_ones(ssize_t last_idx, ssize_t count) const {\n+  assert((last_idx >= 0) && (last_idx < _num_bits), \"precondition\");\n+  assert(last_idx - count >= -1, \"precondition\");\n+  size_t array_idx = last_idx >> LogBitsPerWord;\n+  uintx bit_number = last_idx & right_n_bits(LogBitsPerWord);\n+  uintx element_bits = _bitmap[array_idx];\n+  uintx bits_to_examine = bit_number + 1;\n+  element_bits <<= (BitsPerWord - bits_to_examine);\n+  uintx complement = ~element_bits;\n+  uintx leading_ones;\n+  if (complement) {\n+    leading_ones = count_leading_zeros<uintx>(complement);\n+  } else {\n+    leading_ones = bits_to_examine;\n+  }\n+  if (leading_ones >= (uintx) count) {\n+    return true;\n+  } else if (leading_ones == bits_to_examine) {\n+    \/\/ Tail recursion\n+    return is_backward_consecutive_ones(last_idx - leading_ones, count - leading_ones);\n+  } else {\n+    return false;\n+  }\n+}\n+\n+ssize_t ShenandoahSimpleBitMap::find_next_consecutive_bits(size_t num_bits, ssize_t start_idx, ssize_t boundary_idx) const {\n+  assert((start_idx >= 0) && (start_idx < _num_bits), \"precondition\");\n+\n+  \/\/ Stop looking if there are not num_bits remaining in probe space.\n+  ssize_t start_boundary = boundary_idx - num_bits;\n+  if (start_idx > start_boundary) {\n+    return boundary_idx;\n+  }\n+  uintx array_idx = start_idx >> LogBitsPerWord;\n+  uintx bit_number = start_idx & right_n_bits(LogBitsPerWord);\n+  uintx element_bits = _bitmap[array_idx];\n+  if (bit_number > 0) {\n+    uintx mask_out = right_n_bits(bit_number);\n+    element_bits &= ~mask_out;\n+  }\n+  while (true) {\n+    if (!element_bits) {\n+      \/\/ move to the next element\n+      start_idx += BitsPerWord - bit_number;\n+      if (start_idx > start_boundary) {\n+        \/\/ No match found.\n+        return boundary_idx;\n+      }\n+      array_idx++;\n+      bit_number = 0;\n+      element_bits = _bitmap[array_idx];\n+    } else if (is_forward_consecutive_ones(start_idx, num_bits)) {\n+      return start_idx;\n+    } else {\n+      \/\/ There is at least one non-zero bit within the masked element_bits.  Find it.\n+      uintx next_set_bit = count_trailing_zeros<uintx>(element_bits);\n+      uintx next_start_candidate_1 = (array_idx << LogBitsPerWord) + next_set_bit;\n+\n+      \/\/ There is at least one zero bit in this span.  Align the next probe at the start of trailing ones for probed span.\n+      size_t trailing_ones = count_trailing_ones(start_idx + num_bits - 1);\n+      uintx next_start_candidate_2 = start_idx + num_bits - trailing_ones;\n+\n+      start_idx = MAX2(next_start_candidate_1, next_start_candidate_2);\n+      if (start_idx > start_boundary) {\n+        \/\/ No match found.\n+        return boundary_idx;\n+      }\n+      array_idx = start_idx >> LogBitsPerWord;\n+      element_bits = _bitmap[array_idx];\n+      bit_number = start_idx & right_n_bits(LogBitsPerWord);\n+      if (bit_number > 0) {\n+        size_t mask_out = right_n_bits(bit_number);\n+        element_bits &= ~mask_out;\n+      }\n+    }\n+  }\n+}\n+\n+ssize_t ShenandoahSimpleBitMap::find_prev_consecutive_bits(\n+  const size_t num_bits, ssize_t last_idx, const ssize_t boundary_idx) const {\n+  assert((last_idx >= 0) && (last_idx < _num_bits), \"precondition\");\n+\n+  \/\/ Stop looking if there are not num_bits remaining in probe space.\n+  ssize_t last_boundary = boundary_idx + num_bits;\n+  if (last_idx < last_boundary) {\n+    return boundary_idx;\n+  }\n+\n+  size_t array_idx = last_idx >> LogBitsPerWord;\n+  uintx bit_number = last_idx & right_n_bits(LogBitsPerWord);\n+  uintx element_bits = _bitmap[array_idx];\n+  if (bit_number < BitsPerWord - 1) {\n+    uintx mask_in = right_n_bits(bit_number + 1);\n+    element_bits &= mask_in;\n+  }\n+  while (true) {\n+    if (!element_bits) {\n+      \/\/ move to the previous element\n+      last_idx -= bit_number + 1;\n+      if (last_idx < last_boundary) {\n+        \/\/ No match found.\n+        return boundary_idx;\n+      }\n+      array_idx--;\n+      bit_number = BitsPerWord - 1;\n+      element_bits = _bitmap[array_idx];\n+    } else if (is_backward_consecutive_ones(last_idx, num_bits)) {\n+      return last_idx + 1 - num_bits;\n+    } else {\n+      \/\/ There is at least one non-zero bit within the masked element_bits.  Find it.\n+      uintx next_set_bit = BitsPerWord - (1 + count_leading_zeros<uintx>(element_bits));\n+      uintx next_last_candidate_1 = (array_idx << LogBitsPerWord) + next_set_bit;\n+\n+      \/\/ There is at least one zero bit in this span.  Align the next probe at the end of leading ones for probed span.\n+      size_t leading_ones = count_leading_ones(last_idx - (num_bits - 1));\n+      uintx next_last_candidate_2 = last_idx - (num_bits - leading_ones);\n+\n+      last_idx = MIN2(next_last_candidate_1, next_last_candidate_2);\n+      if (last_idx < last_boundary) {\n+        \/\/ No match found.\n+        return boundary_idx;\n+      }\n+      array_idx = last_idx >> LogBitsPerWord;\n+      bit_number = last_idx & right_n_bits(LogBitsPerWord);\n+      element_bits = _bitmap[array_idx];\n+      if (bit_number < BitsPerWord - 1){\n+        size_t mask_in = right_n_bits(bit_number + 1);\n+        element_bits &= mask_in;\n+      }\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSimpleBitMap.cpp","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2016, 2019, Red Hat, Inc. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHSIMPLEBITMAP_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHSIMPLEBITMAP_HPP\n+\n+\/\/ The API and internal implementation of ShenandoahSimpleBitMap and ShenandoahRegionPartitions use ssize_t to\n+\/\/ represent index, even though index is \"inherently\" unsigned.  There are two reasons for this choice:\n+\/\/  1. We use -1 as a sentinel value to represent empty partitions.  This same value may be used to represent\n+\/\/     failure to find a previous set bit or previous range of set bits.\n+\/\/  2. Certain loops are written most naturally if the iterator, which may hold the sentinel -1 value, can be\n+\/\/     declared as signed and the terminating condition can be < 0.\n+\n+\/\/ ShenandoahSimpleBitMap resembles CHeapBitMap but adds missing support for find_next_consecutive_bits() and\n+\/\/ find_prev_contiguous_bits.  An alternative refactoring of code would subclass CHeapBitMap, but this might\n+\/\/ break abstraction rules, because efficient implementation requires assumptions about superclass internals that\n+\/\/ might be violatee through future software maintenance.\n+class ShenandoahSimpleBitMap {\n+  const ssize_t _num_bits;\n+  const size_t _num_words;\n+  uintx* const _bitmap;\n+\n+public:\n+  ShenandoahSimpleBitMap(size_t num_bits) :\n+      _num_bits(num_bits),\n+      _num_words((num_bits + (BitsPerWord - 1)) \/ BitsPerWord),\n+      _bitmap(NEW_C_HEAP_ARRAY(uintx, _num_words, mtGC))\n+  {\n+    clear_all();\n+  }\n+\n+  ~ShenandoahSimpleBitMap() {\n+    if (_bitmap != nullptr) {\n+      FREE_C_HEAP_ARRAY(uintx, _bitmap);\n+    }\n+  }\n+  void clear_all() {\n+    for (size_t i = 0; i < _num_words; i++) {\n+      _bitmap[i] = 0;\n+    }\n+  }\n+\n+private:\n+\n+  \/\/ Count consecutive ones in forward order, starting from start_idx.  Requires that there is at least one zero\n+  \/\/ between start_idx and index value (_num_bits - 1), inclusive.\n+  size_t count_leading_ones(ssize_t start_idx) const;\n+\n+  \/\/ Count consecutive ones in reverse order, starting from last_idx.  Requires that there is at least one zero\n+  \/\/ between last_idx and index value zero, inclusive.\n+  size_t count_trailing_ones(ssize_t last_idx) const;\n+\n+  bool is_forward_consecutive_ones(ssize_t start_idx, ssize_t count) const;\n+  bool is_backward_consecutive_ones(ssize_t last_idx, ssize_t count) const;\n+\n+public:\n+\n+  inline ssize_t aligned_index(ssize_t idx) const {\n+    assert((idx >= 0) && (idx < _num_bits), \"precondition\");\n+    ssize_t array_idx = idx & ~right_n_bits(LogBitsPerWord);\n+    return array_idx;\n+  }\n+\n+  inline ssize_t alignment() const {\n+    return BitsPerWord;\n+  }\n+\n+  \/\/ For testing\n+  inline ssize_t number_of_bits() const {\n+    return _num_bits;\n+  }\n+\n+  inline uintx bits_at(ssize_t idx) const {\n+    assert((idx >= 0) && (idx < _num_bits), \"precondition\");\n+    ssize_t array_idx = idx >> LogBitsPerWord;\n+    return _bitmap[array_idx];\n+  }\n+\n+  inline void set_bit(ssize_t idx) {\n+    assert((idx >= 0) && (idx < _num_bits), \"precondition\");\n+    size_t array_idx = idx >> LogBitsPerWord;\n+    uintx bit_number = idx & right_n_bits(LogBitsPerWord);\n+    uintx the_bit = nth_bit(bit_number);\n+    _bitmap[array_idx] |= the_bit;\n+  }\n+\n+  inline void clear_bit(ssize_t idx) {\n+    assert((idx >= 0) && (idx < _num_bits), \"precondition\");\n+    assert(idx >= 0, \"precondition\");\n+    size_t array_idx = idx >> LogBitsPerWord;\n+    uintx bit_number = idx & right_n_bits(LogBitsPerWord);\n+    uintx the_bit = nth_bit(bit_number);\n+    _bitmap[array_idx] &= ~the_bit;\n+  }\n+\n+  inline bool is_set(ssize_t idx) const {\n+    assert((idx >= 0) && (idx < _num_bits), \"precondition\");\n+    assert(idx >= 0, \"precondition\");\n+    size_t array_idx = idx >> LogBitsPerWord;\n+    uintx bit_number = idx & right_n_bits(LogBitsPerWord);\n+    uintx the_bit = nth_bit(bit_number);\n+    return (_bitmap[array_idx] & the_bit)? true: false;\n+  }\n+\n+  \/\/ Return the index of the first set bit which is greater or equal to start_idx.  If not found, return _num_bits.\n+  inline ssize_t find_next_set_bit(ssize_t start_idx) const;\n+\n+  \/\/ Return the index of the first set bit which is greater or equal to start_idx and less than boundary_idx.\n+  \/\/ If not found, return boundary_idx\n+  inline ssize_t find_next_set_bit(ssize_t start_idx, ssize_t boundary_idx) const;\n+\n+  \/\/ Return the index of the last set bit which is less or equal to start_idx.  If not found, return -1.\n+  inline ssize_t find_prev_set_bit(ssize_t last_idx) const;\n+\n+  \/\/ Return the index of the last set bit which is less or equal to start_idx and greater than boundary_idx.\n+  \/\/ If not found, return boundary_idx.\n+  inline ssize_t find_prev_set_bit(ssize_t last_idx, ssize_t boundary_idx) const;\n+\n+  \/\/ Return the smallest index at which a run of num_bits consecutive ones is found, where return value is >= start_idx\n+  \/\/ and return value < _num_bits.  If no run of num_bits consecutive ones is found within the target range, return _num_bits.\n+  inline ssize_t find_next_consecutive_bits(size_t num_bits, ssize_t start_idx) const;\n+\n+  \/\/ Return the smallest index at which a run of num_bits consecutive ones is found, where return value is >= start_idx\n+  \/\/ and return value < boundary_idx.  If no run of num_bits consecutive ones is found within the target range,\n+  \/\/ return boundary_idx.\n+  ssize_t find_next_consecutive_bits(size_t num_bits, ssize_t start_idx, ssize_t boundary_idx) const;\n+\n+  \/\/ Return the largest index at which a run of num_bits consecutive ones is found, where return value is <= last_idx and > -1.\n+  \/\/ If no run of num_bits consecutive ones is found within the target range, return -1.\n+  inline ssize_t find_prev_consecutive_bits(size_t num_bits, ssize_t last_idx) const;\n+\n+  \/\/ Return the largest index at which a run of num_bits consecutive ones is found, where return value is <= last_idx and > -1.\n+  \/\/ If no run of num_bits consecutive ones is found within the target range, return -1.\n+  ssize_t find_prev_consecutive_bits(size_t num_bits, ssize_t last_idx, ssize_t boundary_idx) const;\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHSIMPLEBITMAP_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSimpleBitMap.hpp","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -26,2 +26,2 @@\n-#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHFREESET_INLINE_HPP\n-#define SHARE_GC_SHENANDOAH_SHENANDOAHFREESET_INLINE_HPP\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHSIMPLEBITMAP_INLINE_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHSIMPLEBITMAP_INLINE_HPP\n@@ -29,1 +29,1 @@\n-#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahSimpleBitMap.hpp\"\n@@ -101,1 +101,1 @@\n-#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHFREESET_INLINE_HPP\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHSIMPLEBITMAP_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSimpleBitMap.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.inline.hpp","status":"renamed"},{"patch":"@@ -26,2 +26,2 @@\n-#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n-#include \"gc\/shenandoah\/shenandoahFreeSet.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahSimpleBitMap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahSimpleBitMap.inline.hpp\"\n@@ -29,0 +29,1 @@\n+#include <iostream>\n@@ -30,1 +31,0 @@\n-\n@@ -32,1 +32,0 @@\n-#include <iostream>\n@@ -34,1 +33,0 @@\n-\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahSimpleBitMap.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"}]}