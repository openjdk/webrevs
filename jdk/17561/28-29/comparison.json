{"files":[{"patch":"@@ -46,2 +46,0 @@\n-\/\/ Count consecutive ones in forward order, starting from start_idx.  Requires that there is at least one zero\n-\/\/ between start_idx and index value _num_bits - 1 inclusive.\n@@ -50,1 +48,1 @@\n-  size_t array_idx = start_idx \/ _bits_per_array_element;\n+  size_t array_idx = start_idx >> LogBitsPerWord;\n@@ -52,4 +50,4 @@\n-  size_t bit_number = start_idx % _bits_per_array_element;\n-  size_t the_bit = ((size_t) 0x01) << bit_number;\n-  size_t omit_mask = the_bit - 1;\n-  size_t mask = ((size_t) ((ssize_t) -1)) & ~omit_mask;\n+  size_t bit_number = start_idx & right_n_bits(LogBitsPerWord);\n+  size_t the_bit = nth_bit(bit_number);\n+  size_t omit_mask = right_n_bits(bit_number);\n+  size_t mask = right_n_bits(BitsPerWord) & ~omit_mask;\n@@ -58,1 +56,1 @@\n-    size_t counted_ones = _bits_per_array_element - bit_number;\n+    size_t counted_ones = BitsPerWord - bit_number;\n@@ -69,2 +67,0 @@\n-\/\/ Count consecutive ones in reverse order, starting from last_idx.  Requires that there is at least one zero\n-\/\/ between last_idx and index value zero, inclusive.\n@@ -73,1 +69,1 @@\n-  size_t array_idx = last_idx \/ _bits_per_array_element;\n+  size_t array_idx = last_idx >> LogBitsPerWord;\n@@ -75,2 +71,2 @@\n-  size_t bit_number = last_idx % _bits_per_array_element;\n-  size_t the_bit = ((size_t) 0x01) << bit_number;\n+  size_t bit_number = last_idx & right_n_bits(LogBitsPerWord);\n+  size_t the_bit = nth_bit(bit_number);\n@@ -79,1 +75,1 @@\n-  size_t mask = (the_bit * 2) - 1;\n+  size_t mask = right_n_bits(bit_number + 1);\n@@ -96,3 +92,3 @@\n-  size_t array_idx = start_idx \/ _bits_per_array_element;\n-  size_t bit_number = start_idx % _bits_per_array_element;\n-  size_t the_bit = ((size_t) 0x01) << bit_number;\n+  size_t array_idx = start_idx >> LogBitsPerWord;\n+  size_t bit_number = start_idx & right_n_bits(LogBitsPerWord);\n+  size_t the_bit = nth_bit(bit_number);\n@@ -100,1 +96,1 @@\n-  if ((ssize_t) (bit_number + count <= _bits_per_array_element)) {\n+  if ((ssize_t) (bit_number + count <= BitsPerWord)) {\n@@ -102,3 +98,3 @@\n-    size_t overreach_mask =\n-      (bit_number + count == _bits_per_array_element)? ~((size_t) 0): ((size_t) 0x1 << (bit_number + count)) - 1;\n-    size_t exclude_mask = ((size_t) 0x1 << bit_number) - 1;\n+    size_t relevant_bits = bit_number + count;\n+    size_t overreach_mask = right_n_bits(relevant_bits);\n+    size_t exclude_mask = right_n_bits(bit_number);\n@@ -109,2 +105,2 @@\n-    size_t overreach_mask = (size_t) (ssize_t) - 1;\n-    size_t exclude_mask = ((size_t) 0x1 << bit_number) - 1;\n+    size_t overreach_mask = right_n_bits(BitsPerWord);\n+    size_t exclude_mask = right_n_bits(bit_number);\n@@ -113,1 +109,1 @@\n-      size_t matched_bits = _bits_per_array_element - bit_number;\n+      size_t matched_bits = BitsPerWord - bit_number;\n@@ -124,3 +120,3 @@\n-  size_t array_idx = last_idx \/ _bits_per_array_element;\n-  size_t bit_number = last_idx % _bits_per_array_element;\n-  size_t the_bit = ((size_t) 0x01) << bit_number;\n+  size_t array_idx = last_idx >> LogBitsPerWord;\n+  size_t bit_number = last_idx & right_n_bits(LogBitsPerWord);\n+  size_t the_bit = nth_bit(bit_number);\n@@ -130,2 +126,2 @@\n-    size_t overreach_mask = (bit_number == _bits_per_array_element - 1)? ~((size_t) 0): ((size_t) 0x1 << (bit_number + 1)) - 1;\n-    size_t exclude_mask = ((size_t) 0x1 << (bit_number + 1 - count)) - 1;\n+    size_t overreach_mask = right_n_bits(bit_number + 1);\n+    size_t exclude_mask = right_n_bits(bit_number + 1 - count);\n@@ -136,1 +132,1 @@\n-    size_t exact_mask = ((size_t) 0x1 << (bit_number + 1)) - 1;\n+    size_t exact_mask = right_n_bits(bit_number + 1);\n@@ -146,1 +142,0 @@\n-\n@@ -152,2 +147,2 @@\n-  size_t array_idx = start_idx \/ _bits_per_array_element;\n-  size_t bit_number = start_idx % _bits_per_array_element;\n+  size_t array_idx = start_idx >> LogBitsPerWord;\n+  size_t bit_number = start_idx & right_n_bits(LogBitsPerWord);\n@@ -156,1 +151,1 @@\n-    size_t mask_out = (((size_t) 0x01) << bit_number) - 1;\n+    size_t mask_out = right_n_bits(bit_number);\n@@ -163,1 +158,1 @@\n-      start_idx += _bits_per_array_element - bit_number;\n+      start_idx += BitsPerWord - bit_number;\n@@ -173,1 +168,1 @@\n-      array_idx = start_idx \/ _bits_per_array_element;\n+      array_idx = start_idx >> LogBitsPerWord;\n@@ -175,1 +170,1 @@\n-      bit_number = start_idx % _bits_per_array_element;\n+      bit_number = start_idx & right_n_bits(LogBitsPerWord);\n@@ -177,1 +172,1 @@\n-        size_t mask_out = (((size_t) 0x01) << bit_number) - 1;\n+        size_t mask_out = right_n_bits(bit_number);\n@@ -192,2 +187,2 @@\n-  ssize_t array_idx = last_idx \/ _bits_per_array_element;\n-  size_t bit_number = last_idx % _bits_per_array_element;\n+  ssize_t array_idx = last_idx >> LogBitsPerWord;\n+  size_t bit_number = last_idx & right_n_bits(LogBitsPerWord);\n@@ -195,2 +190,2 @@\n-  if (bit_number < _bits_per_array_element - 1) {\n-    size_t mask_in = (((size_t) 0x1) << (bit_number + 1)) - 1;\n+  if (bit_number < BitsPerWord - 1) {\n+    size_t mask_in = right_n_bits(bit_number + 1);\n@@ -204,1 +199,1 @@\n-      bit_number = _bits_per_array_element - 1;\n+      bit_number = BitsPerWord - 1;\n@@ -212,2 +207,2 @@\n-      array_idx = last_idx \/ _bits_per_array_element;\n-      bit_number = last_idx % _bits_per_array_element;\n+      array_idx = last_idx >> LogBitsPerWord;\n+      bit_number = last_idx & right_n_bits(LogBitsPerWord);\n@@ -215,2 +210,2 @@\n-      if (bit_number < _bits_per_array_element - 1){\n-        size_t mask_in = (((size_t) 0x1) << (bit_number + 1)) - 1;\n+      if (bit_number < BitsPerWord - 1){\n+        size_t mask_in = right_n_bits(bit_number + 1);\n@@ -276,3 +271,0 @@\n-\/\/ Returns true iff this region is entirely available, either because it is empty() or because it has been found to represent\n-\/\/ immediate trash and we'll be able to immediately recycle it.  Note that we cannot recycle immediate trash if\n-\/\/ concurrent weak root processing is in progress.\n@@ -401,2 +393,0 @@\n-\n-\n@@ -457,2 +447,0 @@\n-\/\/ Remove the consecutive regions between low_idx and high_idx inclusive from partition since all of these will be subsumed\n-\/\/ by a humongous object.  The entirety of each retired region is assumed to equal the region size.\n@@ -475,2 +463,0 @@\n-\/\/ Remove this region from its free partition, but leave its capacity and used as part of the original free partition's totals.\n-\/\/ When retiring a region, add any remnant of available memory within the region to the used total for the original free partition.\n@@ -568,1 +554,0 @@\n-\/\/ Returns true iff region idx is in the test_partition, which must not equal NotFree.\n@@ -582,1 +567,0 @@\n-  \/\/ Return the index of the next available region >= start_index, or maximum_regions if not found.\n@@ -595,1 +579,0 @@\n-\/\/ Return the index of the previous available region <= last_index, or -1 if not found.\n@@ -609,1 +592,0 @@\n-\/\/ Return the index of the next available cluster of cluster_size regions >= start_index, or maximum_regions if not found.\n@@ -619,1 +601,0 @@\n-\/\/ Return the index of the previous available cluster of cluster_size regions <= last_index, or -1 if not found.\n@@ -1121,4 +1102,0 @@\n-\/\/ This function places all regions that have allocation capacity into the mutator_partition, identifying regions\n-\/\/ that have no allocation capacity as NotFree.  Subsequently, we will move some of the mutator regions into the\n-\/\/ collector partition with the intent of packing collector memory into the highest (rightmost) addresses of the\n-\/\/ heap, with mutator memory consuming the lowest addresses of the heap.\n@@ -1182,6 +1159,0 @@\n-\/\/ Move no more than max_xfer_regions from the existing Collector partition to the Mutator partition.\n-\/\/\n-\/\/ This is called from outside the heap lock at the start of update refs.  At this point, we no longer\n-\/\/ need to reserve memory for evacuation.  (We will create a new reserve after update refs finishes,\n-\/\/ setting aside some of the memory that was reclaimed by the most recent GC.  This new reserve will satisfy\n-\/\/ the evacuation needs of the next GC pass.)\n@@ -1230,2 +1201,0 @@\n-\n-\/\/ Overwrite arguments to represent the number of regions to be reclaimed from the cset\n@@ -1267,3 +1236,0 @@\n-\/\/ Having placed all regions that have allocation capacity into the mutator partition, move some of these regions from\n-\/\/ the mutator partition into the collector partition in order to assure that the memory available for allocations within\n-\/\/ the collector partition is at least to_reserve.\n@@ -1498,21 +1464,0 @@\n-\/*\n- * Internal fragmentation metric: describes how fragmented the heap regions are.\n- *\n- * It is derived as:\n- *\n- *               sum(used[i]^2, i=0..k)\n- *   IF = 1 - ------------------------------\n- *              C * sum(used[i], i=0..k)\n- *\n- * ...where k is the number of regions in computation, C is the region capacity, and\n- * used[i] is the used space in the region.\n- *\n- * The non-linearity causes IF to be lower for the cases where the same total heap\n- * used is densely packed. For example:\n- *   a) Heap is completely full  => IF = 0\n- *   b) Heap is half full, first 50% regions are completely full => IF = 0\n- *   c) Heap is half full, each region is 50% full => IF = 1\/2\n- *   d) Heap is quarter full, first 50% regions are completely full => IF = 0\n- *   e) Heap is quarter full, each region is 25% full => IF = 3\/4\n- *   f) Heap has one small object per each region => IF =~ 1\n- *\/\n@@ -1543,13 +1488,0 @@\n-\/*\n- * External fragmentation metric: describes how fragmented the heap is.\n- *\n- * It is derived as:\n- *\n- *   EF = 1 - largest_contiguous_free \/ total_free\n- *\n- * For example:\n- *   a) Heap is completely empty => EF = 0\n- *   b) Heap is completely full => EF = 0\n- *   c) Heap is first-half full => EF = 1\/2\n- *   d) Heap is half full, full and empty regions interleave => EF =~ 1\n- *\/\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":42,"deletions":110,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -46,2 +46,0 @@\n-  static const size_t _bits_per_array_element = HeapWordSize * 8;\n-\n@@ -55,1 +53,1 @@\n-      _num_words((num_bits + (_bits_per_array_element - 1)) \/ _bits_per_array_element),\n+      _num_words((num_bits + (BitsPerWord - 1)) \/ BitsPerWord),\n@@ -89,2 +87,2 @@\n-    ssize_t array_idx = idx \/ _bits_per_array_element;\n-    return array_idx * _bits_per_array_element;\n+    ssize_t array_idx = idx & ~right_n_bits(LogBitsPerWord);\n+    return array_idx;\n@@ -94,1 +92,1 @@\n-    return _bits_per_array_element;\n+    return BitsPerWord;\n@@ -104,1 +102,1 @@\n-    ssize_t array_idx = idx \/ _bits_per_array_element;\n+    ssize_t array_idx = idx >> LogBitsPerWord;\n@@ -110,3 +108,3 @@\n-    size_t array_idx = idx \/ _bits_per_array_element;\n-    size_t bit_number = idx % _bits_per_array_element;\n-    size_t the_bit = ((size_t) 0x01) << bit_number;\n+    size_t array_idx = idx >> LogBitsPerWord;\n+    size_t bit_number = idx & right_n_bits(LogBitsPerWord);\n+    size_t the_bit = nth_bit(bit_number);\n@@ -119,3 +117,3 @@\n-    size_t array_idx = idx \/ _bits_per_array_element;\n-    size_t bit_number = idx % _bits_per_array_element;\n-    size_t the_bit = ((size_t) 0x01) << bit_number;\n+    size_t array_idx = idx >> LogBitsPerWord;\n+    size_t bit_number = idx & right_n_bits(LogBitsPerWord);\n+    size_t the_bit = nth_bit(bit_number);\n@@ -128,3 +126,3 @@\n-    size_t array_idx = idx \/ _bits_per_array_element;\n-    size_t bit_number = idx % _bits_per_array_element;\n-    size_t the_bit = ((size_t) 0x01) << bit_number;\n+    size_t array_idx = idx >> LogBitsPerWord;\n+    size_t bit_number = idx & right_n_bits(LogBitsPerWord);\n+    size_t the_bit = nth_bit(bit_number);\n@@ -241,3 +239,3 @@\n-  \/\/ Retire region idx from within partition.  Requires that region idx is in in the Mutator or Collector partitions.\n-  \/\/ Hereafter, identifies this region as NotFree.  Any remnant of available memory at the time of retirement is added to the\n-  \/\/ original partition's total of used bytes.\n+  \/\/ Retire region idx from within partition, , leaving its capacity and used as part of the original free partition's totals.\n+  \/\/ Requires that region idx is in in the Mutator or Collector partitions.  Hereafter, identifies this region as NotFree.\n+  \/\/ Any remnant of available memory at the time of retirement is added to the original partition's total of used bytes.\n@@ -419,0 +417,3 @@\n+  \/\/ Returns true iff this region is entirely available, either because it is empty() or because it has been found to represent\n+  \/\/ immediate trash and we'll be able to immediately recycle it.  Note that we cannot recycle immediate trash if\n+  \/\/ concurrent weak root processing is in progress.\n@@ -424,0 +425,4 @@\n+  \/\/ This function places all regions that have allocation capacity into the mutator_partition, identifying regions\n+  \/\/ that have no allocation capacity as NotFree.  Subsequently, we will move some of the mutator regions into the\n+  \/\/ collector partition with the intent of packing collector memory into the highest (rightmost) addresses of the\n+  \/\/ heap, with mutator memory consuming the lowest addresses of the heap.\n@@ -425,0 +430,4 @@\n+\n+  \/\/ Having placed all regions that have allocation capacity into the mutator partition, move some of these regions from\n+  \/\/ the mutator partition into the collector partition in order to assure that the memory available for allocations within\n+  \/\/ the collector partition is at least to_reserve.\n@@ -427,0 +436,1 @@\n+  \/\/ Overwrite arguments to represent the number of regions to be reclaimed from the cset\n@@ -428,0 +438,1 @@\n+\n@@ -468,0 +479,21 @@\n+  \/*\n+   * Internal fragmentation metric: describes how fragmented the heap regions are.\n+   *\n+   * It is derived as:\n+   *\n+   *               sum(used[i]^2, i=0..k)\n+   *   IF = 1 - ------------------------------\n+   *              C * sum(used[i], i=0..k)\n+   *\n+   * ...where k is the number of regions in computation, C is the region capacity, and\n+   * used[i] is the used space in the region.\n+   *\n+   * The non-linearity causes IF to be lower for the cases where the same total heap\n+   * used is densely packed. For example:\n+   *   a) Heap is completely full  => IF = 0\n+   *   b) Heap is half full, first 50% regions are completely full => IF = 0\n+   *   c) Heap is half full, each region is 50% full => IF = 1\/2\n+   *   d) Heap is quarter full, first 50% regions are completely full => IF = 0\n+   *   e) Heap is quarter full, each region is 25% full => IF = 3\/4\n+   *   f) Heap has one small object per each region => IF =~ 1\n+   *\/\n@@ -469,0 +501,14 @@\n+\n+  \/*\n+   * External fragmentation metric: describes how fragmented the heap is.\n+   *\n+   * It is derived as:\n+   *\n+   *   EF = 1 - largest_contiguous_free \/ total_free\n+   *\n+   * For example:\n+   *   a) Heap is completely empty => EF = 0\n+   *   b) Heap is completely full => EF = 0\n+   *   c) Heap is first-half full => EF = 1\/2\n+   *   d) Heap is half full, full and empty regions interleave => EF =~ 1\n+   *\/\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":65,"deletions":19,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-    size_t array_idx = start_idx \/ _bits_per_array_element;\n-    size_t bit_number = start_idx % _bits_per_array_element;\n+    size_t array_idx = start_idx >> LogBitsPerWord;\n+    size_t bit_number = start_idx & right_n_bits(LogBitsPerWord);\n@@ -39,1 +39,1 @@\n-      size_t mask_out = (((size_t) 0x01) << bit_number) - 1;\n+      size_t mask_out = right_n_bits(bit_number);\n@@ -44,2 +44,2 @@\n-      size_t the_bit = ((size_t) 0x01) << bit_number;\n-      while (bit_number < _bits_per_array_element) {\n+      size_t the_bit = nth_bit(bit_number);\n+      while (bit_number < BitsPerWord) {\n@@ -47,1 +47,1 @@\n-          ssize_t candidate_result = (array_idx * _bits_per_array_element) + bit_number;\n+          ssize_t candidate_result = (array_idx * BitsPerWord) + bit_number;\n@@ -58,1 +58,1 @@\n-      start_idx += _bits_per_array_element - bit_number;\n+      start_idx += BitsPerWord - bit_number;\n@@ -73,2 +73,2 @@\n-    ssize_t array_idx = last_idx \/ _bits_per_array_element;\n-    size_t bit_number = last_idx % _bits_per_array_element;\n+    ssize_t array_idx = last_idx >> LogBitsPerWord;\n+    size_t bit_number = last_idx & right_n_bits(LogBitsPerWord);\n@@ -76,2 +76,2 @@\n-    if (bit_number < _bits_per_array_element - 1){\n-      size_t mask_in = (((size_t) 0x1) << (bit_number + 1)) - 1;\n+    if (bit_number < BitsPerWord - 1){\n+      size_t mask_in = right_n_bits(bit_number + 1);\n@@ -82,2 +82,1 @@\n-      size_t the_bit = ((size_t) 0x01) << bit_number;\n-\n+      size_t the_bit = nth_bit(bit_number);\n@@ -86,1 +85,1 @@\n-          ssize_t candidate_result = (array_idx * _bits_per_array_element) + bit_number;\n+          ssize_t candidate_result = (array_idx * BitsPerWord) + bit_number;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.inline.hpp","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"}]}