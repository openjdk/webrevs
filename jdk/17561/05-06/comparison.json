{"files":[{"patch":"@@ -1001,0 +1001,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-ShenandoahRegionPartition::ShenandoahRegionPartition(size_t max_regions, ShenandoahFreeSet* free_set) :\n+ShenandoahRegionPartitions::ShenandoahRegionPartitions(size_t max_regions, ShenandoahFreeSet* free_set) :\n@@ -54,1 +54,1 @@\n-ShenandoahRegionPartition::~ShenandoahRegionPartition() {\n+ShenandoahRegionPartitions::~ShenandoahRegionPartitions() {\n@@ -88,1 +88,1 @@\n-void ShenandoahRegionPartition::make_all_regions_unavailable() {\n+void ShenandoahRegionPartitions::make_all_regions_unavailable() {\n@@ -103,1 +103,0 @@\n-  _region_counts[NotFree] = _max;\n@@ -106,2 +105,2 @@\n-void ShenandoahRegionPartition::increase_used(ShenandoahFreeSetPartitionId which_partition, size_t bytes) {\n-  assert (which_partition > NotFree && which_partition < NumPartitions, \"Partition must be valid\");\n+void ShenandoahRegionPartitions::increase_used(ShenandoahFreeSetPartitionId which_partition, size_t bytes) {\n+  assert (which_partition < NumPartitions, \"Partition must be valid\");\n@@ -114,1 +113,1 @@\n-inline void ShenandoahRegionPartition::shrink_interval_if_boundary_modified(ShenandoahFreeSetPartitionId partition, size_t idx) {\n+inline void ShenandoahRegionPartitions::shrink_interval_if_boundary_modified(ShenandoahFreeSetPartitionId partition, size_t idx) {\n@@ -116,1 +115,1 @@\n-    while ((_leftmosts[partition] < _max) && !in_partition(_leftmosts[partition], partition)) {\n+    while ((_leftmosts[partition] < _max) && !partition_id_matches(_leftmosts[partition], partition)) {\n@@ -125,1 +124,1 @@\n-    while (_rightmosts[partition] > 0 && !in_partition(_rightmosts[partition], partition)) {\n+    while (_rightmosts[partition] > 0 && !partition_id_matches(_rightmosts[partition], partition)) {\n@@ -135,1 +134,1 @@\n-inline void ShenandoahRegionPartition::expand_interval_if_boundary_modified(ShenandoahFreeSetPartitionId partition,\n+inline void ShenandoahRegionPartitions::expand_interval_if_boundary_modified(ShenandoahFreeSetPartitionId partition,\n@@ -155,1 +154,1 @@\n-void ShenandoahRegionPartition::retire_within_partition(size_t idx, size_t used_bytes) {\n+void ShenandoahRegionPartitions::retire_from_partition(size_t idx, size_t used_bytes) {\n@@ -160,1 +159,1 @@\n-  assert (orig_partition > NotFree && orig_partition < NumPartitions, \"Cannot remove from free partitions if not already free\");\n+  assert (orig_partition < NumPartitions, \"Cannot remove from free partitions if not already free\");\n@@ -171,1 +170,0 @@\n-  _region_counts[NotFree]++;\n@@ -174,1 +172,1 @@\n-void ShenandoahRegionPartition::make_free(size_t idx, ShenandoahFreeSetPartitionId which_partition, size_t available) {\n+void ShenandoahRegionPartitions::make_free(size_t idx, ShenandoahFreeSetPartitionId which_partition, size_t available) {\n@@ -177,1 +175,1 @@\n-  assert (which_partition > NotFree && which_partition < NumPartitions, \"selected free partition must be valid\");\n+  assert (which_partition < NumPartitions, \"selected free partition must be valid\");\n@@ -185,1 +183,0 @@\n-  _region_counts[NotFree]--;\n@@ -189,1 +186,1 @@\n-void ShenandoahRegionPartition::move_to_partition(size_t idx, ShenandoahFreeSetPartitionId new_partition, size_t available) {\n+void ShenandoahRegionPartitions::move_to_partition(size_t idx, ShenandoahFreeSetPartitionId new_partition, size_t available) {\n@@ -191,1 +188,1 @@\n-  assert ((new_partition > NotFree) && (new_partition < NumPartitions), \"New partition must be valid\");\n+  assert (new_partition < NumPartitions, \"New partition must be valid\");\n@@ -195,1 +192,1 @@\n-  assert ((orig_partition > NotFree) && (orig_partition < NumPartitions), \"Cannot move free unless already free\");\n+  assert (orig_partition < NumPartitions, \"Cannot move free unless already free\");\n@@ -222,1 +219,1 @@\n-inline ShenandoahFreeSetPartitionId ShenandoahRegionPartition::membership(size_t idx) const {\n+inline ShenandoahFreeSetPartitionId ShenandoahRegionPartitions::membership(size_t idx) const {\n@@ -227,3 +224,2 @@\n-  \/\/ Returns true iff region idx is in the test_partition free_partition.  Before returning true, asserts that the free\n-  \/\/ partition is not empty.  Requires that test_partition != NotFree or NumPartitions.\n-inline bool ShenandoahRegionPartition::in_partition(size_t idx, ShenandoahFreeSetPartitionId test_partition) const {\n+  \/\/ Returns true iff region idx is in the test_partition free_partition.\n+inline bool ShenandoahRegionPartitions::partition_id_matches(size_t idx, ShenandoahFreeSetPartitionId test_partition) const {\n@@ -232,1 +228,1 @@\n-    assert (test_partition == NotFree || _free_set->alloc_capacity(idx) > 0,\n+    assert ((test_partition == NotFree) || (_free_set->alloc_capacity(idx) > 0),\n@@ -241,2 +237,2 @@\n-inline size_t ShenandoahRegionPartition::leftmost(ShenandoahFreeSetPartitionId which_partition) const {\n-  assert (which_partition > NotFree && which_partition < NumPartitions, \"selected free partition must be valid\");\n+inline size_t ShenandoahRegionPartitions::leftmost(ShenandoahFreeSetPartitionId which_partition) const {\n+  assert (which_partition < NumPartitions, \"selected free partition must be valid\");\n@@ -247,1 +243,1 @@\n-    assert (in_partition(idx, which_partition), \"left-most region must be free\");\n+    assert (partition_id_matches(idx, which_partition), \"left-most region must be free\");\n@@ -252,2 +248,2 @@\n-inline size_t ShenandoahRegionPartition::rightmost(ShenandoahFreeSetPartitionId which_partition) const {\n-  assert (which_partition > NotFree && which_partition < NumPartitions, \"selected free partition must be valid\");\n+inline size_t ShenandoahRegionPartitions::rightmost(ShenandoahFreeSetPartitionId which_partition) const {\n+  assert (which_partition < NumPartitions, \"selected free partition must be valid\");\n@@ -255,1 +251,1 @@\n-  assert ((_leftmosts[which_partition] == _max) || in_partition(idx, which_partition), \"right-most region must be free\");\n+  assert ((_leftmosts[which_partition] == _max) || partition_id_matches(idx, which_partition), \"right-most region must be free\");\n@@ -259,2 +255,2 @@\n-inline bool ShenandoahRegionPartition::is_empty(ShenandoahFreeSetPartitionId which_partition) const {\n-  assert (which_partition > NotFree && which_partition < NumPartitions, \"selected free partition must be valid\");\n+inline bool ShenandoahRegionPartitions::is_empty(ShenandoahFreeSetPartitionId which_partition) const {\n+  assert (which_partition < NumPartitions, \"selected free partition must be valid\");\n@@ -264,2 +260,2 @@\n-size_t ShenandoahRegionPartition::leftmost_empty(ShenandoahFreeSetPartitionId which_partition) {\n-  assert (which_partition > NotFree && which_partition < NumPartitions, \"selected free partition must be valid\");\n+size_t ShenandoahRegionPartitions::leftmost_empty(ShenandoahFreeSetPartitionId which_partition) {\n+  assert (which_partition < NumPartitions, \"selected free partition must be valid\");\n@@ -277,2 +273,2 @@\n-inline size_t ShenandoahRegionPartition::rightmost_empty(ShenandoahFreeSetPartitionId which_partition) {\n-  assert (which_partition > NotFree && which_partition < NumPartitions, \"selected free partition must be valid\");\n+inline size_t ShenandoahRegionPartitions::rightmost_empty(ShenandoahFreeSetPartitionId which_partition) {\n+  assert (which_partition < NumPartitions, \"selected free partition must be valid\");\n@@ -291,1 +287,1 @@\n-void ShenandoahRegionPartition::assert_bounds() {\n+void ShenandoahRegionPartitions::assert_bounds() {\n@@ -332,1 +328,0 @@\n-      case NumPartitions:\n@@ -342,1 +337,1 @@\n-  assert (leftmost(Mutator) == _max || in_partition(leftmost(Mutator), Mutator),\n+  assert (leftmost(Mutator) == _max || partition_id_matches(leftmost(Mutator), Mutator),\n@@ -344,1 +339,1 @@\n-  assert (leftmost(Mutator) == _max || in_partition(rightmost(Mutator), Mutator),\n+  assert (leftmost(Mutator) == _max || partition_id_matches(rightmost(Mutator), Mutator),\n@@ -367,1 +362,1 @@\n-  assert (leftmost(Collector) == _max || in_partition(leftmost(Collector), Collector),\n+  assert (leftmost(Collector) == _max || partition_id_matches(leftmost(Collector), Collector),\n@@ -369,1 +364,1 @@\n-  assert (leftmost(Collector) == _max || in_partition(rightmost(Collector), Collector),\n+  assert (leftmost(Collector) == _max || partition_id_matches(rightmost(Collector), Collector),\n@@ -419,2 +414,2 @@\n-        int leftmost = (int) _partitions.leftmost(Mutator);\n-        for (int idx = (int) _partitions.rightmost(Mutator); idx >= leftmost; idx--) {\n+        ssize_t leftmost = _partitions.leftmost(Mutator);\n+        for (ssize_t idx = _partitions.rightmost(Mutator); idx >= leftmost; idx--) {\n@@ -422,1 +417,1 @@\n-          if (_partitions.in_partition(idx, Mutator)) {\n+          if (_partitions.partition_id_matches(idx, Mutator)) {\n@@ -439,1 +434,0 @@\n-      \/\/ size_t is unsigned, need to dodge underflow when _leftmost = 0\n@@ -441,3 +435,3 @@\n-      for (size_t c = _partitions.rightmost(Collector) + 1; c > _partitions.leftmost(Collector); c--) {\n-        size_t idx = c - 1;\n-        if (_partitions.in_partition(idx, Collector)) {\n+      ssize_t leftmost_collector = _partitions.leftmost(Collector);\n+      for (ssize_t idx = _partitions.rightmost(Collector); idx >= leftmost_collector; idx--) {\n+        if (_partitions.partition_id_matches(idx, Collector)) {\n@@ -457,3 +451,3 @@\n-      for (size_t c = _partitions.rightmost_empty(Mutator) + 1; c > _partitions.leftmost_empty(Mutator); c--) {\n-        size_t idx = c - 1;\n-        if (_partitions.in_partition(idx, Mutator)) {\n+      ssize_t leftmost_mutator_empty = _partitions.leftmost_empty(Mutator);\n+      for (ssize_t idx = _partitions.rightmost_empty(Mutator); idx >= leftmost_mutator_empty; idx--) {\n+        if (_partitions.partition_id_matches(idx, Mutator)) {\n@@ -545,1 +539,1 @@\n-    \/\/ Note that retire_within_partition() increases used to account for waste.\n+    \/\/ Note that retire_from_partition() increases used to account for waste.\n@@ -549,2 +543,3 @@\n-    \/\/ following a failed shared allocation request.  TLAB requests will generally downsize to absorb all\n-    \/\/ memory available within the region even if this is less than the desired size.\n+    \/\/ following a failed shared allocation request.  In the current implementation, we only retire a region\n+    \/\/ if the remaining capacity is less than PLAB::min_size().  Note that TLAB requests will generally downsize\n+    \/\/ to absorb all memory available within the region even if the remaining memory is less than the desired size.\n@@ -553,1 +548,1 @@\n-    _partitions.retire_within_partition(idx, r->used());\n+    _partitions.retire_from_partition(idx, r->used());\n@@ -584,1 +579,1 @@\n-    if (!_partitions.in_partition(end, Mutator) || !can_allocate_from(_heap->get_region(end))) {\n+    if (!_partitions.partition_id_matches(end, Mutator) || !can_allocate_from(_heap->get_region(end))) {\n@@ -626,1 +621,1 @@\n-    _partitions.retire_within_partition(r->index(), ShenandoahHeapRegion::region_size_bytes());\n+    _partitions.retire_from_partition(r->index(), ShenandoahHeapRegion::region_size_bytes());\n@@ -660,1 +655,1 @@\n-  assert(_partitions.in_partition(idx, Mutator), \"Should be in mutator view\");\n+  assert(_partitions.partition_id_matches(idx, Mutator), \"Should be in mutator view\");\n@@ -694,1 +689,1 @@\n-      assert(_partitions.in_partition(idx, NotFree), \"We are about to make region free; it should not be free already\");\n+      assert(_partitions.partition_id_matches(idx, NotFree), \"We are about to make region free; it should not be free already\");\n@@ -715,1 +710,2 @@\n-\/\/ Move no more than max_xfer_regions from the existing Collector free partitions to the Mutator free partition.\n+\/\/ Move no more than max_xfer_regions from the existing Collector partition to the Mutator partition.\n+\/\/\n@@ -717,1 +713,1 @@\n-\/\/ need to reserve memory within for evacuation.  (We will create a new reserve after update refs finishes,\n+\/\/ need to reserve memory for evacuation.  (We will create a new reserve after update refs finishes,\n@@ -720,1 +716,1 @@\n-void ShenandoahFreeSet::move_regions_from_collector_to_mutator_partition(size_t max_xfer_regions) {\n+void ShenandoahFreeSet::move_regions_from_collector_to_mutator(size_t max_xfer_regions) {\n@@ -730,1 +726,1 @@\n-      if (_partitions.in_partition(idx, Collector) && can_allocate_from(idx)) {\n+      if (_partitions.partition_id_matches(idx, Collector) && can_allocate_from(idx)) {\n@@ -744,1 +740,1 @@\n-      if (_partitions.in_partition(idx, Collector) && (alloc_capacity > 0)) {\n+      if (_partitions.partition_id_matches(idx, Collector) && (alloc_capacity > 0)) {\n@@ -761,1 +757,2 @@\n-  \/\/ This resets all state information, removing all regions from all partitions.\n+\n+  \/\/ Clear() resets all state information, marking every region as NotFree.\n@@ -802,1 +799,1 @@\n-    if (!_partitions.in_partition(idx, Mutator)) {\n+    if (!_partitions.partition_id_matches(idx, Mutator)) {\n@@ -864,1 +861,1 @@\n-      if (_partitions.in_partition(i, Mutator)) {\n+      if (_partitions.partition_id_matches(i, Mutator)) {\n@@ -869,1 +866,1 @@\n-      } else if (_partitions.in_partition(i, Collector)) {\n+      } else if (_partitions.partition_id_matches(i, Collector)) {\n@@ -906,1 +903,1 @@\n-        if (_partitions.in_partition(idx, Mutator)) {\n+        if (_partitions.partition_id_matches(idx, Mutator)) {\n@@ -967,1 +964,1 @@\n-        if (_partitions.in_partition(idx, Collector)) {\n+        if (_partitions.partition_id_matches(idx, Collector)) {\n@@ -1012,1 +1009,1 @@\n-    if (index < _partitions.max() && _partitions.in_partition(index, Mutator)) {\n+    if (index < _partitions.max() && _partitions.partition_id_matches(index, Mutator)) {\n@@ -1027,1 +1024,1 @@\n-    if (_partitions.in_partition(index, Mutator)) {\n+    if (_partitions.partition_id_matches(index, Mutator)) {\n@@ -1033,1 +1030,1 @@\n-    if (_partitions.in_partition(index, Collector)) {\n+    if (_partitions.partition_id_matches(index, Collector)) {\n@@ -1066,1 +1063,1 @@\n-    if (_partitions.in_partition(index, Mutator)) {\n+    if (_partitions.partition_id_matches(index, Mutator)) {\n@@ -1104,1 +1101,1 @@\n-    if (_partitions.in_partition(index, Mutator)) {\n+    if (_partitions.partition_id_matches(index, Mutator)) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":73,"deletions":76,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-  NotFree,                      \/\/ Region has been retired and is not in any free set: there is no available memory.\n@@ -38,2 +37,1 @@\n-\n-  NumPartitions                 \/\/ This value represents the size of an array that may be indexed by NotFree, Mutator, Collector.\n+  NotFree                       \/\/ Region is in no free set: it has no available memory\n@@ -42,0 +40,5 @@\n+\/\/ We do not maintain counts, capacity, or used for regions that are not free.  Informally, if a region is NotFree, it is\n+\/\/ in no partition.  NumPartitions represents the size of an array that may be indexed by Mutator or Collector.\n+#define NumPartitions NotFree\n+\n+\n@@ -45,1 +48,1 @@\n-class ShenandoahRegionPartition {\n+class ShenandoahRegionPartitions {\n@@ -53,1 +56,1 @@\n-  \/\/ For each type, we track an interval outside of which a region affiliated with that partition is guaranteed\n+  \/\/ For each partition, we track an interval outside of which a region affiliated with that partition is guaranteed\n@@ -60,4 +63,4 @@\n-  \/\/ Allocation for humongous objects needs to find regions that are entirely empty.  For each partion p, _leftmosts[p]\n-  \/\/ represents the first region belonging to this partition that is completely empty and _rightmosts[p] represents the\n-  \/\/ last region that is completely empty.  If there are no completely empty regions in this partition, this is represented\n-  \/\/ by canonical [_max, 0].\n+  \/\/ Allocation for humongous objects needs to find regions that are entirely empty.  For each partion p, _leftmosts_empty[p]\n+  \/\/ represents the first region belonging to this partition that is completely empty and _rightmosts_empty[p] represents the\n+  \/\/ last region that is completely empty.  If there is no completely empty region in this partition, this is represented\n+  \/\/ by the canonical [_max, 0].\n@@ -68,2 +71,2 @@\n-  \/\/ of the most recent rebuild, _used[p] represents the total amount of memory that has been consumed within this\n-  \/\/ partition (either already consumed as of the rebuild, or consumed since the rebuild).  _capacity[p] and _used[p]\n+  \/\/ of the most recent rebuild, _used[p] represents the total amount of memory that has been allocated within this\n+  \/\/ partition (either already allocated as of the rebuild, or allocated since the rebuild).  _capacity[p] and _used[p]\n@@ -81,2 +84,2 @@\n-  ShenandoahRegionPartition(size_t max_regions, ShenandoahFreeSet* free_set);\n-  ~ShenandoahRegionPartition();\n+  ShenandoahRegionPartitions(size_t max_regions, ShenandoahFreeSet* free_set);\n+  ~ShenandoahRegionPartitions();\n@@ -84,1 +87,1 @@\n-  \/\/ Make all regions NotFree and reset all bounds\n+  \/\/ Remove all regions from all partitions and reset all bounds\n@@ -90,1 +93,1 @@\n-  void retire_within_partition(size_t idx, size_t used_bytes);\n+  void retire_from_partition(size_t idx, size_t used_bytes);\n@@ -98,1 +101,1 @@\n-  \/\/ Returns the ShenandoahFreeSetPartitionId affiliation of region idx, NotFree if this region is not currently free.\n+  \/\/ Returns the ShenandoahFreeSetPartitionId affiliation of region idx, NotFree if this region is not currently in any partition.\n@@ -102,3 +105,3 @@\n-  \/\/ Returns true iff region idx is in the test_set free_set.  Before returning true, asserts that the free\n-  \/\/ set is not empty.  Requires that test_set != NotFree or NumPartitions.\n-  inline bool in_partition(size_t idx, ShenandoahFreeSetPartitionId which_partition) const;\n+  \/\/ Returns true iff region idx's membership is which_partition.  If which_partition represents a free set, asserts\n+  \/\/ that the region has allocation capacity.\n+  inline bool partition_id_matches(size_t idx, ShenandoahFreeSetPartitionId which_partition) const;\n@@ -108,3 +111,1 @@\n-  \/\/ regions, which are required for humongous allocations and desired for \"very large\" allocations.  A\n-  \/\/ return value of -1 from leftmost() or leftmost_empty() denotes that the corresponding set is empty.\n-  \/\/ In other words:\n+  \/\/ regions, which are required for humongous allocations and desired for \"very large\" allocations.\n@@ -125,1 +126,1 @@\n-    assert (which_partition > NotFree && which_partition < NumPartitions, \"selected free set must be valid\");\n+    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n@@ -130,1 +131,1 @@\n-    assert (which_partition > NotFree && which_partition < NumPartitions, \"selected free set must be valid\");\n+    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n@@ -135,1 +136,1 @@\n-    assert (which_partition > NotFree && which_partition < NumPartitions, \"selected free set must be valid\");\n+    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n@@ -140,1 +141,1 @@\n-    assert (which_partition > NotFree && which_partition < NumPartitions, \"selected free set must be valid\");\n+    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n@@ -174,1 +175,1 @@\n-  ShenandoahRegionPartition _partitions;\n+  ShenandoahRegionPartitions _partitions;\n@@ -209,1 +210,1 @@\n-  \/\/ Public because ShenandoahRegionPartition assertions require access.\n+  \/\/ Public because ShenandoahRegionPartitions assertions require access.\n@@ -216,3 +217,4 @@\n-  \/\/ After we have finished evacuation, we no longer need to hold regions in reserve for the Collector.\n-  \/\/ Call this method at the start of update refs to make more memory available to the Mutator.  This\n-  \/\/ benefits workloads that do not consume all of the evacuation waste reserve.\n+  \/\/ Move up to cset_regions number of regions from being available to the collector to being available to the mutator.\n+  \/\/\n+  \/\/ Typical usage: At the end of evacuation, when the collector no longer needs the regions that had been reserved\n+  \/\/ for evacuation, invoke this to make regions available for mutator allocations.\n@@ -221,2 +223,4 @@\n-  \/\/ of the regions recycled from the collection set will be available.\n-  void move_regions_from_collector_to_mutator_partition(size_t cset_regions);\n+  \/\/ of the regions recycled from the collection set will be available.  If the very unlikely event that there\n+  \/\/ are fewer regions in the collection set than remain in the collector set, we limit the transfer in order\n+  \/\/ to assure that the replenished Collector reserve can be sufficiently large.\n+  void move_regions_from_collector_to_mutator(size_t cset_regions);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":37,"deletions":33,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -1066,1 +1066,0 @@\n-\n@@ -1068,2 +1067,0 @@\n-\n-    \/\/ Since Full GC directly manipulates top of certain regions, certain ShenandoahFreeSet abstractions may have been corrupted.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2077,1 +2077,1 @@\n-      _heap->free_set()->move_regions_from_collector_to_mutator_partition(cset_regions);\n+      _heap->free_set()->move_regions_from_collector_to_mutator(cset_regions);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}