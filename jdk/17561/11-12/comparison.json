{"files":[{"patch":"@@ -47,0 +47,1 @@\n+#undef KELVIN_HUMONGOUS\n@@ -48,11 +49,26 @@\n-#ifdef KELVIN_TRACE\n-static char buf1[17], buf2[17];\n-const static char ascii[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n-\n-\/\/ NOT THREAD SAFE\n-char* ltos_1(size_t arg) {\n-  buf1[16] = '\\0';\n-  for (int i = 15; i >= 0; i--) {\n-    size_t byte = arg & 0xff;\n-    buf1[i] = ascii[byte];\n-    arg >>= 4;\n+size_t ShenandoahSimpleBitMap::count_leading_ones(ssize_t start_idx) const {\n+  assert((start_idx >= 0) && (start_idx < _num_bits), \"precondition\");\n+  size_t array_idx = start_idx \/ _bits_per_array_element;\n+  size_t element_bits = _bitmap[array_idx];\n+  size_t bit_number = start_idx % _bits_per_array_element;\n+  size_t the_bit = ((size_t) 0x01) << bit_number;\n+  size_t omit_mask = the_bit - 1;\n+  size_t mask = ((size_t) ((ssize_t) -1)) & omit_mask;\n+\n+  if ((element_bits & mask) == mask) {\n+    size_t counted_ones = _bits_per_array_element - bit_number;\n+#ifdef KELVIN_HUMONGOUS\n+    log_info(gc)(\"count_leading_ones(%ld) in 0x%016lx with mask 0x%016lx returning %ld + recurse with %ld\",\n+                 start_idx, element_bits, mask, counted_ones, start_idx + counted_ones);\n+#endif\n+    return counted_ones + count_leading_ones(start_idx + counted_ones);\n+  } else {\n+    size_t counted_ones;\n+    for (counted_ones = 0; element_bits & the_bit; counted_ones++) {\n+      the_bit <<= 1;\n+    }\n+#ifdef KELVIN_HUMONGOUS\n+    log_info(gc)(\"count_leading_ones(%ld) in 0x%016lx with mask 0x%016lx returning %ld\",\n+                 start_idx, element_bits, mask, counted_ones);\n+#endif\n+    return counted_ones;\n@@ -60,1 +76,0 @@\n-  return buf1;\n@@ -63,6 +78,31 @@\n-char* ltos_2(size_t arg) {\n-  buf2[16] = '\\0';\n-  for (int i = 15; i >= 0; i--) {\n-    size_t byte = arg & 0xff;\n-    buf2[i] = ascii[byte];\n-    arg >>= 4;\n+\/\/ Count consecutive ones in reverse order, starting from last_idx.  Requires that there is at least one zero\n+\/\/ between last_idx and index value zero, inclusive.\n+size_t ShenandoahSimpleBitMap::count_trailing_ones(ssize_t last_idx) const {\n+  assert((last_idx >= 0) && (last_idx < _num_bits), \"precondition\");\n+  size_t array_idx = last_idx \/ _bits_per_array_element;\n+  size_t element_bits = _bitmap[array_idx];\n+  size_t bit_number = last_idx % _bits_per_array_element;\n+  size_t the_bit = ((size_t) 0x01) << bit_number;\n+\n+  \/\/ All ones from bit 0 to the_bit\n+  size_t mask = (the_bit * 2) - 1;\n+  if ((element_bits & mask) == mask) {\n+    size_t counted_ones = bit_number;\n+#ifdef KELVIN_HUMONGOUS\n+    log_info(gc)(\"count_trailing_ones(%ld) in 0x%016lx with mask 0x%016lx returning %ld + recurse with %ld\",\n+                 last_idx, element_bits, mask, counted_ones, last_idx - counted_ones);\n+#endif\n+    return counted_ones + count_trailing_ones(last_idx - counted_ones);\n+  } else {\n+    size_t counted_ones;\n+#ifdef KELVIN_HUMONGOUS\n+    log_info(gc)(\"count_trailing_ones @ top of loop, the_bit: 0x%016lx\", the_bit);\n+#endif\n+    for (counted_ones = 0; element_bits & the_bit; counted_ones++) {\n+      the_bit >>= 1;\n+    }\n+#ifdef KELVIN_HUMONGOUS\n+    log_info(gc)(\"count_trailing_ones(%ld) in 0x%016lx with mask 0x%016lx returning %ld\",\n+                 last_idx, element_bits, mask, counted_ones);\n+#endif\n+    return counted_ones;\n@@ -70,1 +110,0 @@\n-  return buf2;\n@@ -72,0 +111,17 @@\n+\n+bool ShenandoahSimpleBitMap::is_forward_consecutive_ones(ssize_t start_idx, ssize_t count) const {\n+  assert((start_idx >= 0) && (start_idx < _num_bits), \"precondition\");\n+  assert(start_idx + count <= (ssize_t) _num_bits, \"precondition\");\n+  size_t array_idx = start_idx \/ _bits_per_array_element;\n+  size_t bit_number = start_idx % _bits_per_array_element;\n+  size_t the_bit = ((size_t) 0x01) << bit_number;\n+  size_t element_bits = _bitmap[array_idx];\n+\n+  if ((ssize_t) (_bits_per_array_element - bit_number) > count) {\n+    \/\/ All relevant bits reside within this array element\n+    size_t overreach_mask = ((size_t) 0x1 << (bit_number + count)) - 1;\n+    size_t exclude_mask = ((size_t) 0x1 << bit_number) - 1;\n+    size_t exact_mask = overreach_mask & ~exclude_mask;\n+#ifdef KELVIN_HUMONGOUS\n+    log_info(gc)(\"is_forward_consecutive_ones(%ld, %ld) in 0x%016lx with mask 0x%016lx returning %s\",\n+                 start_idx, count, element_bits, exact_mask, (element_bits & exact_mask) == exact_mask? \"true\": \"false\");\n@@ -73,0 +129,22 @@\n+    return (element_bits & exact_mask) == exact_mask? true: false;\n+  } else {\n+    \/\/ Need to exactly match all relevant bits of this array element, plus relevant bits of following array elements\n+    size_t overreach_mask = (size_t) (ssize_t) - 1;\n+    size_t exclude_mask = ((size_t) 0x1 << bit_number) - 1;\n+    size_t exact_mask = overreach_mask & ~exclude_mask;\n+    if ((element_bits & exact_mask) == exact_mask) {\n+      size_t matched_bits = _bits_per_array_element - bit_number;\n+#ifdef KELVIN_HUMONGOUS\n+      log_info(gc)(\"is_forward_consecutive_ones(%ld, %ld) in 0x%016lx with mask 0x%016lx recurse after matching %ld\",\n+                   start_idx, count, element_bits, exact_mask, matched_bits);\n+#endif\n+      return is_forward_consecutive_ones(start_idx + matched_bits, count - matched_bits);\n+    } else {\n+#ifdef KELVIN_HUMONGOUS\n+      log_info(gc)(\"is_forward_consecutive_ones(%ld, %ld) in 0x%016lx with mask 0x%016lx returning %s\",\n+                   start_idx, count, element_bits, exact_mask, \"false\");\n+#endif\n+      return false;\n+    }\n+  }\n+}\n@@ -74,0 +152,37 @@\n+bool ShenandoahSimpleBitMap::is_backward_consecutive_ones(ssize_t last_idx, ssize_t count) const {\n+  assert((last_idx >= 0) && (last_idx < _num_bits), \"precondition\");\n+  assert(last_idx - count >= -1, \"precondition\");\n+  size_t array_idx = last_idx \/ _bits_per_array_element;\n+  size_t bit_number = last_idx % _bits_per_array_element;\n+  size_t the_bit = ((size_t) 0x01) << bit_number;\n+  size_t element_bits = _bitmap[array_idx];\n+\n+  if ((ssize_t) (bit_number + 1) >= count) {\n+    \/\/ All relevant bits reside within this array element\n+    size_t overreach_mask = ((size_t) 0x1 << (bit_number + 1)) - 1;\n+    size_t exclude_mask = ((size_t) 0x1 << (bit_number + 1 - count)) - 1;\n+    size_t exact_mask = overreach_mask & ~exclude_mask;\n+#ifdef KELVIN_HUMONGOUS\n+    log_info(gc)(\"is_backward_consecutive_ones(%ld, %ld) in 0x%016lx with mask 0x%016lx returning %s\",\n+                 last_idx, count, element_bits, exact_mask, (element_bits & exact_mask) == exact_mask? \"true\": \"false\");\n+#endif\n+    return (element_bits & exact_mask) == exact_mask? true: false;\n+  } else {\n+    \/\/ Need to exactly match all relevant bits of this array element, plus relevant bits of following array elements\n+    size_t exact_mask = ((size_t) 0x1 << (bit_number + 1)) - 1;\n+    if ((element_bits & exact_mask) == exact_mask) {\n+      size_t matched_bits = bit_number + 1;\n+#ifdef KELVIN_HUMONGOUS\n+      log_info(gc)(\"is_backward_consecutive_ones(%ld, %ld) in 0x%016lx with mask 0x%016lx recurse after matching %ld\",\n+                   last_idx, count, element_bits, exact_mask, matched_bits);\n+#endif\n+      return is_backward_consecutive_ones(last_idx - matched_bits, count - matched_bits);\n+    } else {\n+#ifdef KELVIN_HUMONGOUS\n+      log_info(gc)(\"is_backward_consecutive_ones(%ld, %ld) in 0x%016lx with mask 0x%016lx returning %s\",\n+                   last_idx, count, element_bits, exact_mask, \"false\");\n+#endif\n+      return false;\n+    }\n+  }\n+}\n@@ -197,1 +312,1 @@\n-#ifdef KELVIN_TRACE\n+#ifdef KELVIN_HUMONGOUS\n@@ -205,1 +320,1 @@\n-#ifdef KELVIN_TRACE\n+#ifdef KELVIN_HUMONGOUS\n@@ -207,1 +322,1 @@\n-                   num_bits, start_idx, boundary_idx, orig_start_idx);\n+                   num_bits, orig_start_idx, boundary_idx, start_idx);\n@@ -227,1 +342,1 @@\n-#ifdef KELVIN_TRACE\n+#ifdef KELVIN_HUMONGOUS\n@@ -235,1 +350,1 @@\n-#ifdef KELVIN_TRACE\n+#ifdef KELVIN_HUMONGOUS\n@@ -237,1 +352,1 @@\n-                   num_bits, last_idx, boundary_idx, orig_last_idx);\n+                   num_bits, orig_last_idx, boundary_idx, last_idx + 1 - num_bits);\n@@ -378,1 +493,1 @@\n-#ifdef KELVIN_TRACE\n+#if defined(KELVIN_TRACE) || defined(KELVIN_HUMONGOUS)\n@@ -604,0 +719,8 @@\n+#ifdef KELVIN_HUMONGOUS\n+  log_info(gc)(\"find_index_of_next_available_cluster(%s, %ld, %ld)\", partition_name(which_partition), start_index, cluster_size);\n+  log_info(gc)(\"Mutator range [%ld, %ld], Collector range [%ld, %ld]\",\n+               _leftmosts[Mutator], _rightmosts[Mutator], _leftmosts[Collector], _rightmosts[Collector]);\n+  log_info(gc)(\"Empty Mutator range [%ld, %ld], Empty Collector range [%ld, %ld]\",\n+               _leftmosts_empty[Mutator], _rightmosts_empty[Mutator],\n+               _leftmosts_empty[Collector], _rightmosts_empty[Collector]);\n+#endif\n@@ -605,1 +728,1 @@\n-#ifdef KELVIN_TRACE\n+#ifdef KELVIN_HUMONGOUS\n@@ -608,1 +731,1 @@\n-  dump_bitmap_row(start_index);\n+  dump_bitmap_row((result > rightmost_index)? _max - 1: result);\n@@ -619,0 +742,9 @@\n+#ifdef KELVIN_HUMONGOUS\n+  log_info(gc)(\"find_index_of_previous_available_cluster(%s, %ld, \" SIZE_FORMAT \")\",\n+               partition_name(which_partition), last_index, cluster_size);\n+  log_info(gc)(\"Mutator range [%ld, %ld], Collector range [%ld, %ld]\",\n+               _leftmosts[Mutator], _rightmosts[Mutator], _leftmosts[Collector], _rightmosts[Collector]);\n+  log_info(gc)(\"Empty Mutator range [%ld, %ld], Empty Collector range [%ld, %ld]\",\n+               _leftmosts_empty[Mutator], _rightmosts_empty[Mutator],\n+               _leftmosts_empty[Collector], _rightmosts_empty[Collector]);\n+#endif\n@@ -620,2 +752,2 @@\n-#ifdef KELVIN_TRACE\n-  log_info(gc)(\"find_index_of_next_available_cluster(%s, %ld, \" SIZE_FORMAT \") returning %ld\",\n+#ifdef KELVIN_HUMONGOUS\n+  log_info(gc)(\"find_index_of_previous_available_cluster(%s, %ld, \" SIZE_FORMAT \") returning %ld\",\n@@ -942,1 +1074,1 @@\n-  ssize_t end_range = _partitions.rightmost_empty(Mutator);\n+  ssize_t last_possible_start = _partitions.rightmost_empty(Mutator) + 1 - num;\n@@ -947,1 +1079,1 @@\n-  if (beg > end_range) {\n+  if (beg > last_possible_start) {\n@@ -957,2 +1089,3 @@\n-      beg = _partitions.find_index_of_next_available_cluster_of_regions(Mutator, end_range + 1, num);\n-      if (beg > end_range) {\n+      \/\/ region[end] is not empty, so we restart our search after region[end]\n+      beg = _partitions.find_index_of_next_available_cluster_of_regions(Mutator, end + 1, num);\n+      if (beg > last_possible_start) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":167,"deletions":34,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -33,5 +33,0 @@\n-#ifdef KELVIN_TRACE_HPP\n-\n-extern char* ltos_1(size_t arg);\n-extern char* ltos_2(size_t arg);\n-#endif\n@@ -86,27 +81,1 @@\n-  size_t count_leading_ones(ssize_t start_idx) const {\n-    assert((start_idx >= 0) && (start_idx < _num_bits), \"precondition\");\n-    size_t array_idx = start_idx \/ _bits_per_array_element;\n-    size_t element_bits = _bitmap[array_idx];\n-    size_t bit_number = start_idx % _bits_per_array_element;\n-    size_t the_bit = ((size_t) 0x01) << bit_number;\n-    size_t omit_mask = the_bit - 1;\n-    size_t mask = ((size_t) ((ssize_t) -1)) & omit_mask;\n-    if ((element_bits & mask) == mask) {\n-      size_t counted_ones = _bits_per_array_element - bit_number;\n-#ifdef KELVIN_TRACE_HPP\n-      printf(\"count_leading_ones(%ld) in %s with mask %s returning %ld + recurse with %ld\",\n-                   start_idx, ltos_1(element_bits), ltos_2(mask), counted_ones, start_idx + counted_ones);\n-#endif\n-      return counted_ones + count_leading_ones(start_idx + counted_ones);\n-    } else {\n-      size_t counted_ones;\n-      for (counted_ones = 0; element_bits & the_bit; counted_ones++) {\n-        the_bit <<= 1;\n-      }\n-#ifdef KELVIN_TRACE_HPP\n-      printf(\"count_leading_ones(%ld) in %s with mask %s returning %ld\",\n-                   start_idx, ltos_1(element_bits), ltos_2(mask), counted_ones);\n-#endif\n-      return counted_ones;\n-    }\n-  }\n+  size_t count_leading_ones(ssize_t start_idx) const;\n@@ -116,28 +85,1 @@\n-  size_t count_trailing_ones(ssize_t last_idx) const {\n-    assert((last_idx >= 0) && (last_idx < _num_bits), \"precondition\");\n-    size_t array_idx = last_idx \/ _bits_per_array_element;\n-    size_t element_bits = _bitmap[array_idx];\n-    size_t bit_number = last_idx % _bits_per_array_element;\n-    size_t the_bit = ((size_t) 0x01) << bit_number;\n-\n-    \/\/ All ones from bit 0 to the_bit\n-    size_t mask = (the_bit * 2) - 1;\n-    if ((element_bits & mask) == mask) {\n-      size_t counted_ones = bit_number;\n-#ifdef KELVIN_TRACE_HPP\n-      printf(\"count_trailing_ones(%ld) in %s with mask %s returning %ld + recurse with %ld\",\n-                   last_idx, ltos_1(element_bits), ltos_2(mask), counted_ones, last_idx - counted_ones);\n-#endif\n-      return counted_ones + count_trailing_ones(last_idx - counted_ones);\n-    } else {\n-      size_t counted_ones;\n-      for (counted_ones = 0; element_bits & the_bit; counted_ones++) {\n-        the_bit >>= 1;\n-      }\n-#ifdef KELVIN_TRACE_HPP\n-      printf(\"count_trailing_ones(%ld) in %s with mask %s returning %ld\",\n-                   last_idx, ltos_1(element_bits), ltos_2(mask), counted_ones);\n-#endif\n-      return counted_ones;\n-    }\n-  }\n+  size_t count_trailing_ones(ssize_t last_idx) const;\n@@ -145,77 +87,2 @@\n-  bool is_forward_consecutive_ones(ssize_t start_idx, ssize_t count) const {\n-    assert((start_idx >= 0) && (start_idx < _num_bits), \"precondition\");\n-    assert(start_idx + count <= (ssize_t) _num_bits, \"precondition\");\n-    size_t array_idx = start_idx \/ _bits_per_array_element;\n-    size_t bit_number = start_idx % _bits_per_array_element;\n-    size_t the_bit = ((size_t) 0x01) << bit_number;\n-    size_t element_bits = _bitmap[array_idx];\n-\n-    if ((ssize_t) (_bits_per_array_element - bit_number) > count) {\n-      \/\/ All relevant bits reside within this array element\n-      size_t overreach_mask = ((size_t) 0x1 << (bit_number + count)) - 1;\n-      size_t exclude_mask = ((size_t) 0x1 << bit_number) - 1;\n-      size_t exact_mask = overreach_mask & ~exclude_mask;\n-#ifdef KELVIN_TRACE_HPP\n-      printf(\"is_forward_consecutive_ones(%ld, %ld) in %s with mask %s returning %s\",\n-                   start_idx, count, ltos_1(element_bits), ltos_2(exact_mask), (element_bits & exact_mask) == exact_mask? \"true\": \"false\");\n-#endif\n-      return (element_bits & exact_mask) == exact_mask? true: false;\n-    } else {\n-      \/\/ Need to exactly match all relevant bits of this array element, plus relevant bits of following array elements\n-      size_t overreach_mask = (size_t) (ssize_t) - 1;\n-      size_t exclude_mask = ((size_t) 0x1 << bit_number) - 1;\n-      size_t exact_mask = overreach_mask & ~exclude_mask;\n-      if ((element_bits & exact_mask) == exact_mask) {\n-        size_t matched_bits = _bits_per_array_element - bit_number;\n-#ifdef KELVIN_TRACE_HPP\n-      printf(\"is_forward_consecutive_ones(%ld, %ld) in %s with mask %s recursing\",\n-                   start_idx, count, ltos_1(element_bits), ltos_2(exact_mask));\n-#endif\n-        return is_forward_consecutive_ones(start_idx + matched_bits, count - matched_bits);\n-      } else {\n-#ifdef KELVIN_TRACE_HPP\n-        printf(\"is_forward_consecutive_ones(%ld, %ld) in %s with mask %s returning %s\",\n-                     start_idx, count, ltos_1(element_bits), ltos_2(exact_mask), \"false\");\n-#endif\n-        return false;\n-      }\n-    }\n-  }\n-\n-  bool is_backward_consecutive_ones(ssize_t last_idx, ssize_t count) const {\n-    assert((last_idx >= 0) && (last_idx < _num_bits), \"precondition\");\n-    assert(last_idx - count >= -1, \"precondition\");\n-    size_t array_idx = last_idx \/ _bits_per_array_element;\n-    size_t bit_number = last_idx % _bits_per_array_element;\n-    size_t the_bit = ((size_t) 0x01) << bit_number;\n-    size_t element_bits = _bitmap[array_idx];\n-\n-    if ((ssize_t) (bit_number + 1) >= count) {\n-      \/\/ All relevant bits reside within this array element\n-      size_t overreach_mask = ((size_t) 0x1 << (bit_number + 1)) - 1;\n-      size_t exclude_mask = ((size_t) 0x1 << (bit_number + 1 - count)) - 1;\n-      size_t exact_mask = overreach_mask & ~exclude_mask;\n-#ifdef KELVIN_TRACE_HPP\n-      printf(\"is_backward_consecutive_ones(%ld, %ld) in %s with mask %s returning %s\",\n-                   last_idx, count, ltos_1(element_bits), ltos_2(exact_mask), (element_bits & exact_mask) == exact_mask? \"true\": \"false\");\n-#endif\n-      return (element_bits & exact_mask) == exact_mask? true: false;\n-    } else {\n-      \/\/ Need to exactly match all relevant bits of this array element, plus relevant bits of following array elements\n-      size_t exact_mask = ((size_t) 0x1 << (bit_number + 1)) - 1;\n-      if ((element_bits & exact_mask) == exact_mask) {\n-        size_t matched_bits = bit_number + 1;\n-#ifdef KELVIN_TRACE_HPP\n-        printf(\"is_backward_consecutive_ones(%ld, %ld) in %s with mask %s recursing\",\n-                     last_idx, count,ltos_1( element_bits), ltos_2(exact_mask));\n-#endif\n-        return is_backward_consecutive_ones(last_idx - matched_bits, count - matched_bits);\n-      } else {\n-#ifdef KELVIN_TRACE_HPP\n-        printf(\"is_backward_consecutive_ones(%ld, %ld) in %s with mask %s returning %s\",\n-                     last_idx, count, ltos_1(element_bits), ltos_2(exact_mask), \"false\");\n-#endif\n-        return false;\n-      }\n-    }\n-  }\n+  bool is_forward_consecutive_ones(ssize_t start_idx, ssize_t count) const;\n+  bool is_backward_consecutive_ones(ssize_t last_idx, ssize_t count) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":4,"deletions":137,"binary":false,"changes":141,"status":"modified"}]}