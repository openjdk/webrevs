{"files":[{"patch":"@@ -36,1 +36,1 @@\n-static const char* free_memory_type_name(ShenandoahFreeMemoryType t) {\n+static const char* partition_name(ShenandoahFreeSetPartitionId t) {\n@@ -41,1 +41,0 @@\n-    case NumFreeSets: return \"NumFreeSets\";\n@@ -46,1 +45,1 @@\n-ShenandoahSetsOfFree::ShenandoahSetsOfFree(size_t max_regions, ShenandoahFreeSet* free_set) :\n+ShenandoahRegionPartition::ShenandoahRegionPartition(size_t max_regions, ShenandoahFreeSet* free_set) :\n@@ -48,0 +47,1 @@\n+    _region_size_bytes(ShenandoahHeapRegion::region_size_bytes()),\n@@ -49,1 +49,1 @@\n-    _region_size_bytes(ShenandoahHeapRegion::region_size_bytes())\n+    _membership(NEW_C_HEAP_ARRAY(ShenandoahFreeSetPartitionId, max_regions, mtGC))\n@@ -51,2 +51,1 @@\n-  _membership = NEW_C_HEAP_ARRAY(ShenandoahFreeMemoryType, max_regions, mtGC);\n-  clear_internal();\n+  make_all_regions_unavailable();\n@@ -55,2 +54,2 @@\n-ShenandoahSetsOfFree::~ShenandoahSetsOfFree() {\n-  FREE_C_HEAP_ARRAY(ShenandoahFreeMemoryType, _membership);\n+ShenandoahRegionPartition::~ShenandoahRegionPartition() {\n+  FREE_C_HEAP_ARRAY(ShenandoahFreeSetPartitionId, _membership);\n@@ -89,1 +88,1 @@\n-void ShenandoahSetsOfFree::clear_internal() {\n+void ShenandoahRegionPartition::make_all_regions_unavailable() {\n@@ -94,7 +93,7 @@\n-  for (size_t idx = 0; idx < NumFreeSets; idx++) {\n-    _leftmosts[idx] = _max;\n-    _rightmosts[idx] = 0;\n-    _leftmosts_empty[idx] = _max;\n-    _rightmosts_empty[idx] = 0;\n-    _capacity_of[idx] = 0;\n-    _used_by[idx] = 0;\n+  for (size_t partition_id = 0; partition_id < NumPartitions; partition_id++) {\n+    _leftmosts[partition_id] = _max;\n+    _rightmosts[partition_id] = 0;\n+    _leftmosts_empty[partition_id] = _max;\n+    _rightmosts_empty[partition_id] = 0;\n+    _capacity_of[partition_id] = 0;\n+    _used_by[partition_id] = 0;\n@@ -103,2 +102,1 @@\n-  _region_counts[Mutator] = 0;\n-  _region_counts[Collector] = 0;\n+  _region_counts[Mutator] = _region_counts[Collector] = 0;\n@@ -108,8 +106,4 @@\n-void ShenandoahSetsOfFree::clear_all() {\n-  clear_internal();\n-}\n-\n-void ShenandoahSetsOfFree::increase_used(ShenandoahFreeMemoryType which_set, size_t bytes) {\n-  assert (which_set > NotFree && which_set < NumFreeSets, \"Set must correspond to a valid freeset\");\n-  _used_by[which_set] += bytes;\n-  assert (_used_by[which_set] <= _capacity_of[which_set],\n+void ShenandoahRegionPartition::increase_used(ShenandoahFreeSetPartitionId which_partition, size_t bytes) {\n+  assert (which_partition > NotFree && which_partition < NumPartitions, \"Partition must be valid\");\n+  _used_by[which_partition] += bytes;\n+  assert (_used_by[which_partition] <= _capacity_of[which_partition],\n@@ -117,1 +111,1 @@\n-          _used_by[which_set], _capacity_of[which_set], bytes);\n+          _used_by[which_partition], _capacity_of[which_partition], bytes);\n@@ -120,4 +114,4 @@\n-inline void ShenandoahSetsOfFree::shrink_bounds_if_touched(ShenandoahFreeMemoryType set, size_t idx) {\n-  if (idx == _leftmosts[set]) {\n-    while ((_leftmosts[set] < _max) && !in_free_set(_leftmosts[set], set)) {\n-      _leftmosts[set]++;\n+inline void ShenandoahRegionPartition::shrink_interval_if_boundary_modified(ShenandoahFreeSetPartitionId partition, size_t idx) {\n+  if (idx == _leftmosts[partition]) {\n+    while ((_leftmosts[partition] < _max) && !in_partition(_leftmosts[partition], partition)) {\n+      _leftmosts[partition]++;\n@@ -125,1 +119,1 @@\n-    if (_leftmosts_empty[set] < _leftmosts[set]) {\n+    if (_leftmosts_empty[partition] < _leftmosts[partition]) {\n@@ -127,1 +121,1 @@\n-      _leftmosts_empty[set] = _leftmosts[set];\n+      _leftmosts_empty[partition] = _leftmosts[partition];\n@@ -130,3 +124,3 @@\n-  if (idx == _rightmosts[set]) {\n-    while (_rightmosts[set] > 0 && !in_free_set(_rightmosts[set], set)) {\n-      _rightmosts[set]--;\n+  if (idx == _rightmosts[partition]) {\n+    while (_rightmosts[partition] > 0 && !in_partition(_rightmosts[partition], partition)) {\n+      _rightmosts[partition]--;\n@@ -134,1 +128,1 @@\n-    if (_rightmosts_empty[set] > _rightmosts[set]) {\n+    if (_rightmosts_empty[partition] > _rightmosts[partition]) {\n@@ -136,1 +130,1 @@\n-      _rightmosts_empty[set] = _rightmosts[set];\n+      _rightmosts_empty[partition] = _rightmosts[partition];\n@@ -141,1 +135,2 @@\n-inline void ShenandoahSetsOfFree::expand_bounds_maybe(ShenandoahFreeMemoryType set, size_t idx, size_t region_available) {\n+inline void ShenandoahRegionPartition::expand_interval_if_boundary_modified(ShenandoahFreeSetPartitionId partition,\n+                                                           size_t idx, size_t region_available) {\n@@ -143,2 +138,2 @@\n-    if (_leftmosts_empty[set] > idx) {\n-      _leftmosts_empty[set] = idx;\n+    if (_leftmosts_empty[partition] > idx) {\n+      _leftmosts_empty[partition] = idx;\n@@ -146,2 +141,2 @@\n-    if (_rightmosts_empty[set] < idx) {\n-      _rightmosts_empty[set] = idx;\n+    if (_rightmosts_empty[partition] < idx) {\n+      _rightmosts_empty[partition] = idx;\n@@ -150,2 +145,2 @@\n-  if (_leftmosts[set] > idx) {\n-    _leftmosts[set] = idx;\n+  if (_leftmosts[partition] > idx) {\n+    _leftmosts[partition] = idx;\n@@ -153,2 +148,2 @@\n-  if (_rightmosts[set] < idx) {\n-    _rightmosts[set] = idx;\n+  if (_rightmosts[partition] < idx) {\n+    _rightmosts[partition] = idx;\n@@ -158,4 +153,4 @@\n-\/\/ Remove this region from its free set, but leave its capacity and used as part of the original free set's totals.\n-\/\/ When retiring a region, add any remnant of available memory within the region to the used total for the original free set.\n-void ShenandoahSetsOfFree::retire_within_free_set(size_t idx, size_t used_bytes) {\n-  ShenandoahFreeMemoryType orig_set = membership(idx);\n+\/\/ Remove this region from its free partition, but leave its capacity and used as part of the original free partition's totals.\n+\/\/ When retiring a region, add any remnant of available memory within the region to the used total for the original free partition.\n+void ShenandoahRegionPartition::retire_within_partition(size_t idx, size_t used_bytes) {\n+  ShenandoahFreeSetPartitionId orig_partition = membership(idx);\n@@ -163,1 +158,1 @@\n-  \/\/ Note: we may remove from free set even if region is not entirely full, such as when available < PLAB::min_size()\n+  \/\/ Note: we may remove from free partition even if region is not entirely full, such as when available < PLAB::min_size()\n@@ -165,1 +160,1 @@\n-  assert (orig_set > NotFree && orig_set < NumFreeSets, \"Cannot remove from free sets if not already free\");\n+  assert (orig_partition > NotFree && orig_partition < NumPartitions, \"Cannot remove from free partitions if not already free\");\n@@ -169,1 +164,1 @@\n-    increase_used(orig_set, _region_size_bytes - used_bytes);\n+    increase_used(orig_partition, _region_size_bytes - used_bytes);\n@@ -173,1 +168,1 @@\n-  shrink_bounds_if_touched(orig_set, idx);\n+  shrink_interval_if_boundary_modified(orig_partition, idx);\n@@ -175,1 +170,1 @@\n-  _region_counts[orig_set]--;\n+  _region_counts[orig_partition]--;\n@@ -179,1 +174,1 @@\n-void ShenandoahSetsOfFree::make_free(size_t idx, ShenandoahFreeMemoryType which_set, size_t available) {\n+void ShenandoahRegionPartition::make_free(size_t idx, ShenandoahFreeSetPartitionId which_partition, size_t available) {\n@@ -182,1 +177,1 @@\n-  assert (which_set > NotFree && which_set < NumFreeSets, \"selected free set must be valid\");\n+  assert (which_partition > NotFree && which_partition < NumPartitions, \"selected free partition must be valid\");\n@@ -185,4 +180,4 @@\n-  _membership[idx] = which_set;\n-  _capacity_of[which_set] += _region_size_bytes;\n-  _used_by[which_set] += _region_size_bytes - available;\n-  expand_bounds_maybe(which_set, idx, available);\n+  _membership[idx] = which_partition;\n+  _capacity_of[which_partition] += _region_size_bytes;\n+  _used_by[which_partition] += _region_size_bytes - available;\n+  expand_interval_if_boundary_modified(which_partition, idx, available);\n@@ -191,1 +186,1 @@\n-  _region_counts[which_set]++;\n+  _region_counts[which_partition]++;\n@@ -194,1 +189,1 @@\n-void ShenandoahSetsOfFree::move_to_set(size_t idx, ShenandoahFreeMemoryType new_set, size_t available) {\n+void ShenandoahRegionPartition::move_to_partition(size_t idx, ShenandoahFreeSetPartitionId new_partition, size_t available) {\n@@ -196,1 +191,1 @@\n-  assert ((new_set > NotFree) && (new_set < NumFreeSets), \"New set must be valid\");\n+  assert ((new_partition > NotFree) && (new_partition < NumPartitions), \"New partition must be valid\");\n@@ -199,2 +194,2 @@\n-  ShenandoahFreeMemoryType orig_set = _membership[idx];\n-  assert ((orig_set > NotFree) && (orig_set < NumFreeSets), \"Cannot move free unless already free\");\n+  ShenandoahFreeSetPartitionId orig_partition = _membership[idx];\n+  assert ((orig_partition > NotFree) && (orig_partition < NumPartitions), \"Cannot move free unless already free\");\n@@ -207,2 +202,2 @@\n-           (((orig_set == Mutator) && (new_set == Collector)) ||\n-            ((orig_set == Collector) && (new_set == Mutator)))) ||\n+           (((orig_partition == Mutator) && (new_partition == Collector)) ||\n+            ((orig_partition == Collector) && (new_partition == Mutator)))) ||\n@@ -210,1 +205,1 @@\n-           ((orig_set == Mutator) && (new_set == Collector))), \"Unexpected movement between sets\");\n+           ((orig_partition == Mutator) && (new_partition == Collector))), \"Unexpected movement between partitions\");\n@@ -214,4 +209,4 @@\n-  _membership[idx] = new_set;\n-  _capacity_of[orig_set] -= _region_size_bytes;\n-  _used_by[orig_set] -= used;\n-  shrink_bounds_if_touched(orig_set, idx);\n+  _membership[idx] = new_partition;\n+  _capacity_of[orig_partition] -= _region_size_bytes;\n+  _used_by[orig_partition] -= used;\n+  shrink_interval_if_boundary_modified(orig_partition, idx);\n@@ -219,3 +214,3 @@\n-  _capacity_of[new_set] += _region_size_bytes;;\n-  _used_by[new_set] += used;\n-  expand_bounds_maybe(new_set, idx, available);\n+  _capacity_of[new_partition] += _region_size_bytes;;\n+  _used_by[new_partition] += used;\n+  expand_interval_if_boundary_modified(new_partition, idx, available);\n@@ -223,2 +218,2 @@\n-  _region_counts[orig_set]--;\n-  _region_counts[new_set]++;\n+  _region_counts[orig_partition]--;\n+  _region_counts[new_partition]++;\n@@ -227,1 +222,1 @@\n-inline ShenandoahFreeMemoryType ShenandoahSetsOfFree::membership(size_t idx) const {\n+inline ShenandoahFreeSetPartitionId ShenandoahRegionPartition::membership(size_t idx) const {\n@@ -232,3 +227,3 @@\n-  \/\/ Returns true iff region idx is in the test_set free_set.  Before returning true, asserts that the free\n-  \/\/ set is not empty.  Requires that test_set != NotFree or NumFreeSets.\n-inline bool ShenandoahSetsOfFree::in_free_set(size_t idx, ShenandoahFreeMemoryType test_set) const {\n+  \/\/ Returns true iff region idx is in the test_partition free_partition.  Before returning true, asserts that the free\n+  \/\/ partition is not empty.  Requires that test_partition != NotFree or NumPartitions.\n+inline bool ShenandoahRegionPartition::in_partition(size_t idx, ShenandoahFreeSetPartitionId test_partition) const {\n@@ -236,4 +231,4 @@\n-  if (_membership[idx] == test_set) {\n-    assert (test_set == NotFree || _free_set->alloc_capacity(idx) > 0,\n-            \"Free region \" SIZE_FORMAT \", belonging to %s free set, must have alloc capacity\",\n-            idx, free_memory_type_name(test_set));\n+  if (_membership[idx] == test_partition) {\n+    assert (test_partition == NotFree || _free_set->alloc_capacity(idx) > 0,\n+            \"Free region \" SIZE_FORMAT \", belonging to %s free partition, must have alloc capacity\",\n+            idx, partition_name(test_partition));\n@@ -246,3 +241,3 @@\n-inline size_t ShenandoahSetsOfFree::leftmost(ShenandoahFreeMemoryType which_set) const {\n-  assert (which_set > NotFree && which_set < NumFreeSets, \"selected free set must be valid\");\n-  size_t idx = _leftmosts[which_set];\n+inline size_t ShenandoahRegionPartition::leftmost(ShenandoahFreeSetPartitionId which_partition) const {\n+  assert (which_partition > NotFree && which_partition < NumPartitions, \"selected free partition must be valid\");\n+  size_t idx = _leftmosts[which_partition];\n@@ -252,1 +247,1 @@\n-    assert (in_free_set(idx, which_set), \"left-most region must be free\");\n+    assert (in_partition(idx, which_partition), \"left-most region must be free\");\n@@ -257,4 +252,4 @@\n-inline size_t ShenandoahSetsOfFree::rightmost(ShenandoahFreeMemoryType which_set) const {\n-  assert (which_set > NotFree && which_set < NumFreeSets, \"selected free set must be valid\");\n-  size_t idx = _rightmosts[which_set];\n-  assert ((_leftmosts[which_set] == _max) || in_free_set(idx, which_set), \"right-most region must be free\");\n+inline size_t ShenandoahRegionPartition::rightmost(ShenandoahFreeSetPartitionId which_partition) const {\n+  assert (which_partition > NotFree && which_partition < NumPartitions, \"selected free partition must be valid\");\n+  size_t idx = _rightmosts[which_partition];\n+  assert ((_leftmosts[which_partition] == _max) || in_partition(idx, which_partition), \"right-most region must be free\");\n@@ -264,3 +259,3 @@\n-inline bool ShenandoahSetsOfFree::is_empty(ShenandoahFreeMemoryType which_set) const {\n-  assert (which_set > NotFree && which_set < NumFreeSets, \"selected free set must be valid\");\n-  return (leftmost(which_set) > rightmost(which_set));\n+inline bool ShenandoahRegionPartition::is_empty(ShenandoahFreeSetPartitionId which_partition) const {\n+  assert (which_partition > NotFree && which_partition < NumPartitions, \"selected free partition must be valid\");\n+  return (leftmost(which_partition) > rightmost(which_partition));\n@@ -269,5 +264,5 @@\n-size_t ShenandoahSetsOfFree::leftmost_empty(ShenandoahFreeMemoryType which_set) {\n-  assert (which_set > NotFree && which_set < NumFreeSets, \"selected free set must be valid\");\n-  for (size_t idx = _leftmosts_empty[which_set]; idx < _max; idx++) {\n-    if ((membership(idx) == which_set) && (_free_set->alloc_capacity(idx) == _region_size_bytes)) {\n-      _leftmosts_empty[which_set] = idx;\n+size_t ShenandoahRegionPartition::leftmost_empty(ShenandoahFreeSetPartitionId which_partition) {\n+  assert (which_partition > NotFree && which_partition < NumPartitions, \"selected free partition must be valid\");\n+  for (size_t idx = _leftmosts_empty[which_partition]; idx < _max; idx++) {\n+    if ((membership(idx) == which_partition) && (_free_set->alloc_capacity(idx) == _region_size_bytes)) {\n+      _leftmosts_empty[which_partition] = idx;\n@@ -277,2 +272,2 @@\n-  _leftmosts_empty[which_set] = _max;\n-  _rightmosts_empty[which_set] = 0;\n+  _leftmosts_empty[which_partition] = _max;\n+  _rightmosts_empty[which_partition] = 0;\n@@ -282,5 +277,5 @@\n-inline size_t ShenandoahSetsOfFree::rightmost_empty(ShenandoahFreeMemoryType which_set) {\n-  assert (which_set > NotFree && which_set < NumFreeSets, \"selected free set must be valid\");\n-  for (intptr_t idx = _rightmosts_empty[which_set]; idx >= 0; idx--) {\n-    if ((membership(idx) == which_set) && (_free_set->alloc_capacity(idx) == _region_size_bytes)) {\n-      _rightmosts_empty[which_set] = idx;\n+inline size_t ShenandoahRegionPartition::rightmost_empty(ShenandoahFreeSetPartitionId which_partition) {\n+  assert (which_partition > NotFree && which_partition < NumPartitions, \"selected free partition must be valid\");\n+  for (intptr_t idx = _rightmosts_empty[which_partition]; idx >= 0; idx--) {\n+    if ((membership(idx) == which_partition) && (_free_set->alloc_capacity(idx) == _region_size_bytes)) {\n+      _rightmosts_empty[which_partition] = idx;\n@@ -290,2 +285,2 @@\n-  _leftmosts_empty[which_set] = _max;\n-  _rightmosts_empty[which_set] = 0;\n+  _leftmosts_empty[which_partition] = _max;\n+  _rightmosts_empty[which_partition] = 0;\n@@ -296,1 +291,1 @@\n-void ShenandoahSetsOfFree::assert_bounds() {\n+void ShenandoahRegionPartition::assert_bounds() {\n@@ -298,4 +293,4 @@\n-  size_t leftmosts[NumFreeSets];\n-  size_t rightmosts[NumFreeSets];\n-  size_t empty_leftmosts[NumFreeSets];\n-  size_t empty_rightmosts[NumFreeSets];\n+  size_t leftmosts[NumPartitions];\n+  size_t rightmosts[NumPartitions];\n+  size_t empty_leftmosts[NumPartitions];\n+  size_t empty_rightmosts[NumPartitions];\n@@ -303,1 +298,1 @@\n-  for (int i = 0; i < NumFreeSets; i++) {\n+  for (int i = 0; i < NumPartitions; i++) {\n@@ -311,2 +306,2 @@\n-    ShenandoahFreeMemoryType set = membership(i);\n-    switch (set) {\n+    ShenandoahFreeSetPartitionId partition = membership(i);\n+    switch (partition) {\n@@ -322,2 +317,2 @@\n-        if (i < leftmosts[set]) {\n-          leftmosts[set] = i;\n+        if (i < leftmosts[partition]) {\n+          leftmosts[partition] = i;\n@@ -325,2 +320,2 @@\n-        if (is_empty && (i < empty_leftmosts[set])) {\n-          empty_leftmosts[set] = i;\n+        if (is_empty && (i < empty_leftmosts[partition])) {\n+          empty_leftmosts[partition] = i;\n@@ -328,2 +323,2 @@\n-        if (i > rightmosts[set]) {\n-          rightmosts[set] = i;\n+        if (i > rightmosts[partition]) {\n+          rightmosts[partition] = i;\n@@ -331,2 +326,2 @@\n-        if (is_empty && (i > empty_rightmosts[set])) {\n-          empty_rightmosts[set] = i;\n+        if (is_empty && (i > empty_rightmosts[partition])) {\n+          empty_rightmosts[partition] = i;\n@@ -337,1 +332,1 @@\n-      case NumFreeSets:\n+      case NumPartitions:\n@@ -343,1 +338,1 @@\n-  \/\/ Performance invariants. Failing these would not break the free set, but performance would suffer.\n+  \/\/ Performance invariants. Failing these would not break the free partition, but performance would suffer.\n@@ -347,1 +342,1 @@\n-  assert (leftmost(Mutator) == _max || in_free_set(leftmost(Mutator), Mutator),\n+  assert (leftmost(Mutator) == _max || in_partition(leftmost(Mutator), Mutator),\n@@ -349,1 +344,1 @@\n-  assert (leftmost(Mutator) == _max || in_free_set(rightmost(Mutator), Mutator),\n+  assert (leftmost(Mutator) == _max || in_partition(rightmost(Mutator), Mutator),\n@@ -352,1 +347,2 @@\n-  \/\/ If Mutator set is empty, leftmosts will both equal max, rightmosts will both equal zero.  Likewise for empty region sets.\n+  \/\/ If Mutator partition is empty, leftmosts will both equal max, rightmosts will both equal zero.\n+  \/\/ Likewise for empty region partitions.\n@@ -367,1 +363,1 @@\n-  \/\/ Performance invariants. Failing these would not break the free set, but performance would suffer.\n+  \/\/ Performance invariants. Failing these would not break the free partition, but performance would suffer.\n@@ -371,1 +367,1 @@\n-  assert (leftmost(Collector) == _max || in_free_set(leftmost(Collector), Collector),\n+  assert (leftmost(Collector) == _max || in_partition(leftmost(Collector), Collector),\n@@ -373,1 +369,1 @@\n-  assert (leftmost(Collector) == _max || in_free_set(rightmost(Collector), Collector),\n+  assert (leftmost(Collector) == _max || in_partition(rightmost(Collector), Collector),\n@@ -376,1 +372,2 @@\n-  \/\/ If Collector set is empty, leftmosts will both equal max, rightmosts will both equal zero.  Likewise for empty region sets.\n+  \/\/ If Collector partition is empty, leftmosts will both equal max, rightmosts will both equal zero.\n+  \/\/ Likewise for empty region partitions.\n@@ -395,1 +392,1 @@\n-  _free_sets(max_regions, this)\n+  _partitions(max_regions, this)\n@@ -405,2 +402,1 @@\n-  \/\/ Leftmost and rightmost bounds provide enough caching to walk bitmap efficiently. Normally,\n-  \/\/ we would find the region to allocate at right away.\n+  \/\/ Leftmost and rightmost bounds provide enough caching to quickly find a region from which to allocate.\n@@ -408,3 +404,3 @@\n-  \/\/ Allocations are biased: new application allocs go to beginning of the heap, and GC allocs\n-  \/\/ go to the end. This makes application allocation faster, because we would clear lots\n-  \/\/ of regions from the beginning most of the time.\n+  \/\/ Allocations are biased: GC allocations are taken from the high end of the heap.  Regular (and TLAB)\n+  \/\/ mutator allocations are taken from the middle of heap, below the memory reserved for Collector.\n+  \/\/ Humongous mutator allocations are taken from the bottom of the heap.\n@@ -412,4 +408,3 @@\n-  \/\/ Free set maintains mutator and collector views, and normally they allocate in their views only,\n-  \/\/ unless we special cases for stealing and mixed allocations.\n-\n-  \/\/ Overwrite with non-zero (non-NULL) values only if necessary for allocation bookkeeping.\n+  \/\/ Free set maintains mutator and collector partitions.  Mutator can only allocate from the\n+  \/\/ Mutator partition.  Collector prefers to allocate from the Collector partition, but may steal\n+  \/\/ regions from the Mutator partition if the Collector partition has been depleted.\n@@ -422,1 +417,1 @@\n-      if (!_free_sets.is_empty(Mutator)) {\n+      if (!_partitions.is_empty(Mutator)) {\n@@ -424,2 +419,2 @@\n-        int leftmost = (int) _free_sets.leftmost(Mutator);\n-        for (int idx = (int) _free_sets.rightmost(Mutator); idx >= leftmost; idx--) {\n+        int leftmost = (int) _partitions.leftmost(Mutator);\n+        for (int idx = (int) _partitions.rightmost(Mutator); idx >= leftmost; idx--) {\n@@ -427,1 +422,1 @@\n-          if (_free_sets.in_free_set(idx, Mutator)) {\n+          if (_partitions.in_partition(idx, Mutator)) {\n@@ -441,2 +436,1 @@\n-      \/\/ GCLABs are for evacuation so we must be in evacuation phase.  If this allocation is successful, increment\n-      \/\/ the relevant evac_expended rather than used value.\n+      \/\/ GCLABs are for evacuation so we must be in evacuation phase.\n@@ -447,1 +441,1 @@\n-      for (size_t c = _free_sets.rightmost(Collector) + 1; c > _free_sets.leftmost(Collector); c--) {\n+      for (size_t c = _partitions.rightmost(Collector) + 1; c > _partitions.leftmost(Collector); c--) {\n@@ -449,1 +443,1 @@\n-        if (_free_sets.in_free_set(idx, Collector)) {\n+        if (_partitions.in_partition(idx, Collector)) {\n@@ -463,1 +457,1 @@\n-      for (size_t c = _free_sets.rightmost_empty(Mutator) + 1; c > _free_sets.leftmost_empty(Mutator); c--) {\n+      for (size_t c = _partitions.rightmost_empty(Mutator) + 1; c > _partitions.leftmost_empty(Mutator); c--) {\n@@ -465,1 +459,1 @@\n-        if (_free_sets.in_free_set(idx, Mutator)) {\n+        if (_partitions.in_partition(idx, Mutator)) {\n@@ -516,1 +510,1 @@\n-                          free_memory_type_name(_free_sets.membership(r->index())),  r->index(), r->free());\n+                          partition_name(_partitions.membership(r->index())),  r->index(), r->free());\n@@ -531,1 +525,1 @@\n-                          free_memory_type_name(_free_sets.membership(r->index())),  r->index(), r->free());\n+                          partition_name(_partitions.membership(r->index())),  r->index(), r->free());\n@@ -539,1 +533,1 @@\n-      _free_sets.increase_used(Mutator, req.actual_size() * HeapWordSize);\n+      _partitions.increase_used(Mutator, req.actual_size() * HeapWordSize);\n@@ -551,1 +545,1 @@\n-    \/\/ Note that retire_within_free_set() increases used to account for waste.\n+    \/\/ Note that retire_within_partition() increases used to account for waste.\n@@ -559,2 +553,2 @@\n-    _free_sets.retire_within_free_set(idx, r->used());\n-    _free_sets.assert_bounds();\n+    _partitions.retire_within_partition(idx, r->used());\n+    _partitions.assert_bounds();\n@@ -572,1 +566,1 @@\n-  if (num > _free_sets.count(Mutator)) {\n+  if (num > _partitions.count(Mutator)) {\n@@ -579,1 +573,1 @@\n-  size_t beg = _free_sets.leftmost(Mutator);\n+  size_t beg = _partitions.leftmost(Mutator);\n@@ -583,1 +577,1 @@\n-    if (end >= _free_sets.max()) {\n+    if (end >= _partitions.max()) {\n@@ -590,1 +584,1 @@\n-    if (!_free_sets.in_free_set(end, Mutator) || !can_allocate_from(_heap->get_region(end))) {\n+    if (!_partitions.in_partition(end, Mutator) || !can_allocate_from(_heap->get_region(end))) {\n@@ -631,2 +625,2 @@\n-    \/\/ While individual regions report their true use, all humongous regions are marked used in the free set.\n-    _free_sets.retire_within_free_set(r->index(), ShenandoahHeapRegion::region_size_bytes());\n+    \/\/ While individual regions report their true use, all humongous regions are marked used in the free partition.\n+    _partitions.retire_within_partition(r->index(), ShenandoahHeapRegion::region_size_bytes());\n@@ -636,2 +630,2 @@\n-  _free_sets.increase_used(Mutator, total_humongous_size);\n-  _free_sets.assert_bounds();\n+  _partitions.increase_used(Mutator, total_humongous_size);\n+  _partitions.assert_bounds();\n@@ -666,1 +660,1 @@\n-  assert(_free_sets.in_free_set(idx, Mutator), \"Should be in mutator view\");\n+  assert(_partitions.in_partition(idx, Mutator), \"Should be in mutator view\");\n@@ -670,2 +664,2 @@\n-  _free_sets.move_to_set(idx, Collector, region_capacity);\n-  _free_sets.assert_bounds();\n+  _partitions.move_to_partition(idx, Collector, region_capacity);\n+  _partitions.assert_bounds();\n@@ -683,1 +677,1 @@\n-  _free_sets.clear_all();\n+  _partitions.make_all_regions_unavailable();\n@@ -686,2 +680,2 @@\n-\/\/ This function places all regions that have allocation capacity into the mutator_set.  Subsequently, we will\n-\/\/ move some of the mutator regions into the collector set with the intent of packing collector memory into the\n+\/\/ This function places all regions that have allocation capacity into the mutator_partition.  Subsequently, we will\n+\/\/ move some of the mutator regions into the collector partition with the intent of packing collector memory into the\n@@ -694,1 +688,1 @@\n-      \/\/ Trashed regions represent regions that had been in the collection set but have not yet been \"cleaned up\".\n+      \/\/ Trashed regions represent regions that had been in the collection partition but have not yet been \"cleaned up\".\n@@ -699,2 +693,2 @@\n-      assert(!region->is_cset(), \"Shouldn't be adding cset regions to the free set\");\n-      assert(_free_sets.in_free_set(idx, NotFree), \"We are about to make region free; it should not be free already\");\n+      assert(!region->is_cset(), \"Shouldn't be adding cset regions to the free partition\");\n+      assert(_partitions.in_partition(idx, NotFree), \"We are about to make region free; it should not be free already\");\n@@ -705,1 +699,1 @@\n-        _free_sets.make_free(idx, Mutator, ac);\n+        _partitions.make_free(idx, Mutator, ac);\n@@ -707,1 +701,1 @@\n-          \"  Adding Region \" SIZE_FORMAT \" (Free: \" SIZE_FORMAT \"%s, Used: \" SIZE_FORMAT \"%s) to mutator set\",\n+          \"  Adding Region \" SIZE_FORMAT \" (Free: \" SIZE_FORMAT \"%s, Used: \" SIZE_FORMAT \"%s) to mutator partition\",\n@@ -711,2 +705,2 @@\n-        assert(_free_sets.membership(idx) == NotFree,\n-               \"Region \" SIZE_FORMAT \" should not be in free set because capacity is \" SIZE_FORMAT, idx, ac);\n+        assert(_partitions.membership(idx) == NotFree,\n+               \"Region \" SIZE_FORMAT \" should not be in free partition because capacity is \" SIZE_FORMAT, idx, ac);\n@@ -715,2 +709,2 @@\n-      assert(_free_sets.membership(idx) == NotFree,\n-             \"Region \" SIZE_FORMAT \" should not be in free set because alloc is not allowed and not is trash\", idx);\n+      assert(_partitions.membership(idx) == NotFree,\n+             \"Region \" SIZE_FORMAT \" should not be in free partition because alloc is not allowed and not is trash\", idx);\n@@ -721,1 +715,1 @@\n-\/\/ Move no more than max_xfer_regions from the existing Collector free sets to the Mutator free set.\n+\/\/ Move no more than max_xfer_regions from the existing Collector free partitions to the Mutator free partition.\n@@ -726,1 +720,1 @@\n-void ShenandoahFreeSet::move_collector_sets_to_mutator(size_t max_xfer_regions) {\n+void ShenandoahFreeSet::move_regions_from_collector_to_mutator_partition(size_t max_xfer_regions) {\n@@ -731,2 +725,2 @@\n-  \/\/ Process empty regions within the Collector free set\n-  if ((max_xfer_regions > 0) && (_free_sets.leftmost_empty(Collector) <= _free_sets.rightmost_empty(Collector))) {\n+  \/\/ Process empty regions within the Collector free partition\n+  if ((max_xfer_regions > 0) && (_partitions.leftmost_empty(Collector) <= _partitions.rightmost_empty(Collector))) {\n@@ -734,4 +728,4 @@\n-    for (size_t idx = _free_sets.leftmost_empty(Collector);\n-         (max_xfer_regions > 0) && (idx <= _free_sets.rightmost_empty(Collector)); idx++) {\n-      if (_free_sets.in_free_set(idx, Collector) && can_allocate_from(idx)) {\n-        _free_sets.move_to_set(idx, Mutator, region_size_bytes);\n+    for (size_t idx = _partitions.leftmost_empty(Collector);\n+         (max_xfer_regions > 0) && (idx <= _partitions.rightmost_empty(Collector)); idx++) {\n+      if (_partitions.in_partition(idx, Collector) && can_allocate_from(idx)) {\n+        _partitions.move_to_partition(idx, Mutator, region_size_bytes);\n@@ -744,2 +738,2 @@\n-  \/\/ If there are any non-empty regions within Collector set, we can also move them to the Mutator free set\n-  if ((max_xfer_regions > 0) && (_free_sets.leftmost(Collector) <= _free_sets.rightmost(Collector))) {\n+  \/\/ If there are any non-empty regions within Collector partition, we can also move them to the Mutator free partition\n+  if ((max_xfer_regions > 0) && (_partitions.leftmost(Collector) <= _partitions.rightmost(Collector))) {\n@@ -747,1 +741,2 @@\n-    for (size_t idx = _free_sets.leftmost(Collector); (max_xfer_regions > 0) && (idx <= _free_sets.rightmost(Collector)); idx++) {\n+    for (size_t idx = _partitions.leftmost(Collector);\n+         (max_xfer_regions > 0) && (idx <= _partitions.rightmost(Collector)); idx++) {\n@@ -749,2 +744,2 @@\n-      if (_free_sets.in_free_set(idx, Collector) && (alloc_capacity > 0)) {\n-        _free_sets.move_to_set(idx, Mutator, alloc_capacity);\n+      if (_partitions.in_partition(idx, Collector) && (alloc_capacity > 0)) {\n+        _partitions.move_to_partition(idx, Mutator, alloc_capacity);\n@@ -758,1 +753,1 @@\n-  log_info(gc, free)(\"At start of update refs, moving \" SIZE_FORMAT \"%s to Mutator free set from Collector Reserve\",\n+  log_info(gc, free)(\"At start of update refs, moving \" SIZE_FORMAT \"%s to Mutator free partition from Collector Reserve\",\n@@ -766,1 +761,1 @@\n-  \/\/ This resets all state information, removing all regions from all sets.\n+  \/\/ This resets all state information, removing all regions from all partitions.\n@@ -770,2 +765,1 @@\n-  \/\/ This places regions that have alloc_capacity into the old_collector set if they identify as is_old() or the\n-  \/\/ mutator set otherwise.\n+  \/\/ This places regions that have alloc_capacity into the mutator partition.\n@@ -782,1 +776,1 @@\n-  size_t available_in_collector_set = _free_sets.capacity_of(Collector) - _free_sets.used_by(Collector);\n+  size_t available_in_collector_partition = _partitions.capacity_of(Collector) - _partitions.used_by(Collector);\n@@ -784,2 +778,2 @@\n-  if (available_in_collector_set < reserve) {\n-    additional_reserve = reserve - available_in_collector_set;\n+  if (available_in_collector_partition < reserve) {\n+    additional_reserve = reserve - available_in_collector_partition;\n@@ -791,1 +785,1 @@\n-  _free_sets.assert_bounds();\n+  _partitions.assert_bounds();\n@@ -801,3 +795,3 @@\n-\/\/ Having placed all regions that have allocation capacity into the mutator set, move some of these regions from\n-\/\/ the mutator set into the collector set in order to assure that the memory available for allocations within\n-\/\/ the collector set is at least to_reserve.\n+\/\/ Having placed all regions that have allocation capacity into the mutator partition, move some of these regions from\n+\/\/ the mutator partition into the collector partition in order to assure that the memory available for allocations within\n+\/\/ the collector partition is at least to_reserve.\n@@ -808,1 +802,1 @@\n-    if (!_free_sets.in_free_set(idx, Mutator)) {\n+    if (!_partitions.in_partition(idx, Mutator)) {\n@@ -813,1 +807,1 @@\n-    assert (ac > 0, \"Membership in free set implies has capacity\");\n+    assert (ac > 0, \"Membership in free partition implies has capacity\");\n@@ -815,1 +809,1 @@\n-    bool move_to_collector = _free_sets.capacity_of(Collector) < to_reserve;\n+    bool move_to_collector = _partitions.capacity_of(Collector) < to_reserve;\n@@ -826,1 +820,1 @@\n-      _free_sets.move_to_set(idx, Collector, ac);\n+      _partitions.move_to_partition(idx, Collector, ac);\n@@ -832,1 +826,1 @@\n-    size_t reserve = _free_sets.capacity_of(Collector);\n+    size_t reserve = _partitions.capacity_of(Collector);\n@@ -861,2 +855,2 @@\n-                        _free_sets.leftmost(Mutator), _free_sets.rightmost(Mutator),\n-                        _free_sets.leftmost(Collector), _free_sets.rightmost(Collector));\n+                        _partitions.leftmost(Mutator), _partitions.rightmost(Mutator),\n+                        _partitions.leftmost(Collector), _partitions.rightmost(Collector));\n@@ -870,1 +864,1 @@\n-      if (_free_sets.in_free_set(i, Mutator)) {\n+      if (_partitions.in_partition(i, Mutator)) {\n@@ -875,1 +869,1 @@\n-      } else if (_free_sets.in_free_set(i, Collector)) {\n+      } else if (_partitions.in_partition(i, Collector)) {\n@@ -911,2 +905,2 @@\n-      for (size_t idx = _free_sets.leftmost(Mutator); idx <= _free_sets.rightmost(Mutator); idx++) {\n-        if (_free_sets.in_free_set(idx, Mutator)) {\n+      for (size_t idx = _partitions.leftmost(Mutator); idx <= _partitions.rightmost(Mutator); idx++) {\n+        if (_partitions.in_partition(idx, Mutator)) {\n@@ -936,3 +930,3 @@\n-      \/\/ Since certain regions that belonged to the Mutator free set at the time of most recent rebuild may have been retired,\n-      \/\/ the sum of used and capacities within regions that are still in the Mutator free set may not match my internally tracked\n-      \/\/ values of used() and free().\n+      \/\/ Since certain regions that belonged to the Mutator free partition at the time of most recent rebuild may have been\n+      \/\/ retired, the sum of used and capacities within regions that are still in the Mutator free partition may not match\n+      \/\/ my internally tracked values of used() and free().\n@@ -957,2 +951,2 @@\n-      if (_free_sets.count(Mutator) > 0) {\n-        frag_int = (100 * (total_used \/ _free_sets.count(Mutator)) \/ ShenandoahHeapRegion::region_size_bytes());\n+      if (_partitions.count(Mutator) > 0) {\n+        frag_int = (100 * (total_used \/ _partitions.count(Mutator)) \/ ShenandoahHeapRegion::region_size_bytes());\n@@ -964,1 +958,1 @@\n-               byte_size_in_proper_unit(total_used), proper_unit_for_byte_size(total_used), _free_sets.count(Mutator));\n+               byte_size_in_proper_unit(total_used), proper_unit_for_byte_size(total_used), _partitions.count(Mutator));\n@@ -972,2 +966,2 @@\n-      for (size_t idx = _free_sets.leftmost(Collector); idx <= _free_sets.rightmost(Collector); idx++) {\n-        if (_free_sets.in_free_set(idx, Collector)) {\n+      for (size_t idx = _partitions.leftmost(Collector); idx <= _partitions.rightmost(Collector); idx++) {\n+        if (_partitions.in_partition(idx, Collector)) {\n@@ -1015,1 +1009,1 @@\n-  \/\/ Deliberately not locked, this method is unsafe when free set is modified.\n+  \/\/ Deliberately not locked, this method is unsafe when free partition is modified.\n@@ -1017,2 +1011,2 @@\n-  for (size_t index = _free_sets.leftmost(Mutator); index <= _free_sets.rightmost(Mutator); index++) {\n-    if (index < _free_sets.max() && _free_sets.in_free_set(index, Mutator)) {\n+  for (size_t index = _partitions.leftmost(Mutator); index <= _partitions.rightmost(Mutator); index++) {\n+    if (index < _partitions.max() && _partitions.in_partition(index, Mutator)) {\n@@ -1031,3 +1025,3 @@\n-  out->print_cr(\"Mutator Free Set: \" SIZE_FORMAT \"\", _free_sets.count(Mutator));\n-  for (size_t index = _free_sets.leftmost(Mutator); index <= _free_sets.rightmost(Mutator); index++) {\n-    if (_free_sets.in_free_set(index, Mutator)) {\n+  out->print_cr(\"Mutator Free Set: \" SIZE_FORMAT \"\", _partitions.count(Mutator));\n+  for (size_t index = _partitions.leftmost(Mutator); index <= _partitions.rightmost(Mutator); index++) {\n+    if (_partitions.in_partition(index, Mutator)) {\n@@ -1037,3 +1031,3 @@\n-  out->print_cr(\"Collector Free Set: \" SIZE_FORMAT \"\", _free_sets.count(Collector));\n-  for (size_t index = _free_sets.leftmost(Collector); index <= _free_sets.rightmost(Collector); index++) {\n-    if (_free_sets.in_free_set(index, Collector)) {\n+  out->print_cr(\"Collector Free Set: \" SIZE_FORMAT \"\", _partitions.count(Collector));\n+  for (size_t index = _partitions.leftmost(Collector); index <= _partitions.rightmost(Collector); index++) {\n+    if (_partitions.in_partition(index, Collector)) {\n@@ -1071,2 +1065,2 @@\n-  for (size_t index = _free_sets.leftmost(Mutator); index <= _free_sets.rightmost(Mutator); index++) {\n-    if (_free_sets.in_free_set(index, Mutator)) {\n+  for (size_t index = _partitions.leftmost(Mutator); index <= _partitions.rightmost(Mutator); index++) {\n+    if (_partitions.in_partition(index, Mutator)) {\n@@ -1109,2 +1103,2 @@\n-  for (size_t index = _free_sets.leftmost(Mutator); index <= _free_sets.rightmost(Mutator); index++) {\n-    if (_free_sets.in_free_set(index, Mutator)) {\n+  for (size_t index = _partitions.leftmost(Mutator); index <= _partitions.rightmost(Mutator); index++) {\n+    if (_partitions.in_partition(index, Mutator)) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":236,"deletions":242,"binary":false,"changes":478,"status":"modified"},{"patch":"@@ -33,5 +33,7 @@\n-enum ShenandoahFreeMemoryType : uint8_t {\n-  NotFree,\n-  Mutator,\n-  Collector,\n-  NumFreeSets\n+\/\/ Each ShenandoahHeapRegion is associated with a ShenandoahFreeSetPartitionId.\n+enum ShenandoahFreeSetPartitionId : uint8_t {\n+  NotFree,                      \/\/ Region has been retired and is not in any free set: there is no available memory.\n+  Mutator,                      \/\/ Region is in the Mutator free set: available memory is available to mutators.\n+  Collector,                    \/\/ Region is in the Collector free set: available memory is reserved for evacuations.\n+\n+  NumPartitions                 \/\/ This value represents the size of an array that may be indexed by NotFree, Mutator, Collector.\n@@ -40,1 +42,4 @@\n-class ShenandoahSetsOfFree {\n+\n+\/\/ This class implements partitioning of regions into distinct sets.  Each ShenandoahHeapRegion is either in the Mutator free set,\n+\/\/ the Collector free set, or in neither free set (NotFree).\n+class ShenandoahRegionPartition {\n@@ -43,8 +48,18 @@\n-  size_t _max;                  \/\/ The maximum number of heap regions\n-  ShenandoahFreeSet* _free_set;\n-  size_t _region_size_bytes;\n-  ShenandoahFreeMemoryType* _membership;\n-  size_t _leftmosts[NumFreeSets];\n-  size_t _rightmosts[NumFreeSets];\n-  size_t _leftmosts_empty[NumFreeSets];\n-  size_t _rightmosts_empty[NumFreeSets];\n+  const size_t _max;            \/\/ The maximum number of heap regions\n+  const size_t _region_size_bytes;\n+  const ShenandoahFreeSet* _free_set;\n+  ShenandoahFreeSetPartitionId* const _membership;\n+\n+  \/\/ For each type, we track an interval outside of which a region affiliated with that partition is guaranteed\n+  \/\/ not to be found. This makes searches for free space more efficient.  For each partition p, _leftmosts[p]\n+  \/\/ represents its least index, and its _rightmosts[p] its greatest index. Empty intervals are indicated by the\n+  \/\/ canonical [_max, 0].\n+  size_t _leftmosts[NumPartitions];\n+  size_t _rightmosts[NumPartitions];\n+\n+  \/\/ Allocation for humongous objects needs to find regions that are entirely empty.  For each partion p, _leftmosts[p]\n+  \/\/ represents the first region belonging to this partition that is completely empty and _rightmosts[p] represents the\n+  \/\/ last region that is completely empty.  If there are no completely empty regions in this partition, this is represented\n+  \/\/ by canonical [_max, 0].\n+  size_t _leftmosts_empty[NumPartitions];\n+  size_t _rightmosts_empty[NumPartitions];\n@@ -53,3 +68,3 @@\n-  size_t _capacity_of[NumFreeSets];\n-  size_t _used_by[NumFreeSets];\n-  size_t _region_counts[NumFreeSets];\n+  size_t _capacity_of[NumPartitions];\n+  size_t _used_by[NumPartitions];\n+  size_t _region_counts[NumPartitions];\n@@ -57,5 +72,2 @@\n-  inline void shrink_bounds_if_touched(ShenandoahFreeMemoryType set, size_t idx);\n-  inline void expand_bounds_maybe(ShenandoahFreeMemoryType set, size_t idx, size_t capacity);\n-\n-  \/\/ Restore all state variables to initial default state.\n-  void clear_internal();\n+  inline void shrink_interval_if_boundary_modified(ShenandoahFreeSetPartitionId partition, size_t idx);\n+  inline void expand_interval_if_boundary_modified(ShenandoahFreeSetPartitionId partition, size_t idx, size_t capacity);\n@@ -64,2 +76,2 @@\n-  ShenandoahSetsOfFree(size_t max_regions, ShenandoahFreeSet* free_set);\n-  ~ShenandoahSetsOfFree();\n+  ShenandoahRegionPartition(size_t max_regions, ShenandoahFreeSet* free_set);\n+  ~ShenandoahRegionPartition();\n@@ -68,1 +80,1 @@\n-  void clear_all();\n+  void make_all_regions_unavailable();\n@@ -70,5 +82,4 @@\n-  \/\/ Retire region idx from within its free set.  Requires that idx is in a free set.  The free set's original capacity\n-  \/\/ and usage are unaffected, but this region is no longer considered to be part of the free set insofar as future\n-  \/\/ allocation requests are concerned.  Any remnant of available memory at the time of retirement is added to the\n-  \/\/ original free set's total of used bytes.\n-  void retire_within_free_set(size_t idx, size_t used_bytes);\n+  \/\/ Retire region idx from within its partition.  Requires that region idx is in in Mutator or Collector partitions.\n+  \/\/ Moves this region to the NotFree partition.  Any remnant of available memory at the time of retirement is added to the\n+  \/\/ original partition's total of used bytes.\n+  void retire_within_partition(size_t idx, size_t used_bytes);\n@@ -76,2 +87,2 @@\n-  \/\/ Place region idx into free set which_set.  Requires that idx is currently NotFree.\n-  void make_free(size_t idx, ShenandoahFreeMemoryType which_set, size_t region_capacity);\n+  \/\/ Place region idx into free set which_partition.  Requires that idx is currently NotFree.\n+  void make_free(size_t idx, ShenandoahFreeSetPartitionId which_partition, size_t region_capacity);\n@@ -79,2 +90,2 @@\n-  \/\/ Place region idx into free set new_set.  Requires that idx is currently not NotFree.\n-  void move_to_set(size_t idx, ShenandoahFreeMemoryType new_set, size_t region_capacity);\n+  \/\/ Place region idx into free partition new_partition.  Requires that idx is currently not NotFree.\n+  void move_to_partition(size_t idx, ShenandoahFreeSetPartitionId new_partition, size_t region_capacity);\n@@ -82,1 +93,1 @@\n-  \/\/ Returns the ShenandoahFreeMemoryType affiliation of region idx, or NotFree if this region is not currently free.  This does\n+  \/\/ Returns the ShenandoahFreeSetPartitionId affiliation of region idx, or NotFree if this region is not currently free.  This does\n@@ -84,1 +95,1 @@\n-  inline ShenandoahFreeMemoryType membership(size_t idx) const;\n+  inline ShenandoahFreeSetPartitionId membership(size_t idx) const;\n@@ -87,2 +98,2 @@\n-  \/\/ set is not empty.  Requires that test_set != NotFree or NumFreeSets.\n-  inline bool in_free_set(size_t idx, ShenandoahFreeMemoryType which_set) const;\n+  \/\/ set is not empty.  Requires that test_set != NotFree or NumPartitions.\n+  inline bool in_partition(size_t idx, ShenandoahFreeSetPartitionId which_partition) const;\n@@ -95,1 +106,1 @@\n-  \/\/   if the requested which_set is empty:\n+  \/\/   if the requested which_partition is empty:\n@@ -99,4 +110,4 @@\n-  inline size_t leftmost(ShenandoahFreeMemoryType which_set) const;\n-  inline size_t rightmost(ShenandoahFreeMemoryType which_set) const;\n-  size_t leftmost_empty(ShenandoahFreeMemoryType which_set);\n-  size_t rightmost_empty(ShenandoahFreeMemoryType which_set);\n+  inline size_t leftmost(ShenandoahFreeSetPartitionId which_partition) const;\n+  inline size_t rightmost(ShenandoahFreeSetPartitionId which_partition) const;\n+  size_t leftmost_empty(ShenandoahFreeSetPartitionId which_partition);\n+  size_t rightmost_empty(ShenandoahFreeSetPartitionId which_partition);\n@@ -104,1 +115,1 @@\n-  inline bool is_empty(ShenandoahFreeMemoryType which_set) const;\n+  inline bool is_empty(ShenandoahFreeSetPartitionId which_partition) const;\n@@ -106,1 +117,1 @@\n-  inline void increase_used(ShenandoahFreeMemoryType which_set, size_t bytes);\n+  inline void increase_used(ShenandoahFreeSetPartitionId which_partition, size_t bytes);\n@@ -108,3 +119,3 @@\n-  inline size_t capacity_of(ShenandoahFreeMemoryType which_set) const {\n-    assert (which_set > NotFree && which_set < NumFreeSets, \"selected free set must be valid\");\n-    return _capacity_of[which_set];\n+  inline size_t capacity_of(ShenandoahFreeSetPartitionId which_partition) const {\n+    assert (which_partition > NotFree && which_partition < NumPartitions, \"selected free set must be valid\");\n+    return _capacity_of[which_partition];\n@@ -113,3 +124,3 @@\n-  inline size_t used_by(ShenandoahFreeMemoryType which_set) const {\n-    assert (which_set > NotFree && which_set < NumFreeSets, \"selected free set must be valid\");\n-    return _used_by[which_set];\n+  inline size_t used_by(ShenandoahFreeSetPartitionId which_partition) const {\n+    assert (which_partition > NotFree && which_partition < NumPartitions, \"selected free set must be valid\");\n+    return _used_by[which_partition];\n@@ -118,3 +129,3 @@\n-  inline void set_capacity_of(ShenandoahFreeMemoryType which_set, size_t value) {\n-    assert (which_set > NotFree && which_set < NumFreeSets, \"selected free set must be valid\");\n-    _capacity_of[which_set] = value;\n+  inline void set_capacity_of(ShenandoahFreeSetPartitionId which_partition, size_t value) {\n+    assert (which_partition > NotFree && which_partition < NumPartitions, \"selected free set must be valid\");\n+    _capacity_of[which_partition] = value;\n@@ -123,3 +134,3 @@\n-  inline void set_used_by(ShenandoahFreeMemoryType which_set, size_t value) {\n-    assert (which_set > NotFree && which_set < NumFreeSets, \"selected free set must be valid\");\n-    _used_by[which_set] = value;\n+  inline void set_used_by(ShenandoahFreeSetPartitionId which_partition, size_t value) {\n+    assert (which_partition > NotFree && which_partition < NumPartitions, \"selected free set must be valid\");\n+    _used_by[which_partition] = value;\n@@ -130,1 +141,1 @@\n-  inline size_t count(ShenandoahFreeMemoryType which_set) const { return _region_counts[which_set]; }\n+  inline size_t count(ShenandoahFreeSetPartitionId which_partition) const { return _region_counts[which_partition]; }\n@@ -158,1 +169,1 @@\n-  ShenandoahSetsOfFree _free_sets;\n+  ShenandoahRegionPartition _partitions;\n@@ -163,2 +174,3 @@\n-  \/\/ within a single HeapRegion as characterized by req.  The req.size() value is known to be less than or\n-  \/\/ equal to ShenandoahHeapRegion::humongous_threshold_words().\n+  \/\/ within a single HeapRegion as characterized by req.\n+  \/\/\n+  \/\/ Precondition: req.size() <= ShenandoahHeapRegion::humongous_threshold_words().\n@@ -166,0 +178,5 @@\n+\n+  \/\/ While holding the heap lock, allocate memory for a humongous object which will span multiple contiguous heap\n+  \/\/ regions.\n+  \/\/\n+  \/\/ Precondition: req.size() > ShenandoahHeapRegion::humongous_threshold_words().\n@@ -187,1 +204,1 @@\n-  \/\/ Public because ShenandoahSetsOfFree assertions require access.\n+  \/\/ Public because ShenandoahRegionPartition assertions require access.\n@@ -200,1 +217,1 @@\n-  void move_collector_sets_to_mutator(size_t cset_regions);\n+  void move_regions_from_collector_to_mutator_partition(size_t cset_regions);\n@@ -205,2 +222,2 @@\n-  inline size_t capacity()  const { return _free_sets.capacity_of(Mutator); }\n-  inline size_t used()      const { return _free_sets.used_by(Mutator);     }\n+  inline size_t capacity()  const { return _partitions.capacity_of(Mutator); }\n+  inline size_t used()      const { return _partitions.used_by(Mutator);     }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":82,"deletions":65,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -2077,1 +2077,1 @@\n-      _heap->free_set()->move_collector_sets_to_mutator(cset_regions);\n+      _heap->free_set()->move_regions_from_collector_to_mutator_partition(cset_regions);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}