{"files":[{"patch":"@@ -68,6 +68,6 @@\n-void ShenandoahRegionPartitions::dump_bitmap_range(ssize_t start_idx, ssize_t end_idx) const {\n-  assert((start_idx >= 0) && (start_idx < (ssize_t) _max), \"precondition\");\n-  assert((end_idx >= 0) && (end_idx < (ssize_t) _max), \"precondition\");\n-  ssize_t aligned_start = _membership[int(ShenandoahFreeSetPartitionId::Mutator)].aligned_index(start_idx);\n-  ssize_t aligned_end = _membership[int(ShenandoahFreeSetPartitionId::Mutator)].aligned_index(end_idx);\n-  ssize_t alignment = _membership[int(ShenandoahFreeSetPartitionId::Mutator)].alignment();\n+void ShenandoahRegionPartitions::dump_bitmap_range(idx_t start_idx, idx_t end_idx) const {\n+  assert((start_idx >= 0) && (start_idx < (idx_t) _max), \"precondition\");\n+  assert((end_idx >= 0) && (end_idx < (idx_t) _max), \"precondition\");\n+  idx_t aligned_start = _membership[int(ShenandoahFreeSetPartitionId::Mutator)].aligned_index(start_idx);\n+  idx_t aligned_end = _membership[int(ShenandoahFreeSetPartitionId::Mutator)].aligned_index(end_idx);\n+  idx_t alignment = _membership[int(ShenandoahFreeSetPartitionId::Mutator)].alignment();\n@@ -80,3 +80,3 @@\n-void ShenandoahRegionPartitions::dump_bitmap_row(ssize_t idx) const {\n-  assert((idx >= 0) && (idx < (ssize_t) _max), \"precondition\");\n-  ssize_t aligned_idx = _membership[int(ShenandoahFreeSetPartitionId::Mutator)].aligned_index(idx);\n+void ShenandoahRegionPartitions::dump_bitmap_row(idx_t idx) const {\n+  assert((idx >= 0) && (idx < (idx_t) _max), \"precondition\");\n+  idx_t aligned_idx = _membership[int(ShenandoahFreeSetPartitionId::Mutator)].aligned_index(idx);\n@@ -130,1 +130,1 @@\n-inline ssize_t ShenandoahRegionPartitions:: leftmost(ShenandoahFreeSetPartitionId which_partition) const {\n+inline idx_t ShenandoahRegionPartitions:: leftmost(ShenandoahFreeSetPartitionId which_partition) const {\n@@ -132,1 +132,1 @@\n-  ssize_t idx = _leftmosts[int(which_partition)];\n+  idx_t idx = _leftmosts[int(which_partition)];\n@@ -141,1 +141,1 @@\n-inline ssize_t ShenandoahRegionPartitions::rightmost(ShenandoahFreeSetPartitionId which_partition) const {\n+inline idx_t ShenandoahRegionPartitions::rightmost(ShenandoahFreeSetPartitionId which_partition) const {\n@@ -143,1 +143,1 @@\n-  ssize_t idx = _rightmosts[int(which_partition)];\n+  idx_t idx = _rightmosts[int(which_partition)];\n@@ -161,2 +161,2 @@\n-void ShenandoahRegionPartitions::establish_intervals(ssize_t mutator_leftmost, ssize_t mutator_rightmost,\n-                                                     ssize_t mutator_leftmost_empty, ssize_t mutator_rightmost_empty,\n+void ShenandoahRegionPartitions::establish_intervals(idx_t mutator_leftmost, idx_t mutator_rightmost,\n+                                                     idx_t mutator_leftmost_empty, idx_t mutator_rightmost_empty,\n@@ -193,1 +193,1 @@\n-  ShenandoahFreeSetPartitionId partition, ssize_t low_idx, ssize_t high_idx) {\n+  ShenandoahFreeSetPartitionId partition, idx_t low_idx, idx_t high_idx) {\n@@ -227,1 +227,1 @@\n-inline void ShenandoahRegionPartitions::shrink_interval_if_boundary_modified(ShenandoahFreeSetPartitionId partition, ssize_t idx) {\n+inline void ShenandoahRegionPartitions::shrink_interval_if_boundary_modified(ShenandoahFreeSetPartitionId partition, idx_t idx) {\n@@ -262,1 +262,1 @@\n-                                                                             ssize_t idx, size_t region_available) {\n+                                                                             idx_t idx, size_t region_available) {\n@@ -280,1 +280,1 @@\n-  ShenandoahFreeSetPartitionId partition, ssize_t low_idx, ssize_t high_idx) {\n+  ShenandoahFreeSetPartitionId partition, idx_t low_idx, idx_t high_idx) {\n@@ -287,1 +287,1 @@\n-  for (ssize_t idx = low_idx; idx <= high_idx; idx++) {\n+  for (idx_t idx = low_idx; idx <= high_idx; idx++) {\n@@ -295,1 +295,1 @@\n-void ShenandoahRegionPartitions::retire_from_partition(ShenandoahFreeSetPartitionId partition, ssize_t idx, size_t used_bytes) {\n+void ShenandoahRegionPartitions::retire_from_partition(ShenandoahFreeSetPartitionId partition, idx_t idx, size_t used_bytes) {\n@@ -311,1 +311,1 @@\n-void ShenandoahRegionPartitions::make_free(ssize_t idx, ShenandoahFreeSetPartitionId which_partition, size_t available) {\n+void ShenandoahRegionPartitions::make_free(idx_t idx, ShenandoahFreeSetPartitionId which_partition, size_t available) {\n@@ -325,1 +325,1 @@\n-void ShenandoahRegionPartitions::move_from_partition_to_partition(ssize_t idx, ShenandoahFreeSetPartitionId orig_partition,\n+void ShenandoahRegionPartitions::move_from_partition_to_partition(idx_t idx, ShenandoahFreeSetPartitionId orig_partition,\n@@ -362,1 +362,1 @@\n-const char* ShenandoahRegionPartitions::partition_membership_name(ssize_t idx) const {\n+const char* ShenandoahRegionPartitions::partition_membership_name(idx_t idx) const {\n@@ -376,1 +376,1 @@\n-inline ShenandoahFreeSetPartitionId ShenandoahRegionPartitions::membership(ssize_t idx) const {\n+inline ShenandoahFreeSetPartitionId ShenandoahRegionPartitions::membership(idx_t idx) const {\n@@ -388,1 +388,1 @@\n-inline bool ShenandoahRegionPartitions::partition_id_matches(ssize_t idx, ShenandoahFreeSetPartitionId test_partition) const {\n+inline bool ShenandoahRegionPartitions::partition_id_matches(idx_t idx, ShenandoahFreeSetPartitionId test_partition) const {\n@@ -401,4 +401,4 @@\n-inline ssize_t ShenandoahRegionPartitions::find_index_of_next_available_region(\n-  ShenandoahFreeSetPartitionId which_partition, ssize_t start_index) const {\n-  ssize_t rightmost_idx = rightmost(which_partition);\n-  ssize_t leftmost_idx = leftmost(which_partition);\n+inline idx_t ShenandoahRegionPartitions::find_index_of_next_available_region(\n+  ShenandoahFreeSetPartitionId which_partition, idx_t start_index) const {\n+  idx_t rightmost_idx = rightmost(which_partition);\n+  idx_t leftmost_idx = leftmost(which_partition);\n@@ -409,1 +409,1 @@\n-  ssize_t result = _membership[int(which_partition)].find_next_set_bit(start_index, rightmost_idx + 1);\n+  idx_t result = _membership[int(which_partition)].find_first_set_bit(start_index, rightmost_idx + 1);\n@@ -413,4 +413,4 @@\n-inline ssize_t ShenandoahRegionPartitions::find_index_of_previous_available_region(\n-  ShenandoahFreeSetPartitionId which_partition, ssize_t last_index) const {\n-  ssize_t rightmost_idx = rightmost(which_partition);\n-  ssize_t leftmost_idx = leftmost(which_partition);\n+inline idx_t ShenandoahRegionPartitions::find_index_of_previous_available_region(\n+  ShenandoahFreeSetPartitionId which_partition, idx_t last_index) const {\n+  idx_t rightmost_idx = rightmost(which_partition);\n+  idx_t leftmost_idx = leftmost(which_partition);\n@@ -422,1 +422,1 @@\n-  ssize_t result = _membership[int(which_partition)].find_prev_set_bit(last_index, -1);\n+  idx_t result = _membership[int(which_partition)].find_last_set_bit(-1, last_index);\n@@ -426,4 +426,4 @@\n-inline ssize_t ShenandoahRegionPartitions::find_index_of_next_available_cluster_of_regions(\n-  ShenandoahFreeSetPartitionId which_partition, ssize_t start_index, size_t cluster_size) const {\n-  ssize_t rightmost_idx = rightmost(which_partition);\n-  ssize_t leftmost_idx = leftmost(which_partition);\n+inline idx_t ShenandoahRegionPartitions::find_index_of_next_available_cluster_of_regions(\n+  ShenandoahFreeSetPartitionId which_partition, idx_t start_index, size_t cluster_size) const {\n+  idx_t rightmost_idx = rightmost(which_partition);\n+  idx_t leftmost_idx = leftmost(which_partition);\n@@ -431,1 +431,1 @@\n-  ssize_t result = _membership[int(which_partition)].find_next_consecutive_bits(cluster_size, start_index, rightmost_idx + 1);\n+  idx_t result = _membership[int(which_partition)].find_first_consecutive_set_bits(start_index, rightmost_idx + 1, cluster_size);\n@@ -435,3 +435,3 @@\n-inline ssize_t ShenandoahRegionPartitions::find_index_of_previous_available_cluster_of_regions(\n-  ShenandoahFreeSetPartitionId which_partition, ssize_t last_index, size_t cluster_size) const {\n-  ssize_t leftmost_idx = leftmost(which_partition);\n+inline idx_t ShenandoahRegionPartitions::find_index_of_previous_available_cluster_of_regions(\n+  ShenandoahFreeSetPartitionId which_partition, idx_t last_index, size_t cluster_size) const {\n+  idx_t leftmost_idx = leftmost(which_partition);\n@@ -440,1 +440,1 @@\n-  ssize_t result = _membership[int(which_partition)].find_prev_consecutive_bits(cluster_size, last_index, leftmost_idx - 1);\n+  idx_t result = _membership[int(which_partition)].find_last_consecutive_set_bits(leftmost_idx - 1, last_index, cluster_size);\n@@ -444,1 +444,1 @@\n-ssize_t ShenandoahRegionPartitions::leftmost_empty(ShenandoahFreeSetPartitionId which_partition) {\n+idx_t ShenandoahRegionPartitions::leftmost_empty(ShenandoahFreeSetPartitionId which_partition) {\n@@ -446,1 +446,1 @@\n-  ssize_t max_regions = _max;\n+  idx_t max_regions = _max;\n@@ -450,1 +450,1 @@\n-  for (ssize_t idx = find_index_of_next_available_region(which_partition, _leftmosts_empty[int(which_partition)]);\n+  for (idx_t idx = find_index_of_next_available_region(which_partition, _leftmosts_empty[int(which_partition)]);\n@@ -452,1 +452,1 @@\n-    assert(in_free_set(which_partition, idx), \"Boundaries or find_prev_set_bit failed: \" SSIZE_FORMAT, idx);\n+    assert(in_free_set(which_partition, idx), \"Boundaries or find_last_set_bit failed: \" SSIZE_FORMAT, idx);\n@@ -464,1 +464,1 @@\n-ssize_t ShenandoahRegionPartitions::rightmost_empty(ShenandoahFreeSetPartitionId which_partition) {\n+idx_t ShenandoahRegionPartitions::rightmost_empty(ShenandoahFreeSetPartitionId which_partition) {\n@@ -469,1 +469,1 @@\n-  for (ssize_t idx = find_index_of_previous_available_region(which_partition, _rightmosts_empty[int(which_partition)]);\n+  for (idx_t idx = find_index_of_previous_available_region(which_partition, _rightmosts_empty[int(which_partition)]);\n@@ -471,1 +471,1 @@\n-    assert(in_free_set(which_partition, idx), \"Boundaries or find_prev_set_bit failed: \" SSIZE_FORMAT, idx);\n+    assert(in_free_set(which_partition, idx), \"Boundaries or find_last_set_bit failed: \" SSIZE_FORMAT, idx);\n@@ -487,4 +487,4 @@\n-  ssize_t leftmosts[NumPartitions];\n-  ssize_t rightmosts[NumPartitions];\n-  ssize_t empty_leftmosts[NumPartitions];\n-  ssize_t empty_rightmosts[NumPartitions];\n+  idx_t leftmosts[NumPartitions];\n+  idx_t rightmosts[NumPartitions];\n+  idx_t empty_leftmosts[NumPartitions];\n+  idx_t empty_rightmosts[NumPartitions];\n@@ -499,1 +499,1 @@\n-  for (ssize_t i = 0; i < _max; i++) {\n+  for (idx_t i = 0; i < _max; i++) {\n@@ -546,2 +546,2 @@\n-  ssize_t beg_off = leftmosts[int(ShenandoahFreeSetPartitionId::Mutator)];\n-  ssize_t end_off = rightmosts[int(ShenandoahFreeSetPartitionId::Mutator)];\n+  idx_t beg_off = leftmosts[int(ShenandoahFreeSetPartitionId::Mutator)];\n+  idx_t end_off = rightmosts[int(ShenandoahFreeSetPartitionId::Mutator)];\n@@ -643,1 +643,1 @@\n-        ssize_t non_empty_on_left = (_partitions.leftmost_empty(ShenandoahFreeSetPartitionId::Mutator)\n+        idx_t non_empty_on_left = (_partitions.leftmost_empty(ShenandoahFreeSetPartitionId::Mutator)\n@@ -645,1 +645,1 @@\n-        ssize_t non_empty_on_right = (_partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator)\n+        idx_t non_empty_on_right = (_partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator)\n@@ -654,2 +654,2 @@\n-          ssize_t leftmost = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator);\n-          for (ssize_t idx = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator); idx >= leftmost; ) {\n+          idx_t leftmost = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator);\n+          for (idx_t idx = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator); idx >= leftmost; ) {\n@@ -657,1 +657,1 @@\n-                   \"Boundaries or find_prev_set_bit failed: \" SSIZE_FORMAT, idx);\n+                   \"Boundaries or find_last_set_bit failed: \" SSIZE_FORMAT, idx);\n@@ -674,2 +674,2 @@\n-          ssize_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator);\n-          for (ssize_t idx = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator); idx <= rightmost; ) {\n+          idx_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator);\n+          for (idx_t idx = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator); idx <= rightmost; ) {\n@@ -677,1 +677,1 @@\n-                   \"Boundaries or find_prev_set_bit failed: \" SSIZE_FORMAT, idx);\n+                   \"Boundaries or find_last_set_bit failed: \" SSIZE_FORMAT, idx);\n@@ -697,2 +697,2 @@\n-      ssize_t leftmost_collector = _partitions.leftmost(ShenandoahFreeSetPartitionId::Collector);\n-      for (ssize_t idx = _partitions.rightmost(ShenandoahFreeSetPartitionId::Collector); idx >= leftmost_collector; ) {\n+      idx_t leftmost_collector = _partitions.leftmost(ShenandoahFreeSetPartitionId::Collector);\n+      for (idx_t idx = _partitions.rightmost(ShenandoahFreeSetPartitionId::Collector); idx >= leftmost_collector; ) {\n@@ -700,1 +700,1 @@\n-               \"Boundaries or find_prev_set_bit failed: \" SSIZE_FORMAT, idx);\n+               \"Boundaries or find_prev_last_bit failed: \" SSIZE_FORMAT, idx);\n@@ -714,2 +714,2 @@\n-      ssize_t leftmost_mutator_empty = _partitions.leftmost_empty(ShenandoahFreeSetPartitionId::Mutator);\n-      for (ssize_t idx = _partitions.rightmost_empty(ShenandoahFreeSetPartitionId::Mutator); idx >= leftmost_mutator_empty; ) {\n+      idx_t leftmost_mutator_empty = _partitions.leftmost_empty(ShenandoahFreeSetPartitionId::Mutator);\n+      for (idx_t idx = _partitions.rightmost_empty(ShenandoahFreeSetPartitionId::Mutator); idx >= leftmost_mutator_empty; ) {\n@@ -717,1 +717,1 @@\n-               \"Boundaries or find_prev_set_bit failed: \" SSIZE_FORMAT, idx);\n+               \"Boundaries or find_prev_last_bit failed: \" SSIZE_FORMAT, idx);\n@@ -825,1 +825,1 @@\n-  ssize_t num = ShenandoahHeapRegion::required_regions(words_size * HeapWordSize);\n+  idx_t num = ShenandoahHeapRegion::required_regions(words_size * HeapWordSize);\n@@ -828,1 +828,1 @@\n-  if (num > (ssize_t) _partitions.count(ShenandoahFreeSetPartitionId::Mutator)) {\n+  if (num > (idx_t) _partitions.count(ShenandoahFreeSetPartitionId::Mutator)) {\n@@ -832,3 +832,3 @@\n-  ssize_t start_range = _partitions.leftmost_empty(ShenandoahFreeSetPartitionId::Mutator);\n-  ssize_t end_range = _partitions.rightmost_empty(ShenandoahFreeSetPartitionId::Mutator) + 1;\n-  ssize_t last_possible_start = end_range - num;\n+  idx_t start_range = _partitions.leftmost_empty(ShenandoahFreeSetPartitionId::Mutator);\n+  idx_t end_range = _partitions.rightmost_empty(ShenandoahFreeSetPartitionId::Mutator) + 1;\n+  idx_t last_possible_start = end_range - num;\n@@ -838,1 +838,1 @@\n-  ssize_t beg = _partitions.find_index_of_next_available_cluster_of_regions(ShenandoahFreeSetPartitionId::Mutator,\n+  idx_t beg = _partitions.find_index_of_next_available_cluster_of_regions(ShenandoahFreeSetPartitionId::Mutator,\n@@ -844,1 +844,1 @@\n-  ssize_t end = beg;\n+  idx_t end = beg;\n@@ -852,1 +852,1 @@\n-      ssize_t slide_delta = end + 1 - beg;\n+      idx_t slide_delta = end + 1 - beg;\n@@ -857,1 +857,1 @@\n-      for (ssize_t span_end = beg + num; slide_delta > 0; slide_delta--) {\n+      for (idx_t span_end = beg + num; slide_delta > 0; slide_delta--) {\n@@ -885,1 +885,1 @@\n-  for (ssize_t i = beg; i <= end; i++) {\n+  for (idx_t i = beg; i <= end; i++) {\n@@ -1037,2 +1037,2 @@\n-    ssize_t rightmost = _partitions.rightmost_empty(ShenandoahFreeSetPartitionId::Collector);\n-    for (ssize_t idx = _partitions.leftmost_empty(ShenandoahFreeSetPartitionId::Collector);\n+    idx_t rightmost = _partitions.rightmost_empty(ShenandoahFreeSetPartitionId::Collector);\n+    for (idx_t idx = _partitions.leftmost_empty(ShenandoahFreeSetPartitionId::Collector);\n@@ -1041,1 +1041,1 @@\n-             \"Boundaries or find_next_set_bit failed: \" SSIZE_FORMAT, idx);\n+             \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, idx);\n@@ -1057,2 +1057,2 @@\n-    ssize_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Collector);\n-    for (ssize_t idx = _partitions.leftmost(ShenandoahFreeSetPartitionId::Collector);\n+    idx_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Collector);\n+    for (idx_t idx = _partitions.leftmost(ShenandoahFreeSetPartitionId::Collector);\n@@ -1061,1 +1061,1 @@\n-             \"Boundaries or find_next_set_bit failed: \" SSIZE_FORMAT, idx);\n+             \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, idx);\n@@ -1108,1 +1108,1 @@\n-void ShenandoahFreeSet::rebuild() {\n+void ShenandoahFreeSet::rebuild()y {\n@@ -1219,1 +1219,1 @@\n-      ssize_t last_idx = 0;\n+      idx_t last_idx = 0;\n@@ -1228,1 +1228,1 @@\n-      for (ssize_t idx = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator);\n+      for (idx_t idx = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator);\n@@ -1292,1 +1292,1 @@\n-      for (ssize_t idx = _partitions.leftmost(ShenandoahFreeSetPartitionId::Collector);\n+      for (idx_t idx = _partitions.leftmost(ShenandoahFreeSetPartitionId::Collector);\n@@ -1335,2 +1335,2 @@\n-  ssize_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator);\n-  for (ssize_t index = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator); index <= rightmost; ) {\n+  idx_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator);\n+  for (idx_t index = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator); index <= rightmost; ) {\n@@ -1338,1 +1338,1 @@\n-           \"Boundaries or find_next_set_bit failed: \" SSIZE_FORMAT, index);\n+           \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, index);\n@@ -1344,1 +1344,1 @@\n-  for (ssize_t index = _partitions.leftmost(ShenandoahFreeSetPartitionId::Collector); index <= rightmost; ) {\n+  for (idx_t index = _partitions.leftmost(ShenandoahFreeSetPartitionId::Collector); index <= rightmost; ) {\n@@ -1346,1 +1346,1 @@\n-           \"Boundaries or find_next_set_bit failed: \" SSIZE_FORMAT, index);\n+           \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, index);\n@@ -1357,2 +1357,2 @@\n-  ssize_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator);\n-  for (ssize_t index = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator); index <= rightmost; ) {\n+  idx_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator);\n+  for (idx_t index = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator); index <= rightmost; ) {\n@@ -1360,1 +1360,1 @@\n-           \"Boundaries or find_next_set_bit failed: \" SSIZE_FORMAT, index);\n+           \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, index);\n@@ -1378,1 +1378,1 @@\n-  ssize_t last_idx = 0;\n+  idx_t last_idx = 0;\n@@ -1384,2 +1384,2 @@\n-  ssize_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator);\n-  for (ssize_t index = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator); index <= rightmost; ) {\n+  idx_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator);\n+  for (idx_t index = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator); index <= rightmost; ) {\n@@ -1387,1 +1387,1 @@\n-           \"Boundaries or find_next_set_bit failed: \" SSIZE_FORMAT, index);\n+           \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, index);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":105,"deletions":105,"binary":false,"changes":210,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-size_t ShenandoahSimpleBitMap::count_leading_ones(ssize_t start_idx) const {\n+size_t ShenandoahSimpleBitMap::count_leading_ones(idx_t start_idx) const {\n@@ -47,1 +47,1 @@\n-size_t ShenandoahSimpleBitMap::count_trailing_ones(ssize_t last_idx) const {\n+size_t ShenandoahSimpleBitMap::count_trailing_ones(idx_t last_idx) const {\n@@ -65,1 +65,1 @@\n-bool ShenandoahSimpleBitMap::is_forward_consecutive_ones(ssize_t start_idx, ssize_t count) const {\n+bool ShenandoahSimpleBitMap::is_forward_consecutive_ones(idx_t start_idx, idx_t count) const {\n@@ -69,1 +69,1 @@\n-    assert(start_idx + count <= (ssize_t) _num_bits, \"precondition\");\n+    assert(start_idx + count <= (idx_t) _num_bits, \"precondition\");\n@@ -95,1 +95,1 @@\n-bool ShenandoahSimpleBitMap::is_backward_consecutive_ones(ssize_t last_idx, ssize_t count) const {\n+bool ShenandoahSimpleBitMap::is_backward_consecutive_ones(idx_t last_idx, idx_t count) const {\n@@ -124,2 +124,2 @@\n-ssize_t ShenandoahSimpleBitMap::find_next_consecutive_bits(size_t num_bits, ssize_t start_idx, ssize_t boundary_idx) const {\n-  assert((start_idx >= 0) && (start_idx < _num_bits), \"precondition\");\n+idx_t ShenandoahSimpleBitMap::find_first_consecutive_set_bits(idx_t beg, idx_t end, size_t num_bits) const {\n+  assert((beg >= 0) && (beg < _num_bits), \"precondition\");\n@@ -128,3 +128,3 @@\n-  ssize_t start_boundary = boundary_idx - num_bits;\n-  if (start_idx > start_boundary) {\n-    return boundary_idx;\n+  idx_t start_boundary = end - num_bits;\n+  if (beg > start_boundary) {\n+    return end;\n@@ -132,2 +132,2 @@\n-  uintx array_idx = start_idx >> LogBitsPerWord;\n-  uintx bit_number = start_idx & right_n_bits(LogBitsPerWord);\n+  uintx array_idx = beg >> LogBitsPerWord;\n+  uintx bit_number = beg & right_n_bits(LogBitsPerWord);\n@@ -142,2 +142,2 @@\n-      start_idx += BitsPerWord - bit_number;\n-      if (start_idx > start_boundary) {\n+      beg += BitsPerWord - bit_number;\n+      if (beg > start_boundary) {\n@@ -145,1 +145,1 @@\n-        return boundary_idx;\n+        return end;\n@@ -150,2 +150,2 @@\n-    } else if (is_forward_consecutive_ones(start_idx, num_bits)) {\n-      return start_idx;\n+    } else if (is_forward_consecutive_ones(beg, num_bits)) {\n+      return beg;\n@@ -158,2 +158,2 @@\n-      size_t trailing_ones = count_trailing_ones(start_idx + num_bits - 1);\n-      uintx next_start_candidate_2 = start_idx + num_bits - trailing_ones;\n+      size_t trailing_ones = count_trailing_ones(beg + num_bits - 1);\n+      uintx next_start_candidate_2 = beg + num_bits - trailing_ones;\n@@ -161,2 +161,2 @@\n-      start_idx = MAX2(next_start_candidate_1, next_start_candidate_2);\n-      if (start_idx > start_boundary) {\n+      beg = MAX2(next_start_candidate_1, next_start_candidate_2);\n+      if (beg > start_boundary) {\n@@ -164,1 +164,1 @@\n-        return boundary_idx;\n+        return end;\n@@ -166,1 +166,1 @@\n-      array_idx = start_idx >> LogBitsPerWord;\n+      array_idx = beg >> LogBitsPerWord;\n@@ -168,1 +168,1 @@\n-      bit_number = start_idx & right_n_bits(LogBitsPerWord);\n+      bit_number = beg & right_n_bits(LogBitsPerWord);\n@@ -177,3 +177,3 @@\n-ssize_t ShenandoahSimpleBitMap::find_prev_consecutive_bits(const size_t num_bits,\n-                                                           ssize_t last_idx, const ssize_t boundary_idx) const {\n-  assert((last_idx >= 0) && (last_idx < _num_bits), \"precondition\");\n+idx_t ShenandoahSimpleBitMap::find_last_consecutive_set_bits(const idx_t beg, idx_t end, const size_t num_bits) const {\n+                                                             \n+  assert((end >= 0) && (end < _num_bits), \"precondition\");\n@@ -182,3 +182,3 @@\n-  ssize_t last_boundary = boundary_idx + num_bits;\n-  if (last_idx < last_boundary) {\n-    return boundary_idx;\n+  idx_t last_boundary = beg + num_bits;\n+  if (end < last_boundary) {\n+    return beg;\n@@ -187,2 +187,2 @@\n-  size_t array_idx = last_idx >> LogBitsPerWord;\n-  uintx bit_number = last_idx & right_n_bits(LogBitsPerWord);\n+  size_t array_idx = end >> LogBitsPerWord;\n+  uintx bit_number = end & right_n_bits(LogBitsPerWord);\n@@ -197,2 +197,2 @@\n-      last_idx -= bit_number + 1;\n-      if (last_idx < last_boundary) {\n+      end -= bit_number + 1;\n+      if (end < last_boundary) {\n@@ -200,1 +200,1 @@\n-        return boundary_idx;\n+        return beg;\n@@ -205,2 +205,2 @@\n-    } else if (is_backward_consecutive_ones(last_idx, num_bits)) {\n-      return last_idx + 1 - num_bits;\n+    } else if (is_backward_consecutive_ones(end, num_bits)) {\n+      return end + 1 - num_bits;\n@@ -213,2 +213,2 @@\n-      size_t leading_ones = count_leading_ones(last_idx - (num_bits - 1));\n-      uintx next_last_candidate_2 = last_idx - (num_bits - leading_ones);\n+      size_t leading_ones = count_leading_ones(end - (num_bits - 1));\n+      uintx next_last_candidate_2 = end - (num_bits - leading_ones);\n@@ -216,2 +216,2 @@\n-      last_idx = MIN2(next_last_candidate_1, next_last_candidate_2);\n-      if (last_idx < last_boundary) {\n+      end = MIN2(next_last_candidate_1, next_last_candidate_2);\n+      if (end < last_boundary) {\n@@ -219,1 +219,1 @@\n-        return boundary_idx;\n+        return beg;\n@@ -221,2 +221,2 @@\n-      array_idx = last_idx >> LogBitsPerWord;\n-      bit_number = last_idx & right_n_bits(LogBitsPerWord);\n+      array_idx = end >> LogBitsPerWord;\n+      bit_number = end & right_n_bits(LogBitsPerWord);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSimpleBitMap.cpp","additions":44,"deletions":44,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -29,1 +29,10 @@\n-\/\/ The API and internal implementation of ShenandoahSimpleBitMap and ShenandoahRegionPartitions use ssize_t to\n+\/\/ TODO: Merge the enhanced capabilities of ShenandoahSimpleBitMap into src\/hotspot\/share\/utilities\/bitMap.hpp\n+\/\/       and deprecate ShenandoahSimpleBitMap.  The key enhanced capabilities to be integrated include:\n+\/\/\n+\/\/   1. Allow searches from high to low memory (when biasing allocations towards the top of the heap)\n+\/\/   2. Allow searches for clusters of contiguous set bits (to expedite allocation for humongous objects)\n+\/\/\n+\/\/ idx_t is defined here as ssize_t.  In src\/hotspot\/share\/utiliities\/bitMap.hpp, idx is defined as size_t.\n+\/\/ This is a significant incompatibility.\n+\/\/\n+\/\/ The API and internal implementation of ShenandoahSimpleBitMap and ShenandoahRegionPartitions use idx_t to\n@@ -36,2 +45,4 @@\n-\/\/ ShenandoahSimpleBitMap resembles CHeapBitMap but adds missing support for find_next_consecutive_bits() and\n-\/\/ find_prev_contiguous_bits.  An alternative refactoring of code would subclass CHeapBitMap, but this might\n+typedef ssize_t idx_t;\n+\n+\/\/ ShenandoahSimpleBitMap resembles CHeapBitMap but adds missing support for find_first_consecutive_set_bits() and\n+\/\/ find_last_consecutive_set_bits.  An alternative refactoring of code would subclass CHeapBitMap, but this might\n@@ -41,1 +52,1 @@\n-  const ssize_t _num_bits;\n+  const idx_t _num_bits;\n@@ -69,1 +80,1 @@\n-  size_t count_leading_ones(ssize_t start_idx) const;\n+  size_t count_leading_ones(idx_t start_idx) const;\n@@ -73,1 +84,1 @@\n-  size_t count_trailing_ones(ssize_t last_idx) const;\n+  size_t count_trailing_ones(idx_t last_idx) const;\n@@ -75,2 +86,2 @@\n-  bool is_forward_consecutive_ones(ssize_t start_idx, ssize_t count) const;\n-  bool is_backward_consecutive_ones(ssize_t last_idx, ssize_t count) const;\n+  bool is_forward_consecutive_ones(idx_t start_idx, idx_t count) const;\n+  bool is_backward_consecutive_ones(idx_t last_idx, idx_t count) const;\n@@ -80,1 +91,1 @@\n-  inline ssize_t aligned_index(ssize_t idx) const {\n+  inline idx_t aligned_index(idx_t idx) const {\n@@ -82,1 +93,1 @@\n-    ssize_t array_idx = idx & ~right_n_bits(LogBitsPerWord);\n+    idx_t array_idx = idx & ~right_n_bits(LogBitsPerWord);\n@@ -86,1 +97,1 @@\n-  inline ssize_t alignment() const {\n+  inline idx_t alignment() const {\n@@ -91,1 +102,1 @@\n-  inline ssize_t number_of_bits() const {\n+  inline idx_t size() const {\n@@ -95,1 +106,2 @@\n-  inline uintx bits_at(ssize_t idx) const {\n+  \/\/ Return the word that holds idx bit and its neighboring bits.\n+  inline uintx bits_at(idx_t idx) const {\n@@ -97,1 +109,1 @@\n-    ssize_t array_idx = idx >> LogBitsPerWord;\n+    idx_t array_idx = idx >> LogBitsPerWord;\n@@ -101,1 +113,1 @@\n-  inline void set_bit(ssize_t idx) {\n+  inline void set_bit(idx_t idx) {\n@@ -109,1 +121,1 @@\n-  inline void clear_bit(ssize_t idx) {\n+  inline void clear_bit(idx_t idx) {\n@@ -118,1 +130,1 @@\n-  inline bool is_set(ssize_t idx) const {\n+  inline bool is_set(idx_t idx) const {\n@@ -127,30 +139,35 @@\n-  \/\/ Return the index of the first set bit which is greater or equal to start_idx.  If not found, return _num_bits.\n-  inline ssize_t find_next_set_bit(ssize_t start_idx) const;\n-\n-  \/\/ Return the index of the first set bit which is greater or equal to start_idx and less than boundary_idx.\n-  \/\/ If not found, return boundary_idx\n-  inline ssize_t find_next_set_bit(ssize_t start_idx, ssize_t boundary_idx) const;\n-\n-  \/\/ Return the index of the last set bit which is less or equal to start_idx.  If not found, return -1.\n-  inline ssize_t find_prev_set_bit(ssize_t last_idx) const;\n-\n-  \/\/ Return the index of the last set bit which is less or equal to start_idx and greater than boundary_idx.\n-  \/\/ If not found, return boundary_idx.\n-  inline ssize_t find_prev_set_bit(ssize_t last_idx, ssize_t boundary_idx) const;\n-\n-  \/\/ Return the smallest index at which a run of num_bits consecutive ones is found, where return value is >= start_idx\n-  \/\/ and return value < _num_bits.  If no run of num_bits consecutive ones is found within the target range, return _num_bits.\n-  inline ssize_t find_next_consecutive_bits(size_t num_bits, ssize_t start_idx) const;\n-\n-  \/\/ Return the smallest index at which a run of num_bits consecutive ones is found, where return value is >= start_idx\n-  \/\/ and return value < boundary_idx.  If no run of num_bits consecutive ones is found within the target range,\n-  \/\/ return boundary_idx.\n-  ssize_t find_next_consecutive_bits(size_t num_bits, ssize_t start_idx, ssize_t boundary_idx) const;\n-\n-  \/\/ Return the largest index at which a run of num_bits consecutive ones is found, where return value is <= last_idx and > -1.\n-  \/\/ If no run of num_bits consecutive ones is found within the target range, return -1.\n-  inline ssize_t find_prev_consecutive_bits(size_t num_bits, ssize_t last_idx) const;\n-\n-  \/\/ Return the largest index at which a run of num_bits consecutive ones is found, where return value is <= last_idx and > -1.\n-  \/\/ If no run of num_bits consecutive ones is found within the target range, return -1.\n-  ssize_t find_prev_consecutive_bits(size_t num_bits, ssize_t last_idx, ssize_t boundary_idx) const;\n+  \/\/ Return the index of the first set bit in the range [beg, size()), or size() if none found.\n+  \/\/ precondition: beg and end form a valid range for the bitmap.\n+  inline idx_t find_first_set_bit(idx_t beg) const;\n+\n+  \/\/ Return the index of the first set bit in the range [beg, end), or end if none found.\n+  \/\/ precondition: beg and end form a valid range for the bitmap.\n+  inline idx_t find_first_set_bit(idx_t beg, idx_t end) const;\n+\n+  \/\/ Return the index of the last set bit in the range (-1, end], or -1 if none found.\n+  \/\/ precondition: beg and end form a valid range for the bitmap.\n+  inline idx_t find_last_set_bit(idx_t end) const;\n+\n+  \/\/ Return the index of the last set bit in the range (beg, end], or beg if none found.\n+  \/\/ precondition: beg and end form a valid range for the bitmap.\n+  inline idx_t find_last_set_bit(idx_t beg, idx_t end) const;\n+\n+  \/\/ Return the start index of the first run of <num_bits> consecutive set bits for which the first set bit is within\n+  \/\/   the range [beg, size()), or size() if the run of <num_bits> is not found within this range.\n+  \/\/ precondition: beg is within the valid range for the bitmap.\n+  inline idx_t find_first_consecutive_set_bits(idx_t beg, size_t num_bits) const;\n+\n+  \/\/ Return the start index of the first run of <num_bits> consecutive set bits for which the first set bit is within\n+  \/\/   the range [beg, end), or end if the run of <num_bits> is not found within this range.\n+  \/\/ precondition: beg and end form a valid range for the bitmap.\n+  idx_t find_first_consecutive_set_bits(idx_t beg, idx_t end, size_t num_bits) const;\n+\n+  \/\/ Return the start index of the last run of <num_bits> consecutive set bits for which the entire run of set bits is within\n+  \/\/ the range (-1, end], or -1 if the run of <num_bits> is not found within this range.\n+  \/\/ precondition: end is within the valid range for the bitmap.\n+  inline idx_t find_last_consecutive_set_bits(idx_t end, size_t num_bits) const;\n+\n+  \/\/ Return the start index of the first run of <num_bits> consecutive set bits for which the entire run of set bits is within\n+  \/\/ the range (beg, end], or beg if the run of <num_bits> is not found within this range.\n+  \/\/ precondition: beg and end form a valid range for the bitmap.\n+  idx_t find_last_consecutive_set_bits(idx_t beg, idx_t end, size_t num_bits) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSimpleBitMap.hpp","additions":64,"deletions":47,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -31,3 +31,3 @@\n-inline ssize_t ShenandoahSimpleBitMap::find_next_set_bit(ssize_t start_idx, ssize_t boundary_idx) const {\n-  assert((start_idx >= 0) && (start_idx < _num_bits), \"precondition\");\n-  assert((boundary_idx > start_idx) && (boundary_idx <= _num_bits), \"precondition\");\n+inline idx_t ShenandoahSimpleBitMap::find_first_set_bit(idx_t beg, idx_t end) const {\n+  assert((beg >= 0) && (beg < _num_bits), \"precondition\");\n+  assert((end > beg) && (end <= _num_bits), \"precondition\");\n@@ -35,2 +35,2 @@\n-    size_t array_idx = start_idx >> LogBitsPerWord;\n-    uintx bit_number = start_idx & right_n_bits(LogBitsPerWord);\n+    size_t array_idx = beg >> LogBitsPerWord;\n+    uintx bit_number = beg & right_n_bits(LogBitsPerWord);\n@@ -46,2 +46,2 @@\n-      ssize_t candidate_result = (array_idx * BitsPerWord) + bit_number + first_set_bit;\n-      return (candidate_result < boundary_idx)? candidate_result: boundary_idx;\n+      idx_t candidate_result = (array_idx * BitsPerWord) + bit_number + first_set_bit;\n+      return (candidate_result < end)? candidate_result: end;\n@@ -50,1 +50,1 @@\n-      start_idx += BitsPerWord - bit_number;\n+      beg += BitsPerWord - bit_number;\n@@ -52,2 +52,2 @@\n-  } while (start_idx < boundary_idx);\n-  return boundary_idx;\n+  } while (beg < end);\n+  return end;\n@@ -56,3 +56,3 @@\n-inline ssize_t ShenandoahSimpleBitMap::find_next_set_bit(ssize_t start_idx) const {\n-  assert((start_idx >= 0) && (start_idx < _num_bits), \"precondition\");\n-  return find_next_set_bit(start_idx, _num_bits);\n+inline idx_t ShenandoahSimpleBitMap::find_first_set_bit(idx_t beg) const {\n+  assert((beg >= 0) && (beg < size()), \"precondition\");\n+  return find_first_set_bit(beg, size());\n@@ -61,3 +61,3 @@\n-inline ssize_t ShenandoahSimpleBitMap::find_prev_set_bit(ssize_t last_idx, ssize_t boundary_idx) const {\n-  assert((last_idx >= 0) && (last_idx < _num_bits), \"precondition\");\n-  assert((boundary_idx >= -1) && (boundary_idx < last_idx), \"precondition\");\n+inline idx_t ShenandoahSimpleBitMap::find_last_set_bit(idx_t beg, idx_t end) const {\n+  assert((end >= 0) && (end < _num_bits), \"precondition\");\n+  assert((beg >= -1) && (beg < end), \"precondition\");\n@@ -65,2 +65,2 @@\n-    ssize_t array_idx = last_idx >> LogBitsPerWord;\n-    uintx bit_number = last_idx & right_n_bits(LogBitsPerWord);\n+    idx_t array_idx = end >> LogBitsPerWord;\n+    uintx bit_number = end & right_n_bits(LogBitsPerWord);\n@@ -76,2 +76,2 @@\n-      ssize_t candidate_result = array_idx * BitsPerWord + (bit_number - first_set_bit);\n-      return (candidate_result > boundary_idx)? candidate_result: boundary_idx;\n+      idx_t candidate_result = array_idx * BitsPerWord + (bit_number - first_set_bit);\n+      return (candidate_result > beg)? candidate_result: beg;\n@@ -80,1 +80,1 @@\n-      last_idx -= (bit_number + 1);\n+      end -= (bit_number + 1);\n@@ -82,2 +82,2 @@\n-  } while (last_idx > boundary_idx);\n-  return boundary_idx;\n+  } while (end > beg);\n+  return beg;\n@@ -86,3 +86,3 @@\n-inline ssize_t ShenandoahSimpleBitMap::find_prev_set_bit(ssize_t last_idx) const {\n-  assert((last_idx >= 0) && (last_idx < _num_bits), \"precondition\");\n-  return find_prev_set_bit(last_idx, -1);\n+inline idx_t ShenandoahSimpleBitMap::find_last_set_bit(idx_t end) const {\n+  assert((end >= 0) && (end < _num_bits), \"precondition\");\n+  return find_last_set_bit(-1, end);\n@@ -91,3 +91,3 @@\n-inline ssize_t ShenandoahSimpleBitMap::find_next_consecutive_bits(size_t num_bits, ssize_t start_idx) const {\n-  assert((start_idx >= 0) && (start_idx < _num_bits), \"precondition\");\n-  return find_next_consecutive_bits(num_bits, start_idx, _num_bits);\n+inline idx_t ShenandoahSimpleBitMap::find_first_consecutive_set_bits(idx_t beg, size_t num_bits) const {\n+  assert((beg >= 0) && (beg < _num_bits), \"precondition\");\n+  return find_first_consecutive_set_bits(beg, size(), num_bits);\n@@ -96,3 +96,3 @@\n-inline ssize_t ShenandoahSimpleBitMap::find_prev_consecutive_bits(size_t num_bits, ssize_t last_idx) const {\n-  assert((last_idx >= 0) && (last_idx < _num_bits), \"precondition\");\n-  return find_prev_consecutive_bits(num_bits, last_idx, (ssize_t) -1);\n+inline idx_t ShenandoahSimpleBitMap::find_last_consecutive_set_bits(idx_t end, size_t num_bits) const {\n+  assert((end >= 0) && (end < _num_bits), \"precondition\");\n+  return find_last_consecutive_set_bits((idx_t) -1, end, num_bits);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSimpleBitMap.inline.hpp","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    BitMapAssertEqual(bm.number_of_bits(), size);\n+    BitMapAssertEqual(bm.size(), size);\n@@ -90,1 +90,1 @@\n-    \/\/ Make sure find_next_set_bit() works correctly\n+    \/\/ Make sure find_first_set_bit() works correctly\n@@ -94,1 +94,1 @@\n-      probe_point = bm.find_next_set_bit(probe_point);\n+      probe_point = bm.find_first_set_bit(probe_point);\n@@ -99,1 +99,1 @@\n-      probe_point = bm.find_next_set_bit(probe_point);\n+      probe_point = bm.find_first_set_bit(probe_point);\n@@ -103,1 +103,1 @@\n-    \/\/ Confirm that find_next_set_bit() with a bounded search space works correctly\n+    \/\/ Confirm that find_first_set_bit() with a bounded search space works correctly\n@@ -112,1 +112,1 @@\n-        probe_point = bm.find_next_set_bit(probe_point, boundary_idx);\n+        probe_point = bm.find_first_set_bit(probe_point, boundary_idx);\n@@ -119,1 +119,1 @@\n-      probe_point = bm.find_next_set_bit(probe_point, boundary_idx);\n+      probe_point = bm.find_first_set_bit(probe_point, boundary_idx);\n@@ -123,1 +123,1 @@\n-    \/\/ Make sure find_prev_set_bit() works correctly\n+    \/\/ Make sure find_last_set_bit() works correctly\n@@ -127,1 +127,1 @@\n-      probe_point = bm.find_prev_set_bit(probe_point);\n+      probe_point = bm.find_last_set_bit(probe_point);\n@@ -132,1 +132,1 @@\n-      probe_point = bm.find_prev_set_bit(probe_point);\n+      probe_point = bm.find_last_set_bit(probe_point);\n@@ -136,1 +136,1 @@\n-    \/\/ Confirm that find_prev_set_bit() with a bounded search space works correctly\n+    \/\/ Confirm that find_last_set_bit() with a bounded search space works correctly\n@@ -143,1 +143,1 @@\n-        probe_point = bm.find_prev_set_bit(probe_point, boundary_idx);\n+        probe_point = bm.find_last_set_bit(boundary_idx, probe_point);\n@@ -151,1 +151,1 @@\n-      probe_point = bm.find_prev_set_bit(probe_point, boundary_idx);\n+      probe_point = bm.find_last_set_bit(boundary_idx, probe_point);\n@@ -174,1 +174,1 @@\n-    \/\/ Confirm that find_next_consecutive_bits() works for each cluster size known to have at least one match\n+    \/\/ Confirm that find_first_consecutive_set_bits() works for each cluster size known to have at least one match\n@@ -176,1 +176,1 @@\n-      \/\/ Verify that find_next_consecutive_bits() works\n+      \/\/ Verify that find_first_consecutive_set_bits() works\n@@ -194,1 +194,1 @@\n-          probe_point = bm.find_next_consecutive_bits(cluster_size, orig_probe_point);\n+          probe_point = bm.find_first_consecutive_set_bits(orig_probe_point, cluster_size);\n@@ -205,1 +205,1 @@\n-        probe_point = bm.find_next_consecutive_bits(cluster_size, probe_point);\n+        probe_point = bm.find_first_consecutive_set_bits(probe_point, cluster_size);\n@@ -227,1 +227,1 @@\n-          probe_point = bm.find_next_consecutive_bits(cluster_size, probe_point, boundary_idx);\n+          probe_point = bm.find_first_consecutive_set_bits(probe_point, boundary_idx, cluster_size);\n@@ -237,1 +237,1 @@\n-        probe_point = bm.find_next_consecutive_bits(cluster_size, probe_point, boundary_idx);\n+        probe_point = bm.find_first_consecutive_set_bits(probe_point, boundary_idx, cluster_size);\n@@ -241,1 +241,1 @@\n-      \/\/ Verify that find_prev_consecutive_bits() works\n+      \/\/ Verify that find_last_consecutive_set_bits() works\n@@ -255,1 +255,1 @@\n-          probe_point = bm.find_prev_consecutive_bits(cluster_size, probe_point);\n+          probe_point = bm.find_last_consecutive_set_bits(probe_point, cluster_size);\n@@ -265,1 +265,1 @@\n-        probe_point = bm.find_prev_consecutive_bits(cluster_size, probe_point, boundary_idx);\n+        probe_point = bm.find_last_consecutive_set_bits(boundary_idx, probe_point, cluster_size);\n@@ -269,1 +269,1 @@\n-      \/\/ Verify that find_prev_consecutive_bits() works with the search range bounded at 1\/4 size\n+      \/\/ Verify that find_last_consecutive_set_bits() works with the search range bounded at 1\/4 size\n@@ -283,1 +283,1 @@\n-          probe_point = bm.find_prev_consecutive_bits(cluster_size, probe_point, boundary_idx);\n+          probe_point = bm.find_last_consecutive_set_bits(boundary_idx, probe_point, cluster_size);\n@@ -295,1 +295,1 @@\n-        probe_point = bm.find_prev_consecutive_bits(cluster_size, probe_point, boundary_idx);\n+        probe_point = bm.find_last_consecutive_set_bits(boundary_idx, probe_point, cluster_size);\n@@ -300,2 +300,2 @@\n-    \/\/ Confirm that find_next_consecutive_bits() works for a cluster size known not to have any matches\n-    probe_point = bm.find_next_consecutive_bits(longest_run + 1, 0);\n+    \/\/ Confirm that find_first_consecutive_set_bits() works for a cluster size known not to have any matches\n+    probe_point = bm.find_first_consecutive_set_bits(0, longest_run + 1);\n@@ -304,1 +304,1 @@\n-    probe_point = bm.find_prev_consecutive_bits(longest_run + 1, size - 1);\n+    probe_point = bm.find_last_consecutive_set_bits(size - 1, longest_run + 1);\n@@ -308,1 +308,1 @@\n-    probe_point = bm.find_next_consecutive_bits(longest_run + 1, 0, boundary_idx);\n+    probe_point = bm.find_first_consecutive_set_bits(0, boundary_idx, longest_run + 1);\n@@ -312,1 +312,1 @@\n-    probe_point = bm.find_prev_consecutive_bits(longest_run + 1, size - 1, boundary_idx);\n+    probe_point = bm.find_last_consecutive_set_bits(boundary_idx, size - 1, longest_run + 1);\n@@ -314,1 +314,0 @@\n-\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahSimpleBitMap.cpp","additions":30,"deletions":31,"binary":false,"changes":61,"status":"modified"}]}