{"files":[{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shenandoah\/shenandoahFreeSet.inline.hpp\"\n@@ -144,81 +145,0 @@\n-inline ssize_t ShenandoahSimpleBitMap::find_next_set_bit(ssize_t start_idx, ssize_t boundary_idx) const {\n-  assert((start_idx >= 0) && (start_idx < _num_bits), \"precondition\");\n-  assert((boundary_idx > start_idx) && (boundary_idx <= _num_bits), \"precondition\");\n-  do {\n-    size_t array_idx = start_idx \/ _bits_per_array_element;\n-    size_t bit_number = start_idx % _bits_per_array_element;\n-    size_t element_bits = _bitmap[array_idx];\n-    if (bit_number > 0) {\n-      size_t mask_out = (((size_t) 0x01) << bit_number) - 1;\n-      element_bits &= ~mask_out;\n-    }\n-    if (element_bits) {\n-      \/\/ The next set bit is here\n-      size_t the_bit = ((size_t) 0x01) << bit_number;\n-      while (bit_number < _bits_per_array_element) {\n-        if (element_bits & the_bit) {\n-          ssize_t candidate_result = (array_idx * _bits_per_array_element) + bit_number;\n-          if (candidate_result < boundary_idx) return candidate_result;\n-          else return boundary_idx;\n-        } else {\n-          the_bit <<= 1;\n-          bit_number++;\n-        }\n-      }\n-      assert(false, \"should not reach here\");\n-    } else {\n-      \/\/ Next bit is not here.  Try the next array element\n-      start_idx += _bits_per_array_element - bit_number;\n-    }\n-  } while (start_idx < boundary_idx);\n-  return boundary_idx;\n-}\n-\n-inline ssize_t ShenandoahSimpleBitMap::find_next_set_bit(ssize_t start_idx) const {\n-  assert((start_idx >= 0) && (start_idx < _num_bits), \"precondition\");\n-  return find_next_set_bit(start_idx, _num_bits);\n-}\n-\n-inline ssize_t ShenandoahSimpleBitMap::find_prev_set_bit(ssize_t last_idx, ssize_t boundary_idx) const {\n-  assert((last_idx >= 0) && (last_idx < _num_bits), \"precondition\");\n-  assert((boundary_idx >= -1) && (boundary_idx < last_idx), \"precondition\");\n-  do {\n-    ssize_t array_idx = last_idx \/ _bits_per_array_element;\n-    size_t bit_number = last_idx % _bits_per_array_element;\n-    size_t element_bits = _bitmap[array_idx];\n-    if (bit_number < _bits_per_array_element - 1){\n-      size_t mask_in = (((size_t) 0x1) << (bit_number + 1)) - 1;\n-      element_bits &= mask_in;\n-    }\n-    if (element_bits) {\n-      \/\/ The prev set bit is here\n-      size_t the_bit = ((size_t) 0x01) << bit_number;\n-\n-      for (ssize_t bit_iterator = bit_number; bit_iterator >= 0; bit_iterator--) {\n-        if (element_bits & the_bit) {\n-          ssize_t candidate_result = (array_idx * _bits_per_array_element) + bit_number;\n-          if (candidate_result > boundary_idx) return candidate_result;\n-          else return boundary_idx;\n-        } else {\n-          the_bit >>= 1;\n-          bit_number--;\n-        }\n-      }\n-      assert(false, \"should not reach here\");\n-    } else {\n-      \/\/ Next bit is not here.  Try the previous array element\n-      last_idx -= (bit_number + 1);\n-    }\n-  } while (last_idx > boundary_idx);\n-  return boundary_idx;\n-}\n-\n-inline ssize_t ShenandoahSimpleBitMap::find_prev_set_bit(ssize_t last_idx) const {\n-  assert((last_idx >= 0) && (last_idx < _num_bits), \"precondition\");\n-  return find_prev_set_bit(last_idx, -1);\n-}\n-\n-inline ssize_t ShenandoahSimpleBitMap::find_next_consecutive_bits(size_t num_bits, ssize_t start_idx) const {\n-  assert((start_idx >= 0) && (start_idx < _num_bits), \"precondition\");\n-  return find_next_consecutive_bits(num_bits, start_idx, _num_bits);\n-}\n@@ -264,5 +184,0 @@\n-inline ssize_t ShenandoahSimpleBitMap::find_prev_consecutive_bits(size_t num_bits, ssize_t last_idx) const {\n-  assert((last_idx >= 0) && (last_idx < _num_bits), \"precondition\");\n-  return find_prev_consecutive_bits(num_bits, last_idx, (ssize_t) -1);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":1,"deletions":86,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-  inline size_t number_of_bits() const {\n+  inline ssize_t number_of_bits() const {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shenandoah\/shenandoahFreeSet.inline.hpp\"\n@@ -38,2 +39,4 @@\n-  const size_t SMALL_BITMAP_SIZE =  512;\n-  const size_t LARGE_BITMAP_SIZE = 4096;\n+protected:\n+  const ssize_t SMALL_BITMAP_SIZE =  512;\n+  const ssize_t LARGE_BITMAP_SIZE = 4096;\n+\n@@ -43,1 +46,0 @@\n-protected:\n@@ -54,1 +56,1 @@\n-  void verifyBitMapState(ShenandoahSimpleBitMap& bm, size_t size, size_t set_bits[], size_t num_set_bits) {\n+  void verifyBitMapState(ShenandoahSimpleBitMap& bm, ssize_t size, ssize_t set_bits[], ssize_t num_set_bits) {\n@@ -59,1 +61,1 @@\n-    size_t set_bit_index = 0;\n+    ssize_t set_bit_index = 0;\n@@ -75,2 +77,2 @@\n-    size_t alignment = bm_small.alignment();\n-    size_t small_words = size \/ alignment;\n+    ssize_t alignment = bm_small.alignment();\n+    ssize_t small_words = size \/ alignment;\n@@ -79,2 +81,2 @@\n-      for (size_t b = 0; b < alignment; b++) {\n-        size_t bit_value = i * alignment + b;\n+      for (ssize_t b = 0; b < alignment; b++) {\n+        ssize_t bit_value = i * alignment + b;\n@@ -88,1 +90,1 @@\n-        is_set = (bits & bit_mask) != 0;\n+        bool is_set = (bits & bit_mask) != 0;\n@@ -96,1 +98,1 @@\n-      size_t next_expected_bit = set_bits[i];\n+      ssize_t next_expected_bit = set_bits[i];\n@@ -107,1 +109,1 @@\n-    ssize_t probe_point = 0;\n+    probe_point = 0;\n@@ -109,1 +111,1 @@\n-      size_t next_expected_bit = set_bits[i];\n+      ssize_t next_expected_bit = set_bits[i];\n@@ -127,1 +129,1 @@\n-    size_t probe_point = size - 1;\n+    probe_point = size - 1;\n@@ -129,1 +131,1 @@\n-      size_t next_expected_bit = set_bits[i];\n+      ssize_t next_expected_bit = set_bits[i];\n@@ -142,1 +144,1 @@\n-      size_t next_expected_bit = set_bits[i];\n+      ssize_t next_expected_bit = set_bits[i];\n@@ -161,4 +163,4 @@\n-    size_t longest_run = 0;\n-    size_t current_run = 0;\n-    for (size_t i = 0; i < num_set_bits; i++) {\n-      next_expected_bit = set_bits[i];\n+    ssize_t longest_run = 0;\n+    ssize_t current_run = 0;\n+    for (ssize_t i = 0; i < num_set_bits; i++) {\n+      ssize_t next_expected_bit = set_bits[i];\n@@ -178,1 +180,1 @@\n-    for (size_t cluster_size = 1; cluster_size <= longest_run; cluster_size++) {\n+    for (ssize_t cluster_size = 1; cluster_size <= longest_run; cluster_size++) {\n@@ -181,1 +183,1 @@\n-      size_t bit_idx = 0;\n+      ssize_t bit_idx = 0;\n@@ -184,2 +186,2 @@\n-        size_t cluster_found = false;\n-        size_t next_expected_custer;\n+        bool cluster_found = false;\n+        ssize_t next_expected_custer;\n@@ -188,2 +190,2 @@\n-          for (int i = 1; i < cluster_size; i++) {\n-            if (set_bits[bit_idx] + i != set_bit[bit_idx + i]) {\n+          for (ssize_t i = 1; i < cluster_size; i++) {\n+            if (set_bits[bit_idx] + i != set_bits[bit_idx + i]) {\n@@ -214,2 +216,2 @@\n-        size_t cluster_found = false;\n-        size_t next_expected_custer;\n+        bool cluster_found = false;\n+        ssize_t next_expected_custer;\n@@ -219,1 +221,1 @@\n-            if (set_bits[bit_idx] + i != set_bit[bit_idx + i]) {\n+            if (set_bits[bit_idx] + i != set_bits[bit_idx + i]) {\n@@ -243,2 +245,2 @@\n-        size_t cluster_found = false;\n-        size_t next_expected_custer;\n+        bool cluster_found = false;\n+        ssize_t next_expected_custer;\n@@ -248,1 +250,1 @@\n-            if (set_bits[bit_idx] - i != set_bit[bit_idx - i]) {\n+            if (set_bits[bit_idx] - i != set_bits[bit_idx - i]) {\n@@ -273,2 +275,2 @@\n-        size_t cluster_found = false;\n-        size_t next_expected_custer;\n+        bool cluster_found = false;\n+        ssize_t next_expected_custer;\n@@ -278,1 +280,1 @@\n-            if (set_bits[bit_idx] - i != set_bit[bit_idx - i]) {\n+            if (set_bits[bit_idx] - i != set_bits[bit_idx - i]) {\n@@ -319,1 +321,1 @@\n-    size_t set_bits_0[] = { };\n+    ssize_t set_bits_0[] = { };\n@@ -326,1 +328,1 @@\n-    size_t set_bits_1[] = { 5, 63, 128 };\n+    ssize_t set_bits_1[] = { 5, 63, 128 };\n@@ -352,1 +354,1 @@\n-    size_t set_bits_2[] = { 5, 63, 128, 140, 141, 142, 253, 254, 255, 271, 272, 320, 321, 322, 361 };\n+    ssize_t set_bits_2[] = { 5, 63, 128, 140, 141, 142, 253, 254, 255, 271, 272, 320, 321, 322, 361 };\n@@ -373,1 +375,1 @@\n-    size_t set_bits_3[] = { 5, 63, 128, 140, 141, 142, 1021, 1022, 1023, 1051, 1280, 1281, 1282, 1300, 1301, 1302 }\n+    ssize_t set_bits_3[] = { 5, 63, 128, 140, 141, 142, 1021, 1022, 1023, 1051, 1280, 1281, 1282, 1300, 1301, 1302 };\n@@ -379,1 +381,1 @@\n-    size_t set_bits_4[] = { 5, 63, 128, 140, 142, 254, 255, 271, 272, 320, 321, 322, 361 };\n+    ssize_t set_bits_4[] = { 5, 63, 128, 140, 142, 254, 255, 271, 272, 320, 321, 322, 361 };\n@@ -386,1 +388,1 @@\n-    size_t set_bits_5[] = { 140, 142, 1021, 1022, 1023, 1051, 1280, 1281, 1282, 1300, 1301, 1302 }\n+    ssize_t set_bits_5[] = { 140, 142, 1021, 1022, 1023, 1051, 1280, 1281, 1282, 1300, 1301, 1302 };\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahSimpleBitMap.cpp","additions":43,"deletions":41,"binary":false,"changes":84,"status":"modified"}]}