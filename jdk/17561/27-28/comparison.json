{"files":[{"patch":"@@ -46,0 +46,2 @@\n+\/\/ Count consecutive ones in forward order, starting from start_idx.  Requires that there is at least one zero\n+\/\/ between start_idx and index value _num_bits - 1 inclusive.\n@@ -53,1 +55,1 @@\n-  size_t mask = ((size_t) ((ssize_t) -1)) & omit_mask;\n+  size_t mask = ((size_t) ((ssize_t) -1)) & ~omit_mask;\n@@ -57,1 +59,1 @@\n-    return counted_ones + count_leading_ones(start_idx + counted_ones);\n+    return counted_ones + count_leading_ones(start_idx - counted_ones);\n@@ -98,2 +100,1 @@\n-\n-  if ((ssize_t) (_bits_per_array_element - bit_number) >= count) {\n+  if ((ssize_t) (bit_number + count <= _bits_per_array_element)) {\n@@ -101,1 +102,2 @@\n-    size_t overreach_mask = ((size_t) 0x1 << (bit_number + count)) - 1;\n+    size_t overreach_mask =\n+      (bit_number + count == _bits_per_array_element)? ~((size_t) 0): ((size_t) 0x1 << (bit_number + count)) - 1;\n@@ -126,1 +128,0 @@\n-\n@@ -129,1 +130,1 @@\n-    size_t overreach_mask = ((size_t) 0x1 << (bit_number + 1)) - 1;\n+    size_t overreach_mask = (bit_number == _bits_per_array_element - 1)? ~((size_t) 0): ((size_t) 0x1 << (bit_number + 1)) - 1;\n@@ -158,0 +159,1 @@\n+\n@@ -184,1 +186,2 @@\n-ssize_t ShenandoahSimpleBitMap::find_prev_consecutive_bits(size_t num_bits, ssize_t last_idx, ssize_t boundary_idx) const {\n+ssize_t ShenandoahSimpleBitMap::find_prev_consecutive_bits(\n+  const size_t num_bits, ssize_t last_idx, const ssize_t boundary_idx) const {\n@@ -223,1 +226,1 @@\n-  log_info(gc)(\"Mutator range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"], Collector range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"]\",\n+  printf(\"Mutator range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"], Collector range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"]\",\n@@ -225,1 +228,1 @@\n-  log_info(gc)(\"Empty Mutator range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT\n+  printf(\"Empty Mutator range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT\n@@ -231,1 +234,1 @@\n-  log_info(gc)(\"%6s: %18s %18s %18s\", \"index\", \"Mutator Bits\", \"Collector Bits\", \"NotFree Bits\");\n+  printf(\"%6s: %18s %18s %18s\", \"index\", \"Mutator Bits\", \"Collector Bits\", \"NotFree Bits\");\n@@ -233,1 +236,1 @@\n-  log_info(gc)(\"%6s: %10s %10s %10s\", \"index\", \"Mutator Bits\", \"Collector Bits\", \"NotFree Bits\");\n+  printf(\"%6s: %10s %10s %10s\", \"index\", \"Mutator Bits\", \"Collector Bits\", \"NotFree Bits\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -40,15 +40,0 @@\n-class ShenandoahSimpleBitMapTest: public ::testing::Test {\n-protected:\n-\n-  const ssize_t SMALL_BITMAP_SIZE =  512;\n-  const ssize_t LARGE_BITMAP_SIZE = 4096;\n-\n-  ShenandoahSimpleBitMap bm_small;\n-  ShenandoahSimpleBitMap bm_large;\n-\n-  ShenandoahSimpleBitMapTest():\n-      bm_small(SMALL_BITMAP_SIZE),\n-      bm_large(LARGE_BITMAP_SIZE) {\n-  }\n-};\n-\n@@ -57,1 +42,1 @@\n-class BasicShenandoahSimpleBitMapTest: public ShenandoahSimpleBitMapTest {\n+class ShenandoahSimpleBitMapTest: public ::testing::Test {\n@@ -60,4 +45,2 @@\n-  \/\/ set_bits[] is an array of indexes holding bits that are supposed to be set, in increasing order.\n-  void verifyBitMapState(ShenandoahSimpleBitMap& bm, ssize_t size, ssize_t set_bits[], ssize_t num_set_bits) {\n-    _success = false;\n-    _assertion_failures = 0;\n+  static const ssize_t SMALL_BITMAP_SIZE =  512;\n+  static const ssize_t LARGE_BITMAP_SIZE = 4096;\n@@ -65,0 +48,2 @@\n+  \/\/ set_bits[] is an array of indexes holding bits that are supposed to be set, in increasing order.\n+  static void verifyBitMapState(ShenandoahSimpleBitMap& bm, ssize_t size, ssize_t set_bits[], ssize_t num_set_bits) {\n@@ -71,1 +56,1 @@\n-      bool is_set = bm_small.is_set(i);\n+      bool is_set = bm.is_set(i);\n@@ -84,4 +69,3 @@\n-    ssize_t alignment = bm_small.alignment();\n-    ssize_t small_words = size \/ alignment;\n-    for (ssize_t i = 0; i < small_words; i += alignment) {\n-      size_t bits = bm_small.bits_at(i);\n+    ssize_t alignment = bm.alignment();\n+    for (ssize_t i = 0; i < size; i += alignment) {\n+      size_t bits = bm.bits_at(i);\n@@ -89,1 +73,1 @@\n-        ssize_t bit_value = i * alignment + b;\n+        ssize_t bit_value = i + b;\n@@ -94,0 +78,1 @@\n+            set_bit_index++;\n@@ -110,2 +95,4 @@\n-    probe_point = bm.find_next_set_bit(probe_point);\n-    BitMapAssertEqual(probe_point, size); \/\/ Verify that last failed search returns sentinel value: num bits in bit map\n+    if (probe_point < size) {\n+      probe_point = bm.find_next_set_bit(probe_point);\n+      BitMapAssertEqual(probe_point, size); \/\/ Verify that last failed search returns sentinel value: num bits in bit map\n+    }\n@@ -119,1 +106,0 @@\n-      probe_point = bm.find_next_set_bit(probe_point, boundary_idx);\n@@ -121,2 +107,0 @@\n-        \/\/ Verify that last failed search returns sentinel value: boundary_idx\n-        BitMapAssertEqual(probe_point, boundary_idx);\n@@ -125,0 +109,1 @@\n+        probe_point = bm.find_next_set_bit(probe_point, boundary_idx);\n@@ -143,2 +128,4 @@\n-    probe_point = bm.find_prev_set_bit(probe_point);\n-    BitMapAssertEqual(probe_point, (ssize_t) -1); \/\/ Verify that last failed search returns sentinel value: -1\n+    if (probe_point >= 0) {\n+      probe_point = bm.find_prev_set_bit(probe_point);\n+      BitMapAssertEqual(probe_point, (ssize_t) -1); \/\/ Verify that last failed search returns sentinel value: -1\n+    }\n@@ -152,6 +139,2 @@\n-      probe_point = bm.find_next_set_bit(probe_point, boundary_idx);\n-      if (next_expected_bit <= boundary_idx) {\n-        \/\/ Verify that last failed search returns sentinel value: boundary_idx\n-        BitMapAssertEqual(probe_point, boundary_idx);\n-        break;\n-      } else {\n+      if (next_expected_bit > boundary_idx) {\n+        probe_point = bm.find_prev_set_bit(probe_point, boundary_idx);\n@@ -159,1 +142,3 @@\n-        probe_point--;            \/\/ Prepare to look beyond the most recent bit.\n+        probe_point--;\n+      } else {\n+        break;\n@@ -162,2 +147,2 @@\n-    if (probe_point >= boundary_idx) {\n-      probe_point = bm.find_next_set_bit(probe_point, boundary_idx);\n+    if (probe_point > boundary_idx) {\n+      probe_point = bm.find_prev_set_bit(probe_point, boundary_idx);\n@@ -192,1 +177,1 @@\n-      while (probe_point <= size - cluster_size) {\n+      while ((probe_point <= size - cluster_size) && (bit_idx <= num_set_bits - cluster_size)) {\n@@ -194,1 +179,1 @@\n-        while (!cluster_found && (bit_idx <= num_set_bits - cluster_size)) {\n+        while (!cluster_found && (bit_idx + cluster_size <= num_set_bits)) {\n@@ -199,0 +184,1 @@\n+              bit_idx++;\n@@ -204,1 +190,1 @@\n-          ssize_t next_expected_cluster = bit_idx;\n+          ssize_t next_expected_cluster = set_bits[bit_idx];\n@@ -211,0 +197,1 @@\n+          break;\n@@ -213,3 +200,5 @@\n-      \/\/ Confirm that the last request, which fails to find a cluster, returns sentinel value: num_bits\n-      probe_point = bm.find_next_consecutive_bits(cluster_size, probe_point);\n-      BitMapAssertEqual(probe_point, size);\n+      if (probe_point < size) {\n+        \/\/ Confirm that the last request, which fails to find a cluster, returns sentinel value: num_bits\n+        probe_point = bm.find_next_consecutive_bits(cluster_size, probe_point);\n+        BitMapAssertEqual(probe_point, size);\n+      }\n@@ -221,1 +210,1 @@\n-      while (probe_point <= boundary_idx - cluster_size) {\n+      while ((probe_point <= boundary_idx - cluster_size) && (bit_idx <= num_set_bits - cluster_size)) {\n@@ -223,1 +212,1 @@\n-        while (!cluster_found && (bit_idx <= num_set_bits - cluster_size)) {\n+        while (!cluster_found && (bit_idx + cluster_size <= num_set_bits)) {\n@@ -228,0 +217,1 @@\n+              bit_idx++;\n@@ -242,3 +232,5 @@\n-      \/\/ Confirm that the last request, which fails to find a cluster, returns sentinel value: boundary_idx\n-      probe_point = bm.find_prev_consecutive_bits(cluster_size, probe_point, boundary_idx);\n-      BitMapAssertEqual(probe_point, boundary_idx);\n+      if (probe_point < boundary_idx) {\n+        \/\/ Confirm that the last request, which fails to find a cluster, returns sentinel value: boundary_idx\n+        probe_point = bm.find_next_consecutive_bits(cluster_size, probe_point, boundary_idx);\n+        BitMapAssertEqual(probe_point, boundary_idx);\n+      }\n@@ -249,9 +241,7 @@\n-      while (probe_point >= cluster_size - 1) {\n-        bool cluster_found = false;\n-        while (!cluster_found && (bit_idx - cluster_size >= -1)) {\n-          cluster_found = true;\n-          for (int i = 1; i < cluster_size; i++) {\n-            if (set_bits[bit_idx] - i != set_bits[bit_idx - i]) {\n-              cluster_found = false;\n-              break;\n-            }\n+      \/\/ Iterate over all set bits in reverse order\n+      while (bit_idx + 1 >= cluster_size) {\n+        bool cluster_found = true;\n+        for (int i = 1; i < cluster_size; i++) {\n+          if (set_bits[bit_idx] - i != set_bits[bit_idx - i]) {\n+            cluster_found = false;\n+            break;\n@@ -261,1 +251,1 @@\n-          ssize_t next_expected_cluster = set_bits[bit_idx];\n+          ssize_t next_expected_cluster = set_bits[bit_idx] + 1 - cluster_size;\n@@ -264,1 +254,1 @@\n-          probe_point--;\n+          probe_point = probe_point + cluster_size - 2;\n@@ -270,3 +260,5 @@\n-      \/\/ Confirm that the last request, which fails to find a cluster, returns sentinel value: -1\n-      probe_point = bm.find_prev_consecutive_bits(cluster_size, probe_point);\n-      BitMapAssertEqual(probe_point, (ssize_t) -1);\n+      if (probe_point >= 0) {\n+        \/\/ Confirm that the last request, which fails to find a cluster, returns sentinel value: boundary_idx\n+        probe_point = bm.find_prev_consecutive_bits(cluster_size, probe_point, boundary_idx);\n+        BitMapAssertEqual(probe_point, (ssize_t) boundary_idx);\n+      }\n@@ -278,9 +270,6 @@\n-      while (probe_point >= boundary_idx - 1 + cluster_size) {\n-        bool cluster_found = false;\n-        while (!cluster_found && (bit_idx - cluster_size >= -1)) {\n-          cluster_found = true;\n-          for (int i = 1; i < cluster_size; i++) {\n-            if (set_bits[bit_idx] - i != set_bits[bit_idx - i]) {\n-              cluster_found = false;\n-              break;\n-            }\n+      while (bit_idx + 1 >= cluster_size) {\n+        bool cluster_found = true;\n+        for (int i = 1; i < cluster_size; i++) {\n+          if (set_bits[bit_idx] - i != set_bits[bit_idx - i]) {\n+            cluster_found = false;\n+            break;\n@@ -289,2 +278,2 @@\n-        if (cluster_found) {\n-          ssize_t next_expected_cluster = set_bits[bit_idx];\n+        if (cluster_found && (set_bits[bit_idx] + 1 - cluster_size > boundary_idx)) {\n+          ssize_t next_expected_cluster = set_bits[bit_idx] + 1 - cluster_size;\n@@ -293,1 +282,1 @@\n-          probe_point--;\n+          probe_point = probe_point + cluster_size - 2;\n@@ -295,0 +284,2 @@\n+        } else if (set_bits[bit_idx] + 1 - cluster_size <= boundary_idx) {\n+          break;\n@@ -299,3 +290,5 @@\n-      \/\/ Confirm that the last request, which fails to find a cluster, returns sentinel value: boundary_idx\n-      probe_point = bm.find_prev_consecutive_bits(cluster_size, probe_point, boundary_idx);\n-      BitMapAssertEqual(probe_point, boundary_idx);\n+      if (probe_point > boundary_idx) {\n+        \/\/ Confirm that the last request, which fails to find a cluster, returns sentinel value: boundary_idx\n+        probe_point = bm.find_prev_consecutive_bits(cluster_size, probe_point, boundary_idx);\n+        BitMapAssertEqual(probe_point, boundary_idx);\n+      }\n@@ -304,1 +297,1 @@\n-    \/\/ Confirm that find_next_consecutive_bits() works for each cluster sizes known not to have any matches\n+    \/\/ Confirm that find_next_consecutive_bits() works for a cluster size known not to have any matches\n@@ -308,1 +301,1 @@\n-    probe_point = bm.find_prev_consecutive_bits(longest_run + 1, size);\n+    probe_point = bm.find_prev_consecutive_bits(longest_run + 1, size - 1);\n@@ -316,2 +309,3 @@\n-    probe_point = bm.find_prev_consecutive_bits(longest_run + 1, size, boundary_idx);\n-    BitMapAssertEqual(probe_point, (ssize_t) -1);           \/\/ Confirm: failed search returns sentinel: -1\n+    probe_point = bm.find_prev_consecutive_bits(longest_run + 1, size - 1, boundary_idx);\n+    BitMapAssertEqual(probe_point, boundary_idx);           \/\/ Confirm: failed search returns sentinel: boundary_idx\n+\n@@ -320,0 +314,1 @@\n+public:\n@@ -321,1 +316,7 @@\n-  BasicShenandoahSimpleBitMapTest() {\n+  static bool run_test() {\n+\n+    _success = false;\n+    _assertion_failures = 0;\n+\n+    ShenandoahSimpleBitMap bm_small(SMALL_BITMAP_SIZE);\n+    ShenandoahSimpleBitMap bm_large(LARGE_BITMAP_SIZE);\n@@ -329,1 +330,1 @@\n-\/\/    bm_small.set_bit(63);  confirm that this test actually runs\n+    bm_small.set_bit(63);\n@@ -385,1 +386,1 @@\n-    verifyBitMapState(bm_small, SMALL_BITMAP_SIZE, set_bits_2, 13);\n+    verifyBitMapState(bm_small, SMALL_BITMAP_SIZE, set_bits_4, 13);\n@@ -402,0 +403,1 @@\n+    return true;\n@@ -407,0 +409,3 @@\n+\n+  bool result = ShenandoahSimpleBitMapTest::run_test();\n+  ASSERT_EQ(result, true);\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahSimpleBitMap.cpp","additions":94,"deletions":89,"binary":false,"changes":183,"status":"modified"}]}