{"files":[{"patch":"@@ -41,1 +41,1 @@\n-\/\/ ShenandoahSimpleBitMap resembles CHeapBitMap but adds missing support for find_next_contiguous_bits() and\n+\/\/ ShenandoahSimpleBitMap resembles CHeapBitMap but adds missing support for find_next_consecutive_bits() and\n@@ -97,0 +97,5 @@\n+  \/\/ For testing\n+  inline size_t number_of_bits() const {\n+    return _num_bits;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-#define SMALL_BITMAP_SIZE  128\n-#define LARGE_BITMAP_SIZE 4096\n@@ -40,0 +38,6 @@\n+  const size_t  SMALL_BITMAP_SIZE =  512;\n+  const size_t LARGE_BIT_MAP_SIZE = 4096;\n+  ShenandoahSimpleBitMap bm_small;\n+  ShenandoahSimpleBitMap bm_large;\n+  \n+\n@@ -41,2 +45,4 @@\n-  ShenandoahSimpleBitMap bm_small(SMALL_BITMAP_SIZE);\n-  ShenandoahSimpleBitMap bm_large(LARGE_BITMAP_SIZE);\n+  ShenandoahSimpleBitMapTest():\n+      bm_small(SMALL_BITMAP_SIZE),\n+      bm_large(LARGE_BITMAP_SIZE) {\n+  }\n@@ -47,4 +53,0 @@\n-  BasicShenandoahSimpleBitMapTest() {\n-    \/\/ Initial state of each bitmap is all bits are clear.  Confirm this:\n-    ASSERT_EQ(bm_small.number_of_bits(), SMALL_BITMAP_SIZE);\n-    ASSERT_EQ(bm_large.number_of_bits(), LARGE_BITMAP_SIZE);\n@@ -52,0 +54,7 @@\n+  \/\/ set_bits[] is an array of indexes holding bits that are supposed to be set, in increasing order.\n+  void verifyBitMapState(ShenandoahSimpleBitMap& bm, size_t size, size_t set_bits[], size_t num_set_bits) {\n+\n+    \/\/ Verify number of bits\n+    ASSERT_EQ(bm, bm.number_of_bits(), size);\n+\n+    size_t set_bit_index = 0;\n@@ -53,1 +62,1 @@\n-    for (ssize_t i = 0; i < SMALL_BITMAP_SIZE; i++) {\n+    for (ssize_t i = 0; i < size; i++) {\n@@ -55,6 +64,8 @@\n-      ASSERT_TRUE(!is_set);\n-    }\n-\n-    for (ssize_t i = 0; i < LARGE_BITMAP_SIZE; i++) {\n-      bool is_set = bm_large.is_set(i);\n-      ASSERT_TRUE(!is_set);\n+      bool intended_value = false;;\n+      if (set_bit_index < num_set_bits) {\n+        if (set_bits[set_bit_index] == i) {\n+          intended_value = true;\n+          set_bit_index++;\n+        }\n+      }\n+      ASSERT_EQ(is_set, intended_value);\n@@ -63,1 +74,2 @@\n-    \/\/ Check that bits_at(array_idx) is zero for every valid array_idx value\n+    \/\/ Check that bits_at(array_idx) matches intended value for every valid array_idx value\n+    set_bit_index = 0;\n@@ -65,2 +77,1 @@\n-    size_t small_words = SMALL_BITMAP_SIZE \/ alignment;\n-    size_t large_words = LARGE_BITMAP_SIZE \/ alignment;\n+    size_t small_words = size \/ alignment;\n@@ -69,1 +80,12 @@\n-      ASSERT_EQ(bits, (size_t) 0);\n+      for (size_t b = 0; b < alignment; b++) {\n+        size_t bit_value = i * alignment + b;\n+        bool intended_value = false;;\n+        if (set_bit_index < num_set_bits) {\n+          if (set_bits[set_bit_index] == bit_value) {\n+            intended_value = true;\n+          }\n+        }\n+        size_t bit_mask = 0x01 << b;\n+        is_set = (bits & bit_mask) != 0;\n+        ASSERT_EQ(is_set, intended_value);\n+      }\n@@ -72,3 +94,31 @@\n-    for (ssize_t i = 0; i < large_words; i += alignment) {\n-      size_t bits = bm_large.bits_at(i);\n-      ASSERT_EQ(bits, (size_t) 0);\n+    \/\/ Make sure find_next_set_bit() works correctly\n+    ssize_t probe_point = 0;\n+    for (ssize_t i = 0; i < num_set_bits; i++) {\n+      size_t next_expected_bit = set_bits[i];\n+      probe_point = bm.find_next_set_bit(probe_point);\n+      ASSERT_EQ(probe_point, next_expected_bit);\n+      probe_point++;            \/\/ Prepare to look beyond the most recent bit.\n+    }\n+    probe_point = bm.find_next_set_bit(probe_point);\n+    ASSERT_EQ(probe_point, size); \/\/ Verify that last failed search returns sentinel value: num bits in bit map\n+    \n+    \/\/ Confirm that find_next_set_bit() with a bounded search space works correctly\n+    \/\/ Limit this search to the first 3\/4 of the full bit map\n+    ssize_t boundary_idx = 3 * size \/ 4;\n+    ssize_t probe_point = 0;\n+    for (ssize_t i = 0; i < num_set_bits; i++) {\n+      size_t next_expected_bit = set_bits[i];\n+      probe_point = bm.find_next_set_bit(probe_point, boundary_idx);\n+      if (next_expected_bit >= boundary_idx) {\n+        \/\/ Verify that last failed search returns sentinel value: boundary_idx\n+        ASSERT_EQ(probe_point, boundary_idx);\n+        break;\n+      } else {\n+        ASSERT_EQ(probe_point, next_expected_bit);\n+        probe_point++;            \/\/ Prepare to look beyond the most recent bit.\n+      }\n+    }\n+    if (probe_point < boundary_idx) {\n+      \/\/ In case there are no set bits in the last 1\/4 of bit map, confirm that last failed search returns sentinel: boundary_idx\n+      probe_point = bm.find_next_set_bit(probe_point, boundary_idx);\n+      ASSERT_EQ(probe_point, boundary_idx);\n@@ -77,6 +127,31 @@\n-    \/\/ Confirm that find_next_set_bit(idx) returns _num_bits and find_next_set_bit(idx, boundary_idx) returns boundary_idx\n-    \/\/  for all legal values of idx\n-    for (ssize_t i = 0; i < SMALL_BITMAP_SIZE; i++) {\n-      ssize_t result = bm_small.find_next_set_bit(i);\n-      \/\/ Expect number_of_bits result since set bit should not be found.\n-      ASSERT_EQ(result, SMALL_BITMAP_SIZE);\n+    \/\/ Make sure find_prev_set_bit() works correctly\n+    size_t probe_point = size - 1;\n+    for (ssize_t i = num_set_bits - 1; i >= 0; i--) {\n+      size_t next_expected_bit = set_bits[i];\n+      probe_point = bm.find_prev_set_bit(probe_point);\n+      ASSERT_EQ(probe_point, next_expected_bit);\n+      probe_point--;            \/\/ Prepare to look before the most recent bit.\n+    }\n+    probe_point = bm.find_prev_set_bit(probe_point);\n+    ASSERT_EQ(probe_point, -1); \/\/ Verify that last failed search returns sentinel value: -1\n+\n+    \/\/ Confirm that find_prev_set_bit() with a bounded search space works correctly\n+    \/\/ Limit this search to the last 3\/4 of the full bit map\n+    boundary_idx = size \/ 4;\n+    probe_point = size - 1;\n+    for (ssize_t i = num_set_bits - 1; i >= 0; i--) {\n+      size_t next_expected_bit = set_bits[i];\n+      probe_point = bm.find_next_set_bit(probe_point, boundary_idx);\n+      if (next_expected_bit <= boundary_idx) {\n+        \/\/ Verify that last failed search returns sentinel value: boundary_idx\n+        ASSERT_EQ(probe_point, boundary_idx);\n+        break;\n+      } else {\n+        ASSERT_EQ(probe_point, next_expected_bit);\n+        probe_point--;            \/\/ Prepare to look beyond the most recent bit.\n+      }\n+    }\n+    if (probe_point >= boundary_idx) {\n+      probe_point = bm.find_next_set_bit(probe_point, boundary_idx);\n+        \/\/ Verify that last failed search returns sentinel value: boundary_idx\n+      ASSERT_EQ(probe_point, boundary_idx);\n@@ -85,4 +160,16 @@\n-    for (ssize_t i = LARGE_BITMAP_SIZE \/ 4; i < 3 * LARGE_BITMAP_SIZE\/ 4; i++) {\n-      ssize_t result = bm_large.find_next_set_bit(i, 3 * LARGE_BITMAP_SIZE \/ 4);\n-      \/\/ Expect number_of_bits result since set bit should not be found.\n-      ASSERT_EQ(result, LARGE_BITMAP_SIZE);\n+    \/\/ What's the longest cluster of consecutive bits\n+    ssize_t previous_value = -2;\n+    size_t longest_run = 0;\n+    size_t current_run = 0;\n+    for (size_t i = 0; i < num_set_bits; i++) {\n+      next_expected_bit = set_bits[i];\n+      if (next_expected_bit == previous_value + 1) {\n+        current_run++;\n+      } else {\n+        previous_value = next_expected_bit;\n+        current_run = 1;\n+      }\n+      if (current_run > longest_run) {\n+        longest_run = current_run;\n+      }\n+      previous_value = next_expected_bit;\n@@ -91,4 +178,120 @@\n-    for (ssize_t i = 0; i < SMALL_BITMAP_SIZE; i++) {\n-      ssize_t result = bm_small.find_next_set_bit(i);\n-      \/\/ Expect number_of_bits result since set bit should not be found.\n-      ASSERT_EQ(result, SMALL_BITMAP_SIZE);\n+    \/\/ Confirm that find_next_consecutive_bits() works for each cluster size known to have at least one match\n+    for (size_t cluster_size = 1; cluster_size <= longest_run; cluster_size++) {\n+\n+      \/\/ Verify that find_next_consecutive_bits() works\n+      size_t bit_idx = 0;\n+      ssize_t probe_point = 0;\n+      while (probe_point <= size - cluster_size) {\n+        size_t cluster_found = false;\n+        size_t next_expected_custer;\n+        while (!cluster_found && (bit_idx <= num_set_bits - cluster_size)) {\n+          cluster_found = true;\n+          for (int i = 1; i < cluster_size; i++) {\n+            if (set_bits[bit_idx] + i != set_bit[bit_idx + i]) {\n+              cluster_found = false;\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster_found) {\n+          ssize_t next_expected_cluster = bit_idx;\n+          probe_point = bm.find_next_consecutive_bits(cluster_size, probe_point);\n+          ASSERT_EQ(next_expected_cluster, probe_point);\n+          probe_point++;\n+          bit_idx++;\n+        } else {\n+          bit_idx++;\n+        }\n+      }\n+      \/\/ Confirm that the last request, which fails to find a cluster, returns sentinel value: num_bits\n+      probe_point = bm.find_next_consecutive_bits(cluster_size, probe_point);\n+      ASSERT_EQ(probe_point, size);\n+\n+      \/\/ Repeat the above experiment, using 3\/4 size as the search boundary_idx\n+      bit_idx = 0;\n+      probe_point = 0;\n+      boundary_idx = 4 * size \/ 4;\n+      while (probe_point <= boundary_idx - cluster_size) {\n+        size_t cluster_found = false;\n+        size_t next_expected_custer;\n+        while (!cluster_found && (bit_idx <= num_set_bits - cluster_size)) {\n+          cluster_found = true;\n+          for (int i = 1; i < cluster_size; i++) {\n+            if (set_bits[bit_idx] + i != set_bit[bit_idx + i]) {\n+              cluster_found = false;\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster_found) {\n+          ssize_t next_expected_cluster = set_bits[bit_idx];\n+          probe_point = bm.find_next_consecutive_bits(cluster_size, probe_point, boundary_idx);\n+          ASSERT_EQ(next_expected_cluster, probe_point);\n+          probe_point++;\n+          bit_idx++;\n+        } else {\n+          bit_idx++;\n+        }\n+      }\n+      \/\/ Confirm that the last request, which fails to find a cluster, returns sentinel value: boundary_idx\n+      probe_point = bm.find_prev_consecutive_bits(cluster_size, probe_point, boundary_idx);\n+      ASSERT_EQ(probe_point, boundary_idx);\n+\n+      \/\/ Verify that find_prev_consecutive_bits() works\n+      bit_idx = num_set_bits - 1;\n+      probe_point = size - 1;\n+      while (probe_point >= cluster_size - 1) {\n+        size_t cluster_found = false;\n+        size_t next_expected_custer;\n+        while (!cluster_found && (bit_idx - cluster_size >= -1)) {\n+          cluster_found = true;\n+          for (int i = 1; i < cluster_size; i++) {\n+            if (set_bits[bit_idx] - i != set_bit[bit_idx - i]) {\n+              cluster_found = false;\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster_found) {\n+          ssize_t next_expected_cluster = set_bits[bit_idx];\n+          probe_point = bm.find_prev_consecutive_bits(cluster_size, probe_point);\n+          ASSERT_EQ(next_expected_cluster, probe_point);\n+          probe_point--;\n+          bit_idx--;\n+        } else {\n+          bit_idx--;\n+        }\n+      }\n+      \/\/ Confirm that the last request, which fails to find a cluster, returns sentinel value: -1\n+      probe_point = bm.find_prev_consecutive_bits(cluster_size, probe_point);\n+      ASSERT_EQ(probe_point, -1);\n+\n+      \/\/ Verify that find_prev_consecutive_bits() works with the search range bounded at 1\/4 size\n+      bit_idx = num_set_bits - 1;\n+      probe_point = size - 1;\n+      boundary_idx = size \/ 4;\n+      while (probe_point >= boundary_idx - 1 + cluster_size) {\n+        size_t cluster_found = false;\n+        size_t next_expected_custer;\n+        while (!cluster_found && (bit_idx - cluster_size >= -1)) {\n+          cluster_found = true;\n+          for (int i = 1; i < cluster_size; i++) {\n+            if (set_bits[bit_idx] - i != set_bit[bit_idx - i]) {\n+              cluster_found = false;\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster_found) {\n+          ssize_t next_expected_cluster = set_bits[bit_idx];\n+          probe_point = bm.find_prev_consecutive_bits(cluster_size, probe_point, boundary_idx);\n+          ASSERT_EQ(next_expected_cluster, probe_point);\n+          probe_point--;\n+          bit_idx--;\n+        } else {\n+          bit_idx--;\n+        }\n+      }\n+      \/\/ Confirm that the last request, which fails to find a cluster, returns sentinel value: boundary_idx\n+      probe_point = bm.find_prev_consecutive_bits(cluster_size, probe_point, boundary_idx);\n+      ASSERT_EQ(probe_point, boundary_idx);\n@@ -97,0 +300,3 @@\n+    \/\/ Confirm that find_next_consecutive_bits() works for each cluster sizes known not to have any matches\n+    probe_point = bm.find_next_consecutive_bits(longest_run + 1, 0);\n+    ASSERT_EQ(probe_point, size);  \/\/ Confirm: failed search returns sentinel: size\n@@ -98,0 +304,2 @@\n+    probe_point = bm.find_prev_consecutive_bits(longest_run + 1, size);\n+    ASSERT_EQ(probe_point, -1);    \/\/ Confirm: failed search returns sentinel: -1\n@@ -99,0 +307,3 @@\n+    boundary_idx = 3 * size \/ 4;\n+    probe_point = bm.find_next_consecutive_bits(longest_run + 1, 0, boundary_idx);\n+    ASSERT_EQ(probe_point, boundary_idx); \/\/ Confirm: failed search returns sentinel: boundary_idx\n@@ -100,2 +311,4 @@\n-    \/\/ Confirm that find_prev_set_bit(idx) returns -1 and find_prev_set_bit(idx, boundary_idx) returns boundary idx\n-    \/\/  for all legal values of idx\n+    boundary_idx = size \/ 4;\n+    probe_point = bm.find_prev_consecutive_bits(longest_run + 1, size, boundary_idx);\n+    ASSERT_EQ(probe_point, -1);           \/\/ Confirm: failed search returns sentinel: -1\n+  }\n@@ -103,1 +316,0 @@\n-    \/\/ Confirm that find_next_consecutive_bits(1..8, idx, boundary_idx) returns boundary_idx for all legal values of idx\n@@ -105,1 +317,1 @@\n-    \/\/ Confirm that find_next_consecutive_bits(1..8, idx) returns _num_bits for all legal values of idx\n+  BasicShenandoahSimpleBitMapTest() {\n@@ -107,1 +319,4 @@\n-    \/\/ Confirm that find_prev_consecutive_bits(1..8, idx, boundary_idx) returns boundary_idx for all legal values of idx\n+    \/\/ Initial state of each bitmap is all bits are clear.  Confirm this:\n+    size_t set_bits_0[] = { };\n+    verifyBitMapState(bm_small, SMALL_BITMAP_SIZE, set_bits_0, 0);\n+    verifyBitMapState(bm_large, LARGE_BITMAP_SIZE, set_bits_0, 0);\n@@ -109,4 +324,5 @@\n-    \/\/ Confirm that find_prev_consecutive_bits(1..8, idx) returns -1 for all legal values of idx\n-    \n-    \/\/ Execute clear_all(), then set bits 8, 31, 63, 68, 127\n-    \/\/ Run the same tests\n+    bm_small.set_bit(5);\n+    bm_small.set_bit(63);\n+    bm_small.set_bit(128);\n+    size_t set_bits_1[] = { 5, 63, 128 };\n+    verifyBitMapState(bm_small, SMALL_BITMAP_SIZE, set_bits_1, 3);\n@@ -114,0 +330,4 @@\n+    bm_large.set_bit(5);\n+    bm_large.set_bit(63);\n+    bm_large.set_bit(128);\n+    verifyBitMapState(bm_large, LARGE_BITMAP_SIZE, set_bits_1, 3);\n@@ -115,1 +335,4 @@\n-    \/\/ clear_bits 31 and 68 and run the same tests\n+    \/\/ Test some consecutive bits\n+    bm_small.set_bit(140);\n+    bm_small.set_bit(141);\n+    bm_small.set_bit(142);\n@@ -117,2 +340,3 @@\n-    \/\/ Execute clear_all, set two bits out of every 32 bits\n-    \/\/ Run the same tests\n+    bm_small.set_bit(253);\n+    bm_small.set_bit(254);\n+    bm_small.set_bit(255);\n@@ -120,2 +344,2 @@\n-    \/\/ Execute clear_all, set 3 bits out of every 32 bits\n-    \/\/ Run the same tests\n+    bm_small.set_bit(271);\n+    bm_small.set_bit(272);\n@@ -123,2 +347,3 @@\n-    \/\/ Execute clear_all, set 7 bits out of every 32 bits\n-    \/\/ Run the same tests\n+    bm_small.set_bit(320);\n+    bm_small.set_bit(321);\n+    bm_small.set_bit(322);\n@@ -126,2 +351,1 @@\n-    \/\/ Selectively clear every other bit at the 64-bit offsets\n-    \/\/ Run the same tests\n+    bm_small.set_bit(361);\n@@ -129,2 +353,2 @@\n-    \/\/ Execute clear_all, set 8 bits out of every 32 bits\n-    \/\/ Run the same tests\n+    size_t set_bits_2[] = { 5, 63, 128, 140, 141, 142, 253, 254, 255, 271, 272, 320, 321, 322, 361 };\n+    verifyBitMapState(bm_small, SMALL_BITMAP_SIZE, set_bits_2, 15);\n@@ -132,2 +356,3 @@\n-    \/\/ Clear all 8 bits at each 64-bit offset\n-    \/\/ Run the same tests\n+    bm_large.set_bit(140);\n+    bm_large.set_bit(141);\n+    bm_large.set_bit(142);\n@@ -135,2 +360,3 @@\n-  }\n-};\n+    bm_large.set_bit(1021);\n+    bm_large.set_bit(1022);\n+    bm_large.set_bit(1023);\n@@ -138,3 +364,1 @@\n-TEST_VM_F(BasicShenandoahSimpleBitMapTest, maximum_test) {\n-  EXPECT_EQ(seq.maximum(), 100);\n-}\n+    bm_large.set_bit(1051);\n@@ -142,3 +366,30 @@\n-TEST_VM_F(BasicShenandoahNumberSeqTest, minimum_test) {\n-  EXPECT_EQ(0, seq.percentile(0));\n-}\n+    bm_large.set_bit(1280);\n+    bm_large.set_bit(1281);\n+    bm_large.set_bit(1282);\n+\n+    bm_large.set_bit(1300);\n+    bm_large.set_bit(1301);\n+    bm_large.set_bit(1302);\n+\n+    size_t set_bits_3[] = { 5, 63, 128, 140, 141, 142, 1021, 1022, 1023, 1051, 1280, 1281, 1282, 1300, 1301, 1302 }\n+    verifyBitMapState(bm_large, LARGE_BITMAP_SIZE, set_bits_3, 16);\n+\n+    \/\/ Test clear_bit\n+    bm_small.clear_bit(141);\n+    bm_small.clear_bit(253);\n+    size_t set_bits_4[] = { 5, 63, 128, 140, 142, 254, 255, 271, 272, 320, 321, 322, 361 };\n+    verifyBitMapState(bm_small, SMALL_BITMAP_SIZE, set_bits_2, 13);\n+    \n+    bm_large.clear_bit(5);\n+    bm_large.clear_bit(63);\n+    bm_large.clear_bit(128);\n+    bm_large.clear_bit(141);\n+    size_t set_bits_5[] = { 140, 142, 1021, 1022, 1023, 1051, 1280, 1281, 1282, 1300, 1301, 1302 }\n+    verifyBitMapState(bm_large, LARGE_BITMAP_SIZE, set_bits_5, 12);\n+\n+    \/\/ Test clear_all()\n+    bm_small.clear_all();\n+    bm_large.clear_all();\n+\n+  }\n+};\n@@ -146,9 +397,1 @@\n-TEST_VM_F(BasicShenandoahNumberSeqTest, percentile_test) {\n-  EXPECT_NEAR(0, seq.percentile(10), err);\n-  EXPECT_NEAR(1, seq.percentile(20), err);\n-  EXPECT_NEAR(10, seq.percentile(30), err);\n-  EXPECT_NEAR(100, seq.percentile(40), err);\n-  EXPECT_NEAR(100, seq.percentile(50), err);\n-  EXPECT_NEAR(100, seq.percentile(75), err);\n-  EXPECT_NEAR(100, seq.percentile(90), err);\n-  EXPECT_NEAR(100, seq.percentile(100), err);\n+TEST(BasicShenandoahSimpleBitMapTest, minimum_test) {\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahSimpleBitMap.cpp","additions":318,"deletions":75,"binary":false,"changes":393,"status":"modified"}]}