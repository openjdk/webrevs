{"files":[{"patch":"@@ -592,1 +592,1 @@\n-  size_t beg = _partitions.leftmost(Mutator);\n+  size_t beg = _partitions.leftmost_empty(Mutator);\n@@ -596,1 +596,1 @@\n-    if (end >= _partitions.max()) {\n+    if (end > _partitions.rightmost_empty(Mutator)) {\n@@ -682,2 +682,2 @@\n-  size_t region_capacity = alloc_capacity(r);\n-  _partitions.move_to_partition(idx, Collector, region_capacity);\n+  size_t ac = alloc_capacity(r);\n+  _partitions.move_to_partition(idx, Collector, ac);\n@@ -782,0 +782,1 @@\n+      \/\/ Note: can_allocate_from() denotes that region is entirely empty\n@@ -795,3 +796,3 @@\n-      size_t alloc_capacity = this->alloc_capacity(idx);\n-      if (_partitions.partition_id_matches(idx, Collector) && (alloc_capacity > 0)) {\n-        _partitions.move_to_partition(idx, Mutator, alloc_capacity);\n+      size_t ac = alloc_capacity(idx);\n+      if (_partitions.partition_id_matches(idx, Collector) && (ac > 0)) {\n+        _partitions.move_to_partition(idx, Mutator, ac);\n@@ -799,1 +800,1 @@\n-        collector_not_empty_xfer += alloc_capacity;\n+        collector_not_empty_xfer += ac;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -44,4 +44,4 @@\n-\n-\n-\/\/ This class implements partitioning of regions into distinct sets.  Each ShenandoahHeapRegion is either in the Mutator free set,\n-\/\/ the Collector free set, or in neither free set (NotFree).\n+\/\/ ShenandoahRegionPartitions provides an abstraction to help organize the implementation of ShenandoahFreeSet.  This\n+\/\/ class implements partitioning of regions into distinct sets.  Each ShenandoahHeapRegion is either in the Mutator free set,\n+\/\/ the Collector free set, or in neither free set (NotFree).  When we speak of a \"free partition\", we mean partitions that\n+\/\/ for which the ShenandoahFreeSetPartitionId is not equal to NotFree.\n@@ -109,2 +109,3 @@\n-  \/\/ Place region idx into free partition new_partition.  Requires that idx is currently not NotFree.\n-  void move_to_partition(size_t idx, ShenandoahFreeSetPartitionId new_partition, size_t region_capacity);\n+  \/\/ Place region idx into free partition new_partition, adjusting used and capacity totals for the original and new partition\n+  \/\/ given that available bytes can still be allocated within this region.  Requires that idx is currently not NotFree.\n+  void move_to_partition(size_t idx, ShenandoahFreeSetPartitionId new_partition, size_t available);\n@@ -187,0 +188,24 @@\n+\/\/ Publicly, ShenandoahFreeSet represents memory that is available to mutator threads.  The public capacity(), used(),\n+\/\/ and available() methods represent this public notion of memory that is under control of the mutator.  Separately,\n+\/\/ ShenandoahFreeSet also represents memory available to garbage collection activities for compaction purposes.\n+\/\/\n+\/\/ The Shenandoah garbage collector evacuates live objects out of specific regions that are identified as members of the\n+\/\/ collection set (cset).\n+\/\/\n+\/\/ The ShenandoahFreeSet endeavors to congregrate survivor objects (objects that have been evacuated at least once) at the\n+\/\/ high end of memory.  New mutator allocations are taken from the low end of memory.  Within the mutator's range of regions,\n+\/\/ humongous allocations are taken from the lowest addresses, and LAB (local allocation buffers) and regular shared allocations\n+\/\/ are taken from the higher address of the mutator's range of regions.  This approach allows longer lasting survivor regions\n+\/\/ to congregate at the top of the heap and longer lasting humongous regions to congregate at the bottom of the heap, with\n+\/\/ short-lived frequently evacuated regions occupying the middle of the heap.\n+\/\/\n+\/\/ Mutator and garbage collection activities tend to scramble the content of regions.  Twice, during each GC pass, we rebuild\n+\/\/ the free set in an effort to restore the efficient segregation of Collector and Mutator regions:\n+\/\/\n+\/\/  1. At the start of evacuation, we know exactly how much memory is going to be evacuated, and this guides our\n+\/\/     sizing of the Collector free set.\n+\/\/\n+\/\/  2. At the end of GC, we have reclaimed all of the memory that was spanned by the cset.  We rebuild here to make\n+\/\/     sure there is enough memory reserved at the high end of memory to hold the objects that might need to be evacuated\n+\/\/     during the next GC pass.\n+\n@@ -200,2 +225,3 @@\n-  \/\/ While holding the heap lock, allocate memory for a humongous object which will span multiple contiguous heap\n-  \/\/ regions.\n+  \/\/ While holding the heap lock, allocate memory for a humongous object which spans one or more regions that\n+  \/\/ were previously empty.  Regions that represent humongous objects are entirely dedicated to the humongous\n+  \/\/ object.  No other objects are packed into these regions.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":34,"deletions":8,"binary":false,"changes":42,"status":"modified"}]}