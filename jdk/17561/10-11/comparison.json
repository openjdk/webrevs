{"files":[{"patch":"@@ -45,0 +45,236 @@\n+#undef KELVIN_TRACE\n+\n+\n+#ifdef KELVIN_TRACE\n+static char buf1[17], buf2[17];\n+const static char ascii[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n+\n+\/\/ NOT THREAD SAFE\n+char* ltos_1(size_t arg) {\n+  buf1[16] = '\\0';\n+  for (int i = 15; i >= 0; i--) {\n+    size_t byte = arg & 0xff;\n+    buf1[i] = ascii[byte];\n+    arg >>= 4;\n+  }\n+  return buf1;\n+}\n+\n+char* ltos_2(size_t arg) {\n+  buf2[16] = '\\0';\n+  for (int i = 15; i >= 0; i--) {\n+    size_t byte = arg & 0xff;\n+    buf2[i] = ascii[byte];\n+    arg >>= 4;\n+  }\n+  return buf2;\n+}\n+#endif\n+\n+\n+inline ssize_t ShenandoahSimpleBitMap::find_next_set_bit(ssize_t start_idx, ssize_t boundary_idx) const {\n+  assert((start_idx >= 0) && (start_idx < _num_bits), \"precondition\");\n+  assert((boundary_idx > start_idx) && (boundary_idx <= _num_bits), \"precondition\");\n+#ifdef KELVIN_TRACE\n+  ssize_t orig_start_idx = start_idx;\n+  size_t orig_bit_number = start_idx % _bits_per_array_element;\n+#endif\n+\n+  do {\n+    size_t array_idx = start_idx \/ _bits_per_array_element;\n+    size_t bit_number = start_idx % _bits_per_array_element;\n+    size_t element_bits = _bitmap[array_idx];\n+\n+    size_t mask = (size_t) (ssize_t) -1;\n+    if (bit_number > 0) {\n+      size_t mask_out = (((size_t) 0x01) << bit_number) - 1;\n+      mask &= ~mask_out;\n+    }\n+#ifdef KELVIN_TRACE\n+    log_info(gc)(\" @ top of loop, bit_number: \" SIZE_FORMAT \", elements: 0x%016lx, mask: 0x%016lx\",\n+                 bit_number, element_bits, mask);\n+#endif\n+    if (element_bits & mask) {\n+      \/\/ The next set bit is here\n+      size_t the_bit = ((size_t) 0x01) << bit_number;\n+      while (bit_number < _bits_per_array_element) {\n+        if (element_bits & the_bit) {\n+          ssize_t candidate_result = (array_idx * _bits_per_array_element) + bit_number;\n+#ifdef KELVIN_TRACE\n+          log_info(gc)(\"find_next_set_bit(%ld, %ld) wants to return %ld, the_bit: 0x%016lx, bit_number: %ld\",\n+                       orig_start_idx, boundary_idx, candidate_result, the_bit, bit_number);\n+#endif\n+          if (candidate_result < boundary_idx) return candidate_result;\n+          else return boundary_idx;\n+        } else {\n+          the_bit <<= 1;\n+          bit_number++;\n+        }\n+      }\n+#ifdef KELVIN_TRACE\n+      log_info(gc)(\"find_next_set_bit(%ld, %ld) wants to fail, array_idx: %ld, orig_bit_number: %ld, elements: %lx, mask: %lx\",\n+                   orig_start_idx, boundary_idx, array_idx, orig_bit_number, element_bits, mask);\n+#endif\n+      assert(false, \"should not reach here\");\n+    } else {\n+      \/\/ Next bit is not here.  Try the next array element\n+      start_idx += _bits_per_array_element - bit_number;\n+    }      \n+  } while (start_idx < boundary_idx);\n+  return boundary_idx;\n+}\n+\n+inline ssize_t ShenandoahSimpleBitMap::find_next_set_bit(ssize_t start_idx) const {\n+  assert((start_idx >= 0) && (start_idx < _num_bits), \"precondition\");\n+  return find_next_set_bit(start_idx, _num_bits);\n+}\n+\n+inline ssize_t ShenandoahSimpleBitMap::find_prev_set_bit(ssize_t last_idx, ssize_t boundary_idx) const {\n+  assert((last_idx >= 0) && (last_idx < _num_bits), \"precondition\");\n+  assert((boundary_idx >= -1) && (boundary_idx < last_idx), \"precondition\");\n+#ifdef KELVIN_TRACE\n+  ssize_t orig_last_idx = last_idx;\n+#endif\n+\n+  do {\n+    ssize_t array_idx = last_idx \/ _bits_per_array_element;\n+    size_t bit_number = last_idx % _bits_per_array_element;\n+    size_t element_bits = _bitmap[array_idx];\n+\n+    \/\/ Does not work if bit_number is 63\n+\n+    size_t mask;\n+    if (bit_number == 63){\n+      mask = ~((size_t) 0x0);\n+    } else {\n+      mask = (((size_t) 0x1) << (bit_number + 1)) - 1;\n+    }\n+\n+#ifdef KELVIN_TRACE\n+      log_info(gc)(\" @top of inner loop, array_idx: %ld, bit_number: %ld, element_bits: %lx, mask: %lx\",\n+                   array_idx, bit_number, element_bits, mask);\n+#endif\n+\n+    if (element_bits & mask) {\n+      \/\/ The prev set bit is here\n+      size_t the_bit = ((size_t) 0x01) << bit_number;\n+\n+      for (ssize_t bit_iterator = bit_number; bit_iterator >= 0; bit_iterator--) {\n+        if (element_bits & the_bit) {\n+          ssize_t candidate_result = (array_idx * _bits_per_array_element) + bit_number;\n+#ifdef KELVIN_TRACE\n+          log_info(gc)(\"find_prev_set_bit(%ld, %ld) wants to return %ld, the_bit: %lx, bit_number: %ld\",\n+                       orig_last_idx, boundary_idx, candidate_result, the_bit, bit_number);\n+#endif\n+          if (candidate_result > boundary_idx) return candidate_result;\n+          else return boundary_idx;\n+        } else {\n+          the_bit >>= 1;\n+          bit_number--;\n+        }\n+      }\n+      assert(false, \"should not reach here\");\n+    } else {\n+      \/\/ Next bit is not here.  Try the previous array element\n+      last_idx -= (bit_number + 1);\n+    }      \n+  } while (last_idx > boundary_idx);\n+  return boundary_idx;\n+}\n+\n+inline ssize_t ShenandoahSimpleBitMap::find_prev_set_bit(ssize_t last_idx) const {\n+  assert((last_idx >= 0) && (last_idx < _num_bits), \"precondition\");\n+  return find_prev_set_bit(last_idx, -1);\n+}\n+\n+inline ssize_t ShenandoahSimpleBitMap::find_next_consecutive_bits(size_t num_bits, ssize_t start_idx) const {\n+  assert((start_idx >= 0) && (start_idx < _num_bits), \"precondition\");\n+  return find_next_consecutive_bits(num_bits, start_idx, _num_bits);\n+}\n+\n+ssize_t ShenandoahSimpleBitMap::find_next_consecutive_bits(size_t num_bits, ssize_t start_idx, ssize_t boundary_idx) const {\n+  assert((start_idx >= 0) && (start_idx < _num_bits), \"precondition\");\n+#ifdef KELVIN_TRACE\n+  ssize_t orig_start_idx = start_idx;\n+#endif\n+\n+  \/\/ Stop looking if there are not num_bits remaining in probe space.\n+  ssize_t start_boundary = boundary_idx - num_bits;\n+  while (start_idx <= start_boundary) {\n+    if (is_forward_consecutive_ones(start_idx, num_bits)) {\n+#ifdef KELVIN_TRACE\n+      log_info(gc)(\"find_next_consecutive_bits(%ld, %ld, %ld) wants to return %ld\",\n+                   num_bits, start_idx, boundary_idx, orig_start_idx);\n+#endif\n+      return start_idx;\n+    } else {\n+      \/\/ There is at least one zero bit in this span.  Align the next probe at the start of trailing ones for probed span.\n+      size_t trailing_ones = count_trailing_ones(start_idx + num_bits - 1);\n+      start_idx += num_bits - trailing_ones;\n+    }\n+  }\n+  \/\/ No match found.\n+  return boundary_idx;\n+}\n+\n+inline ssize_t ShenandoahSimpleBitMap::find_prev_consecutive_bits(size_t num_bits, ssize_t last_idx) const {\n+  assert((last_idx >= 0) && (last_idx < _num_bits), \"precondition\");\n+  return find_prev_consecutive_bits(num_bits, last_idx, (ssize_t) -1);\n+}\n+\n+ssize_t ShenandoahSimpleBitMap::find_prev_consecutive_bits(size_t num_bits, ssize_t last_idx, ssize_t boundary_idx) const {\n+  assert((last_idx >= 0) && (last_idx < _num_bits), \"precondition\");\n+#ifdef KELVIN_TRACE\n+  ssize_t orig_last_idx = last_idx;\n+#endif\n+\n+  \/\/ Stop looking if there are not num_bits remaining in probe space.\n+  ssize_t last_boundary = boundary_idx + num_bits;\n+  while (last_idx >= last_boundary) {\n+    if (is_backward_consecutive_ones(last_idx, num_bits)) {\n+#ifdef KELVIN_TRACE\n+      log_info(gc)(\"find_prev_consecutive_bits(%ld, %ld, %ld) wants to return %ld\",\n+                   num_bits, last_idx, boundary_idx, orig_last_idx);\n+#endif\n+      return last_idx + 1 - num_bits;\n+    } else {\n+      \/\/ There is at least one zero bit in this span.  Align the next probe at the end of leading ones for probed span.\n+      size_t leading_ones = count_leading_ones(last_idx - (num_bits - 1));\n+      last_idx -= num_bits - leading_ones;\n+    }\n+  }\n+  \/\/ No match found.\n+  return boundary_idx;\n+}\n+\n+void ShenandoahRegionPartitions::dump_bitmap_all() const {\n+  log_info(gc)(\"Mutator range [%ld, %ld], Collector range [%ld, %ld]\",\n+               _leftmosts[Mutator], _rightmosts[Mutator], _leftmosts[Collector], _rightmosts[Collector]);\n+  log_info(gc)(\"%6s: %18s %18s %18s %18s\", \"index\", \"Mutator Bits\", \"Collector Bits\", \"Conflicted Bits\", \"NotFree Bits\");\n+  dump_bitmap_range(0, _max-1);\n+}\n+\n+void ShenandoahRegionPartitions::dump_bitmap_range(ssize_t start_idx, ssize_t end_idx) const {\n+  assert((start_idx >= 0) && (start_idx < (ssize_t) _max), \"precondition\");\n+  assert((end_idx >= 0) && (end_idx < (ssize_t) _max), \"precondition\");\n+  ssize_t aligned_start = _membership[Mutator].aligned_index(start_idx);\n+  ssize_t aligned_end = _membership[Mutator].aligned_index(end_idx);\n+  ssize_t alignment = _membership[Mutator].alignment();\n+  while (aligned_start <= aligned_end) {\n+    dump_bitmap_row(aligned_start);\n+    aligned_start += alignment;\n+  }\n+}\n+\n+void ShenandoahRegionPartitions::dump_bitmap_row(ssize_t idx) const {\n+  assert((idx >= 0) && (idx < (ssize_t) _max), \"precondition\");\n+  ssize_t aligned_idx = _membership[Mutator].aligned_index(idx);\n+  size_t mutator_bits = _membership[Mutator].bits_at(aligned_idx);\n+  size_t collector_bits = _membership[Collector].bits_at(aligned_idx);\n+  size_t conflicted_bits = mutator_bits & collector_bits;\n+  size_t free_bits = mutator_bits | collector_bits;\n+  size_t notfree_bits =  ~free_bits;\n+  log_info(gc)(\"%6ld: 0x%016lx 0x%016lx 0x%016lx 0x%016lx\",\n+               aligned_idx, mutator_bits, collector_bits, conflicted_bits, notfree_bits);\n+}\n+\n@@ -49,1 +285,1 @@\n-    _membership(NEW_C_HEAP_ARRAY(ShenandoahFreeSetPartitionId, max_regions, mtGC))\n+    _membership{ ShenandoahSimpleBitMap(max_regions), ShenandoahSimpleBitMap(max_regions) }\n@@ -55,1 +291,0 @@\n-  FREE_C_HEAP_ARRAY(ShenandoahFreeSetPartitionId, _membership);\n@@ -88,3 +323,8 @@\n-void ShenandoahRegionPartitions::make_all_regions_unavailable() {\n-  for (size_t idx = 0; idx < _max; idx++) {\n-    _membership[idx] = NotFree;\n+inline ssize_t ShenandoahRegionPartitions:: leftmost(ShenandoahFreeSetPartitionId which_partition) const {\n+  assert (which_partition < NumPartitions, \"selected free partition must be valid\");\n+  ssize_t idx = _leftmosts[which_partition];\n+  if (idx >= _max) {\n+    return _max;\n+  } else {\n+    \/\/ _membership[which_partition].is_set(idx) may not be true if we are shrinking the interval\n+    return idx;\n@@ -92,0 +332,1 @@\n+}\n@@ -93,0 +334,11 @@\n+inline ssize_t ShenandoahRegionPartitions::rightmost(ShenandoahFreeSetPartitionId which_partition) const {\n+  assert (which_partition < NumPartitions, \"selected free partition must be valid\");\n+  ssize_t idx = _rightmosts[which_partition];\n+  \/\/ _membership[which_partition].is_set(idx) may not be true if we are shrinking the interval\n+  return idx;\n+}\n+\n+void ShenandoahRegionPartitions::make_all_regions_unavailable() {\n+#ifdef KELVIN_TRACE\n+  log_info(gc)(\"resetting partition info\");\n+#endif\n@@ -94,0 +346,1 @@\n+    _membership[partition_id].clear_all();\n@@ -95,1 +348,1 @@\n-    _rightmosts[partition_id] = 0;\n+    _rightmosts[partition_id] = -1;\n@@ -97,1 +350,1 @@\n-    _rightmosts_empty[partition_id] = 0;\n+    _rightmosts_empty[partition_id] = -1;;\n@@ -101,1 +354,0 @@\n-\n@@ -105,2 +357,2 @@\n-void ShenandoahRegionPartitions::establish_intervals(size_t mutator_leftmost, size_t mutator_rightmost,\n-                                                     size_t mutator_leftmost_empty, size_t mutator_rightmost_empty,\n+void ShenandoahRegionPartitions::establish_intervals(ssize_t mutator_leftmost, ssize_t mutator_rightmost,\n+                                                     ssize_t mutator_leftmost_empty, ssize_t mutator_rightmost_empty,\n@@ -119,1 +371,1 @@\n-  _rightmosts[Collector] = 0;\n+  _rightmosts[Collector] = -1;\n@@ -121,1 +373,1 @@\n-  _rightmosts_empty[Collector] = 0;\n+  _rightmosts_empty[Collector] = -1;\n@@ -126,0 +378,3 @@\n+#ifdef KELVIN_TRACE\n+  dump_bitmap_all();\n+#endif\n@@ -128,1 +383,0 @@\n-\n@@ -137,1 +391,1 @@\n-inline void ShenandoahRegionPartitions::shrink_interval_if_boundary_modified(ShenandoahFreeSetPartitionId partition, size_t idx) {\n+inline void ShenandoahRegionPartitions::shrink_interval_if_boundary_modified(ShenandoahFreeSetPartitionId partition, ssize_t idx) {\n@@ -139,2 +393,2 @@\n-    while ((_leftmosts[partition] < _max) && !partition_id_matches(_leftmosts[partition], partition)) {\n-      _leftmosts[partition]++;\n+    while ((_leftmosts[partition] < _max) && !_membership[partition].is_set(_leftmosts[partition])) {\n+      _leftmosts[partition] = find_index_of_next_available_region(partition, _leftmosts[partition] + 1);\n@@ -148,2 +402,2 @@\n-    while (_rightmosts[partition] > 0 && !partition_id_matches(_rightmosts[partition], partition)) {\n-      _rightmosts[partition]--;\n+    while (_rightmosts[partition] >= 0 && !_membership[partition].is_set(_rightmosts[partition])) {\n+      _rightmosts[partition] = find_index_of_previous_available_region(partition, _rightmosts[partition] - 1);\n@@ -156,0 +410,6 @@\n+  if (_leftmosts[partition] > _rightmosts[partition]) {\n+    _leftmosts[partition] = _max;\n+    _rightmosts[partition] = -1;\n+    _leftmosts_empty[partition] = _max;\n+    _rightmosts_empty[partition] = -1;\n+  }\n@@ -159,1 +419,7 @@\n-                                                           size_t idx, size_t region_available) {\n+                                                                             ssize_t idx, size_t region_available) {\n+#ifdef KELVIN_TRACE\n+  log_info(gc)(\"expand_maybe(%s, \" SSIZE_FORMAT \", \" SIZE_FORMAT \")\", partition_name(partition), idx, region_available);\n+  log_info(gc)(\" @entry: [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"], empty: [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"]\",\n+               _leftmosts[partition], _rightmosts[partition], _leftmosts_empty[partition], _rightmosts_empty[partition]);\n+#endif\n+\n@@ -174,0 +440,4 @@\n+#ifdef KELVIN_TRACE\n+  log_info(gc)(\" @ exit: [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"], empty: [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"]\",\n+               _leftmosts[partition], _rightmosts[partition], _leftmosts_empty[partition], _rightmosts_empty[partition]);\n+#endif\n@@ -178,2 +448,1 @@\n-void ShenandoahRegionPartitions::retire_from_partition(size_t idx, size_t used_bytes) {\n-  ShenandoahFreeSetPartitionId orig_partition = membership(idx);\n+void ShenandoahRegionPartitions::retire_from_partition(ShenandoahFreeSetPartitionId partition, ssize_t idx, size_t used_bytes) {\n@@ -183,1 +452,2 @@\n-  assert (orig_partition < NumPartitions, \"Cannot remove from free partitions if not already free\");\n+  assert (partition < NumPartitions, \"Cannot remove from free partitions if not already free\");\n+  assert (in_free_set(partition, idx), \"Must be in partition to remove from partition\");\n@@ -187,1 +457,1 @@\n-    increase_used(orig_partition, _region_size_bytes - used_bytes);\n+    increase_used(partition, _region_size_bytes - used_bytes);\n@@ -189,5 +459,9 @@\n-\n-  _membership[idx] = NotFree;\n-  shrink_interval_if_boundary_modified(orig_partition, idx);\n-\n-  _region_counts[orig_partition]--;\n+  _membership[partition].clear_bit(idx);\n+  shrink_interval_if_boundary_modified(partition, idx);\n+  _region_counts[partition]--;\n+#ifdef KELVIN_TRACE\n+  log_info(gc)(\"retire \" SIZE_FORMAT \" from partition %s\", idx, partition_name(partition));\n+  dump_bitmap_row(idx);\n+  log_info(gc)(\" @ exit: [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"], empty: [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"]\",\n+               _leftmosts[partition], _rightmosts[partition], _leftmosts_empty[partition], _rightmosts_empty[partition]);\n+#endif\n@@ -196,1 +470,1 @@\n-void ShenandoahRegionPartitions::make_free(size_t idx, ShenandoahFreeSetPartitionId which_partition, size_t available) {\n+void ShenandoahRegionPartitions::make_free(ssize_t idx, ShenandoahFreeSetPartitionId which_partition, size_t available) {\n@@ -198,1 +472,1 @@\n-  assert (_membership[idx] == NotFree, \"Cannot make free if already free\");\n+  assert (membership(idx) == NotFree, \"Cannot make free if already free\");\n@@ -202,1 +476,1 @@\n-  _membership[idx] = which_partition;\n+  _membership[which_partition].set_bit(idx);\n@@ -210,1 +484,2 @@\n-void ShenandoahRegionPartitions::move_to_partition(size_t idx, ShenandoahFreeSetPartitionId new_partition, size_t available) {\n+void ShenandoahRegionPartitions::move_from_partition_to_partition(ssize_t idx, ShenandoahFreeSetPartitionId orig_partition,\n+                                                                  ShenandoahFreeSetPartitionId new_partition, size_t available) {\n@@ -212,0 +487,1 @@\n+  assert (orig_partition < NumPartitions, \"Original partition must be valid\");\n@@ -215,3 +491,0 @@\n-  ShenandoahFreeSetPartitionId orig_partition = _membership[idx];\n-  assert (orig_partition < NumPartitions, \"Cannot move free unless already free\");\n-\n@@ -230,1 +503,4 @@\n-  _membership[idx] = new_partition;\n+\n+  _membership[orig_partition].clear_bit(idx);\n+  _membership[new_partition].set_bit(idx);\n+\n@@ -241,0 +517,9 @@\n+#ifdef KELVIN_TRACE\n+  log_info(gc)(\"move \" SIZE_FORMAT \" from partition %s to partition %s\",\n+               idx, partition_name(orig_partition), partition_name(new_partition));\n+  dump_bitmap_row(idx);\n+  log_info(gc)(\" @ end,   Mutator: [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"], empty: [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"]\",\n+               _leftmosts[Mutator], _rightmosts[Mutator], _leftmosts_empty[Mutator], _rightmosts_empty[Mutator]);\n+  log_info(gc)(\" @ end, Collector: [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"], empty: [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"]\",\n+               _leftmosts[Collector], _rightmosts[Collector], _leftmosts_empty[Collector], _rightmosts_empty[Collector]);\n+#endif\n@@ -243,1 +528,1 @@\n-inline ShenandoahFreeSetPartitionId ShenandoahRegionPartitions::membership(size_t idx) const {\n+const char* ShenandoahRegionPartitions::partition_membership_name(ssize_t idx) const {\n@@ -245,1 +530,8 @@\n-  return _membership[idx];\n+  ShenandoahFreeSetPartitionId result = NotFree;\n+  for (uint partition_id = 0; partition_id < NumPartitions; partition_id++) {\n+    if (_membership[partition_id].is_set(idx)) {\n+      assert(result == NotFree, \"Region should reside in only one partition\");\n+      result = (ShenandoahFreeSetPartitionId) partition_id;\n+    }\n+  }\n+  return partition_name(result);\n@@ -248,2 +540,3 @@\n-  \/\/ Returns true iff region idx is in the test_partition free_partition.\n-inline bool ShenandoahRegionPartitions::partition_id_matches(size_t idx, ShenandoahFreeSetPartitionId test_partition) const {\n+\n+#ifdef ASSERT\n+inline ShenandoahFreeSetPartitionId ShenandoahRegionPartitions::membership(ssize_t idx) const {\n@@ -251,7 +544,6 @@\n-  if (_membership[idx] == test_partition) {\n-    assert ((test_partition == NotFree) || (_free_set->alloc_capacity(idx) > 0),\n-            \"Free region \" SIZE_FORMAT \", belonging to %s free partition, must have alloc capacity\",\n-            idx, partition_name(test_partition));\n-    return true;\n-  } else {\n-    return false;\n+  ShenandoahFreeSetPartitionId result = NotFree;\n+  for (uint partition_id = 0; partition_id < NumPartitions; partition_id++) {\n+    if (_membership[partition_id].is_set(idx)) {\n+      assert(result == NotFree, \"Region should reside in only one partition\");\n+      result = (ShenandoahFreeSetPartitionId) partition_id;\n+    }\n@@ -259,0 +551,1 @@\n+  return result;\n@@ -261,10 +554,4 @@\n-inline size_t ShenandoahRegionPartitions::leftmost(ShenandoahFreeSetPartitionId which_partition) const {\n-  assert (which_partition < NumPartitions, \"selected free partition must be valid\");\n-  size_t idx = _leftmosts[which_partition];\n-  if (idx >= _max) {\n-    return _max;\n-  } else {\n-    assert (partition_id_matches(idx, which_partition), \"left-most region must be free\");\n-    return idx;\n-  }\n-}\n+\/\/ Returns true iff region idx is in the test_partition, which must not equal NotFree.\n+inline bool ShenandoahRegionPartitions::partition_id_matches(ssize_t idx, ShenandoahFreeSetPartitionId test_partition) const {\n+  assert (idx < _max, \"index is sane: \" SIZE_FORMAT \" < \" SIZE_FORMAT, idx, _max);\n+  assert (test_partition < NotFree, \"must be a valid partition\");\n@@ -272,5 +559,1 @@\n-inline size_t ShenandoahRegionPartitions::rightmost(ShenandoahFreeSetPartitionId which_partition) const {\n-  assert (which_partition < NumPartitions, \"selected free partition must be valid\");\n-  size_t idx = _rightmosts[which_partition];\n-  assert ((_leftmosts[which_partition] == _max) || partition_id_matches(idx, which_partition), \"right-most region must be free\");\n-  return idx;\n+  return membership(idx) == test_partition;\n@@ -278,0 +561,1 @@\n+#endif\n@@ -284,1 +568,61 @@\n-size_t ShenandoahRegionPartitions::leftmost_empty(ShenandoahFreeSetPartitionId which_partition) {\n+  \/\/ Return the index of the next available region >= start_index, or maximum_regions if not found.\n+inline ssize_t ShenandoahRegionPartitions::find_index_of_next_available_region(\n+  ShenandoahFreeSetPartitionId which_partition, ssize_t start_index) const {\n+  ssize_t rightmost_idx = rightmost(which_partition);\n+  ssize_t leftmost_idx = leftmost(which_partition);\n+  if ((rightmost_idx < leftmost_idx) || (start_index > rightmost_idx)) return _max;\n+  ssize_t result = _membership[which_partition].find_next_set_bit(start_index, rightmost_idx + 1);\n+#ifdef KELVIN_TRACE\n+  log_info(gc)(\"find_index_of_next_available_region(%s, %ld) returning %ld\",\n+               partition_name(which_partition), start_index, (result > rightmost_idx)? _max: result);\n+  dump_bitmap_row(result < _max? result: _max - 1);\n+#endif\n+  return (result > rightmost_idx)? _max: result;\n+}\n+\n+\/\/ Return the index of the previous available region <= last_index, or -1 if not found.\n+inline ssize_t ShenandoahRegionPartitions::find_index_of_previous_available_region(\n+  ShenandoahFreeSetPartitionId which_partition, ssize_t last_index) const {\n+  ssize_t leftmost_idx = leftmost(which_partition);\n+  \/\/ if (leftmost_idx == max) then (last_index < leftmost_idx)\n+  if (last_index < leftmost_idx) return -1;\n+  ssize_t result = _membership[which_partition].find_prev_set_bit(last_index, -1);\n+#ifdef KELVIN_TRACE\n+  log_info(gc)(\"find_index_of_previous_available_region(%s, %ld) returning %ld\",\n+               partition_name(which_partition), last_index, (result < leftmost_idx)? -1: result);\n+  dump_bitmap_row(last_index);\n+#endif\n+  return (result < leftmost_idx)? -1: result;\n+}\n+\n+\/\/ Return the index of the next available cluster of cluster_size regions >= start_index, or maximum_regions if not found.\n+inline ssize_t ShenandoahRegionPartitions::find_index_of_next_available_cluster_of_regions(\n+  ShenandoahFreeSetPartitionId which_partition, ssize_t start_index, size_t cluster_size) const {\n+  ssize_t rightmost_idx = rightmost(which_partition);\n+  ssize_t leftmost_idx = leftmost(which_partition);\n+  if ((rightmost_idx < leftmost_idx) || (start_index > rightmost_idx)) return _max;\n+  ssize_t result = _membership[which_partition].find_next_consecutive_bits(cluster_size, start_index, rightmost_idx + 1);\n+#ifdef KELVIN_TRACE\n+  log_info(gc)(\"find_index_of_next_available_cluster(%s, %ld, \" SIZE_FORMAT \") returning %ld\",\n+               partition_name(which_partition), start_index, cluster_size, (result > rightmost_idx)? _max: result);\n+  dump_bitmap_row(start_index);\n+#endif\n+  return (result > rightmost_idx)? _max: result;\n+}\n+\n+\/\/ Return the index of the previous available cluster of cluster_size regions <= last_index, or -1 if not found.\n+inline ssize_t ShenandoahRegionPartitions::find_index_of_previous_available_cluster_of_regions(\n+  ShenandoahFreeSetPartitionId which_partition, ssize_t last_index, size_t cluster_size) const {\n+  ssize_t leftmost_idx = leftmost(which_partition);\n+  \/\/ if (leftmost_idx == max) then (last_index < leftmost_idx)\n+  if (last_index < leftmost_idx) return -1;\n+  ssize_t result = _membership[which_partition].find_prev_consecutive_bits(cluster_size, last_index, leftmost_idx - 1);\n+#ifdef KELVIN_TRACE\n+  log_info(gc)(\"find_index_of_next_available_cluster(%s, %ld, \" SIZE_FORMAT \") returning %ld\",\n+               partition_name(which_partition), last_index, cluster_size, (result <= leftmost_idx)? -1: result);\n+  dump_bitmap_row(last_index);\n+#endif\n+  return (result <= leftmost_idx)? -1: result;\n+}\n+\n+ssize_t ShenandoahRegionPartitions::leftmost_empty(ShenandoahFreeSetPartitionId which_partition) {\n@@ -286,2 +630,5 @@\n-  for (size_t idx = _leftmosts_empty[which_partition]; idx < _max; idx++) {\n-    if ((membership(idx) == which_partition) && (_free_set->alloc_capacity(idx) == _region_size_bytes)) {\n+  ssize_t max_regions = _max;\n+  for (ssize_t idx = find_index_of_next_available_region(which_partition, _leftmosts_empty[which_partition]);\n+       idx < max_regions; ) {\n+    assert(in_free_set(which_partition, idx), \"Boundaries or find_prev_set_bit failed: \" SSIZE_FORMAT, idx);\n+    if (_free_set->alloc_capacity(idx) == _region_size_bytes) {\n@@ -291,0 +638,1 @@\n+    idx = find_index_of_next_available_region(which_partition, idx + 1);\n@@ -293,1 +641,1 @@\n-  _rightmosts_empty[which_partition] = 0;\n+  _rightmosts_empty[which_partition] = -1;\n@@ -297,1 +645,1 @@\n-inline size_t ShenandoahRegionPartitions::rightmost_empty(ShenandoahFreeSetPartitionId which_partition) {\n+ssize_t ShenandoahRegionPartitions::rightmost_empty(ShenandoahFreeSetPartitionId which_partition) {\n@@ -299,2 +647,3 @@\n-  for (intptr_t idx = _rightmosts_empty[which_partition]; idx >= 0; idx--) {\n-    if ((membership(idx) == which_partition) && (_free_set->alloc_capacity(idx) == _region_size_bytes)) {\n+  for (ssize_t idx = find_index_of_previous_available_region(which_partition, _rightmosts_empty[which_partition]); idx >= 0; ) {\n+    assert(in_free_set(which_partition, idx), \"Boundaries or find_prev_set_bit failed: \" SSIZE_FORMAT, idx);\n+    if (_free_set->alloc_capacity(idx) == _region_size_bytes) {\n@@ -304,0 +653,1 @@\n+    idx = find_index_of_previous_available_region(which_partition, idx - 1);\n@@ -306,2 +656,2 @@\n-  _rightmosts_empty[which_partition] = 0;\n-  return 0;\n+  _rightmosts_empty[which_partition] = -1;\n+  return -1;\n@@ -310,0 +660,1 @@\n+\n@@ -313,4 +664,4 @@\n-  size_t leftmosts[NumPartitions];\n-  size_t rightmosts[NumPartitions];\n-  size_t empty_leftmosts[NumPartitions];\n-  size_t empty_rightmosts[NumPartitions];\n+  ssize_t leftmosts[NumPartitions];\n+  ssize_t rightmosts[NumPartitions];\n+  ssize_t empty_leftmosts[NumPartitions];\n+  ssize_t empty_rightmosts[NumPartitions];\n@@ -321,2 +672,2 @@\n-    rightmosts[i] = 0;\n-    empty_rightmosts[i] = 0;\n+    rightmosts[i] = -1;\n+    empty_rightmosts[i] = -1;\n@@ -325,1 +676,1 @@\n-  for (size_t i = 0; i < _max; i++) {\n+  for (ssize_t i = 0; i < _max; i++) {\n@@ -358,2 +709,2 @@\n-  assert (leftmost(Mutator) <= _max, \"leftmost in bounds: \"  SIZE_FORMAT \" < \" SIZE_FORMAT, leftmost(Mutator),  _max);\n-  assert (rightmost(Mutator) < _max, \"rightmost in bounds: \"  SIZE_FORMAT \" < \" SIZE_FORMAT, rightmost(Mutator),  _max);\n+  assert (leftmost(Mutator) <= _max, \"leftmost in bounds: \"  SSIZE_FORMAT \" < \" SSIZE_FORMAT, leftmost(Mutator),  _max);\n+  assert (rightmost(Mutator) < _max, \"rightmost in bounds: \"  SSIZE_FORMAT \" < \" SSIZE_FORMAT, rightmost(Mutator),  _max);\n@@ -362,1 +713,1 @@\n-          \"leftmost region should be free: \" SIZE_FORMAT,  leftmost(Mutator));\n+          \"leftmost region should be free: \" SSIZE_FORMAT,  leftmost(Mutator));\n@@ -364,1 +715,1 @@\n-          \"rightmost region should be free: \" SIZE_FORMAT, rightmost(Mutator));\n+          \"rightmost region should be free: \" SSIZE_FORMAT, rightmost(Mutator));\n@@ -368,2 +719,2 @@\n-  size_t beg_off = leftmosts[Mutator];\n-  size_t end_off = rightmosts[Mutator];\n+  ssize_t beg_off = leftmosts[Mutator];\n+  ssize_t end_off = rightmosts[Mutator];\n@@ -371,1 +722,1 @@\n-          \"free regions before the leftmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT, beg_off, leftmost(Mutator));\n+          \"free regions before the leftmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT, beg_off, leftmost(Mutator));\n@@ -373,1 +724,1 @@\n-          \"free regions past the rightmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT,  end_off, rightmost(Mutator));\n+          \"free regions past the rightmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,  end_off, rightmost(Mutator));\n@@ -378,1 +729,1 @@\n-          \"free empty regions before the leftmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT, beg_off, leftmost_empty(Mutator));\n+          \"free empty regions before the leftmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT, beg_off, leftmost_empty(Mutator));\n@@ -380,1 +731,1 @@\n-          \"free empty regions past the rightmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT,  end_off, rightmost_empty(Mutator));\n+          \"free empty regions past the rightmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,  end_off, rightmost_empty(Mutator));\n@@ -383,2 +734,2 @@\n-  assert (leftmost(Collector) <= _max, \"leftmost in bounds: \"  SIZE_FORMAT \" < \" SIZE_FORMAT, leftmost(Collector),  _max);\n-  assert (rightmost(Collector) < _max, \"rightmost in bounds: \"  SIZE_FORMAT \" < \" SIZE_FORMAT, rightmost(Collector),  _max);\n+  assert (leftmost(Collector) <= _max, \"leftmost in bounds: \"  SSIZE_FORMAT \" < \" SSIZE_FORMAT, leftmost(Collector),  _max);\n+  assert (rightmost(Collector) < _max, \"rightmost in bounds: \"  SSIZE_FORMAT \" < \" SSIZE_FORMAT, rightmost(Collector),  _max);\n@@ -387,1 +738,1 @@\n-          \"leftmost region should be free: \" SIZE_FORMAT,  leftmost(Collector));\n+          \"leftmost region should be free: \" SSIZE_FORMAT,  leftmost(Collector));\n@@ -389,1 +740,1 @@\n-          \"rightmost region should be free: \" SIZE_FORMAT, rightmost(Collector));\n+          \"rightmost region should be free: \" SSIZE_FORMAT, rightmost(Collector));\n@@ -396,1 +747,1 @@\n-          \"free regions before the leftmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT, beg_off, leftmost(Collector));\n+          \"free regions before the leftmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT, beg_off, leftmost(Collector));\n@@ -398,1 +749,1 @@\n-          \"free regions past the rightmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT,  end_off, rightmost(Collector));\n+          \"free regions past the rightmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,  end_off, rightmost(Collector));\n@@ -403,1 +754,1 @@\n-          \"free empty regions before the leftmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT, beg_off, leftmost_empty(Collector));\n+          \"free empty regions before the leftmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT, beg_off, leftmost_empty(Collector));\n@@ -405,1 +756,1 @@\n-          \"free empty regions past the rightmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT,  end_off, rightmost_empty(Collector));\n+          \"free empty regions past the rightmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,  end_off, rightmost_empty(Collector));\n@@ -439,1 +790,2 @@\n-        for (ssize_t idx = _partitions.rightmost(Mutator); idx >= leftmost; idx--) {\n+        for (ssize_t idx = _partitions.rightmost(Mutator); idx >= leftmost; ) {\n+          assert(_partitions.in_free_set(Mutator, idx), \"Boundaries or find_prev_set_bit failed: \" SSIZE_FORMAT, idx);\n@@ -441,7 +793,5 @@\n-          if (_partitions.partition_id_matches(idx, Mutator)) {\n-            \/\/ try_allocate_in() increases used if the allocation is successful.\n-            HeapWord* result;\n-            size_t min_size = (req.type() == ShenandoahAllocRequest::_alloc_tlab)? req.min_size(): req.size();\n-            if ((alloc_capacity(r) >= min_size) && ((result = try_allocate_in(r, req, in_new_region)) != nullptr)) {\n-              return result;\n-            }\n+          \/\/ try_allocate_in() increases used if the allocation is successful.\n+          HeapWord* result;\n+          size_t min_size = (req.type() == ShenandoahAllocRequest::_alloc_tlab)? req.min_size(): req.size();\n+          if ((alloc_capacity(r) >= min_size) && ((result = try_allocate_in(r, req, in_new_region)) != nullptr)) {\n+            return result;\n@@ -449,0 +799,1 @@\n+          idx = _partitions.find_index_of_previous_available_region(Mutator, idx - 1);\n@@ -460,6 +811,5 @@\n-      for (ssize_t idx = _partitions.rightmost(Collector); idx >= leftmost_collector; idx--) {\n-        if (_partitions.partition_id_matches(idx, Collector)) {\n-          HeapWord* result = try_allocate_in(_heap->get_region(idx), req, in_new_region);\n-          if (result != nullptr) {\n-            return result;\n-          }\n+      for (ssize_t idx = _partitions.rightmost(Collector); idx >= leftmost_collector; ) {\n+        assert(_partitions.in_free_set(Collector, idx), \"Boundaries or find_prev_set_bit failed: \" SSIZE_FORMAT, idx);\n+        HeapWord* result = try_allocate_in(_heap->get_region(idx), req, in_new_region);\n+        if (result != nullptr) {\n+          return result;\n@@ -467,0 +817,1 @@\n+        idx = _partitions.find_index_of_previous_available_region(Collector, idx - 1);\n@@ -476,10 +827,9 @@\n-      for (ssize_t idx = _partitions.rightmost_empty(Mutator); idx >= leftmost_mutator_empty; idx--) {\n-        if (_partitions.partition_id_matches(idx, Mutator)) {\n-          ShenandoahHeapRegion* r = _heap->get_region(idx);\n-          if (can_allocate_from(r)) {\n-            flip_to_gc(r);\n-            HeapWord *result = try_allocate_in(r, req, in_new_region);\n-            if (result != nullptr) {\n-              log_debug(gc, free)(\"Flipped region \" SIZE_FORMAT \" to gc for request: \" PTR_FORMAT, idx, p2i(&req));\n-              return result;\n-            }\n+      for (ssize_t idx = _partitions.rightmost_empty(Mutator); idx >= leftmost_mutator_empty; ) {\n+        assert(_partitions.in_free_set(Mutator, idx), \"Boundaries or find_prev_set_bit failed: \" SSIZE_FORMAT, idx);\n+        ShenandoahHeapRegion* r = _heap->get_region(idx);\n+        if (can_allocate_from(r)) {\n+          flip_to_gc(r);\n+          HeapWord *result = try_allocate_in(r, req, in_new_region);\n+          if (result != nullptr) {\n+            log_debug(gc, free)(\"Flipped region \" SIZE_FORMAT \" to gc for request: \" PTR_FORMAT, idx, p2i(&req));\n+            return result;\n@@ -488,0 +838,1 @@\n+        idx = _partitions.find_index_of_previous_available_region(Mutator, idx - 1);\n@@ -528,1 +879,1 @@\n-                          partition_name(_partitions.membership(r->index())),  r->index(), r->free());\n+                          _partitions.partition_membership_name(r->index()), r->index(), r->free());\n@@ -543,1 +894,1 @@\n-                          partition_name(_partitions.membership(r->index())),  r->index(), r->free());\n+                          _partitions.partition_membership_name(r->index()),  r->index(), r->free());\n@@ -561,1 +912,1 @@\n-  if ((!ShenandoahPackEvacTightly && result == nullptr) || (alloc_capacity(r) < PLAB::min_size() * HeapWordSize)) {\n+  if (alloc_capacity(r) < PLAB::min_size() * HeapWordSize) {\n@@ -568,3 +919,3 @@\n-    \/\/ if the remaining capacity is less than PLAB::min_size() or if !ShenandoahPackEvacTightly.  Note that TLAB\n-    \/\/ requests will generally downsize to absorb all memory available within the region even if the remaining\n-    \/\/ memory is less than the desired size.\n+    \/\/ if the remaining capacity is less than PLAB::min_size().  Note that TLAB requests will generally downsize\n+    \/\/ to absorb all memory available within the region even if the remaining memory is less than the desired size.\n+\n@@ -572,1 +923,1 @@\n-    _partitions.retire_from_partition(idx, r->used());\n+    _partitions.retire_from_partition(req.is_mutator_alloc()? Mutator: Collector, idx, r->used());\n@@ -579,0 +930,1 @@\n+  assert(req.is_mutator_alloc(), \"All humongous allocations are performed by mutator\");\n@@ -582,1 +934,1 @@\n-  size_t num = ShenandoahHeapRegion::required_regions(words_size * HeapWordSize);\n+  ssize_t num = ShenandoahHeapRegion::required_regions(words_size * HeapWordSize);\n@@ -585,1 +937,1 @@\n-  if (num > _partitions.count(Mutator)) {\n+  if (num > (ssize_t) _partitions.count(Mutator)) {\n@@ -589,0 +941,3 @@\n+  ssize_t start_range = _partitions.leftmost_empty(Mutator);\n+  ssize_t end_range = _partitions.rightmost_empty(Mutator);\n+\n@@ -591,3 +946,6 @@\n-\n-  size_t beg = _partitions.leftmost_empty(Mutator);\n-  size_t end = beg;\n+  ssize_t beg = _partitions.find_index_of_next_available_cluster_of_regions(Mutator, start_range, num);\n+  if (beg > end_range) {\n+    \/\/ Hit the end, goodbye\n+    return nullptr;\n+  }\n+  ssize_t end = beg;\n@@ -596,6 +954,1 @@\n-    if (end > _partitions.rightmost_empty(Mutator)) {\n-      \/\/ Hit the end, goodbye\n-      return nullptr;\n-    }\n-\n-    \/\/ If regions are not adjacent, then current [beg; end] is useless, and we may fast-forward.\n+    \/\/ We've confirmed num contiguous regions belonging to Mutator partition, so no need to confirm membership.\n@@ -603,4 +956,7 @@\n-    if (!_partitions.partition_id_matches(end, Mutator) || !can_allocate_from(_heap->get_region(end))) {\n-      end++;\n-      beg = end;\n-      continue;\n+    while (!can_allocate_from(_heap->get_region(end))) {\n+      beg = _partitions.find_index_of_next_available_cluster_of_regions(Mutator, end_range + 1, num);\n+      if (beg > end_range) {\n+        \/\/ Hit the end, goodbye\n+        return nullptr;\n+      }\n+      end = beg;\n@@ -620,1 +976,1 @@\n-  for (size_t i = beg; i <= end; i++) {\n+  for (ssize_t i = beg; i <= end; i++) {\n@@ -645,1 +1001,1 @@\n-    _partitions.retire_from_partition(r->index(), ShenandoahHeapRegion::region_size_bytes());\n+    _partitions.retire_from_partition(Mutator, r->index(), ShenandoahHeapRegion::region_size_bytes());\n@@ -683,1 +1039,1 @@\n-  _partitions.move_to_partition(idx, Collector, ac);\n+  _partitions.move_from_partition_to_partition(idx, Mutator, Collector, ac);\n@@ -704,4 +1060,0 @@\n-  cset_regions = 0;\n-\n-  size_t mutator_regions = 0;\n-  size_t mutator_used = 0;\n@@ -709,1 +1061,2 @@\n-  size_t max_regions = _partitions.max_regions();\n+  cset_regions = 0;\n+  clear_internal();\n@@ -711,0 +1064,1 @@\n+  size_t max_regions = _partitions.max_regions();\n@@ -717,0 +1071,3 @@\n+  size_t mutator_regions = 0;\n+  size_t mutator_used = 0;\n+\n@@ -752,1 +1109,3 @@\n-      } else {\n+      }\n+#ifdef KELVIN_DEPRECATE\n+      else {\n@@ -756,1 +1115,4 @@\n-    } else {\n+#endif\n+    }\n+#ifdef KELVIN_DEPRECATE\n+    else {\n@@ -760,0 +1122,1 @@\n+#endif\n@@ -780,2 +1143,3 @@\n-    for (size_t idx = _partitions.leftmost_empty(Collector);\n-         (max_xfer_regions > 0) && (idx <= _partitions.rightmost_empty(Collector)); idx++) {\n+    ssize_t rightmost = _partitions.rightmost_empty(Collector);\n+    for (ssize_t idx = _partitions.leftmost_empty(Collector); (max_xfer_regions > 0) && (idx <= rightmost); ) {\n+      assert(_partitions.in_free_set(Collector, idx), \"Boundaries or find_next_set_bit failed: \" SSIZE_FORMAT, idx);\n@@ -783,2 +1147,2 @@\n-      if (_partitions.partition_id_matches(idx, Collector) && can_allocate_from(idx)) {\n-        _partitions.move_to_partition(idx, Mutator, region_size_bytes);\n+      if (can_allocate_from(idx)) {\n+        _partitions.move_from_partition_to_partition(idx, Collector, Mutator, region_size_bytes);\n@@ -788,0 +1152,1 @@\n+      idx = _partitions.find_index_of_next_available_region(Collector, idx + 1);\n@@ -794,2 +1159,3 @@\n-    for (size_t idx = _partitions.leftmost(Collector);\n-         (max_xfer_regions > 0) && (idx <= _partitions.rightmost(Collector)); idx++) {\n+    ssize_t rightmost = _partitions.rightmost_empty(Collector);\n+    for (ssize_t idx = _partitions.leftmost(Collector); (max_xfer_regions > 0) && (idx <= rightmost); ) {\n+      assert(_partitions.in_free_set(Collector, idx), \"Boundaries or find_next_set_bit failed: \" SSIZE_FORMAT, idx);\n@@ -797,2 +1163,2 @@\n-      if (_partitions.partition_id_matches(idx, Collector) && (ac > 0)) {\n-        _partitions.move_to_partition(idx, Mutator, ac);\n+      if (ac > 0) {\n+        _partitions.move_from_partition_to_partition(idx, Collector, Mutator, ac);\n@@ -802,0 +1168,1 @@\n+      idx = _partitions.find_index_of_next_available_region(Collector, idx + 1);\n@@ -851,2 +1218,0 @@\n-  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n-\n@@ -856,3 +1221,0 @@\n-    if (!_partitions.partition_id_matches(idx, Mutator)) {\n-      continue;\n-    }\n@@ -860,3 +1222,1 @@\n-    size_t ac = alloc_capacity(r);\n-    if (!ShenandoahPackEvacTightly && (ac != region_size_bytes)) {\n-      \/\/ Only use fully empty regions for Collector reserve if !ShenandoahPackEvacTightly\n+    if (!_partitions.in_free_set(Mutator, idx)) {\n@@ -866,0 +1226,1 @@\n+    size_t ac = alloc_capacity(r);\n@@ -879,1 +1240,1 @@\n-      _partitions.move_to_partition(idx, Collector, ac);\n+      _partitions.move_from_partition_to_partition(idx, Mutator, Collector, ac);\n@@ -923,1 +1284,1 @@\n-      if (_partitions.partition_id_matches(i, Mutator)) {\n+      if (_partitions.in_free_set(Mutator, i)) {\n@@ -928,1 +1289,1 @@\n-      } else if (_partitions.partition_id_matches(i, Collector)) {\n+      } else if (_partitions.in_free_set(Collector, i)) {\n@@ -955,1 +1316,1 @@\n-      size_t last_idx = 0;\n+      ssize_t last_idx = 0;\n@@ -964,2 +1325,2 @@\n-      for (size_t idx = _partitions.leftmost(Mutator); idx <= _partitions.rightmost(Mutator); idx++) {\n-        if (_partitions.partition_id_matches(idx, Mutator)) {\n+      for (ssize_t idx = _partitions.leftmost(Mutator); idx <= _partitions.rightmost(Mutator); idx++) {\n+        if (_partitions.in_free_set(Mutator, idx)) {\n@@ -1025,2 +1386,2 @@\n-      for (size_t idx = _partitions.leftmost(Collector); idx <= _partitions.rightmost(Collector); idx++) {\n-        if (_partitions.partition_id_matches(idx, Collector)) {\n+      for (ssize_t idx = _partitions.leftmost(Collector); idx <= _partitions.rightmost(Collector); idx++) {\n+        if (_partitions.in_free_set(Collector, idx)) {\n@@ -1067,0 +1428,1 @@\n+#ifdef KELVIN_NOT_USED\n@@ -1070,6 +1432,8 @@\n-  for (size_t index = _partitions.leftmost(Mutator); index <= _partitions.rightmost(Mutator); index++) {\n-    if (index < _partitions.max() && _partitions.partition_id_matches(index, Mutator)) {\n-      ShenandoahHeapRegion* r = _heap->get_region(index);\n-      if (r->free() >= MinTLABSize) {\n-        return r->free();\n-      }\n+  \/\/ KELVIN DOES NOT LIKE THIS CODE: get the heap lock, and return the sum of available free.\n+\n+  ssize_t rightmost = _partitions.rightmost(Mutator);\n+  for (ssize_t index = _partitions.leftmost(Mutator); index <= rightmost; ) {\n+    assert(_partitions.in_free_set(Mutator, index), \"Boundaries or find_next_set_bit failed: \" SSIZE_FORMAT, index);\n+    ShenandoahHeapRegion* r = _heap->get_region(index);\n+    if (r->free() >= MinTLABSize) {\n+      return r->free();\n@@ -1077,0 +1441,1 @@\n+    index = _partitions.find_index_of_next_available_region(Mutator, index + 1);\n@@ -1082,0 +1447,1 @@\n+#endif\n@@ -1085,4 +1451,5 @@\n-  for (size_t index = _partitions.leftmost(Mutator); index <= _partitions.rightmost(Mutator); index++) {\n-    if (_partitions.partition_id_matches(index, Mutator)) {\n-      _heap->get_region(index)->print_on(out);\n-    }\n+  ssize_t rightmost = _partitions.rightmost(Mutator);\n+  for (ssize_t index = _partitions.leftmost(Mutator); index <= rightmost; ) {\n+    assert(_partitions.in_free_set(Mutator, index), \"Boundaries or find_next_set_bit failed: \" SSIZE_FORMAT, index);\n+    _heap->get_region(index)->print_on(out);\n+    index = _partitions.find_index_of_next_available_region(Mutator, index + 1);\n@@ -1091,4 +1458,5 @@\n-  for (size_t index = _partitions.leftmost(Collector); index <= _partitions.rightmost(Collector); index++) {\n-    if (_partitions.partition_id_matches(index, Collector)) {\n-      _heap->get_region(index)->print_on(out);\n-    }\n+  rightmost = _partitions.rightmost(Collector);\n+  for (ssize_t index = _partitions.leftmost(Collector); index <= rightmost; ) {\n+    assert(_partitions.in_free_set(Collector, index), \"Boundaries or find_next_set_bit failed: \" SSIZE_FORMAT, index);\n+    _heap->get_region(index)->print_on(out);\n+    index = _partitions.find_index_of_next_available_region(Collector, index + 1);\n@@ -1124,8 +1492,9 @@\n-  for (size_t index = _partitions.leftmost(Mutator); index <= _partitions.rightmost(Mutator); index++) {\n-    if (_partitions.partition_id_matches(index, Mutator)) {\n-      ShenandoahHeapRegion* r = _heap->get_region(index);\n-      size_t used = r->used();\n-      squared += used * used;\n-      linear += used;\n-      count++;\n-    }\n+  ssize_t rightmost = _partitions.rightmost(Mutator);\n+  for (ssize_t index = _partitions.leftmost(Mutator); index <= rightmost; ) {\n+    assert(_partitions.in_free_set(Mutator, index), \"Boundaries or find_next_set_bit failed: \" SSIZE_FORMAT, index);\n+    ShenandoahHeapRegion* r = _heap->get_region(index);\n+    size_t used = r->used();\n+    squared += used * used;\n+    linear += used;\n+    count++;\n+    index = _partitions.find_index_of_next_available_region(Mutator, index + 1);\n@@ -1156,1 +1525,1 @@\n-  size_t last_idx = 0;\n+  ssize_t last_idx = 0;\n@@ -1162,10 +1531,8 @@\n-  for (size_t index = _partitions.leftmost(Mutator); index <= _partitions.rightmost(Mutator); index++) {\n-    if (_partitions.partition_id_matches(index, Mutator)) {\n-      ShenandoahHeapRegion* r = _heap->get_region(index);\n-      if (r->is_empty()) {\n-        free += ShenandoahHeapRegion::region_size_bytes();\n-        if (last_idx + 1 == index) {\n-          empty_contig++;\n-        } else {\n-          empty_contig = 1;\n-        }\n+  ssize_t rightmost = _partitions.rightmost(Mutator);\n+  for (ssize_t index = _partitions.leftmost(Mutator); index <= rightmost; ) {\n+    assert(_partitions.in_free_set(Mutator, index), \"Boundaries or find_next_set_bit failed: \" SSIZE_FORMAT, index);\n+    ShenandoahHeapRegion* r = _heap->get_region(index);\n+    if (r->is_empty()) {\n+      free += ShenandoahHeapRegion::region_size_bytes();\n+      if (last_idx + 1 == index) {\n+        empty_contig++;\n@@ -1173,1 +1540,1 @@\n-        empty_contig = 0;\n+        empty_contig = 1;\n@@ -1175,3 +1542,2 @@\n-\n-      max_contig = MAX2(max_contig, empty_contig);\n-      last_idx = index;\n+    } else {\n+      empty_contig = 0;\n@@ -1179,0 +1545,3 @@\n+    max_contig = MAX2(max_contig, empty_contig);\n+    last_idx = index;\n+    index = _partitions.find_index_of_next_available_region(Mutator, index + 1);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":582,"deletions":213,"binary":false,"changes":795,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-\n@@ -33,0 +32,267 @@\n+#undef KELVIN_TRACE_HPP\n+#ifdef KELVIN_TRACE_HPP\n+\n+extern char* ltos_1(size_t arg);\n+extern char* ltos_2(size_t arg);\n+#endif\n+\n+\n+\/\/ ShenandoahSimpleBitMap resembles CHeapBitMap but adds missing support for find_next_contiguous_bits() and\n+\/\/ find_prev_contiguous_bits.  An alternative refactoring of code would subclass CHeapBitMap, but this might\n+\/\/ break abstraction rules, because efficient implementation requires assumptions about superclass internals that\n+\/\/ might be violatee through future software maintenance.\n+class ShenandoahSimpleBitMap {\n+  static const size_t _bits_per_array_element = HeapWordSize * 8;\n+\n+  const ssize_t _num_bits;\n+  const size_t _num_words;\n+  size_t* const _bitmap;\n+\n+public:\n+#ifdef KELVIN_DOES_NOT_WANT\n+  \/\/ No-arg constructor simplifies declaration and subsequent re-initialization after number of regions is known.\n+  ShenandoahSimpleBitMap() :\n+      _num_bits(0),\n+      _num_words(0),\n+      _bitmap(nullptr) {\n+    clear_all();\n+  }\n+#endif\n+  \n+  ShenandoahSimpleBitMap(size_t num_bits) :\n+      _num_bits(num_bits),\n+      _num_words((num_bits + (_bits_per_array_element - 1)) \/ _bits_per_array_element),\n+      _bitmap(NEW_C_HEAP_ARRAY(size_t, _num_words, mtGC))\n+  {\n+    clear_all();\n+  }\n+\n+  ~ShenandoahSimpleBitMap() {\n+    if (_bitmap != nullptr) {\n+      FREE_C_HEAP_ARRAY(size_t, _bitmap);\n+    }\n+  }\n+\n+  void clear_all() {\n+    for (size_t i = 0; i < _num_words; i++) {\n+      _bitmap[i] = 0;\n+    }\n+  }\n+\n+private:\n+\n+  \/\/ Count consecutive ones in forward order, starting from start_idx.  Requires that there is at least one zero\n+  \/\/ between start_idx and index value (_num_bits - 1), inclusive.\n+  size_t count_leading_ones(ssize_t start_idx) const {\n+    assert((start_idx >= 0) && (start_idx < _num_bits), \"precondition\");\n+    size_t array_idx = start_idx \/ _bits_per_array_element;\n+    size_t element_bits = _bitmap[array_idx];\n+    size_t bit_number = start_idx % _bits_per_array_element;\n+    size_t the_bit = ((size_t) 0x01) << bit_number;\n+    size_t omit_mask = the_bit - 1;\n+    size_t mask = ((size_t) ((ssize_t) -1)) & omit_mask;\n+    if ((element_bits & mask) == mask) {\n+      size_t counted_ones = _bits_per_array_element - bit_number;\n+#ifdef KELVIN_TRACE_HPP\n+      printf(\"count_leading_ones(%ld) in %s with mask %s returning %ld + recurse with %ld\",\n+                   start_idx, ltos_1(element_bits), ltos_2(mask), counted_ones, start_idx + counted_ones);\n+#endif\n+      return counted_ones + count_leading_ones(start_idx + counted_ones);\n+    } else {\n+      size_t counted_ones;\n+      for (counted_ones = 0; element_bits & the_bit; counted_ones++) {\n+        the_bit <<= 1;\n+      }\n+#ifdef KELVIN_TRACE_HPP\n+      printf(\"count_leading_ones(%ld) in %s with mask %s returning %ld\",\n+                   start_idx, ltos_1(element_bits), ltos_2(mask), counted_ones);\n+#endif\n+      return counted_ones;\n+    }\n+  }\n+\n+  \/\/ Count consecutive ones in reverse order, starting from last_idx.  Requires that there is at least one zero\n+  \/\/ between last_idx and index value zero, inclusive.\n+  size_t count_trailing_ones(ssize_t last_idx) const {\n+    assert((last_idx >= 0) && (last_idx < _num_bits), \"precondition\");\n+    size_t array_idx = last_idx \/ _bits_per_array_element;\n+    size_t element_bits = _bitmap[array_idx];\n+    size_t bit_number = last_idx % _bits_per_array_element;\n+    size_t the_bit = ((size_t) 0x01) << bit_number;\n+\n+    \/\/ All ones from bit 0 to the_bit\n+    size_t mask = (the_bit * 2) - 1;\n+    if ((element_bits & mask) == mask) {\n+      size_t counted_ones = bit_number;\n+#ifdef KELVIN_TRACE_HPP\n+      printf(\"count_trailing_ones(%ld) in %s with mask %s returning %ld + recurse with %ld\",\n+                   last_idx, ltos_1(element_bits), ltos_2(mask), counted_ones, last_idx - counted_ones);\n+#endif\n+      return counted_ones + count_trailing_ones(last_idx - counted_ones);\n+    } else {\n+      size_t counted_ones;\n+      for (counted_ones = 0; element_bits & the_bit; counted_ones++) {\n+        the_bit >>= 1;\n+      }\n+#ifdef KELVIN_TRACE_HPP\n+      printf(\"count_trailing_ones(%ld) in %s with mask %s returning %ld\",\n+                   last_idx, ltos_1(element_bits), ltos_2(mask), counted_ones);\n+#endif\n+      return counted_ones;\n+    }\n+  }\n+\n+  bool is_forward_consecutive_ones(ssize_t start_idx, ssize_t count) const {\n+    assert((start_idx >= 0) && (start_idx < _num_bits), \"precondition\");\n+    assert(start_idx + count <= (ssize_t) _num_bits, \"precondition\");\n+    size_t array_idx = start_idx \/ _bits_per_array_element;\n+    size_t bit_number = start_idx % _bits_per_array_element;\n+    size_t the_bit = ((size_t) 0x01) << bit_number;\n+    size_t element_bits = _bitmap[array_idx];\n+\n+    if ((ssize_t) (_bits_per_array_element - bit_number) > count) {\n+      \/\/ All relevant bits reside within this array element\n+      size_t overreach_mask = ((size_t) 0x1 << (bit_number + count)) - 1;\n+      size_t exclude_mask = ((size_t) 0x1 << bit_number) - 1;\n+      size_t exact_mask = overreach_mask & ~exclude_mask;\n+#ifdef KELVIN_TRACE_HPP\n+      printf(\"is_forward_consecutive_ones(%ld, %ld) in %s with mask %s returning %s\",\n+                   start_idx, count, ltos_1(element_bits), ltos_2(exact_mask), (element_bits & exact_mask) == exact_mask? \"true\": \"false\");\n+#endif\n+      return (element_bits & exact_mask) == exact_mask? true: false;\n+    } else {\n+      \/\/ Need to exactly match all relevant bits of this array element, plus relevant bits of following array elements\n+      size_t overreach_mask = (size_t) (ssize_t) - 1;\n+      size_t exclude_mask = ((size_t) 0x1 << bit_number) - 1;\n+      size_t exact_mask = overreach_mask & ~exclude_mask;\n+      if ((element_bits & exact_mask) == exact_mask) {\n+        size_t matched_bits = _bits_per_array_element - bit_number;\n+#ifdef KELVIN_TRACE_HPP\n+      printf(\"is_forward_consecutive_ones(%ld, %ld) in %s with mask %s recursing\",\n+                   start_idx, count, ltos_1(element_bits), ltos_2(exact_mask));\n+#endif\n+        return is_forward_consecutive_ones(start_idx + matched_bits, count - matched_bits);\n+      } else {\n+#ifdef KELVIN_TRACE_HPP\n+        printf(\"is_forward_consecutive_ones(%ld, %ld) in %s with mask %s returning %s\",\n+                     start_idx, count, ltos_1(element_bits), ltos_2(exact_mask), \"false\");\n+#endif\n+        return false;\n+      }\n+    }\n+  }\n+\n+  bool is_backward_consecutive_ones(ssize_t last_idx, ssize_t count) const {\n+    assert((last_idx >= 0) && (last_idx < _num_bits), \"precondition\");\n+    assert(last_idx - count >= -1, \"precondition\");\n+    size_t array_idx = last_idx \/ _bits_per_array_element;\n+    size_t bit_number = last_idx % _bits_per_array_element;\n+    size_t the_bit = ((size_t) 0x01) << bit_number;\n+    size_t element_bits = _bitmap[array_idx];\n+\n+    if ((ssize_t) (bit_number + 1) >= count) {\n+      \/\/ All relevant bits reside within this array element\n+      size_t overreach_mask = ((size_t) 0x1 << (bit_number + 1)) - 1;\n+      size_t exclude_mask = ((size_t) 0x1 << (bit_number + 1 - count)) - 1;\n+      size_t exact_mask = overreach_mask & ~exclude_mask;\n+#ifdef KELVIN_TRACE_HPP\n+      printf(\"is_backward_consecutive_ones(%ld, %ld) in %s with mask %s returning %s\",\n+                   last_idx, count, ltos_1(element_bits), ltos_2(exact_mask), (element_bits & exact_mask) == exact_mask? \"true\": \"false\");\n+#endif\n+      return (element_bits & exact_mask) == exact_mask? true: false;\n+    } else {\n+      \/\/ Need to exactly match all relevant bits of this array element, plus relevant bits of following array elements\n+      size_t exact_mask = ((size_t) 0x1 << (bit_number + 1)) - 1;\n+      if ((element_bits & exact_mask) == exact_mask) {\n+        size_t matched_bits = bit_number + 1;\n+#ifdef KELVIN_TRACE_HPP\n+        printf(\"is_backward_consecutive_ones(%ld, %ld) in %s with mask %s recursing\",\n+                     last_idx, count,ltos_1( element_bits), ltos_2(exact_mask));\n+#endif\n+        return is_backward_consecutive_ones(last_idx - matched_bits, count - matched_bits);\n+      } else {\n+#ifdef KELVIN_TRACE_HPP\n+        printf(\"is_backward_consecutive_ones(%ld, %ld) in %s with mask %s returning %s\",\n+                     last_idx, count, ltos_1(element_bits), ltos_2(exact_mask), \"false\");\n+#endif\n+        return false;\n+      }\n+    }\n+  }\n+\n+public:\n+\n+  inline ssize_t aligned_index(ssize_t idx) const {\n+    assert((idx >= 0) && (idx < _num_bits), \"precondition\");\n+    ssize_t array_idx = idx \/ _bits_per_array_element;\n+    return array_idx * _bits_per_array_element;\n+  }\n+\n+  inline ssize_t alignment() const {\n+    return _bits_per_array_element;\n+  }\n+\n+  inline size_t bits_at(ssize_t idx) const {\n+    assert((idx >= 0) && (idx < _num_bits), \"precondition\");\n+    ssize_t array_idx = idx \/ _bits_per_array_element;\n+    return _bitmap[array_idx];\n+  }\n+\n+  inline void set_bit(ssize_t idx) {\n+    assert((idx >= 0) && (idx < _num_bits), \"precondition\");\n+    size_t array_idx = idx \/ _bits_per_array_element;\n+    size_t bit_number = idx % _bits_per_array_element;\n+    size_t the_bit = ((size_t) 0x01) << bit_number;\n+    _bitmap[array_idx] |= the_bit;\n+  }\n+\n+  inline void clear_bit(ssize_t idx) {\n+    assert((idx >= 0) && (idx < _num_bits), \"precondition\");\n+    assert(idx >= 0, \"precondition\");\n+    size_t array_idx = idx \/ _bits_per_array_element;\n+    size_t bit_number = idx % _bits_per_array_element;\n+    size_t the_bit = ((size_t) 0x01) << bit_number;\n+    _bitmap[array_idx] &= ~the_bit;\n+  }\n+  \n+  inline bool is_set(ssize_t idx) const {\n+    assert((idx >= 0) && (idx < _num_bits), \"precondition\");\n+    assert(idx >= 0, \"precondition\");\n+    size_t array_idx = idx \/ _bits_per_array_element;\n+    size_t bit_number = idx % _bits_per_array_element;\n+    size_t the_bit = ((size_t) 0x01) << bit_number;\n+    return (_bitmap[array_idx] & the_bit)? true: false;\n+  }\n+\n+  \/\/ Return the index of the first set bit which is greater or equal to start_idx.  If not found, return _num_bits.\n+  inline ssize_t find_next_set_bit(ssize_t start_idx) const;\n+\n+  \/\/ Return the index of the first set bit which is greater or equal to start_idx and less than boundary_idx. \n+  \/\/ If not found, return boundary_idx\n+  inline ssize_t find_next_set_bit(ssize_t start_idx, ssize_t boundary_idx) const;\n+\n+  \/\/ Return the index of the last set bit which is less or equal to start_idx.  If not found, return -1.\n+  inline ssize_t find_prev_set_bit(ssize_t last_idx) const;\n+\n+  \/\/ Return the index of the last set bit which is less or equal to start_idx and greater than boundary_idx.\n+  \/\/ If not found, return boundary_idx.\n+  inline ssize_t find_prev_set_bit(ssize_t last_idx, ssize_t boundary_idx) const;\n+\n+  \/\/ Return the smallest index at which a run of num_bits consecutive ones is found, where return value is >= start_idx\n+  \/\/ and return value < _num_bits.  If no run of num_bits consecutive ones is found within the target range, return _num_bits.\n+  inline ssize_t find_next_consecutive_bits(size_t num_bits, ssize_t start_idx) const;\n+\n+  \/\/ Return the smallest index at which a run of num_bits consecutive ones is found, where return value is >= start_idx\n+  \/\/ and return value < boundary_idx.  If no run of num_bits consecutive ones is found within the target range,\n+  \/\/ return boundary_idx.\n+  ssize_t find_next_consecutive_bits(size_t num_bits, ssize_t start_idx, ssize_t boundary_idx) const;\n+\n+  \/\/ Return the largest index at which a run of num_bits consecutive ones is found, where return value is <= last_idx and > -1.\n+  \/\/ If no run of num_bits consecutive ones is found within the target range, return -1.\n+  inline ssize_t find_prev_consecutive_bits(size_t num_bits, ssize_t last_idx) const;\n+\n+  \/\/ Return the largest index at which a run of num_bits consecutive ones is found, where return value is <= last_idx and > -1.\n+  \/\/ If no run of num_bits consecutive ones is found within the target range, return -1.\n+  ssize_t find_prev_consecutive_bits(size_t num_bits, ssize_t last_idx, ssize_t boundary_idx) const;\n+};\n+\n@@ -51,1 +317,1 @@\n-  const size_t _max;            \/\/ The maximum number of heap regions\n+  const ssize_t _max;           \/\/ The maximum number of heap regions\n@@ -54,0 +320,1 @@\n+#ifdef KELVIN_DEPRECATE\n@@ -55,0 +322,4 @@\n+#else\n+  \/\/ For each partition, we maintain a bitmap of which regions are affiliated with his partition.\n+  ShenandoahSimpleBitMap _membership[NumPartitions];\n+#endif\n@@ -59,3 +330,3 @@\n-  \/\/ canonical [_max, 0].\n-  size_t _leftmosts[NumPartitions];\n-  size_t _rightmosts[NumPartitions];\n+  \/\/ canonical [_max, -1].\n+  ssize_t _leftmosts[NumPartitions];\n+  ssize_t _rightmosts[NumPartitions];\n@@ -66,3 +337,3 @@\n-  \/\/ by the canonical [_max, 0].\n-  size_t _leftmosts_empty[NumPartitions];\n-  size_t _rightmosts_empty[NumPartitions];\n+  \/\/ by the canonical [_max, -1].\n+  ssize_t _leftmosts_empty[NumPartitions];\n+  ssize_t _rightmosts_empty[NumPartitions];\n@@ -80,2 +351,7 @@\n-  inline void shrink_interval_if_boundary_modified(ShenandoahFreeSetPartitionId partition, size_t idx);\n-  inline void expand_interval_if_boundary_modified(ShenandoahFreeSetPartitionId partition, size_t idx, size_t capacity);\n+  inline void shrink_interval_if_boundary_modified(ShenandoahFreeSetPartitionId partition, ssize_t idx);\n+  inline void expand_interval_if_boundary_modified(ShenandoahFreeSetPartitionId partition, ssize_t idx, size_t capacity);\n+\n+  void dump_bitmap_row(ssize_t idx) const;\n+  void dump_bitmap_range(ssize_t start_idx, ssize_t end_idx) const;\n+  void dump_bitmap_all() const;\n+\n@@ -92,1 +368,1 @@\n-    _membership[idx] = p;\n+    _membership[p].set_bit(idx);\n@@ -97,2 +373,2 @@\n-  void establish_intervals(size_t mutator_leftmost, size_t mutator_rightmost,\n-                           size_t mutator_leftmost_empty, size_t mutator_rightmost_empty,\n+  void establish_intervals(ssize_t mutator_leftmost, ssize_t mutator_rightmost,\n+                           ssize_t mutator_leftmost_empty, ssize_t mutator_rightmost_empty,\n@@ -104,1 +380,1 @@\n-  void retire_from_partition(size_t idx, size_t used_bytes);\n+  void retire_from_partition(ShenandoahFreeSetPartitionId p, ssize_t idx, size_t used_bytes);\n@@ -107,1 +383,1 @@\n-  void make_free(size_t idx, ShenandoahFreeSetPartitionId which_partition, size_t region_capacity);\n+  void make_free(ssize_t idx, ShenandoahFreeSetPartitionId which_partition, size_t region_capacity);\n@@ -111,1 +387,4 @@\n-  void move_to_partition(size_t idx, ShenandoahFreeSetPartitionId new_partition, size_t available);\n+  void move_from_partition_to_partition(ssize_t idx, ShenandoahFreeSetPartitionId orig_partition,\n+                                        ShenandoahFreeSetPartitionId new_partition, size_t available);\n+\n+  const char* partition_membership_name(ssize_t idx) const;\n@@ -113,0 +392,19 @@\n+  \/\/ Return the index of the next available region >= start_index, or maximum_regions if not found.\n+  inline ssize_t find_index_of_next_available_region(ShenandoahFreeSetPartitionId which_partition, ssize_t start_index) const;\n+\n+  \/\/ Return the index of the previous available region <= last_index, or -1 if not found.\n+  inline ssize_t find_index_of_previous_available_region(ShenandoahFreeSetPartitionId which_partition, ssize_t last_index) const;\n+\n+  \/\/ Return the index of the next available cluster of cluster_size regions >= start_index, or maximum_regions if not found.\n+  inline ssize_t find_index_of_next_available_cluster_of_regions(ShenandoahFreeSetPartitionId which_partition,\n+                                                                 ssize_t start_index, size_t cluster_size) const;\n+\n+  \/\/ Return the index of the previous available cluster of cluster_size regions <= last_index, or -1 if not found.\n+  inline ssize_t find_index_of_previous_available_cluster_of_regions(ShenandoahFreeSetPartitionId which_partition,\n+                                                                     ssize_t last_index, size_t cluster_size) const;\n+\n+  inline bool in_free_set(ShenandoahFreeSetPartitionId which_partition, ssize_t idx) const {\n+    return _membership[which_partition].is_set(idx);\n+  }\n+\n+#ifdef ASSERT\n@@ -115,1 +413,1 @@\n-  inline ShenandoahFreeSetPartitionId membership(size_t idx) const;\n+  inline ShenandoahFreeSetPartitionId membership(ssize_t idx) const;\n@@ -119,1 +417,2 @@\n-  inline bool partition_id_matches(size_t idx, ShenandoahFreeSetPartitionId which_partition) const;\n+  inline bool partition_id_matches(ssize_t idx, ShenandoahFreeSetPartitionId which_partition) const;\n+#endif\n@@ -132,4 +431,4 @@\n-  inline size_t leftmost(ShenandoahFreeSetPartitionId which_partition) const;\n-  inline size_t rightmost(ShenandoahFreeSetPartitionId which_partition) const;\n-  size_t leftmost_empty(ShenandoahFreeSetPartitionId which_partition);\n-  size_t rightmost_empty(ShenandoahFreeSetPartitionId which_partition);\n+  inline ssize_t leftmost(ShenandoahFreeSetPartitionId which_partition) const;\n+  inline ssize_t rightmost(ShenandoahFreeSetPartitionId which_partition) const;\n+  ssize_t leftmost_empty(ShenandoahFreeSetPartitionId which_partition);\n+  ssize_t rightmost_empty(ShenandoahFreeSetPartitionId which_partition);\n@@ -161,2 +460,0 @@\n-  inline size_t max() const { return _max; }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":321,"deletions":24,"binary":false,"changes":345,"status":"modified"},{"patch":"@@ -165,8 +165,0 @@\n-  product(bool, ShenandoahPackEvacTightly, false, EXPERIMENTAL,             \\\n-          \"When rebuilding the free set, allow the collector reserve \"      \\\n-          \"to include regions that are not entirely empty and do not \"      \\\n-          \"automatically retire regions within which an attempted \"         \\\n-          \"allocation has failed.  Setting this to true has been observed \" \\\n-          \"to increase concurrent evacuation times by up to 50% on certain \"\\\n-          \"workloads.\")                                                     \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"}]}