{"files":[{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n+\n+#include \"utilities\/ostream.hpp\"\n+\n+#include \"utilities\/vmassert_uninstall.hpp\"\n+#include <iostream>\n+#include \"utilities\/vmassert_reinstall.hpp\"\n+\n+#include \"unittest.hpp\"\n+\n+#define SMALL_BITMAP_SIZE  128\n+#define LARGE_BITMAP_SIZE 4096\n+\n+class ShenandoahSimpleBitMapTest: public ::testing::Test {\n+protected:\n+  ShenandoahSimpleBitMap bm_small(SMALL_BITMAP_SIZE);\n+  ShenandoahSimpleBitMap bm_large(LARGE_BITMAP_SIZE);\n+};\n+\n+class BasicShenandoahSimpleBitMapTest: public ShenandoahSimpleBitMapTest {\n+protected:\n+  BasicShenandoahSimpleBitMapTest() {\n+    \/\/ Initial state of each bitmap is all bits are clear.  Confirm this:\n+    ASSERT_EQ(bm_small.number_of_bits(), SMALL_BITMAP_SIZE);\n+    ASSERT_EQ(bm_large.number_of_bits(), LARGE_BITMAP_SIZE);\n+\n+    \/\/ Check that is_set(idx) for every possible idx\n+    for (ssize_t i = 0; i < SMALL_BITMAP_SIZE; i++) {\n+      bool is_set = bm_small.is_set(i);\n+      ASSERT_TRUE(!is_set);\n+    }\n+\n+    for (ssize_t i = 0; i < LARGE_BITMAP_SIZE; i++) {\n+      bool is_set = bm_large.is_set(i);\n+      ASSERT_TRUE(!is_set);\n+    }\n+\n+    \/\/ Check that bits_at(array_idx) is zero for every valid array_idx value\n+    size_t alignment = bm_small.alignment();\n+    size_t small_words = SMALL_BITMAP_SIZE \/ alignment;\n+    size_t large_words = LARGE_BITMAP_SIZE \/ alignment;\n+    for (ssize_t i = 0; i < small_words; i += alignment) {\n+      size_t bits = bm_small.bits_at(i);\n+      ASSERT_EQ(bits, (size_t) 0);\n+    }\n+\n+    for (ssize_t i = 0; i < large_words; i += alignment) {\n+      size_t bits = bm_large.bits_at(i);\n+      ASSERT_EQ(bits, (size_t) 0);\n+    }\n+\n+    \/\/ Confirm that find_next_set_bit(idx) returns _num_bits and find_next_set_bit(idx, boundary_idx) returns boundary_idx\n+    \/\/  for all legal values of idx\n+    for (ssize_t i = 0; i < SMALL_BITMAP_SIZE; i++) {\n+      ssize_t result = bm_small.find_next_set_bit(i);\n+      \/\/ Expect number_of_bits result since set bit should not be found.\n+      ASSERT_EQ(result, SMALL_BITMAP_SIZE);\n+    }\n+\n+    for (ssize_t i = LARGE_BITMAP_SIZE \/ 4; i < 3 * LARGE_BITMAP_SIZE\/ 4; i++) {\n+      ssize_t result = bm_large.find_next_set_bit(i, 3 * LARGE_BITMAP_SIZE \/ 4);\n+      \/\/ Expect number_of_bits result since set bit should not be found.\n+      ASSERT_EQ(result, LARGE_BITMAP_SIZE);\n+    }\n+\n+    for (ssize_t i = 0; i < SMALL_BITMAP_SIZE; i++) {\n+      ssize_t result = bm_small.find_next_set_bit(i);\n+      \/\/ Expect number_of_bits result since set bit should not be found.\n+      ASSERT_EQ(result, SMALL_BITMAP_SIZE);\n+    }\n+\n+\n+\n+\n+    \/\/ Confirm that find_prev_set_bit(idx) returns -1 and find_prev_set_bit(idx, boundary_idx) returns boundary idx\n+    \/\/  for all legal values of idx\n+\n+    \/\/ Confirm that find_next_consecutive_bits(1..8, idx, boundary_idx) returns boundary_idx for all legal values of idx\n+\n+    \/\/ Confirm that find_next_consecutive_bits(1..8, idx) returns _num_bits for all legal values of idx\n+\n+    \/\/ Confirm that find_prev_consecutive_bits(1..8, idx, boundary_idx) returns boundary_idx for all legal values of idx\n+\n+    \/\/ Confirm that find_prev_consecutive_bits(1..8, idx) returns -1 for all legal values of idx\n+    \n+    \/\/ Execute clear_all(), then set bits 8, 31, 63, 68, 127\n+    \/\/ Run the same tests\n+\n+\n+    \/\/ clear_bits 31 and 68 and run the same tests\n+\n+    \/\/ Execute clear_all, set two bits out of every 32 bits\n+    \/\/ Run the same tests\n+\n+    \/\/ Execute clear_all, set 3 bits out of every 32 bits\n+    \/\/ Run the same tests\n+\n+    \/\/ Execute clear_all, set 7 bits out of every 32 bits\n+    \/\/ Run the same tests\n+\n+    \/\/ Selectively clear every other bit at the 64-bit offsets\n+    \/\/ Run the same tests\n+\n+    \/\/ Execute clear_all, set 8 bits out of every 32 bits\n+    \/\/ Run the same tests\n+\n+    \/\/ Clear all 8 bits at each 64-bit offset\n+    \/\/ Run the same tests\n+\n+  }\n+};\n+\n+TEST_VM_F(BasicShenandoahSimpleBitMapTest, maximum_test) {\n+  EXPECT_EQ(seq.maximum(), 100);\n+}\n+\n+TEST_VM_F(BasicShenandoahNumberSeqTest, minimum_test) {\n+  EXPECT_EQ(0, seq.percentile(0));\n+}\n+\n+TEST_VM_F(BasicShenandoahNumberSeqTest, percentile_test) {\n+  EXPECT_NEAR(0, seq.percentile(10), err);\n+  EXPECT_NEAR(1, seq.percentile(20), err);\n+  EXPECT_NEAR(10, seq.percentile(30), err);\n+  EXPECT_NEAR(100, seq.percentile(40), err);\n+  EXPECT_NEAR(100, seq.percentile(50), err);\n+  EXPECT_NEAR(100, seq.percentile(75), err);\n+  EXPECT_NEAR(100, seq.percentile(90), err);\n+  EXPECT_NEAR(100, seq.percentile(100), err);\n+}\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahSimpleBitMap.cpp","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"}]}