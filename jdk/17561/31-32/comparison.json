{"files":[{"patch":"@@ -49,5 +49,5 @@\n-  size_t element_bits = _bitmap[array_idx];\n-  size_t bit_number = start_idx & right_n_bits(LogBitsPerWord);\n-  size_t the_bit = nth_bit(bit_number);\n-  size_t omit_mask = right_n_bits(bit_number);\n-  size_t mask = right_n_bits(BitsPerWord) & ~omit_mask;\n+  uintx element_bits = _bitmap[array_idx];\n+  uintx bit_number = start_idx & right_n_bits(LogBitsPerWord);\n+  uintx the_bit = nth_bit(bit_number);\n+  uintx omit_mask = right_n_bits(bit_number);\n+  uintx mask = right_n_bits(BitsPerWord) & ~omit_mask;\n@@ -59,5 +59,4 @@\n-    size_t counted_ones;\n-    for (counted_ones = 0; element_bits & the_bit; counted_ones++) {\n-      the_bit <<= 1;\n-    }\n-    return counted_ones;\n+    \/\/ Return number of consecutive ones starting with the_bit and including more significant bits.\n+    uintx aligned = element_bits >> bit_number;\n+    uintx complement = ~aligned;;\n+    return count_leading_zeros<uintx>(complement);\n@@ -70,3 +69,3 @@\n-  size_t element_bits = _bitmap[array_idx];\n-  size_t bit_number = last_idx & right_n_bits(LogBitsPerWord);\n-  size_t the_bit = nth_bit(bit_number);\n+  uintx element_bits = _bitmap[array_idx];\n+  uintx bit_number = last_idx & right_n_bits(LogBitsPerWord);\n+  uintx the_bit = nth_bit(bit_number);\n@@ -75,1 +74,1 @@\n-  size_t mask = right_n_bits(bit_number + 1);\n+  uintx mask = right_n_bits(bit_number + 1);\n@@ -80,5 +79,4 @@\n-    size_t counted_ones;\n-    for (counted_ones = 0; element_bits & the_bit; counted_ones++) {\n-      the_bit >>= 1;\n-    }\n-    return counted_ones;\n+    \/\/ Return number of consecutive ones starting with the_bit and including less significant bits\n+    uintx aligned = element_bits << (BitsPerWord - (bit_number + 1));\n+    uintx complement = ~aligned;\n+    return count_leading_zeros<uintx>(complement);\n@@ -93,10 +91,11 @@\n-  size_t bit_number = start_idx & right_n_bits(LogBitsPerWord);\n-  size_t the_bit = nth_bit(bit_number);\n-  size_t element_bits = _bitmap[array_idx];\n-  if ((ssize_t) (bit_number + count <= BitsPerWord)) {\n-    \/\/ All relevant bits reside within this array element\n-    size_t relevant_bits = bit_number + count;\n-    size_t overreach_mask = right_n_bits(relevant_bits);\n-    size_t exclude_mask = right_n_bits(bit_number);\n-    size_t exact_mask = overreach_mask & ~exclude_mask;\n-    return (element_bits & exact_mask) == exact_mask? true: false;\n+  uintx bit_number = start_idx & right_n_bits(LogBitsPerWord);\n+  uintx element_bits = _bitmap[array_idx];\n+  uintx bits_to_examine  = BitsPerWord - bit_number;\n+  element_bits >>= bit_number;\n+  uintx complement = ~element_bits;\n+  uintx trailing_ones = count_trailing_zeros<uintx>(complement);\n+  if (trailing_ones >= (uintx) count) {\n+    return true;\n+  } else if (trailing_ones == bits_to_examine) {\n+    \/\/ Tail recursion\n+    return is_forward_consecutive_ones(start_idx + bits_to_examine, count - bits_to_examine);\n@@ -104,10 +103,1 @@\n-    \/\/ Need to exactly match all relevant bits of this array element, plus relevant bits of following array elements\n-    size_t overreach_mask = right_n_bits(BitsPerWord);\n-    size_t exclude_mask = right_n_bits(bit_number);\n-    size_t exact_mask = overreach_mask & ~exclude_mask;\n-    if ((element_bits & exact_mask) == exact_mask) {\n-      size_t matched_bits = BitsPerWord - bit_number;\n-      return is_forward_consecutive_ones(start_idx + matched_bits, count - matched_bits);\n-    } else {\n-      return false;\n-    }\n+    return false;\n@@ -121,9 +111,11 @@\n-  size_t bit_number = last_idx & right_n_bits(LogBitsPerWord);\n-  size_t the_bit = nth_bit(bit_number);\n-  size_t element_bits = _bitmap[array_idx];\n-  if ((ssize_t) (bit_number + 1) >= count) {\n-    \/\/ All relevant bits reside within this array element\n-    size_t overreach_mask = right_n_bits(bit_number + 1);\n-    size_t exclude_mask = right_n_bits(bit_number + 1 - count);\n-    size_t exact_mask = overreach_mask & ~exclude_mask;\n-    return (element_bits & exact_mask) == exact_mask? true: false;\n+  uintx bit_number = last_idx & right_n_bits(LogBitsPerWord);\n+  uintx element_bits = _bitmap[array_idx];\n+  uintx bits_to_examine = bit_number + 1;\n+  element_bits <<= (BitsPerWord - bits_to_examine);\n+  uintx complement = ~element_bits;\n+  uintx leading_ones = count_leading_zeros<uintx>(complement);\n+  if (leading_ones >= (uintx) count) {\n+    return true;\n+  } else if (leading_ones == bits_to_examine) {\n+    \/\/ Tail recursion\n+    return is_backward_consecutive_ones(last_idx - leading_ones, count - leading_ones);\n@@ -131,8 +123,1 @@\n-    \/\/ Need to exactly match all relevant bits of this array element, plus relevant bits of following array elements\n-    size_t exact_mask = right_n_bits(bit_number + 1);\n-    if ((element_bits & exact_mask) == exact_mask) {\n-      size_t matched_bits = bit_number + 1;\n-      return is_backward_consecutive_ones(last_idx - matched_bits, count - matched_bits);\n-    } else {\n-      return false;\n-    }\n+    return false;\n@@ -147,3 +132,6 @@\n-  size_t array_idx = start_idx >> LogBitsPerWord;\n-  size_t bit_number = start_idx & right_n_bits(LogBitsPerWord);\n-  size_t element_bits = _bitmap[array_idx];\n+  if (start_idx > start_boundary) {\n+    return boundary_idx;\n+  }\n+  uintx array_idx = start_idx >> LogBitsPerWord;\n+  uintx bit_number = start_idx & right_n_bits(LogBitsPerWord);\n+  uintx element_bits = _bitmap[array_idx];\n@@ -151,1 +139,1 @@\n-    size_t mask_out = right_n_bits(bit_number);\n+    uintx mask_out = right_n_bits(bit_number);\n@@ -155,1 +143,1 @@\n-  while (start_idx <= start_boundary) {\n+  while (true) {\n@@ -159,0 +147,4 @@\n+      if (start_idx > start_boundary) {\n+        \/\/ No match found.\n+        return boundary_idx;\n+      }\n@@ -165,0 +157,4 @@\n+      \/\/ There is at least one non-zero bit within the masked element_bits.  Find it.\n+      uintx next_set_bit = count_trailing_zeros<uintx>(element_bits);\n+      uintx next_start_candidate_1 = (array_idx << LogBitsPerWord) + next_set_bit;\n+\n@@ -167,1 +163,7 @@\n-      start_idx += num_bits - trailing_ones;\n+      uintx next_start_candidate_2 = start_idx + num_bits - trailing_ones;\n+\n+      start_idx = MAX2(next_start_candidate_1, next_start_candidate_2);\n+      if (start_idx > start_boundary) {\n+        \/\/ No match found.\n+        return boundary_idx;\n+      }\n@@ -177,2 +179,0 @@\n-  \/\/ No match found.\n-  return boundary_idx;\n@@ -187,3 +187,7 @@\n-  ssize_t array_idx = last_idx >> LogBitsPerWord;\n-  size_t bit_number = last_idx & right_n_bits(LogBitsPerWord);\n-  size_t element_bits = _bitmap[array_idx];\n+  if (last_idx < last_boundary) {\n+    return boundary_idx;\n+  }\n+\n+  size_t array_idx = last_idx >> LogBitsPerWord;\n+  uintx bit_number = last_idx & right_n_bits(LogBitsPerWord);\n+  uintx element_bits = _bitmap[array_idx];\n@@ -191,1 +195,1 @@\n-    size_t mask_in = right_n_bits(bit_number + 1);\n+    uintx mask_in = right_n_bits(bit_number + 1);\n@@ -194,1 +198,1 @@\n-  while (last_idx >= last_boundary) {\n+  while (true) {\n@@ -198,0 +202,4 @@\n+      if (last_idx < last_boundary) {\n+        \/\/ No match found.\n+        return boundary_idx;\n+      }\n@@ -204,0 +212,4 @@\n+      \/\/ There is at least one non-zero bit within the masked element_bits.  Find it.\n+      uintx next_set_bit = BitsPerWord - (1 + count_leading_zeros<uintx>(element_bits));\n+      uintx next_last_candidate_1 = (array_idx << LogBitsPerWord) + next_set_bit;\n+\n@@ -206,1 +218,7 @@\n-      last_idx -= num_bits - leading_ones;\n+      uintx next_last_candidate_2 = last_idx - (num_bits - leading_ones);\n+\n+      last_idx = MIN2(next_last_candidate_1, next_last_candidate_2);\n+      if (last_idx < last_boundary) {\n+        \/\/ No match found.\n+        return boundary_idx;\n+      }\n@@ -216,2 +234,0 @@\n-  \/\/ No match found.\n-  return boundary_idx;\n@@ -221,1 +237,1 @@\n-  printf(\"Mutator range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"], Collector range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"]\",\n+  log_info(gc)(\"Mutator range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"], Collector range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"]\",\n@@ -223,1 +239,1 @@\n-  printf(\"Empty Mutator range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT\n+  log_info(gc)(\"Empty Mutator range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT\n@@ -229,1 +245,1 @@\n-  printf(\"%6s: %18s %18s %18s\", \"index\", \"Mutator Bits\", \"Collector Bits\", \"NotFree Bits\");\n+  log_info(gc)(\"%6s: %18s %18s %18s\", \"index\", \"Mutator Bits\", \"Collector Bits\", \"NotFree Bits\");\n@@ -231,1 +247,1 @@\n-  printf(\"%6s: %10s %10s %10s\", \"index\", \"Mutator Bits\", \"Collector Bits\", \"NotFree Bits\");\n+  log_infl(gc)(\"%6s: %10s %10s %10s\", \"index\", \"Mutator Bits\", \"Collector Bits\", \"NotFree Bits\");\n@@ -251,4 +267,4 @@\n-  size_t mutator_bits = _membership[Mutator].bits_at(aligned_idx);\n-  size_t collector_bits = _membership[Collector].bits_at(aligned_idx);\n-  size_t free_bits = mutator_bits | collector_bits;\n-  size_t notfree_bits =  ~free_bits;\n+  uintx mutator_bits = _membership[Mutator].bits_at(aligned_idx);\n+  uintx collector_bits = _membership[Collector].bits_at(aligned_idx);\n+  uintx free_bits = mutator_bits | collector_bits;\n+  uintx notfree_bits =  ~free_bits;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":96,"deletions":80,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  size_t* const _bitmap;\n+  uintx* const _bitmap;\n@@ -54,1 +54,1 @@\n-      _bitmap(NEW_C_HEAP_ARRAY(size_t, _num_words, mtGC))\n+      _bitmap(NEW_C_HEAP_ARRAY(uintx, _num_words, mtGC))\n@@ -61,1 +61,1 @@\n-      FREE_C_HEAP_ARRAY(size_t, _bitmap);\n+      FREE_C_HEAP_ARRAY(uintx, _bitmap);\n@@ -100,1 +100,1 @@\n-  inline size_t bits_at(ssize_t idx) const {\n+  inline uintx bits_at(ssize_t idx) const {\n@@ -109,2 +109,2 @@\n-    size_t bit_number = idx & right_n_bits(LogBitsPerWord);\n-    size_t the_bit = nth_bit(bit_number);\n+    uintx bit_number = idx & right_n_bits(LogBitsPerWord);\n+    uintx the_bit = nth_bit(bit_number);\n@@ -118,2 +118,2 @@\n-    size_t bit_number = idx & right_n_bits(LogBitsPerWord);\n-    size_t the_bit = nth_bit(bit_number);\n+    uintx bit_number = idx & right_n_bits(LogBitsPerWord);\n+    uintx the_bit = nth_bit(bit_number);\n@@ -127,2 +127,2 @@\n-    size_t bit_number = idx & right_n_bits(LogBitsPerWord);\n-    size_t the_bit = nth_bit(bit_number);\n+    uintx bit_number = idx & right_n_bits(LogBitsPerWord);\n+    uintx the_bit = nth_bit(bit_number);\n@@ -455,4 +455,0 @@\n-#ifdef KELVIN_BAD_CODE\n-  void dump_bitmaps();\n-#endif\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":10,"deletions":14,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -36,2 +36,2 @@\n-    size_t bit_number = start_idx & right_n_bits(LogBitsPerWord);\n-    size_t element_bits = _bitmap[array_idx];\n+    uintx bit_number = start_idx & right_n_bits(LogBitsPerWord);\n+    uintx element_bits = _bitmap[array_idx];\n@@ -39,1 +39,1 @@\n-      size_t mask_out = right_n_bits(bit_number);\n+      uintx mask_out = right_n_bits(bit_number);\n@@ -43,13 +43,5 @@\n-      \/\/ The next set bit is here\n-      size_t the_bit = nth_bit(bit_number);\n-      while (bit_number < BitsPerWord) {\n-        if (element_bits & the_bit) {\n-          ssize_t candidate_result = (array_idx * BitsPerWord) + bit_number;\n-          if (candidate_result < boundary_idx) return candidate_result;\n-          else return boundary_idx;\n-        } else {\n-          the_bit <<= 1;\n-          bit_number++;\n-        }\n-      }\n-      assert(false, \"should not reach here\");\n+      \/\/ The next set bit is here.  Find first set bit >= bit_number;\n+      uintx aligned = element_bits >> bit_number;\n+      uintx first_set_bit = count_trailing_zeros<uintx>(aligned);\n+      ssize_t candidate_result = (array_idx * BitsPerWord) + bit_number + first_set_bit;\n+      return (candidate_result < boundary_idx)? candidate_result: boundary_idx;\n@@ -74,2 +66,2 @@\n-    size_t bit_number = last_idx & right_n_bits(LogBitsPerWord);\n-    size_t element_bits = _bitmap[array_idx];\n+    uintx bit_number = last_idx & right_n_bits(LogBitsPerWord);\n+    uintx element_bits = _bitmap[array_idx];\n@@ -77,1 +69,1 @@\n-      size_t mask_in = right_n_bits(bit_number + 1);\n+      uintx mask_in = right_n_bits(bit_number + 1);\n@@ -81,13 +73,5 @@\n-      \/\/ The prev set bit is here\n-      size_t the_bit = nth_bit(bit_number);\n-      for (ssize_t bit_iterator = bit_number; bit_iterator >= 0; bit_iterator--) {\n-        if (element_bits & the_bit) {\n-          ssize_t candidate_result = (array_idx * BitsPerWord) + bit_number;\n-          if (candidate_result > boundary_idx) return candidate_result;\n-          else return boundary_idx;\n-        } else {\n-          the_bit >>= 1;\n-          bit_number--;\n-        }\n-      }\n-      assert(false, \"should not reach here\");\n+      \/\/ The prev set bit is here.  Find the first set bit <= bit_number\n+      uintx aligned = element_bits << (BitsPerWord - (bit_number + 1));\n+      uintx first_set_bit = count_leading_zeros<uintx>(aligned);\n+      ssize_t candidate_result = array_idx * BitsPerWord + (bit_number - first_set_bit);\n+      return (candidate_result > boundary_idx)? candidate_result: boundary_idx;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.inline.hpp","additions":16,"deletions":32,"binary":false,"changes":48,"status":"modified"}]}