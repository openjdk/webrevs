{"files":[{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2016, 2019, Red Hat, Inc. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHFREESET_INLINE_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHFREESET_INLINE_HPP\n+\n+#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n+\n+inline ssize_t ShenandoahSimpleBitMap::find_next_set_bit(ssize_t start_idx, ssize_t boundary_idx) const {\n+  assert((start_idx >= 0) && (start_idx < _num_bits), \"precondition\");\n+  assert((boundary_idx > start_idx) && (boundary_idx <= _num_bits), \"precondition\");\n+  do {\n+    size_t array_idx = start_idx \/ _bits_per_array_element;\n+    size_t bit_number = start_idx % _bits_per_array_element;\n+    size_t element_bits = _bitmap[array_idx];\n+    if (bit_number > 0) {\n+      size_t mask_out = (((size_t) 0x01) << bit_number) - 1;\n+      element_bits &= ~mask_out;\n+    }\n+    if (element_bits) {\n+      \/\/ The next set bit is here\n+      size_t the_bit = ((size_t) 0x01) << bit_number;\n+      while (bit_number < _bits_per_array_element) {\n+        if (element_bits & the_bit) {\n+          ssize_t candidate_result = (array_idx * _bits_per_array_element) + bit_number;\n+          if (candidate_result < boundary_idx) return candidate_result;\n+          else return boundary_idx;\n+        } else {\n+          the_bit <<= 1;\n+          bit_number++;\n+        }\n+      }\n+      assert(false, \"should not reach here\");\n+    } else {\n+      \/\/ Next bit is not here.  Try the next array element\n+      start_idx += _bits_per_array_element - bit_number;\n+    }\n+  } while (start_idx < boundary_idx);\n+  return boundary_idx;\n+}\n+\n+inline ssize_t ShenandoahSimpleBitMap::find_next_set_bit(ssize_t start_idx) const {\n+  assert((start_idx >= 0) && (start_idx < _num_bits), \"precondition\");\n+  return find_next_set_bit(start_idx, _num_bits);\n+}\n+\n+inline ssize_t ShenandoahSimpleBitMap::find_prev_set_bit(ssize_t last_idx, ssize_t boundary_idx) const {\n+  assert((last_idx >= 0) && (last_idx < _num_bits), \"precondition\");\n+  assert((boundary_idx >= -1) && (boundary_idx < last_idx), \"precondition\");\n+  do {\n+    ssize_t array_idx = last_idx \/ _bits_per_array_element;\n+    size_t bit_number = last_idx % _bits_per_array_element;\n+    size_t element_bits = _bitmap[array_idx];\n+    if (bit_number < _bits_per_array_element - 1){\n+      size_t mask_in = (((size_t) 0x1) << (bit_number + 1)) - 1;\n+      element_bits &= mask_in;\n+    }\n+    if (element_bits) {\n+      \/\/ The prev set bit is here\n+      size_t the_bit = ((size_t) 0x01) << bit_number;\n+\n+      for (ssize_t bit_iterator = bit_number; bit_iterator >= 0; bit_iterator--) {\n+        if (element_bits & the_bit) {\n+          ssize_t candidate_result = (array_idx * _bits_per_array_element) + bit_number;\n+          if (candidate_result > boundary_idx) return candidate_result;\n+          else return boundary_idx;\n+        } else {\n+          the_bit >>= 1;\n+          bit_number--;\n+        }\n+      }\n+      assert(false, \"should not reach here\");\n+    } else {\n+      \/\/ Next bit is not here.  Try the previous array element\n+      last_idx -= (bit_number + 1);\n+    }\n+  } while (last_idx > boundary_idx);\n+  return boundary_idx;\n+}\n+\n+inline ssize_t ShenandoahSimpleBitMap::find_prev_set_bit(ssize_t last_idx) const {\n+  assert((last_idx >= 0) && (last_idx < _num_bits), \"precondition\");\n+  return find_prev_set_bit(last_idx, -1);\n+}\n+\n+inline ssize_t ShenandoahSimpleBitMap::find_next_consecutive_bits(size_t num_bits, ssize_t start_idx) const {\n+  assert((start_idx >= 0) && (start_idx < _num_bits), \"precondition\");\n+  return find_next_consecutive_bits(num_bits, start_idx, _num_bits);\n+}\n+\n+inline ssize_t ShenandoahSimpleBitMap::find_prev_consecutive_bits(size_t num_bits, ssize_t last_idx) const {\n+  assert((last_idx >= 0) && (last_idx < _num_bits), \"precondition\");\n+  return find_prev_consecutive_bits(num_bits, last_idx, (ssize_t) -1);\n+}\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHFREESET_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.inline.hpp","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"}]}