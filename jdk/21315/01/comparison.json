{"files":[{"patch":"@@ -768,4 +768,5 @@\n-            infinity.equals(other.infinity) &&\n-            NaN.equals(other.NaN) &&\n-            getCurrencySymbol().equals(other.getCurrencySymbol()) && \/\/ possible currency init occurs here\n-            intlCurrencySymbol.equals(other.intlCurrencySymbol) &&\n+            \/\/ Nullable instance variables\n+            Objects.equals(infinity, other.infinity) &&\n+            Objects.equals(NaN, other.NaN) &&\n+            Objects.equals(getCurrencySymbol(), other.getCurrencySymbol()) && \/\/ possible currency init occurs here\n+            Objects.equals(intlCurrencySymbol, other.intlCurrencySymbol) &&\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormatSymbols.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8341445\n+ * @summary Ensure that DFS with null instance variables do not throw\n+ *          NPE when compared against each other. Also provides a white list\n+ *          that forces new setter methods to be explicitly added if throwing NPE.\n+ * @run junit DFSymbolsNullEqualityTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.text.DecimalFormatSymbols;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+\n+public class DFSymbolsNullEqualityTest {\n+\n+    \/\/ This is a white list of DFS setter methods that are allowed to throw NPE\n+    private static final List<Method> NPE_SETTERS;\n+    private static final List<Method> NON_NPE_SETTERS;\n+\n+    static {\n+        try {\n+            NPE_SETTERS = List.of(\n+                    \/\/ New NPE throwing setters MUST be added here\n+                    DecimalFormatSymbols.class.getMethod(\"setCurrency\", Currency.class),\n+                    DecimalFormatSymbols.class.getMethod(\"setExponentSeparator\", String.class)\n+            );\n+            NON_NPE_SETTERS = Arrays.stream(DecimalFormatSymbols.class.getDeclaredMethods())\n+                    .filter(m -> Modifier.isPublic(m.getModifiers()))\n+                    .filter(m -> m.getName().startsWith(\"set\"))\n+                    .filter(m -> Stream.of(m.getParameterTypes()).noneMatch(Class::isPrimitive))\n+                    .filter(m -> NPE_SETTERS.stream().noneMatch(x -> x.equals(m))).toList();\n+        } catch (NoSuchMethodException e) {\n+            throw new RuntimeException(\"Unexpected test init failure\");\n+        }\n+    }\n+\n+    \/\/ If a future (NPE) setter method were to be added without being whitelisted,\n+    \/\/ this test would fail. This ensures that the implications of adding a new\n+    \/\/ setter method are fully understood in relation to the equals method\n+    @Test\n+    public void setterThrowsNPETest() {\n+        var dfs = new DecimalFormatSymbols();\n+        nonNPEThrowingSetters().forEach(m -> {\n+            try {\n+                m.invoke(dfs, (Object) null);\n+            } catch (InvocationTargetException e) {\n+                if (e.getCause() instanceof NullPointerException) {\n+                    throw new RuntimeException(String.format(\n+                            \"DFS method: %s threw NPE, but was not added to whitelist\", m));\n+                } else {\n+                    throw new RuntimeException(String.format(\n+                            \"Unexpected exception: %s thrown for method: %s\", e.getCause(), m));\n+                }\n+            } catch (IllegalAccessException e) {\n+                throw new RuntimeException(String.format(\n+                        \"Test init failed, could not access method: %s\", m));\n+            }\n+        });\n+    }\n+\n+    \/\/ Two DFS instances with null(able) variables should be able to be\n+    \/\/ equality checked without throwing NPE\n+    @ParameterizedTest\n+    @MethodSource(\"nonNPEThrowingSetters\")\n+    public void isEqualTest(Method m)\n+            throws InvocationTargetException, IllegalAccessException {\n+        var dfs = new DecimalFormatSymbols();\n+        var other = new DecimalFormatSymbols();\n+        m.invoke(dfs, (Object) null);\n+        m.invoke(other, (Object) null);\n+        assertEquals(dfs, other,\n+                \"dfs and other should have compared as equal\");\n+    }\n+\n+    \/\/ Same as previous, but don't compare equal\n+    @ParameterizedTest\n+    @MethodSource(\"nonNPEThrowingSetters\")\n+    public void nonEqualTest(Method m)\n+            throws InvocationTargetException, IllegalAccessException {\n+        var dfs = new DecimalFormatSymbols();\n+        var other = new DecimalFormatSymbols();\n+        \/\/ Use some arbitrary valid value of the expected param type\n+        var param = m.getParameterTypes()[0];\n+        if (param == String.class) {\n+            m.invoke(other, \"foo\");\n+        } else if (param == Currency.class) {\n+            m.invoke(other, Currency.getInstance(Locale.US));\n+        } else {\n+            throw new RuntimeException(\n+                    String.format(\"Unexpected param type: %s in method: %s.\", param, m));\n+        }\n+        m.invoke(dfs, (Object) null);\n+        assertNotEquals(dfs, other,\n+                \"dfs and other should not have compared as equal\");\n+    }\n+\n+    \/\/ All public setter methods that do not throw NPE and do not take primitives\n+    private static List<Method> nonNPEThrowingSetters() {\n+        return NON_NPE_SETTERS;\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/DFSymbolsNullEqualityTest.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"}]}