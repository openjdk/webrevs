{"files":[{"patch":"@@ -30,0 +30,3 @@\n+import static sun.font.FontUtilities.isDefaultIgnorable;\n+import static sun.font.FontUtilities.isIgnorableWhitespace;\n+\n@@ -50,1 +53,1 @@\n-        int glyph = charToGlyph(ch);\n+        int glyph = charToGlyph(ch, false);\n@@ -55,1 +58,1 @@\n-        int glyph = charToGlyph(cp);\n+        int glyph = charToGlyph(cp, false);\n@@ -92,1 +95,5 @@\n-        int glyph = cache.get(unicode);\n+        return charToGlyph(unicode, false);\n+    }\n+\n+    private int charToGlyph(char unicode, boolean raw) {\n+        int glyph = cache.get(unicode, raw);\n@@ -95,8 +102,4 @@\n-        if (FontUtilities.isDefaultIgnorable(unicode) || isIgnorableWhitespace(unicode)) {\n-            glyph = INVISIBLE_GLYPH_ID;\n-        } else {\n-            final char[] unicodeArray = new char[] { unicode };\n-            final int[] glyphArray = new int[1];\n-            nativeCharsToGlyphs(fFont.getNativeFontPtr(), 1, unicodeArray, glyphArray);\n-            glyph = glyphArray[0];\n-        }\n+        final char[] unicodeArray = new char[] { unicode };\n+        final int[] glyphArray = new int[1];\n+        nativeCharsToGlyphs(fFont.getNativeFontPtr(), 1, unicodeArray, glyphArray);\n+        glyph = glyphArray[0];\n@@ -110,0 +113,8 @@\n+        return charToGlyph(unicode, false);\n+    }\n+\n+    public synchronized int charToGlyphRaw(int unicode) {\n+        return charToGlyph(unicode, true);\n+    }\n+\n+    private int charToGlyph(int unicode, boolean raw) {\n@@ -116,1 +127,1 @@\n-            charsToGlyphs(2, surrogates, glyphs);\n+            cache.get(2, surrogates, glyphs, raw);\n@@ -119,1 +130,1 @@\n-             return charToGlyph((char)unicode);\n+             return charToGlyph((char) unicode, raw);\n@@ -124,1 +135,1 @@\n-        cache.get(count, unicodes, glyphs);\n+        cache.get(count, unicodes, glyphs, false);\n@@ -129,1 +140,1 @@\n-            glyphs[i] = charToGlyph(unicodes[i]);\n+            glyphs[i] = charToGlyph(unicodes[i], false);\n@@ -133,6 +144,0 @@\n-    \/\/ Matches behavior in e.g. CMap.getControlCodeGlyph(int, boolean)\n-    \/\/ and RasterPrinterJob.removeControlChars(String)\n-    private static boolean isIgnorableWhitespace(int code) {\n-        return code == 0x0009 || code == 0x000a || code == 0x000d;\n-    }\n-\n@@ -162,1 +167,5 @@\n-        public synchronized int get(final int index) {\n+        public synchronized int get(final int index, final boolean raw) {\n+            if (isIgnorableWhitespace(index) || (isDefaultIgnorable(index) && !raw)) {\n+                return INVISIBLE_GLYPH_ID;\n+            }\n+\n@@ -233,1 +242,1 @@\n-        public synchronized void get(int count, char[] indices, int[] values)\n+        public synchronized void get(int count, char[] indices, int[] values, boolean raw)\n@@ -255,1 +264,1 @@\n-                final int value = get(code);\n+                final int value = get(code, raw);\n@@ -262,3 +271,0 @@\n-                } else if (FontUtilities.isDefaultIgnorable(code) || isIgnorableWhitespace(code)) {\n-                    values[i] = INVISIBLE_GLYPH_ID;\n-                    put(code, INVISIBLE_GLYPH_ID);\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/font\/CCharToGlyphMapper.java","additions":33,"deletions":27,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -549,3 +549,2 @@\n-            int controlGlyph = getControlCodeGlyph(charCode, true);\n-            if (controlGlyph >= 0) {\n-                return (char)controlGlyph;\n+            if (isSurrogate(charCode)) {\n+                return 0;\n@@ -636,7 +635,0 @@\n-                if (charCode < 0x0010) {\n-                    switch (charCode) {\n-                    case 0x0009:\n-                    case 0x000a:\n-                    case 0x000d: return CharToGlyphMapper.INVISIBLE_GLYPH_ID;\n-                    }\n-                }\n@@ -781,4 +773,2 @@\n-            final int origCharCode = charCode;\n-            int controlGlyph = getControlCodeGlyph(charCode, true);\n-            if (controlGlyph >= 0) {\n-                return (char)controlGlyph;\n+            if (isSurrogate(charCode)) {\n+                return 0;\n@@ -861,5 +851,3 @@\n-            final int origCharCode = charCode;\n-            int controlGlyph = getControlCodeGlyph(charCode, true);\n-            if (controlGlyph >= 0) {\n-                return (char)controlGlyph;\n-            }\n+             if (isSurrogate(charCode)) {\n+                 return 0;\n+             }\n@@ -1023,5 +1011,0 @@\n-            final int origCharCode = charCode;\n-            int controlGlyph = getControlCodeGlyph(charCode, false);\n-            if (controlGlyph >= 0) {\n-                return (char)controlGlyph;\n-            }\n@@ -1063,11 +1046,2 @@\n-    final int getControlCodeGlyph(int charCode, boolean noSurrogates) {\n-        if (charCode < 0x0010) {\n-            switch (charCode) {\n-            case 0x0009:\n-            case 0x000a:\n-            case 0x000d: return CharToGlyphMapper.INVISIBLE_GLYPH_ID;\n-            }\n-         } else if (noSurrogates && charCode >= 0xFFFF) {\n-            return 0;\n-        }\n-        return -1;\n+    private static boolean isSurrogate(int charCode) {\n+        return charCode >= 0xFFFF;\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/CMap.java","additions":9,"deletions":35,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,0 +89,7 @@\n+    public int charToVariationGlyphRaw(int unicode, int variationSelector) {\n+        \/\/ Override this if variation selector is supported.\n+        return charToGlyphRaw(unicode);\n+    }\n+\n+    public abstract int charToGlyphRaw(int unicode);\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/CharToGlyphMapper.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,3 @@\n+import static sun.font.FontUtilities.isDefaultIgnorable;\n+import static sun.font.FontUtilities.isIgnorableWhitespace;\n+\n@@ -54,1 +57,0 @@\n-\n@@ -99,1 +101,1 @@\n-            return;     \/\/ don't cache surrogates\n+            return; \/\/ don't cache surrogates\n@@ -120,2 +122,8 @@\n-    private int convertToGlyph(int unicode) {\n-\n+    private int getGlyph(int unicode, boolean raw) {\n+        if (isIgnorableWhitespace(unicode) || (isDefaultIgnorable(unicode) && !raw)) {\n+            return INVISIBLE_GLYPH_ID;\n+        }\n+        int glyphCode = getCachedGlyphCode(unicode);\n+        if (glyphCode != UNINITIALIZED_GLYPH) {\n+            return glyphCode;\n+        }\n@@ -125,1 +133,1 @@\n-                int glyphCode = mapper.charToGlyph(unicode);\n+                glyphCode = mapper.charToGlyphRaw(unicode);\n@@ -158,1 +166,4 @@\n-    public int charToGlyph(int unicode) {\n+    public int charToGlyphRaw(int unicode) {\n+        int glyphCode = getGlyph(unicode, true);\n+        return glyphCode;\n+    }\n@@ -160,4 +171,2 @@\n-        int glyphCode = getCachedGlyphCode(unicode);\n-        if (glyphCode == UNINITIALIZED_GLYPH) {\n-            glyphCode = convertToGlyph(unicode);\n-        }\n+    public int charToGlyph(int unicode) {\n+        int glyphCode = getGlyph(unicode, false);\n@@ -179,5 +188,1 @@\n-\n-        int glyphCode  = getCachedGlyphCode(unicode);\n-        if (glyphCode == UNINITIALIZED_GLYPH) {\n-            glyphCode = convertToGlyph(unicode);\n-        }\n+        int glyphCode = getGlyph(unicode, false);\n@@ -209,4 +214,1 @@\n-            int gc = glyphs[i] = getCachedGlyphCode(code);\n-            if (gc == UNINITIALIZED_GLYPH) {\n-                glyphs[i] = convertToGlyph(code);\n-            }\n+            glyphs[i] = getGlyph(code, false);\n@@ -246,4 +248,1 @@\n-                    int gc = glyphs[i] = getCachedGlyphCode(code);\n-                    if (gc == UNINITIALIZED_GLYPH) {\n-                        glyphs[i] = convertToGlyph(code);\n-                    }\n+                    glyphs[i] = getGlyph(code, false);\n@@ -256,4 +255,1 @@\n-            int gc = glyphs[i] = getCachedGlyphCode(code);\n-            if (gc == UNINITIALIZED_GLYPH) {\n-                glyphs[i] = convertToGlyph(code);\n-            }\n+            glyphs[i] = getGlyph(code, false);\n@@ -266,5 +262,1 @@\n-\n-            glyphs[i] = getCachedGlyphCode(code);\n-            if (glyphs[i] == UNINITIALIZED_GLYPH) {\n-                glyphs[i] = convertToGlyph(code);\n-            }\n+            glyphs[i] = getGlyph(code, false);\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/CompositeGlyphMapper.java","additions":25,"deletions":33,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -538,0 +538,8 @@\n+    public int charToGlyphRaw(int wchar) {\n+        return getMapper().charToGlyphRaw(wchar);\n+    }\n+\n+    public int charToVariationGlyphRaw(int wchar, int variationSelector) {\n+        return getMapper().charToVariationGlyphRaw(wchar, variationSelector);\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/Font2D.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -372,0 +372,14 @@\n+    \/**\n+     * Checks whether or not the specified codepoint is whitespace which is\n+     * ignorable at the shaping stage of text rendering. These ignorable\n+     * whitespace characters should be used prior to text shaping and\n+     * rendering to determine the position of the text, but are not themselves\n+     * rendered.\n+     *\n+     * @param ch the codepoint to check\n+     * @return whether the specified codepoint is ignorable whitespace\n+     *\/\n+    public static boolean isIgnorableWhitespace(int ch) {\n+        return ch == 0x0009 || ch == 0x000a || ch == 0x000d;\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/FontUtilities.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -341,1 +341,1 @@\n-        int glyphID = font2D.charToGlyph(unicode);\n+        int glyphID = font2D.charToGlyphRaw(unicode);\n@@ -357,1 +357,1 @@\n-        int glyphID = font2D.charToVariationGlyph(unicode, variation_selector);\n+        int glyphID = font2D.charToVariationGlyphRaw(unicode, variation_selector);\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/HBShaper.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+import static sun.font.FontUtilities.isDefaultIgnorable;\n+import static sun.font.FontUtilities.isIgnorableWhitespace;\n+\n@@ -60,2 +63,2 @@\n-    private char getGlyphFromCMAP(int charCode) {\n-        if (FontUtilities.isDefaultIgnorable(charCode)) {\n+    private char getGlyphFromCMAP(int charCode, boolean raw) {\n+        if (isIgnorableWhitespace(charCode) || (isDefaultIgnorable(charCode) && !raw)) {\n@@ -83,1 +86,1 @@\n-    private char getGlyphFromCMAP(int charCode, int variationSelector) {\n+    private char getGlyphFromCMAP(int charCode, int variationSelector, boolean raw) {\n@@ -85,1 +88,1 @@\n-            return getGlyphFromCMAP(charCode);\n+            return getGlyphFromCMAP(charCode, raw);\n@@ -87,1 +90,1 @@\n-        if (FontUtilities.isDefaultIgnorable(charCode)) {\n+        if (isIgnorableWhitespace(charCode) || (isDefaultIgnorable(charCode) && !raw)) {\n@@ -125,0 +128,11 @@\n+    public int charToGlyphRaw(int unicode) {\n+        int glyph = getGlyphFromCMAP(unicode, true);\n+        return glyph;\n+    }\n+\n+    @Override\n+    public int charToVariationGlyphRaw(int unicode, int variationSelector) {\n+        int glyph = getGlyphFromCMAP(unicode, variationSelector, true);\n+        return glyph;\n+    }\n+\n@@ -126,1 +140,1 @@\n-        int glyph = getGlyphFromCMAP(unicode);\n+        int glyph = getGlyphFromCMAP(unicode, false);\n@@ -131,1 +145,1 @@\n-        int glyph = getGlyphFromCMAP(unicode);\n+        int glyph = getGlyphFromCMAP(unicode, false);\n@@ -137,1 +151,1 @@\n-        int glyph = getGlyphFromCMAP(unicode, variationSelector);\n+        int glyph = getGlyphFromCMAP(unicode, variationSelector, false);\n@@ -143,1 +157,1 @@\n-            glyphs[i] = getGlyphFromCMAP(unicodes[i]);\n+            glyphs[i] = getGlyphFromCMAP(unicodes[i], false);\n@@ -161,1 +175,1 @@\n-                    glyphs[i] = getGlyphFromCMAP(code);\n+                    glyphs[i] = getGlyphFromCMAP(code, false);\n@@ -167,1 +181,1 @@\n-            glyphs[i] = getGlyphFromCMAP(code);\n+            glyphs[i] = getGlyphFromCMAP(code, false);\n@@ -194,1 +208,1 @@\n-            glyphs[i] = getGlyphFromCMAP(code);\n+            glyphs[i] = getGlyphFromCMAP(code, false);\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/TrueTypeGlyphMapper.java","additions":26,"deletions":12,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -34,0 +34,3 @@\n+import static sun.font.FontUtilities.isDefaultIgnorable;\n+import static sun.font.FontUtilities.isIgnorableWhitespace;\n+\n@@ -81,1 +84,1 @@\n-        if (FontUtilities.isDefaultIgnorable(ch) || isIgnorableWhitespace(ch)) {\n+        if (isIgnorableWhitespace(ch) || isDefaultIgnorable(ch)) { \/\/ raw = false\n@@ -93,0 +96,10 @@\n+        int glyph = charToGlyph(ch, false);\n+        return glyph;\n+    }\n+\n+    public int charToGlyphRaw(int ch) {\n+        int glyph = charToGlyph(ch, true);\n+        return glyph;\n+    }\n+\n+    private int charToGlyph(int ch, boolean raw) {\n@@ -96,1 +109,1 @@\n-            if (FontUtilities.isDefaultIgnorable(ch) || isIgnorableWhitespace(ch)) {\n+            if (isIgnorableWhitespace(ch) || (isDefaultIgnorable(ch) && !raw)) {\n@@ -108,7 +121,0 @@\n-    \/\/ Matches behavior in e.g. CMap.getControlCodeGlyph(int, boolean)\n-    \/\/ and RasterPrinterJob.removeControlChars(String)\n-    \/\/ and CCharToGlyphMapper.isIgnorableWhitespace(int)\n-    private static boolean isIgnorableWhitespace(int code) {\n-        return code == 0x0009 || code == 0x000a || code == 0x000d;\n-    }\n-\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/Type1GlyphMapper.java","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,0 +93,2 @@\n+import static sun.font.FontUtilities.isIgnorableWhitespace;\n+\n@@ -2485,1 +2487,1 @@\n-            if (c > '\\r' || c < '\\t' || c == '\\u000b' || c == '\\u000c')  {\n+            if (!isIgnorableWhitespace(c)) {\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/RasterPrinterJob.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -146,1 +146,1 @@\n-         (*env)->GetMethodID(env, tmpClass, \"charToGlyph\", \"(I)I\"));\n+         (*env)->GetMethodID(env, tmpClass, \"charToGlyphRaw\", \"(I)I\"));\n@@ -148,1 +148,1 @@\n-         (*env)->GetMethodID(env, tmpClass, \"charToVariationGlyph\", \"(II)I\"));\n+         (*env)->GetMethodID(env, tmpClass, \"charToVariationGlyphRaw\", \"(II)I\"));\n","filename":"src\/java.desktop\/share\/native\/libfontmanager\/sunFont.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,4 @@\n+    public int charToGlyphRaw(int unicode) {\n+        return charToGlyph(unicode);\n+    }\n+\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/NativeGlyphMapper.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8353230\n+ * @summary Regression test for TrueType font GSUB substitutions.\n+ *\/\n+\n+import java.awt.Font;\n+import java.awt.font.FontRenderContext;\n+import java.awt.font.GlyphVector;\n+import java.awt.font.TextAttribute;\n+import java.io.ByteArrayInputStream;\n+import java.util.Base64;\n+import java.util.Map;\n+\n+public class GlyphVectorGsubTest {\n+\n+    \/**\n+     * <p>Font created for this test which contains two GSUB substitutions: a\n+     * \"liga\" ligature for \"a\" + \"b\" which requires that the ligature support\n+     * be enabled, and a \"ccmp\" ligature for an emoji sequence which does not\n+     * require that ligatures be explicitly enabled.\n+     *\n+     * <p>The following FontForge Python script was used to generate this font:\n+     *\n+     * <pre>\n+     * import fontforge\n+     * import base64\n+     *\n+     * def draw(glyph, width, height):\n+     *   pen = glyph.glyphPen()\n+     *   pen.moveTo((100, 100))\n+     *   pen.lineTo((100, 100 + height))\n+     *   pen.lineTo((100 + width, 100 + height))\n+     *   pen.lineTo((100 + width, 100))\n+     *   pen.closePath()\n+     *   glyph.draw(pen)\n+     *   pen = None\n+     *\n+     * font = fontforge.font()\n+     * font.encoding = 'UnicodeFull'\n+     * font.design_size = 16\n+     * font.em = 2048\n+     * font.ascent = 1638\n+     * font.descent = 410\n+     * font.familyname = 'Test'\n+     * font.fontname = 'Test'\n+     * font.fullname = 'Test'\n+     * font.copyright = ''\n+     * font.autoWidth(0, 0, 2048)\n+     *\n+     * font.addLookup('ligatures', 'gsub_ligature', (), (('liga',(('latn',('dflt')),)),))\n+     * font.addLookupSubtable('ligatures', 'sub1')\n+     *\n+     * font.addLookup('sequences', 'gsub_ligature', (), (('ccmp',(('latn',('dflt')),)),))\n+     * font.addLookupSubtable('sequences', 'sub2')\n+     *\n+     * space = font.createChar(0x20)\n+     * space.width = 600\n+     *\n+     * # create glyphs: a, b, ab\n+     *\n+     * for char in list('ab'):\n+     *   glyph = font.createChar(ord(char))\n+     *   draw(glyph, 400, 100)\n+     *   glyph.width = 600\n+     *\n+     * ab = font.createChar(-1, 'ab')\n+     * ab.addPosSub('sub1', ('a', 'b'))\n+     * draw(ab, 400, 400)\n+     * ab.width = 600\n+     *\n+     * # create glyphs for \"woman\" emoji sequence\n+     *\n+     * components = []\n+     * woman = '\\U0001F471\\U0001F3FD\\u200D\\u2640\\uFE0F'\n+     * for char in list(woman):\n+     *   glyph = font.createChar(ord(char))\n+     *   draw(glyph, 400, 800)\n+     *   glyph.width = 600\n+     *   components.append(glyph.glyphname)\n+     *\n+     * del components[-1] # remove last\n+     * seq = font.createChar(-1, 'seq')\n+     * seq.addPosSub('sub2', components)\n+     * draw(seq, 400, 1200)\n+     * seq.width = 600\n+     *\n+     * # save font to file\n+     *\n+     * ttf = 'test.ttf'     # TrueType\n+     * t64 = 'test.ttf.txt' # TrueType Base64\n+     *\n+     * font.generate(ttf)\n+     *\n+     * with open(ttf, 'rb') as f1:\n+     *   encoded = base64.b64encode(f1.read())\n+     *   with open(t64, 'wb') as f2:\n+     *     f2.write(encoded)\n+     * <\/pre>\n+     *\/\n+    private static final String TTF_BYTES = \"AAEAAAAQAQAABAAARkZUTaomGsgAAAiUAAAAHEdERUYAQQAZAAAHtAAAACRHUE9T4BjvnAAACFwAAAA2R1NVQkbjQAkAAAfYAAAAhE9TLzKik\/GeAAABiAAAAGBjbWFwK+OB7AAAAgwAAAHWY3Z0IABEBREAAAPkAAAABGdhc3D\/\/wADAAAHrAAAAAhnbHlmyBUElgAABAQAAAG4aGVhZCnqeTIAAAEMAAAANmhoZWEIcgJdAAABRAAAACRobXR4CPwB1AAAAegAAAAibG9jYQKIAxYAAAPoAAAAHG1heHAAUQA5AAABaAAAACBuYW1lQcPFIwAABbwAAAGGcG9zdIAWZOAAAAdEAAAAaAABAAAAAQAA7g5Qb18PPPUACwgAAAAAAOQSF3AAAAAA5BIXcABEAAACZAVVAAAACAACAAAAAAAAAAEAAAVVAAAAuAJYAAAAAAJkAAEAAAAAAAAAAAAAAAAAAAAEAAEAAAANAAgAAgAAAAAAAgAAAAEAAQAAAEAALgAAAAAABAJYAZAABQAABTMFmQAAAR4FMwWZAAAD1wBmAhIAAAIABQkAAAAAAACAAAABAgBAAAgAAAAAAAAAUGZFZACAACD\/\/wZm\/mYAuAVVAAAAAAABAAAAAADIAAAAAAAgAAQCWABEAAAAAAJYAAACWAAAAGQAZABkAGQAZABkAGQAZABkAAAAAAAFAAAAAwAAACwAAAAEAAAAbAABAAAAAADQAAMAAQAAACwAAwAKAAAAbAAEAEAAAAAMAAgAAgAEACAAYiANJkD+D\/\/\/AAAAIABhIA0mQP4P\/\/\/\/4\/+j3\/nZxwH5AAEAAAAAAAAAAAAAAAAADAAAAAAAZAAAAAAAAAAHAAAAIAAAACAAAAADAAAAYQAAAGIAAAAEAAAgDQAAIA0AAAAGAAAmQAAAJkAAAAAHAAD+DwAA\/g8AAAAIAAHz\/QAB8\/0AAAAJAAH0cQAB9HEAAAAKAAABBgAAAQAAAAAAAAABAgAAAAIAAAAAAAAAAAAAAAAAAAABAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEQFEQAAACwALAAsACwAPgBQAGQAeACMAKAAtADIANwAAgBEAAACZAVVAAMABwAusQEALzyyBwQA7TKxBgXcPLIDAgDtMgCxAwAvPLIFBADtMrIHBgH8PLIBAgDtMjMRIRElIREhRAIg\/iQBmP5oBVX6q0QEzQAAAAIAZABkAfQAyAADAAcAADc1IRUhNSEVZAGQ\/nABkGRkZGRkAAIAZABkAfQAyAADAAcAADc1IRUhNSEVZAGQ\/nABkGRkZGRkAAIAZABkAfQDhAADAAcAADcRIREhESERZAGQ\/nABkGQDIPzgAyD84AACAGQAZAH0A4QAAwAHAAA3ESERIREhEWQBkP5wAZBkAyD84AMg\/OAAAgBkAGQB9AOEAAMABwAANxEhESERIRFkAZD+cAGQZAMg\/OADIPzgAAIAZABkAfQDhAADAAcAADcRIREhESERZAGQ\/nABkGQDIPzgAyD84AACAGQAZAH0A4QAAwAHAAA3ESERIREhEWQBkP5wAZBkAyD84AMg\/OAAAgBkAGQB9AH0AAMABwAANxEhESERIRFkAZD+cAGQZAGQ\/nABkP5wAAIAZABkAfQFFAADAAcAADcRIREhESERZAGQ\/nABkGQEsPtQBLD7UAAAAA4ArgABAAAAAAAAAAAAAgABAAAAAAABAAQADQABAAAAAAACAAcAIgABAAAAAAADAB8AagABAAAAAAAEAAQAlAABAAAAAAAFAA8AuQABAAAAAAAGAAQA0wADAAEECQAAAAAAAAADAAEECQABAAgAAwADAAEECQACAA4AEgADAAEECQADAD4AKgADAAEECQAEAAgAigADAAEECQAFAB4AmQADAAEECQAGAAgAyQAAAABUAGUAcwB0AABUZXN0AABSAGUAZwB1AGwAYQByAABSZWd1bGFyAABGAG8AbgB0AEYAbwByAGcAZQAgADIALgAwACAAOgAgAFQAZQBzAHQAIAA6ACAAMQAtADQALQAyADAAMgA1AABGb250Rm9yZ2UgMi4wIDogVGVzdCA6IDEtNC0yMDI1AABUAGUAcwB0AABUZXN0AABWAGUAcgBzAGkAbwBuACAAMAAwADEALgAwADAAMAAAVmVyc2lvbiAwMDEuMDAwAABUAGUAcwB0AABUZXN0AAAAAAIAAAAAAAD\/ZwBmAAAAAQAAAAAAAAAAAAAAAAAAAAAADQAAAAEAAgADAEQARQECAQMBBAEFAQYBBwEIB3VuaTIwMEQGZmVtYWxlB3VuaUZFMEYGdTFGM0ZEBnUxRjQ3MQJhYgNzZXEAAAAB\/\/8AAgABAAAADAAAABwAAAACAAIAAwAKAAEACwAMAAIABAAAAAIAAAABAAAACgAgADoAAWxhdG4ACAAEAAAAAP\/\/AAIAAAABAAJjY21wAA5saWdhABQAAAABAAAAAAABAAEAAgAGAA4ABAAAAAEAEAAEAAAAAQAkAAEAFgABAAgAAQAEAAwABAAJAAYABwABAAEACgABABIAAQAIAAEABAALAAIABQABAAEABAABAAAACgAeADQAAWxhdG4ACAAEAAAAAP\/\/AAEAAAABc2l6ZQAIAAQAAACgAAAAAAAAAAAAAAAAAAAAAQAAAADiAevnAAAAAOQSF3AAAAAA5BIXcA==\";\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        byte[] ttfBytes = Base64.getDecoder().decode(TTF_BYTES);\n+        ByteArrayInputStream ttfStream = new ByteArrayInputStream(ttfBytes);\n+        Font f1 = Font.createFont(Font.TRUETYPE_FONT, ttfStream).deriveFont(80f);\n+\n+        \/\/ Test emoji sequence, using \"ccmp\" feature and ZWJ (zero-width joiner):\n+        \/\/ - person with blonde hair\n+        \/\/ - emoji modifier fitzpatrick type 4\n+        \/\/ - zero-width joiner\n+        \/\/ - female sign\n+        \/\/ - variation selector 16\n+        \/\/ Does not require the use of the TextAttribute.LIGATURES_ON attribute.\n+        char[] text1 = \"\\ud83d\\udc71\\ud83c\\udffd\\u200d\\u2640\\ufe0f\".toCharArray();\n+        FontRenderContext frc = new FontRenderContext(null, true, true);\n+        GlyphVector gv1 = f1.layoutGlyphVector(frc, text1, 0, text1.length, 0);\n+        checkOneGlyph(gv1, text1, 12);\n+\n+        \/\/ Test regular ligature, using \"liga\" feature: \"ab\" -> replacement\n+        \/\/ Requires the use of the TextAttribute.LIGATURES_ON attribute.\n+        char[] text2 = \"ab\".toCharArray();\n+        Font f2 = f1.deriveFont(Map.of(TextAttribute.LIGATURES, TextAttribute.LIGATURES_ON));\n+        GlyphVector gv2 = f2.layoutGlyphVector(frc, text2, 0, text2.length, 0);\n+        checkOneGlyph(gv2, text2, 11);\n+    }\n+\n+    private static void checkOneGlyph(GlyphVector gv, char[] text, int expectedCode) {\n+        int glyphs = gv.getNumGlyphs();\n+        if (glyphs != 1) {\n+            throw new RuntimeException(\"Unexpected number of glyphs for text \" +\n+                new String(text) + \": \" + glyphs);\n+        }\n+        int code = gv.getGlyphCode(0);\n+        if (code != expectedCode) {\n+            throw new RuntimeException(\"Unexpected glyph code for text \" +\n+                new String(text) + \": \" + expectedCode + \" != \" + code);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/font\/GlyphVector\/GlyphVectorGsubTest.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"}]}