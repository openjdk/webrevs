{"files":[{"patch":"@@ -758,1 +758,1 @@\n-class G1ScanCollectionSetRegionClosure : public G1HeapRegionClosure {\n+class G1ScanCodeRootsClosure : public G1HeapRegionClosure {\n@@ -762,3 +762,0 @@\n-  G1GCPhaseTimes::GCParPhases _scan_phase;\n-  G1GCPhaseTimes::GCParPhases _code_roots_phase;\n-\n@@ -769,0 +766,52 @@\n+public:\n+  G1ScanCodeRootsClosure(G1RemSetScanState* scan_state,\n+                         G1ParScanThreadState* pss,\n+                         uint worker_id) :\n+    _pss(pss),\n+    _scan_state(scan_state),\n+    _worker_id(worker_id),\n+    _code_roots_scanned(0) { }\n+\n+  bool do_heap_region(G1HeapRegion* r) {\n+    \/\/ Scan the code root list attached to the current region\n+    G1ScanAndCountNMethodClosure cl(_pss->closures()->weak_nmethods());\n+    r->code_roots_do(&cl);\n+    _code_roots_scanned += cl.count();\n+    return false;\n+  }\n+\n+  size_t code_roots_scanned() const { return _code_roots_scanned; }\n+};\n+\n+void G1RemSet::scan_collection_set_code_roots(G1ParScanThreadState* pss,\n+                                              uint worker_id,\n+                                              G1GCPhaseTimes::GCParPhases coderoots_phase,\n+                                              G1GCPhaseTimes::GCParPhases objcopy_phase) {\n+  EventGCPhaseParallel event;\n+\n+  Tickspan code_root_scan_time;\n+  Tickspan code_root_trim_partially_time;\n+  G1EvacPhaseWithTrimTimeTracker timer(pss, code_root_scan_time, code_root_trim_partially_time);\n+\n+  G1GCPhaseTimes* p = _g1h->phase_times();\n+\n+  G1ScanCodeRootsClosure cl(_scan_state, pss, worker_id);\n+  \/\/ Code roots work distribution occurs inside the iteration method. So scan all collection\n+  \/\/ set regions for all threads.\n+  _g1h->collection_set_iterate_increment_from(&cl, worker_id);\n+\n+  p->record_or_add_time_secs(coderoots_phase, worker_id, code_root_scan_time.seconds());\n+  p->add_time_secs(objcopy_phase, worker_id, code_root_trim_partially_time.seconds());\n+\n+  p->record_or_add_thread_work_item(coderoots_phase, worker_id, cl.code_roots_scanned(), G1GCPhaseTimes::CodeRootsScannedNMethods);\n+\n+  event.commit(GCId::current(), worker_id, G1GCPhaseTimes::phase_name(coderoots_phase));\n+}\n+\n+class G1ScanOptionalRemSetRootsClosure : public G1HeapRegionClosure {\n+  G1ParScanThreadState* _pss;\n+\n+  uint _worker_id;\n+\n+  G1GCPhaseTimes::GCParPhases _scan_phase;\n+\n@@ -770,0 +819,1 @@\n+\n@@ -773,6 +823,0 @@\n-  Tickspan _code_root_scan_time;\n-  Tickspan _code_trim_partially_time;\n-\n-  Tickspan _rem_set_opt_root_scan_time;\n-  Tickspan _rem_set_opt_trim_partially_time;\n-\n@@ -789,2 +833,1 @@\n-  G1ScanCollectionSetRegionClosure(G1RemSetScanState* scan_state,\n-                                   G1ParScanThreadState* pss,\n+  G1ScanOptionalRemSetRootsClosure(G1ParScanThreadState* pss,\n@@ -792,2 +835,1 @@\n-                                   G1GCPhaseTimes::GCParPhases scan_phase,\n-                                   G1GCPhaseTimes::GCParPhases code_roots_phase) :\n+                                   G1GCPhaseTimes::GCParPhases scan_phase) :\n@@ -795,3 +837,0 @@\n-    _scan_state(scan_state),\n-    _scan_phase(scan_phase),\n-    _code_roots_phase(code_roots_phase),\n@@ -799,1 +838,1 @@\n-    _code_roots_scanned(0),\n+    _scan_phase(scan_phase),\n@@ -802,5 +841,1 @@\n-    _opt_refs_memory_used(0),\n-    _code_root_scan_time(),\n-    _code_trim_partially_time(),\n-    _rem_set_opt_root_scan_time(),\n-    _rem_set_opt_trim_partially_time() { }\n+    _opt_refs_memory_used(0) { }\n@@ -808,3 +843,1 @@\n-  bool do_heap_region(G1HeapRegion* r) {\n-    \/\/ The individual references for the optional remembered set are per-worker, so we\n-    \/\/ always need to scan them.\n+  bool do_heap_region(G1HeapRegion* r) override {\n@@ -812,2 +845,0 @@\n-      EventGCPhaseParallel event;\n-      G1EvacPhaseWithTrimTimeTracker timer(_pss, _rem_set_opt_root_scan_time, _rem_set_opt_trim_partially_time);\n@@ -815,16 +846,0 @@\n-\n-      event.commit(GCId::current(), _worker_id, G1GCPhaseTimes::phase_name(_scan_phase));\n-    }\n-\n-    \/\/ Scan code root remembered sets.\n-    {\n-      EventGCPhaseParallel event;\n-      G1EvacPhaseWithTrimTimeTracker timer(_pss, _code_root_scan_time, _code_trim_partially_time);\n-      G1ScanAndCountNMethodClosure cl(_pss->closures()->weak_nmethods());\n-\n-      \/\/ Scan the code root list attached to the current region\n-      r->code_roots_do(&cl);\n-\n-      _code_roots_scanned += cl.count();\n-\n-      event.commit(GCId::current(), _worker_id, G1GCPhaseTimes::phase_name(_code_roots_phase));\n@@ -832,1 +847,0 @@\n-\n@@ -836,8 +850,0 @@\n-  Tickspan code_root_scan_time() const { return _code_root_scan_time;  }\n-  Tickspan code_root_trim_partially_time() const { return _code_trim_partially_time; }\n-\n-  size_t code_roots_scanned() const { return _code_roots_scanned; }\n-\n-  Tickspan rem_set_opt_root_scan_time() const { return _rem_set_opt_root_scan_time; }\n-  Tickspan rem_set_opt_trim_partially_time() const { return _rem_set_opt_trim_partially_time; }\n-\n@@ -849,7 +855,11 @@\n-void G1RemSet::scan_collection_set_regions(G1ParScanThreadState* pss,\n-                                           uint worker_id,\n-                                           G1GCPhaseTimes::GCParPhases scan_phase,\n-                                           G1GCPhaseTimes::GCParPhases coderoots_phase,\n-                                           G1GCPhaseTimes::GCParPhases objcopy_phase) {\n-  G1ScanCollectionSetRegionClosure cl(_scan_state, pss, worker_id, scan_phase, coderoots_phase);\n-  _g1h->collection_set_iterate_increment_from(&cl, worker_id);\n+void G1RemSet::scan_collection_set_optional_roots(G1ParScanThreadState* pss,\n+                                                  uint worker_id,\n+                                                  G1GCPhaseTimes::GCParPhases scan_phase,\n+                                                  G1GCPhaseTimes::GCParPhases objcopy_phase) {\n+  assert(scan_phase == G1GCPhaseTimes::OptScanHR, \"must be\");\n+\n+  EventGCPhaseParallel event;\n+\n+  Tickspan rem_set_opt_root_scan_time;\n+  Tickspan rem_set_opt_trim_partially_time;\n+  G1EvacPhaseWithTrimTimeTracker timer(pss, rem_set_opt_root_scan_time, rem_set_opt_trim_partially_time);\n@@ -859,2 +869,4 @@\n-  p->record_or_add_time_secs(scan_phase, worker_id, cl.rem_set_opt_root_scan_time().seconds());\n-  p->record_or_add_time_secs(scan_phase, worker_id, cl.rem_set_opt_trim_partially_time().seconds());\n+  G1ScanOptionalRemSetRootsClosure cl(pss, worker_id, scan_phase);\n+  \/\/ The individual references for the optional remembered set are per-worker, so every worker\n+  \/\/ always need to scan all regions (no claimer).\n+  _g1h->collection_set_iterate_increment_from(&cl, worker_id);\n@@ -862,2 +874,2 @@\n-  p->record_or_add_time_secs(coderoots_phase, worker_id, cl.code_root_scan_time().seconds());\n-  p->record_or_add_thread_work_item(coderoots_phase, worker_id, cl.code_roots_scanned(), G1GCPhaseTimes::CodeRootsScannedNMethods);\n+  p->record_or_add_time_secs(scan_phase, worker_id, rem_set_opt_root_scan_time.seconds());\n+  p->record_or_add_time_secs(objcopy_phase, worker_id, rem_set_opt_trim_partially_time.seconds());\n@@ -865,1 +877,3 @@\n-  p->add_time_secs(objcopy_phase, worker_id, cl.code_root_trim_partially_time().seconds());\n+  p->record_or_add_thread_work_item(scan_phase, worker_id, cl.opt_roots_scanned(), G1GCPhaseTimes::ScanHRFoundRoots);\n+  p->record_or_add_thread_work_item(scan_phase, worker_id, cl.opt_refs_scanned(), G1GCPhaseTimes::ScanHRScannedOptRefs);\n+  p->record_or_add_thread_work_item(scan_phase, worker_id, cl.opt_refs_memory_used(), G1GCPhaseTimes::ScanHRUsedMemory);\n@@ -867,6 +881,1 @@\n-  \/\/ At this time we record some metrics only for the evacuations after the initial one.\n-  if (scan_phase == G1GCPhaseTimes::OptScanHR) {\n-    p->record_or_add_thread_work_item(scan_phase, worker_id, cl.opt_roots_scanned(), G1GCPhaseTimes::ScanHRFoundRoots);\n-    p->record_or_add_thread_work_item(scan_phase, worker_id, cl.opt_refs_scanned(), G1GCPhaseTimes::ScanHRScannedOptRefs);\n-    p->record_or_add_thread_work_item(scan_phase, worker_id, cl.opt_refs_memory_used(), G1GCPhaseTimes::ScanHRUsedMemory);\n-  }\n+  event.commit(GCId::current(), worker_id, G1GCPhaseTimes::phase_name(scan_phase));\n@@ -875,0 +884,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":81,"deletions":71,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -115,5 +115,9 @@\n-  void scan_collection_set_regions(G1ParScanThreadState* pss,\n-                                   uint worker_id,\n-                                   G1GCPhaseTimes::GCParPhases scan_phase,\n-                                   G1GCPhaseTimes::GCParPhases coderoots_phase,\n-                                   G1GCPhaseTimes::GCParPhases objcopy_phase);\n+  void scan_collection_set_code_roots(G1ParScanThreadState* pss,\n+                                      uint worker_id,\n+                                      G1GCPhaseTimes::GCParPhases coderoots_phase,\n+                                      G1GCPhaseTimes::GCParPhases objcopy_phase);\n+\n+  void scan_collection_set_optional_roots(G1ParScanThreadState* pss,\n+                                          uint worker_id,\n+                                          G1GCPhaseTimes::GCParPhases scan_phase,\n+                                          G1GCPhaseTimes::GCParPhases objcopy_phase);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.hpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -595,0 +595,1 @@\n+\n@@ -597,0 +598,1 @@\n+\n@@ -671,1 +673,16 @@\n-    _g1h->rem_set()->scan_collection_set_regions(pss, worker_id, G1GCPhaseTimes::ScanHR, G1GCPhaseTimes::CodeRoots, G1GCPhaseTimes::ObjCopy);\n+    _g1h->rem_set()->scan_collection_set_code_roots(pss, worker_id, G1GCPhaseTimes::CodeRoots, G1GCPhaseTimes::ObjCopy);\n+    \/\/ There are no optional roots to scan right now.\n+#ifdef ASSERT\n+    class VerifyOptionalCollectionSetRootsEmptyClosure : public G1HeapRegionClosure {\n+      G1ParScanThreadState* _pss;\n+\n+    public:\n+      VerifyOptionalCollectionSetRootsEmptyClosure(G1ParScanThreadState* pss) : _pss(pss) { }\n+\n+      bool do_heap_region(G1HeapRegion* r) override {\n+        assert(!r->has_index_in_opt_cset(), \"must be\");\n+        return false;\n+      }\n+    } cl(pss);\n+    _g1h->collection_set_iterate_increment_from(&cl, worker_id);\n+#endif\n@@ -740,1 +757,2 @@\n-    _g1h->rem_set()->scan_collection_set_regions(pss, worker_id, G1GCPhaseTimes::OptScanHR, G1GCPhaseTimes::OptCodeRoots, G1GCPhaseTimes::OptObjCopy);\n+    _g1h->rem_set()->scan_collection_set_code_roots(pss, worker_id, G1GCPhaseTimes::OptCodeRoots, G1GCPhaseTimes::OptObjCopy);\n+    _g1h->rem_set()->scan_collection_set_optional_roots(pss, worker_id, G1GCPhaseTimes::OptScanHR, G1GCPhaseTimes::ObjCopy);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"}]}