{"files":[{"patch":"@@ -823,16 +823,1 @@\n-  \/\/ Create input type (domain)\n-  int argcnt = NOT_LP64(3) LP64_ONLY(4);\n-  const Type** const domain_fields = TypeTuple::fields(argcnt);\n-  int argp = TypeFunc::Parms;\n-  domain_fields[argp++] = TypeInstPtr::NOTNULL;  \/\/ src\n-  domain_fields[argp++] = TypeInstPtr::NOTNULL;  \/\/ dst\n-  domain_fields[argp++] = TypeX_X;               \/\/ size lower\n-  LP64_ONLY(domain_fields[argp++] = Type::HALF); \/\/ size upper\n-  assert(argp == TypeFunc::Parms+argcnt, \"correct decoding\");\n-  const TypeTuple* const domain = TypeTuple::make(TypeFunc::Parms + argcnt, domain_fields);\n-\n-  \/\/ Create result type (range)\n-  const Type** const range_fields = TypeTuple::fields(0);\n-  const TypeTuple* const range = TypeTuple::make(TypeFunc::Parms + 0, range_fields);\n-\n-  return TypeFunc::make(domain, range);\n+  return OptoRuntime::clone_type_Type();\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -530,10 +530,1 @@\n-  const Type **fields = TypeTuple::fields(2);\n-  fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; \/\/ original field value\n-  fields[TypeFunc::Parms+1] = TypeRawPtr::NOTNULL; \/\/ thread\n-  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);\n-\n-  \/\/ create result type (range)\n-  fields = TypeTuple::fields(0);\n-  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);\n-\n-  return TypeFunc::make(domain, range);\n+  return OptoRuntime::write_ref_field_pre_Type();\n@@ -543,9 +534,1 @@\n-  const Type **fields = TypeTuple::fields(1);\n-  fields[TypeFunc::Parms+0] = TypeOopPtr::NOTNULL; \/\/ src oop\n-  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);\n-\n-  \/\/ create result type (range)\n-  fields = TypeTuple::fields(0);\n-  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);\n-\n-  return TypeFunc::make(domain, range);\n+  return OptoRuntime::clone_barrier_Type();\n@@ -555,12 +538,1 @@\n-  const Type **fields = TypeTuple::fields(2);\n-  fields[TypeFunc::Parms+0] = TypeOopPtr::BOTTOM; \/\/ original field value\n-  fields[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM; \/\/ original load address\n-\n-  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);\n-\n-  \/\/ create result type (range)\n-  fields = TypeTuple::fields(1);\n-  fields[TypeFunc::Parms+0] = TypeOopPtr::BOTTOM;\n-  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);\n-\n-  return TypeFunc::make(domain, range);\n+  return OptoRuntime::load_reference_barrier_Type();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":3,"deletions":31,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+const TypeFunc* ArrayCopyNode::_arraycopy_type_tf = nullptr;\n+\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+  static const TypeFunc* _arraycopy_type_tf;\n@@ -68,0 +69,2 @@\n+public:\n+\n@@ -69,0 +72,6 @@\n+    assert(_arraycopy_type_tf != nullptr, \"should be initialized\");\n+    return _arraycopy_type_tf;\n+  }\n+\n+  static void arraycopy_type_init() {\n+    assert(_arraycopy_type_tf == nullptr, \"should be\");\n@@ -86,1 +95,1 @@\n-    return TypeFunc::make(domain, range);\n+    _arraycopy_type_tf =  TypeFunc::make(domain, range);\n@@ -89,0 +98,1 @@\n+private:\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1669,0 +1669,2 @@\n+const TypeFunc* LockNode::_lock_type_tf = nullptr;\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1193,0 +1193,1 @@\n+  static const TypeFunc *_lock_type_tf;\n@@ -1195,1 +1196,7 @@\n-  static const TypeFunc *lock_type() {\n+  static inline const TypeFunc *lock_type() {\n+    assert(_lock_type_tf != nullptr, \"should be initialized\");\n+    return _lock_type_tf;\n+  }\n+\n+  static void lock_type_init() {\n+    assert(_lock_type_tf == nullptr, \"should be called once\");\n@@ -1208,1 +1215,1 @@\n-    return TypeFunc::make(domain,range);\n+    _lock_type_tf = TypeFunc::make(domain,range);\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -195,0 +195,69 @@\n+const TypeFunc* OptoRuntime::_new_instance_tf = nullptr;\n+const TypeFunc* OptoRuntime::_new_array_tf = nullptr;\n+const TypeFunc* OptoRuntime::_multianewarray2_tf = nullptr;\n+const TypeFunc* OptoRuntime::_multianewarray4_tf = nullptr;\n+const TypeFunc* OptoRuntime::_multianewarray3_tf = nullptr;\n+const TypeFunc* OptoRuntime::_multianewarray5_tf = nullptr;\n+const TypeFunc* OptoRuntime::_multianewarrayN_tf = nullptr;\n+const TypeFunc* OptoRuntime::_complete_monitor_enter_tf = nullptr;\n+const TypeFunc* OptoRuntime::_complete_monitor_exit_tf = nullptr;\n+const TypeFunc* OptoRuntime::_monitor_notify_tf = nullptr;\n+const TypeFunc* OptoRuntime::_uncommon_trap_tf = nullptr;\n+const TypeFunc* OptoRuntime::_athrow_tf = nullptr;\n+const TypeFunc* OptoRuntime::_rethrow_tf = nullptr;\n+const TypeFunc* OptoRuntime::_Math_D_D_tf = nullptr;\n+const TypeFunc* OptoRuntime::_Math_DD_D_tf = nullptr;\n+const TypeFunc* OptoRuntime::_modf_tf = nullptr;\n+const TypeFunc* OptoRuntime::_l2f_tf = nullptr;\n+const TypeFunc* OptoRuntime::_void_long_tf = nullptr;\n+const TypeFunc* OptoRuntime::_void_void_tf = nullptr;\n+const TypeFunc* OptoRuntime::_jfr_write_checkpoint_tf = nullptr;\n+const TypeFunc* OptoRuntime::_flush_windows_tf = nullptr;\n+const TypeFunc* OptoRuntime::_fast_arraycopy_tf = nullptr;\n+const TypeFunc* OptoRuntime::_checkcast_arraycopy_tf = nullptr;\n+const TypeFunc* OptoRuntime::_generic_arraycopy_tf = nullptr;\n+const TypeFunc* OptoRuntime::_slow_arraycopy_tf = nullptr;\n+const TypeFunc* OptoRuntime::_make_setmemory_tf = nullptr;\n+const TypeFunc* OptoRuntime::_array_fill_tf = nullptr;\n+const TypeFunc* OptoRuntime::_array_sort_tf = nullptr;\n+const TypeFunc* OptoRuntime::_array_partition_tf = nullptr;\n+const TypeFunc* OptoRuntime::_aescrypt_block_tf = nullptr;\n+const TypeFunc* OptoRuntime::_cipherBlockChaining_aescrypt_tf = nullptr;\n+const TypeFunc* OptoRuntime::_electronicCodeBook_aescrypt_tf = nullptr;\n+const TypeFunc* OptoRuntime::_counterMode_aescrypt_tf = nullptr;\n+const TypeFunc* OptoRuntime::_galoisCounterMode_aescrypt_tf = nullptr;\n+const TypeFunc* OptoRuntime::_digestBase_implCompress_with_sha3_tf = nullptr;\n+const TypeFunc* OptoRuntime::_digestBase_implCompress_without_sha3_tf = nullptr;\n+const TypeFunc* OptoRuntime::_digestBase_implCompressMB_with_sha3_tf = nullptr;\n+const TypeFunc* OptoRuntime::_digestBase_implCompressMB_without_sha3_tf = nullptr;\n+const TypeFunc* OptoRuntime::_multiplyToLen_tf = nullptr;\n+const TypeFunc* OptoRuntime::_montgomeryMultiply_tf = nullptr;\n+const TypeFunc* OptoRuntime::_montgomerySquare_tf = nullptr;\n+const TypeFunc* OptoRuntime::_squareToLen_tf = nullptr;\n+const TypeFunc* OptoRuntime::_mulAdd_tf = nullptr;\n+const TypeFunc* OptoRuntime::_bigIntegerShift_tf = nullptr;\n+const TypeFunc* OptoRuntime::_vectorizedMismatch_tf = nullptr;\n+const TypeFunc* OptoRuntime::_ghash_processBlocks_tf = nullptr;\n+const TypeFunc* OptoRuntime::_chacha20Block_tf = nullptr;\n+const TypeFunc* OptoRuntime::_base64_encodeBlock_tf = nullptr;\n+const TypeFunc* OptoRuntime::_base64_decodeBlock_tf = nullptr;\n+const TypeFunc* OptoRuntime::_string_IndexOf_tf = nullptr;\n+const TypeFunc* OptoRuntime::_poly1305_processBlocks_tf = nullptr;\n+const TypeFunc* OptoRuntime::_intpoly_montgomeryMult_P256_tf = nullptr;\n+const TypeFunc* OptoRuntime::_intpoly_assign_tf = nullptr;\n+const TypeFunc* OptoRuntime::_updateBytesCRC32_tf = nullptr;\n+const TypeFunc* OptoRuntime::_updateBytesCRC32C_tf = nullptr;\n+const TypeFunc* OptoRuntime::_updateBytesAdler32_tf = nullptr;\n+const TypeFunc* OptoRuntime::_osr_end_tf = nullptr;\n+const TypeFunc* OptoRuntime::_register_finalizer_tf = nullptr;\n+JFR_ONLY(const TypeFunc* OptoRuntime::_class_id_load_barrier_tf = nullptr;)\n+#ifdef INCLUDE_JVMTI\n+const TypeFunc* OptoRuntime::_notify_jvmti_vthread_tf = nullptr;\n+#endif \/\/ INCLUDE_JVMTI\n+const TypeFunc* OptoRuntime::_dtrace_method_entry_exit_tf = nullptr;\n+const TypeFunc* OptoRuntime::_dtrace_object_alloc_tf = nullptr;\n+const TypeFunc* OptoRuntime::_clone_type_tf = nullptr;\n+const TypeFunc* OptoRuntime::_load_reference_barrier_tf = nullptr;\n+const TypeFunc* OptoRuntime::_write_ref_field_pre_tf = nullptr;\n+const TypeFunc* OptoRuntime::_clone_barrier_tf = nullptr;\n+\n@@ -501,1 +570,3 @@\n-const TypeFunc *OptoRuntime::new_instance_Type() {\n+void OptoRuntime::new_instance_Type_init() {\n+  assert(_new_instance_tf == nullptr, \"should be called once only\");\n+\n@@ -513,1 +584,1 @@\n-  return TypeFunc::make(domain, range);\n+  _new_instance_tf = TypeFunc::make(domain, range);\n@@ -517,1 +588,2 @@\n-const TypeFunc *OptoRuntime::notify_jvmti_vthread_Type() {\n+void OptoRuntime::notify_jvmti_vthread_Type_init() {\n+  assert(_notify_jvmti_vthread_tf == nullptr, \"should be called once only\");\n@@ -529,1 +601,1 @@\n-  return TypeFunc::make(domain,range);\n+  _notify_jvmti_vthread_tf = TypeFunc::make(domain,range);\n@@ -533,1 +605,2 @@\n-const TypeFunc *OptoRuntime::athrow_Type() {\n+void OptoRuntime::athrow_Type_init() {\n+  assert(_athrow_tf == nullptr, \"should be called once only\");\n@@ -544,1 +617,1 @@\n-  return TypeFunc::make(domain, range);\n+  _athrow_tf = TypeFunc::make(domain, range);\n@@ -547,2 +620,2 @@\n-\n-const TypeFunc *OptoRuntime::new_array_Type() {\n+void OptoRuntime::new_array_Type_init() {\n+  assert(_new_array_tf == nullptr, \"should be called once only\");\n@@ -561,5 +634,1 @@\n-  return TypeFunc::make(domain, range);\n-}\n-\n-const TypeFunc *OptoRuntime::new_array_nozero_Type() {\n-  return new_array_Type();\n+  _new_array_tf = TypeFunc::make(domain, range);\n@@ -585,2 +654,3 @@\n-const TypeFunc *OptoRuntime::multianewarray2_Type() {\n-  return multianewarray_Type(2);\n+void OptoRuntime::multianewarray2_Type_init() {\n+  assert(_multianewarray2_tf == nullptr, \"should be called once only\");\n+  _multianewarray2_tf = multianewarray_Type(2);\n@@ -589,2 +659,3 @@\n-const TypeFunc *OptoRuntime::multianewarray3_Type() {\n-  return multianewarray_Type(3);\n+void OptoRuntime::multianewarray3_Type_init() {\n+  assert(_multianewarray3_tf == nullptr, \"should be called once only\");\n+  _multianewarray3_tf = multianewarray_Type(3);\n@@ -593,2 +664,3 @@\n-const TypeFunc *OptoRuntime::multianewarray4_Type() {\n-  return multianewarray_Type(4);\n+void OptoRuntime::multianewarray4_Type_init() {\n+  assert(_multianewarray4_tf == nullptr, \"should be called once only\");\n+  _multianewarray4_tf = multianewarray_Type(4);\n@@ -597,2 +669,3 @@\n-const TypeFunc *OptoRuntime::multianewarray5_Type() {\n-  return multianewarray_Type(5);\n+void OptoRuntime::multianewarray5_Type_init() {\n+  assert(_multianewarray5_tf == nullptr, \"should be called once only\");\n+  _multianewarray5_tf = multianewarray_Type(5);\n@@ -601,1 +674,2 @@\n-const TypeFunc *OptoRuntime::multianewarrayN_Type() {\n+void OptoRuntime::multianewarrayN_Type_init() {\n+  assert(_multianewarrayN_tf == nullptr, \"should be called once only\");\n@@ -613,1 +687,1 @@\n-  return TypeFunc::make(domain, range);\n+  _multianewarrayN_tf = TypeFunc::make(domain, range);\n@@ -616,1 +690,2 @@\n-const TypeFunc *OptoRuntime::uncommon_trap_Type() {\n+void OptoRuntime::uncommon_trap_Type_init() {\n+  assert(_uncommon_trap_tf == nullptr, \"should be called once only\");\n@@ -626,1 +701,1 @@\n-  return TypeFunc::make(domain, range);\n+  _uncommon_trap_tf = TypeFunc::make(domain, range);\n@@ -631,1 +706,3 @@\n-const TypeFunc *OptoRuntime::complete_monitor_enter_Type() {\n+\n+void OptoRuntime::complete_monitor_enter_Type_init() {\n+  assert(_complete_monitor_enter_tf == nullptr, \"should be called once only\");\n@@ -643,5 +720,1 @@\n-  return TypeFunc::make(domain,range);\n-}\n-\n-const TypeFunc *OptoRuntime::complete_monitor_locking_Type() {\n-  return complete_monitor_enter_Type();\n+  _complete_monitor_enter_tf = TypeFunc::make(domain,range);\n@@ -651,1 +724,3 @@\n-const TypeFunc *OptoRuntime::complete_monitor_exit_Type() {\n+\n+void OptoRuntime::complete_monitor_exit_Type_init() {\n+  assert(_complete_monitor_exit_tf == nullptr, \"should be called once only\");\n@@ -664,1 +739,1 @@\n-  return TypeFunc::make(domain, range);\n+  _complete_monitor_exit_tf = TypeFunc::make(domain, range);\n@@ -667,1 +742,2 @@\n-const TypeFunc *OptoRuntime::monitor_notify_Type() {\n+void OptoRuntime::monitor_notify_Type_init() {\n+  assert(_monitor_notify_tf == nullptr, \"should be called once only\");\n@@ -676,5 +752,1 @@\n-  return TypeFunc::make(domain, range);\n-}\n-\n-const TypeFunc *OptoRuntime::monitor_notifyAll_Type() {\n-  return monitor_notify_Type();\n+  _monitor_notify_tf = TypeFunc::make(domain, range);\n@@ -683,1 +755,2 @@\n-const TypeFunc* OptoRuntime::flush_windows_Type() {\n+void OptoRuntime::flush_windows_Type_init() {\n+  assert(_flush_windows_tf == nullptr, \"should be called once only\");\n@@ -694,1 +767,1 @@\n-  return TypeFunc::make(domain, range);\n+  _flush_windows_tf = TypeFunc::make(domain, range);\n@@ -697,1 +770,2 @@\n-const TypeFunc* OptoRuntime::l2f_Type() {\n+void OptoRuntime::l2f_Type_init() {\n+  assert(_l2f_tf == nullptr, \"should be called once only\");\n@@ -709,1 +783,1 @@\n-  return TypeFunc::make(domain, range);\n+  _l2f_tf = TypeFunc::make(domain, range);\n@@ -712,1 +786,2 @@\n-const TypeFunc* OptoRuntime::modf_Type() {\n+void OptoRuntime::modf_Type_init() {\n+  assert(_modf_tf == nullptr, \"should be called once only\");\n@@ -724,1 +799,1 @@\n-  return TypeFunc::make(domain, range);\n+  _modf_tf = TypeFunc::make(domain, range);\n@@ -727,1 +802,2 @@\n-const TypeFunc *OptoRuntime::Math_D_D_Type() {\n+void OptoRuntime::Math_D_D_Type_init() {\n+  assert(_Math_D_D_tf == nullptr, \"should be called once only\");\n@@ -741,1 +817,1 @@\n-  return TypeFunc::make(domain, range);\n+  _Math_D_D_tf = TypeFunc::make(domain, range);\n@@ -763,1 +839,2 @@\n-const TypeFunc* OptoRuntime::Math_DD_D_Type() {\n+void OptoRuntime::Math_DD_D_Type_init() {\n+  assert(_Math_DD_D_tf == nullptr, \"should be called once only\");\n@@ -777,1 +854,1 @@\n-  return TypeFunc::make(domain, range);\n+  _Math_DD_D_tf = TypeFunc::make(domain, range);\n@@ -782,1 +859,2 @@\n-const TypeFunc* OptoRuntime::void_long_Type() {\n+void OptoRuntime::void_long_Type_init() {\n+  assert(_void_long_tf == nullptr, \"should be called once only\");\n@@ -793,1 +871,1 @@\n-  return TypeFunc::make(domain, range);\n+  _void_long_tf = TypeFunc::make(domain, range);\n@@ -796,4 +874,5 @@\n-const TypeFunc* OptoRuntime::void_void_Type() {\n-   \/\/ create input type (domain)\n-   const Type **fields = TypeTuple::fields(0);\n-   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+0, fields);\n+void OptoRuntime::void_void_Type_init() {\n+  assert(_void_void_tf == nullptr, \"should be called once only\");\n+  \/\/ create input type (domain)\n+  const Type **fields = TypeTuple::fields(0);\n+  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+0, fields);\n@@ -801,5 +880,5 @@\n-   \/\/ create result type (range)\n-   fields = TypeTuple::fields(0);\n-   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);\n-   return TypeFunc::make(domain, range);\n- }\n+  \/\/ create result type (range)\n+  fields = TypeTuple::fields(0);\n+  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);\n+  _void_void_tf = TypeFunc::make(domain, range);\n+}\n@@ -807,4 +886,5 @@\n- const TypeFunc* OptoRuntime::jfr_write_checkpoint_Type() {\n-   \/\/ create input type (domain)\n-   const Type **fields = TypeTuple::fields(0);\n-   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms, fields);\n+void OptoRuntime::jfr_write_checkpoint_Type_init() {\n+  assert(_jfr_write_checkpoint_tf == nullptr, \"should be called once only\");\n+  \/\/ create input type (domain)\n+  const Type **fields = TypeTuple::fields(0);\n+  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms, fields);\n@@ -812,5 +892,5 @@\n-   \/\/ create result type (range)\n-   fields = TypeTuple::fields(0);\n-   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms, fields);\n-   return TypeFunc::make(domain, range);\n- }\n+  \/\/ create result type (range)\n+  fields = TypeTuple::fields(0);\n+  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms, fields);\n+  _jfr_write_checkpoint_tf = TypeFunc::make(domain, range);\n+}\n@@ -823,1 +903,3 @@\n-const TypeFunc* OptoRuntime::make_setmemory_Type() {\n+\n+void OptoRuntime::make_setmemory_Type_init() {\n+  assert(_make_setmemory_tf == nullptr, \"should be called once only\");\n@@ -839,1 +921,1 @@\n-  return TypeFunc::make(domain, range);\n+  _make_setmemory_tf = TypeFunc::make(domain, range);\n@@ -888,3 +970,3 @@\n-const TypeFunc* OptoRuntime::fast_arraycopy_Type() {\n-  \/\/ This signature is simple:  Two base pointers and a size_t.\n-  return make_arraycopy_Type(ac_fast);\n+void OptoRuntime::fast_arraycopy_Type_init() {\n+  assert(_fast_arraycopy_tf == nullptr, \"should be called once only\");\n+  _fast_arraycopy_tf = make_arraycopy_Type(ac_fast);\n@@ -893,3 +975,3 @@\n-const TypeFunc* OptoRuntime::checkcast_arraycopy_Type() {\n-  \/\/ An extension of fast_arraycopy_Type which adds type checking.\n-  return make_arraycopy_Type(ac_checkcast);\n+void OptoRuntime::checkcast_arraycopy_Type_init() {\n+  assert(_checkcast_arraycopy_tf == nullptr, \"should be called once only\");\n+  _checkcast_arraycopy_tf = make_arraycopy_Type(ac_checkcast);\n@@ -898,4 +980,3 @@\n-const TypeFunc* OptoRuntime::slow_arraycopy_Type() {\n-  \/\/ This signature is exactly the same as System.arraycopy.\n-  \/\/ There are no intptr_t (int\/long) arguments.\n-  return make_arraycopy_Type(ac_slow);\n+void OptoRuntime::slow_arraycopy_Type_init() {\n+  assert(_slow_arraycopy_tf == nullptr, \"should be called once only\");\n+  _slow_arraycopy_tf = make_arraycopy_Type(ac_slow);\n@@ -904,3 +985,3 @@\n-const TypeFunc* OptoRuntime::generic_arraycopy_Type() {\n-  \/\/ This signature is like System.arraycopy, except that it returns status.\n-  return make_arraycopy_Type(ac_generic);\n+void OptoRuntime::generic_arraycopy_Type_init() {\n+  assert(_generic_arraycopy_tf == nullptr, \"should be called once only\");\n+  _generic_arraycopy_tf = make_arraycopy_Type(ac_generic);\n@@ -909,2 +990,2 @@\n-\n-const TypeFunc* OptoRuntime::array_fill_Type() {\n+void OptoRuntime::array_fill_Type_init() {\n+  assert(_array_fill_tf == nullptr, \"should be called once only\");\n@@ -926,1 +1007,1 @@\n-  return TypeFunc::make(domain, range);\n+  _array_fill_tf = TypeFunc::make(domain, range);\n@@ -929,1 +1010,2 @@\n-const TypeFunc* OptoRuntime::array_partition_Type() {\n+void OptoRuntime::array_partition_Type_init() {\n+  assert(_array_partition_tf == nullptr, \"should be called once only\");\n@@ -949,1 +1031,1 @@\n-  return TypeFunc::make(domain, range);\n+  _array_partition_tf = TypeFunc::make(domain, range);\n@@ -952,1 +1034,2 @@\n-const TypeFunc* OptoRuntime::array_sort_Type() {\n+void OptoRuntime::array_sort_Type_init() {\n+  assert(_array_sort_tf == nullptr, \"should be called once only\");\n@@ -969,1 +1052,1 @@\n-  return TypeFunc::make(domain, range);\n+  _array_sort_tf = TypeFunc::make(domain, range);\n@@ -972,2 +1055,2 @@\n-\/\/ for aescrypt encrypt\/decrypt operations, just three pointers returning void (length is constant)\n-const TypeFunc* OptoRuntime::aescrypt_block_Type() {\n+void OptoRuntime::aescrypt_block_Type_init() {\n+  assert(_aescrypt_block_tf == nullptr, \"should be called once only\");\n@@ -989,1 +1072,1 @@\n-  return TypeFunc::make(domain, range);\n+  _aescrypt_block_tf = TypeFunc::make(domain, range);\n@@ -992,4 +1075,2 @@\n-\/**\n- * int updateBytesCRC32(int crc, byte* b, int len)\n- *\/\n-const TypeFunc* OptoRuntime::updateBytesCRC32_Type() {\n+void OptoRuntime::updateBytesCRC32_Type_init() {\n+  assert(_updateBytesCRC32_tf == nullptr, \"should be called once only\");\n@@ -1011,1 +1092,1 @@\n-  return TypeFunc::make(domain, range);\n+  _updateBytesCRC32_tf = TypeFunc::make(domain, range);\n@@ -1014,4 +1095,2 @@\n-\/**\n- * int updateBytesCRC32C(int crc, byte* buf, int len, int* table)\n- *\/\n-const TypeFunc* OptoRuntime::updateBytesCRC32C_Type() {\n+void OptoRuntime::updateBytesCRC32C_Type_init() {\n+  assert(_updateBytesCRC32C_tf == nullptr, \"should be called once only\");\n@@ -1034,1 +1113,1 @@\n-  return TypeFunc::make(domain, range);\n+  _updateBytesCRC32C_tf = TypeFunc::make(domain, range);\n@@ -1037,4 +1116,2 @@\n-\/**\n-*  int updateBytesAdler32(int adler, bytes* b, int off, int len)\n-*\/\n-const TypeFunc* OptoRuntime::updateBytesAdler32_Type() {\n+void OptoRuntime::updateBytesAdler32_Type_init() {\n+  assert(_updateBytesAdler32_tf == nullptr, \"should be called once only\");\n@@ -1056,1 +1133,1 @@\n-  return TypeFunc::make(domain, range);\n+  _updateBytesAdler32_tf = TypeFunc::make(domain, range);\n@@ -1059,2 +1136,2 @@\n-\/\/ for cipherBlockChaining calls of aescrypt encrypt\/decrypt, four pointers and a length, returning int\n-const TypeFunc* OptoRuntime::cipherBlockChaining_aescrypt_Type() {\n+void OptoRuntime::cipherBlockChaining_aescrypt_Type_init() {\n+  assert(_cipherBlockChaining_aescrypt_tf == nullptr, \"should be called once only\");\n@@ -1078,1 +1155,1 @@\n-  return TypeFunc::make(domain, range);\n+  _cipherBlockChaining_aescrypt_tf = TypeFunc::make(domain, range);\n@@ -1081,2 +1158,2 @@\n-\/\/ for electronicCodeBook calls of aescrypt encrypt\/decrypt, three pointers and a length, returning int\n-const TypeFunc* OptoRuntime::electronicCodeBook_aescrypt_Type() {\n+void OptoRuntime::electronicCodeBook_aescrypt_Type_init() {\n+  assert(_electronicCodeBook_aescrypt_tf == nullptr, \"should be called once only\");\n@@ -1099,1 +1176,1 @@\n-  return TypeFunc::make(domain, range);\n+  _electronicCodeBook_aescrypt_tf = TypeFunc::make(domain, range);\n@@ -1102,2 +1179,2 @@\n-\/\/for counterMode calls of aescrypt encrypt\/decrypt, four pointers and a length, returning int\n-const TypeFunc* OptoRuntime::counterMode_aescrypt_Type() {\n+void OptoRuntime::counterMode_aescrypt_Type_init() {\n+  assert(_counterMode_aescrypt_tf == nullptr, \"should be called once only\");\n@@ -1122,1 +1199,1 @@\n-  return TypeFunc::make(domain, range);\n+  _counterMode_aescrypt_tf = TypeFunc::make(domain, range);\n@@ -1125,2 +1202,2 @@\n-\/\/for counterMode calls of aescrypt encrypt\/decrypt, four pointers and a length, returning int\n-const TypeFunc* OptoRuntime::galoisCounterMode_aescrypt_Type() {\n+void OptoRuntime::galoisCounterMode_aescrypt_Type_init() {\n+  assert(_galoisCounterMode_aescrypt_tf == nullptr, \"should be called once only\");\n@@ -1147,1 +1224,1 @@\n-  return TypeFunc::make(domain, range);\n+  _galoisCounterMode_aescrypt_tf = TypeFunc::make(domain, range);\n@@ -1150,4 +1227,8 @@\n-\/*\n- * void implCompress(byte[] buf, int ofs)\n- *\/\n-const TypeFunc* OptoRuntime::digestBase_implCompress_Type(bool is_sha3) {\n+void OptoRuntime::digestBase_implCompress_Type_init() {\n+  assert((_digestBase_implCompress_with_sha3_tf == nullptr) &&\n+         (_digestBase_implCompress_without_sha3_tf == nullptr), \"should be called once only\");\n+  _digestBase_implCompress_with_sha3_tf = OptoRuntime::digestBase_implCompress_Type_helper( \/* is_sha3= *\/ true);\n+  _digestBase_implCompress_without_sha3_tf = OptoRuntime::digestBase_implCompress_Type_helper( \/* is_sha3= *\/ false);\n+}\n+\n+const TypeFunc* OptoRuntime::digestBase_implCompress_Type_helper(bool is_sha3) {\n@@ -1172,4 +1253,8 @@\n-\/*\n- * int implCompressMultiBlock(byte[] b, int ofs, int limit)\n- *\/\n-const TypeFunc* OptoRuntime::digestBase_implCompressMB_Type(bool is_sha3) {\n+void OptoRuntime::digestBase_implCompressMB_Type_init() {\n+  assert((_digestBase_implCompressMB_with_sha3_tf == nullptr) &&\n+         (_digestBase_implCompressMB_without_sha3_tf == nullptr), \"should be called once only\");\n+  _digestBase_implCompressMB_with_sha3_tf = OptoRuntime::digestBase_implCompressMB_Type_helper(\/* is_sha3 *\/true);\n+  _digestBase_implCompressMB_without_sha3_tf = OptoRuntime::digestBase_implCompressMB_Type_helper(\/* is_sha3 *\/false);\n+}\n+\n+const TypeFunc* OptoRuntime::digestBase_implCompressMB_Type_helper(bool is_sha3) {\n@@ -1196,1 +1281,2 @@\n-const TypeFunc* OptoRuntime::multiplyToLen_Type() {\n+void OptoRuntime::multiplyToLen_Type_init() {\n+  assert(_multiplyToLen_tf == nullptr, \"should be called once only\");\n@@ -1214,1 +1300,1 @@\n-  return TypeFunc::make(domain, range);\n+  _multiplyToLen_tf = TypeFunc::make(domain, range);\n@@ -1217,1 +1303,2 @@\n-const TypeFunc* OptoRuntime::squareToLen_Type() {\n+void OptoRuntime::squareToLen_Type_init() {\n+  assert(_squareToLen_tf == nullptr, \"should be called once only\");\n@@ -1234,1 +1321,1 @@\n-  return TypeFunc::make(domain, range);\n+  _squareToLen_tf = TypeFunc::make(domain, range);\n@@ -1237,2 +1324,2 @@\n-\/\/ for mulAdd calls, 2 pointers and 3 ints, returning int\n-const TypeFunc* OptoRuntime::mulAdd_Type() {\n+void OptoRuntime::mulAdd_Type_init() {\n+  assert(_mulAdd_tf == nullptr, \"should be called once only\");\n@@ -1256,1 +1343,1 @@\n-  return TypeFunc::make(domain, range);\n+  _mulAdd_tf = TypeFunc::make(domain, range);\n@@ -1259,1 +1346,2 @@\n-const TypeFunc* OptoRuntime::montgomeryMultiply_Type() {\n+void OptoRuntime::montgomeryMultiply_Type_init() {\n+  assert(_montgomeryMultiply_tf == nullptr, \"should be called once only\");\n@@ -1280,1 +1368,1 @@\n-  return TypeFunc::make(domain, range);\n+  _montgomeryMultiply_tf = TypeFunc::make(domain, range);\n@@ -1283,1 +1371,2 @@\n-const TypeFunc* OptoRuntime::montgomerySquare_Type() {\n+void OptoRuntime::montgomerySquare_Type_init() {\n+  assert(_montgomerySquare_tf == nullptr, \"should be called once only\");\n@@ -1303,1 +1392,1 @@\n-  return TypeFunc::make(domain, range);\n+  _montgomerySquare_tf = TypeFunc::make(domain, range);\n@@ -1306,1 +1395,2 @@\n-const TypeFunc * OptoRuntime::bigIntegerShift_Type() {\n+void OptoRuntime::bigIntegerShift_Type_init() {\n+  assert(_bigIntegerShift_tf == nullptr, \"should be called once only\");\n@@ -1322,1 +1412,1 @@\n-  return TypeFunc::make(domain, range);\n+  _bigIntegerShift_tf = TypeFunc::make(domain, range);\n@@ -1325,1 +1415,2 @@\n-const TypeFunc* OptoRuntime::vectorizedMismatch_Type() {\n+void OptoRuntime::vectorizedMismatch_Type_init() {\n+  assert(_vectorizedMismatch_tf == nullptr, \"should be called once only\");\n@@ -1342,1 +1433,1 @@\n-  return TypeFunc::make(domain, range);\n+  _vectorizedMismatch_tf = TypeFunc::make(domain, range);\n@@ -1345,3 +1436,3 @@\n-\/\/ GHASH block processing\n-const TypeFunc* OptoRuntime::ghash_processBlocks_Type() {\n-    int argcnt = 4;\n+void OptoRuntime::ghash_processBlocks_Type_init() {\n+  assert(_ghash_processBlocks_tf == nullptr, \"should be called once only\");\n+  int argcnt = 4;\n@@ -1349,8 +1440,8 @@\n-    const Type** fields = TypeTuple::fields(argcnt);\n-    int argp = TypeFunc::Parms;\n-    fields[argp++] = TypePtr::NOTNULL;    \/\/ state\n-    fields[argp++] = TypePtr::NOTNULL;    \/\/ subkeyH\n-    fields[argp++] = TypePtr::NOTNULL;    \/\/ data\n-    fields[argp++] = TypeInt::INT;        \/\/ blocks\n-    assert(argp == TypeFunc::Parms+argcnt, \"correct decoding\");\n-    const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);\n+  const Type** fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ state\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ subkeyH\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ data\n+  fields[argp++] = TypeInt::INT;        \/\/ blocks\n+  assert(argp == TypeFunc::Parms+argcnt, \"correct decoding\");\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);\n@@ -1358,5 +1449,5 @@\n-    \/\/ result type needed\n-    fields = TypeTuple::fields(1);\n-    fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n-    const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);\n-    return TypeFunc::make(domain, range);\n+  \/\/ result type needed\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);\n+  _ghash_processBlocks_tf = TypeFunc::make(domain, range);\n@@ -1365,3 +1456,3 @@\n-\/\/ ChaCha20 Block function\n-const TypeFunc* OptoRuntime::chacha20Block_Type() {\n-    int argcnt = 2;\n+void OptoRuntime::chacha20Block_Type_init() {\n+  assert(_chacha20Block_tf == nullptr, \"should be called once only\");\n+  int argcnt = 2;\n@@ -1369,4 +1460,4 @@\n-    const Type** fields = TypeTuple::fields(argcnt);\n-    int argp = TypeFunc::Parms;\n-    fields[argp++] = TypePtr::NOTNULL;      \/\/ state\n-    fields[argp++] = TypePtr::NOTNULL;      \/\/ result\n+  const Type** fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  fields[argp++] = TypePtr::NOTNULL;      \/\/ state\n+  fields[argp++] = TypePtr::NOTNULL;      \/\/ result\n@@ -1374,2 +1465,2 @@\n-    assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n-    const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);\n+  assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);\n@@ -1377,5 +1468,5 @@\n-    \/\/ result type needed\n-    fields = TypeTuple::fields(1);\n-    fields[TypeFunc::Parms + 0] = TypeInt::INT;     \/\/ key stream outlen as int\n-    const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);\n-    return TypeFunc::make(domain, range);\n+  \/\/ result type needed\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms + 0] = TypeInt::INT;     \/\/ key stream outlen as int\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);\n+  _chacha20Block_tf = TypeFunc::make(domain, range);\n@@ -1384,2 +1475,2 @@\n-\/\/ Base64 encode function\n-const TypeFunc* OptoRuntime::base64_encodeBlock_Type() {\n+void OptoRuntime::base64_encodeBlock_Type_init() {\n+  assert(_base64_encodeBlock_tf == nullptr, \"should be called once only\");\n@@ -1403,1 +1494,1 @@\n-  return TypeFunc::make(domain, range);\n+  _base64_encodeBlock_tf = TypeFunc::make(domain, range);\n@@ -1406,2 +1497,2 @@\n-\/\/ String IndexOf function\n-const TypeFunc* OptoRuntime::string_IndexOf_Type() {\n+void OptoRuntime::string_IndexOf_Type_init() {\n+  assert(_string_IndexOf_tf == nullptr, \"should be called once only\");\n@@ -1423,1 +1514,1 @@\n-  return TypeFunc::make(domain, range);\n+  _string_IndexOf_tf = TypeFunc::make(domain, range);\n@@ -1426,2 +1517,2 @@\n-\/\/ Base64 decode function\n-const TypeFunc* OptoRuntime::base64_decodeBlock_Type() {\n+void OptoRuntime::base64_decodeBlock_Type_init() {\n+  assert(_base64_decodeBlock_tf == nullptr, \"should be called once only\");\n@@ -1446,1 +1537,1 @@\n-  return TypeFunc::make(domain, range);\n+  _base64_decodeBlock_tf = TypeFunc::make(domain, range);\n@@ -1449,2 +1540,2 @@\n-\/\/ Poly1305 processMultipleBlocks function\n-const TypeFunc* OptoRuntime::poly1305_processBlocks_Type() {\n+void OptoRuntime::poly1305_processBlocks_Type_init() {\n+  assert(_poly1305_processBlocks_tf == nullptr, \"should be called once only\");\n@@ -1466,1 +1557,1 @@\n-  return TypeFunc::make(domain, range);\n+  _poly1305_processBlocks_tf = TypeFunc::make(domain, range);\n@@ -1469,2 +1560,2 @@\n-\/\/ MontgomeryIntegerPolynomialP256 multiply function\n-const TypeFunc* OptoRuntime::intpoly_montgomeryMult_P256_Type() {\n+void OptoRuntime::intpoly_montgomeryMult_P256_Type_init() {\n+  assert(_intpoly_montgomeryMult_P256_tf == nullptr, \"should be called once only\");\n@@ -1485,1 +1576,1 @@\n-  return TypeFunc::make(domain, range);\n+  _intpoly_montgomeryMult_P256_tf = TypeFunc::make(domain, range);\n@@ -1488,2 +1579,2 @@\n-\/\/ IntegerPolynomial constant time assignment function\n-const TypeFunc* OptoRuntime::intpoly_assign_Type() {\n+void OptoRuntime::intpoly_assign_Type_init() {\n+  assert(_intpoly_assign_tf == nullptr, \"should be called once only\");\n@@ -1505,1 +1596,1 @@\n-  return TypeFunc::make(domain, range);\n+  _intpoly_assign_tf = TypeFunc::make(domain, range);\n@@ -1508,2 +1599,3 @@\n-\/\/------------- Interpreter state access for on stack replacement\n-const TypeFunc* OptoRuntime::osr_end_Type() {\n+\/\/------------- Interpreter state for on stack replacement\n+void OptoRuntime::osr_end_Type_init() {\n+  assert(_osr_end_tf == nullptr, \"should be called once only\");\n@@ -1520,1 +1612,1 @@\n-  return TypeFunc::make(domain, range);\n+  _osr_end_tf = TypeFunc::make(domain, range);\n@@ -1755,2 +1847,2 @@\n-\n-const TypeFunc *OptoRuntime::rethrow_Type() {\n+void OptoRuntime::rethrow_Type_init() {\n+  assert(_rethrow_tf == nullptr, \"should be called once only\");\n@@ -1767,1 +1859,1 @@\n-  return TypeFunc::make(domain, range);\n+  _rethrow_tf = TypeFunc::make(domain, range);\n@@ -1806,2 +1898,2 @@\n-\n-const TypeFunc *OptoRuntime::register_finalizer_Type() {\n+void OptoRuntime::register_finalizer_Type_init() {\n+  assert(_register_finalizer_tf == nullptr, \"should be called once only\");\n@@ -1820,1 +1912,1 @@\n-  return TypeFunc::make(domain,range);\n+  _register_finalizer_tf = TypeFunc::make(domain,range);\n@@ -1824,1 +1916,2 @@\n-const TypeFunc *OptoRuntime::class_id_load_barrier_Type() {\n+void OptoRuntime::class_id_load_barrier_Type_init() {\n+  assert(_class_id_load_barrier_tf == nullptr, \"should be called once only\");\n@@ -1835,1 +1928,1 @@\n-  return TypeFunc::make(domain,range);\n+  _class_id_load_barrier_tf = TypeFunc::make(domain,range);\n@@ -1837,1 +1930,1 @@\n-#endif\n+#endif \/\/ INCLUDE_JFR\n@@ -1840,2 +1933,2 @@\n-\/\/ Dtrace support.  entry and exit probes have the same signature\n-const TypeFunc *OptoRuntime::dtrace_method_entry_exit_Type() {\n+void OptoRuntime::dtrace_method_entry_exit_Type_init() {\n+  assert(_dtrace_method_entry_exit_tf == nullptr, \"should be called once only\");\n@@ -1853,1 +1946,1 @@\n-  return TypeFunc::make(domain,range);\n+  _dtrace_method_entry_exit_tf = TypeFunc::make(domain,range);\n@@ -1856,1 +1949,2 @@\n-const TypeFunc *OptoRuntime::dtrace_object_alloc_Type() {\n+void OptoRuntime::dtrace_object_alloc_Type_init() {\n+  assert(_dtrace_object_alloc_tf == nullptr, \"should be called once only\");\n@@ -1869,1 +1963,1 @@\n-  return TypeFunc::make(domain,range);\n+  _dtrace_object_alloc_tf = TypeFunc::make(domain,range);\n@@ -1872,0 +1966,62 @@\n+void OptoRuntime::clone_type_init() {\n+  assert(_clone_type_tf == nullptr, \"should be\");\n+  \/\/ Create input type (domain)\n+  int argcnt = NOT_LP64(3) LP64_ONLY(4);\n+  const Type** const domain_fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  domain_fields[argp++] = TypeInstPtr::NOTNULL;  \/\/ src\n+  domain_fields[argp++] = TypeInstPtr::NOTNULL;  \/\/ dst\n+  domain_fields[argp++] = TypeX_X;               \/\/ size lower\n+  LP64_ONLY(domain_fields[argp++] = Type::HALF); \/\/ size upper\n+  assert(argp == TypeFunc::Parms+argcnt, \"correct decoding\");\n+  const TypeTuple* const domain = TypeTuple::make(TypeFunc::Parms + argcnt, domain_fields);\n+\n+  \/\/ Create result type (range)\n+  const Type** const range_fields = TypeTuple::fields(0);\n+  const TypeTuple* const range = TypeTuple::make(TypeFunc::Parms + 0, range_fields);\n+\n+  _clone_type_tf = TypeFunc::make(domain, range);\n+}\n+\n+void OptoRuntime::load_reference_barrier_init() {\n+  assert(_load_reference_barrier_tf == nullptr, \"should be\");\n+  const Type **fields = TypeTuple::fields(2);\n+  fields[TypeFunc::Parms+0] = TypeOopPtr::BOTTOM; \/\/ original field value\n+  fields[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM; \/\/ original load address\n+\n+  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);\n+\n+  \/\/ create result type (range)\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms+0] = TypeOopPtr::BOTTOM;\n+  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);\n+\n+  _load_reference_barrier_tf = TypeFunc::make(domain, range);\n+}\n+\n+void OptoRuntime::write_ref_field_pre_init() {\n+  assert(_write_ref_field_pre_tf == nullptr, \"should be\");\n+  const Type **fields = TypeTuple::fields(2);\n+  fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; \/\/ original field value\n+  fields[TypeFunc::Parms+1] = TypeRawPtr::NOTNULL; \/\/ thread\n+  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);\n+\n+  \/\/ create result type (range)\n+  fields = TypeTuple::fields(0);\n+  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);\n+\n+  _write_ref_field_pre_tf = TypeFunc::make(domain, range);\n+}\n+\n+void OptoRuntime::clone_barrier_init() {\n+  assert(_clone_barrier_tf == nullptr, \"should be\");\n+  const Type **fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms+0] = TypeOopPtr::NOTNULL; \/\/ src oop\n+  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);\n+\n+  \/\/ create result type (range)\n+  fields = TypeTuple::fields(0);\n+  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);\n+\n+  _clone_barrier_tf = TypeFunc::make(domain, range);\n+}\n@@ -1958,0 +2114,68 @@\n+void OptoRuntime::initialize_types() {\n+  new_instance_Type_init();\n+  new_array_Type_init();\n+  multianewarray2_Type_init();\n+  multianewarray3_Type_init();\n+  multianewarray4_Type_init();\n+  multianewarray5_Type_init();\n+  multianewarrayN_Type_init();\n+  complete_monitor_enter_Type_init();\n+  complete_monitor_exit_Type_init();\n+  monitor_notify_Type_init();\n+  uncommon_trap_Type_init();\n+  athrow_Type_init();\n+  rethrow_Type_init();\n+  Math_D_D_Type_init();\n+  Math_DD_D_Type_init();\n+  modf_Type_init();\n+  l2f_Type_init();\n+  void_long_Type_init();\n+  void_void_Type_init();\n+  jfr_write_checkpoint_Type_init();\n+  fast_arraycopy_Type_init();\n+  checkcast_arraycopy_Type_init();\n+  generic_arraycopy_Type_init();\n+  slow_arraycopy_Type_init();\n+  make_setmemory_Type_init();\n+  array_fill_Type_init();\n+  array_sort_Type_init();\n+  array_partition_Type_init();\n+  aescrypt_block_Type_init();\n+  cipherBlockChaining_aescrypt_Type_init();\n+  electronicCodeBook_aescrypt_Type_init();\n+  counterMode_aescrypt_Type_init();\n+  galoisCounterMode_aescrypt_Type_init();\n+  digestBase_implCompress_Type_init();\n+  digestBase_implCompressMB_Type_init();\n+  multiplyToLen_Type_init();\n+  montgomeryMultiply_Type_init();\n+  montgomerySquare_Type_init();\n+  squareToLen_Type_init();\n+  mulAdd_Type_init();\n+  bigIntegerShift_Type_init();\n+  vectorizedMismatch_Type_init();\n+  ghash_processBlocks_Type_init();\n+  chacha20Block_Type_init();\n+  base64_encodeBlock_Type_init();\n+  base64_decodeBlock_Type_init();\n+  string_IndexOf_Type_init();\n+  poly1305_processBlocks_Type_init();\n+  intpoly_montgomeryMult_P256_Type_init();\n+  intpoly_assign_Type_init();\n+  updateBytesCRC32_Type_init();\n+  updateBytesCRC32C_Type_init();\n+  updateBytesAdler32_Type_init();\n+  osr_end_Type_init();\n+  register_finalizer_Type_init();\n+  JFR_ONLY(class_id_load_barrier_Type_init();)\n+#ifdef INCLUDE_JVMTI\n+  notify_jvmti_vthread_Type_init();\n+#endif \/\/ INCLUDE_JVMTI\n+  dtrace_method_entry_exit_Type_init();\n+  dtrace_object_alloc_Type_init();\n+  clone_type_init();\n+  clone_barrier_init();\n+  write_ref_field_pre_init();\n+  load_reference_barrier_init();\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":433,"deletions":209,"binary":false,"changes":642,"status":"modified"},{"patch":"@@ -134,0 +134,70 @@\n+  \/\/ static TypeFunc* data members\n+  static const TypeFunc *_new_instance_tf;\n+  static const TypeFunc *_new_array_tf;\n+  static const TypeFunc *_multianewarray2_tf;\n+  static const TypeFunc *_multianewarray3_tf;\n+  static const TypeFunc *_multianewarray4_tf;\n+  static const TypeFunc *_multianewarray5_tf;\n+  static const TypeFunc *_multianewarrayN_tf;\n+  static const TypeFunc *_complete_monitor_enter_tf;\n+  static const TypeFunc *_complete_monitor_exit_tf;\n+  static const TypeFunc *_monitor_notify_tf;\n+  static const TypeFunc *_uncommon_trap_tf;\n+  static const TypeFunc *_athrow_tf;\n+  static const TypeFunc *_rethrow_tf;\n+  static const TypeFunc *_Math_D_D_tf;\n+  static const TypeFunc *_Math_DD_D_tf;\n+  static const TypeFunc *_modf_tf;\n+  static const TypeFunc *_l2f_tf;\n+  static const TypeFunc *_void_long_tf;\n+  static const TypeFunc *_void_void_tf;\n+  static const TypeFunc *_jfr_write_checkpoint_tf;\n+  static const TypeFunc *_flush_windows_tf;\n+  static const TypeFunc *_fast_arraycopy_tf;\n+  static const TypeFunc *_checkcast_arraycopy_tf;\n+  static const TypeFunc *_generic_arraycopy_tf;\n+  static const TypeFunc *_slow_arraycopy_tf;\n+  static const TypeFunc *_make_setmemory_tf;\n+  static const TypeFunc *_array_fill_tf;\n+  static const TypeFunc *_array_sort_tf;\n+  static const TypeFunc *_array_partition_tf;\n+  static const TypeFunc *_aescrypt_block_tf;\n+  static const TypeFunc *_cipherBlockChaining_aescrypt_tf;\n+  static const TypeFunc *_electronicCodeBook_aescrypt_tf;\n+  static const TypeFunc *_counterMode_aescrypt_tf;\n+  static const TypeFunc *_galoisCounterMode_aescrypt_tf;\n+  static const TypeFunc *_digestBase_implCompress_with_sha3_tf;\n+  static const TypeFunc *_digestBase_implCompress_without_sha3_tf;\n+  static const TypeFunc *_digestBase_implCompressMB_with_sha3_tf;\n+  static const TypeFunc *_digestBase_implCompressMB_without_sha3_tf;\n+  static const TypeFunc *_multiplyToLen_tf;\n+  static const TypeFunc *_montgomeryMultiply_tf;\n+  static const TypeFunc *_montgomerySquare_tf;\n+  static const TypeFunc *_squareToLen_tf;\n+  static const TypeFunc *_mulAdd_tf;\n+  static const TypeFunc *_bigIntegerShift_tf;\n+  static const TypeFunc *_vectorizedMismatch_tf;\n+  static const TypeFunc *_ghash_processBlocks_tf;\n+  static const TypeFunc *_chacha20Block_tf;\n+  static const TypeFunc *_base64_encodeBlock_tf;\n+  static const TypeFunc *_base64_decodeBlock_tf;\n+  static const TypeFunc *_string_IndexOf_tf;\n+  static const TypeFunc *_poly1305_processBlocks_tf;\n+  static const TypeFunc *_intpoly_montgomeryMult_P256_tf;\n+  static const TypeFunc *_intpoly_assign_tf;\n+  static const TypeFunc *_updateBytesCRC32_tf;\n+  static const TypeFunc *_updateBytesCRC32C_tf;\n+  static const TypeFunc *_updateBytesAdler32_tf;\n+  static const TypeFunc *_osr_end_tf;\n+  static const TypeFunc *_register_finalizer_tf;\n+  JFR_ONLY(static const TypeFunc *_class_id_load_barrier_tf;)\n+#ifdef INCLUDE_JVMTI\n+  static const TypeFunc *_notify_jvmti_vthread_tf;\n+#endif \/\/ INCLUDE_JVMTI\n+  static const TypeFunc *_dtrace_method_entry_exit_tf;\n+  static const TypeFunc *_dtrace_object_alloc_tf;\n+  static const TypeFunc *_clone_type_tf;\n+  static const TypeFunc *_load_reference_barrier_tf;\n+  static const TypeFunc *_write_ref_field_pre_tf;\n+  static const TypeFunc *_clone_barrier_tf;\n+\n@@ -245,3 +315,117 @@\n-  static const TypeFunc* new_instance_Type(); \/\/ object allocation (slow case)\n-  static const TypeFunc* new_array_Type ();   \/\/ [a]newarray (slow case)\n-  static const TypeFunc* new_array_nozero_Type ();   \/\/ [a]newarray (slow case)\n+  \/\/ Initialization methods\n+\n+  static void new_instance_Type_init(); \/\/ object allocation (slow case)\n+  static void new_array_Type_init ();   \/\/ [a]newarray (slow case)\n+  static void multianewarray2_Type_init(); \/\/ multianewarray\n+  static void multianewarray3_Type_init(); \/\/ multianewarray\n+  static void multianewarray4_Type_init(); \/\/ multianewarray\n+  static void multianewarray5_Type_init(); \/\/ multianewarray\n+  static void multianewarrayN_Type_init(); \/\/ multianewarray\n+  static void complete_monitor_enter_Type_init();\n+  static void complete_monitor_exit_Type_init();\n+  static void monitor_notify_Type_init();\n+  static void uncommon_trap_Type_init();\n+  static void athrow_Type_init();\n+  static void rethrow_Type_init();\n+  static void Math_D_D_Type_init();  \/\/ sin,cos & friends\n+  static void Math_DD_D_Type_init(); \/\/ mod,pow & friends\n+  static void modf_Type_init();\n+  static void l2f_Type_init();\n+  static void void_long_Type_init();\n+  static void void_void_Type_init();\n+  static void clone_type_init();\n+  static void load_reference_barrier_init();\n+\n+  static void jfr_write_checkpoint_Type_init();\n+\n+  static void flush_windows_Type_init();\n+\n+  \/\/ arraycopy routine types\n+  static void fast_arraycopy_Type_init(); \/\/ bit-blasters\n+  static void checkcast_arraycopy_Type_init();\n+  static void generic_arraycopy_Type_init();\n+  static void slow_arraycopy_Type_init();   \/\/ the full routine\n+\n+  static void make_setmemory_Type_init();\n+\n+  static void array_fill_Type_init();\n+\n+  static void array_sort_Type_init();\n+  static void array_partition_Type_init();\n+  static void aescrypt_block_Type_init();\n+  static void cipherBlockChaining_aescrypt_Type_init();\n+  static void electronicCodeBook_aescrypt_Type_init();\n+  static void counterMode_aescrypt_Type_init();\n+  static void galoisCounterMode_aescrypt_Type_init();\n+\n+  static void digestBase_implCompress_Type_init();\n+  static const TypeFunc* digestBase_implCompress_Type_helper(bool is_sha3);\n+  static void digestBase_implCompressMB_Type_init();\n+  static const TypeFunc* digestBase_implCompressMB_Type_helper(bool is_sha3);\n+\n+  static void multiplyToLen_Type_init();\n+  static void montgomeryMultiply_Type_init();\n+  static void montgomerySquare_Type_init();\n+\n+  static void squareToLen_Type_init();\n+\n+  static void mulAdd_Type_init();\n+\n+  static void bigIntegerShift_Type_init();\n+\n+  static void vectorizedMismatch_Type_init();\n+\n+  static void ghash_processBlocks_Type_init();\n+  static void chacha20Block_Type_init();\n+  static void base64_encodeBlock_Type_init();\n+  static void base64_decodeBlock_Type_init();\n+  static void string_IndexOf_Type_init();\n+  static void poly1305_processBlocks_Type_init();\n+  static void intpoly_montgomeryMult_P256_Type_init();\n+  static void intpoly_assign_Type_init();\n+\n+  static void updateBytesCRC32_Type_init();\n+  static void updateBytesCRC32C_Type_init();\n+\n+  static void updateBytesAdler32_Type_init();\n+\n+  \/\/ leaf on stack replacement interpreter accessor types\n+  static void osr_end_Type_init();\n+\n+  static void register_finalizer_Type_init();\n+\n+  JFR_ONLY(static void class_id_load_barrier_Type_init();)\n+#if INCLUDE_JVMTI\n+  static void notify_jvmti_vthread_Type_init();\n+#endif\n+\n+  \/\/ Dtrace support\n+  static void dtrace_method_entry_exit_Type_init();\n+  static void dtrace_object_alloc_Type_init();\n+  static void write_ref_field_pre_init();\n+  static void clone_barrier_init();\n+\n+  static inline const TypeFunc *clone_barrier_Type() {\n+    assert(_clone_barrier_tf != nullptr, \"should be initialized\");\n+    return _clone_barrier_tf;\n+  }\n+\n+  static inline const TypeFunc *write_ref_field_pre_Type() {\n+    assert(_write_ref_field_pre_tf != nullptr, \"should be initialized\");\n+    return _write_ref_field_pre_tf;\n+  }\n+\n+  static inline const TypeFunc *new_instance_Type() {\n+    assert(_new_instance_tf != nullptr, \"should be initialized\");\n+    return _new_instance_tf;\n+  }\n+\n+  static inline const TypeFunc *new_array_Type() {\n+    assert(_new_array_tf != nullptr, \"should be initialized\");\n+    return _new_array_tf;\n+  }\n+\n+  static inline const TypeFunc *new_array_nozero_Type() {\n+    return new_array_Type();\n+  }\n+\n@@ -249,15 +433,74 @@\n-  static const TypeFunc* multianewarray2_Type(); \/\/ multianewarray\n-  static const TypeFunc* multianewarray3_Type(); \/\/ multianewarray\n-  static const TypeFunc* multianewarray4_Type(); \/\/ multianewarray\n-  static const TypeFunc* multianewarray5_Type(); \/\/ multianewarray\n-  static const TypeFunc* multianewarrayN_Type(); \/\/ multianewarray\n-  static const TypeFunc* complete_monitor_enter_Type();\n-  static const TypeFunc* complete_monitor_locking_Type();\n-  static const TypeFunc* complete_monitor_exit_Type();\n-  static const TypeFunc* monitor_notify_Type();\n-  static const TypeFunc* monitor_notifyAll_Type();\n-  static const TypeFunc* uncommon_trap_Type();\n-  static const TypeFunc* athrow_Type();\n-  static const TypeFunc* rethrow_Type();\n-  static const TypeFunc* Math_D_D_Type();  \/\/ sin,cos & friends\n-  static const TypeFunc* Math_DD_D_Type(); \/\/ mod,pow & friends\n+\n+  static inline const TypeFunc *multianewarray2_Type() {\n+    assert(_multianewarray2_tf != nullptr, \"should be initialized\");\n+    return _multianewarray2_tf;\n+  }\n+\n+  static inline const TypeFunc *multianewarray3_Type() {\n+    assert(_multianewarray3_tf != nullptr, \"should be initialized\");\n+    return _multianewarray3_tf;\n+  }\n+\n+  static inline const TypeFunc *multianewarray4_Type() {\n+    assert(_multianewarray4_tf != nullptr, \"should be initialized\");\n+    return _multianewarray4_tf;\n+  }\n+\n+  static inline const TypeFunc *multianewarray5_Type() {\n+    assert(_multianewarray5_tf != nullptr, \"should be initialized\");\n+    return _multianewarray5_tf;\n+  }\n+\n+  static inline const TypeFunc *multianewarrayN_Type() {\n+    assert(_multianewarrayN_tf != nullptr, \"should be initialized\");\n+    return _multianewarrayN_tf;\n+  }\n+\n+  static inline const TypeFunc *complete_monitor_enter_Type() {\n+    assert(_complete_monitor_enter_tf != nullptr, \"should be initialized\");\n+    return _complete_monitor_enter_tf;\n+  }\n+\n+  static inline const TypeFunc *complete_monitor_locking_Type() {\n+    return complete_monitor_enter_Type();\n+  }\n+\n+  static inline const TypeFunc *complete_monitor_exit_Type() {\n+    assert(_complete_monitor_exit_tf != nullptr, \"should be initialized\");\n+    return _complete_monitor_exit_tf;\n+  }\n+\n+  static inline const TypeFunc *monitor_notify_Type() {\n+    assert(_monitor_notify_tf != nullptr, \"should be initialized\");\n+    return _monitor_notify_tf;\n+  }\n+\n+  static inline const TypeFunc *monitor_notifyAll_Type() {\n+    return monitor_notify_Type();\n+  }\n+\n+  static inline const TypeFunc *uncommon_trap_Type() {\n+    assert(_uncommon_trap_tf != nullptr, \"should be initialized\");\n+    return _uncommon_trap_tf;\n+  }\n+\n+  static inline const TypeFunc *athrow_Type() {\n+    assert(_athrow_tf != nullptr, \"should be initialized\");\n+    return _athrow_tf;\n+  }\n+\n+  static inline const TypeFunc *rethrow_Type() {\n+    assert(_rethrow_tf != nullptr, \"should be initialized\");\n+    return _rethrow_tf;\n+  }\n+\n+  static inline const TypeFunc *Math_D_D_Type() {\n+    assert(_Math_D_D_tf != nullptr, \"should be initialized\");\n+    return _Math_D_D_tf;\n+  }\n+\n+  static inline const TypeFunc *Math_DD_D_Type() {\n+    assert(_Math_DD_D_tf != nullptr, \"should be initialized\");\n+    return _Math_DD_D_tf;\n+  }\n+\n@@ -265,4 +508,0 @@\n-  static const TypeFunc* modf_Type();\n-  static const TypeFunc* l2f_Type();\n-  static const TypeFunc* void_long_Type();\n-  static const TypeFunc* void_void_Type();\n@@ -270,1 +509,19 @@\n-  static const TypeFunc* jfr_write_checkpoint_Type();\n+  static inline const TypeFunc *modf_Type() {\n+    assert(_modf_tf != nullptr, \"should be initialized\");\n+    return _modf_tf;\n+  }\n+\n+  static inline const TypeFunc *l2f_Type() {\n+    assert(_l2f_tf != nullptr, \"should be initialized\");\n+    return _l2f_tf;\n+  }\n+\n+  static inline const TypeFunc *void_long_Type() {\n+    assert(_void_long_tf != nullptr, \"should be initialized\");\n+    return _void_long_tf;\n+  }\n+\n+  static inline const TypeFunc *void_void_Type() {\n+    assert(_void_void_tf != nullptr, \"should be initialized\");\n+    return _void_void_tf;\n+  }\n@@ -272,1 +529,9 @@\n-  static const TypeFunc* flush_windows_Type();\n+  static const TypeFunc* jfr_write_checkpoint_Type() {\n+    assert(_jfr_write_checkpoint_tf != nullptr, \"should be initialized\");\n+    return _jfr_write_checkpoint_tf;\n+  }\n+\n+  static const TypeFunc* flush_windows_Type() {\n+    assert(_flush_windows_tf != nullptr, \"should be initialized\");\n+    return _flush_windows_tf;\n+  }\n@@ -275,4 +540,102 @@\n-  static const TypeFunc* fast_arraycopy_Type(); \/\/ bit-blasters\n-  static const TypeFunc* checkcast_arraycopy_Type();\n-  static const TypeFunc* generic_arraycopy_Type();\n-  static const TypeFunc* slow_arraycopy_Type();   \/\/ the full routine\n+  static inline const TypeFunc *fast_arraycopy_Type() {\n+    assert(_fast_arraycopy_tf != nullptr, \"should be initialized\");\n+    \/\/ This signature is simple:  Two base pointers and a size_t.\n+    return _fast_arraycopy_tf;\n+  }\n+\n+  static inline const TypeFunc* checkcast_arraycopy_Type() {\n+    assert(_checkcast_arraycopy_tf != nullptr, \"should be initialized\");\n+    \/\/ An extension of fast_arraycopy_Type which adds type checking.\n+    return _checkcast_arraycopy_tf;\n+  }\n+\n+  static inline const TypeFunc* generic_arraycopy_Type() {\n+    assert(_generic_arraycopy_tf != nullptr, \"should be initialized\");\n+    \/\/ This signature is like System.arraycopy, except that it returns status.\n+    return _generic_arraycopy_tf;\n+  }\n+\n+  static inline const TypeFunc* slow_arraycopy_Type() {\n+    assert(_slow_arraycopy_tf != nullptr, \"should be initialized\");\n+    \/\/ This signature is exactly the same as System.arraycopy.\n+    \/\/ There are no intptr_t (int\/long) arguments.\n+    return _slow_arraycopy_tf;\n+  }   \/\/ the full routine\n+\n+  static inline const TypeFunc* make_setmemory_Type() {\n+    assert(_make_setmemory_tf != nullptr, \"should be initialized\");\n+    return _make_setmemory_tf;\n+  }\n+\n+  static inline const TypeFunc* array_fill_Type() {\n+    assert(_array_fill_tf != nullptr, \"should be initialized\");\n+    return _array_fill_tf;\n+  }\n+\n+  static inline const TypeFunc* array_sort_Type() {\n+    assert(_array_sort_tf != nullptr, \"should be initialized\");\n+    return _array_sort_tf;\n+  }\n+\n+  static inline const TypeFunc* array_partition_Type() {\n+    assert(_array_partition_tf != nullptr, \"should be initialized\");\n+    return _array_partition_tf;\n+  }\n+\n+  \/\/ for aescrypt encrypt\/decrypt operations, just three pointers returning void (length is constant)\n+  static inline const TypeFunc* aescrypt_block_Type() {\n+    assert(_aescrypt_block_tf != nullptr, \"should be initialized\");\n+    return _aescrypt_block_tf;\n+  }\n+\n+  \/\/ for cipherBlockChaining calls of aescrypt encrypt\/decrypt, four pointers and a length, returning int\n+  static inline const TypeFunc* cipherBlockChaining_aescrypt_Type() {\n+    assert(_cipherBlockChaining_aescrypt_tf != nullptr, \"should be initialized\");\n+    return _cipherBlockChaining_aescrypt_tf;\n+  }\n+\n+  \/\/ for electronicCodeBook calls of aescrypt encrypt\/decrypt, three pointers and a length, returning int\n+  static inline const TypeFunc* electronicCodeBook_aescrypt_Type() {\n+    assert(_electronicCodeBook_aescrypt_tf != nullptr, \"should be initialized\");\n+    return _electronicCodeBook_aescrypt_tf;\n+  }\n+\n+  \/\/for counterMode calls of aescrypt encrypt\/decrypt, four pointers and a length, returning int\n+  static inline const TypeFunc* counterMode_aescrypt_Type() {\n+    assert(_counterMode_aescrypt_tf != nullptr, \"should be initialized\");\n+    return _counterMode_aescrypt_tf;\n+  }\n+\n+  \/\/for counterMode calls of aescrypt encrypt\/decrypt, four pointers and a length, returning int\n+  static inline const TypeFunc* galoisCounterMode_aescrypt_Type() {\n+    assert(_galoisCounterMode_aescrypt_tf != nullptr, \"should be initialized\");\n+    return _galoisCounterMode_aescrypt_tf;\n+  }\n+\n+  \/*\n+   * void implCompress(byte[] buf, int ofs)\n+   *\/\n+  static inline const TypeFunc* digestBase_implCompress_Type(bool is_sha3) {\n+    assert((_digestBase_implCompress_with_sha3_tf != nullptr) &&\n+           (_digestBase_implCompress_without_sha3_tf != nullptr), \"should be initialized\");\n+    return is_sha3 ? _digestBase_implCompress_with_sha3_tf : _digestBase_implCompress_without_sha3_tf;\n+  }\n+\n+  \/*\n+   * int implCompressMultiBlock(byte[] b, int ofs, int limit)\n+   *\/\n+  static inline const TypeFunc* digestBase_implCompressMB_Type(bool is_sha3) {\n+    assert((_digestBase_implCompressMB_with_sha3_tf != nullptr) &&\n+           (_digestBase_implCompressMB_without_sha3_tf != nullptr), \"should be initialized\");\n+    return is_sha3 ? _digestBase_implCompressMB_with_sha3_tf : _digestBase_implCompressMB_without_sha3_tf;\n+  }\n+\n+  static inline const TypeFunc* multiplyToLen_Type() {\n+    assert(_multiplyToLen_tf != nullptr, \"should be initialized\");\n+    return _multiplyToLen_tf;\n+  }\n+\n+  static inline const TypeFunc* montgomeryMultiply_Type() {\n+    assert(_montgomeryMultiply_tf != nullptr, \"should be initialized\");\n+    return _montgomeryMultiply_tf;\n+  }\n@@ -280,1 +643,4 @@\n-  static const TypeFunc* make_setmemory_Type();\n+  static inline const TypeFunc* montgomerySquare_Type() {\n+    assert(_montgomerySquare_tf != nullptr, \"should be initialized\");\n+    return _montgomerySquare_tf;\n+  }\n@@ -282,1 +648,4 @@\n-  static const TypeFunc* array_fill_Type();\n+  static inline const TypeFunc* squareToLen_Type() {\n+    assert(_squareToLen_tf != nullptr, \"should be initialized\");\n+    return _squareToLen_tf;\n+  }\n@@ -284,7 +653,5 @@\n-  static const TypeFunc* array_sort_Type();\n-  static const TypeFunc* array_partition_Type();\n-  static const TypeFunc* aescrypt_block_Type();\n-  static const TypeFunc* cipherBlockChaining_aescrypt_Type();\n-  static const TypeFunc* electronicCodeBook_aescrypt_Type();\n-  static const TypeFunc* counterMode_aescrypt_Type();\n-  static const TypeFunc* galoisCounterMode_aescrypt_Type();\n+  \/\/ for mulAdd calls, 2 pointers and 3 ints, returning int\n+  static inline const TypeFunc* mulAdd_Type() {\n+    assert(_mulAdd_tf != nullptr, \"should be initialized\");\n+    return _mulAdd_tf;\n+  }\n@@ -292,2 +659,15 @@\n-  static const TypeFunc* digestBase_implCompress_Type(bool is_sha3);\n-  static const TypeFunc* digestBase_implCompressMB_Type(bool is_sha3);\n+  static inline const TypeFunc* bigIntegerShift_Type() {\n+    assert(_bigIntegerShift_tf != nullptr, \"should be initialized\");\n+    return _bigIntegerShift_tf;\n+  }\n+\n+  static inline const TypeFunc* vectorizedMismatch_Type() {\n+    assert(_vectorizedMismatch_tf != nullptr, \"should be initialized\");\n+    return _vectorizedMismatch_tf;\n+  }\n+\n+  \/\/ GHASH block processing\n+  static inline const TypeFunc* ghash_processBlocks_Type() {\n+    assert(_ghash_processBlocks_tf != nullptr, \"should be initialized\");\n+    return _ghash_processBlocks_tf;\n+  }\n@@ -295,3 +675,5 @@\n-  static const TypeFunc* multiplyToLen_Type();\n-  static const TypeFunc* montgomeryMultiply_Type();\n-  static const TypeFunc* montgomerySquare_Type();\n+  \/\/ ChaCha20 Block function\n+  static inline const TypeFunc* chacha20Block_Type() {\n+    assert(_chacha20Block_tf != nullptr, \"should be initialized\");\n+    return _chacha20Block_tf;\n+  }\n@@ -299,1 +681,5 @@\n-  static const TypeFunc* squareToLen_Type();\n+  \/\/ Base64 encode function\n+  static inline const TypeFunc* base64_encodeBlock_Type() {\n+    assert(_base64_encodeBlock_tf != nullptr, \"should be initialized\");\n+    return _base64_encodeBlock_tf;\n+  }\n@@ -301,1 +687,5 @@\n-  static const TypeFunc* mulAdd_Type();\n+  \/\/ Base64 decode function\n+  static inline const TypeFunc* base64_decodeBlock_Type() {\n+    assert(_base64_decodeBlock_tf != nullptr, \"should be initialized\");\n+    return _base64_decodeBlock_tf;\n+  }\n@@ -303,1 +693,5 @@\n-  static const TypeFunc* bigIntegerShift_Type();\n+  \/\/ String IndexOf function\n+  static inline const TypeFunc* string_IndexOf_Type() {\n+    assert(_string_IndexOf_tf != nullptr, \"should be initialized\");\n+    return _string_IndexOf_tf;\n+  }\n@@ -305,1 +699,5 @@\n-  static const TypeFunc* vectorizedMismatch_Type();\n+  \/\/ Poly1305 processMultipleBlocks function\n+  static inline const TypeFunc* poly1305_processBlocks_Type() {\n+    assert(_poly1305_processBlocks_tf != nullptr, \"should be initialized\");\n+    return _poly1305_processBlocks_tf;\n+  }\n@@ -307,8 +705,5 @@\n-  static const TypeFunc* ghash_processBlocks_Type();\n-  static const TypeFunc* chacha20Block_Type();\n-  static const TypeFunc* base64_encodeBlock_Type();\n-  static const TypeFunc* base64_decodeBlock_Type();\n-  static const TypeFunc* string_IndexOf_Type();\n-  static const TypeFunc* poly1305_processBlocks_Type();\n-  static const TypeFunc* intpoly_montgomeryMult_P256_Type();\n-  static const TypeFunc* intpoly_assign_Type();\n+  \/\/ MontgomeryIntegerPolynomialP256 multiply function\n+  static inline const TypeFunc* intpoly_montgomeryMult_P256_Type() {\n+    assert(_intpoly_montgomeryMult_P256_tf != nullptr, \"should be initialized\");\n+    return _intpoly_montgomeryMult_P256_tf;\n+  }\n@@ -316,2 +711,29 @@\n-  static const TypeFunc* updateBytesCRC32_Type();\n-  static const TypeFunc* updateBytesCRC32C_Type();\n+  \/\/ IntegerPolynomial constant time assignment function\n+  static inline const TypeFunc* intpoly_assign_Type() {\n+    assert(_intpoly_assign_tf != nullptr, \"should be initialized\");\n+    return _intpoly_assign_tf;\n+  }\n+\n+  \/**\n+   * int updateBytesCRC32(int crc, byte* b, int len)\n+   *\/\n+  static inline const TypeFunc* updateBytesCRC32_Type() {\n+    assert(_updateBytesCRC32_tf != nullptr, \"should be initialized\");\n+    return _updateBytesCRC32_tf;\n+  }\n+\n+  \/**\n+   * int updateBytesCRC32C(int crc, byte* buf, int len, int* table)\n+   *\/\n+  static inline const TypeFunc* updateBytesCRC32C_Type() {\n+    assert(_updateBytesCRC32C_tf != nullptr, \"should be initialized\");\n+    return _updateBytesCRC32C_tf;\n+  }\n+\n+  \/**\n+   *  int updateBytesAdler32(int adler, bytes* b, int off, int len)\n+   *\/\n+  static inline const TypeFunc* updateBytesAdler32_Type() {\n+    assert(_updateBytesAdler32_tf != nullptr, \"should be initialized\");\n+    return _updateBytesAdler32_tf;\n+  }\n@@ -319,1 +741,0 @@\n-  static const TypeFunc* updateBytesAdler32_Type();\n@@ -322,1 +743,4 @@\n-  static const TypeFunc* osr_end_Type();\n+  static inline const TypeFunc* osr_end_Type() {\n+    assert(_osr_end_tf != nullptr, \"should be initialized\");\n+    return _osr_end_tf;\n+  }\n@@ -324,1 +748,11 @@\n-  static const TypeFunc* register_finalizer_Type();\n+  static inline const TypeFunc* register_finalizer_Type() {\n+    assert(_register_finalizer_tf != nullptr, \"should be initialized\");\n+    return _register_finalizer_tf;\n+  }\n+\n+#ifdef INCLUDE_JFR\n+  static inline const TypeFunc* class_id_load_barrier_Type() {\n+    assert(_class_id_load_barrier_tf != nullptr, \"should be initialized\");\n+    return _class_id_load_barrier_tf;\n+  }\n+#endif \/\/ INCLUDE_JFR\n@@ -326,1 +760,0 @@\n-  JFR_ONLY(static const TypeFunc* class_id_load_barrier_Type();)\n@@ -328,1 +761,4 @@\n-  static const TypeFunc* notify_jvmti_vthread_Type();\n+  static inline const TypeFunc* notify_jvmti_vthread_Type() {\n+    assert(_notify_jvmti_vthread_tf != nullptr, \"should be initialized\");\n+    return _notify_jvmti_vthread_tf;\n+  }\n@@ -331,3 +767,20 @@\n-  \/\/ Dtrace support\n-  static const TypeFunc* dtrace_method_entry_exit_Type();\n-  static const TypeFunc* dtrace_object_alloc_Type();\n+  \/\/ Dtrace support. entry and exit probes have the same signature\n+  static inline const TypeFunc* dtrace_method_entry_exit_Type() {\n+    assert(_dtrace_method_entry_exit_tf != nullptr, \"should be initialized\");\n+    return _dtrace_method_entry_exit_tf;\n+  }\n+\n+  static inline const TypeFunc* dtrace_object_alloc_Type() {\n+    assert(_dtrace_object_alloc_tf != nullptr, \"should be initialized\");\n+    return _dtrace_object_alloc_tf;\n+  }\n+\n+  static inline const TypeFunc* clone_type_Type() {\n+    assert(_clone_type_tf != nullptr, \"should be initialized\");\n+    return _clone_type_tf;\n+  }\n+\n+  static inline const TypeFunc* load_reference_barrier_Type() {\n+    assert(_load_reference_barrier_tf != nullptr, \"should be initialized\");\n+    return _load_reference_barrier_tf;\n+  }\n@@ -346,0 +799,1 @@\n+ static void          initialize_types();\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":518,"deletions":64,"binary":false,"changes":582,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+#include \"opto\/callnode.hpp\"\n+#include \"opto\/arraycopynode.hpp\"\n@@ -41,0 +43,1 @@\n+#include \"opto\/runtime.hpp\"\n@@ -713,0 +716,4 @@\n+  LockNode::lock_type_init();\n+  ArrayCopyNode::arraycopy_type_init();\n+  OptoRuntime::initialize_types();\n+\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"}]}