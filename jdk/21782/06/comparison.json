{"files":[{"patch":"@@ -823,16 +823,1 @@\n-  \/\/ Create input type (domain)\n-  int argcnt = NOT_LP64(3) LP64_ONLY(4);\n-  const Type** const domain_fields = TypeTuple::fields(argcnt);\n-  int argp = TypeFunc::Parms;\n-  domain_fields[argp++] = TypeInstPtr::NOTNULL;  \/\/ src\n-  domain_fields[argp++] = TypeInstPtr::NOTNULL;  \/\/ dst\n-  domain_fields[argp++] = TypeX_X;               \/\/ size lower\n-  LP64_ONLY(domain_fields[argp++] = Type::HALF); \/\/ size upper\n-  assert(argp == TypeFunc::Parms+argcnt, \"correct decoding\");\n-  const TypeTuple* const domain = TypeTuple::make(TypeFunc::Parms + argcnt, domain_fields);\n-\n-  \/\/ Create result type (range)\n-  const Type** const range_fields = TypeTuple::fields(0);\n-  const TypeTuple* const range = TypeTuple::make(TypeFunc::Parms + 0, range_fields);\n-\n-  return TypeFunc::make(domain, range);\n+  return OptoRuntime::clone_type_Type();\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -530,10 +530,1 @@\n-  const Type **fields = TypeTuple::fields(2);\n-  fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; \/\/ original field value\n-  fields[TypeFunc::Parms+1] = TypeRawPtr::NOTNULL; \/\/ thread\n-  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);\n-\n-  \/\/ create result type (range)\n-  fields = TypeTuple::fields(0);\n-  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);\n-\n-  return TypeFunc::make(domain, range);\n+  return OptoRuntime::write_ref_field_pre_Type();\n@@ -543,9 +534,1 @@\n-  const Type **fields = TypeTuple::fields(1);\n-  fields[TypeFunc::Parms+0] = TypeOopPtr::NOTNULL; \/\/ src oop\n-  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);\n-\n-  \/\/ create result type (range)\n-  fields = TypeTuple::fields(0);\n-  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);\n-\n-  return TypeFunc::make(domain, range);\n+  return OptoRuntime::clone_barrier_Type();\n@@ -555,12 +538,1 @@\n-  const Type **fields = TypeTuple::fields(2);\n-  fields[TypeFunc::Parms+0] = TypeOopPtr::BOTTOM; \/\/ original field value\n-  fields[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM; \/\/ original load address\n-\n-  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);\n-\n-  \/\/ create result type (range)\n-  fields = TypeTuple::fields(1);\n-  fields[TypeFunc::Parms+0] = TypeOopPtr::BOTTOM;\n-  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);\n-\n-  return TypeFunc::make(domain, range);\n+  return OptoRuntime::load_reference_barrier_Type();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":3,"deletions":31,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+const TypeFunc* ArrayCopyNode::_arraycopy_type_Type = nullptr;\n+\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+  static const TypeFunc* _arraycopy_type_Type;\n@@ -68,0 +69,2 @@\n+public:\n+\n@@ -69,0 +72,6 @@\n+    assert(_arraycopy_type_Type != nullptr, \"should be initialized\");\n+    return _arraycopy_type_Type;\n+  }\n+\n+  static void arraycopy_type_init() {\n+    assert(_arraycopy_type_Type == nullptr, \"should be\");\n@@ -86,1 +95,1 @@\n-    return TypeFunc::make(domain, range);\n+    _arraycopy_type_Type =  TypeFunc::make(domain, range);\n@@ -89,0 +98,1 @@\n+private:\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1669,0 +1669,2 @@\n+const TypeFunc* LockNode::_lock_type_Type = nullptr;\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1193,0 +1193,1 @@\n+  static const TypeFunc *_lock_type_Type;\n@@ -1195,1 +1196,7 @@\n-  static const TypeFunc *lock_type() {\n+  static inline const TypeFunc *lock_type() {\n+    assert(_lock_type_Type != nullptr, \"should be initialized\");\n+    return _lock_type_Type;\n+  }\n+\n+  static void lock_type_init() {\n+    assert(_lock_type_Type == nullptr, \"should be called once\");\n@@ -1208,1 +1215,1 @@\n-    return TypeFunc::make(domain,range);\n+    _lock_type_Type = TypeFunc::make(domain,range);\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -5134,1 +5134,1 @@\n-                    OptoRuntime::make_setmemory_Type(),\n+                    OptoRuntime::unsafe_setmemory_Type(),\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -195,0 +195,70 @@\n+const TypeFunc* OptoRuntime::_new_instance_Type                   = nullptr;\n+const TypeFunc* OptoRuntime::_new_array_Type                      = nullptr;\n+const TypeFunc* OptoRuntime::_multianewarray2_Type                = nullptr;\n+const TypeFunc* OptoRuntime::_multianewarray4_Type                = nullptr;\n+const TypeFunc* OptoRuntime::_multianewarray3_Type                = nullptr;\n+const TypeFunc* OptoRuntime::_multianewarray5_Type                = nullptr;\n+const TypeFunc* OptoRuntime::_multianewarrayN_Type                = nullptr;\n+const TypeFunc* OptoRuntime::_complete_monitor_enter_Type         = nullptr;\n+const TypeFunc* OptoRuntime::_complete_monitor_exit_Type          = nullptr;\n+const TypeFunc* OptoRuntime::_monitor_notify_Type                 = nullptr;\n+const TypeFunc* OptoRuntime::_uncommon_trap_Type                  = nullptr;\n+const TypeFunc* OptoRuntime::_athrow_Type                         = nullptr;\n+const TypeFunc* OptoRuntime::_rethrow_Type                        = nullptr;\n+const TypeFunc* OptoRuntime::_Math_D_D_Type                       = nullptr;\n+const TypeFunc* OptoRuntime::_Math_DD_D_Type                      = nullptr;\n+const TypeFunc* OptoRuntime::_modf_Type                           = nullptr;\n+const TypeFunc* OptoRuntime::_l2f_Type                            = nullptr;\n+const TypeFunc* OptoRuntime::_void_long_Type                      = nullptr;\n+const TypeFunc* OptoRuntime::_void_void_Type                      = nullptr;\n+const TypeFunc* OptoRuntime::_jfr_write_checkpoint_Type           = nullptr;\n+const TypeFunc* OptoRuntime::_flush_windows_Type                  = nullptr;\n+const TypeFunc* OptoRuntime::_fast_arraycopy_Type                 = nullptr;\n+const TypeFunc* OptoRuntime::_checkcast_arraycopy_Type            = nullptr;\n+const TypeFunc* OptoRuntime::_generic_arraycopy_Type              = nullptr;\n+const TypeFunc* OptoRuntime::_slow_arraycopy_Type                 = nullptr;\n+const TypeFunc* OptoRuntime::_unsafe_setmemory_Type               = nullptr;\n+const TypeFunc* OptoRuntime::_array_fill_Type                     = nullptr;\n+const TypeFunc* OptoRuntime::_array_sort_Type                     = nullptr;\n+const TypeFunc* OptoRuntime::_array_partition_Type                = nullptr;\n+const TypeFunc* OptoRuntime::_aescrypt_block_Type                 = nullptr;\n+const TypeFunc* OptoRuntime::_cipherBlockChaining_aescrypt_Type   = nullptr;\n+const TypeFunc* OptoRuntime::_electronicCodeBook_aescrypt_Type    = nullptr;\n+const TypeFunc* OptoRuntime::_counterMode_aescrypt_Type           = nullptr;\n+const TypeFunc* OptoRuntime::_galoisCounterMode_aescrypt_Type     = nullptr;\n+const TypeFunc* OptoRuntime::_digestBase_implCompress_with_sha3_Type      = nullptr;\n+const TypeFunc* OptoRuntime::_digestBase_implCompress_without_sha3_Type   = nullptr;\n+const TypeFunc* OptoRuntime::_digestBase_implCompressMB_with_sha3_Type    = nullptr;\n+const TypeFunc* OptoRuntime::_digestBase_implCompressMB_without_sha3_Type = nullptr;\n+const TypeFunc* OptoRuntime::_multiplyToLen_Type                  = nullptr;\n+const TypeFunc* OptoRuntime::_montgomeryMultiply_Type             = nullptr;\n+const TypeFunc* OptoRuntime::_montgomerySquare_Type               = nullptr;\n+const TypeFunc* OptoRuntime::_squareToLen_Type                    = nullptr;\n+const TypeFunc* OptoRuntime::_mulAdd_Type                         = nullptr;\n+const TypeFunc* OptoRuntime::_bigIntegerShift_Type                = nullptr;\n+const TypeFunc* OptoRuntime::_vectorizedMismatch_Type             = nullptr;\n+const TypeFunc* OptoRuntime::_ghash_processBlocks_Type            = nullptr;\n+const TypeFunc* OptoRuntime::_chacha20Block_Type                  = nullptr;\n+const TypeFunc* OptoRuntime::_base64_encodeBlock_Type             = nullptr;\n+const TypeFunc* OptoRuntime::_base64_decodeBlock_Type             = nullptr;\n+const TypeFunc* OptoRuntime::_string_IndexOf_Type                 = nullptr;\n+const TypeFunc* OptoRuntime::_poly1305_processBlocks_Type         = nullptr;\n+const TypeFunc* OptoRuntime::_intpoly_montgomeryMult_P256_Type    = nullptr;\n+const TypeFunc* OptoRuntime::_intpoly_assign_Type                 = nullptr;\n+const TypeFunc* OptoRuntime::_updateBytesCRC32_Type               = nullptr;\n+const TypeFunc* OptoRuntime::_updateBytesCRC32C_Type              = nullptr;\n+const TypeFunc* OptoRuntime::_updateBytesAdler32_Type             = nullptr;\n+const TypeFunc* OptoRuntime::_osr_end_Type                        = nullptr;\n+const TypeFunc* OptoRuntime::_register_finalizer_Type             = nullptr;\n+JFR_ONLY(\n+  const TypeFunc* OptoRuntime::_class_id_load_barrier_Type        = nullptr;\n+)\n+#ifdef INCLUDE_JVMTI\n+const TypeFunc* OptoRuntime::_notify_jvmti_vthread_Type           = nullptr;\n+#endif \/\/ INCLUDE_JVMTI\n+const TypeFunc* OptoRuntime::_dtrace_method_entry_exit_Type       = nullptr;\n+const TypeFunc* OptoRuntime::_dtrace_object_alloc_Type            = nullptr;\n+const TypeFunc* OptoRuntime::_clone_type_Type                     = nullptr;\n+const TypeFunc* OptoRuntime::_load_reference_barrier_Type         = nullptr;\n+const TypeFunc* OptoRuntime::_write_ref_field_pre_Type            = nullptr;\n+const TypeFunc* OptoRuntime::_clone_barrier_Type                  = nullptr;\n@@ -501,1 +571,1 @@\n-const TypeFunc *OptoRuntime::new_instance_Type() {\n+static const TypeFunc* make_new_instance_Type() {\n@@ -517,1 +587,1 @@\n-const TypeFunc *OptoRuntime::notify_jvmti_vthread_Type() {\n+static const TypeFunc* make_notify_jvmti_vthread_Type() {\n@@ -533,1 +603,1 @@\n-const TypeFunc *OptoRuntime::athrow_Type() {\n+static const TypeFunc* make_athrow_Type() {\n@@ -547,2 +617,1 @@\n-\n-const TypeFunc *OptoRuntime::new_array_Type() {\n+static const TypeFunc* make_new_array_Type() {\n@@ -564,4 +633,0 @@\n-const TypeFunc *OptoRuntime::new_array_nozero_Type() {\n-  return new_array_Type();\n-}\n-\n@@ -585,17 +650,1 @@\n-const TypeFunc *OptoRuntime::multianewarray2_Type() {\n-  return multianewarray_Type(2);\n-}\n-\n-const TypeFunc *OptoRuntime::multianewarray3_Type() {\n-  return multianewarray_Type(3);\n-}\n-\n-const TypeFunc *OptoRuntime::multianewarray4_Type() {\n-  return multianewarray_Type(4);\n-}\n-\n-const TypeFunc *OptoRuntime::multianewarray5_Type() {\n-  return multianewarray_Type(5);\n-}\n-\n-const TypeFunc *OptoRuntime::multianewarrayN_Type() {\n+static const TypeFunc* make_multianewarrayN_Type() {\n@@ -616,1 +665,1 @@\n-const TypeFunc *OptoRuntime::uncommon_trap_Type() {\n+static const TypeFunc* make_uncommon_trap_Type() {\n@@ -631,1 +680,2 @@\n-const TypeFunc *OptoRuntime::complete_monitor_enter_Type() {\n+\n+static const TypeFunc* make_complete_monitor_enter_Type() {\n@@ -646,4 +696,0 @@\n-const TypeFunc *OptoRuntime::complete_monitor_locking_Type() {\n-  return complete_monitor_enter_Type();\n-}\n-\n@@ -651,1 +697,2 @@\n-const TypeFunc *OptoRuntime::complete_monitor_exit_Type() {\n+\n+static const TypeFunc* make_complete_monitor_exit_Type() {\n@@ -667,1 +714,1 @@\n-const TypeFunc *OptoRuntime::monitor_notify_Type() {\n+static const TypeFunc* make_monitor_notify_Type() {\n@@ -679,5 +726,1 @@\n-const TypeFunc *OptoRuntime::monitor_notifyAll_Type() {\n-  return monitor_notify_Type();\n-}\n-\n-const TypeFunc* OptoRuntime::flush_windows_Type() {\n+static const TypeFunc* make_flush_windows_Type() {\n@@ -697,1 +740,1 @@\n-const TypeFunc* OptoRuntime::l2f_Type() {\n+static const TypeFunc* make_l2f_Type() {\n@@ -712,1 +755,1 @@\n-const TypeFunc* OptoRuntime::modf_Type() {\n+static const TypeFunc* make_modf_Type() {\n@@ -727,1 +770,1 @@\n-const TypeFunc *OptoRuntime::Math_D_D_Type() {\n+static const TypeFunc* make_Math_D_D_Type() {\n@@ -763,1 +806,1 @@\n-const TypeFunc* OptoRuntime::Math_DD_D_Type() {\n+static const TypeFunc* make_Math_DD_D_Type() {\n@@ -782,1 +825,1 @@\n-const TypeFunc* OptoRuntime::void_long_Type() {\n+static const TypeFunc* make_void_long_Type() {\n@@ -796,4 +839,4 @@\n-const TypeFunc* OptoRuntime::void_void_Type() {\n-   \/\/ create input type (domain)\n-   const Type **fields = TypeTuple::fields(0);\n-   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+0, fields);\n+static const TypeFunc* make_void_void_Type() {\n+  \/\/ create input type (domain)\n+  const Type **fields = TypeTuple::fields(0);\n+  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+0, fields);\n@@ -801,5 +844,5 @@\n-   \/\/ create result type (range)\n-   fields = TypeTuple::fields(0);\n-   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);\n-   return TypeFunc::make(domain, range);\n- }\n+  \/\/ create result type (range)\n+  fields = TypeTuple::fields(0);\n+  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);\n+  return TypeFunc::make(domain, range);\n+}\n@@ -807,4 +850,4 @@\n- const TypeFunc* OptoRuntime::jfr_write_checkpoint_Type() {\n-   \/\/ create input type (domain)\n-   const Type **fields = TypeTuple::fields(0);\n-   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms, fields);\n+static const TypeFunc* make_jfr_write_checkpoint_Type() {\n+  \/\/ create input type (domain)\n+  const Type **fields = TypeTuple::fields(0);\n+  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms, fields);\n@@ -812,5 +855,5 @@\n-   \/\/ create result type (range)\n-   fields = TypeTuple::fields(0);\n-   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms, fields);\n-   return TypeFunc::make(domain, range);\n- }\n+  \/\/ create result type (range)\n+  fields = TypeTuple::fields(0);\n+  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms, fields);\n+  return TypeFunc::make(domain, range);\n+}\n@@ -823,1 +866,2 @@\n-const TypeFunc* OptoRuntime::make_setmemory_Type() {\n+\n+static const TypeFunc* make_setmemory_Type() {\n@@ -888,23 +932,1 @@\n-const TypeFunc* OptoRuntime::fast_arraycopy_Type() {\n-  \/\/ This signature is simple:  Two base pointers and a size_t.\n-  return make_arraycopy_Type(ac_fast);\n-}\n-\n-const TypeFunc* OptoRuntime::checkcast_arraycopy_Type() {\n-  \/\/ An extension of fast_arraycopy_Type which adds type checking.\n-  return make_arraycopy_Type(ac_checkcast);\n-}\n-\n-const TypeFunc* OptoRuntime::slow_arraycopy_Type() {\n-  \/\/ This signature is exactly the same as System.arraycopy.\n-  \/\/ There are no intptr_t (int\/long) arguments.\n-  return make_arraycopy_Type(ac_slow);\n-}\n-\n-const TypeFunc* OptoRuntime::generic_arraycopy_Type() {\n-  \/\/ This signature is like System.arraycopy, except that it returns status.\n-  return make_arraycopy_Type(ac_generic);\n-}\n-\n-\n-const TypeFunc* OptoRuntime::array_fill_Type() {\n+static const TypeFunc* make_array_fill_Type() {\n@@ -929,1 +951,1 @@\n-const TypeFunc* OptoRuntime::array_partition_Type() {\n+static const TypeFunc* make_array_partition_Type() {\n@@ -952,1 +974,1 @@\n-const TypeFunc* OptoRuntime::array_sort_Type() {\n+static const TypeFunc* make_array_sort_Type() {\n@@ -972,2 +994,1 @@\n-\/\/ for aescrypt encrypt\/decrypt operations, just three pointers returning void (length is constant)\n-const TypeFunc* OptoRuntime::aescrypt_block_Type() {\n+static const TypeFunc* make_aescrypt_block_Type() {\n@@ -992,4 +1013,1 @@\n-\/**\n- * int updateBytesCRC32(int crc, byte* b, int len)\n- *\/\n-const TypeFunc* OptoRuntime::updateBytesCRC32_Type() {\n+static const TypeFunc* make_updateBytesCRC32_Type() {\n@@ -1014,4 +1032,1 @@\n-\/**\n- * int updateBytesCRC32C(int crc, byte* buf, int len, int* table)\n- *\/\n-const TypeFunc* OptoRuntime::updateBytesCRC32C_Type() {\n+static const TypeFunc* make_updateBytesCRC32C_Type() {\n@@ -1037,4 +1052,1 @@\n-\/**\n-*  int updateBytesAdler32(int adler, bytes* b, int off, int len)\n-*\/\n-const TypeFunc* OptoRuntime::updateBytesAdler32_Type() {\n+static const TypeFunc* make_updateBytesAdler32_Type() {\n@@ -1059,2 +1071,1 @@\n-\/\/ for cipherBlockChaining calls of aescrypt encrypt\/decrypt, four pointers and a length, returning int\n-const TypeFunc* OptoRuntime::cipherBlockChaining_aescrypt_Type() {\n+static const TypeFunc* make_cipherBlockChaining_aescrypt_Type() {\n@@ -1081,2 +1092,1 @@\n-\/\/ for electronicCodeBook calls of aescrypt encrypt\/decrypt, three pointers and a length, returning int\n-const TypeFunc* OptoRuntime::electronicCodeBook_aescrypt_Type() {\n+static const TypeFunc* make_electronicCodeBook_aescrypt_Type() {\n@@ -1102,2 +1112,1 @@\n-\/\/for counterMode calls of aescrypt encrypt\/decrypt, four pointers and a length, returning int\n-const TypeFunc* OptoRuntime::counterMode_aescrypt_Type() {\n+static const TypeFunc* make_counterMode_aescrypt_Type() {\n@@ -1125,2 +1134,1 @@\n-\/\/for counterMode calls of aescrypt encrypt\/decrypt, four pointers and a length, returning int\n-const TypeFunc* OptoRuntime::galoisCounterMode_aescrypt_Type() {\n+static const TypeFunc* make_galoisCounterMode_aescrypt_Type() {\n@@ -1150,4 +1158,1 @@\n-\/*\n- * void implCompress(byte[] buf, int ofs)\n- *\/\n-const TypeFunc* OptoRuntime::digestBase_implCompress_Type(bool is_sha3) {\n+static const TypeFunc* make_digestBase_implCompress_Type(bool is_sha3) {\n@@ -1172,4 +1177,1 @@\n-\/*\n- * int implCompressMultiBlock(byte[] b, int ofs, int limit)\n- *\/\n-const TypeFunc* OptoRuntime::digestBase_implCompressMB_Type(bool is_sha3) {\n+static const TypeFunc* make_digestBase_implCompressMB_Type(bool is_sha3) {\n@@ -1196,1 +1198,1 @@\n-const TypeFunc* OptoRuntime::multiplyToLen_Type() {\n+static const TypeFunc* make_multiplyToLen_Type() {\n@@ -1217,1 +1219,1 @@\n-const TypeFunc* OptoRuntime::squareToLen_Type() {\n+static const TypeFunc* make_squareToLen_Type() {\n@@ -1237,2 +1239,1 @@\n-\/\/ for mulAdd calls, 2 pointers and 3 ints, returning int\n-const TypeFunc* OptoRuntime::mulAdd_Type() {\n+static const TypeFunc* make_mulAdd_Type() {\n@@ -1259,1 +1260,1 @@\n-const TypeFunc* OptoRuntime::montgomeryMultiply_Type() {\n+static const TypeFunc* make_montgomeryMultiply_Type() {\n@@ -1283,1 +1284,1 @@\n-const TypeFunc* OptoRuntime::montgomerySquare_Type() {\n+static const TypeFunc* make_montgomerySquare_Type() {\n@@ -1306,1 +1307,1 @@\n-const TypeFunc * OptoRuntime::bigIntegerShift_Type() {\n+static const TypeFunc* make_bigIntegerShift_Type() {\n@@ -1325,1 +1326,1 @@\n-const TypeFunc* OptoRuntime::vectorizedMismatch_Type() {\n+static const TypeFunc* make_vectorizedMismatch_Type() {\n@@ -1345,3 +1346,2 @@\n-\/\/ GHASH block processing\n-const TypeFunc* OptoRuntime::ghash_processBlocks_Type() {\n-    int argcnt = 4;\n+static const TypeFunc* make_ghash_processBlocks_Type() {\n+  int argcnt = 4;\n@@ -1349,8 +1349,8 @@\n-    const Type** fields = TypeTuple::fields(argcnt);\n-    int argp = TypeFunc::Parms;\n-    fields[argp++] = TypePtr::NOTNULL;    \/\/ state\n-    fields[argp++] = TypePtr::NOTNULL;    \/\/ subkeyH\n-    fields[argp++] = TypePtr::NOTNULL;    \/\/ data\n-    fields[argp++] = TypeInt::INT;        \/\/ blocks\n-    assert(argp == TypeFunc::Parms+argcnt, \"correct decoding\");\n-    const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);\n+  const Type** fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ state\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ subkeyH\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ data\n+  fields[argp++] = TypeInt::INT;        \/\/ blocks\n+  assert(argp == TypeFunc::Parms+argcnt, \"correct decoding\");\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);\n@@ -1358,5 +1358,5 @@\n-    \/\/ result type needed\n-    fields = TypeTuple::fields(1);\n-    fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n-    const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);\n-    return TypeFunc::make(domain, range);\n+  \/\/ result type needed\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);\n+  return TypeFunc::make(domain, range);\n@@ -1365,3 +1365,2 @@\n-\/\/ ChaCha20 Block function\n-const TypeFunc* OptoRuntime::chacha20Block_Type() {\n-    int argcnt = 2;\n+static const TypeFunc* make_chacha20Block_Type() {\n+  int argcnt = 2;\n@@ -1369,4 +1368,4 @@\n-    const Type** fields = TypeTuple::fields(argcnt);\n-    int argp = TypeFunc::Parms;\n-    fields[argp++] = TypePtr::NOTNULL;      \/\/ state\n-    fields[argp++] = TypePtr::NOTNULL;      \/\/ result\n+  const Type** fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  fields[argp++] = TypePtr::NOTNULL;      \/\/ state\n+  fields[argp++] = TypePtr::NOTNULL;      \/\/ result\n@@ -1374,2 +1373,2 @@\n-    assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n-    const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);\n+  assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);\n@@ -1377,5 +1376,5 @@\n-    \/\/ result type needed\n-    fields = TypeTuple::fields(1);\n-    fields[TypeFunc::Parms + 0] = TypeInt::INT;     \/\/ key stream outlen as int\n-    const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);\n-    return TypeFunc::make(domain, range);\n+  \/\/ result type needed\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms + 0] = TypeInt::INT;     \/\/ key stream outlen as int\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);\n+  return TypeFunc::make(domain, range);\n@@ -1384,2 +1383,1 @@\n-\/\/ Base64 encode function\n-const TypeFunc* OptoRuntime::base64_encodeBlock_Type() {\n+static const TypeFunc* make_base64_encodeBlock_Type() {\n@@ -1406,2 +1404,1 @@\n-\/\/ String IndexOf function\n-const TypeFunc* OptoRuntime::string_IndexOf_Type() {\n+static const TypeFunc* make_string_IndexOf_Type() {\n@@ -1426,2 +1423,1 @@\n-\/\/ Base64 decode function\n-const TypeFunc* OptoRuntime::base64_decodeBlock_Type() {\n+static const TypeFunc* make_base64_decodeBlock_Type() {\n@@ -1449,2 +1445,1 @@\n-\/\/ Poly1305 processMultipleBlocks function\n-const TypeFunc* OptoRuntime::poly1305_processBlocks_Type() {\n+static const TypeFunc* make_poly1305_processBlocks_Type() {\n@@ -1469,2 +1464,1 @@\n-\/\/ MontgomeryIntegerPolynomialP256 multiply function\n-const TypeFunc* OptoRuntime::intpoly_montgomeryMult_P256_Type() {\n+static const TypeFunc* make_intpoly_montgomeryMult_P256_Type() {\n@@ -1488,2 +1482,1 @@\n-\/\/ IntegerPolynomial constant time assignment function\n-const TypeFunc* OptoRuntime::intpoly_assign_Type() {\n+static const TypeFunc* make_intpoly_assign_Type() {\n@@ -1508,2 +1501,2 @@\n-\/\/------------- Interpreter state access for on stack replacement\n-const TypeFunc* OptoRuntime::osr_end_Type() {\n+\/\/------------- Interpreter state for on stack replacement\n+static const TypeFunc* make_osr_end_Type() {\n@@ -1755,2 +1748,1 @@\n-\n-const TypeFunc *OptoRuntime::rethrow_Type() {\n+static const TypeFunc* make_rethrow_Type() {\n@@ -1806,2 +1798,1 @@\n-\n-const TypeFunc *OptoRuntime::register_finalizer_Type() {\n+static const TypeFunc* make_register_finalizer_Type() {\n@@ -1824,1 +1815,1 @@\n-const TypeFunc *OptoRuntime::class_id_load_barrier_Type() {\n+static const TypeFunc* make_class_id_load_barrier_Type() {\n@@ -1837,1 +1828,1 @@\n-#endif\n+#endif \/\/ INCLUDE_JFR\n@@ -1840,2 +1831,1 @@\n-\/\/ Dtrace support.  entry and exit probes have the same signature\n-const TypeFunc *OptoRuntime::dtrace_method_entry_exit_Type() {\n+static const TypeFunc* make_dtrace_method_entry_exit_Type() {\n@@ -1856,1 +1846,1 @@\n-const TypeFunc *OptoRuntime::dtrace_object_alloc_Type() {\n+static const TypeFunc* make_dtrace_object_alloc_Type() {\n@@ -1872,0 +1862,58 @@\n+static const TypeFunc* make_clone_type_Type() {\n+  \/\/ Create input type (domain)\n+  int argcnt = NOT_LP64(3) LP64_ONLY(4);\n+  const Type** const domain_fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  domain_fields[argp++] = TypeInstPtr::NOTNULL;  \/\/ src\n+  domain_fields[argp++] = TypeInstPtr::NOTNULL;  \/\/ dst\n+  domain_fields[argp++] = TypeX_X;               \/\/ size lower\n+  LP64_ONLY(domain_fields[argp++] = Type::HALF); \/\/ size upper\n+  assert(argp == TypeFunc::Parms+argcnt, \"correct decoding\");\n+  const TypeTuple* const domain = TypeTuple::make(TypeFunc::Parms + argcnt, domain_fields);\n+\n+  \/\/ Create result type (range)\n+  const Type** const range_fields = TypeTuple::fields(0);\n+  const TypeTuple* const range = TypeTuple::make(TypeFunc::Parms + 0, range_fields);\n+\n+  return TypeFunc::make(domain, range);\n+}\n+\n+static const TypeFunc* make_load_reference_barrier_Type() {\n+  const Type **fields = TypeTuple::fields(2);\n+  fields[TypeFunc::Parms+0] = TypeOopPtr::BOTTOM; \/\/ original field value\n+  fields[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM; \/\/ original load address\n+\n+  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);\n+\n+  \/\/ create result type (range)\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms+0] = TypeOopPtr::BOTTOM;\n+  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);\n+\n+  return TypeFunc::make(domain, range);\n+}\n+\n+static const TypeFunc* make_write_ref_field_pre_Type() {\n+  const Type **fields = TypeTuple::fields(2);\n+  fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; \/\/ original field value\n+  fields[TypeFunc::Parms+1] = TypeRawPtr::NOTNULL; \/\/ thread\n+  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);\n+\n+  \/\/ create result type (range)\n+  fields = TypeTuple::fields(0);\n+  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);\n+\n+  return TypeFunc::make(domain, range);\n+}\n+\n+static const TypeFunc* make_clone_barrier_Type() {\n+  const Type **fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms+0] = TypeOopPtr::NOTNULL; \/\/ src oop\n+  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);\n+\n+  \/\/ create result type (range)\n+  fields = TypeTuple::fields(0);\n+  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);\n+\n+  return TypeFunc::make(domain, range);\n+}\n@@ -1958,0 +2006,73 @@\n+void OptoRuntime::initialize_types() {\n+  _new_instance_Type                  = make_new_instance_Type();\n+  _new_array_Type                     = make_new_array_Type();\n+  _multianewarray2_Type               = multianewarray_Type(2);\n+  _multianewarray4_Type               = multianewarray_Type(3);\n+  _multianewarray3_Type               = multianewarray_Type(4);\n+  _multianewarray5_Type               = multianewarray_Type(5);\n+  _multianewarrayN_Type               = make_multianewarrayN_Type();\n+  _complete_monitor_enter_Type        = make_complete_monitor_enter_Type();\n+  _complete_monitor_exit_Type         = make_complete_monitor_exit_Type();\n+  _monitor_notify_Type                = make_monitor_notify_Type();\n+  _uncommon_trap_Type                 = make_uncommon_trap_Type();\n+  _athrow_Type                        = make_athrow_Type();\n+  _rethrow_Type                       = make_rethrow_Type();\n+  _Math_D_D_Type                      = make_Math_D_D_Type();\n+  _Math_DD_D_Type                     = make_Math_DD_D_Type();\n+  _modf_Type                          = make_modf_Type();\n+  _l2f_Type                           = make_l2f_Type();\n+  _void_long_Type                     = make_void_long_Type();\n+  _void_void_Type                     = make_void_void_Type();\n+  _jfr_write_checkpoint_Type          = make_jfr_write_checkpoint_Type();\n+  _flush_windows_Type                 = make_flush_windows_Type();\n+  _fast_arraycopy_Type                = make_arraycopy_Type(ac_fast);\n+  _checkcast_arraycopy_Type           = make_arraycopy_Type(ac_checkcast);\n+  _generic_arraycopy_Type             = make_arraycopy_Type(ac_generic);\n+  _slow_arraycopy_Type                = make_arraycopy_Type(ac_slow);\n+  _unsafe_setmemory_Type              = make_setmemory_Type();\n+  _array_fill_Type                    = make_array_fill_Type();\n+  _array_sort_Type                    = make_array_sort_Type();\n+  _array_partition_Type               = make_array_partition_Type();\n+  _aescrypt_block_Type                = make_aescrypt_block_Type();\n+  _cipherBlockChaining_aescrypt_Type  = make_cipherBlockChaining_aescrypt_Type();\n+  _electronicCodeBook_aescrypt_Type   = make_electronicCodeBook_aescrypt_Type();\n+  _counterMode_aescrypt_Type          = make_counterMode_aescrypt_Type();\n+  _galoisCounterMode_aescrypt_Type    = make_galoisCounterMode_aescrypt_Type();\n+  _digestBase_implCompress_with_sha3_Type      = make_digestBase_implCompress_Type(  \/* is_sha3= *\/ true);\n+  _digestBase_implCompress_without_sha3_Type   = make_digestBase_implCompress_Type(  \/* is_sha3= *\/ false);;\n+  _digestBase_implCompressMB_with_sha3_Type    = make_digestBase_implCompressMB_Type(\/* is_sha3= *\/ true);\n+  _digestBase_implCompressMB_without_sha3_Type = make_digestBase_implCompressMB_Type(\/* is_sha3= *\/ false);\n+  _multiplyToLen_Type                 = make_multiplyToLen_Type();\n+  _montgomeryMultiply_Type            = make_montgomeryMultiply_Type();\n+  _montgomerySquare_Type              = make_montgomerySquare_Type();\n+  _squareToLen_Type                   = make_squareToLen_Type();\n+  _mulAdd_Type                        = make_mulAdd_Type();\n+  _bigIntegerShift_Type               = make_bigIntegerShift_Type();\n+  _vectorizedMismatch_Type            = make_vectorizedMismatch_Type();\n+  _ghash_processBlocks_Type           = make_ghash_processBlocks_Type();\n+  _chacha20Block_Type                 = make_chacha20Block_Type();\n+  _base64_encodeBlock_Type            = make_base64_encodeBlock_Type();\n+  _base64_decodeBlock_Type            = make_base64_decodeBlock_Type();\n+  _string_IndexOf_Type                = make_string_IndexOf_Type();\n+  _poly1305_processBlocks_Type        = make_poly1305_processBlocks_Type();\n+  _intpoly_montgomeryMult_P256_Type   = make_intpoly_montgomeryMult_P256_Type();\n+  _intpoly_assign_Type                = make_intpoly_assign_Type();\n+  _updateBytesCRC32_Type              = make_updateBytesCRC32_Type();\n+  _updateBytesCRC32C_Type             = make_updateBytesCRC32C_Type();\n+  _updateBytesAdler32_Type            = make_updateBytesAdler32_Type();\n+  _osr_end_Type                       = make_osr_end_Type();\n+  _register_finalizer_Type            = make_register_finalizer_Type();\n+  JFR_ONLY(\n+    _class_id_load_barrier_Type       = make_class_id_load_barrier_Type();\n+  )\n+#ifdef INCLUDE_JVMTI\n+  _notify_jvmti_vthread_Type          = make_notify_jvmti_vthread_Type();\n+#endif \/\/ INCLUDE_JVMTI\n+  _dtrace_method_entry_exit_Type      = make_dtrace_method_entry_exit_Type();\n+  _dtrace_object_alloc_Type           = make_dtrace_object_alloc_Type();\n+  _clone_type_Type                    = make_clone_type_Type();\n+  _load_reference_barrier_Type        = make_load_reference_barrier_Type();\n+  _write_ref_field_pre_Type           = make_write_ref_field_pre_Type();\n+  _clone_barrier_Type                 = make_clone_barrier_Type();\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":300,"deletions":179,"binary":false,"changes":479,"status":"modified"},{"patch":"@@ -134,0 +134,70 @@\n+  \/\/ static TypeFunc* data members\n+  static const TypeFunc *_new_instance_Type;\n+  static const TypeFunc *_new_array_Type;\n+  static const TypeFunc *_multianewarray2_Type;\n+  static const TypeFunc *_multianewarray3_Type;\n+  static const TypeFunc *_multianewarray4_Type;\n+  static const TypeFunc *_multianewarray5_Type;\n+  static const TypeFunc *_multianewarrayN_Type;\n+  static const TypeFunc *_complete_monitor_enter_Type;\n+  static const TypeFunc *_complete_monitor_exit_Type;\n+  static const TypeFunc *_monitor_notify_Type;\n+  static const TypeFunc *_uncommon_trap_Type;\n+  static const TypeFunc *_athrow_Type;\n+  static const TypeFunc *_rethrow_Type;\n+  static const TypeFunc *_Math_D_D_Type;\n+  static const TypeFunc *_Math_DD_D_Type;\n+  static const TypeFunc *_modf_Type;\n+  static const TypeFunc *_l2f_Type;\n+  static const TypeFunc *_void_long_Type;\n+  static const TypeFunc *_void_void_Type;\n+  static const TypeFunc *_jfr_write_checkpoint_Type;\n+  static const TypeFunc *_flush_windows_Type;\n+  static const TypeFunc *_fast_arraycopy_Type;\n+  static const TypeFunc *_checkcast_arraycopy_Type;\n+  static const TypeFunc *_generic_arraycopy_Type;\n+  static const TypeFunc *_slow_arraycopy_Type;\n+  static const TypeFunc *_unsafe_setmemory_Type;\n+  static const TypeFunc *_array_fill_Type;\n+  static const TypeFunc *_array_sort_Type;\n+  static const TypeFunc *_array_partition_Type;\n+  static const TypeFunc *_aescrypt_block_Type;\n+  static const TypeFunc *_cipherBlockChaining_aescrypt_Type;\n+  static const TypeFunc *_electronicCodeBook_aescrypt_Type;\n+  static const TypeFunc *_counterMode_aescrypt_Type;\n+  static const TypeFunc *_galoisCounterMode_aescrypt_Type;\n+  static const TypeFunc *_digestBase_implCompress_with_sha3_Type;\n+  static const TypeFunc *_digestBase_implCompress_without_sha3_Type;\n+  static const TypeFunc *_digestBase_implCompressMB_with_sha3_Type;\n+  static const TypeFunc *_digestBase_implCompressMB_without_sha3_Type;\n+  static const TypeFunc *_multiplyToLen_Type;\n+  static const TypeFunc *_montgomeryMultiply_Type;\n+  static const TypeFunc *_montgomerySquare_Type;\n+  static const TypeFunc *_squareToLen_Type;\n+  static const TypeFunc *_mulAdd_Type;\n+  static const TypeFunc *_bigIntegerShift_Type;\n+  static const TypeFunc *_vectorizedMismatch_Type;\n+  static const TypeFunc *_ghash_processBlocks_Type;\n+  static const TypeFunc *_chacha20Block_Type;\n+  static const TypeFunc *_base64_encodeBlock_Type;\n+  static const TypeFunc *_base64_decodeBlock_Type;\n+  static const TypeFunc *_string_IndexOf_Type;\n+  static const TypeFunc *_poly1305_processBlocks_Type;\n+  static const TypeFunc *_intpoly_montgomeryMult_P256_Type;\n+  static const TypeFunc *_intpoly_assign_Type;\n+  static const TypeFunc *_updateBytesCRC32_Type;\n+  static const TypeFunc *_updateBytesCRC32C_Type;\n+  static const TypeFunc *_updateBytesAdler32_Type;\n+  static const TypeFunc *_osr_end_Type;\n+  static const TypeFunc *_register_finalizer_Type;\n+  JFR_ONLY(static const TypeFunc *_class_id_load_barrier_Type;)\n+#ifdef INCLUDE_JVMTI\n+  static const TypeFunc *_notify_jvmti_vthread_Type;\n+#endif \/\/ INCLUDE_JVMTI\n+  static const TypeFunc *_dtrace_method_entry_exit_Type;\n+  static const TypeFunc *_dtrace_object_alloc_Type;\n+  static const TypeFunc *_clone_type_Type;\n+  static const TypeFunc *_load_reference_barrier_Type;\n+  static const TypeFunc *_write_ref_field_pre_Type;\n+  static const TypeFunc *_clone_barrier_Type;\n+\n@@ -245,3 +315,24 @@\n-  static const TypeFunc* new_instance_Type(); \/\/ object allocation (slow case)\n-  static const TypeFunc* new_array_Type ();   \/\/ [a]newarray (slow case)\n-  static const TypeFunc* new_array_nozero_Type ();   \/\/ [a]newarray (slow case)\n+  static inline const TypeFunc *clone_barrier_Type() {\n+    assert(_clone_barrier_Type != nullptr, \"should be initialized\");\n+    return _clone_barrier_Type;\n+  }\n+\n+  static inline const TypeFunc *write_ref_field_pre_Type() {\n+    assert(_write_ref_field_pre_Type != nullptr, \"should be initialized\");\n+    return _write_ref_field_pre_Type;\n+  }\n+\n+  static inline const TypeFunc *new_instance_Type() {\n+    assert(_new_instance_Type != nullptr, \"should be initialized\");\n+    return _new_instance_Type;\n+  }\n+\n+  static inline const TypeFunc *new_array_Type() {\n+    assert(_new_array_Type != nullptr, \"should be initialized\");\n+    return _new_array_Type;\n+  }\n+\n+  static inline const TypeFunc *new_array_nozero_Type() {\n+    return new_array_Type();\n+  }\n+\n@@ -249,15 +340,74 @@\n-  static const TypeFunc* multianewarray2_Type(); \/\/ multianewarray\n-  static const TypeFunc* multianewarray3_Type(); \/\/ multianewarray\n-  static const TypeFunc* multianewarray4_Type(); \/\/ multianewarray\n-  static const TypeFunc* multianewarray5_Type(); \/\/ multianewarray\n-  static const TypeFunc* multianewarrayN_Type(); \/\/ multianewarray\n-  static const TypeFunc* complete_monitor_enter_Type();\n-  static const TypeFunc* complete_monitor_locking_Type();\n-  static const TypeFunc* complete_monitor_exit_Type();\n-  static const TypeFunc* monitor_notify_Type();\n-  static const TypeFunc* monitor_notifyAll_Type();\n-  static const TypeFunc* uncommon_trap_Type();\n-  static const TypeFunc* athrow_Type();\n-  static const TypeFunc* rethrow_Type();\n-  static const TypeFunc* Math_D_D_Type();  \/\/ sin,cos & friends\n-  static const TypeFunc* Math_DD_D_Type(); \/\/ mod,pow & friends\n+\n+  static inline const TypeFunc *multianewarray2_Type() {\n+    assert(_multianewarray2_Type != nullptr, \"should be initialized\");\n+    return _multianewarray2_Type;\n+  }\n+\n+  static inline const TypeFunc *multianewarray3_Type() {\n+    assert(_multianewarray3_Type != nullptr, \"should be initialized\");\n+    return _multianewarray3_Type;\n+  }\n+\n+  static inline const TypeFunc *multianewarray4_Type() {\n+    assert(_multianewarray4_Type != nullptr, \"should be initialized\");\n+    return _multianewarray4_Type;\n+  }\n+\n+  static inline const TypeFunc *multianewarray5_Type() {\n+    assert(_multianewarray5_Type != nullptr, \"should be initialized\");\n+    return _multianewarray5_Type;\n+  }\n+\n+  static inline const TypeFunc *multianewarrayN_Type() {\n+    assert(_multianewarrayN_Type != nullptr, \"should be initialized\");\n+    return _multianewarrayN_Type;\n+  }\n+\n+  static inline const TypeFunc *complete_monitor_enter_Type() {\n+    assert(_complete_monitor_enter_Type != nullptr, \"should be initialized\");\n+    return _complete_monitor_enter_Type;\n+  }\n+\n+  static inline const TypeFunc *complete_monitor_locking_Type() {\n+    return complete_monitor_enter_Type();\n+  }\n+\n+  static inline const TypeFunc *complete_monitor_exit_Type() {\n+    assert(_complete_monitor_exit_Type != nullptr, \"should be initialized\");\n+    return _complete_monitor_exit_Type;\n+  }\n+\n+  static inline const TypeFunc *monitor_notify_Type() {\n+    assert(_monitor_notify_Type != nullptr, \"should be initialized\");\n+    return _monitor_notify_Type;\n+  }\n+\n+  static inline const TypeFunc *monitor_notifyAll_Type() {\n+    return monitor_notify_Type();\n+  }\n+\n+  static inline const TypeFunc *uncommon_trap_Type() {\n+    assert(_uncommon_trap_Type != nullptr, \"should be initialized\");\n+    return _uncommon_trap_Type;\n+  }\n+\n+  static inline const TypeFunc *athrow_Type() {\n+    assert(_athrow_Type != nullptr, \"should be initialized\");\n+    return _athrow_Type;\n+  }\n+\n+  static inline const TypeFunc *rethrow_Type() {\n+    assert(_rethrow_Type != nullptr, \"should be initialized\");\n+    return _rethrow_Type;\n+  }\n+\n+  static inline const TypeFunc *Math_D_D_Type() {\n+    assert(_Math_D_D_Type != nullptr, \"should be initialized\");\n+    return _Math_D_D_Type;\n+  }\n+\n+  static inline const TypeFunc *Math_DD_D_Type() {\n+    assert(_Math_DD_D_Type != nullptr, \"should be initialized\");\n+    return _Math_DD_D_Type;\n+  }\n+\n@@ -265,4 +415,0 @@\n-  static const TypeFunc* modf_Type();\n-  static const TypeFunc* l2f_Type();\n-  static const TypeFunc* void_long_Type();\n-  static const TypeFunc* void_void_Type();\n@@ -270,1 +416,4 @@\n-  static const TypeFunc* jfr_write_checkpoint_Type();\n+  static inline const TypeFunc *modf_Type() {\n+    assert(_modf_Type != nullptr, \"should be initialized\");\n+    return _modf_Type;\n+  }\n@@ -272,1 +421,24 @@\n-  static const TypeFunc* flush_windows_Type();\n+  static inline const TypeFunc *l2f_Type() {\n+    assert(_l2f_Type != nullptr, \"should be initialized\");\n+    return _l2f_Type;\n+  }\n+\n+  static inline const TypeFunc *void_long_Type() {\n+    assert(_void_long_Type != nullptr, \"should be initialized\");\n+    return _void_long_Type;\n+  }\n+\n+  static inline const TypeFunc *void_void_Type() {\n+    assert(_void_void_Type != nullptr, \"should be initialized\");\n+    return _void_void_Type;\n+  }\n+\n+  static const TypeFunc* jfr_write_checkpoint_Type() {\n+    assert(_jfr_write_checkpoint_Type != nullptr, \"should be initialized\");\n+    return _jfr_write_checkpoint_Type;\n+  }\n+\n+  static const TypeFunc* flush_windows_Type() {\n+    assert(_flush_windows_Type != nullptr, \"should be initialized\");\n+    return _flush_windows_Type;\n+  }\n@@ -275,4 +447,5 @@\n-  static const TypeFunc* fast_arraycopy_Type(); \/\/ bit-blasters\n-  static const TypeFunc* checkcast_arraycopy_Type();\n-  static const TypeFunc* generic_arraycopy_Type();\n-  static const TypeFunc* slow_arraycopy_Type();   \/\/ the full routine\n+  static inline const TypeFunc *fast_arraycopy_Type() {\n+    assert(_fast_arraycopy_Type != nullptr, \"should be initialized\");\n+    \/\/ This signature is simple:  Two base pointers and a size_t.\n+    return _fast_arraycopy_Type;\n+  }\n@@ -280,1 +453,5 @@\n-  static const TypeFunc* make_setmemory_Type();\n+  static inline const TypeFunc* checkcast_arraycopy_Type() {\n+    assert(_checkcast_arraycopy_Type != nullptr, \"should be initialized\");\n+    \/\/ An extension of fast_arraycopy_Type which adds type checking.\n+    return _checkcast_arraycopy_Type;\n+  }\n@@ -282,1 +459,5 @@\n-  static const TypeFunc* array_fill_Type();\n+  static inline const TypeFunc* generic_arraycopy_Type() {\n+    assert(_generic_arraycopy_Type != nullptr, \"should be initialized\");\n+    \/\/ This signature is like System.arraycopy, except that it returns status.\n+    return _generic_arraycopy_Type;\n+  }\n@@ -284,7 +465,6 @@\n-  static const TypeFunc* array_sort_Type();\n-  static const TypeFunc* array_partition_Type();\n-  static const TypeFunc* aescrypt_block_Type();\n-  static const TypeFunc* cipherBlockChaining_aescrypt_Type();\n-  static const TypeFunc* electronicCodeBook_aescrypt_Type();\n-  static const TypeFunc* counterMode_aescrypt_Type();\n-  static const TypeFunc* galoisCounterMode_aescrypt_Type();\n+  static inline const TypeFunc* slow_arraycopy_Type() {\n+    assert(_slow_arraycopy_Type != nullptr, \"should be initialized\");\n+    \/\/ This signature is exactly the same as System.arraycopy.\n+    \/\/ There are no intptr_t (int\/long) arguments.\n+    return _slow_arraycopy_Type;\n+  }   \/\/ the full routine\n@@ -292,2 +472,4 @@\n-  static const TypeFunc* digestBase_implCompress_Type(bool is_sha3);\n-  static const TypeFunc* digestBase_implCompressMB_Type(bool is_sha3);\n+  static inline const TypeFunc* unsafe_setmemory_Type() {\n+    assert(_unsafe_setmemory_Type != nullptr, \"should be initialized\");\n+    return _unsafe_setmemory_Type;\n+  }\n@@ -295,3 +477,4 @@\n-  static const TypeFunc* multiplyToLen_Type();\n-  static const TypeFunc* montgomeryMultiply_Type();\n-  static const TypeFunc* montgomerySquare_Type();\n+  static inline const TypeFunc* array_fill_Type() {\n+    assert(_array_fill_Type != nullptr, \"should be initialized\");\n+    return _array_fill_Type;\n+  }\n@@ -299,1 +482,4 @@\n-  static const TypeFunc* squareToLen_Type();\n+  static inline const TypeFunc* array_sort_Type() {\n+    assert(_array_sort_Type != nullptr, \"should be initialized\");\n+    return _array_sort_Type;\n+  }\n@@ -301,1 +487,4 @@\n-  static const TypeFunc* mulAdd_Type();\n+  static inline const TypeFunc* array_partition_Type() {\n+    assert(_array_partition_Type != nullptr, \"should be initialized\");\n+    return _array_partition_Type;\n+  }\n@@ -303,1 +492,89 @@\n-  static const TypeFunc* bigIntegerShift_Type();\n+  \/\/ for aescrypt encrypt\/decrypt operations, just three pointers returning void (length is constant)\n+  static inline const TypeFunc* aescrypt_block_Type() {\n+    assert(_aescrypt_block_Type != nullptr, \"should be initialized\");\n+    return _aescrypt_block_Type;\n+  }\n+\n+  \/\/ for cipherBlockChaining calls of aescrypt encrypt\/decrypt, four pointers and a length, returning int\n+  static inline const TypeFunc* cipherBlockChaining_aescrypt_Type() {\n+    assert(_cipherBlockChaining_aescrypt_Type != nullptr, \"should be initialized\");\n+    return _cipherBlockChaining_aescrypt_Type;\n+  }\n+\n+  \/\/ for electronicCodeBook calls of aescrypt encrypt\/decrypt, three pointers and a length, returning int\n+  static inline const TypeFunc* electronicCodeBook_aescrypt_Type() {\n+    assert(_electronicCodeBook_aescrypt_Type != nullptr, \"should be initialized\");\n+    return _electronicCodeBook_aescrypt_Type;\n+  }\n+\n+  \/\/for counterMode calls of aescrypt encrypt\/decrypt, four pointers and a length, returning int\n+  static inline const TypeFunc* counterMode_aescrypt_Type() {\n+    assert(_counterMode_aescrypt_Type != nullptr, \"should be initialized\");\n+    return _counterMode_aescrypt_Type;\n+  }\n+\n+  \/\/for counterMode calls of aescrypt encrypt\/decrypt, four pointers and a length, returning int\n+  static inline const TypeFunc* galoisCounterMode_aescrypt_Type() {\n+    assert(_galoisCounterMode_aescrypt_Type != nullptr, \"should be initialized\");\n+    return _galoisCounterMode_aescrypt_Type;\n+  }\n+\n+  \/*\n+   * void implCompress(byte[] buf, int ofs)\n+   *\/\n+  static inline const TypeFunc* digestBase_implCompress_Type(bool is_sha3) {\n+    assert((_digestBase_implCompress_with_sha3_Type != nullptr) &&\n+           (_digestBase_implCompress_without_sha3_Type != nullptr), \"should be initialized\");\n+    return is_sha3 ? _digestBase_implCompress_with_sha3_Type : _digestBase_implCompress_without_sha3_Type;\n+  }\n+\n+  \/*\n+   * int implCompressMultiBlock(byte[] b, int ofs, int limit)\n+   *\/\n+  static inline const TypeFunc* digestBase_implCompressMB_Type(bool is_sha3) {\n+    assert((_digestBase_implCompressMB_with_sha3_Type != nullptr) &&\n+           (_digestBase_implCompressMB_without_sha3_Type != nullptr), \"should be initialized\");\n+    return is_sha3 ? _digestBase_implCompressMB_with_sha3_Type : _digestBase_implCompressMB_without_sha3_Type;\n+  }\n+\n+  static inline const TypeFunc* multiplyToLen_Type() {\n+    assert(_multiplyToLen_Type != nullptr, \"should be initialized\");\n+    return _multiplyToLen_Type;\n+  }\n+\n+  static inline const TypeFunc* montgomeryMultiply_Type() {\n+    assert(_montgomeryMultiply_Type != nullptr, \"should be initialized\");\n+    return _montgomeryMultiply_Type;\n+  }\n+\n+  static inline const TypeFunc* montgomerySquare_Type() {\n+    assert(_montgomerySquare_Type != nullptr, \"should be initialized\");\n+    return _montgomerySquare_Type;\n+  }\n+\n+  static inline const TypeFunc* squareToLen_Type() {\n+    assert(_squareToLen_Type != nullptr, \"should be initialized\");\n+    return _squareToLen_Type;\n+  }\n+\n+  \/\/ for mulAdd calls, 2 pointers and 3 ints, returning int\n+  static inline const TypeFunc* mulAdd_Type() {\n+    assert(_mulAdd_Type != nullptr, \"should be initialized\");\n+    return _mulAdd_Type;\n+  }\n+\n+  static inline const TypeFunc* bigIntegerShift_Type() {\n+    assert(_bigIntegerShift_Type != nullptr, \"should be initialized\");\n+    return _bigIntegerShift_Type;\n+  }\n+\n+  static inline const TypeFunc* vectorizedMismatch_Type() {\n+    assert(_vectorizedMismatch_Type != nullptr, \"should be initialized\");\n+    return _vectorizedMismatch_Type;\n+  }\n+\n+  \/\/ GHASH block processing\n+  static inline const TypeFunc* ghash_processBlocks_Type() {\n+    assert(_ghash_processBlocks_Type != nullptr, \"should be initialized\");\n+    return _ghash_processBlocks_Type;\n+  }\n@@ -305,1 +582,17 @@\n-  static const TypeFunc* vectorizedMismatch_Type();\n+  \/\/ ChaCha20 Block function\n+  static inline const TypeFunc* chacha20Block_Type() {\n+    assert(_chacha20Block_Type != nullptr, \"should be initialized\");\n+    return _chacha20Block_Type;\n+  }\n+\n+  \/\/ Base64 encode function\n+  static inline const TypeFunc* base64_encodeBlock_Type() {\n+    assert(_base64_encodeBlock_Type != nullptr, \"should be initialized\");\n+    return _base64_encodeBlock_Type;\n+  }\n+\n+  \/\/ Base64 decode function\n+  static inline const TypeFunc* base64_decodeBlock_Type() {\n+    assert(_base64_decodeBlock_Type != nullptr, \"should be initialized\");\n+    return _base64_decodeBlock_Type;\n+  }\n@@ -307,8 +600,5 @@\n-  static const TypeFunc* ghash_processBlocks_Type();\n-  static const TypeFunc* chacha20Block_Type();\n-  static const TypeFunc* base64_encodeBlock_Type();\n-  static const TypeFunc* base64_decodeBlock_Type();\n-  static const TypeFunc* string_IndexOf_Type();\n-  static const TypeFunc* poly1305_processBlocks_Type();\n-  static const TypeFunc* intpoly_montgomeryMult_P256_Type();\n-  static const TypeFunc* intpoly_assign_Type();\n+  \/\/ String IndexOf function\n+  static inline const TypeFunc* string_IndexOf_Type() {\n+    assert(_string_IndexOf_Type != nullptr, \"should be initialized\");\n+    return _string_IndexOf_Type;\n+  }\n@@ -316,2 +606,41 @@\n-  static const TypeFunc* updateBytesCRC32_Type();\n-  static const TypeFunc* updateBytesCRC32C_Type();\n+  \/\/ Poly1305 processMultipleBlocks function\n+  static inline const TypeFunc* poly1305_processBlocks_Type() {\n+    assert(_poly1305_processBlocks_Type != nullptr, \"should be initialized\");\n+    return _poly1305_processBlocks_Type;\n+  }\n+\n+  \/\/ MontgomeryIntegerPolynomialP256 multiply function\n+  static inline const TypeFunc* intpoly_montgomeryMult_P256_Type() {\n+    assert(_intpoly_montgomeryMult_P256_Type != nullptr, \"should be initialized\");\n+    return _intpoly_montgomeryMult_P256_Type;\n+  }\n+\n+  \/\/ IntegerPolynomial constant time assignment function\n+  static inline const TypeFunc* intpoly_assign_Type() {\n+    assert(_intpoly_assign_Type != nullptr, \"should be initialized\");\n+    return _intpoly_assign_Type;\n+  }\n+\n+  \/**\n+   * int updateBytesCRC32(int crc, byte* b, int len)\n+   *\/\n+  static inline const TypeFunc* updateBytesCRC32_Type() {\n+    assert(_updateBytesCRC32_Type != nullptr, \"should be initialized\");\n+    return _updateBytesCRC32_Type;\n+  }\n+\n+  \/**\n+   * int updateBytesCRC32C(int crc, byte* buf, int len, int* table)\n+   *\/\n+  static inline const TypeFunc* updateBytesCRC32C_Type() {\n+    assert(_updateBytesCRC32C_Type != nullptr, \"should be initialized\");\n+    return _updateBytesCRC32C_Type;\n+  }\n+\n+  \/**\n+   *  int updateBytesAdler32(int adler, bytes* b, int off, int len)\n+   *\/\n+  static inline const TypeFunc* updateBytesAdler32_Type() {\n+    assert(_updateBytesAdler32_Type != nullptr, \"should be initialized\");\n+    return _updateBytesAdler32_Type;\n+  }\n@@ -319,1 +648,0 @@\n-  static const TypeFunc* updateBytesAdler32_Type();\n@@ -322,1 +650,4 @@\n-  static const TypeFunc* osr_end_Type();\n+  static inline const TypeFunc* osr_end_Type() {\n+    assert(_osr_end_Type != nullptr, \"should be initialized\");\n+    return _osr_end_Type;\n+  }\n@@ -324,1 +655,11 @@\n-  static const TypeFunc* register_finalizer_Type();\n+  static inline const TypeFunc* register_finalizer_Type() {\n+    assert(_register_finalizer_Type != nullptr, \"should be initialized\");\n+    return _register_finalizer_Type;\n+  }\n+\n+#ifdef INCLUDE_JFR\n+  static inline const TypeFunc* class_id_load_barrier_Type() {\n+    assert(_class_id_load_barrier_Type != nullptr, \"should be initialized\");\n+    return _class_id_load_barrier_Type;\n+  }\n+#endif \/\/ INCLUDE_JFR\n@@ -326,1 +667,0 @@\n-  JFR_ONLY(static const TypeFunc* class_id_load_barrier_Type();)\n@@ -328,1 +668,4 @@\n-  static const TypeFunc* notify_jvmti_vthread_Type();\n+  static inline const TypeFunc* notify_jvmti_vthread_Type() {\n+    assert(_notify_jvmti_vthread_Type != nullptr, \"should be initialized\");\n+    return _notify_jvmti_vthread_Type;\n+  }\n@@ -331,3 +674,20 @@\n-  \/\/ Dtrace support\n-  static const TypeFunc* dtrace_method_entry_exit_Type();\n-  static const TypeFunc* dtrace_object_alloc_Type();\n+  \/\/ Dtrace support. entry and exit probes have the same signature\n+  static inline const TypeFunc* dtrace_method_entry_exit_Type() {\n+    assert(_dtrace_method_entry_exit_Type != nullptr, \"should be initialized\");\n+    return _dtrace_method_entry_exit_Type;\n+  }\n+\n+  static inline const TypeFunc* dtrace_object_alloc_Type() {\n+    assert(_dtrace_object_alloc_Type != nullptr, \"should be initialized\");\n+    return _dtrace_object_alloc_Type;\n+  }\n+\n+  static inline const TypeFunc* clone_type_Type() {\n+    assert(_clone_type_Type != nullptr, \"should be initialized\");\n+    return _clone_type_Type;\n+  }\n+\n+  static inline const TypeFunc* load_reference_barrier_Type() {\n+    assert(_load_reference_barrier_Type != nullptr, \"should be initialized\");\n+    return _load_reference_barrier_Type;\n+  }\n@@ -346,0 +706,1 @@\n+ static void          initialize_types();\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":425,"deletions":64,"binary":false,"changes":489,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+#include \"opto\/callnode.hpp\"\n+#include \"opto\/arraycopynode.hpp\"\n@@ -41,0 +43,1 @@\n+#include \"opto\/runtime.hpp\"\n@@ -713,0 +716,4 @@\n+  LockNode::lock_type_init();\n+  ArrayCopyNode::arraycopy_type_init();\n+  OptoRuntime::initialize_types();\n+\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"}]}