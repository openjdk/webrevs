{"files":[{"patch":"@@ -36,1 +36,1 @@\n-const TypeFunc* ArrayCopyNode::_arraycopy_type_tf = nullptr;\n+const TypeFunc* ArrayCopyNode::_arraycopy_type_Type = nullptr;\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-  static const TypeFunc* _arraycopy_type_tf;\n+  static const TypeFunc* _arraycopy_type_Type;\n@@ -72,2 +72,2 @@\n-    assert(_arraycopy_type_tf != nullptr, \"should be initialized\");\n-    return _arraycopy_type_tf;\n+    assert(_arraycopy_type_Type != nullptr, \"should be initialized\");\n+    return _arraycopy_type_Type;\n@@ -77,1 +77,1 @@\n-    assert(_arraycopy_type_tf == nullptr, \"should be\");\n+    assert(_arraycopy_type_Type == nullptr, \"should be\");\n@@ -95,1 +95,1 @@\n-    _arraycopy_type_tf =  TypeFunc::make(domain, range);\n+    _arraycopy_type_Type =  TypeFunc::make(domain, range);\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1669,1 +1669,1 @@\n-const TypeFunc* LockNode::_lock_type_tf = nullptr;\n+const TypeFunc* LockNode::_lock_type_Type = nullptr;\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1193,1 +1193,1 @@\n-  static const TypeFunc *_lock_type_tf;\n+  static const TypeFunc *_lock_type_Type;\n@@ -1197,2 +1197,2 @@\n-    assert(_lock_type_tf != nullptr, \"should be initialized\");\n-    return _lock_type_tf;\n+    assert(_lock_type_Type != nullptr, \"should be initialized\");\n+    return _lock_type_Type;\n@@ -1202,1 +1202,1 @@\n-    assert(_lock_type_tf == nullptr, \"should be called once\");\n+    assert(_lock_type_Type == nullptr, \"should be called once\");\n@@ -1215,1 +1215,1 @@\n-    _lock_type_tf = TypeFunc::make(domain,range);\n+    _lock_type_Type = TypeFunc::make(domain,range);\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -5134,1 +5134,1 @@\n-                    OptoRuntime::make_setmemory_Type(),\n+                    OptoRuntime::unsafe_setmemory_Type(),\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -195,59 +195,61 @@\n-const TypeFunc* OptoRuntime::_new_instance_tf = nullptr;\n-const TypeFunc* OptoRuntime::_new_array_tf = nullptr;\n-const TypeFunc* OptoRuntime::_multianewarray2_tf = nullptr;\n-const TypeFunc* OptoRuntime::_multianewarray4_tf = nullptr;\n-const TypeFunc* OptoRuntime::_multianewarray3_tf = nullptr;\n-const TypeFunc* OptoRuntime::_multianewarray5_tf = nullptr;\n-const TypeFunc* OptoRuntime::_multianewarrayN_tf = nullptr;\n-const TypeFunc* OptoRuntime::_complete_monitor_enter_tf = nullptr;\n-const TypeFunc* OptoRuntime::_complete_monitor_exit_tf = nullptr;\n-const TypeFunc* OptoRuntime::_monitor_notify_tf = nullptr;\n-const TypeFunc* OptoRuntime::_uncommon_trap_tf = nullptr;\n-const TypeFunc* OptoRuntime::_athrow_tf = nullptr;\n-const TypeFunc* OptoRuntime::_rethrow_tf = nullptr;\n-const TypeFunc* OptoRuntime::_Math_D_D_tf = nullptr;\n-const TypeFunc* OptoRuntime::_Math_DD_D_tf = nullptr;\n-const TypeFunc* OptoRuntime::_modf_tf = nullptr;\n-const TypeFunc* OptoRuntime::_l2f_tf = nullptr;\n-const TypeFunc* OptoRuntime::_void_long_tf = nullptr;\n-const TypeFunc* OptoRuntime::_void_void_tf = nullptr;\n-const TypeFunc* OptoRuntime::_jfr_write_checkpoint_tf = nullptr;\n-const TypeFunc* OptoRuntime::_flush_windows_tf = nullptr;\n-const TypeFunc* OptoRuntime::_fast_arraycopy_tf = nullptr;\n-const TypeFunc* OptoRuntime::_checkcast_arraycopy_tf = nullptr;\n-const TypeFunc* OptoRuntime::_generic_arraycopy_tf = nullptr;\n-const TypeFunc* OptoRuntime::_slow_arraycopy_tf = nullptr;\n-const TypeFunc* OptoRuntime::_make_setmemory_tf = nullptr;\n-const TypeFunc* OptoRuntime::_array_fill_tf = nullptr;\n-const TypeFunc* OptoRuntime::_array_sort_tf = nullptr;\n-const TypeFunc* OptoRuntime::_array_partition_tf = nullptr;\n-const TypeFunc* OptoRuntime::_aescrypt_block_tf = nullptr;\n-const TypeFunc* OptoRuntime::_cipherBlockChaining_aescrypt_tf = nullptr;\n-const TypeFunc* OptoRuntime::_electronicCodeBook_aescrypt_tf = nullptr;\n-const TypeFunc* OptoRuntime::_counterMode_aescrypt_tf = nullptr;\n-const TypeFunc* OptoRuntime::_galoisCounterMode_aescrypt_tf = nullptr;\n-const TypeFunc* OptoRuntime::_digestBase_implCompress_with_sha3_tf = nullptr;\n-const TypeFunc* OptoRuntime::_digestBase_implCompress_without_sha3_tf = nullptr;\n-const TypeFunc* OptoRuntime::_digestBase_implCompressMB_with_sha3_tf = nullptr;\n-const TypeFunc* OptoRuntime::_digestBase_implCompressMB_without_sha3_tf = nullptr;\n-const TypeFunc* OptoRuntime::_multiplyToLen_tf = nullptr;\n-const TypeFunc* OptoRuntime::_montgomeryMultiply_tf = nullptr;\n-const TypeFunc* OptoRuntime::_montgomerySquare_tf = nullptr;\n-const TypeFunc* OptoRuntime::_squareToLen_tf = nullptr;\n-const TypeFunc* OptoRuntime::_mulAdd_tf = nullptr;\n-const TypeFunc* OptoRuntime::_bigIntegerShift_tf = nullptr;\n-const TypeFunc* OptoRuntime::_vectorizedMismatch_tf = nullptr;\n-const TypeFunc* OptoRuntime::_ghash_processBlocks_tf = nullptr;\n-const TypeFunc* OptoRuntime::_chacha20Block_tf = nullptr;\n-const TypeFunc* OptoRuntime::_base64_encodeBlock_tf = nullptr;\n-const TypeFunc* OptoRuntime::_base64_decodeBlock_tf = nullptr;\n-const TypeFunc* OptoRuntime::_string_IndexOf_tf = nullptr;\n-const TypeFunc* OptoRuntime::_poly1305_processBlocks_tf = nullptr;\n-const TypeFunc* OptoRuntime::_intpoly_montgomeryMult_P256_tf = nullptr;\n-const TypeFunc* OptoRuntime::_intpoly_assign_tf = nullptr;\n-const TypeFunc* OptoRuntime::_updateBytesCRC32_tf = nullptr;\n-const TypeFunc* OptoRuntime::_updateBytesCRC32C_tf = nullptr;\n-const TypeFunc* OptoRuntime::_updateBytesAdler32_tf = nullptr;\n-const TypeFunc* OptoRuntime::_osr_end_tf = nullptr;\n-const TypeFunc* OptoRuntime::_register_finalizer_tf = nullptr;\n-JFR_ONLY(const TypeFunc* OptoRuntime::_class_id_load_barrier_tf = nullptr;)\n+const TypeFunc* OptoRuntime::_new_instance_Type                   = nullptr;\n+const TypeFunc* OptoRuntime::_new_array_Type                      = nullptr;\n+const TypeFunc* OptoRuntime::_multianewarray2_Type                = nullptr;\n+const TypeFunc* OptoRuntime::_multianewarray4_Type                = nullptr;\n+const TypeFunc* OptoRuntime::_multianewarray3_Type                = nullptr;\n+const TypeFunc* OptoRuntime::_multianewarray5_Type                = nullptr;\n+const TypeFunc* OptoRuntime::_multianewarrayN_Type                = nullptr;\n+const TypeFunc* OptoRuntime::_complete_monitor_enter_Type         = nullptr;\n+const TypeFunc* OptoRuntime::_complete_monitor_exit_Type          = nullptr;\n+const TypeFunc* OptoRuntime::_monitor_notify_Type                 = nullptr;\n+const TypeFunc* OptoRuntime::_uncommon_trap_Type                  = nullptr;\n+const TypeFunc* OptoRuntime::_athrow_Type                         = nullptr;\n+const TypeFunc* OptoRuntime::_rethrow_Type                        = nullptr;\n+const TypeFunc* OptoRuntime::_Math_D_D_Type                       = nullptr;\n+const TypeFunc* OptoRuntime::_Math_DD_D_Type                      = nullptr;\n+const TypeFunc* OptoRuntime::_modf_Type                           = nullptr;\n+const TypeFunc* OptoRuntime::_l2f_Type                            = nullptr;\n+const TypeFunc* OptoRuntime::_void_long_Type                      = nullptr;\n+const TypeFunc* OptoRuntime::_void_void_Type                      = nullptr;\n+const TypeFunc* OptoRuntime::_jfr_write_checkpoint_Type           = nullptr;\n+const TypeFunc* OptoRuntime::_flush_windows_Type                  = nullptr;\n+const TypeFunc* OptoRuntime::_fast_arraycopy_Type                 = nullptr;\n+const TypeFunc* OptoRuntime::_checkcast_arraycopy_Type            = nullptr;\n+const TypeFunc* OptoRuntime::_generic_arraycopy_Type              = nullptr;\n+const TypeFunc* OptoRuntime::_slow_arraycopy_Type                 = nullptr;\n+const TypeFunc* OptoRuntime::_unsafe_setmemory_Type               = nullptr;\n+const TypeFunc* OptoRuntime::_array_fill_Type                     = nullptr;\n+const TypeFunc* OptoRuntime::_array_sort_Type                     = nullptr;\n+const TypeFunc* OptoRuntime::_array_partition_Type                = nullptr;\n+const TypeFunc* OptoRuntime::_aescrypt_block_Type                 = nullptr;\n+const TypeFunc* OptoRuntime::_cipherBlockChaining_aescrypt_Type   = nullptr;\n+const TypeFunc* OptoRuntime::_electronicCodeBook_aescrypt_Type    = nullptr;\n+const TypeFunc* OptoRuntime::_counterMode_aescrypt_Type           = nullptr;\n+const TypeFunc* OptoRuntime::_galoisCounterMode_aescrypt_Type     = nullptr;\n+const TypeFunc* OptoRuntime::_digestBase_implCompress_with_sha3_Type      = nullptr;\n+const TypeFunc* OptoRuntime::_digestBase_implCompress_without_sha3_Type   = nullptr;\n+const TypeFunc* OptoRuntime::_digestBase_implCompressMB_with_sha3_Type    = nullptr;\n+const TypeFunc* OptoRuntime::_digestBase_implCompressMB_without_sha3_Type = nullptr;\n+const TypeFunc* OptoRuntime::_multiplyToLen_Type                  = nullptr;\n+const TypeFunc* OptoRuntime::_montgomeryMultiply_Type             = nullptr;\n+const TypeFunc* OptoRuntime::_montgomerySquare_Type               = nullptr;\n+const TypeFunc* OptoRuntime::_squareToLen_Type                    = nullptr;\n+const TypeFunc* OptoRuntime::_mulAdd_Type                         = nullptr;\n+const TypeFunc* OptoRuntime::_bigIntegerShift_Type                = nullptr;\n+const TypeFunc* OptoRuntime::_vectorizedMismatch_Type             = nullptr;\n+const TypeFunc* OptoRuntime::_ghash_processBlocks_Type            = nullptr;\n+const TypeFunc* OptoRuntime::_chacha20Block_Type                  = nullptr;\n+const TypeFunc* OptoRuntime::_base64_encodeBlock_Type             = nullptr;\n+const TypeFunc* OptoRuntime::_base64_decodeBlock_Type             = nullptr;\n+const TypeFunc* OptoRuntime::_string_IndexOf_Type                 = nullptr;\n+const TypeFunc* OptoRuntime::_poly1305_processBlocks_Type         = nullptr;\n+const TypeFunc* OptoRuntime::_intpoly_montgomeryMult_P256_Type    = nullptr;\n+const TypeFunc* OptoRuntime::_intpoly_assign_Type                 = nullptr;\n+const TypeFunc* OptoRuntime::_updateBytesCRC32_Type               = nullptr;\n+const TypeFunc* OptoRuntime::_updateBytesCRC32C_Type              = nullptr;\n+const TypeFunc* OptoRuntime::_updateBytesAdler32_Type             = nullptr;\n+const TypeFunc* OptoRuntime::_osr_end_Type                        = nullptr;\n+const TypeFunc* OptoRuntime::_register_finalizer_Type             = nullptr;\n+JFR_ONLY(\n+  const TypeFunc* OptoRuntime::_class_id_load_barrier_Type        = nullptr;\n+)\n@@ -255,1 +257,1 @@\n-const TypeFunc* OptoRuntime::_notify_jvmti_vthread_tf = nullptr;\n+const TypeFunc* OptoRuntime::_notify_jvmti_vthread_Type           = nullptr;\n@@ -257,7 +259,6 @@\n-const TypeFunc* OptoRuntime::_dtrace_method_entry_exit_tf = nullptr;\n-const TypeFunc* OptoRuntime::_dtrace_object_alloc_tf = nullptr;\n-const TypeFunc* OptoRuntime::_clone_type_tf = nullptr;\n-const TypeFunc* OptoRuntime::_load_reference_barrier_tf = nullptr;\n-const TypeFunc* OptoRuntime::_write_ref_field_pre_tf = nullptr;\n-const TypeFunc* OptoRuntime::_clone_barrier_tf = nullptr;\n-\n+const TypeFunc* OptoRuntime::_dtrace_method_entry_exit_Type       = nullptr;\n+const TypeFunc* OptoRuntime::_dtrace_object_alloc_Type            = nullptr;\n+const TypeFunc* OptoRuntime::_clone_type_Type                     = nullptr;\n+const TypeFunc* OptoRuntime::_load_reference_barrier_Type         = nullptr;\n+const TypeFunc* OptoRuntime::_write_ref_field_pre_Type            = nullptr;\n+const TypeFunc* OptoRuntime::_clone_barrier_Type                  = nullptr;\n@@ -570,3 +571,1 @@\n-void OptoRuntime::new_instance_Type_init() {\n-  assert(_new_instance_tf == nullptr, \"should be called once only\");\n-\n+static const TypeFunc* make_new_instance_Type() {\n@@ -584,1 +583,1 @@\n-  _new_instance_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -588,2 +587,1 @@\n-void OptoRuntime::notify_jvmti_vthread_Type_init() {\n-  assert(_notify_jvmti_vthread_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_notify_jvmti_vthread_Type() {\n@@ -601,1 +599,1 @@\n-  _notify_jvmti_vthread_tf = TypeFunc::make(domain,range);\n+  return TypeFunc::make(domain,range);\n@@ -605,2 +603,1 @@\n-void OptoRuntime::athrow_Type_init() {\n-  assert(_athrow_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_athrow_Type() {\n@@ -617,1 +614,1 @@\n-  _athrow_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -620,2 +617,1 @@\n-void OptoRuntime::new_array_Type_init() {\n-  assert(_new_array_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_new_array_Type() {\n@@ -634,1 +630,1 @@\n-  _new_array_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -654,22 +650,1 @@\n-void OptoRuntime::multianewarray2_Type_init() {\n-  assert(_multianewarray2_tf == nullptr, \"should be called once only\");\n-  _multianewarray2_tf = multianewarray_Type(2);\n-}\n-\n-void OptoRuntime::multianewarray3_Type_init() {\n-  assert(_multianewarray3_tf == nullptr, \"should be called once only\");\n-  _multianewarray3_tf = multianewarray_Type(3);\n-}\n-\n-void OptoRuntime::multianewarray4_Type_init() {\n-  assert(_multianewarray4_tf == nullptr, \"should be called once only\");\n-  _multianewarray4_tf = multianewarray_Type(4);\n-}\n-\n-void OptoRuntime::multianewarray5_Type_init() {\n-  assert(_multianewarray5_tf == nullptr, \"should be called once only\");\n-  _multianewarray5_tf = multianewarray_Type(5);\n-}\n-\n-void OptoRuntime::multianewarrayN_Type_init() {\n-  assert(_multianewarrayN_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_multianewarrayN_Type() {\n@@ -687,1 +662,1 @@\n-  _multianewarrayN_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -690,2 +665,1 @@\n-void OptoRuntime::uncommon_trap_Type_init() {\n-  assert(_uncommon_trap_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_uncommon_trap_Type() {\n@@ -701,1 +675,1 @@\n-  _uncommon_trap_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -707,2 +681,1 @@\n-void OptoRuntime::complete_monitor_enter_Type_init() {\n-  assert(_complete_monitor_enter_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_complete_monitor_enter_Type() {\n@@ -720,1 +693,1 @@\n-  _complete_monitor_enter_tf = TypeFunc::make(domain,range);\n+  return TypeFunc::make(domain,range);\n@@ -725,2 +698,1 @@\n-void OptoRuntime::complete_monitor_exit_Type_init() {\n-  assert(_complete_monitor_exit_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_complete_monitor_exit_Type() {\n@@ -739,1 +711,1 @@\n-  _complete_monitor_exit_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -742,2 +714,1 @@\n-void OptoRuntime::monitor_notify_Type_init() {\n-  assert(_monitor_notify_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_monitor_notify_Type() {\n@@ -752,1 +723,1 @@\n-  _monitor_notify_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -755,2 +726,1 @@\n-void OptoRuntime::flush_windows_Type_init() {\n-  assert(_flush_windows_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_flush_windows_Type() {\n@@ -767,1 +737,1 @@\n-  _flush_windows_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -770,2 +740,1 @@\n-void OptoRuntime::l2f_Type_init() {\n-  assert(_l2f_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_l2f_Type() {\n@@ -783,1 +752,1 @@\n-  _l2f_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -786,2 +755,1 @@\n-void OptoRuntime::modf_Type_init() {\n-  assert(_modf_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_modf_Type() {\n@@ -799,1 +767,1 @@\n-  _modf_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -802,2 +770,1 @@\n-void OptoRuntime::Math_D_D_Type_init() {\n-  assert(_Math_D_D_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_Math_D_D_Type() {\n@@ -817,1 +784,1 @@\n-  _Math_D_D_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -839,2 +806,1 @@\n-void OptoRuntime::Math_DD_D_Type_init() {\n-  assert(_Math_DD_D_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_Math_DD_D_Type() {\n@@ -854,1 +820,1 @@\n-  _Math_DD_D_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -859,2 +825,1 @@\n-void OptoRuntime::void_long_Type_init() {\n-  assert(_void_long_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_void_long_Type() {\n@@ -871,1 +836,1 @@\n-  _void_long_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -874,2 +839,1 @@\n-void OptoRuntime::void_void_Type_init() {\n-  assert(_void_void_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_void_void_Type() {\n@@ -883,1 +847,1 @@\n-  _void_void_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -886,2 +850,1 @@\n-void OptoRuntime::jfr_write_checkpoint_Type_init() {\n-  assert(_jfr_write_checkpoint_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_jfr_write_checkpoint_Type() {\n@@ -895,1 +858,1 @@\n-  _jfr_write_checkpoint_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -904,2 +867,1 @@\n-void OptoRuntime::make_setmemory_Type_init() {\n-  assert(_make_setmemory_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_setmemory_Type() {\n@@ -921,1 +883,1 @@\n-  _make_setmemory_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -970,22 +932,1 @@\n-void OptoRuntime::fast_arraycopy_Type_init() {\n-  assert(_fast_arraycopy_tf == nullptr, \"should be called once only\");\n-  _fast_arraycopy_tf = make_arraycopy_Type(ac_fast);\n-}\n-\n-void OptoRuntime::checkcast_arraycopy_Type_init() {\n-  assert(_checkcast_arraycopy_tf == nullptr, \"should be called once only\");\n-  _checkcast_arraycopy_tf = make_arraycopy_Type(ac_checkcast);\n-}\n-\n-void OptoRuntime::slow_arraycopy_Type_init() {\n-  assert(_slow_arraycopy_tf == nullptr, \"should be called once only\");\n-  _slow_arraycopy_tf = make_arraycopy_Type(ac_slow);\n-}\n-\n-void OptoRuntime::generic_arraycopy_Type_init() {\n-  assert(_generic_arraycopy_tf == nullptr, \"should be called once only\");\n-  _generic_arraycopy_tf = make_arraycopy_Type(ac_generic);\n-}\n-\n-void OptoRuntime::array_fill_Type_init() {\n-  assert(_array_fill_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_array_fill_Type() {\n@@ -1007,1 +948,1 @@\n-  _array_fill_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -1010,2 +951,1 @@\n-void OptoRuntime::array_partition_Type_init() {\n-  assert(_array_partition_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_array_partition_Type() {\n@@ -1031,1 +971,1 @@\n-  _array_partition_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -1034,2 +974,1 @@\n-void OptoRuntime::array_sort_Type_init() {\n-  assert(_array_sort_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_array_sort_Type() {\n@@ -1052,1 +991,1 @@\n-  _array_sort_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -1055,2 +994,1 @@\n-void OptoRuntime::aescrypt_block_Type_init() {\n-  assert(_aescrypt_block_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_aescrypt_block_Type() {\n@@ -1072,1 +1010,1 @@\n-  _aescrypt_block_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -1075,2 +1013,1 @@\n-void OptoRuntime::updateBytesCRC32_Type_init() {\n-  assert(_updateBytesCRC32_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_updateBytesCRC32_Type() {\n@@ -1092,1 +1029,1 @@\n-  _updateBytesCRC32_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -1095,2 +1032,1 @@\n-void OptoRuntime::updateBytesCRC32C_Type_init() {\n-  assert(_updateBytesCRC32C_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_updateBytesCRC32C_Type() {\n@@ -1113,1 +1049,1 @@\n-  _updateBytesCRC32C_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -1116,2 +1052,1 @@\n-void OptoRuntime::updateBytesAdler32_Type_init() {\n-  assert(_updateBytesAdler32_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_updateBytesAdler32_Type() {\n@@ -1133,1 +1068,1 @@\n-  _updateBytesAdler32_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -1136,2 +1071,1 @@\n-void OptoRuntime::cipherBlockChaining_aescrypt_Type_init() {\n-  assert(_cipherBlockChaining_aescrypt_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_cipherBlockChaining_aescrypt_Type() {\n@@ -1155,1 +1089,1 @@\n-  _cipherBlockChaining_aescrypt_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -1158,2 +1092,1 @@\n-void OptoRuntime::electronicCodeBook_aescrypt_Type_init() {\n-  assert(_electronicCodeBook_aescrypt_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_electronicCodeBook_aescrypt_Type() {\n@@ -1176,1 +1109,1 @@\n-  _electronicCodeBook_aescrypt_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -1179,2 +1112,1 @@\n-void OptoRuntime::counterMode_aescrypt_Type_init() {\n-  assert(_counterMode_aescrypt_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_counterMode_aescrypt_Type() {\n@@ -1199,1 +1131,1 @@\n-  _counterMode_aescrypt_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -1202,2 +1134,1 @@\n-void OptoRuntime::galoisCounterMode_aescrypt_Type_init() {\n-  assert(_galoisCounterMode_aescrypt_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_galoisCounterMode_aescrypt_Type() {\n@@ -1224,8 +1155,1 @@\n-  _galoisCounterMode_aescrypt_tf = TypeFunc::make(domain, range);\n-}\n-\n-void OptoRuntime::digestBase_implCompress_Type_init() {\n-  assert((_digestBase_implCompress_with_sha3_tf == nullptr) &&\n-         (_digestBase_implCompress_without_sha3_tf == nullptr), \"should be called once only\");\n-  _digestBase_implCompress_with_sha3_tf = OptoRuntime::digestBase_implCompress_Type_helper( \/* is_sha3= *\/ true);\n-  _digestBase_implCompress_without_sha3_tf = OptoRuntime::digestBase_implCompress_Type_helper( \/* is_sha3= *\/ false);\n+  return TypeFunc::make(domain, range);\n@@ -1234,1 +1158,1 @@\n-const TypeFunc* OptoRuntime::digestBase_implCompress_Type_helper(bool is_sha3) {\n+static const TypeFunc* make_digestBase_implCompress_Type(bool is_sha3) {\n@@ -1253,8 +1177,1 @@\n-void OptoRuntime::digestBase_implCompressMB_Type_init() {\n-  assert((_digestBase_implCompressMB_with_sha3_tf == nullptr) &&\n-         (_digestBase_implCompressMB_without_sha3_tf == nullptr), \"should be called once only\");\n-  _digestBase_implCompressMB_with_sha3_tf = OptoRuntime::digestBase_implCompressMB_Type_helper(\/* is_sha3 *\/true);\n-  _digestBase_implCompressMB_without_sha3_tf = OptoRuntime::digestBase_implCompressMB_Type_helper(\/* is_sha3 *\/false);\n-}\n-\n-const TypeFunc* OptoRuntime::digestBase_implCompressMB_Type_helper(bool is_sha3) {\n+static const TypeFunc* make_digestBase_implCompressMB_Type(bool is_sha3) {\n@@ -1281,2 +1198,1 @@\n-void OptoRuntime::multiplyToLen_Type_init() {\n-  assert(_multiplyToLen_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_multiplyToLen_Type() {\n@@ -1300,1 +1216,1 @@\n-  _multiplyToLen_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -1303,2 +1219,1 @@\n-void OptoRuntime::squareToLen_Type_init() {\n-  assert(_squareToLen_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_squareToLen_Type() {\n@@ -1321,1 +1236,1 @@\n-  _squareToLen_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -1324,2 +1239,1 @@\n-void OptoRuntime::mulAdd_Type_init() {\n-  assert(_mulAdd_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_mulAdd_Type() {\n@@ -1343,1 +1257,1 @@\n-  _mulAdd_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -1346,2 +1260,1 @@\n-void OptoRuntime::montgomeryMultiply_Type_init() {\n-  assert(_montgomeryMultiply_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_montgomeryMultiply_Type() {\n@@ -1368,1 +1281,1 @@\n-  _montgomeryMultiply_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -1371,2 +1284,1 @@\n-void OptoRuntime::montgomerySquare_Type_init() {\n-  assert(_montgomerySquare_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_montgomerySquare_Type() {\n@@ -1392,1 +1304,1 @@\n-  _montgomerySquare_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -1395,2 +1307,1 @@\n-void OptoRuntime::bigIntegerShift_Type_init() {\n-  assert(_bigIntegerShift_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_bigIntegerShift_Type() {\n@@ -1412,1 +1323,1 @@\n-  _bigIntegerShift_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -1415,2 +1326,1 @@\n-void OptoRuntime::vectorizedMismatch_Type_init() {\n-  assert(_vectorizedMismatch_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_vectorizedMismatch_Type() {\n@@ -1433,1 +1343,1 @@\n-  _vectorizedMismatch_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -1436,2 +1346,1 @@\n-void OptoRuntime::ghash_processBlocks_Type_init() {\n-  assert(_ghash_processBlocks_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_ghash_processBlocks_Type() {\n@@ -1453,1 +1362,1 @@\n-  _ghash_processBlocks_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -1456,2 +1365,1 @@\n-void OptoRuntime::chacha20Block_Type_init() {\n-  assert(_chacha20Block_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_chacha20Block_Type() {\n@@ -1472,1 +1380,1 @@\n-  _chacha20Block_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -1475,2 +1383,1 @@\n-void OptoRuntime::base64_encodeBlock_Type_init() {\n-  assert(_base64_encodeBlock_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_base64_encodeBlock_Type() {\n@@ -1494,1 +1401,1 @@\n-  _base64_encodeBlock_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -1497,2 +1404,1 @@\n-void OptoRuntime::string_IndexOf_Type_init() {\n-  assert(_string_IndexOf_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_string_IndexOf_Type() {\n@@ -1514,1 +1420,1 @@\n-  _string_IndexOf_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -1517,2 +1423,1 @@\n-void OptoRuntime::base64_decodeBlock_Type_init() {\n-  assert(_base64_decodeBlock_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_base64_decodeBlock_Type() {\n@@ -1537,1 +1442,1 @@\n-  _base64_decodeBlock_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -1540,2 +1445,1 @@\n-void OptoRuntime::poly1305_processBlocks_Type_init() {\n-  assert(_poly1305_processBlocks_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_poly1305_processBlocks_Type() {\n@@ -1557,1 +1461,1 @@\n-  _poly1305_processBlocks_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -1560,2 +1464,1 @@\n-void OptoRuntime::intpoly_montgomeryMult_P256_Type_init() {\n-  assert(_intpoly_montgomeryMult_P256_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_intpoly_montgomeryMult_P256_Type() {\n@@ -1576,1 +1479,1 @@\n-  _intpoly_montgomeryMult_P256_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -1579,2 +1482,1 @@\n-void OptoRuntime::intpoly_assign_Type_init() {\n-  assert(_intpoly_assign_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_intpoly_assign_Type() {\n@@ -1596,1 +1498,1 @@\n-  _intpoly_assign_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -1600,2 +1502,1 @@\n-void OptoRuntime::osr_end_Type_init() {\n-  assert(_osr_end_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_osr_end_Type() {\n@@ -1612,1 +1513,1 @@\n-  _osr_end_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -1847,2 +1748,1 @@\n-void OptoRuntime::rethrow_Type_init() {\n-  assert(_rethrow_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_rethrow_Type() {\n@@ -1859,1 +1759,1 @@\n-  _rethrow_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -1898,2 +1798,1 @@\n-void OptoRuntime::register_finalizer_Type_init() {\n-  assert(_register_finalizer_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_register_finalizer_Type() {\n@@ -1912,1 +1811,1 @@\n-  _register_finalizer_tf = TypeFunc::make(domain,range);\n+  return TypeFunc::make(domain,range);\n@@ -1916,2 +1815,1 @@\n-void OptoRuntime::class_id_load_barrier_Type_init() {\n-  assert(_class_id_load_barrier_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_class_id_load_barrier_Type() {\n@@ -1928,1 +1826,1 @@\n-  _class_id_load_barrier_tf = TypeFunc::make(domain,range);\n+  return TypeFunc::make(domain,range);\n@@ -1933,2 +1831,1 @@\n-void OptoRuntime::dtrace_method_entry_exit_Type_init() {\n-  assert(_dtrace_method_entry_exit_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_dtrace_method_entry_exit_Type() {\n@@ -1946,1 +1843,1 @@\n-  _dtrace_method_entry_exit_tf = TypeFunc::make(domain,range);\n+  return TypeFunc::make(domain,range);\n@@ -1949,2 +1846,1 @@\n-void OptoRuntime::dtrace_object_alloc_Type_init() {\n-  assert(_dtrace_object_alloc_tf == nullptr, \"should be called once only\");\n+static const TypeFunc* make_dtrace_object_alloc_Type() {\n@@ -1963,1 +1859,1 @@\n-  _dtrace_object_alloc_tf = TypeFunc::make(domain,range);\n+  return TypeFunc::make(domain,range);\n@@ -1966,2 +1862,1 @@\n-void OptoRuntime::clone_type_init() {\n-  assert(_clone_type_tf == nullptr, \"should be\");\n+static const TypeFunc* make_clone_type_Type() {\n@@ -1983,1 +1878,1 @@\n-  _clone_type_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -1986,2 +1881,1 @@\n-void OptoRuntime::load_reference_barrier_init() {\n-  assert(_load_reference_barrier_tf == nullptr, \"should be\");\n+static const TypeFunc* make_load_reference_barrier_Type() {\n@@ -1999,1 +1893,1 @@\n-  _load_reference_barrier_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -2002,2 +1896,1 @@\n-void OptoRuntime::write_ref_field_pre_init() {\n-  assert(_write_ref_field_pre_tf == nullptr, \"should be\");\n+static const TypeFunc* make_write_ref_field_pre_Type() {\n@@ -2013,1 +1906,1 @@\n-  _write_ref_field_pre_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -2016,2 +1909,1 @@\n-void OptoRuntime::clone_barrier_init() {\n-  assert(_clone_barrier_tf == nullptr, \"should be\");\n+static const TypeFunc* make_clone_barrier_Type() {\n@@ -2026,1 +1918,1 @@\n-  _clone_barrier_tf = TypeFunc::make(domain, range);\n+  return TypeFunc::make(domain, range);\n@@ -2115,56 +2007,61 @@\n-  new_instance_Type_init();\n-  new_array_Type_init();\n-  multianewarray2_Type_init();\n-  multianewarray3_Type_init();\n-  multianewarray4_Type_init();\n-  multianewarray5_Type_init();\n-  multianewarrayN_Type_init();\n-  complete_monitor_enter_Type_init();\n-  complete_monitor_exit_Type_init();\n-  monitor_notify_Type_init();\n-  uncommon_trap_Type_init();\n-  athrow_Type_init();\n-  rethrow_Type_init();\n-  Math_D_D_Type_init();\n-  Math_DD_D_Type_init();\n-  modf_Type_init();\n-  l2f_Type_init();\n-  void_long_Type_init();\n-  void_void_Type_init();\n-  jfr_write_checkpoint_Type_init();\n-  fast_arraycopy_Type_init();\n-  checkcast_arraycopy_Type_init();\n-  generic_arraycopy_Type_init();\n-  slow_arraycopy_Type_init();\n-  make_setmemory_Type_init();\n-  array_fill_Type_init();\n-  array_sort_Type_init();\n-  array_partition_Type_init();\n-  aescrypt_block_Type_init();\n-  cipherBlockChaining_aescrypt_Type_init();\n-  electronicCodeBook_aescrypt_Type_init();\n-  counterMode_aescrypt_Type_init();\n-  galoisCounterMode_aescrypt_Type_init();\n-  digestBase_implCompress_Type_init();\n-  digestBase_implCompressMB_Type_init();\n-  multiplyToLen_Type_init();\n-  montgomeryMultiply_Type_init();\n-  montgomerySquare_Type_init();\n-  squareToLen_Type_init();\n-  mulAdd_Type_init();\n-  bigIntegerShift_Type_init();\n-  vectorizedMismatch_Type_init();\n-  ghash_processBlocks_Type_init();\n-  chacha20Block_Type_init();\n-  base64_encodeBlock_Type_init();\n-  base64_decodeBlock_Type_init();\n-  string_IndexOf_Type_init();\n-  poly1305_processBlocks_Type_init();\n-  intpoly_montgomeryMult_P256_Type_init();\n-  intpoly_assign_Type_init();\n-  updateBytesCRC32_Type_init();\n-  updateBytesCRC32C_Type_init();\n-  updateBytesAdler32_Type_init();\n-  osr_end_Type_init();\n-  register_finalizer_Type_init();\n-  JFR_ONLY(class_id_load_barrier_Type_init();)\n+  _new_instance_Type                  = make_new_instance_Type();\n+  _new_array_Type                     = make_new_array_Type();\n+  _multianewarray2_Type               = multianewarray_Type(2);\n+  _multianewarray4_Type               = multianewarray_Type(3);\n+  _multianewarray3_Type               = multianewarray_Type(4);\n+  _multianewarray5_Type               = multianewarray_Type(5);\n+  _multianewarrayN_Type               = make_multianewarrayN_Type();\n+  _complete_monitor_enter_Type        = make_complete_monitor_enter_Type();\n+  _complete_monitor_exit_Type         = make_complete_monitor_exit_Type();\n+  _monitor_notify_Type                = make_monitor_notify_Type();\n+  _uncommon_trap_Type                 = make_uncommon_trap_Type();\n+  _athrow_Type                        = make_athrow_Type();\n+  _rethrow_Type                       = make_rethrow_Type();\n+  _Math_D_D_Type                      = make_Math_D_D_Type();\n+  _Math_DD_D_Type                     = make_Math_DD_D_Type();\n+  _modf_Type                          = make_modf_Type();\n+  _l2f_Type                           = make_l2f_Type();\n+  _void_long_Type                     = make_void_long_Type();\n+  _void_void_Type                     = make_void_void_Type();\n+  _jfr_write_checkpoint_Type          = make_jfr_write_checkpoint_Type();\n+  _flush_windows_Type                 = make_flush_windows_Type();\n+  _fast_arraycopy_Type                = make_arraycopy_Type(ac_fast);\n+  _checkcast_arraycopy_Type           = make_arraycopy_Type(ac_checkcast);\n+  _generic_arraycopy_Type             = make_arraycopy_Type(ac_generic);\n+  _slow_arraycopy_Type                = make_arraycopy_Type(ac_slow);\n+  _unsafe_setmemory_Type              = make_setmemory_Type();\n+  _array_fill_Type                    = make_array_fill_Type();\n+  _array_sort_Type                    = make_array_sort_Type();\n+  _array_partition_Type               = make_array_partition_Type();\n+  _aescrypt_block_Type                = make_aescrypt_block_Type();\n+  _cipherBlockChaining_aescrypt_Type  = make_cipherBlockChaining_aescrypt_Type();\n+  _electronicCodeBook_aescrypt_Type   = make_electronicCodeBook_aescrypt_Type();\n+  _counterMode_aescrypt_Type          = make_counterMode_aescrypt_Type();\n+  _galoisCounterMode_aescrypt_Type    = make_galoisCounterMode_aescrypt_Type();\n+  _digestBase_implCompress_with_sha3_Type      = make_digestBase_implCompress_Type(  \/* is_sha3= *\/ true);\n+  _digestBase_implCompress_without_sha3_Type   = make_digestBase_implCompress_Type(  \/* is_sha3= *\/ false);;\n+  _digestBase_implCompressMB_with_sha3_Type    = make_digestBase_implCompressMB_Type(\/* is_sha3= *\/ true);\n+  _digestBase_implCompressMB_without_sha3_Type = make_digestBase_implCompressMB_Type(\/* is_sha3= *\/ false);\n+  _multiplyToLen_Type                 = make_multiplyToLen_Type();\n+  _montgomeryMultiply_Type            = make_montgomeryMultiply_Type();\n+  _montgomerySquare_Type              = make_montgomerySquare_Type();\n+  _squareToLen_Type                   = make_squareToLen_Type();\n+  _mulAdd_Type                        = make_mulAdd_Type();\n+  _bigIntegerShift_Type               = make_bigIntegerShift_Type();\n+  _vectorizedMismatch_Type            = make_vectorizedMismatch_Type();\n+  _ghash_processBlocks_Type           = make_ghash_processBlocks_Type();\n+  _chacha20Block_Type                 = make_chacha20Block_Type();\n+  _base64_encodeBlock_Type            = make_base64_encodeBlock_Type();\n+  _base64_decodeBlock_Type            = make_base64_decodeBlock_Type();\n+  _string_IndexOf_Type                = make_string_IndexOf_Type();\n+  _poly1305_processBlocks_Type        = make_poly1305_processBlocks_Type();\n+  _intpoly_montgomeryMult_P256_Type   = make_intpoly_montgomeryMult_P256_Type();\n+  _intpoly_assign_Type                = make_intpoly_assign_Type();\n+  _updateBytesCRC32_Type              = make_updateBytesCRC32_Type();\n+  _updateBytesCRC32C_Type             = make_updateBytesCRC32C_Type();\n+  _updateBytesAdler32_Type            = make_updateBytesAdler32_Type();\n+  _osr_end_Type                       = make_osr_end_Type();\n+  _register_finalizer_Type            = make_register_finalizer_Type();\n+  JFR_ONLY(\n+    _class_id_load_barrier_Type       = make_class_id_load_barrier_Type();\n+  )\n@@ -2172,1 +2069,1 @@\n-  notify_jvmti_vthread_Type_init();\n+  _notify_jvmti_vthread_Type          = make_notify_jvmti_vthread_Type();\n@@ -2174,6 +2071,6 @@\n-  dtrace_method_entry_exit_Type_init();\n-  dtrace_object_alloc_Type_init();\n-  clone_type_init();\n-  clone_barrier_init();\n-  write_ref_field_pre_init();\n-  load_reference_barrier_init();\n+  _dtrace_method_entry_exit_Type      = make_dtrace_method_entry_exit_Type();\n+  _dtrace_object_alloc_Type           = make_dtrace_object_alloc_Type();\n+  _clone_type_Type                    = make_clone_type_Type();\n+  _load_reference_barrier_Type        = make_load_reference_barrier_Type();\n+  _write_ref_field_pre_Type           = make_write_ref_field_pre_Type();\n+  _clone_barrier_Type                 = make_clone_barrier_Type();\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":246,"deletions":349,"binary":false,"changes":595,"status":"modified"},{"patch":"@@ -135,59 +135,59 @@\n-  static const TypeFunc *_new_instance_tf;\n-  static const TypeFunc *_new_array_tf;\n-  static const TypeFunc *_multianewarray2_tf;\n-  static const TypeFunc *_multianewarray3_tf;\n-  static const TypeFunc *_multianewarray4_tf;\n-  static const TypeFunc *_multianewarray5_tf;\n-  static const TypeFunc *_multianewarrayN_tf;\n-  static const TypeFunc *_complete_monitor_enter_tf;\n-  static const TypeFunc *_complete_monitor_exit_tf;\n-  static const TypeFunc *_monitor_notify_tf;\n-  static const TypeFunc *_uncommon_trap_tf;\n-  static const TypeFunc *_athrow_tf;\n-  static const TypeFunc *_rethrow_tf;\n-  static const TypeFunc *_Math_D_D_tf;\n-  static const TypeFunc *_Math_DD_D_tf;\n-  static const TypeFunc *_modf_tf;\n-  static const TypeFunc *_l2f_tf;\n-  static const TypeFunc *_void_long_tf;\n-  static const TypeFunc *_void_void_tf;\n-  static const TypeFunc *_jfr_write_checkpoint_tf;\n-  static const TypeFunc *_flush_windows_tf;\n-  static const TypeFunc *_fast_arraycopy_tf;\n-  static const TypeFunc *_checkcast_arraycopy_tf;\n-  static const TypeFunc *_generic_arraycopy_tf;\n-  static const TypeFunc *_slow_arraycopy_tf;\n-  static const TypeFunc *_make_setmemory_tf;\n-  static const TypeFunc *_array_fill_tf;\n-  static const TypeFunc *_array_sort_tf;\n-  static const TypeFunc *_array_partition_tf;\n-  static const TypeFunc *_aescrypt_block_tf;\n-  static const TypeFunc *_cipherBlockChaining_aescrypt_tf;\n-  static const TypeFunc *_electronicCodeBook_aescrypt_tf;\n-  static const TypeFunc *_counterMode_aescrypt_tf;\n-  static const TypeFunc *_galoisCounterMode_aescrypt_tf;\n-  static const TypeFunc *_digestBase_implCompress_with_sha3_tf;\n-  static const TypeFunc *_digestBase_implCompress_without_sha3_tf;\n-  static const TypeFunc *_digestBase_implCompressMB_with_sha3_tf;\n-  static const TypeFunc *_digestBase_implCompressMB_without_sha3_tf;\n-  static const TypeFunc *_multiplyToLen_tf;\n-  static const TypeFunc *_montgomeryMultiply_tf;\n-  static const TypeFunc *_montgomerySquare_tf;\n-  static const TypeFunc *_squareToLen_tf;\n-  static const TypeFunc *_mulAdd_tf;\n-  static const TypeFunc *_bigIntegerShift_tf;\n-  static const TypeFunc *_vectorizedMismatch_tf;\n-  static const TypeFunc *_ghash_processBlocks_tf;\n-  static const TypeFunc *_chacha20Block_tf;\n-  static const TypeFunc *_base64_encodeBlock_tf;\n-  static const TypeFunc *_base64_decodeBlock_tf;\n-  static const TypeFunc *_string_IndexOf_tf;\n-  static const TypeFunc *_poly1305_processBlocks_tf;\n-  static const TypeFunc *_intpoly_montgomeryMult_P256_tf;\n-  static const TypeFunc *_intpoly_assign_tf;\n-  static const TypeFunc *_updateBytesCRC32_tf;\n-  static const TypeFunc *_updateBytesCRC32C_tf;\n-  static const TypeFunc *_updateBytesAdler32_tf;\n-  static const TypeFunc *_osr_end_tf;\n-  static const TypeFunc *_register_finalizer_tf;\n-  JFR_ONLY(static const TypeFunc *_class_id_load_barrier_tf;)\n+  static const TypeFunc *_new_instance_Type;\n+  static const TypeFunc *_new_array_Type;\n+  static const TypeFunc *_multianewarray2_Type;\n+  static const TypeFunc *_multianewarray3_Type;\n+  static const TypeFunc *_multianewarray4_Type;\n+  static const TypeFunc *_multianewarray5_Type;\n+  static const TypeFunc *_multianewarrayN_Type;\n+  static const TypeFunc *_complete_monitor_enter_Type;\n+  static const TypeFunc *_complete_monitor_exit_Type;\n+  static const TypeFunc *_monitor_notify_Type;\n+  static const TypeFunc *_uncommon_trap_Type;\n+  static const TypeFunc *_athrow_Type;\n+  static const TypeFunc *_rethrow_Type;\n+  static const TypeFunc *_Math_D_D_Type;\n+  static const TypeFunc *_Math_DD_D_Type;\n+  static const TypeFunc *_modf_Type;\n+  static const TypeFunc *_l2f_Type;\n+  static const TypeFunc *_void_long_Type;\n+  static const TypeFunc *_void_void_Type;\n+  static const TypeFunc *_jfr_write_checkpoint_Type;\n+  static const TypeFunc *_flush_windows_Type;\n+  static const TypeFunc *_fast_arraycopy_Type;\n+  static const TypeFunc *_checkcast_arraycopy_Type;\n+  static const TypeFunc *_generic_arraycopy_Type;\n+  static const TypeFunc *_slow_arraycopy_Type;\n+  static const TypeFunc *_unsafe_setmemory_Type;\n+  static const TypeFunc *_array_fill_Type;\n+  static const TypeFunc *_array_sort_Type;\n+  static const TypeFunc *_array_partition_Type;\n+  static const TypeFunc *_aescrypt_block_Type;\n+  static const TypeFunc *_cipherBlockChaining_aescrypt_Type;\n+  static const TypeFunc *_electronicCodeBook_aescrypt_Type;\n+  static const TypeFunc *_counterMode_aescrypt_Type;\n+  static const TypeFunc *_galoisCounterMode_aescrypt_Type;\n+  static const TypeFunc *_digestBase_implCompress_with_sha3_Type;\n+  static const TypeFunc *_digestBase_implCompress_without_sha3_Type;\n+  static const TypeFunc *_digestBase_implCompressMB_with_sha3_Type;\n+  static const TypeFunc *_digestBase_implCompressMB_without_sha3_Type;\n+  static const TypeFunc *_multiplyToLen_Type;\n+  static const TypeFunc *_montgomeryMultiply_Type;\n+  static const TypeFunc *_montgomerySquare_Type;\n+  static const TypeFunc *_squareToLen_Type;\n+  static const TypeFunc *_mulAdd_Type;\n+  static const TypeFunc *_bigIntegerShift_Type;\n+  static const TypeFunc *_vectorizedMismatch_Type;\n+  static const TypeFunc *_ghash_processBlocks_Type;\n+  static const TypeFunc *_chacha20Block_Type;\n+  static const TypeFunc *_base64_encodeBlock_Type;\n+  static const TypeFunc *_base64_decodeBlock_Type;\n+  static const TypeFunc *_string_IndexOf_Type;\n+  static const TypeFunc *_poly1305_processBlocks_Type;\n+  static const TypeFunc *_intpoly_montgomeryMult_P256_Type;\n+  static const TypeFunc *_intpoly_assign_Type;\n+  static const TypeFunc *_updateBytesCRC32_Type;\n+  static const TypeFunc *_updateBytesCRC32C_Type;\n+  static const TypeFunc *_updateBytesAdler32_Type;\n+  static const TypeFunc *_osr_end_Type;\n+  static const TypeFunc *_register_finalizer_Type;\n+  JFR_ONLY(static const TypeFunc *_class_id_load_barrier_Type;)\n@@ -195,1 +195,1 @@\n-  static const TypeFunc *_notify_jvmti_vthread_tf;\n+  static const TypeFunc *_notify_jvmti_vthread_Type;\n@@ -197,6 +197,6 @@\n-  static const TypeFunc *_dtrace_method_entry_exit_tf;\n-  static const TypeFunc *_dtrace_object_alloc_tf;\n-  static const TypeFunc *_clone_type_tf;\n-  static const TypeFunc *_load_reference_barrier_tf;\n-  static const TypeFunc *_write_ref_field_pre_tf;\n-  static const TypeFunc *_clone_barrier_tf;\n+  static const TypeFunc *_dtrace_method_entry_exit_Type;\n+  static const TypeFunc *_dtrace_object_alloc_Type;\n+  static const TypeFunc *_clone_type_Type;\n+  static const TypeFunc *_load_reference_barrier_Type;\n+  static const TypeFunc *_write_ref_field_pre_Type;\n+  static const TypeFunc *_clone_barrier_Type;\n@@ -315,93 +315,0 @@\n-  \/\/ Initialization methods\n-\n-  static void new_instance_Type_init(); \/\/ object allocation (slow case)\n-  static void new_array_Type_init ();   \/\/ [a]newarray (slow case)\n-  static void multianewarray2_Type_init(); \/\/ multianewarray\n-  static void multianewarray3_Type_init(); \/\/ multianewarray\n-  static void multianewarray4_Type_init(); \/\/ multianewarray\n-  static void multianewarray5_Type_init(); \/\/ multianewarray\n-  static void multianewarrayN_Type_init(); \/\/ multianewarray\n-  static void complete_monitor_enter_Type_init();\n-  static void complete_monitor_exit_Type_init();\n-  static void monitor_notify_Type_init();\n-  static void uncommon_trap_Type_init();\n-  static void athrow_Type_init();\n-  static void rethrow_Type_init();\n-  static void Math_D_D_Type_init();  \/\/ sin,cos & friends\n-  static void Math_DD_D_Type_init(); \/\/ mod,pow & friends\n-  static void modf_Type_init();\n-  static void l2f_Type_init();\n-  static void void_long_Type_init();\n-  static void void_void_Type_init();\n-  static void clone_type_init();\n-  static void load_reference_barrier_init();\n-\n-  static void jfr_write_checkpoint_Type_init();\n-\n-  static void flush_windows_Type_init();\n-\n-  \/\/ arraycopy routine types\n-  static void fast_arraycopy_Type_init(); \/\/ bit-blasters\n-  static void checkcast_arraycopy_Type_init();\n-  static void generic_arraycopy_Type_init();\n-  static void slow_arraycopy_Type_init();   \/\/ the full routine\n-\n-  static void make_setmemory_Type_init();\n-\n-  static void array_fill_Type_init();\n-\n-  static void array_sort_Type_init();\n-  static void array_partition_Type_init();\n-  static void aescrypt_block_Type_init();\n-  static void cipherBlockChaining_aescrypt_Type_init();\n-  static void electronicCodeBook_aescrypt_Type_init();\n-  static void counterMode_aescrypt_Type_init();\n-  static void galoisCounterMode_aescrypt_Type_init();\n-\n-  static void digestBase_implCompress_Type_init();\n-  static const TypeFunc* digestBase_implCompress_Type_helper(bool is_sha3);\n-  static void digestBase_implCompressMB_Type_init();\n-  static const TypeFunc* digestBase_implCompressMB_Type_helper(bool is_sha3);\n-\n-  static void multiplyToLen_Type_init();\n-  static void montgomeryMultiply_Type_init();\n-  static void montgomerySquare_Type_init();\n-\n-  static void squareToLen_Type_init();\n-\n-  static void mulAdd_Type_init();\n-\n-  static void bigIntegerShift_Type_init();\n-\n-  static void vectorizedMismatch_Type_init();\n-\n-  static void ghash_processBlocks_Type_init();\n-  static void chacha20Block_Type_init();\n-  static void base64_encodeBlock_Type_init();\n-  static void base64_decodeBlock_Type_init();\n-  static void string_IndexOf_Type_init();\n-  static void poly1305_processBlocks_Type_init();\n-  static void intpoly_montgomeryMult_P256_Type_init();\n-  static void intpoly_assign_Type_init();\n-\n-  static void updateBytesCRC32_Type_init();\n-  static void updateBytesCRC32C_Type_init();\n-\n-  static void updateBytesAdler32_Type_init();\n-\n-  \/\/ leaf on stack replacement interpreter accessor types\n-  static void osr_end_Type_init();\n-\n-  static void register_finalizer_Type_init();\n-\n-  JFR_ONLY(static void class_id_load_barrier_Type_init();)\n-#if INCLUDE_JVMTI\n-  static void notify_jvmti_vthread_Type_init();\n-#endif\n-\n-  \/\/ Dtrace support\n-  static void dtrace_method_entry_exit_Type_init();\n-  static void dtrace_object_alloc_Type_init();\n-  static void write_ref_field_pre_init();\n-  static void clone_barrier_init();\n-\n@@ -409,2 +316,2 @@\n-    assert(_clone_barrier_tf != nullptr, \"should be initialized\");\n-    return _clone_barrier_tf;\n+    assert(_clone_barrier_Type != nullptr, \"should be initialized\");\n+    return _clone_barrier_Type;\n@@ -414,2 +321,2 @@\n-    assert(_write_ref_field_pre_tf != nullptr, \"should be initialized\");\n-    return _write_ref_field_pre_tf;\n+    assert(_write_ref_field_pre_Type != nullptr, \"should be initialized\");\n+    return _write_ref_field_pre_Type;\n@@ -419,2 +326,2 @@\n-    assert(_new_instance_tf != nullptr, \"should be initialized\");\n-    return _new_instance_tf;\n+    assert(_new_instance_Type != nullptr, \"should be initialized\");\n+    return _new_instance_Type;\n@@ -424,2 +331,2 @@\n-    assert(_new_array_tf != nullptr, \"should be initialized\");\n-    return _new_array_tf;\n+    assert(_new_array_Type != nullptr, \"should be initialized\");\n+    return _new_array_Type;\n@@ -435,2 +342,2 @@\n-    assert(_multianewarray2_tf != nullptr, \"should be initialized\");\n-    return _multianewarray2_tf;\n+    assert(_multianewarray2_Type != nullptr, \"should be initialized\");\n+    return _multianewarray2_Type;\n@@ -440,2 +347,2 @@\n-    assert(_multianewarray3_tf != nullptr, \"should be initialized\");\n-    return _multianewarray3_tf;\n+    assert(_multianewarray3_Type != nullptr, \"should be initialized\");\n+    return _multianewarray3_Type;\n@@ -445,2 +352,2 @@\n-    assert(_multianewarray4_tf != nullptr, \"should be initialized\");\n-    return _multianewarray4_tf;\n+    assert(_multianewarray4_Type != nullptr, \"should be initialized\");\n+    return _multianewarray4_Type;\n@@ -450,2 +357,2 @@\n-    assert(_multianewarray5_tf != nullptr, \"should be initialized\");\n-    return _multianewarray5_tf;\n+    assert(_multianewarray5_Type != nullptr, \"should be initialized\");\n+    return _multianewarray5_Type;\n@@ -455,2 +362,2 @@\n-    assert(_multianewarrayN_tf != nullptr, \"should be initialized\");\n-    return _multianewarrayN_tf;\n+    assert(_multianewarrayN_Type != nullptr, \"should be initialized\");\n+    return _multianewarrayN_Type;\n@@ -460,2 +367,2 @@\n-    assert(_complete_monitor_enter_tf != nullptr, \"should be initialized\");\n-    return _complete_monitor_enter_tf;\n+    assert(_complete_monitor_enter_Type != nullptr, \"should be initialized\");\n+    return _complete_monitor_enter_Type;\n@@ -469,2 +376,2 @@\n-    assert(_complete_monitor_exit_tf != nullptr, \"should be initialized\");\n-    return _complete_monitor_exit_tf;\n+    assert(_complete_monitor_exit_Type != nullptr, \"should be initialized\");\n+    return _complete_monitor_exit_Type;\n@@ -474,2 +381,2 @@\n-    assert(_monitor_notify_tf != nullptr, \"should be initialized\");\n-    return _monitor_notify_tf;\n+    assert(_monitor_notify_Type != nullptr, \"should be initialized\");\n+    return _monitor_notify_Type;\n@@ -483,2 +390,2 @@\n-    assert(_uncommon_trap_tf != nullptr, \"should be initialized\");\n-    return _uncommon_trap_tf;\n+    assert(_uncommon_trap_Type != nullptr, \"should be initialized\");\n+    return _uncommon_trap_Type;\n@@ -488,2 +395,2 @@\n-    assert(_athrow_tf != nullptr, \"should be initialized\");\n-    return _athrow_tf;\n+    assert(_athrow_Type != nullptr, \"should be initialized\");\n+    return _athrow_Type;\n@@ -493,2 +400,2 @@\n-    assert(_rethrow_tf != nullptr, \"should be initialized\");\n-    return _rethrow_tf;\n+    assert(_rethrow_Type != nullptr, \"should be initialized\");\n+    return _rethrow_Type;\n@@ -498,2 +405,2 @@\n-    assert(_Math_D_D_tf != nullptr, \"should be initialized\");\n-    return _Math_D_D_tf;\n+    assert(_Math_D_D_Type != nullptr, \"should be initialized\");\n+    return _Math_D_D_Type;\n@@ -503,2 +410,2 @@\n-    assert(_Math_DD_D_tf != nullptr, \"should be initialized\");\n-    return _Math_DD_D_tf;\n+    assert(_Math_DD_D_Type != nullptr, \"should be initialized\");\n+    return _Math_DD_D_Type;\n@@ -510,2 +417,2 @@\n-    assert(_modf_tf != nullptr, \"should be initialized\");\n-    return _modf_tf;\n+    assert(_modf_Type != nullptr, \"should be initialized\");\n+    return _modf_Type;\n@@ -515,2 +422,2 @@\n-    assert(_l2f_tf != nullptr, \"should be initialized\");\n-    return _l2f_tf;\n+    assert(_l2f_Type != nullptr, \"should be initialized\");\n+    return _l2f_Type;\n@@ -520,2 +427,2 @@\n-    assert(_void_long_tf != nullptr, \"should be initialized\");\n-    return _void_long_tf;\n+    assert(_void_long_Type != nullptr, \"should be initialized\");\n+    return _void_long_Type;\n@@ -525,2 +432,2 @@\n-    assert(_void_void_tf != nullptr, \"should be initialized\");\n-    return _void_void_tf;\n+    assert(_void_void_Type != nullptr, \"should be initialized\");\n+    return _void_void_Type;\n@@ -530,2 +437,2 @@\n-    assert(_jfr_write_checkpoint_tf != nullptr, \"should be initialized\");\n-    return _jfr_write_checkpoint_tf;\n+    assert(_jfr_write_checkpoint_Type != nullptr, \"should be initialized\");\n+    return _jfr_write_checkpoint_Type;\n@@ -535,2 +442,2 @@\n-    assert(_flush_windows_tf != nullptr, \"should be initialized\");\n-    return _flush_windows_tf;\n+    assert(_flush_windows_Type != nullptr, \"should be initialized\");\n+    return _flush_windows_Type;\n@@ -541,1 +448,1 @@\n-    assert(_fast_arraycopy_tf != nullptr, \"should be initialized\");\n+    assert(_fast_arraycopy_Type != nullptr, \"should be initialized\");\n@@ -543,1 +450,1 @@\n-    return _fast_arraycopy_tf;\n+    return _fast_arraycopy_Type;\n@@ -547,1 +454,1 @@\n-    assert(_checkcast_arraycopy_tf != nullptr, \"should be initialized\");\n+    assert(_checkcast_arraycopy_Type != nullptr, \"should be initialized\");\n@@ -549,1 +456,1 @@\n-    return _checkcast_arraycopy_tf;\n+    return _checkcast_arraycopy_Type;\n@@ -553,1 +460,1 @@\n-    assert(_generic_arraycopy_tf != nullptr, \"should be initialized\");\n+    assert(_generic_arraycopy_Type != nullptr, \"should be initialized\");\n@@ -555,1 +462,1 @@\n-    return _generic_arraycopy_tf;\n+    return _generic_arraycopy_Type;\n@@ -559,1 +466,1 @@\n-    assert(_slow_arraycopy_tf != nullptr, \"should be initialized\");\n+    assert(_slow_arraycopy_Type != nullptr, \"should be initialized\");\n@@ -562,1 +469,1 @@\n-    return _slow_arraycopy_tf;\n+    return _slow_arraycopy_Type;\n@@ -565,3 +472,3 @@\n-  static inline const TypeFunc* make_setmemory_Type() {\n-    assert(_make_setmemory_tf != nullptr, \"should be initialized\");\n-    return _make_setmemory_tf;\n+  static inline const TypeFunc* unsafe_setmemory_Type() {\n+    assert(_unsafe_setmemory_Type != nullptr, \"should be initialized\");\n+    return _unsafe_setmemory_Type;\n@@ -571,2 +478,2 @@\n-    assert(_array_fill_tf != nullptr, \"should be initialized\");\n-    return _array_fill_tf;\n+    assert(_array_fill_Type != nullptr, \"should be initialized\");\n+    return _array_fill_Type;\n@@ -576,2 +483,2 @@\n-    assert(_array_sort_tf != nullptr, \"should be initialized\");\n-    return _array_sort_tf;\n+    assert(_array_sort_Type != nullptr, \"should be initialized\");\n+    return _array_sort_Type;\n@@ -581,2 +488,2 @@\n-    assert(_array_partition_tf != nullptr, \"should be initialized\");\n-    return _array_partition_tf;\n+    assert(_array_partition_Type != nullptr, \"should be initialized\");\n+    return _array_partition_Type;\n@@ -587,2 +494,2 @@\n-    assert(_aescrypt_block_tf != nullptr, \"should be initialized\");\n-    return _aescrypt_block_tf;\n+    assert(_aescrypt_block_Type != nullptr, \"should be initialized\");\n+    return _aescrypt_block_Type;\n@@ -593,2 +500,2 @@\n-    assert(_cipherBlockChaining_aescrypt_tf != nullptr, \"should be initialized\");\n-    return _cipherBlockChaining_aescrypt_tf;\n+    assert(_cipherBlockChaining_aescrypt_Type != nullptr, \"should be initialized\");\n+    return _cipherBlockChaining_aescrypt_Type;\n@@ -599,2 +506,2 @@\n-    assert(_electronicCodeBook_aescrypt_tf != nullptr, \"should be initialized\");\n-    return _electronicCodeBook_aescrypt_tf;\n+    assert(_electronicCodeBook_aescrypt_Type != nullptr, \"should be initialized\");\n+    return _electronicCodeBook_aescrypt_Type;\n@@ -605,2 +512,2 @@\n-    assert(_counterMode_aescrypt_tf != nullptr, \"should be initialized\");\n-    return _counterMode_aescrypt_tf;\n+    assert(_counterMode_aescrypt_Type != nullptr, \"should be initialized\");\n+    return _counterMode_aescrypt_Type;\n@@ -611,2 +518,2 @@\n-    assert(_galoisCounterMode_aescrypt_tf != nullptr, \"should be initialized\");\n-    return _galoisCounterMode_aescrypt_tf;\n+    assert(_galoisCounterMode_aescrypt_Type != nullptr, \"should be initialized\");\n+    return _galoisCounterMode_aescrypt_Type;\n@@ -619,3 +526,3 @@\n-    assert((_digestBase_implCompress_with_sha3_tf != nullptr) &&\n-           (_digestBase_implCompress_without_sha3_tf != nullptr), \"should be initialized\");\n-    return is_sha3 ? _digestBase_implCompress_with_sha3_tf : _digestBase_implCompress_without_sha3_tf;\n+    assert((_digestBase_implCompress_with_sha3_Type != nullptr) &&\n+           (_digestBase_implCompress_without_sha3_Type != nullptr), \"should be initialized\");\n+    return is_sha3 ? _digestBase_implCompress_with_sha3_Type : _digestBase_implCompress_without_sha3_Type;\n@@ -628,3 +535,3 @@\n-    assert((_digestBase_implCompressMB_with_sha3_tf != nullptr) &&\n-           (_digestBase_implCompressMB_without_sha3_tf != nullptr), \"should be initialized\");\n-    return is_sha3 ? _digestBase_implCompressMB_with_sha3_tf : _digestBase_implCompressMB_without_sha3_tf;\n+    assert((_digestBase_implCompressMB_with_sha3_Type != nullptr) &&\n+           (_digestBase_implCompressMB_without_sha3_Type != nullptr), \"should be initialized\");\n+    return is_sha3 ? _digestBase_implCompressMB_with_sha3_Type : _digestBase_implCompressMB_without_sha3_Type;\n@@ -634,2 +541,2 @@\n-    assert(_multiplyToLen_tf != nullptr, \"should be initialized\");\n-    return _multiplyToLen_tf;\n+    assert(_multiplyToLen_Type != nullptr, \"should be initialized\");\n+    return _multiplyToLen_Type;\n@@ -639,2 +546,2 @@\n-    assert(_montgomeryMultiply_tf != nullptr, \"should be initialized\");\n-    return _montgomeryMultiply_tf;\n+    assert(_montgomeryMultiply_Type != nullptr, \"should be initialized\");\n+    return _montgomeryMultiply_Type;\n@@ -644,2 +551,2 @@\n-    assert(_montgomerySquare_tf != nullptr, \"should be initialized\");\n-    return _montgomerySquare_tf;\n+    assert(_montgomerySquare_Type != nullptr, \"should be initialized\");\n+    return _montgomerySquare_Type;\n@@ -649,2 +556,2 @@\n-    assert(_squareToLen_tf != nullptr, \"should be initialized\");\n-    return _squareToLen_tf;\n+    assert(_squareToLen_Type != nullptr, \"should be initialized\");\n+    return _squareToLen_Type;\n@@ -655,2 +562,2 @@\n-    assert(_mulAdd_tf != nullptr, \"should be initialized\");\n-    return _mulAdd_tf;\n+    assert(_mulAdd_Type != nullptr, \"should be initialized\");\n+    return _mulAdd_Type;\n@@ -660,2 +567,2 @@\n-    assert(_bigIntegerShift_tf != nullptr, \"should be initialized\");\n-    return _bigIntegerShift_tf;\n+    assert(_bigIntegerShift_Type != nullptr, \"should be initialized\");\n+    return _bigIntegerShift_Type;\n@@ -665,2 +572,2 @@\n-    assert(_vectorizedMismatch_tf != nullptr, \"should be initialized\");\n-    return _vectorizedMismatch_tf;\n+    assert(_vectorizedMismatch_Type != nullptr, \"should be initialized\");\n+    return _vectorizedMismatch_Type;\n@@ -671,2 +578,2 @@\n-    assert(_ghash_processBlocks_tf != nullptr, \"should be initialized\");\n-    return _ghash_processBlocks_tf;\n+    assert(_ghash_processBlocks_Type != nullptr, \"should be initialized\");\n+    return _ghash_processBlocks_Type;\n@@ -677,2 +584,2 @@\n-    assert(_chacha20Block_tf != nullptr, \"should be initialized\");\n-    return _chacha20Block_tf;\n+    assert(_chacha20Block_Type != nullptr, \"should be initialized\");\n+    return _chacha20Block_Type;\n@@ -683,2 +590,2 @@\n-    assert(_base64_encodeBlock_tf != nullptr, \"should be initialized\");\n-    return _base64_encodeBlock_tf;\n+    assert(_base64_encodeBlock_Type != nullptr, \"should be initialized\");\n+    return _base64_encodeBlock_Type;\n@@ -689,2 +596,2 @@\n-    assert(_base64_decodeBlock_tf != nullptr, \"should be initialized\");\n-    return _base64_decodeBlock_tf;\n+    assert(_base64_decodeBlock_Type != nullptr, \"should be initialized\");\n+    return _base64_decodeBlock_Type;\n@@ -695,2 +602,2 @@\n-    assert(_string_IndexOf_tf != nullptr, \"should be initialized\");\n-    return _string_IndexOf_tf;\n+    assert(_string_IndexOf_Type != nullptr, \"should be initialized\");\n+    return _string_IndexOf_Type;\n@@ -701,2 +608,2 @@\n-    assert(_poly1305_processBlocks_tf != nullptr, \"should be initialized\");\n-    return _poly1305_processBlocks_tf;\n+    assert(_poly1305_processBlocks_Type != nullptr, \"should be initialized\");\n+    return _poly1305_processBlocks_Type;\n@@ -707,2 +614,2 @@\n-    assert(_intpoly_montgomeryMult_P256_tf != nullptr, \"should be initialized\");\n-    return _intpoly_montgomeryMult_P256_tf;\n+    assert(_intpoly_montgomeryMult_P256_Type != nullptr, \"should be initialized\");\n+    return _intpoly_montgomeryMult_P256_Type;\n@@ -713,2 +620,2 @@\n-    assert(_intpoly_assign_tf != nullptr, \"should be initialized\");\n-    return _intpoly_assign_tf;\n+    assert(_intpoly_assign_Type != nullptr, \"should be initialized\");\n+    return _intpoly_assign_Type;\n@@ -721,2 +628,2 @@\n-    assert(_updateBytesCRC32_tf != nullptr, \"should be initialized\");\n-    return _updateBytesCRC32_tf;\n+    assert(_updateBytesCRC32_Type != nullptr, \"should be initialized\");\n+    return _updateBytesCRC32_Type;\n@@ -729,2 +636,2 @@\n-    assert(_updateBytesCRC32C_tf != nullptr, \"should be initialized\");\n-    return _updateBytesCRC32C_tf;\n+    assert(_updateBytesCRC32C_Type != nullptr, \"should be initialized\");\n+    return _updateBytesCRC32C_Type;\n@@ -737,2 +644,2 @@\n-    assert(_updateBytesAdler32_tf != nullptr, \"should be initialized\");\n-    return _updateBytesAdler32_tf;\n+    assert(_updateBytesAdler32_Type != nullptr, \"should be initialized\");\n+    return _updateBytesAdler32_Type;\n@@ -744,2 +651,2 @@\n-    assert(_osr_end_tf != nullptr, \"should be initialized\");\n-    return _osr_end_tf;\n+    assert(_osr_end_Type != nullptr, \"should be initialized\");\n+    return _osr_end_Type;\n@@ -749,2 +656,2 @@\n-    assert(_register_finalizer_tf != nullptr, \"should be initialized\");\n-    return _register_finalizer_tf;\n+    assert(_register_finalizer_Type != nullptr, \"should be initialized\");\n+    return _register_finalizer_Type;\n@@ -755,2 +662,2 @@\n-    assert(_class_id_load_barrier_tf != nullptr, \"should be initialized\");\n-    return _class_id_load_barrier_tf;\n+    assert(_class_id_load_barrier_Type != nullptr, \"should be initialized\");\n+    return _class_id_load_barrier_Type;\n@@ -762,2 +669,2 @@\n-    assert(_notify_jvmti_vthread_tf != nullptr, \"should be initialized\");\n-    return _notify_jvmti_vthread_tf;\n+    assert(_notify_jvmti_vthread_Type != nullptr, \"should be initialized\");\n+    return _notify_jvmti_vthread_Type;\n@@ -769,2 +676,2 @@\n-    assert(_dtrace_method_entry_exit_tf != nullptr, \"should be initialized\");\n-    return _dtrace_method_entry_exit_tf;\n+    assert(_dtrace_method_entry_exit_Type != nullptr, \"should be initialized\");\n+    return _dtrace_method_entry_exit_Type;\n@@ -774,2 +681,2 @@\n-    assert(_dtrace_object_alloc_tf != nullptr, \"should be initialized\");\n-    return _dtrace_object_alloc_tf;\n+    assert(_dtrace_object_alloc_Type != nullptr, \"should be initialized\");\n+    return _dtrace_object_alloc_Type;\n@@ -779,2 +686,2 @@\n-    assert(_clone_type_tf != nullptr, \"should be initialized\");\n-    return _clone_type_tf;\n+    assert(_clone_type_Type != nullptr, \"should be initialized\");\n+    return _clone_type_Type;\n@@ -784,2 +691,2 @@\n-    assert(_load_reference_barrier_tf != nullptr, \"should be initialized\");\n-    return _load_reference_barrier_tf;\n+    assert(_load_reference_barrier_Type != nullptr, \"should be initialized\");\n+    return _load_reference_barrier_Type;\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":197,"deletions":290,"binary":false,"changes":487,"status":"modified"}]}