{"files":[{"patch":"@@ -10010,1 +10010,1 @@\n-    assert(0 == Type::cmp(mask1->bottom_type(), mask2->bottom_type()), \"\");\n+    assert(Type::equals(mask1->bottom_type(), mask2->bottom_type()), \"Mask types must be equal\");\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2727,1 +2727,1 @@\n-          assert(Type::cmp(vbox->vec_type(), cached_vbox->vec_type()) != 0, \"inconsistent\");\n+          assert(!Type::equals(vbox->vec_type(), cached_vbox->vec_type()), \"inconsistent\");\n@@ -2730,1 +2730,1 @@\n-          assert(Type::cmp(vbox->box_type(), cached_vbox->box_type()) != 0, \"inconsistent\");\n+          assert(!Type::equals(vbox->box_type(), cached_vbox->box_type()), \"inconsistent\");\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -859,1 +859,1 @@\n-  return !Type::cmp(_type, load._type) &&\n+  return Type::equals(_type, load._type) &&\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3014,1 +3014,1 @@\n-  return !Type::cmp(_type, ((TypeNode&)n)._type);\n+  return Type::equals(_type, n.as_Type()->_type);\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -402,3 +402,5 @@\n-int Type::cmp( const Type *const t1, const Type *const t2 ) {\n-  if( t1->_base != t2->_base )\n-    return 1;                   \/\/ Missed badly\n+bool Type::equals(const Type* t1, const Type* t2) {\n+  if (t1->_base != t2->_base) {\n+    return false; \/\/ Missed badly\n+  }\n+\n@@ -406,1 +408,1 @@\n-  return !t1->eq(t2);           \/\/ Return ZERO if equal\n+  return t1->eq(t2);\n@@ -436,3 +438,7 @@\n-  _shared_type_dict =\n-    new (shared_type_arena) Dict( (CmpKey)Type::cmp, (Hash)Type::uhash,\n-                                  shared_type_arena, 128 );\n+\n+  \/\/ Map the boolean result of Type::equals into a comparator result that CmpKey expects.\n+  CmpKey type_cmp = [](const void* t1, const void* t2) -> int32_t {\n+    return Type::equals((Type*) t1, (Type*) t2) ? 0 : 1;\n+  };\n+\n+  _shared_type_dict = new (shared_type_arena) Dict(type_cmp, (Hash) Type::uhash, shared_type_arena, 128);\n@@ -747,1 +753,1 @@\n-  if (cmp(this, _dual) == 0) {  \/\/ Handle self-symmetric\n+  if (equals(this, _dual)) {    \/\/ Handle self-symmetric\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -160,1 +160,1 @@\n-  \/\/ Structural equality check.  Assumes that cmp() has already compared\n+  \/\/ Structural equality check.  Assumes that equals() has already compared\n@@ -219,1 +219,1 @@\n-  static int cmp( const Type *const t1, const Type *const t2 );\n+  static bool equals(const Type* t1, const Type* t2);\n@@ -222,2 +222,2 @@\n-  bool higher_equal(const Type *t) const {\n-    return !cmp(meet(t),t->remove_speculative());\n+  bool higher_equal(const Type* t) const {\n+    return equals(meet(t), t->remove_speculative());\n@@ -226,2 +226,2 @@\n-  bool higher_equal_speculative(const Type *t) const {\n-    return !cmp(meet_speculative(t),t);\n+  bool higher_equal_speculative(const Type* t) const {\n+    return equals(meet_speculative(t), t);\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2602,1 +2602,1 @@\n-  } else if (Type::cmp(src_type, dst_type) != 0) {\n+  } else if (!Type::equals(src_type, dst_type)) {\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1671,1 +1671,1 @@\n-    if (Type::cmp(bottom_type(), n->in(1)->bottom_type()) == 0 &&\n+    if (Type::equals(bottom_type(), n->in(1)->bottom_type()) &&\n@@ -1688,1 +1688,1 @@\n-    if (Type::cmp(bottom_type(), n->in(VectorBoxNode::Value)->bottom_type()) == 0) {\n+    if (Type::equals(bottom_type(), n->in(VectorBoxNode::Value)->bottom_type())) {\n@@ -1725,1 +1725,1 @@\n-    if (Type::cmp(bottom_type(), n->in(VectorBoxNode::Value)->bottom_type()) == 0) {\n+    if (Type::equals(bottom_type(), n->in(VectorBoxNode::Value)->bottom_type())) {\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1550,1 +1550,1 @@\n-    return VectorNode::cmp(n) && !Type::cmp(_src_vt,((VectorReinterpretNode&)n)._src_vt);\n+    return VectorNode::cmp(n) && Type::equals(_src_vt, ((VectorReinterpretNode&) n)._src_vt);\n@@ -1686,1 +1686,1 @@\n-   assert(Type::cmp(vt, vsrc->bottom_type()) == 0, \"input and output must be same type\");\n+   assert(Type::equals(vt, vsrc->bottom_type()), \"input and output must be same type\");\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}