{"files":[{"patch":"@@ -1885,1 +1885,4 @@\n-    __ ldrb(r2, Address(r0, nmethod::state_offset()));\n+    \/\/ Load the _hdr pointer from the nmethod\n+    __ ldr(r2, Address(r0, nmethod::hdr_offset()));\n+    \/\/ Load _state value from _hdr at an offset specified by nmethod::state_offset()\n+    __ ldrb(r2, Address(r2, nmethod::state_offset()));\n@@ -1916,1 +1919,5 @@\n-    __ ldr(rscratch1, Address(r19, nmethod::osr_entry_point_offset()));\n+    \/\/ Load the _hdr pointer from the nmethod\n+    __ ldr(rscratch1, Address(r19, nmethod::hdr_offset()));\n+    \/\/ Load _osr_entry_point address from _hdr at an offset specified\n+    \/\/ by nmethod::osr_entry_point_offset()\n+    __ ldr(rscratch1, Address(rscratch1, nmethod::osr_entry_point_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2140,1 +2140,4 @@\n-    __ ldrb(R1_tmp, Address(Rnmethod, nmethod::state_offset()));\n+    \/\/ Load the _hdr pointer from the nmethod\n+    __ ldr(R1_tmp, Address(Rnmethod, nmethod::hdr_offset()));\n+    \/\/ Load _state value from _hdr at an offset specified by nmethod::state_offset()\n+    __ ldrb(R1_tmp, Address(R1_tmp, nmethod::state_offset()));\n@@ -2154,1 +2157,5 @@\n-    __ ldr(R1_tmp, Address(Rtmp_save0, nmethod::osr_entry_point_offset()));\n+    \/\/ Load the _hdr pointer from the nmethod\n+    __ ldr(R1_tmp, Address(Rtmp_save0, nmethod::hdr_offset()));\n+    \/\/ Load _osr_entry_point address from _hdr at an offset specified\n+    \/\/ by nmethod::osr_entry_point_offset()\n+    __ ldr(R1_tmp, Address(R1_tmp, nmethod::osr_entry_point_offset()));\n","filename":"src\/hotspot\/cpu\/arm\/templateTable_arm.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1723,1 +1723,4 @@\n-    __ lbz(R0, in_bytes(nmethod::state_offset()), R3_RET);\n+    \/\/ Load the _hdr pointer from the nmethod\n+    __ ld(R0, in_bytes(nmethod::hdr_offset()), R3_RET);\n+    \/\/ Load _state value from _hdr at an offset specified by nmethod::state_offset()\n+    __ lbz(R0, in_bytes(nmethod::state_offset()), R0);\n@@ -1744,1 +1747,5 @@\n-    __ ld(R11_scratch1, nmethod::osr_entry_point_offset(), osr_nmethod);\n+    \/\/ Load the _hdr pointer from the nmethod\n+    __ ld(R11_scratch1, in_bytes(nmethod::hdr_offset()), osr_nmethod);\n+    \/\/ Load _osr_entry_point address from _hdr at an offset specified\n+    \/\/ by nmethod::osr_entry_point_offset()\n+    __ ld(R11_scratch1, nmethod::osr_entry_point_offset(), R11_scratch1);\n","filename":"src\/hotspot\/cpu\/ppc\/templateTable_ppc_64.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1732,1 +1732,4 @@\n-    __ lbu(x12, Address(x10, nmethod::state_offset()));\n+    \/\/ Load the _hdr pointer from the nmethod\n+    __ ld(x12, Address(x10, nmethod::hdr_offset()));\n+    \/\/ Load _state value from _hdr at an offset specified by nmethod::state_offset()\n+    __ lbu(x12, Address(x12, nmethod::state_offset()));\n@@ -1764,1 +1767,5 @@\n-    __ ld(t1, Address(x9, nmethod::osr_entry_point_offset()));\n+    \/\/ Load the _hdr pointer from the nmethod\n+    __ ld(t1, Address(x9, nmethod::hdr_offset()));\n+    \/\/ Load _osr_entry_point address from _hdr at an offset specified\n+    \/\/ by nmethod::osr_entry_point_offset()\n+    __ ld(t1, Address(t1, nmethod::osr_entry_point_offset()));\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1991,1 +1991,4 @@\n-    __ z_cliy(in_bytes(nmethod::state_offset()), Z_RET, nmethod::in_use);\n+    \/\/ Load the _hdr pointer from the nmethod\n+    __ z_lg(Z_R1_scratch, Address(Z_RET, nmethod::hdr_offset()));\n+    \/\/ Load _state value from _hdr at an offset specified by nmethod::state_offset()\n+    __ z_cliy(in_bytes(nmethod::state_offset()), Z_R1_scratch, nmethod::in_use);\n@@ -2008,1 +2011,5 @@\n-    __ z_lg(Z_R1_scratch, Address(Z_tmp_1, nmethod::osr_entry_point_offset()));\n+    \/\/ Load the _hdr pointer from the nmethod\n+    __ z_lg(Z_R1_scratch, Address(Z_tmp_1, nmethod::hdr_offset()));\n+    \/\/ Load _osr_entry_point address from _hdr at an offset specified\n+    \/\/ by nmethod::osr_entry_point_offset()\n+    __ z_lg(Z_R1_scratch, Address(Z_R1_scratch, nmethod::osr_entry_point_offset()));\n","filename":"src\/hotspot\/cpu\/s390\/templateTable_s390.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1816,1 +1816,5 @@\n-      __ cmpb(Address(rax, nmethod::state_offset()), nmethod::in_use);\n+      \/\/ Load the _hdr pointer from the nmethod into rscratch1\n+      __ movptr(rscratch1, Address(rax, nmethod::hdr_offset()));\n+      \/\/ Load the _state value from _hdr pointer at an offset specified by\n+      \/\/ nmethod::state_offset() and compare it with nmethod::in_use\n+      __ cmpb(Address(rscratch1, nmethod::state_offset()), nmethod::in_use);\n@@ -1852,1 +1856,4 @@\n-      __ jmp(Address(rbx, nmethod::osr_entry_point_offset()));\n+      \/\/ Load the _hdr pointer from the nmethod into rscratch1\n+      __ movptr(rscratch1, Address(rbx, nmethod::hdr_offset()));\n+      \/\/ Jump to the address in _osr_entry_point (which is at an offset from _hdr pointer)\n+      __ jmp(Address(rscratch1, nmethod::osr_entry_point_offset()));\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -207,0 +207,16 @@\n+CodeBlob::~CodeBlob() {\n+  assert(_oop_maps == nullptr, \"Not flushed\");\n+\n+  \/\/ If the CodeBlob is an nmethod, the _hdr pointer needs to be freed\n+  \/\/ up at this point\n+  if (is_nmethod()) {\n+    nmethod* nm = as_nmethod();\n+    nmethod::NMethodHeader* hdr = nm->hdr();\n+\n+    if (hdr != nullptr) {\n+      nm->set_hdr(nullptr);\n+      delete hdr;\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -177,3 +177,1 @@\n-  ~CodeBlob() {\n-    assert(_oop_maps == nullptr, \"Not flushed\");\n-  }\n+  ~CodeBlob();\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -487,2 +487,2 @@\n-  if (_deoptimization_status != deoptimize_done) { \/\/ can't go backwards\n-    AtomicAccess::store(&_deoptimization_status, deoptimize_done);\n+  if (_hdr->_deoptimization_status != NMethodHeader::deoptimize_done) { \/\/ can't go backwards\n+    AtomicAccess::store(&_hdr->_deoptimization_status, NMethodHeader::deoptimize_done);\n@@ -493,1 +493,1 @@\n-  return AtomicAccess::load_acquire(&_exception_cache);\n+  return AtomicAccess::load_acquire(&_hdr->_exception_cache);\n@@ -513,1 +513,1 @@\n-        if (AtomicAccess::cmpxchg(&_exception_cache, ec, next) == ec) {\n+        if (AtomicAccess::cmpxchg(&_hdr->_exception_cache, ec, next) == ec) {\n@@ -523,1 +523,1 @@\n-    if (AtomicAccess::cmpxchg(&_exception_cache, ec, new_entry) == ec) {\n+    if (AtomicAccess::cmpxchg(&_hdr->_exception_cache, ec, new_entry) == ec) {\n@@ -556,1 +556,1 @@\n-        if (AtomicAccess::cmpxchg(&_exception_cache, curr, next) != curr) {\n+        if (AtomicAccess::cmpxchg(&_hdr->_exception_cache, curr, next) != curr) {\n@@ -990,3 +990,3 @@\n-             _method->method_holder()->external_name(),\n-             _method->name()->as_C_string(),\n-             _method->signature()->as_C_string(),\n+             _hdr->_method->method_holder()->external_name(),\n+             _hdr->_method->name()->as_C_string(),\n+             _hdr->_method->signature()->as_C_string(),\n@@ -1021,1 +1021,1 @@\n-  return compilertype2name(_compiler_type);\n+  return compilertype2name(_hdr->_compiler_type);\n@@ -1219,4 +1219,4 @@\n-  _exception_cache            = nullptr;\n-  _gc_data                    = nullptr;\n-  _oops_do_mark_link          = nullptr;\n-  _compiled_ic_data           = nullptr;\n+  _hdr->_exception_cache            = nullptr;\n+  _hdr->_gc_data                    = nullptr;\n+  _hdr->_oops_do_mark_link          = nullptr;\n+  _hdr->_compiled_ic_data           = nullptr;\n@@ -1224,2 +1224,2 @@\n-  _is_unloading_state         = 0;\n-  _state                      = not_installed;\n+  _hdr->_is_unloading_state         = 0;\n+  _hdr->_state                      = not_installed;\n@@ -1227,7 +1227,7 @@\n-  _has_unsafe_access          = 0;\n-  _has_wide_vectors           = 0;\n-  _has_monitors               = 0;\n-  _has_scoped_access          = 0;\n-  _has_flushed_dependencies   = 0;\n-  _is_unlinked                = 0;\n-  _load_reported              = 0; \/\/ jvmti state\n+  _hdr->_has_unsafe_access          = 0;\n+  _hdr->_has_wide_vectors           = 0;\n+  _hdr->_has_monitors               = 0;\n+  _hdr->_has_scoped_access          = 0;\n+  _hdr->_has_flushed_dependencies   = 0;\n+  _hdr->_is_unlinked                = 0;\n+  _hdr->_load_reported              = 0; \/\/ jvmti state\n@@ -1235,1 +1235,1 @@\n-  _deoptimization_status      = not_marked;\n+  _hdr->_deoptimization_status      = NMethodHeader::not_marked;\n@@ -1241,1 +1241,1 @@\n-  _stub_offset = content_offset() + code_buffer->total_offset_of(code_buffer->stubs());\n+  _hdr->_stub_offset = content_offset() + code_buffer->total_offset_of(code_buffer->stubs());\n@@ -1243,2 +1243,2 @@\n-  CHECKED_CAST(_entry_offset,              uint16_t, (offsets->value(CodeOffsets::Entry)));\n-  CHECKED_CAST(_verified_entry_offset,     uint16_t, (offsets->value(CodeOffsets::Verified_Entry)));\n+  CHECKED_CAST(_hdr->_entry_offset,              uint16_t, (offsets->value(CodeOffsets::Entry)));\n+  CHECKED_CAST(_hdr->_verified_entry_offset,     uint16_t, (offsets->value(CodeOffsets::Verified_Entry)));\n@@ -1246,1 +1246,1 @@\n-  _skipped_instructions_size = code_buffer->total_skipped_instructions_size();\n+  _hdr->_skipped_instructions_size = code_buffer->total_skipped_instructions_size();\n@@ -1275,6 +1275,1 @@\n-             offsets->value(CodeOffsets::Frame_Complete), frame_size, oop_maps, false, mutable_data_size),\n-  _deoptimization_generation(0),\n-  _gc_epoch(CodeCache::gc_epoch()),\n-  _method(method),\n-  _native_receiver_sp_offset(basic_lock_owner_sp_offset),\n-  _native_basic_lock_sp_offset(basic_lock_sp_offset)\n+             offsets->value(CodeOffsets::Frame_Complete), frame_size, oop_maps, false, mutable_data_size)\n@@ -1286,0 +1281,6 @@\n+    \/\/ Allocate space for NMethodHeader in C Heap\n+    _hdr = new NMethodHeader();\n+    if (_hdr == nullptr) {\n+      vm_exit_out_of_memory(sizeof(NMethodHeader), OOM_MALLOC_ERROR, \"no space for NMethodHeader\");\n+    }\n+\n@@ -1288,8 +1289,13 @@\n-    _osr_entry_point         = nullptr;\n-    _pc_desc_container       = nullptr;\n-    _entry_bci               = InvocationEntryBci;\n-    _compile_id              = compile_id;\n-    _comp_level              = CompLevel_none;\n-    _compiler_type           = type;\n-    _orig_pc_offset          = 0;\n-    _num_stack_arg_slots     = 0;\n+    _hdr->_deoptimization_generation = 0;\n+    _hdr->_gc_epoch = CodeCache::gc_epoch();\n+    _hdr->_method = method;\n+    _hdr->_native_receiver_sp_offset = basic_lock_owner_sp_offset;\n+    _hdr->_native_basic_lock_sp_offset = basic_lock_sp_offset;\n+    _hdr->_osr_entry_point         = nullptr;\n+    _hdr->_pc_desc_container       = nullptr;\n+    _hdr->_entry_bci               = InvocationEntryBci;\n+    _hdr->_compile_id              = compile_id;\n+    _hdr->_comp_level              = CompLevel_none;\n+    _hdr->_compiler_type           = type;\n+    _hdr->_orig_pc_offset          = 0;\n+    _hdr->_num_stack_arg_slots     = 0;\n@@ -1299,1 +1305,1 @@\n-      _exception_offset      = code_offset() + offsets->value(CodeOffsets::Exceptions);\n+      _hdr->_exception_offset      = code_offset() + offsets->value(CodeOffsets::Exceptions);\n@@ -1301,1 +1307,1 @@\n-      _exception_offset      = 0;\n+      _hdr->_exception_offset      = 0;\n@@ -1305,2 +1311,2 @@\n-    _deopt_handler_entry_offset    = 0;\n-    _unwind_handler_offset   = 0;\n+    _hdr->_deopt_handler_entry_offset   = 0;\n+    _hdr->_unwind_handler_offset   = 0;\n@@ -1308,1 +1314,1 @@\n-    CHECKED_CAST(_oops_size, uint16_t, align_up(code_buffer->total_oop_size(), oopSize));\n+    CHECKED_CAST(_hdr->_oops_size, uint16_t, align_up(code_buffer->total_oop_size(), oopSize));\n@@ -1311,1 +1317,1 @@\n-    JVMCI_ONLY( _metadata_size = metadata_size; )\n+    JVMCI_ONLY( _hdr->_metadata_size = metadata_size; )\n@@ -1317,6 +1323,6 @@\n-    _immutable_data          = blob_end();\n-    _immutable_data_size     = 0;\n-    _nul_chk_table_offset    = 0;\n-    _handler_table_offset    = 0;\n-    _scopes_pcs_offset       = 0;\n-    _scopes_data_offset      = 0;\n+    _hdr->_immutable_data          = blob_end();\n+    _hdr->_immutable_data_size     = 0;\n+    _hdr->_nul_chk_table_offset    = 0;\n+    _hdr->_handler_table_offset    = 0;\n+    _hdr->_scopes_pcs_offset       = 0;\n+    _hdr->_scopes_data_offset      = 0;\n@@ -1324,1 +1330,1 @@\n-    _speculations_offset     = 0;\n+    _hdr->_speculations_offset     = 0;\n@@ -1326,1 +1332,1 @@\n-    _immutable_data_ref_count_offset = 0;\n+    _hdr->_immutable_data_ref_count_offset = 0;\n@@ -1341,1 +1347,1 @@\n-      xtty->method(_method);\n+      xtty->method(_hdr->_method);\n@@ -1420,4 +1426,10 @@\n-  _deoptimization_generation    = 0;\n-  _gc_epoch                     = CodeCache::gc_epoch();\n-  _method                       = nm._method;\n-  _osr_link                     = nullptr;\n+   \/\/ Allocate space for NMethodHeader in C Heap\n+  _hdr = new NMethodHeader();\n+  if (_hdr == nullptr) {\n+    vm_exit_out_of_memory(sizeof(NMethodHeader), OOM_MALLOC_ERROR, \"no space for NMethodHeader\");\n+  }\n+\n+  _hdr->_deoptimization_generation    = 0;\n+  _hdr->_gc_epoch                     = CodeCache::gc_epoch();\n+  _hdr->_method                       = nm._hdr->_method;\n+  _hdr->_osr_link                     = nullptr;\n@@ -1425,2 +1437,2 @@\n-  _exception_cache              = nullptr;\n-  _gc_data                      = nullptr;\n+  _hdr->_exception_cache              = nullptr;\n+  _hdr->_gc_data                      = nullptr;\n@@ -1428,2 +1440,2 @@\n-  _oops_do_mark_link            = nullptr;\n-  _compiled_ic_data             = nullptr;\n+  _hdr->_oops_do_mark_link            = nullptr;\n+  _hdr->_compiled_ic_data             = nullptr;\n@@ -1431,2 +1443,2 @@\n-  if (nm._osr_entry_point != nullptr) {\n-    _osr_entry_point            = (nm._osr_entry_point - (address) &nm) + (address) this;\n+  if (nm._hdr->_osr_entry_point != nullptr) {\n+    _hdr->_osr_entry_point            = (nm._hdr->_osr_entry_point - (address) &nm) + (address) this;\n@@ -1434,1 +1446,1 @@\n-    _osr_entry_point            = nullptr;\n+    _hdr->_osr_entry_point            = nullptr;\n@@ -1437,4 +1449,4 @@\n-  _entry_offset                 = nm._entry_offset;\n-  _verified_entry_offset        = nm._verified_entry_offset;\n-  _entry_bci                    = nm._entry_bci;\n-  _immutable_data_size          = nm._immutable_data_size;\n+  _hdr->_entry_offset                 = nm._hdr->_entry_offset;\n+  _hdr->_verified_entry_offset        = nm._hdr->_verified_entry_offset;\n+  _hdr->_entry_bci                    = nm._hdr->_entry_bci;\n+  _hdr->_immutable_data_size          = nm._hdr->_immutable_data_size;\n@@ -1442,7 +1454,7 @@\n-  _skipped_instructions_size    = nm._skipped_instructions_size;\n-  _stub_offset                  = nm._stub_offset;\n-  _exception_offset             = nm._exception_offset;\n-  _deopt_handler_entry_offset   = nm._deopt_handler_entry_offset;\n-  _unwind_handler_offset        = nm._unwind_handler_offset;\n-  _num_stack_arg_slots          = nm._num_stack_arg_slots;\n-  _oops_size                    = nm._oops_size;\n+  _hdr->_skipped_instructions_size    = nm._hdr->_skipped_instructions_size;\n+  _hdr->_stub_offset                  = nm._hdr->_stub_offset;\n+  _hdr->_exception_offset             = nm._hdr->_exception_offset;\n+  _hdr->_deopt_handler_entry_offset   = nm._hdr->_deopt_handler_entry_offset;\n+  _hdr->_unwind_handler_offset        = nm._hdr->_unwind_handler_offset;\n+  _hdr->_num_stack_arg_slots          = nm._hdr->_num_stack_arg_slots;\n+  _hdr->_oops_size                    = nm._hdr->_oops_size;\n@@ -1450,1 +1462,1 @@\n-  _metadata_size                = nm._metadata_size;\n+  _hdr->_metadata_size                = nm._hdr->_metadata_size;\n@@ -1452,4 +1464,4 @@\n-  _nul_chk_table_offset         = nm._nul_chk_table_offset;\n-  _handler_table_offset         = nm._handler_table_offset;\n-  _scopes_pcs_offset            = nm._scopes_pcs_offset;\n-  _scopes_data_offset           = nm._scopes_data_offset;\n+  _hdr->_nul_chk_table_offset         = nm._hdr->_nul_chk_table_offset;\n+  _hdr->_handler_table_offset         = nm._hdr->_handler_table_offset;\n+  _hdr->_scopes_pcs_offset            = nm._hdr->_scopes_pcs_offset;\n+  _hdr->_scopes_data_offset           = nm._hdr->_scopes_data_offset;\n@@ -1457,1 +1469,1 @@\n-  _speculations_offset          = nm._speculations_offset;\n+  _hdr->_speculations_offset          = nm._hdr->_speculations_offset;\n@@ -1459,1 +1471,1 @@\n-  _immutable_data_ref_count_offset = nm._immutable_data_ref_count_offset;\n+  _hdr->_immutable_data_ref_count_offset = nm._hdr->_immutable_data_ref_count_offset;\n@@ -1462,2 +1474,2 @@\n-  if (_immutable_data_size > 0) {\n-    _immutable_data             = nm._immutable_data;\n+  if (_hdr->_immutable_data_size > 0) {\n+    _hdr->_immutable_data             = nm._hdr->_immutable_data;\n@@ -1466,1 +1478,1 @@\n-    _immutable_data             = blob_end();\n+    _hdr->_immutable_data             = blob_end();\n@@ -1469,6 +1481,6 @@\n-  _orig_pc_offset               = nm._orig_pc_offset;\n-  _compile_id                   = nm._compile_id;\n-  _comp_level                   = nm._comp_level;\n-  _compiler_type                = nm._compiler_type;\n-  _is_unloading_state           = nm._is_unloading_state;\n-  _state                        = not_installed;\n+  _hdr->_orig_pc_offset               = nm._hdr->_orig_pc_offset;\n+  _hdr->_compile_id                   = nm._hdr->_compile_id;\n+  _hdr->_comp_level                   = nm._hdr->_comp_level;\n+  _hdr->_compiler_type                = nm._hdr->_compiler_type;\n+  _hdr->_is_unloading_state           = nm._hdr->_is_unloading_state;\n+  _hdr->_state                        = not_installed;\n@@ -1476,7 +1488,7 @@\n-  _has_unsafe_access            = nm._has_unsafe_access;\n-  _has_wide_vectors             = nm._has_wide_vectors;\n-  _has_monitors                 = nm._has_monitors;\n-  _has_scoped_access            = nm._has_scoped_access;\n-  _has_flushed_dependencies     = nm._has_flushed_dependencies;\n-  _is_unlinked                  = nm._is_unlinked;\n-  _load_reported                = nm._load_reported;\n+  _hdr->_has_unsafe_access            = nm._hdr->_has_unsafe_access;\n+  _hdr->_has_wide_vectors             = nm._hdr->_has_wide_vectors;\n+  _hdr->_has_monitors                 = nm._hdr->_has_monitors;\n+  _hdr->_has_scoped_access            = nm._hdr->_has_scoped_access;\n+  _hdr->_has_flushed_dependencies     = nm._hdr->_has_flushed_dependencies;\n+  _hdr->_is_unlinked                  = nm._hdr->_is_unlinked;\n+  _hdr->_load_reported                = nm._hdr->_load_reported;\n@@ -1484,1 +1496,1 @@\n-  _deoptimization_status        = nm._deoptimization_status;\n+  _hdr->_deoptimization_status        = nm._hdr->_deoptimization_status;\n@@ -1486,2 +1498,2 @@\n-  if (nm._pc_desc_container != nullptr) {\n-    _pc_desc_container          = new PcDescContainer(scopes_pcs_begin());\n+  if (nm._hdr->_pc_desc_container != nullptr) {\n+    _hdr->_pc_desc_container          = new PcDescContainer(scopes_pcs_begin());\n@@ -1489,1 +1501,1 @@\n-    _pc_desc_container          = nullptr;\n+    _hdr->_pc_desc_container          = nullptr;\n@@ -1674,5 +1686,1 @@\n-             offsets->value(CodeOffsets::Frame_Complete), frame_size, oop_maps, false, mutable_data_size),\n-  _deoptimization_generation(0),\n-  _gc_epoch(CodeCache::gc_epoch()),\n-  _method(method),\n-  _osr_link(nullptr)\n+             offsets->value(CodeOffsets::Frame_Complete), frame_size, oop_maps, false, mutable_data_size)\n@@ -1685,0 +1693,6 @@\n+    \/\/ Allocate space for NMethodHeader in C Heap\n+    _hdr = new NMethodHeader();\n+    if (_hdr == nullptr) {\n+      vm_exit_out_of_memory(sizeof(NMethodHeader), OOM_MALLOC_ERROR, \"no space for NMethodHeader\");\n+    }\n+\n@@ -1687,6 +1701,10 @@\n-    _osr_entry_point = code_begin() + offsets->value(CodeOffsets::OSR_Entry);\n-    _entry_bci       = entry_bci;\n-    _compile_id      = compile_id;\n-    _comp_level      = comp_level;\n-    _compiler_type   = type;\n-    _orig_pc_offset  = orig_pc_offset;\n+    _hdr->_deoptimization_generation = 0;\n+    _hdr->_gc_epoch = CodeCache::gc_epoch();\n+    _hdr->_method = method;\n+    _hdr->_osr_link = nullptr;\n+    _hdr->_osr_entry_point = code_begin() + offsets->value(CodeOffsets::OSR_Entry);\n+    _hdr->_entry_bci       = entry_bci;\n+    _hdr->_compile_id      = compile_id;\n+    _hdr->_comp_level      = comp_level;\n+    _hdr->_compiler_type   = type;\n+    _hdr->_orig_pc_offset  = orig_pc_offset;\n@@ -1694,1 +1712,1 @@\n-    _num_stack_arg_slots = entry_bci != InvocationEntryBci ? 0 : _method->constMethod()->num_stack_arg_slots();\n+    _hdr->_num_stack_arg_slots = entry_bci != InvocationEntryBci ? 0 : _hdr->_method->constMethod()->num_stack_arg_slots();\n@@ -1702,1 +1720,1 @@\n-        _exception_offset        = code_offset() + offsets->value(CodeOffsets::Exceptions);\n+        _hdr->_exception_offset        = code_offset() + offsets->value(CodeOffsets::Exceptions);\n@@ -1704,1 +1722,1 @@\n-        _exception_offset        = -1;\n+        _hdr->_exception_offset        = -1;\n@@ -1707,1 +1725,1 @@\n-        _deopt_handler_entry_offset    = code_offset() + offsets->value(CodeOffsets::Deopt);\n+        _hdr->_deopt_handler_entry_offset    = code_offset() + offsets->value(CodeOffsets::Deopt);\n@@ -1709,1 +1727,1 @@\n-        _deopt_handler_entry_offset    = -1;\n+        _hdr->_deopt_handler_entry_offset    = -1;\n@@ -1721,1 +1739,1 @@\n-        _exception_offset = _stub_offset + offsets->value(CodeOffsets::Exceptions);\n+        _hdr->_exception_offset = _hdr->_stub_offset + offsets->value(CodeOffsets::Exceptions);\n@@ -1723,1 +1741,1 @@\n-        _exception_offset = -1;\n+        _hdr->_exception_offset = -1;\n@@ -1726,1 +1744,1 @@\n-      _deopt_handler_entry_offset = _stub_offset + offsets->value(CodeOffsets::Deopt);\n+      _hdr->_deopt_handler_entry_offset = _hdr->_stub_offset + offsets->value(CodeOffsets::Deopt);\n@@ -1733,1 +1751,1 @@\n-      CHECKED_CAST(_unwind_handler_offset, int16_t, (_stub_offset - unwind_handler_offset));\n+      CHECKED_CAST(_hdr->_unwind_handler_offset, int16_t, (_hdr->_stub_offset - unwind_handler_offset));\n@@ -1735,1 +1753,1 @@\n-      _unwind_handler_offset = -1;\n+      _hdr->_unwind_handler_offset = -1;\n@@ -1738,1 +1756,1 @@\n-    CHECKED_CAST(_oops_size, uint16_t, align_up(code_buffer->total_oop_size(), oopSize));\n+    CHECKED_CAST(_hdr->_oops_size, uint16_t, align_up(code_buffer->total_oop_size(), oopSize));\n@@ -1741,1 +1759,1 @@\n-    JVMCI_ONLY( _metadata_size = metadata_size; )\n+    JVMCI_ONLY( _hdr->_metadata_size = metadata_size; )\n@@ -1749,1 +1767,1 @@\n-    _immutable_data_size  = immutable_data_size;\n+    _hdr->_immutable_data_size  = immutable_data_size;\n@@ -1752,1 +1770,1 @@\n-      _immutable_data     = immutable_data;\n+      _hdr->_immutable_data     = immutable_data;\n@@ -1755,1 +1773,1 @@\n-      _immutable_data     = blob_end();\n+      _hdr->_immutable_data     = blob_end();\n@@ -1757,4 +1775,4 @@\n-    CHECKED_CAST(_nul_chk_table_offset, uint16_t, (align_up((int)dependencies->size_in_bytes(), oopSize)));\n-    CHECKED_CAST(_handler_table_offset, uint16_t, (_nul_chk_table_offset + align_up(nul_chk_table->size_in_bytes(), oopSize)));\n-    _scopes_pcs_offset    = _handler_table_offset + align_up(handler_table->size_in_bytes(), oopSize);\n-    _scopes_data_offset   = _scopes_pcs_offset    + adjust_pcs_size(debug_info->pcs_size());\n+    CHECKED_CAST(_hdr->_nul_chk_table_offset, uint16_t, (align_up((int)dependencies->size_in_bytes(), oopSize)));\n+    CHECKED_CAST(_hdr->_handler_table_offset, uint16_t, (_hdr->_nul_chk_table_offset + align_up(nul_chk_table->size_in_bytes(), oopSize)));\n+    _hdr->_scopes_pcs_offset    = _hdr->_handler_table_offset + align_up(handler_table->size_in_bytes(), oopSize);\n+    _hdr->_scopes_data_offset   = _hdr->_scopes_pcs_offset    + adjust_pcs_size(debug_info->pcs_size());\n@@ -1763,2 +1781,2 @@\n-    _speculations_offset  = _scopes_data_offset   + align_up(debug_info->data_size(), oopSize);\n-    _immutable_data_ref_count_offset = _speculations_offset + align_up(speculations_len, oopSize);\n+    _hdr->_speculations_offset  = _hdr->_scopes_data_offset   + align_up(debug_info->data_size(), oopSize);\n+    _hdr->_immutable_data_ref_count_offset = _hdr->_speculations_offset + align_up(speculations_len, oopSize);\n@@ -1766,1 +1784,1 @@\n-    _immutable_data_ref_count_offset = _scopes_data_offset + align_up(debug_info->data_size(), oopSize);\n+    _hdr->_immutable_data_ref_count_offset = _hdr->_scopes_data_offset + align_up(debug_info->data_size(), oopSize);\n@@ -1768,1 +1786,1 @@\n-    DEBUG_ONLY( int immutable_data_end_offset = _immutable_data_ref_count_offset + ImmutableDataRefCountSize; )\n+    DEBUG_ONLY( int immutable_data_end_offset = _hdr->_immutable_data_ref_count_offset + ImmutableDataRefCountSize; )\n@@ -1781,1 +1799,1 @@\n-    _pc_desc_container = new PcDescContainer(scopes_pcs_begin());\n+    _hdr->_pc_desc_container = new PcDescContainer(scopes_pcs_begin());\n@@ -1807,1 +1825,1 @@\n-           _method->is_static() == (entry_point() == verified_entry_point()),\n+           _hdr->_method->is_static() == (entry_point() == verified_entry_point()),\n@@ -1969,1 +1987,1 @@\n-    methodHandle mh(Thread::current(), _method);\n+    methodHandle mh(Thread::current(), _hdr->_method);\n@@ -2097,2 +2115,2 @@\n-    _compiled_ic_data = new CompiledICData[virtual_call_data.length()];\n-    CompiledICData* next_data = _compiled_ic_data;\n+    _hdr->_compiled_ic_data = new CompiledICData[virtual_call_data.length()];\n+    CompiledICData* next_data = _hdr->_compiled_ic_data;\n@@ -2203,1 +2221,1 @@\n-  AtomicAccess::store(&_gc_epoch, CodeCache::gc_epoch());\n+  AtomicAccess::store(&_hdr->_gc_epoch, CodeCache::gc_epoch());\n@@ -2209,1 +2227,1 @@\n-  return AtomicAccess::load(&_gc_epoch) >= CodeCache::previous_completed_gc_marking_cycle();\n+  return AtomicAccess::load(&_hdr->_gc_epoch) >= CodeCache::previous_completed_gc_marking_cycle();\n@@ -2231,1 +2249,1 @@\n-  signed char old_state = _state;\n+  signed char old_state = _hdr->_state;\n@@ -2236,1 +2254,1 @@\n-  AtomicAccess::store(&_state, new_state);\n+  AtomicAccess::store(&_hdr->_state, new_state);\n@@ -2241,1 +2259,1 @@\n-  assert(_entry_bci != InvocationEntryBci, \"wrong kind of nmethod\");\n+  assert(_hdr->_entry_bci != InvocationEntryBci, \"wrong kind of nmethod\");\n@@ -2287,1 +2305,1 @@\n-  if (AtomicAccess::load(&_state) == not_entrant) {\n+  if (AtomicAccess::load(&_hdr->_state) == not_entrant) {\n@@ -2299,1 +2317,1 @@\n-    if (AtomicAccess::load(&_state) == not_entrant) {\n+    if (AtomicAccess::load(&_hdr->_state) == not_entrant) {\n@@ -2414,1 +2432,1 @@\n-              _compile_id, p2i(this), _comp_level, is_osr_method(), is_cold(), _gc_epoch, CodeCache::cold_gc_count(),\n+              _hdr->_compile_id, p2i(this), _hdr->_comp_level, is_osr_method(), is_cold(), _hdr->_gc_epoch, CodeCache::cold_gc_count(),\n@@ -2427,2 +2445,2 @@\n-  if (_pc_desc_container != nullptr) {\n-    delete _pc_desc_container;\n+  if (_hdr->_pc_desc_container != nullptr) {\n+    delete _hdr->_pc_desc_container;\n@@ -2430,1 +2448,1 @@\n-  delete[] _compiled_ic_data;\n+  delete[] _hdr->_compiled_ic_data;\n@@ -2432,1 +2450,1 @@\n-  if (_immutable_data != blob_end()) {\n+  if (_hdr->_immutable_data != blob_end()) {\n@@ -2435,1 +2453,1 @@\n-      os::free(_immutable_data);\n+      os::free(_hdr->_immutable_data);\n@@ -2438,1 +2456,1 @@\n-    _immutable_data = blob_end(); \/\/ Valid not null address\n+    _hdr->_immutable_data = blob_end(); \/\/ Valid not null address\n@@ -2446,1 +2464,1 @@\n-  JVMCI_ONLY( _metadata_size = 0; )\n+  JVMCI_ONLY( _hdr->_metadata_size = 0; )\n@@ -2586,1 +2604,1 @@\n-  assert(_method != nullptr, \"just checking\");\n+  assert(_hdr->_method != nullptr, \"just checking\");\n@@ -2617,1 +2635,1 @@\n-          if (md != _method) f->do_metadata(md);\n+          if (md != _hdr->_method) f->do_metadata(md);\n@@ -2636,1 +2654,1 @@\n-  if (_method != nullptr) f->do_metadata(_method);\n+  if (_hdr->_method != nullptr) f->do_metadata(_hdr->_method);\n@@ -2668,1 +2686,1 @@\n-  return CodeCache::previous_completed_gc_marking_cycle() > _gc_epoch + 2 * CodeCache::cold_gc_count();\n+  return CodeCache::previous_completed_gc_marking_cycle() > _hdr->_gc_epoch + 2 * CodeCache::cold_gc_count();\n@@ -2712,1 +2730,1 @@\n-  uint8_t state = AtomicAccess::load(&_is_unloading_state);\n+  uint8_t state = AtomicAccess::load(&_hdr->_is_unloading_state);\n@@ -2735,1 +2753,1 @@\n-  uint8_t found_state = AtomicAccess::cmpxchg(&_is_unloading_state, state, new_state, memory_order_relaxed);\n+  uint8_t found_state = AtomicAccess::cmpxchg(&_hdr->_is_unloading_state, state, new_state, memory_order_relaxed);\n@@ -2748,1 +2766,1 @@\n-  AtomicAccess::store(&_is_unloading_state, state);\n+  AtomicAccess::store(&_hdr->_is_unloading_state, state);\n@@ -2832,2 +2850,2 @@\n-  if ((_oops_do_mark_link == nullptr) &&\n-      (AtomicAccess::replace_if_null(&_oops_do_mark_link, mark_link(this, claim_weak_request_tag)))) {\n+  if ((_hdr->_oops_do_mark_link == nullptr) &&\n+      (AtomicAccess::replace_if_null(&_hdr->_oops_do_mark_link, mark_link(this, claim_weak_request_tag)))) {\n@@ -2841,1 +2859,1 @@\n-  _oops_do_mark_link = mark_link(old_head, claim_strong_done_tag);\n+  _hdr->_oops_do_mark_link = mark_link(old_head, claim_strong_done_tag);\n@@ -2844,1 +2862,1 @@\n-nmethod::oops_do_mark_link* nmethod::oops_do_try_claim_strong_done() {\n+nmethod::NMethodHeader::oops_do_mark_link* nmethod::oops_do_try_claim_strong_done() {\n@@ -2847,1 +2865,1 @@\n-  oops_do_mark_link* old_next = AtomicAccess::cmpxchg(&_oops_do_mark_link, mark_link(nullptr, claim_weak_request_tag), mark_link(this, claim_strong_done_tag));\n+  nmethod::NMethodHeader::oops_do_mark_link* old_next = AtomicAccess::cmpxchg(&_hdr->_oops_do_mark_link, mark_link(nullptr, claim_weak_request_tag), mark_link(this, claim_strong_done_tag));\n@@ -2854,1 +2872,1 @@\n-nmethod::oops_do_mark_link* nmethod::oops_do_try_add_strong_request(nmethod::oops_do_mark_link* next) {\n+nmethod::NMethodHeader::oops_do_mark_link* nmethod::oops_do_try_add_strong_request(NMethodHeader::oops_do_mark_link* next) {\n@@ -2858,1 +2876,1 @@\n-  oops_do_mark_link* old_next = AtomicAccess::cmpxchg(&_oops_do_mark_link, next, mark_link(this, claim_strong_request_tag));\n+  nmethod::NMethodHeader::oops_do_mark_link* old_next = AtomicAccess::cmpxchg(&_hdr->_oops_do_mark_link, next, mark_link(this, claim_strong_request_tag));\n@@ -2865,1 +2883,1 @@\n-bool nmethod::oops_do_try_claim_weak_done_as_strong_done(nmethod::oops_do_mark_link* next) {\n+bool nmethod::oops_do_try_claim_weak_done_as_strong_done(NMethodHeader::oops_do_mark_link* next) {\n@@ -2869,1 +2887,1 @@\n-  oops_do_mark_link* old_next = AtomicAccess::cmpxchg(&_oops_do_mark_link, next, mark_link(extract_nmethod(next), claim_strong_done_tag));\n+  nmethod::NMethodHeader::oops_do_mark_link* old_next = AtomicAccess::cmpxchg(&_hdr->_oops_do_mark_link, next, mark_link(extract_nmethod(next), claim_strong_done_tag));\n@@ -2880,3 +2898,3 @@\n-  assert(extract_state(_oops_do_mark_link) == claim_weak_request_tag ||\n-         extract_state(_oops_do_mark_link) == claim_strong_request_tag,\n-         \"must be but is nmethod \" PTR_FORMAT \" %u\", p2i(extract_nmethod(_oops_do_mark_link)), extract_state(_oops_do_mark_link));\n+  assert(extract_state(_hdr->_oops_do_mark_link) == claim_weak_request_tag ||\n+         extract_state(_hdr->_oops_do_mark_link) == claim_strong_request_tag,\n+         \"must be but is nmethod \" PTR_FORMAT \" %u\", p2i(extract_nmethod(_hdr->_oops_do_mark_link)), extract_state(_hdr->_oops_do_mark_link));\n@@ -2890,1 +2908,1 @@\n-  if (AtomicAccess::cmpxchg(&_oops_do_mark_link, mark_link(this, claim_weak_request_tag), mark_link(old_head, claim_weak_done_tag)) == mark_link(this, claim_weak_request_tag)) {\n+  if (AtomicAccess::cmpxchg(&_hdr->_oops_do_mark_link, mark_link(this, claim_weak_request_tag), mark_link(old_head, claim_weak_done_tag)) == mark_link(this, claim_weak_request_tag)) {\n@@ -2906,2 +2924,2 @@\n-  assert(_oops_do_mark_link == mark_link(this, claim_strong_done_tag), \"must be but is nmethod \" PTR_FORMAT \" state %u\",\n-         p2i(extract_nmethod(_oops_do_mark_link)), extract_state(_oops_do_mark_link));\n+  assert(_hdr->_oops_do_mark_link == mark_link(this, claim_strong_done_tag), \"must be but is nmethod \" PTR_FORMAT \" state %u\",\n+         p2i(extract_nmethod(_hdr->_oops_do_mark_link)), extract_state(_hdr->_oops_do_mark_link));\n@@ -2927,2 +2945,2 @@\n-  assert(extract_state(_oops_do_mark_link) == claim_strong_request_tag,\n-         \"must be but is %u\", extract_state(_oops_do_mark_link));\n+  assert(extract_state(_hdr->_oops_do_mark_link) == claim_strong_request_tag,\n+         \"must be but is %u\", extract_state(_hdr->_oops_do_mark_link));\n@@ -2938,1 +2956,1 @@\n-  oops_do_mark_link* next_raw = oops_do_try_claim_strong_done();\n+  NMethodHeader::oops_do_mark_link* next_raw = oops_do_try_claim_strong_done();\n@@ -2946,1 +2964,1 @@\n-    oops_do_mark_link* old = next_raw;\n+    NMethodHeader::oops_do_mark_link* old = next_raw;\n@@ -2984,2 +3002,2 @@\n-      next = extract_nmethod(cur->_oops_do_mark_link);\n-      cur->_oops_do_mark_link = nullptr;\n+      next = extract_nmethod(cur->_hdr->_oops_do_mark_link);\n+      cur->_hdr->_oops_do_mark_link = nullptr;\n@@ -3290,2 +3308,2 @@\n-  assert(_oops_do_mark_link == nullptr, \"_oops_do_mark_link for %s should be nullptr but is \" PTR_FORMAT,\n-         nm->method()->external_name(), p2i(_oops_do_mark_link));\n+  assert(_hdr->_oops_do_mark_link == nullptr, \"_oops_do_mark_link for %s should be nullptr but is \" PTR_FORMAT,\n+         nm->method()->external_name(), p2i(_hdr->_oops_do_mark_link));\n@@ -4033,2 +4051,2 @@\n-  if (JVMCI_ONLY(_exception_offset >= 0 &&) pos == exception_begin())          label = \"[Exception Handler]\";\n-  if (JVMCI_ONLY(_deopt_handler_entry_offset != -1 &&) pos == deopt_handler_entry()) label = \"[Deopt Handler Entry Point]\";\n+  if (JVMCI_ONLY(_hdr->_exception_offset >= 0 &&) pos == exception_begin())          label = \"[Exception Handler]\";\n+  if (JVMCI_ONLY(_hdr->_deopt_handler_entry_offset != -1 &&) pos == deopt_handler_entry()) label = \"[Deopt Handler Entry Point]\";\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":210,"deletions":192,"binary":false,"changes":402,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"memory\/allocation.hpp\"\n@@ -137,1 +138,1 @@\n-\/\/  - Header                 (the nmethod structure)\n+\/\/  - Pointer to the C Heap header structure (NMethodHeader)\n@@ -150,0 +151,3 @@\n+\/\/ The nmethod header (excluding CodeBlob header) is allocated on C heap as part\n+\/\/ of the NMethodHeader structure.\n+\/\/\n@@ -174,24 +178,26 @@\n- private:\n-\n-  \/\/ Used to track in which deoptimize handshake this method will be deoptimized.\n-  uint64_t  _deoptimization_generation;\n-\n-  uint64_t  _gc_epoch;\n-\n-  Method*   _method;\n-\n-  \/\/ To reduce header size union fields which usages do not overlap.\n-  union {\n-    \/\/ To support simple linked-list chaining of nmethods:\n-    nmethod*  _osr_link; \/\/ from InstanceKlass::osr_nmethods_head\n-    struct {\n-      \/\/ These are used for compiled synchronized native methods to\n-      \/\/ locate the owner and stack slot for the BasicLock. They are\n-      \/\/ needed because there is no debug information for compiled native\n-      \/\/ wrappers and the oop maps are insufficient to allow\n-      \/\/ frame::retrieve_receiver() to work. Currently they are expected\n-      \/\/ to be byte offsets from the Java stack pointer for maximum code\n-      \/\/ sharing between platforms. JVMTI's GetLocalInstance() uses these\n-      \/\/ offsets to find the receiver for non-static native wrapper frames.\n-      ByteSize _native_receiver_sp_offset;\n-      ByteSize _native_basic_lock_sp_offset;\n+public:\n+    \/\/ \"NMethodHeader\" holds all the header members of the nmethod class\n+  struct NMethodHeader : public CHeapObj<mtCode> {\n+    \/\/ Used to track in which deoptimize handshake this method will be deoptimized.\n+    uint64_t  _deoptimization_generation;\n+    uint64_t  _gc_epoch;\n+\n+    \/\/ Method pointer\n+    Method*   _method;\n+\n+    \/\/ To reduce header size union fields which usages do not overlap.\n+    union {\n+      \/\/ To support simple linked-list chaining of nmethods:\n+      nmethod*  _osr_link; \/\/ from InstanceKlass::osr_nmethods_head\n+      struct {\n+        \/\/ These are used for compiled synchronized native methods to\n+        \/\/ locate the owner and stack slot for the BasicLock. They are\n+        \/\/ needed because there is no debug information for compiled native\n+        \/\/ wrappers and the oop maps are insufficient to allow\n+        \/\/ frame::retrieve_receiver() to work. Currently they are expected\n+        \/\/ to be byte offsets from the Java stack pointer for maximum code\n+        \/\/ sharing between platforms. JVMTI's GetLocalInstance() uses these\n+        \/\/ offsets to find the receiver for non-static native wrapper frames.\n+        ByteSize _native_receiver_sp_offset;\n+        ByteSize _native_basic_lock_sp_offset;\n+      };\n@@ -199,1 +205,0 @@\n-  };\n@@ -201,2 +206,2 @@\n-  \/\/ nmethod's read-only data\n-  address _immutable_data;\n+    \/\/ nmethod's read-only data\n+    address _immutable_data;\n@@ -204,2 +209,2 @@\n-  PcDescContainer* _pc_desc_container;\n-  ExceptionCache* volatile _exception_cache;\n+    PcDescContainer* _pc_desc_container;\n+    ExceptionCache* volatile _exception_cache;\n@@ -207,1 +212,1 @@\n-  void* _gc_data;\n+    void* _gc_data;\n@@ -209,3 +214,2 @@\n-  struct oops_do_mark_link; \/\/ Opaque data type.\n-  static nmethod*    volatile _oops_do_mark_nmethods;\n-  oops_do_mark_link* volatile _oops_do_mark_link;\n+    struct oops_do_mark_link; \/\/ Opaque data type.\n+    oops_do_mark_link* volatile _oops_do_mark_link;\n@@ -213,1 +217,1 @@\n-  CompiledICData* _compiled_ic_data;\n+    CompiledICData* _compiled_ic_data;\n@@ -215,6 +219,6 @@\n-  \/\/ offsets for entry points\n-  address  _osr_entry_point;       \/\/ entry point for on stack replacement\n-  uint16_t _entry_offset;          \/\/ entry point with class check\n-  uint16_t _verified_entry_offset; \/\/ entry point without class check\n-  int      _entry_bci;             \/\/ != InvocationEntryBci if this nmethod is an on-stack replacement method\n-  int      _immutable_data_size;\n+    \/\/ offsets for entry points\n+    address  _osr_entry_point;       \/\/ entry point for on stack replacement\n+    uint16_t _entry_offset;          \/\/ entry point with class check\n+    uint16_t _verified_entry_offset; \/\/ entry point without class check\n+    int      _entry_bci;             \/\/ != InvocationEntryBci if this nmethod is an on-stack replacement method\n+    int      _immutable_data_size;\n@@ -222,1 +226,1 @@\n-  \/\/ _consts_offset == _content_offset because SECT_CONSTS is first in code buffer\n+    \/\/ _consts_offset == _content_offset because SECT_CONSTS is first in code buffer\n@@ -224,1 +228,1 @@\n-  int _skipped_instructions_size;\n+    int _skipped_instructions_size;\n@@ -226,1 +230,1 @@\n-  int _stub_offset;\n+    int _stub_offset;\n@@ -228,9 +232,9 @@\n-  \/\/ Offsets for different stubs section parts\n-  int _exception_offset;\n-  \/\/ All deoptee's will resume execution at this location described by\n-  \/\/ this offset.\n-  int _deopt_handler_entry_offset;\n-  \/\/ Offset (from insts_end) of the unwind handler if it exists\n-  int16_t  _unwind_handler_offset;\n-  \/\/ Number of arguments passed on the stack\n-  uint16_t _num_stack_arg_slots;\n+    \/\/ Offsets for different stubs section parts\n+    int _exception_offset;\n+    \/\/ All deoptee's will resume execution at this location described by\n+    \/\/ this offset.\n+    int _deopt_handler_entry_offset;\n+    \/\/ Offset (from insts_end) of the unwind handler if it exists\n+    int16_t  _unwind_handler_offset;\n+    \/\/ Number of arguments passed on the stack\n+    uint16_t _num_stack_arg_slots;\n@@ -238,1 +242,1 @@\n-  uint16_t _oops_size;\n+    uint16_t _oops_size;\n@@ -245,39 +249,42 @@\n-  \/\/ Offset in immutable data section\n-  \/\/ _dependencies_offset == 0\n-  uint16_t _nul_chk_table_offset;\n-  uint16_t _handler_table_offset; \/\/ This table could be big in C1 code\n-  int      _scopes_pcs_offset;\n-  int      _scopes_data_offset;\n-#if INCLUDE_JVMCI\n-  int      _speculations_offset;\n-#endif\n-  int      _immutable_data_ref_count_offset;\n-\n-  \/\/ location in frame (offset for sp) that deopt can store the original\n-  \/\/ pc during a deopt.\n-  int _orig_pc_offset;\n-\n-  int          _compile_id;            \/\/ which compilation made this nmethod\n-  CompLevel    _comp_level;            \/\/ compilation level (s1)\n-  CompilerType _compiler_type;         \/\/ which compiler made this nmethod (u1)\n-\n-  \/\/ Local state used to keep track of whether unloading is happening or not\n-  volatile uint8_t _is_unloading_state;\n-\n-  \/\/ Protected by NMethodState_lock\n-  volatile signed char _state;         \/\/ {not_installed, in_use, not_entrant}\n-\n-  \/\/ set during construction\n-  uint8_t _has_unsafe_access:1,        \/\/ May fault due to unsafe access.\n-          _has_wide_vectors:1,         \/\/ Preserve wide vectors at safepoints\n-          _has_monitors:1,             \/\/ Fastpath monitor detection for continuations\n-          _has_scoped_access:1,        \/\/ used by for shared scope closure (scopedMemoryAccess.cpp)\n-          _has_flushed_dependencies:1, \/\/ Used for maintenance of dependencies (under CodeCache_lock)\n-          _is_unlinked:1,              \/\/ mark during class unloading\n-          _load_reported:1;            \/\/ used by jvmti to track if an event has been posted for this nmethod\n-\n-  enum DeoptimizationStatus : u1 {\n-    not_marked,\n-    deoptimize,\n-    deoptimize_noupdate,\n-    deoptimize_done\n+    \/\/ Offset in immutable data section\n+    \/\/ _dependencies_offset == 0\n+    uint16_t _nul_chk_table_offset;\n+    uint16_t _handler_table_offset; \/\/ This table could be big in C1 code\n+    int      _scopes_pcs_offset;\n+    int      _scopes_data_offset;\n+  #if INCLUDE_JVMCI\n+    int      _speculations_offset;\n+  #endif\n+    int      _immutable_data_ref_count_offset;\n+\n+    \/\/ location in frame (offset for sp) that deopt can store the original\n+    \/\/ pc during a deopt.\n+    int _orig_pc_offset;\n+\n+    int          _compile_id;            \/\/ which compilation made this nmethod\n+    CompLevel    _comp_level;            \/\/ compilation level (s1)\n+    CompilerType _compiler_type;         \/\/ which compiler made this nmethod (u1)\n+\n+    \/\/ Local state used to keep track of whether unloading is happening or not\n+    volatile uint8_t _is_unloading_state;\n+\n+    \/\/ Protected by NMethodState_lock\n+    volatile signed char _state;         \/\/ {not_installed, in_use, not_entrant}\n+\n+    \/\/ set during construction\n+    uint8_t _has_unsafe_access:1,        \/\/ May fault due to unsafe access.\n+            _has_wide_vectors:1,         \/\/ Preserve wide vectors at safepoints\n+            _has_monitors:1,             \/\/ Fastpath monitor detection for continuations\n+            _has_scoped_access:1,        \/\/ used by for shared scope closure (scopedMemoryAccess.cpp)\n+            _has_flushed_dependencies:1, \/\/ Used for maintenance of dependencies (under CodeCache_lock)\n+            _is_unlinked:1,              \/\/ mark during class unloading\n+            _load_reported:1;            \/\/ used by jvmti to track if an event has been posted for this nmethod\n+\n+    enum DeoptimizationStatus : u1 {\n+      not_marked,\n+      deoptimize,\n+      deoptimize_noupdate,\n+      deoptimize_done\n+    };\n+\n+    volatile DeoptimizationStatus _deoptimization_status; \/\/ Used for stack deoptimization\n@@ -286,1 +293,3 @@\n-  volatile DeoptimizationStatus _deoptimization_status; \/\/ Used for stack deoptimization\n+ private:\n+  \/\/ Pointer to the C-heap block where the NMethodHeader lives\n+  NMethodHeader* _hdr;\n@@ -288,2 +297,4 @@\n-  DeoptimizationStatus deoptimization_status() const {\n-    return AtomicAccess::load(&_deoptimization_status);\n+  static nmethod*    volatile _oops_do_mark_nmethods;\n+\n+  NMethodHeader::DeoptimizationStatus deoptimization_status() const {\n+    return AtomicAccess::load(&_hdr->_deoptimization_status);\n@@ -362,2 +373,2 @@\n-    if (_pc_desc_container == nullptr) return nullptr; \/\/ native method\n-    return _pc_desc_container->find_pc_desc(pc, approximate, code_begin(), scopes_pcs_begin(), scopes_pcs_end());\n+    if (_hdr->_pc_desc_container == nullptr) return nullptr; \/\/ native method\n+    return _hdr->_pc_desc_container->find_pc_desc(pc, approximate, code_begin(), scopes_pcs_begin(), scopes_pcs_end());\n@@ -432,1 +443,1 @@\n-  static oops_do_mark_link* mark_link(nmethod* nm, uint tag) {\n+  static NMethodHeader::oops_do_mark_link* mark_link(nmethod* nm, uint tag) {\n@@ -435,1 +446,1 @@\n-    return (oops_do_mark_link*)(((uintptr_t)nm & ~0x3) | tag);\n+    return (NMethodHeader::oops_do_mark_link*)(((uintptr_t)nm & ~0x3) | tag);\n@@ -438,1 +449,1 @@\n-  static uint extract_state(oops_do_mark_link* link) {\n+  static uint extract_state(NMethodHeader::oops_do_mark_link* link) {\n@@ -442,1 +453,1 @@\n-  static nmethod* extract_nmethod(oops_do_mark_link* link) {\n+  static nmethod* extract_nmethod(NMethodHeader::oops_do_mark_link* link) {\n@@ -448,1 +459,1 @@\n-  static bool oops_do_has_weak_request(oops_do_mark_link* next) {\n+  static bool oops_do_has_weak_request(NMethodHeader::oops_do_mark_link* next) {\n@@ -452,1 +463,1 @@\n-  static bool oops_do_has_any_strong_state(oops_do_mark_link* next) {\n+  static bool oops_do_has_any_strong_state(NMethodHeader::oops_do_mark_link* next) {\n@@ -460,1 +471,1 @@\n-  oops_do_mark_link* oops_do_try_claim_strong_done();\n+  NMethodHeader::oops_do_mark_link* oops_do_try_claim_strong_done();\n@@ -465,1 +476,1 @@\n-  oops_do_mark_link* oops_do_try_add_strong_request(oops_do_mark_link* next);\n+  NMethodHeader::oops_do_mark_link* oops_do_try_add_strong_request(NMethodHeader::oops_do_mark_link* next);\n@@ -467,1 +478,1 @@\n-  bool oops_do_try_claim_weak_done_as_strong_done(oops_do_mark_link* next);\n+  bool oops_do_try_claim_weak_done_as_strong_done(NMethodHeader::oops_do_mark_link* next);\n@@ -592,4 +603,8 @@\n-  Method* method       () const { return _method; }\n-  bool is_native_method() const { return _method != nullptr && _method->is_native(); }\n-  bool is_java_method  () const { return _method != nullptr && !_method->is_native(); }\n-  bool is_osr_method   () const { return _entry_bci != InvocationEntryBci; }\n+  \/\/ getter\/setter for the _hdr pointer\n+  NMethodHeader* hdr() { return _hdr; }\n+  void set_hdr(NMethodHeader* hdr) { _hdr = hdr; }\n+\n+  Method* method       () const { return _hdr->_method; }\n+  bool is_native_method() const { return _hdr->_method != nullptr && _hdr->_method->is_native(); }\n+  bool is_java_method  () const { return _hdr->_method != nullptr && !_hdr->_method->is_native(); }\n+  bool is_osr_method   () const { return _hdr->_entry_bci != InvocationEntryBci; }\n@@ -603,1 +618,1 @@\n-  int compile_id() const { return _compile_id; }\n+  int compile_id() const { return _hdr->_compile_id; }\n@@ -606,4 +621,4 @@\n-  inline bool  is_compiled_by_c1   () const { return _compiler_type == compiler_c1; }\n-  inline bool  is_compiled_by_c2   () const { return _compiler_type == compiler_c2; }\n-  inline bool  is_compiled_by_jvmci() const { return _compiler_type == compiler_jvmci; }\n-  CompilerType compiler_type       () const { return _compiler_type; }\n+  inline bool  is_compiled_by_c1   () const { return _hdr->_compiler_type == compiler_c1; }\n+  inline bool  is_compiled_by_c2   () const { return _hdr->_compiler_type == compiler_c2; }\n+  inline bool  is_compiled_by_jvmci() const { return _hdr->_compiler_type == compiler_jvmci; }\n+  CompilerType compiler_type       () const { return _hdr->_compiler_type; }\n@@ -616,2 +631,2 @@\n-  address insts_end             () const { return           header_begin() + _stub_offset             ; }\n-  address stub_begin            () const { return           header_begin() + _stub_offset             ; }\n+  address insts_end             () const { return           header_begin() + _hdr->_stub_offset       ; }\n+  address stub_begin            () const { return           header_begin() + _hdr->_stub_offset       ; }\n@@ -619,3 +634,3 @@\n-  address exception_begin       () const { return           header_begin() + _exception_offset        ; }\n-  address deopt_handler_entry   () const { return           header_begin() + _deopt_handler_entry_offset    ; }\n-  address unwind_handler_begin  () const { return _unwind_handler_offset != -1 ? (insts_end() - _unwind_handler_offset) : nullptr; }\n+  address exception_begin       () const { return           header_begin() + _hdr->_exception_offset        ; }\n+  address deopt_handler_entry   () const { return           header_begin() + _hdr->_deopt_handler_entry_offset    ; }\n+  address unwind_handler_begin  () const { return _hdr->_unwind_handler_offset != -1 ? (insts_end() - _hdr->_unwind_handler_offset) : nullptr; }\n@@ -628,2 +643,2 @@\n-  Metadata** metadata_end       () const { return (Metadata**) (mutable_data_begin() + _relocation_size + _metadata_size); }\n-  address jvmci_data_begin      () const { return               mutable_data_begin() + _relocation_size + _metadata_size; }\n+  Metadata** metadata_end       () const { return (Metadata**) (mutable_data_begin() + _relocation_size + _hdr->_metadata_size); }\n+  address jvmci_data_begin      () const { return               mutable_data_begin() + _relocation_size + _hdr->_metadata_size; }\n@@ -636,11 +651,11 @@\n-  address immutable_data_begin  () const { return           _immutable_data; }\n-  address immutable_data_end    () const { return           _immutable_data + _immutable_data_size ; }\n-  address dependencies_begin    () const { return           _immutable_data; }\n-  address dependencies_end      () const { return           _immutable_data + _nul_chk_table_offset; }\n-  address nul_chk_table_begin   () const { return           _immutable_data + _nul_chk_table_offset; }\n-  address nul_chk_table_end     () const { return           _immutable_data + _handler_table_offset; }\n-  address handler_table_begin   () const { return           _immutable_data + _handler_table_offset; }\n-  address handler_table_end     () const { return           _immutable_data + _scopes_pcs_offset   ; }\n-  PcDesc* scopes_pcs_begin      () const { return (PcDesc*)(_immutable_data + _scopes_pcs_offset)  ; }\n-  PcDesc* scopes_pcs_end        () const { return (PcDesc*)(_immutable_data + _scopes_data_offset) ; }\n-  address scopes_data_begin     () const { return           _immutable_data + _scopes_data_offset  ; }\n+  address immutable_data_begin  () const { return           _hdr->_immutable_data; }\n+  address immutable_data_end    () const { return           _hdr->_immutable_data + _hdr->_immutable_data_size ; }\n+  address dependencies_begin    () const { return           _hdr->_immutable_data; }\n+  address dependencies_end      () const { return           _hdr->_immutable_data + _hdr->_nul_chk_table_offset; }\n+  address nul_chk_table_begin   () const { return           _hdr->_immutable_data + _hdr->_nul_chk_table_offset; }\n+  address nul_chk_table_end     () const { return           _hdr->_immutable_data + _hdr->_handler_table_offset; }\n+  address handler_table_begin   () const { return           _hdr->_immutable_data + _hdr->_handler_table_offset; }\n+  address handler_table_end     () const { return           _hdr->_immutable_data + _hdr->_scopes_pcs_offset   ; }\n+  PcDesc* scopes_pcs_begin      () const { return (PcDesc*)(_hdr->_immutable_data + _hdr->_scopes_pcs_offset)  ; }\n+  PcDesc* scopes_pcs_end        () const { return (PcDesc*)(_hdr->_immutable_data + _hdr->_scopes_data_offset) ; }\n+  address scopes_data_begin     () const { return           _hdr->_immutable_data + _hdr->_scopes_data_offset  ; }\n@@ -649,3 +664,3 @@\n-  address scopes_data_end       () const { return           _immutable_data + _speculations_offset ; }\n-  address speculations_begin    () const { return           _immutable_data + _speculations_offset ; }\n-  address speculations_end      () const { return           _immutable_data + _immutable_data_ref_count_offset ; }\n+  address scopes_data_end       () const { return           _hdr->_immutable_data + _hdr->_speculations_offset ; }\n+  address speculations_begin    () const { return           _hdr->_immutable_data + _hdr->_speculations_offset ; }\n+  address speculations_end      () const { return           _hdr->_immutable_data + _hdr->_immutable_data_ref_count_offset ; }\n@@ -653,1 +668,1 @@\n-  address scopes_data_end       () const { return           _immutable_data + _immutable_data_ref_count_offset ; }\n+  address scopes_data_end       () const { return           _hdr->_immutable_data + _hdr->_immutable_data_ref_count_offset ; }\n@@ -655,1 +670,1 @@\n-  address immutable_data_ref_count_begin () const { return  _immutable_data + _immutable_data_ref_count_offset ; }\n+  address immutable_data_ref_count_begin () const { return  _hdr->_immutable_data + _hdr->_immutable_data_ref_count_offset ; }\n@@ -658,1 +673,1 @@\n-  int immutable_data_size() const { return _immutable_data_size; }\n+  int immutable_data_size() const { return _hdr->_immutable_data_size; }\n@@ -677,1 +692,1 @@\n-  int skipped_instructions_size () const { return _skipped_instructions_size; }\n+  int skipped_instructions_size () const { return _hdr->_skipped_instructions_size; }\n@@ -695,2 +710,2 @@\n-  address entry_point() const          { return code_begin() + _entry_offset;          } \/\/ normal entry point\n-  address verified_entry_point() const { return code_begin() + _verified_entry_offset; } \/\/ if klass is correct\n+  address entry_point() const          { return code_begin() + _hdr->_entry_offset;          } \/\/ normal entry point\n+  address verified_entry_point() const { return code_begin() + _hdr->_verified_entry_offset; } \/\/ if klass is correct\n@@ -705,4 +720,4 @@\n-  bool is_not_installed() const        { return _state == not_installed; }\n-  bool is_in_use() const               { return _state <= in_use; }\n-  bool is_not_entrant() const          { return _state == not_entrant; }\n-  int  get_state() const               { return _state; }\n+  bool is_not_installed() const        { return _hdr->_state == not_installed; }\n+  bool is_in_use() const               { return _hdr->_state <= in_use; }\n+  bool is_not_entrant() const          { return _hdr->_state == not_entrant; }\n+  int  get_state() const               { return _hdr->_state; }\n@@ -726,2 +741,2 @@\n-  bool  is_marked_for_deoptimization() const { return deoptimization_status() != not_marked; }\n-  bool  has_been_deoptimized() const { return deoptimization_status() == deoptimize_done; }\n+  bool  is_marked_for_deoptimization() const { return deoptimization_status() != NMethodHeader::not_marked; }\n+  bool  has_been_deoptimized() const { return deoptimization_status() == NMethodHeader::deoptimize_done; }\n@@ -732,1 +747,1 @@\n-    \/\/ or the nmethod is not marked for deoptimization at all (not_marked).\n+    \/\/ or the nmethod is not marked for deoptimization at all (NMethodHeader::not_marked).\n@@ -734,2 +749,2 @@\n-    DeoptimizationStatus status = deoptimization_status();\n-    return status != deoptimize_noupdate && status != deoptimize_done;\n+    NMethodHeader::DeoptimizationStatus status = deoptimization_status();\n+    return status != NMethodHeader::deoptimize_noupdate && status != NMethodHeader::deoptimize_done;\n@@ -747,1 +762,1 @@\n-  T* gc_data() const                              { return reinterpret_cast<T*>(_gc_data); }\n+  T* gc_data() const                              { return reinterpret_cast<T*>(_hdr->_gc_data); }\n@@ -749,1 +764,1 @@\n-  void set_gc_data(T* gc_data)                    { _gc_data = reinterpret_cast<void*>(gc_data); }\n+  void set_gc_data(T* gc_data)                    { _hdr->_gc_data = reinterpret_cast<void*>(gc_data); }\n@@ -751,2 +766,2 @@\n-  bool  has_unsafe_access() const                 { return _has_unsafe_access; }\n-  void  set_has_unsafe_access(bool z)             { _has_unsafe_access = z; }\n+  bool  has_unsafe_access() const                 { return _hdr->_has_unsafe_access; }\n+  void  set_has_unsafe_access(bool z)             { _hdr->_has_unsafe_access = z; }\n@@ -754,2 +769,2 @@\n-  bool  has_monitors() const                      { return _has_monitors; }\n-  void  set_has_monitors(bool z)                  { _has_monitors = z; }\n+  bool  has_monitors() const                      { return _hdr->_has_monitors; }\n+  void  set_has_monitors(bool z)                  { _hdr->_has_monitors = z; }\n@@ -757,2 +772,2 @@\n-  bool  has_scoped_access() const                 { return _has_scoped_access; }\n-  void  set_has_scoped_access(bool z)             { _has_scoped_access = z; }\n+  bool  has_scoped_access() const                 { return _hdr->_has_scoped_access; }\n+  void  set_has_scoped_access(bool z)             { _hdr->_has_scoped_access = z; }\n@@ -760,2 +775,2 @@\n-  bool  has_wide_vectors() const                  { return _has_wide_vectors; }\n-  void  set_has_wide_vectors(bool z)              { _has_wide_vectors = z; }\n+  bool  has_wide_vectors() const                  { return _hdr->_has_wide_vectors; }\n+  void  set_has_wide_vectors(bool z)              { _hdr->_has_wide_vectors = z; }\n@@ -763,1 +778,1 @@\n-  bool  has_flushed_dependencies() const          { return _has_flushed_dependencies; }\n+  bool  has_flushed_dependencies() const          { return _hdr->_has_flushed_dependencies; }\n@@ -766,1 +781,1 @@\n-    _has_flushed_dependencies = z;\n+    _hdr->_has_flushed_dependencies = z;\n@@ -769,1 +784,1 @@\n-  bool  is_unlinked() const                       { return _is_unlinked; }\n+  bool  is_unlinked() const                       { return _hdr->_is_unlinked; }\n@@ -771,2 +786,2 @@\n-     assert(!_is_unlinked, \"already unlinked\");\n-      _is_unlinked = true;\n+     assert(!_hdr->_is_unlinked, \"already unlinked\");\n+      _hdr->_is_unlinked = true;\n@@ -775,1 +790,1 @@\n-  int   comp_level() const                        { return _comp_level; }\n+  int   comp_level() const                        { return _hdr->_comp_level; }\n@@ -818,1 +833,1 @@\n-  ExceptionCache* exception_cache() const         { return _exception_cache; }\n+  ExceptionCache* exception_cache() const         { return _hdr->_exception_cache; }\n@@ -881,4 +896,4 @@\n-  int      osr_entry_bci()    const { assert(is_osr_method(), \"wrong kind of nmethod\"); return _entry_bci; }\n-  address  osr_entry()        const { assert(is_osr_method(), \"wrong kind of nmethod\"); return _osr_entry_point; }\n-  nmethod* osr_link()         const { return _osr_link; }\n-  void     set_osr_link(nmethod *n) { _osr_link = n; }\n+  int      osr_entry_bci()    const { assert(is_osr_method(), \"wrong kind of nmethod\"); return _hdr->_entry_bci; }\n+  address  osr_entry()        const { assert(is_osr_method(), \"wrong kind of nmethod\"); return _hdr->_osr_entry_point; }\n+  nmethod* osr_link()         const { return _hdr->_osr_link; }\n+  void     set_osr_link(nmethod *n) { _hdr->_osr_link = n; }\n@@ -888,1 +903,1 @@\n-    return rounded ? align_up(_num_stack_arg_slots, 2) : _num_stack_arg_slots;\n+    return rounded ? align_up(_hdr->_num_stack_arg_slots, 2) : _hdr->_num_stack_arg_slots;\n@@ -905,1 +920,1 @@\n-  void set_method(Method* method) { _method = method; }\n+  void set_method(Method* method) { _hdr->_method = method; }\n@@ -963,2 +978,2 @@\n-  bool  load_reported() const                     { return _load_reported; }\n-  void  set_load_reported()                       { _load_reported = true; }\n+  bool  load_reported() const                     { return _hdr->_load_reported; }\n+  void  set_load_reported()                       { _hdr->_load_reported = true; }\n@@ -1001,1 +1016,1 @@\n-  int orig_pc_offset() { return _orig_pc_offset; }\n+  int orig_pc_offset() { return _hdr->_orig_pc_offset; }\n@@ -1083,1 +1098,1 @@\n-    return _native_receiver_sp_offset;\n+    return _hdr->_native_receiver_sp_offset;\n@@ -1087,1 +1102,1 @@\n-    return _native_basic_lock_sp_offset;\n+    return _hdr->_native_basic_lock_sp_offset;\n@@ -1091,2 +1106,3 @@\n-  static ByteSize osr_entry_point_offset() { return byte_offset_of(nmethod, _osr_entry_point); }\n-  static ByteSize state_offset()           { return byte_offset_of(nmethod, _state); }\n+  static ByteSize hdr_offset()             { return byte_offset_of(nmethod, _hdr); }\n+  static ByteSize osr_entry_point_offset() { return byte_offset_of(nmethod::NMethodHeader, _osr_entry_point); }\n+  static ByteSize state_offset()           { return byte_offset_of(nmethod::NMethodHeader, _state); }\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":198,"deletions":182,"binary":false,"changes":380,"status":"modified"},{"patch":"@@ -333,2 +333,3 @@\n-  nonstatic_field(nmethod,                     _verified_entry_offset,                        u2)                                    \\\n-  nonstatic_field(nmethod,                     _comp_level,                                   CompLevel)                             \\\n+  nonstatic_field(nmethod,                     _hdr,                                          nmethod::NMethodHeader*)               \\\n+  nonstatic_field(nmethod::NMethodHeader,      _verified_entry_offset,                        u2)                                    \\\n+  nonstatic_field(nmethod::NMethodHeader,      _comp_level,                                   CompLevel)                             \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -135,3 +135,3 @@\n-  nmethod::DeoptimizationStatus status =\n-    inc_recompile_counts ? nmethod::deoptimize : nmethod::deoptimize_noupdate;\n-  AtomicAccess::store(&nm->_deoptimization_status, status);\n+  nmethod::NMethodHeader::DeoptimizationStatus status =\n+    inc_recompile_counts ? nmethod::NMethodHeader::deoptimize : nmethod::NMethodHeader::deoptimize_noupdate;\n+  AtomicAccess::store(&nm->_hdr->_deoptimization_status, status);\n@@ -141,1 +141,1 @@\n-  assert(nm->_deoptimization_generation == 0, \"Is already marked\");\n+  assert(nm->_hdr->_deoptimization_generation == 0, \"Is already marked\");\n@@ -143,1 +143,1 @@\n-  nm->_deoptimization_generation = DeoptimizationScope::_active_deopt_gen;\n+  nm->_hdr->_deoptimization_generation = DeoptimizationScope::_active_deopt_gen;\n@@ -152,2 +152,2 @@\n-  if (_required_gen < nm->_deoptimization_generation) {\n-    _required_gen = nm->_deoptimization_generation;\n+  if (_required_gen < nm->_hdr->_deoptimization_generation) {\n+    _required_gen = nm->_hdr->_deoptimization_generation;\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -535,21 +535,23 @@\n-  nonstatic_field(nmethod,                     _method,                                       Method*)                               \\\n-  nonstatic_field(nmethod,                     _entry_bci,                                    int)                                   \\\n-  nonstatic_field(nmethod,                     _osr_link,                                     nmethod*)                              \\\n-  nonstatic_field(nmethod,                     _state,                                        volatile signed char)                  \\\n-  nonstatic_field(nmethod,                     _exception_offset,                             int)                                   \\\n-  nonstatic_field(nmethod,                     _deopt_handler_entry_offset,                   int)                                   \\\n-  nonstatic_field(nmethod,                     _orig_pc_offset,                               int)                                   \\\n-  nonstatic_field(nmethod,                     _stub_offset,                                  int)                                   \\\n-  nonstatic_field(nmethod,                     _immutable_data_ref_count_offset,              int)                                   \\\n-  nonstatic_field(nmethod,                     _scopes_pcs_offset,                            int)                                   \\\n-  nonstatic_field(nmethod,                     _scopes_data_offset,                           int)                                   \\\n-  nonstatic_field(nmethod,                     _handler_table_offset,                         u2)                                    \\\n-  nonstatic_field(nmethod,                     _nul_chk_table_offset,                         u2)                                    \\\n-  nonstatic_field(nmethod,                     _entry_offset,                                 u2)                                    \\\n-  nonstatic_field(nmethod,                     _verified_entry_offset,                        u2)                                    \\\n-  nonstatic_field(nmethod,                     _osr_entry_point,                              address)                               \\\n-  nonstatic_field(nmethod,                     _immutable_data,                               address)                               \\\n-  nonstatic_field(nmethod,                     _immutable_data_size,                          int)                                   \\\n-  nonstatic_field(nmethod,                     _compile_id,                                   int)                                   \\\n-  nonstatic_field(nmethod,                     _comp_level,                                   CompLevel)                             \\\n-  volatile_nonstatic_field(nmethod,            _exception_cache,                              ExceptionCache*)                       \\\n+  nonstatic_field(nmethod,                           _hdr,                                   nmethod::NMethodHeader*)                \\\n+  nonstatic_field(nmethod::NMethodHeader,            _method,                                Method*)                                \\\n+  nonstatic_field(nmethod::NMethodHeader,            _entry_bci,                             int)                                    \\\n+  nonstatic_field(nmethod::NMethodHeader,            _osr_link,                              nmethod*)                               \\\n+  nonstatic_field(nmethod::NMethodHeader,            _state,                                 volatile signed char)                   \\\n+  nonstatic_field(nmethod::NMethodHeader,            _exception_offset,                      int)                                    \\\n+  nonstatic_field(nmethod::NMethodHeader,            _deopt_handler_entry_offset,            int)                                    \\\n+  nonstatic_field(nmethod::NMethodHeader,            _orig_pc_offset,                        int)                                    \\\n+  nonstatic_field(nmethod::NMethodHeader,            _stub_offset,                           int)                                    \\\n+  nonstatic_field(nmethod::NMethodHeader,            _immutable_data_ref_count_offset,       int)                                    \\\n+  nonstatic_field(nmethod::NMethodHeader,            _scopes_pcs_offset,                     int)                                    \\\n+  nonstatic_field(nmethod::NMethodHeader,            _scopes_data_offset,                    int)                                    \\\n+  JVMCI_ONLY(nonstatic_field(nmethod::NMethodHeader, _speculations_offset,                   int))                                   \\\n+  nonstatic_field(nmethod::NMethodHeader,            _handler_table_offset,                  u2)                                     \\\n+  nonstatic_field(nmethod::NMethodHeader,            _nul_chk_table_offset,                  u2)                                     \\\n+  nonstatic_field(nmethod::NMethodHeader,            _entry_offset,                          u2)                                     \\\n+  nonstatic_field(nmethod::NMethodHeader,            _verified_entry_offset,                 u2)                                     \\\n+  nonstatic_field(nmethod::NMethodHeader,            _osr_entry_point,                       address)                                \\\n+  nonstatic_field(nmethod::NMethodHeader,            _immutable_data,                        address)                                \\\n+  nonstatic_field(nmethod::NMethodHeader,            _immutable_data_size,                   int)                                    \\\n+  nonstatic_field(nmethod::NMethodHeader,            _compile_id,                            int)                                    \\\n+  nonstatic_field(nmethod::NMethodHeader,            _comp_level,                            CompLevel)                              \\\n+  volatile_nonstatic_field(nmethod::NMethodHeader,   _exception_cache,                       ExceptionCache*)                        \\\n@@ -1083,0 +1085,6 @@\n+  \/************\/                                                          \\\n+  \/* nmethod *\/                                                           \\\n+  \/************\/                                                          \\\n+                                                                          \\\n+  declare_toplevel_type(nmethod::NMethodHeader)                           \\\n+                                                                          \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":29,"deletions":21,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -41,0 +42,2 @@\n+  \/\/ The pointer to the header in C Heap\n+  private static AddressField  headerField;\n@@ -48,0 +51,2 @@\n+  \/\/ Size of NMethodHeader\n+  private static long          NMethodHeaderSize;\n@@ -54,2 +59,2 @@\n-  private static CIntField     handlerTableOffsetField;\n-  private static CIntField     nulChkTableOffsetField;\n+  private static CIntegerField handlerTableOffsetField;\n+  private static CIntegerField nulChkTableOffsetField;\n@@ -58,0 +63,1 @@\n+  private static CIntegerField speculationsOffsetField;\n@@ -62,1 +68,1 @@\n-  private static CIntField  entryOffsetField;\n+  private static CIntegerField entryOffsetField;\n@@ -64,1 +70,1 @@\n-  private static CIntField  verifiedEntryOffsetField;\n+  private static CIntegerField verifiedEntryOffsetField;\n@@ -70,1 +76,1 @@\n-  private static CIntField compLevelField;\n+  private static CIntegerField compLevelField;\n@@ -81,1 +87,1 @@\n-    Type type = db.lookupType(\"nmethod\");\n+    Type type = db.lookupType(\"nmethod::NMethodHeader\");\n@@ -83,0 +89,1 @@\n+    headerField                        = db.lookupType(\"nmethod\").getAddressField(\"_hdr\");\n@@ -88,0 +95,1 @@\n+    NMethodHeaderSize                  = type.getSize();\n@@ -94,0 +102,6 @@\n+\n+    sun.jvm.hotspot.types.Field f = type.getField(\"_speculations_offset\", false, false);\n+    if (f != null) {\n+      speculationsOffsetField          = type.getCIntegerField(\"_speculations_offset\");\n+    }\n+\n@@ -95,4 +109,4 @@\n-    handlerTableOffsetField            = new CIntField(type.getCIntegerField(\"_handler_table_offset\"), 0);\n-    nulChkTableOffsetField             = new CIntField(type.getCIntegerField(\"_nul_chk_table_offset\"), 0);\n-    entryOffsetField                   = new CIntField(type.getCIntegerField(\"_entry_offset\"), 0);\n-    verifiedEntryOffsetField           = new CIntField(type.getCIntegerField(\"_verified_entry_offset\"), 0);\n+    handlerTableOffsetField            = type.getCIntegerField(\"_handler_table_offset\");\n+    nulChkTableOffsetField             = type.getCIntegerField(\"_nul_chk_table_offset\");\n+    entryOffsetField                   = type.getCIntegerField(\"_entry_offset\");\n+    verifiedEntryOffsetField           = type.getCIntegerField(\"_verified_entry_offset\");\n@@ -100,1 +114,1 @@\n-    compLevelField                     = new CIntField(type.getCIntegerField(\"_comp_level\"), 0);\n+    compLevelField                     = type.getCIntegerField(\"_comp_level\");\n@@ -115,1 +129,1 @@\n-    return (Method)Metadata.instantiateWrapperFor(methodField.getValue(addr));\n+    return (Method)Metadata.instantiateWrapperFor(methodField.getValue(NMethodHeaderBegin()));\n@@ -124,0 +138,14 @@\n+  public Address NMethodHeaderBegin() throws UnmappedAddressException {\n+    \/\/ read _hdr out of the nmethod object\n+    Address nmethod_hdr = headerField.getAddress(getAddress());\n+    if (nmethod_hdr == null) {\n+      throw new UnmappedAddressException(\"nmethod header is missing\", 0);\n+    }\n+\n+    return nmethod_hdr;\n+  }\n+\n+  public Address NMethodHeaderEnd() throws UnmappedAddressException {\n+    return NMethodHeaderBegin().addOffsetTo(NMethodHeaderSize);\n+  }\n+\n@@ -135,1 +163,1 @@\n-  public Address immutableDataBegin()         { return immutableDataField.getValue(addr);                         }\n+  public Address immutableDataBegin()         { return immutableDataField.getValue(NMethodHeaderBegin());         }\n@@ -138,3 +166,1 @@\n-  public Address dependenciesEnd()            { return immutableDataBegin().addOffsetTo(getHandlerTableOffset()); }\n-  public Address handlerTableBegin()          { return immutableDataBegin().addOffsetTo(getHandlerTableOffset()); }\n-  public Address handlerTableEnd()            { return immutableDataBegin().addOffsetTo(getNulChkTableOffset());  }\n+  public Address dependenciesEnd()            { return immutableDataBegin().addOffsetTo(getNulChkTableOffset());  }\n@@ -142,3 +168,3 @@\n-  public Address nulChkTableEnd()             { return immutableDataBegin().addOffsetTo(getScopesDataOffset());   }\n-  public Address scopesDataBegin()            { return immutableDataBegin().addOffsetTo(getScopesDataOffset());   }\n-  public Address scopesDataEnd()              { return immutableDataBegin().addOffsetTo(getScopesPCsOffset());    }\n+  public Address nulChkTableEnd()             { return immutableDataBegin().addOffsetTo(getHandlerTableOffset()); }\n+  public Address handlerTableBegin()          { return immutableDataBegin().addOffsetTo(getHandlerTableOffset()); }\n+  public Address handlerTableEnd()            { return immutableDataBegin().addOffsetTo(getScopesPCsOffset());  }\n@@ -146,1 +172,7 @@\n-  public Address scopesPCsEnd()               { return immutableDataBegin().addOffsetTo(getImmutableDataRefCountOffset()); }\n+  public Address scopesPCsEnd()               { return immutableDataBegin().addOffsetTo(getScopesDataOffset());                                        }\n+  public Address scopesDataBegin()            { return immutableDataBegin().addOffsetTo(getScopesDataOffset());   }\n+  public Address scopesDataEnd()              {\n+    return immutableDataBegin().addOffsetTo(speculationsOffsetField != null ?\n+      getSpeculationsOffset() :\n+      getImmutableDataRefCountOffset());\n+  }\n@@ -152,1 +184,1 @@\n-  public int getImmutableDataSize()           { return (int) immutableDataSizeField.getValue(addr);        }\n+  public int getImmutableDataSize()           { return (int) immutableDataSizeField.getValue(NMethodHeaderBegin());  }\n@@ -163,1 +195,1 @@\n-  public int origPCOffset()                   { return (int) origPCOffsetField.getValue(addr);             }\n+  public int origPCOffset()                   { return (int) origPCOffsetField.getValue(NMethodHeaderBegin());       }\n@@ -187,0 +219,12 @@\n+  @Override\n+  public boolean blobContains        (Address addr) {\n+    try {\n+      if (NMethodHeaderBegin().lessThanOrEqual(addr) && NMethodHeaderEnd().greaterThan(addr)) {\n+        return true;\n+      }\n+    } catch (UnmappedAddressException e) {\n+      \/\/ nmethod header is missing but check if blob contains the address\n+    }\n+\n+    return super.blobContains(addr);\n+  }\n@@ -259,1 +303,1 @@\n-    return VMObjectFactory.newObject(NMethod.class, osrLinkField.getValue(addr));\n+    return VMObjectFactory.newObject(NMethod.class, osrLinkField.getValue(NMethodHeaderBegin()));\n@@ -447,2 +491,2 @@\n-  public int getEntryPointOffset()            { return (int) entryOffsetField.getValue(addr);        }\n-  public int getVerifiedEntryPointOffset()    { return (int) verifiedEntryOffsetField.getValue(addr);}\n+  public int getEntryPointOffset()            { return (int) entryOffsetField.getValue(NMethodHeaderBegin());        }\n+  public int getVerifiedEntryPointOffset()    { return (int) verifiedEntryOffsetField.getValue(NMethodHeaderBegin());}\n@@ -491,10 +535,16 @@\n-  private int getEntryBCI()                     { return (int) entryBCIField                    .getValue(addr); }\n-  private int getExceptionOffset()              { return (int) exceptionOffsetField             .getValue(addr); }\n-  private int getDeoptHandlerEntryOffset()      { return (int) deoptHandlerEntryOffsetField     .getValue(addr); }\n-  private int getStubOffset()                   { return (int) stubOffsetField                  .getValue(addr); }\n-  private int getScopesDataOffset()             { return (int) scopesDataOffsetField            .getValue(addr); }\n-  private int getScopesPCsOffset()              { return (int) scopesPCsOffsetField             .getValue(addr); }\n-  private int getHandlerTableOffset()           { return (int) handlerTableOffsetField          .getValue(addr); }\n-  private int getNulChkTableOffset()            { return (int) nulChkTableOffsetField           .getValue(addr); }\n-  private int getCompLevel()                    { return (int) compLevelField                   .getValue(addr); }\n-  private int getImmutableDataRefCountOffset()  { return (int) immutableDataRefCountOffsetField .getValue(addr); }\n+  private int getEntryBCI()                     { return (int) entryBCIField                    .getValue(NMethodHeaderBegin()); }\n+  private int getExceptionOffset()              { return (int) exceptionOffsetField             .getValue(NMethodHeaderBegin()); }\n+  private int getDeoptHandlerEntryOffset()      { return (int) deoptHandlerEntryOffsetField     .getValue(NMethodHeaderBegin()); }\n+  private int getStubOffset()                   { return (int) stubOffsetField                  .getValue(NMethodHeaderBegin()); }\n+  private int getScopesDataOffset()             { return (int) scopesDataOffsetField            .getValue(NMethodHeaderBegin()); }\n+  private int getScopesPCsOffset()              { return (int) scopesPCsOffsetField             .getValue(NMethodHeaderBegin()); }\n+  private int getSpeculationsOffset() {\n+    if (speculationsOffsetField == null) {\n+      throw new UnsupportedOperationException(\"nmethod::NMethodHeader::_speculations_offset is not present\");\n+    }\n+    return (int) speculationsOffsetField.getValue(NMethodHeaderBegin());\n+  }\n+  private int getHandlerTableOffset()           { return (int) handlerTableOffsetField          .getValue(NMethodHeaderBegin()); }\n+  private int getNulChkTableOffset()            { return (int) nulChkTableOffsetField           .getValue(NMethodHeaderBegin()); }\n+  private int getCompLevel()                    { return (int) compLevelField                   .getValue(NMethodHeaderBegin()); }\n+  private int getImmutableDataRefCountOffset()  { return (int) immutableDataRefCountOffsetField .getValue(NMethodHeaderBegin()); }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/NMethod.java","additions":85,"deletions":35,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -468,1 +468,4 @@\n-            return UNSAFE.getByte(compiledCode + config().nmethodCompLevelOffset) == level;\n+            long nmethod_hdr = UNSAFE.getAddress(compiledCode + config().nmethodHdrOffset);\n+            if (nmethod_hdr != 0) {\n+                return UNSAFE.getByte(nmethod_hdr + config().nmethodHeaderCompLevelOffset) == level;\n+            }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethodImpl.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -170,1 +170,2 @@\n-    final int nmethodCompLevelOffset = getFieldOffset(\"nmethod::_comp_level\", Integer.class, \"CompLevel\");\n+    final int nmethodHdrOffset = getFieldOffset(\"nmethod::_hdr\", Integer.class, \"nmethod::NMethodHeader*\");\n+    final int nmethodHeaderCompLevelOffset = getFieldOffset(\"nmethod::NMethodHeader::_comp_level\", Integer.class, \"CompLevel\");\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-                \"field nmethod _entry_bci int\",\n+                \"field nmethod::NMethodHeader _entry_bci int\",\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbField.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}