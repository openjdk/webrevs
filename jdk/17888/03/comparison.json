{"files":[{"patch":"@@ -4,1 +4,1 @@\n- Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -687,0 +687,6 @@\n+  <Event name=\"TimeToSafepoint\" category=\"Java Virtual Machine, Runtime, Safepoint\" label=\"Time To Safepoint\" description=\"Time to safepoint\" startTime=\"true\" thread=\"true\" stackTrace=\"true\" >\n+    <Field type=\"ulong\" name=\"safepointId\" label=\"Safepoint Identifier\" relation=\"SafepointId\" \/>\n+    <Field type=\"Thread\" name=\"thread\" label=\"Thread\" \/>\n+    <Field type=\"int\" name=\"iterations\" label=\"Iterations\" description=\"Number of state check iterations\" \/>\n+  <\/Event>\n+\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+#include \"runtime\/safepoint.hpp\"\n@@ -291,2 +292,4 @@\n-  assert(jt == Thread::current(), \"invariant\");\n-  assert(jt->thread_state() != _thread_in_native, \"invariant\");\n+  assert(jt == Thread::current() ||\n+         (Thread::current()->is_VM_thread() && SafepointSynchronize::is_at_safepoint()), \"invariant\");\n+  assert(jt->thread_state() != _thread_in_native ||\n+         (Thread::current()->is_VM_thread() && SafepointSynchronize::is_at_safepoint()), \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTrace.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-  friend class StackTraceResolver;\n+  friend class JfrTimeToSafepoint;\n@@ -97,1 +97,1 @@\n-  bool record(JavaThread* current_thread, const frame& frame, int skip, int64_t stack_frame_id);\n+  bool record(JavaThread* thread, const frame& frame, int skip, int64_t stack_frame_id);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTrace.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+  friend class JfrTimeToSafepoint;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTraceRepository.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"jfr\/jfrEvents.hpp\"\n+#include \"jfr\/recorder\/jfrEventSetting.inline.hpp\"\n+#include \"jfr\/support\/jfrTimeToSafepoint.hpp\"\n+\n+#include \"runtime\/safepoint.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n+\n+struct Entry {\n+  JavaThread* thread;\n+  Ticks start;\n+  Ticks end;\n+  int iterations;\n+};\n+\n+static GrowableArray<Entry>* _events = nullptr;\n+\n+void JfrTimeToSafepoint::record(JavaThread* thread, Ticks& start, Ticks& end, int iterations) {\n+  assert(Thread::current()->is_VM_thread(), \"invariant\");\n+  assert(SafepointSynchronize::is_synchronizing(), \"invariant\");\n+  assert(start.value() > 0 && end.value() > 0, \"invariant\");\n+\n+  jlong duration = (end - start).value();\n+  if (duration <= JfrEventSetting::threshold(EventTimeToSafepoint::eventId)) {\n+    return;\n+  }\n+\n+  if (_events == nullptr) {\n+    _events = new (mtTracing) GrowableArray<Entry>(8, mtTracing);\n+  }\n+\n+  Entry entry = {thread, start, end, iterations};\n+  _events->append(entry);\n+}\n+\n+void JfrTimeToSafepoint::emit_events() {\n+  assert(Thread::current()->is_VM_thread(), \"invariant\");\n+  assert(SafepointSynchronize::is_at_safepoint(), \"invariant\");\n+\n+  if (_events == nullptr || _events->length() == 0) {\n+    return;\n+  }\n+\n+  JfrThreadLocal* tl = VMThread::vm_thread()->jfr_thread_local();\n+  assert(!tl->has_cached_stack_trace(), \"invariant\");\n+\n+  for (int i = 0; i < _events->length(); i++) {\n+    Entry& entry = _events->at(i);\n+\n+    EventTimeToSafepoint event(UNTIMED);\n+    event.set_starttime(entry.start);\n+    event.set_endtime(entry.end);\n+\n+    event.set_safepointId(SafepointSynchronize::safepoint_id());\n+    event.set_iterations(entry.iterations);\n+\n+    JavaThread* jt = entry.thread;\n+    event.set_thread(JfrThreadLocal::thread_id(jt));\n+\n+    if (EventTimeToSafepoint::is_stacktrace_enabled() && jt->has_last_Java_frame()) {\n+      JfrStackTrace stacktrace(tl->stackframes(), tl->stackdepth());\n+      if (stacktrace.record(jt, jt->last_frame(), 0, -1)) {\n+        tl->set_cached_stack_trace_id(JfrStackTraceRepository::add(stacktrace));\n+      } else {\n+        tl->set_cached_stack_trace_id(0);\n+      }\n+    } else {\n+      tl->set_cached_stack_trace_id(0);\n+    }\n+    event.commit();\n+  }\n+\n+  tl->clear_cached_stack_trace();\n+  _events->clear();\n+}\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrTimeToSafepoint.cpp","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_JFR_SUPPORT_JFRTIMETOSAFEPOINT_HPP\n+#define SHARE_JFR_SUPPORT_JFRTIMETOSAFEPOINT_HPP\n+\n+class JfrTimeToSafepoint : AllStatic {\n+ public:\n+  static void record(JavaThread* thread, Ticks& start, Ticks& end, int iterations);\n+\n+  static void emit_events();\n+};\n+\n+#endif \/\/ SHARE_JFR_SUPPORT_JFRTIMETOSAFEPOINTEVENT_HPP\n+\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrTimeToSafepoint.hpp","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,4 @@\n+#if INCLUDE_JFR\n+#include \"jfr\/support\/jfrTimeToSafepoint.hpp\"\n+#endif\n+\n@@ -219,0 +223,5 @@\n+#if INCLUDE_JFR\n+  bool ttsp_event_enabled = EventTimeToSafepoint::is_enabled();\n+  Ticks ttsp_start = ttsp_event_enabled ? Ticks::now() : Ticks(0);\n+#endif\n+\n@@ -263,0 +272,7 @@\n+#if INCLUDE_JFR\n+    Ticks ttsp_end = Ticks(0);\n+    if (ttsp_event_enabled) {\n+      ttsp_end = Ticks::now();\n+    }\n+#endif\n+\n@@ -273,0 +289,5 @@\n+#if INCLUDE_JFR\n+        if (ttsp_event_enabled) {\n+          JfrTimeToSafepoint::record(tmp->thread(), ttsp_start, ttsp_end, iterations);\n+        }\n+#endif\n@@ -441,0 +462,2 @@\n+  JFR_ONLY(JfrTimeToSafepoint::emit_events();)\n+\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -239,0 +239,2 @@\n+\n+  friend class SafepointSynchronize;\n","filename":"src\/hotspot\/share\/utilities\/ticks.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -934,0 +934,5 @@\n+    <event name=\"jdk.TimeToSafepoint\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n+      <setting name=\"threshold\">10 s<\/setting>\n+    <\/event>\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -934,0 +934,5 @@\n+    <event name=\"jdk.TimeToSafepoint\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n+      <setting name=\"threshold\">10 s<\/setting>\n+    <\/event>\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.runtime;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertNull;\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+import java.util.List;\n+import java.time.Duration;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+import jdk.test.whitebox.WhiteBox;\n+\n+\/**\n+ * @test TestTimeToSafepointEvent\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   jdk.jfr.event.runtime.TestTimeToSafepointEvent\n+ *\/\n+public class TestTimeToSafepointEvent {\n+\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    public static void main(String[] args) throws Exception {\n+        Thread thread = new Thread(() -> {\n+            while (true) {\n+                WB.waitUnsafe(999);\n+            }\n+        }, \"SafepointTimeout Trigger\");\n+        thread.setDaemon(true);\n+        thread.start();\n+\n+        {\n+            Recording recording = new Recording();\n+            recording.enable(EventNames.TimeToSafepoint)\n+                     .withThreshold(Duration.ofMillis(200))\n+                     .withStackTrace();\n+\n+            recording.start();\n+            forceSafepoints();\n+            recording.stop();\n+\n+            List<RecordedEvent> events = Events.fromRecording(recording);\n+            assertTrue(events.size() > 0);\n+            for (RecordedEvent event : events) {\n+                System.out.println(\"Event: \" + event);\n+                assertTrue(Events.isEventType(event, EventNames.TimeToSafepoint));\n+                assertEquals(event.getThread().getOSName(), \"VM Thread\");\n+                Events.assertEventThread(event, \"thread\", thread);\n+                Events.assertTopFrame(event, WhiteBox.class.getName(), \"waitUnsafe\");\n+            }\n+        }\n+\n+        \/\/ Test without stack trace\n+        {\n+            Recording recording = new Recording();\n+            recording.enable(EventNames.TimeToSafepoint)\n+                     .withThreshold(Duration.ofMillis(200))\n+                     .withoutStackTrace();\n+\n+            recording.start();\n+            forceSafepoints();\n+            recording.stop();\n+\n+            List<RecordedEvent> events = Events.fromRecording(recording);\n+            assertTrue(events.size() > 0);\n+            for (RecordedEvent event : events) {\n+                System.out.println(\"Event: \" + event);\n+                assertNull(event.getStackTrace());\n+            }\n+        }\n+\n+        \/\/ Test with high threshold\n+        {\n+            Recording recording = new Recording();\n+            recording.enable(EventNames.TimeToSafepoint)\n+                     .withThreshold(Duration.ofSeconds(5))\n+                     .withoutStackTrace();\n+\n+            recording.start();\n+            forceSafepoints();\n+            recording.stop();\n+\n+            List<RecordedEvent> events = Events.fromRecording(recording);\n+            assertTrue(events.size() == 0);\n+        }\n+    }\n+\n+    private static void forceSafepoints() throws Exception {\n+        for (int i = 0; i < 4; i++) {\n+            Thread.sleep(50);\n+            WB.forceSafepoint();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestTimeToSafepointEvent.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,0 +68,1 @@\n+    public static final String TimeToSafepoint = PREFIX + \"TimeToSafepoint\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}