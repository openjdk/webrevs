{"files":[{"patch":"@@ -4,1 +4,1 @@\n- Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -687,0 +687,6 @@\n+  <Event name=\"TimeToSafepoint\" category=\"Java Virtual Machine, Runtime, Safepoint\" label=\"Time To Safepoint\" description=\"Time to safepoint\" startTime=\"true\" thread=\"true\" stackTrace=\"true\" >\n+    <Field type=\"ulong\" name=\"safepointId\" label=\"Safepoint Identifier\" relation=\"SafepointId\" \/>\n+    <Field type=\"Thread\" name=\"thread\" label=\"Thread\" \/>\n+    <Field type=\"int\" name=\"iterations\" label=\"Iterations\" description=\"Number of state check iterations for the thread\" \/>\n+  <\/Event>\n+\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+#include \"runtime\/safepoint.hpp\"\n@@ -291,2 +292,4 @@\n-  assert(jt == Thread::current(), \"invariant\");\n-  assert(jt->thread_state() != _thread_in_native, \"invariant\");\n+  assert(jt == Thread::current() ||\n+         (Thread::current()->is_VM_thread() && SafepointSynchronize::is_at_safepoint()), \"invariant\");\n+  assert(jt->thread_state() != _thread_in_native ||\n+         (Thread::current()->is_VM_thread() && SafepointSynchronize::is_at_safepoint()), \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTrace.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-  friend class StackTraceResolver;\n+  friend class JfrTimeToSafepoint;\n@@ -97,1 +97,1 @@\n-  bool record(JavaThread* current_thread, const frame& frame, int skip, int64_t stack_frame_id);\n+  bool record(JavaThread* thread, const frame& frame, int skip, int64_t stack_frame_id);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTrace.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+  friend class JfrTimeToSafepoint;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTraceRepository.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jfr\/support\/jfrTimeToSafepoint.hpp\"\n+\n+bool JfrTimeToSafepoint::_active = false;\n+\n+JfrTicks JfrTimeToSafepoint::_start;\n+\n+GrowableArray<JfrTimeToSafepoint::Entry>* JfrTimeToSafepoint::_entries = nullptr;\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrTimeToSafepoint.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_JFR_SUPPORT_JFRTIMETOSAFEPOINT_HPP\n+#define SHARE_JFR_SUPPORT_JFRTIMETOSAFEPOINT_HPP\n+\n+#include \"jfr\/utilities\/jfrTime.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+class JfrTimeToSafepoint : AllStatic {\n+ public:\n+  static void on_synchronizing();\n+  static void on_thread_not_running(JavaThread* thread, int iterations);\n+  static void on_synchronized();\n+\n+ private:\n+  struct Entry {\n+    JavaThread* thread;\n+    JfrTicks end;\n+    int iterations;\n+  };\n+\n+  static bool _active;\n+  static JfrTicks _start;\n+  static GrowableArray<Entry>* _entries;\n+};\n+\n+#endif \/\/ SHARE_JFR_SUPPORT_JFRTIMETOSAFEPOINTEVENT_HPP\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrTimeToSafepoint.hpp","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_JFR_SUPPORT_JFRTIMETOSAFEPOINT_INLINE_HPP\n+#define SHARE_JFR_SUPPORT_JFRTIMETOSAFEPOINT_INLINE_HPP\n+\n+#include \"jfr\/jfrEvents.hpp\"\n+#include \"jfr\/recorder\/jfrEventSetting.inline.hpp\"\n+#include \"jfr\/support\/jfrTimeToSafepoint.hpp\"\n+\n+#include \"runtime\/safepoint.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n+\n+inline void JfrTimeToSafepoint::on_synchronizing() {\n+  assert(Thread::current()->is_VM_thread(), \"invariant\");\n+  assert(SafepointSynchronize::is_synchronizing(), \"invariant\");\n+\n+  _active = EventTimeToSafepoint::is_enabled();\n+  if (_active) {\n+    _start = JfrTicks::now();\n+  }\n+}\n+\n+inline void JfrTimeToSafepoint::on_thread_not_running(JavaThread* thread, int iterations) {\n+  assert(Thread::current()->is_VM_thread(), \"invariant\");\n+  assert(SafepointSynchronize::is_synchronizing(), \"invariant\");\n+  assert(thread != nullptr && iterations >= 0, \"invariant\");\n+\n+  if (!_active) {\n+    return;\n+  }\n+\n+  assert(_start.value() > 0, \"invariant\");\n+\n+  JfrTicks end = JfrTicks::now();\n+  if ((end - _start).value() <= JfrEventSetting::threshold(EventTimeToSafepoint::eventId)) {\n+    return;\n+  }\n+\n+  if (_entries == nullptr) {\n+    _entries = new (mtTracing) GrowableArray<Entry>(4, mtTracing);\n+  }\n+\n+  Entry entry = {thread, end, iterations};\n+  _entries->append(entry);\n+}\n+\n+inline void JfrTimeToSafepoint::on_synchronized() {\n+  assert(Thread::current()->is_VM_thread(), \"invariant\");\n+  assert(SafepointSynchronize::is_at_safepoint(), \"invariant\");\n+\n+  if (!_active || _entries == nullptr || _entries->length() == 0) {\n+    return;\n+  }\n+\n+  JfrThreadLocal* tl = VMThread::vm_thread()->jfr_thread_local();\n+  assert(!tl->has_cached_stack_trace(), \"invariant\");\n+\n+  for (int i = 0; i < _entries->length(); i++) {\n+    Entry& entry = _entries->at(i);\n+\n+    EventTimeToSafepoint event(UNTIMED);\n+    event.set_starttime(_start);\n+    event.set_endtime(entry.end);\n+\n+    event.set_safepointId(SafepointSynchronize::safepoint_id());\n+    event.set_iterations(entry.iterations);\n+\n+    JavaThread* jt = entry.thread;\n+    event.set_thread(JfrThreadLocal::thread_id(jt));\n+\n+    if (EventTimeToSafepoint::is_stacktrace_enabled() && jt->has_last_Java_frame()) {\n+      JfrStackTrace stacktrace(tl->stackframes(), tl->stackdepth());\n+      if (stacktrace.record(jt, jt->last_frame(), 0, -1)) {\n+        tl->set_cached_stack_trace_id(JfrStackTraceRepository::add(stacktrace));\n+      } else {\n+        tl->set_cached_stack_trace_id(0);\n+      }\n+    } else {\n+      tl->set_cached_stack_trace_id(0);\n+    }\n+    event.commit();\n+  }\n+\n+  tl->clear_cached_stack_trace();\n+\n+  \/\/ Should we shrink it?\n+  _entries->clear();\n+}\n+\n+#undef ENTRY_ARRAY_SIZE\n+\n+#endif \/\/ SHARE_JFR_SUPPORT_JFRTIMETOSAFEPOINT_INLINE_HPP\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrTimeToSafepoint.inline.hpp","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,4 @@\n+#if INCLUDE_JFR\n+#include \"jfr\/support\/jfrTimeToSafepoint.inline.hpp\"\n+#endif\n+\n@@ -237,0 +241,1 @@\n+      JFR_ONLY(JfrTimeToSafepoint::on_thread_not_running(cur_tss->thread(), 0);)\n@@ -273,0 +278,1 @@\n+        JFR_ONLY(JfrTimeToSafepoint::on_thread_not_running(tmp->thread(), iterations);)\n@@ -391,0 +397,2 @@\n+  JFR_ONLY(JfrTimeToSafepoint::on_synchronizing();)\n+\n@@ -441,0 +449,2 @@\n+  JFR_ONLY(JfrTimeToSafepoint::on_synchronized();)\n+\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -934,0 +934,5 @@\n+    <event name=\"jdk.TimeToSafepoint\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n+      <setting name=\"threshold\">10 s<\/setting>\n+    <\/event>\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -934,0 +934,5 @@\n+    <event name=\"jdk.TimeToSafepoint\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n+      <setting name=\"threshold\">10 s<\/setting>\n+    <\/event>\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.runtime;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertNull;\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+import java.util.List;\n+import java.time.Duration;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+import jdk.test.whitebox.WhiteBox;\n+\n+\/**\n+ * @test TestTimeToSafepointEvent\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   jdk.jfr.event.runtime.TestTimeToSafepointEvent\n+ *\/\n+public class TestTimeToSafepointEvent {\n+\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    public static void main(String[] args) throws Exception {\n+        Thread thread = new Thread(() -> {\n+            while (true) {\n+                WB.waitUnsafe(999);\n+            }\n+        }, \"SafepointTimeout Trigger\");\n+        thread.setDaemon(true);\n+        thread.start();\n+\n+        {\n+            Recording recording = new Recording();\n+            recording.enable(EventNames.TimeToSafepoint)\n+                     .withThreshold(Duration.ofMillis(200))\n+                     .withStackTrace();\n+\n+            recording.start();\n+            forceSafepoints();\n+            recording.stop();\n+\n+            List<RecordedEvent> events = Events.fromRecording(recording);\n+            assertTrue(events.size() > 0);\n+            for (RecordedEvent event : events) {\n+                System.out.println(\"Event: \" + event);\n+                assertTrue(Events.isEventType(event, EventNames.TimeToSafepoint));\n+                assertEquals(event.getThread().getOSName(), \"VM Thread\");\n+                Events.assertEventThread(event, \"thread\", thread);\n+                Events.assertTopFrame(event, WhiteBox.class.getName(), \"waitUnsafe\");\n+            }\n+        }\n+\n+        \/\/ Test without stack trace\n+        {\n+            Recording recording = new Recording();\n+            recording.enable(EventNames.TimeToSafepoint)\n+                     .withThreshold(Duration.ofMillis(200))\n+                     .withoutStackTrace();\n+\n+            recording.start();\n+            forceSafepoints();\n+            recording.stop();\n+\n+            List<RecordedEvent> events = Events.fromRecording(recording);\n+            assertTrue(events.size() > 0);\n+            for (RecordedEvent event : events) {\n+                System.out.println(\"Event: \" + event);\n+                assertNull(event.getStackTrace());\n+            }\n+        }\n+\n+        \/\/ Test with high threshold\n+        {\n+            Recording recording = new Recording();\n+            recording.enable(EventNames.TimeToSafepoint)\n+                     .withThreshold(Duration.ofSeconds(5))\n+                     .withoutStackTrace();\n+\n+            recording.start();\n+            forceSafepoints();\n+            recording.stop();\n+\n+            List<RecordedEvent> events = Events.fromRecording(recording);\n+            assertTrue(events.size() == 0);\n+        }\n+    }\n+\n+    private static void forceSafepoints() throws Exception {\n+        for (int i = 0; i < 4; i++) {\n+            Thread.sleep(50);\n+            WB.forceSafepoint();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestTimeToSafepointEvent.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,0 +68,1 @@\n+    public static final String TimeToSafepoint = PREFIX + \"TimeToSafepoint\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}