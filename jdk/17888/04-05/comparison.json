{"files":[{"patch":"@@ -24,4 +24,0 @@\n-#include \"precompiled.hpp\"\n-\n-#include \"jfr\/jfrEvents.hpp\"\n-#include \"jfr\/recorder\/jfrEventSetting.inline.hpp\"\n@@ -30,53 +26,1 @@\n-#include \"runtime\/safepoint.hpp\"\n-#include \"runtime\/vmThread.hpp\"\n-\n-struct Entry {\n-  JavaThread* thread;\n-  Ticks start;\n-  Ticks end;\n-  int iterations;\n-};\n-\n-static GrowableArray<Entry>* _events = nullptr;\n-\n-void JfrTimeToSafepoint::record(JavaThread* thread, Ticks& start, Ticks& end, int iterations) {\n-  assert(Thread::current()->is_VM_thread(), \"invariant\");\n-  assert(SafepointSynchronize::is_synchronizing(), \"invariant\");\n-  assert(start.value() > 0 && end.value() > 0, \"invariant\");\n-\n-  jlong duration = (end - start).value();\n-  if (duration <= JfrEventSetting::threshold(EventTimeToSafepoint::eventId)) {\n-    return;\n-  }\n-\n-  if (_events == nullptr) {\n-    _events = new (mtTracing) GrowableArray<Entry>(8, mtTracing);\n-  }\n-\n-  Entry entry = {thread, start, end, iterations};\n-  _events->append(entry);\n-}\n-\n-void JfrTimeToSafepoint::emit_events() {\n-  assert(Thread::current()->is_VM_thread(), \"invariant\");\n-  assert(SafepointSynchronize::is_at_safepoint(), \"invariant\");\n-\n-  if (_events == nullptr || _events->length() == 0) {\n-    return;\n-  }\n-\n-  JfrThreadLocal* tl = VMThread::vm_thread()->jfr_thread_local();\n-  assert(!tl->has_cached_stack_trace(), \"invariant\");\n-\n-  for (int i = 0; i < _events->length(); i++) {\n-    Entry& entry = _events->at(i);\n-\n-    EventTimeToSafepoint event(UNTIMED);\n-    event.set_starttime(entry.start);\n-    event.set_endtime(entry.end);\n-\n-    event.set_safepointId(SafepointSynchronize::safepoint_id());\n-    event.set_iterations(entry.iterations);\n-\n-    JavaThread* jt = entry.thread;\n-    event.set_thread(JfrThreadLocal::thread_id(jt));\n+bool JfrTimeToSafepoint::_active = false;\n@@ -84,12 +28,1 @@\n-    if (EventTimeToSafepoint::is_stacktrace_enabled() && jt->has_last_Java_frame()) {\n-      JfrStackTrace stacktrace(tl->stackframes(), tl->stackdepth());\n-      if (stacktrace.record(jt, jt->last_frame(), 0, -1)) {\n-        tl->set_cached_stack_trace_id(JfrStackTraceRepository::add(stacktrace));\n-      } else {\n-        tl->set_cached_stack_trace_id(0);\n-      }\n-    } else {\n-      tl->set_cached_stack_trace_id(0);\n-    }\n-    event.commit();\n-  }\n+JfrTicks JfrTimeToSafepoint::_start;\n@@ -97,3 +30,1 @@\n-  tl->clear_cached_stack_trace();\n-  _events->clear();\n-}\n+GrowableArray<JfrTimeToSafepoint::Entry>* JfrTimeToSafepoint::_entries = nullptr;\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrTimeToSafepoint.cpp","additions":3,"deletions":72,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -27,0 +27,5 @@\n+#include \"jfr\/utilities\/jfrTime.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n@@ -29,1 +34,10 @@\n-  static void record(JavaThread* thread, Ticks& start, Ticks& end, int iterations);\n+  static void on_synchronizing();\n+  static void on_thread_not_running(JavaThread* thread, int iterations);\n+  static void on_synchronized();\n+\n+ private:\n+  struct Entry {\n+    JavaThread* thread;\n+    JfrTicks end;\n+    int iterations;\n+  };\n@@ -31,1 +45,3 @@\n-  static void emit_events();\n+  static bool _active;\n+  static JfrTicks _start;\n+  static GrowableArray<Entry>* _entries;\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrTimeToSafepoint.hpp","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jfr\/jfrEvents.hpp\"\n+#include \"jfr\/recorder\/jfrEventSetting.inline.hpp\"\n+#include \"jfr\/support\/jfrTimeToSafepoint.hpp\"\n+\n+#include \"runtime\/safepoint.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n+\n+inline void JfrTimeToSafepoint::on_synchronizing() {\n+  assert(Thread::current()->is_VM_thread(), \"invariant\");\n+  assert(SafepointSynchronize::is_synchronizing(), \"invariant\");\n+\n+  _active = EventTimeToSafepoint::is_enabled();\n+  if (_active) {\n+    _start = JfrTicks::now();\n+  }\n+}\n+\n+inline void JfrTimeToSafepoint::on_thread_not_running(JavaThread* thread, int iterations) {\n+  assert(Thread::current()->is_VM_thread(), \"invariant\");\n+  assert(SafepointSynchronize::is_synchronizing(), \"invariant\");\n+  assert(thread != nullptr && iterations >= 0, \"invariant\");\n+\n+  if (!_active) {\n+    return;\n+  }\n+\n+  assert(_start.value() > 0, \"invariant\");\n+\n+  JfrTicks end = JfrTicks::now();\n+  if ((end - _start).value() <= JfrEventSetting::threshold(EventTimeToSafepoint::eventId)) {\n+    return;\n+  }\n+\n+  if (_entries == nullptr) {\n+    _entries = new (mtTracing) GrowableArray<Entry>(8, mtTracing);\n+  }\n+\n+  Entry entry = {thread, end, iterations};\n+  _entries->append(entry);\n+}\n+\n+inline void JfrTimeToSafepoint::on_synchronized() {\n+  assert(Thread::current()->is_VM_thread(), \"invariant\");\n+  assert(SafepointSynchronize::is_at_safepoint(), \"invariant\");\n+\n+  if (!_active || _entries == nullptr || _entries->length() == 0) {\n+    return;\n+  }\n+\n+  JfrThreadLocal* tl = VMThread::vm_thread()->jfr_thread_local();\n+  assert(!tl->has_cached_stack_trace(), \"invariant\");\n+\n+  for (int i = 0; i < _entries ->length(); i++) {\n+    Entry& entry = _entries ->at(i);\n+\n+    EventTimeToSafepoint event(UNTIMED);\n+    event.set_starttime(_start);\n+    event.set_endtime(entry.end);\n+\n+    event.set_safepointId(SafepointSynchronize::safepoint_id());\n+    event.set_iterations(entry.iterations);\n+\n+    JavaThread* jt = entry.thread;\n+    event.set_thread(JfrThreadLocal::thread_id(jt));\n+\n+    if (EventTimeToSafepoint::is_stacktrace_enabled() && jt->has_last_Java_frame()) {\n+      JfrStackTrace stacktrace(tl->stackframes(), tl->stackdepth());\n+      if (stacktrace.record(jt, jt->last_frame(), 0, -1)) {\n+        tl->set_cached_stack_trace_id(JfrStackTraceRepository::add(stacktrace));\n+      } else {\n+        tl->set_cached_stack_trace_id(0);\n+      }\n+    } else {\n+      tl->set_cached_stack_trace_id(0);\n+    }\n+    event.commit();\n+  }\n+\n+  tl->clear_cached_stack_trace();\n+  _entries->clear();\n+}\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrTimeToSafepoint.inline.hpp","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -75,1 +75,1 @@\n-#include \"jfr\/support\/jfrTimeToSafepoint.hpp\"\n+#include \"jfr\/support\/jfrTimeToSafepoint.inline.hpp\"\n@@ -223,5 +223,0 @@\n-#if INCLUDE_JFR\n-  bool ttsp_event_enabled = EventTimeToSafepoint::is_enabled();\n-  Ticks ttsp_start = ttsp_event_enabled ? Ticks::now() : Ticks(0);\n-#endif\n-\n@@ -246,0 +241,1 @@\n+      JFR_ONLY(JfrTimeToSafepoint::on_thread_not_running(cur_tss->thread(), 0);)\n@@ -272,2 +268,0 @@\n-    JFR_ONLY(Ticks ttsp_end = ttsp_event_enabled ? Ticks::now() : Ticks(0);)\n-\n@@ -284,5 +278,1 @@\n-#if INCLUDE_JFR\n-        if (ttsp_event_enabled) {\n-          JfrTimeToSafepoint::record(tmp->thread(), ttsp_start, ttsp_end, iterations);\n-        }\n-#endif\n+        JFR_ONLY(JfrTimeToSafepoint::on_thread_not_running(tmp->thread(), iterations);)\n@@ -407,0 +397,2 @@\n+  JFR_ONLY(JfrTimeToSafepoint::on_synchronizing();)\n+\n@@ -457,1 +449,1 @@\n-  JFR_ONLY(JfrTimeToSafepoint::emit_events();)\n+  JFR_ONLY(JfrTimeToSafepoint::on_synchronized();)\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":6,"deletions":14,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -239,2 +239,0 @@\n-\n-  friend class SafepointSynchronize;\n","filename":"src\/hotspot\/share\/utilities\/ticks.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}