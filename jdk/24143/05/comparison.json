{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,7 @@\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.locks.Condition;\n+import jdk.test.lib.util.ForceGC;\n+\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.WeakReference;\n+import java.time.Duration;\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -35,1 +40,3 @@\n- * @run main FinalizerHistogramTest\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.util.ForceGC\n+ * @run main\/othervm FinalizerHistogramTest\n@@ -40,3 +47,5 @@\n-    static volatile int wasInitialized = 0;\n-    static volatile int wasTrapped = 0;\n-    static final int objectsCount = 1000;\n+    static final AtomicInteger initializedCount = new AtomicInteger(0);\n+    static final AtomicInteger trappedCount = new AtomicInteger(0);\n+    static final int OBJECTS_COUNT = 1000;\n+\n+    static RefQForTwo refQForTwo;\n@@ -47,1 +56,1 @@\n-            wasInitialized += 1;\n+            initializedCount.incrementAndGet();\n@@ -52,1 +61,1 @@\n-            wasTrapped += 1;\n+            trappedCount.incrementAndGet();\n@@ -60,1 +69,2 @@\n-            for(int i = 0; i < objectsCount; ++i) {\n+            refQForTwo = new RefQForTwo(new MyObject(), new MyObject());\n+            for(int i = 2; i < OBJECTS_COUNT; ++i) {\n@@ -63,3 +73,12 @@\n-            System.out.println(\"Objects intialized: \" + objectsCount);\n-            System.gc();\n-            while(wasTrapped < 1);\n+            System.out.println(\"Objects intialized: \" + initializedCount.get());\n+            \/\/ GC and wait for at least 2 MyObjects to be ready for finalization,\n+            \/\/ and one MyObject to be trapped in finalize().\n+            boolean forceGCResult = ForceGC.waitFor(() -> refQForTwo.bothRefsCleared() &&\n+                                                          trappedCount.intValue() > 0,\n+                    Duration.ofSeconds(60).toMillis());\n+            if (!forceGCResult) {\n+                System.out.println(\"*** ForceGC condition not met! ***\");\n+            }\n+            System.out.println(\"ref1Cleared: \" + refQForTwo.ref1Cleared);\n+            System.out.println(\"ref2Cleared: \" + refQForTwo.ref2Cleared);\n+            System.out.println(\"trappedCount.intValue(): \" + trappedCount.intValue());\n@@ -105,0 +124,33 @@\n+\n+    private static class RefQForTwo implements Runnable {\n+        final ReferenceQueue queue;\n+        final WeakReference ref1;\n+        final WeakReference ref2;\n+        volatile boolean ref1Cleared = false;\n+        volatile boolean ref2Cleared = false;\n+        Thread thread;\n+\n+        private RefQForTwo(Object obj1, Object obj2) {\n+            queue = new ReferenceQueue();\n+            ref1 = new WeakReference(obj1, queue);\n+            ref2 = new WeakReference(obj2, queue);\n+\n+            thread = new Thread(this, \"RefQForTwo thread\");\n+            thread.start();\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                while (!bothRefsCleared()) {\n+                    Reference ref = queue.remove();\n+                    if (ref == ref1) { ref1Cleared = true; }\n+                    else if (ref == ref2) { ref2Cleared = true; }\n+                }\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        public boolean bothRefsCleared() { return ref1Cleared && ref2Cleared; }\n+    }\n","filename":"test\/jdk\/java\/lang\/ref\/FinalizerHistogramTest.java","additions":65,"deletions":13,"binary":false,"changes":78,"status":"modified"}]}