{"files":[{"patch":"@@ -24,1 +24,1 @@\n-import jdk.test.lib.util.ForceGC;\n+import jdk.test.whitebox.WhiteBox;\n@@ -26,4 +26,0 @@\n-import java.lang.ref.Reference;\n-import java.lang.ref.ReferenceQueue;\n-import java.lang.ref.WeakReference;\n-import java.time.Duration;\n@@ -41,2 +37,7 @@\n- * @build jdk.test.lib.util.ForceGC\n- * @run main\/othervm FinalizerHistogramTest\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\n+ *      -Xbootclasspath\/a:.\n+ *      -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:+WhiteBoxAPI\n+ *      FinalizerHistogramTest\n@@ -51,1 +52,2 @@\n-    static RefQForTwo refQForTwo;\n+    static WhiteBox wb;\n+    static boolean refProResult;\n@@ -66,1 +68,1 @@\n-    public static void main(String[] argvs) {\n+    public static void main(String[] argvs) throws InterruptedException {\n@@ -69,2 +71,1 @@\n-            refQForTwo = new RefQForTwo(new MyObject(), new MyObject());\n-            for(int i = 2; i < OBJECTS_COUNT; ++i) {\n+            for(int i = 0; i < OBJECTS_COUNT; ++i) {\n@@ -74,11 +75,5 @@\n-            \/\/ GC and wait for at least 2 MyObjects to be ready for finalization,\n-            \/\/ and one MyObject to be trapped in finalize().\n-            boolean forceGCResult = ForceGC.waitFor(() -> refQForTwo.bothRefsCleared() &&\n-                                                          trappedCount.intValue() > 0,\n-                    Duration.ofSeconds(60).toMillis());\n-            if (!forceGCResult) {\n-                System.out.println(\"*** ForceGC condition not met! ***\");\n-            }\n-            System.out.println(\"ref1Cleared: \" + refQForTwo.ref1Cleared);\n-            System.out.println(\"ref2Cleared: \" + refQForTwo.ref2Cleared);\n-            System.out.println(\"trappedCount.intValue(): \" + trappedCount.intValue());\n+            wb = WhiteBox.getWhiteBox();\n+            wb.fullGC();\n+            refProResult = wb.waitForReferenceProcessing();\n+            System.out.println(\"waitForReferenceProcessing returned: \" + refProResult);\n+            while(trappedCount.get() < 1);\n@@ -124,33 +119,0 @@\n-\n-    private static class RefQForTwo implements Runnable {\n-        final ReferenceQueue queue;\n-        final WeakReference ref1;\n-        final WeakReference ref2;\n-        volatile boolean ref1Cleared = false;\n-        volatile boolean ref2Cleared = false;\n-        Thread thread;\n-\n-        private RefQForTwo(Object obj1, Object obj2) {\n-            queue = new ReferenceQueue();\n-            ref1 = new WeakReference(obj1, queue);\n-            ref2 = new WeakReference(obj2, queue);\n-\n-            thread = new Thread(this, \"RefQForTwo thread\");\n-            thread.start();\n-        }\n-\n-        @Override\n-        public void run() {\n-            try {\n-                while (!bothRefsCleared()) {\n-                    Reference ref = queue.remove();\n-                    if (ref == ref1) { ref1Cleared = true; }\n-                    else if (ref == ref2) { ref2Cleared = true; }\n-                }\n-            } catch (InterruptedException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        public boolean bothRefsCleared() { return ref1Cleared && ref2Cleared; }\n-    }\n","filename":"test\/jdk\/java\/lang\/ref\/FinalizerHistogramTest.java","additions":17,"deletions":55,"binary":false,"changes":72,"status":"modified"}]}