{"files":[{"patch":"@@ -26,1 +26,4 @@\n-import java.lang.ref.PhantomReference;\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.WeakReference;\n+import java.time.Duration;\n@@ -48,0 +51,2 @@\n+    static RefQForTwo refQForTwo;\n+\n@@ -64,2 +69,1 @@\n-            final PhantomReference<MyObject> ref1 = new PhantomReference<>(new MyObject(), null);\n-            final PhantomReference<MyObject> ref2 = new PhantomReference<>(new MyObject(), null);\n+            refQForTwo = new RefQForTwo(new MyObject(), new MyObject());\n@@ -71,5 +75,10 @@\n-            \/\/ and one MyObject to be stuck in finalize().\n-            ForceGC.wait(() -> ref1.refersTo(null) &&\n-                               ref2.refersTo(null) &&\n-                               trappedCount.intValue() > 0\n-            );\n+            \/\/ and one MyObject to be trapped in finalize().\n+            boolean forceGCResult = ForceGC.waitFor(() -> refQForTwo.bothRefsCleared() &&\n+                                                          trappedCount.intValue() > 0,\n+                    Duration.ofSeconds(60).toMillis());\n+            if (!forceGCResult) {\n+                System.out.println(\"*** ForceGC condition not met! ***\");\n+            }\n+            System.out.println(\"ref1Cleared: \" + refQForTwo.ref1Cleared);\n+            System.out.println(\"ref2Cleared: \" + refQForTwo.ref2Cleared);\n+            System.out.println(\"trappedCount.intValue(): \" + trappedCount.intValue());\n@@ -115,0 +124,33 @@\n+\n+    private static class RefQForTwo implements Runnable {\n+        final ReferenceQueue queue;\n+        final WeakReference ref1;\n+        final WeakReference ref2;\n+        volatile boolean ref1Cleared = false;\n+        volatile boolean ref2Cleared = false;\n+        Thread thread;\n+\n+        private RefQForTwo(Object obj1, Object obj2) {\n+            queue = new ReferenceQueue();\n+            ref1 = new WeakReference(obj1, queue);\n+            ref2 = new WeakReference(obj2, queue);\n+\n+            thread = new Thread(this, \"RefQForTwo thread\");\n+            thread.start();\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                while (!bothRefsCleared()) {\n+                    Reference ref = queue.remove();\n+                    if (ref == ref1) { ref1Cleared = true; }\n+                    else if (ref == ref2) { ref2Cleared = true; }\n+                }\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        public boolean bothRefsCleared() { return ref1Cleared && ref2Cleared; }\n+    }\n","filename":"test\/jdk\/java\/lang\/ref\/FinalizerHistogramTest.java","additions":50,"deletions":8,"binary":false,"changes":58,"status":"modified"}]}