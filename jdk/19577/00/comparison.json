{"files":[{"patch":"@@ -589,2 +589,12 @@\n-    if (offset_plus_k(n->in(1)) && scaled_iv_plus_offset(n->in(2))) {\n-      _scale *= -1;\n+    VPointer tmp(this);\n+    if (offset_plus_k(n->in(1)) && tmp.scaled_iv_plus_offset(n->in(2))) {\n+      assert(_scale == 0, \"shouldn't be set yet\");\n+      _scale = tmp._scale * -1;\n+      _offset -= tmp._offset;\n+      if (tmp._invar != nullptr) {\n+        maybe_add_to_invar(tmp._invar, true);\n+#ifdef ASSERT\n+        _debug_invar_scale = tmp._debug_invar_scale;\n+        _debug_negate_invar = !tmp._debug_negate_invar;\n+#endif\n+      }\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ *\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.vectorization.TestVectorizationUnsafeNegativeScale\n+ *\n+ *\/\n+\n+package compiler.vectorization;\n+\n+import java.util.Arrays;\n+import jdk.internal.misc.Unsafe;\n+import compiler.lib.ir_framework.*;\n+\n+public class TestVectorizationUnsafeNegativeScale {\n+\n+    static Unsafe unsafe = Unsafe.getUnsafe();\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\");\n+    }\n+\n+    static byte[] byteArray = new byte[1000];\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR , \">= 1\"})\n+    private static void testByteArray(byte[] array, int start) {\n+        for (int i = start; i < array.length; i++) {\n+            final long idx = (long)array.length - (long)(i + 1);\n+            final long offset = Unsafe.ARRAY_BYTE_BASE_OFFSET + idx * Unsafe.ARRAY_BYTE_INDEX_SCALE;\n+            unsafe.putByte(array, offset, (byte) 0x42);\n+        }\n+    }\n+\n+    @Run(test = \"testByteArray\")\n+    private static void testByteArrayRunner() {\n+        Arrays.fill(byteArray, (byte)0);\n+        testByteArray(byteArray, 0);\n+        for (int j = 0; j < byteArray.length; j++) {\n+            if (byteArray[j] != 0x42) {\n+                throw new RuntimeException(\"For index \" + j + \": \" + byteArray[j]);\n+            }\n+        }\n+    }\n+\n+    static short[] shortArray = new short[1000];\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR , \">= 1\"})\n+    private static void testShortArray(short[] array, int start) {\n+        for (int i = start; i < array.length; i++) {\n+            final long idx = (long)array.length - (long)(i + 1);\n+            final long offset = Unsafe.ARRAY_SHORT_BASE_OFFSET + idx * Unsafe.ARRAY_SHORT_INDEX_SCALE;\n+            unsafe.putShort(array, offset, (short) 0x42);\n+        }\n+    }\n+\n+    @Run(test = \"testShortArray\")\n+    private static void testShortArrayRunner() {\n+        Arrays.fill(shortArray, (short)0);\n+        testShortArray(shortArray, 0);\n+        for (int j = 0; j < shortArray.length; j++) {\n+            if (shortArray[j] != 0x42) {\n+                throw new RuntimeException(\"For index \" + j + \": \" + shortArray[j]);\n+            }\n+        }\n+    }\n+\n+    static int[] intArray = new int[1000];\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR , \">= 1\"})\n+    private static void testIntArray(int[] array, int start) {\n+        for (int i = start; i < array.length; i++) {\n+            final long idx = (long)array.length - (long)(i + 1);\n+            final long offset = Unsafe.ARRAY_INT_BASE_OFFSET + idx * Unsafe.ARRAY_INT_INDEX_SCALE;\n+            unsafe.putInt(array, offset, (int) 0x42);\n+        }\n+    }\n+\n+    @Run(test = \"testIntArray\")\n+    private static void testIntArrayRunner() {\n+        Arrays.fill(intArray, (int)0);\n+        testIntArray(intArray, 0);\n+        for (int j = 0; j < intArray.length; j++) {\n+            if (intArray[j] != 0x42) {\n+                throw new RuntimeException(\"For index \" + j + \": \" + intArray[j]);\n+            }\n+        }\n+    }\n+\n+    static long[] longArray = new long[1000];\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR , \">= 1\"})\n+    private static void testLongArray(long[] array, int start) {\n+        for (int i = start; i < array.length; i++) {\n+            final long idx = (long)array.length - (long)(i + 1);\n+            final long offset = Unsafe.ARRAY_LONG_BASE_OFFSET + idx * Unsafe.ARRAY_LONG_INDEX_SCALE;\n+            unsafe.putLong(array, offset, (long) 0x42);\n+        }\n+    }\n+\n+    @Run(test = \"testLongArray\")\n+    private static void testLongArrayRunner() {\n+        Arrays.fill(longArray, (long)0);\n+        testLongArray(longArray, 0);\n+        for (int j = 0; j < longArray.length; j++) {\n+            if (longArray[j] != 0x42) {\n+                throw new RuntimeException(\"For index \" + j + \": \" + longArray[j]);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestVectorizationUnsafeNegativeScale.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"}]}