{"files":[{"patch":"@@ -91,8 +91,8 @@\n-    \/\/ Arrays don't add any new methods, so their vtable is the same size as\n-    \/\/ the vtable of klass Object.\n-    set_vtable_length(Universe::base_vtable_size());\n-    set_name(name);\n-    set_super(Universe::is_bootstrapping() ? NULL : vmClasses::Object_klass());\n-    set_layout_helper(Klass::_lh_neutral_value);\n-    set_is_cloneable(); \/\/ All arrays are considered to be cloneable (See JLS 20.1.5)\n-    JFR_ONLY(INIT_ID(this);)\n+  \/\/ Arrays don't add any new methods, so their vtable is the same size as\n+  \/\/ the vtable of klass Object.\n+  set_vtable_length(Universe::base_vtable_size());\n+  set_name(name);\n+  set_super(Universe::is_bootstrapping() ? NULL : vmClasses::Object_klass());\n+  set_layout_helper(Klass::_lh_neutral_value);\n+  set_is_cloneable(); \/\/ All arrays are considered to be cloneable (See JLS 20.1.5)\n+  JFR_ONLY(INIT_ID(this);)\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -380,3 +380,0 @@\n-    case Type::KlassPtr:\n-      st->print(\" %s%d]=#Ptr\" INTPTR_FORMAT,msg,i,p2i(t->make_ptr()->isa_klassptr()->klass()));\n-      break;\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1134,1 +1134,1 @@\n-  const TypeKlassPtr* ttkp = (ttp != NULL) ? ttp->isa_klassptr() : NULL;\n+  const TypeKlassPtr* ttkp = (ttp != NULL) ? ttp->isa_instklassptr() : NULL;\n@@ -1227,1 +1227,1 @@\n-    const TypeKlassPtr *jtkp = (jtp != NULL) ? jtp->isa_klassptr() : NULL;\n+    const TypeKlassPtr *jtkp = (jtp != NULL) ? jtp->isa_instklassptr() : NULL;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1398,1 +1398,1 @@\n-                                   TypeKlassPtr::OBJECT->klass(),\n+                                   TypeInstKlassPtr::OBJECT->klass(),\n@@ -1445,1 +1445,1 @@\n-    case Type::KlassPtr: tj = TypeKlassPtr::OBJECT; break;\n+    case Type::KlassPtr: tj = TypeInstKlassPtr::OBJECT; break;\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -897,1 +897,1 @@\n-    ex_klass_node = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, TypeInstPtr::KLASS, TypeKlassPtr::OBJECT));\n+    ex_klass_node = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n@@ -906,1 +906,1 @@\n-      ex_klass_node = new PhiNode(ex_node->in(0), TypeKlassPtr::OBJECT);\n+      ex_klass_node = new PhiNode(ex_node->in(0), TypeInstKlassPtr::OBJECT);\n@@ -915,1 +915,1 @@\n-        Node* k = _gvn.transform( LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, TypeInstPtr::KLASS, TypeKlassPtr::OBJECT));\n+        Node* k = _gvn.transform( LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n@@ -918,1 +918,1 @@\n-      _gvn.set_type(ex_klass_node, TypeKlassPtr::OBJECT);\n+      _gvn.set_type(ex_klass_node, TypeInstKlassPtr::OBJECT);\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3128,1 +3128,1 @@\n-              igvn->type(alloc->in(AllocateNode::KlassNode)) != TypeKlassPtr::OBJECT)) {\n+              igvn->type(alloc->in(AllocateNode::KlassNode)) != TypeInstKlassPtr::OBJECT)) {\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2854,1 +2854,1 @@\n-  Node *nkls = gvn.transform(LoadKlassNode::make(gvn, NULL, kmem, p2, gvn.type(p2)->is_ptr(), TypeKlassPtr::OBJECT_OR_NULL));\n+  Node *nkls = gvn.transform(LoadKlassNode::make(gvn, NULL, kmem, p2, gvn.type(p2)->is_ptr(), TypeInstKlassPtr::OBJECT_OR_NULL));\n@@ -3776,1 +3776,1 @@\n-  if (!tklass)  tklass = TypeKlassPtr::OBJECT;\n+  if (!tklass)  tklass = TypeInstKlassPtr::OBJECT;\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2834,1 +2834,1 @@\n-                                                 TypeRawPtr::BOTTOM, TypeKlassPtr::OBJECT_OR_NULL));\n+                                                 TypeRawPtr::BOTTOM, TypeInstKlassPtr::OBJECT_OR_NULL));\n@@ -2864,1 +2864,1 @@\n-                                                   TypeRawPtr::BOTTOM, TypeKlassPtr::OBJECT_OR_NULL));\n+                                                   TypeRawPtr::BOTTOM, TypeInstKlassPtr::OBJECT_OR_NULL));\n@@ -2957,1 +2957,1 @@\n-  const TypeKlassPtr*  kls_type = TypeKlassPtr::OBJECT_OR_NULL;\n+  const TypeKlassPtr*  kls_type = TypeInstKlassPtr::OBJECT_OR_NULL;\n@@ -3146,1 +3146,1 @@\n-    kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, TypeRawPtr::BOTTOM, TypeKlassPtr::OBJECT_OR_NULL));\n+    kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, TypeRawPtr::BOTTOM, TypeInstKlassPtr::OBJECT_OR_NULL));\n@@ -3288,1 +3288,1 @@\n-  const TypeKlassPtr* kls_type = TypeKlassPtr::OBJECT_OR_NULL;\n+  const TypeKlassPtr* kls_type = TypeInstKlassPtr::OBJECT_OR_NULL;\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -532,1 +532,1 @@\n-                    const TypeKlassPtr* tk = TypeKlassPtr::OBJECT);\n+                    const TypeKlassPtr* tk = TypeInstKlassPtr::OBJECT);\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1790,4 +1790,1 @@\n-    ciKlass*           klass = toop ? toop->klass() : (tkls ? tkls->klass() : NULL );\n-    if (klass && klass->is_loaded() && klass->is_interface()) {\n-      st->print(\"  Interface:\");\n-    } else if (toop) {\n+    if (toop) {\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -171,1 +171,1 @@\n-      && tak != TypeKlassPtr::OBJECT) {\n+      && tak != TypeInstKlassPtr::OBJECT) {\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -237,1 +237,1 @@\n-          Node* nkls = phase->transform(LoadKlassNode::make(*phase, NULL, C->immutable_memory(), p2, phase->type(p2)->is_ptr(), TypeKlassPtr::OBJECT_OR_NULL));\n+          Node* nkls = phase->transform(LoadKlassNode::make(*phase, NULL, C->immutable_memory(), p2, phase->type(p2)->is_ptr(), TypeInstKlassPtr::OBJECT_OR_NULL));\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -97,0 +97,2 @@\n+  { Bad,             T_METADATA,   \"instklass:\",    false, Op_RegP,              relocInfo::metadata_type },  \/\/ InstKlassPtr\n+  { Bad,             T_METADATA,   \"aryklass:\",     false, Op_RegP,              relocInfo::metadata_type },  \/\/ AryKlassPtr\n@@ -602,2 +604,2 @@\n-  TypeKlassPtr::OBJECT = TypeKlassPtr::make( TypePtr::NotNull, current->env()->Object_klass(), 0 );\n-  TypeKlassPtr::OBJECT_OR_NULL = TypeKlassPtr::make( TypePtr::BotPTR, current->env()->Object_klass(), 0 );\n+  TypeInstKlassPtr::OBJECT = TypeInstKlassPtr::make(TypePtr::NotNull, current->env()->Object_klass(), 0);\n+  TypeInstKlassPtr::OBJECT_OR_NULL = TypeInstKlassPtr::make(TypePtr::BotPTR, current->env()->Object_klass(), 0);\n@@ -936,0 +938,2 @@\n+  case InstKlassPtr:\n+  case AryKlassPtr:\n@@ -1193,0 +1197,2 @@\n+  case InstKlassPtr:\n+  case AryKlassPtr:\n@@ -1304,0 +1310,2 @@\n+  case InstKlassPtr:\n+  case AryKlassPtr:\n@@ -1475,0 +1483,2 @@\n+  case InstKlassPtr:\n+  case AryKlassPtr:\n@@ -1736,0 +1746,2 @@\n+  case InstKlassPtr:\n+  case AryKlassPtr:\n@@ -2583,0 +2595,2 @@\n+  case InstKlassPtr:\n+  case AryKlassPtr:\n@@ -3014,0 +3028,2 @@\n+  case InstKlassPtr:\n+  case AryKlassPtr:\n@@ -3204,7 +3220,3 @@\n-const TypeKlassPtr* TypeOopPtr::as_klass_type() const {\n-  ciKlass* k = klass();\n-  bool    xk = klass_is_exact();\n-  if (k == NULL)\n-    return TypeKlassPtr::OBJECT;\n-  else\n-    return TypeKlassPtr::make(xk? Constant: NotNull, k, 0);\n+const TypeKlassPtr* TypeOopPtr::as_klass_type(bool try_for_exact) const {\n+  ShouldNotReachHere();\n+  return NULL;\n@@ -3243,0 +3255,2 @@\n+  case InstKlassPtr:\n+  case AryKlassPtr:\n@@ -3773,0 +3787,2 @@\n+  case InstKlassPtr:\n+  case AryKlassPtr:\n@@ -3848,2 +3864,2 @@\n-    int off = meet_offset( tinst->offset() );\n-    PTR ptr = meet_ptr( tinst->ptr() );\n+    int off = meet_offset(tinst->offset());\n+    PTR ptr = meet_ptr(tinst->ptr());\n@@ -3853,10 +3869,0 @@\n-\n-    \/\/ Check for easy case; klasses are equal (and perhaps not loaded!)\n-    \/\/ If we have constants, then we created oops so classes are loaded\n-    \/\/ and we can handle the constants further down.  This case handles\n-    \/\/ both-not-loaded or both-loaded classes\n-    if (ptr != Constant && klass()->equals(tinst->klass()) && klass_is_exact() == tinst->klass_is_exact()) {\n-      return make(ptr, klass(), klass_is_exact(), NULL, off, instance_id, speculative, depth);\n-    }\n-\n-    \/\/ Classes require inspection in the Java klass hierarchy.  Must be loaded.\n@@ -3864,1 +3870,1 @@\n-    ciKlass* this_klass  = this->klass();\n+    ciKlass* this_klass  = klass();\n@@ -3866,2 +3872,7 @@\n-    bool this_xk  = this->klass_is_exact();\n-    if (!tinst_klass->is_loaded() || !this_klass->is_loaded() ) {\n+    bool this_xk  = klass_is_exact();\n+\n+    ciKlass* res_klass = NULL;\n+    bool res_xk = false;\n+    const Type* res;\n+    MeetResult kind = meet_instptr(ptr, this_klass, tinst_klass, this_xk, tinst_xk, this->_ptr, tinst->_ptr, res_klass, res_xk);\n+    if (kind == UNLOADED) {\n@@ -3869,1 +3880,1 @@\n-      const TypeInstPtr *unloaded_meet = xmeet_unloaded(tinst);\n+      const TypeInstPtr* unloaded_meet = xmeet_unloaded(tinst);\n@@ -3871,4 +3882,10 @@\n-      if( PrintOpto && Verbose ) {\n-        tty->print(\"meet of unloaded classes resulted in: \"); unloaded_meet->dump(); tty->cr();\n-        tty->print(\"  this == \"); this->dump(); tty->cr();\n-        tty->print(\" tinst == \"); tinst->dump(); tty->cr();\n+      if (PrintOpto && Verbose) {\n+        tty->print(\"meet of unloaded classes resulted in: \");\n+        unloaded_meet->dump();\n+        tty->cr();\n+        tty->print(\"  this == \");\n+        dump();\n+        tty->cr();\n+        tty->print(\" tinst == \");\n+        tinst->dump();\n+        tty->cr();\n@@ -3877,105 +3894,6 @@\n-      return unloaded_meet;\n-    }\n-\n-    \/\/ Handle mixing oops and interfaces first.\n-    if( this_klass->is_interface() && !(tinst_klass->is_interface() ||\n-                                        tinst_klass == ciEnv::current()->Object_klass())) {\n-      ciKlass *tmp = tinst_klass; \/\/ Swap interface around\n-      tinst_klass = this_klass;\n-      this_klass = tmp;\n-      bool tmp2 = tinst_xk;\n-      tinst_xk = this_xk;\n-      this_xk = tmp2;\n-    }\n-    if (tinst_klass->is_interface() &&\n-        !(this_klass->is_interface() ||\n-          \/\/ Treat java\/lang\/Object as an honorary interface,\n-          \/\/ because we need a bottom for the interface hierarchy.\n-          this_klass == ciEnv::current()->Object_klass())) {\n-      \/\/ Oop meets interface!\n-\n-      \/\/ See if the oop subtypes (implements) interface.\n-      ciKlass *k;\n-      bool xk;\n-      if( this_klass->is_subtype_of( tinst_klass ) ) {\n-        \/\/ Oop indeed subtypes.  Now keep oop or interface depending\n-        \/\/ on whether we are both above the centerline or either is\n-        \/\/ below the centerline.  If we are on the centerline\n-        \/\/ (e.g., Constant vs. AnyNull interface), use the constant.\n-        k  = below_centerline(ptr) ? tinst_klass : this_klass;\n-        \/\/ If we are keeping this_klass, keep its exactness too.\n-        xk = below_centerline(ptr) ? tinst_xk    : this_xk;\n-      } else {                  \/\/ Does not implement, fall to Object\n-        \/\/ Oop does not implement interface, so mixing falls to Object\n-        \/\/ just like the verifier does (if both are above the\n-        \/\/ centerline fall to interface)\n-        k = above_centerline(ptr) ? tinst_klass : ciEnv::current()->Object_klass();\n-        xk = above_centerline(ptr) ? tinst_xk : false;\n-        \/\/ Watch out for Constant vs. AnyNull interface.\n-        if (ptr == Constant) {\n-          ptr = NotNull;  \/\/ forget it was a constant\n-        }\n-        if (instance_id > 0) {\n-          instance_id = InstanceBot;\n-        }\n-      }\n-      ciObject* o = NULL;  \/\/ the Constant value, if any\n-      if (ptr == Constant) {\n-        \/\/ Find out which constant.\n-        o = (this_klass == klass()) ? const_oop() : tinst->const_oop();\n-      }\n-      return make(ptr, k, xk, o, off, instance_id, speculative, depth);\n-    }\n-\n-    \/\/ Either oop vs oop or interface vs interface or interface vs Object\n-\n-    \/\/ !!! Here's how the symmetry requirement breaks down into invariants:\n-    \/\/ If we split one up & one down AND they subtype, take the down man.\n-    \/\/ If we split one up & one down AND they do NOT subtype, \"fall hard\".\n-    \/\/ If both are up and they subtype, take the subtype class.\n-    \/\/ If both are up and they do NOT subtype, \"fall hard\".\n-    \/\/ If both are down and they subtype, take the supertype class.\n-    \/\/ If both are down and they do NOT subtype, \"fall hard\".\n-    \/\/ Constants treated as down.\n-\n-    \/\/ Now, reorder the above list; observe that both-down+subtype is also\n-    \/\/ \"fall hard\"; \"fall hard\" becomes the default case:\n-    \/\/ If we split one up & one down AND they subtype, take the down man.\n-    \/\/ If both are up and they subtype, take the subtype class.\n-\n-    \/\/ If both are down and they subtype, \"fall hard\".\n-    \/\/ If both are down and they do NOT subtype, \"fall hard\".\n-    \/\/ If both are up and they do NOT subtype, \"fall hard\".\n-    \/\/ If we split one up & one down AND they do NOT subtype, \"fall hard\".\n-\n-    \/\/ If a proper subtype is exact, and we return it, we return it exactly.\n-    \/\/ If a proper supertype is exact, there can be no subtyping relationship!\n-    \/\/ If both types are equal to the subtype, exactness is and-ed below the\n-    \/\/ centerline and or-ed above it.  (N.B. Constants are always exact.)\n-\n-    \/\/ Check for subtyping:\n-    ciKlass *subtype = NULL;\n-    bool subtype_exact = false;\n-    if( tinst_klass->equals(this_klass) ) {\n-      subtype = this_klass;\n-      subtype_exact = below_centerline(ptr) ? (this_xk && tinst_xk) : (this_xk || tinst_xk);\n-    } else if( !tinst_xk && this_klass->is_subtype_of( tinst_klass ) ) {\n-      subtype = this_klass;     \/\/ Pick subtyping class\n-      subtype_exact = this_xk;\n-    } else if( !this_xk && tinst_klass->is_subtype_of( this_klass ) ) {\n-      subtype = tinst_klass;    \/\/ Pick subtyping class\n-      subtype_exact = tinst_xk;\n-    }\n-\n-    if( subtype ) {\n-      if( above_centerline(ptr) ) { \/\/ both are up?\n-        this_klass = tinst_klass = subtype;\n-        this_xk = tinst_xk = subtype_exact;\n-      } else if( above_centerline(this ->_ptr) && !above_centerline(tinst->_ptr) ) {\n-        this_klass = tinst_klass; \/\/ tinst is down; keep down man\n-        this_xk = tinst_xk;\n-      } else if( above_centerline(tinst->_ptr) && !above_centerline(this ->_ptr) ) {\n-        tinst_klass = this_klass; \/\/ this is down; keep down man\n-        tinst_xk = this_xk;\n-      } else {\n-        this_xk = subtype_exact;  \/\/ either they are equal, or we'll do an LCA\n+      res = unloaded_meet;\n+    } else {\n+      if (kind == NOT_SUBTYPE && instance_id > 0) {\n+        instance_id = InstanceBot;\n+      } else if (kind == LCA) {\n+        instance_id = InstanceBot;\n@@ -3983,7 +3901,0 @@\n-    }\n-\n-    \/\/ Check for classes now being equal\n-    if (tinst_klass->equals(this_klass)) {\n-      \/\/ If the klasses are equal, the constants may still differ.  Fall to\n-      \/\/ NotNull if they do (neither constant is NULL; that is a special case\n-      \/\/ handled elsewhere).\n@@ -3991,1 +3902,1 @@\n-      ciObject* this_oop  = const_oop();\n+      ciObject* this_oop = const_oop();\n@@ -3993,1 +3904,1 @@\n-      if( ptr == Constant ) {\n+      if (ptr == Constant) {\n@@ -3995,1 +3906,1 @@\n-            this_oop->equals(tinst_oop) )\n+            this_oop->equals(tinst_oop))\n@@ -3997,1 +3908,2 @@\n-        else if (above_centerline(this ->_ptr))\n+        else if (above_centerline(_ptr)) {\n+          assert(!tinst_klass->is_interface(), \"\");\n@@ -3999,1 +3911,2 @@\n-        else if (above_centerline(tinst ->_ptr))\n+        } else if (above_centerline(tinst->_ptr)) {\n+          assert(!this_klass->is_interface(), \"\");\n@@ -4001,1 +3914,1 @@\n-        else\n+        } else\n@@ -4004,7 +3917,1 @@\n-      return make(ptr, this_klass, this_xk, o, off, instance_id, speculative, depth);\n-    } \/\/ Else classes are not equal\n-\n-    \/\/ Since klasses are different, we require a LCA in the Java\n-    \/\/ class hierarchy - which means we have to fall to at least NotNull.\n-    if (ptr == TopPTR || ptr == AnyNull || ptr == Constant) {\n-      ptr = NotNull;\n+      res = make(ptr, res_klass, res_xk, o, off, instance_id, speculative, depth);\n@@ -4012,1 +3919,0 @@\n-    instance_id = InstanceBot;\n@@ -4014,3 +3920,2 @@\n-    \/\/ Now we find the LCA of Java classes\n-    ciKlass* k = this_klass->least_common_ancestor(tinst_klass);\n-    return make(ptr, k, false, NULL, off, instance_id, speculative, depth);\n+    return res;\n+\n@@ -4023,0 +3928,138 @@\n+TypePtr::MeetResult TypePtr::meet_instptr(PTR &ptr, ciKlass* this_klass, ciKlass* tinst_klass, bool this_xk, bool tinst_xk,\n+                                          PTR this_ptr,\n+                                          PTR tinst_ptr, ciKlass*&res_klass, bool &res_xk) {\n+\n+  \/\/ Check for easy case; klasses are equal (and perhaps not loaded!)\n+  \/\/ If we have constants, then we created oops so classes are loaded\n+  \/\/ and we can handle the constants further down.  This case handles\n+  \/\/ both-not-loaded or both-loaded classes\n+  if (ptr != Constant && this_klass->equals(tinst_klass) && this_xk == tinst_xk) {\n+    res_klass = this_klass;\n+    res_xk = this_xk;\n+    return QUICK;\n+  }\n+\n+  \/\/ Classes require inspection in the Java klass hierarchy.  Must be loaded.\n+  if (!tinst_klass->is_loaded() || !this_klass->is_loaded()) {\n+    return UNLOADED;\n+  }\n+\n+  \/\/ Handle mixing oops and interfaces first.\n+  if (this_klass->is_interface() && !(tinst_klass->is_interface() ||\n+                                      tinst_klass == ciEnv::current()->Object_klass())) {\n+    ciKlass *tmp = tinst_klass; \/\/ Swap interface around\n+    tinst_klass = this_klass;\n+    this_klass = tmp;\n+    bool tmp2 = tinst_xk;\n+    tinst_xk = this_xk;\n+    this_xk = tmp2;\n+  }\n+  if (tinst_klass->is_interface() &&\n+      !(this_klass->is_interface() ||\n+        \/\/ Treat java\/lang\/Object as an honorary interface,\n+        \/\/ because we need a bottom for the interface hierarchy.\n+        this_klass == ciEnv::current()->Object_klass())) {\n+    \/\/ Oop meets interface!\n+\n+    \/\/ See if the oop subtypes (implements) interface.\n+    if (this_klass->is_subtype_of(tinst_klass)) {\n+      \/\/ Oop indeed subtypes.  Now keep oop or interface depending\n+      \/\/ on whether we are both above the centerline or either is\n+      \/\/ below the centerline.  If we are on the centerline\n+      \/\/ (e.g., Constant vs. AnyNull interface), use the constant.\n+      res_klass  = below_centerline(ptr) ? tinst_klass : this_klass;\n+      \/\/ If we are keeping this_klass, keep its exactness too.\n+      res_xk = below_centerline(ptr) ? tinst_xk    : this_xk;\n+      return SUBTYPE;\n+    } else {                  \/\/ Does not implement, fall to Object\n+      \/\/ Oop does not implement interface, so mixing falls to Object\n+      \/\/ just like the verifier does (if both are above the\n+      \/\/ centerline fall to interface)\n+      res_klass = above_centerline(ptr) ? tinst_klass : ciEnv::current()->Object_klass();\n+      res_xk = above_centerline(ptr) ? tinst_xk : false;\n+      \/\/ Watch out for Constant vs. AnyNull interface.\n+      if (ptr == Constant)  ptr = NotNull;   \/\/ forget it was a constant\n+      return NOT_SUBTYPE;\n+    }\n+  }\n+\n+  \/\/ Either oop vs oop or interface vs interface or interface vs Object\n+\n+  \/\/ !!! Here's how the symmetry requirement breaks down into invariants:\n+  \/\/ If we split one up & one down AND they subtype, take the down man.\n+  \/\/ If we split one up & one down AND they do NOT subtype, \"fall hard\".\n+  \/\/ If both are up and they subtype, take the subtype class.\n+  \/\/ If both are up and they do NOT subtype, \"fall hard\".\n+  \/\/ If both are down and they subtype, take the supertype class.\n+  \/\/ If both are down and they do NOT subtype, \"fall hard\".\n+  \/\/ Constants treated as down.\n+\n+  \/\/ Now, reorder the above list; observe that both-down+subtype is also\n+  \/\/ \"fall hard\"; \"fall hard\" becomes the default case:\n+  \/\/ If we split one up & one down AND they subtype, take the down man.\n+  \/\/ If both are up and they subtype, take the subtype class.\n+\n+  \/\/ If both are down and they subtype, \"fall hard\".\n+  \/\/ If both are down and they do NOT subtype, \"fall hard\".\n+  \/\/ If both are up and they do NOT subtype, \"fall hard\".\n+  \/\/ If we split one up & one down AND they do NOT subtype, \"fall hard\".\n+\n+  \/\/ If a proper subtype is exact, and we return it, we return it exactly.\n+  \/\/ If a proper supertype is exact, there can be no subtyping relationship!\n+  \/\/ If both types are equal to the subtype, exactness is and-ed below the\n+  \/\/ centerline and or-ed above it.  (N.B. Constants are always exact.)\n+\n+  \/\/ Check for subtyping:\n+  ciKlass *subtype = NULL;\n+  bool subtype_exact = false;\n+  if (tinst_klass->equals(this_klass)) {\n+    subtype = this_klass;\n+    subtype_exact = below_centerline(ptr) ? (this_xk && tinst_xk) : (this_xk || tinst_xk);\n+  } else if (!tinst_xk && this_klass->is_subtype_of(tinst_klass)) {\n+    subtype = this_klass;     \/\/ Pick subtyping class\n+    subtype_exact = this_xk;\n+  } else if (!this_xk && tinst_klass->is_subtype_of(this_klass)) {\n+    subtype = tinst_klass;    \/\/ Pick subtyping class\n+    subtype_exact = tinst_xk;\n+  }\n+\n+  if (subtype) {\n+    if (above_centerline(ptr)) { \/\/ both are up?\n+      this_klass = tinst_klass = subtype;\n+      this_xk = tinst_xk = subtype_exact;\n+    } else if (above_centerline(this_ptr) && !above_centerline(tinst_ptr)) {\n+      this_klass = tinst_klass; \/\/ tinst is down; keep down man\n+      this_xk = tinst_xk;\n+    } else if (above_centerline(tinst_ptr) && !above_centerline(this_ptr)) {\n+      tinst_klass = this_klass; \/\/ this is down; keep down man\n+      tinst_xk = this_xk;\n+    } else {\n+      this_xk = subtype_exact;  \/\/ either they are equal, or we'll do an LCA\n+    }\n+  }\n+\n+  \/\/ Check for classes now being equal\n+  if (tinst_klass->equals(this_klass)) {\n+    \/\/ If the klasses are equal, the constants may still differ.  Fall to\n+    \/\/ NotNull if they do (neither constant is NULL; that is a special case\n+    \/\/ handled elsewhere).\n+    res_klass = this_klass;\n+    res_xk = this_xk;\n+    return SUBTYPE;\n+  } \/\/ Else classes are not equal\n+\n+  \/\/ Since klasses are different, we require a LCA in the Java\n+  \/\/ class hierarchy - which means we have to fall to at least NotNull.\n+  if (ptr == TopPTR || ptr == AnyNull || ptr == Constant) {\n+    ptr = NotNull;\n+  }\n+\n+  \/\/ Now we find the LCA of Java classes\n+  ciKlass* k = this_klass->least_common_ancestor(tinst_klass);\n+\n+  res_klass = k;\n+  res_xk = false;\n+\n+  return LCA;\n+}\n+\n@@ -4139,0 +4182,12 @@\n+const TypeKlassPtr* TypeInstPtr::as_klass_type(bool try_for_exact) const {\n+  bool xk = klass_is_exact();\n+  ciInstanceKlass* ik = klass()->as_instance_klass();\n+  if (try_for_exact && !xk && !ik->has_subklass() && !ik->is_final() && !ik->is_interface()) {\n+    Compile* C = Compile::current();\n+    Dependencies* deps = C->dependencies();\n+    deps->assert_leaf_type(ik);\n+    xk = true;\n+  }\n+  return TypeInstKlassPtr::make(xk ? TypePtr::Constant : TypePtr::NotNull, klass(), 0);\n+}\n+\n@@ -4382,0 +4437,2 @@\n+  case InstKlassPtr:\n+  case AryKlassPtr:\n@@ -4392,31 +4449,0 @@\n-    ciKlass* lazy_klass = NULL;\n-    if (tary->_elem->isa_int()) {\n-      \/\/ Integral array element types have irrelevant lattice relations.\n-      \/\/ It is the klass that determines array layout, not the element type.\n-      if (_klass == NULL)\n-        lazy_klass = tap->_klass;\n-      else if (tap->_klass == NULL || tap->_klass == _klass) {\n-        lazy_klass = _klass;\n-      } else {\n-        \/\/ Something like byte[int+] meets char[int+].\n-        \/\/ This must fall to bottom, not (int[-128..65535])[int+].\n-        instance_id = InstanceBot;\n-        tary = TypeAry::make(Type::BOTTOM, tary->_size, tary->_stable);\n-      }\n-    } else \/\/ Non integral arrays.\n-      \/\/ Must fall to bottom if exact klasses in upper lattice\n-      \/\/ are not equal or super klass is exact.\n-      if ((above_centerline(ptr) || ptr == Constant) && klass() != tap->klass() &&\n-          \/\/ meet with top[] and bottom[] are processed further down:\n-          tap->_klass != NULL  && this->_klass != NULL   &&\n-          \/\/ both are exact and not equal:\n-          ((tap->_klass_is_exact && this->_klass_is_exact) ||\n-           \/\/ 'tap'  is exact and super or unrelated:\n-           (tap->_klass_is_exact && !tap->klass()->is_subtype_of(klass())) ||\n-           \/\/ 'this' is exact and super or unrelated:\n-           (this->_klass_is_exact && !klass()->is_subtype_of(tap->klass())))) {\n-      if (above_centerline(ptr) || (tary->_elem->make_ptr() && above_centerline(tary->_elem->make_ptr()->_ptr))) {\n-        tary = TypeAry::make(Type::BOTTOM, tary->_size, tary->_stable);\n-      }\n-      return make(NotNull, NULL, tary, lazy_klass, false, off, InstanceBot, speculative, depth);\n-    }\n@@ -4424,30 +4450,5 @@\n-    bool xk = false;\n-    switch (tap->ptr()) {\n-    case AnyNull:\n-    case TopPTR:\n-      \/\/ Compute new klass on demand, do not use tap->_klass\n-      if (below_centerline(this->_ptr)) {\n-        xk = this->_klass_is_exact;\n-      } else {\n-        xk = (tap->_klass_is_exact || this->_klass_is_exact);\n-      }\n-      return make(ptr, const_oop(), tary, lazy_klass, xk, off, instance_id, speculative, depth);\n-    case Constant: {\n-      ciObject* o = const_oop();\n-      if( _ptr == Constant ) {\n-        if( tap->const_oop() != NULL && !o->equals(tap->const_oop()) ) {\n-          xk = (klass() == tap->klass());\n-          ptr = NotNull;\n-          o = NULL;\n-          instance_id = InstanceBot;\n-        } else {\n-          xk = true;\n-        }\n-      } else if(above_centerline(_ptr)) {\n-        o = tap->const_oop();\n-        xk = true;\n-      } else {\n-        \/\/ Only precise for identical arrays\n-        xk = this->_klass_is_exact && (klass() == tap->klass());\n-      }\n-      return make(ptr, o, tary, lazy_klass, xk, off, instance_id, speculative, depth);\n+    ciKlass* res_klass = NULL;\n+    bool res_xk = false;\n+    const Type* elem = tary->_elem;\n+    if (meet_aryptr(ptr, elem, this->klass(), tap->klass(), this->klass_is_exact(), tap->klass_is_exact(), this->ptr(), tap->ptr(), res_klass, res_xk) == NOT_SUBTYPE) {\n+      instance_id = InstanceBot;\n@@ -4455,5 +4456,12 @@\n-    case NotNull:\n-    case BotPTR:\n-      \/\/ Compute new klass on demand, do not use tap->_klass\n-      if (above_centerline(this->_ptr)) {\n-        xk = tap->_klass_is_exact;\n+\n+    ciObject* o = NULL;             \/\/ Assume not constant when done\n+    ciObject* this_oop = const_oop();\n+    ciObject* tap_oop = tap->const_oop();\n+    if (ptr == Constant) {\n+      if (this_oop != NULL && tap_oop != NULL &&\n+          this_oop->equals(tap_oop)) {\n+        o = tap_oop;\n+      } else if (above_centerline(_ptr)) {\n+        o = tap_oop;\n+      } else if (above_centerline(tap->_ptr)) {\n+        o = this_oop;\n@@ -4461,2 +4469,1 @@\n-        xk = (tap->_klass_is_exact & this->_klass_is_exact) &&\n-             (klass() == tap->klass()); \/\/ Only precise for identical arrays\n+        ptr = NotNull;\n@@ -4464,2 +4471,0 @@\n-      return make(ptr, NULL, tary, lazy_klass, xk, off, instance_id, speculative, depth);\n-    default: ShouldNotReachHere();\n@@ -4467,0 +4472,1 @@\n+    return make(ptr, o, TypeAry::make(elem, tary->_size, tary->_stable), res_klass, res_xk, off, instance_id, speculative, depth);\n@@ -4523,0 +4529,79 @@\n+\n+TypePtr::MeetResult TypePtr::meet_aryptr(PTR& ptr, const Type*& elem, ciKlass* this_klass, ciKlass* tap_klass, bool this_xk, bool tap_xk, PTR this_ptr, PTR tap_ptr, ciKlass*& res_klass, bool& res_xk) {\n+  res_klass = NULL;\n+  MeetResult result = SUBTYPE;\n+  if (elem->isa_int()) {\n+    \/\/ Integral array element types have irrelevant lattice relations.\n+    \/\/ It is the klass that determines array layout, not the element type.\n+    if (this_klass == NULL)\n+      res_klass = tap_klass;\n+    else if (tap_klass == NULL || tap_klass == this_klass) {\n+      res_klass = this_klass;\n+    } else {\n+      \/\/ Something like byte[int+] meets char[int+].\n+      \/\/ This must fall to bottom, not (int[-128..65535])[int+].\n+      \/\/ instance_id = InstanceBot;\n+      elem = Type::BOTTOM;\n+      result = NOT_SUBTYPE;\n+    }\n+  } else \/\/ Non integral arrays.\n+    \/\/ Must fall to bottom if exact klasses in upper lattice\n+    \/\/ are not equal or super klass is exact.\n+    if ((above_centerline(ptr) || ptr == Constant) && this_klass != tap_klass &&\n+        \/\/ meet with top[] and bottom[] are processed further down:\n+        tap_klass != NULL  && this_klass != NULL   &&\n+        \/\/ both are exact and not equal:\n+        ((tap_xk && this_xk) ||\n+         \/\/ 'tap'  is exact and super or unrelated:\n+         (tap_xk && !tap_klass->is_subtype_of(this_klass)) ||\n+         \/\/ 'this' is exact and super or unrelated:\n+         (this_xk && !this_klass->is_subtype_of(tap_klass)))) {\n+      if (above_centerline(ptr) || (elem->make_ptr() && above_centerline(elem->make_ptr()->_ptr))) {\n+        elem = Type::BOTTOM;\n+      }\n+      ptr = NotNull;\n+      res_xk = false;\n+      return NOT_SUBTYPE;\n+    }\n+\n+  res_xk = false;\n+  switch (tap_ptr) {\n+    case AnyNull:\n+    case TopPTR:\n+      \/\/ Compute new klass on demand, do not use tap->_klass\n+      if (below_centerline(this_ptr)) {\n+        res_xk = this_xk;\n+      } else {\n+        res_xk = (tap_xk || this_xk);\n+      }\n+      return result;\n+    case Constant: {\n+      if (this_ptr == Constant) {\n+          res_xk = true;\n+      } else if(above_centerline(this_ptr)) {\n+        res_xk = true;\n+      } else {\n+        \/\/ Only precise for identical arrays\n+        res_xk = this_xk && (this_klass == tap_klass);\n+      }\n+      return result;\n+    }\n+    case NotNull:\n+    case BotPTR:\n+      \/\/ Compute new klass on demand, do not use tap->_klass\n+      if (above_centerline(this_ptr)) {\n+        res_xk = tap_xk;\n+      } else {\n+        res_xk = (tap_xk && this_xk) &&\n+          (this_klass == tap_klass); \/\/ Only precise for identical arrays\n+      }\n+      return result;\n+    default:  {\n+      ShouldNotReachHere();\n+      return result;\n+    }\n+  }\n+  return result;\n+}\n+\n+\n@@ -4704,0 +4789,2 @@\n+  case InstKlassPtr:\n+  case AryKlassPtr:\n@@ -4882,0 +4969,2 @@\n+  case InstKlassPtr:\n+  case AryKlassPtr:\n@@ -4955,2 +5044,11 @@\n-\/\/=============================================================================\n-\/\/ Convenience common pre-built types.\n+const TypeKlassPtr* TypeAryPtr::as_klass_type(bool try_for_exact) const {\n+  const Type* elem = _ary->_elem;\n+  bool xk = klass_is_exact();\n+  if (elem->make_oopptr() != NULL) {\n+    elem = elem->make_oopptr()->as_klass_type(try_for_exact);\n+    if (elem->is_klassptr()->klass_is_exact()) {\n+      xk = true;\n+    }\n+  }\n+  return TypeAryKlassPtr::make(xk ? TypePtr::Constant : TypePtr::NotNull, elem, klass(), 0);\n+}\n@@ -4958,3 +5056,6 @@\n-\/\/ Not-null object klass or below\n-const TypeKlassPtr *TypeKlassPtr::OBJECT;\n-const TypeKlassPtr *TypeKlassPtr::OBJECT_OR_NULL;\n+const TypeKlassPtr* TypeKlassPtr::make(ciKlass *klass) {\n+  if (klass->is_instance_klass()) {\n+    return TypeInstKlassPtr::make(klass);\n+  }\n+  return TypeAryKlassPtr::make(klass);\n+}\n@@ -4962,3 +5063,5 @@\n-\/\/------------------------------TypeKlassPtr-----------------------------------\n-TypeKlassPtr::TypeKlassPtr( PTR ptr, ciKlass* klass, int offset )\n-  : TypePtr(KlassPtr, ptr, offset), _klass(klass), _klass_is_exact(ptr == Constant) {\n+const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* klass, int offset) {\n+  if (klass->is_instance_klass()) {\n+    return TypeInstKlassPtr::make(ptr, klass, offset);\n+  }\n+  return TypeAryKlassPtr::make(ptr, klass, offset);\n@@ -4967,7 +5070,0 @@\n-\/\/------------------------------make-------------------------------------------\n-\/\/ ptr to klass 'k', if Constant, or possibly to a sub-klass if not a Constant\n-const TypeKlassPtr *TypeKlassPtr::make( PTR ptr, ciKlass* k, int offset ) {\n-  assert( k != NULL, \"Expect a non-NULL klass\");\n-  assert(k->is_instance_klass() || k->is_array_klass(), \"Incorrect type of klass oop\");\n-  TypeKlassPtr *r =\n-    (TypeKlassPtr*)(new TypeKlassPtr(ptr, k, offset))->hashcons();\n@@ -4975,1 +5071,3 @@\n-  return r;\n+\/\/------------------------------TypeKlassPtr-----------------------------------\n+TypeKlassPtr::TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, int offset)\n+  : TypePtr(t, ptr, offset), _klass(klass) {\n@@ -4980,1 +5078,1 @@\n-bool TypeKlassPtr::eq( const Type *t ) const {\n+bool TypeKlassPtr::eq(const Type *t) const {\n@@ -4983,1 +5081,0 @@\n-    klass()->equals(p->klass()) &&\n@@ -4990,1 +5087,1 @@\n-  return java_add((jint)klass()->hash(), (jint)TypePtr::hash());\n+  return TypePtr::hash();\n@@ -5007,2 +5104,2 @@\n-  const TypeKlassPtr* ftkp = ft->isa_klassptr();\n-  const TypeKlassPtr* ktkp = kills->isa_klassptr();\n+  const TypeKlassPtr* ftkp = ft->isa_instklassptr();\n+  const TypeKlassPtr* ktkp = kills->isa_instklassptr();\n@@ -5029,0 +5126,312 @@\n+\/\/------------------------------get_con----------------------------------------\n+intptr_t TypeKlassPtr::get_con() const {\n+  assert( _ptr == Null || _ptr == Constant, \"\" );\n+  assert( _offset >= 0, \"\" );\n+\n+  if (_offset != 0) {\n+    \/\/ After being ported to the compiler interface, the compiler no longer\n+    \/\/ directly manipulates the addresses of oops.  Rather, it only has a pointer\n+    \/\/ to a handle at compile time.  This handle is embedded in the generated\n+    \/\/ code and dereferenced at the time the nmethod is made.  Until that time,\n+    \/\/ it is not reasonable to do arithmetic with the addresses of oops (we don't\n+    \/\/ have access to the addresses!).  This does not seem to currently happen,\n+    \/\/ but this assertion here is to help prevent its occurence.\n+    tty->print_cr(\"Found oop constant with non-zero offset\");\n+    ShouldNotReachHere();\n+  }\n+\n+  return (intptr_t)klass()->constant_encoding();\n+}\n+\n+\/\/------------------------------dump2------------------------------------------\n+\/\/ Dump Klass Type\n+#ifndef PRODUCT\n+void TypeKlassPtr::dump2( Dict & d, uint depth, outputStream *st ) const {\n+  {\n+    const char *name = klass()->name()->as_utf8();\n+    if( name ) {\n+      st->print(\"klass %s: \" INTPTR_FORMAT, name, p2i(klass()));\n+    } else {\n+      ShouldNotReachHere();\n+    }\n+  }\n+  switch( _ptr ) {\n+  case Constant:\n+    st->print(\"precise \");\n+  case NotNull:\n+  case BotPTR:\n+    if( !WizardMode && !Verbose && _ptr != Constant ) break;\n+  case TopPTR:\n+  case AnyNull:\n+    st->print(\":%s\", ptr_msg[_ptr]);\n+    if( _ptr == Constant ) st->print(\":exact\");\n+    break;\n+  default:\n+    break;\n+  }\n+\n+  if( _offset ) {               \/\/ Dump offset, if any\n+    if( _offset == OffsetBot )      { st->print(\"+any\"); }\n+    else if( _offset == OffsetTop ) { st->print(\"+unknown\"); }\n+    else                            { st->print(\"+%d\", _offset); }\n+  }\n+\n+  st->print(\" *\");\n+}\n+#endif\n+\n+\/\/=============================================================================\n+\/\/ Convenience common pre-built types.\n+\n+\/\/ Not-null object klass or below\n+const TypeInstKlassPtr *TypeInstKlassPtr::OBJECT;\n+const TypeInstKlassPtr *TypeInstKlassPtr::OBJECT_OR_NULL;\n+\n+bool TypeInstKlassPtr::eq(const Type *t) const {\n+  const TypeKlassPtr *p = t->is_klassptr();\n+  return\n+    klass()->equals(p->klass()) &&\n+    TypeKlassPtr::eq(p);\n+}\n+\n+int TypeInstKlassPtr::hash(void) const {\n+  return java_add((jint)klass()->hash(), TypeKlassPtr::hash());\n+}\n+\n+const TypeInstKlassPtr *TypeInstKlassPtr::make(PTR ptr, ciKlass* k, int offset) {\n+  TypeInstKlassPtr *r =\n+    (TypeInstKlassPtr*)(new TypeInstKlassPtr(ptr, k, offset))->hashcons();\n+\n+  return r;\n+}\n+\n+\/\/------------------------------add_offset-------------------------------------\n+\/\/ Access internals of klass object\n+const TypePtr *TypeInstKlassPtr::add_offset( intptr_t offset ) const {\n+  return make( _ptr, klass(), xadd_offset(offset) );\n+}\n+\n+const TypeKlassPtr *TypeInstKlassPtr::with_offset(intptr_t offset) const {\n+  return make(_ptr, klass(), offset);\n+}\n+\n+\/\/------------------------------cast_to_ptr_type-------------------------------\n+const TypePtr* TypeInstKlassPtr::cast_to_ptr_type(PTR ptr) const {\n+  assert(_base == InstKlassPtr, \"subclass must override cast_to_ptr_type\");\n+  if( ptr == _ptr ) return this;\n+  return make(ptr, _klass, _offset);\n+}\n+\n+\n+bool TypeInstKlassPtr::must_be_exact() const {\n+  if (!_klass->is_loaded())  return false;\n+  ciInstanceKlass* ik = _klass->as_instance_klass();\n+  if (ik->is_final())  return true;  \/\/ cannot clear xk\n+  return false;\n+}\n+\n+\/\/-----------------------------cast_to_exactness-------------------------------\n+const TypeKlassPtr* TypeInstKlassPtr::cast_to_exactness(bool klass_is_exact) const {\n+  if (klass_is_exact == (_ptr == Constant)) return this;\n+  if (must_be_exact()) return this;\n+  ciKlass* k = klass();\n+  return make(klass_is_exact ? Constant : NotNull, k, _offset);\n+}\n+\n+\n+\/\/-----------------------------as_instance_type--------------------------------\n+\/\/ Corresponding type for an instance of the given class.\n+\/\/ It will be NotNull, and exact if and only if the klass type is exact.\n+const TypeOopPtr* TypeInstKlassPtr::as_instance_type() const {\n+  ciKlass* k = klass();\n+  bool    xk = klass_is_exact();\n+  return TypeInstPtr::make(TypePtr::BotPTR, k, xk, NULL, 0);\n+}\n+\n+\/\/------------------------------xmeet------------------------------------------\n+\/\/ Compute the MEET of two types, return a new Type object.\n+const Type    *TypeInstKlassPtr::xmeet( const Type *t ) const {\n+  \/\/ Perform a fast test for common case; meeting the same types together.\n+  if( this == t ) return this;  \/\/ Meeting same type-rep?\n+\n+  \/\/ Current \"this->_base\" is Pointer\n+  switch (t->base()) {          \/\/ switch on original type\n+\n+  case Int:                     \/\/ Mixing ints & oops happens when javac\n+  case Long:                    \/\/ reuses local variables\n+  case FloatTop:\n+  case FloatCon:\n+  case FloatBot:\n+  case DoubleTop:\n+  case DoubleCon:\n+  case DoubleBot:\n+  case NarrowOop:\n+  case NarrowKlass:\n+  case Bottom:                  \/\/ Ye Olde Default\n+    return Type::BOTTOM;\n+  case Top:\n+    return this;\n+\n+  default:                      \/\/ All else is a mistake\n+    typerr(t);\n+\n+  case AnyPtr: {                \/\/ Meeting to AnyPtrs\n+    \/\/ Found an AnyPtr type vs self-KlassPtr type\n+    const TypePtr *tp = t->is_ptr();\n+    int offset = meet_offset(tp->offset());\n+    PTR ptr = meet_ptr(tp->ptr());\n+    switch (tp->ptr()) {\n+    case TopPTR:\n+      return this;\n+    case Null:\n+      if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, tp->speculative(), tp->inline_depth());\n+    case AnyNull:\n+      return make( ptr, klass(), offset );\n+    case BotPTR:\n+    case NotNull:\n+      return TypePtr::make(AnyPtr, ptr, offset, tp->speculative(), tp->inline_depth());\n+    default: typerr(t);\n+    }\n+  }\n+\n+  case RawPtr:\n+  case MetadataPtr:\n+  case OopPtr:\n+  case AryPtr:                  \/\/ Meet with AryPtr\n+  case InstPtr:                 \/\/ Meet with InstPtr\n+    return TypePtr::BOTTOM;\n+\n+  \/\/\n+  \/\/             A-top         }\n+  \/\/           \/   |   \\       }  Tops\n+  \/\/       B-top A-any C-top   }\n+  \/\/          | \/  |  \\ |      }  Any-nulls\n+  \/\/       B-any   |   C-any   }\n+  \/\/          |    |    |\n+  \/\/       B-con A-con C-con   } constants; not comparable across classes\n+  \/\/          |    |    |\n+  \/\/       B-not   |   C-not   }\n+  \/\/          | \\  |  \/ |      }  not-nulls\n+  \/\/       B-bot A-not C-bot   }\n+  \/\/           \\   |   \/       }  Bottoms\n+  \/\/             A-bot         }\n+  \/\/\n+\n+  case InstKlassPtr: {  \/\/ Meet two KlassPtr types\n+    const TypeInstKlassPtr *tkls = t->is_instklassptr();\n+    int  off     = meet_offset(tkls->offset());\n+    PTR  ptr     = meet_ptr(tkls->ptr());\n+    ciKlass* tkls_klass = tkls->klass();\n+    ciKlass* this_klass  = klass();\n+    bool tkls_xk = tkls->klass_is_exact();\n+    bool this_xk  = klass_is_exact();\n+\n+    ciKlass* res_klass = NULL;\n+    bool res_xk = false;\n+    switch(meet_instptr(ptr, this_klass, tkls_klass, this_xk, tkls_xk, this->_ptr, tkls->_ptr, res_klass, res_xk)) {\n+      case UNLOADED:\n+        ShouldNotReachHere();\n+      case SUBTYPE:\n+      case NOT_SUBTYPE:\n+      case LCA:\n+      case QUICK: {\n+        assert(res_xk == (ptr == Constant), \"\");\n+        const Type* res1 = make(ptr, res_klass, off);\n+        return res1;\n+      }\n+      default:\n+        ShouldNotReachHere();\n+    }\n+  } \/\/ End of case KlassPtr\n+  case AryKlassPtr: {                \/\/ All arrays inherit from Object class\n+    const TypeAryKlassPtr *tp = t->is_aryklassptr();\n+    int offset = meet_offset(tp->offset());\n+    PTR ptr = meet_ptr(tp->ptr());\n+\n+    switch (ptr) {\n+    case TopPTR:\n+    case AnyNull:                \/\/ Fall 'down' to dual of object klass\n+      \/\/ For instances when a subclass meets a superclass we fall\n+      \/\/ below the centerline when the superclass is exact. We need to\n+      \/\/ do the same here.\n+      if (klass()->equals(ciEnv::current()->Object_klass()) && !klass_is_exact()) {\n+        return TypeAryKlassPtr::make(ptr, tp->elem(), tp->klass(), offset);\n+      } else {\n+        \/\/ cannot subclass, so the meet has to fall badly below the centerline\n+        ptr = NotNull;\n+        return make(ptr, ciEnv::current()->Object_klass(), offset);\n+      }\n+    case Constant:\n+    case NotNull:\n+    case BotPTR:                \/\/ Fall down to object klass\n+      \/\/ LCA is object_klass, but if we subclass from the top we can do better\n+      if( above_centerline(_ptr) ) { \/\/ if( _ptr == TopPTR || _ptr == AnyNull )\n+        \/\/ If 'this' (InstPtr) is above the centerline and it is Object class\n+        \/\/ then we can subclass in the Java class hierarchy.\n+        \/\/ For instances when a subclass meets a superclass we fall\n+        \/\/ below the centerline when the superclass is exact. We need\n+        \/\/ to do the same here.\n+        if (klass()->equals(ciEnv::current()->Object_klass())) {\n+          \/\/ that is, tp's array type is a subtype of my klass\n+          return TypeAryKlassPtr::make(ptr,\n+                                       tp->elem(), tp->klass(), offset);\n+        }\n+      }\n+      \/\/ The other case cannot happen, since I cannot be a subtype of an array.\n+      \/\/ The meet falls down to Object class below centerline.\n+      if( ptr == Constant )\n+         ptr = NotNull;\n+      return make(ptr, ciEnv::current()->Object_klass(), offset);\n+    default: typerr(t);\n+    }\n+  }\n+\n+  } \/\/ End of switch\n+  return this;                  \/\/ Return the double constant\n+}\n+\n+\/\/------------------------------xdual------------------------------------------\n+\/\/ Dual: compute field-by-field dual\n+const Type    *TypeInstKlassPtr::xdual() const {\n+  return new TypeInstKlassPtr(dual_ptr(), klass(), dual_offset());\n+}\n+\n+const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, const Type* elem, ciKlass* k, int offset) {\n+  return (TypeAryKlassPtr*)(new TypeAryKlassPtr(ptr, elem, k, offset))->hashcons();\n+}\n+\n+const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, ciKlass* klass, int offset) {\n+  if (klass->is_obj_array_klass()) {\n+    \/\/ Element is an object array. Recursively call ourself.\n+    ciKlass* eklass = klass->as_obj_array_klass()->element_klass();\n+    const TypeKlassPtr *etype = TypeKlassPtr::make(eklass)->cast_to_exactness(false);\n+    return TypeAryKlassPtr::make(ptr, etype, NULL, offset);\n+  } else if (klass->is_type_array_klass()) {\n+    \/\/ Element is an typeArray\n+    const Type* etype = get_const_basic_type(klass->as_type_array_klass()->element_type());\n+    return TypeAryKlassPtr::make(ptr, etype, klass, offset);\n+  } else {\n+    ShouldNotReachHere();\n+    return NULL;\n+  }\n+}\n+\n+const TypeAryKlassPtr* TypeAryKlassPtr::make(ciKlass* klass) {\n+  return TypeAryKlassPtr::make(Constant, klass, 0);\n+}\n+\n+\/\/------------------------------eq---------------------------------------------\n+\/\/ Structural equality check for Type representations\n+bool TypeAryKlassPtr::eq(const Type *t) const {\n+  const TypeAryKlassPtr *p = t->is_aryklassptr();\n+  return\n+    _elem == p->_elem &&  \/\/ Check array\n+    TypeKlassPtr::eq(p);  \/\/ Check sub-parts\n+}\n+\n+\/\/------------------------------hash-------------------------------------------\n+\/\/ Type-specific hashing function.\n+int TypeAryKlassPtr::hash(void) const {\n+  return (intptr_t)_elem + TypeKlassPtr::hash();\n+}\n+\n@@ -5119,2 +5528,6 @@\n-const TypePtr *TypeKlassPtr::add_offset( intptr_t offset ) const {\n-  return make( _ptr, klass(), xadd_offset(offset) );\n+const TypePtr *TypeAryKlassPtr::add_offset(intptr_t offset) const {\n+  return make(_ptr, elem(), klass(), xadd_offset(offset));\n+}\n+\n+const TypeKlassPtr *TypeAryKlassPtr::with_offset(intptr_t offset) const {\n+  return make(_ptr, elem(), klass(), offset);\n@@ -5124,4 +5537,12 @@\n-const Type *TypeKlassPtr::cast_to_ptr_type(PTR ptr) const {\n-  assert(_base == KlassPtr, \"subclass must override cast_to_ptr_type\");\n-  if( ptr == _ptr ) return this;\n-  return make(ptr, _klass, _offset);\n+const TypePtr* TypeAryKlassPtr::cast_to_ptr_type(PTR ptr) const {\n+  assert(_base == AryKlassPtr, \"subclass must override cast_to_ptr_type\");\n+  if (ptr == _ptr) return this;\n+  return make(ptr, elem(), _klass, _offset);\n+}\n+\n+bool TypeAryKlassPtr::must_be_exact() const {\n+  if (_elem == Type::BOTTOM) return false;\n+  if (_elem == Type::TOP   ) return false;\n+  const TypeKlassPtr*  tk = _elem->isa_klassptr();\n+  if (!tk)             return true;   \/\/ a primitive type, like int\n+  return tk->must_be_exact();\n@@ -5132,3 +5553,8 @@\n-const Type *TypeKlassPtr::cast_to_exactness(bool klass_is_exact) const {\n-  if( klass_is_exact == _klass_is_exact ) return this;\n-  return make(klass_is_exact ? Constant : NotNull, _klass, _offset);\n+const TypeKlassPtr *TypeAryKlassPtr::cast_to_exactness(bool klass_is_exact) const {\n+  if (must_be_exact()) return this;  \/\/ cannot clear xk\n+  ciKlass* k = _klass;\n+  const Type* elem = this->elem();\n+  if (elem->isa_klassptr() && !klass_is_exact) {\n+    elem = elem->is_klassptr()->cast_to_exactness(klass_is_exact);\n+  }\n+  return make(klass_is_exact ? Constant : NotNull, elem, k, _offset);\n@@ -5141,1 +5567,1 @@\n-const TypeOopPtr* TypeKlassPtr::as_instance_type() const {\n+const TypeOopPtr* TypeAryKlassPtr::as_instance_type() const {\n@@ -5144,1 +5570,0 @@\n-  \/\/return TypeInstPtr::make(TypePtr::NotNull, k, xk, NULL, 0);\n@@ -5148,1 +5573,2 @@\n-  return toop->cast_to_exactness(xk)->is_oopptr();\n+  const Type* el = elem()->isa_klassptr() ? elem()->is_klassptr()->as_instance_type()->is_oopptr()->cast_to_exactness(false) : elem();\n+  return TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(el, TypeInt::POS), k, xk, 0);\n@@ -5154,1 +5580,1 @@\n-const Type    *TypeKlassPtr::xmeet( const Type *t ) const {\n+const Type    *TypeAryKlassPtr::xmeet( const Type *t ) const {\n@@ -5190,1 +5616,1 @@\n-      return make( ptr, klass(), offset );\n+      return make( ptr, _elem, klass(), offset );\n@@ -5221,12 +5647,4 @@\n-  case KlassPtr: {  \/\/ Meet two KlassPtr types\n-    const TypeKlassPtr *tkls = t->is_klassptr();\n-    int  off     = meet_offset(tkls->offset());\n-    PTR  ptr     = meet_ptr(tkls->ptr());\n-\n-    \/\/ Check for easy case; klasses are equal (and perhaps not loaded!)\n-    \/\/ If we have constants, then we created oops so classes are loaded\n-    \/\/ and we can handle the constants further down.  This case handles\n-    \/\/ not-loaded classes\n-    if( ptr != Constant && tkls->klass()->equals(klass()) ) {\n-      return make( ptr, klass(), off );\n-    }\n+  case AryKlassPtr: {  \/\/ Meet two KlassPtr types\n+    const TypeAryKlassPtr *tap = t->is_aryklassptr();\n+    int off = meet_offset(tap->offset());\n+    const Type* elem = _elem->meet(tap->_elem);\n@@ -5234,18 +5652,11 @@\n-    \/\/ Classes require inspection in the Java klass hierarchy.  Must be loaded.\n-    ciKlass* tkls_klass = tkls->klass();\n-    ciKlass* this_klass = this->klass();\n-    assert( tkls_klass->is_loaded(), \"This class should have been loaded.\");\n-    assert( this_klass->is_loaded(), \"This class should have been loaded.\");\n-\n-    \/\/ If 'this' type is above the centerline and is a superclass of the\n-    \/\/ other, we can treat 'this' as having the same type as the other.\n-    if ((above_centerline(this->ptr())) &&\n-        tkls_klass->is_subtype_of(this_klass)) {\n-      this_klass = tkls_klass;\n-    }\n-    \/\/ If 'tinst' type is above the centerline and is a superclass of the\n-    \/\/ other, we can treat 'tinst' as having the same type as the other.\n-    if ((above_centerline(tkls->ptr())) &&\n-        this_klass->is_subtype_of(tkls_klass)) {\n-      tkls_klass = this_klass;\n-    }\n+    PTR ptr = meet_ptr(tap->ptr());\n+    ciKlass* res_klass = NULL;\n+    bool res_xk = false;\n+    meet_aryptr(ptr, elem, this->klass(), tap->klass(), this->klass_is_exact(), tap->klass_is_exact(), this->ptr(), tap->ptr(), res_klass, res_xk);\n+    assert(res_xk == (ptr == Constant), \"\");\n+    return make(ptr, elem, res_klass, off);\n+  } \/\/ End of case KlassPtr\n+  case InstKlassPtr: {\n+    const TypeInstKlassPtr *tp = t->is_instklassptr();\n+    int offset = meet_offset(tp->offset());\n+    PTR ptr = meet_ptr(tp->ptr());\n@@ -5253,12 +5664,12 @@\n-    \/\/ Check for classes now being equal\n-    if (tkls_klass->equals(this_klass)) {\n-      \/\/ If the klasses are equal, the constants may still differ.  Fall to\n-      \/\/ NotNull if they do (neither constant is NULL; that is a special case\n-      \/\/ handled elsewhere).\n-      if( ptr == Constant ) {\n-        if (this->_ptr == Constant && tkls->_ptr == Constant &&\n-            this->klass()->equals(tkls->klass()));\n-        else if (above_centerline(this->ptr()));\n-        else if (above_centerline(tkls->ptr()));\n-        else\n-          ptr = NotNull;\n+    switch (ptr) {\n+    case TopPTR:\n+    case AnyNull:                \/\/ Fall 'down' to dual of object klass\n+      \/\/ For instances when a subclass meets a superclass we fall\n+      \/\/ below the centerline when the superclass is exact. We need to\n+      \/\/ do the same here.\n+      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact()) {\n+        return TypeAryKlassPtr::make(ptr, _elem, _klass, offset);\n+      } else {\n+        \/\/ cannot subclass, so the meet has to fall badly below the centerline\n+        ptr = NotNull;\n+        return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), offset);\n@@ -5266,11 +5677,23 @@\n-      return make( ptr, this_klass, off );\n-    } \/\/ Else classes are not equal\n-\n-    \/\/ Since klasses are different, we require the LCA in the Java\n-    \/\/ class hierarchy - which means we have to fall to at least NotNull.\n-    if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )\n-      ptr = NotNull;\n-    \/\/ Now we find the LCA of Java classes\n-    ciKlass* k = this_klass->least_common_ancestor(tkls_klass);\n-    return   make( ptr, k, off );\n-  } \/\/ End of case KlassPtr\n+    case Constant:\n+    case NotNull:\n+    case BotPTR:                \/\/ Fall down to object klass\n+      \/\/ LCA is object_klass, but if we subclass from the top we can do better\n+      if (above_centerline(tp->ptr())) {\n+        \/\/ If 'tp'  is above the centerline and it is Object class\n+        \/\/ then we can subclass in the Java class hierarchy.\n+        \/\/ For instances when a subclass meets a superclass we fall\n+        \/\/ below the centerline when the superclass is exact. We need\n+        \/\/ to do the same here.\n+        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact()) {\n+          \/\/ that is, my array type is a subtype of 'tp' klass\n+          return make(ptr, _elem, _klass, offset);\n+        }\n+      }\n+      \/\/ The other case cannot happen, since t cannot be a subtype of an array.\n+      \/\/ The meet falls down to Object class below centerline.\n+      if (ptr == Constant)\n+         ptr = NotNull;\n+      return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), offset);\n+    default: typerr(t);\n+    }\n+  }\n@@ -5284,2 +5707,2 @@\n-const Type    *TypeKlassPtr::xdual() const {\n-  return new TypeKlassPtr( dual_ptr(), klass(), dual_offset() );\n+const Type    *TypeAryKlassPtr::xdual() const {\n+  return new TypeAryKlassPtr(dual_ptr(), elem()->dual(), klass(), dual_offset());\n@@ -5289,14 +5712,15 @@\n-intptr_t TypeKlassPtr::get_con() const {\n-  assert( _ptr == Null || _ptr == Constant, \"\" );\n-  assert( _offset >= 0, \"\" );\n-\n-  if (_offset != 0) {\n-    \/\/ After being ported to the compiler interface, the compiler no longer\n-    \/\/ directly manipulates the addresses of oops.  Rather, it only has a pointer\n-    \/\/ to a handle at compile time.  This handle is embedded in the generated\n-    \/\/ code and dereferenced at the time the nmethod is made.  Until that time,\n-    \/\/ it is not reasonable to do arithmetic with the addresses of oops (we don't\n-    \/\/ have access to the addresses!).  This does not seem to currently happen,\n-    \/\/ but this assertion here is to help prevent its occurence.\n-    tty->print_cr(\"Found oop constant with non-zero offset\");\n-    ShouldNotReachHere();\n+ciKlass* TypeAryKlassPtr::klass() const {\n+  if (_klass != NULL) {\n+    return _klass;\n+  }\n+  ciKlass* k = NULL;\n+  if (elem()->isa_klassptr()) {\n+    k = elem()->is_klassptr()->klass();\n+    if (k != NULL) {\n+      k = ciObjArrayKlass::make(k);\n+      ((TypeAryKlassPtr*)this)->_klass = k;\n+    }\n+  } else if ((elem()->base() == Type::Top) ||\n+             (elem()->base() == Type::Bottom)) {\n+  } else {\n+    k = ciTypeArrayKlass::make(elem()->basic_type());\n@@ -5304,2 +5728,1 @@\n-\n-  return (intptr_t)klass()->constant_encoding();\n+  return k;\n@@ -5307,0 +5730,1 @@\n+\n@@ -5310,1 +5734,5 @@\n-void TypeKlassPtr::dump2( Dict & d, uint depth, outputStream *st ) const {\n+void TypeAryKlassPtr::dump2( Dict & d, uint depth, outputStream *st ) const {\n+  _elem->dump2(d, depth, st);\n+  st->print(\"[\");\n+  st->print(\"]\");\n+\n@@ -5315,8 +5743,0 @@\n-    {\n-      const char *name = klass()->name()->as_utf8();\n-      if( name ) {\n-        st->print(\"klass %s: \" INTPTR_FORMAT, name, p2i(klass()));\n-      } else {\n-        ShouldNotReachHere();\n-      }\n-    }\n@@ -5324,1 +5744,1 @@\n-    if( !WizardMode && !Verbose && !_klass_is_exact ) break;\n+    if( !WizardMode && !Verbose && _ptr != Constant ) break;\n@@ -5328,1 +5748,1 @@\n-    if( _klass_is_exact ) st->print(\":exact\");\n+    if( _ptr == Constant ) st->print(\":exact\");\n@@ -5344,1 +5764,9 @@\n-\n+const Type* TypeAryKlassPtr::base_element_type(int& dims) const {\n+  const Type* elem = this->elem();\n+  dims = 1;\n+  while (elem->isa_aryklassptr()) {\n+    elem = elem->is_aryklassptr()->elem();\n+    dims++;\n+  }\n+  return elem;\n+}\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":774,"deletions":346,"binary":false,"changes":1120,"status":"modified"},{"patch":"@@ -70,0 +70,2 @@\n+class       TypeInstKlassPtr;\n+class       TypeAryKlassPtr;\n@@ -111,0 +113,2 @@\n+    InstKlassPtr,\n+    AryKlassPtr,\n@@ -324,0 +328,4 @@\n+  const TypeInstKlassPtr  *isa_instklassptr() const;  \/\/ Returns NULL if not IntKlassPtr\n+  const TypeInstKlassPtr  *is_instklassptr() const;   \/\/ assert if not IntKlassPtr\n+  const TypeAryKlassPtr   *isa_aryklassptr() const;   \/\/ Returns NULL if not AryKlassPtr\n+  const TypeAryKlassPtr   *is_aryklassptr() const;    \/\/ assert if not AryKlassPtr\n@@ -919,0 +927,13 @@\n+  enum MeetResult {\n+    QUICK,\n+    UNLOADED,\n+    SUBTYPE,\n+    NOT_SUBTYPE,\n+    LCA\n+  };\n+  static MeetResult\n+  meet_instptr(PTR &ptr, ciKlass* this_klass, ciKlass* tinst_klass, bool this_xk, bool tinst_xk, PTR this_ptr,\n+               PTR tinst_ptr, ciKlass*&res_klass, bool &res_xk);\n+  static MeetResult\n+  meet_aryptr(PTR& ptr, const Type*& elem, ciKlass* this_klass, ciKlass* tap_klass, bool this_xk, bool tap_xk, PTR this_ptr, PTR tap_ptr, ciKlass*& res_klass, bool& res_xk);\n+\n@@ -1107,1 +1128,1 @@\n-  const TypeKlassPtr* as_klass_type() const;\n+  virtual const TypeKlassPtr* as_klass_type(bool try_for_exact = false) const;\n@@ -1202,0 +1223,2 @@\n+  const TypeKlassPtr* as_klass_type(bool try_for_exact = false) const;\n+\n@@ -1295,0 +1318,1 @@\n+  virtual const TypeKlassPtr* as_klass_type(bool try_for_exact = false) const;\n@@ -1366,2 +1390,0 @@\n-  TypeKlassPtr( PTR ptr, ciKlass* klass, int offset );\n-\n@@ -1369,0 +1391,2 @@\n+  TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, int offset);\n+\n@@ -1370,1 +1394,2 @@\n- public:\n+\n+public:\n@@ -1372,1 +1397,1 @@\n-  virtual int hash() const;             \/\/ Type specific hashing\n+  virtual int hash() const;\n@@ -1374,1 +1399,1 @@\n- private:\n+  virtual bool must_be_exact() const { ShouldNotReachHere(); return false; }\n@@ -1376,1 +1401,1 @@\n-  static const TypeKlassPtr* make_from_klass_common(ciKlass* klass, bool klass_change, bool try_for_exact);\n+protected:\n@@ -1380,3 +1405,0 @@\n-  \/\/ Does the type exclude subclasses of the klass?  (Inexact == polymorphic.)\n-  bool          _klass_is_exact;\n-\n@@ -1384,4 +1406,0 @@\n-  ciSymbol* name()  const { return klass()->name(); }\n-\n-  ciKlass* klass() const { return  _klass; }\n-  bool klass_is_exact()    const { return _klass_is_exact; }\n@@ -1389,0 +1407,2 @@\n+  virtual ciKlass* klass() const { return  _klass; }\n+  bool klass_is_exact()    const { return _ptr == Constant; }\n@@ -1391,5 +1411,29 @@\n-  \/\/ Creates a type given a klass. Correctly handles multi-dimensional arrays\n-  \/\/ Respects UseUniqueSubclasses.\n-  \/\/ If the klass is final, the resulting type will be exact.\n-  static const TypeKlassPtr* make_from_klass(ciKlass* klass) {\n-    return make_from_klass_common(klass, true, false);\n+  static const TypeKlassPtr* make(ciKlass* klass);\n+  static const TypeKlassPtr *make(PTR ptr, ciKlass* klass, int offset);\n+\n+\n+  virtual const TypePtr* cast_to_ptr_type(PTR ptr) const { ShouldNotReachHere(); return NULL; }\n+\n+  virtual const TypeKlassPtr *cast_to_exactness(bool klass_is_exact) const { ShouldNotReachHere(); return NULL; }\n+\n+  \/\/ corresponding pointer to instance, for a given class\n+  virtual const TypeOopPtr* as_instance_type() const { ShouldNotReachHere(); return NULL; }\n+\n+  virtual const TypePtr *add_offset( intptr_t offset ) const { ShouldNotReachHere(); return NULL; }\n+  virtual const Type    *xmeet( const Type *t ) const { ShouldNotReachHere(); return NULL; }\n+  virtual const Type    *xdual() const { ShouldNotReachHere(); return NULL; }\n+\n+  virtual intptr_t get_con() const;\n+\n+  virtual const TypeKlassPtr* with_offset(intptr_t offset) const { ShouldNotReachHere(); return NULL; }\n+\n+#ifndef PRODUCT\n+  virtual void dump2( Dict &d, uint depth, outputStream *st ) const; \/\/ Specialized per-Type dumping\n+#endif\n+};\n+\n+\/\/ Instance klass pointer, mirrors TypeInstPtr\n+class TypeInstKlassPtr : public TypeKlassPtr {\n+\n+  TypeInstKlassPtr(PTR ptr, ciKlass* klass, int offset)\n+    : TypeKlassPtr(InstKlassPtr, ptr, klass, offset) {\n@@ -1397,4 +1441,9 @@\n-  \/\/ Same as before, but will produce an exact type, even if\n-  \/\/ the klass is not final, as long as it has exactly one implementation.\n-  static const TypeKlassPtr* make_from_klass_unique(ciKlass* klass) {\n-    return make_from_klass_common(klass, true, true);\n+\n+  virtual bool must_be_exact() const;\n+\n+public:\n+  \/\/ Instance klass ignoring any interface\n+  ciInstanceKlass* instance_klass() const { return klass()->as_instance_klass();     }\n+\n+  static const TypeInstKlassPtr *make(ciKlass* k) {\n+    return make(TypePtr::Constant, k, 0);\n@@ -1402,4 +1451,27 @@\n-  \/\/ Same as before, but does not respects UseUniqueSubclasses.\n-  \/\/ Use this only for creating array element types.\n-  static const TypeKlassPtr* make_from_klass_raw(ciKlass* klass) {\n-    return make_from_klass_common(klass, false, false);\n+  static const TypeInstKlassPtr *make(PTR ptr, ciKlass* k, int offset);\n+\n+  virtual const TypePtr* cast_to_ptr_type(PTR ptr) const;\n+\n+  virtual const TypeKlassPtr *cast_to_exactness(bool klass_is_exact) const;\n+\n+  \/\/ corresponding pointer to instance, for a given class\n+  virtual const TypeOopPtr* as_instance_type() const;\n+  virtual int hash() const;\n+  virtual bool eq(const Type *t) const;\n+\n+  virtual const TypePtr *add_offset( intptr_t offset ) const;\n+  virtual const Type    *xmeet( const Type *t ) const;\n+  virtual const Type    *xdual() const;\n+  virtual const TypeKlassPtr* with_offset(intptr_t offset) const;\n+\n+  \/\/ Convenience common pre-built types.\n+  static const TypeInstKlassPtr* OBJECT; \/\/ Not-null object klass or below\n+  static const TypeInstKlassPtr* OBJECT_OR_NULL; \/\/ Maybe-null version of same\n+};\n+\n+\/\/ Array klass pointer, mirrors TypeAryPtr\n+class TypeAryKlassPtr : public TypeKlassPtr {\n+  const Type *_elem;\n+\n+  TypeAryKlassPtr(PTR ptr, const Type *elem, ciKlass* klass, int offset)\n+    : TypeKlassPtr(AryKlassPtr, ptr, klass, offset), _elem(elem) {\n@@ -1408,2 +1480,4 @@\n-  \/\/ Make a generic (unclassed) pointer to metadata.\n-  static const TypeKlassPtr* make(PTR ptr, int offset);\n+  virtual bool must_be_exact() const;\n+\n+public:\n+  virtual ciKlass* klass() const;\n@@ -1411,6 +1485,2 @@\n-  \/\/ ptr to klass 'k'\n-  static const TypeKlassPtr *make( ciKlass* k ) { return make( TypePtr::Constant, k, 0); }\n-  \/\/ ptr to klass 'k' with offset\n-  static const TypeKlassPtr *make( ciKlass* k, int offset ) { return make( TypePtr::Constant, k, offset); }\n-  \/\/ ptr to klass 'k' or sub-klass\n-  static const TypeKlassPtr *make( PTR ptr, ciKlass* k, int offset);\n+  \/\/ returns base element type, an instance klass (and not interface) for object arrays\n+  const Type* base_element_type(int& dims) const;\n@@ -1418,1 +1488,3 @@\n-  virtual const Type *cast_to_ptr_type(PTR ptr) const;\n+  static const TypeAryKlassPtr *make(PTR ptr, ciKlass* k, int offset);\n+  static const TypeAryKlassPtr *make(PTR ptr, const Type *elem, ciKlass* k, int offset);\n+  static const TypeAryKlassPtr* make(ciKlass* klass);\n@@ -1420,1 +1492,8 @@\n-  virtual const Type *cast_to_exactness(bool klass_is_exact) const;\n+  const Type *elem() const { return _elem; }\n+\n+  virtual bool eq(const Type *t) const;\n+  virtual int hash() const;             \/\/ Type specific hashing\n+\n+  virtual const TypePtr* cast_to_ptr_type(PTR ptr) const;\n+\n+  virtual const TypeKlassPtr *cast_to_exactness(bool klass_is_exact) const;\n@@ -1423,1 +1502,1 @@\n-  const TypeOopPtr* as_instance_type() const;\n+  virtual const TypeOopPtr* as_instance_type() const;\n@@ -1429,1 +1508,5 @@\n-  virtual intptr_t get_con() const;\n+  virtual const TypeKlassPtr* with_offset(intptr_t offset) const;\n+\n+  virtual bool empty(void) const {\n+    return TypeKlassPtr::empty() || _elem->empty();\n+  }\n@@ -1431,3 +1514,0 @@\n-  \/\/ Convenience common pre-built types.\n-  static const TypeKlassPtr* OBJECT; \/\/ Not-null object klass or below\n-  static const TypeKlassPtr* OBJECT_OR_NULL; \/\/ Maybe-null version of same\n@@ -1724,1 +1804,1 @@\n-  assert(_base >= AnyPtr && _base <= KlassPtr, \"Not a pointer\");\n+  assert(_base >= AnyPtr && _base <= AryKlassPtr, \"Not a pointer\");\n@@ -1730,1 +1810,1 @@\n-  return (_base >= AnyPtr && _base <= KlassPtr) ? (TypePtr*)this : NULL;\n+  return (_base >= AnyPtr && _base <= AryKlassPtr) ? (TypePtr*)this : NULL;\n@@ -1802,1 +1882,1 @@\n-  return (_base == KlassPtr) ? (TypeKlassPtr*)this : NULL;\n+  return (_base >= KlassPtr && _base <= AryKlassPtr ) ? (TypeKlassPtr*)this : NULL;\n@@ -1806,1 +1886,1 @@\n-  assert( _base == KlassPtr, \"Not a klass pointer\" );\n+  assert( _base >= KlassPtr && _base <= AryKlassPtr, \"Not a klass pointer\" );\n@@ -1810,0 +1890,18 @@\n+inline const TypeInstKlassPtr *Type::isa_instklassptr() const {\n+  return (_base == InstKlassPtr) ? (TypeInstKlassPtr*)this : NULL;\n+}\n+\n+inline const TypeInstKlassPtr *Type::is_instklassptr() const {\n+  assert( _base == InstKlassPtr, \"Not a klass pointer\" );\n+  return (TypeInstKlassPtr*)this;\n+}\n+\n+inline const TypeAryKlassPtr *Type::isa_aryklassptr() const {\n+  return (_base == AryKlassPtr) ? (TypeAryKlassPtr*)this : NULL;\n+}\n+\n+inline const TypeAryKlassPtr *Type::is_aryklassptr() const {\n+  assert( _base == AryKlassPtr, \"Not a klass pointer\" );\n+  return (TypeAryKlassPtr*)this;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":144,"deletions":46,"binary":false,"changes":190,"status":"modified"},{"patch":"@@ -450,1 +450,1 @@\n-  \/\/ that element is not already in the list.  Assumes the list is\n+  \/\/ that element if not already in the list.  Assumes the list is\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}