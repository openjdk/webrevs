{"files":[{"patch":"@@ -780,1 +780,0 @@\n-          __ move(LIR_OprFact::floatConst(-0.0), tmp);\n@@ -786,1 +785,0 @@\n-          __ move(LIR_OprFact::floatConst(-0.0), tmp);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -699,2 +699,0 @@\n-      \/\/ f2hf treats tmp as live_in. Workaround: initialize to some value.\n-      __ move(LIR_OprFact::floatConst(-0.0), tmp); \/\/ just to satisfy LinearScan\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRGenerator_ppc.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -352,1 +352,0 @@\n-      __ move(LIR_OprFact::doubleConst(-0.0), tmp);\n@@ -356,1 +355,0 @@\n-      __ move(LIR_OprFact::floatConst(-0.0), tmp);\n@@ -837,1 +835,0 @@\n-    __ move(LIR_OprFact::doubleConst(-0.0), tmp);\n@@ -842,1 +839,0 @@\n-    __ move(LIR_OprFact::floatConst(-0.0), tmp);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -638,0 +638,18 @@\n+    case lir_abs:\n+    case lir_sqrt:\n+    case lir_neg: {\n+      assert(in->is_fpu_register(), \"must be\");\n+      assert(res->is_fpu_register(), \"must be\");\n+      assert(in->is_last_use(), \"old value gets destroyed\");\n+\n+      insert_free_if_dead(res, in);\n+      insert_exchange(in);\n+      do_rename(in, res);\n+\n+      new_in = to_fpu_stack_top(res);\n+      new_res = new_in;\n+\n+      op1->set_fpu_stack_size(sim()->stack_size());\n+      break;\n+    }\n+\n@@ -759,20 +777,0 @@\n-    case lir_abs:\n-    case lir_sqrt:\n-    case lir_neg: {\n-      \/\/ Right argument appears to be unused\n-      assert(right->is_illegal(), \"must be\");\n-      assert(left->is_fpu_register(), \"must be\");\n-      assert(res->is_fpu_register(), \"must be\");\n-      assert(left->is_last_use(), \"old value gets destroyed\");\n-\n-      insert_free_if_dead(res, left);\n-      insert_exchange(left);\n-      do_rename(left, res);\n-\n-      new_left = to_fpu_stack_top(res);\n-      new_res = new_left;\n-\n-      op2->set_fpu_stack_size(sim()->stack_size());\n-      break;\n-    }\n-\n","filename":"src\/hotspot\/cpu\/x86\/c1_LinearScan_x86.cpp","additions":18,"deletions":20,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -69,29 +69,1 @@\n-  switch (op->code()) {\n-    case lir_tan: {\n-      \/\/ The slow path for these functions may need to save and\n-      \/\/ restore all live registers but we don't want to save and\n-      \/\/ restore everything all the time, so mark the xmms as being\n-      \/\/ killed.  If the slow path were explicit or we could propagate\n-      \/\/ live register masks down to the assembly we could do better\n-      \/\/ but we don't have any easy way to do that right now.  We\n-      \/\/ could also consider not killing all xmm registers if we\n-      \/\/ assume that slow paths are uncommon but it's not clear that\n-      \/\/ would be a good idea.\n-      if (UseSSE > 0) {\n-#ifdef ASSERT\n-        if (TraceLinearScanLevel >= 2) {\n-          tty->print_cr(\"killing XMMs for trig\");\n-        }\n-#endif\n-        int num_caller_save_xmm_regs = FrameMap::get_num_caller_save_xmms();\n-        int op_id = op->id();\n-        for (int xmm = 0; xmm < num_caller_save_xmm_regs; xmm++) {\n-          LIR_Opr opr = FrameMap::caller_save_xmm_reg_at(xmm);\n-          add_temp(reg_num(opr), op_id, noUse, T_ILLEGAL);\n-        }\n-      }\n-      break;\n-    }\n-    default:\n-      break;\n-  }\n+  \/\/ No special case behaviours yet\n","filename":"src\/hotspot\/cpu\/x86\/c1_LinearScan_x86.hpp","additions":1,"deletions":29,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -455,0 +455,5 @@\n+    case lir_sqrt:           \/\/ FP Ops have no info, but input and result\n+    case lir_abs:\n+    case lir_neg:\n+    case lir_f2hf:\n+    case lir_hf2f:\n@@ -461,0 +466,1 @@\n+      if (op1->_tmp->is_valid())       do_temp(op1->_tmp);\n@@ -486,0 +492,1 @@\n+      assert(op1->_tmp->is_illegal(), \"not used\");\n@@ -569,5 +576,0 @@\n-    case lir_sqrt:\n-    case lir_abs:\n-    case lir_neg:\n-    case lir_f2hf:\n-    case lir_hf2f:\n@@ -670,0 +672,1 @@\n+      assert(op1->_tmp->is_illegal(), \"not used\");\n@@ -1733,0 +1736,5 @@\n+     case lir_abs:                   s = \"abs\";           break;\n+     case lir_neg:                   s = \"neg\";           break;\n+     case lir_sqrt:                  s = \"sqrt\";          break;\n+     case lir_f2hf:                  s = \"f2hf\";          break;\n+     case lir_hf2f:                  s = \"hf2f\";          break;\n@@ -1749,5 +1757,0 @@\n-     case lir_abs:                   s = \"abs\";           break;\n-     case lir_neg:                   s = \"neg\";           break;\n-     case lir_sqrt:                  s = \"sqrt\";          break;\n-     case lir_f2hf:                  s = \"f2hf\";          break;\n-     case lir_hf2f:                  s = \"hf2f\";          break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -942,0 +942,5 @@\n+      , lir_sqrt\n+      , lir_abs\n+      , lir_neg\n+      , lir_f2hf\n+      , lir_hf2f\n@@ -958,7 +963,0 @@\n-      , lir_sqrt\n-      , lir_abs\n-      , lir_neg\n-      , lir_tan\n-      , lir_f2hf\n-      , lir_hf2f\n-      , lir_log10\n@@ -1360,0 +1358,1 @@\n+  LIR_Opr         _tmp;\n@@ -1374,0 +1373,8 @@\n+    , _tmp(LIR_OprFact::illegalOpr)\n+    , _type(type)\n+    , _patch(patch)                    { assert(is_in_range(code, begin_op1, end_op1), \"code check\"); }\n+\n+  LIR_Op1(LIR_Code code, LIR_Opr opr, LIR_Opr result, LIR_Opr tmp, BasicType type = T_ILLEGAL, LIR_PatchCode patch = lir_patch_none, CodeEmitInfo* info = nullptr)\n+    : LIR_Op(code, result, info)\n+    , _opr(opr)\n+    , _tmp(tmp)\n@@ -1380,0 +1387,1 @@\n+    , _tmp(LIR_OprFact::illegalOpr)\n@@ -1389,0 +1397,1 @@\n+    , _tmp(LIR_OprFact::illegalOpr)\n@@ -1393,0 +1402,1 @@\n+  LIR_Opr tmp_opr()          const               { return _tmp;   }\n@@ -2275,3 +2285,3 @@\n-  void abs (LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op2(lir_abs , from, tmp, to)); }\n-  void negate(LIR_Opr from, LIR_Opr to, LIR_Opr tmp = LIR_OprFact::illegalOpr)              { append(new LIR_Op2(lir_neg, from, tmp, to)); }\n-  void sqrt(LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op2(lir_sqrt, from, tmp, to)); }\n+  void abs (LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op1(lir_abs , from, to, tmp)); }\n+  void negate(LIR_Opr from, LIR_Opr to, LIR_Opr tmp = LIR_OprFact::illegalOpr) { append(new LIR_Op1(lir_neg, from, to, tmp)); }\n+  void sqrt(LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op1(lir_sqrt, from, to, tmp)); }\n@@ -2280,4 +2290,2 @@\n-  void log10 (LIR_Opr from, LIR_Opr to, LIR_Opr tmp)              { append(new LIR_Op2(lir_log10, from, LIR_OprFact::illegalOpr, to, tmp)); }\n-  void tan (LIR_Opr from, LIR_Opr to, LIR_Opr tmp1, LIR_Opr tmp2) { append(new LIR_Op2(lir_tan , from, tmp1, to, tmp2)); }\n-  void f2hf(LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op2(lir_f2hf, from, tmp, to)); }\n-  void hf2f(LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op2(lir_hf2f, from, tmp, to)); }\n+  void f2hf(LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op1(lir_f2hf, from, to, tmp)); }\n+  void hf2f(LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op1(lir_hf2f, from, to, tmp)); }\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":22,"deletions":14,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -530,0 +530,11 @@\n+    case lir_abs:\n+    case lir_sqrt:\n+    case lir_f2hf:\n+    case lir_hf2f:\n+      intrinsic_op(op->code(), op->in_opr(), op->tmp_opr(), op->result_opr(), op);\n+      break;\n+\n+    case lir_neg:\n+      negate(op->in_opr(), op->result_opr(), op->tmp_opr());\n+      break;\n+\n@@ -727,13 +738,0 @@\n-    case lir_abs:\n-    case lir_sqrt:\n-    case lir_tan:\n-    case lir_log10:\n-    case lir_f2hf:\n-    case lir_hf2f:\n-      intrinsic_op(op->code(), op->in_opr1(), op->in_opr2(), op->result_opr(), op);\n-      break;\n-\n-    case lir_neg:\n-      negate(op->in_opr1(), op->result_opr(), op->in_opr2());\n-      break;\n-\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -211,1 +211,1 @@\n-  void intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr unused, LIR_Opr dest, LIR_Op* op);\n+  void intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr temp, LIR_Opr dest, LIR_Op* op);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6742,1 +6742,0 @@\n-        case lir_log10:\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}