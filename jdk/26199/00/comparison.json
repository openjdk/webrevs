{"files":[{"patch":"@@ -352,4 +352,1 @@\n-  \/\/ Note that soft_max_capacity() \/ 100 * min_free_threshold is smaller than max_capacity() \/ 100 * min_free_threshold.\n-  \/\/ We want to behave conservatively here, so use max_capacity().  By returning a larger value, we cause the GC to\n-  \/\/ trigger when the remaining amount of free shrinks below the larger threshold.\n-  return _space_info->max_capacity() \/ 100 * ShenandoahMinFreeThreshold;\n+  return ShenandoahHeap::heap()->soft_max_capacity() \/ 100 * ShenandoahMinFreeThreshold;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-  size_t capacity = heap->young_generation()->max_capacity();\n+  size_t capacity = heap->soft_max_capacity();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahGlobalHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-  size_t capacity = heap->young_generation()->max_capacity();\n+  size_t capacity = heap->soft_max_capacity();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahYoungHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-  size_t free_expected = (generation->max_capacity() \/ 100) * ShenandoahCriticalFreeThreshold;\n+  size_t free_expected = (ShenandoahHeap::heap()->soft_max_capacity() \/ 100) * ShenandoahCriticalFreeThreshold;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMetrics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}