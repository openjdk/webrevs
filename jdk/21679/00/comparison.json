{"files":[{"patch":"@@ -765,1 +765,1 @@\n-  const uint idx_before_clone = Compile::current()->unique();\n+  const uint first_node_index_in_cloned_loop_body = Compile::current()->unique();\n@@ -818,13 +818,2 @@\n-    CountedLoopNode *cl_head = head->as_CountedLoop();\n-    Node* init = cl_head->init_trip();\n-    Node* stride = cl_head->stride();\n-    IdealLoopTree* outer_loop = get_loop(outer_loop_head);\n-    const Predicates predicates(new_head->in(LoopNode::EntryControl));\n-    initialize_assertion_predicates_for_peeled_loop(predicates.loop_predicate_block(),\n-                                                    outer_loop_head, dd_outer_loop_head,\n-                                                    init, stride, outer_loop,\n-                                                    idx_before_clone, old_new);\n-    initialize_assertion_predicates_for_peeled_loop(predicates.profiled_loop_predicate_block(),\n-                                                    outer_loop_head, dd_outer_loop_head,\n-                                                    init, stride, outer_loop,\n-                                                    idx_before_clone, old_new);\n+      initialize_assertion_predicates_for_peeled_loop(new_head->as_CountedLoop(), head->as_CountedLoop(),\n+                                                      first_node_index_in_cloned_loop_body, old_new);\n@@ -1437,1 +1426,0 @@\n-#endif \/\/ ASSERT\n@@ -1463,0 +1451,1 @@\n+#endif \/\/ ASSERT\n@@ -1981,47 +1970,6 @@\n-void PhaseIdealLoop::initialize_assertion_predicates_for_peeled_loop(const PredicateBlock* predicate_block,\n-                                                                     LoopNode* outer_loop_head,\n-                                                                     const int dd_outer_loop_head, Node* init,\n-                                                                     Node* stride, IdealLoopTree* outer_loop,\n-                                                                     const uint idx_before_clone,\n-                                                                     const Node_List &old_new) {\n-  if (!predicate_block->has_parse_predicate()) {\n-    return;\n-  }\n-  Node* input_proj = outer_loop_head->in(LoopNode::EntryControl);\n-  const Node* parse_predicate_uncommon_trap = predicate_block->parse_predicate()->uncommon_trap();\n-  Node* next_regular_predicate_proj = predicate_block->skip_parse_predicate();\n-  while (next_regular_predicate_proj->is_IfProj()) {\n-    IfNode* iff = next_regular_predicate_proj->in(0)->as_If();\n-    ProjNode* uncommon_proj = iff->proj_out(1 - next_regular_predicate_proj->as_Proj()->_con);\n-    if (uncommon_proj->unique_ctrl_out() != parse_predicate_uncommon_trap) {\n-      \/\/ Does not belong to this Predicate Block anymore.\n-      break;\n-    }\n-    Node* bol = iff->in(1);\n-    assert(!bol->is_OpaqueInitializedAssertionPredicate(), \"should not find an Initialized Assertion Predicate\");\n-    if (bol->is_OpaqueTemplateAssertionPredicate()) {\n-      \/\/ Initialize from Template Assertion Predicate.\n-      input_proj = create_initialized_assertion_predicate(iff, init, stride, input_proj);\n-\n-      \/\/ Rewire any control inputs from the old Assertion Predicates above the peeled iteration down to the initialized\n-      \/\/ Assertion Predicates above the peeled loop.\n-      for (DUIterator i = next_regular_predicate_proj->outs(); next_regular_predicate_proj->has_out(i); i++) {\n-        Node* dependent = next_regular_predicate_proj->out(i);\n-        Node* new_node = old_new[dependent->_idx];\n-\n-        if (!dependent->is_CFG() &&\n-            dependent->_idx < idx_before_clone &&  \/\/ old node\n-            new_node != nullptr &&                 \/\/ cloned\n-            new_node->_idx >= idx_before_clone) {  \/\/ for peeling\n-          \/\/ The old nodes from the peeled loop still point to the predicate above the peeled loop.\n-          \/\/ We need to rewire the dependencies to the newly Initialized Assertion Predicates.\n-          _igvn.replace_input_of(dependent, 0, input_proj);\n-          --i; \/\/ correct for just deleted predicate->out(i)\n-        }\n-      }\n-    }\n-    next_regular_predicate_proj = iff->in(0);\n-  }\n-\n-  _igvn.replace_input_of(outer_loop_head, LoopNode::EntryControl, input_proj);\n-  set_idom(outer_loop_head, input_proj, dd_outer_loop_head);\n+void PhaseIdealLoop::initialize_assertion_predicates_for_peeled_loop(CountedLoopNode* peeled_loop_head,\n+                                                                     CountedLoopNode* remaining_loop_head,\n+                                                                     const uint first_node_index_in_cloned_loop_body,\n+                                                                     const Node_List& old_new) {\n+  const NodeInOriginalLoopBody node_in_original_loop_body(first_node_index_in_cloned_loop_body, old_new);\n+  create_assertion_predicates_at_loop(peeled_loop_head, remaining_loop_head, node_in_original_loop_body);\n@@ -2030,0 +1978,18 @@\n+void PhaseIdealLoop::create_assertion_predicates_at_loop(CountedLoopNode* source_loop_head,\n+                                                         CountedLoopNode* target_loop_head,\n+                                                         const NodeInLoopBody& _node_in_loop_body) {\n+  Node* init = target_loop_head->init_trip();\n+  Node* stride = target_loop_head->stride();\n+  LoopNode* target_outer_loop_head = target_loop_head->skip_strip_mined();\n+  Node* target_loop_entry = target_outer_loop_head->in(LoopNode::EntryControl);\n+  AssertionPredicatesForLoop assertion_predicates_for_loop(init, stride, target_loop_entry, this,\n+                                                           _node_in_loop_body);\n+  Node* source_loop_entry = source_loop_head->skip_strip_mined()->in(LoopNode::EntryControl);\n+  PredicateIterator predicate_iterator(source_loop_entry);\n+  predicate_iterator.for_each(assertion_predicates_for_loop);\n+  if (assertion_predicates_for_loop.has_created_predicates()) {\n+    IfTrueNode* last_created_node = assertion_predicates_for_loop.last_created_success_proj();\n+    _igvn.replace_input_of(target_outer_loop_head, LoopNode::EntryControl, last_created_node);\n+    set_idom(target_outer_loop_head, last_created_node, dom_depth(target_outer_loop_head));\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":28,"deletions":62,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -955,0 +955,1 @@\n+ public:\n@@ -957,1 +958,2 @@\n-  static void count_opaque_loop_nodes(Node* n, uint& init, uint& stride);\n+ private:\n+  DEBUG_ONLY(static void count_opaque_loop_nodes(Node* n, uint& init, uint& stride);)\n@@ -963,3 +965,3 @@\n-  void initialize_assertion_predicates_for_peeled_loop(const PredicateBlock* predicate_block, LoopNode* outer_loop_head,\n-                                                       int dd_outer_loop_head, Node* init, Node* stride,\n-                                                       IdealLoopTree* outer_loop, uint idx_before_clone,\n+  void initialize_assertion_predicates_for_peeled_loop(CountedLoopNode* peeled_loop_head,\n+                                                       CountedLoopNode* remaining_loop_head,\n+                                                       uint first_node_index_in_cloned_loop_body,\n@@ -967,0 +969,2 @@\n+  void create_assertion_predicates_at_loop(CountedLoopNode* source_loop_head, CountedLoopNode* target_loop_head,\n+                                           const NodeInLoopBody& _node_in_loop_body);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -141,0 +141,15 @@\n+\/\/ Rewire any non-CFG nodes dependent on this Template Assertion Predicate (i.e. with a control input to this\n+\/\/ Template Assertion Predicate) to the 'target_predicate' based on the `data_in_loop_body` check.\n+void TemplateAssertionPredicate::rewire_loop_data_dependencies(IfTrueNode* target_predicate,\n+                                                               const NodeInLoopBody& data_in_loop_body,\n+                                                               PhaseIdealLoop* phase) const {\n+  for (DUIterator i = _success_proj->outs(); _success_proj->has_out(i); i++) {\n+    Node* output = _success_proj->out(i);\n+    if (!output->is_CFG() && data_in_loop_body.check(output)) {\n+      phase->igvn().replace_input_of(output, 0, target_predicate);\n+      --i; \/\/ account for the just deleted output\n+    }\n+  }\n+}\n+\n+\n@@ -715,0 +730,21 @@\n+\n+\/\/ Keep track of the current Predicate Block by setting '_current_parse_predicate'.\n+void AssertionPredicatesForLoop::visit(const ParsePredicate& parse_predicate) {\n+  Deoptimization::DeoptReason deopt_reason = parse_predicate.head()->deopt_reason();\n+  if (deopt_reason == Deoptimization::Reason_predicate ||\n+      deopt_reason == Deoptimization::Reason_profile_predicate) {\n+    _current_parse_predicate = parse_predicate.tail();\n+  }\n+}\n+\n+void AssertionPredicatesForLoop::visit(const TemplateAssertionPredicate& template_assertion_predicate) {\n+  if (_current_parse_predicate == nullptr) {\n+    \/\/ Only process if we are in the correct Predicate Block.\n+    return;\n+  }\n+  IfNode* template_head = template_assertion_predicate.head();\n+  IfTrueNode* initialized_predicate = _phase->create_initialized_assertion_predicate(template_head, _init, _stride,\n+                                                                                     _new_control);\n+  template_assertion_predicate.rewire_loop_data_dependencies(initialized_predicate, _node_in_loop_body, _phase);\n+  _new_control = initialized_predicate;\n+}\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -251,0 +251,6 @@\n+\/\/ Interface to check whether a node is in a loop body or not.\n+class NodeInLoopBody : public StackObj {\n+ public:\n+  virtual bool check(Node* node) const = 0;\n+};\n+\n@@ -396,0 +402,2 @@\n+  void rewire_loop_data_dependencies(IfTrueNode* target_predicate, const NodeInLoopBody& data_in_loop_body,\n+                                     PhaseIdealLoop* phase) const;\n@@ -913,0 +921,66 @@\n+\/\/ This class checks whether a node is in the original loop body and not the cloned one.\n+class NodeInOriginalLoopBody : public NodeInLoopBody {\n+  const uint _first_node_index_in_cloned_loop_body;\n+  const Node_List& _old_new;\n+\n+ public:\n+  NodeInOriginalLoopBody(const uint first_node_index_in_cloned_loop_body, const Node_List& old_new)\n+      : _first_node_index_in_cloned_loop_body(first_node_index_in_cloned_loop_body),\n+        _old_new(old_new) {}\n+  NONCOPYABLE(NodeInOriginalLoopBody);\n+\n+  \/\/ Check if 'node' is not a cloned node (i.e. \"< _first_node_index_in_cloned_loop_body\") and if we've created a\n+  \/\/ clone from 'node' (i.e. _old_new entry is non-null). Then we know that 'node' belongs to the original loop body.\n+  bool check(Node* node) const override {\n+    if (node->_idx < _first_node_index_in_cloned_loop_body) {\n+      Node* cloned_node = _old_new[node->_idx];\n+      return cloned_node != nullptr && cloned_node->_idx >= _first_node_index_in_cloned_loop_body;\n+    } else {\n+      return false;\n+    }\n+  }\n+};\n+\n+\/\/ Visitor to create Initialized Assertion Predicates at a target from Template Assertion Predicates from a source loop.\n+\/\/ This visitor can be used in combination with a PredicateIterator.\n+class AssertionPredicatesForLoop : public PredicateVisitor {\n+  Node* const _init;\n+  Node* const _stride;\n+  Node* const _old_target_loop_entry;\n+  Node* _new_control;\n+  PhaseIdealLoop* const _phase;\n+  ParsePredicateSuccessProj* _current_parse_predicate;\n+  const NodeInLoopBody& _node_in_loop_body;\n+\n+ public:\n+  AssertionPredicatesForLoop(Node* init, Node* stride, Node* new_control, PhaseIdealLoop* phase,\n+                             const NodeInLoopBody& node_in_loop_body)\n+      : _init(init),\n+        _stride(stride),\n+        _old_target_loop_entry(new_control),\n+        _new_control(new_control),\n+        _phase(phase),\n+        _current_parse_predicate(nullptr),\n+        _node_in_loop_body(node_in_loop_body) {}\n+  NONCOPYABLE(AssertionPredicatesForLoop);\n+\n+  using PredicateVisitor::visit;\n+\n+  void visit(const ParsePredicate& parse_predicate) override;\n+  void visit(const TemplateAssertionPredicate& template_assertion_predicate) override;\n+\n+  \/\/ Did we create any new Initialized Assertion Predicates?\n+  bool has_created_predicates() const {\n+    return _new_control != _old_target_loop_entry;\n+  }\n+\n+  \/\/ Return the last created node by this visitor or the originally provided 'new_control' to the visitor if there was\n+  \/\/ no new node created (i.e. no Template Assertion Predicates found).\n+  IfTrueNode* last_created_success_proj() const {\n+    assert(has_created_predicates(), \"should only be queried if new nodes have been created\");\n+    assert(_new_control->unique_ctrl_out_or_null() == nullptr, \"no control outputs, yet\");\n+    assert(_new_control->is_IfTrue(), \"Assertion Predicates only have IfTrue on success proj\");\n+    return _new_control->as_IfTrue();\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"}]}