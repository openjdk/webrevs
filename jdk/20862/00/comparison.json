{"files":[{"patch":"@@ -280,0 +280,18 @@\n+#ifdef _WINDOWS\n+static void map_stack_pages(JavaThread* thread, size_t size, address sp) {\n+  address new_sp = sp - size;\n+  address watermark = thread->stack_overflow_state()->shadow_zone_growth_watermark();\n+\n+  if (new_sp < watermark) {\n+    size_t page_size = os::vm_page_size();\n+    address last_touched_page = watermark - StackOverflow::stack_shadow_zone_size();\n+    size_t pages_to_touch = align_up(watermark - new_sp, page_size) \/ page_size;\n+    while (pages_to_touch--) {\n+      last_touched_page -= page_size;\n+      *last_touched_page = 0;\n+    }\n+    thread->stack_overflow_state()->set_shadow_zone_growth_watermark(new_sp);\n+  }\n+}\n+#endif\n+\n@@ -286,0 +304,1 @@\n+    WINDOWS_ONLY(map_stack_pages(thread, size, sp));\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -296,0 +296,10 @@\n+  address shadow_zone_growth_watermark() const {\n+    assert(_shadow_zone_growth_watermark != nullptr, \"Don't call this before the field is initialized.\");\n+    return _shadow_zone_growth_watermark;\n+  }\n+\n+  void set_shadow_zone_growth_watermark(address new_watermark) {\n+    assert(_shadow_zone_growth_watermark != nullptr, \"Don't call this before the field is initialized.\");\n+    _shadow_zone_growth_watermark = new_watermark;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/stackOverflow.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=default\n+ * @bug 8335362\n+ * @summary Test virtual thread usage with big stackChunks\n+ * @requires vm.continuations\n+ * @run junit\/othervm BigStackChunk\n+ *\/\n+\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class BigStackChunk {\n+\n+    void recurse(int cnt, ReentrantLock rlock) {\n+        int i1 = cnt;\n+        int i2 = i1 + 1;\n+        int i3 = i2 + 1;\n+        int i4 = i3 + 1;\n+        int i5 = i4 + 1;\n+        int i6 = i5 + 1;\n+        int i7 = i6 + 1;\n+        long ll = 2*(long)i1;\n+        float ff = ll + 1.2f;\n+        double dd = ff + 1.3D;\n+\n+        if (cnt > 0) {\n+            recurse(cnt - 1, rlock);\n+        } else {\n+            rlock.lock();\n+            rlock.unlock();\n+        }\n+    }\n+\n+    @Test\n+    void bigStackChunkTest() throws Exception {\n+        int VTHREAD_CNT = Runtime.getRuntime().availableProcessors();\n+        ReentrantLock rlock = new ReentrantLock();\n+        Thread[] vthreads = new Thread[VTHREAD_CNT];\n+\n+        rlock.lock();\n+        for (int i = 0; i < VTHREAD_CNT; i++) {\n+            vthreads[i] = Thread.ofVirtual().start(() -> {\n+                \/\/ Set up things so that half of the carriers will commit lots of\n+                \/\/ pages in the stack while running the mounted vthread and half\n+                \/\/ will just commit very few ones.\n+                if (Math.random() < 0.5) {\n+                    recurse(300, rlock);\n+                } else {\n+                    recurse(1, rlock);\n+                }\n+            });\n+        }\n+        await(vthreads[0], Thread.State.WAITING);\n+        \/\/ Now we expect that some vthread that recursed a lot is mounted on\n+        \/\/ a carrier that previously run a vthread that didn't recurse at all.\n+        rlock.unlock();\n+\n+        for (int i = 0; i < VTHREAD_CNT; i++) {\n+            vthreads[i].join();\n+        }\n+    }\n+\n+    private void await(Thread thread, Thread.State expectedState) throws InterruptedException {\n+        Thread.State state = thread.getState();\n+        while (state != expectedState) {\n+            assertTrue(state != Thread.State.TERMINATED, \"Thread has terminated\");\n+            Thread.sleep(10);\n+            state = thread.getState();\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/BigStackChunk.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"}]}