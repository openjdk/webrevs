{"files":[{"patch":"@@ -3614,0 +3614,242 @@\n+\/\/ Ensure that the inline code and the stub are using the same registers\n+\/\/ as we need to call the stub from inline code when there is a collision\n+\/\/ in the hashed lookup in the secondary supers array.\n+#define LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS(r_super_klass, r_array_base, r_array_length,  \\\n+                                                r_array_index, r_sub_klass, result, r_bitmap) \\\n+do {                                                                                          \\\n+  assert(r_super_klass  == x10                             &&                                 \\\n+         r_array_base   == x11                             &&                                 \\\n+         r_array_length == x12                             &&                                 \\\n+         (r_array_index == x13  || r_array_index == noreg) &&                                 \\\n+         (r_sub_klass   == x14  || r_sub_klass   == noreg) &&                                 \\\n+         (result        == x15  || result        == noreg) &&                                 \\\n+         (r_bitmap      == x16  || r_bitmap      == noreg), \"registers must match riscv.ad\"); \\\n+} while(0)\n+\n+\/\/ Return true: we succeeded in generating this code\n+bool MacroAssembler::lookup_secondary_supers_table(Register r_sub_klass,\n+                                                   Register r_super_klass,\n+                                                   Register result,\n+                                                   Register tmp1,\n+                                                   Register tmp2,\n+                                                   Register tmp3,\n+                                                   Register tmp4,\n+                                                   u1 super_klass_slot,\n+                                                   bool stub_is_near) {\n+  assert_different_registers(r_sub_klass, r_super_klass, result, tmp1, tmp2, tmp3, tmp4, t0);\n+\n+  Label L_fallthrough;\n+\n+  BLOCK_COMMENT(\"lookup_secondary_supers_table {\");\n+\n+  const Register\n+    r_array_base   = tmp1, \/\/ x11\n+    r_array_length = tmp2, \/\/ x12\n+    r_array_index  = tmp3, \/\/ x13\n+    r_bitmap       = tmp4; \/\/ x16\n+\n+  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS(r_super_klass, r_array_base, r_array_length,\n+                                          r_array_index, r_sub_klass, result, r_bitmap);\n+\n+  u1 bit = super_klass_slot;\n+\n+  \/\/ Initialize result value to 1 which means mismatch.\n+  mv(result, 1);\n+\n+  ld(r_bitmap, Address(r_sub_klass, Klass::bitmap_offset()));\n+\n+  \/\/ First check the bitmap to see if super_klass might be present. If\n+  \/\/ the bit is zero, we are certain that super_klass is not one of\n+  \/\/ the secondary supers.\n+  test_bit(t0, r_bitmap, bit);\n+  beqz(t0, L_fallthrough);\n+\n+  \/\/ Get the first array index that can contain super_klass into r_array_index.\n+  if (bit != 0) {\n+    slli(r_array_index, r_bitmap, (Klass::SECONDARY_SUPERS_TABLE_MASK - bit));\n+    cpop(r_array_index, r_array_index);\n+  } else {\n+    mv(r_array_index, (u1)1);\n+  }\n+\n+  \/\/ We will consult the secondary-super array.\n+  ld(r_array_base, Address(r_sub_klass, in_bytes(Klass::secondary_supers_offset())));\n+\n+  \/\/ The value i in r_array_index is >= 1, so even though r_array_base\n+  \/\/ points to the length, we don't need to adjust it to point to the data.\n+  assert(Array<Klass*>::base_offset_in_bytes() == wordSize, \"Adjust this code\");\n+  assert(Array<Klass*>::length_offset_in_bytes() == 0, \"Adjust this code\");\n+\n+  shadd(result, r_array_index, r_array_base, result, LogBytesPerWord);\n+  ld(result, Address(result));\n+  xorr(result, result, r_super_klass);\n+  beqz(result, L_fallthrough); \/\/ Found a match\n+\n+  \/\/ Is there another entry to check? Consult the bitmap.\n+  test_bit(t0, r_bitmap, (bit + 1) & Klass::SECONDARY_SUPERS_TABLE_MASK);\n+  beqz(t0, L_fallthrough);\n+\n+  \/\/ Linear probe.\n+  if (bit != 0) {\n+    ror_imm(r_bitmap, r_bitmap, bit);\n+  }\n+\n+  \/\/ The slot we just inspected is at secondary_supers[r_array_index - 1].\n+  \/\/ The next slot to be inspected, by the stub we're about to call,\n+  \/\/ is secondary_supers[r_array_index]. Bits 0 and 1 in the bitmap\n+  \/\/ have been checked.\n+  Address stub = RuntimeAddress(StubRoutines::lookup_secondary_supers_table_slow_path_stub());\n+  if (stub_is_near) {\n+    jump_link(stub, t0);\n+  } else {\n+    address call = trampoline_call(stub);\n+    if (call == nullptr) {\n+      return false; \/\/ trampoline allocation failed\n+    }\n+  }\n+\n+  BLOCK_COMMENT(\"} lookup_secondary_supers_table\");\n+\n+  bind(L_fallthrough);\n+\n+  if (VerifySecondarySupers) {\n+    verify_secondary_supers_table(r_sub_klass, r_super_klass, \/\/ x14, x10\n+                                  result, tmp1, tmp2, tmp3);  \/\/ x15, x11, x12, x13\n+  }\n+  return true;\n+}\n+\n+\/\/ Called by code generated by check_klass_subtype_slow_path\n+\/\/ above. This is called when there is a collision in the hashed\n+\/\/ lookup in the secondary supers array.\n+void MacroAssembler::lookup_secondary_supers_table_slow_path(Register r_super_klass,\n+                                                             Register r_array_base,\n+                                                             Register r_array_index,\n+                                                             Register r_bitmap,\n+                                                             Register result,\n+                                                             Register tmp1) {\n+  assert_different_registers(r_super_klass, r_array_base, r_array_index, r_bitmap, tmp1, result, t0);\n+\n+  const Register\n+    r_array_length = tmp1,\n+    r_sub_klass    = noreg; \/\/ unused\n+\n+  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS(r_super_klass, r_array_base, r_array_length,\n+                                          r_array_index, r_sub_klass, result, r_bitmap);\n+\n+  Label L_matched, L_fallthrough, L_bitmap_full;\n+\n+  \/\/ Initialize result value to 1 which means mismatch.\n+  mv(result, 1);\n+\n+  \/\/ Load the array length.\n+  lwu(r_array_length, Address(r_array_base, Array<Klass*>::length_offset_in_bytes()));\n+  \/\/ And adjust the array base to point to the data.\n+  \/\/ NB! Effectively increments current slot index by 1.\n+  assert(Array<Klass*>::base_offset_in_bytes() == wordSize, \"\");\n+  addi(r_array_base, r_array_base, Array<Klass*>::base_offset_in_bytes());\n+\n+  \/\/ Check if bitmap is SECONDARY_SUPERS_BITMAP_FULL\n+  assert(Klass::SECONDARY_SUPERS_BITMAP_FULL == ~uintx(0), \"Adjust this code\");\n+  addi(t0, r_bitmap, (u1)1);\n+  beqz(t0, L_bitmap_full);\n+\n+  \/\/ NB! Our caller has checked bits 0 and 1 in the bitmap. The\n+  \/\/ current slot (at secondary_supers[r_array_index]) has not yet\n+  \/\/ been inspected, and r_array_index may be out of bounds if we\n+  \/\/ wrapped around the end of the array.\n+\n+  { \/\/ This is conventional linear probing, but instead of terminating\n+    \/\/ when a null entry is found in the table, we maintain a bitmap\n+    \/\/ in which a 0 indicates missing entries.\n+    \/\/ The check above guarantees there are 0s in the bitmap, so the loop\n+    \/\/ eventually terminates.\n+    Label L_loop;\n+    bind(L_loop);\n+\n+    \/\/ Check for wraparound.\n+    Label skip;\n+    bge(r_array_length, r_array_index, skip);\n+    mv(r_array_index, zr);\n+    bind(skip);\n+\n+    shadd(t0, r_array_index, r_array_base, t0, LogBytesPerWord);\n+    ld(t0, Address(t0));\n+    beq(t0, r_super_klass, L_matched);\n+\n+    test_bit(t0, r_bitmap, 2);  \/\/ look-ahead check (Bit 2); result is non-zero\n+    beqz(t0, L_fallthrough);\n+\n+    ror_imm(r_bitmap, r_bitmap, 1);\n+    addi(r_array_index, r_array_index, 1);\n+    j(L_loop);\n+  }\n+\n+  { \/\/ Degenerate case: more than 64 secondary supers.\n+    \/\/ FIXME: We could do something smarter here, maybe a vectorized\n+    \/\/ comparison or a binary search, but is that worth any added\n+    \/\/ complexity?\n+    bind(L_bitmap_full);\n+    repne_scan(r_array_base, r_super_klass, r_array_length, t0);\n+    bne(r_super_klass, t0, L_fallthrough);\n+  }\n+\n+  bind(L_matched);\n+  mv(result, zr);\n+\n+  bind(L_fallthrough);\n+}\n+\n+\/\/ Make sure that the hashed lookup and a linear scan agree.\n+void MacroAssembler::verify_secondary_supers_table(Register r_sub_klass,\n+                                                   Register r_super_klass,\n+                                                   Register result,\n+                                                   Register tmp1,\n+                                                   Register tmp2,\n+                                                   Register tmp3) {\n+  assert_different_registers(r_sub_klass, r_super_klass, tmp1, tmp2, tmp3, result, t0);\n+\n+  const Register\n+    r_array_base   = tmp1,  \/\/ X11\n+    r_array_length = tmp2,  \/\/ X12\n+    r_array_index  = noreg, \/\/ unused\n+    r_bitmap       = noreg; \/\/ unused\n+\n+  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS(r_super_klass, r_array_base, r_array_length,\n+                                          r_array_index, r_sub_klass, result, r_bitmap);\n+\n+  BLOCK_COMMENT(\"verify_secondary_supers_table {\");\n+\n+  \/\/ We will consult the secondary-super array.\n+  ld(r_array_base, Address(r_sub_klass, in_bytes(Klass::secondary_supers_offset())));\n+\n+  \/\/ Load the array length.\n+  lwu(r_array_length, Address(r_array_base, Array<Klass*>::length_offset_in_bytes()));\n+  \/\/ And adjust the array base to point to the data.\n+  addi(r_array_base, r_array_base, Array<Klass*>::base_offset_in_bytes());\n+\n+  repne_scan(r_array_base, r_super_klass, r_array_length, t0);\n+  Label failed;\n+  mv(tmp3, 1);\n+  bne(r_super_klass, t0, failed);\n+  mv(tmp3, zr);\n+  bind(failed);\n+\n+  snez(result, result); \/\/ normalize result to 0\/1 for comparison\n+\n+  Label passed;\n+  beq(tmp3, result, passed);\n+  {\n+    mv(x10, r_super_klass);\n+    mv(x11, r_sub_klass);\n+    mv(x12, tmp3);\n+    mv(x13, result);\n+    mv(x14, (address)(\"mismatch\"));\n+    rt_call(CAST_FROM_FN_PTR(address, Klass::on_secondary_supers_verification_failure));\n+    should_not_reach_here();\n+  }\n+  bind(passed);\n+\n+  BLOCK_COMMENT(\"} verify_secondary_supers_table\");\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":242,"deletions":0,"binary":false,"changes":242,"status":"modified"},{"patch":"@@ -325,0 +325,26 @@\n+  \/\/ As above, but with a constant super_klass.\n+  \/\/ The result is in Register result, not the condition codes.\n+  bool lookup_secondary_supers_table(Register r_sub_klass,\n+                                     Register r_super_klass,\n+                                     Register result,\n+                                     Register tmp1,\n+                                     Register tmp2,\n+                                     Register tmp3,\n+                                     Register tmp4,\n+                                     u1 super_klass_slot,\n+                                     bool stub_is_near = false);\n+\n+  void verify_secondary_supers_table(Register r_sub_klass,\n+                                     Register r_super_klass,\n+                                     Register result,\n+                                     Register tmp1,\n+                                     Register tmp2,\n+                                     Register tmp3);\n+\n+  void lookup_secondary_supers_table_slow_path(Register r_super_klass,\n+                                               Register r_array_base,\n+                                               Register r_array_index,\n+                                               Register r_bitmap,\n+                                               Register result,\n+                                               Register tmp1);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -3313,0 +3313,10 @@\n+operand iRegP_R16()\n+%{\n+  constraint(ALLOC_IN_RC(r16_reg));\n+  match(RegP);\n+  match(iRegPNoSp);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -10113,0 +10123,30 @@\n+instruct partialSubtypeCheckConstSuper(iRegP_R14 sub, iRegP_R10 super_reg, immP super_con, iRegP_R15 result,\n+                                       iRegP_R11 tmpR11, iRegP_R12 tmpR12, iRegP_R13 tmpR13, iRegP_R16 tmpR16)\n+%{\n+  predicate(UseSecondarySupersTable);\n+  match(Set result (PartialSubtypeCheck sub (Binary super_reg super_con)));\n+  effect(TEMP tmpR11, TEMP tmpR12, TEMP tmpR13, TEMP tmpR16);\n+\n+  ins_cost(700);  \/\/ smaller than the next version\n+  format %{ \"partialSubtypeCheck $result, $sub, $super_reg, $super_con\" %}\n+\n+  ins_encode %{\n+    bool success = false;\n+    u1 super_klass_slot = ((Klass*)$super_con$$constant)->hash_slot();\n+    if (InlineSecondarySupersTest) {\n+      success = __ lookup_secondary_supers_table($sub$$Register, $super_reg$$Register, $result$$Register,\n+                                                 $tmpR11$$Register, $tmpR12$$Register, $tmpR13$$Register,\n+                                                 $tmpR16$$Register, super_klass_slot);\n+    } else {\n+      address call = __ trampoline_call(RuntimeAddress(StubRoutines::lookup_secondary_supers_table_stub(super_klass_slot)));\n+      success = (call != nullptr);\n+    }\n+    if (!success) {\n+      ciEnv::current()->record_failure(\"CodeCache is full\");\n+      return;\n+    }\n+  %}\n+\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2810,0 +2810,44 @@\n+  address generate_lookup_secondary_supers_table_stub(u1 super_klass_index) {\n+    StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table\");\n+\n+    address start = __ pc();\n+    const Register\n+      r_super_klass  = x10,\n+      r_array_base   = x11,\n+      r_array_length = x12,\n+      r_array_index  = x13,\n+      r_sub_klass    = x14,\n+      result         = x15,\n+      r_bitmap       = x16;\n+\n+    Label L_success;\n+    __ enter();\n+    __ lookup_secondary_supers_table(r_sub_klass, r_super_klass, result,\n+                                     r_array_base, r_array_length, r_array_index,\n+                                     r_bitmap, super_klass_index, \/*stub_is_near*\/true);\n+    __ leave();\n+    __ ret();\n+\n+    return start;\n+  }\n+\n+  \/\/ Slow path implementation for UseSecondarySupersTable.\n+  address generate_lookup_secondary_supers_table_slow_path_stub() {\n+    StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table_slow_path\");\n+\n+    address start = __ pc();\n+    const Register\n+      r_super_klass  = x10,        \/\/ argument\n+      r_array_base   = x11,        \/\/ argument\n+      temp1          = x12,        \/\/ tmp\n+      r_array_index  = x13,        \/\/ argument\n+      result         = x15,        \/\/ argument\n+      r_bitmap       = x16;        \/\/ argument\n+\n+\n+    __ lookup_secondary_supers_table_slow_path(r_super_klass, r_array_base, r_array_index, r_bitmap, result, temp1);\n+    __ ret();\n+\n+    return start;\n+  }\n+\n@@ -5569,0 +5613,12 @@\n+#ifdef COMPILER2\n+    if (UseSecondarySupersTable) {\n+      StubRoutines::_lookup_secondary_supers_table_slow_path_stub = generate_lookup_secondary_supers_table_slow_path_stub();\n+      if (!InlineSecondarySupersTest) {\n+        for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n+          StubRoutines::_lookup_secondary_supers_table_stubs[slot]\n+            = generate_lookup_secondary_supers_table_stub(slot);\n+        }\n+      }\n+    }\n+#endif \/\/ COMPILER2\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":56,"deletions":0,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -206,0 +206,9 @@\n+  if (!UsePopCountInstruction) {\n+    if (UseSecondarySupersTable) {\n+      if (!FLAG_IS_DEFAULT(UseSecondarySupersTable)) {\n+        warning(\"UseSecondarySupersTable is not supported on this CPU\");\n+      }\n+      FLAG_SET_DEFAULT(UseSecondarySupersTable, false);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -280,0 +280,2 @@\n+  constexpr static bool supports_secondary_supers_table() { return true; }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}