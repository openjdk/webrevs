{"files":[{"patch":"@@ -109,1 +109,1 @@\n-        final var appResult = Result.create(() -> createMacApplicationInternal(options));\n+        final var appResult = Result.of(() -> createMacApplicationInternal(options));\n@@ -149,1 +149,1 @@\n-                final var pkgSignConfigResult = Result.create(signingIdentityBuilder::create);\n+                final var pkgSignConfigResult = Result.of(signingIdentityBuilder::create);\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacFromOptions.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-        final var analyzerResult = Result.create(() -> new OptionsAnalyzer(untypedOptions, bundlingEnv));\n+        final var analyzerResult = Result.of(() -> new OptionsAnalyzer(untypedOptions, bundlingEnv));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionsProcessor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import static jdk.jpackage.internal.util.function.ExceptionBox.toUnchecked;\n-\n@@ -31,0 +29,1 @@\n+import java.util.Objects;\n@@ -35,1 +34,0 @@\n-import java.util.function.UnaryOperator;\n@@ -37,0 +35,2 @@\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n+import jdk.jpackage.internal.util.function.ThrowingSupplier;\n@@ -42,5 +42,1 @@\n-            throw new IllegalArgumentException();\n-        }\n-\n-        if (value.isEmpty() && errors.isEmpty()) {\n-            throw new IllegalArgumentException(\"Error collection must be non-empty\");\n+            throw new IllegalArgumentException(\"'value' and 'errors' cannot both be non-empty or both be empty\");\n@@ -48,1 +44,0 @@\n-\n@@ -53,1 +48,1 @@\n-            throw toUnchecked(ex);\n+            throw ExceptionBox.toUnchecked(ex);\n@@ -67,1 +62,10 @@\n-        return new Result<>(value.map(conv), errors);\n+        if (hasValue()) {\n+            var mapped = value.map(conv);\n+            if (mapped.isEmpty()) {\n+                throw new NullPointerException();\n+            } else {\n+                return new Result<>(mapped, errors);\n+            }\n+        } else {\n+            return mapErrors();\n+        }\n@@ -76,4 +80,1 @@\n-    public Result<T> mapErrors(UnaryOperator<Collection<? extends Exception>> errorsMapper) {\n-        return new Result<>(value, errorsMapper.apply(errors));\n-    }\n-\n+    @SuppressWarnings(\"unchecked\")\n@@ -81,1 +82,4 @@\n-        return new Result<>(Optional.empty(), errors);\n+        if (hasValue()) {\n+            throw new IllegalStateException(\"Can not map errors from a result without errors\");\n+        }\n+        return (Result<U>)this;\n@@ -100,1 +104,11 @@\n-    public static <T> Result<T> create(Supplier<T> supplier) {\n+    public static <T> Result<T> of(Supplier<T> supplier) {\n+        return of(supplier::get, RuntimeException.class);\n+    }\n+\n+    public static <T, E extends Exception> Result<T> of(\n+            ThrowingSupplier<T, ? extends E> supplier, Class<? extends E> supplierExceptionType) {\n+\n+        Objects.requireNonNull(supplier);\n+        Objects.requireNonNull(supplierExceptionType);\n+\n+        T value;\n@@ -102,1 +116,1 @@\n-            return ofValue(supplier.get());\n+            value = supplier.get();\n@@ -104,1 +118,8 @@\n-            return ofError(ex);\n+            if (supplierExceptionType.isInstance(ex)) {\n+                return ofError(ex);\n+            } else if (ex instanceof RuntimeException rex) {\n+                throw rex;\n+            } else {\n+                \/\/ Unreachable because the `supplier` can throw exceptions of type or supertype `E` or runtime exceptions.\n+                throw ExceptionBox.reachedUnreachable();\n+            }\n@@ -106,0 +127,2 @@\n+\n+        return ofValue(value);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/Result.java","additions":42,"deletions":19,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-        return Result.create(WixTool::createToolset).map(WinSystemEnvironment::new);\n+        return Result.of(WixTool::createToolset).map(WinSystemEnvironment::new);\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinSystemEnvironment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,602 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.util;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n+import jdk.jpackage.internal.util.function.ThrowingSupplier;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+public class ResultTest {\n+\n+    @Test\n+    public void test_ctor_with_value() {\n+        var result = new Result<String>(Optional.of(\"foo\"), List.of());\n+\n+        assertTrue(result.hasValue());\n+        assertFalse(result.hasErrors());\n+        assertEquals(Optional.of(\"foo\"), result.value());\n+        assertEquals(List.of(), result.errors());\n+        assertEquals(Optional.empty(), result.firstError());\n+    }\n+\n+    @Test\n+    public void test_ctor_with_errors() {\n+        var ex = new Exception(\"Kaput!\");\n+        var result = new Result<String>(Optional.empty(), List.of(ex));\n+\n+        assertFalse(result.hasValue());\n+        assertTrue(result.hasErrors());\n+        assertEquals(Optional.empty(), result.value());\n+        assertEquals(List.of(ex), result.errors());\n+        assertEquals(Optional.of(ex), result.firstError());\n+    }\n+\n+    @Test\n+    public void test_ctor_invalid_npe() {\n+        assertThrowsExactly(NullPointerException.class, () -> {\n+            new Result<String>(Optional.of(\"foo\"), null);\n+        });\n+\n+        assertThrowsExactly(NullPointerException.class, () -> {\n+            new Result<String>(null, List.of(new Exception()));\n+        });\n+\n+        assertThrowsExactly(NullPointerException.class, () -> {\n+            new Result<String>(null, null);\n+        });\n+    }\n+\n+    @Test\n+    public void test_ctor_invalid_both_empty() {\n+        var ex = assertThrowsExactly(IllegalArgumentException.class, () -> {\n+            new Result<String>(Optional.empty(), List.of());\n+        });\n+        assertEquals(\"'value' and 'errors' cannot both be non-empty or both be empty\", ex.getMessage());\n+    }\n+\n+    @Test\n+    public void test_ctor_invalid_both_non_empty() {\n+        var ex = assertThrowsExactly(IllegalArgumentException.class, () -> {\n+            new Result<String>(Optional.of(\"foo\"), List.of(new Exception()));\n+        });\n+        assertEquals(\"'value' and 'errors' cannot both be non-empty or both be empty\", ex.getMessage());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_ofValue(boolean valid) {\n+        if (valid) {\n+            assertTrue(Result.ofValue(\"foo\").hasValue());\n+        } else {\n+            assertThrowsExactly(NullPointerException.class, () -> {\n+                Result.ofValue(null);\n+            });\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_ofError(boolean valid) {\n+        if (valid) {\n+            var err = new Exception(\"foo\");\n+            var result = Result.ofError(err);\n+            assertEquals(List.of(err), result.errors());\n+        } else {\n+            assertThrowsExactly(NullPointerException.class, () -> {\n+                Result.ofError(null);\n+            });\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_ofErrors(boolean valid) {\n+        if (valid) {\n+            var errors = List.of(new Exception(\"foo\"), new IllegalArgumentException(\"bar\"));\n+            var result = Result.ofErrors(errors);\n+            assertSame(errors, result.errors());\n+        } else {\n+            assertThrowsExactly(NullPointerException.class, () -> {\n+                Result.ofErrors(null);\n+            });\n+\n+            assertThrowsExactly(NullPointerException.class, () -> {\n+                var errors = new ArrayList<Exception>();\n+                errors.add(new Exception());\n+                errors.add(null);\n+                Result.ofErrors(errors);\n+            });\n+        }\n+    }\n+\n+    @Test\n+    public void test_of() {\n+        assertEquals(\"foo\", Result.<String>of(() -> {\n+            return \"foo\";\n+        }).orElseThrow());\n+    }\n+\n+    @Test\n+    public void test_of_null_value() {\n+        assertThrowsExactly(NullPointerException.class, () -> {\n+            Result.<String>of(() -> {\n+                return null;\n+            });\n+        });\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_of_throws(boolean declaredExceptionType) {\n+\n+        Exception cause;\n+        if (declaredExceptionType) {\n+            cause = new IOException(\"foo\");\n+        } else {\n+            cause = new UnsupportedOperationException(\"bar\");\n+        }\n+\n+        ThrowingSupplier<String, IOException> supplier = () -> {\n+            if (declaredExceptionType) {\n+                throw (IOException)cause;\n+            } else {\n+                throw (UnsupportedOperationException)cause;\n+            }\n+        };\n+\n+        if (declaredExceptionType) {\n+            var result = Result.<String, IOException>of(supplier, IOException.class);\n+            assertSame(cause, result.firstError().orElseThrow());\n+            assertEquals(1, result.errors().size());\n+        } else {\n+            var ex = assertThrowsExactly(cause.getClass(), () -> {\n+                Result.<String, IOException>of(supplier, IOException.class);\n+            });\n+            assertSame(cause, ex);\n+        }\n+    }\n+\n+    @Test\n+    public void test_orElseThrow_hasValue() {\n+        assertEquals(\"foo\", Result.ofValue(\"foo\").orElseThrow());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_orElseThrow(boolean uncheckedException) {\n+        Exception ex;\n+        Class<? extends Exception> expectedType;\n+        if (uncheckedException) {\n+            ex = new RuntimeException(\"Kaput!\");\n+            expectedType = ex.getClass();\n+        } else {\n+            ex = new Exception(\"Kaput!\");\n+            expectedType = ExceptionBox.class;\n+        }\n+\n+        var actual = assertThrowsExactly(expectedType, Result.ofError(ex)::orElseThrow);\n+\n+        if (uncheckedException) {\n+            assertSame(ex, actual);\n+        } else {\n+            assertSame(ex, actual.getCause());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test_map_and_flatMap(MapTestSpec spec) {\n+        spec.run();\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_peekValue(boolean hasValue) {\n+        var pickedValue = Slot.<String>createEmpty();\n+\n+        Consumer<String> consumer = v -> {\n+            assertNotNull(v);\n+            assertTrue(pickedValue.find().isEmpty());\n+            pickedValue.set(v);\n+        };\n+\n+        Result<String> result;\n+        if (hasValue) {\n+            result = Result.ofValue(\"foo\");\n+        } else {\n+            result = Result.ofError(new Exception(\"foo\"));\n+        }\n+        result.peekValue(consumer);\n+\n+        if (hasValue) {\n+            assertEquals(\"foo\", pickedValue.get());\n+        } else {\n+            assertTrue(pickedValue.find().isEmpty());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_peekErrors(boolean hasValue) {\n+        var pickedErrors = Slot.<Collection<? extends Exception>>createEmpty();\n+\n+        Consumer<Collection<? extends Exception>> consumer = v -> {\n+            assertNotNull(v);\n+            assertTrue(pickedErrors.find().isEmpty());\n+            pickedErrors.set(v);\n+        };\n+\n+        Result<String> result;\n+        if (hasValue) {\n+            result = Result.ofValue(\"foo\");\n+        } else {\n+            result = Result.ofErrors(List.of(new Exception(\"foo\"), new IOException(\"bar\")));\n+        }\n+        result.peekErrors(consumer);\n+\n+        if (hasValue) {\n+            assertTrue(pickedErrors.find().isEmpty());\n+        } else {\n+            assertSame(result.errors(), pickedErrors.get());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_mapErrors(boolean hasValue) {\n+        Result<String> result;\n+        if (hasValue) {\n+            result = Result.ofValue(\"foo\");\n+        } else {\n+            result = Result.ofErrors(List.of(new Exception(\"foo\"), new IOException(\"bar\")));\n+        }\n+\n+        if (hasValue) {\n+            var ex = assertThrowsExactly(IllegalStateException.class, result::mapErrors);\n+            assertEquals(\"Can not map errors from a result without errors\", ex.getMessage());\n+        } else {\n+            assertSame(result, result.mapErrors());\n+        }\n+    }\n+\n+    @Test\n+    public void test_allHaveValues_empty() {\n+        assertTrue(Result.allHaveValues());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_allHaveValues(boolean expected) {\n+        if (expected) {\n+            assertTrue(Result.allHaveValues(Result.ofValue(\"foo\"), Result.ofValue(37)));\n+        } else {\n+            assertFalse(Result.allHaveValues(Result.ofValue(\"foo\"), Result.ofError(new Exception())));\n+        }\n+    }\n+\n+    enum MapFunctionType {\n+        MAP,\n+        FLAT_MAP,\n+        ;\n+    }\n+\n+    enum MapFunctionOutcome {\n+        RETURN_NON_NULL,\n+        RETURN_NULL,\n+        THROW,\n+        FLAT_MAP_NEW_ERRORS(MapFunctionType.FLAT_MAP),\n+        ;\n+\n+        MapFunctionOutcome(MapFunctionType... supportedTypes) {\n+            this.supportedTypes = Set.of(supportedTypes);\n+        }\n+\n+        MapFunctionOutcome() {\n+            this(MapFunctionType.values());\n+        }\n+\n+        private final Set<MapFunctionType> supportedTypes;\n+    }\n+\n+    record MapTestSpec(boolean hasValue, MapFunctionOutcome outcome, MapFunctionType type) {\n+        MapTestSpec {\n+            Objects.requireNonNull(outcome);\n+            Objects.requireNonNull(type);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            var tokens = new ArrayList<String>();\n+            tokens.add(outcome.name());\n+            if (type == MapFunctionType.FLAT_MAP) {\n+                tokens.add(\"flatMap\");\n+            }\n+            if (!hasValue) {\n+                tokens.add(\"no-value\");\n+            }\n+            return String.join(\", \", tokens);\n+        }\n+\n+        void run() {\n+            var builder = MapTest.<Integer, String>build();\n+            if (hasValue) {\n+                builder.initialValue(100);\n+            }\n+\n+            Function<Integer, String> plainMapper;\n+            switch (outcome) {\n+                case RETURN_NON_NULL -> {\n+                    if (hasValue) {\n+                        builder.expectValue(\"200\");\n+                    }\n+                    plainMapper = v -> {\n+                        return String.valueOf(v * 2);\n+                    };\n+                }\n+                case RETURN_NULL -> {\n+                    builder.expectExceptionOfType(NullPointerException.class);\n+                    plainMapper = _ -> {\n+                        return null;\n+                    };\n+                }\n+                case THROW -> {\n+                    var cause = new UnsupportedOperationException(\"Unsupported\");\n+                    builder.expectException(cause);\n+                    plainMapper = _ -> {\n+                        throw cause;\n+                    };\n+                }\n+                case FLAT_MAP_NEW_ERRORS -> {\n+                    if (hasValue) {\n+                        \/\/ Just a stub to make `builder.create()` pass.\n+                        builder.expectValue(\"\");\n+                    }\n+                    var mappedResult = Result.<String>ofError(new UnsupportedOperationException(\"Whoopsy-daisy\"));\n+                    var test = builder.create().copyWithMappedValue(mappedResult);\n+                    test.flatMap(v -> {\n+                        return mappedResult;\n+                    });\n+                    return;\n+                }\n+                default -> {\n+                    throw ExceptionBox.reachedUnreachable();\n+                }\n+            }\n+\n+            var test = builder.create();\n+\n+            switch (type) {\n+                case MAP -> {\n+                    test.map(plainMapper);\n+                }\n+                case FLAT_MAP -> {\n+                    test.flatMap(v -> {\n+                        return Optional.ofNullable(plainMapper.apply(v)).map(Result::ofValue).orElse(null);\n+                    });\n+                }\n+            }\n+        }\n+    }\n+\n+    private static List<MapTestSpec> test_map_and_flatMap() {\n+        var data = new ArrayList<MapTestSpec>();\n+        for (var type : MapFunctionType.values()) {\n+            for (var outcome : MapFunctionOutcome.values()) {\n+                if (outcome.supportedTypes.contains(type)) {\n+                    for (var hasValue : List.of(true, false)) {\n+                        data.add(new MapTestSpec(hasValue, outcome, type));\n+                    }\n+                }\n+            }\n+        }\n+        return data;\n+    }\n+\n+    private static final class Counter<T, U> implements Function<T, U> {\n+\n+        Counter(Function<T, U> impl) {\n+            this.impl = Objects.requireNonNull(impl);\n+        }\n+\n+        @Override\n+        public U apply(T v) {\n+            counter++;\n+            return impl.apply(v);\n+        }\n+\n+        int count() {\n+            return counter;\n+        }\n+\n+        private int counter;\n+        private final Function<T, U> impl;\n+    }\n+\n+    private record MapTest<T, U>(\n+            Result<T> initialValue,\n+            Optional<Result<U>> mappedValue,\n+            Optional<Exception> expectedException,\n+            Optional<Class<? extends Exception>> expectedExceptionType) {\n+\n+        MapTest {\n+            Objects.requireNonNull(initialValue);\n+            Objects.requireNonNull(mappedValue);\n+            Objects.requireNonNull(expectedException);\n+            Objects.requireNonNull(expectedExceptionType);\n+\n+            if (expectedExceptionType.isPresent() && mappedValue.isPresent()) {\n+                \/\/ Bad configuration: the mapping operation is expected to throw,\n+                \/\/ but it also expects it to return a value.\n+                throw new IllegalArgumentException();\n+            }\n+\n+            if (expectedExceptionType.isEmpty() && mappedValue.isEmpty()) {\n+                \/\/ Bad configuration: the mapping operation is expected to return normally (not to throw),\n+                \/\/ but it also doesn't expect a mapped value.\n+                throw new IllegalArgumentException();\n+            }\n+\n+            if (initialValue.hasErrors() && mappedValue.map(Result::hasValue).orElse(false)) {\n+                \/\/ Bad configuration: the initial value has errors but they expect a mapped value without errors.\n+                throw new IllegalArgumentException();\n+            }\n+\n+            expectedException.map(Object::getClass).ifPresent(expectedExpectedExceptionType -> {\n+                var configuredExpectedExceptionType = expectedExceptionType.orElseThrow();\n+                if (!configuredExpectedExceptionType.equals(expectedExpectedExceptionType)) {\n+                    throw new IllegalArgumentException(String.format(\n+                            \"expectedException=%s; expectedExceptionType=%s\",\n+                            expectedExpectedExceptionType, configuredExpectedExceptionType));\n+                }\n+            });\n+        }\n+\n+        MapTest<T, U> copyWithMappedValue(Result<U> v) {\n+            return new MapTest<>(initialValue, Optional.of(v), expectedException, expectedExceptionType);\n+        }\n+\n+        static <T, U> Builder<T, U> build() {\n+            return new Builder<>();\n+        }\n+\n+        void map(Function<T, U> mapper) {\n+            map(new Counter<>(mapper), initialValue::map);\n+        }\n+\n+        void flatMap(Function<T, Result<U>> mapper) {\n+            map(new Counter<>(mapper), initialValue::flatMap);\n+        }\n+\n+        private <V> void map(Counter<T, V> countingMapper, Function<Counter<T, V>, Result<U>> mapper) {\n+\n+            if (initialValue.hasErrors()) {\n+                Result<U> mapped = mapper.apply(countingMapper);\n+                assertTrue(mapped.hasErrors());\n+                assertEquals(initialValue.errors(), mapped.errors());\n+            } else {\n+                expectedExceptionType.ifPresentOrElse(theExpectedExceptionType -> {\n+                    var ex = assertThrowsExactly(theExpectedExceptionType, () -> {\n+                        initialValue.map(countingMapper);\n+                    });\n+\n+                    expectedException.ifPresent(theExpectedException -> {\n+                        assertSame(theExpectedException, ex);\n+                    });\n+                }, () -> {\n+                    Result<U> mapped = mapper.apply(countingMapper);\n+                    assertEquals(mappedValue.orElseThrow(), mapped);\n+                });\n+            }\n+\n+            if (initialValue.hasValue()) {\n+                assertEquals(1, countingMapper.count());\n+            } else {\n+                assertEquals(0, countingMapper.count());\n+            }\n+        }\n+\n+        static final class Builder<T, U> {\n+\n+            MapTest<T, U> create() {\n+\n+                var theInitialValue = Optional.ofNullable(initialValue).orElseGet(() -> {\n+                    return Result.ofError(new Exception(\"Kaput!\"));\n+                });\n+\n+                return new MapTest<>(\n+                        theInitialValue,\n+                        Optional.ofNullable(expectedValue).map(Result::ofValue).or(() -> {\n+                            if (expectedExceptionType == null) {\n+                                return Optional.of(theInitialValue.mapErrors());\n+                            } else {\n+                                return Optional.empty();\n+                            }\n+                        }),\n+                        Optional.ofNullable(expectedException),\n+                        Optional.ofNullable(expectedExceptionType));\n+            }\n+\n+            Builder<T, U> initialValue(Result<T> v) {\n+                initialValue = v;\n+                return this;\n+            }\n+\n+            Builder<T, U> initialValue(T v) {\n+                return initialValue(Result.ofValue(v));\n+            }\n+\n+            Builder<T, U> expectException(Exception v) {\n+                expectedException = v;\n+                if (expectedException != null) {\n+                    expectedExceptionType = expectedException.getClass();\n+                    expectValue(null);\n+                } else {\n+                    expectedExceptionType = null;\n+                }\n+                return this;\n+            }\n+\n+            Builder<T, U> expectExceptionOfType(Class<? extends Exception> v) {\n+                expectedException = null;\n+                expectedExceptionType = v;\n+                if (v != null) {\n+                    expectValue(null);\n+                }\n+                return this;\n+            }\n+\n+            Builder<T, U> expectValue(U v) {\n+                expectedValue = v;\n+                if (v != null) {\n+                    expectException(null);\n+                }\n+                return this;\n+            }\n+\n+            private Result<T> initialValue;\n+            private U expectedValue;\n+            private Exception expectedException;\n+            private Class<? extends Exception> expectedExceptionType;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/util\/ResultTest.java","additions":602,"deletions":0,"binary":false,"changes":602,"status":"added"},{"patch":"@@ -257,0 +257,4 @@\n+                        \/\/ Ignore externally configured runtime if any.\n+                        \/\/ It may or may not have the \"bin\" directory, it also can be a bundle.\n+                        \/\/ These factors affect the runtime plist file (see JDK-8363980) which may not be the default one.\n+                        .ignoreDefaultRuntime(true)\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/CustomInfoPListTest.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}