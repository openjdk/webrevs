{"files":[{"patch":"@@ -52,1 +52,1 @@\n-import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n+import static jdk.jpackage.internal.util.function.ExceptionBox.toUnchecked;\n@@ -109,1 +109,1 @@\n-        final var appResult = Result.create(() -> createMacApplicationInternal(options));\n+        final var appResult = Result.of(() -> createMacApplicationInternal(options));\n@@ -149,1 +149,1 @@\n-                final var pkgSignConfigResult = Result.create(signingIdentityBuilder::create);\n+                final var pkgSignConfigResult = Result.of(signingIdentityBuilder::create);\n@@ -156,1 +156,1 @@\n-                    rethrowUnchecked(expiredAppCertException);\n+                    throw toUnchecked(expiredAppCertException);\n@@ -160,1 +160,1 @@\n-                rethrowUnchecked(expiredAppCertException);\n+                throw toUnchecked(expiredAppCertException);\n@@ -306,1 +306,1 @@\n-        rethrowUnchecked(ex);\n+        throw toUnchecked(ex);\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacFromOptions.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-    static void withKeychains(ThrowingConsumer<List<Keychain>> keychainConsumer, List<Keychain> keychains) throws Throwable {\n+    static void withKeychains(ThrowingConsumer<List<Keychain>, ? extends Exception> keychainConsumer, List<Keychain> keychains) throws Exception {\n@@ -50,1 +50,1 @@\n-    static void withKeychain(ThrowingConsumer<Keychain> keychainConsumer, Keychain keychain) throws Throwable {\n+    static void withKeychain(ThrowingConsumer<Keychain, ? extends Exception> keychainConsumer, Keychain keychain) throws Exception {\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/TempKeychain.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -201,1 +201,1 @@\n-            throw ExceptionBox.rethrowUnchecked(ex);\n+            throw ExceptionBox.toUnchecked(ex);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AppImageFile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -511,1 +511,1 @@\n-            throw ExceptionBox.rethrowUnchecked(ex);\n+            throw ExceptionBox.toUnchecked(ex);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/PackagingPipeline.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-                throw ExceptionBox.rethrowUnchecked(ex);\n+                throw ExceptionBox.toUnchecked(ex);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/Main.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-        final var analyzerResult = Result.create(() -> new OptionsAnalyzer(untypedOptions, bundlingEnv));\n+        final var analyzerResult = Result.of(() -> new OptionsAnalyzer(untypedOptions, bundlingEnv));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionsProcessor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import jdk.jpackage.internal.util.function.ExceptionBox;\n@@ -173,1 +172,1 @@\n-        private void runActionOnPath(ThrowingConsumer<Path> action, Path path) {\n+        private void runActionOnPath(ThrowingConsumer<Path, IOException> action, Path path) {\n@@ -180,2 +179,0 @@\n-            } catch (Throwable t) {\n-                throw ExceptionBox.rethrowUnchecked(t);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/FileUtils.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n-\n@@ -31,0 +29,1 @@\n+import java.util.Objects;\n@@ -35,1 +34,0 @@\n-import java.util.function.UnaryOperator;\n@@ -37,0 +35,2 @@\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n+import jdk.jpackage.internal.util.function.ThrowingSupplier;\n@@ -42,5 +42,1 @@\n-            throw new IllegalArgumentException();\n-        }\n-\n-        if (value.isEmpty() && errors.isEmpty()) {\n-            throw new IllegalArgumentException(\"Error collection must be non-empty\");\n+            throw new IllegalArgumentException(\"'value' and 'errors' cannot both be non-empty or both be empty\");\n@@ -48,1 +44,0 @@\n-\n@@ -53,1 +48,1 @@\n-            rethrowUnchecked(ex);\n+            throw ExceptionBox.toUnchecked(ex);\n@@ -67,1 +62,10 @@\n-        return new Result<>(value.map(conv), errors);\n+        if (hasValue()) {\n+            var mapped = value.map(conv);\n+            if (mapped.isEmpty()) {\n+                throw new NullPointerException();\n+            } else {\n+                return new Result<>(mapped, errors);\n+            }\n+        } else {\n+            return mapErrors();\n+        }\n@@ -76,4 +80,1 @@\n-    public Result<T> mapErrors(UnaryOperator<Collection<? extends Exception>> errorsMapper) {\n-        return new Result<>(value, errorsMapper.apply(errors));\n-    }\n-\n+    @SuppressWarnings(\"unchecked\")\n@@ -81,1 +82,4 @@\n-        return new Result<>(Optional.empty(), errors);\n+        if (hasValue()) {\n+            throw new IllegalStateException(\"Can not map errors from a result without errors\");\n+        }\n+        return (Result<U>)this;\n@@ -100,1 +104,11 @@\n-    public static <T> Result<T> create(Supplier<T> supplier) {\n+    public static <T> Result<T> of(Supplier<T> supplier) {\n+        return of(supplier::get, RuntimeException.class);\n+    }\n+\n+    public static <T, E extends Exception> Result<T> of(\n+            ThrowingSupplier<T, ? extends E> supplier, Class<? extends E> supplierExceptionType) {\n+\n+        Objects.requireNonNull(supplier);\n+        Objects.requireNonNull(supplierExceptionType);\n+\n+        T value;\n@@ -102,1 +116,1 @@\n-            return ofValue(supplier.get());\n+            value = supplier.get();\n@@ -104,1 +118,8 @@\n-            return ofError(ex);\n+            if (supplierExceptionType.isInstance(ex)) {\n+                return ofError(ex);\n+            } else if (ex instanceof RuntimeException rex) {\n+                throw rex;\n+            } else {\n+                \/\/ Unreachable because the `supplier` can throw exceptions of type or supertype `E` or runtime exceptions.\n+                throw ExceptionBox.reachedUnreachable();\n+            }\n@@ -106,0 +127,2 @@\n+\n+        return ofValue(value);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/Result.java","additions":42,"deletions":19,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n+import static jdk.jpackage.internal.util.function.ExceptionBox.toUnchecked;\n@@ -83,1 +83,1 @@\n-            throw rethrowUnchecked(ex);\n+            throw toUnchecked(ex);\n@@ -104,1 +104,1 @@\n-            throw rethrowUnchecked(ex);\n+            throw toUnchecked(ex);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/XmlUtils.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,7 +33,20 @@\n-    public static RuntimeException rethrowUnchecked(Throwable throwable) {\n-        if (throwable instanceof RuntimeException err) {\n-            throw err;\n-        }\n-\n-        if (throwable instanceof Error err) {\n-            throw err;\n+    public static RuntimeException toUnchecked(Exception ex) {\n+        switch (ex) {\n+            case RuntimeException rex -> {\n+                return rex;\n+            }\n+            case InvocationTargetException itex -> {\n+                var t = itex.getCause();\n+                if (t instanceof Exception cause) {\n+                    return toUnchecked(cause);\n+                } else {\n+                    throw (Error)t;\n+                }\n+            }\n+            case InterruptedException _ -> {\n+                Thread.currentThread().interrupt();\n+                return new ExceptionBox(ex);\n+            }\n+            default -> {\n+                return new ExceptionBox(ex);\n+            }\n@@ -41,0 +54,1 @@\n+    }\n@@ -42,2 +56,18 @@\n-        if (throwable instanceof InvocationTargetException err) {\n-            throw rethrowUnchecked(err.getCause());\n+    public static Exception unbox(Throwable t) {\n+        switch (t) {\n+            case ExceptionBox ex -> {\n+                return unbox(ex.getCause());\n+            }\n+            case InvocationTargetException ex -> {\n+                return unbox(ex.getCause());\n+            }\n+            case Exception ex -> {\n+                return ex;\n+            }\n+            case Error err -> {\n+                throw err;\n+            }\n+            default -> {\n+                \/\/ Unreachable\n+                throw reachedUnreachable();\n+            }\n@@ -45,0 +75,1 @@\n+    }\n@@ -46,1 +77,2 @@\n-        throw new ExceptionBox(throwable);\n+    public static Error reachedUnreachable() {\n+        return new AssertionError(\"Reached unreachable!\");\n@@ -49,2 +81,2 @@\n-    private ExceptionBox(Throwable throwable) {\n-        super(throwable);\n+    private ExceptionBox(Exception ex) {\n+        super(ex);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/function\/ExceptionBox.java","additions":45,"deletions":13,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-public interface ThrowingBiConsumer<T, U> {\n+public interface ThrowingBiConsumer<T, U, E extends Exception> {\n@@ -32,1 +32,1 @@\n-    void accept(T t, U u) throws Throwable;\n+    void accept(T t, U u) throws E;\n@@ -35,1 +35,1 @@\n-            ThrowingBiConsumer<T, U> v) {\n+            ThrowingBiConsumer<T, U, ? extends Exception> v) {\n@@ -39,2 +39,2 @@\n-            } catch (Throwable ex) {\n-                throw ExceptionBox.rethrowUnchecked(ex);\n+            } catch (Exception ex) {\n+                throw ExceptionBox.toUnchecked(ex);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/function\/ThrowingBiConsumer.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-public interface ThrowingBiFunction<T, U, R> {\n+public interface ThrowingBiFunction<T, U, R, E extends Exception> {\n@@ -32,1 +32,1 @@\n-    R apply(T t, U u) throws Throwable;\n+    R apply(T t, U u) throws E;\n@@ -35,1 +35,1 @@\n-            ThrowingBiFunction<T, U, R> v) {\n+            ThrowingBiFunction<T, U, R, ? extends Exception> v) {\n@@ -39,2 +39,2 @@\n-            } catch (Throwable ex) {\n-                throw ExceptionBox.rethrowUnchecked(ex);\n+            } catch (Exception ex) {\n+                throw ExceptionBox.toUnchecked(ex);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/function\/ThrowingBiFunction.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-public interface ThrowingConsumer<T> {\n+public interface ThrowingConsumer<T, E extends Exception> {\n@@ -32,1 +32,1 @@\n-    void accept(T t) throws Throwable;\n+    void accept(T t) throws E;\n@@ -34,1 +34,1 @@\n-    public static <T> Consumer<T> toConsumer(ThrowingConsumer<T> v) {\n+    public static <T> Consumer<T> toConsumer(ThrowingConsumer<T, ? extends Exception> v) {\n@@ -38,2 +38,2 @@\n-            } catch (Throwable ex) {\n-                throw ExceptionBox.rethrowUnchecked(ex);\n+            } catch (Exception ex) {\n+                throw ExceptionBox.toUnchecked(ex);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/function\/ThrowingConsumer.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-public interface ThrowingFunction<T, R> {\n+public interface ThrowingFunction<T, R, E extends Exception> {\n@@ -32,1 +32,1 @@\n-    R apply(T t) throws Throwable;\n+    R apply(T t) throws E;\n@@ -34,1 +34,1 @@\n-    public static <T, R> Function<T, R> toFunction(ThrowingFunction<T, R> v) {\n+    public static <T, R> Function<T, R> toFunction(ThrowingFunction<T, R, ? extends Exception> v) {\n@@ -38,2 +38,2 @@\n-            } catch (Throwable ex) {\n-                throw ExceptionBox.rethrowUnchecked(ex);\n+            } catch (Exception ex) {\n+                throw ExceptionBox.toUnchecked(ex);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/function\/ThrowingFunction.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-public interface ThrowingRunnable {\n+public interface ThrowingRunnable<E extends Exception> {\n@@ -30,1 +30,1 @@\n-    void run() throws Throwable;\n+    void run() throws E;\n@@ -32,1 +32,1 @@\n-    public static Runnable toRunnable(ThrowingRunnable v) {\n+    public static Runnable toRunnable(ThrowingRunnable<? extends Exception> v) {\n@@ -36,2 +36,2 @@\n-            } catch (Throwable ex) {\n-                throw ExceptionBox.rethrowUnchecked(ex);\n+            } catch (Exception ex) {\n+                throw ExceptionBox.toUnchecked(ex);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/function\/ThrowingRunnable.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-public interface ThrowingSupplier<T> {\n+public interface ThrowingSupplier<T, E extends Exception> {\n@@ -32,1 +32,1 @@\n-    T get() throws Throwable;\n+    T get() throws E;\n@@ -34,1 +34,1 @@\n-    public static <T> Supplier<T> toSupplier(ThrowingSupplier<T> v) {\n+    public static <T> Supplier<T> toSupplier(ThrowingSupplier<T, ? extends Exception> v) {\n@@ -38,2 +38,2 @@\n-            } catch (Throwable ex) {\n-                throw ExceptionBox.rethrowUnchecked(ex);\n+            } catch (Exception ex) {\n+                throw ExceptionBox.toUnchecked(ex);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/function\/ThrowingSupplier.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-public interface ThrowingUnaryOperator<T> {\n+public interface ThrowingUnaryOperator<T, E extends Exception> {\n@@ -32,1 +32,1 @@\n-    T apply(T t) throws Throwable;\n+    T apply(T t) throws E;\n@@ -35,1 +35,1 @@\n-            ThrowingUnaryOperator<T> v) {\n+            ThrowingUnaryOperator<T, ? extends Exception> v) {\n@@ -39,2 +39,2 @@\n-            } catch (Throwable ex) {\n-                throw ExceptionBox.rethrowUnchecked(ex);\n+            } catch (Exception ex) {\n+                throw ExceptionBox.toUnchecked(ex);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/function\/ThrowingUnaryOperator.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-        return Result.create(WixTool::createToolset).map(WinSystemEnvironment::new);\n+        return Result.of(WixTool::createToolset).map(WinSystemEnvironment::new);\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinSystemEnvironment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -356,2 +356,2 @@\n-        } catch (Throwable t) {\n-            t.printStackTrace(System.err);\n+        } catch (Exception ex) {\n+            ex.printStackTrace(System.err);\n@@ -361,1 +361,1 @@\n-            throw new RuntimeException(t);\n+            throw new RuntimeException(ex);\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/AnnotationsTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -171,1 +171,1 @@\n-    private static class CountingConsumer extends TickCounter implements ThrowingConsumer<JPackageCommand> {\n+    private static class CountingConsumer extends TickCounter implements ThrowingConsumer<JPackageCommand, RuntimeException> {\n@@ -191,1 +191,1 @@\n-    private static class CountingRunnable extends TickCounter implements ThrowingRunnable {\n+    private static class CountingRunnable extends TickCounter implements ThrowingRunnable<RuntimeException> {\n@@ -211,1 +211,1 @@\n-    private static class CountingBundleVerifier extends TickCounter implements ThrowingBiConsumer<JPackageCommand, Executor.Result> {\n+    private static class CountingBundleVerifier extends TickCounter implements ThrowingBiConsumer<JPackageCommand, Executor.Result, RuntimeException> {\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/PackageTestTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.io.IOException;\n@@ -215,1 +216,1 @@\n-    public void testCreateTempFile(CreateTempTestSpec testSpec) throws Throwable {\n+    public void testCreateTempFile(CreateTempTestSpec testSpec) throws IOException {\n@@ -221,1 +222,1 @@\n-    public void testCreateTempDirectory(CreateTempTestSpec testSpec) throws Throwable {\n+    public void testCreateTempDirectory(CreateTempTestSpec testSpec) throws IOException {\n@@ -235,1 +236,1 @@\n-        void test(ThrowingFunction<String, Path> createTempPath, Consumer<Path> assertTempPathExists) throws Throwable {\n+        void test(ThrowingFunction<String, Path, IOException> createTempPath, Consumer<Path> assertTempPathExists) throws IOException {\n@@ -336,1 +337,1 @@\n-    private static void runAssertWithExpectedLogOutput(ThrowingRunnable action,\n+    private static void runAssertWithExpectedLogOutput(ThrowingRunnable<? extends Exception> action,\n@@ -343,1 +344,1 @@\n-    private static void runWithExpectedLogOutput(ThrowingRunnable action,\n+    private static void runWithExpectedLogOutput(ThrowingRunnable<? extends Exception> action,\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/TKitTest.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-            ThrowingBiConsumer<Path, Collection<Map.Entry<String, String>>> handler) {\n+            ThrowingBiConsumer<Path, Collection<Map.Entry<String, String>>, ? extends Exception> handler) {\n@@ -185,1 +185,1 @@\n-    private ThrowingConsumer<JPackageCommand> createVerifierAsConsumer() {\n+    private ThrowingConsumer<JPackageCommand, ? extends Exception> createVerifierAsConsumer() {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/AdditionalLauncher.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -294,1 +294,1 @@\n-        ThrowingConsumer<Path> createBulkFile = path -> {\n+        ThrowingConsumer<Path, IOException> createBulkFile = path -> {\n@@ -331,1 +331,1 @@\n-    JPackageCommand addPrerequisiteAction(ThrowingConsumer<JPackageCommand> action) {\n+    JPackageCommand addPrerequisiteAction(ThrowingConsumer<JPackageCommand, ? extends Exception> action) {\n@@ -336,1 +336,1 @@\n-    JPackageCommand addVerifyAction(ThrowingConsumer<JPackageCommand> action) {\n+    JPackageCommand addVerifyAction(ThrowingConsumer<JPackageCommand, ? extends Exception> action) {\n@@ -346,1 +346,1 @@\n-    JPackageCommand addVerifyAction(ThrowingConsumer<JPackageCommand> action, ActionRole actionRole) {\n+    JPackageCommand addVerifyAction(ThrowingConsumer<JPackageCommand, ? extends Exception> action, ActionRole actionRole) {\n@@ -351,1 +351,1 @@\n-    Stream<ThrowingConsumer<JPackageCommand>> getVerifyActionsWithRole(ActionRole actionRole) {\n+    Stream<ThrowingConsumer<JPackageCommand, ? extends Exception>> getVerifyActionsWithRole(ActionRole actionRole) {\n@@ -1651,1 +1651,1 @@\n-        void add(ThrowingConsumer<JPackageCommand> action) {\n+        void add(ThrowingConsumer<JPackageCommand, ? extends Exception> action) {\n@@ -1655,1 +1655,1 @@\n-        void add(ThrowingConsumer<JPackageCommand> action, ActionRole role) {\n+        void add(ThrowingConsumer<JPackageCommand, ? extends Exception> action, ActionRole role) {\n@@ -1660,1 +1660,1 @@\n-        Stream<ThrowingConsumer<JPackageCommand>> actionsWithRole(ActionRole role) {\n+        Stream<ThrowingConsumer<JPackageCommand, ? extends Exception>> actionsWithRole(ActionRole role) {\n@@ -1669,1 +1669,1 @@\n-            Action(ThrowingConsumer<JPackageCommand> impl, ActionRole role) {\n+            Action(ThrowingConsumer<JPackageCommand, ? extends Exception> impl, ActionRole role) {\n@@ -1678,1 +1678,1 @@\n-            ThrowingConsumer<JPackageCommand> impl() {\n+            ThrowingConsumer<JPackageCommand, ? extends Exception> impl() {\n@@ -1691,1 +1691,1 @@\n-            private final ThrowingConsumer<JPackageCommand> impl;\n+            private final ThrowingConsumer<JPackageCommand, ? extends Exception> impl;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n+import static jdk.jpackage.internal.util.function.ExceptionBox.toUnchecked;\n@@ -43,1 +43,1 @@\n-            throw rethrowUnchecked(ex);\n+            throw toUnchecked(ex);\n@@ -54,1 +54,1 @@\n-            throw rethrowUnchecked(ex);\n+            throw toUnchecked(ex);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageStringBundle.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-        Action(ThrowingBiConsumer<LauncherVerifier, JPackageCommand> action) {\n+        Action(ThrowingBiConsumer<LauncherVerifier, JPackageCommand, ? extends Exception> action) {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherVerifier.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -648,1 +648,1 @@\n-            ThrowingConsumer<Path> consumer) {\n+            ThrowingConsumer<Path, ? extends Exception> consumer) {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LinuxHelper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-            ThrowingConsumer<Path> consumer) {\n+            ThrowingConsumer<Path, ? extends Exception> consumer) {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacHelper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import java.security.NoSuchAlgorithmException;\n@@ -529,1 +530,1 @@\n-            Map<X509Certificate, Throwable> unmappedCertificates) {\n+            Map<X509Certificate, Exception> unmappedCertificates) {\n@@ -563,1 +564,1 @@\n-            final Map<X509Certificate, Throwable> unmappedCertificates = new HashMap<>();\n+            final Map<X509Certificate, Exception> unmappedCertificates = new HashMap<>();\n@@ -571,7 +572,1 @@\n-                        final Throwable t;\n-                        if (ex instanceof ExceptionBox) {\n-                            t = ex.getCause();\n-                        } else {\n-                            t = ex;\n-                        }\n-                        unmappedCertificates.put(cert, t);\n+                        unmappedCertificates.put(cert, ExceptionBox.unbox(ex));\n@@ -638,1 +633,1 @@\n-        DigestAlgorithm(int hashLength, ThrowingSupplier<MessageDigest> createDigest) {\n+        DigestAlgorithm(int hashLength, ThrowingSupplier<MessageDigest, NoSuchAlgorithmException> createDigest) {\n@@ -644,1 +639,1 @@\n-        final ThrowingSupplier<MessageDigest> createDigest;\n+        final ThrowingSupplier<MessageDigest, NoSuchAlgorithmException> createDigest;\n@@ -1226,1 +1221,1 @@\n-    private static void withTempDirectory(ThrowingConsumer<Path> callback) {\n+    private static void withTempDirectory(ThrowingConsumer<Path, ? extends Exception> callback) {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacSign.java","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -265,2 +265,2 @@\n-            } catch (Throwable t) {\n-                t.printStackTrace();\n+            } catch (Exception ex) {\n+                ex.printStackTrace();\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacSignVerify.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n@@ -44,1 +45,1 @@\n-    public static void main(String... args) throws Throwable {\n+    public static void main(String... args) throws Exception {\n@@ -48,1 +49,1 @@\n-    public static void main(TestBuilder.Builder builder, String... args) throws Throwable {\n+    public static void main(TestBuilder.Builder builder, String... args) throws Exception {\n@@ -89,2 +90,2 @@\n-                } catch (Throwable throwable) {\n-                    TKit.unbox(throwable);\n+                } catch (Exception ex) {\n+                    throw ExceptionBox.unbox(ex);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/Main.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-class MethodCall implements ThrowingConsumer<Object> {\n+class MethodCall implements ThrowingConsumer<Object, Exception> {\n@@ -110,1 +110,1 @@\n-    public void accept(Object thiz) throws Throwable {\n+    public void accept(Object thiz) throws Exception {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MethodCall.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n+import static jdk.jpackage.internal.util.function.ExceptionBox.toUnchecked;\n@@ -286,1 +286,1 @@\n-            throw rethrowUnchecked(ex);\n+            throw toUnchecked(ex);\n@@ -727,1 +727,1 @@\n-                rethrowUnchecked(ex);\n+                throw toUnchecked(ex);\n@@ -743,1 +743,1 @@\n-                rethrowUnchecked(ex);\n+                throw toUnchecked(ex);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/ObjectMapper.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n+import static jdk.jpackage.internal.util.function.ExceptionBox.toUnchecked;\n@@ -146,1 +146,1 @@\n-    private PackageTest addInitializer(ThrowingConsumer<JPackageCommand> v, String id) {\n+    private PackageTest addInitializer(ThrowingConsumer<JPackageCommand, ? extends Exception> v, String id) {\n@@ -159,1 +159,1 @@\n-    private PackageTest addRunOnceInitializer(ThrowingRunnable v, String id) {\n+    private PackageTest addRunOnceInitializer(ThrowingRunnable<? extends Exception> v, String id) {\n@@ -161,1 +161,1 @@\n-        return addInitializer(new ThrowingConsumer<JPackageCommand>() {\n+        return addInitializer(new ThrowingConsumer<JPackageCommand, Exception>() {\n@@ -163,1 +163,1 @@\n-            public void accept(JPackageCommand unused) throws Throwable {\n+            public void accept(JPackageCommand unused) throws Exception {\n@@ -174,1 +174,1 @@\n-    public PackageTest addInitializer(ThrowingConsumer<JPackageCommand> v) {\n+    public PackageTest addInitializer(ThrowingConsumer<JPackageCommand, ? extends Exception> v) {\n@@ -178,1 +178,1 @@\n-    public PackageTest addRunOnceInitializer(ThrowingRunnable v) {\n+    public PackageTest addRunOnceInitializer(ThrowingRunnable<? extends Exception> v) {\n@@ -182,1 +182,1 @@\n-    public PackageTest addBundleVerifier(ThrowingBiConsumer<JPackageCommand, Executor.Result> v) {\n+    public PackageTest addBundleVerifier(ThrowingBiConsumer<JPackageCommand, Executor.Result, ? extends Exception> v) {\n@@ -188,1 +188,1 @@\n-    public PackageTest addBundleVerifier(ThrowingConsumer<JPackageCommand> v) {\n+    public PackageTest addBundleVerifier(ThrowingConsumer<JPackageCommand, ? extends Exception> v) {\n@@ -225,1 +225,1 @@\n-    public PackageTest addInstallVerifier(ThrowingConsumer<JPackageCommand> v) {\n+    public PackageTest addInstallVerifier(ThrowingConsumer<JPackageCommand, ? extends Exception> v) {\n@@ -231,1 +231,1 @@\n-    public PackageTest addUninstallVerifier(ThrowingConsumer<JPackageCommand> v) {\n+    public PackageTest addUninstallVerifier(ThrowingConsumer<JPackageCommand, ? extends Exception> v) {\n@@ -262,1 +262,1 @@\n-            ThrowingBiConsumer<FileAssociations.TestRun, List<Path>> consumer) {\n+            ThrowingBiConsumer<FileAssociations.TestRun, List<Path>, ? extends Exception> consumer) {\n@@ -863,1 +863,1 @@\n-                rethrowUnchecked(ex);\n+                throw toUnchecked(ex);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/PackageTest.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import java.lang.reflect.InvocationTargetException;\n@@ -113,1 +112,1 @@\n-    static void withExtraLogStream(ThrowingRunnable action) {\n+    static void withExtraLogStream(ThrowingRunnable<? extends Exception> action) {\n@@ -123,1 +122,1 @@\n-    static void withExtraLogStream(ThrowingRunnable action, PrintStream logStream) {\n+    static void withExtraLogStream(ThrowingRunnable<? extends Exception> action, PrintStream logStream) {\n@@ -129,1 +128,1 @@\n-    public static void withMainLogStream(ThrowingRunnable action, PrintStream logStream) {\n+    public static void withMainLogStream(ThrowingRunnable<? extends Exception> action, PrintStream logStream) {\n@@ -135,1 +134,1 @@\n-    public static void withStackTraceStream(ThrowingRunnable action, PrintStream logStream) {\n+    public static void withStackTraceStream(ThrowingRunnable<? extends Exception> action, PrintStream logStream) {\n@@ -149,1 +148,1 @@\n-    private static void withNewState(ThrowingRunnable action, Consumer<State.Builder> stateBuilderMutator) {\n+    private static void withNewState(ThrowingRunnable<? extends Exception> action, Consumer<State.Builder> stateBuilderMutator) {\n@@ -201,1 +200,1 @@\n-    static <T> T runAdhocTest(ThrowingSupplier<T> action) {\n+    static <T> T runAdhocTest(ThrowingSupplier<T, ? extends Exception> action) {\n@@ -209,1 +208,1 @@\n-    static void runAdhocTest(ThrowingRunnable action) {\n+    static void runAdhocTest(ThrowingRunnable<? extends Exception> action) {\n@@ -230,1 +229,1 @@\n-    static Runnable ignoreExceptions(ThrowingRunnable action) {\n+    static Runnable ignoreExceptions(ThrowingRunnable<? extends Exception> action) {\n@@ -235,2 +234,2 @@\n-                } catch (Throwable ex) {\n-                    unbox(ex);\n+                } catch (Exception ex) {\n+                    throw ExceptionBox.unbox(ex);\n@@ -238,2 +237,2 @@\n-            } catch (Throwable throwable) {\n-                printStackTrace(throwable);\n+            } catch (Exception|AssertionError t) {\n+                printStackTrace(t);\n@@ -244,8 +243,0 @@\n-    static void unbox(Throwable throwable) throws Throwable {\n-        try {\n-            throw throwable;\n-        } catch (ExceptionBox | InvocationTargetException ex) {\n-            unbox(ex.getCause());\n-        }\n-    }\n-\n@@ -443,1 +434,1 @@\n-    private static Path createTempPath(Path templatePath, ThrowingUnaryOperator<Path> createPath) {\n+    private static Path createTempPath(Path templatePath, ThrowingUnaryOperator<Path, IOException> createPath) {\n@@ -461,2 +452,0 @@\n-        } catch (Throwable t) {\n-            throw ExceptionBox.rethrowUnchecked(t);\n@@ -467,1 +456,1 @@\n-            ThrowingConsumer<Path> action) {\n+            ThrowingConsumer<Path, ? extends Exception> action) {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TKit.java","additions":14,"deletions":25,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-    void processCmdLineArg(String arg) throws Throwable {\n+    void processCmdLineArg(String arg) throws Exception {\n@@ -143,1 +143,1 @@\n-            ThrowingConsumer<String> argProcessor = argProcessors.get(argName);\n+            var argProcessor = argProcessors.get(argName);\n@@ -208,2 +208,2 @@\n-        final List<ThrowingConsumer<Object>> curBeforeActions;\n-        final List<ThrowingConsumer<Object>> curAfterActions;\n+        final List<ThrowingConsumer<Object, ? extends Exception>> curBeforeActions;\n+        final List<ThrowingConsumer<Object, ? extends Exception>> curAfterActions;\n@@ -329,1 +329,1 @@\n-    private ThrowingConsumer<Object> wrap(Method method) {\n+    private ThrowingConsumer<Object, ? extends Exception> wrap(Method method) {\n@@ -378,1 +378,1 @@\n-    private final Map<String, ThrowingConsumer<String>> argProcessors;\n+    private final Map<String, ThrowingConsumer<String, ? extends Exception>> argProcessors;\n@@ -383,2 +383,2 @@\n-    private List<ThrowingConsumer<Object>> beforeActions;\n-    private List<ThrowingConsumer<Object>> afterActions;\n+    private List<ThrowingConsumer<Object, ? extends Exception>> beforeActions;\n+    private List<ThrowingConsumer<Object, ? extends Exception>> afterActions;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TestBuilder.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-final class TestInstance implements ThrowingRunnable {\n+final class TestInstance implements ThrowingRunnable<Exception> {\n@@ -152,1 +152,1 @@\n-    TestInstance(ThrowingRunnable testBody, Path workDirRoot) {\n+    TestInstance(ThrowingRunnable<? extends Exception> testBody, Path workDirRoot) {\n@@ -163,2 +163,2 @@\n-    TestInstance(MethodCall testBody, List<ThrowingConsumer<Object>> beforeActions,\n-            List<ThrowingConsumer<Object>> afterActions, boolean dryRun, Path workDirRoot) {\n+    TestInstance(MethodCall testBody, List<ThrowingConsumer<Object, ? extends Exception>> beforeActions,\n+            List<ThrowingConsumer<Object, ? extends Exception>> afterActions, boolean dryRun, Path workDirRoot) {\n@@ -229,1 +229,1 @@\n-    public void run() throws Throwable {\n+    public void run() throws Exception {\n@@ -336,4 +336,4 @@\n-    private final ThrowingFunction<ThrowingConsumer<Object>, Object> testConstructor;\n-    private final ThrowingConsumer<Object> testBody;\n-    private final List<ThrowingConsumer<Object>> beforeActions;\n-    private final List<ThrowingConsumer<Object>> afterActions;\n+    private final ThrowingFunction<ThrowingConsumer<Object, ? extends Exception>, Object, ? extends Exception> testConstructor;\n+    private final ThrowingConsumer<Object, ? extends Exception> testBody;\n+    private final List<ThrowingConsumer<Object, ? extends Exception>> beforeActions;\n+    private final List<ThrowingConsumer<Object, ? extends Exception>> afterActions;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TestInstance.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n+import static jdk.jpackage.internal.util.function.ExceptionBox.toUnchecked;\n@@ -198,1 +198,1 @@\n-            throw rethrowUnchecked(ex);\n+            throw toUnchecked(ex);\n@@ -271,1 +271,1 @@\n-                throw rethrowUnchecked(ex);\n+                throw toUnchecked(ex);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/WinExecutableIconVerifier.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n+import static jdk.jpackage.internal.util.function.ExceptionBox.toUnchecked;\n@@ -637,1 +637,1 @@\n-                throw rethrowUnchecked(ex);\n+                throw toUnchecked(ex);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/WindowsHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n+import static jdk.jpackage.internal.util.function.ExceptionBox.toUnchecked;\n@@ -415,1 +415,1 @@\n-            rethrowUnchecked(expectedException);\n+            throw toUnchecked(expectedException);\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/PackagingPipelineTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-    Stream<DynamicTest> getTestCasesFromErrorTest() throws Throwable {\n+    Stream<DynamicTest> getTestCasesFromErrorTest() throws Exception {\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/OptionsValidationFailTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,602 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.util;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n+import jdk.jpackage.internal.util.function.ThrowingSupplier;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+public class ResultTest {\n+\n+    @Test\n+    public void test_ctor_with_value() {\n+        var result = new Result<String>(Optional.of(\"foo\"), List.of());\n+\n+        assertTrue(result.hasValue());\n+        assertFalse(result.hasErrors());\n+        assertEquals(Optional.of(\"foo\"), result.value());\n+        assertEquals(List.of(), result.errors());\n+        assertEquals(Optional.empty(), result.firstError());\n+    }\n+\n+    @Test\n+    public void test_ctor_with_errors() {\n+        var ex = new Exception(\"Kaput!\");\n+        var result = new Result<String>(Optional.empty(), List.of(ex));\n+\n+        assertFalse(result.hasValue());\n+        assertTrue(result.hasErrors());\n+        assertEquals(Optional.empty(), result.value());\n+        assertEquals(List.of(ex), result.errors());\n+        assertEquals(Optional.of(ex), result.firstError());\n+    }\n+\n+    @Test\n+    public void test_ctor_invalid_npe() {\n+        assertThrowsExactly(NullPointerException.class, () -> {\n+            new Result<String>(Optional.of(\"foo\"), null);\n+        });\n+\n+        assertThrowsExactly(NullPointerException.class, () -> {\n+            new Result<String>(null, List.of(new Exception()));\n+        });\n+\n+        assertThrowsExactly(NullPointerException.class, () -> {\n+            new Result<String>(null, null);\n+        });\n+    }\n+\n+    @Test\n+    public void test_ctor_invalid_both_empty() {\n+        var ex = assertThrowsExactly(IllegalArgumentException.class, () -> {\n+            new Result<String>(Optional.empty(), List.of());\n+        });\n+        assertEquals(\"'value' and 'errors' cannot both be non-empty or both be empty\", ex.getMessage());\n+    }\n+\n+    @Test\n+    public void test_ctor_invalid_both_non_empty() {\n+        var ex = assertThrowsExactly(IllegalArgumentException.class, () -> {\n+            new Result<String>(Optional.of(\"foo\"), List.of(new Exception()));\n+        });\n+        assertEquals(\"'value' and 'errors' cannot both be non-empty or both be empty\", ex.getMessage());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_ofValue(boolean valid) {\n+        if (valid) {\n+            assertTrue(Result.ofValue(\"foo\").hasValue());\n+        } else {\n+            assertThrowsExactly(NullPointerException.class, () -> {\n+                Result.ofValue(null);\n+            });\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_ofError(boolean valid) {\n+        if (valid) {\n+            var err = new Exception(\"foo\");\n+            var result = Result.ofError(err);\n+            assertEquals(List.of(err), result.errors());\n+        } else {\n+            assertThrowsExactly(NullPointerException.class, () -> {\n+                Result.ofError(null);\n+            });\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_ofErrors(boolean valid) {\n+        if (valid) {\n+            var errors = List.of(new Exception(\"foo\"), new IllegalArgumentException(\"bar\"));\n+            var result = Result.ofErrors(errors);\n+            assertSame(errors, result.errors());\n+        } else {\n+            assertThrowsExactly(NullPointerException.class, () -> {\n+                Result.ofErrors(null);\n+            });\n+\n+            assertThrowsExactly(NullPointerException.class, () -> {\n+                var errors = new ArrayList<Exception>();\n+                errors.add(new Exception());\n+                errors.add(null);\n+                Result.ofErrors(errors);\n+            });\n+        }\n+    }\n+\n+    @Test\n+    public void test_of() {\n+        assertEquals(\"foo\", Result.<String>of(() -> {\n+            return \"foo\";\n+        }).orElseThrow());\n+    }\n+\n+    @Test\n+    public void test_of_null_value() {\n+        assertThrowsExactly(NullPointerException.class, () -> {\n+            Result.<String>of(() -> {\n+                return null;\n+            });\n+        });\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_of_throws(boolean declaredExceptionType) {\n+\n+        Exception cause;\n+        if (declaredExceptionType) {\n+            cause = new IOException(\"foo\");\n+        } else {\n+            cause = new UnsupportedOperationException(\"bar\");\n+        }\n+\n+        ThrowingSupplier<String, IOException> supplier = () -> {\n+            if (declaredExceptionType) {\n+                throw (IOException)cause;\n+            } else {\n+                throw (UnsupportedOperationException)cause;\n+            }\n+        };\n+\n+        if (declaredExceptionType) {\n+            var result = Result.<String, IOException>of(supplier, IOException.class);\n+            assertSame(cause, result.firstError().orElseThrow());\n+            assertEquals(1, result.errors().size());\n+        } else {\n+            var ex = assertThrowsExactly(cause.getClass(), () -> {\n+                Result.<String, IOException>of(supplier, IOException.class);\n+            });\n+            assertSame(cause, ex);\n+        }\n+    }\n+\n+    @Test\n+    public void test_orElseThrow_hasValue() {\n+        assertEquals(\"foo\", Result.ofValue(\"foo\").orElseThrow());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_orElseThrow(boolean uncheckedException) {\n+        Exception ex;\n+        Class<? extends Exception> expectedType;\n+        if (uncheckedException) {\n+            ex = new RuntimeException(\"Kaput!\");\n+            expectedType = ex.getClass();\n+        } else {\n+            ex = new Exception(\"Kaput!\");\n+            expectedType = ExceptionBox.class;\n+        }\n+\n+        var actual = assertThrowsExactly(expectedType, Result.ofError(ex)::orElseThrow);\n+\n+        if (uncheckedException) {\n+            assertSame(ex, actual);\n+        } else {\n+            assertSame(ex, actual.getCause());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test_map_and_flatMap(MapTestSpec spec) {\n+        spec.run();\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_peekValue(boolean hasValue) {\n+        var pickedValue = Slot.<String>createEmpty();\n+\n+        Consumer<String> consumer = v -> {\n+            assertNotNull(v);\n+            assertTrue(pickedValue.find().isEmpty());\n+            pickedValue.set(v);\n+        };\n+\n+        Result<String> result;\n+        if (hasValue) {\n+            result = Result.ofValue(\"foo\");\n+        } else {\n+            result = Result.ofError(new Exception(\"foo\"));\n+        }\n+        result.peekValue(consumer);\n+\n+        if (hasValue) {\n+            assertEquals(\"foo\", pickedValue.get());\n+        } else {\n+            assertTrue(pickedValue.find().isEmpty());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_peekErrors(boolean hasValue) {\n+        var pickedErrors = Slot.<Collection<? extends Exception>>createEmpty();\n+\n+        Consumer<Collection<? extends Exception>> consumer = v -> {\n+            assertNotNull(v);\n+            assertTrue(pickedErrors.find().isEmpty());\n+            pickedErrors.set(v);\n+        };\n+\n+        Result<String> result;\n+        if (hasValue) {\n+            result = Result.ofValue(\"foo\");\n+        } else {\n+            result = Result.ofErrors(List.of(new Exception(\"foo\"), new IOException(\"bar\")));\n+        }\n+        result.peekErrors(consumer);\n+\n+        if (hasValue) {\n+            assertTrue(pickedErrors.find().isEmpty());\n+        } else {\n+            assertSame(result.errors(), pickedErrors.get());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_mapErrors(boolean hasValue) {\n+        Result<String> result;\n+        if (hasValue) {\n+            result = Result.ofValue(\"foo\");\n+        } else {\n+            result = Result.ofErrors(List.of(new Exception(\"foo\"), new IOException(\"bar\")));\n+        }\n+\n+        if (hasValue) {\n+            var ex = assertThrowsExactly(IllegalStateException.class, result::mapErrors);\n+            assertEquals(\"Can not map errors from a result without errors\", ex.getMessage());\n+        } else {\n+            assertSame(result, result.mapErrors());\n+        }\n+    }\n+\n+    @Test\n+    public void test_allHaveValues_empty() {\n+        assertTrue(Result.allHaveValues());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_allHaveValues(boolean expected) {\n+        if (expected) {\n+            assertTrue(Result.allHaveValues(Result.ofValue(\"foo\"), Result.ofValue(37)));\n+        } else {\n+            assertFalse(Result.allHaveValues(Result.ofValue(\"foo\"), Result.ofError(new Exception())));\n+        }\n+    }\n+\n+    enum MapFunctionType {\n+        MAP,\n+        FLAT_MAP,\n+        ;\n+    }\n+\n+    enum MapFunctionOutcome {\n+        RETURN_NON_NULL,\n+        RETURN_NULL,\n+        THROW,\n+        FLAT_MAP_NEW_ERRORS(MapFunctionType.FLAT_MAP),\n+        ;\n+\n+        MapFunctionOutcome(MapFunctionType... supportedTypes) {\n+            this.supportedTypes = Set.of(supportedTypes);\n+        }\n+\n+        MapFunctionOutcome() {\n+            this(MapFunctionType.values());\n+        }\n+\n+        private final Set<MapFunctionType> supportedTypes;\n+    }\n+\n+    record MapTestSpec(boolean hasValue, MapFunctionOutcome outcome, MapFunctionType type) {\n+        MapTestSpec {\n+            Objects.requireNonNull(outcome);\n+            Objects.requireNonNull(type);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            var tokens = new ArrayList<String>();\n+            tokens.add(outcome.name());\n+            if (type == MapFunctionType.FLAT_MAP) {\n+                tokens.add(\"flatMap\");\n+            }\n+            if (!hasValue) {\n+                tokens.add(\"no-value\");\n+            }\n+            return String.join(\", \", tokens);\n+        }\n+\n+        void run() {\n+            var builder = MapTest.<Integer, String>build();\n+            if (hasValue) {\n+                builder.initialValue(100);\n+            }\n+\n+            Function<Integer, String> plainMapper;\n+            switch (outcome) {\n+                case RETURN_NON_NULL -> {\n+                    if (hasValue) {\n+                        builder.expectValue(\"200\");\n+                    }\n+                    plainMapper = v -> {\n+                        return String.valueOf(v * 2);\n+                    };\n+                }\n+                case RETURN_NULL -> {\n+                    builder.expectExceptionOfType(NullPointerException.class);\n+                    plainMapper = _ -> {\n+                        return null;\n+                    };\n+                }\n+                case THROW -> {\n+                    var cause = new UnsupportedOperationException(\"Unsupported\");\n+                    builder.expectException(cause);\n+                    plainMapper = _ -> {\n+                        throw cause;\n+                    };\n+                }\n+                case FLAT_MAP_NEW_ERRORS -> {\n+                    if (hasValue) {\n+                        \/\/ Just a stub to make `builder.create()` pass.\n+                        builder.expectValue(\"\");\n+                    }\n+                    var mappedResult = Result.<String>ofError(new UnsupportedOperationException(\"Whoopsy-daisy\"));\n+                    var test = builder.create().copyWithMappedValue(mappedResult);\n+                    test.flatMap(v -> {\n+                        return mappedResult;\n+                    });\n+                    return;\n+                }\n+                default -> {\n+                    throw ExceptionBox.reachedUnreachable();\n+                }\n+            }\n+\n+            var test = builder.create();\n+\n+            switch (type) {\n+                case MAP -> {\n+                    test.map(plainMapper);\n+                }\n+                case FLAT_MAP -> {\n+                    test.flatMap(v -> {\n+                        return Optional.ofNullable(plainMapper.apply(v)).map(Result::ofValue).orElse(null);\n+                    });\n+                }\n+            }\n+        }\n+    }\n+\n+    private static List<MapTestSpec> test_map_and_flatMap() {\n+        var data = new ArrayList<MapTestSpec>();\n+        for (var type : MapFunctionType.values()) {\n+            for (var outcome : MapFunctionOutcome.values()) {\n+                if (outcome.supportedTypes.contains(type)) {\n+                    for (var hasValue : List.of(true, false)) {\n+                        data.add(new MapTestSpec(hasValue, outcome, type));\n+                    }\n+                }\n+            }\n+        }\n+        return data;\n+    }\n+\n+    private static final class Counter<T, U> implements Function<T, U> {\n+\n+        Counter(Function<T, U> impl) {\n+            this.impl = Objects.requireNonNull(impl);\n+        }\n+\n+        @Override\n+        public U apply(T v) {\n+            counter++;\n+            return impl.apply(v);\n+        }\n+\n+        int count() {\n+            return counter;\n+        }\n+\n+        private int counter;\n+        private final Function<T, U> impl;\n+    }\n+\n+    private record MapTest<T, U>(\n+            Result<T> initialValue,\n+            Optional<Result<U>> mappedValue,\n+            Optional<Exception> expectedException,\n+            Optional<Class<? extends Exception>> expectedExceptionType) {\n+\n+        MapTest {\n+            Objects.requireNonNull(initialValue);\n+            Objects.requireNonNull(mappedValue);\n+            Objects.requireNonNull(expectedException);\n+            Objects.requireNonNull(expectedExceptionType);\n+\n+            if (expectedExceptionType.isPresent() && mappedValue.isPresent()) {\n+                \/\/ Bad configuration: the mapping operation is expected to throw,\n+                \/\/ but it also expects it to return a value.\n+                throw new IllegalArgumentException();\n+            }\n+\n+            if (expectedExceptionType.isEmpty() && mappedValue.isEmpty()) {\n+                \/\/ Bad configuration: the mapping operation is expected to return normally (not to throw),\n+                \/\/ but it also doesn't expect a mapped value.\n+                throw new IllegalArgumentException();\n+            }\n+\n+            if (initialValue.hasErrors() && mappedValue.map(Result::hasValue).orElse(false)) {\n+                \/\/ Bad configuration: the initial value has errors but they expect a mapped value without errors.\n+                throw new IllegalArgumentException();\n+            }\n+\n+            expectedException.map(Object::getClass).ifPresent(expectedExpectedExceptionType -> {\n+                var configuredExpectedExceptionType = expectedExceptionType.orElseThrow();\n+                if (!configuredExpectedExceptionType.equals(expectedExpectedExceptionType)) {\n+                    throw new IllegalArgumentException(String.format(\n+                            \"expectedException=%s; expectedExceptionType=%s\",\n+                            expectedExpectedExceptionType, configuredExpectedExceptionType));\n+                }\n+            });\n+        }\n+\n+        MapTest<T, U> copyWithMappedValue(Result<U> v) {\n+            return new MapTest<>(initialValue, Optional.of(v), expectedException, expectedExceptionType);\n+        }\n+\n+        static <T, U> Builder<T, U> build() {\n+            return new Builder<>();\n+        }\n+\n+        void map(Function<T, U> mapper) {\n+            map(new Counter<>(mapper), initialValue::map);\n+        }\n+\n+        void flatMap(Function<T, Result<U>> mapper) {\n+            map(new Counter<>(mapper), initialValue::flatMap);\n+        }\n+\n+        private <V> void map(Counter<T, V> countingMapper, Function<Counter<T, V>, Result<U>> mapper) {\n+\n+            if (initialValue.hasErrors()) {\n+                Result<U> mapped = mapper.apply(countingMapper);\n+                assertTrue(mapped.hasErrors());\n+                assertEquals(initialValue.errors(), mapped.errors());\n+            } else {\n+                expectedExceptionType.ifPresentOrElse(theExpectedExceptionType -> {\n+                    var ex = assertThrowsExactly(theExpectedExceptionType, () -> {\n+                        initialValue.map(countingMapper);\n+                    });\n+\n+                    expectedException.ifPresent(theExpectedException -> {\n+                        assertSame(theExpectedException, ex);\n+                    });\n+                }, () -> {\n+                    Result<U> mapped = mapper.apply(countingMapper);\n+                    assertEquals(mappedValue.orElseThrow(), mapped);\n+                });\n+            }\n+\n+            if (initialValue.hasValue()) {\n+                assertEquals(1, countingMapper.count());\n+            } else {\n+                assertEquals(0, countingMapper.count());\n+            }\n+        }\n+\n+        static final class Builder<T, U> {\n+\n+            MapTest<T, U> create() {\n+\n+                var theInitialValue = Optional.ofNullable(initialValue).orElseGet(() -> {\n+                    return Result.ofError(new Exception(\"Kaput!\"));\n+                });\n+\n+                return new MapTest<>(\n+                        theInitialValue,\n+                        Optional.ofNullable(expectedValue).map(Result::ofValue).or(() -> {\n+                            if (expectedExceptionType == null) {\n+                                return Optional.of(theInitialValue.mapErrors());\n+                            } else {\n+                                return Optional.empty();\n+                            }\n+                        }),\n+                        Optional.ofNullable(expectedException),\n+                        Optional.ofNullable(expectedExceptionType));\n+            }\n+\n+            Builder<T, U> initialValue(Result<T> v) {\n+                initialValue = v;\n+                return this;\n+            }\n+\n+            Builder<T, U> initialValue(T v) {\n+                return initialValue(Result.ofValue(v));\n+            }\n+\n+            Builder<T, U> expectException(Exception v) {\n+                expectedException = v;\n+                if (expectedException != null) {\n+                    expectedExceptionType = expectedException.getClass();\n+                    expectValue(null);\n+                } else {\n+                    expectedExceptionType = null;\n+                }\n+                return this;\n+            }\n+\n+            Builder<T, U> expectExceptionOfType(Class<? extends Exception> v) {\n+                expectedException = null;\n+                expectedExceptionType = v;\n+                if (v != null) {\n+                    expectValue(null);\n+                }\n+                return this;\n+            }\n+\n+            Builder<T, U> expectValue(U v) {\n+                expectedValue = v;\n+                if (v != null) {\n+                    expectException(null);\n+                }\n+                return this;\n+            }\n+\n+            private Result<T> initialValue;\n+            private U expectedValue;\n+            private Exception expectedException;\n+            private Class<? extends Exception> expectedExceptionType;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/util\/ResultTest.java","additions":602,"deletions":0,"binary":false,"changes":602,"status":"added"},{"patch":"@@ -0,0 +1,246 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.util.function;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.UnaryOperator;\n+import jdk.jpackage.internal.util.Slot;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+\n+public class ExceptionBoxTest {\n+\n+    @Test\n+    public void test_unbox_RuntimeException() {\n+        var ex = new RuntimeException();\n+        assertSame(ex, ExceptionBox.unbox(ex));\n+    }\n+\n+    @Test\n+    public void test_unbox_Exception() {\n+        var ex = new Exception();\n+        assertSame(ex, ExceptionBox.unbox(ex));\n+    }\n+\n+    @Test\n+    public void test_unbox_InvocationTargetException() {\n+        var ex = new Exception();\n+        assertSame(ex, ExceptionBox.unbox(new InvocationTargetException(ex)));\n+    }\n+\n+    @Test\n+    public void test_unbox_ExceptionBox() {\n+        var ex = new Exception(\"foo\");\n+        \/\/ There is no way to directly instantiate ExceptionBox, use a workaround.\n+        var box = assertThrowsExactly(ExceptionBox.class, () -> {\n+            throw ExceptionBox.toUnchecked(ex);\n+        });\n+        assertSame(ex, ExceptionBox.unbox(box));\n+    }\n+\n+    @Test\n+    public void test_unbox_Error() {\n+        var err = new Error(\"On Fire!\");\n+        var thrown = assertThrowsExactly(Error.class, () -> {\n+            ExceptionBox.unbox(err);\n+        });\n+        assertSame(err, thrown);\n+    }\n+\n+    @Test\n+    public void test_reachedUnreachable() {\n+        var err = ExceptionBox.reachedUnreachable();\n+        assertEquals(\"Reached unreachable!\", err.getMessage());\n+    }\n+\n+    @Test\n+    public void test_toUnchecked_RuntimeException() {\n+        assertToUnchecked(new RuntimeException(), true);\n+    }\n+\n+    @Test\n+    public void test_toUnchecked_Exception() {\n+        assertToUnchecked(new Exception(), false);\n+    }\n+\n+    @Test\n+    public void test_toUnchecked_ExceptionBox() {\n+        \/\/ There is no way to directly instantiate ExceptionBox, use a workaround.\n+        var box = assertThrowsExactly(ExceptionBox.class, () -> {\n+            throw ExceptionBox.toUnchecked(new Exception(\"foo\"));\n+        });\n+        assertToUnchecked(box, true);\n+    }\n+\n+    @Test\n+    public void test_toUnchecked_InterruptedException() throws InterruptedException {\n+\n+        var workerThreadReadyToWait = Slot.<Boolean>createEmpty();\n+\n+        var workerThreadInterruptedExceptionCaught = Slot.<Boolean>createEmpty();\n+\n+        var workerThreadException = new AtomicReference<Throwable>();\n+\n+        var thread = Thread.ofVirtual().uncaughtExceptionHandler((Thread _, Throwable e) -> {\n+            trace(\"unexpected exception: %s\", e);\n+            workerThreadException.set(e);\n+        }).start(() -> {\n+            try {\n+                var lock = new Object();\n+                synchronized (lock) {\n+                    synchronized (workerThreadReadyToWait) {\n+                        workerThreadReadyToWait.set(true);\n+                        workerThreadReadyToWait.notify();\n+                    }\n+                    trace(\"wait\");\n+                    lock.wait();\n+                }\n+            } catch (InterruptedException iex) {\n+                trace(\"interrupted state cleared\");\n+                synchronized (workerThreadInterruptedExceptionCaught) {\n+                    workerThreadInterruptedExceptionCaught.set(true);\n+                    trace(\"notify about to interrupt itself\");\n+                    workerThreadInterruptedExceptionCaught.notify();\n+                }\n+                trace(\"before toUnchecked()\");\n+                var box = assertThrowsExactly(ExceptionBox.class, () -> {\n+                    throw ExceptionBox.toUnchecked(iex);\n+                });\n+                assertSame(iex, box.getCause());\n+            }\n+        });\n+\n+        \/\/ Wait until the worker thread gets to the point\n+        \/\/ when interrupting it will cause InterruptedException.\n+        synchronized (workerThreadReadyToWait) {\n+            while (workerThreadReadyToWait.find().isEmpty()) {\n+                workerThreadReadyToWait.wait();\n+            }\n+        }\n+\n+        trace(\"interrupt %s\", thread);\n+        thread.interrupt();\n+\n+        \/\/ Wait until the worker thread catches an InterruptedException.\n+        synchronized (workerThreadInterruptedExceptionCaught) {\n+            while (workerThreadInterruptedExceptionCaught.find().isEmpty()) {\n+                trace(\"wait for %s to catch InterruptedException\", thread);\n+                workerThreadInterruptedExceptionCaught.wait();\n+            }\n+        }\n+\n+        \/\/ Block waiting when ExceptionBox.toUnchecked()\n+        \/\/ called in the worker thread will interrupt the worker thread.\n+        while (!thread.isInterrupted()) {\n+            trace(\"wait %s is interrupted\", thread);\n+            Thread.sleep(100);\n+        }\n+\n+        trace(\"join interrupted %s\", thread);\n+        thread.join();\n+\n+        assertNull(workerThreadException.get());\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(InvocationTargetExceptionType.class)\n+    public void test_rethrowUnchecked_InvocationTargetException(InvocationTargetExceptionType type)\n+            throws NoSuchMethodException, SecurityException, IllegalAccessException {\n+\n+        var m = ExceptionBoxTest.class.getMethod(type.methodName);\n+\n+        try {\n+            m.invoke(null);\n+        } catch (InvocationTargetException ex) {\n+            var cause = assertThrows(type.expectedThrownType, () -> {\n+                throw ExceptionBox.toUnchecked(ex);\n+            });\n+            assertSame(ex.getCause(), type.expectedThrowableGetter.apply(cause));\n+        }\n+    }\n+\n+    public enum InvocationTargetExceptionType {\n+        CHECKED(\"throwIOException\", t -> {\n+            return t.getCause();\n+        }, ExceptionBox.class),\n+        UNCHECKED(\"throwNPE\", x -> x, RuntimeException.class),\n+        ERROR(\"throwError\", x -> x, Error.class),\n+        ;\n+\n+        InvocationTargetExceptionType(\n+                String methodName,\n+                UnaryOperator<Throwable> expectedThrowableGetter,\n+                Class<? extends Throwable> expectedThrownType) {\n+            this.methodName = Objects.requireNonNull(methodName);\n+            this.expectedThrownType = Objects.requireNonNull(expectedThrownType);\n+            this.expectedThrowableGetter = Objects.requireNonNull(expectedThrowableGetter);\n+        }\n+\n+        final String methodName;\n+        final Class<? extends Throwable> expectedThrownType;\n+        final UnaryOperator<Throwable> expectedThrowableGetter;\n+    }\n+\n+    public static void throwIOException() throws IOException {\n+        throw new IOException(\"foo\");\n+    }\n+\n+    public static void throwNPE() {\n+        throw new NullPointerException(\"foo\");\n+    }\n+\n+    public static void throwError() {\n+        throw new Error(\"Kaput!\");\n+    }\n+\n+    private static void assertToUnchecked(Exception cause, boolean asis) {\n+        Class<? extends Throwable> expectedType;\n+        if (asis) {\n+            expectedType = cause.getClass();\n+        } else {\n+            expectedType = ExceptionBox.class;\n+        }\n+        var unchecked = ExceptionBox.toUnchecked(cause);\n+        if (asis) {\n+            assertSame(cause, unchecked);\n+        } else {\n+            assertSame(cause, unchecked.getCause());\n+        }\n+    }\n+\n+    private void trace(String format, Object... args) {\n+        Objects.requireNonNull(format);\n+        System.out.println(String.format(\"[%s]: %s\", Thread.currentThread(), String.format(format, args)));\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/util\/function\/ExceptionBoxTest.java","additions":246,"deletions":0,"binary":false,"changes":246,"status":"added"},{"patch":"@@ -0,0 +1,189 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.util.function;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.Map;\n+import java.util.function.Supplier;\n+import jdk.jpackage.internal.util.Slot;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+public class FunctionalTest {\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_toRunnable(boolean error) {\n+        var reply = Slot.<Integer>createEmpty();\n+\n+        var runnable = ThrowingRunnable.toRunnable(() -> {\n+            if (error) {\n+                throw new Exception();\n+            } else {\n+                reply.set(135);\n+            }\n+        });\n+\n+        if (error) {\n+            assertThrowsExactly(ExceptionBox.class, runnable::run);\n+            assertTrue(reply.find().isEmpty());\n+        } else {\n+            runnable.run();\n+            assertEquals(135, reply.get());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_toSupplier(boolean error) {\n+        var supplier = ThrowingSupplier.<Integer>toSupplier(() -> {\n+            if (error) {\n+                throw new Exception();\n+            } else {\n+                return 135;\n+            }\n+        });\n+\n+        if (error) {\n+            assertThrowsExactly(ExceptionBox.class, supplier::get);\n+        } else {\n+            assertEquals(135, supplier.get());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_toConsumer(boolean error) {\n+        var reply = Slot.<Integer>createEmpty();\n+\n+        Runnable runnable = () -> {\n+            ThrowingConsumer.<Integer>toConsumer(v -> {\n+                if (error) {\n+                    throw new Exception();\n+                } else {\n+                    reply.set(v);\n+                }\n+            }).accept(135);\n+        };\n+\n+        if (error) {\n+            assertThrowsExactly(ExceptionBox.class, runnable::run);\n+            assertTrue(reply.find().isEmpty());\n+        } else {\n+            runnable.run();\n+            assertEquals(135, reply.get());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_toBiConsumer(boolean error) {\n+        var reply = Slot.<Integer>createEmpty();\n+        var reply2 = Slot.<String>createEmpty();\n+\n+        Runnable runnable = () -> {\n+            ThrowingBiConsumer.<Integer, String>toBiConsumer((x, y) -> {\n+                if (error) {\n+                    throw new Exception();\n+                } else {\n+                    reply.set(x);\n+                    reply2.set(y);\n+                }\n+            }).accept(456, \"Hello\");\n+        };\n+\n+        if (error) {\n+            assertThrowsExactly(ExceptionBox.class, runnable::run);\n+            assertTrue(reply.find().isEmpty());\n+            assertTrue(reply2.find().isEmpty());\n+        } else {\n+            runnable.run();\n+            assertEquals(456, reply.get());\n+            assertEquals(\"Hello\", reply2.get());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_toFunction(boolean error) {\n+        Supplier<String> supplier = () -> {\n+            return ThrowingFunction.<Integer, String>toFunction(v -> {\n+                if (error) {\n+                    throw new Exception();\n+                } else {\n+                    return String.valueOf(v);\n+                }\n+            }).apply(765);\n+        };\n+\n+        if (error) {\n+            assertThrowsExactly(ExceptionBox.class, supplier::get);\n+        } else {\n+            assertEquals(\"765\", supplier.get());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_toBiFunction(boolean error) {\n+        Supplier< Map.Entry<String, Integer>> supplier = () -> {\n+            return ThrowingBiFunction.<Integer, String, Map.Entry<String, Integer>>toBiFunction((x, y) -> {\n+                if (error) {\n+                    throw new Exception();\n+                } else {\n+                    return Map.entry(y, x + 23);\n+                }\n+            }).apply(400, \"foo\");\n+        };\n+\n+        if (error) {\n+            assertThrowsExactly(ExceptionBox.class, supplier::get);\n+        } else {\n+            assertEquals(Map.entry(\"foo\", 423), supplier.get());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_toUnaryOperator(boolean error) {\n+        Supplier<Integer> supplier = () -> {\n+            return ThrowingUnaryOperator.<Integer>toUnaryOperator(v -> {\n+                if (error) {\n+                    throw new Exception();\n+                } else {\n+                    return v - 222;\n+                }\n+            }).apply(777);\n+        };\n+\n+        if (error) {\n+            assertThrowsExactly(ExceptionBox.class, supplier::get);\n+        } else {\n+            assertEquals(555, supplier.get());\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/util\/function\/FunctionalTest.java","additions":189,"deletions":0,"binary":false,"changes":189,"status":"added"},{"patch":"@@ -52,1 +52,1 @@\n-    public static Stream<DynamicTest> createJPackageTests(ClassLoader testClassLoader, String... args) throws Throwable {\n+    public static Stream<DynamicTest> createJPackageTests(ClassLoader testClassLoader, String... args) throws Exception {\n@@ -67,1 +67,1 @@\n-    Stream<DynamicTest> createJPackageTests() throws Throwable {\n+    Stream<DynamicTest> createJPackageTests() throws Exception {\n@@ -71,1 +71,1 @@\n-    static List<String> captureJPackageTestLog(ThrowingRunnable runnable) {\n+    static List<String> captureJPackageTestLog(ThrowingRunnable<? extends Exception> runnable) {\n","filename":"test\/jdk\/tools\/jpackage\/junit\/tools\/jdk\/jpackage\/test\/JUnitAdapter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-    private static void runTest(ThrowingConsumer<JPackageCommand> initializer,\n+    private static void runTest(ThrowingConsumer<JPackageCommand, ? extends Exception> initializer,\n","filename":"test\/jdk\/tools\/jpackage\/linux\/AppAboutUrlTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.jpackage.internal.util.Slot;\n@@ -55,0 +54,1 @@\n+import jdk.jpackage.internal.util.Slot;\n@@ -87,1 +87,1 @@\n-    public void testAppImage(TestConfig cfg) throws Throwable {\n+    public void testAppImage(TestConfig cfg) {\n@@ -257,0 +257,4 @@\n+                        \/\/ Ignore externally configured runtime if any.\n+                        \/\/ It may or may not have the \"bin\" directory, it also can be a bundle.\n+                        \/\/ These factors affect the runtime plist file (see JDK-8363980) which may not be the default one.\n+                        .ignoreDefaultRuntime(true)\n@@ -323,2 +327,2 @@\n-                ThrowingBiConsumer<JPackageCommand, XMLStreamWriter> inputPlistWriter,\n-                ThrowingBiConsumer<JPackageCommand, XMLStreamWriter> outputPlistWriter,\n+                ThrowingBiConsumer<JPackageCommand, XMLStreamWriter, ? extends Exception> inputPlistWriter,\n+                ThrowingBiConsumer<JPackageCommand, XMLStreamWriter, ? extends Exception> outputPlistWriter,\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/CustomInfoPListTest.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-        EntitlementsSource(ThrowingConsumer<JPackageCommand> initializer) {\n+        EntitlementsSource(ThrowingConsumer<JPackageCommand, ? extends Exception> initializer) {\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/EntitlementsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import java.util.Map;\n@@ -634,1 +633,1 @@\n-        FileContentFactory(ThrowingSupplier<Path> factory, Path pathInAppContentRoot) {\n+        FileContentFactory(ThrowingSupplier<Path, IOException> factory, Path pathInAppContentRoot) {\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppContentTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.jpackage.internal.util.Slot;\n@@ -64,1 +65,1 @@\n-    public void test() throws Throwable {\n+    public void test() throws Exception {\n@@ -97,1 +98,1 @@\n-            Throwable[] fatalError = new Throwable[1];\n+            var fatalError = Slot.<Exception>createEmpty();\n@@ -105,3 +106,1 @@\n-                result.throwable().filter(Predicate.not(TKit::isSkippedException)).ifPresent(t -> {\n-                    fatalError[0] = t;\n-                });\n+                result.exception().filter(Predicate.not(TKit::isSkippedException)).ifPresent(fatalError::set);\n@@ -110,2 +109,2 @@\n-            if (fatalError[0] != null) {\n-                throw fatalError[0];\n+            if (fatalError.find().isPresent()) {\n+                throw fatalError.get();\n@@ -146,1 +145,1 @@\n-    private record Result(String stdoutBuffer, String stderrBuffer, String id, Optional<Throwable> throwable) {\n+    private record Result(String stdoutBuffer, String stderrBuffer, String id, Optional<Exception> exception) {\n@@ -152,1 +151,1 @@\n-            Objects.requireNonNull(throwable);\n+            Objects.requireNonNull(exception);\n@@ -160,1 +159,1 @@\n-            ThrowingRunnable runnable,\n+            ThrowingRunnable<? extends Exception> runnable,\n@@ -170,1 +169,1 @@\n-        Workload(ThrowingRunnable runnable, String id) {\n+        Workload(ThrowingRunnable<? extends Exception> runnable, String id) {\n@@ -205,1 +204,1 @@\n-            Optional<Throwable> err = Optional.empty();\n+            Optional<Exception> err = Optional.empty();\n@@ -211,2 +210,2 @@\n-            } catch (Throwable t) {\n-                err = Optional.of(t);\n+            } catch (Exception ex) {\n+                err = Optional.of(ex);\n","filename":"test\/jdk\/tools\/jpackage\/share\/AsyncTest.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -310,1 +310,1 @@\n-    public void testNoOutputDir(boolean appImage) throws Throwable {\n+    public void testNoOutputDir(boolean appImage) throws IOException {\n@@ -315,1 +315,1 @@\n-        final ThrowingConsumer<JPackageCommand> initializer = cmdNoOutputDir -> {\n+        final ThrowingConsumer<JPackageCommand, IOException> initializer = cmdNoOutputDir -> {\n","filename":"test\/jdk\/tools\/jpackage\/share\/BasicTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -206,1 +206,1 @@\n-    private ThrowingBiConsumer<JPackageCommand, Executor.Result> createBundleVerifier() {\n+    private ThrowingBiConsumer<JPackageCommand, Executor.Result, IOException> createBundleVerifier() {\n@@ -279,1 +279,1 @@\n-    private ThrowingConsumer<JPackageCommand> createInstallVerifier() {\n+    private ThrowingConsumer<JPackageCommand, IOException> createInstallVerifier() {\n","filename":"test\/jdk\/tools\/jpackage\/share\/IconTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+import static jdk.jpackage.test.RunnablePackageTest.Action.CREATE_AND_UNPACK;\n+\n@@ -34,3 +36,1 @@\n-import jdk.jpackage.test.AppImageFile;\n-import jdk.jpackage.test.ApplicationLayout;\n-import jdk.jpackage.test.PackageFile;\n+import jdk.jpackage.internal.util.function.ThrowingConsumer;\n@@ -39,1 +39,2 @@\n-import jdk.jpackage.internal.util.function.ThrowingConsumer;\n+import jdk.jpackage.test.AppImageFile;\n+import jdk.jpackage.test.ApplicationLayout;\n@@ -42,0 +43,1 @@\n+import jdk.jpackage.test.PackageFile;\n@@ -44,1 +46,0 @@\n-import static jdk.jpackage.test.RunnablePackageTest.Action.CREATE_AND_UNPACK;\n@@ -148,1 +149,1 @@\n-    public void test() throws Throwable {\n+    public void test() throws Exception {\n@@ -152,1 +153,1 @@\n-    private static Envelope wrap(ThrowingConsumer<JPackageCommand> v, String label) {\n+    private static Envelope wrap(ThrowingConsumer<JPackageCommand, ? extends Exception> v, String label) {\n@@ -161,2 +162,2 @@\n-            ThrowingConsumer<JPackageCommand> configure) throws Throwable {\n-        ThrowingConsumer<JPackageCommand> configureWrapper = cmd -> {\n+            ThrowingConsumer<JPackageCommand, ? extends Exception> configure) throws Exception {\n+        ThrowingConsumer<JPackageCommand, Exception> configureWrapper = cmd -> {\n@@ -271,1 +272,1 @@\n-    private static final record Envelope(ThrowingConsumer<JPackageCommand> value, String label) {\n+    private static final record Envelope(ThrowingConsumer<JPackageCommand, ? extends Exception> value, String label) {\n@@ -294,1 +295,1 @@\n-    private final ThrowingConsumer<JPackageCommand> configure;\n+    private final ThrowingConsumer<JPackageCommand, ? extends Exception> configure;\n","filename":"test\/jdk\/tools\/jpackage\/share\/InOutPathTest.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -161,2 +161,2 @@\n-            Path outputCfgFileDir, ThrowingConsumer<JPackageCommand> action) throws\n-            Throwable {\n+            Path outputCfgFileDir, ThrowingConsumer<JPackageCommand, ? extends Exception> action) throws\n+            Exception {\n","filename":"test\/jdk\/tools\/jpackage\/share\/PerUserCfgTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import jdk.jpackage.internal.util.function.ThrowingSupplier;\n+import java.util.function.Supplier;\n@@ -117,1 +117,1 @@\n-    private static PackageTest init(ThrowingSupplier<Path> createRuntime) {\n+    private static PackageTest init(Supplier<Path> createRuntime) {\n","filename":"test\/jdk\/tools\/jpackage\/share\/RuntimePackageTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-    public void test() throws Throwable {\n+    public void test() {\n@@ -119,1 +119,1 @@\n-    public void testUpdate() throws Throwable {\n+    public void testUpdate() {\n","filename":"test\/jdk\/tools\/jpackage\/share\/ServiceTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}