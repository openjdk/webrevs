{"files":[{"patch":"@@ -63,2 +63,2 @@\n-        UNLAMBDA(8),\n-        LOWER(9),\n+        LOWER(8),\n+        UNLAMBDA(9),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/CompileStates.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-import com.sun.tools.javac.code.Symbol.TypeSymbol;\n@@ -48,1 +47,0 @@\n-import com.sun.tools.javac.code.Type.TypeVar;\n@@ -51,1 +49,0 @@\n-import com.sun.tools.javac.comp.Lower.BasicFreeVarCollector;\n@@ -53,1 +50,0 @@\n-import com.sun.tools.javac.jvm.*;\n@@ -56,1 +52,0 @@\n-import com.sun.source.tree.MemberReferenceTree.ReferenceMode;\n@@ -75,1 +70,0 @@\n-import javax.lang.model.type.TypeKind;\n@@ -129,3 +123,0 @@\n-    \/** lambda proxy is a dynamic nestmate *\/\n-    private final boolean nestmateLambdas;\n-\n@@ -178,1 +169,0 @@\n-        nestmateLambdas = Target.instance(context).runtimeUseNestAccess();\n@@ -287,0 +277,1 @@\n+        cdef = analyzer.analyzeAndPreprocessClass((JCClassDecl) cdef);\n@@ -300,4 +291,0 @@\n-        if (tree.sym.owner.kind == PCK) {\n-            \/\/analyze class\n-            tree = analyzer.analyzeAndPreprocessClass(tree);\n-        }\n@@ -421,3 +408,1 @@\n-        if (localContext.methodReferenceReceiver != null) {\n-            syntheticInits.append(localContext.methodReferenceReceiver);\n-        } else if (!sym.isStatic()) {\n+        if (!sym.isStatic()) {\n@@ -436,5 +421,0 @@\n-        \/\/ add captured outer this instances (used only when `this' capture itself is illegal)\n-        for (Symbol fv : localContext.getSymbolMap(CAPTURED_OUTER_THIS).keySet()) {\n-            JCExpression captured_local = make.QualThis(fv.type);\n-            syntheticInits.append(captured_local);\n-        }\n@@ -556,48 +536,0 @@\n-    \/**\n-     * Translate qualified `this' references within a lambda to the mapped identifier\n-     * @param tree\n-     *\/\n-    @Override\n-    public void visitSelect(JCFieldAccess tree) {\n-        if (context == null || !analyzer.lambdaFieldAccessFilter(tree)) {\n-            super.visitSelect(tree);\n-        } else {\n-            int prevPos = make.pos;\n-            try {\n-                make.at(tree);\n-\n-                LambdaTranslationContext lambdaContext = (LambdaTranslationContext) context;\n-                JCTree ltree = lambdaContext.translate(tree);\n-                if (ltree != null) {\n-                    result = ltree;\n-                } else {\n-                    super.visitSelect(tree);\n-                }\n-            } finally {\n-                make.at(prevPos);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Translate instance creation expressions with implicit enclosing instances\n-     * @param tree\n-     *\/\n-    @Override\n-    public void visitNewClass(JCNewClass tree) {\n-        if (context == null || !analyzer.lambdaNewClassFilter(context, tree)) {\n-            super.visitNewClass(tree);\n-        } else {\n-            int prevPos = make.pos;\n-            try {\n-                make.at(tree);\n-\n-                LambdaTranslationContext lambdaContext = (LambdaTranslationContext) context;\n-                tree = lambdaContext.translate(tree);\n-                super.visitNewClass(tree);\n-            } finally {\n-                make.at(prevPos);\n-            }\n-        }\n-    }\n-\n@@ -728,1 +660,1 @@\n-        return deser;\n+        return lower.translateMethod(attrEnv, deser, make);\n@@ -860,30 +792,0 @@\n-    \/**\n-     * Set varargsElement field on a given tree (must be either a new class tree\n-     * or a method call tree)\n-     *\/\n-    private void setVarargsIfNeeded(JCTree tree, Type varargsElement) {\n-        if (varargsElement != null) {\n-            switch (tree.getTag()) {\n-                case APPLY: ((JCMethodInvocation)tree).varargsElement = varargsElement; break;\n-                case NEWCLASS: ((JCNewClass)tree).varargsElement = varargsElement; break;\n-                case TYPECAST: setVarargsIfNeeded(((JCTypeCast) tree).expr, varargsElement); break;\n-                default: throw new AssertionError();\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Convert method\/constructor arguments by inserting appropriate cast\n-     * as required by type-erasure - this is needed when bridging a lambda\/method\n-     * reference, as the bridged signature might require downcast to be compatible\n-     * with the generated signature.\n-     *\/\n-    private List<JCExpression> convertArgs(Symbol meth, List<JCExpression> args, Type varargsElement) {\n-       Assert.check(meth.kind == MTH);\n-       List<Type> formals = types.erasure(meth.type).getParameterTypes();\n-       if (varargsElement != null) {\n-           Assert.check((meth.flags() & VARARGS) != 0);\n-       }\n-       return transTypes.translateArgs(args, formals, varargsElement, attrEnv);\n-    }\n-\n@@ -892,207 +794,0 @@\n-    \/**\n-     * Converts a method reference which cannot be used directly into a lambda\n-     *\/\n-    private class MemberReferenceToLambda {\n-\n-        private final JCMemberReference tree;\n-        private final ReferenceTranslationContext localContext;\n-        private final Symbol owner;\n-        private final ListBuffer<JCExpression> args = new ListBuffer<>();\n-        private final ListBuffer<JCVariableDecl> params = new ListBuffer<>();\n-\n-        private JCExpression receiverExpression = null;\n-\n-        MemberReferenceToLambda(JCMemberReference tree, ReferenceTranslationContext localContext, Symbol owner) {\n-            this.tree = tree;\n-            this.localContext = localContext;\n-            this.owner = owner;\n-        }\n-\n-        JCLambda lambda() {\n-            int prevPos = make.pos;\n-            try {\n-                make.at(tree);\n-\n-                \/\/body generation - this can be either a method call or a\n-                \/\/new instance creation expression, depending on the member reference kind\n-                VarSymbol rcvr = addParametersReturnReceiver();\n-                JCExpression expr = (tree.getMode() == ReferenceMode.INVOKE)\n-                        ? expressionInvoke(rcvr)\n-                        : expressionNew();\n-\n-                JCLambda slam = make.Lambda(params.toList(), expr);\n-                slam.target = tree.target;\n-                slam.type = tree.type;\n-                slam.pos = tree.pos;\n-                return slam;\n-            } finally {\n-                make.at(prevPos);\n-            }\n-        }\n-\n-        \/**\n-         * Generate the parameter list for the converted member reference.\n-         *\n-         * @return The receiver variable symbol, if any\n-         *\/\n-        VarSymbol addParametersReturnReceiver() {\n-            Type samDesc = localContext.bridgedRefSig();\n-            List<Type> samPTypes = samDesc.getParameterTypes();\n-            List<Type> descPTypes = tree.getDescriptorType(types).getParameterTypes();\n-\n-            \/\/ Determine the receiver, if any\n-            VarSymbol rcvr;\n-            switch (tree.kind) {\n-                case BOUND:\n-                    \/\/ The receiver is explicit in the method reference\n-                    rcvr = addParameter(\"rec$\", tree.getQualifierExpression().type, false);\n-                    receiverExpression = attr.makeNullCheck(tree.getQualifierExpression());\n-                    break;\n-                case UNBOUND:\n-                    \/\/ The receiver is the first parameter, extract it and\n-                    \/\/ adjust the SAM and unerased type lists accordingly\n-                    rcvr = addParameter(\"rec$\", samDesc.getParameterTypes().head, false);\n-                    samPTypes = samPTypes.tail;\n-                    descPTypes = descPTypes.tail;\n-                    break;\n-                default:\n-                    rcvr = null;\n-                    break;\n-            }\n-            List<Type> implPTypes = tree.sym.type.getParameterTypes();\n-            int implSize = implPTypes.size();\n-            int samSize = samPTypes.size();\n-            \/\/ Last parameter to copy from referenced method, exclude final var args\n-            int last = localContext.needsVarArgsConversion() ? implSize - 1 : implSize;\n-\n-            \/\/ Failsafe -- assure match-up\n-            boolean checkForIntersection = tree.varargsElement != null || implSize == descPTypes.size();\n-\n-            \/\/ Use parameter types of the implementation method unless the unerased\n-            \/\/ SAM parameter type is an intersection type, in that case use the\n-            \/\/ erased SAM parameter type so that the supertype relationship\n-            \/\/ the implementation method parameters is not obscured.\n-            \/\/ Note: in this loop, the lists implPTypes, samPTypes, and descPTypes\n-            \/\/ are used as pointers to the current parameter type information\n-            \/\/ and are thus not usable afterwards.\n-            for (int i = 0; implPTypes.nonEmpty() && i < last; ++i) {\n-                \/\/ By default use the implementation method parameter type\n-                Type parmType = implPTypes.head;\n-                if (checkForIntersection) {\n-                    if (descPTypes.head.getKind() == TypeKind.INTERSECTION) {\n-                        parmType = samPTypes.head;\n-                    }\n-                    \/\/ If the unerased parameter type is a type variable whose\n-                    \/\/ bound is an intersection (eg. <T extends A & B>) then\n-                    \/\/ use the SAM parameter type\n-                    if (descPTypes.head.getKind() == TypeKind.TYPEVAR) {\n-                        TypeVar tv = (TypeVar) descPTypes.head;\n-                        if (tv.getUpperBound().getKind() == TypeKind.INTERSECTION) {\n-                            parmType = samPTypes.head;\n-                        }\n-                    }\n-                }\n-                addParameter(\"x$\" + i, parmType, true);\n-\n-                \/\/ Advance to the next parameter\n-                implPTypes = implPTypes.tail;\n-                samPTypes = samPTypes.tail;\n-                descPTypes = descPTypes.tail;\n-            }\n-            \/\/ Flatten out the var args\n-            for (int i = last; i < samSize; ++i) {\n-                addParameter(\"xva$\" + i, tree.varargsElement, true);\n-            }\n-\n-            return rcvr;\n-        }\n-\n-        JCExpression getReceiverExpression() {\n-            return receiverExpression;\n-        }\n-\n-        private JCExpression makeReceiver(VarSymbol rcvr) {\n-            if (rcvr == null) return null;\n-            JCExpression rcvrExpr = make.Ident(rcvr);\n-            boolean protAccess =\n-                    isProtectedInSuperClassOfEnclosingClassInOtherPackage(tree.sym, owner);\n-            Type rcvrType = tree.ownerAccessible && !protAccess ? tree.sym.enclClass().type\n-                                                                : tree.expr.type;\n-            if (rcvrType == syms.arrayClass.type) {\n-                \/\/ Map the receiver type to the actually type, not just \"array\"\n-                rcvrType = tree.getQualifierExpression().type;\n-            }\n-            if (!rcvr.type.tsym.isSubClass(rcvrType.tsym, types)) {\n-                rcvrExpr = make.TypeCast(make.Type(rcvrType), rcvrExpr).setType(rcvrType);\n-            }\n-            return rcvrExpr;\n-        }\n-\n-        \/**\n-         * determine the receiver of the method call - the receiver can\n-         * be a type qualifier, the synthetic receiver parameter or 'super'.\n-         *\/\n-        private JCExpression expressionInvoke(VarSymbol rcvr) {\n-            JCExpression qualifier =\n-                    (rcvr != null) ?\n-                        makeReceiver(rcvr) :\n-                        tree.getQualifierExpression();\n-\n-            \/\/create the qualifier expression\n-            JCFieldAccess select = make.Select(qualifier, tree.sym.name);\n-            select.sym = tree.sym;\n-            select.type = tree.sym.erasure(types);\n-\n-            \/\/create the method call expression\n-            JCExpression apply = make.Apply(List.nil(), select,\n-                    convertArgs(tree.sym, args.toList(), tree.varargsElement)).\n-                    setType(tree.sym.erasure(types).getReturnType());\n-\n-            apply = transTypes.coerce(attrEnv, apply,\n-                    types.erasure(localContext.tree.referentType.getReturnType()));\n-\n-            setVarargsIfNeeded(apply, tree.varargsElement);\n-            return apply;\n-        }\n-\n-        \/**\n-         * Lambda body to use for a 'new'.\n-         *\/\n-        private JCExpression expressionNew() {\n-            if (tree.kind == ReferenceKind.ARRAY_CTOR) {\n-                \/\/create the array creation expression\n-                JCNewArray newArr = make.NewArray(\n-                        make.Type(types.elemtype(tree.getQualifierExpression().type)),\n-                        List.of(make.Ident(params.first())),\n-                        null);\n-                newArr.type = tree.getQualifierExpression().type;\n-                return newArr;\n-            } else {\n-                \/\/create the instance creation expression\n-                \/\/note that method reference syntax does not allow an explicit\n-                \/\/enclosing class (so the enclosing class is null)\n-                \/\/ but this may need to be patched up later with the proxy for the outer this\n-                JCNewClass newClass = make.NewClass(null,\n-                        List.nil(),\n-                        make.Type(tree.getQualifierExpression().type),\n-                        convertArgs(tree.sym, args.toList(), tree.varargsElement),\n-                        null);\n-                newClass.constructor = tree.sym;\n-                newClass.constructorType = tree.sym.erasure(types);\n-                newClass.type = tree.getQualifierExpression().type;\n-                setVarargsIfNeeded(newClass, tree.varargsElement);\n-                return newClass;\n-            }\n-        }\n-\n-        private VarSymbol addParameter(String name, Type p, boolean genArg) {\n-            VarSymbol vsym = new VarSymbol(PARAMETER | SYNTHETIC, names.fromString(name), p, owner);\n-            vsym.pos = tree.pos;\n-            params.append(make.VarDef(vsym, null));\n-            if (genArg) {\n-                args.append(make.Ident(vsym));\n-            }\n-            return vsym;\n-        }\n-    }\n-\n@@ -1241,5 +936,0 @@\n-        \/**\n-         * List of types undergoing construction, i.e., in an early construction context.\n-         *\/\n-        private List<ClassSymbol> typesUnderConstruction;\n-\n@@ -1276,1 +966,0 @@\n-            typesUnderConstruction = List.nil();\n@@ -1281,19 +970,0 @@\n-        @Override\n-        public void visitApply(JCMethodInvocation tree) {\n-            super.visitApply(tree);\n-            if (TreeInfo.isConstructorCall(tree)) {\n-                Assert.check(typesUnderConstruction.head == currentClass());\n-                typesUnderConstruction = typesUnderConstruction.tail;   \/\/ end of early construction context\n-            }\n-        }\n-            \/\/ where\n-            private ClassSymbol currentClass() {\n-                for (Frame frame : frameStack) {\n-                    if (frame.tree.hasTag(JCTree.Tag.CLASSDEF)) {\n-                        JCClassDecl cdef = (JCClassDecl) frame.tree;\n-                        return cdef.sym;\n-                    }\n-                }\n-                return null;\n-            }\n-\n@@ -1332,15 +1002,0 @@\n-                    if (tree.sym.hasOuterInstance()) {\n-                        \/\/if a class is defined within a lambda, the lambda must capture\n-                        \/\/its enclosing instance (if any)\n-                        TranslationContext<?> localContext = context();\n-                        final TypeSymbol outerInstanceSymbol = tree.sym.type.getEnclosingType().tsym;\n-                        while (localContext != null && !localContext.owner.isStatic()) {\n-                            if (localContext.tree.hasTag(LAMBDA)) {\n-                                JCTree block = capturedDecl(localContext.depth, outerInstanceSymbol);\n-                                if (block == null) break;\n-                                ((LambdaTranslationContext)localContext)\n-                                        .addSymbol(outerInstanceSymbol, CAPTURED_THIS);\n-                            }\n-                            localContext = localContext.prev;\n-                        }\n-                    }\n@@ -1401,10 +1056,1 @@\n-            analyzeLambda(tree, \"lambda.stat\");\n-        }\n-\n-        private void analyzeLambda(JCLambda tree, JCExpression methodReferenceReceiver) {\n-            \/\/ Translation of the receiver expression must occur first\n-            JCExpression rcvr = translate(methodReferenceReceiver);\n-            LambdaTranslationContext context = analyzeLambda(tree, \"mref.stat.1\");\n-            if (rcvr != null) {\n-                context.methodReferenceReceiver = rcvr;\n-            }\n+            analyzeLambda(tree, tree.wasMethodReference ? \"mref.stat.1\" : \"lambda.stat\");\n@@ -1437,1 +1083,0 @@\n-            List<ClassSymbol> prevTypesUnderConstruction = typesUnderConstruction;\n@@ -1440,2 +1085,0 @@\n-                if (TreeInfo.isConstructor(tree))       \/\/ start early construction context (Object() notwithstanding)\n-                    typesUnderConstruction = typesUnderConstruction.prepend(currentClass());\n@@ -1444,25 +1087,0 @@\n-            } finally {\n-                frameStack = prevStack;\n-                typesUnderConstruction = prevTypesUnderConstruction;\n-            }\n-        }\n-\n-        @Override\n-        public void visitNewClass(JCNewClass tree) {\n-            TypeSymbol def = tree.type.tsym;\n-            boolean inReferencedClass = currentlyInClass(def);\n-            boolean isLocal = def.isDirectlyOrIndirectlyLocal();\n-            if ((inReferencedClass && isLocal || lambdaNewClassFilter(context(), tree))) {\n-                TranslationContext<?> localContext = context();\n-                final TypeSymbol outerInstanceSymbol = tree.type.getEnclosingType().tsym;\n-                while (localContext != null  && !localContext.owner.isStatic()) {\n-                    if (localContext.tree.hasTag(LAMBDA)) {\n-                        if (outerInstanceSymbol != null) {\n-                            JCTree block = capturedDecl(localContext.depth, outerInstanceSymbol);\n-                            if (block == null) break;\n-                        }\n-                        ((LambdaTranslationContext)localContext)\n-                                .addSymbol(outerInstanceSymbol, CAPTURED_THIS);\n-                    }\n-                    localContext = localContext.prev;\n-                }\n@@ -1470,44 +1088,2 @@\n-            super.visitNewClass(tree);\n-            if (context() != null && !inReferencedClass && isLocal) {\n-                LambdaTranslationContext lambdaContext = (LambdaTranslationContext)context();\n-                captureLocalClassDefs(def, lambdaContext);\n-            }\n-        }\n-        \/\/where\n-            void captureLocalClassDefs(Symbol csym, final LambdaTranslationContext lambdaContext) {\n-                JCClassDecl localCDef = localClassDefs.get(csym);\n-                if (localCDef != null && lambdaContext.freeVarProcessedLocalClasses.add(csym)) {\n-                    BasicFreeVarCollector fvc = lower.new BasicFreeVarCollector() {\n-                        @Override\n-                        void addFreeVars(ClassSymbol c) {\n-                            captureLocalClassDefs(c, lambdaContext);\n-                        }\n-                        @Override\n-                        void visitSymbol(Symbol sym) {\n-                            if (sym.kind == VAR &&\n-                                    sym.owner.kind == MTH &&\n-                                    ((VarSymbol)sym).getConstValue() == null) {\n-                                TranslationContext<?> localContext = context();\n-                                while (localContext != null) {\n-                                    if (localContext.tree.getTag() == LAMBDA) {\n-                                        JCTree block = capturedDecl(localContext.depth, sym);\n-                                        if (block == null) break;\n-                                        ((LambdaTranslationContext)localContext).addSymbol(sym, CAPTURED_VAR);\n-                                    }\n-                                    localContext = localContext.prev;\n-                                }\n-                            }\n-                        }\n-                    };\n-                    fvc.scan(localCDef);\n-                }\n-        }\n-        \/\/where\n-        boolean currentlyInClass(Symbol csym) {\n-            for (Frame frame : frameStack) {\n-                if (frame.tree.hasTag(JCTree.Tag.CLASSDEF)) {\n-                    JCClassDecl cdef = (JCClassDecl) frame.tree;\n-                    if (cdef.sym == csym) {\n-                        return true;\n-                    }\n-                }\n+            finally {\n+                frameStack = prevStack;\n@@ -1515,1 +1091,0 @@\n-            return false;\n@@ -1534,9 +1109,3 @@\n-            if (rcontext.needsConversionToLambda()) {\n-                 \/\/ Convert to a lambda, and process as such\n-                MemberReferenceToLambda conv = new MemberReferenceToLambda(tree, rcontext, owner());\n-                analyzeLambda(conv.lambda(), conv.getReceiverExpression());\n-            } else {\n-                super.visitReference(tree);\n-                if (dumpLambdaToMethodStats) {\n-                    log.note(tree, Notes.MrefStat(rcontext.needsAltMetafactory(), null));\n-                }\n+            super.visitReference(tree);\n+            if (dumpLambdaToMethodStats) {\n+                log.note(tree, Notes.MrefStat(rcontext.needsAltMetafactory(), null));\n@@ -1776,36 +1345,0 @@\n-        \/**\n-         *  This is used to filter out those select nodes that need to be adjusted\n-         *  when translating away lambda expressions - at the moment, this is the\n-         *  set of nodes that select `this' (qualified this)\n-         *\/\n-        private boolean lambdaFieldAccessFilter(JCFieldAccess fAccess) {\n-            return (context instanceof LambdaTranslationContext lambdaContext)\n-                    && !fAccess.sym.isStatic()\n-                    && fAccess.name == names._this\n-                    && (fAccess.sym.owner.kind == TYP)\n-                    && !lambdaContext.translatedSymbols.get(CAPTURED_OUTER_THIS).isEmpty();\n-        }\n-\n-        \/**\n-         * This is used to filter out those new class expressions that need to\n-         * be qualified with an enclosing tree\n-         *\/\n-        private boolean lambdaNewClassFilter(TranslationContext<?> context, JCNewClass tree) {\n-            if (context != null\n-                    && tree.encl == null\n-                    && tree.def == null\n-                    && !tree.type.getEnclosingType().hasTag(NONE)) {\n-                Type encl = tree.type.getEnclosingType();\n-                Type current = context.owner.enclClass().type;\n-                while (!current.hasTag(NONE)) {\n-                    if (current.tsym.isSubClass(encl.tsym, types)) {\n-                        return true;\n-                    }\n-                    current = current.getEnclosingType();\n-                }\n-                return false;\n-            } else {\n-                return false;\n-            }\n-        }\n-\n@@ -1921,12 +1454,0 @@\n-            \/**\n-             * to prevent recursion, track local classes processed\n-             *\/\n-            final Set<Symbol> freeVarProcessedLocalClasses;\n-\n-            \/**\n-             * For method references converted to lambdas.  The method\n-             * reference receiver expression. Must be treated like a captured\n-             * variable.\n-             *\/\n-            JCExpression methodReferenceReceiver;\n-\n@@ -1963,7 +1484,4 @@\n-                translatedSymbols.put(PARAM, new LinkedHashMap<Symbol, Symbol>());\n-                translatedSymbols.put(LOCAL_VAR, new LinkedHashMap<Symbol, Symbol>());\n-                translatedSymbols.put(CAPTURED_VAR, new LinkedHashMap<Symbol, Symbol>());\n-                translatedSymbols.put(CAPTURED_THIS, new LinkedHashMap<Symbol, Symbol>());\n-                translatedSymbols.put(CAPTURED_OUTER_THIS, new LinkedHashMap<Symbol, Symbol>());\n-\n-                freeVarProcessedLocalClasses = new HashSet<>();\n+                translatedSymbols.put(PARAM, new LinkedHashMap<>());\n+                translatedSymbols.put(LOCAL_VAR, new LinkedHashMap<>());\n+                translatedSymbols.put(CAPTURED_VAR, new LinkedHashMap<>());\n+                translatedSymbols.put(CAPTURED_THIS, new LinkedHashMap<>());\n@@ -2069,10 +1587,0 @@\n-                    case CAPTURED_OUTER_THIS:\n-                        Name name = names.fromString(sym.flatName().toString().replace('.', '$') + names.dollarThis);\n-                        ret = new VarSymbol(SYNTHETIC | FINAL | PARAMETER, name, types.erasure(sym.type), translatedSym) {\n-                            @Override\n-                            public Symbol baseSymbol() {\n-                                \/\/keep mapping with original captured symbol\n-                                return sym;\n-                            }\n-                        };\n-                        break;\n@@ -2117,8 +1625,0 @@\n-                if (skind == CAPTURED_THIS && sym != null && sym.kind == TYP && !typesUnderConstruction.isEmpty()) {\n-                    ClassSymbol currentClass = currentClass();\n-                    if (currentClass != null && typesUnderConstruction.contains(currentClass)) {\n-                        \/\/ reference must be to enclosing outer instance, mutate capture kind.\n-                        Assert.check(sym != currentClass); \/\/ should have been caught right in Attr\n-                        skind = CAPTURED_OUTER_THIS;\n-                    }\n-                }\n@@ -2148,14 +1648,0 @@\n-                        case CAPTURED_OUTER_THIS:\n-                            Optional<Symbol> proxy = m.keySet().stream()\n-                                    .filter(out -> lambdaIdent.sym.isMemberOf(out.type.tsym, types))\n-                                    .reduce((a, b) -> a.isEnclosedBy((ClassSymbol)b) ? a : b);\n-                            if (proxy.isPresent()) {\n-                                \/\/ Transform outer instance variable references anchoring them to the captured synthetic.\n-                                Symbol tSym = m.get(proxy.get());\n-                                JCExpression t = make.Ident(tSym).setType(lambdaIdent.sym.owner.type);\n-                                t = make.Select(t, lambdaIdent.name);\n-                                t.setType(lambdaIdent.type);\n-                                TreeInfo.setSymbol(t, lambdaIdent.sym);\n-                                return t;\n-                            }\n-                            break;\n@@ -2167,29 +1653,0 @@\n-            \/* Translate away qualified this expressions, anchoring them to synthetic parameters that\n-               capture the qualified this handle. `fieldAccess' is guaranteed to one such.\n-            *\/\n-            public JCTree translate(JCFieldAccess fieldAccess) {\n-                Assert.check(fieldAccess.name == names._this);\n-                Map<Symbol, Symbol> m = translatedSymbols.get(LambdaSymbolKind.CAPTURED_OUTER_THIS);\n-                if (m.containsKey(fieldAccess.sym.owner)) {\n-                    Symbol tSym = m.get(fieldAccess.sym.owner);\n-                    JCExpression t = make.Ident(tSym).setType(fieldAccess.sym.owner.type);\n-                    return t;\n-                }\n-                return null;\n-            }\n-\n-            \/* Translate away naked new instance creation expressions with implicit enclosing instances,\n-               anchoring them to synthetic parameters that stand proxy for the qualified outer this handle.\n-            *\/\n-            public JCNewClass translate(JCNewClass newClass) {\n-                Assert.check(newClass.clazz.type.tsym.hasOuterInstance() && newClass.encl == null);\n-                Map<Symbol, Symbol> m = translatedSymbols.get(LambdaSymbolKind.CAPTURED_OUTER_THIS);\n-                final Type enclosingType = newClass.clazz.type.getEnclosingType();\n-                if (m.containsKey(enclosingType.tsym)) {\n-                      Symbol tSym = m.get(enclosingType.tsym);\n-                      JCExpression encl = make.Ident(tSym).setType(enclosingType);\n-                      newClass.encl = encl;\n-                }\n-                return newClass;\n-            }\n-\n@@ -2233,4 +1690,0 @@\n-                for (Symbol thisSym : getSymbolMap(CAPTURED_OUTER_THIS).values()) {\n-                    params.append(make.VarDef((VarSymbol) thisSym, null));\n-                    parameterSymbols.append((VarSymbol) thisSym);\n-                }\n@@ -2262,4 +1715,1 @@\n-         * This class retains all the useful information about a method reference;\n-         * the contents of this class are filled by the LambdaAnalyzer visitor,\n-         * and the used by the main translation routines in order to adjust method\n-         * references (i.e. in case a bridge is needed)\n+         * Simple subclass modelling the translation context of a method reference.\n@@ -2269,2 +1719,0 @@\n-            final boolean isSuper;\n-\n@@ -2273,85 +1721,0 @@\n-                this.isSuper = tree.hasKind(ReferenceKind.SUPER);\n-            }\n-\n-            boolean needsVarArgsConversion() {\n-                return tree.varargsElement != null;\n-            }\n-\n-            \/**\n-             * @return Is this an array operation like clone()\n-             *\/\n-            boolean isArrayOp() {\n-                return tree.sym.owner == syms.arrayClass;\n-            }\n-\n-            boolean receiverAccessible() {\n-                \/\/hack needed to workaround 292 bug (7087658)\n-                \/\/when 292 issue is fixed we should remove this and change the backend\n-                \/\/code to always generate a method handle to an accessible method\n-                return tree.ownerAccessible;\n-            }\n-\n-            \/**\n-             * This method should be called only when target release <= 14\n-             * where LambdaMetaFactory does not spin nestmate classes.\n-             *\n-             * This method should be removed when --release 14 is not supported.\n-             *\/\n-            boolean isPrivateInOtherClass() {\n-                assert !nestmateLambdas;\n-                return  (tree.sym.flags() & PRIVATE) != 0 &&\n-                        !types.isSameType(\n-                              types.erasure(tree.sym.enclClass().asType()),\n-                              types.erasure(owner.enclClass().asType()));\n-            }\n-\n-            \/**\n-             * Erasure destroys the implementation parameter subtype\n-             * relationship for intersection types.\n-             * Have similar problems for union types too.\n-             *\/\n-            boolean interfaceParameterIsIntersectionOrUnionType() {\n-                List<Type> tl = tree.getDescriptorType(types).getParameterTypes();\n-                for (; tl.nonEmpty(); tl = tl.tail) {\n-                    Type pt = tl.head;\n-                    if (isIntersectionOrUnionType(pt))\n-                        return true;\n-                }\n-                return false;\n-            }\n-\n-            boolean isIntersectionOrUnionType(Type t) {\n-                switch (t.getKind()) {\n-                    case INTERSECTION:\n-                    case UNION:\n-                        return true;\n-                    case TYPEVAR:\n-                        TypeVar tv = (TypeVar) t;\n-                        return isIntersectionOrUnionType(tv.getUpperBound());\n-                }\n-                return false;\n-            }\n-\n-            \/**\n-             * Does this reference need to be converted to a lambda\n-             * (i.e. var args need to be expanded or \"super\" is used)\n-             *\/\n-            final boolean needsConversionToLambda() {\n-                return interfaceParameterIsIntersectionOrUnionType() ||\n-                        isSuper ||\n-                        needsVarArgsConversion() ||\n-                        isArrayOp() ||\n-                        (!nestmateLambdas && isPrivateInOtherClass()) ||\n-                        isProtectedInSuperClassOfEnclosingClassInOtherPackage(tree.sym, owner) ||\n-                        !receiverAccessible() ||\n-                        (tree.getMode() == ReferenceMode.NEW &&\n-                          tree.kind != ReferenceKind.ARRAY_CTOR &&\n-                          (tree.sym.owner.isDirectlyOrIndirectlyLocal() || tree.sym.owner.isInner()));\n-            }\n-\n-            Type generatedRefSig() {\n-                return types.erasure(tree.sym.type);\n-            }\n-\n-            Type bridgedRefSig() {\n-                return types.erasure(types.findDescriptorSymbol(tree.target.tsym).type);\n@@ -2371,2 +1734,1 @@\n-        CAPTURED_THIS,  \/\/ class symbols to translated synthetic parameters (for captured member access)\n-        CAPTURED_OUTER_THIS; \/\/ used when `this' capture is illegal, but outer this capture is legit (JDK-8129740)\n+        CAPTURED_THIS;  \/\/ class symbols to translated synthetic parameters (for captured member access)\n@@ -2378,1 +1740,0 @@\n-                case CAPTURED_OUTER_THIS:\n@@ -2420,6 +1781,0 @@\n-    private boolean isProtectedInSuperClassOfEnclosingClassInOtherPackage(Symbol targetReference,\n-                                                                          Symbol currentClass) {\n-        return ((targetReference.flags() & PROTECTED) != 0 &&\n-                targetReference.packge() != currentClass.packge());\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":15,"deletions":660,"binary":false,"changes":675,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import com.sun.source.tree.LambdaExpressionTree.BodyKind;\n+import com.sun.source.tree.MemberReferenceTree.ReferenceMode;\n@@ -38,0 +40,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.Notes;\n@@ -39,0 +42,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCMemberReference.ReferenceKind;\n@@ -65,0 +69,3 @@\n+\n+import javax.lang.model.type.TypeKind;\n+\n@@ -106,0 +113,1 @@\n+    private int variableIndex = 0;\n@@ -173,0 +181,5 @@\n+    \/**\n+     * The current expected return type.\n+     *\/\n+    Type currentRestype;\n+\n@@ -189,6 +202,0 @@\n-    \/** A map from local variable symbols to their translation (as per LambdaToMethod).\n-     * This is required when a capturing local class is created from a lambda (in which\n-     * case the captured symbols should be replaced with the translated lambda symbols).\n-     *\/\n-    Map<Symbol, Symbol> lambdaTranslationMap = null;\n-\n@@ -1236,8 +1243,4 @@\n-            if (lambdaTranslationMap != null && lambdaTranslationMap.get(sym) != null) {\n-                return make.at(tree.pos).Ident(lambdaTranslationMap.get(sym));\n-            } else {\n-                \/\/ Otherwise replace the variable by its proxy.\n-                sym = proxies.get(sym);\n-                Assert.check(sym != null && (sym.flags_field & FINAL) != 0);\n-                tree = make.at(tree.pos).Ident(sym);\n-            }\n+            \/\/ Otherwise replace the variable by its proxy.\n+            sym = proxies.get(sym);\n+            Assert.check(sym != null && (sym.flags_field & FINAL) != 0);\n+            tree = make.at(tree.pos).Ident(sym);\n@@ -1328,8 +1331,0 @@\n-            } else if (sym.owner.kind == MTH && lambdaTranslationMap != null) {\n-                \/\/sym is a local variable - check the lambda translation map to\n-                \/\/see if sym has been translated to something else in the current\n-                \/\/scope (by LambdaToMethod)\n-                Symbol translatedSym = lambdaTranslationMap.get(sym.baseSymbol());\n-                if (translatedSym != null) {\n-                    tree = make.at(tree.pos).Ident(translatedSym);\n-                }\n@@ -2782,0 +2777,1 @@\n+        Type prevRestype = currentRestype;\n@@ -2784,0 +2780,1 @@\n+        int prevVariableIndex = variableIndex;\n@@ -2785,0 +2782,1 @@\n+            currentRestype = types.erasure(tree.type.getReturnType());\n@@ -2787,0 +2785,1 @@\n+            variableIndex = 0;\n@@ -2789,0 +2788,1 @@\n+            currentRestype = prevRestype;\n@@ -2791,0 +2791,1 @@\n+            variableIndex = prevVariableIndex;\n@@ -2869,10 +2870,1 @@\n-            Map<Symbol, Symbol> prevLambdaTranslationMap =\n-                    lambdaTranslationMap;\n-            try {\n-                lambdaTranslationMap = (tree.sym.flags() & SYNTHETIC) != 0 &&\n-                        tree.sym.name.startsWith(names.lambda) ?\n-                        makeTranslationMap(tree) : null;\n-                super.visitMethodDef(tree);\n-            } finally {\n-                lambdaTranslationMap = prevLambdaTranslationMap;\n-            }\n+            super.visitMethodDef(tree);\n@@ -2904,11 +2896,0 @@\n-    \/\/where\n-        private Map<Symbol, Symbol> makeTranslationMap(JCMethodDecl tree) {\n-            Map<Symbol, Symbol> translationMap = new HashMap<>();\n-            for (JCVariableDecl vd : tree.params) {\n-                Symbol p = vd.sym;\n-                if (p != p.baseSymbol()) {\n-                    translationMap.put(p.baseSymbol(), p);\n-                }\n-            }\n-            return translationMap;\n-        }\n@@ -2976,1 +2957,1 @@\n-                    names.fromString(\"tmp\" + tree.pos + this.target.syntheticNameChar()),\n+                    names.fromString(\"tmp\" + variableIndex++ + this.target.syntheticNameChar()),\n@@ -3135,7 +3116,1 @@\n-            Map<Symbol, Symbol> prevLambdaTranslationMap = lambdaTranslationMap;\n-            try {\n-                lambdaTranslationMap = null;\n-                translate(tree.def);\n-            } finally {\n-                lambdaTranslationMap = prevLambdaTranslationMap;\n-            }\n+            translate(tree.def);\n@@ -3361,0 +3336,3 @@\n+        if (tree.args.stream().anyMatch(c -> c == null)) {\n+            throw new AssertionError(\"Whooops before: \" + tree);\n+        }\n@@ -3848,0 +3826,1 @@\n+        int prevVariableIndex = variableIndex;\n@@ -3857,3 +3836,7 @@\n-        if (tree.init != null) tree.init = translate(tree.init, tree.type);\n-        result = tree;\n-        currentMethodSym = oldMethodSym;\n+        try {\n+            if (tree.init != null) tree.init = translate(tree.init, tree.type);\n+            result = tree;\n+        } finally {\n+            currentMethodSym = oldMethodSym;\n+            variableIndex = prevVariableIndex;\n+        }\n@@ -3871,2 +3854,8 @@\n-        super.visitBlock(tree);\n-        currentMethodSym = oldMethodSym;\n+        int prevVariableIndex = variableIndex;\n+        try {\n+            variableIndex = 0;\n+            super.visitBlock(tree);\n+        } finally {\n+            currentMethodSym = oldMethodSym;\n+            variableIndex = prevVariableIndex;\n+        }\n@@ -3899,2 +3888,1 @@\n-                                  types.erasure(currentMethodDef\n-                                                .restype.type));\n+                                  currentRestype);\n@@ -3904,0 +3892,345 @@\n+    @Override\n+    public void visitLambda(JCLambda tree) {\n+        Type prevRestype = currentRestype;\n+        try {\n+            currentRestype = types.findDescriptorType(tree.type).getReturnType();\n+            tree.body = tree.getBodyKind() == BodyKind.EXPRESSION ?\n+                    translate((JCExpression) tree.body, currentRestype) :\n+                    translate(tree.body);\n+        } finally {\n+            currentRestype = prevRestype;\n+        }\n+        result = tree;\n+    }\n+\n+    @Override\n+    public void visitReference(JCMemberReference tree) {\n+        if (needsConversionToLambda(tree)) {\n+            \/\/ Convert to a lambda, and process as such\n+            MemberReferenceToLambda conv = new MemberReferenceToLambda(tree);\n+            result = translate(conv.lambda());\n+        } else {\n+            super.visitReference(tree);\n+        }\n+    }\n+    \/\/ where\n+        boolean needsVarArgsConversion(JCMemberReference tree) {\n+            return tree.varargsElement != null;\n+        }\n+\n+        \/**\n+         * @return Is this an array operation like clone()\n+         *\/\n+        boolean isArrayOp(JCMemberReference tree) {\n+            return tree.sym.owner == syms.arrayClass;\n+        }\n+\n+        boolean receiverAccessible(JCMemberReference tree) {\n+            \/\/hack needed to workaround 292 bug (7087658)\n+            \/\/when 292 issue is fixed we should remove this and change the backend\n+            \/\/code to always generate a method handle to an accessible method\n+            return tree.ownerAccessible;\n+        }\n+\n+        \/**\n+         * Erasure destroys the implementation parameter subtype\n+         * relationship for intersection types.\n+         * Have similar problems for union types too.\n+         *\/\n+        boolean interfaceParameterIsIntersectionOrUnionType(JCMemberReference tree) {\n+            List<Type> tl = tree.getDescriptorType(types).getParameterTypes();\n+            for (; tl.nonEmpty(); tl = tl.tail) {\n+                Type pt = tl.head;\n+                if (isIntersectionOrUnionType(pt))\n+                    return true;\n+            }\n+            return false;\n+        }\n+\n+        boolean isIntersectionOrUnionType(Type t) {\n+            switch (t.getKind()) {\n+                case INTERSECTION:\n+                case UNION:\n+                    return true;\n+                case TYPEVAR:\n+                    TypeVar tv = (TypeVar) t;\n+                    return isIntersectionOrUnionType(tv.getUpperBound());\n+            }\n+            return false;\n+        }\n+\n+        private boolean isProtectedInSuperClassOfEnclosingClassInOtherPackage(Symbol targetReference,\n+                                                                              Symbol currentClass) {\n+            return ((targetReference.flags() & PROTECTED) != 0 &&\n+                    targetReference.packge() != currentClass.packge());\n+        }\n+\n+        \/**\n+         * This method should be called only when target release <= 14\n+         * where LambdaMetaFactory does not spin nestmate classes.\n+         *\n+         * This method should be removed when --release 14 is not supported.\n+         *\/\n+        boolean isPrivateInOtherClass(JCMemberReference tree) {\n+            assert !target.runtimeUseNestAccess();\n+            return  (tree.sym.flags() & PRIVATE) != 0 &&\n+                    !types.isSameType(\n+                            types.erasure(tree.sym.enclClass().asType()),\n+                            types.erasure(currentClass.asType()));\n+        }\n+\n+        \/**\n+         * Does this reference need to be converted to a lambda\n+         * (i.e. var args need to be expanded or \"super\" is used)\n+         *\/\n+        boolean needsConversionToLambda(JCMemberReference tree) {\n+            return interfaceParameterIsIntersectionOrUnionType(tree) ||\n+                    tree.hasKind(ReferenceKind.SUPER) ||\n+                    needsVarArgsConversion(tree) ||\n+                    isArrayOp(tree) ||\n+                    (!target.runtimeUseNestAccess() && isPrivateInOtherClass(tree)) ||\n+                    isProtectedInSuperClassOfEnclosingClassInOtherPackage(tree.sym, currentClass) ||\n+                    !receiverAccessible(tree) ||\n+                    (tree.getMode() == ReferenceMode.NEW &&\n+                            tree.kind != ReferenceKind.ARRAY_CTOR &&\n+                            (tree.sym.owner.isDirectlyOrIndirectlyLocal() || tree.sym.owner.isInner()));\n+        }\n+\n+    \/**\n+     * Converts a method reference which cannot be used directly into a lambda\n+     *\/\n+    private class MemberReferenceToLambda {\n+\n+        private final JCMemberReference tree;\n+        private final ListBuffer<JCExpression> args = new ListBuffer<>();\n+        private final ListBuffer<JCVariableDecl> params = new ListBuffer<>();\n+        private final MethodSymbol owner = new MethodSymbol(0, names.empty, Type.noType, currentClass);\n+\n+        private JCExpression receiverExpression = null;\n+\n+        MemberReferenceToLambda(JCMemberReference tree) {\n+            this.tree = tree;\n+        }\n+\n+        JCExpression lambda() {\n+            int prevPos = make.pos;\n+            try {\n+                make.at(tree);\n+\n+                \/\/body generation - this can be either a method call or a\n+                \/\/new instance creation expression, depending on the member reference kind\n+                VarSymbol rcvr = addParametersReturnReceiver();\n+                JCExpression expr = (tree.getMode() == ReferenceMode.INVOKE)\n+                        ? expressionInvoke(rcvr)\n+                        : expressionNew();\n+\n+                JCLambda slam = make.Lambda(params.toList(), expr);\n+                slam.target = tree.target;\n+                slam.type = tree.type;\n+                slam.pos = tree.pos;\n+                slam.wasMethodReference = true;\n+                if (receiverExpression != null) {\n+                    \/\/ use a let expression so that the receiver expression is evaluated eagerly\n+                    return make.at(tree.pos).LetExpr(\n+                            make.VarDef(rcvr, translate(receiverExpression)), slam).setType(tree.type);\n+                } else {\n+                    return slam;\n+                }\n+            } finally {\n+                make.at(prevPos);\n+            }\n+        }\n+\n+        \/**\n+         * Generate the parameter list for the converted member reference.\n+         *\n+         * @return The receiver variable symbol, if any\n+         *\/\n+        VarSymbol addParametersReturnReceiver() {\n+            Type samDesc = types.erasure(types.findDescriptorSymbol(tree.target.tsym).type);\n+            List<Type> samPTypes = samDesc.getParameterTypes();\n+            List<Type> descPTypes = tree.getDescriptorType(types).getParameterTypes();\n+\n+            \/\/ Determine the receiver, if any\n+            VarSymbol rcvr;\n+            switch (tree.kind) {\n+                case BOUND:\n+                    \/\/ The receiver is explicit in the method reference\n+                    rcvr = new VarSymbol(SYNTHETIC, names.fromString(\"rec$\"), tree.getQualifierExpression().type, owner);\n+                    rcvr.pos = tree.pos;\n+                    receiverExpression = attr.makeNullCheck(tree.getQualifierExpression());\n+                    break;\n+                case UNBOUND:\n+                    \/\/ The receiver is the first parameter, extract it and\n+                    \/\/ adjust the SAM and unerased type lists accordingly\n+                    rcvr = addParameter(\"rec$\", samDesc.getParameterTypes().head, false);\n+                    samPTypes = samPTypes.tail;\n+                    descPTypes = descPTypes.tail;\n+                    break;\n+                default:\n+                    rcvr = null;\n+                    break;\n+            }\n+            List<Type> implPTypes = tree.sym.type.getParameterTypes();\n+            int implSize = implPTypes.size();\n+            int samSize = samPTypes.size();\n+            \/\/ Last parameter to copy from referenced method, exclude final var args\n+            int last = needsVarArgsConversion(tree) ? implSize - 1 : implSize;\n+\n+            \/\/ Failsafe -- assure match-up\n+            boolean checkForIntersection = tree.varargsElement != null || implSize == descPTypes.size();\n+\n+            \/\/ Use parameter types of the implementation method unless the unerased\n+            \/\/ SAM parameter type is an intersection type, in that case use the\n+            \/\/ erased SAM parameter type so that the supertype relationship\n+            \/\/ the implementation method parameters is not obscured.\n+            \/\/ Note: in this loop, the lists implPTypes, samPTypes, and descPTypes\n+            \/\/ are used as pointers to the current parameter type information\n+            \/\/ and are thus not usable afterwards.\n+            for (int i = 0; implPTypes.nonEmpty() && i < last; ++i) {\n+                \/\/ By default use the implementation method parameter type\n+                Type parmType = implPTypes.head;\n+                if (checkForIntersection) {\n+                    if (descPTypes.head.getKind() == TypeKind.INTERSECTION) {\n+                        parmType = samPTypes.head;\n+                    }\n+                    \/\/ If the unerased parameter type is a type variable whose\n+                    \/\/ bound is an intersection (eg. <T extends A & B>) then\n+                    \/\/ use the SAM parameter type\n+                    if (descPTypes.head.getKind() == TypeKind.TYPEVAR) {\n+                        TypeVar tv = (TypeVar) descPTypes.head;\n+                        if (tv.getUpperBound().getKind() == TypeKind.INTERSECTION) {\n+                            parmType = samPTypes.head;\n+                        }\n+                    }\n+                }\n+                addParameter(\"x$\" + i, parmType, true);\n+\n+                \/\/ Advance to the next parameter\n+                implPTypes = implPTypes.tail;\n+                samPTypes = samPTypes.tail;\n+                descPTypes = descPTypes.tail;\n+            }\n+            \/\/ Flatten out the var args\n+            for (int i = last; i < samSize; ++i) {\n+                addParameter(\"xva$\" + i, tree.varargsElement, true);\n+            }\n+\n+            return rcvr;\n+        }\n+\n+        private JCExpression makeReceiver(VarSymbol rcvr) {\n+            if (rcvr == null) return null;\n+            JCExpression rcvrExpr = make.Ident(rcvr);\n+            boolean protAccess =\n+                    isProtectedInSuperClassOfEnclosingClassInOtherPackage(tree.sym, currentClass);\n+            Type rcvrType = tree.ownerAccessible && !protAccess ? tree.sym.enclClass().type\n+                    : tree.expr.type;\n+            if (rcvrType == syms.arrayClass.type) {\n+                \/\/ Map the receiver type to the actually type, not just \"array\"\n+                rcvrType = tree.getQualifierExpression().type;\n+            }\n+            if (!rcvr.type.tsym.isSubClass(rcvrType.tsym, types)) {\n+                rcvrExpr = make.TypeCast(make.Type(rcvrType), rcvrExpr).setType(rcvrType);\n+            }\n+            return rcvrExpr;\n+        }\n+\n+        \/**\n+         * determine the receiver of the method call - the receiver can\n+         * be a type qualifier, the synthetic receiver parameter or 'super'.\n+         *\/\n+        private JCExpression expressionInvoke(VarSymbol rcvr) {\n+            JCExpression qualifier =\n+                    (rcvr != null) ?\n+                            makeReceiver(rcvr) :\n+                            tree.getQualifierExpression();\n+\n+            \/\/create the qualifier expression\n+            JCFieldAccess select = make.Select(qualifier, tree.sym.name);\n+            select.sym = tree.sym;\n+            select.type = tree.sym.erasure(types);\n+\n+            \/\/create the method call expression\n+            JCExpression apply = make.Apply(List.nil(), select,\n+                            convertArgs(tree.sym, args.toList(), tree.varargsElement)).\n+                    setType(tree.sym.erasure(types).getReturnType());\n+\n+            apply = transTypes.coerce(attrEnv, apply,\n+                    types.erasure(tree.referentType.getReturnType()));\n+\n+            setVarargsIfNeeded(apply, tree.varargsElement);\n+            return apply;\n+        }\n+\n+        \/**\n+         * Lambda body to use for a 'new'.\n+         *\/\n+        private JCExpression expressionNew() {\n+            if (tree.kind == ReferenceKind.ARRAY_CTOR) {\n+                \/\/create the array creation expression\n+                JCNewArray newArr = make.NewArray(\n+                        make.Type(types.elemtype(tree.getQualifierExpression().type)),\n+                        List.of(make.Ident(params.first())),\n+                        null);\n+                newArr.type = tree.getQualifierExpression().type;\n+                return newArr;\n+            } else {\n+                \/\/create the instance creation expression\n+                \/\/note that method reference syntax does not allow an explicit\n+                \/\/enclosing class (so the enclosing class is null)\n+                \/\/ but this may need to be patched up later with the proxy for the outer this\n+                JCNewClass newClass = make.NewClass(null,\n+                        List.nil(),\n+                        make.Type(tree.getQualifierExpression().type),\n+                        convertArgs(tree.sym, args.toList(), tree.varargsElement),\n+                        null);\n+                newClass.constructor = tree.sym;\n+                newClass.constructorType = tree.sym.erasure(types);\n+                newClass.type = tree.getQualifierExpression().type;\n+                setVarargsIfNeeded(newClass, tree.varargsElement);\n+                return newClass;\n+            }\n+        }\n+\n+        private VarSymbol addParameter(String name, Type p, boolean genArg) {\n+            VarSymbol vsym = new VarSymbol(PARAMETER | SYNTHETIC, names.fromString(name), p, owner);\n+            vsym.pos = tree.pos;\n+            params.append(make.VarDef(vsym, null));\n+            if (genArg) {\n+                args.append(make.Ident(vsym));\n+            }\n+            return vsym;\n+        }\n+    }\n+\n+    \/**\n+     * Convert method\/constructor arguments by inserting appropriate cast\n+     * as required by type-erasure - this is needed when bridging a lambda\/method\n+     * reference, as the bridged signature might require downcast to be compatible\n+     * with the generated signature.\n+     *\/\n+    private List<JCExpression> convertArgs(Symbol meth, List<JCExpression> args, Type varargsElement) {\n+        Assert.check(meth.kind == MTH);\n+        List<Type> formals = types.erasure(meth.type).getParameterTypes();\n+        if (varargsElement != null) {\n+            Assert.check((meth.flags() & VARARGS) != 0);\n+        }\n+        return transTypes.translateArgs(args, formals, varargsElement, attrEnv);\n+    }\n+\n+    \/**\n+     * Set varargsElement field on a given tree (must be either a new class tree\n+     * or a method call tree)\n+     *\/\n+    private void setVarargsIfNeeded(JCTree tree, Type varargsElement) {\n+        if (varargsElement != null) {\n+            switch (tree.getTag()) {\n+                case APPLY: ((JCMethodInvocation)tree).varargsElement = varargsElement; break;\n+                case NEWCLASS: ((JCNewClass)tree).varargsElement = varargsElement; break;\n+                case TYPECAST: setVarargsIfNeeded(((JCTypeCast) tree).expr, varargsElement); break;\n+                default: throw new AssertionError();\n+            }\n+        }\n+    }\n+\n@@ -4021,1 +4354,1 @@\n-                                               names.fromString(\"s\" + tree.pos + this.target.syntheticNameChar()),\n+                                               names.fromString(\"s\" + variableIndex++ + this.target.syntheticNameChar()),\n@@ -4178,1 +4511,1 @@\n-                                               names.fromString(\"s\" + tree.pos + target.syntheticNameChar()),\n+                                               names.fromString(\"s\" + variableIndex++ + target.syntheticNameChar()),\n@@ -4184,1 +4517,1 @@\n-                                                 names.fromString(\"tmp\" + tree.pos + target.syntheticNameChar()),\n+                                                 names.fromString(\"tmp\" + variableIndex++ + target.syntheticNameChar()),\n@@ -4326,1 +4659,1 @@\n-                                               names.fromString(\"s\" + tree.pos + this.target.syntheticNameChar()),\n+                                               names.fromString(\"s\" + variableIndex++ + this.target.syntheticNameChar()),\n@@ -4384,1 +4717,1 @@\n-        if (tree.name == names._class) {\n+        if (tree.name == names._class && tree.selected.type.isPrimitiveOrVoid()) {\n@@ -4460,0 +4793,1 @@\n+            currentRestype = null;\n@@ -4489,0 +4823,1 @@\n+            currentRestype = null;\n@@ -4508,0 +4843,19 @@\n+\n+    \/\/ needed for the lambda deserialization method, which is expressed as a big switch on strings\n+    public JCMethodDecl translateMethod(Env<AttrContext> env, JCMethodDecl methodDecl, TreeMaker make) {\n+        try {\n+            this.attrEnv = env;\n+            this.make = make;\n+            this.currentClass = methodDecl.sym.enclClass();\n+            proxies = new HashMap<>();\n+            return translate(methodDecl);\n+        } finally {\n+            this.attrEnv = null;\n+            this.make = null;\n+            this.currentClass = null;\n+            \/\/ the two fields below are set when visiting the method\n+            this.currentMethodSym = null;\n+            this.currentMethodDef = null;\n+            this.proxies = null;\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":417,"deletions":63,"binary":false,"changes":480,"status":"modified"},{"patch":"@@ -1621,8 +1621,0 @@\n-            if (scanner.hasLambdas) {\n-                if (shouldStop(CompileState.UNLAMBDA))\n-                    return;\n-\n-                env.tree = LambdaToMethod.instance(context).translateTopLevelClass(env, env.tree, localMake);\n-                compileStates.put(env, CompileState.UNLAMBDA);\n-            }\n-\n@@ -1650,0 +1642,10 @@\n+            if (scanner.hasLambdas) {\n+                if (shouldStop(CompileState.UNLAMBDA))\n+                    return;\n+\n+                for (JCTree def : cdefs) {\n+                    LambdaToMethod.instance(context).translateTopLevelClass(env, def, localMake);\n+                }\n+                compileStates.put(env, CompileState.UNLAMBDA);\n+            }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2016,0 +2016,1 @@\n+        public boolean wasMethodReference;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -347,0 +347,1 @@\n+            result = tree;\n@@ -352,0 +353,1 @@\n+            result = tree;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8333766\n+ * @summary Test for compiler crash when anonymous class created in early lambda\n+ *\/\n+\n+public class AnonSuperLambdaCrash {\n+    class Inner {\n+        Inner() {\n+            this(() -> new Object() { { AnonSuperLambdaCrash.this.hashCode(); } });\n+        }\n+        Inner(Runnable r) {\n+            r.run();\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new AnonSuperLambdaCrash().new Inner();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/AnonSuperLambdaCrash.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8333313\n+ * @summary Verify references to local classes declared in early construction contexts\n+ * @enablePreview\n+ *\/\n+public class EarlyLocalTest1 {\n+\n+    class Test {\n+        Test() {\n+            class InnerLocal { }\n+            Runnable r = () -> new InnerLocal();\n+            r.run();\n+            super();\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new EarlyLocalTest1().new Test();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyLocalTest1.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8333313\n+ * @summary Verify references to local classes declared in early construction contexts\n+ * @enablePreview\n+ *\/\n+public class EarlyLocalTest4 {\n+\n+    class Test {\n+        Test() {\n+            class InnerLocal { }\n+            Runnable r = new Runnable() {\n+                public void run() {\n+                    new InnerLocal();\n+                }\n+            };\n+            r.run();\n+            super();\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new EarlyLocalTest4().new Test();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyLocalTest4.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8333313\n+ * @summary Verify references to local classes declared in early construction contexts\n+ * @enablePreview\n+ *\/\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public class EarlyLocalTest5 {\n+\n+    int y;\n+\n+    class Test extends AtomicReference<Runnable> {\n+        Test(int x) {\n+            class Foo implements Runnable {\n+                public void run() {\n+                    System.out.println(x + y);\n+                }\n+            }\n+            super(new Foo());\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new EarlyLocalTest5().new Test(42);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyLocalTest5.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8333313\n+ * @summary Verify references to local classes declared in early construction contexts\n+ * @enablePreview\n+ *\/\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public class EarlyLocalTest6 {\n+\n+    int y;\n+\n+    class Test extends AtomicReference<Runnable> {\n+        Test(int x) {\n+            super(new Runnable() {\n+                public void run() {\n+                    System.out.println(x + y);\n+                }\n+            });\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new EarlyLocalTest6().new Test(42);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyLocalTest6.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8333313\n+ * @summary Verify references to local classes declared in early construction contexts\n+ * @enablePreview\n+ *\/\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public class EarlyLocalTest7 {\n+\n+    int y;\n+\n+    class Test extends AtomicReference<Runnable> {\n+        Test(int x) {\n+            super(() -> System.out.println(x + y));\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new EarlyLocalTest7().new Test(42);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyLocalTest7.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8334037\n+ * @summary Test for compiler crash when local class created in early lambda\n+ * @enablePreview\n+ *\/\n+\n+public class LambdaLocalEarlyCrash {\n+    interface A { }\n+\n+    class Inner {\n+       Inner() {\n+          this(() -> {\n+             class Local {\n+                void g() {\n+                   m();\n+                }\n+             }\n+             new Local().g(); \/\/ error\n+          });\n+       }\n+\n+       Inner(Runnable tr) {\n+          tr.run();\n+       }\n+    }\n+\n+    void m() {\n+       System.out.println(\"Hello\");\n+    }\n+\n+    public static void main(String[] args) {\n+       new LambdaLocalEarlyCrash().new Inner();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/LambdaLocalEarlyCrash.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 8194743\n+ * @bug 8334252\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/LambdaOuterCapture.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,1 +72,15 @@\n-                    this(name, moonsCount, java.lang.invoke.LambdaMetafactory.metafactory(name, Universe.Galaxy.this, Universe.Galaxy.SolarSystem.this));\n+                    this(name, moonsCount, ()->{\n+                        String n = name;\n+                        StringBuffer buf = new StringBuffer();\n+                        buf.append(\"This planet belongs to the galaxy \" + Galaxy.this.name + \" with \" + starsCount + \" stars\\n\");\n+                        buf.append(\"This planet belongs to the galaxy \" + Universe.Galaxy.this.name + \" with \" + starsCount() + \" stars\\n\");\n+                        buf.append(\"This planet belongs to the galaxy \" + Galaxy.this.name() + \" with \" + starsCount() + \" stars\\n\");\n+                        buf.append(\"This planet belongs to the galaxy \" + Universe.Galaxy.this.name() + \" with \" + (Universe.Galaxy.this).starsCount() + \" stars\\n\");\n+                        buf.append(\"This planet belongs to the solar system \" + SolarSystem.this.name + \" with \" + planetsCount + \" planets\\n\");\n+                        buf.append(\"This planet belongs to the solar system \" + Galaxy.SolarSystem.this.name + \" with \" + planetsCount() + \" planets\\n\");\n+                        buf.append(\"This planet belongs to the solar system \" + (SolarSystem.this).name + \" with \" + planetsCount + \" planets\\n\");\n+                        buf.append(\"This planet belongs to the solar system \" + Universe.Galaxy.SolarSystem.this.name + \" with \" + Universe.Galaxy.SolarSystem.this.planetsCount + \" planets\\n\");\n+                        buf.append(\"This planet belongs to the solar system \" + Universe.Galaxy.SolarSystem.this.name.toLowerCase().toUpperCase() + \" with \" + Universe.Galaxy.SolarSystem.this.planetsCount + \" planets\\n\");\n+                        buf.append(\"This planet belongs to the solar system \" + copy(Universe.Galaxy.SolarSystem.this).name.toLowerCase().toUpperCase() + \" with \" + Universe.Galaxy.SolarSystem.this.planetsCount + \" planets\\n\");\n+                        if (!buf.toString().equals(output)) throw new AssertionError(\"Unexpected value\\n\" + buf);\n+                    });\n@@ -79,16 +93,0 @@\n-                \n-                \/*synthetic*\/ private static void lambda$new$0(\/*synthetic*\/ final String name, \/*synthetic*\/ final Universe.Galaxy Universe$Galaxy$this, \/*synthetic*\/ final Universe.Galaxy.SolarSystem Universe$Galaxy$SolarSystem$this) {\n-                    String n = name;\n-                    StringBuffer buf = new StringBuffer();\n-                    buf.append(\"This planet belongs to the galaxy \" + Universe$Galaxy$this.name + \" with \" + Universe$Galaxy$this.starsCount + \" stars\\n\");\n-                    buf.append(\"This planet belongs to the galaxy \" + Universe$Galaxy$this.name + \" with \" + Universe$Galaxy$this.starsCount() + \" stars\\n\");\n-                    buf.append(\"This planet belongs to the galaxy \" + Universe$Galaxy$this.name() + \" with \" + Universe$Galaxy$this.starsCount() + \" stars\\n\");\n-                    buf.append(\"This planet belongs to the galaxy \" + Universe$Galaxy$this.name() + \" with \" + (Universe$Galaxy$this).starsCount() + \" stars\\n\");\n-                    buf.append(\"This planet belongs to the solar system \" + Universe$Galaxy$SolarSystem$this.name + \" with \" + Universe$Galaxy$SolarSystem$this.planetsCount + \" planets\\n\");\n-                    buf.append(\"This planet belongs to the solar system \" + Universe$Galaxy$SolarSystem$this.name + \" with \" + Universe$Galaxy$SolarSystem$this.planetsCount() + \" planets\\n\");\n-                    buf.append(\"This planet belongs to the solar system \" + (Universe$Galaxy$SolarSystem$this).name + \" with \" + Universe$Galaxy$SolarSystem$this.planetsCount + \" planets\\n\");\n-                    buf.append(\"This planet belongs to the solar system \" + Universe$Galaxy$SolarSystem$this.name + \" with \" + Universe$Galaxy$SolarSystem$this.planetsCount + \" planets\\n\");\n-                    buf.append(\"This planet belongs to the solar system \" + Universe$Galaxy$SolarSystem$this.name.toLowerCase().toUpperCase() + \" with \" + Universe$Galaxy$SolarSystem$this.planetsCount + \" planets\\n\");\n-                    buf.append(\"This planet belongs to the solar system \" + Universe$Galaxy$SolarSystem$this.copy(Universe$Galaxy$SolarSystem$this).name.toLowerCase().toUpperCase() + \" with \" + Universe$Galaxy$SolarSystem$this.planetsCount + \" planets\\n\");\n-                    if (!buf.toString().equals(output)) throw new AssertionError(\"Unexpected value\\n\" + buf);\n-                }\n","filename":"test\/langtools\/tools\/javac\/lambda\/T8129740\/Universe.java.out","additions":15,"deletions":17,"binary":false,"changes":32,"status":"modified"}]}