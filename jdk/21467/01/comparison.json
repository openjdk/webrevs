{"files":[{"patch":"@@ -168,3 +168,5 @@\n-     * If 'nowrap' is true then the ZLIB header and checksum fields will\n-     * not be used in order to support the compression format used in\n-     * both GZIP and PKZIP.\n+     * If {@code nowrap} is true then the compressed output will be\n+     * in the raw 'deflate' format, without any ZLIB header or checksum\n+     * fields wrapping the compressed stream. This provides compatibility\n+     * with compression formats used by both GZIP and ZIP.\n+     *\n@@ -172,1 +174,1 @@\n-     * @param nowrap if true then use GZIP compatible compression\n+     * @param nowrap if true then produce a compressed output without ZLIB headers\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Deflater.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -99,7 +99,5 @@\n-     * Creates a new decompressor. If the parameter 'nowrap' is true then\n-     * the ZLIB header and checksum fields will not be used. This provides\n-     * compatibility with the compression format used by both GZIP and PKZIP.\n-     * <p>\n-     * Note: When using the 'nowrap' option it is also necessary to provide\n-     * an extra \"dummy\" byte as input. This is required by the ZLIB native\n-     * library in order to support certain optimizations.\n+     * Creates a new decompressor.\n+     * If {@code nowrap} is true then the compressed input is expected to be\n+     * in the raw 'deflate' format, without any ZLIB header or checksum\n+     * fields wrapping the compressed stream. This provides compatibility\n+     * with compression formats used by both GZIP and ZIP.\n@@ -107,1 +105,1 @@\n-     * @param nowrap if true then support GZIP compatible compression\n+     * @param nowrap if true then expect compressed input without ZLIB headers\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Inflater.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -446,1 +446,0 @@\n-        private boolean eof = false;\n@@ -473,16 +472,0 @@\n-        \/\/ Override fill() method to provide an extra \"dummy\" byte\n-        \/\/ at the end of the input stream. This is required when\n-        \/\/ using the \"nowrap\" Inflater option.\n-        protected void fill() throws IOException {\n-            if (eof) {\n-                throw new EOFException(\"Unexpected end of ZLIB input stream\");\n-            }\n-            len = in.read(buf, 0, buf.length);\n-            if (len == -1) {\n-                buf[0] = 0;\n-                len = 1;\n-                eof = true;\n-            }\n-            inf.setInput(buf, 0, len);\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2465,18 +2465,0 @@\n-                \/\/ Override fill() method to provide an extra \"dummy\" byte\n-                \/\/ at the end of the input stream. This is required when\n-                \/\/ using the \"nowrap\" Inflater option. (it appears the new\n-                \/\/ zlib in 7 does not need it, but keep it for now)\n-                protected void fill() throws IOException {\n-                    if (eof) {\n-                        throw new EOFException(\n-                            \"Unexpected end of ZLIB input stream\");\n-                    }\n-                    len = this.in.read(buf, 0, buf.length);\n-                    if (len == -1) {\n-                        buf[0] = 0;\n-                        len = 1;\n-                        eof = true;\n-                    }\n-                    inf.setInput(buf, 0, len);\n-                }\n-                private boolean eof;\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipFileSystem.java","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"}]}