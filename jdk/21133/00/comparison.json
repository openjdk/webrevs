{"files":[{"patch":"@@ -1181,0 +1181,1 @@\n+        public static final String INDEX_OVERFLOW = \"index overflow\";\n@@ -1218,4 +1219,4 @@\n-        \/\/ Checks the entry at offset pos in the CEN, calculates the Entry values as per above,\n-        \/\/ then returns the length of the entry name.\n-        private int checkAndAddEntry(int pos, int index)\n-            throws ZipException\n+        \/\/ Checks the entry at offset state.pos in the CEN, calculates the Entry values as per above.\n+        \/\/ Returns false if the last entry has been processed\n+        private boolean processNextCENEntry(CENState state)\n+            throws IOException\n@@ -1223,0 +1224,10 @@\n+            int pos = state.pos;\n+            if (pos > state.limit) {\n+                return false;\n+            }\n+            int index = state.idx;\n+            int[] entries = this.entries;\n+            if (index >= entries.length) {\n+                zerror(INDEX_OVERFLOW);\n+            }\n+\n@@ -1235,1 +1246,0 @@\n-            int entryPos = pos + CENHDR;\n@@ -1239,1 +1249,1 @@\n-            long headerSize = (long)CENHDR + nlen + clen + elen;\n+            int headerSize = CENHDR + nlen + clen + elen;\n@@ -1249,1 +1259,1 @@\n-                checkExtraFields(pos, entryPos + nlen, elen);\n+                checkExtraFields(pos, pos + CENHDR + nlen, elen);\n@@ -1259,1 +1269,1 @@\n-                int hash = zcp.checkedHash(cen, entryPos, nlen);\n+                int hash = zcp.checkedHash(cen, pos + CENHDR, nlen);\n@@ -1261,0 +1271,1 @@\n+                int[] table = this.table;\n@@ -1262,1 +1273,0 @@\n-                table[hsh] = index;\n@@ -1265,0 +1275,1 @@\n+                table[hsh] = index; \/\/ Store state.idx + 1, reserving 0 for end-of-chain\n@@ -1266,1 +1277,1 @@\n-                entries[index  ] = pos;\n+                entries[index] = pos;\n@@ -1271,2 +1282,1 @@\n-                    int start = entryPos + nlen + elen;\n-                    zcp.toString(cen, start, clen);\n+                    zcp.toString(cen, headerSize - clen, clen);\n@@ -1277,1 +1287,30 @@\n-            return nlen;\n+\n+            \/\/ Adds name to metanames.\n+            if (isMetaName(cen, pos, nlen)) {\n+                \/\/ nlen is at least META_INF_LENGTH\n+                if (isManifestName(pos + CENHDR + META_INF_LEN, nlen - META_INF_LEN)) {\n+                    manifestPos = pos;\n+                    manifestNum++;\n+                } else {\n+                    if (isSignatureRelated(pos + CENHDR, nlen)) {\n+                        if (state.signatureNames == null) {\n+                            state.signatureNames = new ArrayList<>(4);\n+                        }\n+                        state.signatureNames.add(pos);\n+                    }\n+\n+                    \/\/ If this is a versioned entry, parse the version\n+                    \/\/ and store it for later. This optimizes lookup\n+                    \/\/ performance in multi-release jar files\n+                    int version = getMetaVersion(pos + CENHDR + META_INF_LEN, nlen - META_INF_LEN);\n+                    if (version > 0) {\n+                        if (state.metaVersionsSet == null) {\n+                            state.metaVersionsSet = new TreeSet<>();\n+                        }\n+                        state.metaVersionsSet.add(version);\n+                    }\n+                }\n+            }\n+            state.pos += headerSize;\n+            state.idx += 3;\n+            return true;\n@@ -1442,2 +1481,1 @@\n-        private int getEntryHash(int index) { return entries[index]; }\n-        private int getEntryNext(int index) { return entries[index + 1]; }\n+\n@@ -1445,1 +1483,0 @@\n-        private static final int ZIP_ENDCHAIN  = -1;\n@@ -1713,0 +1750,9 @@\n+        private static class CENState {\n+            int pos;\n+            int idx;\n+            final int limit;\n+            List<Integer> signatureNames;\n+            Set<Integer> metaVersionsSet;\n+            CENState(int limit) { this.limit = limit; }\n+        }\n+\n@@ -1726,1 +1772,2 @@\n-                if (end.cenlen > end.endpos)\n+                long cenlen = end.cenlen;\n+                if (cenlen > end.endpos)\n@@ -1728,1 +1775,1 @@\n-                long cenpos = end.endpos - end.cenlen;     \/\/ position of CEN table\n+                long cenpos = end.endpos - cenlen;     \/\/ position of CEN table\n@@ -1736,1 +1783,1 @@\n-                if (end.cenlen + ENDHDR >= Integer.MAX_VALUE) {\n+                if (cenlen + ENDHDR >= Integer.MAX_VALUE) {\n@@ -1739,2 +1786,3 @@\n-                cen = this.cen = new byte[(int)(end.cenlen + ENDHDR)];\n-                if (readFullyAt(cen, 0, cen.length, cenpos) != end.cenlen + ENDHDR) {\n+                int len = (int)(cenlen + ENDHDR);\n+                cen = this.cen = new byte[len];\n+                if (readFullyAt(cen, 0, len, cenpos) != len) {\n@@ -1758,7 +1806,0 @@\n-            Arrays.fill(table, ZIP_ENDCHAIN);\n-\n-            \/\/ list for all meta entries\n-            ArrayList<Integer> signatureNames = null;\n-            \/\/ Set of all version numbers seen in META-INF\/versions\/\n-            Set<Integer> metaVersionsSet = null;\n-\n@@ -1766,7 +1807,7 @@\n-            int idx = 0; \/\/ Index into the entries array\n-            int pos = 0;\n-            int entryPos = CENHDR;\n-            int limit = cen.length - ENDHDR;\n-            manifestNum = 0;\n-            while (entryPos <= limit) {\n-                if (idx >= entriesLength) {\n+            int cenend = cen.length - ENDHDR;\n+            var state = new CENState(cenend - CENHDR); \/\/ state holder\n+            try {\n+                \/\/ Checks the entry and adds values to entries[idx ... idx+2], state.pos will contain position of next entry\n+                while (processNextCENEntry(state)) {}\n+            } catch (ZipException ze) {\n+                if (ze.getMessage().equals(INDEX_OVERFLOW)) {\n@@ -1776,1 +1817,3 @@\n-                    initCEN(countCENHeaders(cen, limit));\n+                    manifestNum = 0;\n+                    manifestPos = -1;\n+                    initCEN(countCENHeaders(cen, cenend));\n@@ -1779,32 +1822,1 @@\n-\n-                \/\/ Checks the entry and adds values to entries[idx ... idx+2]\n-                int nlen = checkAndAddEntry(pos, idx);\n-                idx += 3;\n-\n-                \/\/ Adds name to metanames.\n-                if (isMetaName(cen, entryPos, nlen)) {\n-                    \/\/ nlen is at least META_INF_LENGTH\n-                    if (isManifestName(entryPos + META_INF_LEN, nlen - META_INF_LEN)) {\n-                        manifestPos = pos;\n-                        manifestNum++;\n-                    } else {\n-                        if (isSignatureRelated(entryPos, nlen)) {\n-                            if (signatureNames == null)\n-                                signatureNames = new ArrayList<>(4);\n-                            signatureNames.add(pos);\n-                        }\n-\n-                        \/\/ If this is a versioned entry, parse the version\n-                        \/\/ and store it for later. This optimizes lookup\n-                        \/\/ performance in multi-release jar files\n-                        int version = getMetaVersion(entryPos + META_INF_LEN, nlen - META_INF_LEN);\n-                        if (version > 0) {\n-                            if (metaVersionsSet == null)\n-                                metaVersionsSet = new TreeSet<>();\n-                            metaVersionsSet.add(version);\n-                        }\n-                    }\n-                }\n-                \/\/ skip to the start of the next entry\n-                pos = nextEntryPos(pos, entryPos, nlen);\n-                entryPos = pos + CENHDR;\n+                throw ze;\n@@ -1814,1 +1826,1 @@\n-            this.total = idx \/ 3;\n+            this.total = state.idx \/ 3;\n@@ -1816,5 +1828,5 @@\n-            if (signatureNames != null) {\n-                int len = signatureNames.size();\n-                signatureMetaNames = new int[len];\n-                for (int j = 0; j < len; j++) {\n-                    signatureMetaNames[j] = signatureNames.get(j);\n+            if (state.signatureNames != null) {\n+                int signatures = state.signatureNames.size();\n+                signatureMetaNames = new int[signatures];\n+                for (int j = 0; j < signatures; j++) {\n+                    signatureMetaNames[j] = state.signatureNames.get(j);\n@@ -1823,2 +1835,3 @@\n-            if (metaVersionsSet != null) {\n-                metaVersions = new int[metaVersionsSet.size()];\n+            if (state.metaVersionsSet != null) {\n+                int size = state.metaVersionsSet.size();\n+                metaVersions = new int[size];\n@@ -1826,1 +1839,1 @@\n-                for (Integer version : metaVersionsSet) {\n+                for (Integer version : state.metaVersionsSet) {\n@@ -1832,1 +1845,1 @@\n-            if (pos + ENDHDR != cen.length) {\n+            if (state.pos != cenend) {\n@@ -1837,4 +1850,0 @@\n-        private int nextEntryPos(int pos, int entryPos, int nlen) {\n-            return entryPos + nlen + CENCOM(cen, pos) + CENEXT(cen, pos);\n-        }\n-\n@@ -1861,4 +1870,4 @@\n-            while (idx != ZIP_ENDCHAIN) {\n-                if (getEntryHash(idx) == hsh) {\n-\n-                    int pos = getEntryPos(idx);\n+            int[] entries = this.entries;\n+            while (idx != 0) {\n+                if (entries[idx - 1] == hsh) {\n+                    int pos = getEntryPos(idx - 1);\n@@ -1884,1 +1893,1 @@\n-                idx = getEntryNext(idx);\n+                idx = entries[idx];\n@@ -1912,0 +1921,1 @@\n+            off += CENHDR;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":97,"deletions":87,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -110,0 +110,8 @@\n+\n+    public static void main(String... args) throws Exception {\n+        var bench = new ZipFileOpen();\n+        bench.size = 1024*8;\n+        bench.beforeRun();\n+        bench.openCloseZipFile();\n+        bench.openCloseZipFilex2();\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/zip\/ZipFileOpen.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}