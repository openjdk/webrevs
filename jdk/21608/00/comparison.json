{"files":[{"patch":"@@ -273,1 +273,1 @@\n-macro(Opaque4)\n+macro(OpaqueNotNull)\n@@ -275,0 +275,1 @@\n+macro(OpaqueTemplateAssertionPredicate)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -396,1 +396,1 @@\n-  if (dead->Opcode() == Op_Opaque4) {\n+  if (dead->is_OpaqueTemplateAssertionPredicate()) {\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -373,1 +373,2 @@\n-  GrowableArray<Node*>  _template_assertion_predicate_opaqs; \/\/ List of Opaque4 nodes for Template Assertion Predicates.\n+  \/\/ List of OpaqueTemplateAssertionPredicateNode nodes for Template Assertion Predicates.\n+  GrowableArray<Node*>  _template_assertion_predicate_opaqs;\n@@ -773,1 +774,1 @@\n-           \"duplicate entry in template assertion predicate opaque4 list\");\n+           \"Duplicate entry in Template Assertion Predicate OpaqueTemplateAssertionPredicate list\");\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -577,3 +577,1 @@\n-          \/\/ We may have Opaque4 node between If and Bool nodes.\n-          \/\/ Bail out in such case - we need to preserve Opaque4 for correct\n-          \/\/ processing predicates after loop opts.\n+          \/\/ We may have an OpaqueNotNull node between If and Bool nodes. Bail out in such case.\n@@ -585,0 +583,2 @@\n+          } else {\n+            assert(iff->in(1)->is_OpaqueNotNull(), \"must be OpaqueNotNull\");\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1461,1 +1461,1 @@\n-\/\/ an Opaque4 node that will cause the check to be removed after loop\n+\/\/ an OpaqueNotNull node that will cause the check to be removed after loop\n@@ -1469,3 +1469,3 @@\n-  Node *tst = _gvn.transform(new BoolNode(chk, BoolTest::ne));\n-  Node* opaq = _gvn.transform(new Opaque4Node(C, tst, intcon(1)));\n-  IfNode *iff = new IfNode(control(), opaq, PROB_MAX, COUNT_UNKNOWN);\n+  Node* tst = _gvn.transform(new BoolNode(chk, BoolTest::ne));\n+  Node* opaq = _gvn.transform(new OpaqueNotNullNode(C, tst));\n+  IfNode* iff = new IfNode(control(), opaq, PROB_MAX, COUNT_UNKNOWN);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -341,1 +341,2 @@\n-\/\/ is set, then the Opaque4 nodes of the Assertion Predicates are put on the list instead of the projections.\n+\/\/ is set, then the OpaqueTemplateAssertionPredicate nodes of the Assertion Predicates are put on the list instead of\n+\/\/ the projections.\n@@ -356,1 +357,1 @@\n-    if (bol->is_Opaque4()) {\n+    if (bol->is_OpaqueTemplateAssertionPredicate()) {\n@@ -359,1 +360,1 @@\n-        \/\/ Collect the predicate Opaque4 node.\n+        \/\/ Collect the OpaqueTemplateAssertionPredicateNode.\n@@ -377,2 +378,2 @@\n-  TemplateAssertionExpression template_assertion_expression(template_assertion_predicate->in(1)->as_Opaque4());\n-  Opaque4Node* cloned_opaque4_node = template_assertion_expression.clone(parse_predicate_proj->in(0)->in(0), this);\n+  TemplateAssertionExpression template_assertion_expression(template_assertion_predicate->in(1)->as_OpaqueTemplateAssertionPredicate());\n+  OpaqueTemplateAssertionPredicateNode* cloned_opaque_node = template_assertion_expression.clone(parse_predicate_proj->in(0)->in(0), this);\n@@ -381,1 +382,1 @@\n-  _igvn.replace_input_of(if_proj->in(0), 1, cloned_opaque4_node);\n+  _igvn.replace_input_of(if_proj->in(0), 1, cloned_opaque_node);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1192,2 +1192,4 @@\n-        assert(bol->is_Opaque4() || bol->is_OpaqueInitializedAssertionPredicate(),\n-               \"Opaque node of non-null-check or of Initialized Assertion Predicate\");\n+        assert(bol->is_OpaqueNotNull() ||\n+               bol->is_OpaqueTemplateAssertionPredicate() ||\n+               bol->is_OpaqueInitializedAssertionPredicate(),\n+               \"Opaque node of a non-null-check or an Assertion Predicate\");\n@@ -1362,1 +1364,1 @@\n-      if (bol->is_Opaque4()) {\n+      if (bol->is_OpaqueTemplateAssertionPredicate()) {\n@@ -1402,0 +1404,1 @@\n+#ifdef ASSERT\n@@ -1406,1 +1409,0 @@\n-#ifdef ASSERT\n@@ -1432,1 +1434,0 @@\n-#endif\n@@ -1436,0 +1437,1 @@\n+#endif \/\/ ASSERT\n@@ -1478,2 +1480,2 @@\n-\/\/ We keep the Opaque4 node since it's still a template. Since the templates are eventually removed after loop opts,\n-\/\/ these are never executed. We therefore insert a Halt node instead of an uncommon trap.\n+\/\/ We keep the OpaqueTemplateAssertionPredicate node since it's still a template. Since the templates are eventually\n+\/\/ removed after loop opts, these are never executed. We therefore insert a Halt node instead of an uncommon trap.\n@@ -1483,1 +1485,1 @@\n-  TemplateAssertionExpression template_assertion_expression(iff->in(1)->as_Opaque4());\n+  TemplateAssertionExpression template_assertion_expression(iff->in(1)->as_OpaqueTemplateAssertionPredicate());\n@@ -1485,1 +1487,2 @@\n-  Opaque4Node* new_opaque_node = template_assertion_expression.clone_and_replace_init(new_init, control, this);\n+  OpaqueTemplateAssertionPredicateNode* new_opaque_node =\n+      template_assertion_expression.clone_and_replace_init(new_init, control, this);\n@@ -1925,12 +1928,7 @@\n-    if (bol->is_Opaque4()) {\n-      if (assertion_predicate_has_loop_opaque_node(iff)) {\n-        \/\/ This is a Template Assertion Predicate for the initial or last access.\n-        \/\/ Create an Initialized Assertion Predicates for it accordingly:\n-        \/\/ - For the initial access a[init] (same as before)\n-        \/\/ - For the last access a[init+new_stride-orig_stride] (with the new unroll stride)\n-        prev_proj = create_initialized_assertion_predicate(iff, init, max_value, prev_proj);\n-      } else {\n-        \/\/ Ignore Opaque4 from a non-null-check for an intrinsic or unsafe access. This could happen when we maximally\n-        \/\/ unroll a non-main loop with such an If with an Opaque4 node directly above the loop entry.\n-        assert(!loop_head->is_main_loop(), \"Opaque4 node from a non-null check - should not be at main loop\");\n-      }\n+    if (bol->is_OpaqueTemplateAssertionPredicate()) {\n+      assert(assertion_predicate_has_loop_opaque_node(iff), \"must find OpaqueLoop* nodes\");\n+      \/\/ This is a Template Assertion Predicate for the initial or last access.\n+      \/\/ Create an Initialized Assertion Predicates for it accordingly:\n+      \/\/ - For the initial access a[init] (same as before)\n+      \/\/ - For the last access a[init+new_stride-orig_stride] (with the new unroll stride)\n+      prev_proj = create_initialized_assertion_predicate(iff, init, max_value, prev_proj);\n@@ -1944,0 +1942,1 @@\n+    assert(!bol->is_OpaqueNotNull() || !loop_head->is_main_loop(), \"OpaqueNotNull should not be at main loop\");\n@@ -1970,1 +1969,1 @@\n-    if (iff->in(1)->is_Opaque4()) {\n+    if (iff->in(1)->is_OpaqueTemplateAssertionPredicate()) {\n@@ -2003,1 +2002,1 @@\n-    if (bol->is_Opaque4()) {\n+    if (bol->is_OpaqueTemplateAssertionPredicate()) {\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":22,"deletions":23,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -4384,1 +4384,2 @@\n-\/\/ replacing the Opaque4 node of the If node with true. These nodes will be removed during the next round of IGVN.\n+\/\/ replacing the OpaqueTemplateAssertionPredicate node of the If node with true. These nodes will be removed during the\n+\/\/ next round of IGVN.\n@@ -4425,3 +4426,4 @@\n-    Opaque4Node* opaque4_node = C->template_assertion_predicate_opaq_node(i - 1)->as_Opaque4();\n-    if (!useful_predicates.member(opaque4_node)) { \/\/ not in the useful list\n-      _igvn.replace_node(opaque4_node, opaque4_node->in(2));\n+    OpaqueTemplateAssertionPredicateNode* opaque_node =\n+        C->template_assertion_predicate_opaq_node(i - 1)->as_OpaqueTemplateAssertionPredicate();\n+    if (!useful_predicates.member(opaque_node)) { \/\/ not in the useful list\n+      _igvn.replace_node(opaque_node, _igvn.intcon(1));\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -958,1 +958,1 @@\n-  static bool assertion_predicate_has_loop_opaque_node(IfNode* iff);\n+  DEBUG_ONLY(static bool assertion_predicate_has_loop_opaque_node(IfNode* iff);)\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -790,4 +790,3 @@\n-  if (bol->is_Opaque4()) {\n-    \/\/ Ignore Template Assertion Predicates with Opaque4 nodes.\n-    assert(assertion_predicate_has_loop_opaque_node(iff),\n-           \"must be Template Assertion Predicate, non-null-check with Opaque4 cannot form a diamond with Halt\");\n+  if (bol->is_OpaqueTemplateAssertionPredicate()) {\n+    \/\/ Ignore Template Assertion Predicates with OpaqueTemplateAssertionPredicate nodes.\n+    assert(assertion_predicate_has_loop_opaque_node(iff), \"must find OpaqueLoop* nodes\");\n@@ -1705,1 +1704,1 @@\n-      !n->is_Opaque4() &&\n+      !n->is_OpaqueNotNull() &&\n@@ -1707,0 +1706,1 @@\n+      !n->is_OpaqueTemplateAssertionPredicate() &&\n@@ -2023,2 +2023,2 @@\n-      assert(b->is_Bool() || b->is_Opaque4() || b->is_OpaqueInitializedAssertionPredicate(),\n-             \"bool, non-null check with Opaque4 node or Initialized Assertion Predicate with its Opaque node\");\n+      assert(b->is_Bool() || b->is_OpaqueNotNull() || b->is_OpaqueInitializedAssertionPredicate(),\n+             \"bool, non-null check with OpaqueNotNull or Initialized Assertion Predicate with its Opaque node\");\n@@ -2030,1 +2030,1 @@\n-  if (n->is_Opaque4() || n->is_OpaqueInitializedAssertionPredicate()) {\n+  if (n->is_OpaqueNotNull() || n->is_OpaqueInitializedAssertionPredicate()) {\n@@ -2204,1 +2204,3 @@\n-      if (use->is_If() || use->is_CMove() || use->is_Opaque4() || use->is_OpaqueInitializedAssertionPredicate() ||\n+      assert(!use->is_OpaqueTemplateAssertionPredicate(),\n+             \"should not clone a Template Assertion Predicate which should be removed once it's useless\");\n+      if (use->is_If() || use->is_CMove() || use->is_OpaqueNotNull() || use->is_OpaqueInitializedAssertionPredicate() ||\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2431,1 +2431,1 @@\n-               n->is_Opaque4()             ||\n+               n->is_OpaqueNotNull()       ||\n@@ -2483,7 +2483,4 @@\n-      } else if (n->is_Opaque4()) {\n-        \/\/ With Opaque4 nodes, the expectation is that the test of input 1\n-        \/\/ is always equal to the constant value of input 2. So we can\n-        \/\/ remove the Opaque4 and replace it by input 2. In debug builds,\n-        \/\/ leave the non constant test in instead to sanity check that it\n-        \/\/ never fails (if it does, that subgraph was constructed so, at\n-        \/\/ runtime, a Halt node is executed).\n+      } else if (n->is_OpaqueNotNull()) {\n+        \/\/ Tests with OpaqueNotNull nodes are implicitly known to be true. Replace the node with true. In debug builds,\n+        \/\/ we leave the test in the graph to have an additional sanity check at runtime. If the test fails (i.e. a bug),\n+        \/\/ we will execute a Halt node.\n@@ -2493,1 +2490,1 @@\n-        _igvn.replace_node(n, n->in(2));\n+        _igvn.replace_node(n, _igvn.intcon(1));\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -614,1 +614,1 @@\n-  if (is_Opaque4()) {\n+  if (is_OpaqueTemplateAssertionPredicate()) {\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-class Opaque4Node;\n+class OpaqueNotNullNode;\n@@ -143,0 +143,1 @@\n+class OpaqueTemplateAssertionPredicateNode;\n@@ -799,1 +800,1 @@\n-    DEFINE_CLASS_ID(Opaque4,  Node, 17)\n+    DEFINE_CLASS_ID(OpaqueNotNull,  Node, 17)\n@@ -801,3 +802,4 @@\n-    DEFINE_CLASS_ID(Move,     Node, 19)\n-    DEFINE_CLASS_ID(LShift,   Node, 20)\n-    DEFINE_CLASS_ID(Neg,      Node, 21)\n+    DEFINE_CLASS_ID(OpaqueTemplateAssertionPredicate,  Node, 19)\n+    DEFINE_CLASS_ID(Move,     Node, 20)\n+    DEFINE_CLASS_ID(LShift,   Node, 21)\n+    DEFINE_CLASS_ID(Neg,      Node, 22)\n@@ -973,1 +975,1 @@\n-  DEFINE_CLASS_QUERY(Opaque4)\n+  DEFINE_CLASS_QUERY(OpaqueNotNull)\n@@ -975,0 +977,1 @@\n+  DEFINE_CLASS_QUERY(OpaqueTemplateAssertionPredicate)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -85,1 +85,18 @@\n-const Type* Opaque4Node::Value(PhaseGVN* phase) const {\n+const Type* OpaqueNotNullNode::Value(PhaseGVN* phase) const {\n+  return phase->type(in(1));\n+}\n+\n+Node* OpaqueTemplateAssertionPredicateNode::Identity(PhaseGVN* phase) {\n+  if (phase->C->post_loop_opts_phase()) {\n+    \/\/ Template Assertion Predicates only serve as templates to create Initialized Assertion Predicates when splitting\n+    \/\/ a loop during loop opts. They are not used anymore once loop opts are over and can then be removed. They feed\n+    \/\/ into the bool input of an If node and can thus be replaced by true to let the Template Assertion Predicate be\n+    \/\/ folded away (the success path is always the true path by design).\n+    return phase->intcon(1);\n+  } else {\n+    phase->C->record_for_post_loop_opts_igvn(this);\n+  }\n+  return this;\n+}\n+\n+const Type* OpaqueTemplateAssertionPredicateNode::Value(PhaseGVN* phase) const {\n","filename":"src\/hotspot\/share\/opto\/opaquenode.cpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -94,7 +94,7 @@\n-\/\/ Input 1 is a check that we know implicitly is always true or false\n-\/\/ but the compiler has no way to prove. If during optimizations, that\n-\/\/ check becomes true or false, the Opaque4 node is replaced by that\n-\/\/ constant true or false. Input 2 is the constant value we know the\n-\/\/ test takes. After loop optimizations, we replace input 1 by input 2\n-\/\/ so the control that depends on that test can be removed and there's\n-\/\/ no overhead at runtime. Used for instance by\n+\/\/ This node is used in the context of intrinsics. We sometimes implicitly know that an object is non-null even though\n+\/\/ the compiler cannot prove it. We therefore add a corresponding cast to propagate this implicit knowledge. However,\n+\/\/ this cast could become top during optimizations (input to cast becomes null) and the data path is folded. To ensure\n+\/\/ that the control path is also properly folded, we insert an If node with a OpaqueNotNullNode as condition. During\n+\/\/ macro expansion, we replace the OpaqueNotNullNodes with true in product builds such that the actually unneeded checks\n+\/\/ are folded and do not end up in the emitted code. In debug builds, we keep the actual checks as additional\n+\/\/ verification code (i.e. removing OpaqueNotNullNodes and use the BoolNode inputs instead). For more details, also see\n@@ -102,4 +102,4 @@\n-class Opaque4Node : public Node {\n-  public:\n-  Opaque4Node(Compile* C, Node* tst, Node* final_tst) : Node(nullptr, tst, final_tst) {\n-    init_class_id(Class_Opaque4);\n+class OpaqueNotNullNode : public Node {\n+ public:\n+  OpaqueNotNullNode(Compile* C, Node* tst) : Node(nullptr, tst) {\n+    init_class_id(Class_OpaqueNotNull);\n@@ -115,0 +115,15 @@\n+\/\/ This node is used for Template Assertion Predicate BoolNodes. A Template Assertion Predicate is always removed\n+\/\/ after loop opts and thus is never converted to actual code. In the post loop opts IGVN phase, the\n+\/\/ OpaqueTemplateAssertionPredicateNode is replaced by true in order to fold the Template Assertion Predicate away.\n+class OpaqueTemplateAssertionPredicateNode : public Node {\n+ public:\n+  OpaqueTemplateAssertionPredicateNode(BoolNode* bol) : Node(nullptr, bol) {\n+    init_class_id(Class_OpaqueTemplateAssertionPredicate);\n+  }\n+\n+  virtual int Opcode() const;\n+  virtual Node* Identity(PhaseGVN* phase);\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual const Type* bottom_type() const { return TypeInt::BOOL; }\n+};\n+\n@@ -116,2 +131,4 @@\n-\/\/ to true. Therefore, we get rid of them in product builds during macro expansion as they are useless. In debug builds\n-\/\/ we keep them as additional verification code (i.e. removing this node and use the BoolNode input instead).\n+\/\/ to true. During  macro expansion, we replace the OpaqueInitializedAssertionPredicateNodes with true in product builds\n+\/\/ such that the actually unneeded checks are folded and do not end up in the emitted code. In debug builds, we keep the\n+\/\/ actual checks as additional verification code (i.e. removing OpaqueInitializedAssertionPredicateNodes and use the\n+\/\/ BoolNode inputs instead).\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":30,"deletions":13,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -58,2 +58,2 @@\n-\/\/ Check if the If node of `predicate_proj` has an Opaque4 (Template Assertion Predicate) or an\n-\/\/ OpaqueInitializedAssertionPredicate (Initialized Assertion Predicate) node as input.\n+\/\/ Check if the If node of `predicate_proj` has an OpaqueTemplateAssertionPredicate (Template Assertion Predicate) or\n+\/\/ an OpaqueInitializedAssertionPredicate (Initialized Assertion Predicate) node as input.\n@@ -63,1 +63,1 @@\n-  return bol->is_Opaque4() || bol->is_OpaqueInitializedAssertionPredicate();\n+  return bol->is_OpaqueTemplateAssertionPredicate() || bol->is_OpaqueInitializedAssertionPredicate();\n@@ -140,2 +140,1 @@\n-\/\/ A Template Assertion Predicate has an If\/RangeCheckNode and either an UCT or a halt node depending on where it\n-\/\/ was created.\n+\/\/ Template Assertion Predicates always have the dedicated OpaqueTemplateAssertionPredicate to identify them.\n@@ -147,4 +146,1 @@\n-  if (if_node->in(1)->is_Opaque4()) {\n-    return RegularPredicateWithUCT::has_valid_uncommon_trap(node) || AssertionPredicateWithHalt::has_halt(node);\n-  }\n-  return false;\n+  return if_node->in(1)->is_OpaqueTemplateAssertionPredicate();\n@@ -153,1 +149,2 @@\n-\/\/ Initialized Assertion Predicates always have the dedicated opaque node and a halt node.\n+\/\/ Initialized Assertion Predicates always have the dedicated OpaqueInitiailizedAssertionPredicate node to identify\n+\/\/ them.\n@@ -155,1 +152,1 @@\n-  if (!AssertionPredicateWithHalt::is_predicate(node)) {\n+  if (!may_be_assertion_predicate_if(node)) {\n@@ -241,5 +238,5 @@\n-\/\/ Creates an identical clone of this Template Assertion Expression (i.e.cloning all nodes from the Opaque4Node to and\n-\/\/ including the OpaqueLoop* nodes). The cloned nodes are rewired to reflect the same graph structure as found for this\n-\/\/ Template Assertion Expression. The cloned nodes get 'new_ctrl' as ctrl. There is no other update done for the cloned\n-\/\/ nodes. Return the newly cloned Opaque4Node.\n-Opaque4Node* TemplateAssertionExpression::clone(Node* new_ctrl, PhaseIdealLoop* phase) {\n+\/\/ Creates an identical clone of this Template Assertion Expression (i.e.cloning all nodes from the\n+\/\/ OpaqueTemplateAssertionPredicate to and including the OpaqueLoop* nodes). The cloned nodes are rewired to reflect the\n+\/\/ same graph structure as found for this Template Assertion Expression. The cloned nodes get 'new_ctrl' as ctrl. There\n+\/\/ is no other update done for the cloned nodes. Return the newly cloned OpaqueTemplateAssertionPredicate.\n+OpaqueTemplateAssertionPredicateNode* TemplateAssertionExpression::clone(Node* new_ctrl, PhaseIdealLoop* phase) {\n@@ -251,2 +248,2 @@\n-Opaque4Node* TemplateAssertionExpression::clone_and_replace_init(Node* new_init, Node* new_ctrl,\n-                                                                 PhaseIdealLoop* phase) {\n+OpaqueTemplateAssertionPredicateNode*\n+TemplateAssertionExpression::clone_and_replace_init(Node* new_init, Node* new_ctrl, PhaseIdealLoop* phase) {\n@@ -259,3 +256,3 @@\n-Opaque4Node* TemplateAssertionExpression::clone_and_replace_init_and_stride(Node* new_control, Node* new_init,\n-                                                                            Node* new_stride,\n-                                                                            PhaseIdealLoop* phase) {\n+OpaqueTemplateAssertionPredicateNode*\n+TemplateAssertionExpression::clone_and_replace_init_and_stride(Node* new_control, Node* new_init, Node* new_stride,\n+                                                               PhaseIdealLoop* phase) {\n@@ -344,2 +341,3 @@\n-Opaque4Node* TemplateAssertionExpression::clone(const TransformStrategyForOpaqueLoopNodes& transform_strategy,\n-                                                Node* new_ctrl, PhaseIdealLoop* phase) {\n+OpaqueTemplateAssertionPredicateNode*\n+TemplateAssertionExpression::clone(const TransformStrategyForOpaqueLoopNodes& transform_strategy, Node* new_ctrl,\n+                                   PhaseIdealLoop* phase) {\n@@ -352,1 +350,1 @@\n-  const Unique_Node_List& collected_nodes = data_nodes_on_path_to_targets.collect(_opaque4_node);\n+  const Unique_Node_List& collected_nodes = data_nodes_on_path_to_targets.collect(_opaque_node);\n@@ -355,3 +353,3 @@\n-  assert(orig_to_new.contains(_opaque4_node), \"must exist\");\n-  Node* opaque4_clone = *orig_to_new.get(_opaque4_node);\n-  return opaque4_clone->as_Opaque4();\n+  assert(orig_to_new.contains(_opaque_node), \"must exist\");\n+  Node* opaque_node_clone = *orig_to_new.get(_opaque_node);\n+  return opaque_node_clone->as_OpaqueTemplateAssertionPredicate();\n@@ -379,1 +377,1 @@\n-  return node->is_If() && node->in(1)->is_Opaque4();\n+  return node->is_If() && node->in(1)->is_OpaqueTemplateAssertionPredicate();\n@@ -401,2 +399,2 @@\n-  \/\/ Create the expression for a Template Assertion Predicate with an Opaque4 node.\n-  Opaque4Node* create_for_template(Node* new_control, Node* operand, bool& does_overflow) const {\n+  \/\/ Create the expression for a Template Assertion Predicate with an OpaqueTemplateAssertionPredicate node.\n+  OpaqueTemplateAssertionPredicateNode* create_for_template(Node* new_control, Node* operand, bool& does_overflow) const {\n@@ -405,1 +403,1 @@\n-    return create_opaque4_node(new_control, bool_for_expression);\n+    return create_opaque_node(new_control, bool_for_expression);\n@@ -409,4 +407,3 @@\n-  Opaque4Node* create_opaque4_node(Node* new_control, BoolNode* bool_for_expression) const {\n-    Compile* C = _phase->C;\n-    Opaque4Node* new_expression = new Opaque4Node(C, bool_for_expression, _phase->igvn().intcon(1));\n-    C->add_template_assertion_predicate_opaq(new_expression);\n+  OpaqueTemplateAssertionPredicateNode* create_opaque_node(Node* new_control, BoolNode* bool_for_expression) const {\n+    OpaqueTemplateAssertionPredicateNode* new_expression = new OpaqueTemplateAssertionPredicateNode(bool_for_expression);\n+    _phase->C->add_template_assertion_predicate_opaq(new_expression);\n@@ -466,2 +463,2 @@\n-  assert(assertion_expression->is_Opaque4() || assertion_expression->is_OpaqueInitializedAssertionPredicate(),\n-         \"not a valid assertion expression\");\n+  assert(assertion_expression->is_OpaqueTemplateAssertionPredicate() ||\n+         assertion_expression->is_OpaqueInitializedAssertionPredicate(), \"not a valid assertion expression\");\n@@ -520,2 +517,2 @@\n-  Opaque4Node* template_assertion_predicate_expression = create_for_init_value(new_control, opaque_init,\n-                                                                               does_overflow);\n+  OpaqueTemplateAssertionPredicateNode* template_assertion_predicate_expression =\n+      create_for_init_value(new_control, opaque_init, does_overflow);\n@@ -539,2 +536,3 @@\n-Opaque4Node* TemplateAssertionPredicateCreator::create_for_init_value(Node* new_control, OpaqueLoopInitNode* opaque_init,\n-                                                                      bool& does_overflow) const {\n+OpaqueTemplateAssertionPredicateNode*\n+TemplateAssertionPredicateCreator::create_for_init_value(Node* new_control, OpaqueLoopInitNode* opaque_init,\n+                                                         bool& does_overflow) const {\n@@ -546,2 +544,3 @@\n-    Opaque4Node* template_assertion_predicate_expression, ParsePredicateSuccessProj* parse_predicate_success_proj,\n-    const Deoptimization::DeoptReason deopt_reason, const int if_opcode, const bool does_overflow\n+    OpaqueTemplateAssertionPredicateNode* template_assertion_predicate_expression,\n+    ParsePredicateSuccessProj* parse_predicate_success_proj, const Deoptimization::DeoptReason deopt_reason,\n+    const int if_opcode, const bool does_overflow\n@@ -556,2 +555,3 @@\n-Opaque4Node* TemplateAssertionPredicateCreator::create_for_last_value(Node* new_control, OpaqueLoopInitNode* opaque_init,\n-                                                                      bool& does_overflow) const {\n+OpaqueTemplateAssertionPredicateNode*\n+TemplateAssertionPredicateCreator::create_for_last_value(Node* new_control, OpaqueLoopInitNode* opaque_init,\n+                                                         bool& does_overflow) const {\n@@ -578,1 +578,1 @@\n-    Node* new_control, Opaque4Node* template_assertion_predicate_expression, bool does_overflow\n+    Node* new_control, OpaqueTemplateAssertionPredicateNode* template_assertion_predicate_expression, bool does_overflow\n@@ -591,2 +591,2 @@\n-  Opaque4Node* template_assertion_predicate_expression = create_for_init_value(new_control, opaque_init,\n-                                                                               does_overflow);\n+  OpaqueTemplateAssertionPredicateNode* template_assertion_predicate_expression =\n+      create_for_init_value(new_control, opaque_init, does_overflow);\n@@ -607,1 +607,1 @@\n-\/\/ - Opaque4 with OpaqueInitializedAssertionPredicate\n+\/\/ - OpaqueTemplateAssertionPredicateNode with OpaqueInitializedAssertionPredicate\n@@ -612,12 +612,12 @@\n-\/\/             |  OpaqueLoopInitNode  OpaqueLoopStrideNode                      \/        new_init    new_stride\n-\/\/  Template   |                 \\     \/                                        |              \\     \/\n-\/\/  Assertion  |                   ...                               Assertion  |                ...\n-\/\/  Expression |                    |                                Expression |                 |\n-\/\/             |                   Bool                                         |              new Bool\n-\/\/             |                    |                                           |                 |\n-\/\/             \\                 Opaque4           ======>      new_control     \\  OpaqueInitializedAssertionPredicate\n-\/\/                                  |                                      \\      \/\n-\/\/                                 If                                       new If\n-\/\/                               \/    \\                                     \/    \\\n-\/\/                         success     fail path                   new success   new Halt\n-\/\/                           proj    (Halt or UCT)                     proj\n+\/\/             |  OpaqueLoopInitNode  OpaqueLoopStrideNode                        \/        new_init    new_stride\n+\/\/  Template   |                 \\     \/                                          |              \\     \/\n+\/\/  Assertion  |                   ...                                 Assertion  |                ...\n+\/\/  Expression |                    |                                  Expression |                 |\n+\/\/             |                   Bool                                           |              new Bool\n+\/\/             |                    |                                             |                 |\n+\/\/             \\      OpaqueTemplateAssertionPredicate    ===>    new_control     \\  OpaqueInitializedAssertionPredicate\n+\/\/                                  |                                        \\      \/\n+\/\/                                 If                                         new If\n+\/\/                               \/    \\                                       \/    \\\n+\/\/                         success     fail path                     new success   new Halt\n+\/\/                           proj    (Halt or UCT)                       proj\n@@ -661,1 +661,2 @@\n-  Opaque4Node* template_opaque = template_assertion_predicate->in(1)->as_Opaque4();\n+  OpaqueTemplateAssertionPredicateNode* template_opaque =\n+      template_assertion_predicate->in(1)->as_OpaqueTemplateAssertionPredicate();\n@@ -663,3 +664,2 @@\n-  Opaque4Node* tmp_opaque = template_assertion_expression.clone_and_replace_init_and_stride(new_control, new_init,\n-                                                                                            new_stride,\n-                                                                                            _phase);\n+  OpaqueTemplateAssertionPredicateNode* tmp_opaque =\n+      template_assertion_expression.clone_and_replace_init_and_stride(new_control, new_init, new_stride, _phase);\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":65,"deletions":65,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -85,2 +85,2 @@\n- *                        We use special Opaque4 nodes to block some optimizations and replace the Assertion Predicates\n- *                        later in product builds.\n+ *                        We use special OpaqueTemplateAssertionPredicateNode nodes to block some optimizations and replace\n+ *                        the Assertion Predicates later in product builds.\n@@ -434,2 +434,2 @@\n-\/\/ A Template Assertion Predicate represents the Opaque4Node for the initial value or the last value of a\n-\/\/ Template Assertion Predicate and all the nodes up to and including the OpaqueLoop* nodes.\n+\/\/ A Template Assertion Predicate represents the OpaqueTemplateAssertionPredicateNode for the initial value or the last\n+\/\/ value of a Template Assertion Predicate and all the nodes up to and including the OpaqueLoop* nodes.\n@@ -437,1 +437,1 @@\n-  Opaque4Node* _opaque4_node;\n+  OpaqueTemplateAssertionPredicateNode* _opaque_node;\n@@ -440,1 +440,1 @@\n-  explicit TemplateAssertionExpression(Opaque4Node* opaque4_node) : _opaque4_node(opaque4_node) {}\n+  explicit TemplateAssertionExpression(OpaqueTemplateAssertionPredicateNode* opaque_node) : _opaque_node(opaque_node) {}\n@@ -443,1 +443,2 @@\n-  Opaque4Node* clone(const TransformStrategyForOpaqueLoopNodes& transform_strategy, Node* new_ctrl, PhaseIdealLoop* phase);\n+  OpaqueTemplateAssertionPredicateNode* clone(const TransformStrategyForOpaqueLoopNodes& transform_strategy,\n+                                              Node* new_ctrl, PhaseIdealLoop* phase);\n@@ -446,4 +447,4 @@\n-  Opaque4Node* clone(Node* new_ctrl, PhaseIdealLoop* phase);\n-  Opaque4Node* clone_and_replace_init(Node* new_init, Node* new_ctrl, PhaseIdealLoop* phase);\n-  Opaque4Node* clone_and_replace_init_and_stride(Node* new_control, Node* new_init, Node* new_stride,\n-                                                 PhaseIdealLoop* phase);\n+  OpaqueTemplateAssertionPredicateNode* clone(Node* new_ctrl, PhaseIdealLoop* phase);\n+  OpaqueTemplateAssertionPredicateNode* clone_and_replace_init(Node* new_init, Node* new_ctrl, PhaseIdealLoop* phase);\n+  OpaqueTemplateAssertionPredicateNode* clone_and_replace_init_and_stride(Node* new_control, Node* new_init,\n+                                                                          Node* new_stride, PhaseIdealLoop* phase);\n@@ -557,2 +558,4 @@\n-  Opaque4Node* create_for_init_value(Node* new_control, OpaqueLoopInitNode* opaque_init, bool& does_overflow) const;\n-  Opaque4Node* create_for_last_value(Node* new_control, OpaqueLoopInitNode* opaque_init, bool& does_overflow) const;\n+  OpaqueTemplateAssertionPredicateNode* create_for_init_value(Node* new_control, OpaqueLoopInitNode* opaque_init,\n+                                                              bool& does_overflow) const;\n+  OpaqueTemplateAssertionPredicateNode* create_for_last_value(Node* new_control, OpaqueLoopInitNode* opaque_init,\n+                                                              bool& does_overflow) const;\n@@ -560,1 +563,1 @@\n-  IfTrueNode* create_if_node_with_uncommon_trap(Opaque4Node* template_assertion_predicate_expression,\n+  IfTrueNode* create_if_node_with_uncommon_trap(OpaqueTemplateAssertionPredicateNode* template_assertion_predicate_expression,\n@@ -565,1 +568,2 @@\n-  IfTrueNode* create_if_node_with_halt(Node* new_control, Opaque4Node* template_assertion_predicate_expression,\n+  IfTrueNode* create_if_node_with_halt(Node* new_control,\n+                                       OpaqueTemplateAssertionPredicateNode* template_assertion_predicate_expression,\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -325,1 +325,2 @@\n-            if (use->is_Opaque4() || use->is_OpaqueInitializedAssertionPredicate()) {\n+            if (use->is_OpaqueNotNull() || use->is_OpaqueTemplateAssertionPredicate() ||\n+                use->is_OpaqueInitializedAssertionPredicate()) {\n@@ -354,2 +355,3 @@\n-              \/\/ Uses are either IfNodes, CMoves, Opaque4, or OpaqueInitializedAssertionPredicates\n-              if (u->is_Opaque4() || u->is_OpaqueInitializedAssertionPredicate()) {\n+              \/\/ Uses are either IfNodes, CMoves, OpaqueNotNull, or Opaque*AssertionPredicate\n+              if (u->is_OpaqueNotNull() || u->is_OpaqueTemplateAssertionPredicate() ||\n+                  u->is_OpaqueInitializedAssertionPredicate()) {\n@@ -424,2 +426,3 @@\n-    Opaque4Node* opaque4_node = template_assertion_predicate->in(1)->as_Opaque4();\n-    TemplateAssertionExpression template_assertion_expression(opaque4_node);\n+    OpaqueTemplateAssertionPredicateNode* opaque_node =\n+        template_assertion_predicate->in(1)->as_OpaqueTemplateAssertionPredicate();\n+    TemplateAssertionExpression template_assertion_expression(opaque_node);\n@@ -427,2 +430,2 @@\n-    Opaque4Node* cloned_opaque4_node = template_assertion_expression.clone(new_ctrl, this);\n-    igvn().replace_input_of(template_assertion_predicate, 1, cloned_opaque4_node);\n+    OpaqueTemplateAssertionPredicateNode* cloned_opaque_node = template_assertion_expression.clone(new_ctrl, this);\n+    igvn().replace_input_of(template_assertion_predicate, 1, cloned_opaque_node);\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"}]}