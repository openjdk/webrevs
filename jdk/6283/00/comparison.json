{"files":[{"patch":"@@ -32,0 +32,1 @@\n+#include <sys\/wait.h>\n@@ -33,0 +34,1 @@\n+#include <stddef.h>\n@@ -46,1 +48,1 @@\n-static JvmlLauncherData* initJvmlLauncherData(void) {\n+static JvmlLauncherData* initJvmlLauncherData(int* size) {\n@@ -89,1 +91,1 @@\n-    result = jvmLauncherCreateJvmlLauncherData(api, jvmLauncherHandle);\n+    result = jvmLauncherCreateJvmlLauncherData(api, jvmLauncherHandle, size);\n@@ -134,0 +136,32 @@\n+static void closePipeEnd(int* pipefd, int idx) {\n+    if (pipefd[idx] >= 0) {\n+        close(pipefd[idx]);\n+        pipefd[idx] = -1;\n+    }\n+}\n+\n+\n+static void initJvmlLauncherDataPointers(void* baseAddress,\n+                                        JvmlLauncherData* jvmLauncherData) {\n+    ptrdiff_t offset = (char*)jvmLauncherData - (char*)baseAddress;\n+    int i;\n+\n+    jvmLauncherData->jliLibPath += offset;\n+    jvmLauncherData->jliLaunchArgv =\n+            (char**)((char*)jvmLauncherData->jliLaunchArgv + offset);\n+    jvmLauncherData->envVarNames =\n+            (char**)((char*)jvmLauncherData->envVarNames + offset);\n+    jvmLauncherData->envVarValues =\n+            (char**)((char*)jvmLauncherData->envVarValues + offset);\n+\n+    for (i = 0; i != jvmLauncherData->jliLaunchArgc; i++) {\n+        jvmLauncherData->jliLaunchArgv[i] += offset;\n+    }\n+\n+    for (i = 0; i != jvmLauncherData->envVarCount; i++) {\n+        jvmLauncherData->envVarNames[i] += offset;\n+        jvmLauncherData->envVarValues[i] += offset;\n+    }\n+}\n+\n+\n@@ -135,0 +169,2 @@\n+    int pipefd[2];\n+    pid_t cpid;\n@@ -136,1 +172,2 @@\n-    JvmlLauncherData* jvmLauncherData;\n+    JvmlLauncherData* jvmLauncherData = 0;\n+    int jvmLauncherDataBufferSize = 0;\n@@ -141,2 +178,75 @@\n-    jvmLauncherData = initJvmlLauncherData();\n-    if (jvmLauncherData) {\n+    if (pipe(pipefd) == -1) {\n+        JP_LOG_ERRNO;\n+        return exitCode;\n+    }\n+\n+    cpid = fork();\n+    if (cpid == -1) {\n+        JP_LOG_ERRNO;\n+    } else if (cpid == 0) \/* Child process *\/ {\n+        \/* Close unused read end *\/\n+        closePipeEnd(pipefd, 0);\n+\n+        jvmLauncherData = initJvmlLauncherData(&jvmLauncherDataBufferSize);\n+        if (jvmLauncherData) {\n+            \/* Buffer size *\/\n+            if (write(pipefd[1], &jvmLauncherDataBufferSize,\n+                                    sizeof(jvmLauncherDataBufferSize)) == -1) {\n+                JP_LOG_ERRNO;\n+                goto cleanup;\n+            }\n+            if (jvmLauncherDataBufferSize) {\n+                \/* Buffer address *\/\n+                if (write(pipefd[1], &jvmLauncherData,\n+                                            sizeof(jvmLauncherData)) == -1) {\n+                    JP_LOG_ERRNO;\n+                    goto cleanup;\n+                }\n+                \/* Buffer data *\/\n+                if (write(pipefd[1], jvmLauncherData,\n+                                            jvmLauncherDataBufferSize) == -1) {\n+                    JP_LOG_ERRNO;\n+                    goto cleanup;\n+                }\n+            }\n+        }\n+\n+        exitCode = 0;\n+    } else if (cpid > 0) {\n+        void* baseAddress = 0;\n+\n+        \/* Close unused write end *\/\n+        closePipeEnd(pipefd, 1);\n+\n+        if (read(pipefd[0], &jvmLauncherDataBufferSize,\n+                                sizeof(jvmLauncherDataBufferSize)) == -1) {\n+            JP_LOG_ERRNO;\n+            goto cleanup;\n+        }\n+\n+        if (jvmLauncherDataBufferSize == 0) {\n+            JP_LOG_ERRNO;\n+            goto cleanup;\n+        }\n+\n+        if (read(pipefd[0], &baseAddress, sizeof(baseAddress)) == -1) {\n+            JP_LOG_ERRNO;\n+            goto cleanup;\n+        }\n+\n+        jvmLauncherData = malloc(jvmLauncherDataBufferSize);\n+        if (!jvmLauncherData) {\n+            JP_LOG_ERRNO;\n+            goto cleanup;\n+        }\n+\n+        if (read(pipefd[0], jvmLauncherData,\n+                                        jvmLauncherDataBufferSize) == -1) {\n+            JP_LOG_ERRNO;\n+            goto cleanup;\n+        }\n+\n+        closePipeEnd(pipefd, 0);\n+        wait(NULL); \/* Wait child process to terminate *\/\n+\n+        initJvmlLauncherDataPointers(baseAddress, jvmLauncherData);\n@@ -144,1 +254,0 @@\n-        free(jvmLauncherData);\n@@ -147,0 +256,4 @@\n+cleanup:\n+    closePipeEnd(pipefd, 0);\n+    closePipeEnd(pipefd, 1);\n+    free(jvmLauncherData);\n","filename":"src\/jdk.jpackage\/linux\/native\/applauncher\/LinuxLauncher.c","additions":119,"deletions":6,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -116,10 +116,0 @@\n-    JP_TRY;\n-    if (0 != setenv(_JPACKAGE_LAUNCHER.c_str(), launchInfo.c_str(), 1)) {\n-        JP_THROW(tstrings::any() << \"setenv(\" << _JPACKAGE_LAUNCHER\n-                << \", \" << launchInfo << \") failed. Error: \" << lastCRTError());\n-    } else {\n-        LOG_TRACE(tstrings::any() << \"Set \"\n-                << _JPACKAGE_LAUNCHER << \"=[\" << launchInfo << \"]\");\n-    }\n-    JP_CATCH_ALL;\n-\n@@ -127,0 +117,2 @@\n+\n+    jvmLauncher->addEnvVariable(_JPACKAGE_LAUNCHER, launchInfo);\n","filename":"src\/jdk.jpackage\/linux\/native\/libapplauncher\/LinuxLauncherLib.cpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -133,0 +133,2 @@\n+    std::unique_ptr<Jvm> jvm(new Jvm());\n+\n@@ -134,1 +136,1 @@\n-        SysInfo::setEnvVariable(libEnvVarName, SysInfo::getEnvVariable(\n+        (*jvm).addEnvVariable(libEnvVarName, SysInfo::getEnvVariable(\n@@ -140,2 +142,0 @@\n-    std::unique_ptr<Jvm> jvm(new Jvm());\n-\n","filename":"src\/jdk.jpackage\/share\/native\/applauncher\/AppLauncher.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -204,1 +204,1 @@\n-                                                            jlh.release()));\n+                                                        jlh.release(), 0));\n@@ -218,0 +218,7 @@\n+void Jvm::setEnvVariables() {\n+    for (size_t i = 0; i != envVarNames.size(); i++) {\n+        SysInfo::setEnvVariable(envVarNames.at(i), envVarValues.at(i));\n+    }\n+}\n+\n+\n@@ -223,0 +230,2 @@\n+    tstring_array envVarNames;\n+    tstring_array envVarValues;\n@@ -233,0 +242,23 @@\n+    template <class T>\n+    static char* copyStrings(const std::vector<T>& src,\n+                JvmlLauncherData* ptr, const size_t offset, char* curPtr) {\n+        char** strArray = 0;\n+        if (ptr) {\n+            strArray = *reinterpret_cast<char***>(\n+                                    reinterpret_cast<char*>(ptr) + offset);\n+        }\n+\n+        for (size_t i = 0; i != src.size(); i++) {\n+            const size_t count = (src[i].size() + 1 \/* trailing zero *\/)\n+                                            * sizeof(typename T::value_type);\n+            if (ptr) {\n+                std::memcpy(curPtr, src[i].c_str(), count);\n+                strArray[i] = curPtr;\n+            }\n+\n+            curPtr += count;\n+        };\n+\n+        return curPtr;\n+    }\n+\n@@ -246,1 +278,1 @@\n-        \/\/ Next write array of char* pointing to JLI lib arg strings.\n+        \/\/ Write array of char* pointing to JLI lib arg strings.\n@@ -253,2 +285,1 @@\n-\n-        \/\/ Skip memory occupied by char* array.\n+        \/\/ Skip memory occupied by JvmlLauncherData::jliLaunchArgv array.\n@@ -256,0 +287,3 @@\n+        \/\/ Store JLI lib arg strings.\n+        curPtr = copyStrings(args, ptr,\n+                            offsetof(JvmlLauncherData, jliLaunchArgv), curPtr);\n@@ -257,9 +291,20 @@\n-        \/\/ Store array of strings.\n-        for (size_t i = 0; i != args.size(); i++) {\n-            const size_t count = (args[i].size() + 1 \/* trailing zero *\/);\n-            if (ptr) {\n-                std::memcpy(curPtr, args[i].c_str(), count);\n-                ptr->jliLaunchArgv[i] = curPtr;\n-            }\n-            curPtr += count;\n-        };\n+        \/\/ Write array of char* pointing to env variable name strings.\n+        if (ptr) {\n+            ptr->envVarNames = reinterpret_cast<TCHAR**>(curPtr);\n+            ptr->envVarCount = (int)envVarNames.size();\n+        }\n+        \/\/ Skip memory occupied by JvmlLauncherData::envVarNames array.\n+        curPtr += sizeof(TCHAR*) * envVarNames.size();\n+        \/\/ Store env variable names.\n+        curPtr = copyStrings(envVarNames, ptr,\n+                            offsetof(JvmlLauncherData, envVarNames), curPtr);\n+\n+        \/\/ Write array of char* pointing to env variable value strings.\n+        if (ptr) {\n+            ptr->envVarValues = reinterpret_cast<TCHAR**>(curPtr);\n+        }\n+        \/\/ Skip memory occupied by JvmlLauncherData::envVarValues array.\n+        curPtr += sizeof(TCHAR*) * envVarValues.size();\n+        \/\/ Store env variable values.\n+        curPtr = copyStrings(envVarValues, ptr,\n+                            offsetof(JvmlLauncherData, envVarValues), curPtr);\n@@ -279,7 +324,1 @@\n-} \/\/ namespace\n-\n-JvmlLauncherHandle Jvm::exportLauncher() const {\n-    std::unique_ptr<JliLaunchData> result(new JliLaunchData());\n-\n-    result->jliLibPath = tstrings::toUtf8(jvmPath);\n-\n+void copyStringArray(const tstring_array& src, std::vector<std::string>& dst) {\n@@ -288,2 +327,2 @@\n-        tstring_array::const_iterator it = args.begin();\n-        const tstring_array::const_iterator end = args.end();\n+        tstring_array::const_iterator it = src.begin();\n+        const tstring_array::const_iterator end = src.end();\n@@ -291,1 +330,1 @@\n-            result->args.push_back(tstrings::toACP(*it));\n+            dst.push_back(tstrings::toACP(*it));\n@@ -295,1 +334,1 @@\n-    result->args = args;\n+    dst = src;\n@@ -297,0 +336,12 @@\n+}\n+\n+} \/\/ namespace\n+\n+JvmlLauncherHandle Jvm::exportLauncher() const {\n+    std::unique_ptr<JliLaunchData> result(new JliLaunchData());\n+\n+    result->jliLibPath = tstrings::toUtf8(jvmPath);\n+\n+    copyStringArray(args, result->args);\n+    result->envVarNames = envVarNames;\n+    result->envVarValues = envVarValues;\n","filename":"src\/jdk.jpackage\/share\/native\/applauncher\/JvmLauncher.cpp","additions":75,"deletions":24,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -32,0 +32,4 @@\n+#ifdef _WIN32\n+#include <windows.h>\n+#include <tchar.h>\n+#endif\n@@ -38,0 +42,4 @@\n+#ifndef _WIN32\n+typedef char TCHAR;\n+#endif\n+\n@@ -41,0 +49,1 @@\n+    int envVarCount;\n@@ -42,0 +51,2 @@\n+    TCHAR** envVarNames;\n+    TCHAR** envVarValues;\n@@ -74,1 +85,2 @@\n-JvmlLauncherData* jvmLauncherCreateJvmlLauncherData(JvmlLauncherAPI* api, JvmlLauncherHandle h);\n+JvmlLauncherData* jvmLauncherCreateJvmlLauncherData(JvmlLauncherAPI* api,\n+                                            JvmlLauncherHandle h, int* size);\n@@ -108,0 +120,6 @@\n+    Jvm& addEnvVariable(const tstring& name, const tstring& value) {\n+        envVarNames.push_back(name);\n+        envVarValues.push_back(value);\n+        return *this;\n+    }\n+\n@@ -121,0 +139,2 @@\n+    void setEnvVariables();\n+\n@@ -126,0 +146,2 @@\n+    tstring_array envVarNames;\n+    tstring_array envVarValues;\n","filename":"src\/jdk.jpackage\/share\/native\/applauncher\/JvmLauncher.h","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+#ifdef LINUX\n+#include <unistd.h>\n+#endif\n@@ -47,1 +50,1 @@\n-                                JvmlLauncherAPI* api, JvmlLauncherHandle h) {\n+                    JvmlLauncherAPI* api, JvmlLauncherHandle h, int* size) {\n@@ -72,0 +75,3 @@\n+        if (size) {\n+            *size = jvmLauncherDataBufferSize;\n+        }\n@@ -88,0 +94,4 @@\n+    for (i = 0; i < jvmArgs->envVarCount; ++i) {\n+        JP_LOG_TRACE(\"env var[%d]: %s=[%s]\", i, jvmArgs->envVarNames[i],\n+                                                jvmArgs->envVarValues[i]);\n+    }\n@@ -92,0 +102,1 @@\n+    int i;\n@@ -95,0 +106,15 @@\n+\n+    for (i = 0; i < jvmArgs->envVarCount; ++i) {\n+#ifdef _WIN32\n+        if (!SetEnvironmentVariable(jvmArgs->envVarNames[i],\n+                                                jvmArgs->envVarValues[i])) {\n+            JP_LOG_TRACE(\"SetEnvironmentVariable(%d) failed\", i);\n+        }\n+#else\n+        if (setenv(jvmArgs->envVarNames[i],\n+                                        jvmArgs->envVarValues[i], 1) != 0) {\n+            JP_LOG_TRACE(\"setenv(%d) failed\", i);\n+        }\n+#endif\n+    }\n+\n@@ -124,0 +150,3 @@\n+#endif\n+#ifdef LINUX\n+    fprintf(stderr, \"[%d]: \", getpid());\n","filename":"src\/jdk.jpackage\/share\/native\/applauncher\/JvmLauncherLib.c","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -59,1 +59,4 @@\n-    ::setenv(name.c_str(), value.c_str(), 1);\n+    if (::setenv(name.c_str(), value.c_str(), 1) != 0) {\n+        JP_THROW(tstrings::any() << \"setenv(\" << name << \", \" << value\n+                                    << \") failed. Error: \" << lastCRTError());\n+    }\n","filename":"src\/jdk.jpackage\/unix\/native\/common\/UnixSysInfo.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -157,0 +157,2 @@\n+        jvm->setEnvVariables();\n+\n","filename":"src\/jdk.jpackage\/windows\/native\/applauncher\/WinLauncher.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}