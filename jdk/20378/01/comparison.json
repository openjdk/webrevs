{"files":[{"patch":"@@ -240,1 +240,0 @@\n-      DISABLED_WARNINGS_gcc_gtk2_interface.c := parentheses type-limits, \\\n@@ -255,1 +254,0 @@\n-      DISABLED_WARNINGS_clang_gtk2_interface.c := parentheses, \\\n@@ -265,2 +263,0 @@\n-      DISABLED_WARNINGS_clang_aix_gtk2_interface.c := parentheses \\\n-          logical-op-parentheses, \\\n","filename":"make\/modules\/java.desktop\/lib\/AwtLibraries.gmk","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-    \/** This enum mirrors that in gtk2_interface.h *\/\n+    \/** This enum mirrors that in gtk_interface.h *\/\n@@ -631,1 +631,1 @@\n-    \/* GtkSettings enum mirrors that in gtk2_interface.h *\/\n+    \/* GtkSettings enum mirrors that in gtk_interface.h *\/\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKEngine.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-    static final int DEFAULT_TOGGLE_MENU_ITEM_SIZE = 12; \/\/ For pre-gtk2.4\n+    static final int DEFAULT_TOGGLE_MENU_ITEM_SIZE = 12;\n@@ -69,1 +69,1 @@\n-                methodName == TREE_EXPANDED_ICON)\n+                    methodName == TREE_EXPANDED_ICON)\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKIconFactory.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -80,1 +80,0 @@\n-    private static boolean IS_22;\n@@ -127,11 +126,0 @@\n-    \/**\n-     * Returns true if running on system containing at least 2.2.\n-     *\/\n-    static boolean is2_2() {\n-        \/\/ NOTE: We're currently hard coding to use 2.2.\n-        \/\/ If we want to support both GTK 2.0 and 2.2, we'll\n-        \/\/ need to get the major\/minor\/micro version from the .so.\n-        \/\/ Refer to bug 4912613 for details.\n-        return IS_22;\n-    }\n-\n@@ -1457,11 +1445,1 @@\n-        if (UNIXToolkit.getGtkVersion() == UNIXToolkit.GtkVersions.GTK2) {\n-            @SuppressWarnings(\"removal\")\n-            String version = AccessController.doPrivileged(\n-                    new GetPropertyAction(\"jdk.gtk.version\"));\n-            if (version != null) {\n-                IS_22 = version.equals(\"2.2\");\n-            } else {\n-                IS_22 = true;\n-            }\n-        } else if (UNIXToolkit.getGtkVersion() ==\n-                                UNIXToolkit.GtkVersions.GTK3) {\n+        if (UNIXToolkit.getGtkVersion() == UNIXToolkit.GtkVersions.GTK3) {\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKLookAndFeel.java","additions":1,"deletions":23,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -216,11 +216,0 @@\n-                return;\n-            }\n-            synchronized (UNIXToolkit.GTK_LOCK) {\n-                if (! ENGINE.paintCachedImage(g, x, y, w, h, id)) {\n-                    ShadowType shadow = (GTKLookAndFeel.is2_2() ?\n-                        ShadowType.NONE : ShadowType.OUT);\n-                    ENGINE.startPainting(g, x, y, w, h, id);\n-                    ENGINE.paintBox(g, context, id, gtkState,\n-                            shadow, \"menuitem\", x, y, w, h);\n-                    ENGINE.finishPainting();\n-                }\n@@ -575,12 +564,0 @@\n-                return;\n-            }\n-            Region id = Region.MENU_ITEM;\n-            synchronized (UNIXToolkit.GTK_LOCK) {\n-                if (! ENGINE.paintCachedImage(g, x, y, w, h, id)) {\n-                    ShadowType shadow = (GTKLookAndFeel.is2_2() ?\n-                        ShadowType.NONE : ShadowType.OUT);\n-                    ENGINE.startPainting(g, x, y, w, h, id);\n-                    ENGINE.paintBox(g, context, id, gtkState, shadow,\n-                            \"menuitem\", x, y, w, h);\n-                    ENGINE.finishPainting();\n-                }\n@@ -1087,3 +1064,3 @@\n-                        y += focusSize + (GTKLookAndFeel.is3() ? 3 : 1);\n-                        w -= 2 * focusSize + (GTKLookAndFeel.is3() ? 4 : 1);\n-                        h -= 2 * focusSize + (GTKLookAndFeel.is3() ? 6 : 2);\n+                        y += focusSize + 3;\n+                        w -= 2 * focusSize + 4;\n+                        h -= 2 * focusSize + 6;\n@@ -1091,4 +1068,4 @@\n-                        x += focusSize + (GTKLookAndFeel.is3() ? 2 : 0);\n-                        y += focusSize + (GTKLookAndFeel.is3() ? 2 :0 );\n-                        w -= 2 * focusSize + (GTKLookAndFeel.is3() ? 4 : 0);\n-                        h -= 2 * focusSize + (GTKLookAndFeel.is3() ? 4 : 0);\n+                        x += focusSize + 2;\n+                        y += focusSize + 2;\n+                        w -= 2 * focusSize + 4;\n+                        h -= 2 * focusSize + 4;\n@@ -1440,5 +1417,0 @@\n-        if (!GTKLookAndFeel.is3()) {\n-            x += 3;\n-            y += 3;\n-            w = h = 7;\n-        }\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKPainter.java","additions":7,"deletions":35,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -754,8 +754,1 @@\n-        if (!GTKLookAndFeel.is3()) {\n-            if (region == Region.FORMATTED_TEXT_FIELD ||\n-                  region == Region.PASSWORD_FIELD ||\n-                  region == Region.SPINNER ||\n-                  region == Region.TEXT_FIELD) {\n-                return true;\n-            }\n-        }\n+\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKStyle.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -73,5 +73,0 @@\n-    private static final String GTK2_DEPRECATION_MESSAGE =\n-            \"WARNING: the GTK 2 library is deprecated and \" +\n-                    \"its support will be removed in a future release\";\n-    private static volatile boolean gtk2WarningIssued = false;\n-\n@@ -81,1 +76,0 @@\n-        GTK2(Constants.GTK2_MAJOR_NUMBER),\n@@ -85,1 +79,0 @@\n-            static final int GTK2_MAJOR_NUMBER = 2;\n@@ -97,2 +90,0 @@\n-                case Constants.GTK2_MAJOR_NUMBER:\n-                    return GTK2;\n@@ -501,9 +492,1 @@\n-        if (version == null) {\n-            return GtkVersions.ANY;\n-        } else if (version.startsWith(\"2\")) {\n-            if (!gtk2WarningIssued) {\n-                System.err.println(GTK2_DEPRECATION_MESSAGE);\n-                gtk2WarningIssued = true;\n-            }\n-            return GtkVersions.GTK2;\n-        } else if(\"3\".equals(version) ){\n+        if (\"3\".equals(version)) {\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/UNIXToolkit.java","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1,2603 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifdef HEADLESS\n-    #error This file should not be included in headless library\n-#endif\n-\n-#include <dlfcn.h>\n-#include <setjmp.h>\n-#include <X11\/Xlib.h>\n-#include <limits.h>\n-#include <stdio.h>\n-#include <string.h>\n-#include \"gtk2_interface.h\"\n-#include \"java_awt_Transparency.h\"\n-#include \"jvm_md.h\"\n-#include \"sizecalc.h\"\n-#include <jni_util.h>\n-#include \"awt.h\"\n-\n-#define GTK_TYPE_BORDER                 ((*fp_gtk_border_get_type)())\n-\n-#define G_TYPE_FUNDAMENTAL_SHIFT        (2)\n-#define G_TYPE_MAKE_FUNDAMENTAL(x)      ((GType) ((x) << G_TYPE_FUNDAMENTAL_SHIFT))\n-\n-#define CONV_BUFFER_SIZE 128\n-\n-#define NO_SYMBOL_EXCEPTION 1\n-\n-static void *gtk2_libhandle = NULL;\n-static void *gthread_libhandle = NULL;\n-\n-static jmp_buf j;\n-\n-\/* Widgets *\/\n-static GtkWidget *gtk2_widget = NULL;\n-static GtkWidget *gtk2_window = NULL;\n-static GtkFixed  *gtk2_fixed  = NULL;\n-\n-\/* Paint system *\/\n-static GdkPixmap *gtk2_white_pixmap = NULL;\n-static GdkPixmap *gtk2_black_pixmap = NULL;\n-static GdkPixbuf *gtk2_white_pixbuf = NULL;\n-static GdkPixbuf *gtk2_black_pixbuf = NULL;\n-static int gtk2_pixbuf_width = 0;\n-static int gtk2_pixbuf_height = 0;\n-\n-\/* Static buffer for conversion from java.lang.String to UTF-8 *\/\n-static char convertionBuffer[CONV_BUFFER_SIZE];\n-\n-static gboolean new_combo = TRUE;\n-const char ENV_PREFIX[] = \"GTK_MODULES=\";\n-\n-\n-static GtkWidget *gtk2_widgets[_GTK_WIDGET_TYPE_SIZE];\n-\n-\/*************************\n- * Glib function pointers\n- *************************\/\n-\n-static gboolean (*fp_g_main_context_iteration)(GMainContext *context,\n-                                             gboolean may_block);\n-\n-static GValue*      (*fp_g_value_init)(GValue *value, GType g_type);\n-static gboolean     (*fp_g_type_is_a)(GType type, GType is_a_type);\n-static gboolean     (*fp_g_value_get_boolean)(const GValue *value);\n-static gchar        (*fp_g_value_get_char)(const GValue *value);\n-static guchar       (*fp_g_value_get_uchar)(const GValue *value);\n-static gint         (*fp_g_value_get_int)(const GValue *value);\n-static guint        (*fp_g_value_get_uint)(const GValue *value);\n-static glong        (*fp_g_value_get_long)(const GValue *value);\n-static gulong       (*fp_g_value_get_ulong)(const GValue *value);\n-static gint64       (*fp_g_value_get_int64)(const GValue *value);\n-static guint64      (*fp_g_value_get_uint64)(const GValue *value);\n-static gfloat       (*fp_g_value_get_float)(const GValue *value);\n-static gdouble      (*fp_g_value_get_double)(const GValue *value);\n-static const gchar* (*fp_g_value_get_string)(const GValue *value);\n-static gint         (*fp_g_value_get_enum)(const GValue *value);\n-static guint        (*fp_g_value_get_flags)(const GValue *value);\n-static GParamSpec*  (*fp_g_value_get_param)(const GValue *value);\n-static gpointer*    (*fp_g_value_get_boxed)(const GValue *value);\n-static gpointer*    (*fp_g_value_get_pointer)(const GValue *value);\n-static GObject*     (*fp_g_value_get_object)(const GValue *value);\n-static GParamSpec*  (*fp_g_param_spec_int)(const gchar *name,\n-        const gchar *nick, const gchar *blurb,\n-        gint minimum, gint maximum, gint default_value,\n-        GParamFlags flags);\n-static void         (*fp_g_object_get)(gpointer object,\n-                                       const gchar* fpn, ...);\n-static void         (*fp_g_object_set)(gpointer object,\n-                                       const gchar *first_property_name,\n-                                       ...);\n-\/************************\n- * GDK function pointers\n- ************************\/\n-static GdkPixmap *(*fp_gdk_pixmap_new)(GdkDrawable *drawable,\n-        gint width, gint height, gint depth);\n-static GdkGC *(*fp_gdk_gc_new)(GdkDrawable*);\n-static void (*fp_gdk_rgb_gc_set_foreground)(GdkGC*, guint32);\n-static void (*fp_gdk_draw_rectangle)(GdkDrawable*, GdkGC*, gboolean,\n-        gint, gint, gint, gint);\n-static GdkPixbuf *(*fp_gdk_pixbuf_new)(GdkColorspace colorspace,\n-        gboolean has_alpha, int bits_per_sample, int width, int height);\n-static void (*fp_gdk_drawable_get_size)(GdkDrawable *drawable,\n-        gint* width, gint* height);\n-\n-\/************************\n- * Gtk function pointers\n- ************************\/\n-static gboolean (*fp_gtk_init_check)(int* argc, char** argv);\n-\n-\/* Painting *\/\n-static void (*fp_gtk_paint_hline)(GtkStyle* style, GdkWindow* window,\n-        GtkStateType state_type, GdkRectangle* area, GtkWidget* widget,\n-        const gchar* detail, gint x1, gint x2, gint y);\n-static void (*fp_gtk_paint_vline)(GtkStyle* style, GdkWindow* window,\n-        GtkStateType state_type, GdkRectangle* area, GtkWidget* widget,\n-        const gchar* detail, gint y1, gint y2, gint x);\n-static void (*fp_gtk_paint_shadow)(GtkStyle* style, GdkWindow* window,\n-        GtkStateType state_type, GtkShadowType shadow_type,\n-        GdkRectangle* area, GtkWidget* widget, const gchar* detail,\n-        gint x, gint y, gint width, gint height);\n-static void (*fp_gtk_paint_arrow)(GtkStyle* style, GdkWindow* window,\n-        GtkStateType state_type, GtkShadowType shadow_type,\n-        GdkRectangle* area, GtkWidget* widget, const gchar* detail,\n-        GtkArrowType arrow_type, gboolean fill, gint x, gint y,\n-        gint width, gint height);\n-static void (*fp_gtk_paint_box)(GtkStyle* style, GdkWindow* window,\n-        GtkStateType state_type, GtkShadowType shadow_type,\n-        GdkRectangle* area, GtkWidget* widget, const gchar* detail,\n-        gint x, gint y, gint width, gint height);\n-static void (*fp_gtk_paint_flat_box)(GtkStyle* style, GdkWindow* window,\n-        GtkStateType state_type, GtkShadowType shadow_type,\n-        GdkRectangle* area, GtkWidget* widget, const gchar* detail,\n-        gint x, gint y, gint width, gint height);\n-static void (*fp_gtk_paint_check)(GtkStyle* style, GdkWindow* window,\n-        GtkStateType state_type, GtkShadowType shadow_type,\n-        GdkRectangle* area, GtkWidget* widget, const gchar* detail,\n-        gint x, gint y, gint width, gint height);\n-static void (*fp_gtk_paint_option)(GtkStyle* style, GdkWindow* window,\n-        GtkStateType state_type, GtkShadowType shadow_type,\n-        GdkRectangle* area, GtkWidget* widget, const gchar* detail,\n-        gint x, gint y, gint width, gint height);\n-static void (*fp_gtk_paint_box_gap)(GtkStyle* style, GdkWindow* window,\n-        GtkStateType state_type, GtkShadowType shadow_type,\n-        GdkRectangle* area, GtkWidget* widget, const gchar* detail,\n-        gint x, gint y, gint width, gint height,\n-        GtkPositionType gap_side, gint gap_x, gint gap_width);\n-static void (*fp_gtk_paint_extension)(GtkStyle* style, GdkWindow* window,\n-        GtkStateType state_type, GtkShadowType shadow_type,\n-        GdkRectangle* area, GtkWidget* widget, const gchar* detail,\n-        gint x, gint y, gint width, gint height, GtkPositionType gap_side);\n-static void (*fp_gtk_paint_focus)(GtkStyle* style, GdkWindow* window,\n-        GtkStateType state_type, GdkRectangle* area, GtkWidget* widget,\n-        const gchar* detail, gint x, gint y, gint width, gint height);\n-static void (*fp_gtk_paint_slider)(GtkStyle* style, GdkWindow* window,\n-        GtkStateType state_type, GtkShadowType shadow_type,\n-        GdkRectangle* area, GtkWidget* widget, const gchar* detail,\n-        gint x, gint y, gint width, gint height, GtkOrientation orientation);\n-static void (*fp_gtk_paint_handle)(GtkStyle* style, GdkWindow* window,\n-        GtkStateType state_type, GtkShadowType shadow_type,\n-        GdkRectangle* area, GtkWidget* widget, const gchar* detail,\n-        gint x, gint y, gint width, gint height, GtkOrientation orientation);\n-static void (*fp_gtk_paint_expander)(GtkStyle* style, GdkWindow* window,\n-        GtkStateType state_type, GdkRectangle* area, GtkWidget* widget,\n-        const gchar* detail, gint x, gint y, GtkExpanderStyle expander_style);\n-static void (*fp_gtk_style_apply_default_background)(GtkStyle* style,\n-        GdkWindow* window, gboolean set_bg, GtkStateType state_type,\n-        GdkRectangle* area, gint x, gint y, gint width, gint height);\n-\n-\/* Widget creation *\/\n-static GtkWidget* (*fp_gtk_arrow_new)(GtkArrowType arrow_type,\n-                                      GtkShadowType shadow_type);\n-static GtkWidget* (*fp_gtk_button_new)();\n-static GtkWidget* (*fp_gtk_check_button_new)();\n-static GtkWidget* (*fp_gtk_check_menu_item_new)();\n-static GtkWidget* (*fp_gtk_color_selection_dialog_new)(const gchar* title);\n-static GtkWidget* (*fp_gtk_combo_box_new)();\n-static GtkWidget* (*fp_gtk_combo_box_entry_new)();\n-static GtkWidget* (*fp_gtk_entry_new)();\n-static GtkWidget* (*fp_gtk_fixed_new)();\n-static GtkWidget* (*fp_gtk_handle_box_new)();\n-static GtkWidget* (*fp_gtk_hpaned_new)();\n-static GtkWidget* (*fp_gtk_vpaned_new)();\n-static GtkWidget* (*fp_gtk_hscale_new)(GtkAdjustment* adjustment);\n-static GtkWidget* (*fp_gtk_vscale_new)(GtkAdjustment* adjustment);\n-static GtkWidget* (*fp_gtk_hscrollbar_new)(GtkAdjustment* adjustment);\n-static GtkWidget* (*fp_gtk_vscrollbar_new)(GtkAdjustment* adjustment);\n-static GtkWidget* (*fp_gtk_hseparator_new)();\n-static GtkWidget* (*fp_gtk_vseparator_new)();\n-static GtkWidget* (*fp_gtk_image_new)();\n-static GtkWidget* (*fp_gtk_label_new)(const gchar* str);\n-static GtkWidget* (*fp_gtk_menu_new)();\n-static GtkWidget* (*fp_gtk_menu_bar_new)();\n-static GtkWidget* (*fp_gtk_menu_item_new)();\n-static GtkWidget* (*fp_gtk_notebook_new)();\n-static GtkWidget* (*fp_gtk_progress_bar_new)();\n-static GtkWidget* (*fp_gtk_progress_bar_set_orientation)(\n-        GtkProgressBar *pbar,\n-        GtkProgressBarOrientation orientation);\n-static GtkWidget* (*fp_gtk_radio_button_new)(GSList *group);\n-static GtkWidget* (*fp_gtk_radio_menu_item_new)(GSList *group);\n-static GtkWidget* (*fp_gtk_scrolled_window_new)(GtkAdjustment *hadjustment,\n-        GtkAdjustment *vadjustment);\n-static GtkWidget* (*fp_gtk_separator_menu_item_new)();\n-static GtkWidget* (*fp_gtk_separator_tool_item_new)();\n-static GtkWidget* (*fp_gtk_text_view_new)();\n-static GtkWidget* (*fp_gtk_toggle_button_new)();\n-static GtkWidget* (*fp_gtk_toolbar_new)();\n-static GtkWidget* (*fp_gtk_tree_view_new)();\n-static GtkWidget* (*fp_gtk_viewport_new)(GtkAdjustment *hadjustment,\n-        GtkAdjustment *vadjustment);\n-static GtkWidget* (*fp_gtk_window_new)(GtkWindowType type);\n-static GtkWidget* (*fp_gtk_dialog_new)();\n-static GtkWidget* (*fp_gtk_spin_button_new)(GtkAdjustment *adjustment,\n-        gdouble climb_rate, guint digits);\n-static GtkWidget* (*fp_gtk_frame_new)(const gchar *label);\n-\n-\/* Other widget operations *\/\n-static GtkObject* (*fp_gtk_adjustment_new)(gdouble value,\n-        gdouble lower, gdouble upper, gdouble step_increment,\n-        gdouble page_increment, gdouble page_size);\n-static void (*fp_gtk_container_add)(GtkContainer *window, GtkWidget *widget);\n-static void (*fp_gtk_menu_shell_append)(GtkMenuShell *menu_shell,\n-        GtkWidget *child);\n-static void (*fp_gtk_menu_item_set_submenu)(GtkMenuItem *menu_item,\n-        GtkWidget *submenu);\n-static void (*fp_gtk_widget_realize)(GtkWidget *widget);\n-static GdkPixbuf* (*fp_gtk_widget_render_icon)(GtkWidget *widget,\n-        const gchar *stock_id, GtkIconSize size, const gchar *detail);\n-static void (*fp_gtk_widget_set_name)(GtkWidget *widget, const gchar *name);\n-static void (*fp_gtk_widget_set_parent)(GtkWidget *widget, GtkWidget *parent);\n-static void (*fp_gtk_widget_set_direction)(GtkWidget *widget,\n-        GtkTextDirection direction);\n-static void (*fp_gtk_widget_style_get)(GtkWidget *widget,\n-        const gchar *first_property_name, ...);\n-static void (*fp_gtk_widget_class_install_style_property)(\n-        GtkWidgetClass* class, GParamSpec *pspec);\n-static GParamSpec* (*fp_gtk_widget_class_find_style_property)(\n-        GtkWidgetClass* class, const gchar* property_name);\n-static void (*fp_gtk_widget_style_get_property)(GtkWidget* widget,\n-        const gchar* property_name, GValue* value);\n-static char* (*fp_pango_font_description_to_string)(\n-        const PangoFontDescription* fd);\n-static GtkSettings* (*fp_gtk_settings_get_default)();\n-static GtkSettings* (*fp_gtk_widget_get_settings)(GtkWidget *widget);\n-static GType        (*fp_gtk_border_get_type)();\n-static void (*fp_gtk_arrow_set)(GtkWidget* arrow,\n-                                GtkArrowType arrow_type,\n-                                GtkShadowType shadow_type);\n-static void (*fp_gtk_widget_size_request)(GtkWidget *widget,\n-                                          GtkRequisition *requisition);\n-static GtkAdjustment* (*fp_gtk_range_get_adjustment)(GtkRange* range);\n-\n-\/* Method bodies *\/\n-\n-static void throw_exception(JNIEnv *env, const char* name, const char* message)\n-{\n-    jclass class = (*env)->FindClass(env, name);\n-\n-    if (class != NULL)\n-        (*env)->ThrowNew(env, class, message);\n-\n-    (*env)->DeleteLocalRef(env, class);\n-}\n-\n-\/* This is a workaround for the bug:\n- * http:\/\/sourceware.org\/bugzilla\/show_bug.cgi?id=1814\n- * (dlsym\/dlopen clears dlerror state)\n- * This bug is specific to Linux, but there is no harm in\n- * applying this workaround on Solaris as well.\n- *\/\n-static void* dl_symbol(const char* name)\n-{\n-    void* result = dlsym(gtk2_libhandle, name);\n-    if (!result)\n-        longjmp(j, NO_SYMBOL_EXCEPTION);\n-\n-    return result;\n-}\n-\n-static void* dl_symbol_gthread(const char* name)\n-{\n-    void* result = dlsym(gthread_libhandle, name);\n-    if (!result)\n-        longjmp(j, NO_SYMBOL_EXCEPTION);\n-\n-    return result;\n-}\n-\n-gboolean gtk2_check(const char* lib_name, gboolean load)\n-{\n-    if (gtk2_libhandle != NULL) {\n-        \/* We've already successfully opened the GTK libs, so return true. *\/\n-        return TRUE;\n-    } else {\n-        void *lib = NULL;\n-\n-#ifdef RTLD_NOLOAD\n-        \/* Just check if gtk libs are already in the process space *\/\n-        lib = dlopen(lib_name, RTLD_LAZY | RTLD_NOLOAD);\n-        if (!load || lib != NULL) {\n-            return lib != NULL;\n-        }\n-#else\n-#ifdef _AIX\n-        \/* On AIX we could implement this with the help of loadquery(L_GETINFO, ..)  *\/\n-        \/* (see reload_table() in hotspot\/src\/os\/aix\/vm\/loadlib_aix.cpp) but it is   *\/\n-        \/* probably not worth it because most AIX servers don't have GTK libs anyway *\/\n-#endif\n-#endif\n-\n-        lib = dlopen(lib_name, RTLD_LAZY | RTLD_LOCAL);\n-        if (lib == NULL) {\n-            return FALSE;\n-        }\n-\n-        fp_gtk_check_version = dlsym(lib, \"gtk_check_version\");\n-        \/* Check for GTK 2.2+ *\/\n-        if (!fp_gtk_check_version(2, 2, 0)) {\n-            return TRUE;\n-        }\n-\n-        \/\/ 8048289: workaround for https:\/\/bugzilla.gnome.org\/show_bug.cgi?id=733065\n-        \/\/ dlclose(lib);\n-\n-        return FALSE;\n-    }\n-}\n-\n-#define ADD_SUPPORTED_ACTION(actionStr) \\\n-do { \\\n-    jfieldID fld_action = (*env)->GetStaticFieldID(env, cls_action, actionStr, \"Ljava\/awt\/Desktop$Action;\"); \\\n-    if (!(*env)->ExceptionCheck(env)) { \\\n-        jobject action = (*env)->GetStaticObjectField(env, cls_action, fld_action); \\\n-        (*env)->CallBooleanMethod(env, supportedActions, mid_arrayListAdd, action); \\\n-    } else { \\\n-        (*env)->ExceptionClear(env); \\\n-    } \\\n-} while(0);\n-\n-\n-static void update_supported_actions(JNIEnv *env) {\n-    GVfs * (*fp_g_vfs_get_default) (void);\n-    const gchar * const * (*fp_g_vfs_get_supported_uri_schemes) (GVfs * vfs);\n-    const gchar * const * schemes = NULL;\n-\n-    jclass cls_action = (*env)->FindClass(env, \"java\/awt\/Desktop$Action\");\n-    CHECK_NULL(cls_action);\n-    jclass cls_xDesktopPeer = (*env)->FindClass(env, \"sun\/awt\/X11\/XDesktopPeer\");\n-    CHECK_NULL(cls_xDesktopPeer);\n-    jfieldID fld_supportedActions = (*env)->GetStaticFieldID(env, cls_xDesktopPeer, \"supportedActions\", \"Ljava\/util\/List;\");\n-    CHECK_NULL(fld_supportedActions);\n-    jobject supportedActions = (*env)->GetStaticObjectField(env, cls_xDesktopPeer, fld_supportedActions);\n-\n-    jclass cls_arrayList = (*env)->FindClass(env, \"java\/util\/ArrayList\");\n-    CHECK_NULL(cls_arrayList);\n-    jmethodID mid_arrayListAdd = (*env)->GetMethodID(env, cls_arrayList, \"add\", \"(Ljava\/lang\/Object;)Z\");\n-    CHECK_NULL(mid_arrayListAdd);\n-    jmethodID mid_arrayListClear = (*env)->GetMethodID(env, cls_arrayList, \"clear\", \"()V\");\n-    CHECK_NULL(mid_arrayListClear);\n-\n-    (*env)->CallVoidMethod(env, supportedActions, mid_arrayListClear);\n-\n-    ADD_SUPPORTED_ACTION(\"OPEN\");\n-\n-    \/**\n-     * gtk_show_uri() documentation says:\n-     *\n-     * > you need to install gvfs to get support for uri schemes such as http:\/\/\n-     * > or ftp:\/\/, as only local files are handled by GIO itself.\n-     *\n-     * So OPEN action was safely added here.\n-     * However, it looks like Solaris 11 have gvfs support only for 32-bit\n-     * applications only by default.\n-     *\/\n-\n-    fp_g_vfs_get_default = dl_symbol(\"g_vfs_get_default\");\n-    fp_g_vfs_get_supported_uri_schemes = dl_symbol(\"g_vfs_get_supported_uri_schemes\");\n-    dlerror();\n-\n-    if (fp_g_vfs_get_default && fp_g_vfs_get_supported_uri_schemes) {\n-        GVfs * vfs = fp_g_vfs_get_default();\n-        schemes = vfs ? fp_g_vfs_get_supported_uri_schemes(vfs) : NULL;\n-        if (schemes) {\n-            int i = 0;\n-            while (schemes[i]) {\n-                if (strcmp(schemes[i], \"http\") == 0) {\n-                    ADD_SUPPORTED_ACTION(\"BROWSE\");\n-                    ADD_SUPPORTED_ACTION(\"MAIL\");\n-                    break;\n-                }\n-                i++;\n-            }\n-        }\n-    } else {\n-#ifdef DEBUG\n-        fprintf(stderr, \"Cannot load g_vfs_get_supported_uri_schemes\\n\");\n-#endif \/* DEBUG *\/\n-    }\n-\n-}\n-\/**\n- * Functions for awt_Desktop.c\n- *\/\n-static gboolean gtk2_show_uri_load(JNIEnv *env) {\n-     gboolean success = FALSE;\n-     dlerror();\n-     const char *gtk_version = fp_gtk_check_version(2, 14, 0);\n-     if (gtk_version != NULL) {\n-         \/\/ The gtk_show_uri is available from GTK+ 2.14\n-#ifdef DEBUG\n-         fprintf (stderr, \"The version of GTK is %s. \"\n-             \"The gtk_show_uri function is supported \"\n-             \"since GTK+ 2.14.\\n\", gtk_version);\n-#endif \/* DEBUG *\/\n-     } else {\n-         \/\/ Loading symbols only if the GTK version is 2.14 and higher\n-         fp_gtk_show_uri = dl_symbol(\"gtk_show_uri\");\n-         const char *dlsym_error = dlerror();\n-         if (dlsym_error) {\n-#ifdef DEBUG\n-             fprintf (stderr, \"Cannot load symbol: %s \\n\", dlsym_error);\n-#endif \/* DEBUG *\/\n-         } else if (fp_gtk_show_uri == NULL) {\n-#ifdef DEBUG\n-             fprintf(stderr, \"dlsym(gtk_show_uri) returned NULL\\n\");\n-#endif \/* DEBUG *\/\n-        } else {\n-            gtk->gtk_show_uri = fp_gtk_show_uri;\n-            update_supported_actions(env);\n-            success = TRUE;\n-        }\n-     }\n-     return success;\n-}\n-\n-\/**\n- * Functions for sun_awt_X11_GtkFileDialogPeer.c\n- *\/\n-static void gtk2_file_chooser_load()\n-{\n-    fp_gtk_file_chooser_get_filename = dl_symbol(\n-            \"gtk_file_chooser_get_filename\");\n-    fp_gtk_file_chooser_dialog_new = dl_symbol(\"gtk_file_chooser_dialog_new\");\n-    fp_gtk_file_chooser_set_current_folder = dl_symbol(\n-            \"gtk_file_chooser_set_current_folder\");\n-    fp_gtk_file_chooser_set_filename = dl_symbol(\n-            \"gtk_file_chooser_set_filename\");\n-    fp_gtk_file_chooser_set_current_name = dl_symbol(\n-            \"gtk_file_chooser_set_current_name\");\n-    fp_gtk_file_filter_add_custom = dl_symbol(\"gtk_file_filter_add_custom\");\n-    fp_gtk_file_chooser_set_filter = dl_symbol(\"gtk_file_chooser_set_filter\");\n-    fp_gtk_file_chooser_get_type = dl_symbol(\"gtk_file_chooser_get_type\");\n-    fp_gtk_file_filter_new = dl_symbol(\"gtk_file_filter_new\");\n-    if (fp_gtk_check_version(2, 8, 0) == NULL) {\n-        fp_gtk_file_chooser_set_do_overwrite_confirmation = dl_symbol(\n-                \"gtk_file_chooser_set_do_overwrite_confirmation\");\n-    }\n-    fp_gtk_file_chooser_set_select_multiple = dl_symbol(\n-            \"gtk_file_chooser_set_select_multiple\");\n-    fp_gtk_file_chooser_get_current_folder = dl_symbol(\n-            \"gtk_file_chooser_get_current_folder\");\n-    fp_gtk_file_chooser_get_filenames = dl_symbol(\n-            \"gtk_file_chooser_get_filenames\");\n-    fp_gtk_g_slist_length = dl_symbol(\"g_slist_length\");\n-    fp_gdk_x11_drawable_get_xid = dl_symbol(\"gdk_x11_drawable_get_xid\");\n-}\n-\n-GtkApi* gtk2_load(JNIEnv *env, const char* lib_name)\n-{\n-    gboolean result;\n-    int i;\n-    int (*handler)();\n-    int (*io_handler)();\n-    char *gtk_modules_env;\n-\n-    gtk2_libhandle = dlopen(lib_name, RTLD_LAZY | RTLD_LOCAL);\n-    if (gtk2_libhandle == NULL) {\n-        return FALSE;\n-    }\n-\n-    gthread_libhandle = dlopen(GTHREAD_LIB_VERSIONED, RTLD_LAZY | RTLD_LOCAL);\n-    if (gthread_libhandle == NULL) {\n-        gthread_libhandle = dlopen(GTHREAD_LIB, RTLD_LAZY | RTLD_LOCAL);\n-        if (gthread_libhandle == NULL)\n-            return FALSE;\n-    }\n-\n-    if (setjmp(j) == 0)\n-    {\n-        fp_gtk_check_version = dl_symbol(\"gtk_check_version\");\n-        \/* Check for GTK 2.2+ *\/\n-        if (fp_gtk_check_version(2, 2, 0)) {\n-            longjmp(j, NO_SYMBOL_EXCEPTION);\n-        }\n-\n-        \/* GLib *\/\n-        fp_glib_check_version = dlsym(gtk2_libhandle, \"glib_check_version\");\n-        if (!fp_glib_check_version) {\n-            dlerror();\n-        }\n-        fp_g_free = dl_symbol(\"g_free\");\n-        fp_g_object_unref = dl_symbol(\"g_object_unref\");\n-\n-        fp_g_main_context_iteration =\n-            dl_symbol(\"g_main_context_iteration\");\n-\n-        fp_g_value_init = dl_symbol(\"g_value_init\");\n-        fp_g_type_is_a = dl_symbol(\"g_type_is_a\");\n-\n-        fp_g_value_get_boolean = dl_symbol(\"g_value_get_boolean\");\n-        fp_g_value_get_char = dl_symbol(\"g_value_get_char\");\n-        fp_g_value_get_uchar = dl_symbol(\"g_value_get_uchar\");\n-        fp_g_value_get_int = dl_symbol(\"g_value_get_int\");\n-        fp_g_value_get_uint = dl_symbol(\"g_value_get_uint\");\n-        fp_g_value_get_long = dl_symbol(\"g_value_get_long\");\n-        fp_g_value_get_ulong = dl_symbol(\"g_value_get_ulong\");\n-        fp_g_value_get_int64 = dl_symbol(\"g_value_get_int64\");\n-        fp_g_value_get_uint64 = dl_symbol(\"g_value_get_uint64\");\n-        fp_g_value_get_float = dl_symbol(\"g_value_get_float\");\n-        fp_g_value_get_double = dl_symbol(\"g_value_get_double\");\n-        fp_g_value_get_string = dl_symbol(\"g_value_get_string\");\n-        fp_g_value_get_enum = dl_symbol(\"g_value_get_enum\");\n-        fp_g_value_get_flags = dl_symbol(\"g_value_get_flags\");\n-        fp_g_value_get_param = dl_symbol(\"g_value_get_param\");\n-        fp_g_value_get_boxed = dl_symbol(\"g_value_get_boxed\");\n-        fp_g_value_get_pointer = dl_symbol(\"g_value_get_pointer\");\n-        fp_g_value_get_object = dl_symbol(\"g_value_get_object\");\n-        fp_g_param_spec_int = dl_symbol(\"g_param_spec_int\");\n-        fp_g_object_get = dl_symbol(\"g_object_get\");\n-        fp_g_object_set = dl_symbol(\"g_object_set\");\n-\n-        \/* GDK *\/\n-        fp_gdk_get_default_root_window =\n-            dl_symbol(\"gdk_get_default_root_window\");\n-        fp_gdk_pixmap_new = dl_symbol(\"gdk_pixmap_new\");\n-        fp_gdk_pixbuf_get_from_drawable =\n-            dl_symbol(\"gdk_pixbuf_get_from_drawable\");\n-        fp_gdk_pixbuf_scale_simple =\n-            dl_symbol(\"gdk_pixbuf_scale_simple\");\n-        fp_gdk_gc_new = dl_symbol(\"gdk_gc_new\");\n-        fp_gdk_rgb_gc_set_foreground =\n-            dl_symbol(\"gdk_rgb_gc_set_foreground\");\n-        fp_gdk_draw_rectangle = dl_symbol(\"gdk_draw_rectangle\");\n-        fp_gdk_drawable_get_size = dl_symbol(\"gdk_drawable_get_size\");\n-\n-        \/* Pixbuf *\/\n-        fp_gdk_pixbuf_new = dl_symbol(\"gdk_pixbuf_new\");\n-        fp_gdk_pixbuf_new_from_file =\n-                dl_symbol(\"gdk_pixbuf_new_from_file\");\n-        fp_gdk_pixbuf_get_width = dl_symbol(\"gdk_pixbuf_get_width\");\n-        fp_gdk_pixbuf_get_height = dl_symbol(\"gdk_pixbuf_get_height\");\n-        fp_gdk_pixbuf_get_pixels = dl_symbol(\"gdk_pixbuf_get_pixels\");\n-        fp_gdk_pixbuf_get_rowstride =\n-                dl_symbol(\"gdk_pixbuf_get_rowstride\");\n-        fp_gdk_pixbuf_get_has_alpha =\n-                dl_symbol(\"gdk_pixbuf_get_has_alpha\");\n-        fp_gdk_pixbuf_get_bits_per_sample =\n-                dl_symbol(\"gdk_pixbuf_get_bits_per_sample\");\n-        fp_gdk_pixbuf_get_n_channels =\n-                dl_symbol(\"gdk_pixbuf_get_n_channels\");\n-        fp_gdk_pixbuf_get_colorspace =\n-                dl_symbol(\"gdk_pixbuf_get_colorspace\");\n-\n-        \/* GTK painting *\/\n-        fp_gtk_init_check = dl_symbol(\"gtk_init_check\");\n-        fp_gtk_paint_hline = dl_symbol(\"gtk_paint_hline\");\n-        fp_gtk_paint_vline = dl_symbol(\"gtk_paint_vline\");\n-        fp_gtk_paint_shadow = dl_symbol(\"gtk_paint_shadow\");\n-        fp_gtk_paint_arrow = dl_symbol(\"gtk_paint_arrow\");\n-        fp_gtk_paint_box = dl_symbol(\"gtk_paint_box\");\n-        fp_gtk_paint_flat_box = dl_symbol(\"gtk_paint_flat_box\");\n-        fp_gtk_paint_check = dl_symbol(\"gtk_paint_check\");\n-        fp_gtk_paint_option = dl_symbol(\"gtk_paint_option\");\n-        fp_gtk_paint_box_gap = dl_symbol(\"gtk_paint_box_gap\");\n-        fp_gtk_paint_extension = dl_symbol(\"gtk_paint_extension\");\n-        fp_gtk_paint_focus = dl_symbol(\"gtk_paint_focus\");\n-        fp_gtk_paint_slider = dl_symbol(\"gtk_paint_slider\");\n-        fp_gtk_paint_handle = dl_symbol(\"gtk_paint_handle\");\n-        fp_gtk_paint_expander = dl_symbol(\"gtk_paint_expander\");\n-        fp_gtk_style_apply_default_background =\n-                dl_symbol(\"gtk_style_apply_default_background\");\n-\n-        \/* GTK widgets *\/\n-        fp_gtk_arrow_new = dl_symbol(\"gtk_arrow_new\");\n-        fp_gtk_button_new = dl_symbol(\"gtk_button_new\");\n-        fp_gtk_spin_button_new = dl_symbol(\"gtk_spin_button_new\");\n-        fp_gtk_check_button_new = dl_symbol(\"gtk_check_button_new\");\n-        fp_gtk_check_menu_item_new =\n-                dl_symbol(\"gtk_check_menu_item_new\");\n-        fp_gtk_color_selection_dialog_new =\n-                dl_symbol(\"gtk_color_selection_dialog_new\");\n-        fp_gtk_entry_new = dl_symbol(\"gtk_entry_new\");\n-        fp_gtk_fixed_new = dl_symbol(\"gtk_fixed_new\");\n-        fp_gtk_handle_box_new = dl_symbol(\"gtk_handle_box_new\");\n-        fp_gtk_image_new = dl_symbol(\"gtk_image_new\");\n-        fp_gtk_hpaned_new = dl_symbol(\"gtk_hpaned_new\");\n-        fp_gtk_vpaned_new = dl_symbol(\"gtk_vpaned_new\");\n-        fp_gtk_hscale_new = dl_symbol(\"gtk_hscale_new\");\n-        fp_gtk_vscale_new = dl_symbol(\"gtk_vscale_new\");\n-        fp_gtk_hscrollbar_new = dl_symbol(\"gtk_hscrollbar_new\");\n-        fp_gtk_vscrollbar_new = dl_symbol(\"gtk_vscrollbar_new\");\n-        fp_gtk_hseparator_new = dl_symbol(\"gtk_hseparator_new\");\n-        fp_gtk_vseparator_new = dl_symbol(\"gtk_vseparator_new\");\n-        fp_gtk_label_new = dl_symbol(\"gtk_label_new\");\n-        fp_gtk_menu_new = dl_symbol(\"gtk_menu_new\");\n-        fp_gtk_menu_bar_new = dl_symbol(\"gtk_menu_bar_new\");\n-        fp_gtk_menu_item_new = dl_symbol(\"gtk_menu_item_new\");\n-        fp_gtk_menu_item_set_submenu =\n-                dl_symbol(\"gtk_menu_item_set_submenu\");\n-        fp_gtk_notebook_new = dl_symbol(\"gtk_notebook_new\");\n-        fp_gtk_progress_bar_new =\n-            dl_symbol(\"gtk_progress_bar_new\");\n-        fp_gtk_progress_bar_set_orientation =\n-            dl_symbol(\"gtk_progress_bar_set_orientation\");\n-        fp_gtk_radio_button_new =\n-            dl_symbol(\"gtk_radio_button_new\");\n-        fp_gtk_radio_menu_item_new =\n-            dl_symbol(\"gtk_radio_menu_item_new\");\n-        fp_gtk_scrolled_window_new =\n-            dl_symbol(\"gtk_scrolled_window_new\");\n-        fp_gtk_separator_menu_item_new =\n-            dl_symbol(\"gtk_separator_menu_item_new\");\n-        fp_gtk_text_view_new = dl_symbol(\"gtk_text_view_new\");\n-        fp_gtk_toggle_button_new =\n-            dl_symbol(\"gtk_toggle_button_new\");\n-        fp_gtk_toolbar_new = dl_symbol(\"gtk_toolbar_new\");\n-        fp_gtk_tree_view_new = dl_symbol(\"gtk_tree_view_new\");\n-        fp_gtk_viewport_new = dl_symbol(\"gtk_viewport_new\");\n-        fp_gtk_window_new = dl_symbol(\"gtk_window_new\");\n-        fp_gtk_window_present = dl_symbol(\"gtk_window_present\");\n-        fp_gtk_window_move = dl_symbol(\"gtk_window_move\");\n-        fp_gtk_window_resize = dl_symbol(\"gtk_window_resize\");\n-\n-          fp_gtk_dialog_new = dl_symbol(\"gtk_dialog_new\");\n-        fp_gtk_frame_new = dl_symbol(\"gtk_frame_new\");\n-\n-        fp_gtk_adjustment_new = dl_symbol(\"gtk_adjustment_new\");\n-        fp_gtk_container_add = dl_symbol(\"gtk_container_add\");\n-        fp_gtk_menu_shell_append =\n-            dl_symbol(\"gtk_menu_shell_append\");\n-        fp_gtk_widget_realize = dl_symbol(\"gtk_widget_realize\");\n-        fp_gtk_widget_destroy = dl_symbol(\"gtk_widget_destroy\");\n-        fp_gtk_widget_render_icon =\n-            dl_symbol(\"gtk_widget_render_icon\");\n-        fp_gtk_widget_set_name =\n-            dl_symbol(\"gtk_widget_set_name\");\n-        fp_gtk_widget_set_parent =\n-            dl_symbol(\"gtk_widget_set_parent\");\n-        fp_gtk_widget_set_direction =\n-            dl_symbol(\"gtk_widget_set_direction\");\n-        fp_gtk_widget_style_get =\n-            dl_symbol(\"gtk_widget_style_get\");\n-        fp_gtk_widget_class_install_style_property =\n-            dl_symbol(\"gtk_widget_class_install_style_property\");\n-        fp_gtk_widget_class_find_style_property =\n-            dl_symbol(\"gtk_widget_class_find_style_property\");\n-        fp_gtk_widget_style_get_property =\n-            dl_symbol(\"gtk_widget_style_get_property\");\n-        fp_pango_font_description_to_string =\n-            dl_symbol(\"pango_font_description_to_string\");\n-        fp_gtk_settings_get_default =\n-            dl_symbol(\"gtk_settings_get_default\");\n-        fp_gtk_widget_get_settings =\n-            dl_symbol(\"gtk_widget_get_settings\");\n-        fp_gtk_border_get_type =  dl_symbol(\"gtk_border_get_type\");\n-        fp_gtk_arrow_set = dl_symbol(\"gtk_arrow_set\");\n-        fp_gtk_widget_size_request =\n-            dl_symbol(\"gtk_widget_size_request\");\n-        fp_gtk_range_get_adjustment =\n-            dl_symbol(\"gtk_range_get_adjustment\");\n-\n-        fp_gtk_widget_hide = dl_symbol(\"gtk_widget_hide\");\n-        fp_gtk_main_quit = dl_symbol(\"gtk_main_quit\");\n-        fp_g_signal_connect_data = dl_symbol(\"g_signal_connect_data\");\n-        fp_gtk_widget_show = dl_symbol(\"gtk_widget_show\");\n-        fp_gtk_main = dl_symbol(\"gtk_main\");\n-\n-        fp_g_path_get_dirname = dl_symbol(\"g_path_get_dirname\");\n-\n-        \/**\n-         * GLib thread system\n-         *\/\n-        if (GLIB_CHECK_VERSION(2, 20, 0)) {\n-            fp_g_thread_get_initialized = dl_symbol_gthread(\"g_thread_get_initialized\");\n-        }\n-        fp_g_thread_init = dl_symbol_gthread(\"g_thread_init\");\n-        fp_gdk_threads_init = dl_symbol(\"gdk_threads_init\");\n-        fp_gdk_threads_enter = dl_symbol(\"gdk_threads_enter\");\n-        fp_gdk_threads_leave = dl_symbol(\"gdk_threads_leave\");\n-\n-        \/**\n-         * Functions for sun_awt_X11_GtkFileDialogPeer.c\n-         *\/\n-        if (fp_gtk_check_version(2, 4, 0) == NULL) {\n-            \/\/ The current GtkFileChooser is available from GTK+ 2.4\n-            gtk2_file_chooser_load();\n-        }\n-\n-        \/* Some functions may be missing in pre-2.4 GTK.\n-           We handle them specially here.\n-         *\/\n-        fp_gtk_combo_box_new = dlsym(gtk2_libhandle, \"gtk_combo_box_new\");\n-        if (fp_gtk_combo_box_new == NULL) {\n-            fp_gtk_combo_box_new = dl_symbol(\"gtk_combo_new\");\n-        }\n-\n-        fp_gtk_combo_box_entry_new =\n-            dlsym(gtk2_libhandle, \"gtk_combo_box_entry_new\");\n-        if (fp_gtk_combo_box_entry_new == NULL) {\n-            fp_gtk_combo_box_entry_new = dl_symbol(\"gtk_combo_new\");\n-            new_combo = FALSE;\n-        }\n-\n-        fp_gtk_separator_tool_item_new =\n-            dlsym(gtk2_libhandle, \"gtk_separator_tool_item_new\");\n-        if (fp_gtk_separator_tool_item_new == NULL) {\n-            fp_gtk_separator_tool_item_new =\n-                dl_symbol(\"gtk_vseparator_new\");\n-        }\n-\n-        fp_g_list_append = dl_symbol(\"g_list_append\");\n-        fp_g_list_free = dl_symbol(\"g_list_free\");\n-        fp_g_list_free_full = dl_symbol(\"g_list_free_full\");\n-    }\n-    \/* Now we have only one kind of exceptions: NO_SYMBOL_EXCEPTION\n-     * Otherwise we can check the return value of setjmp method.\n-     *\/\n-    else\n-    {\n-        dlclose(gtk2_libhandle);\n-        gtk2_libhandle = NULL;\n-\n-        dlclose(gthread_libhandle);\n-        gthread_libhandle = NULL;\n-\n-        return FALSE;\n-    }\n-\n-    \/*\n-     * Strip the AT-SPI GTK_MODULES if present\n-     *\/\n-    gtk_modules_env = getenv (\"GTK_MODULES\");\n-    if ((gtk_modules_env && strstr(gtk_modules_env, \"atk-bridge\")) ||\n-        (gtk_modules_env && strstr(gtk_modules_env, \"gail\"))) {\n-        \/* careful, strtok modifies its args *\/\n-        gchar *tmp_env = strdup(gtk_modules_env);\n-        if (tmp_env) {\n-            \/* the new env will be smaller than the old one *\/\n-            gchar *s, *new_env = SAFE_SIZE_STRUCT_ALLOC(malloc,\n-                    sizeof(ENV_PREFIX), 1, strlen (gtk_modules_env));\n-\n-            if (new_env) {\n-                strcpy(new_env, ENV_PREFIX);\n-\n-                \/* strip out 'atk-bridge' and 'gail' *\/\n-                size_t PREFIX_LENGTH = strlen(ENV_PREFIX);\n-                gchar *tmp_ptr = NULL;\n-                for (s = strtok_r(tmp_env, \":\", &tmp_ptr); s;\n-                     s = strtok_r(NULL, \":\", &tmp_ptr)) {\n-                    if ((!strstr(s, \"atk-bridge\")) && (!strstr(s, \"gail\"))) {\n-                        if (strlen(new_env) > PREFIX_LENGTH) {\n-                            new_env = strcat(new_env, \":\");\n-                        }\n-                        new_env = strcat(new_env, s);\n-                    }\n-                }\n-                if (putenv(new_env) != 0) {\n-                    \/* no free() on success, putenv() doesn't copy string *\/\n-                    free(new_env);\n-                }\n-            }\n-            free(tmp_env);\n-        }\n-    }\n-    \/*\n-     * GTK should be initialized with gtk_init_check() before use.\n-     *\n-     * gtk_init_check installs its own error handlers. It is critical that\n-     * we preserve error handler set from AWT. Otherwise we'll crash on\n-     * BadMatch errors which we would normally ignore. The IO error handler\n-     * is preserved here, too, just for consistency.\n-    *\/\n-    AWT_LOCK();\n-    handler = XSetErrorHandler(NULL);\n-    io_handler = XSetIOErrorHandler(NULL);\n-\n-    if (fp_gtk_check_version(2, 2, 0) == NULL) {\n-\n-        \/\/ Calling g_thread_init() multiple times leads to crash on GLib < 2.24\n-        \/\/ We can use g_thread_get_initialized () but it is available only for\n-        \/\/ GLib >= 2.20.\n-        gboolean is_g_thread_get_initialized = FALSE;\n-        if (GLIB_CHECK_VERSION(2, 20, 0)) {\n-            is_g_thread_get_initialized = fp_g_thread_get_initialized();\n-        }\n-\n-        if (!is_g_thread_get_initialized) {\n-            fp_g_thread_init(NULL);\n-        }\n-\n-        \/\/According the GTK documentation, gdk_threads_init() should be\n-        \/\/called before gtk_init() or gtk_init_check()\n-        fp_gdk_threads_init();\n-    }\n-    result = (*fp_gtk_init_check)(NULL, NULL);\n-\n-    XSetErrorHandler(handler);\n-    XSetIOErrorHandler(io_handler);\n-    AWT_UNLOCK();\n-\n-    \/* Initialize widget array. *\/\n-    for (i = 0; i < _GTK_WIDGET_TYPE_SIZE; i++)\n-    {\n-        gtk2_widgets[i] = NULL;\n-    }\n-    if (result) {\n-        GtkApi* gtk = (GtkApi*)malloc(sizeof(GtkApi));\n-        gtk2_init(gtk);\n-        return gtk;\n-    }\n-    return NULL;\n-}\n-\n-int gtk2_unload()\n-{\n-    int i;\n-    char *gtk2_error;\n-\n-    if (!gtk2_libhandle)\n-        return TRUE;\n-\n-    \/* Release painting objects *\/\n-    if (gtk2_white_pixmap != NULL) {\n-        (*fp_g_object_unref)(gtk2_white_pixmap);\n-        (*fp_g_object_unref)(gtk2_black_pixmap);\n-        (*fp_g_object_unref)(gtk2_white_pixbuf);\n-        (*fp_g_object_unref)(gtk2_black_pixbuf);\n-        gtk2_white_pixmap = gtk2_black_pixmap =\n-            gtk2_white_pixbuf = gtk2_black_pixbuf = NULL;\n-    }\n-    gtk2_pixbuf_width = 0;\n-    gtk2_pixbuf_height = 0;\n-\n-    if (gtk2_window != NULL) {\n-        \/* Destroying toplevel widget will destroy all contained widgets *\/\n-        (*fp_gtk_widget_destroy)(gtk2_window);\n-\n-        \/* Unset some static data so they get reinitialized on next load *\/\n-        gtk2_window = NULL;\n-    }\n-\n-    dlerror();\n-    dlclose(gtk2_libhandle);\n-    dlclose(gthread_libhandle);\n-    if ((gtk2_error = dlerror()) != NULL)\n-    {\n-        return FALSE;\n-    }\n-    return TRUE;\n-}\n-\n-\/* Dispatch all pending events from the GTK event loop.\n- * This is needed to catch theme change and update widgets' style.\n- *\/\n-static void flush_gtk_event_loop()\n-{\n-    while( (*fp_g_main_context_iteration)(NULL, FALSE));\n-}\n-\n-\/*\n- * Initialize components of containment hierarchy. This creates a GtkFixed\n- * inside a GtkWindow. All widgets get realized.\n- *\/\n-static void init_containers()\n-{\n-    if (gtk2_window == NULL)\n-    {\n-        gtk2_window = (*fp_gtk_window_new)(GTK_WINDOW_TOPLEVEL);\n-        gtk2_fixed = (GtkFixed *)(*fp_gtk_fixed_new)();\n-        (*fp_gtk_container_add)((GtkContainer*)gtk2_window,\n-                                (GtkWidget *)gtk2_fixed);\n-        (*fp_gtk_widget_realize)(gtk2_window);\n-        (*fp_gtk_widget_realize)((GtkWidget *)gtk2_fixed);\n-    }\n-}\n-\n-\/*\n- * Ensure everything is ready for drawing an element of the specified width\n- * and height.\n- *\n- * We should somehow handle translucent images. GTK can draw to X Drawables\n- * only, which don't support alpha. When we retrieve the image back from\n- * the server, translucency information is lost. There're several ways to\n- * work around this:\n- * 1) Subclass GdkPixmap and cache translucent objects on client side. This\n- * requires us to implement parts of X server drawing logic on client side.\n- * Many X requests can potentially be \"translucent\"; e.g. XDrawLine with\n- * fill=tile and a translucent tile is a \"translucent\" operation, whereas\n- * XDrawLine with fill=solid is an \"opaque\" one. Moreover themes can (and some\n- * do) intermix transparent and opaque operations which makes caching even\n- * more problematic.\n- * 2) Use Xorg 32bit ARGB visual when available. GDK has no native support\n- * for it (as of version 2.6). Also even in JDS 3 Xorg does not support\n- * these visuals by default, which makes optimizing for them pointless.\n- * We can consider doing this at a later point when ARGB visuals become more\n- * popular.\n- * 3') GTK has plans to use Cairo as its graphical backend (presumably in\n- * 2.8), and Cairo supports alpha. With it we could also get rid of the\n- * unnecessary round trip to server and do all the drawing on client side.\n- * 4) For now we draw to two different pixmaps and restore alpha channel by\n- * comparing results. This can be optimized by using subclassed pixmap and\n- * doing the second drawing only if necessary.\n-*\/\n-static void gtk2_init_painting(JNIEnv *env, gint width, gint height)\n-{\n-    GdkGC *gc;\n-    GdkPixbuf *white, *black;\n-\n-    init_containers();\n-\n-    if (gtk2_pixbuf_width < width || gtk2_pixbuf_height < height)\n-    {\n-        white = (*fp_gdk_pixbuf_new)(GDK_COLORSPACE_RGB, TRUE, 8, width, height);\n-        black = (*fp_gdk_pixbuf_new)(GDK_COLORSPACE_RGB, TRUE, 8, width, height);\n-\n-        if (white == NULL || black == NULL)\n-        {\n-            snprintf(convertionBuffer, CONV_BUFFER_SIZE, \"Couldn't create pixbuf of size %dx%d\", width, height);\n-            throw_exception(env, \"java\/lang\/RuntimeException\", convertionBuffer);\n-            fp_gdk_threads_leave();\n-            return;\n-        }\n-\n-        if (gtk2_white_pixmap != NULL) {\n-            \/* free old stuff *\/\n-            (*fp_g_object_unref)(gtk2_white_pixmap);\n-            (*fp_g_object_unref)(gtk2_black_pixmap);\n-            (*fp_g_object_unref)(gtk2_white_pixbuf);\n-            (*fp_g_object_unref)(gtk2_black_pixbuf);\n-        }\n-\n-        gtk2_white_pixmap = (*fp_gdk_pixmap_new)(gtk2_window->window, width, height, -1);\n-        gtk2_black_pixmap = (*fp_gdk_pixmap_new)(gtk2_window->window, width, height, -1);\n-\n-        gtk2_white_pixbuf = white;\n-        gtk2_black_pixbuf = black;\n-\n-        gtk2_pixbuf_width = width;\n-        gtk2_pixbuf_height = height;\n-    }\n-\n-    \/* clear the pixmaps *\/\n-    gc = (*fp_gdk_gc_new)(gtk2_white_pixmap);\n-    (*fp_gdk_rgb_gc_set_foreground)(gc, 0xffffff);\n-    (*fp_gdk_draw_rectangle)(gtk2_white_pixmap, gc, TRUE, 0, 0, width, height);\n-    (*fp_g_object_unref)(gc);\n-\n-    gc = (*fp_gdk_gc_new)(gtk2_black_pixmap);\n-    (*fp_gdk_rgb_gc_set_foreground)(gc, 0x000000);\n-    (*fp_gdk_draw_rectangle)(gtk2_black_pixmap, gc, TRUE, 0, 0, width, height);\n-    (*fp_g_object_unref)(gc);\n-}\n-\n-\/*\n- * Restore image from white and black pixmaps and copy it into destination\n- * buffer. This method compares two pixbufs taken from white and black\n- * pixmaps and decodes color and alpha components. Pixbufs are RGB without\n- * alpha, destination buffer is ABGR.\n- *\n- * The return value is the transparency type of the resulting image, either\n- * one of java_awt_Transparency_OPAQUE, java_awt_Transparency_BITMASK, and\n- * java_awt_Transparency_TRANSLUCENT.\n- *\/\n-static gint gtk2_copy_image(gint *dst, gint width, gint height)\n-{\n-    gint i, j, r, g, b;\n-    guchar *white, *black;\n-    gint stride, padding;\n-    gboolean is_opaque = TRUE;\n-    gboolean is_bitmask = TRUE;\n-\n-    (*fp_gdk_pixbuf_get_from_drawable)(gtk2_white_pixbuf, gtk2_white_pixmap,\n-            NULL, 0, 0, 0, 0, width, height);\n-    (*fp_gdk_pixbuf_get_from_drawable)(gtk2_black_pixbuf, gtk2_black_pixmap,\n-            NULL, 0, 0, 0, 0, width, height);\n-\n-    white = (*fp_gdk_pixbuf_get_pixels)(gtk2_white_pixbuf);\n-    black = (*fp_gdk_pixbuf_get_pixels)(gtk2_black_pixbuf);\n-    stride = (*fp_gdk_pixbuf_get_rowstride)(gtk2_black_pixbuf);\n-    padding = stride - width * 4;\n-    if (padding >= 0 && stride > 0) {\n-        for (i = 0; i < height; i++) {\n-            for (j = 0; j < width; j++) {\n-                int r1 = *white++;\n-                int r2 = *black++;\n-                int alpha = 0xff + r2 - r1;\n-\n-                switch (alpha) {\n-                    case 0:       \/* transparent pixel *\/\n-                        r = g = b = 0;\n-                        black += 3;\n-                        white += 3;\n-                        is_opaque = FALSE;\n-                        break;\n-\n-                    case 0xff:    \/* opaque pixel *\/\n-                        r = r2;\n-                        g = *black++;\n-                        b = *black++;\n-                        black++;\n-                        white += 3;\n-                        break;\n-\n-                    default:      \/* translucent pixel *\/\n-                        r = 0xff * r2 \/ alpha;\n-                        g = 0xff * *black++ \/ alpha;\n-                        b = 0xff * *black++ \/ alpha;\n-                        black++;\n-                        white += 3;\n-                        is_opaque = FALSE;\n-                        is_bitmask = FALSE;\n-                        break;\n-                }\n-\n-                *dst++ = (alpha << 24 | r << 16 | g << 8 | b);\n-            }\n-\n-            white += padding;\n-            black += padding;\n-        }\n-    }\n-    return is_opaque ? java_awt_Transparency_OPAQUE :\n-                       (is_bitmask ? java_awt_Transparency_BITMASK :\n-                                     java_awt_Transparency_TRANSLUCENT);\n-}\n-\n-static void\n-gtk2_set_direction(GtkWidget *widget, GtkTextDirection dir)\n-{\n-    \/*\n-     * Some engines (inexplicably) look at the direction of the widget's\n-     * parent, so we need to set the direction of both the widget and its\n-     * parent.\n-     *\/\n-    (*fp_gtk_widget_set_direction)(widget, dir);\n-    if (widget->parent != NULL) {\n-        (*fp_gtk_widget_set_direction)(widget->parent, dir);\n-    }\n-}\n-\n-\/*\n- * Initializes the widget to correct state for some engines.\n- * This is a pure empirical method.\n- *\/\n-static void init_toggle_widget(WidgetType widget_type, gint synth_state)\n-{\n-    gboolean is_active = ((synth_state & SELECTED) != 0);\n-\n-    if (widget_type == RADIO_BUTTON ||\n-        widget_type == CHECK_BOX ||\n-        widget_type == TOGGLE_BUTTON) {\n-        ((GtkToggleButton*)gtk2_widget)->active = is_active;\n-    }\n-\n-    if ((synth_state & FOCUSED) != 0) {\n-        ((GtkObject*)gtk2_widget)->flags |= GTK_HAS_FOCUS;\n-    } else {\n-        ((GtkObject*)gtk2_widget)->flags &= ~GTK_HAS_FOCUS;\n-    }\n-\n-    if ((((synth_state & MOUSE_OVER) != 0) && ((synth_state & PRESSED) == 0)) ||\n-           (((synth_state & FOCUSED) != 0) && ((synth_state & PRESSED) != 0))) {\n-        gtk2_widget->state = GTK_STATE_PRELIGHT;\n-    } else if ((synth_state & DISABLED) != 0) {\n-        gtk2_widget->state = GTK_STATE_INSENSITIVE;\n-    } else {\n-        gtk2_widget->state = is_active ? GTK_STATE_ACTIVE : GTK_STATE_NORMAL;\n-    }\n-}\n-\n-\/* GTK state_type filter *\/\n-static GtkStateType get_gtk_state_type(WidgetType widget_type, gint synth_state)\n-{\n-    GtkStateType result = GTK_STATE_NORMAL;\n-\n-    if ((synth_state & DISABLED) != 0) {\n-        result = GTK_STATE_INSENSITIVE;\n-    } else if ((synth_state & PRESSED) != 0) {\n-        result = GTK_STATE_ACTIVE;\n-    } else if ((synth_state & MOUSE_OVER) != 0) {\n-        result = GTK_STATE_PRELIGHT;\n-    }\n-    return result;\n-}\n-\n-\/* GTK shadow_type filter *\/\n-static GtkShadowType get_gtk_shadow_type(WidgetType widget_type, gint synth_state)\n-{\n-    GtkShadowType result = GTK_SHADOW_OUT;\n-\n-    if ((synth_state & SELECTED) != 0) {\n-        result = GTK_SHADOW_IN;\n-    }\n-    return result;\n-}\n-\n-\n-static GtkWidget* gtk2_get_arrow(GtkArrowType arrow_type, GtkShadowType shadow_type)\n-{\n-    GtkWidget *arrow = NULL;\n-    if (NULL == gtk2_widgets[_GTK_ARROW_TYPE])\n-    {\n-        gtk2_widgets[_GTK_ARROW_TYPE] = (*fp_gtk_arrow_new)(arrow_type, shadow_type);\n-        (*fp_gtk_container_add)((GtkContainer *)gtk2_fixed, gtk2_widgets[_GTK_ARROW_TYPE]);\n-        (*fp_gtk_widget_realize)(gtk2_widgets[_GTK_ARROW_TYPE]);\n-    }\n-    arrow = gtk2_widgets[_GTK_ARROW_TYPE];\n-\n-    (*fp_gtk_arrow_set)(arrow, arrow_type, shadow_type);\n-    return arrow;\n-}\n-\n-static GtkAdjustment* create_adjustment()\n-{\n-    return (GtkAdjustment *)\n-            (*fp_gtk_adjustment_new)(50.0, 0.0, 100.0, 10.0, 20.0, 20.0);\n-}\n-\n-\/**\n- * Returns a pointer to the cached native widget for the specified widget\n- * type.\n- *\/\n-static GtkWidget *gtk2_get_widget(WidgetType widget_type)\n-{\n-    gboolean init_result = FALSE;\n-    GtkWidget *result = NULL;\n-    switch (widget_type)\n-    {\n-        case BUTTON:\n-        case TABLE_HEADER:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_BUTTON_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_BUTTON_TYPE] = (*fp_gtk_button_new)();\n-            }\n-            result = gtk2_widgets[_GTK_BUTTON_TYPE];\n-            break;\n-        case CHECK_BOX:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_CHECK_BUTTON_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_CHECK_BUTTON_TYPE] =\n-                    (*fp_gtk_check_button_new)();\n-            }\n-            result = gtk2_widgets[_GTK_CHECK_BUTTON_TYPE];\n-            break;\n-        case CHECK_BOX_MENU_ITEM:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_CHECK_MENU_ITEM_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_CHECK_MENU_ITEM_TYPE] =\n-                    (*fp_gtk_check_menu_item_new)();\n-            }\n-            result = gtk2_widgets[_GTK_CHECK_MENU_ITEM_TYPE];\n-            break;\n-        \/************************************************************\n-         *    Creation a dedicated color chooser is dangerous because\n-         * it deadlocks the EDT\n-         ************************************************************\/\n-\/*        case COLOR_CHOOSER:\n-            if (init_result =\n-                    (NULL == gtk2_widgets[_GTK_COLOR_SELECTION_DIALOG_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_COLOR_SELECTION_DIALOG_TYPE] =\n-                    (*fp_gtk_color_selection_dialog_new)(NULL);\n-            }\n-            result = gtk2_widgets[_GTK_COLOR_SELECTION_DIALOG_TYPE];\n-            break;*\/\n-        case COMBO_BOX:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_COMBO_BOX_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_COMBO_BOX_TYPE] =\n-                    (*fp_gtk_combo_box_new)();\n-            }\n-            result = gtk2_widgets[_GTK_COMBO_BOX_TYPE];\n-            break;\n-        case COMBO_BOX_ARROW_BUTTON:\n-            if (init_result =\n-                    (NULL == gtk2_widgets[_GTK_COMBO_BOX_ARROW_BUTTON_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_COMBO_BOX_ARROW_BUTTON_TYPE] =\n-                     (*fp_gtk_toggle_button_new)();\n-            }\n-            result = gtk2_widgets[_GTK_COMBO_BOX_ARROW_BUTTON_TYPE];\n-            break;\n-        case COMBO_BOX_TEXT_FIELD:\n-            if (init_result =\n-                    (NULL == gtk2_widgets[_GTK_COMBO_BOX_TEXT_FIELD_TYPE]))\n-            {\n-                result = gtk2_widgets[_GTK_COMBO_BOX_TEXT_FIELD_TYPE] =\n-                     (*fp_gtk_entry_new)();\n-            }\n-            result = gtk2_widgets[_GTK_COMBO_BOX_TEXT_FIELD_TYPE];\n-            break;\n-        case DESKTOP_ICON:\n-        case INTERNAL_FRAME_TITLE_PANE:\n-        case LABEL:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_LABEL_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_LABEL_TYPE] =\n-                    (*fp_gtk_label_new)(NULL);\n-            }\n-            result = gtk2_widgets[_GTK_LABEL_TYPE];\n-            break;\n-        case DESKTOP_PANE:\n-        case PANEL:\n-        case ROOT_PANE:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_CONTAINER_TYPE]))\n-            {\n-                \/* There is no constructor for a container type.  I've\n-                 * chosen GtkFixed container since it has a default\n-                 * constructor.\n-                 *\/\n-                gtk2_widgets[_GTK_CONTAINER_TYPE] =\n-                    (*fp_gtk_fixed_new)();\n-            }\n-            result = gtk2_widgets[_GTK_CONTAINER_TYPE];\n-            break;\n-        case EDITOR_PANE:\n-        case TEXT_AREA:\n-        case TEXT_PANE:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_TEXT_VIEW_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_TEXT_VIEW_TYPE] =\n-                    (*fp_gtk_text_view_new)();\n-            }\n-            result = gtk2_widgets[_GTK_TEXT_VIEW_TYPE];\n-            break;\n-        case FORMATTED_TEXT_FIELD:\n-        case PASSWORD_FIELD:\n-        case TEXT_FIELD:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_ENTRY_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_ENTRY_TYPE] =\n-                    (*fp_gtk_entry_new)();\n-            }\n-            result = gtk2_widgets[_GTK_ENTRY_TYPE];\n-            break;\n-        case HANDLE_BOX:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_HANDLE_BOX_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_HANDLE_BOX_TYPE] =\n-                    (*fp_gtk_handle_box_new)();\n-            }\n-            result = gtk2_widgets[_GTK_HANDLE_BOX_TYPE];\n-            break;\n-        case HSCROLL_BAR:\n-        case HSCROLL_BAR_BUTTON_LEFT:\n-        case HSCROLL_BAR_BUTTON_RIGHT:\n-        case HSCROLL_BAR_TRACK:\n-        case HSCROLL_BAR_THUMB:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_HSCROLLBAR_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_HSCROLLBAR_TYPE] =\n-                    (*fp_gtk_hscrollbar_new)(create_adjustment());\n-            }\n-            result = gtk2_widgets[_GTK_HSCROLLBAR_TYPE];\n-            break;\n-        case HSEPARATOR:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_HSEPARATOR_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_HSEPARATOR_TYPE] =\n-                    (*fp_gtk_hseparator_new)();\n-            }\n-            result = gtk2_widgets[_GTK_HSEPARATOR_TYPE];\n-            break;\n-        case HSLIDER:\n-        case HSLIDER_THUMB:\n-        case HSLIDER_TRACK:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_HSCALE_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_HSCALE_TYPE] =\n-                    (*fp_gtk_hscale_new)(NULL);\n-            }\n-            result = gtk2_widgets[_GTK_HSCALE_TYPE];\n-            break;\n-        case HSPLIT_PANE_DIVIDER:\n-        case SPLIT_PANE:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_HPANED_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_HPANED_TYPE] = (*fp_gtk_hpaned_new)();\n-            }\n-            result = gtk2_widgets[_GTK_HPANED_TYPE];\n-            break;\n-        case IMAGE:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_IMAGE_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_IMAGE_TYPE] = (*fp_gtk_image_new)();\n-            }\n-            result = gtk2_widgets[_GTK_IMAGE_TYPE];\n-            break;\n-        case INTERNAL_FRAME:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_WINDOW_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_WINDOW_TYPE] =\n-                    (*fp_gtk_window_new)(GTK_WINDOW_TOPLEVEL);\n-            }\n-            result = gtk2_widgets[_GTK_WINDOW_TYPE];\n-            break;\n-        case TOOL_TIP:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_TOOLTIP_TYPE]))\n-            {\n-                result = (*fp_gtk_window_new)(GTK_WINDOW_TOPLEVEL);\n-                (*fp_gtk_widget_set_name)(result, \"gtk-tooltips\");\n-                gtk2_widgets[_GTK_TOOLTIP_TYPE] = result;\n-            }\n-            result = gtk2_widgets[_GTK_TOOLTIP_TYPE];\n-            break;\n-        case LIST:\n-        case TABLE:\n-        case TREE:\n-        case TREE_CELL:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_TREE_VIEW_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_TREE_VIEW_TYPE] =\n-                    (*fp_gtk_tree_view_new)();\n-            }\n-            result = gtk2_widgets[_GTK_TREE_VIEW_TYPE];\n-            break;\n-        case TITLED_BORDER:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_FRAME_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_FRAME_TYPE] = fp_gtk_frame_new(NULL);\n-            }\n-            result = gtk2_widgets[_GTK_FRAME_TYPE];\n-            break;\n-        case POPUP_MENU:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_MENU_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_MENU_TYPE] =\n-                    (*fp_gtk_menu_new)();\n-            }\n-            result = gtk2_widgets[_GTK_MENU_TYPE];\n-            break;\n-        case MENU:\n-        case MENU_ITEM:\n-        case MENU_ITEM_ACCELERATOR:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_MENU_ITEM_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_MENU_ITEM_TYPE] =\n-                    (*fp_gtk_menu_item_new)();\n-            }\n-            result = gtk2_widgets[_GTK_MENU_ITEM_TYPE];\n-            break;\n-        case MENU_BAR:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_MENU_BAR_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_MENU_BAR_TYPE] =\n-                    (*fp_gtk_menu_bar_new)();\n-            }\n-            result = gtk2_widgets[_GTK_MENU_BAR_TYPE];\n-            break;\n-        case COLOR_CHOOSER:\n-        case OPTION_PANE:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_DIALOG_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_DIALOG_TYPE] =\n-                    (*fp_gtk_dialog_new)();\n-            }\n-            result = gtk2_widgets[_GTK_DIALOG_TYPE];\n-            break;\n-        case POPUP_MENU_SEPARATOR:\n-            if (init_result =\n-                    (NULL == gtk2_widgets[_GTK_SEPARATOR_MENU_ITEM_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_SEPARATOR_MENU_ITEM_TYPE] =\n-                    (*fp_gtk_separator_menu_item_new)();\n-            }\n-            result = gtk2_widgets[_GTK_SEPARATOR_MENU_ITEM_TYPE];\n-            break;\n-        case HPROGRESS_BAR:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_HPROGRESS_BAR_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_HPROGRESS_BAR_TYPE] =\n-                    (*fp_gtk_progress_bar_new)();\n-            }\n-            result = gtk2_widgets[_GTK_HPROGRESS_BAR_TYPE];\n-            break;\n-        case VPROGRESS_BAR:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_VPROGRESS_BAR_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_VPROGRESS_BAR_TYPE] =\n-                    (*fp_gtk_progress_bar_new)();\n-                \/*\n-                 * Vertical JProgressBars always go bottom-to-top,\n-                 * regardless of the ComponentOrientation.\n-                 *\/\n-                (*fp_gtk_progress_bar_set_orientation)(\n-                    (GtkProgressBar *)gtk2_widgets[_GTK_VPROGRESS_BAR_TYPE],\n-                    GTK_PROGRESS_BOTTOM_TO_TOP);\n-            }\n-            result = gtk2_widgets[_GTK_VPROGRESS_BAR_TYPE];\n-            break;\n-        case RADIO_BUTTON:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_RADIO_BUTTON_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_RADIO_BUTTON_TYPE] =\n-                    (*fp_gtk_radio_button_new)(NULL);\n-            }\n-            result = gtk2_widgets[_GTK_RADIO_BUTTON_TYPE];\n-            break;\n-        case RADIO_BUTTON_MENU_ITEM:\n-            if (init_result =\n-                    (NULL == gtk2_widgets[_GTK_RADIO_MENU_ITEM_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_RADIO_MENU_ITEM_TYPE] =\n-                    (*fp_gtk_radio_menu_item_new)(NULL);\n-            }\n-            result = gtk2_widgets[_GTK_RADIO_MENU_ITEM_TYPE];\n-            break;\n-        case SCROLL_PANE:\n-            if (init_result =\n-                    (NULL == gtk2_widgets[_GTK_SCROLLED_WINDOW_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_SCROLLED_WINDOW_TYPE] =\n-                    (*fp_gtk_scrolled_window_new)(NULL, NULL);\n-            }\n-            result = gtk2_widgets[_GTK_SCROLLED_WINDOW_TYPE];\n-            break;\n-        case SPINNER:\n-        case SPINNER_ARROW_BUTTON:\n-        case SPINNER_TEXT_FIELD:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_SPIN_BUTTON_TYPE]))\n-            {\n-                result = gtk2_widgets[_GTK_SPIN_BUTTON_TYPE] =\n-                    (*fp_gtk_spin_button_new)(NULL, 0, 0);\n-            }\n-            result = gtk2_widgets[_GTK_SPIN_BUTTON_TYPE];\n-            break;\n-        case TABBED_PANE:\n-        case TABBED_PANE_TAB_AREA:\n-        case TABBED_PANE_CONTENT:\n-        case TABBED_PANE_TAB:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_NOTEBOOK_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_NOTEBOOK_TYPE] =\n-                    (*fp_gtk_notebook_new)();\n-            }\n-            result = gtk2_widgets[_GTK_NOTEBOOK_TYPE];\n-            break;\n-        case TOGGLE_BUTTON:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_TOGGLE_BUTTON_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_TOGGLE_BUTTON_TYPE] =\n-                    (*fp_gtk_toggle_button_new)();\n-            }\n-            result = gtk2_widgets[_GTK_TOGGLE_BUTTON_TYPE];\n-            break;\n-        case TOOL_BAR:\n-        case TOOL_BAR_DRAG_WINDOW:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_TOOLBAR_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_TOOLBAR_TYPE] =\n-                    (*fp_gtk_toolbar_new)();\n-            }\n-            result = gtk2_widgets[_GTK_TOOLBAR_TYPE];\n-            break;\n-        case TOOL_BAR_SEPARATOR:\n-            if (init_result =\n-                    (NULL == gtk2_widgets[_GTK_SEPARATOR_TOOL_ITEM_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_SEPARATOR_TOOL_ITEM_TYPE] =\n-                    (*fp_gtk_separator_tool_item_new)();\n-            }\n-            result = gtk2_widgets[_GTK_SEPARATOR_TOOL_ITEM_TYPE];\n-            break;\n-        case VIEWPORT:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_VIEWPORT_TYPE]))\n-            {\n-                GtkAdjustment *adjustment = create_adjustment();\n-                gtk2_widgets[_GTK_VIEWPORT_TYPE] =\n-                    (*fp_gtk_viewport_new)(adjustment, adjustment);\n-            }\n-            result = gtk2_widgets[_GTK_VIEWPORT_TYPE];\n-            break;\n-        case VSCROLL_BAR:\n-        case VSCROLL_BAR_BUTTON_UP:\n-        case VSCROLL_BAR_BUTTON_DOWN:\n-        case VSCROLL_BAR_TRACK:\n-        case VSCROLL_BAR_THUMB:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_VSCROLLBAR_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_VSCROLLBAR_TYPE] =\n-                    (*fp_gtk_vscrollbar_new)(create_adjustment());\n-            }\n-            result = gtk2_widgets[_GTK_VSCROLLBAR_TYPE];\n-            break;\n-        case VSEPARATOR:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_VSEPARATOR_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_VSEPARATOR_TYPE] =\n-                    (*fp_gtk_vseparator_new)();\n-            }\n-            result = gtk2_widgets[_GTK_VSEPARATOR_TYPE];\n-            break;\n-        case VSLIDER:\n-        case VSLIDER_THUMB:\n-        case VSLIDER_TRACK:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_VSCALE_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_VSCALE_TYPE] =\n-                    (*fp_gtk_vscale_new)(NULL);\n-            }\n-            result = gtk2_widgets[_GTK_VSCALE_TYPE];\n-            \/*\n-             * Vertical JSliders start at the bottom, while vertical\n-             * GtkVScale widgets start at the top (by default), so to fix\n-             * this we set the \"inverted\" flag to get the Swing behavior.\n-             *\/\n-            ((GtkRange*)result)->inverted = 1;\n-            break;\n-        case VSPLIT_PANE_DIVIDER:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_VPANED_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_VPANED_TYPE] = (*fp_gtk_vpaned_new)();\n-            }\n-            result = gtk2_widgets[_GTK_VPANED_TYPE];\n-            break;\n-        default:\n-            result = NULL;\n-            break;\n-    }\n-\n-    if (result != NULL && init_result)\n-    {\n-        if (widget_type == RADIO_BUTTON_MENU_ITEM ||\n-                widget_type == CHECK_BOX_MENU_ITEM ||\n-                widget_type == MENU_ITEM ||\n-                widget_type == MENU ||\n-                widget_type == POPUP_MENU_SEPARATOR)\n-        {\n-            GtkWidget *menu = gtk2_get_widget(POPUP_MENU);\n-            (*fp_gtk_menu_shell_append)((GtkMenuShell *)menu, result);\n-        }\n-        else if (widget_type == POPUP_MENU)\n-        {\n-            GtkWidget *menu_bar = gtk2_get_widget(MENU_BAR);\n-            GtkWidget *root_menu = (*fp_gtk_menu_item_new)();\n-            (*fp_gtk_menu_item_set_submenu)((GtkMenuItem*)root_menu, result);\n-            (*fp_gtk_menu_shell_append)((GtkMenuShell *)menu_bar, root_menu);\n-        }\n-        else if (widget_type == COMBO_BOX_ARROW_BUTTON ||\n-                 widget_type == COMBO_BOX_TEXT_FIELD)\n-        {\n-            \/*\n-            * We add a regular GtkButton\/GtkEntry to a GtkComboBoxEntry\n-            * in order to trick engines into thinking it's a real combobox\n-            * arrow button\/text field.\n-            *\/\n-            GtkWidget *combo = (*fp_gtk_combo_box_entry_new)();\n-\n-            if (new_combo && widget_type == COMBO_BOX_ARROW_BUTTON) {\n-                (*fp_gtk_widget_set_parent)(result, combo);\n-                ((GtkBin*)combo)->child = result;\n-            } else {\n-                (*fp_gtk_container_add)((GtkContainer *)combo, result);\n-            }\n-            (*fp_gtk_container_add)((GtkContainer *)gtk2_fixed, combo);\n-        }\n-        else if (widget_type != TOOL_TIP &&\n-                 widget_type != INTERNAL_FRAME &&\n-                 widget_type != OPTION_PANE)\n-        {\n-            (*fp_gtk_container_add)((GtkContainer *)gtk2_fixed, result);\n-        }\n-        (*fp_gtk_widget_realize)(result);\n-    }\n-    return result;\n-}\n-\n-void gtk2_paint_arrow(WidgetType widget_type, GtkStateType state_type,\n-        GtkShadowType shadow_type, const gchar *detail,\n-        gint x, gint y, gint width, gint height,\n-        GtkArrowType arrow_type, gboolean fill)\n-{\n-    static int w, h;\n-    static GtkRequisition size;\n-\n-    if (widget_type == COMBO_BOX_ARROW_BUTTON || widget_type == TABLE)\n-        gtk2_widget = gtk2_get_arrow(arrow_type, shadow_type);\n-    else\n-        gtk2_widget = gtk2_get_widget(widget_type);\n-\n-    switch (widget_type)\n-    {\n-        case SPINNER_ARROW_BUTTON:\n-            x = 1;\n-            y = ((arrow_type == GTK_ARROW_UP) ? 2 : 0);\n-            height -= 2;\n-            width -= 3;\n-\n-            w = width \/ 2;\n-            w -= w % 2 - 1;\n-            h = (w + 1) \/ 2;\n-            break;\n-\n-        case HSCROLL_BAR_BUTTON_LEFT:\n-        case HSCROLL_BAR_BUTTON_RIGHT:\n-        case VSCROLL_BAR_BUTTON_UP:\n-        case VSCROLL_BAR_BUTTON_DOWN:\n-            w = width \/ 2;\n-            h = height \/ 2;\n-            break;\n-\n-        case COMBO_BOX_ARROW_BUTTON:\n-        case TABLE:\n-            x = 1;\n-            (*fp_gtk_widget_size_request)(gtk2_widget, &size);\n-            w = size.width - ((GtkMisc*)gtk2_widget)->xpad * 2;\n-            h = size.height - ((GtkMisc*)gtk2_widget)->ypad * 2;\n-            w = h = MIN(MIN(w, h), MIN(width,height)) * 0.7;\n-            break;\n-\n-        default:\n-            w = width;\n-            h = height;\n-            break;\n-    }\n-    x += (width - w) \/ 2;\n-    y += (height - h) \/ 2;\n-\n-    (*fp_gtk_paint_arrow)(gtk2_widget->style, gtk2_white_pixmap, state_type,\n-            shadow_type, NULL, gtk2_widget, detail, arrow_type, fill,\n-            x, y, w, h);\n-    (*fp_gtk_paint_arrow)(gtk2_widget->style, gtk2_black_pixmap, state_type,\n-            shadow_type, NULL, gtk2_widget, detail, arrow_type, fill,\n-            x, y, w, h);\n-}\n-\n-static void gtk2_paint_box(WidgetType widget_type, GtkStateType state_type,\n-                    GtkShadowType shadow_type, const gchar *detail,\n-                    gint x, gint y, gint width, gint height,\n-                    gint synth_state, GtkTextDirection dir)\n-{\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-\n-    \/*\n-     * The clearlooks engine sometimes looks at the widget's state field\n-     * instead of just the state_type variable that we pass in, so to account\n-     * for those cases we set the widget's state field accordingly.  The\n-     * flags field is similarly important for things like focus\/default state.\n-     *\/\n-    gtk2_widget->state = state_type;\n-\n-    if (widget_type == HSLIDER_TRACK) {\n-        \/*\n-         * For horizontal JSliders with right-to-left orientation, we need\n-         * to set the \"inverted\" flag to match the native GTK behavior where\n-         * the foreground highlight is on the right side of the slider thumb.\n-         * This is needed especially for the ubuntulooks engine, which looks\n-         * exclusively at the \"inverted\" flag to determine on which side of\n-         * the thumb to paint the highlight...\n-         *\/\n-        ((GtkRange*)gtk2_widget)->inverted = (dir == GTK_TEXT_DIR_RTL);\n-\n-        \/*\n-         * Note however that other engines like clearlooks will look at both\n-         * the \"inverted\" field and the text direction to determine how\n-         * the foreground highlight is painted:\n-         *     !inverted && ltr --> paint highlight on left side\n-         *     !inverted && rtl --> paint highlight on right side\n-         *      inverted && ltr --> paint highlight on right side\n-         *      inverted && rtl --> paint highlight on left side\n-         * So the only way to reliably get the desired results for horizontal\n-         * JSlider (i.e., highlight on left side for LTR ComponentOrientation\n-         * and highlight on right side for RTL ComponentOrientation) is to\n-         * always override text direction as LTR, and then set the \"inverted\"\n-         * flag accordingly (as we have done above).\n-         *\/\n-        dir = GTK_TEXT_DIR_LTR;\n-    }\n-\n-    \/*\n-     * Some engines (e.g. clearlooks) will paint the shadow of certain\n-     * widgets (e.g. COMBO_BOX_ARROW_BUTTON) differently depending on the\n-     * the text direction.\n-     *\/\n-    gtk2_set_direction(gtk2_widget, dir);\n-\n-    switch (widget_type) {\n-    case BUTTON:\n-        if (synth_state & DEFAULT) {\n-            ((GtkObject*)gtk2_widget)->flags |= GTK_HAS_DEFAULT;\n-        } else {\n-            ((GtkObject*)gtk2_widget)->flags &= ~GTK_HAS_DEFAULT;\n-        }\n-        break;\n-    case TOGGLE_BUTTON:\n-        init_toggle_widget(widget_type, synth_state);\n-        break;\n-    case HSCROLL_BAR_BUTTON_LEFT:\n-        \/*\n-         * The clearlooks engine will draw a \"left\" button when:\n-         *   x == w->allocation.x\n-         *\n-         * The ubuntulooks engine will draw a \"left\" button when:\n-         *   [x,y,width,height]\n-         *     intersects\n-         *   [w->alloc.x,w->alloc.y,width,height]\n-         *\n-         * The values that are set below should ensure that a \"left\"\n-         * button is rendered for both of these (and other) engines.\n-         *\/\n-        gtk2_widget->allocation.x = x;\n-        gtk2_widget->allocation.y = y;\n-        gtk2_widget->allocation.width = width;\n-        gtk2_widget->allocation.height = height;\n-        break;\n-    case HSCROLL_BAR_BUTTON_RIGHT:\n-        \/*\n-         * The clearlooks engine will draw a \"right\" button when:\n-         *   x + width == w->allocation.x + w->allocation.width\n-         *\n-         * The ubuntulooks engine will draw a \"right\" button when:\n-         *   [x,y,width,height]\n-         *     does not intersect\n-         *   [w->alloc.x,w->alloc.y,width,height]\n-         *     but does intersect\n-         *   [w->alloc.x+width,w->alloc.y,width,height]\n-         *\n-         * The values that are set below should ensure that a \"right\"\n-         * button is rendered for both of these (and other) engines.\n-         *\/\n-        gtk2_widget->allocation.x = x+width;\n-        gtk2_widget->allocation.y = 0;\n-        gtk2_widget->allocation.width = 0;\n-        gtk2_widget->allocation.height = height;\n-        break;\n-    case VSCROLL_BAR_BUTTON_UP:\n-        \/*\n-         * The clearlooks engine will draw an \"up\" button when:\n-         *   y == w->allocation.y\n-         *\n-         * The ubuntulooks engine will draw an \"up\" button when:\n-         *   [x,y,width,height]\n-         *     intersects\n-         *   [w->alloc.x,w->alloc.y,width,height]\n-         *\n-         * The values that are set below should ensure that an \"up\"\n-         * button is rendered for both of these (and other) engines.\n-         *\/\n-        gtk2_widget->allocation.x = x;\n-        gtk2_widget->allocation.y = y;\n-        gtk2_widget->allocation.width = width;\n-        gtk2_widget->allocation.height = height;\n-        break;\n-    case VSCROLL_BAR_BUTTON_DOWN:\n-        \/*\n-         * The clearlooks engine will draw a \"down\" button when:\n-         *   y + height == w->allocation.y + w->allocation.height\n-         *\n-         * The ubuntulooks engine will draw a \"down\" button when:\n-         *   [x,y,width,height]\n-         *     does not intersect\n-         *   [w->alloc.x,w->alloc.y,width,height]\n-         *     but does intersect\n-         *   [w->alloc.x,w->alloc.y+height,width,height]\n-         *\n-         * The values that are set below should ensure that a \"down\"\n-         * button is rendered for both of these (and other) engines.\n-         *\/\n-        gtk2_widget->allocation.x = x;\n-        gtk2_widget->allocation.y = y+height;\n-        gtk2_widget->allocation.width = width;\n-        gtk2_widget->allocation.height = 0;\n-        break;\n-    default:\n-        break;\n-    }\n-\n-    (*fp_gtk_paint_box)(gtk2_widget->style, gtk2_white_pixmap, state_type,\n-            shadow_type, NULL, gtk2_widget, detail, x, y, width, height);\n-    (*fp_gtk_paint_box)(gtk2_widget->style, gtk2_black_pixmap, state_type,\n-            shadow_type, NULL, gtk2_widget, detail, x, y, width, height);\n-\n-    \/*\n-     * Reset the text direction to the default value so that we don't\n-     * accidentally affect other operations and widgets.\n-     *\/\n-    gtk2_set_direction(gtk2_widget, GTK_TEXT_DIR_LTR);\n-}\n-\n-void gtk2_paint_box_gap(WidgetType widget_type, GtkStateType state_type,\n-        GtkShadowType shadow_type, const gchar *detail,\n-        gint x, gint y, gint width, gint height,\n-        GtkPositionType gap_side, gint gap_x, gint gap_width)\n-{\n-    \/* Clearlooks needs a real clip area to paint the gap properly *\/\n-    GdkRectangle area = { x, y, width, height };\n-\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-    (*fp_gtk_paint_box_gap)(gtk2_widget->style, gtk2_white_pixmap, state_type,\n-            shadow_type, &area, gtk2_widget, detail,\n-            x, y, width, height, gap_side, gap_x, gap_width);\n-    (*fp_gtk_paint_box_gap)(gtk2_widget->style, gtk2_black_pixmap, state_type,\n-            shadow_type, &area, gtk2_widget, detail,\n-            x, y, width, height, gap_side, gap_x, gap_width);\n-}\n-\n-static void gtk2_paint_check(WidgetType widget_type, gint synth_state,\n-        const gchar *detail, gint x, gint y, gint width, gint height)\n-{\n-    GtkStateType state_type = get_gtk_state_type(widget_type, synth_state);\n-    GtkShadowType shadow_type = get_gtk_shadow_type(widget_type, synth_state);\n-\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-    init_toggle_widget(widget_type, synth_state);\n-\n-    (*fp_gtk_paint_check)(gtk2_widget->style, gtk2_white_pixmap, state_type,\n-            shadow_type, NULL, gtk2_widget, detail,\n-            x, y, width, height);\n-    (*fp_gtk_paint_check)(gtk2_widget->style, gtk2_black_pixmap, state_type,\n-            shadow_type, NULL, gtk2_widget, detail,\n-            x, y, width, height);\n-}\n-\n-static void gtk2_paint_expander(WidgetType widget_type, GtkStateType state_type,\n-        const gchar *detail, gint x, gint y, gint width, gint height,\n-        GtkExpanderStyle expander_style)\n-{\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-    (*fp_gtk_paint_expander)(gtk2_widget->style, gtk2_white_pixmap,\n-            state_type, NULL, gtk2_widget, detail,\n-            x + width \/ 2, y + height \/ 2, expander_style);\n-    (*fp_gtk_paint_expander)(gtk2_widget->style, gtk2_black_pixmap,\n-            state_type, NULL, gtk2_widget, detail,\n-            x + width \/ 2, y + height \/ 2, expander_style);\n-}\n-\n-static void gtk2_paint_extension(WidgetType widget_type, GtkStateType state_type,\n-        GtkShadowType shadow_type, const gchar *detail,\n-        gint x, gint y, gint width, gint height, GtkPositionType gap_side)\n-{\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-    (*fp_gtk_paint_extension)(gtk2_widget->style, gtk2_white_pixmap,\n-            state_type, shadow_type, NULL, gtk2_widget, detail,\n-            x, y, width, height, gap_side);\n-    (*fp_gtk_paint_extension)(gtk2_widget->style, gtk2_black_pixmap,\n-            state_type, shadow_type, NULL, gtk2_widget, detail,\n-            x, y, width, height, gap_side);\n-}\n-\n-static void gtk2_paint_flat_box(WidgetType widget_type, GtkStateType state_type,\n-        GtkShadowType shadow_type, const gchar *detail,\n-        gint x, gint y, gint width, gint height, gboolean has_focus)\n-{\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-\n-    if (has_focus)\n-        ((GtkObject*)gtk2_widget)->flags |= GTK_HAS_FOCUS;\n-    else\n-        ((GtkObject*)gtk2_widget)->flags &= ~GTK_HAS_FOCUS;\n-\n-    (*fp_gtk_paint_flat_box)(gtk2_widget->style, gtk2_white_pixmap,\n-            state_type, shadow_type, NULL, gtk2_widget, detail,\n-            x, y, width, height);\n-    (*fp_gtk_paint_flat_box)(gtk2_widget->style, gtk2_black_pixmap,\n-            state_type, shadow_type, NULL, gtk2_widget, detail,\n-            x, y, width, height);\n-}\n-\n-static void gtk2_paint_focus(WidgetType widget_type, GtkStateType state_type,\n-        const char *detail, gint x, gint y, gint width, gint height)\n-{\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-    (*fp_gtk_paint_focus)(gtk2_widget->style, gtk2_white_pixmap, state_type,\n-            NULL, gtk2_widget, detail, x, y, width, height);\n-    (*fp_gtk_paint_focus)(gtk2_widget->style, gtk2_black_pixmap, state_type,\n-            NULL, gtk2_widget, detail, x, y, width, height);\n-}\n-\n-static void gtk2_paint_handle(WidgetType widget_type, GtkStateType state_type,\n-        GtkShadowType shadow_type, const gchar *detail,\n-        gint x, gint y, gint width, gint height, GtkOrientation orientation)\n-{\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-    (*fp_gtk_paint_handle)(gtk2_widget->style, gtk2_white_pixmap, state_type,\n-            shadow_type, NULL, gtk2_widget, detail,\n-            x, y, width, height, orientation);\n-    (*fp_gtk_paint_handle)(gtk2_widget->style, gtk2_black_pixmap, state_type,\n-            shadow_type, NULL, gtk2_widget, detail,\n-            x, y, width, height, orientation);\n-}\n-\n-static void gtk2_paint_hline(WidgetType widget_type, GtkStateType state_type,\n-        const gchar *detail, gint x, gint y, gint width, gint height)\n-{\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-    (*fp_gtk_paint_hline)(gtk2_widget->style, gtk2_white_pixmap, state_type,\n-            NULL, gtk2_widget, detail, x, x + width, y);\n-    (*fp_gtk_paint_hline)(gtk2_widget->style, gtk2_black_pixmap, state_type,\n-            NULL, gtk2_widget, detail, x, x + width, y);\n-}\n-\n-static void gtk2_paint_option(WidgetType widget_type, gint synth_state,\n-        const gchar *detail, gint x, gint y, gint width, gint height)\n-{\n-    GtkStateType state_type = get_gtk_state_type(widget_type, synth_state);\n-    GtkShadowType shadow_type = get_gtk_shadow_type(widget_type, synth_state);\n-\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-    init_toggle_widget(widget_type, synth_state);\n-\n-    (*fp_gtk_paint_option)(gtk2_widget->style, gtk2_white_pixmap, state_type,\n-            shadow_type, NULL, gtk2_widget, detail,\n-            x, y, width, height);\n-    (*fp_gtk_paint_option)(gtk2_widget->style, gtk2_black_pixmap, state_type,\n-            shadow_type, NULL, gtk2_widget, detail,\n-            x, y, width, height);\n-}\n-\n-static void gtk2_paint_shadow(WidgetType widget_type, GtkStateType state_type,\n-                       GtkShadowType shadow_type, const gchar *detail,\n-                       gint x, gint y, gint width, gint height,\n-                       gint synth_state, GtkTextDirection dir)\n-{\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-\n-    \/*\n-     * The clearlooks engine sometimes looks at the widget's state field\n-     * instead of just the state_type variable that we pass in, so to account\n-     * for those cases we set the widget's state field accordingly.  The\n-     * flags field is similarly important for things like focus state.\n-     *\/\n-    gtk2_widget->state = state_type;\n-\n-    \/*\n-     * Some engines (e.g. clearlooks) will paint the shadow of certain\n-     * widgets (e.g. COMBO_BOX_TEXT_FIELD) differently depending on the\n-     * the text direction.\n-     *\/\n-    gtk2_set_direction(gtk2_widget, dir);\n-\n-    switch (widget_type) {\n-    case COMBO_BOX_TEXT_FIELD:\n-    case FORMATTED_TEXT_FIELD:\n-    case PASSWORD_FIELD:\n-    case SPINNER_TEXT_FIELD:\n-    case TEXT_FIELD:\n-        if (synth_state & FOCUSED) {\n-            ((GtkObject*)gtk2_widget)->flags |= GTK_HAS_FOCUS;\n-        } else {\n-            ((GtkObject*)gtk2_widget)->flags &= ~GTK_HAS_FOCUS;\n-        }\n-        break;\n-    default:\n-        break;\n-    }\n-\n-    (*fp_gtk_paint_shadow)(gtk2_widget->style, gtk2_white_pixmap, state_type,\n-            shadow_type, NULL, gtk2_widget, detail, x, y, width, height);\n-    (*fp_gtk_paint_shadow)(gtk2_widget->style, gtk2_black_pixmap, state_type,\n-            shadow_type, NULL, gtk2_widget, detail, x, y, width, height);\n-\n-    \/*\n-     * Reset the text direction to the default value so that we don't\n-     * accidentally affect other operations and widgets.\n-     *\/\n-    gtk2_set_direction(gtk2_widget, GTK_TEXT_DIR_LTR);\n-}\n-\n-static void gtk2_paint_slider(WidgetType widget_type, GtkStateType state_type,\n-        GtkShadowType shadow_type, const gchar *detail,\n-        gint x, gint y, gint width, gint height, GtkOrientation orientation,\n-        gboolean has_focus)\n-{\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-    (*fp_gtk_paint_slider)(gtk2_widget->style, gtk2_white_pixmap, state_type,\n-            shadow_type, NULL, gtk2_widget, detail,\n-            x, y, width, height, orientation);\n-    (*fp_gtk_paint_slider)(gtk2_widget->style, gtk2_black_pixmap, state_type,\n-            shadow_type, NULL, gtk2_widget, detail,\n-            x, y, width, height, orientation);\n-}\n-\n-static void gtk2_paint_vline(WidgetType widget_type, GtkStateType state_type,\n-        const gchar *detail, gint x, gint y, gint width, gint height)\n-{\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-    (*fp_gtk_paint_vline)(gtk2_widget->style, gtk2_white_pixmap, state_type,\n-            NULL, gtk2_widget, detail, y, y + height, x);\n-    (*fp_gtk_paint_vline)(gtk2_widget->style, gtk2_black_pixmap, state_type,\n-            NULL, gtk2_widget, detail, y, y + height, x);\n-}\n-\n-static void gtk_paint_background(WidgetType widget_type, GtkStateType state_type,\n-        gint x, gint y, gint width, gint height)\n-{\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-    (*fp_gtk_style_apply_default_background)(gtk2_widget->style,\n-            gtk2_white_pixmap, TRUE, state_type, NULL, x, y, width, height);\n-    (*fp_gtk_style_apply_default_background)(gtk2_widget->style,\n-            gtk2_black_pixmap, TRUE, state_type, NULL, x, y, width, height);\n-}\n-\n-static GdkPixbuf *gtk2_get_stock_icon(gint widget_type, const gchar *stock_id,\n-        GtkIconSize size, GtkTextDirection direction, const char *detail)\n-{\n-    init_containers();\n-    gtk2_widget = gtk2_get_widget((widget_type < 0) ? IMAGE : widget_type);\n-    gtk2_widget->state = GTK_STATE_NORMAL;\n-    (*fp_gtk_widget_set_direction)(gtk2_widget, direction);\n-    return (*fp_gtk_widget_render_icon)(gtk2_widget, stock_id, size, detail);\n-}\n-\n-static jboolean gtk2_get_pixbuf_data(JNIEnv *env, GdkPixbuf* pixbuf,\n-                              jmethodID icon_upcall_method, jobject this) {\n-    if (!pixbuf) {\n-        return JNI_FALSE;\n-    }\n-    guchar *pixbuf_data = (*fp_gdk_pixbuf_get_pixels)(pixbuf);\n-    if (pixbuf_data) {\n-        int row_stride = (*fp_gdk_pixbuf_get_rowstride)(pixbuf);\n-        int width = (*fp_gdk_pixbuf_get_width)(pixbuf);\n-        int height = (*fp_gdk_pixbuf_get_height)(pixbuf);\n-        int bps = (*fp_gdk_pixbuf_get_bits_per_sample)(pixbuf);\n-        int channels = (*fp_gdk_pixbuf_get_n_channels)(pixbuf);\n-        gboolean alpha = (*fp_gdk_pixbuf_get_has_alpha)(pixbuf);\n-\n-        jbyteArray data = (*env)->NewByteArray(env, (row_stride * height));\n-        JNU_CHECK_EXCEPTION_RETURN(env, JNI_FALSE);\n-\n-        (*env)->SetByteArrayRegion(env, data, 0, (row_stride * height),\n-                                   (jbyte *)pixbuf_data);\n-        (*fp_g_object_unref)(pixbuf);\n-\n-        \/* Call the callback method to create the image on the Java side. *\/\n-        (*env)->CallVoidMethod(env, this, icon_upcall_method, data,\n-                width, height, row_stride, bps, channels, alpha);\n-        return JNI_TRUE;\n-    }\n-    return JNI_FALSE;\n-}\n-\n-static jboolean gtk2_get_file_icon_data(JNIEnv *env, const char *filename,\n-                 GError **error, jmethodID icon_upcall_method, jobject this) {\n-    GdkPixbuf* pixbuf = fp_gdk_pixbuf_new_from_file(filename, error);\n-    return gtk2_get_pixbuf_data(env, pixbuf, icon_upcall_method, this);\n-}\n-\n-static jboolean gtk2_get_icon_data(JNIEnv *env, gint widget_type,\n-                              const gchar *stock_id, GtkIconSize size,\n-                              GtkTextDirection direction, const char *detail,\n-                              jmethodID icon_upcall_method, jobject this) {\n-    GdkPixbuf* pixbuf = gtk2_get_stock_icon(widget_type, stock_id, size,\n-                                       direction, detail);\n-    return gtk2_get_pixbuf_data(env, pixbuf, icon_upcall_method, this);\n-}\n-\n-\/*************************************************\/\n-static gint gtk2_get_xthickness(JNIEnv *env, WidgetType widget_type)\n-{\n-    init_containers();\n-\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-    GtkStyle* style = gtk2_widget->style;\n-    return style->xthickness;\n-}\n-\n-static gint gtk2_get_ythickness(JNIEnv *env, WidgetType widget_type)\n-{\n-    init_containers();\n-\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-    GtkStyle* style = gtk2_widget->style;\n-    return style->ythickness;\n-}\n-\n-\/*************************************************\/\n-static guint8 recode_color(guint16 channel)\n-{\n-    return (guint8)(channel>>8);\n-}\n-\n-static gint gtk2_get_color_for_state(JNIEnv *env, WidgetType widget_type,\n-                              GtkStateType state_type, ColorType color_type)\n-{\n-    gint result = 0;\n-    GdkColor *color = NULL;\n-\n-    init_containers();\n-\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-    GtkStyle* style = gtk2_widget->style;\n-\n-    switch (color_type)\n-    {\n-        case FOREGROUND:\n-            color = &(style->fg[state_type]);\n-            break;\n-        case BACKGROUND:\n-            color = &(style->bg[state_type]);\n-            break;\n-        case TEXT_FOREGROUND:\n-            color = &(style->text[state_type]);\n-            break;\n-        case TEXT_BACKGROUND:\n-            color = &(style->base[state_type]);\n-            break;\n-        case LIGHT:\n-            color = &(style->light[state_type]);\n-            break;\n-        case DARK:\n-            color = &(style->dark[state_type]);\n-            break;\n-        case MID:\n-            color = &(style->mid[state_type]);\n-            break;\n-        case FOCUS:\n-        case BLACK:\n-            color = &(style->black);\n-            break;\n-        case WHITE:\n-            color = &(style->white);\n-            break;\n-    }\n-\n-    if (color)\n-        result = recode_color(color->red)   << 16 |\n-                 recode_color(color->green) << 8  |\n-                 recode_color(color->blue);\n-\n-    return result;\n-}\n-\n-\/*************************************************\/\n-static jobject create_Boolean(JNIEnv *env, jboolean boolean_value);\n-static jobject create_Integer(JNIEnv *env, jint int_value);\n-static jobject create_Long(JNIEnv *env, jlong long_value);\n-static jobject create_Float(JNIEnv *env, jfloat float_value);\n-static jobject create_Double(JNIEnv *env, jdouble double_value);\n-static jobject create_Character(JNIEnv *env, jchar char_value);\n-static jobject create_Insets(JNIEnv *env, GtkBorder *border);\n-\n-static jobject gtk2_get_class_value(JNIEnv *env, WidgetType widget_type,\n-                              const char* key)\n-{\n-    init_containers();\n-\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-\n-    GValue value;\n-    value.g_type = 0;\n-\n-    GParamSpec* param = (*fp_gtk_widget_class_find_style_property)(\n-                                    ((GTypeInstance*)gtk2_widget)->g_class, key);\n-    if( param )\n-    {\n-        (*fp_g_value_init)( &value, param->value_type );\n-        (*fp_gtk_widget_style_get_property)(gtk2_widget, key, &value);\n-\n-        if( (*fp_g_type_is_a)( param->value_type, G_TYPE_BOOLEAN ))\n-        {\n-            gboolean val = (*fp_g_value_get_boolean)(&value);\n-            return create_Boolean(env, (jboolean)val);\n-        }\n-        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_CHAR ))\n-        {\n-            gchar val = (*fp_g_value_get_char)(&value);\n-            return create_Character(env, (jchar)val);\n-        }\n-        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_UCHAR ))\n-        {\n-            guchar val = (*fp_g_value_get_uchar)(&value);\n-            return create_Character(env, (jchar)val);\n-        }\n-        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_INT ))\n-        {\n-            gint val = (*fp_g_value_get_int)(&value);\n-            return create_Integer(env, (jint)val);\n-        }\n-        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_UINT ))\n-        {\n-            guint val = (*fp_g_value_get_uint)(&value);\n-            return create_Integer(env, (jint)val);\n-        }\n-        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_LONG ))\n-        {\n-            glong val = (*fp_g_value_get_long)(&value);\n-            return create_Long(env, (jlong)val);\n-        }\n-        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_ULONG ))\n-        {\n-            gulong val = (*fp_g_value_get_ulong)(&value);\n-            return create_Long(env, (jlong)val);\n-        }\n-        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_INT64 ))\n-        {\n-            gint64 val = (*fp_g_value_get_int64)(&value);\n-            return create_Long(env, (jlong)val);\n-        }\n-        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_UINT64 ))\n-        {\n-            guint64 val = (*fp_g_value_get_uint64)(&value);\n-            return create_Long(env, (jlong)val);\n-        }\n-        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_FLOAT ))\n-        {\n-            gfloat val = (*fp_g_value_get_float)(&value);\n-            return create_Float(env, (jfloat)val);\n-        }\n-        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_DOUBLE ))\n-        {\n-            gdouble val = (*fp_g_value_get_double)(&value);\n-            return create_Double(env, (jdouble)val);\n-        }\n-        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_ENUM ))\n-        {\n-            gint val = (*fp_g_value_get_enum)(&value);\n-            return create_Integer(env, (jint)val);\n-        }\n-        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_FLAGS ))\n-        {\n-            guint val = (*fp_g_value_get_flags)(&value);\n-            return create_Integer(env, (jint)val);\n-        }\n-        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_STRING ))\n-        {\n-            const gchar* val = (*fp_g_value_get_string)(&value);\n-\n-            \/* We suppose that all values come in C locale and\n-             * utf-8 representation of a string is the same as\n-             * the string itself. If this isn't so we should\n-             * use g_convert.\n-             *\/\n-            return (*env)->NewStringUTF(env, val);\n-        }\n-        else if( (*fp_g_type_is_a)( param->value_type, GTK_TYPE_BORDER ))\n-        {\n-            GtkBorder *border = (GtkBorder*)(*fp_g_value_get_boxed)(&value);\n-            return border ? create_Insets(env, border) : NULL;\n-        }\n-\n-        \/*      TODO: Other types are not supported yet.*\/\n-\/*        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_PARAM ))\n-        {\n-            GParamSpec* val = (*fp_g_value_get_param)(&value);\n-            printf( \"Param: %p\\n\", val );\n-        }\n-        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_BOXED ))\n-        {\n-            gpointer* val = (*fp_g_value_get_boxed)(&value);\n-            printf( \"Boxed: %p\\n\", val );\n-        }\n-        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_POINTER ))\n-        {\n-            gpointer* val = (*fp_g_value_get_pointer)(&value);\n-            printf( \"Pointer: %p\\n\", val );\n-        }\n-        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_OBJECT ))\n-        {\n-            GObject* val = (GObject*)(*fp_g_value_get_object)(&value);\n-            printf( \"Object: %p\\n\", val );\n-        }*\/\n-    }\n-\n-    return NULL;\n-}\n-\n-static void gtk2_set_range_value(WidgetType widget_type, jdouble value,\n-                          jdouble min, jdouble max, jdouble visible)\n-{\n-    GtkAdjustment *adj;\n-\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-\n-    adj = (*fp_gtk_range_get_adjustment)((GtkRange *)gtk2_widget);\n-    adj->value = (gdouble)value;\n-    adj->lower = (gdouble)min;\n-    adj->upper = (gdouble)max;\n-    adj->page_size = (gdouble)visible;\n-}\n-\n-\/*************************************************\/\n-static jobject create_Object(JNIEnv *env, jmethodID *cid,\n-                             const char* class_name,\n-                             const char* signature,\n-                             jvalue* value)\n-{\n-    jclass  class;\n-    jobject result;\n-\n-    class = (*env)->FindClass(env, class_name);\n-    if( class == NULL )\n-        return NULL; \/* can't find\/load the class, exception thrown *\/\n-\n-    if( *cid == NULL)\n-    {\n-        *cid = (*env)->GetMethodID(env, class, \"<init>\", signature);\n-        if( *cid == NULL )\n-        {\n-            (*env)->DeleteLocalRef(env, class);\n-            return NULL; \/* can't find\/get the method, exception thrown *\/\n-        }\n-    }\n-\n-    result = (*env)->NewObjectA(env, class, *cid, value);\n-\n-    (*env)->DeleteLocalRef(env, class);\n-    return result;\n-}\n-\n-jobject create_Boolean(JNIEnv *env, jboolean boolean_value)\n-{\n-    static jmethodID cid = NULL;\n-    jvalue value;\n-\n-    value.z = boolean_value;\n-\n-    return create_Object(env, &cid, \"java\/lang\/Boolean\", \"(Z)V\", &value);\n-}\n-\n-jobject create_Integer(JNIEnv *env, jint int_value)\n-{\n-    static jmethodID cid = NULL;\n-    jvalue value;\n-\n-    value.i = int_value;\n-\n-    return create_Object(env, &cid, \"java\/lang\/Integer\", \"(I)V\", &value);\n-}\n-\n-jobject create_Long(JNIEnv *env, jlong long_value)\n-{\n-    static jmethodID cid = NULL;\n-    jvalue value;\n-\n-    value.j = long_value;\n-\n-    return create_Object(env, &cid, \"java\/lang\/Long\", \"(J)V\", &value);\n-}\n-\n-jobject create_Float(JNIEnv *env, jfloat float_value)\n-{\n-    static jmethodID cid = NULL;\n-    jvalue value;\n-\n-    value.f = float_value;\n-\n-    return create_Object(env, &cid, \"java\/lang\/Float\", \"(F)V\", &value);\n-}\n-\n-jobject create_Double(JNIEnv *env, jdouble double_value)\n-{\n-    static jmethodID cid = NULL;\n-    jvalue value;\n-\n-    value.d = double_value;\n-\n-    return create_Object(env, &cid, \"java\/lang\/Double\", \"(D)V\", &value);\n-}\n-\n-jobject create_Character(JNIEnv *env, jchar char_value)\n-{\n-    static jmethodID cid = NULL;\n-    jvalue value;\n-\n-    value.c = char_value;\n-\n-    return create_Object(env, &cid, \"java\/lang\/Character\", \"(C)V\", &value);\n-}\n-\n-\n-jobject create_Insets(JNIEnv *env, GtkBorder *border)\n-{\n-    static jmethodID cid = NULL;\n-    jvalue values[4];\n-\n-    values[0].i = border->top;\n-    values[1].i = border->left;\n-    values[2].i = border->bottom;\n-    values[3].i = border->right;\n-\n-    return create_Object(env, &cid, \"java\/awt\/Insets\", \"(IIII)V\", values);\n-}\n-\n-\/*********************************************\/\n-static jstring gtk2_get_pango_font_name(JNIEnv *env, WidgetType widget_type)\n-{\n-    init_containers();\n-\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-    jstring  result = NULL;\n-    GtkStyle* style = gtk2_widget->style;\n-\n-    if (style && style->font_desc)\n-    {\n-        gchar* val = (*fp_pango_font_description_to_string)(style->font_desc);\n-        result = (*env)->NewStringUTF(env, val);\n-        (*fp_g_free)( val );\n-    }\n-\n-    return result;\n-}\n-\n-\/***********************************************\/\n-static jobject get_string_property(JNIEnv *env, GtkSettings* settings, const gchar* key)\n-{\n-    jobject result = NULL;\n-    gchar*  strval = NULL;\n-\n-    (*fp_g_object_get)(settings, key, &strval, NULL);\n-    result = (*env)->NewStringUTF(env, strval);\n-    (*fp_g_free)(strval);\n-\n-    return result;\n-}\n-\n-static jobject get_integer_property(JNIEnv *env, GtkSettings* settings, const gchar* key)\n-{\n-    gint intval = 0;\n-    (*fp_g_object_get)(settings, key, &intval, NULL);\n-    return create_Integer(env, intval);\n-}\n-\n-static jobject get_boolean_property(JNIEnv *env, GtkSettings* settings, const gchar* key)\n-{\n-    gint intval = 0;\n-    (*fp_g_object_get)(settings, key, &intval, NULL);\n-    return create_Boolean(env, intval);\n-}\n-\n-static jobject gtk2_get_setting(JNIEnv *env, Setting property)\n-{\n-    GtkSettings* settings = (*fp_gtk_settings_get_default)();\n-\n-    switch (property)\n-    {\n-        case GTK_FONT_NAME:\n-            return get_string_property(env, settings, \"gtk-font-name\");\n-        case GTK_ICON_SIZES:\n-            return get_string_property(env, settings, \"gtk-icon-sizes\");\n-        case GTK_CURSOR_BLINK:\n-            return get_boolean_property(env, settings, \"gtk-cursor-blink\");\n-        case GTK_CURSOR_BLINK_TIME:\n-            return get_integer_property(env, settings, \"gtk-cursor-blink-time\");\n-    }\n-\n-    return NULL;\n-}\n-\n-static gboolean gtk2_get_drawable_data(JNIEnv *env, jintArray pixelArray, jint x,\n-     jint y, jint width, jint height, jint jwidth, int dx, int dy) {\n-    GdkPixbuf *pixbuf;\n-    jint *ary;\n-\n-    GdkWindow *root = (*fp_gdk_get_default_root_window)();\n-\n-    pixbuf = (*fp_gdk_pixbuf_get_from_drawable)(NULL, root, NULL, x, y,\n-                                                    0, 0, width, height);\n-\n-    if (pixbuf) {\n-        int nchan = (*fp_gdk_pixbuf_get_n_channels)(pixbuf);\n-        int stride = (*fp_gdk_pixbuf_get_rowstride)(pixbuf);\n-\n-        if ((*fp_gdk_pixbuf_get_width)(pixbuf) == width\n-                && (*fp_gdk_pixbuf_get_height)(pixbuf) == height\n-                && (*fp_gdk_pixbuf_get_bits_per_sample)(pixbuf) == 8\n-                && (*fp_gdk_pixbuf_get_colorspace)(pixbuf) == GDK_COLORSPACE_RGB\n-                && nchan >= 3\n-                ) {\n-            guchar *p, *pix = (*fp_gdk_pixbuf_get_pixels)(pixbuf);\n-\n-            ary = (*env)->GetPrimitiveArrayCritical(env, pixelArray, NULL);\n-            if (ary) {\n-                jint _x, _y;\n-                int index;\n-                for (_y = 0; _y < height; _y++) {\n-                    for (_x = 0; _x < width; _x++) {\n-                        p = pix + (intptr_t) _y * stride + _x * nchan;\n-\n-                        index = (_y + dy) * jwidth + (_x + dx);\n-                        ary[index] = 0xff000000\n-                                        | (p[0] << 16)\n-                                        | (p[1] << 8)\n-                                        | (p[2]);\n-\n-                    }\n-                }\n-                (*env)->ReleasePrimitiveArrayCritical(env, pixelArray, ary, 0);\n-            }\n-        }\n-        (*fp_g_object_unref)(pixbuf);\n-    }\n-    return JNI_FALSE;\n-}\n-\n-static GdkWindow* gtk2_get_window(void *widget) {\n-    return ((GtkWidget*)widget)->window;\n-}\n-\n-void gtk2_init(GtkApi* gtk) {\n-    gtk->version = GTK_2;\n-\n-    gtk->show_uri_load = &gtk2_show_uri_load;\n-    gtk->unload = &gtk2_unload;\n-    gtk->flush_event_loop = &flush_gtk_event_loop;\n-    gtk->gtk_check_version = fp_gtk_check_version;\n-    gtk->get_setting = &gtk2_get_setting;\n-\n-    gtk->paint_arrow = &gtk2_paint_arrow;\n-    gtk->paint_box = &gtk2_paint_box;\n-    gtk->paint_box_gap = &gtk2_paint_box_gap;\n-    gtk->paint_expander = &gtk2_paint_expander;\n-    gtk->paint_extension = &gtk2_paint_extension;\n-    gtk->paint_flat_box = &gtk2_paint_flat_box;\n-    gtk->paint_focus = &gtk2_paint_focus;\n-    gtk->paint_handle = &gtk2_paint_handle;\n-    gtk->paint_hline = &gtk2_paint_hline;\n-    gtk->paint_vline = &gtk2_paint_vline;\n-    gtk->paint_option = &gtk2_paint_option;\n-    gtk->paint_shadow = &gtk2_paint_shadow;\n-    gtk->paint_slider = &gtk2_paint_slider;\n-    gtk->paint_background = &gtk_paint_background;\n-    gtk->paint_check = &gtk2_paint_check;\n-    gtk->set_range_value = &gtk2_set_range_value;\n-\n-    gtk->init_painting = &gtk2_init_painting;\n-    gtk->copy_image = &gtk2_copy_image;\n-\n-    gtk->get_xthickness = &gtk2_get_xthickness;\n-    gtk->get_ythickness = &gtk2_get_ythickness;\n-    gtk->get_color_for_state = &gtk2_get_color_for_state;\n-    gtk->get_class_value = &gtk2_get_class_value;\n-\n-    gtk->get_pango_font_name = &gtk2_get_pango_font_name;\n-    gtk->get_icon_data = &gtk2_get_icon_data;\n-    gtk->get_file_icon_data = &gtk2_get_file_icon_data;\n-    gtk->gdk_threads_enter = fp_gdk_threads_enter;\n-    gtk->gdk_threads_leave = fp_gdk_threads_leave;\n-    gtk->gtk_show_uri = fp_gtk_show_uri;\n-    gtk->get_drawable_data = &gtk2_get_drawable_data;\n-    gtk->g_free = fp_g_free;\n-\n-    gtk->gtk_file_chooser_get_filename = fp_gtk_file_chooser_get_filename;\n-    gtk->gtk_widget_hide = fp_gtk_widget_hide;\n-    gtk->gtk_main_quit = fp_gtk_main_quit;\n-    gtk->gtk_file_chooser_dialog_new = fp_gtk_file_chooser_dialog_new;\n-    gtk->gtk_file_chooser_set_current_folder =\n-                          fp_gtk_file_chooser_set_current_folder;\n-    gtk->gtk_file_chooser_set_filename = fp_gtk_file_chooser_set_filename;\n-    gtk->gtk_file_chooser_set_current_name =\n-                          fp_gtk_file_chooser_set_current_name;\n-    gtk->gtk_file_filter_add_custom = fp_gtk_file_filter_add_custom;\n-    gtk->gtk_file_chooser_set_filter = fp_gtk_file_chooser_set_filter;\n-    gtk->gtk_file_chooser_get_type = fp_gtk_file_chooser_get_type;\n-    gtk->gtk_file_filter_new = fp_gtk_file_filter_new;\n-    gtk->gtk_file_chooser_set_do_overwrite_confirmation =\n-                          fp_gtk_file_chooser_set_do_overwrite_confirmation;\n-    gtk->gtk_file_chooser_set_select_multiple =\n-                          fp_gtk_file_chooser_set_select_multiple;\n-    gtk->gtk_file_chooser_get_current_folder =\n-                          fp_gtk_file_chooser_get_current_folder;\n-    gtk->gtk_file_chooser_get_filenames = fp_gtk_file_chooser_get_filenames;\n-    gtk->gtk_g_slist_length = fp_gtk_g_slist_length;\n-    gtk->g_signal_connect_data = fp_g_signal_connect_data;\n-    gtk->gtk_widget_show = fp_gtk_widget_show;\n-    gtk->gtk_main = fp_gtk_main;\n-    gtk->gtk_main_level = fp_gtk_main_level;\n-    gtk->g_path_get_dirname = fp_g_path_get_dirname;\n-    gtk->gdk_x11_drawable_get_xid = fp_gdk_x11_drawable_get_xid;\n-    gtk->gtk_widget_destroy = fp_gtk_widget_destroy;\n-    gtk->gtk_window_present = fp_gtk_window_present;\n-    gtk->gtk_window_move = fp_gtk_window_move;\n-    gtk->gtk_window_resize = fp_gtk_window_resize;\n-    gtk->get_window = &gtk2_get_window;\n-\n-    gtk->g_object_unref = fp_g_object_unref;\n-    gtk->g_list_append = fp_g_list_append;\n-    gtk->g_list_free = fp_g_list_free;\n-    gtk->g_list_free_full = fp_g_list_free_full;\n-}\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk2_interface.c","additions":0,"deletions":2603,"binary":false,"changes":2603,"status":"deleted"},{"patch":"@@ -1,448 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifdef HEADLESS\n-    #error This file should not be included in headless library\n-#endif\n-\n-#ifndef _GTK2_INTERFACE_H\n-#define _GTK2_INTERFACE_H\n-\n-#include <stdlib.h>\n-#include <jni.h>\n-#include <X11\/X.h>\n-#include \"gtk_interface.h\"\n-\n-#define GTK_HAS_FOCUS   (1 << 12)\n-#define GTK_HAS_DEFAULT (1 << 14)\n-\n-typedef enum\n-{\n-  GTK_WINDOW_TOPLEVEL,\n-  GTK_WINDOW_POPUP\n-} GtkWindowType;\n-\n-typedef enum\n-{\n-  G_PARAM_READABLE            = 1 << 0,\n-  G_PARAM_WRITABLE            = 1 << 1,\n-  G_PARAM_CONSTRUCT           = 1 << 2,\n-  G_PARAM_CONSTRUCT_ONLY      = 1 << 3,\n-  G_PARAM_LAX_VALIDATION      = 1 << 4,\n-  G_PARAM_PRIVATE             = 1 << 5\n-} GParamFlags;\n-\n-\/* We define all structure pointers to be void* *\/\n-typedef void GVfs;\n-\n-typedef void GdkColormap;\n-typedef void GdkDrawable;\n-typedef void GdkGC;\n-typedef void GdkPixmap;\n-\n-typedef void GtkFixed;\n-typedef void GtkMenuItem;\n-typedef void GtkMenuShell;\n-typedef void GtkWidgetClass;\n-typedef void PangoFontDescription;\n-typedef void GtkSettings;\n-\n-\/* Some real structures *\/\n-typedef struct\n-{\n-  guint32 pixel;\n-  guint16 red;\n-  guint16 green;\n-  guint16 blue;\n-} GdkColor;\n-\n-typedef struct {\n-  gint      fd;\n-  gushort   events;\n-  gushort   revents;\n-} GPollFD;\n-\n-typedef struct {\n-  gint x;\n-  gint y;\n-  gint width;\n-  gint height;\n-} GtkAllocation;\n-\n-typedef struct {\n-  gint width;\n-  gint height;\n-} GtkRequisition;\n-\n-typedef struct {\n-  GtkWidgetClass *g_class;\n-} GTypeInstance;\n-\n-typedef struct {\n-  gint left;\n-  gint right;\n-  gint top;\n-  gint bottom;\n-} GtkBorder;\n-\n-\/******************************************************\n- * FIXME: it is more safe to include gtk headers for\n- * the precise type definition of GType and other\n- * structures. This is a place where getting rid of gtk\n- * headers may be dangerous.\n- ******************************************************\/\n-\n-typedef struct\n-{\n-  GType         g_type;\n-\n-  union {\n-    gint        v_int;\n-    guint       v_uint;\n-    glong       v_long;\n-    gulong      v_ulong;\n-    gint64      v_int64;\n-    guint64     v_uint64;\n-    gfloat      v_float;\n-    gdouble     v_double;\n-    gpointer    v_pointer;\n-  } data[2];\n-} GValue;\n-\n-typedef struct\n-{\n-  GTypeInstance  g_type_instance;\n-\n-  gchar         *name;\n-  GParamFlags    flags;\n-  GType          value_type;\n-  GType          owner_type;\n-} GParamSpec;\n-\n-typedef struct {\n-  GTypeInstance g_type_instance;\n-  guint         ref_count;\n-  void         *qdata;\n-} GObject;\n-\n-typedef struct {\n-  GObject parent_instance;\n-  guint32 flags;\n-} GtkObject;\n-\n-typedef struct\n-{\n-  GObject parent_instance;\n-\n-  GdkColor fg[5];\n-  GdkColor bg[5];\n-  GdkColor light[5];\n-  GdkColor dark[5];\n-  GdkColor mid[5];\n-  GdkColor text[5];\n-  GdkColor base[5];\n-  GdkColor text_aa[5];          \/* Halfway between text\/base *\/\n-\n-  GdkColor black;\n-  GdkColor white;\n-  PangoFontDescription *font_desc;\n-\n-  gint xthickness;\n-  gint ythickness;\n-\n-  GdkGC *fg_gc[5];\n-  GdkGC *bg_gc[5];\n-  GdkGC *light_gc[5];\n-  GdkGC *dark_gc[5];\n-  GdkGC *mid_gc[5];\n-  GdkGC *text_gc[5];\n-  GdkGC *base_gc[5];\n-  GdkGC *text_aa_gc[5];\n-  GdkGC *black_gc;\n-  GdkGC *white_gc;\n-\n-  GdkPixmap *bg_pixmap[5];\n-} GtkStyle;\n-\n-typedef struct _GtkWidget GtkWidget;\n-struct _GtkWidget\n-{\n-  GtkObject object;\n-  guint16 private_flags;\n-  guint8 state;\n-  guint8 saved_state;\n-  gchar *name;\n-  GtkStyle *style;\n-  GtkRequisition requisition;\n-  GtkAllocation allocation;\n-  GdkWindow *window;\n-  GtkWidget *parent;\n-};\n-\n-typedef struct\n-{\n-  GtkWidget widget;\n-\n-  gfloat xalign;\n-  gfloat yalign;\n-\n-  guint16 xpad;\n-  guint16 ypad;\n-} GtkMisc;\n-\n-typedef struct {\n-  GtkWidget widget;\n-  GtkWidget *focus_child;\n-  guint border_width : 16;\n-  guint need_resize : 1;\n-  guint resize_mode : 2;\n-  guint reallocate_redraws : 1;\n-  guint has_focus_chain : 1;\n-} GtkContainer;\n-\n-typedef struct {\n-  GtkContainer container;\n-  GtkWidget *child;\n-} GtkBin;\n-\n-typedef struct {\n-  GtkBin bin;\n-  GdkWindow *event_window;\n-  gchar *label_text;\n-  guint activate_timeout;\n-  guint constructed : 1;\n-  guint in_button : 1;\n-  guint button_down : 1;\n-  guint relief : 2;\n-  guint use_underline : 1;\n-  guint use_stock : 1;\n-  guint depressed : 1;\n-  guint depress_on_activate : 1;\n-  guint focus_on_click : 1;\n-} GtkButton;\n-\n-typedef struct {\n-  GtkButton button;\n-  guint active : 1;\n-  guint draw_indicator : 1;\n-  guint inconsistent : 1;\n-} GtkToggleButton;\n-\n-typedef struct _GtkAdjustment GtkAdjustment;\n-struct _GtkAdjustment\n-{\n-  GtkObject parent_instance;\n-\n-  gdouble lower;\n-  gdouble upper;\n-  gdouble value;\n-  gdouble step_increment;\n-  gdouble page_increment;\n-  gdouble page_size;\n-};\n-\n-typedef enum\n-{\n-  GTK_UPDATE_CONTINUOUS,\n-  GTK_UPDATE_DISCONTINUOUS,\n-  GTK_UPDATE_DELAYED\n-} GtkUpdateType;\n-\n-typedef struct _GtkRange GtkRange;\n-struct _GtkRange\n-{\n-  GtkWidget widget;\n-  GtkAdjustment *adjustment;\n-  GtkUpdateType update_policy;\n-  guint inverted : 1;\n-  \/*< protected >*\/\n-  guint flippable : 1;\n-  guint has_stepper_a : 1;\n-  guint has_stepper_b : 1;\n-  guint has_stepper_c : 1;\n-  guint has_stepper_d : 1;\n-  guint need_recalc : 1;\n-  guint slider_size_fixed : 1;\n-  gint min_slider_size;\n-  GtkOrientation orientation;\n-  GdkRectangle range_rect;\n-  gint slider_start, slider_end;\n-  gint round_digits;\n-  \/*< private >*\/\n-  guint trough_click_forward : 1;\n-  guint update_pending : 1;\n-  \/*GtkRangeLayout * *\/ void *layout;\n-  \/*GtkRangeStepTimer * *\/ void* timer;\n-  gint slide_initial_slider_position;\n-  gint slide_initial_coordinate;\n-  guint update_timeout_id;\n-  GdkWindow *event_window;\n-};\n-\n-typedef struct _GtkProgressBar       GtkProgressBar;\n-\n-typedef enum\n-{\n-  GTK_PROGRESS_CONTINUOUS,\n-  GTK_PROGRESS_DISCRETE\n-} GtkProgressBarStyle;\n-\n-typedef enum\n-{\n-  GTK_PROGRESS_LEFT_TO_RIGHT,\n-  GTK_PROGRESS_RIGHT_TO_LEFT,\n-  GTK_PROGRESS_BOTTOM_TO_TOP,\n-  GTK_PROGRESS_TOP_TO_BOTTOM\n-} GtkProgressBarOrientation;\n-\n-typedef struct _GtkProgress       GtkProgress;\n-\n-struct _GtkProgress\n-{\n-  GtkWidget widget;\n-  GtkAdjustment *adjustment;\n-  GdkPixmap     *offscreen_pixmap;\n-  gchar         *format;\n-  gfloat         x_align;\n-  gfloat         y_align;\n-  guint          show_text : 1;\n-  guint          activity_mode : 1;\n-  guint          use_text_format : 1;\n-};\n-\n-struct _GtkProgressBar\n-{\n-  GtkProgress progress;\n-  GtkProgressBarStyle bar_style;\n-  GtkProgressBarOrientation orientation;\n-  guint blocks;\n-  gint  in_block;\n-  gint  activity_pos;\n-  guint activity_step;\n-  guint activity_blocks;\n-  gdouble pulse_fraction;\n-  guint activity_dir : 1;\n-  guint ellipsize : 3;\n-};\n-\n-\/**\n- * Returns :\n- * NULL if the GLib library is compatible with the given version, or a string\n- * describing the version mismatch.\n- * Please note that the glib_check_version() is available since 2.6,\n- * so you should use GLIB_CHECK_VERSION macro instead.\n- *\/\n-static gchar* (*fp_glib_check_version)(guint required_major, guint required_minor,\n-                       guint required_micro);\n-\n-\/**\n- * Returns :\n- *  TRUE if the GLib library is compatible with the given version\n- *\/\n-#define GLIB_CHECK_VERSION(major, minor, micro) \\\n-    (fp_glib_check_version && fp_glib_check_version(major, minor, micro) == NULL)\n-\n-\/**\n- * Returns :\n- * NULL if the GTK+ library is compatible with the given version, or a string\n- * describing the version mismatch.\n- *\/\n-static gchar* (*fp_gtk_check_version)(guint required_major, guint required_minor,\n-                       guint required_micro);\n-\n-static void gtk2_init(GtkApi* gtk);\n-\n-static void (*fp_g_free)(gpointer mem);\n-static void (*fp_g_object_unref)(gpointer object);\n-static GdkWindow *(*fp_gdk_get_default_root_window) (void);\n-\n-static int (*fp_gdk_pixbuf_get_bits_per_sample)(const GdkPixbuf *pixbuf);\n-static guchar *(*fp_gdk_pixbuf_get_pixels)(const GdkPixbuf *pixbuf);\n-static gboolean (*fp_gdk_pixbuf_get_has_alpha)(const GdkPixbuf *pixbuf);\n-static int (*fp_gdk_pixbuf_get_height)(const GdkPixbuf *pixbuf);\n-static int (*fp_gdk_pixbuf_get_n_channels)(const GdkPixbuf *pixbuf);\n-static int (*fp_gdk_pixbuf_get_rowstride)(const GdkPixbuf *pixbuf);\n-static int (*fp_gdk_pixbuf_get_width)(const GdkPixbuf *pixbuf);\n-static GdkPixbuf *(*fp_gdk_pixbuf_new_from_file)(const char *filename, GError **error);\n-static GdkColorspace (*fp_gdk_pixbuf_get_colorspace)(const GdkPixbuf *pixbuf);\n-\n-static GdkPixbuf *(*fp_gdk_pixbuf_get_from_drawable)(GdkPixbuf *dest,\n-        GdkDrawable *src, GdkColormap *cmap, int src_x, int src_y,\n-        int dest_x, int dest_y, int width, int height);\n-static GdkPixbuf *(*fp_gdk_pixbuf_scale_simple)(GdkPixbuf *src,\n-        int dest_width, int dest_heigh, GdkInterpType interp_type);\n-\n-\n-static void (*fp_gtk_widget_destroy)(void *widget);\n-static void (*fp_gtk_window_present)(GtkWindow *window);\n-static void (*fp_gtk_window_move)(GtkWindow *window, gint x, gint y);\n-static void (*fp_gtk_window_resize)(GtkWindow *window, gint width, gint height);\n-\n-\/**\n- * Function Pointers for GtkFileChooser\n- *\/\n-static gchar* (*fp_gtk_file_chooser_get_filename)(GtkFileChooser *chooser);\n-static void (*fp_gtk_widget_hide)(void *widget);\n-static void (*fp_gtk_main_quit)(void);\n-static void* (*fp_gtk_file_chooser_dialog_new)(const gchar *title,\n-    GtkWindow *parent, GtkFileChooserAction action,\n-    const gchar *first_button_text, ...);\n-static gboolean (*fp_gtk_file_chooser_set_current_folder)(GtkFileChooser *chooser,\n-    const gchar *filename);\n-static gboolean (*fp_gtk_file_chooser_set_filename)(GtkFileChooser *chooser,\n-    const char *filename);\n-static void (*fp_gtk_file_chooser_set_current_name)(GtkFileChooser *chooser,\n-    const gchar *name);\n-static void (*fp_gtk_file_filter_add_custom)(GtkFileFilter *filter,\n-    GtkFileFilterFlags needed, GtkFileFilterFunc func, gpointer data,\n-    GDestroyNotify notify);\n-static void (*fp_gtk_file_chooser_set_filter)(GtkFileChooser *chooser,\n-    GtkFileFilter *filter);\n-static GType (*fp_gtk_file_chooser_get_type)(void);\n-static GtkFileFilter* (*fp_gtk_file_filter_new)(void);\n-static void (*fp_gtk_file_chooser_set_do_overwrite_confirmation)(\n-    GtkFileChooser *chooser, gboolean do_overwrite_confirmation);\n-static void (*fp_gtk_file_chooser_set_select_multiple)(\n-    GtkFileChooser *chooser, gboolean select_multiple);\n-static gchar* (*fp_gtk_file_chooser_get_current_folder)(GtkFileChooser *chooser);\n-static GSList* (*fp_gtk_file_chooser_get_filenames)(GtkFileChooser *chooser);\n-static guint (*fp_gtk_g_slist_length)(GSList *list);\n-static gulong (*fp_g_signal_connect_data)(gpointer instance,\n-    const gchar *detailed_signal, GCallback c_handler, gpointer data,\n-    GClosureNotify destroy_data, GConnectFlags connect_flags);\n-static void (*fp_gtk_widget_show)(void *widget);\n-static void (*fp_gtk_main)(void);\n-static guint (*fp_gtk_main_level)(void);\n-static gchar* (*fp_g_path_get_dirname) (const gchar *file_name);\n-static XID (*fp_gdk_x11_drawable_get_xid) (GdkWindow *drawable);\n-\n-static GList* (*fp_g_list_append) (GList *list, gpointer data);\n-static void (*fp_g_list_free) (GList *list);\n-static void (*fp_g_list_free_full) (GList *list, GDestroyNotify free_func);\n-\n-static gboolean (*fp_gtk_show_uri)(GdkScreen *screen, const gchar *uri,\n-    guint32 timestamp, GError **error);\n-\n-#endif \/* !_GTK2_INTERFACE_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk2_interface.h","additions":0,"deletions":448,"binary":false,"changes":448,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-GtkApi* gtk2_load(JNIEnv *env, const char* lib_name);\n@@ -38,1 +37,0 @@\n-gboolean gtk2_check(const char* lib_name, gboolean load);\n@@ -59,7 +57,0 @@\n-    {\n-        GTK_2,\n-        JNI_LIB_NAME(\"gtk-x11-2.0\"),\n-        VERSIONED_JNI_LIB_NAME(\"gtk-x11-2.0\", \"0\"),\n-        &gtk2_load,\n-        &gtk2_check\n-    }\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk_interface.c","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -678,1 +678,0 @@\n-\/\/glib_version_2_68 false for gtk2, as it comes from gtk3_interface.c\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/screencast_pipewire.c","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,2 +48,3 @@\n-        test(\"2\", \"2\");\n-        test(\"2.2\", \"2\");\n+\/\/        GTK 2 is removed, but the test can still be useful.\n+\/\/        test(\"2\", \"2\");\n+\/\/        test(\"2.2\", \"2\");\n","filename":"test\/jdk\/java\/awt\/Gtk\/GtkVersionTest\/GtkVersionTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @summary  Verifies Robot screen capture capabilities with different\n+ * @summary  Verifies Robot screen capture capabilities with available\n@@ -47,1 +47,0 @@\n- * @run main\/othervm -Djdk.gtk.version=2 -Dsun.java2d.uiScale=1 ScreenCaptureGtkTest\n@@ -56,6 +55,0 @@\n-        if (\"2\".equals(System.getProperty(\"jdk.gtk.version\"))\n-                && System.getenv(\"WAYLAND_DISPLAY\") != null) {\n-            \/\/ screen capture is not supported with gtk2 on Wayland\n-            return;\n-        }\n-\n","filename":"test\/jdk\/java\/awt\/Robot\/HiDPIScreenCapture\/ScreenCaptureGtkTest.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-  @run main\/othervm -Djdk.gtk.version=2 DemandGTK\n","filename":"test\/jdk\/javax\/swing\/LookAndFeel\/8145547\/DemandGTK.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,91 +0,0 @@\n-#!\/bin\/ksh -p\n-\n-#\n-# Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#   @test\n-#   @summary  Try to force GTK2. We must bail out to GTK3 (if any) if no 2 available.\n-#\n-#   @key headful\n-#   @bug 8156128 8212903\n-#   @compile ProvokeGTK.java\n-#   @requires os.family == \"linux\"\n-#   @run shell\/timeout=400 DemandGTK2.sh\n-\n-#\n-# Note that we depend on\n-# strace in the PATH\n-# \/sbin\/ldconfig (which may be not in PATH)\n-# It is true for OEL 7 and Ubuntu 14, 16\n-# but may fail in future. Save tomorrow for tomorrow.\n-#\n-# Read DemandGTK2.txt how to prepare GTK2-less machine.\n-#\n-\n-which strace\n-if [ $?  -ne 0 ]\n-then\n-    echo \"Please provide strace: \\\"which strace\\\" failed.\"\n-    exit 1\n-fi\n-\n-HAVE_2=`\/sbin\/ldconfig -v 2>\/dev\/null | grep libgtk-x11-2 | wc -l`\n-HAVE_3=`\/sbin\/ldconfig -v 2>\/dev\/null | grep libgtk-3.so | wc -l`\n-\n-\n-if [ \"${HAVE_2}\" = \"0\" ]\n-then\n-    \n-    if [ \"${HAVE_3}\" = \"0\" ]\n-    then\n-        echo \"Neither GTK2 nor GTK3 found: system misconfiguration. Exit.\"\n-        exit 1\n-    fi\n-    echo \"No GTK 2 library found: we should bail out to 3\"\n-    strace -o strace.log -fe open,openat ${TESTJAVA}\/bin\/java  -cp ${TESTCLASSPATH}  -Djdk.gtk.version=2 ProvokeGTK\n-    EXECRES=$?\n-    grep  'libgtk-3.*=\\ *[0-9]*$' strace.log > logg\n-else\n-    echo \"There is GTK 2 library: we should use it\"\n-    strace -o strace.log -fe open,openat ${TESTJAVA}\/bin\/java  -cp ${TESTCLASSPATH}  -Djdk.gtk.version=2 ProvokeGTK\n-    EXECRES=$?\n-    grep  'libgtk-x11.*=\\ *[0-9]*$' strace.log > logg\n-fi\n-\n-if [ ${EXECRES}  -ne 0 ]\n-then\n-    echo \"java execution failed for unknown reason, see logs\"\n-    exit 2\n-fi\n-\n-cat logg\n-if [ -s logg ]\n-then\n-    echo \"Success.\"\n-    exit 0\n-else\n-    echo \"Failed. Examine logs.\"\n-    exit 3\n-fi\n-\n-\n","filename":"test\/jdk\/javax\/swing\/LookAndFeel\/8145547\/DemandGTK2.sh","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-How to prepare an Ubuntu machine for GTK-2-less test run.\n-\n-The test DemandGTK2.sh should work well without GTK-2 switching to version 3\n-if there's no GTK-2 library available. \n-At the moment, it's not easy to find a system with GTK-3 and without GTK-2:\n-many programs still depend on version 2.\n-We can, however, rename GTK-2 library for a single test run and then restore\n-it back.\n-\n-(1) Find GTK2 library: run\n-  \/sbin\/ldconfig -v 2>\/dev\/null |  grep libgtk-x11-2\n-\n-It will output one or two lines like \n-libgtk-x11-2.0.so.0 -> libgtk-x11-2.0.so.0.2400.23\n-Search for the target of that symlink for instance with locate:\n-locate libgtk-x11-2.0.so.0.2400.23\n-Finally, you'll find the libraries. On my current machine they are\n-\/usr\/lib\/i386-linux-gnu\/libgtk-x11-2.0.so.0.2400.23\n-\/usr\/lib\/x86_64-linux-gnu\/libgtk-x11-2.0.so.0.2400.23\n-\n-I'm running 64-bit JDK and need to tamper with x86_64 copy only.\n-\n-(2) Find running programs depending on this library. They probably would crash\n-if you rename it. Stop them for this test run.\n-That said, I'm afraid it would be impossible to do on a system older than Ubuntu 16.04.\n-On my Ubuntu 16.04 I have only hud-service using this library, and that's OK, it will restart\n-after a crash, if any.\n-To find these programs, run\n-lsof \/usr\/lib\/x86_64-linux-gnu\/libgtk-x11-2.0.so.0.2400.23\n-\n-(3) Now,\n-sudo mv  \/usr\/lib\/x86_64-linux-gnu\/libgtk-x11-2.0.so.0.2400.23  \/usr\/lib\/x86_64-linux-gnu\/bak.libgtk-x11-2.0.so.0.2400.23\n-jtreg DemandGTK2.sh \n-sudo mv  \/usr\/lib\/x86_64-linux-gnu\/bak.libgtk-x11-2.0.so.0.2400.23  \/usr\/lib\/x86_64-linux-gnu\/libgtk-x11-2.0.so.0.2400.23\n-\n-Needless to say, you should substitute your own library path and however you run jtreg.\n","filename":"test\/jdk\/javax\/swing\/LookAndFeel\/8145547\/DemandGTK2.txt","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -4,1 +4,1 @@\n-# Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#   @summary  Try to force GTK3. We must bail out to GTK2 if no 3 available.\n+#   @summary  Try to force GTK3.\n@@ -56,5 +56,2 @@\n-    \n-    echo \"No GTK 3 library found: we should bail out to 2\"\n-    strace -o strace.log -fe open,openat ${TESTJAVA}\/bin\/java  -cp ${TESTCLASSPATH}  -Djdk.gtk.version=3 ProvokeGTK\n-    EXECRES=$?\n-    grep  'libgtk-x11.*=\\ *[0-9]*$' strace.log > logg\n+    echo \"No GTK 3 library found, do nothing\"\n+    exit 0\n","filename":"test\/jdk\/javax\/swing\/LookAndFeel\/8145547\/DemandGTK3.sh","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"}]}