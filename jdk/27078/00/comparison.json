{"files":[{"patch":"@@ -58,0 +58,36 @@\n+lowercase_table := A,a B,b C,c D,d E,e F,f G,g H,h I,i J,j K,k L,l M,m N,n O,o \\\n+    P,p Q,q R,r S,s T,t U,u V,v W,w X,x Y,y Z,z\n+\n+lowercase_internal = \\\n+  $(if $(strip $1), $$(subst $(firstword $1), $(call lowercase_internal, \\\n+      $(wordlist 2, $(words $1), $1), $2)), $2)\n+\n+# Convert a string to lower case. Works only on a-z.\n+# $1 - The string to convert\n+lowercase = \\\n+  $(strip \\\n+    $(eval lowercase_result := $(call lowercase_internal, $(lowercase_table), $1)) \\\n+    $(lowercase_result) \\\n+  )\n+\n+lowercase_letters := a b c d e f g h i j k l m n o p q r s t u v w x y z\n+uppercase_letters := A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\n+\n+titlecase_internal = \\\n+  $(strip $(or \\\n+    $(strip $(foreach l, $(lowercase_letters) $(uppercase_letters), \\\n+      $(if $(filter $l%, $1), \\\n+        $(call uppercase, $l)$(call lowercase, $(patsubst $l%,%,$1))))), \\\n+    $1))\n+\n+# Convert a string to Title Case. Works only on a-z.\n+# $1 - The string to convert\n+titlecase = \\\n+  $(strip $(foreach w, $1, $(call titlecase_internal, $w)))\n+\n+# Returns the first character of a string. Works only on a-z.\n+# $1 - The string to extract the first character from\n+firstchar = \\\n+  $(strip $(foreach l, $(lowercase_letters) $(uppercase_letters), \\\n+    $(if $(filter $l%, $(firstword $1)), $l)))\n+\n","filename":"make\/common\/Utils.gmk","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,228 @@\n+#\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+include MakeIncludeStart.gmk\n+ifeq ($(INCLUDE), true)\n+\n+################################################################################\n+# This file defines macros that sets up rules for running the spp.Spp build tool\n+################################################################################\n+\n+include Execute.gmk\n+include $(TOPDIR)\/make\/ToolsJdk.gmk\n+\n+NON_BYTE_NUMBER_TYPES := char short int long float double\n+NUMBER_TYPES := byte $(NON_BYTE_NUMBER_TYPES)\n+PRIMITIVE_TYPES := boolean $(NUMBER_TYPES)\n+\n+################################################################################\n+# The Conv function converts a type given as first argument (as a normal Java\n+# native type name), into one of several corresponding strings, depending on\n+# the aspect given in the second argument\n+#\n+# The implementation dispatches the call to one of several Conv_<aspect> macros.\n+#\n+# arg $1: the type to convert\n+# arg $2: the aspect to convert for\n+# arg $3: byte order (only needed for certain aspects)\n+#\n+Conv = \\\n+  $(strip $(call Conv_$(strip $2),$(strip $1),$(strip $3)))\n+\n+################################################################################\n+# Conv_<aspect> implementations\n+\n+# Return a single letter representing the type (lowercase first letter)\n+Conv_x = \\\n+  $(call firstchar, $1)\n+\n+# Return capitalized type name\n+Conv_Type = \\\n+  $(call titlecase, $1)\n+\n+# Return the full descriptive name of the type, e.g. int -> integer\n+Conv_fulltype = \\\n+  $(if $(filter char, $1), \\\n+    character, \\\n+    $(if $(filter int, $1), \\\n+      integer, \\\n+      $1 \\\n+    ) \\\n+  )\n+\n+# Return the capitalized full descriptive name of the type, e.g. int -> Integer\n+Conv_Fulltype = \\\n+  $(call titlecase, $(call Conv_fulltype, $1))\n+\n+# Return log2 bits per value (0-3)\n+Conv_LBPV = \\\n+  $(if $(filter byte, $1), \\\n+    0, \\\n+    $(if $(filter char short, $1), \\\n+      1, \\\n+      $(if $(filter int float, $1), \\\n+        2, \\\n+        $(if $(filter long double, $1), \\\n+          3))))\n+\n+# Return float or int category\n+Conv_category = \\\n+    $(if $(filter float double, $1), \\\n+      floatingPointType, \\\n+      integralType \\\n+    )\n+\n+# Return stream information for char\n+Conv_streams = \\\n+  $(if $(filter char, $1), streamableType)\n+\n+# Return stream type information for char\n+Conv_streamtype = \\\n+  $(if $(filter char, $1), int)\n+\n+# Return capitalized stream type information for char\n+Conv_Streamtype = \\\n+  $(if $(filter char, $1), Int)\n+\n+# Return article to use for type in English text\n+Conv_a = \\\n+  $(if $(filter int, $1), an, a)\n+\n+# Return capitalized article to use for type in English text\n+Conv_A = \\\n+  $(if $(filter int, $1), An, A)\n+\n+# Return integer type with same size as the type\n+Conv_memtype = \\\n+  $(if $(filter float, $1), int, $(if $(filter double, $1), long, $1))\n+\n+# Return capitalized integer type with same size as the type\n+Conv_Memtype = \\\n+  $(call titlecase, $(call Conv, $1, memtype))\n+\n+# Return capitalized full descriptive name for integer type with same size as the type\n+Conv_FullMemtype = \\\n+  $(call Conv, $(call Conv, $1, memtype), Fulltype)\n+\n+# Return Type or Memtype depending on byte order\n+# arg $2: BYTE_ORDER\n+Conv_Swaptype = \\\n+  $(if $(filter U, $2), \\\n+      $(call Conv, $1, Type), \\\n+      $(call Conv, $1, Memtype))\n+\n+# Return fromBits method name for floating types, depending on byte order\n+# arg $2: BYTE_ORDER\n+Conv_fromBits = \\\n+  $(if $(filter float double, $1), \\\n+    $(if $(filter U, $2), , \\\n+      $(call Conv, $1, Type).$(call Conv, $1, memtype)BitsTo$(call Conv, $1, Type)))\n+\n+# Return toBits method name for floating types, depending on byte order\n+# arg $2: BYTE_ORDER\n+Conv_toBits = \\\n+  $(if $(filter float double, $1), \\\n+    $(if $(filter U, $2), , \\\n+      $(call Conv, $1, Type).$1ToRaw$(call Conv, $(call Conv, $1, memtype), Type)Bits))\n+\n+# Return swap method name, depending on byte order\n+# arg $2: BYTE_ORDER\n+Conv_swap = \\\n+  $(if $(filter S, $2), Bits.swap)\n+\n+# Return word describing the number of bytes required by type\n+Conv_nbytes = \\\n+  $(if $(filter 0, $(call Conv, $1, LBPV)), one, \\\n+    $(if $(filter 1, $(call Conv, $1, LBPV)), two, \\\n+      $(if $(filter 2, $(call Conv, $1, LBPV)), four, \\\n+        $(if $(filter 3, $(call Conv, $1, LBPV)), eight))))\n+\n+# Return word describing the number of bytes required by type, minus one\n+Conv_nbytesButOne = \\\n+  $(if $(filter 0, $(call Conv, $1, LBPV)), zero, \\\n+    $(if $(filter 1, $(call Conv, $1, LBPV)), one, \\\n+      $(if $(filter 2, $(call Conv, $1, LBPV)), three, \\\n+        $(if $(filter 3, $(call Conv, $1, LBPV)), seven))))\n+\n+################################################################################\n+# Setup make rules that runs the spp.Spp build tool on an input file.\n+#\n+# Parameter 1 is the name of the rule. This name is used as variable prefix,\n+# and the targets generated are listed in a variable by that name.\n+#\n+# Remaining parameters are named arguments. These include:\n+#   BEGIN_END Set to true to exclude everything outside #begin\/#end (default: false)\n+#   SUBST_EMPTY_LINES Set to false to not generate empty lines for removed lines (default: true)\n+#   SOURCE_FILE The input file to process (required)\n+#   OUTPUT_FILE The output file (required)\n+#   INFO Override default message to print (optional)\n+#   KEYS One or more keys to control the generation (optional)\n+#   REPLACEMENTS one or more text replacement patterns, using the syntax:\n+#       VAR=VALUE [VAR=VALUE] ...\n+#\n+SetupStreamPreProcessing = $(NamedParamsMacroTemplate)\n+define SetupStreamPreProcessingBody\n+  # Verify arguments\n+  ifeq ($$($1_SOURCE_FILE), )\n+    $$(error Must specify SOURCE_FILE (in $1))\n+  endif\n+  ifeq ($$($1_OUTPUT_FILE), )\n+    $$(error Must specify OUTPUT_FILE (in $1))\n+  endif\n+\n+  $1_COMMAND_LINE :=\n+  ifeq ($$($1_BEGIN_END), true)\n+    $1_COMMAND_LINE += -be\n+  endif\n+\n+  ifeq ($$($1_SUBST_EMPTY_LINES), false)\n+    $1_COMMAND_LINE += -nel\n+  endif\n+\n+  $1_COMMAND_LINE += $$(foreach k, $$($1_KEYS), -K$$k)\n+  $1_COMMAND_LINE += $$(subst $$$$(SPACE), ,$$(foreach d, $$($1_REPLACEMENTS), -D$$d))\n+\n+  $1_COMMAND_LINE += -i$$($1_SOURCE_FILE) -o$$($1_OUTPUT_FILE).tmp\n+\n+  ifeq ($$($1_INFO), )\n+    $1_INFO := Preprocessing $$(notdir $$($1_SOURCE_FILE)) for $(MODULE)\n+  endif\n+\n+  $$(eval $$(call SetupExecute, RUN_SPP_$1, \\\n+      INFO := $$($1_INFO), \\\n+      DEPS := $$($1_SOURCE_FILE) $$(BUILD_TOOLS_JDK), \\\n+      OUTPUT_FILE := $$($1_OUTPUT_FILE), \\\n+      COMMAND := $$(TOOL_SPP) $$($1_COMMAND_LINE), \\\n+      PRE_COMMAND := $$(RM) $$($1_OUTPUT_FILE).tmp $$($1_OUTPUT_FILE), \\\n+      POST_COMMAND := $$(MV) $$($1_OUTPUT_FILE).tmp $$($1_OUTPUT_FILE), \\\n+))\n+\n+  $1 += $$(RUN_SPP_$1)\n+endef\n+\n+################################################################################\n+\n+endif # include guard\n+include MakeIncludeEnd.gmk\n","filename":"make\/common\/modules\/GensrcStreamPreProcessing.gmk","additions":228,"deletions":0,"binary":false,"changes":228,"status":"added"},{"patch":"@@ -29,0 +29,2 @@\n+include GensrcProperties.gmk\n+include GensrcStreamPreProcessing.gmk\n@@ -74,2 +76,0 @@\n-include GensrcProperties.gmk\n-\n","filename":"make\/modules\/java.base\/Gensrc.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,2 @@\n-GENSRC_BUFFER :=\n+BUFFER_INPUT_DIR := $(MODULE_SRC)\/share\/classes\/java\/nio\n+BUFFER_OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/gensrc\/java.base\/java\/nio\n@@ -33,190 +34,13 @@\n-GENSRC_BUFFER_DST := $(SUPPORT_OUTPUTDIR)\/gensrc\/java.base\/java\/nio\n-\n-GENSRC_BUFFER_SRC := $(MODULE_SRC)\/share\/classes\/java\/nio\n-\n-###\n-\n-$(GENSRC_BUFFER_DST)\/_the.buffer.dir:\n-\t$(call LogInfo, Generating buffer classes)\n-\t$(call MakeDir, $(@D))\n-\t$(TOUCH) $@\n-\n-define fixRw\n-  $1_RW := $2\n-  $1_rwkey := rw\n-  ifeq (R, $2)\n-    $1_rwkey := ro\n-  endif\n-endef\n-\n-define typesAndBits\n-  # param 1 target\n-  # param 2 type\n-  # param 3 BO\n-  $1_a := a\n-  $1_A := A\n-\n-  $1_type := $2\n-\n-  ifeq ($2, byte)\n-    $1_x        := b\n-    $1_Type     := Byte\n-    $1_fulltype := byte\n-    $1_Fulltype := Byte\n-    $1_category := integralType\n-    $1_LBPV     := 0\n-  endif\n-\n-  ifeq ($2, char)\n-    $1_x        := c\n-    $1_Type     := Char\n-    $1_fulltype := character\n-    $1_Fulltype := Character\n-    $1_category := integralType\n-    $1_streams  := streamableType\n-    $1_streamtype := int\n-    $1_Streamtype := Int\n-    $1_LBPV     := 1\n-  endif\n-\n-  ifeq ($2, short)\n-    $1_x        := s\n-    $1_Type     := Short\n-    $1_fulltype := short\n-    $1_Fulltype := Short\n-    $1_category := integralType\n-    $1_LBPV     := 1\n-  endif\n-\n-  ifeq ($2, int)\n-    $1_a        := an\n-    $1_A        := An\n-    $1_x        := i\n-    $1_Type     := Int\n-    $1_fulltype := integer\n-    $1_Fulltype := Integer\n-    $1_category := integralType\n-    $1_LBPV     := 2\n-  endif\n-\n-  ifeq ($2, long)\n-    $1_x        := l\n-    $1_Type     := Long\n-    $1_fulltype := long\n-    $1_Fulltype := Long\n-    $1_category := integralType\n-    $1_LBPV     := 3\n-  endif\n-\n-  ifeq ($2, float)\n-    $1_x        := f\n-    $1_Type     := Float\n-    $1_fulltype := float\n-    $1_Fulltype := Float\n-    $1_category := floatingPointType\n-    $1_LBPV     := 2\n-  endif\n-\n-  ifeq ($2, double)\n-    $1_x        := d\n-    $1_Type     := Double\n-    $1_fulltype := double\n-    $1_Fulltype := Double\n-    $1_category := floatingPointType\n-    $1_LBPV     := 3\n-  endif\n-\n-  $1_Swaptype := $$($1_Type)\n-  $1_memtype := $2\n-  $1_Memtype := $$($1_Type)\n-\n-  ifeq ($2, float)\n-    $1_memtype := int\n-    $1_Memtype := Int\n-    ifneq ($3, U)\n-      $1_Swaptype := Int\n-      $1_fromBits := Float.intBitsToFloat\n-      $1_toBits   := Float.floatToRawIntBits\n-    endif\n-  endif\n-\n-  ifeq ($2, double)\n-    $1_memtype := long\n-    $1_Memtype := Long\n-    ifneq ($3, U)\n-      $1_Swaptype := Long\n-      $1_fromBits := Double.longBitsToDouble\n-      $1_toBits   := Double.doubleToRawLongBits\n-    endif\n-  endif\n-\n-  ifeq ($3, S)\n-    $1_swap := Bits.swap\n-  endif\n-endef\n-\n-define genBinOps\n-  # param 1 target\n-  # param 2 type\n-  # param 3 BO\n-  # param 4 RW\n-  # param 5 nbytes\n-  # param 6 nbytesButOne\n-  $(call typesAndBits,$1,$2,$3)\n-  $(call fixRw,$1,$4)\n-  $1_nbytes := $5\n-  $1_nbytesButOne := $6\n-  $1_CMD := $(TOOL_SPP) \\\n-    -Dtype=$$($1_type) \\\n-    -DType=$$($1_Type) \\\n-    -Dfulltype=$$($1_fulltype) \\\n-    -Dmemtype=$$($1_memtype) \\\n-    -DMemtype=$$($1_Memtype) \\\n-    -DfromBits=$$($1_fromBits) \\\n-    -DtoBits=$$($1_toBits) \\\n-    -DLG_BYTES_PER_VALUE=$$($1_LBPV) \\\n-    -DBYTES_PER_VALUE=\"(1 << $$($1_LBPV))\" \\\n-    -Dnbytes=$$($1_nbytes) \\\n-    -DnbytesButOne=$$($1_nbytesButOne) \\\n-    -DRW=$$($1_RW) \\\n-    -K$$($1_rwkey) \\\n-    -Da=$$($1_a) \\\n-    -be\n-endef\n-\n-define SetupGenBuffer\n-  # param 1 is for output file\n-  # param 2 is template dependency\n-  # param 3-9 are named args.\n-  #   type :=\n-  #   BIN :=\n-  #   RW := Mutability (R)ead-only (W)ritable\n-  #   BO := (U)nswapped\/(S)wapped\/(L)ittle\/(B)ig\n-  #\n-  $(if $3,$1_$(strip $3))\n-  $(if $4,$1_$(strip $4))\n-  $(if $5,$1_$(strip $5))\n-  $(if $6,$1_$(strip $6))\n-  $(if $7,$1_$(strip $7))\n-  $(if $8,$1_$(strip $8))\n-  $(if $9,$1_$(strip $9))\n-  $(if $(10),$1_$(strip $(10)))\n-  $(if $(11),$1_$(strip $(11)))\n-  $(if $(12),$1_$(strip $(12)))\n-  $(if $(13),$1_$(strip $(13)))\n-  $(if $(14),$1_$(strip $(14)))\n-  $(foreach i,3 4 5 6 7 8 9 10 11 12 13 14 15,$(if $($i),$1_$(strip $($i)))$(NEWLINE))\n-  $(call LogSetupMacroEntry,SetupGenBuffer($1),$2,$3,$4,$5,$6,$7,$8,$9,$(10),$(11),$(12),$(13),$(14),$(15))\n-  $(if $(16),$(error Internal makefile error: Too many arguments to SetupGenBuffer, please update GensrcBuffer.gmk))\n-\n-  $(call fixRw,$1,$$($1_RW))\n-  $(call typesAndBits,$1,$$($1_type),$$($1_BO))\n-\n-  $1_DST := $(GENSRC_BUFFER_DST)\/$1.java\n-  $1_SRC := $(GENSRC_BUFFER_SRC)\/$(strip $2).java.template\n-  $1_SRC_BIN := $(GENSRC_BUFFER_SRC)\/$(strip $2)-bin.java.template\n-\n-  $1_DEP := $$($1_SRC)\n-  ifneq ($$($1_BIN), 1)\n-    $1_DEP := $$($1_SRC)\n-    $1_OUT := $$($1_DST)\n+################################################################################\n+# Helper method to setup generation of bin snippets.\n+# Will add the generated snippet file name to $1_BIN_SNIPPET_FILES.\n+#\n+# arg $1: $1 as passed into SetupGenBuffer\n+# arg $2: type for this bin snippet\n+define SetupGenBufferBinSnippets\n+  $1_$2_TMP := $$(BUFFER_OUTPUT_DIR)\/$1.java.bin-snippet.$2\n+\n+  $1_$2_LBPV :=  $$(call Conv, $2, LBPV)\n+  ifeq ($$($1_READ_ONLY), true)\n+    $1_$2_RW_KEYS := ro\n+    $1_$2_RW_REPLACEMENT := R\n@@ -224,11 +48,2 @@\n-    $1_DEP += $$($1_SRC) $$($1_SRC_BIN)\n-    $1_OUT := $(GENSRC_BUFFER_DST)\/$1.binop.0.java\n-  endif\n-\n-  ifeq ($$($1_BIN), 1)\n-    $(call genBinOps,$1_char,char,$$($1_BO),$$($1_RW),two,one)\n-    $(call genBinOps,$1_short,short,$$($1_BO),$$($1_RW),two,one)\n-    $(call genBinOps,$1_int,int,$$($1_BO),$$($1_RW),four,three)\n-    $(call genBinOps,$1_long,long,$$($1_BO),$$($1_RW),eight,seven)\n-    $(call genBinOps,$1_float,float,$$($1_BO),$$($1_RW),four,three)\n-    $(call genBinOps,$1_double,double,$$($1_BO),$$($1_RW),eight,seven)\n+    $1_$2_RW_KEYS := rw\n+    $1_$2_RW_REPLACEMENT :=\n@@ -237,44 +52,25 @@\n-  $$($1_DST): $$($1_DEP) $(GENSRC_BUFFER_DST)\/_the.buffer.dir\n-\t$(RM) $$($1_OUT).tmp\n-\t$(TOOL_SPP) -i$$($1_SRC) -o$$($1_OUT).tmp \\\n-\t    -K$$($1_type) \\\n-\t    -K$$($1_category) \\\n-\t    -K$$($1_streams) \\\n-\t    -Dtype=$$($1_type) \\\n-\t    -DType=$$($1_Type) \\\n-\t    -Dfulltype=$$($1_fulltype) \\\n-\t    -DFulltype=$$($1_Fulltype) \\\n-\t    -Dstreamtype=$$($1_streamtype) \\\n-\t    -DStreamtype=$$($1_Streamtype) \\\n-\t    -Dx=$$($1_x) \\\n-\t    -Dmemtype=$$($1_memtype) \\\n-\t    -DMemtype=$$($1_Memtype) \\\n-\t    -DSwaptype=$$($1_Swaptype) \\\n-\t    -DfromBits=$$($1_fromBits) \\\n-\t    -DtoBits=$$($1_toBits) \\\n-\t    -DLG_BYTES_PER_VALUE=$$($1_LBPV) \\\n-\t    -DBYTES_PER_VALUE=\"(1 << $$($1_LBPV))\" \\\n-\t    -DBO=$$($1_BO) \\\n-\t    -Dswap=$$($1_swap) \\\n-\t    -DRW=$$($1_RW) \\\n-\t    -K$$($1_rwkey) \\\n-\t    -Da=$$($1_a) \\\n-\t    -DA=$$($1_A) \\\n-\t    -Kbo$$($1_BO)\n-\t$(MV) $$($1_OUT).tmp $$($1_OUT)\n-        # Do the extra bin thing\n-        ifeq ($$($1_BIN), 1)\n-\t  $(SED) -e '\/#BIN\/,$$$$d' < $$($1_OUT) > $$($1_DST).tmp\n-\t  $(RM) $$($1_OUT)\n-\t  $$($1_char_CMD) -i$$($1_SRC_BIN) -o$$($1_DST).tmp\n-\t  $$($1_short_CMD) -i$$($1_SRC_BIN) -o$$($1_DST).tmp\n-\t  $$($1_int_CMD) -i$$($1_SRC_BIN) -o$$($1_DST).tmp\n-\t  $$($1_long_CMD) -i$$($1_SRC_BIN) -o$$($1_DST).tmp\n-\t  $$($1_float_CMD) -i$$($1_SRC_BIN) -o$$($1_DST).tmp\n-\t  $$($1_double_CMD) -i$$($1_SRC_BIN) -o$$($1_DST).tmp\n-\t  $(ECHO) \"}\" >> $$($1_DST).tmp\n-\t  mv $$($1_DST).tmp $$($1_DST)\n-        endif\n-\n-  GENSRC_BUFFER += $$($1_DST)\n-\n+  $$(eval $$(call SetupStreamPreProcessing, GEN_BUFFER_BIN_$1_$2, \\\n+      SOURCE_FILE := $$(BUFFER_INPUT_DIR)\/$$($1_TEMPLATE)-bin.java.template, \\\n+      OUTPUT_FILE := $$($1_$2_TMP), \\\n+      INFO := Generating buffer class bin snippets for $1 ($2), \\\n+      BEGIN_END := true, \\\n+      KEYS := \\\n+          $$($1_$2_RW_KEYS), \\\n+      REPLACEMENTS := \\\n+          type=$2 \\\n+          RW=$$($1_$2_RW_REPLACEMENT) \\\n+          LG_BYTES_PER_VALUE=$$($1_$2_LBPV) \\\n+          BYTES_PER_VALUE=\"(1$$$$(SPACE)<<$$$$(SPACE)$$($1_$2_LBPV))\" \\\n+          a=$$(call Conv, $2, a) \\\n+          fulltype=$$(call Conv, $2, fulltype) \\\n+          memtype=$$(call Conv, $2, memtype) \\\n+          Memtype=$$(call Conv, $2, Memtype) \\\n+          nbytes=$$(call Conv, $2, nbytes) \\\n+          nbytesButOne=$$(call Conv, $2, nbytesButOne) \\\n+          Type=$$(call Conv, $2, Type) \\\n+          fromBits=$$(call Conv, $2, fromBits, $$($1_BYTE_ORDER)) \\\n+          toBits=$$(call Conv, $2, toBits, $$($1_BYTE_ORDER)), \\\n+  ))\n+  TARGETS += $$(GEN_BUFFER_$1_$2)\n+\n+  $1_BIN_SNIPPET_FILES += $$($1_$2_TMP)\n@@ -283,32 +79,3 @@\n-###\n-\n-X_BUF := X-Buffer\n-\n-$(eval $(call SetupGenBuffer,ByteBuffer,  $(X_BUF), type := byte, BIN := 1))\n-$(eval $(call SetupGenBuffer,CharBuffer,  $(X_BUF), type := char))\n-$(eval $(call SetupGenBuffer,ShortBuffer, $(X_BUF), type := short))\n-$(eval $(call SetupGenBuffer,IntBuffer,   $(X_BUF), type := int))\n-$(eval $(call SetupGenBuffer,LongBuffer,  $(X_BUF), type := long))\n-$(eval $(call SetupGenBuffer,FloatBuffer, $(X_BUF), type := float))\n-$(eval $(call SetupGenBuffer,DoubleBuffer,$(X_BUF), type := double))\n-\n-# Buffers whose contents are heap-allocated\n-#\n-HEAP_X_BUF := Heap-X-Buffer\n-\n-$(eval $(call SetupGenBuffer,HeapByteBuffer,   $(HEAP_X_BUF), type := byte))\n-$(eval $(call SetupGenBuffer,HeapByteBufferR,  $(HEAP_X_BUF), type := byte, RW := R))\n-$(eval $(call SetupGenBuffer,HeapCharBuffer,   $(HEAP_X_BUF), type := char))\n-$(eval $(call SetupGenBuffer,HeapCharBufferR,  $(HEAP_X_BUF), type := char, RW := R))\n-$(eval $(call SetupGenBuffer,HeapShortBuffer,  $(HEAP_X_BUF), type := short))\n-$(eval $(call SetupGenBuffer,HeapShortBufferR, $(HEAP_X_BUF), type := short, RW := R))\n-$(eval $(call SetupGenBuffer,HeapIntBuffer,    $(HEAP_X_BUF), type := int))\n-$(eval $(call SetupGenBuffer,HeapIntBufferR,   $(HEAP_X_BUF), type := int, RW := R))\n-$(eval $(call SetupGenBuffer,HeapLongBuffer,   $(HEAP_X_BUF), type := long))\n-$(eval $(call SetupGenBuffer,HeapLongBufferR,  $(HEAP_X_BUF), type := long, RW := R))\n-$(eval $(call SetupGenBuffer,HeapFloatBuffer,  $(HEAP_X_BUF), type := float))\n-$(eval $(call SetupGenBuffer,HeapFloatBufferR, $(HEAP_X_BUF), type := float, RW := R))\n-$(eval $(call SetupGenBuffer,HeapDoubleBuffer, $(HEAP_X_BUF), type := double))\n-$(eval $(call SetupGenBuffer,HeapDoubleBufferR,$(HEAP_X_BUF), type := double, RW := R))\n-\n-# Direct byte buffer\n+################################################################################\n+# Setup make rules that creates a generated buffer class java source file,\n+# according to specifications provided.\n@@ -316,6 +83,3 @@\n-DIRECT_X_BUF := Direct-X-Buffer\n-\n-$(eval $(call SetupGenBuffer,DirectByteBuffer, $(DIRECT_X_BUF), type := byte, BIN := 1))\n-$(eval $(call SetupGenBuffer,DirectByteBufferR,$(DIRECT_X_BUF), type := byte, BIN := 1, RW := R))\n-\n-# Unswapped views of direct byte buffers\n+# Parameter 1 is the name of the rule. This name is used as variable prefix,\n+# and the targets generated are listed in a variable by that name. The output\n+# file name is also based on this.\n@@ -323,14 +87,6 @@\n-$(eval $(call SetupGenBuffer,DirectCharBufferU,   $(DIRECT_X_BUF), type := char, BO := U))\n-$(eval $(call SetupGenBuffer,DirectCharBufferRU,  $(DIRECT_X_BUF), type := char, RW := R, BO := U))\n-$(eval $(call SetupGenBuffer,DirectShortBufferU,  $(DIRECT_X_BUF), type := short, BO := U))\n-$(eval $(call SetupGenBuffer,DirectShortBufferRU, $(DIRECT_X_BUF), type := short, RW := R, BO := U))\n-$(eval $(call SetupGenBuffer,DirectIntBufferU,    $(DIRECT_X_BUF), type := int, BO := U))\n-$(eval $(call SetupGenBuffer,DirectIntBufferRU,   $(DIRECT_X_BUF), type := int, RW := R, BO := U))\n-$(eval $(call SetupGenBuffer,DirectLongBufferU,   $(DIRECT_X_BUF), type := long, BO := U))\n-$(eval $(call SetupGenBuffer,DirectLongBufferRU,  $(DIRECT_X_BUF), type := long, RW := R, BO := U))\n-$(eval $(call SetupGenBuffer,DirectFloatBufferU,  $(DIRECT_X_BUF), type := float, BO := U))\n-$(eval $(call SetupGenBuffer,DirectFloatBufferRU, $(DIRECT_X_BUF), type := float, RW := R, BO := U))\n-$(eval $(call SetupGenBuffer,DirectDoubleBufferU, $(DIRECT_X_BUF), type := double, BO := U))\n-$(eval $(call SetupGenBuffer,DirectDoubleBufferRU,$(DIRECT_X_BUF), type := double, RW := R, BO := U))\n-\n-# Swapped views of direct byte buffers\n+# Remaining parameters are named arguments. These include:\n+#   TYPE          The native type\n+#   TEMPLATE      The base file name of the template to use\n+#   BYTE_ORDER    (U)nswapped\/(S)wapped\/(L)ittle\/(B)ig\n+#   READ_ONLY     Set to true to generate read-only buffers (default: false)\n+#   GENERATE_BIN  Set to true to generate bin snippets (default: false)\n@@ -338,12 +94,9 @@\n-$(eval $(call SetupGenBuffer,DirectCharBufferS,   $(DIRECT_X_BUF), type := char, BO := S))\n-$(eval $(call SetupGenBuffer,DirectCharBufferRS,  $(DIRECT_X_BUF), type := char, RW := R, BO := S))\n-$(eval $(call SetupGenBuffer,DirectShortBufferS,  $(DIRECT_X_BUF), type := short, BO := S))\n-$(eval $(call SetupGenBuffer,DirectShortBufferRS, $(DIRECT_X_BUF), type := short, RW := R, BO := S))\n-$(eval $(call SetupGenBuffer,DirectIntBufferS,    $(DIRECT_X_BUF), type := int, BO := S))\n-$(eval $(call SetupGenBuffer,DirectIntBufferRS,   $(DIRECT_X_BUF), type := int, RW := R, BO := S))\n-$(eval $(call SetupGenBuffer,DirectLongBufferS,   $(DIRECT_X_BUF), type := long, BO := S))\n-$(eval $(call SetupGenBuffer,DirectLongBufferRS,  $(DIRECT_X_BUF), type := long, RW := R, BO := S))\n-$(eval $(call SetupGenBuffer,DirectFloatBufferS,  $(DIRECT_X_BUF), type := float, BO := S))\n-$(eval $(call SetupGenBuffer,DirectFloatBufferRS, $(DIRECT_X_BUF), type := float, RW := R, BO := S))\n-$(eval $(call SetupGenBuffer,DirectDoubleBufferS, $(DIRECT_X_BUF), type := double, BO := S))\n-$(eval $(call SetupGenBuffer,DirectDoubleBufferRS,$(DIRECT_X_BUF), type := double, RW := R, BO := S))\n+SetupGenBuffer = $(NamedParamsMacroTemplate)\n+define SetupGenBufferBody\n+  $1_OUTPUT := $$(BUFFER_OUTPUT_DIR)\/$1.java\n+  ifeq ($$($1_GENERATE_BIN), true)\n+    # After generating the buffer class, we need to do further post processing,\n+    # so output to a temporary file\n+    $1_REAL_OUTPUT := $$($1_OUTPUT)\n+    $1_OUTPUT := $$($1_OUTPUT).bin-snippet.tmp\n+  endif\n@@ -351,3 +104,8 @@\n-# Big-endian views of byte buffers\n-#\n-BYTE_X_BUF := ByteBufferAs-X-Buffer\n+  $1_LBPV := $$(call Conv, $$($1_TYPE), LBPV)\n+  ifeq ($$($1_READ_ONLY), true)\n+    $1_RW_KEYS := ro\n+    $1_RW_REPLACEMENT := R\n+  else\n+    $1_RW_KEYS := rw\n+    $1_RW_REPLACEMENT :=\n+  endif\n@@ -355,12 +113,55 @@\n-$(eval $(call SetupGenBuffer,ByteBufferAsCharBufferB,   $(BYTE_X_BUF), type := char, BO := B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsCharBufferRB,  $(BYTE_X_BUF), type := char, RW := R, BO := B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsShortBufferB,  $(BYTE_X_BUF), type := short, BO := B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsShortBufferRB, $(BYTE_X_BUF), type := short, RW := R, BO := B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsIntBufferB,    $(BYTE_X_BUF), type := int, BO := B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsIntBufferRB,   $(BYTE_X_BUF), type := int, RW := R, BO := B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsLongBufferB,   $(BYTE_X_BUF), type := long, BO := B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsLongBufferRB,  $(BYTE_X_BUF), type := long, RW := R, BO := B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsFloatBufferB,  $(BYTE_X_BUF), type := float, BO := B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsFloatBufferRB, $(BYTE_X_BUF), type := float, RW := R, BO := B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsDoubleBufferB, $(BYTE_X_BUF), type := double, BO := B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsDoubleBufferRB,$(BYTE_X_BUF), type := double, RW := R, BO := B))\n+  $$(eval $$(call SetupStreamPreProcessing, GEN_BUFFER_$1, \\\n+      SOURCE_FILE := $$(BUFFER_INPUT_DIR)\/$$($1_TEMPLATE).java.template, \\\n+      OUTPUT_FILE := $$($1_OUTPUT), \\\n+      INFO := Generating buffer class $1.java, \\\n+      KEYS := \\\n+          $$($1_TYPE) \\\n+          $$($1_RW_KEYS) \\\n+          bo$$($1_BYTE_ORDER) \\\n+          $$(call Conv, $$($1_TYPE), category) \\\n+          $$(call Conv, $$($1_TYPE), streams), \\\n+      REPLACEMENTS := \\\n+          type=$$($1_TYPE) \\\n+          BO=$$($1_BYTE_ORDER) \\\n+          RW=$$($1_RW_REPLACEMENT) \\\n+          LG_BYTES_PER_VALUE=$$($1_LBPV) \\\n+          BYTES_PER_VALUE=\"(1$$$$(SPACE)<<$$$$(SPACE)$$($1_$2_LBPV))\" \\\n+          a=$$(call Conv, $$($1_TYPE), a) \\\n+          A=$$(call Conv, $$($1_TYPE), A) \\\n+          fulltype=$$(call Conv, $$($1_TYPE), fulltype) \\\n+          Fulltype=$$(call Conv, $$($1_TYPE), Fulltype) \\\n+          memtype=$$(call Conv, $$($1_TYPE), memtype) \\\n+          Memtype=$$(call Conv, $$($1_TYPE), Memtype) \\\n+          streamtype=$$(call Conv, $$($1_TYPE), streamtype) \\\n+          Streamtype=$$(call Conv, $$($1_TYPE), Streamtype) \\\n+          Type=$$(call Conv, $$($1_TYPE), Type) \\\n+          x=$$(call Conv, $$($1_TYPE), x) \\\n+          fromBits=$$(call Conv, $$($1_TYPE), fromBits, $$($1_BYTE_ORDER)) \\\n+          toBits=$$(call Conv, $$($1_TYPE), toBits, $$($1_BYTE_ORDER)) \\\n+          swap=$$(call Conv, $$($1_TYPE), swap, $$($1_BYTE_ORDER)) \\\n+          Swaptype=$$(call Conv, $$($1_TYPE), Swaptype, $$($1_BYTE_ORDER)), \\\n+  ))\n+  TARGETS += $$(GEN_BUFFER_$1)\n+  $1 += $$(GEN_BUFFER_$1)\n+\n+  ifeq ($$($1_GENERATE_BIN), true)\n+    # Setup generation of snippet files, one for each non-byte type. This will\n+    # populate $1_BIN_SNIPPET_FILES.\n+    $1_BIN_SNIPPET_FILES :=\n+    $$(foreach t, $$(NON_BYTE_NUMBER_TYPES), \\\n+      $$(eval $$(call SetupGenBufferBinSnippets,$1,$$t)) \\\n+    )\n+\n+    # Inject these snippets in the file generated by GEN_BUFFER_$1\n+    $$($1_REAL_OUTPUT): $$($1_OUTPUT) $$($1_BIN_SNIPPET_FILES)\n+\t$$(call LogInfo, Concatenating buffer class bin snippets for $1)\n+        # Delete everything from the line containing #BIN and below\n+\t$$(SED) -e '\/#BIN\/,$$$$d' < $$($1_OUTPUT) > $$($1_REAL_OUTPUT).tmp\n+\t$$(CAT) $$($1_BIN_SNIPPET_FILES) >> $$($1_REAL_OUTPUT).tmp\n+\t$$(ECHO) \"}\" >> $$($1_REAL_OUTPUT).tmp\n+\t$$(MV) $$($1_REAL_OUTPUT).tmp $$($1_REAL_OUTPUT)\n+\n+    TARGETS += $$($1_REAL_OUTPUT)\n+    $1 += $$($1_REAL_OUTPUT)\n+  endif\n+endef\n@@ -368,1 +169,3 @@\n-# Little-endian views of byte buffers\n+################################################################################\n+# Helper method to setup generation of all buffer classes, for a given\n+# modifiability state (read-only or not)\n@@ -370,12 +173,20 @@\n-$(eval $(call SetupGenBuffer,ByteBufferAsCharBufferL,   $(BYTE_X_BUF), type := char, BO := L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsCharBufferRL,  $(BYTE_X_BUF), type := char, RW := R, BO := L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsShortBufferL,  $(BYTE_X_BUF), type := short, BO := L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsShortBufferRL, $(BYTE_X_BUF), type := short, RW := R, BO := L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsIntBufferL,    $(BYTE_X_BUF), type := int, BO := L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsIntBufferRL,   $(BYTE_X_BUF), type := int, RW := R, BO := L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsLongBufferL,   $(BYTE_X_BUF), type := long, BO := L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsLongBufferRL,  $(BYTE_X_BUF), type := long, RW := R, BO := L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsFloatBufferL,  $(BYTE_X_BUF), type := float, BO := L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsFloatBufferRL, $(BYTE_X_BUF), type := float, RW := R, BO := L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsDoubleBufferL, $(BYTE_X_BUF), type := double, BO := L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsDoubleBufferRL,$(BYTE_X_BUF), type := double, RW := R, BO := L))\n+# arg $1: READ_ONLY argument, true or false\n+# arg $2: Modifiability marker for class name (R or empty)\n+define SetupGenerateBuffersWithRO\n+  ifeq ($1, false)\n+    # The basic buffer classes are not generated in READ_ONLY versions\n+    $$(eval $$(call SetupGenBuffer, ByteBuffer, \\\n+        TYPE := byte, \\\n+        TEMPLATE := X-Buffer, \\\n+        GENERATE_BIN := true, \\\n+    ))\n+    TARGETS += $$(ByteBuffer)\n+\n+    $$(foreach t, $$(NON_BYTE_NUMBER_TYPES), \\\n+      $$(eval $$(call SetupGenBuffer, $$(call titlecase, $$t)Buffer, \\\n+          TYPE := $$t, \\\n+          TEMPLATE := X-Buffer, \\\n+      )) \\\n+      $$(eval TARGETS += $$($$(call titlecase, $$t)Buffer)) \\\n+    )\n+  endif\n@@ -383,1 +194,47 @@\n-###\n+  # Buffers whose contents are heap-allocated, one for every type\n+  $$(foreach t, $$(NUMBER_TYPES), \\\n+    $$(eval $$(call SetupGenBuffer, Heap$$(call titlecase, $$t)Buffer$2, \\\n+        TYPE := $$t, \\\n+        TEMPLATE := Heap-X-Buffer, \\\n+        READ_ONLY := $1, \\\n+    )) \\\n+    $$(eval TARGETS += $$(Heap$$(call titlecase, $$t)Buffer$2)) \\\n+  )\n+\n+  # Treat byte special for DirectByteBuffer classes\n+  $$(eval $$(call SetupGenBuffer, DirectByteBuffer$2, \\\n+      TEMPLATE := Direct-X-Buffer, \\\n+      TYPE := byte, \\\n+      GENERATE_BIN := true, \\\n+      READ_ONLY := $1, \\\n+  ))\n+  TARGETS += $$(DirectByteBuffer$2)\n+\n+  # Generate Swapped and Unswapped views of the direct byte buffers, each for\n+  # every non-byte type\n+  $$(foreach b, U S, \\\n+    $$(foreach t, $$(NON_BYTE_NUMBER_TYPES), \\\n+      $$(eval $$(call SetupGenBuffer, Direct$$(call titlecase, $$t)Buffer$2$$b, \\\n+          TYPE := $$t, \\\n+          TEMPLATE := Direct-X-Buffer, \\\n+          BYTE_ORDER := $$b, \\\n+          READ_ONLY := $1, \\\n+      )) \\\n+      $$(eval TARGETS += $$(Direct$$(call titlecase, $$t)Buffer$2$$b)) \\\n+    ) \\\n+  )\n+\n+  # Generate Big and Little endian views of the direct byte buffers, each for\n+  # every non-byte type\n+  $$(foreach b, B L, \\\n+    $$(foreach t, $$(NON_BYTE_NUMBER_TYPES), \\\n+      $$(eval $$(call SetupGenBuffer, ByteBufferAs$$(call titlecase, $$t)Buffer$2$$b, \\\n+          TYPE := $$t, \\\n+          TEMPLATE := ByteBufferAs-X-Buffer, \\\n+          BYTE_ORDER := $$b, \\\n+          READ_ONLY := $1, \\\n+      )) \\\n+      $$(eval TARGETS += $$(ByteBufferAs$$(call titlecase, $$t)Buffer$2$$b)) \\\n+    ) \\\n+  )\n+endef\n@@ -385,1 +242,2 @@\n-$(GENSRC_BUFFER): $(BUILD_TOOLS_JDK)\n+################################################################################\n+# Generate buffers in both read-write and read-only variants for all buffers\n@@ -387,1 +245,2 @@\n-TARGETS += $(GENSRC_BUFFER)\n+$(eval $(call SetupGenerateBuffersWithRO,false,))\n+$(eval $(call SetupGenerateBuffersWithRO,true,R))\n","filename":"make\/modules\/java.base\/gensrc\/GensrcBuffer.gmk","additions":200,"deletions":341,"binary":false,"changes":541,"status":"modified"},{"patch":"@@ -31,79 +31,2 @@\n-GENSRC_CHARSETCODER :=\n-\n-GENSRC_CHARSETCODER_DST := $(SUPPORT_OUTPUTDIR)\/gensrc\/java.base\/java\/nio\/charset\n-\n-GENSRC_CHARSETCODER_SRC := $(MODULE_SRC)\/share\/classes\/java\/nio\n-\n-GENSRC_CHARSETCODER_TEMPLATE := $(GENSRC_CHARSETCODER_SRC)\/charset\/Charset-X-Coder.java.template\n-\n-################################################################################\n-\n-$(GENSRC_CHARSETCODER_DST)\/CharsetDecoder.java: $(GENSRC_CHARSETCODER_TEMPLATE)\n-\t$(call MakeTargetDir)\n-\t$(RM) $@.tmp\n-\t$(call ExecuteWithLog, $(SUPPORT_OUTPUTDIR)\/gensrc\/java.base\/_charset_decoder, \\\n-\t    $(TOOL_SPP) -i$< -o$@.tmp \\\n-\t    -Kdecoder \\\n-\t    -DA='A' \\\n-\t    -Da='a' \\\n-\t    -DCode='Decode' \\\n-\t    -Dcode='decode' \\\n-\t    -DitypesPhrase='bytes in a specific charset' \\\n-\t    -DotypesPhrase='sixteen-bit Unicode characters' \\\n-\t    -Ditype='byte' \\\n-\t    -Dotype='character' \\\n-\t    -DItype='Byte' \\\n-\t    -DOtype='Char' \\\n-\t    -Dcoder='decoder' \\\n-\t    -DCoder='Decoder' \\\n-\t    -Dcoding='decoding' \\\n-\t    -DOtherCoder='Encoder' \\\n-\t    -DreplTypeName='string' \\\n-\t    -DdefaultRepl='\"\\\\uFFFD\"' \\\n-\t    -DdefaultReplName='<code>\"\\&#92;uFFFD\"<\\\/code>' \\\n-\t    -DreplType='String' \\\n-\t    -DreplFQType='java.lang.String' \\\n-\t    -DreplLength='length()' \\\n-\t    -DItypesPerOtype='CharsPerByte' \\\n-\t    -DnotLegal='not legal for this charset' \\\n-\t    -Dotypes-per-itype='chars-per-byte' \\\n-\t    -DoutSequence='Unicode character')\n-\t$(MV) $@.tmp $@\n-\n-GENSRC_CHARSETCODER += $(GENSRC_CHARSETCODER_DST)\/CharsetDecoder.java\n-\n-################################################################################\n-\n-$(GENSRC_CHARSETCODER_DST)\/CharsetEncoder.java: $(GENSRC_CHARSETCODER_TEMPLATE)\n-\t$(call MakeTargetDir)\n-\t$(RM) $@.tmp\n-\t$(call ExecuteWithLog, $(SUPPORT_OUTPUTDIR)\/gensrc\/java.base\/_charset_encoder, \\\n-\t    $(TOOL_SPP) -i$< -o$@.tmp \\\n-\t    -Kencoder \\\n-\t    -DA='An' \\\n-\t    -Da='an' \\\n-\t    -DCode='Encode' \\\n-\t    -Dcode='encode' \\\n-\t    -DitypesPhrase='sixteen-bit Unicode characters' \\\n-\t    -DotypesPhrase='bytes in a specific charset' \\\n-\t    -Ditype='character' \\\n-\t    -Dotype='byte' \\\n-\t    -DItype='Char' \\\n-\t    -DOtype='Byte' \\\n-\t    -Dcoder='encoder' \\\n-\t    -DCoder='Encoder' \\\n-\t    -Dcoding='encoding' \\\n-\t    -DOtherCoder='Decoder' \\\n-\t    -DreplTypeName='byte array' \\\n-\t    -DdefaultRepl='new byte[] { (byte)'\"'\"\\\\?\"'\"' }' \\\n-\t    -DdefaultReplName='<code>{<\\\/code>\\&nbsp;<code>(byte)'\"'\"\\\\?\"'\"'<\\\/code>\\&nbsp;<code>}<\\\/code>' \\\n-\t    -DreplType='byte[]' \\\n-\t    -DreplFQType='byte[]' \\\n-\t    -DreplLength='length' \\\n-\t    -DItypesPerOtype='BytesPerChar' \\\n-\t    -DnotLegal='not a legal sixteen-bit Unicode sequence' \\\n-\t    -Dotypes-per-itype='bytes-per-char' \\\n-\t    -DoutSequence='byte sequence in the given charset')\n-\t$(MV) $@.tmp $@\n-\n-GENSRC_CHARSETCODER += $(GENSRC_CHARSETCODER_DST)\/CharsetEncoder.java\n+CHARSETCODER_INPUT := $(MODULE_SRC)\/share\/classes\/java\/nio\/charset\/Charset-X-Coder.java.template\n+CHARSETCODER_OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/gensrc\/java.base\/java\/nio\/charset\n@@ -113,3 +36,63 @@\n-$(GENSRC_CHARSETCODER): $(BUILD_TOOLS_JDK)\n-\n-TARGETS += $(GENSRC_CHARSETCODER)\n+$(eval $(call SetupStreamPreProcessing, GEN_CHARSETDECODER, \\\n+    SOURCE_FILE := $(CHARSETCODER_INPUT), \\\n+    OUTPUT_FILE := $(CHARSETCODER_OUTPUT_DIR)\/CharsetDecoder.java, \\\n+    INFO := Generating CharsetDecoder.java, \\\n+    KEYS := decoder, \\\n+    REPLACEMENTS := \\\n+        A='A' \\\n+        a='a' \\\n+        Code='Decode' \\\n+        code='decode' \\\n+        itypesPhrase='bytes$$(SPACE)in$$(SPACE)a$$(SPACE)specific$$(SPACE)charset' \\\n+        otypesPhrase='sixteen-bit$$(SPACE)Unicode$$(SPACE)characters' \\\n+        itype='byte' \\\n+        otype='character' \\\n+        Itype='Byte' \\\n+        Otype='Char' \\\n+        coder='decoder' \\\n+        Coder='Decoder' \\\n+        coding='decoding' \\\n+        OtherCoder='Encoder' \\\n+        replTypeName='string' \\\n+        replType='String' \\\n+        replFQType='java.lang.String' \\\n+        replLength='length()' \\\n+        ItypesPerOtype='CharsPerByte' \\\n+        notLegal='not$$(SPACE)legal$$(SPACE)for$$(SPACE)this$$(SPACE)charset' \\\n+        otypes-per-itype='chars-per-byte' \\\n+        outSequence='Unicode$$(SPACE)character', \\\n+))\n+\n+TARGETS += $(GEN_CHARSETDECODER)\n+\n+$(eval $(call SetupStreamPreProcessing, GEN_CHARSETENCODER, \\\n+    SOURCE_FILE := $(CHARSETCODER_INPUT), \\\n+    OUTPUT_FILE := $(CHARSETCODER_OUTPUT_DIR)\/CharsetEncoder.java, \\\n+    INFO := Generating CharsetEncoder.java, \\\n+    KEYS := encoder, \\\n+    REPLACEMENTS := \\\n+        A='An' \\\n+        a='an' \\\n+        Code='Encode' \\\n+        code='encode' \\\n+        itypesPhrase='sixteen-bit$$(SPACE)Unicode$$(SPACE)characters' \\\n+        otypesPhrase='bytes$$(SPACE)in$$(SPACE)a$$(SPACE)specific$$(SPACE)charset' \\\n+        itype='character' \\\n+        otype='byte' \\\n+        Itype='Char' \\\n+        Otype='Byte' \\\n+        coder='encoder' \\\n+        Coder='Encoder' \\\n+        coding='encoding' \\\n+        OtherCoder='Decoder' \\\n+        replTypeName='byte$$(SPACE)array' \\\n+        replType='byte[]' \\\n+        replFQType='byte[]' \\\n+        replLength='length' \\\n+        ItypesPerOtype='BytesPerChar' \\\n+        notLegal='not$$(SPACE)a$$(SPACE)legal$$(SPACE)sixteen-bit$$(SPACE)Unicode$$(SPACE)sequence' \\\n+        otypes-per-itype='bytes-per-char' \\\n+        outSequence='byte$$(SPACE)sequence$$(SPACE)in$$(SPACE)the$$(SPACE)given$$(SPACE)charset', \\\n+))\n+\n+TARGETS += $(GEN_CHARSETENCODER)\n","filename":"make\/modules\/java.base\/gensrc\/GensrcCharsetCoder.gmk","additions":65,"deletions":82,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -31,5 +31,3 @@\n-SCOPED_MEMORY_ACCESS_GENSRC_DIR := $(SUPPORT_OUTPUTDIR)\/gensrc\/java.base\/jdk\/internal\/misc\n-SCOPED_MEMORY_ACCESS_SRC_DIR := $(MODULE_SRC)\/share\/classes\/jdk\/internal\/misc\n-SCOPED_MEMORY_ACCESS_TEMPLATE := $(SCOPED_MEMORY_ACCESS_SRC_DIR)\/X-ScopedMemoryAccess.java.template\n-SCOPED_MEMORY_ACCESS_BIN_TEMPLATE := $(SCOPED_MEMORY_ACCESS_SRC_DIR)\/X-ScopedMemoryAccess-bin.java.template\n-SCOPED_MEMORY_ACCESS_DEST := $(SCOPED_MEMORY_ACCESS_GENSRC_DIR)\/ScopedMemoryAccess.java\n+SCOPED_INPUT_DIR := $(MODULE_SRC)\/share\/classes\/jdk\/internal\/misc\n+SCOPED_INPUT := $(SCOPED_INPUT_DIR)\/X-ScopedMemoryAccess.java.template\n+SCOPED_OUTPUT := $(SUPPORT_OUTPUTDIR)\/gensrc\/java.base\/jdk\/internal\/misc\/ScopedMemoryAccess.java\n@@ -38,61 +36,6 @@\n-# Setup a rule for generating the ScopedMemoryAccess java class\n-# Param 1 - Variable declaration prefix\n-# Param 2 - Type with first letter capitalized\n-define GenerateScopedOp\n-\n-  $1_Type := $2\n-\n-  ifeq ($$($1_Type), Boolean)\n-    $1_type := boolean\n-    $1_BoxType := $$($1_Type)\n-\n-    $1_rawType := $$($1_type)\n-    $1_RawType := $$($1_Type)\n-    $1_RawBoxType := $$($1_BoxType)\n-\n-    $1_ARGS += -KCAS\n-  endif\n-\n-  ifeq ($$($1_Type), Byte)\n-    $1_type := byte\n-    $1_BoxType := $$($1_Type)\n-\n-    $1_rawType := $$($1_type)\n-    $1_RawType := $$($1_Type)\n-    $1_RawBoxType := $$($1_BoxType)\n-\n-    $1_ARGS += -KCAS\n-    $1_ARGS += -Kbyte\n-  endif\n-\n-  ifeq ($$($1_Type), Short)\n-    $1_type := short\n-    $1_BoxType := $$($1_Type)\n-\n-    $1_rawType := $$($1_type)\n-    $1_RawType := $$($1_Type)\n-    $1_RawBoxType := $$($1_BoxType)\n-\n-    $1_ARGS += -KCAS\n-    $1_ARGS += -KUnaligned\n-  endif\n-\n-  ifeq ($$($1_Type), Char)\n-    $1_type := char\n-    $1_BoxType := Character\n-\n-    $1_rawType := $$($1_type)\n-    $1_RawType := $$($1_Type)\n-    $1_RawBoxType := $$($1_BoxType)\n-\n-    $1_ARGS += -KCAS\n-    $1_ARGS += -KUnaligned\n-  endif\n-\n-  ifeq ($$($1_Type), Int)\n-    $1_type := int\n-    $1_BoxType := Integer\n-\n-    $1_rawType := $$($1_type)\n-    $1_RawType := $$($1_Type)\n-    $1_RawBoxType := $$($1_BoxType)\n+# Helper method to setup generation of scoped snippets.\n+# Will add the generated snippet file name to SCOPED_SNIPPET_FILES.\n+#\n+# arg $1: type for this snippet\n+define SetupGenScopedSnippets\n+  $1_SCOPED_SNIPPET_FILE := $$(SCOPED_OUTPUT).snippet.$1\n@@ -100,2 +43,3 @@\n-    $1_ARGS += -KCAS\n-    $1_ARGS += -KUnaligned\n+  $1_KEYS := $1 CAS\n+  ifneq ($$(filter byte, $1),)\n+    $1_KEYS += byte\n@@ -103,11 +47,2 @@\n-\n-  ifeq ($$($1_Type), Long)\n-    $1_type := long\n-    $1_BoxType := $$($1_Type)\n-\n-    $1_rawType := $$($1_type)\n-    $1_RawType := $$($1_Type)\n-    $1_RawBoxType := $$($1_BoxType)\n-\n-    $1_ARGS += -KCAS\n-    $1_ARGS += -KUnaligned\n+  ifneq ($$(filter float double, $1),)\n+    $1_KEYS += floatingPoint\n@@ -115,11 +50,2 @@\n-\n-  ifeq ($$($1_Type), Float)\n-    $1_type := float\n-    $1_BoxType := $$($1_Type)\n-\n-    $1_rawType := int\n-    $1_RawType := Int\n-    $1_RawBoxType := Integer\n-\n-    $1_ARGS += -KCAS\n-    $1_ARGS += -KfloatingPoint\n+  ifneq ($$(filter char short int long, $1),)\n+    $1_KEYS += Unaligned\n@@ -127,11 +53,2 @@\n-\n-  ifeq ($$($1_Type), Double)\n-    $1_type := double\n-    $1_BoxType := $$($1_Type)\n-\n-    $1_rawType := long\n-    $1_RawType := Long\n-    $1_RawBoxType := Long\n-\n-    $1_ARGS += -KCAS\n-    $1_ARGS += -KfloatingPoint\n+  ifneq ($$(filter boolean byte char short, $1),)\n+    $1_KEYS += ShorterThanInt\n@@ -139,3 +56,2 @@\n-\n-  ifneq ($$(findstring $$($1_Type), Byte Short Char Int Long Float Double), )\n-    $1_ARGS += -KAtomicAdd\n+  ifeq ($$(filter boolean, $1),)\n+    $1_KEYS += AtomicAdd\n@@ -143,3 +59,2 @@\n-\n-  ifneq ($$(findstring $$($1_Type), Boolean Byte Short Char Int Long), )\n-    $1_ARGS += -KBitwise\n+  ifeq ($$(filter float double, $1),)\n+    $1_KEYS += Bitwise\n@@ -148,3 +63,13 @@\n-  ifneq ($$(findstring $$($1_Type), Boolean Byte Short Char), )\n-    $1_ARGS += -KShorterThanInt\n-  endif\n+  $$(eval $$(call SetupStreamPreProcessing, GEN_SCOPED_SNIPPET_$1, \\\n+      SOURCE_FILE := $$(SCOPED_INPUT_DIR)\/X-ScopedMemoryAccess-bin.java.template, \\\n+      OUTPUT_FILE := $$($1_SCOPED_SNIPPET_FILE), \\\n+      INFO := Generating snippets for ScopedMemoryAccess ($1), \\\n+      SUBST_EMPTY_LINES := false, \\\n+      KEYS := $$($1_KEYS), \\\n+      REPLACEMENTS := \\\n+          type=$1 \\\n+          Type=$$(call Conv, $1, Type), \\\n+  ))\n+  TARGETS += $$(GEN_SCOPED_SNIPPET_$1)\n+\n+  SCOPED_SNIPPET_FILES += $$($1_SCOPED_SNIPPET_FILE)\n@@ -154,15 +79,23 @@\n-# Setup a rule for generating the ScopedMemoryAccess java class\n-\n-SCOPE_MEMORY_ACCESS_TYPES := Boolean Byte Short Char Int Long Float Double\n-$(foreach t, $(SCOPE_MEMORY_ACCESS_TYPES), \\\n-  $(eval $(call GenerateScopedOp,BIN_$t,$t)))\n-\n-$(SCOPED_MEMORY_ACCESS_DEST): $(BUILD_TOOLS_JDK) $(SCOPED_MEMORY_ACCESS_TEMPLATE) $(SCOPED_MEMORY_ACCESS_BIN_TEMPLATE)\n-\t$(call MakeDir, $(SCOPED_MEMORY_ACCESS_GENSRC_DIR))\n-\t$(CAT) $(SCOPED_MEMORY_ACCESS_TEMPLATE) > $(SCOPED_MEMORY_ACCESS_DEST)\n-\t$(foreach t, $(SCOPE_MEMORY_ACCESS_TYPES), \\\n-\t  $(TOOL_SPP) -nel -K$(BIN_$t_type) -Dtype=$(BIN_$t_type) -DType=$(BIN_$t_Type) $(BIN_$t_ARGS) \\\n-\t  -i$(SCOPED_MEMORY_ACCESS_BIN_TEMPLATE) -o$(SCOPED_MEMORY_ACCESS_DEST) ;)\n-\t$(ECHO) \"}\" >> $(SCOPED_MEMORY_ACCESS_DEST)\n-\n-TARGETS += $(SCOPED_MEMORY_ACCESS_DEST)\n+# Setup generation of snippet files, one for each primitive type. This will\n+# populate SCOPED_SNIPPET_FILES.\n+\n+# SCOPED_TYPES is identical to PRIMITIVE_TYPES, but with a slightly different\n+# order. Keep the original SCOPED_TYPES order for now to not change the\n+# generated file.\n+SCOPED_TYPES := boolean byte short char int long float double\n+\n+SCOPED_SNIPPET_FILES :=\n+$(foreach t, $(SCOPED_TYPES), \\\n+  $(eval $(call SetupGenScopedSnippets,$t)) \\\n+)\n+\n+# Setup a rule for generating the ScopedMemoryAccess java class by incorporating\n+# those snippets\n+$(SCOPED_OUTPUT): $(SCOPED_INPUT) $(SCOPED_SNIPPET_FILES)\n+\t$(call LogInfo, Concatenating snippets for ScopedMemoryAccess.java)\n+\t$(CAT) $(SCOPED_INPUT) > $(SCOPED_OUTPUT).tmp\n+\t$(CAT) $(SCOPED_SNIPPET_FILES) >> $(SCOPED_OUTPUT).tmp\n+\t$(ECHO) \"}\" >> $(SCOPED_OUTPUT).tmp\n+\t$(MV) $(SCOPED_OUTPUT).tmp $(SCOPED_OUTPUT)\n+\n+TARGETS += $(SCOPED_OUTPUT)\n","filename":"make\/modules\/java.base\/gensrc\/GensrcScopedMemoryAccess.gmk","additions":58,"deletions":125,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -31,4 +31,2 @@\n-GENSRC_VARHANDLES :=\n-\n-VARHANDLES_GENSRC_DIR := $(SUPPORT_OUTPUTDIR)\/gensrc\/java.base\/java\/lang\/invoke\n-VARHANDLES_SRC_DIR := $(MODULE_SRC)\/share\/classes\/java\/lang\/invoke\n+VARHANDLES_INPUT_DIR := $(MODULE_SRC)\/share\/classes\/java\/lang\/invoke\n+VARHANDLES_OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/gensrc\/java.base\/java\/lang\/invoke\n@@ -38,2 +36,2 @@\n-# Param 1 - Variable declaration prefix\n-# Param 2 - Type with first letter capitalized\n+#\n+# arg $1: type for this varhandle\n@@ -41,31 +39,25 @@\n-\n-  $1_Type := $2\n-\n-  $1_FILENAME := $(VARHANDLES_GENSRC_DIR)\/VarHandle$$($1_Type)s.java\n-\n-  $1_ARGS += -KCAS\n-\n-  ifneq ($$(findstring $$($1_Type), Byte Short Char Int Long Float Double), )\n-    $1_ARGS += -KAtomicAdd\n-  endif\n-\n-  ifneq ($$(findstring $$($1_Type), Boolean Byte Short Char Int Long), )\n-    $1_ARGS += -KBitwise\n-  endif\n-\n-  ifneq ($$(findstring $$($1_Type), Byte Short Char), )\n-    $1_ARGS += -KShorterThanInt\n-  endif\n-\n-  $$($1_FILENAME): $(VARHANDLES_SRC_DIR)\/X-VarHandle.java.template $(BUILD_TOOLS_JDK)\n-        ifeq ($$($1_Type), Reference)\n-\t  $$(eval $1_type := Object)\n-        else\n-\t  $$(eval $1_type := $$$$(shell $(TR) '[:upper:]' '[:lower:]' <<< $$$$($1_Type)))\n-        endif\n-\t$$(call MakeDir, $$(@D))\n-\t$(RM) $$@\n-\t$(TOOL_SPP) -nel -K$$($1_type) -Dtype=$$($1_type) -DType=$$($1_Type) \\\n-\t    $$($1_ARGS) -i$$< -o$$@\n-\n-  GENSRC_VARHANDLES += $$($1_FILENAME)\n+  VARHANDLE_$1_type := $$(strip $$(if $$(filter reference, $1), Object, $1))\n+  VARHANDLE_$1_Type := $$(call Conv, $1, Type)\n+\n+  $1_KEYS := $$(VARHANDLE_$1_type) CAS\n+  ifneq ($$(filter byte short char, $1),)\n+    $1_KEYS += ShorterThanInt\n+  endif\n+  ifeq ($$(filter boolean reference, $1),)\n+    $1_KEYS += AtomicAdd\n+  endif\n+  ifeq ($$(filter float double reference, $1),)\n+    $1_KEYS += Bitwise\n+  endif\n+\n+  $$(eval $$(call SetupStreamPreProcessing, GEN_VARHANDLE_$1, \\\n+      SOURCE_FILE := $$(VARHANDLES_INPUT_DIR)\/X-VarHandle.java.template, \\\n+      OUTPUT_FILE := $$(VARHANDLES_OUTPUT_DIR)\/VarHandle$$(VARHANDLE_$1_Type)s.java, \\\n+      INFO := Generating VarHandle class for $1, \\\n+      SUBST_EMPTY_LINES := false, \\\n+      KEYS := $$($1_KEYS), \\\n+      REPLACEMENTS := \\\n+          type=$$(VARHANDLE_$1_type) \\\n+          Type=$$(VARHANDLE_$1_Type), \\\n+  ))\n+  TARGETS += $$(GEN_VARHANDLE_$1)\n@@ -74,2 +66,0 @@\n-################################################################################\n-\n@@ -78,2 +68,2 @@\n-# Param 1 - Variable declaration prefix\n-# Param 2 - Type with first letter capitalized\n+#\n+# arg $1: type for this varhandle\n@@ -81,82 +71,28 @@\n-\n-  $1_Type := $2\n-\n-  $1_FILENAME := $(VARHANDLES_GENSRC_DIR)\/VarHandleByteArrayAs$$($1_Type)s.java\n-\n-  ifeq ($$($1_Type), Short)\n-    $1_type := short\n-    $1_BoxType := $$($1_Type)\n-\n-    $1_rawType := $$($1_type)\n-    $1_RawType := $$($1_Type)\n-    $1_RawBoxType := $$($1_BoxType)\n-  endif\n-\n-  ifeq ($$($1_Type), Char)\n-    $1_type := char\n-    $1_BoxType := Character\n-\n-    $1_rawType := $$($1_type)\n-    $1_RawType := $$($1_Type)\n-    $1_RawBoxType := $$($1_BoxType)\n-  endif\n-\n-  ifeq ($$($1_Type), Int)\n-    $1_type := int\n-    $1_BoxType := Integer\n-\n-    $1_rawType := $$($1_type)\n-    $1_RawType := $$($1_Type)\n-    $1_RawBoxType := $$($1_BoxType)\n-\n-    $1_ARGS += -KCAS\n-    $1_ARGS += -KAtomicAdd\n-    $1_ARGS += -KBitwise\n-  endif\n-\n-  ifeq ($$($1_Type), Long)\n-    $1_type := long\n-    $1_BoxType := $$($1_Type)\n-\n-    $1_rawType := $$($1_type)\n-    $1_RawType := $$($1_Type)\n-    $1_RawBoxType := $$($1_BoxType)\n-\n-    $1_ARGS += -KCAS\n-    $1_ARGS += -KAtomicAdd\n-    $1_ARGS += -KBitwise\n-  endif\n-\n-  ifeq ($$($1_Type), Float)\n-    $1_type := float\n-    $1_BoxType := $$($1_Type)\n-\n-    $1_rawType := int\n-    $1_RawType := Int\n-    $1_RawBoxType := Integer\n-\n-    $1_ARGS += -KCAS\n-    $1_ARGS += -KfloatingPoint\n-  endif\n-\n-  ifeq ($$($1_Type), Double)\n-    $1_type := double\n-    $1_BoxType := $$($1_Type)\n-\n-    $1_rawType := long\n-    $1_RawType := Long\n-    $1_RawBoxType := Long\n-\n-    $1_ARGS += -KCAS\n-    $1_ARGS += -KfloatingPoint\n-  endif\n-\n-  $$($1_FILENAME): $(VARHANDLES_SRC_DIR)\/X-VarHandleByteArrayView.java.template $(BUILD_TOOLS_JDK)\n-\t$$(call MakeDir, $$(@D))\n-\t$(RM) $$@\n-\t$(TOOL_SPP) -nel -K$$($1_type) \\\n-\t    -Dtype=$$($1_type) -DType=$$($1_Type) -DBoxType=$$($1_BoxType) \\\n-\t    -DrawType=$$($1_rawType) -DRawType=$$($1_RawType) -DRawBoxType=$$($1_RawBoxType) \\\n-\t    $$($1_ARGS) -i$$< -o$$@\n-\n-  GENSRC_VARHANDLES += $$($1_FILENAME)\n+  VARHANDLE_BYTEARRAY_$1_Type := $$(call Conv, $1, Type)\n+\n+  $1_KEYS := $1\n+  ifneq ($$(filter int long float double, $1),)\n+    $1_KEYS += CAS\n+  endif\n+  ifneq ($$(filter float double, $1),)\n+    $1_KEYS += floatingPoint\n+  endif\n+  ifneq ($$(filter int long, $1),)\n+    $1_KEYS += AtomicAdd Bitwise\n+  endif\n+\n+  $$(eval $$(call SetupStreamPreProcessing, GEN_VARHANDLE_BYTEARRAY_$1, \\\n+      SOURCE_FILE := $$(VARHANDLES_INPUT_DIR)\/X-VarHandleByteArrayView.java.template, \\\n+      OUTPUT_FILE := $$(VARHANDLES_OUTPUT_DIR)\/VarHandleByteArrayAs$$(VARHANDLE_BYTEARRAY_$1_Type)s.java, \\\n+      INFO := Generating VarHandleByteArray class for $1, \\\n+      SUBST_EMPTY_LINES := false, \\\n+      KEYS := $$($1_KEYS), \\\n+      REPLACEMENTS := \\\n+          type=$1 \\\n+          Type=$$(VARHANDLE_BYTEARRAY_$1_Type) \\\n+          BoxType=$$(call Conv, $1, Fulltype) \\\n+          rawType=$$(call Conv, $1, memtype) \\\n+          RawType=$$(call Conv, $1, Memtype) \\\n+          RawBoxType=$$(call Conv, $1, FullMemtype), \\\n+  ))\n+  TARGETS += $$(GEN_VARHANDLE_BYTEARRAY_$1)\n@@ -166,5 +102,3 @@\n-\n-################################################################################\n-# Setup a rule for generating a memory segment var handle view class\n-# Param 1 - Variable declaration prefix\n-# Param 2 - Type with first letter capitalized\n+# Setup a rule for generating a VarHandleMemorySegment java class\n+#\n+# arg $1: type for this varhandle\n@@ -172,0 +106,1 @@\n+  VARHANDLE_SEGMENT_$1_Type := $$(call Conv, $1, Type)\n@@ -173,7 +108,0 @@\n-  $1_Type := $2\n-\n-  $1_FILENAME := $(VARHANDLES_GENSRC_DIR)\/VarHandleSegmentAs$$($1_Type)s.java\n-\n-  ifeq ($$($1_Type), Boolean)\n-    $1_type := boolean\n-    $1_BoxType := $$($1_Type)\n@@ -181,6 +109,3 @@\n-    $1_rawType := $$($1_type)\n-    $1_RawType := $$($1_Type)\n-    $1_RawBoxType := $$($1_BoxType)\n-\n-    $1_ARGS += -Kbyte\n-    $1_ARGS += -KShorterThanInt\n+  $1_KEYS := $1\n+  ifneq ($$(filter int long float double, $1),)\n+    $1_KEYS += CAS\n@@ -188,11 +113,2 @@\n-\n-  ifeq ($$($1_Type), Byte)\n-    $1_type := byte\n-    $1_BoxType := $$($1_Type)\n-\n-    $1_rawType := $$($1_type)\n-    $1_RawType := $$($1_Type)\n-    $1_RawBoxType := $$($1_BoxType)\n-\n-    $1_ARGS += -Kbyte\n-    $1_ARGS += -KShorterThanInt\n+  ifneq ($$(filter boolean byte, $1),)\n+    $1_KEYS += byte\n@@ -200,10 +116,2 @@\n-\n-  ifeq ($$($1_Type), Short)\n-    $1_type := short\n-    $1_BoxType := $$($1_Type)\n-\n-    $1_rawType := $$($1_type)\n-    $1_RawType := $$($1_Type)\n-    $1_RawBoxType := $$($1_BoxType)\n-\n-    $1_ARGS += -KShorterThanInt\n+  ifneq ($$(filter float double, $1),)\n+    $1_KEYS += floatingPoint\n@@ -211,36 +119,2 @@\n-\n-  ifeq ($$($1_Type), Char)\n-    $1_type := char\n-    $1_BoxType := Character\n-\n-    $1_rawType := $$($1_type)\n-    $1_RawType := $$($1_Type)\n-    $1_RawBoxType := $$($1_BoxType)\n-\n-    $1_ARGS += -KShorterThanInt\n-  endif\n-\n-  ifeq ($$($1_Type), Int)\n-    $1_type := int\n-    $1_BoxType := Integer\n-\n-    $1_rawType := $$($1_type)\n-    $1_RawType := $$($1_Type)\n-    $1_RawBoxType := $$($1_BoxType)\n-\n-    $1_ARGS += -KCAS\n-    $1_ARGS += -KAtomicAdd\n-    $1_ARGS += -KBitwise\n-  endif\n-\n-  ifeq ($$($1_Type), Long)\n-    $1_type := long\n-    $1_BoxType := $$($1_Type)\n-\n-    $1_rawType := $$($1_type)\n-    $1_RawType := $$($1_Type)\n-    $1_RawBoxType := $$($1_BoxType)\n-\n-    $1_ARGS += -KCAS\n-    $1_ARGS += -KAtomicAdd\n-    $1_ARGS += -KBitwise\n+  ifneq ($$(filter boolean byte short char, $1),)\n+    $1_KEYS += ShorterThanInt\n@@ -248,11 +122,2 @@\n-\n-  ifeq ($$($1_Type), Float)\n-    $1_type := float\n-    $1_BoxType := $$($1_Type)\n-\n-    $1_rawType := int\n-    $1_RawType := Int\n-    $1_RawBoxType := Integer\n-\n-    $1_ARGS += -KCAS\n-    $1_ARGS += -KfloatingPoint\n+  ifneq ($$(filter int long, $1),)\n+    $1_KEYS += AtomicAdd Bitwise\n@@ -261,21 +126,15 @@\n-  ifeq ($$($1_Type), Double)\n-    $1_type := double\n-    $1_BoxType := $$($1_Type)\n-\n-    $1_rawType := long\n-    $1_RawType := Long\n-    $1_RawBoxType := Long\n-\n-    $1_ARGS += -KCAS\n-    $1_ARGS += -KfloatingPoint\n-  endif\n-\n-  $$($1_FILENAME): $(VARHANDLES_SRC_DIR)\/X-VarHandleSegmentView.java.template $(BUILD_TOOLS_JDK)\n-\t$$(call MakeDir, $$(@D))\n-\t$(RM) $$@\n-\t$(TOOL_SPP) -nel -K$$($1_type) \\\n-\t    -Dtype=$$($1_type) -DType=$$($1_Type) -DBoxType=$$($1_BoxType) \\\n-\t    -DrawType=$$($1_rawType) -DRawType=$$($1_RawType) -DRawBoxType=$$($1_RawBoxType) \\\n-\t    $$($1_ARGS) -i$$< -o$$@\n-\n-  GENSRC_VARHANDLES += $$($1_FILENAME)\n+  $$(eval $$(call SetupStreamPreProcessing, GEN_VARHANDLE_SEGMENT_$1, \\\n+      SOURCE_FILE := $$(VARHANDLES_INPUT_DIR)\/X-VarHandleSegmentView.java.template, \\\n+      OUTPUT_FILE := $$(VARHANDLES_OUTPUT_DIR)\/VarHandleSegmentAs$$(VARHANDLE_SEGMENT_$1_Type)s.java, \\\n+      INFO := Generating VarHandleSegment class for $1, \\\n+      SUBST_EMPTY_LINES := false, \\\n+      KEYS := $$($1_KEYS), \\\n+      REPLACEMENTS := \\\n+          type=$1 \\\n+          Type=$$(VARHANDLE_SEGMENT_$1_Type) \\\n+          BoxType=$$(call Conv, $1, Fulltype) \\\n+          rawType=$$(call Conv, $1, memtype) \\\n+          RawType=$$(call Conv, $1, Memtype) \\\n+          RawBoxType=$$(call Conv, $1, FullMemtype), \\\n+  ))\n+  TARGETS += $$(GEN_VARHANDLE_SEGMENT_$1)\n@@ -285,0 +144,1 @@\n+# Generate all VarHandle related classes\n@@ -286,9 +146,3 @@\n-# List the types to generate source for, with capitalized first letter\n-VARHANDLES_TYPES := Boolean Byte Short Char Int Long Float Double Reference\n-$(foreach t, $(VARHANDLES_TYPES), \\\n-  $(eval $(call GenerateVarHandle,VAR_HANDLE_$t,$t)))\n-\n-# List the types to generate source for, with capitalized first letter\n-VARHANDLES_BYTE_ARRAY_TYPES := Short Char Int Long Float Double\n-$(foreach t, $(VARHANDLES_BYTE_ARRAY_TYPES), \\\n-  $(eval $(call GenerateVarHandleByteArray,VAR_HANDLE_BYTE_ARRAY_$t,$t)))\n+$(foreach t, $(PRIMITIVE_TYPES) reference, \\\n+  $(eval $(call GenerateVarHandle,$t)) \\\n+)\n@@ -296,4 +150,3 @@\n-# List the types to generate source for, with capitalized first letter\n-VARHANDLES_MEMORY_SEGMENT_TYPES := Boolean Byte Short Char Int Long Float Double\n-$(foreach t, $(VARHANDLES_MEMORY_SEGMENT_TYPES), \\\n-  $(eval $(call GenerateVarHandleMemorySegment,VAR_HANDLE_MEMORY_SEGMENT_$t,$t)))\n+$(foreach t, $(NON_BYTE_NUMBER_TYPES), \\\n+  $(eval $(call GenerateVarHandleByteArray,$t)) \\\n+)\n@@ -301,1 +154,3 @@\n-TARGETS += $(GENSRC_VARHANDLES)\n+$(foreach t, $(PRIMITIVE_TYPES), \\\n+  $(eval $(call GenerateVarHandleMemorySegment,$t)) \\\n+)\n","filename":"make\/modules\/java.base\/gensrc\/GensrcVarHandles.gmk","additions":99,"deletions":244,"binary":false,"changes":343,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n- * (but not always) has the initial value&nbsp;$defaultReplName$;\n+ * (but not always) has the initial value&nbsp;<code>{<\/code>&nbsp;<code>(byte)'?'<\/code>&nbsp;<code>}<\/code>;\n@@ -103,1 +103,1 @@\n- * has the initial value $defaultReplName$;\n+ * has the initial value <code>\"&#92;uFFFD\"<\/code>;\n@@ -215,1 +215,6 @@\n-     * $replTypeName$ $defaultReplName$.\n+#if[encoder]\n+     * byte array <code>{<\/code>&nbsp;<code>(byte)'?'<\/code>&nbsp;<code>}<\/code>.\n+#end[encoder]\n+#if[decoder]\n+     * string <code>\"&#92;uFFFD\"<\/code>.\n+#end[decoder]\n@@ -237,1 +242,6 @@\n-             $defaultRepl$);\n+#if[encoder]\n+             new byte[] { (byte)'?' });\n+#end[encoder]\n+#if[decoder]\n+             \"\\uFFFD\");\n+#end[decoder]\n","filename":"src\/java.base\/share\/classes\/java\/nio\/charset\/Charset-X-Coder.java.template","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -116,0 +116,57 @@\n+################################################################################\n+# Test string manipulation\n+\n+$(call AssertEquals, \\\n+    $(call uppercase, foo bar), \\\n+    FOO BAR, \\\n+    uppercase \"foo bar\" failed, \\\n+)\n+\n+$(call AssertEquals, \\\n+    $(call uppercase, Foo BaR 123), \\\n+    FOO BAR 123, \\\n+    uppercase \"Foo BaR 123\" failed, \\\n+)\n+\n+$(call AssertEquals, \\\n+    $(call lowercase, FOO BAR), \\\n+    foo bar, \\\n+    lowercase \"FOO BAR\" failed, \\\n+)\n+\n+$(call AssertEquals, \\\n+    $(call lowercase, Foo BaR 123), \\\n+    foo bar 123, \\\n+    lowercase \"Foo BaR 123\" failed, \\\n+)\n+\n+$(call AssertEquals, \\\n+    $(call titlecase, foo bar), \\\n+    Foo Bar, \\\n+    titlecase \"foo bar\" failed, \\\n+)\n+\n+$(call AssertEquals, \\\n+    $(call titlecase, FOO BAR), \\\n+    Foo Bar, \\\n+    titlecase \"FOO BAR\" failed, \\\n+)\n+\n+$(call AssertEquals, \\\n+    $(call titlecase, Foo BaR 123), \\\n+    Foo Bar 123, \\\n+    titlecase \"Foo BaR 123\" failed, \\\n+)\n+\n+$(call AssertEquals, \\\n+    $(call firstchar, foo bar), \\\n+    f, \\\n+    firstchar \"foo bar\" failed, \\\n+)\n+\n+$(call AssertEquals, \\\n+    $(call firstchar, Foo Bar), \\\n+    F, \\\n+    firstchar \"Foo Bar\" failed, \\\n+)\n+\n","filename":"test\/make\/TestMakeBase.gmk","additions":57,"deletions":0,"binary":false,"changes":57,"status":"modified"}]}