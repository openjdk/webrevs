{"files":[{"patch":"@@ -10904,0 +10904,10 @@\n+instruct convHF2SAndHF2F(regF dst, regF src)\n+%{\n+  match(Set dst (ConvHF2F (ReinterpretHF2S src)));\n+  format %{ \"convHF2SAndHF2F $dst, $src\" %}\n+  ins_encode %{\n+    __ vcvtph2ps($dst$$XMMRegister, $src$$XMMRegister, Assembler::AVX_128bit);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+    private static final Float16 ONE = valueOf(1.0f);\n+    private static final Float16 MONE = valueOf(-1.0f);\n@@ -84,0 +86,13 @@\n+    @Test\n+    @IR(counts = {\"convHF2SAndHF2F\", \" >0 \"}, phase = {CompilePhase.FINAL_CODE},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void testEliminateIntermediateHF2S() {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < count; i++) {\n+            \/\/ Intermediate HF2S + S2HF is eliminated in following transformation\n+            \/\/ AddHF S2HF(HF2S (AddHF S2HF(src[i]), S2HF(0))), S2HF(src[i]) => AddHF (AddHF S2HF(src[i]), S2HF(0)), S2HF(src[i])\n+            res = add(add(res, shortBitsToFloat16(src[i])), shortBitsToFloat16(src[i]));\n+            dst[i] = (short)res.floatValue();\n+        }\n+    }\n+\n@@ -140,0 +155,11 @@\n+    @Test\n+    @IR(counts = {IRNode.DIV_HF, \" 0 \", IRNode.REINTERPRET_S2HF, \" 0 \", IRNode.REINTERPRET_HF2S, \" 0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void testDivByOne() {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < count; i++) {\n+            res = Float16.divide(shortBitsToFloat16(src[i]), ONE);\n+            dst[i] = float16ToRawShortBits(res);\n+        }\n+    }\n+\n@@ -420,0 +446,18 @@\n+    @Test\n+    @IR(counts = {IRNode.SQRT_HF, \" 0 \", IRNode.REINTERPRET_S2HF, \" 0 \", IRNode.REINTERPRET_HF2S, \" 0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void testSqrtConstantFolding() {\n+        \/\/ If the argument is NaN or less than zero, then the result is NaN.\n+        assertResult(sqrt(Float16.NaN).floatValue(), Float.NaN, \"testSqrtConstantFolding\");\n+\n+        \/\/ If the argument is positive infinity, then the result is positive infinity.\n+        assertResult(sqrt(Float16.POSITIVE_INFINITY).floatValue(), Float.POSITIVE_INFINITY, \"testSqrtConstantFolding\");\n+\n+        \/\/ If the argument is positive zero or negative zero, then the result is the same as the argument.\n+        assertResult(sqrt(POSITIVE_ZERO).floatValue(), 0.0f, \"testSqrtConstantFolding\");\n+        assertResult(sqrt(NEGATIVE_ZERO).floatValue(), -0.0f, \"testSqrtConstantFolding\");\n+\n+        \/\/ Other cases.\n+        assertResult(Math.round(sqrt(valueOf(0x1.ffcP+14f)).floatValue()), Math.round(Math.sqrt(0x1.ffcP+14f)), \"testSqrtConstantFolding\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestFloat16ScalarOperations.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -111,2 +111,0 @@\n-        \"fphp\",\n-        \"asimdhp\",\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}