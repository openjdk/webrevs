{"files":[{"patch":"@@ -821,1 +821,1 @@\n-  \/\/ If divisor is a constant and not zero, divide them numbers\n+  \/\/ If divisor is a constant and not zero, divide the numbers\n@@ -826,1 +826,1 @@\n-    return TypeH::make(t1->getf()\/t2->getf());\n+    return TypeH::make(t1->getf() \/ t2->getf());\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1444,6 +1444,6 @@\n-const TypeH *TypeH::MAX;        \/\/ Half float max\n-const TypeH *TypeH::MIN;        \/\/ Half float min\n-const TypeH *TypeH::ZERO;       \/\/ Half float zero\n-const TypeH *TypeH::ONE;        \/\/ Half float one\n-const TypeH *TypeH::POS_INF;    \/\/ Half float positive infinity\n-const TypeH *TypeH::NEG_INF;    \/\/ Half float negative infinity\n+const TypeH* TypeH::MAX;        \/\/ Half float max\n+const TypeH* TypeH::MIN;        \/\/ Half float min\n+const TypeH* TypeH::ZERO;       \/\/ Half float zero\n+const TypeH* TypeH::ONE;        \/\/ Half float one\n+const TypeH* TypeH::POS_INF;    \/\/ Half float positive infinity\n+const TypeH* TypeH::NEG_INF;    \/\/ Half float negative infinity\n@@ -1453,1 +1453,1 @@\n-const TypeH *TypeH::make(short f) {\n+const TypeH* TypeH::make(short f) {\n@@ -1457,1 +1457,1 @@\n-const TypeH *TypeH::make(float f) {\n+const TypeH* TypeH::make(float f) {\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -544,2 +544,2 @@\n-  static const TypeH *make(float f);\n-  static const TypeH *make(short f);\n+  static const TypeH* make(float f);\n+  static const TypeH* make(short f);\n@@ -554,6 +554,6 @@\n-  static const TypeH *MAX;\n-  static const TypeH *MIN;\n-  static const TypeH *ZERO; \/\/ positive zero only\n-  static const TypeH *ONE;\n-  static const TypeH *POS_INF;\n-  static const TypeH *NEG_INF;\n+  static const TypeH* MAX;\n+  static const TypeH* MIN;\n+  static const TypeH* ZERO; \/\/ positive zero only\n+  static const TypeH* ONE;\n+  static const TypeH* POS_INF;\n+  static const TypeH* NEG_INF;\n@@ -2023,1 +2023,1 @@\n-inline const TypeH *Type::isa_half_float() const {\n+inline const TypeH* Type::isa_half_float() const {\n@@ -2029,1 +2029,1 @@\n-inline const TypeH *Type::is_half_float_constant() const {\n+inline const TypeH* Type::is_half_float_constant() const {\n@@ -2034,1 +2034,1 @@\n-inline const TypeH *Type::isa_half_float_constant() const {\n+inline const TypeH* Type::isa_half_float_constant() const {\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+    private static final Float16 SIGNALING_NAN = shortBitsToFloat16((short)31807);\n@@ -452,0 +453,1 @@\n+        assertResult(sqrt(SIGNALING_NAN).floatValue(), Float.NaN, \"testSqrtConstantFolding\");\n@@ -470,0 +472,1 @@\n+        assertResult(fma(SIGNALING_NAN, valueOf(2.0f), valueOf(3.0f)).floatValue(), Float.NaN, \"testFMAConstantFolding\");\n@@ -471,1 +474,4 @@\n-        assertResult(fma(valueOf(2.0f), valueOf(3.0f), Float16.NaN).floatValue(), Float.NaN, \"testFMAConstantFolding\");\n+\n+        assertResult(fma(shortBitsToFloat16(Float.floatToFloat16(2.0f)),\n+                         shortBitsToFloat16(Float.floatToFloat16(3.0f)),\n+                         Float16.NaN).floatValue(), Float.NaN, \"testFMAConstantFolding\");\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestFloat16ScalarOperations.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"}]}