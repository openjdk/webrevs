{"files":[{"patch":"@@ -945,2 +945,10 @@\n-  do_signature(float16_unary_math_op_sig, \"(SLjdk\/internal\/vm\/vector\/Float16Math$Float16UnaryMathOp;)S\")                 \\\n-  do_signature(float16_ternary_math_op_sig, \"(SSSLjdk\/internal\/vm\/vector\/Float16Math$Float16TernaryMathOp;)S\")           \\\n+  do_signature(float16_unary_math_op_sig, \"(Ljava\/lang\/Class;\"                                                           \\\n+                                           \"Ljava\/lang\/Object;\"                                                          \\\n+                                           \"Ljdk\/internal\/vm\/vector\/Float16Math$Float16UnaryMathOp;)\"                    \\\n+                                           \"Ljava\/lang\/Object;\")                                                         \\\n+  do_signature(float16_ternary_math_op_sig, \"(Ljava\/lang\/Class;\"                                                         \\\n+                                             \"Ljava\/lang\/Object;\"                                                        \\\n+                                             \"Ljava\/lang\/Object;\"                                                        \\\n+                                             \"Ljava\/lang\/Object;\"                                                        \\\n+                                             \"Ljdk\/internal\/vm\/vector\/Float16Math$Float16TernaryMathOp;)\"                \\\n+                                             \"Ljava\/lang\/Object;\")                                                       \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -4608,0 +4608,1 @@\n+              op == Op_ReinterpretS2HF ||\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"ci\/ciSymbols.hpp\"\n@@ -8620,0 +8621,42 @@\n+Node* LibraryCallKit::unbox_fp16_value(const TypeInstPtr* float16_box_type, ciField* field, Node* box) {\n+  const TypeInstPtr* box_type = _gvn.type(box)->isa_instptr();\n+  if (box_type == nullptr || box_type->instance_klass() != float16_box_type->instance_klass()) {\n+    return nullptr; \/\/ box klass is not Float16\n+  }\n+\n+  \/\/ Null check; get notnull casted pointer\n+  Node* null_ctl = top();\n+  Node* not_null_box = null_check_oop(box, &null_ctl, true);\n+  \/\/ If not_null_box is dead, only null-path is taken\n+  if (stopped()) {\n+    set_control(null_ctl);\n+    return nullptr;\n+  }\n+  assert(not_null_box->bottom_type()->is_instptr()->maybe_null() == false, \"\");\n+  const TypePtr* adr_type = C->alias_type(field)->adr_type();\n+  Node* adr = basic_plus_adr(not_null_box, field->offset_in_bytes());\n+  return access_load_at(not_null_box, adr, adr_type, TypeInt::SHORT, T_SHORT, IN_HEAP);\n+}\n+\n+Node* LibraryCallKit::box_fp16_value(const TypeInstPtr* float16_box_type, ciField* field, Node* value) {\n+  PreserveReexecuteState preexecs(this);\n+  jvms()->set_should_reexecute(true);\n+\n+  const TypeKlassPtr* klass_type = float16_box_type->as_klass_type();\n+  Node* klass_node = makecon(klass_type);\n+  Node* box = new_instance(klass_node);\n+\n+  Node* value_field = basic_plus_adr(box, field->offset_in_bytes());\n+  const TypePtr* value_adr_type = value_field->bottom_type()->is_ptr();\n+\n+  Node* field_store = _gvn.transform(access_store_at(box,\n+                                                     value_field,\n+                                                     value_adr_type,\n+                                                     value,\n+                                                     TypeInt::SHORT,\n+                                                     T_SHORT,\n+                                                     IN_HEAP));\n+  set_memory(field_store, value_adr_type);\n+  return box;\n+}\n+\n@@ -8626,0 +8669,12 @@\n+  const TypeInstPtr* box_type = _gvn.type(argument(0))->isa_instptr();\n+  if (box_type == nullptr || box_type->const_oop() == nullptr) {\n+    return false;\n+  }\n+\n+  ciInstanceKlass* float16_klass = box_type->const_oop()->as_instance()->java_lang_Class_klass()->as_instance_klass();\n+  const TypeInstPtr* float16_box_type = TypeInstPtr::make_exact(TypePtr::NotNull, float16_klass);\n+  ciField* field = float16_klass->get_field_by_name(ciSymbols::value_name(),\n+                                                    ciSymbols::short_signature(),\n+                                                    false);\n+  assert(field != nullptr, \"\");\n+\n@@ -8632,5 +8687,5 @@\n-      assert((argument(2)->is_ConI() &&\n-              argument(2)->get_int() >= min_jshort &&\n-              argument(2)->get_int() <= max_jshort) ||\n-             (argument(2)->bottom_type()->array_element_basic_type() == T_SHORT), \"\");\n-      fld3 = _gvn.transform(new ReinterpretS2HFNode(argument(2)));\n+      fld3 = unbox_fp16_value(float16_box_type, field, argument(3));\n+      if (fld3 == nullptr) {\n+        return false;\n+      }\n+      fld3 = _gvn.transform(new ReinterpretS2HFNode(fld3));\n@@ -8639,5 +8694,5 @@\n-      assert((argument(1)->is_ConI() &&\n-              argument(1)->get_int() >= min_jshort &&\n-              argument(1)->get_int() <= max_jshort) ||\n-             (argument(1)->bottom_type()->array_element_basic_type() == T_SHORT), \"\");\n-      fld2 = _gvn.transform(new ReinterpretS2HFNode(argument(1)));\n+      fld2 = unbox_fp16_value(float16_box_type, field, argument(2));\n+      if (fld2 == nullptr) {\n+        return false;\n+      }\n+      fld2 = _gvn.transform(new ReinterpretS2HFNode(fld2));\n@@ -8646,5 +8701,5 @@\n-      assert((argument(0)->is_ConI() &&\n-              argument(0)->get_int() >= min_jshort &&\n-              argument(0)->get_int() <= max_jshort) ||\n-             (argument(0)->bottom_type()->array_element_basic_type() == T_SHORT), \"\");\n-      fld1 = _gvn.transform(new ReinterpretS2HFNode(argument(0)));\n+      fld1 = unbox_fp16_value(float16_box_type, field, argument(1));\n+      if (fld1 == nullptr) {\n+        return false;\n+      }\n+      fld1 = _gvn.transform(new ReinterpretS2HFNode(fld1));\n@@ -8669,1 +8724,2 @@\n-  set_result(_gvn.transform(new ReinterpretHF2SNode(result)));\n+  result = _gvn.transform(new ReinterpretHF2SNode(result));\n+  set_result(box_fp16_value(float16_box_type, field, result));\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":72,"deletions":16,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -295,0 +295,2 @@\n+  Node* unbox_fp16_value(const TypeInstPtr* box_class, ciField* field, Node* box);\n+  Node* box_fp16_value(const TypeInstPtr* box_class, ciField* field, Node* value);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import jdk.internal.vm.annotation.ForceInline;\n-\n-import static java.lang.Float.*;\n@@ -35,1 +32,1 @@\n- * @since   24\n+ * @since   25\n@@ -42,1 +39,1 @@\n-        short apply(short a);\n+        Object apply(Object a);\n@@ -46,1 +43,1 @@\n-        short apply(short a, short b, short c);\n+        Object apply(Object a, Object b, Object c);\n@@ -50,1 +47,1 @@\n-    public static short sqrt(short a, Float16UnaryMathOp defaultImpl) {\n+    public static Object sqrt(Class<?> box_class, Object oa, Float16UnaryMathOp defaultImpl) {\n@@ -52,1 +49,1 @@\n-        return defaultImpl.apply(a);\n+        return defaultImpl.apply(oa);\n@@ -56,1 +53,1 @@\n-    public static short fma(short a, short b, short c, Float16TernaryMathOp defaultImpl) {\n+    public static Object fma(Class<?> box_class, Object oa, Object ob, Object oc, Float16TernaryMathOp defaultImpl) {\n@@ -58,1 +55,1 @@\n-        return defaultImpl.apply(a, b, c);\n+        return defaultImpl.apply(oa, ob, oc);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/Float16Math.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1202,6 +1202,2 @@\n-        \/\/ Explicitly unbox float16 radicand as intrinsic expects\n-        \/\/ to receive short type arguments holding IEEE 754 binary16\n-        \/\/ value.\n-        short unboxed_radicand = float16ToRawShortBits(radicand);\n-        short retval = Float16Math.sqrt(unboxed_radicand,\n-            (f16) -> {\n+        return (Float16) Float16Math.sqrt(Float16.class, radicand,\n+            (_radicand) -> {\n@@ -1213,2 +1209,1 @@\n-               double res = Math.sqrt(float16ToFloat(f16));\n-               return float16ToRawShortBits(valueOf(res));\n+               return valueOf(Math.sqrt(((Float16)(_radicand)).doubleValue()));\n@@ -1217,1 +1212,0 @@\n-        return shortBitsToFloat16(retval);\n@@ -1419,9 +1413,2 @@\n-        \/\/ Explicitly unbox float16 values as intrinsic expects\n-        \/\/ to receive short type arguments holding IEEE 754 binary16\n-        \/\/ values.\n-        short unboxed_a = float16ToRawShortBits(a);\n-        short unboxed_b = float16ToRawShortBits(b);\n-        short unboxed_c = float16ToRawShortBits(c);\n-\n-        short res = Float16Math.fma(unboxed_a, unboxed_b, unboxed_c,\n-                (f16a, f16b, f16c) -> {\n+         return (Float16) Float16Math.fma(Float16.class, a, b, c,\n+                (_a, _b, _c) -> {\n@@ -1431,2 +1418,2 @@\n-                    double product = (double)(float16ToFloat(f16a) * float16ToFloat(f16b));\n-                    return float16ToRawShortBits(valueOf(product + float16ToFloat(f16c)));\n+                    double product = (double)(((Float16)_a).floatValue() * ((Float16)_b).floatValue());\n+                    return valueOf(product + ((Float16)_c).doubleValue());\n@@ -1434,1 +1421,0 @@\n-        return shortBitsToFloat16(res);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float16.java","additions":7,"deletions":21,"binary":false,"changes":28,"status":"modified"}]}