{"files":[{"patch":"@@ -3478,0 +3478,16 @@\n+void Assembler::vmovw(XMMRegister dst, Register src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP5, &attributes, true);\n+  emit_int16(0x6E, (0xC0 | encode));\n+}\n+\n+void Assembler::vmovw(Register dst, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP5, &attributes, true);\n+  emit_int16(0x7E, (0xC0 | encode));\n+}\n+\n@@ -8445,0 +8461,64 @@\n+void Assembler::vaddsh(XMMRegister dst, XMMRegister nds, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x58, (0xC0 | encode));\n+}\n+\n+void Assembler::vsubsh(XMMRegister dst, XMMRegister nds, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5C, (0xC0 | encode));\n+}\n+\n+void Assembler::vdivsh(XMMRegister dst, XMMRegister nds, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5E, (0xC0 | encode));\n+}\n+\n+void Assembler::vmulsh(XMMRegister dst, XMMRegister nds, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x59, (0xC0 | encode));\n+}\n+\n+void Assembler::vmaxsh(XMMRegister dst, XMMRegister nds, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5F, (0xC0 | encode));\n+}\n+\n+void Assembler::vminsh(XMMRegister dst, XMMRegister nds, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5D, (0xC0 | encode));\n+}\n+\n+void Assembler::vsqrtsh(XMMRegister dst, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x51, (0xC0 | encode));\n+}\n+\n+void Assembler::vfmadd132sh(XMMRegister dst, XMMRegister src1, XMMRegister src2) {\n+  assert(VM_Version::supports_avx512_fp16(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP6, &attributes);\n+  emit_int16((unsigned char)0x99, (0xC0 | encode));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -588,0 +588,2 @@\n+    VEX_OPCODE_MAP5  = 0x5,\n+    VEX_OPCODE_MAP6  = 0x6,\n@@ -1818,0 +1820,3 @@\n+  void vmovw(XMMRegister dst, Register src);\n+  void vmovw(Register dst, XMMRegister src);\n+\n@@ -2694,0 +2699,10 @@\n+  \/\/ FP16 instructions\n+  void vaddsh(XMMRegister dst, XMMRegister nds, XMMRegister src);\n+  void vsubsh(XMMRegister dst, XMMRegister nds, XMMRegister src);\n+  void vmulsh(XMMRegister dst, XMMRegister nds, XMMRegister src);\n+  void vdivsh(XMMRegister dst, XMMRegister nds, XMMRegister src);\n+  void vmaxsh(XMMRegister dst, XMMRegister nds, XMMRegister src);\n+  void vminsh(XMMRegister dst, XMMRegister nds, XMMRegister src);\n+  void vsqrtsh(XMMRegister dst, XMMRegister src);\n+  void vfmadd132sh(XMMRegister dst, XMMRegister src1, XMMRegister src2);\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -6678,0 +6678,12 @@\n+void C2_MacroAssembler::efp16sh(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2) {\n+  switch(opcode) {\n+    case Op_AddHF: vaddsh(dst, src1, src2); break;\n+    case Op_SubHF: vsubsh(dst, src1, src2); break;\n+    case Op_MulHF: vmulsh(dst, src1, src2); break;\n+    case Op_DivHF: vdivsh(dst, src1, src2); break;\n+    case Op_MaxHF: vmaxsh(dst, src1, src2); break;\n+    case Op_MinHF: vminsh(dst, src1, src2); break;\n+    default: assert(false, \"%s\", NodeClassNames[opcode]); break;\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -508,0 +508,1 @@\n+  void efp16sh(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1030,0 +1030,1 @@\n+    _features &= ~CPU_AVX512_FP16;\n@@ -1080,0 +1081,1 @@\n+      _features &= ~CPU_AVX512_FP16;\n@@ -3112,0 +3114,3 @@\n+\n+    if (_cpuid_info.sef_cpuid7_edx.bits.avx512_fp16 != 0)\n+      result |= CPU_AVX512_FP16;\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -279,1 +279,3 @@\n-                           : 11;\n+                           : 2,\n+              avx512_fp16  : 1,\n+                           : 8;\n@@ -419,2 +421,3 @@\n-    decl(APX_F,             \"apx_f\",             60) \/* Intel Advanced Performance Extensions*\/\\\n-    decl(SHA512,            \"sha512\",            61) \/* SHA512 instructions*\/\n+    decl(APX_F,             \"apx_f\",             60) \/* Intel Advanced Performance Extensions*\/ \\\n+    decl(SHA512,            \"sha512\",            61) \/* SHA512 instructions*\/ \\\n+    decl(AVX512_FP16,       \"avx512_fp16\",       62) \/* AVX512 FP16 ISA support*\/\n@@ -756,0 +759,1 @@\n+  static bool supports_avx512_fp16()  { return (_features & CPU_AVX512_FP16) != 0; }\n@@ -843,1 +847,1 @@\n-    return supports_f16c() || supports_avx512vl();\n+    return supports_f16c() || supports_avx512vl() || supports_avx512_fp16();\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1464,0 +1464,14 @@\n+    case Op_AddHF:\n+    case Op_DivHF:\n+    case Op_FmaHF:\n+    case Op_MaxHF:\n+    case Op_MinHF:\n+    case Op_MulHF:\n+    case Op_ReinterpretS2HF:\n+    case Op_ReinterpretHF2S:\n+    case Op_SubHF:\n+    case Op_SqrtHF:\n+      if (!VM_Version::supports_avx512_fp16()) {\n+        return false;\n+      }\n+      break;\n@@ -4524,0 +4538,29 @@\n+#ifdef _LP64\n+instruct ReplHF_imm(vec dst, immH con, rRegI rtmp) %{\n+  match(Set dst (Replicate con));\n+  effect(TEMP rtmp);\n+  format %{ \"replicateHF $dst, $con \\t! using $rtmp as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    assert(VM_Version::supports_avx512_fp16() && bt == T_SHORT, \"\");\n+    __ movl($rtmp$$Register, $con$$constant);\n+    __ evpbroadcastw($dst$$XMMRegister, $rtmp$$Register, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct ReplHF_reg(vec dst, regF src, rRegI rtmp) %{\n+  predicate(VM_Version::supports_avx512_fp16() && Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst (Replicate src));\n+  effect(TEMP rtmp);\n+  format %{ \"replicateHF $dst, $src \\t! using $rtmp as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vmovw($rtmp$$Register, $src$$XMMRegister);\n+    __ evpbroadcastw($dst$$XMMRegister, $rtmp$$Register, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+#endif\n+\n@@ -10840,0 +10883,77 @@\n+\n+instruct reinterpretS2HF(regF dst, rRegI src)\n+%{\n+  match(Set dst (ReinterpretS2HF src));\n+  format %{ \"vmovw $dst, $src\" %}\n+  ins_encode %{\n+    __ vmovw($dst$$XMMRegister, $src$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct convF2HFAndS2HF(regF dst, regF src)\n+%{\n+  match(Set dst (ReinterpretS2HF (ConvF2HF src)));\n+  format %{ \"convF2HFAndS2HF $dst, $src\" %}\n+  ins_encode %{\n+    __ vcvtps2ph($dst$$XMMRegister, $src$$XMMRegister, 0x04, Assembler::AVX_128bit);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct convHF2SAndHF2F(regF dst, regF src)\n+%{\n+  match(Set dst (ConvHF2F (ReinterpretHF2S src)));\n+  format %{ \"convHF2SAndHF2F $dst, $src\" %}\n+  ins_encode %{\n+    __ vcvtph2ps($dst$$XMMRegister, $src$$XMMRegister, Assembler::AVX_128bit);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reinterpretHF2S(rRegI dst, regF src)\n+%{\n+  match(Set dst (ReinterpretHF2S src));\n+  format %{ \"vmovw $dst, $src\" %}\n+  ins_encode %{\n+    __ vmovw($dst$$Register, $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct scalar_sqrt_HF_reg(regF dst, regF src)\n+%{\n+  match(Set dst (SqrtHF src));\n+  format %{ \"scalar_sqrt_fp16 $dst, $src\" %}\n+  ins_encode %{\n+    __ vsqrtsh($dst$$XMMRegister, $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct scalar_binOps_HF_reg(regF dst, regF src1, regF src2)\n+%{\n+  match(Set dst (AddHF src1 src2));\n+  match(Set dst (DivHF src1 src2));\n+  match(Set dst (MaxHF src1 src2));\n+  match(Set dst (MinHF src1 src2));\n+  match(Set dst (MulHF src1 src2));\n+  match(Set dst (SubHF src1 src2));\n+  format %{ \"scalar_binop_fp16 $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    __ efp16sh(opcode, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct scalar_fma_HF_reg(regF dst, regF src1, regF src2)\n+%{\n+  match(Set dst (FmaHF  src2 (Binary dst src1)));\n+  effect(DEF dst);\n+  format %{ \"scalar_fma_fp16 $dst, $src1, $src2\\t# $dst = $dst * $src1 + $src2 fma packedH\" %}\n+  ins_encode %{\n+    __ vfmadd132sh($dst$$XMMRegister, $src2$$XMMRegister, $src1$$XMMRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":121,"deletions":1,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -2385,0 +2385,10 @@\n+\/\/ Half Float Immediate\n+operand immH()\n+%{\n+  match(ConH);\n+\n+  op_cost(15);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -4843,0 +4853,10 @@\n+instruct loadConH(regF dst, immH con) %{\n+  match(Set dst con);\n+  ins_cost(125);\n+  format %{ \"movss   $dst, [$constantaddress]\\t# load from constant table: halffloat=$con\" %}\n+  ins_encode %{\n+    __ movflt($dst$$XMMRegister, $constantaddress($con));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -7025,0 +7045,11 @@\n+instruct castHH(regF dst)\n+%{\n+  match(Set dst (CastHH dst));\n+\n+  size(0);\n+  format %{ \"# castHH of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1056,0 +1056,1 @@\n+  case 'H':    return \"Type::HALF_FLOAT\";\n@@ -1093,1 +1094,1 @@\n-        !strcmp(ident, \"ConF\") || !strcmp(ident, \"ConD\") ||\n+        !strcmp(ident, \"ConH\") || !strcmp(ident, \"ConF\") || !strcmp(ident, \"ConD\") ||\n","filename":"src\/hotspot\/share\/adlc\/archDesc.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -223,0 +223,1 @@\n+  if (strcmp(name,\"ConH\")==0) return Form::idealH;\n","filename":"src\/hotspot\/share\/adlc\/forms.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -186,1 +186,2 @@\n-    idealV      = 11   \/\/ Vector  type\n+    idealV      = 11,  \/\/ Vector  type\n+    idealH      = 12   \/\/ HalfFloat  type\n","filename":"src\/hotspot\/share\/adlc\/forms.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1091,1 +1091,1 @@\n-      if ( (type == Form::idealF) || (type == Form::idealD) ) {\n+      if ( (type == Form::idealH) || (type == Form::idealF) || (type == Form::idealD) ) {\n@@ -1102,1 +1102,1 @@\n-  if( data_type==idealD || data_type==idealF ) {\n+  if( data_type==idealH || data_type==idealD || data_type==idealF ) {\n@@ -2665,0 +2665,1 @@\n+  case Form::idealH: fprintf(fp,\"  st->print(\\\"#%%d\\\", _c%d);\\n\", const_index); break;\n@@ -2746,0 +2747,1 @@\n+  case idealH: fprintf(fp,\"_c%d\",           const_index); break;\n@@ -3956,1 +3958,1 @@\n-    \"AddI\",\"AddL\",\"AddF\",\"AddD\",\n+    \"AddI\",\"AddL\",\"AddHF\",\"AddF\",\"AddD\",\n@@ -3958,3 +3960,4 @@\n-    \"MaxI\",\"MinI\",\"MaxF\",\"MinF\",\"MaxD\",\"MinD\",\n-    \"MulI\",\"MulL\",\"MulF\",\"MulD\",\n-    \"OrI\",\"OrL\", \"XorI\",\"XorL\",\n+    \"MaxI\",\"MinI\",\"MaxHF\",\"MinHF\",\"MaxF\",\"MinF\",\"MaxD\",\"MinD\",\n+    \"MulI\",\"MulL\",\"MulHF\",\"MulF\",\"MulD\",\n+    \"OrI\",\"OrL\",\n+    \"XorI\",\"XorL\"\n@@ -4196,0 +4199,1 @@\n+        strcmp(opType,\"DivHF\")==0 ||\n@@ -4203,0 +4207,1 @@\n+        strcmp(opType,\"SqrtHF\")==0 ||\n@@ -4222,0 +4227,1 @@\n+        strcmp(opType,\"FmaHF\") == 0 ||\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -2424,0 +2424,2 @@\n+        } else if ( _constant_type == Form::idealH ) {\n+          fprintf(_fp,\"->constantH()\");\n@@ -3792,0 +3794,2 @@\n+    } else if ( (strcmp(optype,\"ConH\") == 0) ) {\n+      fprintf(fp, \"_leaf->geth()\");\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -236,0 +236,4 @@\n+    else if (!strcmp(type, \"ConH\")) {\n+      if (i > 0) fprintf(fp,\", \");\n+      fprintf(fp,\"  jshort        _c%d;\\n\", i);\n+    }\n@@ -272,0 +276,4 @@\n+      else if (!strcmp(comp->base_type(globals), \"ConH\")) {\n+        fprintf(fp,\"  jshort            _c%d;\\n\", i);\n+        i++;\n+      }\n@@ -317,0 +325,1 @@\n+    case Form::idealH :      { fprintf(fp,\"jshort c%d\", i);   break;        }\n@@ -406,0 +415,5 @@\n+  else if (!strcmp(ideal_type, \"ConH\")) {\n+    fprintf(fp,\"   st->print(\\\"#%%d\\\", _c%d);\\n\", i);\n+    fprintf(fp,\"   st->print(\\\"\/0x%%08x\\\", _c%d);\\n\", i);\n+    ++i;\n+  }\n@@ -1284,0 +1298,1 @@\n+        case Form::idealH: type = \"Type::HALF_FLOAT\"; break;\n@@ -1428,0 +1443,8 @@\n+        else if (!strcmp(oper->ideal_type(_globalNames), \"ConH\")) {\n+          fprintf(fp,\"  virtual intptr_t       constant() const {\");\n+          fprintf(fp,   \" ShouldNotReachHere(); return 0; \");\n+          fprintf(fp, \" }\\n\");\n+          fprintf(fp,\"  virtual jshort         constantH() const {\");\n+          fprintf(fp,   \" return (jshort)_c0;\");\n+          fprintf(fp, \" }\\n\");\n+        }\n@@ -1900,0 +1923,3 @@\n+      case Form::idealH:\n+        fprintf(fp,\"    return  TypeH::make(opnd_array(1)->constantH());\\n\");\n+        break;\n","filename":"src\/hotspot\/share\/adlc\/output_h.cpp","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -929,1 +929,1 @@\n-   do_alias(    getAndSetInt_signature,                                 \/*\"(Ljava\/lang\/Object;JI)I\"*\/ getAndAddInt_signature)   \\\n+   do_alias(    getAndSetInt_signature,                                 \/*\"(Ljava\/lang\/Object;JI)I\"*\/ getAndAddInt_signature) \\\n@@ -932,1 +932,1 @@\n-   do_alias(    getAndSetLong_signature,                                \/*\"(Ljava\/lang\/Object;JJ)J\"*\/ getAndAddLong_signature)  \\\n+   do_alias(    getAndSetLong_signature,                                \/*\"(Ljava\/lang\/Object;JJ)J\"*\/ getAndAddLong_signature)\\\n@@ -935,1 +935,1 @@\n-   do_alias(    getAndSetByte_signature,                                \/*\"(Ljava\/lang\/Object;JB)B\"*\/ getAndAddByte_signature)  \\\n+   do_alias(    getAndSetByte_signature,                                \/*\"(Ljava\/lang\/Object;JB)B\"*\/ getAndAddByte_signature)\\\n@@ -937,4 +937,4 @@\n-   do_name(     getAndSetShort_name,                                    \"getAndSetShort\")                                     \\\n-   do_alias(    getAndSetShort_signature,                               \/*\"(Ljava\/lang\/Object;JS)S\"*\/ getAndAddShort_signature) \\\n-  do_intrinsic(_getAndSetReference,       jdk_internal_misc_Unsafe,     getAndSetReference_name, getAndSetReference_signature, F_R) \\\n-   do_name(     getAndSetReference_name,                                \"getAndSetReference\")                                  \\\n+   do_name(     getAndSetShort_name,                                    \"getAndSetShort\")                                             \\\n+   do_alias(    getAndSetShort_signature,                               \/*\"(Ljava\/lang\/Object;JS)S\"*\/ getAndAddShort_signature)       \\\n+  do_intrinsic(_getAndSetReference,       jdk_internal_misc_Unsafe,     getAndSetReference_name, getAndSetReference_signature, F_R)   \\\n+   do_name(     getAndSetReference_name,                                \"getAndSetReference\")                                         \\\n@@ -942,0 +942,15 @@\n+                                                                                                                             \\\n+  \/* Float16Math API intrinsification support *\/                                                                             \\\n+  \/* Float16 signatures *\/                                                                                                   \\\n+  do_signature(float16_unary_math_op_sig, \"(Ljava\/lang\/Class;\"                                                               \\\n+                                           \"Ljava\/lang\/Object;\"                                                              \\\n+                                           \"Ljava\/util\/function\/UnaryOperator;)\"                                             \\\n+                                           \"Ljava\/lang\/Object;\")                                                             \\\n+  do_signature(float16_ternary_math_op_sig, \"(Ljava\/lang\/Class;\"                                                             \\\n+                                             \"Ljava\/lang\/Object;\"                                                            \\\n+                                             \"Ljava\/lang\/Object;\"                                                            \\\n+                                             \"Ljava\/lang\/Object;\"                                                            \\\n+                                             \"Ljdk\/internal\/vm\/vector\/Float16Math$TernaryOperator;)\"                         \\\n+                                             \"Ljava\/lang\/Object;\")                                                           \\\n+  do_intrinsic(_sqrt_float16, jdk_internal_vm_vector_Float16Math, sqrt_name, float16_unary_math_op_sig, F_S)                 \\\n+  do_intrinsic(_fma_float16, jdk_internal_vm_vector_Float16Math, fma_name, float16_ternary_math_op_sig, F_S)                 \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":22,"deletions":7,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -94,1 +94,2 @@\n-  template(jdk_internal_vm_vector_VectorSupport,      \"jdk\/internal\/vm\/vector\/VectorSupport\")               \\\n+  template(jdk_internal_vm_vector_VectorSupport,      \"jdk\/internal\/vm\/vector\/VectorSupport\")     \\\n+  template(jdk_internal_vm_vector_Float16Math,        \"jdk\/internal\/vm\/vector\/Float16Math\")       \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/stubRoutines.hpp\"\n@@ -558,0 +559,16 @@\n+\/\/=============================================================================\n+\/\/------------------------------add_of_identity--------------------------------\n+\/\/ Check for addition of the identity\n+const Type* AddHFNode::add_of_identity(const Type* t1, const Type* t2) const {\n+  return nullptr;\n+}\n+\n+\/\/ Supplied function returns the sum of the inputs.\n+\/\/ This also type-checks the inputs for sanity.  Guaranteed never to\n+\/\/ be passed a TOP or BOTTOM type, these are filtered out by pre-check.\n+const Type* AddHFNode::add_ring(const Type* t0, const Type* t1) const {\n+  if (!t0->isa_half_float_constant() || !t1->isa_half_float_constant()) {\n+    return bottom_type();\n+  }\n+  return TypeH::make(t0->getf() + t1->getf());\n+}\n@@ -1507,0 +1524,27 @@\n+\/\/------------------------------add_ring---------------------------------------\n+const Type* MinHFNode::add_ring(const Type* t0, const Type* t1) const {\n+  const TypeH* r0 = t0->isa_half_float_constant();\n+  const TypeH* r1 = t1->isa_half_float_constant();\n+  if (r0 == nullptr || r1 == nullptr) {\n+    return bottom_type();\n+  }\n+\n+  if (r0->is_nan()) {\n+    return r0;\n+  }\n+  if (r1->is_nan()) {\n+    return r1;\n+  }\n+\n+  float f0 = r0->getf();\n+  float f1 = r1->getf();\n+  if (f0 != 0.0f || f1 != 0.0f) {\n+    return f0 < f1 ? r0 : r1;\n+  }\n+\n+  \/\/ As per IEEE 754 specification, floating point comparison consider +ve and -ve\n+  \/\/ zeros as equals. Thus, performing signed integral comparison for min value\n+  \/\/ detection.\n+  return (jint_cast(f0) < jint_cast(f1)) ? r0 : r1;\n+}\n+\n@@ -1557,0 +1601,28 @@\n+\/\/------------------------------add_ring---------------------------------------\n+const Type* MaxHFNode::add_ring(const Type* t0, const Type* t1) const {\n+  const TypeH* r0 = t0->isa_half_float_constant();\n+  const TypeH* r1 = t1->isa_half_float_constant();\n+  if (r0 == nullptr || r1 == nullptr) {\n+    return bottom_type();\n+  }\n+\n+  if (r0->is_nan()) {\n+    return r0;\n+  }\n+  if (r1->is_nan()) {\n+    return r1;\n+  }\n+\n+  float f0 = r0->getf();\n+  float f1 = r1->getf();\n+  if (f0 != 0.0f || f1 != 0.0f) {\n+    return f0 > f1 ? r0 : r1;\n+  }\n+\n+  \/\/ As per IEEE 754 specification, floating point comparison consider +ve and -ve\n+  \/\/ zeros as equals. Thus, performing signed integral comparison for max value\n+  \/\/ detection.\n+  return (jint_cast(f0) > jint_cast(f1)) ? r0 : r1;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,0 +158,16 @@\n+\/\/------------------------------AddHFNode---------------------------------------\n+\/\/ Add 2 half-precision floats\n+class AddHFNode : public AddNode {\n+public:\n+  AddHFNode(Node* in1, Node* in2) : AddNode(in1,in2) {}\n+  virtual int Opcode() const;\n+  virtual const Type* add_of_identity(const Type* t1, const Type* t2) const;\n+  virtual const Type* add_ring(const Type*, const Type*) const;\n+  virtual const Type* add_id() const { return TypeH::ZERO; }\n+  virtual const Type* bottom_type() const { return Type::HALF_FLOAT; }\n+  int max_opcode() const { return Op_MaxHF; }\n+  int min_opcode() const { return Op_MinHF; }\n+  virtual Node* Identity(PhaseGVN* phase) { return this; }\n+  virtual uint ideal_reg() const { return Op_RegF; }\n+};\n+\n@@ -405,0 +421,28 @@\n+\/\/------------------------------MaxHFNode--------------------------------------\n+\/\/ Maximum of 2 half floats.\n+class MaxHFNode : public MaxNode {\n+public:\n+  MaxHFNode(Node* in1, Node* in2) : MaxNode(in1, in2) {}\n+  virtual int Opcode() const;\n+  virtual const Type* add_ring(const Type*, const Type*) const;\n+  virtual const Type* add_id() const { return TypeH::NEG_INF; }\n+  virtual const Type* bottom_type() const { return Type::HALF_FLOAT; }\n+  virtual uint ideal_reg() const { return Op_RegF; }\n+  int max_opcode() const { return Op_MaxHF; }\n+  int min_opcode() const { return Op_MinHF; }\n+};\n+\n+\/\/------------------------------MinHFNode---------------------------------------\n+\/\/ Minimum of 2 half floats.\n+class MinHFNode : public MaxNode {\n+public:\n+  MinHFNode(Node* in1, Node* in2) : MaxNode(in1, in2) {}\n+  virtual int Opcode() const;\n+  virtual const Type* add_ring(const Type*, const Type*) const;\n+  virtual const Type* add_id() const { return TypeH::POS_INF; }\n+  virtual const Type* bottom_type() const { return Type::HALF_FLOAT; }\n+  virtual uint ideal_reg() const { return Op_RegF; }\n+  int max_opcode() const { return Op_MaxHF; }\n+  int min_opcode() const { return Op_MinHF; }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":45,"deletions":1,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -355,0 +355,6 @@\n+  case vmIntrinsics::_sqrt_float16:\n+    if (!Matcher::match_rule_supported(Op_SqrtHF)) return false;\n+    break;\n+  case vmIntrinsics::_fma_float16:\n+    if (!Matcher::match_rule_supported(Op_FmaHF)) return false;\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -478,0 +478,2 @@\n+  } else if (type->isa_half_float()) {\n+    return new CastHHNode(c, in, type, dependency, types);\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -146,0 +146,11 @@\n+class CastHHNode: public ConstraintCastNode {\n+public:\n+  CastHHNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+          : ConstraintCastNode(ctrl, n, t, dependency, types) {\n+    assert(ctrl != nullptr, \"control must be set\");\n+    init_class_id(Class_CastHH);\n+  }\n+  virtual int Opcode() const;\n+  virtual uint ideal_reg() const { return in(1)->ideal_reg(); }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+macro(AddHF)\n@@ -67,0 +68,1 @@\n+macro(CastHH)\n@@ -135,0 +137,1 @@\n+macro(ConH)\n@@ -169,0 +172,1 @@\n+macro(DivHF)\n@@ -187,0 +191,1 @@\n+macro(FmaHF)\n@@ -225,0 +230,1 @@\n+macro(MaxHF)\n@@ -240,0 +246,1 @@\n+macro(MinHF)\n@@ -256,0 +263,1 @@\n+macro(MulHF)\n@@ -341,0 +349,1 @@\n+macro(SqrtHF)\n@@ -360,0 +369,1 @@\n+macro(SubHF)\n@@ -488,0 +498,2 @@\n+macro(ReinterpretS2HF)\n+macro(ReinterpretHF2S)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -46,0 +46,3 @@\n+  if (t->isa_half_float_constant()) {\n+    return new ConHNode( t->is_half_float_constant() );\n+  }\n","filename":"src\/hotspot\/share\/opto\/connode.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,0 +118,13 @@\n+\/\/------------------------------ConHNode---------------------------------------\n+\/\/ Simple half float constants\n+class ConHNode : public ConNode {\n+public:\n+  ConHNode(const TypeH* t) : ConNode(t) {}\n+  virtual int Opcode() const;\n+\n+  \/\/ Factory method:\n+  static ConHNode* make(float con) {\n+    return new ConHNode(TypeH::make(con));\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/connode.hpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+  case T_SHORT:   return (_v._value.i == other._v._value.i);\n@@ -105,0 +106,1 @@\n+  case T_SHORT:   return sizeof(jint   );\n@@ -170,0 +172,1 @@\n+      case T_SHORT:  constant_addr = masm->int_constant(   con.get_jint()   ); break;\n@@ -284,0 +287,1 @@\n+  case T_SHORT:   value.i = oper->constantH(); break;\n","filename":"src\/hotspot\/share\/opto\/constantTable.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"opto\/divnode.hpp\"\n@@ -31,0 +32,1 @@\n+#include \"opto\/mulnode.hpp\"\n@@ -251,0 +253,31 @@\n+\/\/------------------------------Ideal------------------------------------------\n+Node* ConvF2HFNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  \/\/ Float16 instance encapsulates a short field holding IEEE 754\n+  \/\/ binary16 value. On unboxing, this short field is loaded into a\n+  \/\/ GPR register while FP operation operates over floating point\n+  \/\/ registers. ConvHF2F converts incoming short value to a FP32 value\n+  \/\/ to perform operation at FP32 granularity. However, if target\n+  \/\/ support FP16 ISA we can save this redundant up casting and\n+  \/\/ optimize the graph pallet using following transformation.\n+  \/\/\n+  \/\/ ConvF2HF(FP32BinOp(ConvHF2F(x), ConvHF2F(y))) =>\n+  \/\/        ReinterpretHF2S(FP16BinOp(ReinterpretS2HF(x), ReinterpretS2HF(y)))\n+  \/\/\n+  \/\/ Please note we need to inject appropriate reinterpretation\n+  \/\/ IR to move the values b\/w GPR and floating point register\n+  \/\/ before and after FP16 operation.\n+\n+  if (Float16NodeFactory::is_float32_binary_oper(in(1)->Opcode()) &&\n+      in(1)->in(1)->Opcode() == Op_ConvHF2F &&\n+      in(1)->in(2)->Opcode() == Op_ConvHF2F) {\n+    if (Matcher::match_rule_supported(Float16NodeFactory::get_float16_binary_oper(in(1)->Opcode())) &&\n+        Matcher::match_rule_supported(Op_ReinterpretS2HF) &&\n+        Matcher::match_rule_supported(Op_ReinterpretHF2S)) {\n+      Node* in1 = phase->transform(new ReinterpretS2HFNode(in(1)->in(1)->in(1)));\n+      Node* in2 = phase->transform(new ReinterpretS2HFNode(in(1)->in(2)->in(1)));\n+      Node* binop = phase->transform(Float16NodeFactory::make(in(1)->Opcode(), in(1)->in(0), in1, in2));\n+      return new ReinterpretHF2SNode(binop);\n+    }\n+  }\n+  return nullptr;\n+}\n@@ -899,0 +932,72 @@\n+\n+const Type* ReinterpretS2HFNode::Value(PhaseGVN* phase) const {\n+  const Type* type = phase->type(in(1));\n+  \/\/ Convert short constant value to a Half Float constant value\n+  if ((type->isa_int() && type->is_int()->is_con())) {\n+     jshort hfval = type->is_int()->get_con();\n+     return TypeH::make(hfval);\n+  }\n+  return Type::HALF_FLOAT;\n+}\n+\n+Node* ReinterpretS2HFNode::Identity(PhaseGVN* phase) {\n+  if (in(1)->Opcode() == Op_ReinterpretHF2S) {\n+     assert(in(1)->in(1)->bottom_type()->isa_half_float(), \"\");\n+     return in(1)->in(1);\n+  }\n+  return this;\n+}\n+\n+const Type* ReinterpretHF2SNode::Value(PhaseGVN* phase) const {\n+  const Type* type = phase->type(in(1));\n+  \/\/ Convert Half float constant value to short constant value.\n+  if (type->isa_half_float_constant()) {\n+     jshort hfval = type->is_half_float_constant()->_f;\n+     return TypeInt::make(hfval);\n+  }\n+  return TypeInt::SHORT;\n+}\n+\n+bool Float16NodeFactory::is_float32_binary_oper(int opc) {\n+  switch(opc) {\n+    case Op_AddF:\n+    case Op_SubF:\n+    case Op_MulF:\n+    case Op_DivF:\n+    case Op_MaxF:\n+    case Op_MinF:\n+      return true;\n+    default:\n+      return false;\n+  }\n+}\n+\n+int Float16NodeFactory::get_float16_binary_oper(int opc) {\n+  switch(opc) {\n+    case Op_AddF:\n+      return Op_AddHF;\n+    case Op_SubF:\n+      return Op_SubHF;\n+    case Op_MulF:\n+      return Op_MulHF;\n+    case Op_DivF:\n+      return Op_DivHF;\n+    case Op_MaxF:\n+      return Op_MaxHF;\n+    case Op_MinF:\n+      return Op_MinHF;\n+    default: ShouldNotReachHere();\n+  }\n+}\n+\n+Node* Float16NodeFactory::make(int opc, Node* c, Node* in1, Node* in2) {\n+  switch(opc) {\n+    case Op_AddF: return new AddHFNode(in1, in2);\n+    case Op_SubF: return new SubHFNode(in1, in2);\n+    case Op_MulF: return new MulHFNode(in1, in2);\n+    case Op_DivF: return new DivHFNode(c, in1, in2);\n+    case Op_MaxF: return new MaxHFNode(in1, in2);\n+    case Op_MinF: return new MinHFNode(in1, in2);\n+    default: ShouldNotReachHere();\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":105,"deletions":0,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,0 +115,1 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -216,0 +217,24 @@\n+\n+\/\/-----------------------------ReinterpretS2HFNode ---------------------------\n+\/\/ Reinterpret Short to Half Float\n+class ReinterpretS2HFNode : public Node {\n+  public:\n+  ReinterpretS2HFNode(Node* in1) : Node(nullptr, in1) {}\n+  virtual int Opcode() const;\n+  virtual const Type* bottom_type() const { return Type::HALF_FLOAT; }\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual Node* Identity(PhaseGVN* phase);\n+  virtual uint  ideal_reg() const { return Op_RegF; }\n+};\n+\n+\/\/-----------------------------ReinterpretS2HFNode ---------------------------\n+\/\/ Reinterpret Half Float to Short\n+class ReinterpretHF2SNode : public Node {\n+  public:\n+  ReinterpretHF2SNode(Node* in1) : Node(nullptr, in1) {}\n+  virtual int Opcode() const;\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual const Type* bottom_type() const { return TypeInt::SHORT; }\n+  virtual uint  ideal_reg() const { return Op_RegI; }\n+};\n+\n@@ -272,0 +297,6 @@\n+class Float16NodeFactory {\n+  public:\n+  static bool is_float32_binary_oper(int opc);\n+  static int get_float16_binary_oper(int opc);\n+  static Node* make(int opc, Node* c, Node* in1, Node* in2);\n+};\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -808,0 +808,109 @@\n+\/\/=============================================================================\n+\/\/------------------------------Value------------------------------------------\n+\/\/ An DivHFNode divides its inputs.  The third input is a Control input, used to\n+\/\/ prevent hoisting the divide above an unsafe test.\n+const Type* DivHFNode::Value(PhaseGVN* phase) const {\n+  \/\/ Either input is TOP ==> the result is TOP\n+  const Type* t1 = phase->type(in(1));\n+  const Type* t2 = phase->type(in(2));\n+  if(t1 == Type::TOP) { return Type::TOP; }\n+  if(t2 == Type::TOP) { return Type::TOP; }\n+\n+  \/\/ Either input is BOTTOM ==> the result is the local BOTTOM\n+  const Type* bot = bottom_type();\n+  if((t1 == bot) || (t2 == bot) ||\n+     (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM)) {\n+    return bot;\n+  }\n+\n+  \/\/ x\/x == 1, we ignore 0\/0.\n+  \/\/ Note: if t1 and t2 are zero then result is NaN (JVMS page 213)\n+  \/\/ Does not work for variables because of NaN's\n+  if (in(1) == in(2) && t1->base() == Type::HalfFloatCon &&\n+      !g_isnan(t1->getf()) && g_isfinite(t1->getf()) && t1->getf() != 0.0) { \/\/ could be negative ZERO or NaN\n+    return TypeH::ONE;\n+  }\n+\n+  if (t2 == TypeH::ONE) {\n+    return t1;\n+  }\n+\n+  \/\/ If divisor is a constant and not zero, divide the numbers\n+  if (t1->base() == Type::HalfFloatCon &&\n+      t2->base() == Type::HalfFloatCon &&\n+      t2->getf() != 0.0)  {\n+    \/\/ could be negative zero\n+    return TypeH::make(t1->getf() \/ t2->getf());\n+  }\n+\n+  \/\/ If the dividend is a constant zero\n+  \/\/ Note: if t1 and t2 are zero then result is NaN (JVMS page 213)\n+  \/\/ Test TypeHF::ZERO is not sufficient as it could be negative zero\n+\n+  if (t1 == TypeH::ZERO && !g_isnan(t2->getf()) && t2->getf() != 0.0) {\n+    return TypeH::ZERO;\n+  }\n+\n+  \/\/ If divisor or dividend is nan then result is nan.\n+  if (g_isnan(t1->getf()) || g_isnan(t2->getf())) {\n+    return TypeH::make(NAN);\n+  }\n+\n+  \/\/ Otherwise we give up all hope\n+  return Type::HALF_FLOAT;\n+}\n+\n+\/\/-----------------------------------------------------------------------------\n+\/\/ Dividing by self is 1.\n+\/\/ IF the divisor is 1, we are an identity on the dividend.\n+Node* DivHFNode::Identity(PhaseGVN* phase) {\n+  return (phase->type( in(2) ) == TypeH::ONE) ? in(1) : this;\n+}\n+\n+\n+\/\/------------------------------Idealize---------------------------------------\n+Node* DivHFNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (in(0) != nullptr && remove_dead_region(phase, can_reshape))  return this;\n+  \/\/ Don't bother trying to transform a dead node\n+  if (in(0) != nullptr && in(0)->is_top())  { return nullptr; }\n+\n+  const Type* t2 = phase->type(in(2));\n+  if (t2 == TypeH::ONE) {      \/\/ Identity?\n+    return nullptr;            \/\/ Skip it\n+  }\n+  const TypeH* tf = t2->isa_half_float_constant();\n+  if(tf == nullptr) { return nullptr; }\n+  if(tf->base() != Type::HalfFloatCon) { return nullptr; }\n+\n+  \/\/ Check for out of range values\n+  if(tf->is_nan() || !tf->is_finite()) { return nullptr; }\n+\n+  \/\/ Get the value\n+  float f = tf->getf();\n+  int exp;\n+\n+  \/\/ Consider the following geometric progression series of POT(power of two) numbers.\n+  \/\/ 0.5 x 2^0 = 0.5, 0.5 x 2^1 = 1.0, 0.5 x 2^2 = 2.0, 0.5 x 2^3 = 4.0 ... 0.5 x 2^n,\n+  \/\/ In all the above cases, normalized mantissa returned by frexp routine will\n+  \/\/ be exactly equal to 0.5 while exponent will be 0,1,2,3...n\n+  \/\/ Perform division to multiplication transform only if divisor is a POT value.\n+  if(frexp((double)f, &exp) != 0.5) { return nullptr; }\n+\n+  \/\/ Limit the range of acceptable exponents\n+  if(exp < -14 || exp > 15) { return nullptr; }\n+\n+  \/\/ Since divisor is a POT number, hence its reciprocal will never\n+  \/\/ overflow 11 bits precision range of Float16\n+  \/\/ value if exponent returned by frexp routine strictly lie\n+  \/\/ within the exponent range of normal min(0x1.0P-14) and\n+  \/\/ normal max(0x1.ffcP+15) values.\n+  \/\/ Thus we can safely compute the reciprocal of divisor without\n+  \/\/ any concerns about the precision loss and transform the division\n+  \/\/ into a multiplication operation.\n+  float reciprocal = ((float)1.0) \/ f;\n+\n+  assert(frexp((double)reciprocal, &exp) == 0.5, \"reciprocal should be power of 2\");\n+\n+  \/\/ return multiplication by the reciprocal\n+  return (new MulHFNode(in(1), phase->makecon(TypeH::make(reciprocal))));\n+}\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":109,"deletions":0,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -81,0 +81,14 @@\n+\n+\/\/------------------------------DivHFNode--------------------------------------\n+\/\/ Half float division\n+class DivHFNode : public Node {\n+public:\n+  DivHFNode(Node* c, Node* dividend, Node* divisor) : Node(c, dividend, divisor) {}\n+  virtual int Opcode() const;\n+  virtual Node* Identity(PhaseGVN* phase);\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual const Type* bottom_type() const { return Type::HALF_FLOAT; }\n+  virtual uint ideal_reg() const { return Op_RegF; }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/divnode.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -4607,0 +4607,1 @@\n+              op == Op_ReinterpretS2HF ||\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"ci\/ciSymbols.hpp\"\n@@ -545,1 +546,2 @@\n-\n+  case vmIntrinsics::_sqrt_float16:             return inline_fp16_operations(intrinsic_id(), 1);\n+  case vmIntrinsics::_fma_float16:              return inline_fp16_operations(intrinsic_id(), 3);\n@@ -8624,0 +8626,109 @@\n+\n+Node* LibraryCallKit::unbox_fp16_value(const TypeInstPtr* float16_box_type, ciField* field, Node* box) {\n+  const TypeInstPtr* box_type = _gvn.type(box)->isa_instptr();\n+  if (box_type == nullptr || box_type->instance_klass() != float16_box_type->instance_klass()) {\n+    return nullptr; \/\/ box klass is not Float16\n+  }\n+\n+  \/\/ Null check; get notnull casted pointer\n+  Node* null_ctl = top();\n+  Node* not_null_box = null_check_oop(box, &null_ctl, true);\n+  \/\/ If not_null_box is dead, only null-path is taken\n+  if (stopped()) {\n+    set_control(null_ctl);\n+    return nullptr;\n+  }\n+  assert(not_null_box->bottom_type()->is_instptr()->maybe_null() == false, \"\");\n+  const TypePtr* adr_type = C->alias_type(field)->adr_type();\n+  Node* adr = basic_plus_adr(not_null_box, field->offset_in_bytes());\n+  return access_load_at(not_null_box, adr, adr_type, TypeInt::SHORT, T_SHORT, IN_HEAP);\n+}\n+\n+Node* LibraryCallKit::box_fp16_value(const TypeInstPtr* float16_box_type, ciField* field, Node* value) {\n+  PreserveReexecuteState preexecs(this);\n+  jvms()->set_should_reexecute(true);\n+\n+  const TypeKlassPtr* klass_type = float16_box_type->as_klass_type();\n+  Node* klass_node = makecon(klass_type);\n+  Node* box = new_instance(klass_node);\n+\n+  Node* value_field = basic_plus_adr(box, field->offset_in_bytes());\n+  const TypePtr* value_adr_type = value_field->bottom_type()->is_ptr();\n+\n+  Node* field_store = _gvn.transform(access_store_at(box,\n+                                                     value_field,\n+                                                     value_adr_type,\n+                                                     value,\n+                                                     TypeInt::SHORT,\n+                                                     T_SHORT,\n+                                                     IN_HEAP));\n+  set_memory(field_store, value_adr_type);\n+  return box;\n+}\n+\n+bool LibraryCallKit::inline_fp16_operations(vmIntrinsics::ID id, int num_args) {\n+  if (!Matcher::match_rule_supported(Op_ReinterpretS2HF) ||\n+      !Matcher::match_rule_supported(Op_ReinterpretHF2S)) {\n+    return false;\n+  }\n+\n+  const TypeInstPtr* box_type = _gvn.type(argument(0))->isa_instptr();\n+  if (box_type == nullptr || box_type->const_oop() == nullptr) {\n+    return false;\n+  }\n+\n+  ciInstanceKlass* float16_klass = box_type->const_oop()->as_instance()->java_lang_Class_klass()->as_instance_klass();\n+  const TypeInstPtr* float16_box_type = TypeInstPtr::make_exact(TypePtr::NotNull, float16_klass);\n+  ciField* field = float16_klass->get_field_by_name(ciSymbols::value_name(),\n+                                                    ciSymbols::short_signature(),\n+                                                    false);\n+  assert(field != nullptr, \"\");\n+\n+  \/\/ Transformed nodes\n+  Node* fld1 = nullptr;\n+  Node* fld2 = nullptr;\n+  Node* fld3 = nullptr;\n+  switch(num_args) {\n+    case 3:\n+      fld3 = unbox_fp16_value(float16_box_type, field, argument(3));\n+      if (fld3 == nullptr) {\n+        return false;\n+      }\n+      fld3 = _gvn.transform(new ReinterpretS2HFNode(fld3));\n+    \/\/ fall-through\n+    case 2:\n+      fld2 = unbox_fp16_value(float16_box_type, field, argument(2));\n+      if (fld2 == nullptr) {\n+        return false;\n+      }\n+      fld2 = _gvn.transform(new ReinterpretS2HFNode(fld2));\n+    \/\/ fall-through\n+    case 1:\n+      fld1 = unbox_fp16_value(float16_box_type, field, argument(1));\n+      if (fld1 == nullptr) {\n+        return false;\n+      }\n+      fld1 = _gvn.transform(new ReinterpretS2HFNode(fld1));\n+      break;\n+    default: fatal(\"Unsupported number of arguments %d\", num_args);\n+  }\n+\n+  Node* result = nullptr;\n+  switch (id) {\n+    \/\/ Unary operations\n+    case vmIntrinsics::_sqrt_float16:\n+      result = _gvn.transform(new SqrtHFNode(C, control(), fld1));\n+      break;\n+    \/\/ Ternary operations\n+    case vmIntrinsics::_fma_float16:\n+      result = _gvn.transform(new FmaHFNode(fld1, fld2, fld3));\n+      break;\n+    default:\n+      fatal_unexpected_iid(id);\n+      break;\n+  }\n+  result = _gvn.transform(new ReinterpretHF2SNode(result));\n+  set_result(box_fp16_value(float16_box_type, field, result));\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":112,"deletions":1,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -294,0 +294,3 @@\n+  bool inline_fp16_operations(vmIntrinsics::ID id, int num_args);\n+  Node* unbox_fp16_value(const TypeInstPtr* box_class, ciField* field, Node* box);\n+  Node* box_fp16_value(const TypeInstPtr* box_class, ciField* field, Node* value);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+jshort  MachOper::constantH() const { ShouldNotReachHere(); }\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -159,0 +159,1 @@\n+  virtual jshort  constantH() const;\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2307,0 +2307,1 @@\n+    case Op_FmaHF:\n@@ -2479,0 +2480,1 @@\n+    case Op_FmaHF:\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,1 +69,2 @@\n-                  (op == Op_MulF) || (op == Op_MulD);\n+                  (op == Op_MulF) || (op == Op_MulD) ||\n+                  (op == Op_MulHF);\n@@ -124,1 +125,2 @@\n-      op != Op_MulD ) {\n+      op != Op_MulD &&\n+      op != Op_MulHF) {\n@@ -538,0 +540,8 @@\n+  return MulNode::Ideal(phase, can_reshape);\n+}\n+\n+\/\/=============================================================================\n+\/\/------------------------------Ideal------------------------------------------\n+\/\/ Check to see if we are multiplying by a constant 2 and convert to add, then try the regular MulNode::Ideal\n+Node* MulHFNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  const TypeH* t2 = phase->type(in(2))->isa_half_float_constant();\n@@ -539,0 +549,5 @@\n+  \/\/ x * 2 -> x + x\n+  if (t2 != nullptr && t2->getf() == 2) {\n+    Node* base = in(1);\n+    return new AddHFNode(base, base);\n+  }\n@@ -542,0 +557,8 @@\n+\/\/ Compute the product type of two half float ranges into this node.\n+const Type* MulHFNode::mul_ring(const Type* t0, const Type* t1) const {\n+  if (t0 == Type::HALF_FLOAT || t1 == Type::HALF_FLOAT) {\n+    return Type::HALF_FLOAT;\n+  }\n+  return TypeH::make(t0->getf() * t1->getf());\n+}\n+\n@@ -1903,0 +1926,22 @@\n+\/\/=============================================================================\n+\/\/------------------------------Value------------------------------------------\n+const Type* FmaHFNode::Value(PhaseGVN* phase) const {\n+  const Type* t1 = phase->type(in(1));\n+  if (t1 == Type::TOP) { return Type::TOP; }\n+  if (t1->base() != Type::HalfFloatCon) { return Type::HALF_FLOAT; }\n+  const Type* t2 = phase->type(in(2));\n+  if (t2 == Type::TOP) { return Type::TOP; }\n+  if (t2->base() != Type::HalfFloatCon) { return Type::HALF_FLOAT; }\n+  const Type* t3 = phase->type(in(3));\n+  if (t3 == Type::TOP) { return Type::TOP; }\n+  if (t3->base() != Type::HalfFloatCon) { return Type::HALF_FLOAT; }\n+#ifndef __STDC_IEC_559__\n+  return Type::HALF_FLOAT;\n+#else\n+  float f1 = t1->getf();\n+  float f2 = t2->getf();\n+  float f3 = t3->getf();\n+  return TypeH::make(fma(f1, f2, f3));\n+#endif\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":47,"deletions":2,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -146,0 +146,18 @@\n+\/\/------------------------------MulHFNode---------------------------------------\n+\/\/ Multiply 2 half floats\n+class MulHFNode : public MulNode {\n+public:\n+  MulHFNode(Node* in1, Node* in2) : MulNode(in1, in2) {}\n+  virtual int Opcode() const;\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual const Type* mul_ring(const Type*, const Type*) const;\n+  const Type* mul_id() const { return TypeH::ONE; }\n+  const Type* add_id() const { return TypeH::ZERO; }\n+  int add_opcode() const { return Op_AddHF; }\n+  int mul_opcode() const { return Op_MulHF; }\n+  int max_opcode() const { return Op_MaxHF; }\n+  int min_opcode() const { return Op_MinHF; }\n+  const Type* bottom_type() const { return Type::HALF_FLOAT; }\n+  virtual uint ideal_reg() const { return Op_RegF; }\n+};\n+\n@@ -419,0 +437,11 @@\n+\/\/------------------------------FmaHFNode-------------------------------------\n+\/\/ fused-multiply-add half-precision float\n+class FmaHFNode : public FmaNode {\n+public:\n+  FmaHFNode(Node* in1, Node* in2, Node* in3) : FmaNode(in1, in2, in3) {}\n+  virtual int Opcode() const;\n+  const Type* bottom_type() const { return Type::HALF_FLOAT; }\n+  virtual uint ideal_reg() const { return Op_RegF; }\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1598,0 +1598,7 @@\n+\/\/ Get a half float constant from a ConstNode.\n+\/\/ Returns the constant if it is a float ConstNode\n+jshort Node::geth() const {\n+  assert( Opcode() == Op_ConH, \"\" );\n+  return ((ConHNode*)this)->type()->is_half_float_constant()->geth();\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,0 +61,1 @@\n+class CastHHNode;\n@@ -727,0 +728,1 @@\n+        DEFINE_CLASS_ID(CastHH, ConstraintCast, 7)\n@@ -911,0 +913,1 @@\n+  DEFINE_CLASS_QUERY(CastFF)\n@@ -1259,0 +1262,1 @@\n+  jshort geth() const;\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -555,0 +555,18 @@\n+\/\/------------------------------sub--------------------------------------------\n+\/\/ A subtract node differences its two inputs.\n+const Type* SubHFNode::sub(const Type* t1, const Type* t2) const {\n+  \/\/ no folding if one of operands is infinity or NaN, do not do constant folding\n+  if(g_isfinite(t1->getf()) && g_isfinite(t2->getf())) {\n+    return TypeH::make(t1->getf() - t2->getf());\n+  }\n+  else if(g_isnan(t1->getf())) {\n+    return t1;\n+  }\n+  else if(g_isnan(t2->getf())) {\n+    return t2;\n+  }\n+  else {\n+    return Type::HALF_FLOAT;\n+  }\n+}\n+\n@@ -1992,0 +2010,9 @@\n+const Type* SqrtHFNode::Value(PhaseGVN* phase) const {\n+  const Type* t1 = phase->type(in(1));\n+  if (t1 == Type::TOP) { return Type::TOP; }\n+  if (t1->base() != Type::HalfFloatCon) { return Type::HALF_FLOAT; }\n+  float f = t1->getf();\n+  if (f < 0.0f) return Type::HALF_FLOAT;\n+  return TypeH::make((float)sqrt((double)f));\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -133,0 +133,12 @@\n+\/\/------------------------------SubHFNode--------------------------------------\n+\/\/ Subtract 2 half floats\n+class SubHFNode : public SubFPNode {\n+public:\n+  SubHFNode(Node* in1, Node* in2) : SubFPNode(in1, in2) {}\n+  virtual int Opcode() const;\n+  virtual const Type* sub(const Type*, const Type*) const;\n+  const Type* add_id() const { return TypeH::ZERO; }\n+  const Type* bottom_type() const { return Type::HALF_FLOAT; }\n+  virtual uint  ideal_reg() const { return Op_RegF; }\n+};\n+\n@@ -531,0 +543,14 @@\n+\/\/------------------------------SqrtHFNode-------------------------------------\n+\/\/ square root of a half-precision float\n+class SqrtHFNode : public Node {\n+public:\n+  SqrtHFNode(Compile* C, Node* c, Node* in1) : Node(c, in1) {\n+    init_flags(Flag_is_expensive);\n+    C->add_expensive_node(this);\n+  }\n+  virtual int Opcode() const;\n+  const Type* bottom_type() const { return Type::HALF_FLOAT; }\n+  virtual uint ideal_reg() const { return Op_RegF; }\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2610,1 +2610,1 @@\n-    if (n->Opcode() == Op_ConvF2HF) {\n+    if (n->Opcode() == Op_ConvF2HF || n->Opcode() == Op_ReinterpretHF2S) {\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -47,0 +48,1 @@\n+#include \"runtime\/stubRoutines.hpp\"\n@@ -107,0 +109,3 @@\n+  { HalfFloatBot,    T_SHORT,      \"halffloat_top\", false, Op_RegF,              relocInfo::none          },  \/\/ HalfFloatTop\n+  { HalfFloatCon,    T_SHORT,      \"hfcon:\",        false, Op_RegF,              relocInfo::none          },  \/\/ HalfFloatCon\n+  { HalfFloatTop,    T_SHORT,      \"short\",         false, Op_RegF,              relocInfo::none          },  \/\/ HalfFloatBot\n@@ -136,0 +141,1 @@\n+const Type *Type::HALF_FLOAT;   \/\/ All half floats\n@@ -456,0 +462,1 @@\n+  HALF_FLOAT = make(HalfFloatBot); \/\/ All half floats\n@@ -467,0 +474,7 @@\n+  TypeH::MAX = TypeH::make(max_jfloat16); \/\/ HalfFloat MAX\n+  TypeH::MIN = TypeH::make(min_jfloat16); \/\/ HalfFloat MIN\n+  TypeH::ZERO = TypeH::make((jshort)0); \/\/ HalfFloat 0 (positive zero)\n+  TypeH::ONE  = TypeH::make(one_jfloat16); \/\/ HalfFloat 1\n+  TypeH::POS_INF = TypeH::make(pos_inf_jfloat16);\n+  TypeH::NEG_INF = TypeH::make(neg_inf_jfloat16);\n+\n@@ -1042,0 +1056,1 @@\n+  case HalfFloatCon:\n@@ -1077,0 +1092,9 @@\n+  case HalfFloatTop:\n+    if (_base == HalfFloatTop) { return this; }\n+  case HalfFloatBot:            \/\/ Half Float\n+    if (_base == HalfFloatBot || _base == HalfFloatTop) { return HALF_FLOAT; }\n+    if (_base == FloatBot || _base == FloatTop) { return Type::BOTTOM; }\n+    if (_base == DoubleTop || _base == DoubleBot) { return Type::BOTTOM; }\n+    typerr(t);\n+    return Type::BOTTOM;\n+\n@@ -1078,1 +1102,1 @@\n-    if( _base == FloatTop ) return this;\n+    if (_base == FloatTop ) { return this; }\n@@ -1080,2 +1104,3 @@\n-    if( _base == FloatBot || _base == FloatTop ) return FLOAT;\n-    if( _base == DoubleTop || _base == DoubleBot ) return Type::BOTTOM;\n+    if (_base == FloatBot || _base == FloatTop) { return FLOAT; }\n+    if (_base == HalfFloatTop || _base == HalfFloatBot) { return Type::BOTTOM; }\n+    if (_base == DoubleTop || _base == DoubleBot) { return Type::BOTTOM; }\n@@ -1086,1 +1111,1 @@\n-    if( _base == DoubleTop ) return this;\n+    if (_base == DoubleTop) { return this; }\n@@ -1088,2 +1113,3 @@\n-    if( _base == DoubleBot || _base == DoubleTop ) return DOUBLE;\n-    if( _base == FloatTop || _base == FloatBot ) return Type::BOTTOM;\n+    if (_base == DoubleBot || _base == DoubleTop) { return DOUBLE; }\n+    if (_base == HalfFloatTop || _base == HalfFloatBot) { return Type::BOTTOM; }\n+    if (_base == FloatTop || _base == FloatBot) { return Type::BOTTOM; }\n@@ -1097,1 +1123,1 @@\n-    if( _base == t->_base )  return this;\n+    if (_base == t->_base)  { return this; }\n@@ -1177,0 +1203,1 @@\n+  case HalfFloatTop:\n@@ -1185,0 +1212,1 @@\n+  case HalfFloatBot:\n@@ -1232,0 +1260,3 @@\n+    case Type::HalfFloatTop:\n+    case Type::HalfFloatCon:\n+    case Type::HalfFloatBot:\n@@ -1337,0 +1368,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n@@ -1415,0 +1449,132 @@\n+\/\/=============================================================================\n+\/\/ Convenience common pre-built types.\n+const TypeH* TypeH::MAX;        \/\/ Half float max\n+const TypeH* TypeH::MIN;        \/\/ Half float min\n+const TypeH* TypeH::ZERO;       \/\/ Half float zero\n+const TypeH* TypeH::ONE;        \/\/ Half float one\n+const TypeH* TypeH::POS_INF;    \/\/ Half float positive infinity\n+const TypeH* TypeH::NEG_INF;    \/\/ Half float negative infinity\n+\n+\/\/------------------------------make-------------------------------------------\n+\/\/ Create a halffloat constant\n+const TypeH* TypeH::make(short f) {\n+  return (TypeH*)(new TypeH(f))->hashcons();\n+}\n+\n+const TypeH* TypeH::make(float f) {\n+  assert(StubRoutines::f2hf_adr() != nullptr, \"\");\n+  short hf = StubRoutines::f2hf(f);\n+  return (TypeH*)(new TypeH(hf))->hashcons();\n+}\n+\n+\/\/------------------------------xmeet-------------------------------------------\n+\/\/ Compute the MEET of two types.  It returns a new Type object.\n+const Type* TypeH::xmeet(const Type* t) const {\n+  \/\/ Perform a fast test for common case; meeting the same types together.\n+  if (this == t) return this;  \/\/ Meeting same type-rep?\n+\n+  \/\/ Current \"this->_base\" is FloatCon\n+  switch (t->base()) {          \/\/ Switch on original type\n+  case AnyPtr:                  \/\/ Mixing with oops happens when javac\n+  case RawPtr:                  \/\/ reuses local variables\n+  case OopPtr:\n+  case InstPtr:\n+  case AryPtr:\n+  case MetadataPtr:\n+  case KlassPtr:\n+  case InstKlassPtr:\n+  case AryKlassPtr:\n+  case NarrowOop:\n+  case NarrowKlass:\n+  case Int:\n+  case Long:\n+  case FloatTop:\n+  case FloatCon:\n+  case FloatBot:\n+  case DoubleTop:\n+  case DoubleCon:\n+  case DoubleBot:\n+  case Bottom:                  \/\/ Ye Olde Default\n+    return Type::BOTTOM;\n+\n+  case HalfFloatBot:\n+    return t;\n+\n+  default:                      \/\/ All else is a mistake\n+    typerr(t);\n+\n+  case HalfFloatCon:            \/\/ Half float-constant vs Half float-constant?\n+    if (_f != t->geth()) {      \/\/ unequal constants?\n+                                \/\/ must compare bitwise as positive zero, negative zero and NaN have\n+                                \/\/ all the same representation in C++\n+      return HALF_FLOAT;        \/\/ Return generic float\n+    }                           \/\/ Equal constants\n+  case Top:\n+  case HalfFloatTop:\n+    break;                      \/\/ Return the Half float constant\n+  }\n+  return this;                  \/\/ Return the Half float constant\n+}\n+\n+\/\/------------------------------xdual------------------------------------------\n+\/\/ Dual: symmetric\n+const Type* TypeH::xdual() const {\n+  return this;\n+}\n+\n+\/\/------------------------------eq---------------------------------------------\n+\/\/ Structural equality check for Type representations\n+bool TypeH::eq(const Type* t) const {\n+  \/\/ Bitwise comparison to distinguish between +\/-0. These values must be treated\n+  \/\/ as different to be consistent with C1 and the interpreter.\n+  return (_f == t->geth());\n+}\n+\n+\/\/------------------------------hash-------------------------------------------\n+\/\/ Type-specific hashing function.\n+uint TypeH::hash(void) const {\n+  return *(jshort*)(&_f);\n+}\n+\n+\/\/------------------------------is_finite--------------------------------------\n+\/\/ Has a finite value\n+bool TypeH::is_finite() const {\n+  assert(StubRoutines::hf2f_adr() != nullptr, \"\");\n+  float f = StubRoutines::hf2f(geth());\n+  return g_isfinite(f) != 0;\n+}\n+\n+float TypeH::getf() const {\n+  assert(StubRoutines::hf2f_adr() != nullptr, \"\");\n+  return StubRoutines::hf2f(geth());\n+}\n+\n+\/\/------------------------------is_nan-----------------------------------------\n+\/\/ Is not a number (NaN)\n+bool TypeH::is_nan() const {\n+  assert(StubRoutines::hf2f_adr() != nullptr, \"\");\n+  float f = StubRoutines::hf2f(geth());\n+  return g_isnan(f) != 0;\n+}\n+\n+\/\/------------------------------dump2------------------------------------------\n+\/\/ Dump float constant Type\n+#ifndef PRODUCT\n+void TypeH::dump2(Dict &d, uint depth, outputStream* st) const {\n+  Type::dump2(d,depth, st);\n+  st->print(\"%f\", getf());\n+}\n+#endif\n+\n+\/\/------------------------------singleton--------------------------------------\n+\/\/ TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple\n+\/\/ constants (Ldi nodes).  Singletons are integer, half float, float or double constants\n+\/\/ or a single symbol.\n+bool TypeH::singleton(void) const {\n+  return true;                  \/\/ Always a singleton\n+}\n+\n+bool TypeH::empty(void) const {\n+  return false;                 \/\/ always exactly a singleton\n+}\n+\n@@ -1450,0 +1616,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n@@ -1646,0 +1815,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n@@ -1909,0 +2081,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n@@ -2703,0 +2878,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n@@ -3642,0 +3820,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n@@ -4210,0 +4391,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n@@ -4887,0 +5071,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n@@ -5316,0 +5503,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n@@ -5471,0 +5661,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n@@ -5845,0 +6038,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n@@ -6269,0 +6465,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":206,"deletions":7,"binary":false,"changes":213,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+class   TypeH;\n@@ -123,0 +124,3 @@\n+    HalfFloatTop,               \/\/ No float value\n+    HalfFloatCon,               \/\/ Floating point constant\n+    HalfFloatBot,               \/\/ Any float value\n@@ -280,1 +284,2 @@\n-  float getf() const;\n+  short geth() const;\n+  virtual float getf() const;\n@@ -292,0 +297,3 @@\n+  const TypeH      *isa_half_float() const;          \/\/ Returns null if not a Float{Top,Con,Bot}\n+  const TypeH      *is_half_float_constant() const;  \/\/ Asserts it is a FloatCon\n+  const TypeH      *isa_half_float_constant() const; \/\/ Returns null if not a FloatCon\n@@ -434,0 +442,1 @@\n+  static const Type *HALF_FLOAT;\n@@ -524,0 +533,32 @@\n+\/\/ Class of Half Float-Constant Types.\n+class TypeH : public Type {\n+  TypeH(short f) : Type(HalfFloatCon), _f(f) {};\n+public:\n+  virtual bool eq(const Type* t) const;\n+  virtual uint hash() const;             \/\/ Type specific hashing\n+  virtual bool singleton(void) const;    \/\/ TRUE if type is a singleton\n+  virtual bool empty(void) const;        \/\/ TRUE if type is vacuous\n+public:\n+  const short _f;                        \/\/ Half Float constant\n+\n+  static const TypeH* make(float f);\n+  static const TypeH* make(short f);\n+\n+  virtual bool is_finite() const;  \/\/ Has a finite value\n+  virtual bool is_nan() const;     \/\/ Is not a number (NaN)\n+\n+  virtual float getf() const;\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xdual() const;    \/\/ Compute dual right now.\n+  \/\/ Convenience common pre-built types.\n+  static const TypeH* MAX;\n+  static const TypeH* MIN;\n+  static const TypeH* ZERO; \/\/ positive zero only\n+  static const TypeH* ONE;\n+  static const TypeH* POS_INF;\n+  static const TypeH* NEG_INF;\n+#ifndef PRODUCT\n+  virtual void dump2(Dict &d, uint depth, outputStream* st) const;\n+#endif\n+};\n+\n@@ -1946,0 +1987,5 @@\n+inline short Type::geth() const {\n+  assert(_base == HalfFloatCon, \"Not a HalfFloatCon\");\n+  return ((TypeH*)this)->_f;\n+}\n+\n@@ -1978,0 +2024,15 @@\n+inline const TypeH* Type::isa_half_float() const {\n+  return ((_base == HalfFloatTop ||\n+           _base == HalfFloatCon ||\n+           _base == HalfFloatBot) ? (TypeH*)this : nullptr);\n+}\n+\n+inline const TypeH* Type::is_half_float_constant() const {\n+  assert( _base == HalfFloatCon, \"Not a HalfFloat\" );\n+  return (TypeH*)this;\n+}\n+\n+inline const TypeH* Type::isa_half_float_constant() const {\n+  return (_base == HalfFloatCon ? (TypeH*)this : nullptr);\n+}\n+\n@@ -2167,1 +2228,2 @@\n-  if( (_base == FloatCon)  || (_base == FloatBot) ||\n+  if( (_base == HalfFloatCon)  || (_base == HalfFloatBot) ||\n+      (_base == FloatCon)  || (_base == FloatBot) ||\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":64,"deletions":2,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -549,0 +549,5 @@\n+const jshort max_jfloat16 = 31743;\n+const jshort min_jfloat16 = 1;\n+const jshort one_jfloat16 = 15360;\n+const jshort pos_inf_jfloat16 = 31744;\n+const jshort neg_inf_jfloat16 = -1024;\n@@ -907,0 +912,1 @@\n+ void set_jshort(jshort i) { _value.i = i;}\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm.vector;\n+\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n+import java.util.function.UnaryOperator;\n+\n+public class Float16Math {\n+\n+    @FunctionalInterface\n+    public interface TernaryOperator<T> {\n+        T apply(T a, T b, T c);\n+    }\n+\n+    @IntrinsicCandidate\n+    public static <T> T sqrt(Class<T> box_class, T oa, UnaryOperator<T> defaultImpl) {\n+        assert isNonCapturingLambda(defaultImpl) : defaultImpl;\n+        return defaultImpl.apply(oa);\n+    }\n+\n+    @IntrinsicCandidate\n+    public static <T> T fma(Class<T> box_class, T oa, T ob, T oc, TernaryOperator<T> defaultImpl) {\n+        assert isNonCapturingLambda(defaultImpl) : defaultImpl;\n+        return defaultImpl.apply(oa, ob, oc);\n+    }\n+\n+    public static boolean isNonCapturingLambda(Object o) {\n+        return o.getClass().getDeclaredFields().length == 0;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/Float16Math.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,2 @@\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.Float16Math;\n@@ -324,0 +326,1 @@\n+    @ForceInline\n@@ -767,0 +770,1 @@\n+    @ForceInline\n@@ -788,0 +792,1 @@\n+    @ForceInline\n@@ -803,0 +808,1 @@\n+    @ForceInline\n@@ -833,0 +839,1 @@\n+    @ForceInline\n@@ -848,0 +855,1 @@\n+    @ForceInline\n@@ -1194,6 +1202,10 @@\n-        \/\/ Rounding path of sqrt(Float16 -> double) -> Float16 is fine\n-        \/\/ for preserving the correct final value. The conversion\n-        \/\/ Float16 -> double preserves the exact numerical value. The\n-        \/\/ conversion of double -> Float16 also benefits from the\n-        \/\/ 2p+2 property of IEEE 754 arithmetic.\n-        return valueOf(Math.sqrt(radicand.doubleValue()));\n+        return Float16Math.sqrt(Float16.class, radicand,\n+            (_radicand) -> {\n+                \/\/ Rounding path of sqrt(Float16 -> double) -> Float16 is fine\n+                \/\/ for preserving the correct final value. The conversion\n+                \/\/ Float16 -> double preserves the exact numerical value. The\n+                \/\/ conversion of double -> Float16 also benefits from the\n+                \/\/ 2p+2 property of IEEE 754 arithmetic.\n+               return valueOf(Math.sqrt(_radicand.doubleValue()));\n+            }\n+        );\n@@ -1401,5 +1413,8 @@\n-        \/\/ product is numerically exact in float before the cast to\n-        \/\/ double; not necessary to widen to double before the\n-        \/\/ multiply.\n-        double product = (double)(a.floatValue() * b.floatValue());\n-        return valueOf(product + c.doubleValue());\n+         return Float16Math.fma(Float16.class, a, b, c,\n+                (_a, _b, _c) -> {\n+                    \/\/ product is numerically exact in float before the cast to\n+                    \/\/ double; not necessary to widen to double before the\n+                    \/\/ multiply.\n+                    double product = (double)(_a.floatValue() * _b.floatValue());\n+                    return valueOf(product + _c.doubleValue());\n+                });\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float16.java","additions":27,"deletions":12,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -260,0 +260,1 @@\n+        AVX512_FP16,\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/amd64\/AMD64.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2025, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.incubator.vector.Float16;\n+import static jdk.incubator.vector.Float16.*;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8338061\n+ * @summary Test that Ideal transformations of ConvF2HF are being performed as expected.\n+ * @modules jdk.incubator.vector\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.ConvF2HFIdealizationTests\n+ *\/\n+public class ConvF2HFIdealizationTests {\n+    private short[] sin;\n+    private short[] sout;\n+    private static final int SIZE = 65504;\n+    public ConvF2HFIdealizationTests() {\n+        sin  = new short[SIZE];\n+        sout = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            sin[i] = Float.floatToFloat16((float)i);\n+        }\n+    }\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\", \"-XX:-UseSuperWord\");\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.REINTERPRET_S2HF, \">=1\", IRNode.REINTERPRET_HF2S, \">=1\", IRNode.ADD_HF, \">=1\" },\n+        failOn = {IRNode.ADD_F, IRNode.CONV_HF2F, IRNode.CONV_F2HF},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    \/\/ Test pattern - ConvHF2F -> AddF -> ConvF2HF is optimized to ReinterpretS2HF -> AddHF -> ReinterpretHF2S\n+    public void test1() {\n+        for (int i = 0; i < SIZE; i++) {\n+            sout[i] = Float.floatToFloat16(Float.float16ToFloat(sin[i]) + Float.float16ToFloat(sin[i]));\n+        }\n+    }\n+\n+    @Check(test=\"test1\")\n+    public void checkResult() {\n+        for (int i = 0; i < SIZE; i++) {\n+            short expected = Float16.float16ToRawShortBits(Float16.add(Float16.shortBitsToFloat16(sin[i]), Float16.shortBitsToFloat16(sin[i])));\n+            if (expected != sout[i]) {\n+                throw new RuntimeException(\"Invalid result: sout[\" + i + \"] = \" + sout[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/ConvF2HFIdealizationTests.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2025, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.incubator.vector.Float16;\n+import static jdk.incubator.vector.Float16.*;\n+import java.util.Random;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8336406\n+ * @summary Test that Ideal transformations of MulHFNode are being performed as expected.\n+ * @modules jdk.incubator.vector\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.MulHFNodeIdealizationTests\n+ *\/\n+public class MulHFNodeIdealizationTests {\n+\n+    private Float16 src;\n+    private Float16 dst;\n+    private Random rng;\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\");\n+    }\n+\n+    public MulHFNodeIdealizationTests() {\n+        rng = new Random(25);\n+        src = valueOf(rng.nextFloat());\n+        dst = valueOf(rng.nextFloat());\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_HF, \"1\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"},\n+        failOn = {IRNode.MUL_HF})\n+    public void test1() {\n+        dst = multiply(src, valueOf(2.0f));\n+    }\n+\n+    @Check(test=\"test1\")\n+    public void checkTest1() {\n+        Float16 expected = valueOf(src.floatValue() * 2.0f);\n+        if (float16ToRawShortBits(expected) != float16ToRawShortBits(dst)) {\n+            throw new RuntimeException(\"Invalid result: dst = \" + float16ToRawShortBits(dst) + \" != \" + float16ToRawShortBits(expected));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/MulHFNodeIdealizationTests.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,585 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8308363 8336406\n+* @summary Validate compiler IR for various Float16 scalar operations.\n+* @modules jdk.incubator.vector\n+* @requires vm.compiler2.enabled\n+* @library \/test\/lib \/\n+* @run driver TestFloat16ScalarOperations\n+*\/\n+import compiler.lib.ir_framework.*;\n+import jdk.incubator.vector.Float16;\n+import static jdk.incubator.vector.Float16.*;\n+import java.util.Random;\n+\n+public class TestFloat16ScalarOperations {\n+    private static final int count = 1024;\n+\n+    private short[] src;\n+    private short[] dst;\n+    private short res;\n+\n+    private static final Float16 ONE = valueOf(1.0f);\n+    private static final Float16 MONE = valueOf(-1.0f);\n+    private static final Float16 POSITIVE_ZERO = valueOf(0.0f);\n+    private static final Float16 NEGATIVE_ZERO = valueOf(-0.0f);\n+    private static final Float16 MIN_NORMAL = valueOf(0x1.0P-14f);\n+    private static final Float16 NEGATIVE_MAX_VALUE = valueOf(-0x1.ffcP+15f);\n+    private static final Float16 LT_MAX_HALF_ULP = Float16.valueOf(14.0f);\n+    private static final Float16 MAX_HALF_ULP = Float16.valueOf(16.0f);\n+    private static final Float16 SIGNALING_NAN = shortBitsToFloat16((short)31807);\n+\n+    private static Random r = jdk.test.lib.Utils.getRandomInstance();\n+\n+    private static final Float16 RANDOM1 = Float16.valueOf(r.nextFloat() * MAX_VALUE.floatValue());\n+    private static final Float16 RANDOM2 = Float16.valueOf(r.nextFloat() * MAX_VALUE.floatValue());\n+    private static final Float16 RANDOM3 = Float16.valueOf(r.nextFloat() * MAX_VALUE.floatValue());\n+    private static final Float16 RANDOM4 = Float16.valueOf(r.nextFloat() * MAX_VALUE.floatValue());\n+    private static final Float16 RANDOM5 = Float16.valueOf(r.nextFloat() * MAX_VALUE.floatValue());\n+\n+    private static Float16 RANDOM1_VAR = RANDOM1;\n+    private static Float16 RANDOM2_VAR = RANDOM2;\n+    private static Float16 RANDOM3_VAR = RANDOM3;\n+    private static Float16 RANDOM4_VAR = RANDOM4;\n+    private static Float16 RANDOM5_VAR = RANDOM5;\n+\n+    public static void main(String args[]) {\n+        Scenario s0 = new Scenario(0, \"--add-modules=jdk.incubator.vector\", \"-Xint\");\n+        Scenario s1 = new Scenario(1, \"--add-modules=jdk.incubator.vector\");\n+        new TestFramework().addScenarios(s1).start();\n+    }\n+\n+    public TestFloat16ScalarOperations() {\n+        src = new short[count];\n+        dst = new short[count];\n+        for (int i = 0; i < count; i++) {\n+            src[i] = Float.floatToFloat16(r.nextFloat() * MAX_VALUE.floatValue());\n+        }\n+    }\n+\n+    static void assertResult(float actual, float expected, String msg) {\n+        if (actual != expected) {\n+            if (!Float.isNaN(actual) || !Float.isNaN(expected)) {\n+                String error = \"TEST : \" + msg + \": actual(\" + actual + \") != expected(\" + expected + \")\";\n+                throw new AssertionError(error);\n+            }\n+        }\n+    }\n+\n+    static void assertResult(float actual, float expected, String msg, int iter) {\n+        if (actual != expected) {\n+            if (!Float.isNaN(actual) || !Float.isNaN(expected)) {\n+                String error = \"TEST (\" + iter + \"): \" + msg + \": actual(\" + actual + \") != expected(\" + expected + \")\";\n+                throw new AssertionError(error);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"convHF2SAndHF2F\", \" >0 \"}, phase = {CompilePhase.FINAL_CODE},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void testEliminateIntermediateHF2S() {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < count; i++) {\n+            \/\/ Intermediate HF2S + S2HF is eliminated in following transformation\n+            \/\/ AddHF S2HF(HF2S (AddHF S2HF(src[i]), S2HF(0))), S2HF(src[i]) => AddHF (AddHF S2HF(src[i]), S2HF(0)), S2HF(src[i])\n+            res = add(add(res, shortBitsToFloat16(src[i])), shortBitsToFloat16(src[i]));\n+            dst[i] = (short)res.floatValue();\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_HF, \" >0 \", IRNode.REINTERPRET_S2HF, \" >0 \", IRNode.REINTERPRET_HF2S, \" >0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void testAdd1() {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < count; i++) {\n+            res = Float16.add(res, shortBitsToFloat16(src[i]));\n+            dst[i] = float16ToRawShortBits(res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD_HF, IRNode.REINTERPRET_S2HF, IRNode.REINTERPRET_HF2S},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void testAdd2() {\n+        Float16 hf0 = shortBitsToFloat16((short)0);\n+        Float16 hf1 = shortBitsToFloat16((short)15360);\n+        Float16 hf2 = shortBitsToFloat16((short)16384);\n+        Float16 hf3 = shortBitsToFloat16((short)16896);\n+        Float16 hf4 = shortBitsToFloat16((short)17408);\n+        res = float16ToRawShortBits(Float16.add(Float16.add(Float16.add(Float16.add(hf0, hf1), hf2), hf3), hf4));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SUB_HF, \" >0 \", IRNode.REINTERPRET_S2HF, \" >0 \", IRNode.REINTERPRET_HF2S, \" >0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void testSub() {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < count; i++) {\n+            res = Float16.subtract(res, shortBitsToFloat16(src[i]));\n+            dst[i] = float16ToRawShortBits(res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_HF, \" >0 \", IRNode.REINTERPRET_S2HF, \" >0 \", IRNode.REINTERPRET_HF2S, \" >0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void testMul() {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < count; i++) {\n+            res = Float16.multiply(res, shortBitsToFloat16(src[i]));\n+            dst[i] = float16ToRawShortBits(res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.DIV_HF, \" >0 \", IRNode.REINTERPRET_S2HF, \" >0 \", IRNode.REINTERPRET_HF2S, \" >0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void testDiv() {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < count; i++) {\n+            res = Float16.divide(res, shortBitsToFloat16(src[i]));\n+            dst[i] = float16ToRawShortBits(res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.DIV_HF, \" 0 \", IRNode.REINTERPRET_S2HF, \" 0 \", IRNode.REINTERPRET_HF2S, \" 0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void testDivByOne() {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < count; i++) {\n+            res = Float16.divide(shortBitsToFloat16(src[i]), ONE);\n+            dst[i] = float16ToRawShortBits(res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MAX_HF, \" >0 \", IRNode.REINTERPRET_S2HF, \" >0 \", IRNode.REINTERPRET_HF2S, \" >0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void testMax() {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < count; i++) {\n+            res = Float16.max(res, shortBitsToFloat16(src[i]));\n+            dst[i] = float16ToRawShortBits(res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MIN_HF, \" >0 \", IRNode.REINTERPRET_S2HF, \" >0 \", IRNode.REINTERPRET_HF2S, \" >0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void testMin() {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < count; i++) {\n+            res = Float16.min(res, shortBitsToFloat16(src[i]));\n+            dst[i] = float16ToRawShortBits(res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SQRT_HF, \" >0 \", IRNode.REINTERPRET_S2HF, \" >0 \", IRNode.REINTERPRET_HF2S, \" >0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void testSqrt() {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < count; i++) {\n+            res = Float16.sqrt(shortBitsToFloat16(src[i]));\n+            dst[i] = float16ToRawShortBits(res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.FMA_HF, \" >0 \", IRNode.REINTERPRET_S2HF, \" >0 \", IRNode.REINTERPRET_HF2S, \" >0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void testFma() {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < count; i++) {\n+            Float16 in = shortBitsToFloat16(src[i]);\n+            res = Float16.fma(in, in, in);\n+            dst[i] = float16ToRawShortBits(res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_HF, \" >0 \", IRNode.REINTERPRET_S2HF, \" >0 \", IRNode.REINTERPRET_HF2S, \" >0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void testDivByPOT() {\n+        Float16 res = valueOf(0.0f);\n+        for (int i = 0; i < 50; i++) {\n+            Float16 divisor = valueOf(8.0f);\n+            Float16 dividend = shortBitsToFloat16(src[i]);\n+            res = add(res, divide(dividend, divisor));\n+            divisor = valueOf(16.0f);\n+            res = add(res, divide(dividend, divisor));\n+            divisor = valueOf(32.0f);\n+            res = add(res, divide(dividend, divisor));\n+        }\n+        dst[0] = float16ToRawShortBits(res);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_HF, \" 0 \", IRNode.ADD_HF, \" >0 \", IRNode.REINTERPRET_S2HF, \" >0 \", IRNode.REINTERPRET_HF2S, \" >0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void testMulByTWO() {\n+        Float16 res = valueOf(0.0f);\n+        Float16 multiplier = valueOf(2.0f);\n+        for (int i = 0; i < 20; i++) {\n+            Float16 multiplicand = valueOf((float)i);\n+            res = add(res, multiply(multiplicand, multiplier));\n+        }\n+        assertResult(res.floatValue(), (float)((20 * (20 - 1))\/2) * 2.0f, \"testMulByTWO\");\n+    }\n+\n+\n+    \/\/\n+    \/\/ Tests points for various Float16 constant folding transforms. Following figure represents various\n+    \/\/ special IEEE 754 binary16 values on a number line\n+    \/\/\n+    \/\/   -Inf                               -0.0                              Inf\n+    \/\/   -------|-----------------------------|----------------------------|------\n+    \/\/     -MAX_VALUE                        0.0                        MAX_VALUE\n+    \/\/\n+    \/\/  Number whose exponent lie between -14 and 15, both values inclusive, belongs to normal value range.\n+    \/\/  IEEE 754 binary16 specification allows graceful degradation of numbers with exponents less than -14\n+    \/\/  into a sub-normal value range i.e. their exponents may extend uptill -24, this is because format\n+    \/\/  supports 10 mantissa bits which can be used to represent a number with exponents less than -14.\n+    \/\/\n+    \/\/  A number below the sub-normal value range is considered as 0.0. With regards to overflowing\n+    \/\/  semantics, a value equal to or greater than MAX_VALUE + half ulp (MAX_VALUE) is considered as\n+    \/\/  an Infinite value on both side of axis.\n+    \/\/\n+    \/\/  In addition, format specifies special bit representation for +Inf, -Inf and NaN values.\n+    \/\/\n+    \/\/  Tests also covers special cases for various operations as per Java SE specification.\n+    \/\/\n+\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_HF, \" 0 \", IRNode.REINTERPRET_S2HF, \" 0 \", IRNode.REINTERPRET_HF2S, \" 0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void testAddConstantFolding() {\n+        \/\/ If either value is NaN, then the result is NaN.\n+        assertResult(add(Float16.NaN, valueOf(2.0f)).floatValue(), Float.NaN, \"testAddConstantFolding\");\n+        assertResult(add(Float16.NaN, Float16.NaN).floatValue(), Float.NaN, \"testAddConstantFolding\");\n+        assertResult(add(Float16.NaN, Float16.POSITIVE_INFINITY).floatValue(), Float.NaN, \"testAddConstantFolding\");\n+\n+        \/\/ The sum of two infinities of opposite sign is NaN.\n+        assertResult(add(Float16.POSITIVE_INFINITY, Float16.NEGATIVE_INFINITY).floatValue(), Float.NaN, \"testAddConstantFolding\");\n+\n+        \/\/ The sum of two infinities of the same sign is the infinity of that sign.\n+        assertResult(add(Float16.POSITIVE_INFINITY, Float16.POSITIVE_INFINITY).floatValue(), Float.POSITIVE_INFINITY, \"testAddConstantFolding\");\n+        assertResult(add(Float16.NEGATIVE_INFINITY, Float16.NEGATIVE_INFINITY).floatValue(), Float.NEGATIVE_INFINITY, \"testAddConstantFolding\");\n+\n+        \/\/ The sum of an infinity and a finite value is equal to the infinite operand.\n+        assertResult(add(Float16.POSITIVE_INFINITY, valueOf(2.0f)).floatValue(), Float.POSITIVE_INFINITY, \"testAddConstantFolding\");\n+        assertResult(add(Float16.NEGATIVE_INFINITY, valueOf(2.0f)).floatValue(), Float.NEGATIVE_INFINITY, \"testAddConstantFolding\");\n+\n+        \/\/ The sum of two zeros of opposite sign is positive zero.\n+        assertResult(add(NEGATIVE_ZERO, POSITIVE_ZERO).floatValue(), 0.0f, \"testAddConstantFolding\");\n+\n+        \/\/ The sum of two zeros of the same sign is the zero of that sign.\n+        assertResult(add(NEGATIVE_ZERO, NEGATIVE_ZERO).floatValue(), -0.0f, \"testAddConstantFolding\");\n+\n+        \/\/ The sum of a zero and a nonzero finite value is equal to the nonzero operand.\n+        assertResult(add(POSITIVE_ZERO, valueOf(2.0f)).floatValue(), 2.0f, \"testAddConstantFolding\");\n+        assertResult(add(NEGATIVE_ZERO, valueOf(2.0f)).floatValue(), 2.0f, \"testAddConstantFolding\");\n+\n+        \/\/ Number equal to MAX_VALUE when added to half upl for MAX_VALUE results into Inf.\n+        assertResult(add(Float16.MAX_VALUE, MAX_HALF_ULP).floatValue(), Float.POSITIVE_INFINITY, \"testAddConstantFolding\");\n+\n+        \/\/ If the magnitude of the sum is too large to represent, we say the operation\n+        \/\/ overflows; the result is then an infinity of appropriate sign.\n+        assertResult(add(Float16.MAX_VALUE, Float16.MAX_VALUE).floatValue(), Float.POSITIVE_INFINITY, \"testAddConstantFolding\");\n+\n+        \/\/ Number equal to MAX_VALUE when added to half upl for MAX_VALUE results into MAX_VALUE.\n+        assertResult(add(Float16.MAX_VALUE, LT_MAX_HALF_ULP).floatValue(), Float16.MAX_VALUE.floatValue(), \"testAddConstantFolding\");\n+\n+        assertResult(add(valueOf(1.0f), valueOf(2.0f)).floatValue(), 3.0f, \"testAddConstantFolding\");\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SUB_HF, \" 0 \", IRNode.REINTERPRET_S2HF, \" 0 \", IRNode.REINTERPRET_HF2S, \" 0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void testSubConstantFolding() {\n+        \/\/ If either value is NaN, then the result is NaN.\n+        assertResult(subtract(Float16.NaN, valueOf(2.0f)).floatValue(), Float.NaN, \"testAddConstantFolding\");\n+        assertResult(subtract(Float16.NaN, Float16.NaN).floatValue(), Float.NaN, \"testAddConstantFolding\");\n+        assertResult(subtract(Float16.NaN, Float16.POSITIVE_INFINITY).floatValue(), Float.NaN, \"testAddConstantFolding\");\n+\n+        \/\/ The difference of two infinities of opposite sign is NaN.\n+        assertResult(subtract(Float16.POSITIVE_INFINITY, Float16.NEGATIVE_INFINITY).floatValue(), Float.POSITIVE_INFINITY, \"testAddConstantFolding\");\n+\n+        \/\/ The difference of two infinities of the same sign is NaN.\n+        assertResult(subtract(Float16.POSITIVE_INFINITY, Float16.POSITIVE_INFINITY).floatValue(), Float.NaN, \"testAddConstantFolding\");\n+        assertResult(subtract(Float16.NEGATIVE_INFINITY, Float16.NEGATIVE_INFINITY).floatValue(), Float.NaN, \"testAddConstantFolding\");\n+\n+        \/\/ The difference of an infinity and a finite value is equal to the infinite operand.\n+        assertResult(subtract(Float16.POSITIVE_INFINITY, valueOf(2.0f)).floatValue(), Float.POSITIVE_INFINITY, \"testAddConstantFolding\");\n+        assertResult(subtract(Float16.NEGATIVE_INFINITY, valueOf(2.0f)).floatValue(), Float.NEGATIVE_INFINITY, \"testAddConstantFolding\");\n+\n+        \/\/ The difference of two zeros of opposite sign is positive zero.\n+        assertResult(subtract(NEGATIVE_ZERO, POSITIVE_ZERO).floatValue(), 0.0f, \"testAddConstantFolding\");\n+\n+        \/\/ Number equal to -MAX_VALUE when subtracted by half upl of MAX_VALUE results into -Inf.\n+        assertResult(subtract(NEGATIVE_MAX_VALUE, MAX_HALF_ULP).floatValue(), Float.NEGATIVE_INFINITY, \"testAddConstantFolding\");\n+\n+        \/\/ Number equal to -MAX_VALUE when subtracted by a number less than half upl for MAX_VALUE results into -MAX_VALUE.\n+        assertResult(subtract(NEGATIVE_MAX_VALUE, LT_MAX_HALF_ULP).floatValue(), NEGATIVE_MAX_VALUE.floatValue(), \"testAddConstantFolding\");\n+\n+        assertResult(subtract(valueOf(1.0f), valueOf(2.0f)).floatValue(), -1.0f, \"testAddConstantFolding\");\n+    }\n+\n+    @Test\n+    @Warmup(value = 10000)\n+    @IR(counts = {IRNode.MAX_HF, \" 0 \", IRNode.REINTERPRET_S2HF, \" 0 \", IRNode.REINTERPRET_HF2S, \" 0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void testMaxConstantFolding() {\n+        \/\/ If either value is NaN, then the result is NaN.\n+        assertResult(max(valueOf(2.0f), Float16.NaN).floatValue(), Float.NaN, \"testMaxConstantFolding\");\n+        assertResult(max(Float16.NaN, Float16.NaN).floatValue(), Float.NaN, \"testMaxConstantFolding\");\n+\n+        \/\/ This operation considers negative zero to be strictly smaller than positive zero\n+        assertResult(max(POSITIVE_ZERO, NEGATIVE_ZERO).floatValue(), 0.0f, \"testMaxConstantFolding\");\n+\n+        \/\/ Other cases.\n+        assertResult(max(Float16.POSITIVE_INFINITY, Float16.NEGATIVE_INFINITY).floatValue(), Float.POSITIVE_INFINITY, \"testMaxConstantFolding\");\n+        assertResult(max(valueOf(1.0f), valueOf(2.0f)).floatValue(), 2.0f, \"testMaxConstantFolding\");\n+        assertResult(max(Float16.MAX_VALUE, Float16.MIN_VALUE).floatValue(), Float16.MAX_VALUE.floatValue(), \"testMaxConstantFolding\");\n+    }\n+\n+\n+    @Test\n+    @IR(counts = {IRNode.MIN_HF, \" 0 \", IRNode.REINTERPRET_S2HF, \" 0 \", IRNode.REINTERPRET_HF2S, \" 0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void testMinConstantFolding() {\n+        \/\/ If either value is NaN, then the result is NaN.\n+        assertResult(min(valueOf(2.0f), Float16.NaN).floatValue(), Float.NaN, \"testMinConstantFolding\");\n+        assertResult(min(Float16.NaN, Float16.NaN).floatValue(), Float.NaN, \"testMinConstantFolding\");\n+\n+        \/\/ This operation considers negative zero to be strictly smaller than positive zero\n+        assertResult(min(POSITIVE_ZERO, NEGATIVE_ZERO).floatValue(), -0.0f, \"testMinConstantFolding\");\n+\n+        \/\/ Other cases.\n+        assertResult(min(Float16.POSITIVE_INFINITY, Float16.NEGATIVE_INFINITY).floatValue(), Float.NEGATIVE_INFINITY, \"testMinConstantFolding\");\n+        assertResult(min(valueOf(1.0f), valueOf(2.0f)).floatValue(), 1.0f, \"testMinConstantFolding\");\n+        assertResult(min(Float16.MAX_VALUE, Float16.MIN_VALUE).floatValue(), Float16.MIN_VALUE.floatValue(), \"testMinConstantFolding\");\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.DIV_HF, \" 0 \", IRNode.REINTERPRET_S2HF, \" 0 \", IRNode.REINTERPRET_HF2S, \" 0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void testDivConstantFolding() {\n+        \/\/ If either value is NaN, then the result is NaN.\n+        assertResult(divide(Float16.NaN, POSITIVE_ZERO).floatValue(), Float.NaN, \"testDivConstantFolding\");\n+        assertResult(divide(NEGATIVE_ZERO, Float16.NaN).floatValue(), Float.NaN, \"testDivConstantFolding\");\n+\n+        \/\/ Division of an infinity by an infinity results in NaN.\n+        assertResult(divide(Float16.NEGATIVE_INFINITY, Float16.POSITIVE_INFINITY).floatValue(), Float.NaN, \"testDivConstantFolding\");\n+\n+        \/\/ Division of an infinity by a finite value results in a signed infinity. Sign of the result is positive if both operands have\n+        \/\/ the same sign, and negative if the operands have different signs\n+        assertResult(divide(Float16.NEGATIVE_INFINITY, valueOf(2.0f)).floatValue(), Float.NEGATIVE_INFINITY, \"testDivConstantFolding\");\n+        assertResult(divide(Float16.POSITIVE_INFINITY, valueOf(2.0f)).floatValue(), Float.POSITIVE_INFINITY, \"testDivConstantFolding\");\n+\n+        \/\/ Division of a finite value by an infinity results in a signed zero. The sign is\n+        \/\/ determined by the above rule.\n+        assertResult(divide(valueOf(2.0f), Float16.POSITIVE_INFINITY).floatValue(), 0.0f, \"testDivConstantFolding\");\n+        assertResult(divide(valueOf(2.0f), Float16.NEGATIVE_INFINITY).floatValue(), -0.0f, \"testDivConstantFolding\");\n+\n+        \/\/ Division of a zero by a zero results in NaN; division of zero by any other finite\n+        \/\/ value results in a signed zero. The sign is determined by the rule stated above.\n+        assertResult(divide(POSITIVE_ZERO, NEGATIVE_ZERO).floatValue(), Float.NaN, \"testDivConstantFolding\");\n+        assertResult(divide(POSITIVE_ZERO, Float16.MAX_VALUE).floatValue(), 0.0f, \"testDivConstantFolding\");\n+        assertResult(divide(NEGATIVE_ZERO, Float16.MAX_VALUE).floatValue(), -0.0f, \"testDivConstantFolding\");\n+\n+        \/\/ Division of a nonzero finite value by a zero results in a signed infinity. The sign\n+        \/\/ is determined by the rule stated above\n+        assertResult(divide(valueOf(2.0f), NEGATIVE_ZERO).floatValue(), Float.NEGATIVE_INFINITY, \"testDivConstantFolding\");\n+        assertResult(divide(valueOf(2.0f), POSITIVE_ZERO).floatValue(), Float.POSITIVE_INFINITY, \"testDivConstantFolding\");\n+\n+        \/\/ If the magnitude of the quotient is too large to represent, we say the operation\n+        \/\/ overflows; the result is then an infinity of appropriate sign.\n+        assertResult(divide(Float16.MAX_VALUE, Float16.MIN_NORMAL).floatValue(), Float.POSITIVE_INFINITY, \"testDivConstantFolding\");\n+        assertResult(divide(Float16.MAX_VALUE, valueOf(-0x1.0P-14f)).floatValue(), Float.NEGATIVE_INFINITY, \"testDivConstantFolding\");\n+\n+        assertResult(divide(valueOf(2.0f), valueOf(2.0f)).floatValue(), 1.0f, \"testDivConstantFolding\");\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_HF, \" 0 \", IRNode.REINTERPRET_S2HF, \" 0 \", IRNode.REINTERPRET_HF2S, \" 0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void testMulConstantFolding() {\n+        \/\/ If any operand is NaN, the result is NaN.\n+        assertResult(multiply(Float16.NaN, valueOf(4.0f)).floatValue(), Float.NaN, \"testMulConstantFolding\");\n+        assertResult(multiply(Float16.NaN, Float16.NaN).floatValue(), Float.NaN, \"testMulConstantFolding\");\n+\n+        \/\/ Multiplication of an infinity by a zero results in NaN.\n+        assertResult(multiply(Float16.POSITIVE_INFINITY, POSITIVE_ZERO).floatValue(), Float.NaN, \"testMulConstantFolding\");\n+\n+        \/\/ Multiplication of an infinity by a finite value results in a signed infinity.\n+        assertResult(multiply(Float16.POSITIVE_INFINITY, valueOf(2.0f)).floatValue(), Float.POSITIVE_INFINITY, \"testMulConstantFolding\");\n+        assertResult(multiply(Float16.NEGATIVE_INFINITY, valueOf(2.0f)).floatValue(), Float.NEGATIVE_INFINITY, \"testMulConstantFolding\");\n+\n+        \/\/ If the magnitude of the product is too large to represent, we say the operation\n+        \/\/ overflows; the result is then an infinity of appropriate sign\n+        assertResult(multiply(Float16.MAX_VALUE, Float16.MAX_VALUE).floatValue(), Float.POSITIVE_INFINITY, \"testMulConstantFolding\");\n+        assertResult(multiply(NEGATIVE_MAX_VALUE, Float16.MAX_VALUE).floatValue(), Float.NEGATIVE_INFINITY, \"testMulConstantFolding\");\n+\n+        assertResult(multiply(multiply(multiply(valueOf(1.0f), valueOf(2.0f)), valueOf(3.0f)), valueOf(4.0f)).floatValue(), 1.0f * 2.0f * 3.0f * 4.0f, \"testMulConstantFolding\");\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SQRT_HF, \" 0 \", IRNode.REINTERPRET_S2HF, \" 0 \", IRNode.REINTERPRET_HF2S, \" 0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void testSqrtConstantFolding() {\n+        \/\/ If the argument is NaN or less than zero, then the result is NaN.\n+        assertResult(sqrt(Float16.NaN).floatValue(), Float.NaN, \"testSqrtConstantFolding\");\n+        assertResult(sqrt(SIGNALING_NAN).floatValue(), Float.NaN, \"testSqrtConstantFolding\");\n+\n+        \/\/ If the argument is positive infinity, then the result is positive infinity.\n+        assertResult(sqrt(Float16.POSITIVE_INFINITY).floatValue(), Float.POSITIVE_INFINITY, \"testSqrtConstantFolding\");\n+\n+        \/\/ If the argument is positive zero or negative zero, then the result is the same as the argument.\n+        assertResult(sqrt(POSITIVE_ZERO).floatValue(), 0.0f, \"testSqrtConstantFolding\");\n+        assertResult(sqrt(NEGATIVE_ZERO).floatValue(), -0.0f, \"testSqrtConstantFolding\");\n+\n+        \/\/ Other cases.\n+        assertResult(Math.round(sqrt(valueOf(0x1.ffcP+14f)).floatValue()), Math.round(Math.sqrt(0x1.ffcP+14f)), \"testSqrtConstantFolding\");\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.FMA_HF, \" 0 \", IRNode.REINTERPRET_S2HF, \" 0 \", IRNode.REINTERPRET_HF2S, \" 0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void testFMAConstantFolding() {\n+        \/\/ If any argument is NaN, the result is NaN.\n+        assertResult(fma(Float16.NaN, valueOf(2.0f), valueOf(3.0f)).floatValue(), Float.NaN, \"testFMAConstantFolding\");\n+        assertResult(fma(SIGNALING_NAN, valueOf(2.0f), valueOf(3.0f)).floatValue(), Float.NaN, \"testFMAConstantFolding\");\n+        assertResult(fma(valueOf(2.0f), Float16.NaN, valueOf(3.0f)).floatValue(), Float.NaN, \"testFMAConstantFolding\");\n+\n+        assertResult(fma(shortBitsToFloat16(Float.floatToFloat16(2.0f)),\n+                         shortBitsToFloat16(Float.floatToFloat16(3.0f)),\n+                         Float16.NaN).floatValue(), Float.NaN, \"testFMAConstantFolding\");\n+\n+        \/\/ If one of the first two arguments is infinite and the other is zero, the result is NaN.\n+        assertResult(fma(Float16.POSITIVE_INFINITY, POSITIVE_ZERO, valueOf(2.0f)).floatValue(), Float.NaN, \"testFMAConstantFolding\");\n+        assertResult(fma(Float16.POSITIVE_INFINITY, NEGATIVE_ZERO, valueOf(2.0f)).floatValue(), Float.NaN, \"testFMAConstantFolding\");\n+        assertResult(fma(NEGATIVE_ZERO, Float16.POSITIVE_INFINITY, valueOf(2.0f)).floatValue(), Float.NaN, \"testFMAConstantFolding\");\n+        assertResult(fma(POSITIVE_ZERO, Float16.POSITIVE_INFINITY, valueOf(2.0f)).floatValue(), Float.NaN, \"testFMAConstantFolding\");\n+\n+        \/\/ If the exact product of the first two arguments is infinite (in other words, at least one of the arguments is infinite\n+        \/\/ and the other is neither zero nor NaN) and the third argument is an infinity of the opposite sign, the result is NaN.\n+        assertResult(fma(valueOf(2.0f), Float16.POSITIVE_INFINITY, Float16.NEGATIVE_INFINITY).floatValue(), Float.NaN, \"testFMAConstantFolding\");\n+        assertResult(fma(valueOf(2.0f), Float16.NEGATIVE_INFINITY, Float16.POSITIVE_INFINITY).floatValue(), Float.NaN, \"testFMAConstantFolding\");\n+        assertResult(fma(Float16.POSITIVE_INFINITY, valueOf(2.0f), Float16.NEGATIVE_INFINITY).floatValue(), Float.NaN, \"testFMAConstantFolding\");\n+        assertResult(fma(Float16.NEGATIVE_INFINITY, valueOf(2.0f), Float16.POSITIVE_INFINITY).floatValue(), Float.NaN, \"testFMAConstantFolding\");\n+\n+        \/\/ Signed bits.\n+        assertResult(fma(NEGATIVE_ZERO, POSITIVE_ZERO, POSITIVE_ZERO).floatValue(), 0.0f, \"testFMAConstantFolding\");\n+        assertResult(fma(NEGATIVE_ZERO, POSITIVE_ZERO, NEGATIVE_ZERO).floatValue(), -0.0f, \"testFMAConstantFolding\");\n+\n+        assertResult(fma(Float16.POSITIVE_INFINITY, valueOf(2.0f), valueOf(3.0f)).floatValue(), Float.POSITIVE_INFINITY, \"testFMAConstantFolding\");\n+        assertResult(fma(Float16.NEGATIVE_INFINITY, valueOf(2.0f), valueOf(3.0f)).floatValue(), Float.NEGATIVE_INFINITY, \"testFMAConstantFolding\");\n+        assertResult(fma(valueOf(1.0f), valueOf(2.0f), valueOf(3.0f)).floatValue(), 1.0f * 2.0f + 3.0f, \"testFMAConstantFolding\");\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD_HF, IRNode.SUB_HF, IRNode.MUL_HF, IRNode.DIV_HF, IRNode.SQRT_HF, IRNode.FMA_HF},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void testRounding1() {\n+        dst[0] = float16ToRawShortBits(add(RANDOM1, RANDOM2));\n+        dst[1] = float16ToRawShortBits(subtract(RANDOM2, RANDOM3));\n+        dst[2] = float16ToRawShortBits(multiply(RANDOM4, RANDOM5));\n+        dst[3] = float16ToRawShortBits(sqrt(RANDOM2));\n+        dst[4] = float16ToRawShortBits(fma(RANDOM3, RANDOM4, RANDOM5));\n+        dst[5] = float16ToRawShortBits(divide(RANDOM5, RANDOM4));\n+    }\n+\n+    @Check(test = \"testRounding1\", when = CheckAt.COMPILED)\n+    public void checkRounding1() {\n+        assertResult(dst[0], Float.floatToFloat16(RANDOM1.floatValue() + RANDOM2.floatValue()),\n+                     \"testRounding1 case1a\");\n+        assertResult(dst[0], float16ToRawShortBits(add(RANDOM1, RANDOM2)), \"testRounding1 case1b\");\n+\n+        assertResult(dst[1], Float.floatToFloat16(RANDOM2.floatValue() - RANDOM3.floatValue()),\n+                     \"testRounding1 case2a\");\n+        assertResult(dst[1], float16ToRawShortBits(subtract(RANDOM2, RANDOM3)), \"testRounding1 case2b\");\n+\n+        assertResult(dst[2], Float.floatToFloat16(RANDOM4.floatValue() * RANDOM5.floatValue()),\n+                     \"testRounding1 case3a\");\n+        assertResult(dst[2], float16ToRawShortBits(multiply(RANDOM4, RANDOM5)), \"testRounding1 cast3b\");\n+\n+        assertResult(dst[3], Float.floatToFloat16((float)Math.sqrt(RANDOM2.floatValue())), \"testRounding1 case4a\");\n+        assertResult(dst[3], float16ToRawShortBits(sqrt(RANDOM2)), \"testRounding1 case4a\");\n+\n+        assertResult(dst[4], Float.floatToFloat16(Math.fma(RANDOM3.floatValue(), RANDOM4.floatValue(),\n+                     RANDOM5.floatValue())), \"testRounding1 case5a\");\n+        assertResult(dst[4], float16ToRawShortBits(fma(RANDOM3, RANDOM4, RANDOM5)), \"testRounding1 case5b\");\n+\n+        assertResult(dst[5], Float.floatToFloat16(RANDOM5.floatValue() \/ RANDOM4.floatValue()),\n+                     \"testRounding1 case6a\");\n+        assertResult(dst[5], float16ToRawShortBits(divide(RANDOM5, RANDOM4)), \"testRounding1 case6b\");\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_HF, \" >0 \", IRNode.SUB_HF, \" >0 \", IRNode.MUL_HF, \" >0 \",\n+                  IRNode.DIV_HF, \" >0 \", IRNode.SQRT_HF, \" >0 \", IRNode.FMA_HF, \" >0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void testRounding2() {\n+        dst[0] = float16ToRawShortBits(add(RANDOM1_VAR, RANDOM2_VAR));\n+        dst[1] = float16ToRawShortBits(subtract(RANDOM2_VAR, RANDOM3_VAR));\n+        dst[2] = float16ToRawShortBits(multiply(RANDOM4_VAR, RANDOM5_VAR));\n+        dst[3] = float16ToRawShortBits(sqrt(RANDOM2_VAR));\n+        dst[4] = float16ToRawShortBits(fma(RANDOM3_VAR, RANDOM4_VAR, RANDOM5_VAR));\n+        dst[5] = float16ToRawShortBits(divide(RANDOM5_VAR, RANDOM4_VAR));\n+    }\n+\n+    @Check(test = \"testRounding2\", when = CheckAt.COMPILED)\n+    public void checkRounding2() {\n+        assertResult(dst[0], Float.floatToFloat16(RANDOM1_VAR.floatValue() + RANDOM2_VAR.floatValue()),\n+                     \"testRounding2 case1a\");\n+        assertResult(dst[0], float16ToRawShortBits(add(RANDOM1_VAR, RANDOM2_VAR)), \"testRounding2 case1b\");\n+\n+        assertResult(dst[1], Float.floatToFloat16(RANDOM2_VAR.floatValue() - RANDOM3_VAR.floatValue()),\n+                     \"testRounding2 case2a\");\n+        assertResult(dst[1], float16ToRawShortBits(subtract(RANDOM2_VAR, RANDOM3_VAR)), \"testRounding2 case2b\");\n+\n+        assertResult(dst[2], Float.floatToFloat16(RANDOM4_VAR.floatValue() * RANDOM5_VAR.floatValue()),\n+                     \"testRounding2 case3a\");\n+        assertResult(dst[2], float16ToRawShortBits(multiply(RANDOM4_VAR, RANDOM5_VAR)), \"testRounding2 cast3b\");\n+\n+        assertResult(dst[3], Float.floatToFloat16((float)Math.sqrt(RANDOM2_VAR.floatValue())), \"testRounding2 case4a\");\n+        assertResult(dst[3], float16ToRawShortBits(sqrt(RANDOM2_VAR)), \"testRounding2 case4a\");\n+\n+        assertResult(dst[4], Float.floatToFloat16(Math.fma(RANDOM3_VAR.floatValue(), RANDOM4_VAR.floatValue(),\n+                     RANDOM5_VAR.floatValue())), \"testRounding2 case5a\");\n+        assertResult(dst[4], float16ToRawShortBits(fma(RANDOM3_VAR, RANDOM4_VAR, RANDOM5_VAR)), \"testRounding2 case5b\");\n+\n+        assertResult(dst[5], Float.floatToFloat16(RANDOM5_VAR.floatValue() \/ RANDOM4_VAR.floatValue()),\n+                     \"testRounding2 case6a\");\n+        assertResult(dst[5], float16ToRawShortBits(divide(RANDOM5_VAR, RANDOM4_VAR)), \"testRounding2 case6b\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestFloat16ScalarOperations.java","additions":585,"deletions":0,"binary":false,"changes":585,"status":"added"},{"patch":"@@ -212,0 +212,5 @@\n+    public static final String ADD_F = PREFIX + \"ADD_F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ADD_F, \"AddF\");\n+    }\n+\n@@ -222,0 +227,5 @@\n+    public static final String ADD_HF = PREFIX + \"ADD_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ADD_HF, \"AddHF\");\n+    }\n+\n@@ -531,0 +541,5 @@\n+    public static final String CONV_F2HF = PREFIX + \"CONV_F2HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CONV_F2HF, \"ConvF2HF\");\n+    }\n+\n@@ -541,0 +556,5 @@\n+    public static final String CONV_HF2F = PREFIX + \"CONV_HF2F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CONV_HF2F, \"ConvHF2F\");\n+    }\n+\n@@ -655,0 +675,5 @@\n+    public static final String FMA_HF = PREFIX + \"FMA_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(FMA_HF, \"FmaHF\");\n+    }\n+\n@@ -1157,0 +1182,10 @@\n+    public static final String MIN_HF = PREFIX + \"MIN_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MIN_HF, \"MinHF\");\n+    }\n+\n+    public static final String MAX_HF = PREFIX + \"MAX_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MAX_HF, \"MaxHF\");\n+    }\n+\n@@ -1238,0 +1273,5 @@\n+    public static final String MUL_HF = PREFIX + \"MUL_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_HF, \"MulHF\");\n+    }\n+\n@@ -1438,0 +1478,10 @@\n+    public static final String REINTERPRET_S2HF = PREFIX + \"REINTERPRET_S2HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(REINTERPRET_S2HF, \"ReinterpretS2HF\");\n+    }\n+\n+    public static final String REINTERPRET_HF2S = PREFIX + \"REINTERPRET_HF2S\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(REINTERPRET_HF2S, \"ReinterpretHF2S\");\n+    }\n+\n@@ -1604,0 +1654,10 @@\n+    public static final String SQRT_HF = PREFIX + \"SQRT_HF\" + POSTFIX;\n+    static {\n+       beforeMatchingNameRegex(SQRT_HF, \"SqrtHF\");\n+    }\n+\n+    public static final String SQRT_F = PREFIX + \"SQRT_F\" + POSTFIX;\n+    static {\n+       beforeMatchingNameRegex(SQRT_F, \"SqrtF\");\n+    }\n+\n@@ -1745,0 +1805,5 @@\n+    public static final String SUB_HF = PREFIX + \"SUB_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(SUB_HF, \"SubHF\");\n+    }\n+\n@@ -1795,0 +1860,5 @@\n+    public static final String DIV_HF = PREFIX + \"DIV_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(DIV_HF, \"DivHF\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,0 +105,1 @@\n+        \"avx512_fp16\",\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,6 @@\n-    @IR(applyIfCPUFeatureOr = {\"f16c\", \"true\", \"avx512vl\", \"true\", \"zvfh\", \"true\"}, counts = {IRNode.VECTOR_CAST_HF2F, IRNode.VECTOR_SIZE_ANY, \">= 1\", IRNode.VECTOR_CAST_F2HF, IRNode.VECTOR_SIZE_ANY, \" >= 1\"})\n+    @IR(applyIfCPUFeatureAnd = {\"avx512_fp16\", \"false\", \"avx512vl\", \"true\"},\n+        counts = {IRNode.VECTOR_CAST_HF2F, IRNode.VECTOR_SIZE_ANY, \">= 1\", IRNode.VECTOR_CAST_F2HF, IRNode.VECTOR_SIZE_ANY, \" >= 1\"})\n+    @IR(applyIfCPUFeatureAnd = {\"avx512_fp16\", \"false\", \"f16c\", \"true\"},\n+        counts = {IRNode.VECTOR_CAST_HF2F, IRNode.VECTOR_SIZE_ANY, \">= 1\", IRNode.VECTOR_CAST_F2HF, IRNode.VECTOR_SIZE_ANY, \" >= 1\"})\n+    @IR(applyIfCPUFeature = {\"zvfh\", \"true\"},\n+        counts = {IRNode.VECTOR_CAST_HF2F, IRNode.VECTOR_SIZE_ANY, \">= 1\", IRNode.VECTOR_CAST_F2HF, IRNode.VECTOR_SIZE_ANY, \" >= 1\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloat16VectorConvChain.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,347 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8342103\n+ * @summary C2 compiler support for Float16 type and associated operations\n+ * @modules jdk.incubator.vector\n+ * @library \/test\/lib\n+ * @compile ScalarFloat16OperationsTest.java\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation -XX:-UseSuperWord ScalarFloat16OperationsTest\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation -XX:+UseSuperWord ScalarFloat16OperationsTest\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.util.Random;\n+import java.util.stream.IntStream;\n+import jdk.incubator.vector.Float16;\n+import static jdk.incubator.vector.Float16.*;\n+\n+public class ScalarFloat16OperationsTest {\n+    static final int SIZE = 65504;\n+    static Random r = jdk.test.lib.Utils.getRandomInstance();\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+    @DataProvider\n+    public static Object[][] unaryOpProvider() {\n+        Float16 [] input = new Float16[SIZE];\n+        Float16 [] special_input = {\n+            Float16.MAX_VALUE, Float16.MIN_VALUE, Float16.MIN_NORMAL, Float16.POSITIVE_INFINITY,\n+            Float16.NEGATIVE_INFINITY, Float16.valueOf(0.0f), Float16.valueOf(-0.0f), Float16.NaN\n+        };\n+\n+        \/\/ Input array covers entire Float16 value range\n+        IntStream.range(0, input.length).forEach(i -> {input[i] = valueOf(i);});\n+\n+        return new Object[][] {\n+            {input},\n+            {special_input}\n+        };\n+    }\n+\n+    @DataProvider\n+    public static Object[][] binaryOpProvider() {\n+        Float16 [] input1 = new Float16[SIZE];\n+        Float16 [] input2 = new Float16[SIZE];\n+        Float16 [] special_input = {\n+            Float16.MAX_VALUE, Float16.MIN_VALUE, Float16.MIN_NORMAL, Float16.POSITIVE_INFINITY,\n+            Float16.NEGATIVE_INFINITY, Float16.valueOf(0.0f), Float16.valueOf(-0.0f), Float16.NaN\n+        };\n+\n+        \/\/ Input arrays covers entire Float16 value range interspersed with special values.\n+        IntStream.range(0, input1.length).forEach(i -> {input1[i] = valueOf(i);});\n+        IntStream.range(0, input2.length).forEach(i -> {input2[i] = valueOf(i);});\n+\n+        for (int i = 0; i < special_input.length; i += 256) {\n+            input1[r.nextInt(input1.length)] = special_input[i];\n+            input2[r.nextInt(input2.length)] = special_input[i];\n+        }\n+\n+        return new Object[][] {\n+            {input1, input2},\n+            {special_input, special_input},\n+        };\n+    }\n+\n+    @DataProvider\n+    public static Object[][] ternaryOpProvider() {\n+        Float16 [] input1 = new Float16[SIZE];\n+        Float16 [] input2 = new Float16[SIZE];\n+        Float16 [] input3 = new Float16[SIZE];\n+        Float16 [] special_input = {\n+            Float16.MAX_VALUE, Float16.MIN_VALUE, Float16.MIN_NORMAL, Float16.POSITIVE_INFINITY,\n+            Float16.NEGATIVE_INFINITY, Float16.valueOf(0.0f), Float16.valueOf(-0.0f), Float16.NaN\n+        };\n+\n+        \/\/ Input arrays covers entire Float16 value range interspersed with special values.\n+        IntStream.range(0, input1.length).forEach(i -> {input1[i] = valueOf(i);});\n+        IntStream.range(0, input2.length).forEach(i -> {input2[i] = valueOf(i);});\n+        IntStream.range(0, input3.length).forEach(i -> {input3[i] = valueOf(i);});\n+        for (int i = 0; i < special_input.length; i += 256) {\n+            input1[r.nextInt(input1.length)] = special_input[i];\n+            input2[r.nextInt(input2.length)] = special_input[i];\n+            input3[r.nextInt(input3.length)] = special_input[i];\n+        }\n+\n+        return new Object[][] {\n+            {input1, input2, input3},\n+            {special_input, special_input, special_input},\n+        };\n+    }\n+\n+    interface FUnOp1 {\n+        Float16 apply(Float16 a);\n+    }\n+\n+    interface FUnOp2 {\n+        boolean apply(Float16 a);\n+    }\n+\n+    static void assertArraysEquals(Float16[] r, Float16[] a, FUnOp1 f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, Float16[] a, FUnOp2 f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FBinOp {\n+        Float16 apply(Float16 a, Float16 b);\n+    }\n+\n+    static void assertArraysEquals(Float16[] r, Float16[] a, Float16[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i]);\n+        }\n+    }\n+\n+    interface FTernOp {\n+        Float16 apply(Float16 a, Float16 b, Float16 c);\n+    }\n+\n+    static void assertArraysEquals(Float16[] r, Float16[] a, Float16[] b, Float16[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"unaryOpProvider\")\n+    public static void absTest(Object input) {\n+        Float16 [] farr =  (Float16[])input;\n+        Float16 [] res  = new Float16[farr.length];\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = abs(farr[i]);\n+            }\n+        }\n+        assertArraysEquals(res, farr, (fp16) -> valueOf(Math.abs(fp16.floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"unaryOpProvider\")\n+    public static void negTest(Object input) {\n+        Float16 [] farr =  (Float16[])input;\n+        Float16 [] res  = new Float16[farr.length];\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = negate(farr[i]);\n+            }\n+        }\n+        assertArraysEquals(res, farr, (fp16) -> shortBitsToFloat16((short)(float16ToRawShortBits(fp16) ^ (short)0x0000_8000)));\n+    }\n+\n+    @Test(dataProvider = \"unaryOpProvider\")\n+    public static void sqrtTest(Object input) {\n+        Float16 [] farr =  (Float16[])input;\n+        Float16 [] res  = new Float16[farr.length];\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = sqrt(farr[i]);\n+            }\n+        }\n+        assertArraysEquals(res, farr, (fp16) -> valueOf(Math.sqrt(fp16.floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"unaryOpProvider\")\n+    public static void isInfiniteTest(Object input) {\n+        Float16 [] farr =  (Float16[])input;\n+        boolean [] res  = new boolean[farr.length];\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = isInfinite(farr[i]);\n+            }\n+        }\n+        assertArraysEquals(res, farr, (fp16) -> Float.isInfinite(fp16.floatValue()));\n+    }\n+\n+    @Test(dataProvider = \"unaryOpProvider\")\n+    public static void isFiniteTest(Object input) {\n+        Float16 [] farr =  (Float16[])input;\n+        boolean [] res  = new boolean[farr.length];\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = isFinite(farr[i]);\n+            }\n+        }\n+        assertArraysEquals(res, farr, (fp16) -> Float.isFinite(fp16.floatValue()));\n+    }\n+\n+    @Test(dataProvider = \"unaryOpProvider\")\n+    public static void isNaNTest(Object input) {\n+        Float16 [] farr =  (Float16[])input;\n+        boolean [] res  = new boolean[farr.length];\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = isNaN(farr[i]);\n+            }\n+        }\n+        assertArraysEquals(res, farr, (fp16) -> Float.isNaN(fp16.floatValue()));\n+    }\n+\n+    @Test(dataProvider = \"binaryOpProvider\")\n+    public static void addTest(Object input1, Object input2) {\n+        Float16 [] farr1 =  (Float16[])input1;\n+        Float16 [] farr2 =  (Float16[])input2;\n+\n+        Float16 [] res  = new Float16[farr1.length];\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = add(farr1[i], farr2[i]);\n+            }\n+        }\n+        assertArraysEquals(res, farr1, farr2, (fp16_val1, fp16_val2) -> valueOf(fp16_val1.floatValue() + fp16_val2.floatValue()));\n+    }\n+\n+    @Test(dataProvider = \"binaryOpProvider\")\n+    public static void subtractTest(Object input1, Object input2) {\n+        Float16 [] farr1 =  (Float16[])input1;\n+        Float16 [] farr2 =  (Float16[])input2;\n+\n+        Float16 [] res  = new Float16[farr1.length];\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = subtract(farr1[i], farr2[i]);\n+            }\n+        }\n+        assertArraysEquals(res, farr1, farr2, (fp16_val1, fp16_val2) -> valueOf(fp16_val1.floatValue() - fp16_val2.floatValue()));\n+    }\n+\n+    @Test(dataProvider = \"binaryOpProvider\")\n+    public static void multiplyTest(Object input1, Object input2) {\n+        Float16 [] farr1 =  (Float16[])input1;\n+        Float16 [] farr2 =  (Float16[])input2;\n+\n+        Float16 [] res  = new Float16[farr1.length];\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = multiply(farr1[i], farr2[i]);\n+            }\n+        }\n+        assertArraysEquals(res, farr1, farr2, (fp16_val1, fp16_val2) -> valueOf(fp16_val1.floatValue() * fp16_val2.floatValue()));\n+    }\n+\n+    @Test(dataProvider = \"binaryOpProvider\")\n+    public static void divideTest(Object input1, Object input2) {\n+        Float16 [] farr1 =  (Float16[])input1;\n+        Float16 [] farr2 =  (Float16[])input2;\n+\n+        Float16 [] res  = new Float16[farr1.length];\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = divide(farr1[i], farr2[i]);\n+            }\n+        }\n+        assertArraysEquals(res, farr1, farr2, (fp16_val1, fp16_val2) -> valueOf(fp16_val1.floatValue() \/ fp16_val2.floatValue()));\n+    }\n+\n+    @Test(dataProvider = \"binaryOpProvider\")\n+    public static void maxTest(Object input1, Object input2) {\n+        Float16 [] farr1 =  (Float16[])input1;\n+        Float16 [] farr2 =  (Float16[])input2;\n+\n+        Float16 [] res  = new Float16[farr1.length];\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = max(farr1[i], farr2[i]);\n+            }\n+        }\n+        assertArraysEquals(res, farr1, farr2,  (fp16_val1, fp16_val2) -> valueOf(Float.max(fp16_val1.floatValue(), fp16_val2.floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"binaryOpProvider\")\n+    public static void minTest(Object input1, Object input2) {\n+        Float16 [] farr1 =  (Float16[])input1;\n+        Float16 [] farr2 =  (Float16[])input2;\n+\n+        Float16 [] res  = new Float16[farr1.length];\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = min(farr1[i], farr2[i]);\n+            }\n+        }\n+        assertArraysEquals(res, farr1, farr2, (fp16_val1, fp16_val2) -> valueOf(Float.min(fp16_val1.floatValue(), fp16_val2.floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"ternaryOpProvider\")\n+    public static void fmaTest(Object input1, Object input2, Object input3) {\n+        Float16 [] farr1 =  (Float16[])input1;\n+        Float16 [] farr2 =  (Float16[])input2;\n+        Float16 [] farr3 =  (Float16[])input2;\n+\n+        Float16 [] res  = new Float16[farr1.length];\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = fma(farr1[i], farr2[i], farr3[i]);\n+            }\n+        }\n+        assertArraysEquals(res, farr1, farr2, farr3, (fp16_val1, fp16_val2, fp16_val3) -> valueOf(Math.fma(fp16_val1.floatValue(), fp16_val2.floatValue(), fp16_val3.floatValue())));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ScalarFloat16OperationsTest.java","additions":347,"deletions":0,"binary":false,"changes":347,"status":"added"},{"patch":"@@ -0,0 +1,296 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import java.util.stream.IntStream;\n+import java.util.concurrent.TimeUnit;\n+import jdk.incubator.vector.*;\n+import org.openjdk.jmh.annotations.*;\n+import static jdk.incubator.vector.Float16.*;\n+import static java.lang.Float.*;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Fork(jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\", \"-Xbatch\",  \"-XX:-TieredCompilation\"})\n+public class Float16OperationsBenchmark {\n+    @Param({\"256\", \"512\", \"1024\", \"2048\"})\n+    int vectorDim;\n+\n+    int   [] rexp;\n+    short [] vectorRes;\n+    short [] vector1;\n+    short [] vector2;\n+    short [] vector3;\n+    boolean [] vectorPredicate;\n+\n+    static final short f16_one = Float.floatToFloat16(1.0f);\n+    static final short f16_two = Float.floatToFloat16(2.0f);\n+\n+    @Setup(Level.Trial)\n+    public void BmSetup() {\n+        rexp      = new int[vectorDim];\n+        vectorRes = new short[vectorDim];\n+        vector1   = new short[vectorDim];\n+        vector2   = new short[vectorDim];\n+        vector3   = new short[vectorDim];\n+        vectorPredicate = new boolean[vectorDim];\n+\n+        IntStream.range(0, vectorDim).forEach(i -> {vector1[i] = Float.floatToFloat16((float)i);});\n+        IntStream.range(0, vectorDim).forEach(i -> {vector2[i] = Float.floatToFloat16((float)i);});\n+        IntStream.range(0, vectorDim).forEach(i -> {vector3[i] = Float.floatToFloat16((float)i);});\n+\n+        \/\/ Special Values\n+        Float16 [] specialValues = {Float16.NaN, Float16.NEGATIVE_INFINITY, Float16.valueOf(0.0), Float16.valueOf(-0.0), Float16.POSITIVE_INFINITY};\n+        IntStream.range(0, vectorDim).forEach(\n+            i -> {\n+                if ((i % 64) == 0) {\n+                    int idx1 = i % specialValues.length;\n+                    int idx2 = (i + 1) % specialValues.length;\n+                    int idx3 = (i + 2) % specialValues.length;\n+                    vector1[i] = float16ToRawShortBits(specialValues[idx1]);\n+                    vector2[i] = float16ToRawShortBits(specialValues[idx2]);\n+                    vector3[i] = float16ToRawShortBits(specialValues[idx3]);\n+                }\n+            }\n+        );\n+    }\n+\n+    @Benchmark\n+    public void addBenchmark() {\n+        for (int i = 0; i < vectorDim; i++) {\n+            vectorRes[i] = float16ToRawShortBits(add(shortBitsToFloat16(vector1[i]), shortBitsToFloat16(vector2[i])));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void subBenchmark() {\n+        for (int i = 0; i < vectorDim; i++) {\n+            vectorRes[i] = float16ToRawShortBits(subtract(shortBitsToFloat16(vector1[i]), shortBitsToFloat16(vector2[i])));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void mulBenchmark() {\n+        for (int i = 0; i < vectorDim; i++) {\n+            vectorRes[i] = float16ToRawShortBits(multiply(shortBitsToFloat16(vector1[i]), shortBitsToFloat16(vector2[i])));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void divBenchmark() {\n+        for (int i = 0; i < vectorDim; i++) {\n+            vectorRes[i] = float16ToRawShortBits(divide(shortBitsToFloat16(vector1[i]), shortBitsToFloat16(vector2[i])));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fmaBenchmark() {\n+        for (int i = 0; i < vectorDim; i++) {\n+            vectorRes[i] = float16ToRawShortBits(fma(shortBitsToFloat16(vector1[i]), shortBitsToFloat16(vector2[i]), shortBitsToFloat16(vector3[i])));\n+        }\n+    }\n+\n+    @Benchmark\n+    public boolean isInfiniteBenchmark() {\n+        boolean res = true;\n+        for (int i = 0; i < vectorDim; i++) {\n+            res &= isInfinite(shortBitsToFloat16(vector1[i]));\n+        }\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean isFiniteBenchmark() {\n+        boolean res = true;\n+        for (int i = 0; i < vectorDim; i++) {\n+            res &= isFinite(shortBitsToFloat16(vector1[i]));\n+        }\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean isNaNBenchmark() {\n+        boolean res = true;\n+        for (int i = 0; i < vectorDim; i++) {\n+            res &= isNaN(shortBitsToFloat16(vector1[i]));\n+        }\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public void isNaNStoreBenchmark() {\n+        for (int i = 0; i < vectorDim; i++) {\n+            vectorPredicate[i] = Float16.isNaN(shortBitsToFloat16(vector1[i]));\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    public void isNaNCMovBenchmark() {\n+        for (int i = 0; i < vectorDim; i++) {\n+            vectorRes[i] = Float16.isNaN(shortBitsToFloat16(vector1[i])) ? f16_one : f16_two;\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    public void isInfiniteStoreBenchmark() {\n+        for (int i = 0; i < vectorDim; i++) {\n+            vectorPredicate[i] = Float16.isInfinite(shortBitsToFloat16(vector1[i]));\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    public void isInfiniteCMovBenchmark() {\n+        for (int i = 0; i < vectorDim; i++) {\n+            vectorRes[i] = Float16.isInfinite(shortBitsToFloat16(vector1[i])) ? f16_one : f16_two;\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    public void isFiniteStoreBenchmark() {\n+        for (int i = 0; i < vectorDim; i++) {\n+            vectorPredicate[i] = Float16.isFinite(shortBitsToFloat16(vector1[i]));\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    public void isFiniteCMovBenchmark() {\n+        for (int i = 0; i < vectorDim; i++) {\n+            vectorRes[i] = Float16.isFinite(shortBitsToFloat16(vector1[i])) ? f16_one : f16_two;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void maxBenchmark() {\n+        for (int i = 0; i < vectorDim; i++) {\n+            vectorRes[i] = float16ToRawShortBits(max(shortBitsToFloat16(vector1[i]), shortBitsToFloat16(vector2[i])));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void minBenchmark() {\n+        for (int i = 0; i < vectorDim; i++) {\n+            vectorRes[i] = float16ToRawShortBits(min(shortBitsToFloat16(vector1[i]), shortBitsToFloat16(vector2[i])));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void sqrtBenchmark() {\n+        for (int i = 0; i < vectorDim; i++) {\n+            vectorRes[i] = float16ToRawShortBits(sqrt(shortBitsToFloat16(vector1[i])));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void negateBenchmark() {\n+        for (int i = 0; i < vectorDim; i++) {\n+            vectorRes[i] = float16ToRawShortBits(negate(shortBitsToFloat16(vector1[i])));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void absBenchmark() {\n+        for (int i = 0; i < vectorDim; i++) {\n+            vectorRes[i] = float16ToRawShortBits(abs(shortBitsToFloat16(vector1[i])));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void getExponentBenchmark() {\n+        for (int i = 0; i < vectorDim; i++) {\n+            rexp[i] = getExponent(shortBitsToFloat16(vector1[i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    public short cosineSimilarityDoubleRoundingFP16() {\n+        short macRes = floatToFloat16(0.0f);\n+        short vector1Square = floatToFloat16(0.0f);\n+        short vector2Square = floatToFloat16(0.0f);\n+        for (int i = 0; i < vectorDim; i++) {\n+            \/\/ Explicit add and multiply operation ensures double rounding.\n+            Float16 vec1 = shortBitsToFloat16(vector1[i]);\n+            Float16 vec2 = shortBitsToFloat16(vector2[i]);\n+            macRes = float16ToRawShortBits(add(multiply(vec1, vec2), shortBitsToFloat16(macRes)));\n+            vector1Square = float16ToRawShortBits(add(multiply(vec1, vec1), shortBitsToFloat16(vector1Square)));\n+            vector2Square = float16ToRawShortBits(add(multiply(vec2, vec2), shortBitsToFloat16(vector2Square)));\n+        }\n+        return float16ToRawShortBits(divide(shortBitsToFloat16(macRes), add(shortBitsToFloat16(vector1Square), shortBitsToFloat16(vector2Square))));\n+    }\n+\n+    @Benchmark\n+    public short cosineSimilaritySingleRoundingFP16() {\n+        short macRes = floatToFloat16(0.0f);\n+        short vector1Square = floatToFloat16(0.0f);\n+        short vector2Square = floatToFloat16(0.0f);\n+        for (int i = 0; i < vectorDim; i++) {\n+            Float16 vec1 = shortBitsToFloat16(vector1[i]);\n+            Float16 vec2 = shortBitsToFloat16(vector2[i]);\n+            macRes = float16ToRawShortBits(fma(vec1, vec2, shortBitsToFloat16(macRes)));\n+            vector1Square = float16ToRawShortBits(fma(vec1, vec1, shortBitsToFloat16(vector1Square)));\n+            vector2Square = float16ToRawShortBits(fma(vec2, vec2, shortBitsToFloat16(vector2Square)));\n+        }\n+        return float16ToRawShortBits(divide(shortBitsToFloat16(macRes), add(shortBitsToFloat16(vector1Square), shortBitsToFloat16(vector2Square))));\n+    }\n+\n+    @Benchmark\n+    public short cosineSimilarityDequantizedFP16() {\n+        float macRes = 0.0f;\n+        float vector1Square = 0.0f;\n+        float vector2Square = 0.0f;\n+        for (int i = 0; i < vectorDim; i++) {\n+            float vec1 = float16ToFloat(vector1[i]);\n+            float vec2 = float16ToFloat(vector2[i]);\n+            macRes = Math.fma(vec1, vec2, macRes);\n+            vector1Square = Math.fma(vec1, vec1, vector1Square);\n+            vector2Square = Math.fma(vec2, vec2, vector2Square);\n+        }\n+        return floatToFloat16(macRes \/ (vector1Square + vector2Square));\n+    }\n+\n+    @Benchmark\n+    public short euclideanDistanceFP16() {\n+        short distRes = floatToFloat16(0.0f);\n+        short squareRes = floatToFloat16(0.0f);\n+        for (int i = 0; i < vectorDim; i++) {\n+            squareRes = float16ToRawShortBits(subtract(shortBitsToFloat16(vector1[i]), shortBitsToFloat16(vector2[i])));\n+            distRes = float16ToRawShortBits(fma(shortBitsToFloat16(squareRes), shortBitsToFloat16(squareRes), shortBitsToFloat16(distRes)));\n+        }\n+        return float16ToRawShortBits(sqrt(shortBitsToFloat16(distRes)));\n+    }\n+\n+    @Benchmark\n+    public short euclideanDistanceDequantizedFP16() {\n+        float distRes = 0.0f;\n+        float squareRes = 0.0f;\n+        for (int i = 0; i < vectorDim; i++) {\n+            squareRes = float16ToFloat(vector1[i]) - float16ToFloat(vector2[i]);\n+            distRes = distRes + squareRes * squareRes;\n+        }\n+        return float16ToRawShortBits(sqrt(shortBitsToFloat16(floatToFloat16(distRes))));\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/Float16OperationsBenchmark.java","additions":296,"deletions":0,"binary":false,"changes":296,"status":"added"}]}