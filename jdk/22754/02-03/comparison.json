{"files":[{"patch":"@@ -4199,0 +4199,1 @@\n+        strcmp(opType,\"DivHF\")==0 ||\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -328,2 +328,1 @@\n-        short hf = floatToFloat16(f);\n-        return new Float16(hf);\n+        return new Float16(floatToFloat16(f));\n@@ -1203,8 +1202,16 @@\n-        \/\/ Rounding path of sqrt(Float16 -> double) -> Float16 is fine\n-        \/\/ for preserving the correct final value. The conversion\n-        \/\/ Float16 -> double preserves the exact numerical value. The\n-        \/\/ conversion of double -> Float16 also benefits from the\n-        \/\/ 2p+2 property of IEEE 754 arithmetic.\n-        short res = Float16Math.sqrt(float16ToRawShortBits(radicand),\n-                      (f16) -> float16ToRawShortBits(valueOf(Math.sqrt(shortBitsToFloat16(f16).doubleValue()))));\n-        return shortBitsToFloat16(res);\n+        \/\/ Explicitly unbox float16 radicand as intrinsic expects\n+        \/\/ to receive short type arguments holding IEEE 754 binary16\n+        \/\/ value.\n+        short unboxed_radicand = float16ToRawShortBits(radicand);\n+        short retval = Float16Math.sqrt(unboxed_radicand,\n+            (f16) -> {\n+                \/\/ Rounding path of sqrt(Float16 -> double) -> Float16 is fine\n+                \/\/ for preserving the correct final value. The conversion\n+                \/\/ Float16 -> double preserves the exact numerical value. The\n+                \/\/ conversion of double -> Float16 also benefits from the\n+                \/\/ 2p+2 property of IEEE 754 arithmetic.\n+               double res = Math.sqrt(float16ToFloat(f16));\n+               return float16ToRawShortBits(valueOf(res));\n+            }\n+        );\n+        return shortBitsToFloat16(retval);\n@@ -1412,7 +1419,8 @@\n-        \/\/ product is numerically exact in float before the cast to\n-        \/\/ double; not necessary to widen to double before the\n-        \/\/ multiply.\n-        short fa = float16ToRawShortBits(a);\n-        short fb = float16ToRawShortBits(b);\n-        short fc = float16ToRawShortBits(c);\n-        short res = Float16Math.fma(fa, fb, fc,\n+        \/\/ Explicitly unbox float16 values as intrinsic expects\n+        \/\/ to receive short type arguments holding IEEE 754 binary16\n+        \/\/ values.\n+        short unboxed_a = float16ToRawShortBits(a);\n+        short unboxed_b = float16ToRawShortBits(b);\n+        short unboxed_c = float16ToRawShortBits(c);\n+\n+        short res = Float16Math.fma(unboxed_a, unboxed_b, unboxed_c,\n@@ -1420,0 +1428,3 @@\n+                    \/\/ product is numerically exact in float before the cast to\n+                    \/\/ double; not necessary to widen to double before the\n+                    \/\/ multiply.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float16.java","additions":28,"deletions":17,"binary":false,"changes":45,"status":"modified"}]}