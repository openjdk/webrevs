{"files":[{"patch":"@@ -123,1 +123,1 @@\n-        value = (initCoder == LATIN1)\n+        value = (isLatin1(coder))\n@@ -182,0 +182,1 @@\n+        byte coder = this.coder;\n@@ -183,2 +184,2 @@\n-            return isLatin1() ? StringLatin1.compareTo(val1, val2, count1, count2)\n-                              : StringUTF16.compareTo(val1, val2, count1, count2);\n+            return isLatin1(coder) ? StringLatin1.compareTo(val1, val2, count1, count2)\n+                    : StringUTF16.compareTo(val1, val2, count1, count2);\n@@ -186,2 +187,2 @@\n-        return isLatin1() ? StringLatin1.compareToUTF16(val1, val2, count1, count2)\n-                          : StringUTF16.compareToLatin1(val1, val2, count1, count2);\n+        return isLatin1(coder) ? StringLatin1.compareToUTF16(val1, val2, count1, count2)\n+                : StringUTF16.compareToLatin1(val1, val2, count1, count2);\n@@ -230,1 +231,1 @@\n-            ensureCapacityInternal(minimumCapacity);\n+            value = ensureCapacitySameCoder(value, coder, minimumCapacity);\n@@ -235,0 +236,22 @@\n+     * {@return true if the byte array should be replaced due to increased capacity or coder change}\n+     * <ul>\n+     *     <li>The new coder is the different than the old coder\n+     *     <li>The new length is greater than to the current length\n+     *     <li>The new length is negative, as it might have overflowed due to an increment\n+     * <\/ul>\n+     *\n+     * @param value       a byte array\n+     * @param coder       old coder\n+     * @param newCapacity new capacity in characters\n+     * @param newCoder    new coder\n+     *\/\n+    private static boolean needsNewBuffer(byte[] value, byte coder, int newCapacity, byte newCoder) {\n+        long newLength = (long) newCapacity << newCoder;\n+        return coder != newCoder || newLength > value.length || 0 > newLength;\n+    }\n+\n+\n+    \/**\n+     * {@return a buffer suitable for storing the bytes up to minimum capacity using the new coder}\n+     * If the coder matches and there is enough room, the same buffer is returned.\n+     * Otherwise, a new buffer is allocated and the string is copied or inflated to match the new coder.\n@@ -236,3 +259,2 @@\n-     * behaves like {@code ensureCapacity}, however it is never\n-     * synchronized.\n-     * If {@code minimumCapacity} is non positive due to numeric\n+     * behaves like {@code ensureCapacity}, however it is never synchronized.\n+     * If {@code minimumCapacity} is non-positive due to numeric\n@@ -240,0 +262,41 @@\n+     * @param value the current buffer\n+     * @param coder of the current buffer\n+     * @param count the count of chars in the current buffer\n+     * @param minimumCapacity the new minimum capacity\n+     * @param newCoder the desired new coder\n+     *\/\n+    private static byte[] ensureCapacityNewCoder(byte[] value, byte coder, int count,\n+                                                 int minimumCapacity, byte newCoder) {\n+        assert coder == newCoder || newCoder == UTF16 : \"bad new coder UTF16 -> LATIN1\";\n+        \/\/ overflow-conscious code\n+        int growth = minimumCapacity - (value.length >> coder);\n+        if (coder == newCoder) {\n+            if (growth > 0) {\n+                \/\/ copy all bytes to new larger buffer\n+                value = Arrays.copyOf(value,\n+                        newCapacity(value, newCoder, minimumCapacity) << newCoder);\n+            }\n+            return value;\n+        } else {\n+            \/\/ inflate (and grow if additional length is requested)\n+            \/\/ always growing might be better but it breaks current Capacity tests\n+            int newCap = (growth > 0)\n+                ? newCapacity(value, newCoder, minimumCapacity)\n+                : value.length;\n+            byte[] newValue = StringUTF16.newBytesFor(newCap);\n+            StringLatin1.inflate(value, 0, newValue, 0, count);\n+            return newValue;\n+        }\n+    }\n+\n+    \/**\n+     * {@return the value buffer sufficient to hold the minimumCapactity and a copy of the contents}\n+     * There is no change to the coder.\n+     * The current value buffer is returned if the size is already sufficient.\n+     * For positive values of {@code minimumCapacity}, this method\n+     * behaves like {@code ensureCapacity}, however it is never synchronized.\n+     * If {@code minimumCapacity} is non-positive due to numeric\n+     * overflow, this method throws {@code OutOfMemoryError}.\n+     * @param value the current buffer\n+     * @param coder of the current buffer\n+     * @param minimumCapacity the new minimum capacity\n@@ -241,1 +304,1 @@\n-    private void ensureCapacityInternal(int minimumCapacity) {\n+    private static byte[] ensureCapacitySameCoder(byte[] value, byte coder, int minimumCapacity) {\n@@ -246,1 +309,1 @@\n-                    newCapacity(minimumCapacity) << coder);\n+                    newCapacity(value, coder, minimumCapacity) << coder);\n@@ -248,0 +311,13 @@\n+        return value;\n+    }\n+\n+    \/**\n+     * Inflates the internal 8-bit latin1 storage to 16-bit <hi=0, low> pair storage.\n+     * @param value the current byte array buffer\n+     * @param count the number of latin1 characters to convert to UTF16\n+     * @return the new buffer, the caller is responsible for updates to the coder\n+     *\/\n+    private static byte[] inflateToUTF16(byte[] value, int count) {\n+        byte[] newValue = StringUTF16.newBytesFor(value.length);\n+        StringLatin1.inflate(value, 0, newValue, 0, count);\n+        return newValue;\n@@ -258,0 +334,2 @@\n+     * @param value the current buffer\n+     * @param coder of the current buffer\n@@ -262,1 +340,1 @@\n-    private int newCapacity(int minCapacity) {\n+    private static int newCapacity(byte[] value, byte coder, int minCapacity) {\n@@ -273,14 +351,0 @@\n-    \/**\n-     * If the coder is \"isLatin1\", this inflates the internal 8-bit storage\n-     * to 16-bit <hi=0, low> pair storage.\n-     *\/\n-    private void inflate() {\n-        if (!isLatin1()) {\n-            return;\n-        }\n-        byte[] buf = StringUTF16.newBytesFor(value.length);\n-        StringLatin1.inflate(value, 0, buf, 0, count);\n-        this.value = buf;\n-        this.coder = UTF16;\n-    }\n-\n@@ -330,1 +394,3 @@\n-        ensureCapacityInternal(newLength);\n+        byte coder = this.coder;\n+        int count = this.count;\n+        byte[] value = ensureCapacitySameCoder(this.value, coder, newLength);\n@@ -332,5 +398,1 @@\n-            if (isLatin1()) {\n-                StringLatin1.fillNull(value, count, newLength);\n-            } else {\n-                StringUTF16.fillNull(value, count, newLength);\n-            }\n+            Arrays.fill(value, count << coder, newLength << coder, (byte)0);\n@@ -340,1 +402,2 @@\n-        count = newLength;\n+        this.count = newLength;\n+        this.value = value;\n@@ -364,1 +427,1 @@\n-        \/\/ Ensure count is less than or equal to capacity (racy reads and writes can produce inconsistent values)\n+        \/\/ Count should be less than or equal to capacity (racy reads and writes can produce inconsistent values)\n@@ -367,1 +430,1 @@\n-        if (coder == LATIN1) {\n+        if (isLatin1(coder)) {\n@@ -395,0 +458,1 @@\n+        byte coder = this.coder;\n@@ -398,1 +462,1 @@\n-        if (isLatin1()) {\n+        if (isLatin1(coder)) {\n@@ -426,0 +490,2 @@\n+        byte coder = this.coder;\n+        int count = this.count;\n@@ -429,1 +495,1 @@\n-        if (isLatin1()) {\n+        if (isLatin1(coder)) {\n@@ -456,2 +522,5 @@\n-        Preconditions.checkFromToIndex(beginIndex, endIndex, length(), null);\n-        if (isLatin1()) {\n+        byte coder = this.coder;\n+        int count = this.count;\n+        byte[] value = this.value;\n+        Preconditions.checkFromToIndex(beginIndex, endIndex, count, null);\n+        if (isLatin1(coder)) {\n@@ -523,1 +592,1 @@\n-        if (isLatin1()) {\n+        if (isLatin1(coder)) {\n@@ -545,0 +614,2 @@\n+        byte coder = this.coder;\n+        int count = this.count;\n@@ -546,1 +617,7 @@\n-        if (isLatin1() && StringLatin1.canEncode(ch)) {\n+        byte[] value  = this.value;\n+        byte newCoder = (byte)(coder | StringLatin1.coderFromChar(ch));\n+        if (needsNewBuffer(value, coder, count, newCoder)) {\n+            this.value = value = ensureCapacityNewCoder(value, coder, count, count, newCoder);\n+            this.coder = coder = newCoder;\n+        }\n+        if (isLatin1(coder)) {\n@@ -549,4 +626,1 @@\n-            if (isLatin1()) {\n-                inflate();\n-            }\n-            StringUTF16.putCharSB(value, index, ch);\n+            StringUTF16.putChar(value, index, ch);\n@@ -594,0 +668,3 @@\n+        byte coder = this.coder;\n+        int count = this.count;\n+        byte[] value = this.value;\n@@ -595,3 +672,7 @@\n-        ensureCapacityInternal(count + len);\n-        putStringAt(count, str);\n-        count += len;\n+        byte newCoder = (byte)(coder | str.coder());\n+        if (needsNewBuffer(value, coder, count + len, newCoder)) {\n+            this.value = value = ensureCapacityNewCoder(value, coder, count, count + len, newCoder);\n+            this.coder = newCoder;\n+        }\n+        str.getBytes(value, count, newCoder);\n+        this.count = count + len;\n@@ -619,4 +700,10 @@\n-        ensureCapacityInternal(count + len);\n-        inflateIfNeededFor(asb);\n-        asb.getBytes(value, count, coder);\n-        count += len;\n+        byte coder = this.coder;\n+        int count = this.count;\n+        byte[] value = this.value;\n+        byte newCoder = (byte)(coder | asb.coder);\n+        if (needsNewBuffer(value, coder, count + len, newCoder)) {\n+            this.value = value = ensureCapacityNewCoder(value, coder, count, count + len, newCoder);\n+            this.coder = newCoder;\n+        }\n+        asb.getBytes(value, count, newCoder);\n+        this.count = count + len;\n@@ -633,2 +720,2 @@\n-        if (s instanceof String) {\n-            return this.append((String)s);\n+        if (s instanceof String str) {\n+            return this.append(str);\n@@ -636,2 +723,2 @@\n-        if (s instanceof AbstractStringBuilder) {\n-            return this.append((AbstractStringBuilder)s);\n+        if (s instanceof AbstractStringBuilder asb) {\n+            return this.append(asb);\n@@ -643,1 +730,1 @@\n-        ensureCapacityInternal(count + 4);\n+        byte coder = this.coder;\n@@ -645,10 +732,8 @@\n-        byte[] val = this.value;\n-        if (isLatin1()) {\n-            val[count++] = 'n';\n-            val[count++] = 'u';\n-            val[count++] = 'l';\n-            val[count++] = 'l';\n-        } else {\n-            count = StringUTF16.putCharsAt(val, count, 'n', 'u', 'l', 'l');\n-        }\n-        this.count = count;\n+        int newCount = count + 4;\n+        byte[] value = ensureCapacitySameCoder(this.value, coder, newCount);\n+        if (isLatin1(coder))\n+            StringLatin1.putCharsAt(value, count, 'n', 'u', 'l', 'l');\n+        else\n+            StringUTF16.putCharsAt(value, count, 'n', 'u', 'l', 'l');\n+        this.count = newCount;\n+        this.value = value;\n@@ -698,5 +783,8 @@\n-        ensureCapacityInternal(count + len);\n-        if (s instanceof String) {\n-            appendChars((String)s, start, end);\n-        } else {\n-            appendChars(s, start, end);\n+        byte coder = this.coder;\n+        int count = this.count;\n+        byte[] currValue = ensureCapacitySameCoder(this.value, coder, count + len);\n+        byte[] value = (s instanceof String str)\n+            ? appendChars(currValue, coder, count, str, start, end)\n+            : appendChars(currValue, coder, count, s, start, end);\n+        if (currValue != value) {\n+            this.coder = UTF16;\n@@ -704,0 +792,2 @@\n+        this.count = count + len;\n+        this.value = value;\n@@ -726,2 +816,9 @@\n-        ensureCapacityInternal(count + len);\n-        appendChars(str, 0, len);\n+        byte coder = this.coder;\n+        int count = this.count;\n+        byte[] currValue = ensureCapacitySameCoder(this.value, coder, count + len);\n+        byte[] value = appendChars(currValue, coder, count, str, 0, len);\n+        if (currValue != value) {\n+            this.coder = UTF16;\n+        }\n+        this.count = count + len;\n+        this.value = value;\n@@ -756,2 +853,9 @@\n-        ensureCapacityInternal(count + len);\n-        appendChars(str, offset, end);\n+        byte coder = this.coder;\n+        int count = this.count;\n+        byte[] currValue = ensureCapacitySameCoder(value, coder, count + len);\n+        byte[] value = appendChars(currValue, coder, count, str, offset, end);\n+        if (currValue != value) {\n+            this.coder = UTF16;\n+        }\n+        this.count = count + len;\n+        this.value = value;\n@@ -774,1 +878,1 @@\n-        ensureCapacityInternal(count + (b ? 4 : 5));\n+        byte coder = this.coder;\n@@ -776,14 +880,8 @@\n-        byte[] val = this.value;\n-        if (isLatin1()) {\n-            if (b) {\n-                val[count++] = 't';\n-                val[count++] = 'r';\n-                val[count++] = 'u';\n-                val[count++] = 'e';\n-            } else {\n-                val[count++] = 'f';\n-                val[count++] = 'a';\n-                val[count++] = 'l';\n-                val[count++] = 's';\n-                val[count++] = 'e';\n-            }\n+\n+        int newCount = count + (b ? 4 : 5);\n+        byte[] value = ensureCapacitySameCoder(this.value, coder, newCount);\n+        if (b) {\n+            if (isLatin1(coder))\n+                StringLatin1.putCharsAt(value, count, 't', 'r', 'u', 'e');\n+            else\n+                StringUTF16.putCharsAt(value, count, 't', 'r', 'u', 'e');\n@@ -791,5 +889,4 @@\n-            if (b) {\n-                count = StringUTF16.putCharsAt(val, count, 't', 'r', 'u', 'e');\n-            } else {\n-                count = StringUTF16.putCharsAt(val, count, 'f', 'a', 'l', 's', 'e');\n-            }\n+            if (isLatin1(coder))\n+                StringLatin1.putCharsAt(value, count, 'f', 'a', 'l', 's', 'e');\n+            else\n+                StringUTF16.putCharsAt(value, count, 'f', 'a', 'l', 's', 'e');\n@@ -797,1 +894,2 @@\n-        this.count = count;\n+        this.value = value;\n+        this.count = newCount;\n@@ -818,2 +916,9 @@\n-        ensureCapacityInternal(count + 1);\n-        if (isLatin1() && StringLatin1.canEncode(c)) {\n+        byte coder = this.coder;\n+        int count = this.count;\n+        byte[] value = this.value;\n+        byte newCoder = (byte) (coder | StringLatin1.coderFromChar(c));\n+        if (needsNewBuffer(value, coder, count + 1, newCoder)) {\n+            this.value = value = ensureCapacityNewCoder(value, coder, count, count + 1, newCoder);\n+            this.coder = coder = newCoder;\n+        }\n+        if (isLatin1(coder)) {\n@@ -822,4 +927,1 @@\n-            if (isLatin1()) {\n-                inflate();\n-            }\n-            StringUTF16.putCharSB(value, count++, c);\n+            StringUTF16.putChar(value, count++, c);\n@@ -827,0 +929,1 @@\n+        this.count = count;\n@@ -843,0 +946,1 @@\n+        byte coder = this.coder;\n@@ -845,2 +949,2 @@\n-        ensureCapacityInternal(spaceNeeded);\n-        if (isLatin1()) {\n+        byte[] value = ensureCapacitySameCoder(this.value, coder, spaceNeeded);\n+        if (isLatin1(coder)) {\n@@ -851,0 +955,1 @@\n+        this.value = value;\n@@ -868,0 +973,1 @@\n+        byte coder = this.coder;\n@@ -870,2 +976,2 @@\n-        ensureCapacityInternal(spaceNeeded);\n-        if (isLatin1()) {\n+        byte[] value = ensureCapacitySameCoder(this.value, coder, spaceNeeded);\n+        if (isLatin1(coder)) {\n@@ -876,0 +982,1 @@\n+        this.value = value;\n@@ -893,3 +1000,6 @@\n-        ensureCapacityInternal(count + FloatToDecimal.MAX_CHARS);\n-        FloatToDecimal toDecimal = isLatin1() ? FloatToDecimal.LATIN1 : FloatToDecimal.UTF16;\n-        count = toDecimal.putDecimal(value, count, f);\n+        byte coder = this.coder;\n+        int count = this.count;\n+        byte[] value = ensureCapacitySameCoder(this.value, coder,count + FloatToDecimal.MAX_CHARS);\n+        FloatToDecimal toDecimal = isLatin1(coder) ? FloatToDecimal.LATIN1 : FloatToDecimal.UTF16;\n+        this.count = toDecimal.putDecimal(value, count, f);\n+        this.value = value;\n@@ -912,3 +1022,6 @@\n-        ensureCapacityInternal(count + DoubleToDecimal.MAX_CHARS);\n-        DoubleToDecimal toDecimal = isLatin1() ? DoubleToDecimal.LATIN1 : DoubleToDecimal.UTF16;\n-        count = toDecimal.putDecimal(value, count, d);\n+        byte coder = this.coder;\n+        int count = this.count;\n+        byte[] value = ensureCapacitySameCoder(this.value, coder,count + DoubleToDecimal.MAX_CHARS);\n+        DoubleToDecimal toDecimal = isLatin1(coder) ? DoubleToDecimal.LATIN1 : DoubleToDecimal.UTF16;\n+        this.count = toDecimal.putDecimal(value, count, d);\n+        this.value = value;\n@@ -940,1 +1053,1 @@\n-            shift(end, -len);\n+            shift(value, coder, count, end, -len);\n@@ -991,0 +1104,1 @@\n+        int count = this.count;\n@@ -992,2 +1106,2 @@\n-        shift(index + 1, -1);\n-        count--;\n+        shift(value, coder, count, index + 1, -1);\n+        this.count = count - 1;\n@@ -1018,0 +1132,1 @@\n+        byte coder = this.coder;\n@@ -1025,2 +1140,8 @@\n-        ensureCapacityInternal(newCount);\n-        shift(end, newCount - count);\n+        byte newCoder = (byte) (coder | str.coder());\n+        byte[] value = this.value;\n+        if (needsNewBuffer(value, coder, newCount, newCoder) ) {\n+            this.value = value = ensureCapacityNewCoder(value, coder, count, newCount, newCoder);\n+            this.coder = coder = newCoder;\n+        }\n+        shift(value, coder, count, end, newCount - count);\n+        str.getBytes(value, start, coder);\n@@ -1028,1 +1149,0 @@\n-        putStringAt(start, str);\n@@ -1094,1 +1214,1 @@\n-        if (isLatin1()) {\n+        if (isLatin1(coder)) {\n@@ -1100,1 +1220,1 @@\n-    private void shift(int offset, int n) {\n+    private static void shift(byte[] value, byte coder, int count, int offset, int n) {\n@@ -1129,0 +1249,2 @@\n+        byte coder = this.coder;\n+        int count = this.count;\n@@ -1131,2 +1253,2 @@\n-        ensureCapacityInternal(count + len);\n-        shift(index, len);\n+        byte[] value = ensureCapacitySameCoder(this.value, coder, count + len);\n+        shift(value, coder, count, index, len);\n@@ -1134,1 +1256,6 @@\n-        putCharsAt(index, str, offset, offset + len);\n+        byte[] newValue = putCharsAt(value, coder, count, index, str, offset, offset + len);\n+        if  (newValue != value) {\n+            this.coder = UTF16;\n+        }\n+        this.value = newValue;\n+        this.count = count;\n@@ -1193,0 +1320,2 @@\n+        byte coder = this.coder;\n+        int count = this.count;\n@@ -1198,4 +1327,9 @@\n-        ensureCapacityInternal(count + len);\n-        shift(offset, len);\n-        count += len;\n-        putStringAt(offset, str);\n+        byte newCoder = (byte) (coder | str.coder());\n+        byte[] value = this.value;\n+        if (needsNewBuffer(value, coder, count + len, newCoder)) {\n+            this.value = value = ensureCapacityNewCoder(value, coder, count, count + len, newCoder);\n+            this.coder = coder = newCoder;\n+        }\n+        shift(value, coder, count, offset, len);\n+        this.count = count + len;\n+        str.getBytes(value, offset, coder);\n@@ -1230,0 +1364,2 @@\n+        byte coder = this.coder;\n+        int count = this.count;\n@@ -1232,2 +1368,2 @@\n-        ensureCapacityInternal(count + len);\n-        shift(offset, len);\n+        byte[] currValue = ensureCapacitySameCoder(this.value, coder, count + len);\n+        shift(currValue, coder, count, offset, len);\n@@ -1235,1 +1371,6 @@\n-        putCharsAt(offset, str, 0, len);\n+        byte[] newValue = putCharsAt(currValue, coder, count, offset, str, 0, len);\n+        if (currValue != newValue) {\n+            this.coder = UTF16;\n+        }\n+        this.count = count;\n+        this.value = newValue;\n@@ -1295,1 +1436,1 @@\n-     * <p>The start argument must be nonnegative, and not greater than\n+     * <p>The start argument must be non-negative, and not greater than\n@@ -1325,0 +1466,2 @@\n+        byte coder = this.coder;\n+        int count = this.count;\n@@ -1328,2 +1471,2 @@\n-        ensureCapacityInternal(count + len);\n-        shift(dstOffset, len);\n+        byte[] currValue = ensureCapacitySameCoder(this.value, coder, count + len);\n+        shift(currValue, coder, count, dstOffset, len);\n@@ -1331,4 +1474,6 @@\n-        if (s instanceof String) {\n-            putStringAt(dstOffset, (String) s, start, end);\n-        } else {\n-            putCharsAt(dstOffset, s, start, end);\n+        \/\/ Coder of CharSequence may be a mismatch, requiring the value array to be inflated\n+        byte[] newValue = (s instanceof String str)\n+            ? putStringAt(currValue, coder, count, dstOffset, str, start, end)\n+            : putCharsAt(currValue, coder, count, dstOffset, s, start, end);\n+        if (currValue != newValue) {\n+            this.coder = UTF16;\n@@ -1336,0 +1481,2 @@\n+        this.value = newValue;\n+        this.count = count;\n@@ -1382,0 +1529,2 @@\n+        byte coder = this.coder;\n+        int count = this.count;\n@@ -1383,4 +1532,9 @@\n-        ensureCapacityInternal(count + 1);\n-        shift(offset, 1);\n-        count += 1;\n-        if (isLatin1() && StringLatin1.canEncode(c)) {\n+        byte newCoder = (byte)(coder | StringLatin1.coderFromChar(c));\n+        byte[] value = this.value;\n+\n+        if (needsNewBuffer(value, coder, count + 1, newCoder)) {\n+            this.value = value = ensureCapacityNewCoder(value, coder, count, count + 1, newCoder);\n+            this.coder = coder = newCoder;\n+        }\n+        shift(value, coder, count, offset, 1);\n+        if (isLatin1(coder)) {\n@@ -1389,3 +1543,0 @@\n-            if (isLatin1()) {\n-                inflate();\n-            }\n@@ -1394,0 +1545,1 @@\n+        this.count = count + 1;\n@@ -1594,1 +1746,1 @@\n-        if (isLatin1()) {\n+        if (isLatin1(this.coder)) {\n@@ -1659,1 +1811,1 @@\n-                    return coder == LATIN1\n+                    return isLatin1(coder)\n@@ -1705,0 +1857,1 @@\n+    \/\/ Package access for String and StringBuffer.\n@@ -1706,0 +1859,4 @@\n+        return isLatin1(coder);\n+    }\n+\n+    private static boolean isLatin1(byte coder) {\n@@ -1709,4 +1866,18 @@\n-    private final void putCharsAt(int index, char[] s, int off, int end) {\n-        if (isLatin1()) {\n-            byte[] val = this.value;\n-            for (int i = off, j = index; i < end; i++) {\n+    \/**\n+     * {@return Return the buffer containing the composed string and inserted characters}\n+     * If the buffer coder needs to support UTF16 and does not, it is inflated and a different\n+     * buffer is returned. The caller is responsible for setting the coder and updating the value ref\n+     * based solely on the difference in the buffer reference.\n+     *\n+     * @param value byte array destination for the string (if the coder matches)\n+     * @param coder the original buffer coder\n+     * @param count the count of characters in the original buffer\n+     * @param index the insertion point\n+     * @param s char[] array to insert from\n+     * @param off offset of the first character\n+     * @param end the offset of the last character (exclusive)\n+     *\/\n+    private static byte[] putCharsAt(byte[] value, byte coder, int count, int index, char[] s, int off, int end) {\n+        if (isLatin1(coder)) {\n+            int latin1Len = StringUTF16.compress(s, off, value, index, end - off);\n+            for (int i = off + latin1Len, j = index + latin1Len; i < end; i++) {\n@@ -1715,1 +1886,1 @@\n-                    val[j++] = (byte)c;\n+                    value[j++] = (byte)c;\n@@ -1717,3 +1888,6 @@\n-                    inflate();\n-                    StringUTF16.putCharsSB(this.value, j, s, i, end);\n-                    return;\n+                    value = inflateToUTF16(value, count);\n+                    \/\/ Store c to make sure sb has a UTF16 char\n+                    StringUTF16.putCharSB(value, j++, c);\n+                    i++;\n+                    StringUTF16.putCharsSB(value, j, s, i, end);\n+                    return value;\n@@ -1723,1 +1897,1 @@\n-            StringUTF16.putCharsSB(this.value, index, s, off, end);\n+            StringUTF16.putCharsSB(value, index, s, off, end);\n@@ -1725,0 +1899,1 @@\n+        return value;\n@@ -1727,3 +1902,16 @@\n-    private final void putCharsAt(int index, CharSequence s, int off, int end) {\n-        if (isLatin1()) {\n-            byte[] val = this.value;\n+    \/**\n+     * {@return Return the buffer containing the composed string and inserted characters}\n+     * If the buffer coder needs to support UTF16 and does not, it is inflated and a different\n+     * buffer is returned. The caller is responsible for setting the coder and updating the value ref\n+     * based solely on the difference in the buffer reference.\n+     *\n+     * @param value byte array destination for the string (if the coder matches)\n+     * @param coder the original buffer coder\n+     * @param count the count of characters in the original buffer\n+     * @param index the insertion point\n+     * @param s char[] array to insert from\n+     * @param off offset of the first character\n+     * @param end the offset of the last character (exclusive)\n+     *\/\n+    private static byte[] putCharsAt(byte[] value, byte coder, int count, int index, CharSequence s, int off, int end) {\n+        if (isLatin1(coder)) {\n@@ -1733,1 +1921,1 @@\n-                    val[j++] = (byte)c;\n+                    value[j++] = (byte)c;\n@@ -1735,1 +1923,1 @@\n-                    inflate();\n+                    value = inflateToUTF16(value, count);\n@@ -1737,1 +1925,1 @@\n-                    StringUTF16.putCharSB(this.value, j++, c);\n+                    StringUTF16.putCharSB(value, j++, c);\n@@ -1739,2 +1927,2 @@\n-                    StringUTF16.putCharsSB(this.value, j, s, i, end);\n-                    return;\n+                    StringUTF16.putCharsSB(value, j, s, i, end);\n+                    return value;\n@@ -1744,7 +1932,1 @@\n-            StringUTF16.putCharsSB(this.value, index, s, off, end);\n-        }\n-    }\n-\n-    private void inflateIfNeededFor(String input) {\n-        if (COMPACT_STRINGS && (coder != input.coder())) {\n-            inflate();\n+            StringUTF16.putCharsSB(value, index, s, off, end);\n@@ -1752,0 +1934,1 @@\n+        return value;\n@@ -1754,3 +1937,3 @@\n-    private void inflateIfNeededFor(AbstractStringBuilder input) {\n-        if (COMPACT_STRINGS && (coder != input.getCoder())) {\n-            inflate();\n+    private static byte[] inflateIfNeededFor(byte[] value, int count, byte coder, byte otherCoder) {\n+        if (COMPACT_STRINGS && (coder == LATIN1 && otherCoder == UTF16)) {\n+            return inflateToUTF16(value, count);\n@@ -1758,0 +1941,1 @@\n+        return value;\n@@ -1760,15 +1944,34 @@\n-    private void putStringAt(int index, String str, int off, int end) {\n-        inflateIfNeededFor(str);\n-        str.getBytes(value, off, index, coder, end - off);\n-    }\n-\n-    private void putStringAt(int index, String str) {\n-        inflateIfNeededFor(str);\n-        str.getBytes(value, index, coder);\n-    }\n-\n-    private final void appendChars(char[] s, int off, int end) {\n-        int count = this.count;\n-        if (isLatin1()) {\n-            byte[] val = this.value;\n-            for (int i = off, j = count; i < end; i++) {\n+    \/**\n+     * {@return the buffer with the substring inserted}\n+     * If the substring contains UTF16 characters and the current coder is LATIN1, inflation occurs\n+     * into a new buffer and returned; the caller must update the coder to UTF16.\n+     * Since the contents are immutable, a simple copy of characters is sufficient.\n+     * @param value an existing buffer to insert into\n+     * @param coder the coder of the buffer\n+     * @param count the count of characters in the buffer\n+     * @param index the index to insert the string\n+     * @param str the string\n+     *\/\n+     private static byte[] putStringAt(byte[] value, byte coder, int count, int index, String str, int off, int end) {\n+        byte[] newValue = inflateIfNeededFor(value, count, coder, str.coder());\n+        coder = (newValue == value) ? coder : UTF16;\n+        str.getBytes(newValue, off, index, coder, end - off);\n+        return newValue;\n+    }\n+\n+    \/**\n+     * {@return buffer with new characters appended, possibly inflated}\n+     * The buffer may need to be inflated if any character does not fit;\n+     * if the returned buffer is different then passed in, the new coder is UTF16.\n+     * The caller is responsible for updating the count.\n+     * @param value the current buffer\n+     * @param coder the coder of the buffer\n+     * @param count the character count\n+     * @param s a char array\n+     * @param off the offset of the first character to append\n+     * @param end end last (exclusive) character to append\n+     *\/\n+    private static byte[] appendChars(byte[] value, byte coder, int count, char[] s, int off, int end) {\n+        if (isLatin1(coder)) {\n+            int latin1Len = StringUTF16.compress(s, off, value, count, end - off);\n+            for (int i = off + latin1Len, j = count + latin1Len; i < end; i++) {\n@@ -1777,1 +1980,1 @@\n-                    val[j++] = (byte)c;\n+                    value[j++] = (byte)c;\n@@ -1779,5 +1982,6 @@\n-                    this.count = count = j;\n-                    inflate();\n-                    StringUTF16.putCharsSB(this.value, j, s, i, end);\n-                    this.count = count + end - i;\n-                    return;\n+                    value = inflateToUTF16(value, j);\n+                    \/\/ Store c to make sure sb has a UTF16 char\n+                    StringUTF16.putCharSB(value, j++, c);\n+                    i++;\n+                    StringUTF16.putCharsSB(value, j, s, i, end);\n+                    return value;\n@@ -1787,1 +1991,1 @@\n-            StringUTF16.putCharsSB(this.value, count, s, off, end);\n+            StringUTF16.putCharsSB(value, count, s, off, end);\n@@ -1789,1 +1993,1 @@\n-        this.count = count + end - off;\n+        return value;\n@@ -1792,2 +1996,14 @@\n-    private final void appendChars(String s, int off, int end) {\n-        if (isLatin1()) {\n+    \/**\n+     * {@return buffer with new characters appended, possibly inflated}\n+     * The buffer may need to be inflated if any character does not fit;\n+     * if the returned buffer is different then passed in, the new coder is UTF16.\n+     * The caller is responsible for updating the count.\n+     * @param value the current buffer\n+     * @param coder the coder of the buffer\n+     * @param count the character count\n+     * @param s a string\n+     * @param off the offset of the first character to append\n+     * @param end end last (exclusive) character to append\n+     *\/\n+    private static byte[] appendChars(byte[] value, byte coder, int count, String s, int off, int end) {\n+        if (isLatin1(coder)) {\n@@ -1795,1 +2011,1 @@\n-                System.arraycopy(s.value(), off, this.value, this.count, end - off);\n+                System.arraycopy(s.value(), off, value, count, end - off);\n@@ -1799,1 +2015,0 @@\n-                byte[] val = this.value;\n@@ -1803,1 +2018,1 @@\n-                        val[j++] = (byte) c;\n+                        value[j++] = (byte) c;\n@@ -1805,5 +2020,3 @@\n-                        count = j;\n-                        inflate();\n-                        System.arraycopy(s.value(), i << UTF16, this.value, j << UTF16, (end - i) << UTF16);\n-                        count += end - i;\n-                        return;\n+                        value = inflateToUTF16(value, j);\n+                        System.arraycopy(s.value(), i << UTF16, value, j << UTF16, (end - i) << UTF16);\n+                        return value;\n@@ -1814,1 +2027,1 @@\n-            StringUTF16.putCharsSB(this.value, this.count, s, off, end);\n+            StringUTF16.putCharsSB(value, count, s, off, end);\n@@ -1816,1 +2029,1 @@\n-            System.arraycopy(s.value(), off << UTF16, this.value, this.count << UTF16, (end - off) << UTF16);\n+            System.arraycopy(s.value(), off << UTF16, value, count << UTF16, (end - off) << UTF16);\n@@ -1818,1 +2031,1 @@\n-        count += end - off;\n+        return value;\n@@ -1821,3 +2034,14 @@\n-    private final void appendChars(CharSequence s, int off, int end) {\n-        if (isLatin1()) {\n-            byte[] val = this.value;\n+    \/**\n+     * {@return buffer with new characters appended, possibly inflated}\n+     * The buffer may need to be inflated if any character does not fit;\n+     * if the returned buffer is different then passed in, the new coder is UTF16.\n+     * The caller is responsible for updating the count.\n+     * @param value the current buffer\n+     * @param coder the coder of the buffer\n+     * @param count the character count\n+     * @param s a string\n+     * @param off the offset of the first character to append\n+     * @param end end last (exclusive) character to append\n+     *\/\n+    private static byte[] appendChars(byte[] value, byte coder, int count, CharSequence s, int off, int end) {\n+        if (isLatin1(coder)) {\n@@ -1827,1 +2051,1 @@\n-                    val[j++] = (byte)c;\n+                    value[j++] = (byte)c;\n@@ -1829,2 +2053,1 @@\n-                    count = j;\n-                    inflate();\n+                    value = inflateToUTF16(value, j);\n@@ -1832,2 +2055,1 @@\n-                    StringUTF16.putCharSB(this.value, j++, c);\n-                    count = j;\n+                    StringUTF16.putCharSB(value, j++, c);\n@@ -1835,3 +2057,2 @@\n-                    StringUTF16.putCharsSB(this.value, j, s, i, end);\n-                    count += end - i;\n-                    return;\n+                    StringUTF16.putCharsSB(value, j, s, i, end);\n+                    return value;\n@@ -1841,1 +2062,1 @@\n-            StringUTF16.putCharsSB(this.value, count, s, off, end);\n+            StringUTF16.putCharsSB(value, count, s, off, end);\n@@ -1843,1 +2064,1 @@\n-        count += end - off;\n+        return value;\n@@ -1873,1 +2094,1 @@\n-        } else if (coder == LATIN1) {\n+        } else if (isLatin1(coder)) {\n@@ -1883,5 +2104,11 @@\n-        int limit = this.count + count;\n-        ensureCapacityInternal(limit);\n-        boolean isLatin1 = isLatin1();\n-        if (isLatin1 && StringLatin1.canEncode(c)) {\n-            Arrays.fill(value, this.count, limit, (byte)c);\n+        byte coder = this.coder;\n+        int prevCount = this.count;\n+        int limit = prevCount + count;\n+        byte[] value = this.value;\n+        byte newCoder = (byte) (coder | StringLatin1.coderFromChar(c));\n+        if (needsNewBuffer(value, coder, limit, newCoder)) {\n+            this.value = value = ensureCapacityNewCoder(value, coder, prevCount, limit, newCoder);\n+            this.coder = coder = newCoder;\n+        }\n+        if (isLatin1(coder)) {\n+            Arrays.fill(value, prevCount, limit, (byte)c);\n@@ -1889,4 +2116,1 @@\n-            if (isLatin1) {\n-                inflate();\n-            }\n-            for (int index = this.count; index < limit; index++) {\n+            for (int index = prevCount; index < limit; index++) {\n@@ -1977,0 +2201,1 @@\n+        byte coder = this.coder;\n@@ -1978,0 +2203,1 @@\n+        byte[] value = this.value;\n@@ -1984,1 +2210,0 @@\n-        ensureCapacityInternal(limit);\n@@ -1986,1 +2211,6 @@\n-            putStringAt(offset, str);\n+            byte newCoder = (byte)(coder | str.coder());\n+            if (needsNewBuffer(value, coder, limit, newCoder)) {\n+                this.value = value = ensureCapacityNewCoder(value, coder, offset, limit, newCoder);\n+                this.coder = coder = newCoder;\n+            }\n+            str.getBytes(value, offset, newCoder);\n@@ -1988,1 +2218,6 @@\n-            append(asb);\n+            byte newCoder = (byte)(coder | asb.coder);\n+            if (needsNewBuffer(value, coder, limit, newCoder)) {\n+                this.value = value = ensureCapacityNewCoder(value, coder, offset, limit, newCoder);\n+                this.coder = coder = newCoder;\n+            }\n+            asb.getBytes(value, offset, newCoder);\n@@ -1990,1 +2225,6 @@\n-            appendChars(cs, 0, length);\n+            byte[] currValue = ensureCapacitySameCoder(value, coder, limit);\n+            value = appendChars(currValue, coder, offset, cs, 0, length);\n+            if (currValue != value) {\n+                this.coder = coder = UTF16;\n+            }\n+            this.value = value;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AbstractStringBuilder.java","additions":477,"deletions":237,"binary":false,"changes":714,"status":"modified"},{"patch":"@@ -57,0 +57,4 @@\n+    public static byte coderFromChar(char cp) {\n+        return (byte)((0xff - cp) >>> (Integer.SIZE - 1));\n+    }\n+\n@@ -712,0 +716,15 @@\n+    public static void putCharsAt(byte[] value, int i, char c1, char c2, char c3, char c4) {\n+        value[i] = (byte)c1;\n+        value[i + 1] = (byte)c2;\n+        value[i + 2] = (byte)c3;\n+        value[i + 3] = (byte)c4;\n+    }\n+\n+    public static void putCharsAt(byte[] value, int i, char c1, char c2, char c3, char c4, char c5) {\n+        value[i] = (byte)c1;\n+        value[i + 1] = (byte)c2;\n+        value[i + 2] = (byte)c3;\n+        value[i + 3] = (byte)c4;\n+        value[i + 4] = (byte)c5;\n+    }\n+\n@@ -745,4 +764,0 @@\n-    public static void fillNull(byte[] val, int index, int end) {\n-        Arrays.fill(val, index, end, (byte)0);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1334,4 +1334,0 @@\n-    public static void fillNull(byte[] val, int index, int end) {\n-        Arrays.fill(val, index << 1, end << 1, (byte)0);\n-    }\n-\n@@ -1535,1 +1531,1 @@\n-    public static int putCharsAt(byte[] value, int i, char c1, char c2, char c3, char c4) {\n+    public static void putCharsAt(byte[] value, int i, char c1, char c2, char c3, char c4) {\n@@ -1538,6 +1534,4 @@\n-        putChar(value, i++, c1);\n-        putChar(value, i++, c2);\n-        putChar(value, i++, c3);\n-        putChar(value, i++, c4);\n-        assert(i == end);\n-        return end;\n+        putChar(value, i, c1);\n+        putChar(value, i + 1, c2);\n+        putChar(value, i + 2, c3);\n+        putChar(value, i + 3, c4);\n@@ -1546,1 +1540,1 @@\n-    public static int putCharsAt(byte[] value, int i, char c1, char c2, char c3, char c4, char c5) {\n+    public static void putCharsAt(byte[] value, int i, char c1, char c2, char c3, char c4, char c5) {\n@@ -1549,7 +1543,5 @@\n-        putChar(value, i++, c1);\n-        putChar(value, i++, c2);\n-        putChar(value, i++, c3);\n-        putChar(value, i++, c4);\n-        putChar(value, i++, c5);\n-        assert(i == end);\n-        return end;\n+        putChar(value, i, c1);\n+        putChar(value, i + 1, c2);\n+        putChar(value, i + 2, c3);\n+        putChar(value, i + 3, c4);\n+        putChar(value, i + 4, c5);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringUTF16.java","additions":11,"deletions":19,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -143,2 +143,2 @@\n-    public static int putCharsAt(byte[] value, int i, char c1, char c2, char c3, char c4) {\n-        return StringUTF16.putCharsAt(value, i, c1, c2, c3, c4);\n+    public static void putCharsAt(byte[] value, int i, char c1, char c2, char c3, char c4) {\n+        StringUTF16.putCharsAt(value, i, c1, c2, c3, c4);\n@@ -147,2 +147,2 @@\n-    public static int putCharsAt(byte[] value, int i, char c1, char c2, char c3, char c4, char c5) {\n-        return StringUTF16.putCharsAt(value, i, c1, c2, c3, c4, c5);\n+    public static void putCharsAt(byte[] value, int i, char c1, char c2, char c3, char c4, char c5) {\n+        StringUTF16.putCharsAt(value, i, c1, c2, c3, c4, c5);\n","filename":"test\/hotspot\/jtreg\/compiler\/patches\/java.base\/java\/lang\/Helper.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @bug 8054307 8077559\n+ * @bug 8054307 8077559 8351443\n@@ -57,0 +57,4 @@\n+        check(new StringBuilder(ORIGIN).append(new char[] { 'a', 'b', 'c'}),\n+                \"Aabc\");\n+        check(new StringBuilder(ORIGIN).append(new char[] { 'a', 'b', 'c'}, 1, 2),\n+                \"Abc\");\n","filename":"test\/jdk\/java\/lang\/StringBuilder\/CompactStringBuilder.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+import java.util.Arrays;\n+\n@@ -28,1 +30,1 @@\n- * @bug 8149330 8218227\n+ * @bug 8149330 8218227 8351443\n@@ -50,0 +52,1 @@\n+        testHugePlus(isCompact);\n@@ -111,0 +114,19 @@\n+\n+    \/\/ Test creating and appending the max size string for -XX:+CompactStrings and -XX:-CompactStrings\n+    private static void testHugePlus(boolean isCompact) {\n+        int repeatCount = (isCompact) ? Integer.MAX_VALUE \/ 2 - 1 : Integer.MAX_VALUE \/ 4 - 1;\n+        char[] chars = new char[repeatCount];\n+        char[] aChar = {'A', '\\uff21'};\n+        for (char ch : aChar) {\n+            try {\n+                int size = (ch > 0xff) ? repeatCount \/ 2 : repeatCount;\n+                Arrays.fill(chars, 0, size, ch);\n+                StringBuilder b = new StringBuilder(0);\n+                b.append(chars, 0, size);\n+                b.append(chars, 0, size);\n+            } catch (Throwable unexpected) {\n+                unexpected.printStackTrace();\n+                failures++;\n+            }\n+        }\n+    }\n","filename":"test\/jdk\/java\/lang\/StringBuilder\/HugeCapacity.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,337 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8351443\n+ * @summary Randomized test of StringBuilder\n+ * @run main StressSBTest\n+ *\/\n+\n+import java.lang.System.Logger;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.nio.CharBuffer;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.stream.IntStream;\n+\n+\n+public class StressSBTest {\n+\n+    \/\/ Logger for info and errors\n+    static final Logger LOG = System.getLogger(\"StressSBTest\");\n+    \/\/ Number of concurrent platform threads\n+    private final static int N_THREADS = 11;\n+    \/\/ Base length of test run\n+    private final static Duration N_Duration = Duration.ofSeconds(2);\n+    \/\/ Cache jtreg timeout factor to allow test to be run as a standalone main()\n+    private static final double TIMEOUT_FACTOR =\n+            Double.parseDouble(System.getProperty(\"test.timeout.factor\", \"1.0\"));\n+\n+    \/**\n+     * Run the stress test with a fixed set of parameters.\n+     *\n+     * @param ignored\n+     *\/\n+    public static void main(String[] ignored) {\n+        Duration duration = Duration.ofMillis((long) (N_Duration.toMillis() * TIMEOUT_FACTOR));\n+        new StressSBTest().stress(N_THREADS, duration);\n+    }\n+\n+    \/**\n+     * Stress test using a number of platform threads for a duration.\n+     * Success is marked by a lack of exceptions.\n+     * Logging output indicates the number of operations performed by each thread\n+     *\n+     * @param numThreads the number of threads\n+     * @param duration   a Duration, typically a few seconds\n+     *\/\n+    public void stress(int numThreads, Duration duration) {\n+        StressOps stressOps = new StressOps();\n+\n+        final StringBuilder sb = new StringBuilder(\"abcdefghijklmnopqrstuvwxyz\");\n+        \/\/ A single StringBuilder is used to exercise the API in the face of racy behavior\n+        List<Thread> threads = IntStream.range(0, numThreads).mapToObj(i -> {\n+                    try {\n+                        Thread t = Thread.ofPlatform().start(() -> stressOps.randomStress(sb, duration));\n+                        LOG.log(Logger.Level.DEBUG, t);\n+                        return t;\n+                    } catch (Throwable t) {\n+                        LOG.log(Logger.Level.ERROR, \"Thread.ofPlatform\", t);\n+                    }\n+                    return null;\n+                })\n+                .filter(t -> t != null)\n+                .toList();\n+        threads.forEach(t -> {\n+            try {\n+                t.join();\n+            } catch (InterruptedException ie) {\n+                \/\/ ignore\n+            }\n+        });\n+        LOG.log(Logger.Level.INFO, \"Completed: threads: %d, duration: %s\".formatted(numThreads, duration));\n+    }\n+\n+\n+    \/**\n+     * Methods and support for stress testing StringBuilder.\n+     *\/\n+    private static class StressOps {\n+\n+        private static final Random randomGen = new Random();\n+        private static final StringBuilder stringBuilder = new StringBuilder(\"wxyz\");\n+        private static final StringBuffer stringBuffer = new StringBuffer(\"wxyz\");\n+        private static final CharBuffer charBuffer = CharBuffer.allocate(10).append(\"charBuffer\");\n+        private static final char[] charArray = \"xyz\".toCharArray();\n+        private static final CharSequence charSequence = \"now is the time\";\n+        \/\/ Cache of mappings of all StringBuilder public instand methods mh -> Method\n+        private static Map<MethodHandle, Method> testMethodsCache;\n+        \/\/ Active map of SB methods mh -> Method\n+        private final Map<MethodHandle, Method> testMethods;\n+\n+        public StressOps() {\n+            if (testMethodsCache == null) {\n+                testMethodsCache = findTestMethods();\n+            }\n+            testMethods = testMethodsCache;\n+        }\n+\n+        \/**\n+         * Stress test randomizes methods acting on a StringBuilder.\n+         * Exceptions are logged but do no affect success\/failure result.\n+         *\n+         * @param sb       a StringBuilder\n+         * @param duration a Duration of time to stress\n+         *\/\n+        public void randomStress(StringBuilder sb, Duration duration) {\n+            MethodHandle[] ops = testMethods.keySet().toArray(new MethodHandle[0]);\n+            int count = 0;\n+            int worked = 0;\n+            Instant end = Instant.now().plus(duration);\n+            while (Instant.now().isBefore(end)) {\n+                int j = randomGen.nextInt(ops.length);\n+                var mh = ops[j];\n+                String name = testMethods.get(mh).getName();\n+                MethodType mt = mh.type();\n+                try {\n+                    count++;\n+                    if (invokeByMethodNameAndType(name, mt, sb)) {\n+                        worked++;\n+                    }\n+\n+                } catch (Throwable t) {\n+                    LOG.log(Logger.Level.DEBUG, \"Exception testing \" + name + mt, t);\n+                }\n+            }\n+            LOG.log(Logger.Level.INFO, \"StringBuilder method calls: %d, successful: %d\".formatted(count, worked));\n+        }\n+\n+\n+        \/**\n+         * {@return Return a map of all the public instance methods of java.lang.StringBuilder\n+         * mapping MethodHandle to the Method}\n+         *\/\n+        private Map<MethodHandle, Method> findTestMethods() {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            Method[] methods = StringBuilder.class.getDeclaredMethods();\n+            Map<MethodHandle, Method> map = new HashMap<>(methods.length);\n+            Arrays.stream(methods)\n+                    .filter(m -> Modifier.isPublic(m.getModifiers()) &&\n+                            !Modifier.isStatic(m.getModifiers()))\n+                    .forEach(m -> {\n+                        try {\n+                            MethodHandle mh = lookup.unreflect(m);\n+                            map.put(mh, m);\n+                        } catch (IllegalAccessException iae) {\n+                            LOG.log(Logger.Level.DEBUG, \"AsbTest annotated method not accessible\", iae);\n+                        }\n+                    });\n+            LOG.log(Logger.Level.DEBUG, \"%d StringBuilder test methods\".formatted(map.size()));\n+            return map;\n+        }\n+\n+        \/**\n+         * Invoke the indicated method on the StringBuilder\n+         *\n+         * @param name the method name\n+         * @param mt   the method type\n+         * @param sb   a StringBuilder\n+         * @return true if the method returned a non-null result\n+         *\/\n+        private boolean invokeByMethodNameAndType(String name, MethodType mt, StringBuilder sb) {\n+            String s = name + mt.toString();\n+            Object o = switch (s) {\n+                case \"length(StringBuilder)int\" -> sb.length();\n+                case \"toString(StringBuilder)String\" -> sb.toString();\n+                case \"append(StringBuilder,StringBuffer)AbstractStringBuilder\" ->\n+                        sb.append(stringBuffer);\n+                case \"append(StringBuilder,StringBuffer)StringBuilder\" -> sb.append(stringBuffer);\n+                case \"append(StringBuilder,CharSequence)AbstractStringBuilder\" ->\n+                        sb.append(charBuffer);\n+                case \"append(StringBuilder,CharSequence)StringBuilder\" -> sb.append(charBuffer);\n+                case \"append(StringBuilder,CharSequence)Appendable\" -> sb.append(charBuffer);\n+                case \"append(StringBuilder,CharSequence,int,int)AbstractStringBuilder\" ->\n+                        sb.append(\"abc\", 1, 2);\n+                case \"append(StringBuilder,CharSequence,int,int)StringBuilder\" ->\n+                        sb.append(\"abc\", 1, 2);\n+                case \"append(StringBuilder,CharSequence,int,int)Appendable\" ->\n+                        sb.append(\"abc\", 1, 2);\n+                case \"append(StringBuilder,char[])AbstractStringBuilder\" -> sb.append(charArray);\n+                case \"append(StringBuilder,char[])StringBuilder\" -> sb.append(charArray);\n+                case \"append(StringBuilder,String)AbstractStringBuilder\" -> sb.append(\"Abcdefg\");\n+                case \"append(StringBuilder,String)StringBuilder\" -> sb.append(\"abcdefg\");\n+                case \"append(StringBuilder,Object)AbstractStringBuilder\" -> new Object();\n+                case \"append(StringBuilder,Object)StringBuilder\" -> sb.append(new Object());\n+                case \"append(StringBuilder,char)Appendable\" -> sb.append('\\uff21');\n+                case \"append(StringBuilder,char)AbstractStringBuilder\" -> sb.append('A');\n+                case \"append(StringBuilder,char)StringBuilder\" -> sb.append('B');\n+                case \"append(StringBuilder,int)AbstractStringBuilder\" -> sb.append(987654321);\n+                case \"append(StringBuilder,int)StringBuilder\" -> sb.append(987654321);\n+                case \"append(StringBuilder,long)AbstractStringBuilder\" ->\n+                        sb.append(987654321987654321L);\n+                case \"append(StringBuilder,long)StringBuilder\" -> sb.append(987654321987654321L);\n+                case \"append(StringBuilder,float)AbstractStringBuilder\" -> sb.append(Math.PI);\n+                case \"append(StringBuilder,float)StringBuilder\" -> sb.append(Math.PI);\n+                case \"append(StringBuilder,double)AbstractStringBuilder\" -> sb.append(Math.TAU);\n+                case \"append(StringBuilder,double)StringBuilder\" -> sb.append(Math.TAU);\n+                case \"append(StringBuilder,boolean)AbstractStringBuilder\" -> sb.append(true);\n+                case \"append(StringBuilder,boolean)StringBuilder\" -> sb.append(false);\n+                case \"append(StringBuilder,char[],int,int)AbstractStringBuilder\" ->\n+                        sb.append(charArray, 3, 4);\n+                case \"append(StringBuilder,char[],int,int)StringBuilder\" ->\n+                        sb.append(charArray, 4, 3);\n+                case \"reverse(StringBuilder)StringBuilder\" -> sb.reverse();\n+                case \"reverse(StringBuilder)AbstractStringBuilder\" -> sb.reverse();\n+                case \"getChars(StringBuilder,int,int,char[],int)void\" -> {\n+                    sb.getChars(2, 4, charArray, 3);\n+                    yield sb;\n+                }\n+                case \"compareTo(StringBuilder,Object)int\" -> sb.compareTo(stringBuilder);\n+                case \"compareTo(StringBuilder,StringBuilder)int\" -> sb.compareTo(stringBuilder);\n+                case \"indexOf(StringBuilder,String,int)int\" -> sb.indexOf(\"A\", 2);\n+                case \"indexOf(StringBuilder,String)int\" -> sb.indexOf(\"B\");\n+                case \"insert(StringBuilder,int,CharSequence)StringBuilder\" ->\n+                        sb.insert(2, charSequence);\n+                case \"insert(StringBuilder,int,CharSequence)AbstractStringBuilder\" ->\n+                        sb.insert(2, charSequence);\n+                case \"insert(StringBuilder,int,String)StringBuilder\" -> sb.insert(2, \"Now\");\n+                case \"insert(StringBuilder,int,String)AbstractStringBuilder\" ->\n+                        sb.insert(2, \"Then\");\n+                case \"insert(StringBuilder,int,char[])StringBuilder\" -> sb.insert(4, charArray);\n+                case \"insert(StringBuilder,int,char[])AbstractStringBuilder\" ->\n+                        sb.insert(4, charArray);\n+                case \"insert(StringBuilder,int,Object)AbstractStringBuilder\" ->\n+                        sb.insert(3, new Object());\n+                case \"insert(StringBuilder,int,Object)StringBuilder\" -> sb.insert(4, \"RUST\");\n+                case \"insert(StringBuilder,int,char[],int,int)AbstractStringBuilder\" ->\n+                        sb.insert(2, charArray, 0, 4);\n+                case \"insert(StringBuilder,int,char[],int,int)StringBuilder\" ->\n+                        sb.insert(2, charArray, 0, 4);\n+                case \"insert(StringBuilder,int,int)StringBuilder\" -> sb.insert(2, 46000);\n+                case \"insert(StringBuilder,int,int)AbstractStringBuilder\" -> sb.insert(3, 47000);\n+                case \"insert(StringBuilder,int,double)StringBuilder\" -> sb.insert(2, Math.PI);\n+                case \"insert(StringBuilder,int,double)AbstractStringBuilder\" ->\n+                        sb.insert(2, Math.PI);\n+                case \"insert(StringBuilder,int,float)StringBuilder\" -> sb.insert(2, Math.TAU);\n+                case \"insert(StringBuilder,int,float)AbstractStringBuilder\" ->\n+                        sb.insert(2, Math.TAU);\n+                case \"insert(StringBuilder,int,long)StringBuilder\" -> sb.insert(2, 42L);\n+                case \"insert(StringBuilder,int,long)AbstractStringBuilder\" -> sb.insert(2, 42L);\n+                case \"insert(StringBuilder,int,char)StringBuilder\" -> sb.insert(2, 'Z');\n+                case \"insert(StringBuilder,int,char)AbstractStringBuilder\" -> sb.insert(2, 'Z');\n+                case \"insert(StringBuilder,int,boolean)StringBuilder\" -> sb.insert(2, true);\n+                case \"insert(StringBuilder,int,boolean)AbstractStringBuilder\" ->\n+                        sb.insert(3, false);\n+                case \"insert(StringBuilder,int,CharSequence,int,int)StringBuilder\" ->\n+                        sb.insert(4, charSequence, 4, 5);\n+                case \"insert(StringBuilder,int,CharSequence,int,int)AbstractStringBuilder\" ->\n+                        sb.insert(4, charSequence, 5, 4);\n+                case \"charAt(StringBuilder,int)char\" -> sb.charAt(5);\n+                case \"codePointAt(StringBuilder,int)int\" -> sb.codePointAt(4);\n+                case \"codePointBefore(StringBuilder,int)int\" -> sb.codePointBefore(3);\n+                case \"codePointCount(StringBuilder,int,int)int\" -> sb.codePointCount(3, 9);\n+                case \"offsetByCodePoints(StringBuilder,int,int)int\" -> sb.offsetByCodePoints(3, 7);\n+                case \"lastIndexOf(StringBuilder,String,int)int\" -> sb.lastIndexOf(\"A\", 45);\n+                case \"lastIndexOf(StringBuilder,String)int\" -> sb.lastIndexOf(\"B\");\n+                case \"substring(StringBuilder,int)String\" -> sb.substring(6);\n+                case \"substring(StringBuilder,int,int)String\" -> sb.substring(6, 9);\n+                case \"replace(StringBuilder,int,int,String)StringBuilder\" ->\n+                        sb.replace(2, 5, \"xyz\");\n+                case \"replace(StringBuilder,int,int,String)AbstractStringBuilder\" ->\n+                        sb.replace(2, 5, \"XYZ\");\n+                case \"repeat(StringBuilder,CharSequence,int)StringBuilder\" -> sb.repeat('Z', 6);\n+                case \"repeat(StringBuilder,CharSequence,int)AbstractStringBuilder\" ->\n+                        sb.repeat('X', 42);\n+                case \"repeat(StringBuilder,int,int)AbstractStringBuilder\" -> sb.repeat(101, 25);\n+                case \"repeat(StringBuilder,int,int)StringBuilder\" -> sb.repeat(102, 24);\n+                case \"codePoints(StringBuilder)IntStream\" -> sb.codePoints().count();\n+                case \"subSequence(StringBuilder,int,int)CharSequence\" -> sb.subSequence(3, 9);\n+                case \"chars(StringBuilder)IntStream\" -> sb.chars().count();\n+                case \"setLength(StringBuilder,int)void\" -> {\n+                    sb.setLength(45);\n+                    yield 45;\n+                }\n+                case \"capacity(StringBuilder)int\" -> sb.capacity();\n+                case \"ensureCapacity(StringBuilder,int)void\" -> {\n+                    sb.ensureCapacity(150);\n+                    yield 150;\n+                }\n+                case \"trimToSize(StringBuilder)void\" -> {\n+                    sb.trimToSize();\n+                    yield sb.length();\n+                }\n+                case \"setCharAt(StringBuilder,int,char)void\" -> {\n+                    sb.setCharAt(6, 'T');\n+                    yield 'T';\n+                }\n+                case \"appendCodePoint(StringBuilder,int)StringBuilder\" ->\n+                        sb.appendCodePoint(0xff21);\n+                case \"appendCodePoint(StringBuilder,int)AbstractStringBuilder\" ->\n+                        sb.appendCodePoint(0xff21);\n+                case \"delete(StringBuilder,int,int)StringBuilder\" -> sb.delete(5, 20);\n+                case \"delete(StringBuilder,int,int)AbstractStringBuilder\" -> sb.delete(6, 21);\n+                case \"deleteCharAt(StringBuilder,int)AbstractStringBuilder\" -> sb.deleteCharAt(7);\n+                case \"deleteCharAt(StringBuilder,int)StringBuilder\" -> sb.deleteCharAt(8);\n+                case \"equals(Object,Object)boolean\" -> false;\n+                case \"hashCode(Object)int\" -> sb.hashCode();\n+                case \"getClass(Object)Class\" -> sb.getClass();\n+                case \"isEmpty(CharSequence)boolean\" -> null;\n+                default -> {\n+                    System.out.println(\"not executing: \" + s);\n+                    yield null;\n+                }\n+            };\n+            return o != null;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/StringBuilder\/StressSBTest.java","additions":337,"deletions":0,"binary":false,"changes":337,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @bug 8302323\n+ * @bug 8302323 8351443\n@@ -110,1 +110,1 @@\n-        assertEquals(expected, sb.toString());\n+        assertEquals(sb.toString(), expected);\n@@ -130,1 +130,1 @@\n-        assertEquals(expected, sb.toString());\n+        assertEquals(sb.toString(), expected);\n","filename":"test\/jdk\/java\/lang\/StringBuilder\/StringBuilderRepeat.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}