{"files":[{"patch":"@@ -253,1 +253,0 @@\n-\n@@ -255,1 +254,1 @@\n-     * {@return a buffer suitable for storing the bytes up to minimum capacity using the new coder}\n+     * {@return the value, with the requested coder, in a buffer with at least the minimum capacity}\n@@ -259,1 +258,1 @@\n-     * behaves like {@code ensureCapacity}, however it is never synchronized.\n+     * behaves like the public {@linkplain #ensureCapacity}, however it is never synchronized.\n@@ -272,1 +271,8 @@\n-        int growth = minimumCapacity - (value.length >> coder);\n+        \/\/ Compute the new larger size if growth is requested, otherwise keep the capacity the same\n+        int oldCapacity = value.length >> coder;\n+        int growth = minimumCapacity - oldCapacity;\n+        int newCapacity = (growth <= 0)\n+                ? oldCapacity               \/\/ Do not reduce capacity even if requested\n+                : newCapacity(value, newCoder, minimumCapacity);\n+        assert count <= newCapacity : \"count exceeds new capacity\";\n+\n@@ -274,1 +280,1 @@\n-            if (growth > 0) {\n+            if (newCapacity > oldCapacity) {\n@@ -276,2 +282,1 @@\n-                value = Arrays.copyOf(value,\n-                        newCapacity(value, newCoder, minimumCapacity) << newCoder);\n+                value = Arrays.copyOf(value, newCapacity << newCoder);\n@@ -282,5 +287,1 @@\n-            \/\/ always growing might be better but it breaks current Capacity tests\n-            int newCap = (growth > 0)\n-                ? newCapacity(value, newCoder, minimumCapacity)\n-                : value.length;\n-            byte[] newValue = StringUTF16.newBytesFor(newCap);\n+            byte[] newValue = StringUTF16.newBytesFor(newCapacity);\n@@ -329,4 +330,2 @@\n-     * Returns the current capacity increased by the current length + 2 if\n-     * that suffices.\n-     * Will not return a capacity greater than\n-     * {@code (SOFT_MAX_ARRAY_LENGTH >> coder)}\n+     * Returns the current capacity increased by the current length + 2 if that suffices.\n+     * Will not return a capacity greater than {@code (SOFT_MAX_ARRAY_LENGTH >> coder)}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AbstractStringBuilder.java","additions":15,"deletions":16,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+ * @run testng\/othervm -Xcomp CompactStringBuilder\n@@ -411,0 +412,48 @@\n+    \/\/ Test cases to force expanding the capacity during replace.\n+    \/\/ Start with a known capacity and a known initial value that almost fills it.\n+    \/\/ Use both latin1 and utf16 initial values and replacement values.\n+    \/\/ Iterate through cases of SB.replace start and end values and various lengths of replacement.\n+    \/\/ The results are checked by composing the new string using concatenation of the segments.\n+    @Test\n+    public void testGrowingCapacityReplace() {\n+        final int INIT_CAPACITY = 8;\n+        final String[] INITIAL_CHARS = {\"A\", \"\\u0100\"};\n+        final String[] REPLACEMENT_CHARS = {\"B\", \"\\u0101\"};\n+        for (String INITIAL : INITIAL_CHARS) {\n+            for (String REPLACEMENT : REPLACEMENT_CHARS) {\n+                for (int initLen = INIT_CAPACITY - 1; initLen < INIT_CAPACITY + 2; initLen++) {\n+                    final String orig = INITIAL.repeat(initLen);\n+                    for (int start = INIT_CAPACITY - 4; start < orig.length(); start++) {\n+                        for (int end = start; end < orig.length(); end++) {\n+                            for (int insLen = 0; insLen < 2; insLen++) {\n+                                final String repl = REPLACEMENT.repeat(insLen);\n+                                var sb = new StringBuilder(INIT_CAPACITY)\n+                                        .append(orig);\n+                                int capBefore = sb.capacity();\n+                                sb.replace(start, end, repl);\n+                                int capAfter = sb.capacity();\n+                                String expected = genReplacementString(orig, start, end, repl);\n+                                try {\n+                                    check(sb, expected);\n+                                } catch (Throwable ex) {\n+                                    System.out.printf(\"repl: \\\"%s\\\", actual: %s, expected: %s%n\", repl, sb, expected);\n+                                    System.out.printf(\"    insLen: %d, gap: %d, beforeLen: %d, afterLen: %d, capBefore: %d, capAfter: %d%n\",\n+                                            insLen, (end - start), orig.length(), sb.length(),\n+                                            capBefore, capAfter);\n+                                    throw ex;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Construct the replacement string using string concat of the segments\n+    private static String genReplacementString(String orig, int start, int end, String repl) {\n+        return orig.substring(0, start) +\n+                repl +\n+                orig.substring(end, orig.length());\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/StringBuilder\/CompactStringBuilder.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"}]}