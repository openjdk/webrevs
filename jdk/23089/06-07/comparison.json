{"files":[{"patch":"@@ -995,1 +995,1 @@\n-    \/\/ just XOR them bits.\n+    \/\/ Constant fold: (c1 ^ c2) -> c3\n@@ -999,1 +999,1 @@\n-  \/\/ not constants\n+  \/\/ At least one of the arguments is not constant\n@@ -1001,1 +1001,2 @@\n-  \/\/ result of xor can only have bits sets where any of the\n+\n+  \/\/ Result of xor can only have bits sets where any of the\n@@ -1009,1 +1010,1 @@\n-      \/\/ note cast to unsigned happens before +1 to avoid signed overflow, and\n+      \/\/ Note: cast to unsigned happens before +1 to avoid signed overflow, and\n@@ -1026,1 +1027,1 @@\n-    \/\/ just XOR them bits.\n+    \/\/ Constant fold: (c1 ^ c2) -> c3\n@@ -1030,1 +1031,1 @@\n-  \/\/ not constants\n+  \/\/ At least one of the arguments is not constant\n@@ -1032,1 +1033,1 @@\n-  \/\/ result of xor can only have bits sets where any of the\n+  \/\/ Result of xor can only have bits sets where any of the\n@@ -1040,1 +1041,1 @@\n-      \/\/ we want to find a value that has all 1 bits everywhere up to and including\n+      \/\/ We want to find a value that has all 1 bits everywhere up to and including\n@@ -1055,1 +1056,1 @@\n-      \/\/ without the +1, round_up_pow2 would be 0b0100, resulting in 0b0011 as max\n+      \/\/ Without the +1, round_up_pow2 would be 0b0100, resulting in 0b0011 as max\n@@ -1057,1 +1058,1 @@\n-      \/\/ note cast to unsigned happens before +1 to avoid signed overflow, and\n+      \/\/ Note: cast to unsigned happens before +1 to avoid signed overflow, and\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"opto\/addnode.hpp\"\n+#include \"unittest.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+\n+TEST_VM(opto, xor) {\n+\/\/    ThreadInVMfromNative ThreadInVMfromNative(JavaThread::current());\n+\n+\/\/    const TypeLong *v=TypeLong::make(0);\n+}\n","filename":"test\/hotspot\/gtest\/opto\/test_xor_node.cpp","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import compiler.lib.generators.Generators;\n@@ -36,2 +37,2 @@\n-    private static final int CONST_1 = RunInfo.getRandom().nextInt();\n-    private static final int CONST_2 = RunInfo.getRandom().nextInt();\n+    private static final int CONST_1 = Generators.G.ints().next();\n+    private static final int CONST_2 = Generators.G.ints().next();\n@@ -40,1 +41,1 @@\n-    private static final int CONST_POW_2 = Math.abs(1 << RunInfo.getRandom().nextInt());\n+    private static final int CONST_POW_2 = Math.abs(1 << Generators.G.uniformInts().next());\n@@ -256,1 +257,1 @@\n-    \/\/ Checks (c ^c)  => c (constant folded)\n+    \/\/ Checks (c1 ^ c2)  => c3 (constant folded)\n@@ -272,2 +273,1 @@\n-        \/\/ equivalent to Math.min(CONST_POW_2, Math.max(value, 1))\n-        return 1 + (value & (CONST_POW_2 - 1));\n+        return Math.min(CONST_POW_2, Math.max(value, 1));\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/XorINodeIdealizationTests.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import compiler.lib.generators.Generators;\n@@ -37,3 +38,3 @@\n-    private static final long CONST_1 = RunInfo.getRandom().nextLong();\n-    private static final long CONST_2 = RunInfo.getRandom().nextLong();\n-    private static final long CONST_POW_2 = Math.abs(1L << RunInfo.getRandom().nextInt());\n+    private static final long CONST_1 = Generators.G.longs().next();\n+    private static final long CONST_2 = Generators.G.longs().next();\n+    private static final long CONST_POW_2 = Math.abs(1L << Generators.G.uniformLongs().next());\n@@ -236,1 +237,1 @@\n-    \/\/ Checks (c ^c)  => c (constant folded)\n+    \/\/ Checks (c1 ^ c2)  => c3 (constant folded)\n@@ -252,1 +253,2 @@\n-        \/\/ equivalent to Math.min(CONST_POW_2, Math.max(value, 1))\n+        \/\/ Equivalent to Math.min(CONST_POW_2, Math.max(value, 1)).\n+        \/\/ The bounds do not propagate to the type for longs with min\/max\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/XorLNodeIdealizationTests.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"}]}