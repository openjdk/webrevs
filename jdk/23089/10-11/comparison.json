{"files":[{"patch":"@@ -1001,1 +1001,0 @@\n-\n@@ -1006,8 +1005,1 @@\n-      \/\/ x ^ y cannot have any bit set that is higher than both the highest bits set in x and y\n-      \/\/ x cannot have any bit set that is higher than the highest bit set in r0->_hi\n-      \/\/ y cannot have any bit set that is higher than the highest bit set in r1->_hi\n-\n-      \/\/ Note: cast to unsigned happens before +1 to avoid signed overflow, and\n-      \/\/ round_up is safe because high bit is unset (0 <= lo <= hi)\n-      juint max = round_up_power_of_2(juint(r0->_hi | r1->_hi) + 1) - 1;\n-\n+      jint max = calc_xor_max(r0->_hi, r1->_hi);\n@@ -1020,0 +1012,12 @@\n+jint XorINode::calc_xor_max(const jint hi_0, const jint hi_1) {\n+  assert(hi_0 >= 0, \"must be non-negative\");\n+  assert(hi_1 >= 0, \"must be non-negative\");\n+\n+  \/\/ x ^ y cannot have any bit set that is higher than both the highest bits set in x and y\n+  \/\/ x cannot have any bit set that is higher than the highest bit set in r0->_hi\n+  \/\/ y cannot have any bit set that is higher than the highest bit set in r1->_hi\n+\n+  \/\/ Note: cast to unsigned happens before +1 to avoid signed overflow, and\n+  \/\/ round_up is safe because high bit is unset (0 <= lo <= hi)\n+  return round_up_power_of_2(juint(hi_0 | hi_1) + 1) - 1;\n+}\n@@ -1037,25 +1041,1 @@\n-      \/\/ x ^ y cannot have any bit set that is higher than both the highest bits set in x and y\n-      \/\/ x cannot have any bit set that is higher than the highest bit set in r0->_hi\n-      \/\/ y cannot have any bit set that is higher than the highest bit set in r1->_hi\n-\n-      \/\/ We want to find a value that has all 1 bits everywhere up to and including\n-      \/\/ the highest bits set in r0->_hi as well as r1->_hi. For this,we can take the next\n-      \/\/ power of 2 strictly greater than both hi values and subtract 1 from it.\n-\n-      \/\/ Example 1:\n-      \/\/ r0->_hi =  5 (0b0101)        r1->_hi=1 (0b0001)\n-      \/\/    (5|1)+1       = 0b0110\n-      \/\/    round_up_pow2 = 0b1000\n-      \/\/    -1            = 0b0111 = max\n-\n-      \/\/ Example 2 - this demonstrates need for the +1:\n-      \/\/ r0->_hi =  4 (0b0100)        r1->_hi=4 (0b0100)\n-      \/\/    (4|4)+1       = 0b0101\n-      \/\/    round_up_pow2 = 0b1000\n-      \/\/    -1            = 0b0111 = max\n-      \/\/ Without the +1, round_up_pow2 would be 0b0100, resulting in 0b0011 as max\n-\n-      \/\/ Note: cast to unsigned happens before +1 to avoid signed overflow, and\n-      \/\/ round_up is safe because high bit is unset (0 <= lo <= hi)\n-      julong max = round_up_power_of_2(julong(r0->_hi | r1->_hi) + 1) - 1;\n-\n+      julong max = calc_xor_max(r0->_hi, r1->_hi);\n@@ -1068,0 +1048,30 @@\n+jlong XorLNode::calc_xor_max(const jlong hi_0, const jlong hi_1) {\n+  assert(hi_0 >= 0, \"must be non-negative\");\n+  assert(hi_1 >= 0, \"must be non-negative\");\n+\n+  \/\/ x ^ y cannot have any bit set that is higher than both the highest bits set in x and y\n+  \/\/ x cannot have any bit set that is higher than the highest bit set in r0->_hi\n+  \/\/ y cannot have any bit set that is higher than the highest bit set in r1->_hi\n+\n+  \/\/ We want to find a value that has all 1 bits everywhere up to and including\n+  \/\/ the highest bits set in r0->_hi as well as r1->_hi. For this,we can take the next\n+  \/\/ power of 2 strictly greater than both hi values and subtract 1 from it.\n+\n+  \/\/ Example 1:\n+  \/\/ r0->_hi =  5 (0b0101)        r1->_hi=1 (0b0001)\n+  \/\/    (5|1)+1       = 0b0110\n+  \/\/    round_up_pow2 = 0b1000\n+  \/\/    -1            = 0b0111 = max\n+\n+  \/\/ Example 2 - this demonstrates need for the +1:\n+  \/\/ r0->_hi =  4 (0b0100)        r1->_hi=4 (0b0100)\n+  \/\/    (4|4)+1       = 0b0101\n+  \/\/    round_up_pow2 = 0b1000\n+  \/\/    -1            = 0b0111 = max\n+  \/\/ Without the +1, round_up_pow2 would be 0b0100, resulting in 0b0011 as max\n+\n+  \/\/ Note: cast to unsigned happens before +1 to avoid signed overflow, and\n+  \/\/ round_up is safe because high bit is unset (0 <= lo <= hi)\n+  return round_up_power_of_2(julong(hi_0 | hi_1) + 1) - 1 ;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":44,"deletions":34,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -238,0 +238,3 @@\n+private:\n+  friend void test_xor_bounds(jlong, jlong, jlong, jlong);\n+  static jint calc_xor_max( const jint, const jint );\n@@ -254,0 +257,3 @@\n+private:\n+  friend void test_xor_bounds(jlong, jlong, jlong, jlong);\n+  static jlong calc_xor_max( const jlong, const jlong );\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-import compiler.lib.generators.Generators;\n+import compiler.lib.generators.*;\n@@ -37,6 +37,5 @@\n-    private static final int CONST_1 = Generators.G.ints().next();\n-    private static final int CONST_2 = Generators.G.ints().next();\n-    private static final boolean CONST_BOOL_1 = RunInfo.getRandom().nextBoolean();\n-    private static final boolean CONST_BOOL_2 = RunInfo.getRandom().nextBoolean();\n-    private static final int CONST_POW_2 = Generators.G.powerOfTwoInts(0)\n-            .restricted(1, Integer.MAX_VALUE).next();\n+    private static final RestrictableGenerator<Integer> G = Generators.G.ints();\n+    private static final int CONST_1 = G.next();\n+    private static final int CONST_2 = G.next();\n+\n+\n@@ -49,9 +48,6 @@\n-                 \"test4\", \"test5\", \"test6\",\n-                 \"test7\", \"test8\", \"test9\",\n-                 \"test10\", \"test11\", \"test12\",\n-                 \"test13\", \"test14\", \"test15\",\n-                 \"test16\", \"test17\",\n-                 \"testConstXor\", \"testXorSelf\",\n-                 \"testConstXorBool\", \"testXorSelfBool\",\n-                 \"testMaxPow2\",\"testMaxPow2Folded\"\n-\n+            \"test4\", \"test5\", \"test6\",\n+            \"test7\", \"test8\", \"test9\",\n+            \"test10\", \"test11\", \"test12\",\n+            \"test13\", \"test14\", \"test15\",\n+            \"test16\", \"test17\",\n+            \"testConstXor\", \"testXorSelf\"\n@@ -63,1 +59,1 @@\n-        boolean d = RunInfo.getRandom().nextBoolean();\n+        int d = RunInfo.getRandom().nextInt();\n@@ -68,1 +64,1 @@\n-        assertResult(0, 0, 0, false);\n+        assertResult(0, 0, 0, 0);\n@@ -70,2 +66,2 @@\n-        assertResult(min, min, min, false);\n-        assertResult(max, max, max, true);\n+        assertResult(min, min, min, min);\n+        assertResult(max, max, max, max);\n@@ -75,1 +71,1 @@\n-    public void assertResult(int a, int b, int c, boolean d) {\n+    public void assertResult(int a, int b, int c, int d) {\n@@ -92,7 +88,3 @@\n-        Asserts.assertEQ(CONST_1 ^ CONST_2  , testConstXor());\n-        Asserts.assertEQ(0                  , testXorSelf(a));\n-        Asserts.assertEQ(CONST_BOOL_1 ^ CONST_BOOL_2  , testConstXorBool());\n-        Asserts.assertEQ(false              , testXorSelfBool(d));\n-        String msg = String.format(\"CONST_POW_2=%d a=%d b=%d\", CONST_POW_2, a, b);\n-        Asserts.assertEQ(interpretedMaxPow2(a, b), testMaxPow2(a, b), msg);\n-        Asserts.assertEQ(true, testMaxPow2Folded(a, b), msg);\n+        Asserts.assertEQ(-2023 - a          , test17(a));\n+        Asserts.assertEQ(CONST_1 ^ CONST_2, testConstXor());\n+        Asserts.assertEQ(0, testXorSelf(a));\n@@ -101,0 +93,1 @@\n+\n@@ -243,1 +236,1 @@\n-    \/\/ Checks (c ^c)  => c (constant folded)\n+    \/\/ Checks (c1 ^ c2)  => c3 (constant folded)\n@@ -256,0 +249,17 @@\n+    private static final boolean CONST_BOOL_1 = RunInfo.getRandom().nextBoolean();\n+    private static final boolean CONST_BOOL_2 = RunInfo.getRandom().nextBoolean();\n+\n+    @Run(test={\n+            \"testConstXorBool\", \"testXorSelfBool\"\n+    })\n+    public void runBooleanTests() {\n+        assertBooleanResult(true);\n+        assertBooleanResult(false);\n+    }\n+\n+    @DontCompile\n+    public void assertBooleanResult(boolean b){\n+        Asserts.assertEQ(CONST_BOOL_1 ^ CONST_BOOL_2, testConstXorBool());\n+        Asserts.assertEQ(false, testXorSelfBool(b));\n+    }\n+\n@@ -272,4 +282,12 @@\n-    \/\/ clamp value to [1,CONST_POW_2]\n-    @ForceInline\n-    private static int forceMinMax(int value){\n-        return Math.min(CONST_POW_2, Math.max(value, 1));\n+    private static final Range RANGE_1;\n+    private static final Range RANGE_2;\n+    private static final int XOR_MAX_OF_RANGES;\n+\n+    static {\n+        var r1 = RANGE_1 = Range.generate(G);\n+        var r2 = RANGE_2 = Range.generate(G);\n+        if (r1.lo() >= 0 && r2.lo() >= 0 && r1.hi() != 0 && r2.hi() != 0) {\n+            XOR_MAX_OF_RANGES = Integer.highestOneBit(r1.hi() | r2.hi() * 2) - 1;\n+        } else {\n+            XOR_MAX_OF_RANGES = Integer.MAX_VALUE;\n+        }\n@@ -278,9 +296,12 @@\n-    @Test\n-    @IR(counts = {IRNode.XOR, \"1\"}) \/\/ must not be constant-folded\n-    \/\/ checks that add_ring computes correct max on exact powers of 2\n-    public boolean testMaxPow2(int x, int y) {\n-        x = forceMinMax(x);\n-        y = forceMinMax(y);\n-\n-        long xor = x ^ y;\n-        return xor < CONST_POW_2;\n+    @Run(test = {\n+            \"testFoldableXor\", \"testXorConstRange\"\n+    })\n+    public void runRangeTests() {\n+        var rand1 = G.restricted(RANGE_1.lo(), RANGE_1.hi());\n+        var rand2 = G.restricted(RANGE_2.lo(), RANGE_2.hi());\n+\n+        for (int i = 0; i < 100; i++) {\n+            checkXor(rand1.next(), rand2.next());\n+        }\n+        checkXor(RANGE_1.hi(), RANGE_2.hi());\n+        checkXor(RANGE_1.lo(), RANGE_2.lo());\n@@ -290,3 +311,4 @@\n-    public boolean interpretedMaxPow2(int x, int y) {\n-        x = forceMinMax(x);\n-        y = forceMinMax(y);\n+    public void checkXor(int a, int b) {\n+        Asserts.assertEQ(true, testFoldableXor(a, b));\n+        Asserts.assertEQ(RANGE_1.clamp(a) ^ RANGE_2.clamp(b), testXorConstRange(a, b));\n+    }\n@@ -294,2 +316,6 @@\n-        long xor = x ^ y;\n-        return xor < CONST_POW_2;\n+    @Test\n+    public int testXorConstRange(int x, int y) {\n+        x = RANGE_1.clamp(x);\n+        y = RANGE_2.clamp(y);\n+\n+        return x ^ y;\n@@ -301,3 +327,6 @@\n-    public boolean testMaxPow2Folded(int x, int y) {\n-        x = forceMinMax(x);\n-        y = forceMinMax(y);\n+    public boolean testFoldableXor(int x, int y) {\n+        x = RANGE_1.clamp(x);\n+        y = RANGE_2.clamp(y);\n+        var xor = x ^ y;\n+        return xor <= XOR_MAX_OF_RANGES;\n+    }\n@@ -305,2 +334,21 @@\n-        long xor = x ^ y;\n-        return xor < (CONST_POW_2*2L);\n+    record Range(int lo, int hi) {\n+        Range {\n+            if (lo > hi) {\n+                throw new IllegalArgumentException(\"lo > hi\");\n+            }\n+        }\n+\n+        int clamp(int v) {\n+            return Math.min(hi, Math.max(v, lo));\n+        }\n+\n+        static Range generate(Generator<Integer> g) {\n+            var a = g.next();\n+            var b = g.next();\n+            if (a > b) {\n+                var tmp = a;\n+                a = b;\n+                b = tmp;\n+            }\n+            return new Range(a, b);\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/XorINodeIdealizationTests.java","additions":101,"deletions":53,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-import compiler.lib.generators.Generators;\n+import compiler.lib.generators.*;\n@@ -37,5 +37,3 @@\n-\n-    private static final long CONST_1 = Generators.G.longs().next();\n-    private static final long CONST_2 = Generators.G.longs().next();\n-    private static final long CONST_POW_2 = Generators.G.powerOfTwoLongs(0)\n-            .restricted(1L, Long.MAX_VALUE).next();\n+    private static final RestrictableGenerator<Long> G = Generators.G.longs();\n+    private static final long CONST_1 = G.next();\n+    private static final long CONST_2 = G.next();\n@@ -54,1 +52,0 @@\n-                 \"testMaxPow2\",\"testMaxPow2Folded\"\n@@ -92,3 +89,0 @@\n-        String msg = String.format(\"CONST_POW_2=%d a=%d b=%d\", CONST_POW_2, a, b);\n-        Asserts.assertEQ(interpretedMaxPow2(a, b), testMaxPow2(a, b), msg);\n-        Asserts.assertEQ(true, testMaxPow2Folded(a, b), msg);\n@@ -251,38 +245,0 @@\n-\n-    \/\/ clamp value to [1,CONST_POW_2]\n-    @ForceInline\n-    private static long forceMinMax(long value) {\n-        \/\/ Equivalent to Math.min(CONST_POW_2, Math.max(value, 1)).\n-        \/\/ The bounds do not propagate to the type for longs with min\/max\n-        return 1L + (value & (CONST_POW_2 - 1L));\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.XOR, \"1\"})  \/\/ must not be constant-folded\n-    \/\/ checks that add_ring computes correct max on exact powers of 2\n-    public boolean testMaxPow2(long x, long y) {\n-        x = forceMinMax(x);\n-        y = forceMinMax(y);\n-        long xor = x ^ y;\n-        return xor < CONST_POW_2;\n-    }\n-\n-    @DontCompile\n-    public boolean interpretedMaxPow2(long x, long y) {\n-        x = forceMinMax(x);\n-        y = forceMinMax(y);\n-\n-        long xor = x ^ y;\n-        return xor < CONST_POW_2;\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.XOR})\n-    @IR(counts = {IRNode.CON_I, \"1\"})\n-    public boolean testMaxPow2Folded(long x, long y) {\n-        x = forceMinMax(x);\n-        y = forceMinMax(y);\n-\n-        long xor = x ^ y;\n-        return xor < (CONST_POW_2*2L);\n-    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/XorLNodeIdealizationTests.java","additions":5,"deletions":49,"binary":false,"changes":54,"status":"modified"}]}