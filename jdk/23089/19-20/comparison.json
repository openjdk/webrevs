{"files":[{"patch":"@@ -985,0 +985,31 @@\n+template<class S, class U>\n+static S calc_xor_max(const S hi_0, const S hi_1) {\n+  assert(hi_0 >= 0, \"must be non-negative\");\n+  assert(hi_1 >= 0, \"must be non-negative\");\n+\n+  \/\/ x ^ y cannot have any bit set that is higher than both the highest bits set in x and y\n+  \/\/ x cannot have any bit set that is higher than the highest bit set in r0->_hi\n+  \/\/ y cannot have any bit set that is higher than the highest bit set in r1->_hi\n+\n+  \/\/ We want to find a value that has all 1 bits everywhere up to and including\n+  \/\/ the highest bits set in r0->_hi as well as r1->_hi. For this,we can take the next\n+  \/\/ power of 2 strictly greater than both hi values and subtract 1 from it.\n+\n+  \/\/ Example 1:\n+  \/\/ r0->_hi =  5 (0b0101)        r1->_hi=1 (0b0001)\n+  \/\/    (5|1)+1       = 0b0110\n+  \/\/    round_up_pow2 = 0b1000\n+  \/\/    -1            = 0b0111 = max\n+\n+  \/\/ Example 2 - this demonstrates need for the +1:\n+  \/\/ r0->_hi =  4 (0b0100)        r1->_hi=4 (0b0100)\n+  \/\/    (4|4)+1       = 0b0101\n+  \/\/    round_up_pow2 = 0b1000\n+  \/\/    -1            = 0b0111 = max\n+  \/\/ Without the +1, round_up_pow2 would be 0b0100, resulting in 0b0011 as max\n+\n+  \/\/ Note: cast to unsigned happens before +1 to avoid signed overflow, and\n+  \/\/ round_up is safe because high bit is unset (0 <= lo <= hi)\n+\n+  return round_up_power_of_2(U(hi_0 | hi_1) + 1) - 1 ;\n+}\n@@ -1013,0 +1044,4 @@\n+jint XorINode::calc_max(const jint hi_0, const jint hi_1)  {\n+  return calc_xor_max<jint, juint>(hi_0, hi_1);\n+}\n+\n@@ -1037,0 +1072,3 @@\n+jlong XorLNode::calc_max(const jlong hi_0, const jlong hi_1)  {\n+  return calc_xor_max<jlong, julong>(hi_0, hi_1);\n+}\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -238,0 +238,3 @@\n+private:\n+  friend jint test_calc_max(const jint, const jint);\n+  static jint calc_max(const jint hi_0, const jint hi_1);\n@@ -254,0 +257,3 @@\n+private:\n+  friend jlong test_calc_max(const jlong, const jlong);\n+  static jlong calc_max(const jlong hi_0, const jlong hi_1);\n@@ -256,32 +262,0 @@\n-template<class S, class U>\n-static S calc_xor_max(const S hi_0, const S hi_1) {\n-  assert(hi_0 >= 0, \"must be non-negative\");\n-  assert(hi_1 >= 0, \"must be non-negative\");\n-\n-  \/\/ x ^ y cannot have any bit set that is higher than both the highest bits set in x and y\n-  \/\/ x cannot have any bit set that is higher than the highest bit set in r0->_hi\n-  \/\/ y cannot have any bit set that is higher than the highest bit set in r1->_hi\n-\n-  \/\/ We want to find a value that has all 1 bits everywhere up to and including\n-  \/\/ the highest bits set in r0->_hi as well as r1->_hi. For this,we can take the next\n-  \/\/ power of 2 strictly greater than both hi values and subtract 1 from it.\n-\n-  \/\/ Example 1:\n-  \/\/ r0->_hi =  5 (0b0101)        r1->_hi=1 (0b0001)\n-  \/\/    (5|1)+1       = 0b0110\n-  \/\/    round_up_pow2 = 0b1000\n-  \/\/    -1            = 0b0111 = max\n-\n-  \/\/ Example 2 - this demonstrates need for the +1:\n-  \/\/ r0->_hi =  4 (0b0100)        r1->_hi=4 (0b0100)\n-  \/\/    (4|4)+1       = 0b0101\n-  \/\/    round_up_pow2 = 0b1000\n-  \/\/    -1            = 0b0111 = max\n-  \/\/ Without the +1, round_up_pow2 would be 0b0100, resulting in 0b0011 as max\n-\n-  \/\/ Note: cast to unsigned happens before +1 to avoid signed overflow, and\n-  \/\/ round_up is safe because high bit is unset (0 <= lo <= hi)\n-\n-  return round_up_power_of_2(U(hi_0 | hi_1) + 1) - 1 ;\n-}\n-\n@@ -465,3 +439,0 @@\n-template<class S, class U> S calc_xor_max(const S hi_0, const S hi_1);\n-\n-\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":6,"deletions":35,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n-jint calc_max(const jint hi_0, const jint hi_1) {\n-  return calc_xor_max<jint, juint>(hi_0, hi_1);\n+jint test_calc_max(const jint hi_0, const jint hi_1) {\n+  return XorINode::calc_max(hi_0, hi_1);\n@@ -32,2 +32,2 @@\n-jlong calc_max(const jlong hi_0, const jlong hi_1) {\n-  return calc_xor_max<jlong, julong>(hi_0, hi_1);\n+jlong test_calc_max(const jlong hi_0, const jlong hi_1) {\n+  return XorLNode::calc_max(hi_0, hi_1);\n@@ -40,1 +40,1 @@\n-  if(val_0> hi_0 || val_0 < S(0) || val_1 > hi_1 || val_1< S(0)) {\n+  if(val_0 > hi_0 || val_0 < S(0) || val_1 > hi_1 || val_1 < S(0)) {\n@@ -43,1 +43,0 @@\n-\n@@ -45,1 +44,1 @@\n-  S max = calc_max(hi_0, hi_1);\n+  S max = test_calc_max(hi_0, hi_1);\n@@ -49,9 +48,0 @@\n-template <class S>\n-void test_exhaustive_values(S hi_0, S hi_1){\n-  for(S val_0 = 0; val_0 <= hi_0; val_0++){\n-    for(S val_1 = val_0; val_1 <= hi_1; val_1++){\n-      test_xor_bounds(hi_0, hi_1, val_0, val_1);\n-    }\n-  }\n-}\n-\n@@ -61,2 +51,2 @@\n-  for(S i=0; i<=3; i++){\n-    for(S j=0; j<=3; j++){\n+  for(S i = 0; i <= 3; i++){\n+    for(S j = 0; j <= 3; j++){\n@@ -65,1 +55,1 @@\n-      test_xor_bounds(hi_0, hi_1, hi_0-i, hi_1-j);\n+      test_xor_bounds(hi_0, hi_1, hi_0 - i, hi_1 - j);\n@@ -70,2 +60,2 @@\n-template <class S, class F>\n-void test_in_ranges(S lo, S hi, F f){\n+template <class S>\n+void test_in_ranges(S lo, S hi){\n@@ -74,1 +64,14 @@\n-      f(hi_0, hi_1);\n+      test_sample_values(hi_0, hi_1);\n+    }\n+  }\n+}\n+\n+template <class S>\n+void test_exhaustive(S limit){\n+  for(S hi_0 = 0; hi_0 <= limit; hi_0++){\n+    for(S hi_1 = hi_0; hi_1 <= limit; hi_1++){\n+      for(S val_0 = 0; val_0 <= hi_0; val_0++){\n+        for(S val_1 = val_0; val_1 <= hi_1; val_1++){\n+          test_xor_bounds(hi_0, hi_1, val_0, val_1);\n+        }\n+      }\n@@ -80,2 +83,0 @@\n-  auto maxjint = jint(std::numeric_limits<jint>::max());\n-  auto maxjlong = jint(std::numeric_limits<jint>::max());\n@@ -83,2 +84,5 @@\n-  test_in_ranges<jint>(0, 15, test_exhaustive_values<jint>);\n-  test_in_ranges<jlong>(0, 15, test_exhaustive_values<jlong>);\n+  test_exhaustive<jint>(15);\n+  test_exhaustive<jlong>(15);\n+\n+  auto max_jint = jint(std::numeric_limits<jint>::max());\n+  auto max_jlong = jint(std::numeric_limits<jint>::max());\n@@ -86,2 +90,2 @@\n-  test_in_ranges<jint>(maxjint - 1, maxjint, test_sample_values<jlong>);\n-  test_in_ranges<jlong>(maxjlong - 1, maxjlong, test_sample_values<jlong>);\n+  test_in_ranges<jint>(max_jint - 1, max_jint);\n+  test_in_ranges<jlong>(max_jlong - 1, max_jlong);\n@@ -92,2 +96,2 @@\n-  test_in_ranges<jint>(top_pos_bit_int - 1, top_pos_bit_long, test_sample_values<jint>);\n-  test_in_ranges<jlong>(top_pos_bit_long - 1, top_pos_bit_long, test_sample_values<jlong>);\n+  test_in_ranges<jint>(top_pos_bit_int - 1, top_pos_bit_long);\n+  test_in_ranges<jlong>(top_pos_bit_long - 1, top_pos_bit_long);\n","filename":"test\/hotspot\/gtest\/opto\/test_xor_node.cpp","additions":34,"deletions":30,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -41,2 +41,0 @@\n-\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/XorINodeIdealizationTests.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}