{"files":[{"patch":"@@ -36,1 +36,1 @@\n-#include \"opto\/addnodeXorUtil.hpp\"\n+#include \"opto\/utilities\/xor.hpp\"\n@@ -1020,1 +1020,1 @@\n-      jint max = calc_xor_upper_bound_of_non_neg<jint, juint>(r0->_hi, r1->_hi);\n+      jint max = xor_upper_bound_for_ranges<jint, juint>(r0->_hi, r1->_hi);\n@@ -1028,1 +1028,1 @@\n-  return calc_xor_upper_bound_of_non_neg<jint, juint>(hi_0, hi_1);\n+  return xor_upper_bound_for_ranges<jint, juint>(hi_0, hi_1);\n@@ -1046,1 +1046,1 @@\n-      julong max = calc_xor_upper_bound_of_non_neg<jlong, julong>(r0->_hi, r1->_hi);\n+      julong max = xor_upper_bound_for_ranges<jlong, julong>(r0->_hi, r1->_hi);\n@@ -1054,1 +1054,1 @@\n-  return calc_xor_upper_bound_of_non_neg<jlong, julong>(hi_0, hi_1);\n+  return xor_upper_bound_for_ranges<jlong, julong>(hi_0, hi_1);\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,41 +0,0 @@\n-#ifndef SHARE_OPTO_ADDNODEXORUTIL_HPP\n-#define SHARE_OPTO_ADDNODEXORUTIL_HPP\n-\n-#include \"utilities\/powerOfTwo.hpp\"\n-\/\/ Code separated into its own header to allow access from GTEST\n-\n-\/\/ Given 2 non-negative values in the ranges [0, hi_0] and [0, hi_1], respectively. The bitwise\n-\/\/ xor of these values should also be non-negative. This method calculates an upper bound.\n-template<class S, class U>\n-static S calc_xor_upper_bound_of_non_neg(const S hi_0, const S hi_1) {\n-    assert(hi_0 >= 0, \"must be non-negative\");\n-    assert(hi_1 >= 0, \"must be non-negative\");\n-\n-    \/\/ x ^ y cannot have any bit set that is higher than both the highest bits set in x and y\n-    \/\/ x cannot have any bit set that is higher than the highest bit set in hi_0\n-    \/\/ y cannot have any bit set that is higher than the highest bit set in hi_1\n-\n-    \/\/ We want to find a value that has all 1 bits everywhere up to and including\n-    \/\/ the highest bits set in hi_0 as well as hi_1. For this, we can take the next\n-    \/\/ power of 2 strictly greater than both hi values and subtract 1 from it.\n-\n-    \/\/ Example 1:\n-    \/\/ hi_0 = 5 (0b0101)       hi_1=1 (0b0001)\n-    \/\/    (5|1)+1       = 0b0110\n-    \/\/    round_up_pow2 = 0b1000\n-    \/\/    -1            = 0b0111 = max\n-\n-    \/\/ Example 2 - this demonstrates need for the +1:\n-    \/\/ hi_0 =  4 (0b0100)        hi_1=4 (0b0100)\n-    \/\/    (4|4)+1       = 0b0101\n-    \/\/    round_up_pow2 = 0b1000\n-    \/\/    -1            = 0b0111 = max\n-    \/\/ Without the +1, round_up_pow2 would be 0b0100, resulting in 0b0011 as max\n-\n-    \/\/ Note: cast to unsigned happens before +1 to avoid signed overflow, and\n-    \/\/ round_up is safe because high bit is unset (0 <= lo <= hi)\n-\n-    return round_up_power_of_2(U(hi_0 | hi_1) + 1) - 1;\n-}\n-\n-#endif \/\/SHARE_OPTO_ADDNODEXORUTIL_HPP\n","filename":"src\/hotspot\/share\/opto\/addnodeXorUtil.hpp","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -0,0 +1,47 @@\n+#ifndef SHARE_OPTO_UTILITIES_XOR_HPP\n+#define SHARE_OPTO_UTILITIES_XOR_HPP\n+\n+#include \"utilities\/powerOfTwo.hpp\"\n+\/\/ Code separated into its own header to allow access from GTEST\n+\n+\/\/ Given 2 non-negative values in the ranges [0, hi_0] and [0, hi_1], respectively. The bitwise\n+\/\/ xor of these values should also be non-negative. This method calculates an upper bound.\n+\n+\/\/ S and U type parameters correspond to the signed and unsigned\n+\/\/ variants of an integer to operate on.\n+template<class S, class U>\n+static S xor_upper_bound_for_ranges(const S hi_0, const S hi_1) {\n+    static_assert(S(-1) < S(0), \"S must be signed\");\n+    static_assert(U(-1) > U(0), \"U must be unsigned\");\n+\n+    assert(hi_0 >= 0, \"must be non-negative\");\n+    assert(hi_1 >= 0, \"must be non-negative\");\n+\n+    \/\/ x ^ y cannot have any bit set that is higher than both the highest bits set in x and y\n+    \/\/ x cannot have any bit set that is higher than the highest bit set in hi_0\n+    \/\/ y cannot have any bit set that is higher than the highest bit set in hi_1\n+\n+    \/\/ We want to find a value that has all 1 bits everywhere up to and including\n+    \/\/ the highest bits set in hi_0 as well as hi_1. For this, we can take the next\n+    \/\/ power of 2 strictly greater than both hi values and subtract 1 from it.\n+\n+    \/\/ Example 1:\n+    \/\/ hi_0 = 5 (0b0101)       hi_1=1 (0b0001)\n+    \/\/    (5|1)+1       = 0b0110\n+    \/\/    round_up_pow2 = 0b1000\n+    \/\/    -1            = 0b0111 = max\n+\n+    \/\/ Example 2 - this demonstrates need for the +1:\n+    \/\/ hi_0 =  4 (0b0100)        hi_1=4 (0b0100)\n+    \/\/    (4|4)+1       = 0b0101\n+    \/\/    round_up_pow2 = 0b1000\n+    \/\/    -1            = 0b0111 = max\n+    \/\/ Without the +1, round_up_pow2 would be 0b0100, resulting in 0b0011 as max\n+\n+    \/\/ Note: cast to unsigned happens before +1 to avoid signed overflow, and\n+    \/\/ round_up is safe because high bit is unset (0 <= lo <= hi)\n+\n+    return round_up_power_of_2(U(hi_0 | hi_1) + 1) - 1;\n+}\n+\n+#endif \/\/ SHARE_OPTO_UTILITIES_XOR_HPP\n","filename":"src\/hotspot\/share\/opto\/utilities\/xor.hpp","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"opto\/addnodeXorUtil.hpp\"\n+#include \"opto\/utilities\/xor.hpp\"\n@@ -30,1 +30,1 @@\n-  return calc_xor_upper_bound_of_non_neg<jint,juint>(hi_0, hi_1);\n+  return xor_upper_bound_for_ranges<jint, juint>(hi_0, hi_1);\n@@ -34,1 +34,1 @@\n-  return calc_xor_upper_bound_of_non_neg<jlong,julong>(hi_0, hi_1);\n+  return xor_upper_bound_for_ranges<jlong, julong>(hi_0, hi_1);\n","filename":"test\/hotspot\/gtest\/opto\/test_xor_node.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}