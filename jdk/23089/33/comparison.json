{"files":[{"patch":"@@ -998,13 +998,0 @@\n-  \/\/ result of xor can only have bits sets where any of the\n-  \/\/ inputs have bits set. lo can always become 0.\n-  const TypeInt* t1i = t1->is_int();\n-  const TypeInt* t2i = t2->is_int();\n-  if ((t1i->_lo >= 0) &&\n-      (t1i->_hi > 0)  &&\n-      (t2i->_lo >= 0) &&\n-      (t2i->_hi > 0)) {\n-    \/\/ hi - set all bits below the highest bit. Using round_down to avoid overflow.\n-    const TypeInt* t1x = TypeInt::make(0, round_down_power_of_2(t1i->_hi) + (round_down_power_of_2(t1i->_hi) - 1), t1i->_widen);\n-    const TypeInt* t2x = TypeInt::make(0, round_down_power_of_2(t2i->_hi) + (round_down_power_of_2(t2i->_hi) - 1), t2i->_widen);\n-    return t1x->meet(t2x);\n-  }\n@@ -1014,0 +1001,33 @@\n+\/\/ Given 2 non-negative values in the ranges [0, hi_0] and [0, hi_1], respectively. The bitwise\n+\/\/ xor of these values should also be non-negative. This method calculates an upper bound.\n+template<class S, class U>\n+static S calc_xor_upper_bound_of_non_neg(const S hi_0, const S hi_1) {\n+  assert(hi_0 >= 0, \"must be non-negative\");\n+  assert(hi_1 >= 0, \"must be non-negative\");\n+\n+  \/\/ x ^ y cannot have any bit set that is higher than both the highest bits set in x and y\n+  \/\/ x cannot have any bit set that is higher than the highest bit set in hi_0\n+  \/\/ y cannot have any bit set that is higher than the highest bit set in hi_1\n+\n+  \/\/ We want to find a value that has all 1 bits everywhere up to and including\n+  \/\/ the highest bits set in hi_0 as well as hi_1. For this, we can take the next\n+  \/\/ power of 2 strictly greater than both hi values and subtract 1 from it.\n+\n+  \/\/ Example 1:\n+  \/\/ hi_0 = 5 (0b0101)       hi_1=1 (0b0001)\n+  \/\/    (5|1)+1       = 0b0110\n+  \/\/    round_up_pow2 = 0b1000\n+  \/\/    -1            = 0b0111 = max\n+\n+  \/\/ Example 2 - this demonstrates need for the +1:\n+  \/\/ hi_0 =  4 (0b0100)        hi_1=4 (0b0100)\n+  \/\/    (4|4)+1       = 0b0101\n+  \/\/    round_up_pow2 = 0b1000\n+  \/\/    -1            = 0b0111 = max\n+  \/\/ Without the +1, round_up_pow2 would be 0b0100, resulting in 0b0011 as max\n+\n+  \/\/ Note: cast to unsigned happens before +1 to avoid signed overflow, and\n+  \/\/ round_up is safe because high bit is unset (0 <= lo <= hi)\n+\n+  return round_up_power_of_2(U(hi_0 | hi_1) + 1) - 1;\n+}\n@@ -1024,4 +1044,4 @@\n-  \/\/ Complementing a boolean?\n-  if( r0 == TypeInt::BOOL && ( r1 == TypeInt::ONE\n-                               || r1 == TypeInt::BOOL))\n-    return TypeInt::BOOL;\n+  if (r0->is_con() && r1->is_con()) {\n+    \/\/ Constant fold: (c1 ^ c2) -> c3\n+    return TypeInt::make(r0->get_con() ^ r1->get_con());\n+  }\n@@ -1029,2 +1049,9 @@\n-  if( !r0->is_con() || !r1->is_con() ) \/\/ Not constants\n-    return TypeInt::INT;        \/\/ Any integer, but still no symbols.\n+  \/\/ At least one of the arguments is not constant\n+\n+  if (r0->_lo >= 0 && r1->_lo >= 0) {\n+      jint max = calc_xor_upper_bound_of_non_neg<jint, juint>(r0->_hi, r1->_hi);\n+      return TypeInt::make(0, max, MAX2(r0->_widen, r1->_widen));\n+  }\n+\n+  return TypeInt::INT;\n+}\n@@ -1032,2 +1059,2 @@\n-  \/\/ Otherwise just XOR them bits.\n-  return TypeInt::make( r0->get_con() ^ r1->get_con() );\n+jint XorINode::calc_max(const jint hi_0, const jint hi_1)  {\n+  return calc_xor_upper_bound_of_non_neg<jint, juint>(hi_0, hi_1);\n@@ -1042,3 +1069,4 @@\n-  \/\/ If either input is not a constant, just return all integers.\n-  if( !r0->is_con() || !r1->is_con() )\n-    return TypeLong::LONG;      \/\/ Any integer, but still no symbols.\n+  if (r0->is_con() && r1->is_con()) {\n+    \/\/ Constant fold: (c1 ^ c2) -> c3\n+    return TypeLong::make(r0->get_con() ^ r1->get_con());\n+  }\n@@ -1046,2 +1074,13 @@\n-  \/\/ Otherwise just OR them bits.\n-  return TypeLong::make( r0->get_con() ^ r1->get_con() );\n+  \/\/ At least one of the arguments is not constant\n+\n+  if (r0->_lo >= 0 && r1->_lo >= 0) {\n+      \/\/ Combine [0, lo_1] ^ [0, hi_1] -> [0, max]\n+      julong max = calc_xor_upper_bound_of_non_neg<jlong, julong>(r0->_hi, r1->_hi);\n+      return TypeLong::make(0, max, MAX2(r0->_widen, r1->_widen));\n+  }\n+\n+  return TypeLong::LONG;\n+}\n+\n+jlong XorLNode::calc_max(const jlong hi_0, const jlong hi_1)  {\n+  return calc_xor_upper_bound_of_non_neg<jlong, julong>(hi_0, hi_1);\n@@ -1083,13 +1122,1 @@\n-  \/\/ result of xor can only have bits sets where any of the\n-  \/\/ inputs have bits set. lo can always become 0.\n-  const TypeLong* t1l = t1->is_long();\n-  const TypeLong* t2l = t2->is_long();\n-  if ((t1l->_lo >= 0) &&\n-      (t1l->_hi > 0)  &&\n-      (t2l->_lo >= 0) &&\n-      (t2l->_hi > 0)) {\n-    \/\/ hi - set all bits below the highest bit. Using round_down to avoid overflow.\n-    const TypeLong* t1x = TypeLong::make(0, round_down_power_of_2(t1l->_hi) + (round_down_power_of_2(t1l->_hi) - 1), t1l->_widen);\n-    const TypeLong* t2x = TypeLong::make(0, round_down_power_of_2(t2l->_hi) + (round_down_power_of_2(t2l->_hi) - 1), t2l->_widen);\n-    return t1x->meet(t2x);\n-  }\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":66,"deletions":39,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -254,0 +254,3 @@\n+private:\n+  friend jint test_calc_max(const jint, const jint);\n+  static jint calc_max(const jint hi_0, const jint hi_1);\n@@ -270,0 +273,3 @@\n+private:\n+  friend jlong test_calc_max(const jlong, const jlong);\n+  static jlong calc_max(const jlong hi_0, const jlong hi_1);\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"opto\/addnode.hpp\"\n+#include \"unittest.hpp\"\n+\n+jint test_calc_max(const jint hi_0, const jint hi_1) {\n+  return XorINode::calc_max(hi_0, hi_1);\n+}\n+\n+jlong test_calc_max(const jlong hi_0, const jlong hi_1) {\n+  return XorLNode::calc_max(hi_0, hi_1);\n+}\n+\n+template <class S>\n+void test_xor_bounds(S hi_0, S hi_1, S val_0, S val_1) {\n+  ASSERT_GE(hi_0, 0);\n+  ASSERT_GE(hi_1, 0);\n+\n+  \/\/ Skip out-of-bounds values for convenience\n+  if (val_0 > hi_0 || val_0 < S(0) || val_1 > hi_1 || val_1 < S(0)) {\n+    return;\n+  }\n+\n+  S v = val_0 ^ val_1;\n+  S max = test_calc_max(hi_0, hi_1);\n+  EXPECT_LE(v, max);\n+}\n+\n+template <class S>\n+void test_sample_values(S hi_0, S hi_1) {\n+  for (S i = 0; i <= 3; i++) {\n+    for (S j = 0; j <= 3; j++) {\n+      \/\/ Some bit combinations near the low and high ends of the range\n+      test_xor_bounds(hi_0, hi_1, i, j);\n+      test_xor_bounds(hi_0, hi_1, hi_0 - i, hi_1 - j);\n+    }\n+  }\n+}\n+\n+template <class S>\n+void test_in_ranges(S lo, S hi){\n+  ASSERT_GE(lo, 0);\n+  ASSERT_LE(lo, hi);\n+\n+  for (S hi_0 = lo; hi_0 <= hi; hi_0++) {\n+    for (S hi_1 = hi_0; hi_1 <=hi; hi_1++) {\n+      test_sample_values(hi_0, hi_1);\n+    }\n+  }\n+}\n+\n+template <class S>\n+void test_exhaustive(S limit) {\n+  for (S hi_0 = 0; hi_0 <= limit; hi_0++) {\n+    for (S hi_1 = hi_0; hi_1 <= limit; hi_1++) {\n+      for (S val_0 = 0; val_0 <= hi_0; val_0++) {\n+        for (S val_1 = val_0; val_1 <= hi_1; val_1++) {\n+          test_xor_bounds(hi_0, hi_1, val_0, val_1);\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+template <class S>\n+void exec_tests() {\n+  S top_bit = max_power_of_2<S>();\n+  S prev_bit = top_bit >> 1;\n+\n+  test_exhaustive<S>(15);\n+\n+  test_in_ranges<S>(top_bit - 1, top_bit);\n+  test_in_ranges<S>(prev_bit - 1, prev_bit);\n+}\n+\n+TEST_VM(opto, xor_max) {\n+  exec_tests<jint>();\n+  exec_tests<jlong>();\n+}\n","filename":"test\/hotspot\/gtest\/opto\/test_xor_node.cpp","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import compiler.lib.generators.*;\n@@ -36,0 +37,4 @@\n+    private static final RestrictableGenerator<Integer> G = Generators.G.ints();\n+    private static final int CONST_1 = G.next();\n+    private static final int CONST_2 = G.next();\n+\n@@ -45,1 +50,3 @@\n-                 \"test16\", \"test17\"})\n+                 \"test16\", \"test17\",\n+                 \"testConstXor\", \"testXorSelf\"\n+    })\n@@ -80,0 +87,2 @@\n+        Asserts.assertEQ(CONST_1 ^ CONST_2  , testConstXor());\n+        Asserts.assertEQ(0                  , testXorSelf(a));\n@@ -220,0 +229,106 @@\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR})\n+    @IR(counts = {IRNode.CON_I, \"1\"})\n+    \/\/ Checks (c1 ^ c2)  => c3 (constant folded)\n+    public int testConstXor() {\n+        return CONST_1 ^ CONST_2;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR})\n+    @IR(counts = {IRNode.CON_I, \"1\"})\n+    \/\/ Checks (x ^ x)  => c (constant folded)\n+    public int testXorSelf(int x) {\n+        return x ^ x;\n+    }\n+\n+    private static final boolean CONST_BOOL_1 = RunInfo.getRandom().nextBoolean();\n+    private static final boolean CONST_BOOL_2 = RunInfo.getRandom().nextBoolean();\n+\n+    @Run(test={\n+            \"testConstXorBool\", \"testXorSelfBool\", \"testXorIntAsBool\"\n+    })\n+    public void runBooleanTests() {\n+        int c = G.next();\n+        int d = G.next();\n+\n+        assertBooleanResult(true, c, d);\n+        assertBooleanResult(false, c, d);\n+    }\n+\n+    @DontCompile\n+    public void assertBooleanResult(boolean b, int x, int y) {\n+        Asserts.assertEQ(CONST_BOOL_1 ^ CONST_BOOL_2, testConstXorBool());\n+        Asserts.assertEQ(false, testXorSelfBool(b));\n+        Asserts.assertEQ(true, testXorIntAsBool(x, y));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR})\n+    @IR(counts = {IRNode.CON_I, \"1\"})\n+    \/\/ Checks (c1 ^ c2)  => c3 (constant folded)\n+    public boolean testConstXorBool() {\n+        return CONST_BOOL_1 ^ CONST_BOOL_2;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR})\n+    @IR(counts = {IRNode.CON_I, \"1\"})\n+    \/\/ Checks (x ^ x)  => c (constant folded)\n+    public boolean testXorSelfBool(boolean x) {\n+        return x ^ x;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR})\n+    @IR(counts = {IRNode.CON_I, \"1\"})\n+    \/\/ This test explicitly checks for constant folding over ints representing booleans.\n+    \/\/ Checks (x ^ y) => z in [0, 1] when x and y are known to be in [0, 1] (constant folded)\n+    public boolean testXorIntAsBool(int xi, int yi) {\n+        int xor = (xi & 1) ^ (yi & 1);\n+        return 0 <= xor && xor <= 1;\n+    }\n+\n+    @Run(test = {\n+            \"testFoldableXor\", \"testFoldableXorPow2\", \"testUnfoldableXorPow2\"\n+    })\n+    public void runRangeTests() {\n+        int a = G.next();\n+        int b = G.next();\n+        checkXor(a, b);\n+\n+        for (a = 0; a < 16; a++) {\n+            for (b = a; b < 16; b++) {\n+                checkXor(a, b);\n+            }\n+        }\n+    }\n+\n+    @DontCompile\n+    public void checkXor(int a, int b) {\n+        Asserts.assertEQ(true, testFoldableXor(a, b));\n+        Asserts.assertEQ(((a & 0b1000) ^ (b & 0b1000)) < 0b1000, testUnfoldableXorPow2(a, b));\n+        Asserts.assertEQ(true, testFoldableXorPow2(a, b));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR})\n+    @IR(counts = {IRNode.CON_I, \"1\"})\n+    public boolean testFoldableXorPow2(int x, int y) {\n+        return ((x & 0b1000) ^ (y & 0b1000)) < 0b10000;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.XOR, \"1\"})\n+    public boolean testUnfoldableXorPow2(int x, int y) {\n+        return ((x & 0b1000) ^ (y & 0b1000)) < 0b1000;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR})\n+    @IR(counts = {IRNode.CON_I, \"1\"})\n+    public boolean testFoldableXor(int x, int y) {\n+        var xor = (x & 0b111) ^ (y & 0b100);\n+        return xor < 0b1000;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/XorINodeIdealizationTests.java","additions":117,"deletions":2,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import compiler.lib.generators.*;\n@@ -36,0 +37,4 @@\n+    private static final RestrictableGenerator<Long> G = Generators.G.longs();\n+    private static final long CONST_1 = G.next();\n+    private static final long CONST_2 = G.next();\n+\n@@ -45,1 +50,3 @@\n-                 \"test16\", \"test17\"})\n+                 \"test16\", \"test17\",\n+                 \"testConstXor\", \"testXorSelf\",\n+    })\n@@ -80,0 +87,2 @@\n+        Asserts.assertEQ(CONST_1 ^ CONST_2  , testConstXor());\n+        Asserts.assertEQ(0L                 , testXorSelf(a));\n@@ -220,0 +229,59 @@\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR})\n+    @IR(counts = {IRNode.CON_L, \"1\"})\n+    \/\/ Checks (c1 ^ c2)  => c3 (constant folded)\n+    public long testConstXor() {\n+        return CONST_1 ^ CONST_2;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR})\n+    @IR(counts = {IRNode.CON_L, \"1\"})\n+    \/\/ Checks (x ^ x)  => c (constant folded)\n+    public long testXorSelf(long x) {\n+        return x ^ x;\n+    }\n+\n+    @Run(test = {\n+            \"testFoldableXor\", \"testFoldableXorPow2\", \"testUnfoldableXorPow2\"\n+    })\n+    public void runRangeTests() {\n+        long a = G.next();\n+        long b = G.next();\n+        checkXor(a, b);\n+\n+        for (a = 0; a < 16; a++) {\n+            for (b = a; b < 16; b++) {\n+                checkXor(a, b);\n+            }\n+        }\n+    }\n+\n+    @DontCompile\n+    public void checkXor(long a, long b) {\n+        Asserts.assertEQ(true, testFoldableXor(a, b));\n+        Asserts.assertEQ(((a & 0b1000) ^ (b & 0b1000)) < 0b1000, testUnfoldableXorPow2(a, b));\n+        Asserts.assertEQ(true, testFoldableXorPow2(a, b));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR})\n+    @IR(counts = {IRNode.CON_I, \"1\"})\n+    public boolean testFoldableXorPow2(long x, long y) {\n+        return ((x & 0b1000) ^ (y & 0b1000)) < 0b10000;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.XOR, \"1\"})\n+    public boolean testUnfoldableXorPow2(long x, long y) {\n+        return ((x & 0b1000) ^ (y & 0b1000)) < 0b1000;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR})\n+    @IR(counts = {IRNode.CON_I, \"1\"}) \/\/ note boolean is a CON_I\n+    public boolean testFoldableXor(long x, long y) {\n+        var xor = (x & 0b111) ^ (y & 0b100);\n+        return xor < 0b1000;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/XorLNodeIdealizationTests.java","additions":70,"deletions":2,"binary":false,"changes":72,"status":"modified"}]}