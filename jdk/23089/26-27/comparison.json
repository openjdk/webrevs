{"files":[{"patch":"@@ -984,1 +984,2 @@\n-\n+\/\/ Given 2 non-negative values in the ranges [0, hi_0] and [0, hi_1], respectively. The bitwise\n+\/\/ xor of these values should also be non-negative. This method calculates an upper bound.\n@@ -986,1 +987,1 @@\n-static S calc_xor_max(const S hi_0, const S hi_1) {\n+static S calc_xor_upper_bound_of_non_neg(const S hi_0, const S hi_1) {\n@@ -995,1 +996,1 @@\n-  \/\/ the highest bits set in r0->_hi as well as r1->_hi. For this,we can take the next\n+  \/\/ the highest bits set in r0->_hi as well as r1->_hi. For this, we can take the next\n@@ -1033,3 +1034,0 @@\n-  \/\/ Result of xor can only have bits sets where any of the\n-  \/\/ inputs have bits set. lo can always become 0.\n-\n@@ -1037,1 +1035,1 @@\n-      jint max = calc_xor_max<jint, juint>(r0->_hi, r1->_hi);\n+      jint max = calc_xor_upper_bound_of_non_neg<jint, juint>(r0->_hi, r1->_hi);\n@@ -1045,1 +1043,1 @@\n-  return calc_xor_max<jint, juint>(hi_0, hi_1);\n+  return calc_xor_upper_bound_of_non_neg<jint, juint>(hi_0, hi_1);\n@@ -1061,3 +1059,0 @@\n-  \/\/ Result of xor can only have bits sets where any of the\n-  \/\/ inputs have bits set. lo can always become 0.\n-\n@@ -1065,1 +1060,1 @@\n-      julong max = calc_xor_max<jlong, julong>(r0->_hi, r1->_hi);\n+      julong max = calc_xor_upper_bound_of_non_neg<jlong, julong>(r0->_hi, r1->_hi);\n@@ -1073,1 +1068,1 @@\n-  return calc_xor_max<jlong, julong>(hi_0, hi_1);\n+  return calc_xor_upper_bound_of_non_neg<jlong, julong>(hi_0, hi_1);\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -250,1 +250,1 @@\n-            \"testConstXorBool\", \"testXorSelfBool\"\n+            \"testConstXorBool\", \"testXorSelfBool\", \"testXorIntAsBool\"\n@@ -253,2 +253,5 @@\n-        assertBooleanResult(true);\n-        assertBooleanResult(false);\n+        int c = G.next();\n+        int d = G.next();\n+\n+        assertBooleanResult(true, c, d);\n+        assertBooleanResult(false, c, d);\n@@ -258,1 +261,1 @@\n-    public void assertBooleanResult(boolean b){\n+    public void assertBooleanResult(boolean b, int x, int y) {\n@@ -261,0 +264,1 @@\n+        Asserts.assertEQ(true, testXorIntAsBool(x, y));\n@@ -279,0 +283,8 @@\n+    @Test\n+    @IR(failOn = {IRNode.XOR})\n+    @IR(counts = {IRNode.CON_I, \"1\"})\n+    \/\/ Checks (x ^ y)  => z <=1  when x and y are known to be in [0,1] (constant folded)\n+    public boolean testXorIntAsBool(int xi, int yi) {\n+        return ((xi & 0b1) ^ (yi & 0b1)) <= 1;\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/XorINodeIdealizationTests.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"}]}