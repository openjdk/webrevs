{"files":[{"patch":"@@ -984,0 +984,31 @@\n+template<class S, class U>\n+S calc_xor_max(const S hi_0, const S hi_1) {\n+  assert(hi_0 >= 0, \"must be non-negative\");\n+  assert(hi_1 >= 0, \"must be non-negative\");\n+\n+  \/\/ x ^ y cannot have any bit set that is higher than both the highest bits set in x and y\n+  \/\/ x cannot have any bit set that is higher than the highest bit set in r0->_hi\n+  \/\/ y cannot have any bit set that is higher than the highest bit set in r1->_hi\n+\n+  \/\/ We want to find a value that has all 1 bits everywhere up to and including\n+  \/\/ the highest bits set in r0->_hi as well as r1->_hi. For this,we can take the next\n+  \/\/ power of 2 strictly greater than both hi values and subtract 1 from it.\n+\n+  \/\/ Example 1:\n+  \/\/ r0->_hi =  5 (0b0101)        r1->_hi=1 (0b0001)\n+  \/\/    (5|1)+1       = 0b0110\n+  \/\/    round_up_pow2 = 0b1000\n+  \/\/    -1            = 0b0111 = max\n+\n+  \/\/ Example 2 - this demonstrates need for the +1:\n+  \/\/ r0->_hi =  4 (0b0100)        r1->_hi=4 (0b0100)\n+  \/\/    (4|4)+1       = 0b0101\n+  \/\/    round_up_pow2 = 0b1000\n+  \/\/    -1            = 0b0111 = max\n+  \/\/ Without the +1, round_up_pow2 would be 0b0100, resulting in 0b0011 as max\n+\n+  \/\/ Note: cast to unsigned happens before +1 to avoid signed overflow, and\n+  \/\/ round_up is safe because high bit is unset (0 <= lo <= hi)\n+\n+  return round_up_power_of_2(U(hi_0 | hi_1) + 1) - 1 ;\n+}\n@@ -1005,1 +1036,1 @@\n-      jint max = calc_xor_max(r0->_hi, r1->_hi);\n+      jint max = calc_xor_max<jint, juint>(r0->_hi, r1->_hi);\n@@ -1012,12 +1043,0 @@\n-jint XorINode::calc_xor_max(const jint hi_0, const jint hi_1) {\n-  assert(hi_0 >= 0, \"must be non-negative\");\n-  assert(hi_1 >= 0, \"must be non-negative\");\n-\n-  \/\/ x ^ y cannot have any bit set that is higher than both the highest bits set in x and y\n-  \/\/ x cannot have any bit set that is higher than the highest bit set in r0->_hi\n-  \/\/ y cannot have any bit set that is higher than the highest bit set in r1->_hi\n-\n-  \/\/ Note: cast to unsigned happens before +1 to avoid signed overflow, and\n-  \/\/ round_up is safe because high bit is unset (0 <= lo <= hi)\n-  return round_up_power_of_2(juint(hi_0 | hi_1) + 1) - 1;\n-}\n@@ -1041,1 +1060,1 @@\n-      julong max = calc_xor_max(r0->_hi, r1->_hi);\n+      julong max = calc_xor_max<jlong, julong>(r0->_hi, r1->_hi);\n@@ -1048,29 +1067,0 @@\n-jlong XorLNode::calc_xor_max(const jlong hi_0, const jlong hi_1) {\n-  assert(hi_0 >= 0, \"must be non-negative\");\n-  assert(hi_1 >= 0, \"must be non-negative\");\n-\n-  \/\/ x ^ y cannot have any bit set that is higher than both the highest bits set in x and y\n-  \/\/ x cannot have any bit set that is higher than the highest bit set in r0->_hi\n-  \/\/ y cannot have any bit set that is higher than the highest bit set in r1->_hi\n-\n-  \/\/ We want to find a value that has all 1 bits everywhere up to and including\n-  \/\/ the highest bits set in r0->_hi as well as r1->_hi. For this,we can take the next\n-  \/\/ power of 2 strictly greater than both hi values and subtract 1 from it.\n-\n-  \/\/ Example 1:\n-  \/\/ r0->_hi =  5 (0b0101)        r1->_hi=1 (0b0001)\n-  \/\/    (5|1)+1       = 0b0110\n-  \/\/    round_up_pow2 = 0b1000\n-  \/\/    -1            = 0b0111 = max\n-\n-  \/\/ Example 2 - this demonstrates need for the +1:\n-  \/\/ r0->_hi =  4 (0b0100)        r1->_hi=4 (0b0100)\n-  \/\/    (4|4)+1       = 0b0101\n-  \/\/    round_up_pow2 = 0b1000\n-  \/\/    -1            = 0b0111 = max\n-  \/\/ Without the +1, round_up_pow2 would be 0b0100, resulting in 0b0011 as max\n-\n-  \/\/ Note: cast to unsigned happens before +1 to avoid signed overflow, and\n-  \/\/ round_up is safe because high bit is unset (0 <= lo <= hi)\n-  return round_up_power_of_2(julong(hi_0 | hi_1) + 1) - 1 ;\n-}\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":33,"deletions":43,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -238,3 +238,0 @@\n-private:\n-  friend void test_xor_bounds(jlong, jlong, jlong, jlong);\n-  static jint calc_xor_max( const jint, const jint );\n@@ -257,3 +254,0 @@\n-private:\n-  friend void test_xor_bounds(jlong, jlong, jlong, jlong);\n-  static jlong calc_xor_max( const jlong, const jlong );\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-#include <iostream>\n-#include <climits>\n-\n@@ -31,1 +28,12 @@\n-void test_xor_bounds(jlong hi_0, jlong hi_1, jlong val_0, jlong val_1) {\n+template<class S, class U> S calc_xor_max(const S hi_0, const S hi_1);\n+\n+jint calc_max(const jint hi_0, const jint hi_1) {\n+  return calc_xor_max<jint, juint>(hi_0, hi_1);\n+}\n+\n+jlong calc_max(const jlong hi_0, const jlong hi_1) {\n+  return calc_xor_max<jlong, julong>(hi_0, hi_1);\n+}\n+\n+template <class S>\n+void test_xor_bounds(S hi_0, S hi_1, S val_0, S val_1) {\n@@ -34,1 +42,1 @@\n-  if(val_0> hi_0 || val_0 < 0 || val_1 > hi_1 || val_1< 0) {\n+  if(val_0> hi_0 || val_0 < S(0) || val_1 > hi_1 || val_1< S(0)) {\n@@ -38,6 +46,3 @@\n-  EXPECT_LE(val_0 ^ val_1, XorLNode::calc_xor_max(hi_0, hi_1));\n-\n-  \/\/ check ints when in range\n-  if(hi_0 <= INT_MAX && hi_1 <= INT_MAX) {\n-    EXPECT_LE(val_0 ^ val_1, XorINode::calc_xor_max(hi_0, hi_1));\n-  }\n+  S v = val_0 ^ val_1;\n+  S max = calc_max(hi_0, hi_1);\n+  EXPECT_LE(v, max);\n@@ -46,7 +51,4 @@\n-void test_exhaustive_values(jlong hi_0, jlong hi_1){\n-\n-  jlong fail_val_0, fail_val_1;\n-\n-  bool hit_bound=false;\n-  for(jlong val_0 = 0; val_0 <= hi_0; val_0++){\n-    for(jlong val_1 = val_0; val_1 <= hi_1; val_1++){\n+template <class S>\n+void test_exhaustive_values(S hi_0, S hi_1){\n+  for(S val_0 = 0; val_0 <= hi_0; val_0++){\n+    for(S val_1 = val_0; val_1 <= hi_1; val_1++){\n@@ -58,1 +60,2 @@\n-void test_sample_values(jlong hi_0, jlong hi_1){\n+template <class S>\n+void test_sample_values(S hi_0, S hi_1){\n@@ -60,4 +63,2 @@\n-  jlong fail_val_0, fail_val_1;\n-\n-  for(int i=0; i<=3; i++){\n-    for(int j=0; j<=3; j++){\n+  for(S i=0; i<=3; i++){\n+    for(S j=0; j<=3; j++){\n@@ -71,3 +72,4 @@\n-void test_exhaustive_values_with_bounds_in_range(jlong lo, jlong hi){\n-  for(jlong hi_0 = lo; hi_0 <= hi; hi_0++){\n-    for(jlong hi_1 = hi_0; hi_1 <=hi; hi_1++){\n+template <class S>\n+void test_exhaustive_values_with_bounds_in_range(S lo, S hi){\n+  for(S hi_0 = lo; hi_0 <= hi; hi_0++){\n+    for(S hi_1 = hi_0; hi_1 <=hi; hi_1++){\n@@ -79,3 +81,4 @@\n-void test_sample_values_with_bounds_in_range(jlong lo, jlong hi){\n-  for(jlong hi_0 = lo; hi_0 <= hi; hi_0++){\n-    for(jlong hi_1 = hi_0; hi_1 <=hi; hi_1++){\n+template <class S>\n+void test_sample_values_with_bounds_in_range(S lo, S hi){\n+  for(S hi_0 = lo; hi_0 <= hi; hi_0++){\n+    for(S hi_1 = hi_0; hi_1 <=hi; hi_1++){\n@@ -88,5 +91,12 @@\n-  test_exhaustive_values_with_bounds_in_range(0, 15);\n-  test_sample_values_with_bounds_in_range(INT_MAX - 1, INT_MAX);\n-  test_sample_values_with_bounds_in_range((1 << 30) - 1, 1 << 30);\n-  test_sample_values_with_bounds_in_range(LONG_MAX - 1, LONG_MAX);\n-  test_sample_values_with_bounds_in_range((1L << 62) - 1, 1L << 62);\n+\n+  auto maxjint = jint(std::numeric_limits<jint>::max());\n+  auto maxjlong = jint(std::numeric_limits<jint>::max());\n+\n+  test_exhaustive_values_with_bounds_in_range<jint>(0, 15);\n+  test_exhaustive_values_with_bounds_in_range<jlong>(0, 15);\n+\n+  test_sample_values_with_bounds_in_range<jint>(maxjint-1, maxjint);\n+  test_sample_values_with_bounds_in_range<jlong>(maxjlong-1, maxjlong);\n+\n+  test_sample_values_with_bounds_in_range<jint>((1 << 30) - 1, 1 << 30);\n+  test_sample_values_with_bounds_in_range<jlong>((1L << 62) - 1, 1L << 62);\n","filename":"test\/hotspot\/gtest\/opto\/test_xor_node.cpp","additions":44,"deletions":34,"binary":false,"changes":78,"status":"modified"}]}