{"files":[{"patch":"@@ -984,4 +984,0 @@\n-template<class S, class U>\n-S calc_xor_max(const S hi_0, const S hi_1) {\n-  assert(hi_0 >= 0, \"must be non-negative\");\n-  assert(hi_1 >= 0, \"must be non-negative\");\n@@ -989,26 +985,0 @@\n-  \/\/ x ^ y cannot have any bit set that is higher than both the highest bits set in x and y\n-  \/\/ x cannot have any bit set that is higher than the highest bit set in r0->_hi\n-  \/\/ y cannot have any bit set that is higher than the highest bit set in r1->_hi\n-\n-  \/\/ We want to find a value that has all 1 bits everywhere up to and including\n-  \/\/ the highest bits set in r0->_hi as well as r1->_hi. For this,we can take the next\n-  \/\/ power of 2 strictly greater than both hi values and subtract 1 from it.\n-\n-  \/\/ Example 1:\n-  \/\/ r0->_hi =  5 (0b0101)        r1->_hi=1 (0b0001)\n-  \/\/    (5|1)+1       = 0b0110\n-  \/\/    round_up_pow2 = 0b1000\n-  \/\/    -1            = 0b0111 = max\n-\n-  \/\/ Example 2 - this demonstrates need for the +1:\n-  \/\/ r0->_hi =  4 (0b0100)        r1->_hi=4 (0b0100)\n-  \/\/    (4|4)+1       = 0b0101\n-  \/\/    round_up_pow2 = 0b1000\n-  \/\/    -1            = 0b0111 = max\n-  \/\/ Without the +1, round_up_pow2 would be 0b0100, resulting in 0b0011 as max\n-\n-  \/\/ Note: cast to unsigned happens before +1 to avoid signed overflow, and\n-  \/\/ round_up is safe because high bit is unset (0 <= lo <= hi)\n-\n-  return round_up_power_of_2(U(hi_0 | hi_1) + 1) - 1 ;\n-}\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -256,0 +256,32 @@\n+template<class S, class U>\n+static S calc_xor_max(const S hi_0, const S hi_1) {\n+  assert(hi_0 >= 0, \"must be non-negative\");\n+  assert(hi_1 >= 0, \"must be non-negative\");\n+\n+  \/\/ x ^ y cannot have any bit set that is higher than both the highest bits set in x and y\n+  \/\/ x cannot have any bit set that is higher than the highest bit set in r0->_hi\n+  \/\/ y cannot have any bit set that is higher than the highest bit set in r1->_hi\n+\n+  \/\/ We want to find a value that has all 1 bits everywhere up to and including\n+  \/\/ the highest bits set in r0->_hi as well as r1->_hi. For this,we can take the next\n+  \/\/ power of 2 strictly greater than both hi values and subtract 1 from it.\n+\n+  \/\/ Example 1:\n+  \/\/ r0->_hi =  5 (0b0101)        r1->_hi=1 (0b0001)\n+  \/\/    (5|1)+1       = 0b0110\n+  \/\/    round_up_pow2 = 0b1000\n+  \/\/    -1            = 0b0111 = max\n+\n+  \/\/ Example 2 - this demonstrates need for the +1:\n+  \/\/ r0->_hi =  4 (0b0100)        r1->_hi=4 (0b0100)\n+  \/\/    (4|4)+1       = 0b0101\n+  \/\/    round_up_pow2 = 0b1000\n+  \/\/    -1            = 0b0111 = max\n+  \/\/ Without the +1, round_up_pow2 would be 0b0100, resulting in 0b0011 as max\n+\n+  \/\/ Note: cast to unsigned happens before +1 to avoid signed overflow, and\n+  \/\/ round_up is safe because high bit is unset (0 <= lo <= hi)\n+\n+  return round_up_power_of_2(U(hi_0 | hi_1) + 1) - 1 ;\n+}\n+\n@@ -433,0 +465,3 @@\n+template<class S, class U> S calc_xor_max(const S hi_0, const S hi_1);\n+\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-template<class S, class U> S calc_xor_max(const S hi_0, const S hi_1);\n-\n","filename":"test\/hotspot\/gtest\/opto\/test_xor_node.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}