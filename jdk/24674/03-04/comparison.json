{"files":[{"patch":"@@ -2194,1 +2194,17 @@\n-Node* XorVNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+\/\/ This function transforms the following patterns:\n+\/\/\n+\/\/ For integer types:\n+\/\/ (XorV (VectorMaskCmp src1 src2 cond) (Replicate -1))\n+\/\/    => (VectorMaskCmp src1 src2 ncond)\n+\/\/ (XorVMask (VectorMaskCmp src1 src2 cond) (MaskAll m1))\n+\/\/    => (VectorMaskCmp src1 src2 ncond)\n+\/\/ cond can be eq, ne, le, ge, lt, gt, ule, uge, ult and ugt.\n+\/\/ ncond is the negative comparison of cond.\n+\/\/\n+\/\/ For float and double types:\n+\/\/ (XorV (VectorMaskCast (VectorMaskCmp src1 src2 cond)) (Replicate -1))\n+\/\/    => (VectorMaskCast (VectorMaskCmp src1 src2 ncond))\n+\/\/ (XorVMask (VectorMaskCast (VectorMaskCmp src1 src2 cond)) (MaskAll m1))\n+\/\/    => (VectorMaskCast (VectorMaskCmp src1 src2 ncond))\n+\/\/ cond can be eq or ne.\n+Node* XorVNode::Ideal_XorV_VectorMaskCmp(PhaseGVN* phase, bool can_reshape) {\n@@ -2197,14 +2213,0 @@\n-  \/\/ (XorV src src)      => (Replicate zero)\n-  \/\/ (XorVMask src src)  => (MaskAll zero)\n-  \/\/\n-  \/\/ The transformation is only applied to the un-predicated\n-  \/\/ operation, since the VectorAPI masked operation requires\n-  \/\/ the unmasked lanes to save the same values in the first\n-  \/\/ operand.\n-  if (!is_predicated_vector() && (in1 == in2)) {\n-    BasicType bt = vect_type()->element_basic_type();\n-    Node* zero = phase->transform(phase->zerocon(bt));\n-    return VectorNode::scalar2vector(zero, length(), bt,\n-                                     bottom_type()->isa_vectmask() != nullptr);\n-  }\n-\n@@ -2212,1 +2214,0 @@\n-  bool with_predicated = false;\n@@ -2215,1 +2216,1 @@\n-    with_predicated = true;\n+    return nullptr;\n@@ -2218,15 +2219,0 @@\n-  \/\/ For integer types:\n-  \/\/ (XorV (VectorMaskCmp src1 src2 cond) (Replicate -1))\n-  \/\/    => (VectorMaskCmp src1 src2 ncond)\n-  \/\/ (XorVMask (VectorMaskCmp src1 src2 cond) (MaskAll m1))\n-  \/\/    => (VectorMaskCmp src1 src2 ncond)\n-  \/\/ cond can be eq, ne, le, ge, lt, gt, ule, uge, ult and ugt, ncond is the\n-  \/\/ negative comparison of cond.\n-  \/\/\n-  \/\/ For float and double types:\n-  \/\/ (XorV (VectorMaskCast (VectorMaskCmp src1 src2 cond)) (Replicate -1))\n-  \/\/    => (VectorMaskCast (VectorMaskCmp src1 src2 ncond))\n-  \/\/ (XorVMask (VectorMaskCast (VectorMaskCmp src1 src2 cond)) (MaskAll m1))\n-  \/\/    => (VectorMaskCast (VectorMaskCmp src1 src2 ncond))\n-  \/\/ cond can be eq or ne.\n-  \/\/\n@@ -2244,2 +2230,1 @@\n-  if (with_predicated || in1->Opcode() != Op_VectorMaskCmp ||\n-      in1->outcnt() > 1 ||\n+  if (in1->Opcode() != Op_VectorMaskCmp || in1->outcnt() > 1 ||\n@@ -2248,1 +2233,1 @@\n-    return VectorNode::Ideal(phase, can_reshape);\n+    return nullptr;\n@@ -2270,0 +2255,21 @@\n+Node* XorVNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  \/\/ (XorV src src)      => (Replicate zero)\n+  \/\/ (XorVMask src src)  => (MaskAll zero)\n+  \/\/\n+  \/\/ The transformation is only applied to the un-predicated\n+  \/\/ operation, since the VectorAPI masked operation requires\n+  \/\/ the unmasked lanes to save the same values in the first\n+  \/\/ operand.\n+  if (!is_predicated_vector() && (in(1) == in(2))) {\n+    BasicType bt = vect_type()->element_basic_type();\n+    Node* zero = phase->transform(phase->zerocon(bt));\n+    return VectorNode::scalar2vector(zero, length(), bt, bottom_type()->isa_vectmask() != nullptr);\n+  }\n+\n+  Node* res = Ideal_XorV_VectorMaskCmp(phase, can_reshape);\n+  if (res == nullptr) {\n+    res = VectorNode::Ideal(phase, can_reshape);\n+  }\n+  return res;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":41,"deletions":35,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -1015,0 +1015,1 @@\n+  Node* Ideal_XorV_VectorMaskCmp(PhaseGVN* phase, bool can_reshape);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}