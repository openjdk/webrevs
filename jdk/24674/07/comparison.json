{"files":[{"patch":"@@ -1219,0 +1219,7 @@\n+  } else if (n->Opcode() == Op_XorV || n->Opcode() == Op_XorVMask) {\n+    \/\/ Condition for removing an unnecessary not() following a compare(...)\n+    \/\/ operation. The predecessor of n (this XorV or XorVMask) may also be used\n+    \/\/ by a useless VectorBox node which will later be eliminated by\n+    \/\/ RemoveUseless. Return true to ensure that subgraph transformations are\n+    \/\/ performed on n.\n+    return true;\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -332,0 +332,2 @@\n+  \/\/ Return the negative mask for the given mask, for both signed and unsigned comparison.\n+  static mask negate_mask(mask btm) { return mask(btm^4); }\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2166,0 +2166,87 @@\n+\/\/ Returns whether (XorV (VectorMaskCmp) -1) can be optimized by negating the\n+\/\/ comparison operation.\n+bool VectorMaskCmpNode::predicate_can_be_negated() {\n+  switch (_predicate) {\n+    case BoolTest::eq:\n+    case BoolTest::ne:\n+      \/\/ eq and ne also apply to floating-point special values like NaN and infinities.\n+      return true;\n+    case BoolTest::le:\n+    case BoolTest::ge:\n+    case BoolTest::lt:\n+    case BoolTest::gt:\n+    case BoolTest::ule:\n+    case BoolTest::uge:\n+    case BoolTest::ult:\n+    case BoolTest::ugt: {\n+      BasicType bt = vect_type()->element_basic_type();\n+      \/\/ For float and double, we don't know if either comparison operand is a\n+      \/\/ NaN, NaN {le|ge|lt|gt} anything is false, resulting in inconsistent\n+      \/\/ results before and after negation.\n+      return is_integral_type(bt);\n+    }\n+    default:\n+      return false;\n+  }\n+}\n+\n+\/\/ This function transforms the following patterns:\n+\/\/\n+\/\/ For integer types:\n+\/\/ (XorV (VectorMaskCmp src1 src2 cond) (Replicate -1))\n+\/\/    => (VectorMaskCmp src1 src2 ncond)\n+\/\/ (XorVMask (VectorMaskCmp src1 src2 cond) (MaskAll m1))\n+\/\/    => (VectorMaskCmp src1 src2 ncond)\n+\/\/ cond can be eq, ne, le, ge, lt, gt, ule, uge, ult and ugt.\n+\/\/ ncond is the negative comparison of cond.\n+\/\/\n+\/\/ For float and double types:\n+\/\/ (XorV (VectorMaskCast (VectorMaskCmp src1 src2 cond)) (Replicate -1))\n+\/\/    => (VectorMaskCast (VectorMaskCmp src1 src2 ncond))\n+\/\/ (XorVMask (VectorMaskCast (VectorMaskCmp src1 src2 cond)) (MaskAll m1))\n+\/\/    => (VectorMaskCast (VectorMaskCmp src1 src2 ncond))\n+\/\/ cond can be eq or ne.\n+Node* XorVNode::Ideal_XorV_VectorMaskCmp(PhaseGVN* phase, bool can_reshape) {\n+  Node* in1 = in(1);\n+  Node* in2 = in(2);\n+  \/\/ Transformations for predicated vectors are not supported for now.\n+  if (is_predicated_vector() ||\n+      in1->is_predicated_vector() ||\n+      in2->is_predicated_vector()) {\n+    return nullptr;\n+  }\n+\n+  \/\/ XorV\/XorVMask is commutative, swap VectorMaskCmp\/VectorMaskCast to in1.\n+  if (in2->Opcode() == Op_VectorMaskCmp ||\n+      (in2->Opcode() == Op_VectorMaskCast && in2->in(1)->Opcode() == Op_VectorMaskCmp)) {\n+    swap(in1, in2);\n+  }\n+\n+  const TypeVect* vector_mask_cast_vt = nullptr;\n+  \/\/ in1 should be single used, otherwise the optimization may be unprofitable.\n+  if (in1->Opcode() == Op_VectorMaskCast && in1->outcnt() == 1 && in1->in(1)->Opcode() == Op_VectorMaskCmp) {\n+    vector_mask_cast_vt = in1->as_Vector()->vect_type();\n+    in1 = in1->in(1);\n+  }\n+\n+  if (in1->Opcode() != Op_VectorMaskCmp ||\n+      in1->outcnt() > 1 ||\n+      !((VectorMaskCmpNode*) in1)->predicate_can_be_negated() ||\n+      !VectorNode::is_all_ones_vector(in2)) {\n+    return nullptr;\n+  }\n+\n+  BoolTest::mask neg_cond = BoolTest::negate_mask(((VectorMaskCmpNode*) in1)->get_predicate());\n+  ConINode* predicate_node = phase->intcon(neg_cond);\n+  const TypeVect* vt = in1->as_Vector()->vect_type();\n+  Node* res = new VectorMaskCmpNode(neg_cond, in1->in(1), in1->in(2),\n+                                      predicate_node, vt);\n+  if (vector_mask_cast_vt != nullptr) {\n+    \/\/ We optimized out a VectorMaskCast, and in order to ensure type\n+    \/\/ correctness, we need to regenerate one. VectorMaskCast will be encoded as\n+    \/\/ a no-op (identity function) for types with the same size.\n+    res = new VectorMaskCastNode(phase->transform(res), vector_mask_cast_vt);\n+  }\n+  return res;\n+}\n+\n@@ -2179,1 +2266,6 @@\n-  return VectorNode::Ideal(phase, can_reshape);\n+\n+  Node* res = Ideal_XorV_VectorMaskCmp(phase, can_reshape);\n+  if (res == nullptr) {\n+    res = VectorNode::Ideal(phase, can_reshape);\n+  }\n+  return res;\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":93,"deletions":1,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -1015,0 +1015,1 @@\n+  Node* Ideal_XorV_VectorMaskCmp(PhaseGVN* phase, bool can_reshape);\n@@ -1687,0 +1688,1 @@\n+  bool predicate_can_be_negated();\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2229,0 +2229,10 @@\n+    public static final String VECTOR_MASK_CMP_B = VECTOR_PREFIX + \"VECTOR_MASK_CMP_B\" + POSTFIX;\n+    static {\n+        vectorNode(VECTOR_MASK_CMP_B, \"VectorMaskCmp\", TYPE_BYTE);\n+    }\n+\n+    public static final String VECTOR_MASK_CMP_S = VECTOR_PREFIX + \"VECTOR_MASK_CMP_S\" + POSTFIX;\n+    static {\n+        vectorNode(VECTOR_MASK_CMP_S, \"VectorMaskCmp\", TYPE_SHORT);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,1 +136,1 @@\n-        return nodeRegex.replaceAll(IRNode.IS_REPLACED, \"vector[A-Za-z]<\" + type + \",\" + sizeRegex + \">\");\n+        return nodeRegex.replaceAll(IRNode.IS_REPLACED, \"vector([A-Za-z]|mask)<\" + type + \",\" + sizeRegex + \">\");\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/checkattribute\/parsing\/RawIRNode.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,695 @@\n+\/*\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.generators.*;\n+import jdk.incubator.vector.*;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8354242\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @summary test combining vector not operation with compare\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run driver compiler.vectorapi.VectorMaskCompareNotTest\n+ *\/\n+\n+public class VectorMaskCompareNotTest {\n+    private static int LENGTH = 128;\n+    private static final VectorSpecies<Byte> B_SPECIES = VectorSpecies.ofLargestShape(byte.class);\n+    private static final VectorSpecies<Short> S_SPECIES = VectorSpecies.ofLargestShape(short.class);\n+    private static final VectorSpecies<Integer> I_SPECIES = VectorSpecies.ofLargestShape(int.class);\n+    private static final VectorSpecies<Long> L_SPECIES = VectorSpecies.ofLargestShape(long.class);\n+    private static final VectorSpecies<Float> F_SPECIES = VectorSpecies.ofLargestShape(float.class);\n+    private static final VectorSpecies<Double> D_SPECIES = VectorSpecies.ofLargestShape(double.class);\n+    private static final Generators RD = Generators.G;\n+\n+    private static byte[] ba;\n+    private static byte[] bb;\n+    private static short[] sa;\n+    private static short[] sb;\n+    private static int[] ia;\n+    private static int[] ib;\n+    private static long[] la;\n+    private static long[] lb;\n+    private static float[] fa;\n+    private static float[] fb;\n+    private static float[] fnan;\n+    private static float[] fpinf;\n+    private static float[] fninf;\n+    private static double[] da;\n+    private static double[] db;\n+    private static double[] dnan;\n+    private static double[] dpinf;\n+    private static double[] dninf;\n+    private static boolean[] mr;\n+\n+    static {\n+        ba = new byte[LENGTH];\n+        bb = new byte[LENGTH];\n+        sa = new short[LENGTH];\n+        sb = new short[LENGTH];\n+        ia = new int[LENGTH];\n+        ib = new int[LENGTH];\n+        la = new long[LENGTH];\n+        lb = new long[LENGTH];\n+        fa = new float[LENGTH];\n+        fb = new float[LENGTH];\n+        fnan = new float[LENGTH];\n+        fpinf = new float[LENGTH];\n+        fninf = new float[LENGTH];\n+        da = new double[LENGTH];\n+        db = new double[LENGTH];\n+        dnan = new double[LENGTH];\n+        dpinf = new double[LENGTH];\n+        dninf = new double[LENGTH];\n+        mr = new boolean[LENGTH];\n+\n+        Generator<Integer> iGen = RD.ints();\n+        Generator<Long> lGen = RD.longs();\n+        \/\/ Use uniform generators for floating point numbers not to generate NaN values.\n+        Generator<Float> fGen = RD.uniformFloats(Float.MIN_VALUE, Float.MAX_VALUE);\n+        Generator<Double> dGen = RD.uniformDoubles(Double.MIN_VALUE, Double.MAX_VALUE);\n+        for (int i = 0; i < LENGTH; i++) {\n+            ba[i] = iGen.next().byteValue();\n+            bb[i] = iGen.next().byteValue();\n+            sa[i] = iGen.next().shortValue();\n+            sb[i] = iGen.next().shortValue();\n+            ia[i] = iGen.next();\n+            ib[i] = iGen.next();\n+            la[i] = lGen.next();\n+            lb[i] = lGen.next();\n+            fa[i] = fGen.next();\n+            fb[i] = fGen.next();\n+            fnan[i] = Float.NaN;\n+            fpinf[i] = Float.POSITIVE_INFINITY;\n+            fninf[i] = Float.NEGATIVE_INFINITY;\n+            da[i] = dGen.next();\n+            db[i] = dGen.next();\n+            dnan[i] = Double.NaN;\n+            dpinf[i] = Double.POSITIVE_INFINITY;\n+            dninf[i] = Double.NEGATIVE_INFINITY;\n+        }\n+    }\n+\n+    public static int compareUnsigned(Number a, Number b) {\n+        if (a instanceof Byte) {\n+            return Integer.compareUnsigned(Byte.toUnsignedInt(a.byteValue()), Byte.toUnsignedInt(b.byteValue()));\n+        } else if (a instanceof Short) {\n+            return Integer.compareUnsigned(Short.toUnsignedInt(a.shortValue()), Short.toUnsignedInt(b.shortValue()));\n+        } else if (a instanceof Integer) {\n+            return Integer.compareUnsigned(a.intValue(), b.intValue());\n+        } else if (a instanceof Long) {\n+            return Long.compareUnsigned(a.longValue(), b.longValue());\n+        }\n+        return 0;\n+    }\n+\n+    public static <T extends Number & Comparable<T>> void verifyResults(T a, T b, boolean r, VectorOperators.Comparison op) {\n+        if (op == VectorOperators.EQ) {\n+            \/\/ For floating point numbers, a is not NaN, b may be NaN. If b is NaN,\n+            \/\/ a.compareTo(b) will return 1, 1 != 0 is true, r is expected to be true.\n+            Asserts.assertEquals(a.compareTo(b) != 0, r);\n+        } else if (op == VectorOperators.NE) {\n+            \/\/ For floating point numbers, a is not NaN, b may be NaN. If b is NaN,\n+            \/\/ a.compareTo(b) will return 1, 1 == 0 is false, r is expected to be false.\n+            Asserts.assertEquals(a.compareTo(b) == 0, r);\n+        } else if (op == VectorOperators.LE) {\n+            Asserts.assertEquals(a.compareTo(b) > 0, r);\n+        } else if (op == VectorOperators.GE) {\n+            Asserts.assertEquals(a.compareTo(b) < 0, r);\n+        } else if (op == VectorOperators.LT) {\n+            Asserts.assertEquals(a.compareTo(b) >= 0, r);\n+        } else if (op == VectorOperators.GT) {\n+            Asserts.assertEquals(a.compareTo(b) <= 0, r);\n+        } else if (op == VectorOperators.ULE) {\n+            Asserts.assertEquals(compareUnsigned(a, b) > 0, r);\n+        } else if (op == VectorOperators.UGE) {\n+            Asserts.assertEquals(compareUnsigned(a, b) < 0, r);\n+        } else if (op == VectorOperators.ULT) {\n+            Asserts.assertEquals(compareUnsigned(a, b) >= 0, r);\n+        } else if (op == VectorOperators.UGT) {\n+            Asserts.assertEquals(compareUnsigned(a, b) <= 0, r);\n+        }\n+    }\n+\n+    interface VectorMaskOperator {\n+        public VectorMask apply(VectorMask m1);\n+    }\n+\n+    @ForceInline\n+    public static void testCompareMaskNotByte(VectorOperators.Comparison op, VectorMaskOperator func) {\n+        ByteVector av = ByteVector.fromArray(B_SPECIES, ba, 0);\n+        ByteVector bv = ByteVector.fromArray(B_SPECIES, bb, 0);\n+        VectorMask<Byte> m1 = av.compare(op, bv);\n+        func.apply(m1).intoArray(mr, 0);\n+\n+        for (int i = 0; i < B_SPECIES.length(); i++) {\n+            verifyResults(ba[i], bb[i], mr[i], op);\n+        }\n+    }\n+\n+    @ForceInline\n+    public static void testCompareMaskNotShort(VectorOperators.Comparison op, VectorMaskOperator func) {\n+        ShortVector av = ShortVector.fromArray(S_SPECIES, sa, 0);\n+        ShortVector bv = ShortVector.fromArray(S_SPECIES, sb, 0);\n+        VectorMask<Short> m1 = av.compare(op, bv);\n+        func.apply(m1).intoArray(mr, 0);\n+\n+        for (int i = 0; i < S_SPECIES.length(); i++) {\n+            verifyResults(sa[i], sb[i], mr[i], op);\n+        }\n+    }\n+\n+    @ForceInline\n+    public static void testCompareMaskNotInt(VectorOperators.Comparison op, VectorMaskOperator func) {\n+        IntVector av = IntVector.fromArray(I_SPECIES, ia, 0);\n+        IntVector bv = IntVector.fromArray(I_SPECIES, ib, 0);\n+        VectorMask<Integer> m1 = av.compare(op, bv);\n+        func.apply(m1).intoArray(mr, 0);\n+\n+        for (int i = 0; i < I_SPECIES.length(); i++) {\n+            verifyResults(ia[i], ib[i], mr[i], op);\n+        }\n+    }\n+\n+    @ForceInline\n+    public static void testCompareMaskNotLong(VectorOperators.Comparison op, VectorMaskOperator func) {\n+        LongVector av = LongVector.fromArray(L_SPECIES, la, 0);\n+        LongVector bv = LongVector.fromArray(L_SPECIES, lb, 0);\n+        VectorMask<Long> m1 = av.compare(op, bv);\n+        func.apply(m1).intoArray(mr, 0);\n+\n+        for (int i = 0; i < L_SPECIES.length(); i++) {\n+            verifyResults(la[i], lb[i], mr[i], op);\n+        }\n+    }\n+\n+    @ForceInline\n+    public static void testCompareMaskNotFloat(VectorOperators.Comparison op, float[] a, float[] b, VectorMaskOperator func) {\n+        FloatVector av = FloatVector.fromArray(F_SPECIES, a, 0);\n+        FloatVector bv = FloatVector.fromArray(F_SPECIES, b, 0);\n+        VectorMask<Float> m1 = av.compare(op, bv);\n+        func.apply(m1).intoArray(mr, 0);\n+\n+        for (int i = 0; i < F_SPECIES.length(); i++) {\n+            verifyResults(a[i], b[i], mr[i], op);\n+        }\n+    }\n+\n+    @ForceInline\n+    public static void testCompareMaskNotDouble(VectorOperators.Comparison op, double[] a, double[] b, VectorMaskOperator func) {\n+        DoubleVector av = DoubleVector.fromArray(D_SPECIES, a, 0);\n+        DoubleVector bv = DoubleVector.fromArray(D_SPECIES, b, 0);\n+        VectorMask<Double> m1 = av.compare(op, bv);\n+        func.apply(m1).intoArray(mr, 0);\n+\n+        for (int i = 0; i < D_SPECIES.length(); i++) {\n+            verifyResults(a[i], b[i], mr[i], op);\n+        }\n+    }\n+\n+    \/\/ Byte tests\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VB, \"= 0\", IRNode.VECTOR_MASK_CMP_B, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareEQMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.EQ, m -> m.not());\n+        testCompareMaskNotByte(VectorOperators.EQ, m -> m.xor(B_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VB, \"= 0\", IRNode.VECTOR_MASK_CMP_B, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareNEMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.NE, m -> m.not());\n+        testCompareMaskNotByte(VectorOperators.NE, m -> m.xor(B_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VB, \"= 0\", IRNode.VECTOR_MASK_CMP_B, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareLTMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.LT, m -> m.not());\n+        testCompareMaskNotByte(VectorOperators.LT, m -> m.xor(B_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VB, \"= 0\", IRNode.VECTOR_MASK_CMP_B, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareGTMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.GT, m -> m.not());\n+        testCompareMaskNotByte(VectorOperators.GT, m -> m.xor(B_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VB, \"= 0\", IRNode.VECTOR_MASK_CMP_B, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareLEMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.LE, m -> m.not());\n+        testCompareMaskNotByte(VectorOperators.LE, m -> m.xor(B_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VB, \"= 0\", IRNode.VECTOR_MASK_CMP_B, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareGEMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.GE, m -> m.not());\n+        testCompareMaskNotByte(VectorOperators.GE, m -> m.xor(B_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VB, \"= 0\", IRNode.VECTOR_MASK_CMP_B, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareULTMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.ULT, m -> m.not());\n+        testCompareMaskNotByte(VectorOperators.ULT, m -> m.xor(B_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VB, \"= 0\", IRNode.VECTOR_MASK_CMP_B, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareUGTMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.UGT, m -> m.not());\n+        testCompareMaskNotByte(VectorOperators.UGT, m -> m.xor(B_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VB, \"= 0\", IRNode.VECTOR_MASK_CMP_B, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareULEMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.ULE, m -> m.not());\n+        testCompareMaskNotByte(VectorOperators.ULE, m -> m.xor(B_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VB, \"= 0\", IRNode.VECTOR_MASK_CMP_B, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareUGEMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.UGE, m -> m.not());\n+        testCompareMaskNotByte(VectorOperators.UGE, m -> m.xor(B_SPECIES.maskAll(true)));\n+    }\n+\n+    \/\/ Short tests\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VS, \"= 0\", IRNode.VECTOR_MASK_CMP_S, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareEQMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.EQ, m -> m.not());\n+        testCompareMaskNotShort(VectorOperators.EQ, m -> m.xor(S_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VS, \"= 0\", IRNode.VECTOR_MASK_CMP_S, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareNEMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.NE, m -> m.not());\n+        testCompareMaskNotShort(VectorOperators.NE, m -> m.xor(S_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VS, \"= 0\", IRNode.VECTOR_MASK_CMP_S, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareLTMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.LT, m -> m.not());\n+        testCompareMaskNotShort(VectorOperators.LT, m -> m.xor(S_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VS, \"= 0\", IRNode.VECTOR_MASK_CMP_S, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareGTMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.GT, m -> m.not());\n+        testCompareMaskNotShort(VectorOperators.GT, m -> m.xor(S_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VS, \"= 0\", IRNode.VECTOR_MASK_CMP_S, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareLEMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.LE, m -> m.not());\n+        testCompareMaskNotShort(VectorOperators.LE, m -> m.xor(S_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VS, \"= 0\", IRNode.VECTOR_MASK_CMP_S, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareGEMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.GE, m -> m.not());\n+        testCompareMaskNotShort(VectorOperators.GE, m -> m.xor(S_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VS, \"= 0\", IRNode.VECTOR_MASK_CMP_S, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareULTMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.ULT, m -> m.not());\n+        testCompareMaskNotShort(VectorOperators.ULT, m -> m.xor(S_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VS, \"= 0\", IRNode.VECTOR_MASK_CMP_S, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareUGTMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.UGT, m -> m.not());\n+        testCompareMaskNotShort(VectorOperators.UGT, m -> m.xor(S_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VS, \"= 0\", IRNode.VECTOR_MASK_CMP_S, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareULEMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.ULE, m -> m.not());\n+        testCompareMaskNotShort(VectorOperators.ULE, m -> m.xor(S_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VS, \"= 0\", IRNode.VECTOR_MASK_CMP_S, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareUGEMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.UGE, m -> m.not());\n+        testCompareMaskNotShort(VectorOperators.UGE, m -> m.xor(S_SPECIES.maskAll(true)));\n+    }\n+\n+    \/\/ Int tests\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VI, \"= 0\", IRNode.VECTOR_MASK_CMP_I, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareEQMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.EQ, m -> m.not());\n+        testCompareMaskNotInt(VectorOperators.EQ, m -> m.xor(I_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VI, \"= 0\", IRNode.VECTOR_MASK_CMP_I, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareNEMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.NE, m -> m.not());\n+        testCompareMaskNotInt(VectorOperators.NE, m -> m.xor(I_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VI, \"= 0\", IRNode.VECTOR_MASK_CMP_I, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareLTMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.LT, m -> m.not());\n+        testCompareMaskNotInt(VectorOperators.LT, m -> m.xor(I_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VI, \"= 0\", IRNode.VECTOR_MASK_CMP_I, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareGTMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.GT, m -> m.not());\n+        testCompareMaskNotInt(VectorOperators.GT, m -> m.xor(I_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VI, \"= 0\", IRNode.VECTOR_MASK_CMP_I, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareLEMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.LE, m -> m.not());\n+        testCompareMaskNotInt(VectorOperators.LE, m -> m.xor(I_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VI, \"= 0\", IRNode.VECTOR_MASK_CMP_I, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareGEMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.GE, m -> m.not());\n+        testCompareMaskNotInt(VectorOperators.GE, m -> m.xor(I_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VI, \"= 0\", IRNode.VECTOR_MASK_CMP_I, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareULTMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.ULT, m -> m.not());\n+        testCompareMaskNotInt(VectorOperators.ULT, m -> m.xor(I_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VI, \"= 0\", IRNode.VECTOR_MASK_CMP_I, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareUGTMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.UGT, m -> m.not());\n+        testCompareMaskNotInt(VectorOperators.UGT, m -> m.xor(I_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VI, \"= 0\", IRNode.VECTOR_MASK_CMP_I, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareULEMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.ULE, m -> m.not());\n+        testCompareMaskNotInt(VectorOperators.ULE, m -> m.xor(I_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VI, \"= 0\", IRNode.VECTOR_MASK_CMP_I, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareUGEMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.UGE, m -> m.not());\n+        testCompareMaskNotInt(VectorOperators.UGE, m -> m.xor(I_SPECIES.maskAll(true)));\n+    }\n+\n+    \/\/ Long tests\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\", IRNode.VECTOR_MASK_CMP_L, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareEQMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.EQ, m -> m.not());\n+        testCompareMaskNotLong(VectorOperators.EQ, m -> m.xor(L_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\", IRNode.VECTOR_MASK_CMP_L, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareNEMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.NE, m -> m.not());\n+        testCompareMaskNotLong(VectorOperators.NE, m -> m.xor(L_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\", IRNode.VECTOR_MASK_CMP_L, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareLTMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.LT, m -> m.not());\n+        testCompareMaskNotLong(VectorOperators.LT, m -> m.xor(L_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\", IRNode.VECTOR_MASK_CMP_L, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareGTMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.GT, m -> m.not());\n+        testCompareMaskNotLong(VectorOperators.GT, m -> m.xor(L_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\", IRNode.VECTOR_MASK_CMP_L, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareLEMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.LE, m -> m.not());\n+        testCompareMaskNotLong(VectorOperators.LE, m -> m.xor(L_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\", IRNode.VECTOR_MASK_CMP_L, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareGEMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.GE, m -> m.not());\n+        testCompareMaskNotLong(VectorOperators.GE, m -> m.xor(L_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\", IRNode.VECTOR_MASK_CMP_L, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareULTMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.ULT, m -> m.not());\n+        testCompareMaskNotLong(VectorOperators.ULT, m -> m.xor(L_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\", IRNode.VECTOR_MASK_CMP_L, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareUGTMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.UGT, m -> m.not());\n+        testCompareMaskNotLong(VectorOperators.UGT, m -> m.xor(L_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\", IRNode.VECTOR_MASK_CMP_L, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareULEMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.ULE, m -> m.not());\n+        testCompareMaskNotLong(VectorOperators.ULE, m -> m.xor(L_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\", IRNode.VECTOR_MASK_CMP_L, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareUGEMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.UGE, m -> m.not());\n+        testCompareMaskNotLong(VectorOperators.UGE, m -> m.xor(L_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VI, \"= 0\", IRNode.VECTOR_MASK_CMP_F, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareEQMaskNotFloat() {\n+        testCompareMaskNotFloat(VectorOperators.EQ, fa, fb, m -> m.not());\n+        testCompareMaskNotFloat(VectorOperators.EQ, fa, fb, m -> m.xor(F_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VI, \"= 0\", IRNode.VECTOR_MASK_CMP_F, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareNEMaskNotFloat() {\n+        testCompareMaskNotFloat(VectorOperators.NE, fa, fb, m -> m.not());\n+        testCompareMaskNotFloat(VectorOperators.NE, fa, fb, m -> m.xor(F_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\", IRNode.VECTOR_MASK_CMP_F, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareEQMaskNotFloatNaN() {\n+        testCompareMaskNotFloat(VectorOperators.EQ, fa, fnan, m -> m.not());\n+        testCompareMaskNotFloat(VectorOperators.EQ, fa, fnan, m -> m.xor(F_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\", IRNode.VECTOR_MASK_CMP_F, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareNEMaskNotFloatNaN() {\n+        testCompareMaskNotFloat(VectorOperators.NE, fa, fnan, m -> m.not());\n+        testCompareMaskNotFloat(VectorOperators.NE, fa, fnan, m -> m.xor(F_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\", IRNode.VECTOR_MASK_CMP_F, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareEQMaskNotFloatPositiveInfinity() {\n+        testCompareMaskNotFloat(VectorOperators.EQ, fa, fpinf, m -> m.not());\n+        testCompareMaskNotFloat(VectorOperators.EQ, fa, fpinf, m -> m.xor(F_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\", IRNode.VECTOR_MASK_CMP_F, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareNEMaskNotFloatPositiveInfinity() {\n+        testCompareMaskNotFloat(VectorOperators.NE, fa, fpinf, m -> m.not());\n+        testCompareMaskNotFloat(VectorOperators.NE, fa, fpinf, m -> m.xor(F_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\", IRNode.VECTOR_MASK_CMP_F, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareEQMaskNotFloatNegativeInfinity() {\n+        testCompareMaskNotFloat(VectorOperators.EQ, fa, fninf, m -> m.not());\n+        testCompareMaskNotFloat(VectorOperators.EQ, fa, fninf, m -> m.xor(F_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\", IRNode.VECTOR_MASK_CMP_F, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareNEMaskNotFloatNegativeInfinity() {\n+        testCompareMaskNotFloat(VectorOperators.NE, fa, fninf, m -> m.not());\n+        testCompareMaskNotFloat(VectorOperators.NE, fa, fninf, m -> m.xor(F_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\", IRNode.VECTOR_MASK_CMP_D, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareEQMaskNotDouble() {\n+        testCompareMaskNotDouble(VectorOperators.EQ, da, db, m -> m.not());\n+        testCompareMaskNotDouble(VectorOperators.EQ, da, db, m -> m.xor(D_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\", IRNode.VECTOR_MASK_CMP_D, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareNEMaskNotDouble() {\n+        testCompareMaskNotDouble(VectorOperators.NE, da, db, m -> m.not());\n+        testCompareMaskNotDouble(VectorOperators.NE, da, db, m -> m.xor(D_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\", IRNode.VECTOR_MASK_CMP_D, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareEQMaskNotDoubleNaN() {\n+        testCompareMaskNotDouble(VectorOperators.EQ, da, dnan, m -> m.not());\n+        testCompareMaskNotDouble(VectorOperators.EQ, da, dnan, m -> m.xor(D_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\", IRNode.VECTOR_MASK_CMP_D, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareNEMaskNotDoubleNaN() {\n+        testCompareMaskNotDouble(VectorOperators.NE, da, dnan, m -> m.not());\n+        testCompareMaskNotDouble(VectorOperators.NE, da, dnan, m -> m.xor(D_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\", IRNode.VECTOR_MASK_CMP_D, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareEQMaskNotDoublePositiveInfinity() {\n+        testCompareMaskNotDouble(VectorOperators.EQ, da, dpinf, m -> m.not());\n+        testCompareMaskNotDouble(VectorOperators.EQ, da, dpinf, m -> m.xor(D_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\", IRNode.VECTOR_MASK_CMP_D, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareNEMaskNotDoublePositiveInfinity() {\n+        testCompareMaskNotDouble(VectorOperators.NE, da, dpinf, m -> m.not());\n+        testCompareMaskNotDouble(VectorOperators.NE, da, dpinf, m -> m.xor(D_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\", IRNode.VECTOR_MASK_CMP_D, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareEQMaskNotDoubleNegativeInfinity() {\n+        testCompareMaskNotDouble(VectorOperators.EQ, da, dninf, m -> m.not());\n+        testCompareMaskNotDouble(VectorOperators.EQ, da, dninf, m -> m.xor(D_SPECIES.maskAll(true)));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\", IRNode.VECTOR_MASK_CMP_D, \"= 2\" },\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\"})\n+    public static void testCompareNEMaskNotDoubleNegativeInfinity() {\n+        testCompareMaskNotDouble(VectorOperators.NE, da, dninf, m -> m.not());\n+        testCompareMaskNotDouble(VectorOperators.NE, da, dninf, m -> m.xor(D_SPECIES.maskAll(true)));\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.addFlags(\"--add-modules=jdk.incubator.vector\");\n+        testFramework.setDefaultWarmup(10000);\n+        testFramework.start();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskCompareNotTest.java","additions":695,"deletions":0,"binary":false,"changes":695,"status":"added"},{"patch":"@@ -0,0 +1,377 @@\n+\/*\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+\n+import jdk.incubator.vector.*;\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(jvmArgs = { \"--add-modules=jdk.incubator.vector\" })\n+public class MaskCompareNotBenchmark {\n+    @Param({\"4096\"})\n+    private int ARRAYLEN;\n+    private static Random r = new Random();\n+\n+    private static final VectorSpecies<Byte> B_SPECIES = ByteVector.SPECIES_MAX;\n+    private static final VectorSpecies<Short> S_SPECIES = ShortVector.SPECIES_MAX;\n+    private static final VectorSpecies<Integer> I_SPECIES = IntVector.SPECIES_MAX;\n+    private static final VectorSpecies<Long> L_SPECIES = LongVector.SPECIES_MAX;\n+    private static final VectorSpecies<Float> F_SPECIES = FloatVector.SPECIES_MAX;\n+    private static final VectorSpecies<Double> D_SPECIES = DoubleVector.SPECIES_MAX;\n+\n+    boolean[] mr;\n+    byte[] ba;\n+    byte[] bb;\n+    short[] sa;\n+    short[] sb;\n+    int[] ia;\n+    int[] ib;\n+    long[] la;\n+    long[] lb;\n+    float[] fa;\n+    float[] fb;\n+    double[] da;\n+    double[] db;\n+\n+    @Setup\n+    public void init() {\n+        mr = new boolean[ARRAYLEN];\n+        ba = new byte[ARRAYLEN];\n+        bb = new byte[ARRAYLEN];\n+        sa = new short[ARRAYLEN];\n+        sb = new short[ARRAYLEN];\n+        ia = new int[ARRAYLEN];\n+        ib = new int[ARRAYLEN];\n+        la = new long[ARRAYLEN];\n+        lb = new long[ARRAYLEN];\n+        fa = new float[ARRAYLEN];\n+        fb = new float[ARRAYLEN];\n+        da = new double[ARRAYLEN];\n+        db = new double[ARRAYLEN];\n+\n+        for (int i = 0; i < ARRAYLEN; i++) {\n+            mr[i] = r.nextBoolean();\n+            ba[i] = (byte) r.nextInt();\n+            bb[i] = (byte) r.nextInt();\n+            sa[i] = (short) r.nextInt();\n+            sb[i] = (short) r.nextInt();\n+            ia[i] = r.nextInt();\n+            ib[i] = r.nextInt();\n+            la[i] = r.nextLong();\n+            lb[i] = r.nextLong();\n+            fa[i] = r.nextFloat();\n+            fb[i] = r.nextFloat();\n+            da[i] = r.nextDouble();\n+            db[i] = r.nextDouble();\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    private void testCompareMaskNotByte(VectorOperators.Comparison op) {\n+        ByteVector bv = ByteVector.fromArray(B_SPECIES, bb, 0);\n+        for (int j = 0; j < ARRAYLEN; j += B_SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(B_SPECIES, ba, j);\n+            VectorMask<Byte> m = av.compare(op, bv).not();\n+            m.intoArray(mr, j);\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    private void testCompareMaskNotShort(VectorOperators.Comparison op) {\n+        ShortVector bv = ShortVector.fromArray(S_SPECIES, sb, 0);\n+        for (int j = 0; j < ARRAYLEN; j += S_SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(S_SPECIES, sa, j);\n+            VectorMask<Short> m = av.compare(op, bv).not();\n+            m.intoArray(mr, j);\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    private void testCompareMaskNotInt(VectorOperators.Comparison op) {\n+        IntVector bv = IntVector.fromArray(I_SPECIES, ib, 0);\n+        for (int j = 0; j < ARRAYLEN; j += I_SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(I_SPECIES, ia, j);\n+            VectorMask<Integer> m = av.compare(op, bv).not();\n+            m.intoArray(mr, j);\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    private void testCompareMaskNotLong(VectorOperators.Comparison op) {\n+        LongVector bv = LongVector.fromArray(L_SPECIES, lb, 0);\n+        for (int j = 0; j < ARRAYLEN; j += L_SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(L_SPECIES, la, j);\n+            VectorMask<Long> m = av.compare(op, bv).not();\n+            m.intoArray(mr, j);\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    private void testCompareMaskNotFloat(VectorOperators.Comparison op) {\n+        FloatVector bv = FloatVector.fromArray(F_SPECIES, fb, 0);\n+        for (int j = 0; j < ARRAYLEN; j += F_SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(F_SPECIES, fa, j);\n+            VectorMask<Float> m = av.compare(op, bv).not();\n+            m.intoArray(mr, j);\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    private void testCompareMaskNotDouble(VectorOperators.Comparison op) {\n+        DoubleVector bv = DoubleVector.fromArray(D_SPECIES, db, 0);\n+        for (int j = 0; j < ARRAYLEN; j += D_SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(D_SPECIES, da, j);\n+            VectorMask<Double> m = av.compare(op, bv).not();\n+            m.intoArray(mr, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testCompareEQMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.EQ);\n+    }\n+\n+    @Benchmark\n+    public void testCompareNEMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.NE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareLTMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.LT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareGTMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.GT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareLEMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.LE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareGEMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.GE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareULTMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.ULT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareUGTMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.UGT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareULEMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.ULE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareUGEMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.UGE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareEQMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.EQ);\n+    }\n+\n+    @Benchmark\n+    public void testCompareNEMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.NE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareLTMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.LT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareGTMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.GT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareLEMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.LE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareGEMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.GE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareULTMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.ULT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareUGTMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.UGT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareULEMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.ULE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareUGEMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.UGE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareEQMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.EQ);\n+    }\n+\n+    @Benchmark\n+    public void testCompareNEMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.NE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareLTMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.LT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareGTMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.GT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareLEMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.LE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareGEMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.GE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareULTMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.ULT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareUGTMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.UGT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareULEMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.ULE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareUGEMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.UGE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareEQMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.EQ);\n+    }\n+\n+    @Benchmark\n+    public void testCompareNEMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.NE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareLTMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.LT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareGTMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.GT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareLEMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.LE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareGEMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.GE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareULTMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.ULT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareUGTMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.UGT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareULEMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.ULE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareUGEMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.UGE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareEQMaskNotFloat() {\n+        testCompareMaskNotFloat(VectorOperators.EQ);\n+    }\n+\n+    @Benchmark\n+    public void testCompareNEMaskNotFloat() {\n+        testCompareMaskNotFloat(VectorOperators.NE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareEQMaskNotDouble() {\n+        testCompareMaskNotDouble(VectorOperators.EQ);\n+    }\n+\n+    @Benchmark\n+    public void testCompareNEMaskNotDouble() {\n+        testCompareMaskNotDouble(VectorOperators.NE);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/MaskCompareNotBenchmark.java","additions":377,"deletions":0,"binary":false,"changes":377,"status":"added"}]}