{"files":[{"patch":"@@ -1219,0 +1219,3 @@\n+  } else if (n->Opcode() == Op_XorV || n->Opcode() == Op_XorVMask) {\n+    \/\/ Condition for XorVMask(VectorMaskCmp(x,y,cond), MaskAll(true)) ==> VectorMaskCmp(x,y,ncond)\n+    return true;\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -331,1 +331,3 @@\n-  mask negate( ) const { return mask(_test^4); }\n+  mask negate( ) const { return negate_mask(_test); }\n+  \/\/ Return the negative mask for the given mask, for both signed and unsigned comparison.\n+  static mask negate_mask(mask btm) { return mask(btm ^ 4); }\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2166,0 +2166,90 @@\n+\/\/ Returns whether (XorV (VectorMaskCmp) -1) can be optimized by negating the\n+\/\/ comparison operation.\n+bool VectorMaskCmpNode::predicate_can_be_negated() {\n+  switch (_predicate) {\n+    case BoolTest::eq:\n+    case BoolTest::ne:\n+      \/\/ eq and ne also apply to floating-point special values like NaN and infinities.\n+      return true;\n+    case BoolTest::le:\n+    case BoolTest::ge:\n+    case BoolTest::lt:\n+    case BoolTest::gt:\n+    case BoolTest::ule:\n+    case BoolTest::uge:\n+    case BoolTest::ult:\n+    case BoolTest::ugt: {\n+      BasicType bt = vect_type()->element_basic_type();\n+      \/\/ For float and double, we don't know if either comparison operand is a\n+      \/\/ NaN, NaN {le|ge|lt|gt} anything is false, resulting in inconsistent\n+      \/\/ results before and after negation.\n+      return is_integral_type(bt);\n+    }\n+    default:\n+      return false;\n+  }\n+}\n+\n+\/\/ This function transforms the following patterns:\n+\/\/\n+\/\/ For integer types:\n+\/\/ (XorV (VectorMaskCmp src1 src2 cond) (Replicate -1))\n+\/\/    => (VectorMaskCmp src1 src2 ncond)\n+\/\/ (XorVMask (VectorMaskCmp src1 src2 cond) (MaskAll m1))\n+\/\/    => (VectorMaskCmp src1 src2 ncond)\n+\/\/ (XorV (VectorMaskCast (VectorMaskCmp src1 src2 cond)) (Replicate -1))\n+\/\/    => (VectorMaskCast (VectorMaskCmp src1 src2 ncond))\n+\/\/ (XorVMask (VectorMaskCast (VectorMaskCmp src1 src2 cond)) (MaskAll m1))\n+\/\/    => (VectorMaskCast (VectorMaskCmp src1 src2 ncond))\n+\/\/ cond can be eq, ne, le, ge, lt, gt, ule, uge, ult and ugt.\n+\/\/ ncond is the negative comparison of cond.\n+\/\/\n+\/\/ For float and double types:\n+\/\/ (XorV (VectorMaskCast (VectorMaskCmp src1 src2 cond)) (Replicate -1))\n+\/\/    => (VectorMaskCast (VectorMaskCmp src1 src2 ncond))\n+\/\/ (XorVMask (VectorMaskCast (VectorMaskCmp src1 src2 cond)) (MaskAll m1))\n+\/\/    => (VectorMaskCast (VectorMaskCmp src1 src2 ncond))\n+\/\/ cond can be eq or ne.\n+Node* XorVNode::Ideal_XorV_VectorMaskCmp(PhaseGVN* phase, bool can_reshape) {\n+  Node* in1 = in(1);\n+  Node* in2 = in(2);\n+  \/\/ Transformations for predicated vectors are not supported for now.\n+  if (is_predicated_vector() ||\n+      in1->is_predicated_vector() ||\n+      in2->is_predicated_vector()) {\n+    return nullptr;\n+  }\n+\n+  \/\/ XorV\/XorVMask is commutative, swap VectorMaskCmp\/VectorMaskCast to in1.\n+  if (VectorNode::is_all_ones_vector(in1)) {\n+    swap(in1, in2);\n+  }\n+\n+  bool with_vector_mask_cast = false;\n+  \/\/ VectorMaskCast and VectorMaskCmp should only have a single use,\n+  \/\/ otherwise the optimization may be unprofitable.\n+  if (in1->Opcode() == Op_VectorMaskCast) {\n+    if (in1->outcnt() != 1) {\n+      return nullptr;\n+    }\n+    with_vector_mask_cast = true;\n+    in1 = in1->in(1);\n+  }\n+  if (in1->Opcode() != Op_VectorMaskCmp ||\n+      in1->outcnt() != 1 ||\n+      !(in1->as_VectorMaskCmp())->predicate_can_be_negated() ||\n+      !VectorNode::is_all_ones_vector(in2)) {\n+    return nullptr;\n+  }\n+\n+  BoolTest::mask neg_cond = BoolTest::negate_mask((in1->as_VectorMaskCmp())->get_predicate());\n+  ConINode* predicate_node = phase->intcon(neg_cond);\n+  const TypeVect* vt = in1->as_Vector()->vect_type();\n+  Node* res = new VectorMaskCmpNode(neg_cond, in1->in(1), in1->in(2), predicate_node, vt);\n+  if (with_vector_mask_cast) {\n+    \/\/ We optimized out a VectorMaskCast, regenerate one to ensure type correctness.\n+    res = new VectorMaskCastNode(phase->transform(res), vect_type());\n+  }\n+  return res;\n+}\n+\n@@ -2179,1 +2269,6 @@\n-  return VectorNode::Ideal(phase, can_reshape);\n+\n+  Node* res = Ideal_XorV_VectorMaskCmp(phase, can_reshape);\n+  if (res == nullptr) {\n+    res = VectorNode::Ideal(phase, can_reshape);\n+  }\n+  return res;\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":96,"deletions":1,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -1015,0 +1015,1 @@\n+  Node* Ideal_XorV_VectorMaskCmp(PhaseGVN* phase, bool can_reshape);\n@@ -1687,0 +1688,1 @@\n+  bool predicate_can_be_negated();\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2270,0 +2270,5 @@\n+    public static final String VECTOR_MASK_CMP = PREFIX + \"VECTOR_MASK_CMP\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_MASK_CMP, \"VectorMaskCmp\");\n+    }\n+\n@@ -2680,0 +2685,5 @@\n+    public static final String XOR_V = PREFIX + \"XOR_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(XOR_V, \"XorV\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,1259 @@\n+\/*\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.generators.*;\n+import compiler.lib.ir_framework.*;\n+import jdk.incubator.vector.*;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8354242\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @summary test combining vector not operation with compare\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run driver compiler.vectorapi.VectorMaskCompareNotTest\n+ *\/\n+\n+public class VectorMaskCompareNotTest {\n+    private static int LENGTH = 128;\n+\n+    private static final VectorSpecies<Byte> B_SPECIES = VectorSpecies.ofLargestShape(byte.class);\n+    private static final VectorSpecies<Short> S_SPECIES = VectorSpecies.ofLargestShape(short.class);\n+    private static final VectorSpecies<Integer> I_SPECIES = VectorSpecies.ofLargestShape(int.class);\n+    private static final VectorSpecies<Long> L_SPECIES = VectorSpecies.ofLargestShape(long.class);\n+    private static final VectorSpecies<Float> F_SPECIES = VectorSpecies.ofLargestShape(float.class);\n+    private static final VectorSpecies<Double> D_SPECIES = VectorSpecies.ofLargestShape(double.class);\n+\n+    \/\/ Vector species for vector mask cast operation between int and long types,\n+    \/\/ they must have the same number of elements.\n+    \/\/ For other types, use a vector species of the specified width.\n+    private static final VectorSpecies<Long> L_SPECIES_FOR_CAST = VectorSpecies.ofLargestShape(long.class);\n+    private static final VectorSpecies<Integer> I_SPECIES_FOR_CAST = VectorSpecies.of(int.class, VectorShape.forBitSize(L_SPECIES_FOR_CAST.vectorBitSize() \/ 2));\n+\n+    private static final Generators RD = Generators.G;\n+\n+    private static byte[] ba;\n+    private static byte[] bb;\n+    private static short[] sa;\n+    private static short[] sb;\n+    private static int[] ia;\n+    private static int[] ib;\n+    private static int[] ic;\n+    private static long[] la;\n+    private static long[] lb;\n+    private static float[] fa;\n+    private static float[] fb;\n+    private static float[] fnan;\n+    private static float[] fpinf;\n+    private static float[] fninf;\n+    private static double[] da;\n+    private static double[] db;\n+    private static double[] dnan;\n+    private static double[] dpinf;\n+    private static double[] dninf;\n+    private static boolean[] mr;\n+\n+    static {\n+        ba = new byte[LENGTH];\n+        bb = new byte[LENGTH];\n+        sa = new short[LENGTH];\n+        sb = new short[LENGTH];\n+        ia = new int[LENGTH];\n+        ib = new int[LENGTH];\n+        ic = new int[LENGTH];\n+        la = new long[LENGTH];\n+        lb = new long[LENGTH];\n+        fa = new float[LENGTH];\n+        fb = new float[LENGTH];\n+        fnan = new float[LENGTH];\n+        fpinf = new float[LENGTH];\n+        fninf = new float[LENGTH];\n+        da = new double[LENGTH];\n+        db = new double[LENGTH];\n+        dnan = new double[LENGTH];\n+        dpinf = new double[LENGTH];\n+        dninf = new double[LENGTH];\n+        mr = new boolean[LENGTH];\n+\n+        Generator<Integer> iGen = RD.ints();\n+        Generator<Long> lGen = RD.longs();\n+        \/\/ Use uniform generators for floating point numbers not to generate NaN values.\n+        Generator<Float> fGen = RD.uniformFloats(Float.MIN_VALUE, Float.MAX_VALUE);\n+        Generator<Double> dGen = RD.uniformDoubles(Double.MIN_VALUE, Double.MAX_VALUE);\n+        for (int i = 0; i < LENGTH; i++) {\n+            ba[i] = iGen.next().byteValue();\n+            bb[i] = iGen.next().byteValue();\n+            sa[i] = iGen.next().shortValue();\n+            sb[i] = iGen.next().shortValue();\n+            ia[i] = iGen.next();\n+            ib[i] = iGen.next();\n+            la[i] = lGen.next();\n+            lb[i] = lGen.next();\n+            fa[i] = fGen.next();\n+            fb[i] = fGen.next();\n+            fnan[i] = Float.NaN;\n+            fpinf[i] = Float.POSITIVE_INFINITY;\n+            fninf[i] = Float.NEGATIVE_INFINITY;\n+            da[i] = dGen.next();\n+            db[i] = dGen.next();\n+            dnan[i] = Double.NaN;\n+            dpinf[i] = Double.POSITIVE_INFINITY;\n+            dninf[i] = Double.NEGATIVE_INFINITY;\n+        }\n+    }\n+\n+    public static int compareUnsigned(Number a, Number b) {\n+        if (a instanceof Byte) {\n+            return Integer.compareUnsigned(Byte.toUnsignedInt(a.byteValue()), Byte.toUnsignedInt(b.byteValue()));\n+        } else if (a instanceof Short) {\n+            return Integer.compareUnsigned(Short.toUnsignedInt(a.shortValue()), Short.toUnsignedInt(b.shortValue()));\n+        } else if (a instanceof Integer) {\n+            return Integer.compareUnsigned(a.intValue(), b.intValue());\n+        } else if (a instanceof Long) {\n+            return Long.compareUnsigned(a.longValue(), b.longValue());\n+        } else {\n+            throw new IllegalArgumentException(\"Unsupported type for unsigned comparison: \" + a.getClass() + \", \" + b.getClass());\n+        }\n+    }\n+\n+    public static <T extends Number & Comparable<T>> void compareResults(T a, T b, boolean r, VectorOperators.Comparison op) {\n+        if (op == VectorOperators.EQ) {\n+            \/\/ For floating point numbers, a is not NaN, b may be NaN. If b is NaN,\n+            \/\/ a.compareTo(b) will return 1, 1 != 0 is true, r is expected to be true.\n+            Asserts.assertEquals(a.compareTo(b) != 0, r);\n+        } else if (op == VectorOperators.NE) {\n+            \/\/ For floating point numbers, a is not NaN, b may be NaN. If b is NaN,\n+            \/\/ a.compareTo(b) will return 1, 1 == 0 is false, r is expected to be false.\n+            Asserts.assertEquals(a.compareTo(b) == 0, r);\n+        } else if (op == VectorOperators.LE) {\n+            Asserts.assertEquals(a.compareTo(b) > 0, r);\n+        } else if (op == VectorOperators.GE) {\n+            Asserts.assertEquals(a.compareTo(b) < 0, r);\n+        } else if (op == VectorOperators.LT) {\n+            Asserts.assertEquals(a.compareTo(b) >= 0, r);\n+        } else if (op == VectorOperators.GT) {\n+            Asserts.assertEquals(a.compareTo(b) <= 0, r);\n+        } else if (op == VectorOperators.ULE) {\n+            Asserts.assertEquals(compareUnsigned(a, b) > 0, r);\n+        } else if (op == VectorOperators.UGE) {\n+            Asserts.assertEquals(compareUnsigned(a, b) < 0, r);\n+        } else if (op == VectorOperators.ULT) {\n+            Asserts.assertEquals(compareUnsigned(a, b) >= 0, r);\n+        } else if (op == VectorOperators.UGT) {\n+            Asserts.assertEquals(compareUnsigned(a, b) <= 0, r);\n+        } else {\n+            throw new IllegalArgumentException(\"Unknown comparison operator: \" + op);\n+        }\n+    }\n+\n+    @DontInline\n+    public static void verifyResultsByte(VectorSpecies<Byte> vs, VectorOperators.Comparison op) {\n+        for (int i = 0; i < vs.length(); i++) {\n+            compareResults(ba[i], bb[i], mr[i], op);\n+        }\n+    }\n+\n+    @DontInline\n+    public static void verifyResultsShort(VectorSpecies<Short> vs, VectorOperators.Comparison op) {\n+        for (int i = 0; i < vs.length(); i++) {\n+            compareResults(sa[i], sb[i], mr[i], op);\n+        }\n+    }\n+\n+    @DontInline\n+    public static void verifyResultsInt(VectorSpecies<Integer> vs, VectorOperators.Comparison op) {\n+        for (int i = 0; i < vs.length(); i++) {\n+            compareResults(ia[i], ib[i], mr[i], op);\n+        }\n+    }\n+\n+    @DontInline\n+    public static void verifyResultsLong(VectorSpecies<Long> vs, VectorOperators.Comparison op) {\n+        for (int i = 0; i < vs.length(); i++) {\n+            compareResults(la[i], lb[i], mr[i], op);\n+        }\n+    }\n+\n+    @DontInline\n+    public static void verifyResultsFloat(VectorSpecies<Float> vs, VectorOperators.Comparison op, float[] a, float[] b) {\n+        for (int i = 0; i < vs.length(); i++) {\n+            compareResults(a[i], b[i], mr[i], op);\n+        }\n+    }\n+\n+    @DontInline\n+    public static void verifyResultsDouble(VectorSpecies<Double> vs, VectorOperators.Comparison op, double[] a, double[] b) {\n+        for (int i = 0; i < vs.length(); i++) {\n+            compareResults(a[i], b[i], mr[i], op);\n+        }\n+    }\n+\n+    interface VectorMaskOperator {\n+        public VectorMask apply(VectorMask m);\n+    }\n+\n+    @ForceInline\n+    public static void testCompareMaskNotByte(VectorSpecies<Byte> vs, VectorOperators.Comparison op, VectorMaskOperator func) {\n+        ByteVector av = ByteVector.fromArray(vs, ba, 0);\n+        ByteVector bv = ByteVector.fromArray(vs, bb, 0);\n+        VectorMask<Byte> m = av.compare(op, bv);\n+        func.apply(m).intoArray(mr, 0);\n+    }\n+\n+    @ForceInline\n+    public static void testCompareMaskNotShort(VectorSpecies<Short> vs, VectorOperators.Comparison op, VectorMaskOperator func) {\n+        ShortVector av = ShortVector.fromArray(vs, sa, 0);\n+        ShortVector bv = ShortVector.fromArray(vs, sb, 0);\n+        VectorMask<Short> m = av.compare(op, bv);\n+        func.apply(m).intoArray(mr, 0);\n+    }\n+\n+    @ForceInline\n+    public static void testCompareMaskNotInt(VectorSpecies<Integer> vs, VectorOperators.Comparison op, VectorMaskOperator func) {\n+        IntVector av = IntVector.fromArray(vs, ia, 0);\n+        IntVector bv = IntVector.fromArray(vs, ib, 0);\n+        VectorMask<Integer> m = av.compare(op, bv);\n+        func.apply(m).intoArray(mr, 0);\n+    }\n+\n+    @ForceInline\n+    public static void testCompareMaskNotLong(VectorSpecies<Long> vs, VectorOperators.Comparison op, VectorMaskOperator func) {\n+        LongVector av = LongVector.fromArray(vs, la, 0);\n+        LongVector bv = LongVector.fromArray(vs, lb, 0);\n+        VectorMask<Long> m = av.compare(op, bv);\n+        func.apply(m).intoArray(mr, 0);\n+    }\n+\n+    @ForceInline\n+    public static void testCompareMaskNotFloat(VectorSpecies<Float> vs, VectorOperators.Comparison op, float[] a, float[] b, VectorMaskOperator func) {\n+        FloatVector av = FloatVector.fromArray(vs, a, 0);\n+        FloatVector bv = FloatVector.fromArray(vs, b, 0);\n+        VectorMask<Float> m = av.compare(op, bv);\n+        func.apply(m).intoArray(mr, 0);\n+    }\n+\n+    @ForceInline\n+    public static void testCompareMaskNotDouble(VectorSpecies<Double> vs, VectorOperators.Comparison op, double[] a, double[] b, VectorMaskOperator func) {\n+        DoubleVector av = DoubleVector.fromArray(vs, a, 0);\n+        DoubleVector bv = DoubleVector.fromArray(vs, b, 0);\n+        VectorMask<Double> m = av.compare(op, bv);\n+        func.apply(m).intoArray(mr, 0);\n+    }\n+\n+    \/\/ Byte tests\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareEQMaskNotByte() {\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.EQ, (m) -> { return m.not(); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.EQ);\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.EQ, (m) -> { return B_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.EQ);\n+\n+        testCompareMaskNotByte(ByteVector.SPECIES_64, VectorOperators.EQ, (m) -> { return m.cast(ShortVector.SPECIES_128).not(); });\n+        verifyResultsByte(ByteVector.SPECIES_64, VectorOperators.EQ);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareNEMaskNotByte() {\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.NE, (m) -> { return m.not(); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.NE);\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.NE, (m) -> { return B_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.NE);\n+\n+        testCompareMaskNotByte(ByteVector.SPECIES_64, VectorOperators.NE, (m) -> { return m.cast(ShortVector.SPECIES_128).not(); });\n+        verifyResultsByte(ByteVector.SPECIES_64, VectorOperators.NE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareLTMaskNotByte() {\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.LT, (m) -> { return m.not(); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.LT);\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.LT, (m) -> { return B_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.LT);\n+\n+        testCompareMaskNotByte(ByteVector.SPECIES_64, VectorOperators.LT, (m) -> { return m.cast(ShortVector.SPECIES_128).not(); });\n+        verifyResultsByte(ByteVector.SPECIES_64, VectorOperators.LT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareGTMaskNotByte() {\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.GT, (m) -> { return m.not(); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.GT);\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.GT, (m) -> { return B_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.GT);\n+\n+        testCompareMaskNotByte(ByteVector.SPECIES_64, VectorOperators.GT, (m) -> { return m.cast(ShortVector.SPECIES_128).not(); });\n+        verifyResultsByte(ByteVector.SPECIES_64, VectorOperators.GT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareLEMaskNotByte() {\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.LE, (m) -> { return m.not(); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.LE);\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.LE, (m) -> { return B_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.LE);\n+\n+        testCompareMaskNotByte(ByteVector.SPECIES_64, VectorOperators.LE, (m) -> { return m.cast(ShortVector.SPECIES_128).not(); });\n+        verifyResultsByte(ByteVector.SPECIES_64, VectorOperators.LE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareGEMaskNotByte() {\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.GE, (m) -> { return m.not(); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.GE);\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.GE, (m) -> { return B_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.GE);\n+\n+        testCompareMaskNotByte(ByteVector.SPECIES_64, VectorOperators.GE, (m) -> { return m.cast(ShortVector.SPECIES_128).not(); });\n+        verifyResultsByte(ByteVector.SPECIES_64, VectorOperators.GE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareULTMaskNotByte() {\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.ULT, (m) -> { return m.not(); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.ULT);\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.ULT, (m) -> { return B_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.ULT);\n+\n+        testCompareMaskNotByte(ByteVector.SPECIES_64, VectorOperators.ULT, (m) -> { return m.cast(ShortVector.SPECIES_128).not(); });\n+        verifyResultsByte(ByteVector.SPECIES_64, VectorOperators.ULT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareUGTMaskNotByte() {\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.UGT, (m) -> { return m.not(); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.UGT);\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.UGT, (m) -> { return B_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.UGT);\n+\n+        testCompareMaskNotByte(ByteVector.SPECIES_64, VectorOperators.UGT, (m) -> { return m.cast(ShortVector.SPECIES_128).not(); });\n+        verifyResultsByte(ByteVector.SPECIES_64, VectorOperators.UGT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareULEMaskNotByte() {\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.ULE, (m) -> { return m.not(); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.ULE);\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.ULE, (m) -> { return B_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.ULE);\n+\n+        testCompareMaskNotByte(ByteVector.SPECIES_64, VectorOperators.ULE, (m) -> { return m.cast(ShortVector.SPECIES_128).not(); });\n+        verifyResultsByte(ByteVector.SPECIES_64, VectorOperators.ULE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareUGEMaskNotByte() {\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.UGE, (m) -> { return m.not(); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.UGE);\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.UGE, (m) -> { return B_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.UGE);\n+\n+        testCompareMaskNotByte(ByteVector.SPECIES_64, VectorOperators.UGE, (m) -> { return m.cast(ShortVector.SPECIES_128).not(); });\n+        verifyResultsByte(ByteVector.SPECIES_64, VectorOperators.UGE);\n+    }\n+\n+    \/\/ Short tests\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareEQMaskNotShort() {\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.EQ, (m) -> { return m.not(); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.EQ);\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.EQ, (m) -> { return S_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.EQ);\n+\n+        testCompareMaskNotShort(ShortVector.SPECIES_64, VectorOperators.EQ, (m) -> { return IntVector.SPECIES_128.maskAll(true).xor(m.cast(IntVector.SPECIES_128)); });\n+        verifyResultsShort(ShortVector.SPECIES_64, VectorOperators.EQ);\n+        testCompareMaskNotShort(ShortVector.SPECIES_128, VectorOperators.EQ, (m) -> { return m.cast(ByteVector.SPECIES_64).not(); });\n+        verifyResultsShort(ShortVector.SPECIES_128, VectorOperators.EQ);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareNEMaskNotShort() {\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.NE, (m) -> { return m.not(); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.NE);\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.NE, (m) -> { return S_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.NE);\n+\n+        testCompareMaskNotShort(ShortVector.SPECIES_64, VectorOperators.NE, (m) -> { return IntVector.SPECIES_128.maskAll(true).xor(m.cast(IntVector.SPECIES_128)); });\n+        verifyResultsShort(ShortVector.SPECIES_64, VectorOperators.NE);\n+        testCompareMaskNotShort(ShortVector.SPECIES_128, VectorOperators.NE, (m) -> { return m.cast(ByteVector.SPECIES_64).not(); });\n+        verifyResultsShort(ShortVector.SPECIES_128, VectorOperators.NE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareLTMaskNotShort() {\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.LT, (m) -> { return m.not(); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.LT);\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.LT, (m) -> { return S_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.LT);\n+\n+        testCompareMaskNotShort(ShortVector.SPECIES_64, VectorOperators.LT, (m) -> { return IntVector.SPECIES_128.maskAll(true).xor(m.cast(IntVector.SPECIES_128)); });\n+        verifyResultsShort(ShortVector.SPECIES_64, VectorOperators.LT);\n+        testCompareMaskNotShort(ShortVector.SPECIES_128, VectorOperators.LT, (m) -> { return m.cast(ByteVector.SPECIES_64).not(); });\n+        verifyResultsShort(ShortVector.SPECIES_128, VectorOperators.LT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareGTMaskNotShort() {\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.GT, (m) -> { return m.not(); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.GT);\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.GT, (m) -> { return S_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.GT);\n+\n+        testCompareMaskNotShort(ShortVector.SPECIES_64, VectorOperators.GT, (m) -> { return IntVector.SPECIES_128.maskAll(true).xor(m.cast(IntVector.SPECIES_128)); });\n+        verifyResultsShort(ShortVector.SPECIES_64, VectorOperators.GT);\n+        testCompareMaskNotShort(ShortVector.SPECIES_128, VectorOperators.GT, (m) -> { return m.cast(ByteVector.SPECIES_64).not(); });\n+        verifyResultsShort(ShortVector.SPECIES_128, VectorOperators.GT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareLEMaskNotShort() {\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.LE, (m) -> { return m.not(); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.LE);\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.LE, (m) -> { return S_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.LE);\n+\n+        testCompareMaskNotShort(ShortVector.SPECIES_64, VectorOperators.LE, (m) -> { return IntVector.SPECIES_128.maskAll(true).xor(m.cast(IntVector.SPECIES_128)); });\n+        verifyResultsShort(ShortVector.SPECIES_64, VectorOperators.LE);\n+        testCompareMaskNotShort(ShortVector.SPECIES_128, VectorOperators.LE, (m) -> { return m.cast(ByteVector.SPECIES_64).not(); });\n+        verifyResultsShort(ShortVector.SPECIES_128, VectorOperators.LE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareGEMaskNotShort() {\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.GE, (m) -> { return m.not(); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.GE);\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.GE, (m) -> { return S_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.GE);\n+\n+        testCompareMaskNotShort(ShortVector.SPECIES_64, VectorOperators.GE, (m) -> { return IntVector.SPECIES_128.maskAll(true).xor(m.cast(IntVector.SPECIES_128)); });\n+        verifyResultsShort(ShortVector.SPECIES_64, VectorOperators.GE);\n+        testCompareMaskNotShort(ShortVector.SPECIES_128, VectorOperators.GE, (m) -> { return m.cast(ByteVector.SPECIES_64).not(); });\n+        verifyResultsShort(ShortVector.SPECIES_128, VectorOperators.GE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareULTMaskNotShort() {\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.ULT, (m) -> { return m.not(); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.ULT);\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.ULT, (m) -> { return S_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.ULT);\n+\n+        testCompareMaskNotShort(ShortVector.SPECIES_64, VectorOperators.ULT, (m) -> { return IntVector.SPECIES_128.maskAll(true).xor(m.cast(IntVector.SPECIES_128)); });\n+        verifyResultsShort(ShortVector.SPECIES_64, VectorOperators.ULT);\n+        testCompareMaskNotShort(ShortVector.SPECIES_128, VectorOperators.ULT, (m) -> { return m.cast(ByteVector.SPECIES_64).not(); });\n+        verifyResultsShort(ShortVector.SPECIES_128, VectorOperators.ULT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareUGTMaskNotShort() {\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.UGT, (m) -> { return m.not(); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.UGT);\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.UGT, (m) -> { return S_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.UGT);\n+\n+        testCompareMaskNotShort(ShortVector.SPECIES_64, VectorOperators.UGT, (m) -> { return IntVector.SPECIES_128.maskAll(true).xor(m.cast(IntVector.SPECIES_128)); });\n+        verifyResultsShort(ShortVector.SPECIES_64, VectorOperators.UGT);\n+        testCompareMaskNotShort(ShortVector.SPECIES_128, VectorOperators.UGT, (m) -> { return m.cast(ByteVector.SPECIES_64).not(); });\n+        verifyResultsShort(ShortVector.SPECIES_128, VectorOperators.UGT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareULEMaskNotShort() {\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.ULE, (m) -> { return m.not(); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.ULE);\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.ULE, (m) -> { return S_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.ULE);\n+\n+        testCompareMaskNotShort(ShortVector.SPECIES_64, VectorOperators.ULE, (m) -> { return IntVector.SPECIES_128.maskAll(true).xor(m.cast(IntVector.SPECIES_128)); });\n+        verifyResultsShort(ShortVector.SPECIES_64, VectorOperators.ULE);\n+        testCompareMaskNotShort(ShortVector.SPECIES_128, VectorOperators.ULE, (m) -> { return m.cast(ByteVector.SPECIES_64).not(); });\n+        verifyResultsShort(ShortVector.SPECIES_128, VectorOperators.ULE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareUGEMaskNotShort() {\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.UGE, (m) -> { return m.not(); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.UGE);\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.UGE, (m) -> { return S_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.UGE);\n+\n+        testCompareMaskNotShort(ShortVector.SPECIES_64, VectorOperators.UGE, (m) -> { return IntVector.SPECIES_128.maskAll(true).xor(m.cast(IntVector.SPECIES_128)); });\n+        verifyResultsShort(ShortVector.SPECIES_64, VectorOperators.UGE);\n+        testCompareMaskNotShort(ShortVector.SPECIES_128, VectorOperators.UGE, (m) -> { return m.cast(ByteVector.SPECIES_64).not(); });\n+        verifyResultsShort(ShortVector.SPECIES_128, VectorOperators.UGE);\n+    }\n+\n+    \/\/ Int tests\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareEQMaskNotInt() {\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.EQ, (m) -> { return m.not(); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.EQ);\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.EQ, (m) -> { return I_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.EQ);\n+\n+        testCompareMaskNotInt(I_SPECIES_FOR_CAST, VectorOperators.EQ, (m) -> { return L_SPECIES_FOR_CAST.maskAll(true).xor(m.cast(L_SPECIES_FOR_CAST)); });\n+        verifyResultsInt(I_SPECIES_FOR_CAST, VectorOperators.EQ);\n+        testCompareMaskNotInt(IntVector.SPECIES_128, VectorOperators.EQ, (m) -> { return m.cast(ShortVector.SPECIES_64).not(); });\n+        verifyResultsInt(IntVector.SPECIES_128, VectorOperators.EQ);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareNEMaskNotInt() {\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.NE, (m) -> { return m.not(); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.NE);\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.NE, (m) -> { return I_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.NE);\n+\n+        testCompareMaskNotInt(I_SPECIES_FOR_CAST, VectorOperators.NE, (m) -> { return L_SPECIES_FOR_CAST.maskAll(true).xor(m.cast(L_SPECIES_FOR_CAST)); });\n+        verifyResultsInt(I_SPECIES_FOR_CAST, VectorOperators.NE);\n+        testCompareMaskNotInt(IntVector.SPECIES_128, VectorOperators.NE, (m) -> { return m.cast(ShortVector.SPECIES_64).not(); });\n+        verifyResultsInt(IntVector.SPECIES_128, VectorOperators.NE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareLTMaskNotInt() {\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.LT, (m) -> { return m.not(); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.LT);\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.LT, (m) -> { return I_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.LT);\n+\n+        testCompareMaskNotInt(I_SPECIES_FOR_CAST, VectorOperators.LT, (m) -> { return L_SPECIES_FOR_CAST.maskAll(true).xor(m.cast(L_SPECIES_FOR_CAST)); });\n+        verifyResultsInt(I_SPECIES_FOR_CAST, VectorOperators.LT);\n+        testCompareMaskNotInt(IntVector.SPECIES_128, VectorOperators.LT, (m) -> { return m.cast(ShortVector.SPECIES_64).not(); });\n+        verifyResultsInt(IntVector.SPECIES_128, VectorOperators.LT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareGTMaskNotInt() {\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.GT, (m) -> { return m.not(); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.GT);\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.GT, (m) -> { return I_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.GT);\n+\n+        testCompareMaskNotInt(I_SPECIES_FOR_CAST, VectorOperators.GT, (m) -> { return L_SPECIES_FOR_CAST.maskAll(true).xor(m.cast(L_SPECIES_FOR_CAST)); });\n+        verifyResultsInt(I_SPECIES_FOR_CAST, VectorOperators.GT);\n+        testCompareMaskNotInt(IntVector.SPECIES_128, VectorOperators.GT, (m) -> { return m.cast(ShortVector.SPECIES_64).not(); });\n+        verifyResultsInt(IntVector.SPECIES_128, VectorOperators.GT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareLEMaskNotInt() {\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.LE, (m) -> { return m.not(); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.LE);\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.LE, (m) -> { return I_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.LE);\n+\n+        testCompareMaskNotInt(I_SPECIES_FOR_CAST, VectorOperators.LE, (m) -> { return L_SPECIES_FOR_CAST.maskAll(true).xor(m.cast(L_SPECIES_FOR_CAST)); });\n+        verifyResultsInt(I_SPECIES_FOR_CAST, VectorOperators.LE);\n+        testCompareMaskNotInt(IntVector.SPECIES_128, VectorOperators.LE, (m) -> { return m.cast(ShortVector.SPECIES_64).not(); });\n+        verifyResultsInt(IntVector.SPECIES_128, VectorOperators.LE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareGEMaskNotInt() {\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.GE, (m) -> { return m.not(); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.GE);\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.GE, (m) -> { return I_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.GE);\n+\n+        testCompareMaskNotInt(I_SPECIES_FOR_CAST, VectorOperators.GE, (m) -> { return L_SPECIES_FOR_CAST.maskAll(true).xor(m.cast(L_SPECIES_FOR_CAST)); });\n+        verifyResultsInt(I_SPECIES_FOR_CAST, VectorOperators.GE);\n+        testCompareMaskNotInt(IntVector.SPECIES_128, VectorOperators.GE, (m) -> { return m.cast(ShortVector.SPECIES_64).not(); });\n+        verifyResultsInt(IntVector.SPECIES_128, VectorOperators.GE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareULTMaskNotInt() {\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.ULT, (m) -> { return m.not(); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.ULT);\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.ULT, (m) -> { return I_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.ULT);\n+\n+        testCompareMaskNotInt(I_SPECIES_FOR_CAST, VectorOperators.ULT, (m) -> { return L_SPECIES_FOR_CAST.maskAll(true).xor(m.cast(L_SPECIES_FOR_CAST)); });\n+        verifyResultsInt(I_SPECIES_FOR_CAST, VectorOperators.ULT);\n+        testCompareMaskNotInt(IntVector.SPECIES_128, VectorOperators.ULT, (m) -> { return m.cast(ShortVector.SPECIES_64).not(); });\n+        verifyResultsInt(IntVector.SPECIES_128, VectorOperators.ULT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareUGTMaskNotInt() {\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.UGT, (m) -> { return m.not(); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.UGT);\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.UGT, (m) -> { return I_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.UGT);\n+\n+        testCompareMaskNotInt(I_SPECIES_FOR_CAST, VectorOperators.UGT, (m) -> { return L_SPECIES_FOR_CAST.maskAll(true).xor(m.cast(L_SPECIES_FOR_CAST)); });\n+        verifyResultsInt(I_SPECIES_FOR_CAST, VectorOperators.UGT);\n+        testCompareMaskNotInt(IntVector.SPECIES_128, VectorOperators.UGT, (m) -> { return m.cast(ShortVector.SPECIES_64).not(); });\n+        verifyResultsInt(IntVector.SPECIES_128, VectorOperators.UGT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareULEMaskNotInt() {\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.ULE, (m) -> { return m.not(); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.ULE);\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.ULE, (m) -> { return I_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.ULE);\n+\n+        testCompareMaskNotInt(I_SPECIES_FOR_CAST, VectorOperators.ULE, (m) -> { return L_SPECIES_FOR_CAST.maskAll(true).xor(m.cast(L_SPECIES_FOR_CAST)); });\n+        verifyResultsInt(I_SPECIES_FOR_CAST, VectorOperators.ULE);\n+        testCompareMaskNotInt(IntVector.SPECIES_128, VectorOperators.ULE, (m) -> { return m.cast(ShortVector.SPECIES_64).not(); });\n+        verifyResultsInt(IntVector.SPECIES_128, VectorOperators.ULE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareUGEMaskNotInt() {\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.UGE, (m) -> { return m.not(); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.UGE);\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.UGE, (m) -> { return I_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.UGE);\n+\n+        testCompareMaskNotInt(I_SPECIES_FOR_CAST, VectorOperators.UGE, (m) -> { return L_SPECIES_FOR_CAST.maskAll(true).xor(m.cast(L_SPECIES_FOR_CAST)); });\n+        verifyResultsInt(I_SPECIES_FOR_CAST, VectorOperators.UGE);\n+        testCompareMaskNotInt(IntVector.SPECIES_128, VectorOperators.UGE, (m) -> { return m.cast(ShortVector.SPECIES_64).not(); });\n+        verifyResultsInt(IntVector.SPECIES_128, VectorOperators.UGE);\n+    }\n+\n+    \/\/ Long tests\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareEQMaskNotLong() {\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.EQ, (m) -> { return m.not(); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.EQ);\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.EQ, (m) -> { return L_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.EQ);\n+\n+        testCompareMaskNotLong(L_SPECIES_FOR_CAST, VectorOperators.EQ, (m) -> { return m.cast(I_SPECIES_FOR_CAST).not(); });\n+        verifyResultsLong(L_SPECIES_FOR_CAST, VectorOperators.EQ);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareNEMaskNotLong() {\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.NE, (m) -> { return m.not(); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.NE);\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.NE, (m) -> { return L_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.NE);\n+\n+        testCompareMaskNotLong(L_SPECIES_FOR_CAST, VectorOperators.NE, (m) -> { return m.cast(I_SPECIES_FOR_CAST).not(); });\n+        verifyResultsLong(L_SPECIES_FOR_CAST, VectorOperators.NE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareLTMaskNotLong() {\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.LT, (m) -> { return m.not(); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.LT);\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.LT, (m) -> { return L_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.LT);\n+\n+        testCompareMaskNotLong(L_SPECIES_FOR_CAST, VectorOperators.LT, (m) -> { return m.cast(I_SPECIES_FOR_CAST).not(); });\n+        verifyResultsLong(L_SPECIES_FOR_CAST, VectorOperators.LT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareGTMaskNotLong() {\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.GT, (m) -> { return m.not(); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.GT);\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.GT, (m) -> { return L_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.GT);\n+\n+        testCompareMaskNotLong(L_SPECIES_FOR_CAST, VectorOperators.GT, (m) -> { return m.cast(I_SPECIES_FOR_CAST).not(); });\n+        verifyResultsLong(L_SPECIES_FOR_CAST, VectorOperators.GT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareLEMaskNotLong() {\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.LE, (m) -> { return m.not(); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.LE);\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.LE, (m) -> { return L_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.LE);\n+\n+        testCompareMaskNotLong(L_SPECIES_FOR_CAST, VectorOperators.LE, (m) -> { return m.cast(I_SPECIES_FOR_CAST).not(); });\n+        verifyResultsLong(L_SPECIES_FOR_CAST, VectorOperators.LE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareGEMaskNotLong() {\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.GE, (m) -> { return m.not(); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.GE);\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.GE, (m) -> { return L_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.GE);\n+\n+        testCompareMaskNotLong(L_SPECIES_FOR_CAST, VectorOperators.GE, (m) -> { return m.cast(I_SPECIES_FOR_CAST).not(); });\n+        verifyResultsLong(L_SPECIES_FOR_CAST, VectorOperators.GE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareULTMaskNotLong() {\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.ULT, (m) -> { return m.not(); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.ULT);\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.ULT, (m) -> { return L_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.ULT);\n+\n+        testCompareMaskNotLong(L_SPECIES_FOR_CAST, VectorOperators.ULT, (m) -> { return m.cast(I_SPECIES_FOR_CAST).not(); });\n+        verifyResultsLong(L_SPECIES_FOR_CAST, VectorOperators.ULT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareUGTMaskNotLong() {\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.UGT, (m) -> { return m.not(); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.UGT);\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.UGT, (m) -> { return L_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.UGT);\n+\n+        testCompareMaskNotLong(L_SPECIES_FOR_CAST, VectorOperators.UGT, (m) -> { return m.cast(I_SPECIES_FOR_CAST).not(); });\n+        verifyResultsLong(L_SPECIES_FOR_CAST, VectorOperators.UGT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareULEMaskNotLong() {\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.ULE, (m) -> { return m.not(); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.ULE);\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.ULE, (m) -> { return L_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.ULE);\n+\n+        testCompareMaskNotLong(L_SPECIES_FOR_CAST, VectorOperators.ULE, (m) -> { return m.cast(I_SPECIES_FOR_CAST).not(); });\n+        verifyResultsLong(L_SPECIES_FOR_CAST, VectorOperators.ULE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareUGEMaskNotLong() {\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.UGE, (m) -> { return m.not(); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.UGE);\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.UGE, (m) -> { return L_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.UGE);\n+\n+        testCompareMaskNotLong(L_SPECIES_FOR_CAST, VectorOperators.UGE, (m) -> { return m.cast(I_SPECIES_FOR_CAST).not(); });\n+        verifyResultsLong(L_SPECIES_FOR_CAST, VectorOperators.UGE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareEQMaskNotFloat() {\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.EQ, fa, fb, (m) -> { return m.not(); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.EQ, fa, fb);\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.EQ, fa, fb, (m) -> { return F_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.EQ, fa, fb);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareNEMaskNotFloat() {\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.NE, fa, fb, (m) -> { return m.not(); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.NE, fa, fb);\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.NE, fa, fb, (m) -> { return F_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.NE, fa, fb);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareEQMaskNotFloatNaN() {\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.EQ, fa, fnan, (m) -> { return m.not(); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.EQ, fa, fnan);\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.EQ, fa, fnan, (m) -> { return F_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.EQ, fa, fnan);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareNEMaskNotFloatNaN() {\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.NE, fa, fnan, (m) -> { return m.not(); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.NE, fa, fnan);\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.NE, fa, fnan, (m) -> { return F_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.NE, fa, fnan);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareEQMaskNotFloatPositiveInfinity() {\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.EQ, fa, fpinf, (m) -> { return m.not(); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.EQ, fa, fpinf);\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.EQ, fa, fpinf, (m) -> { return F_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.EQ, fa, fpinf);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareNEMaskNotFloatPositiveInfinity() {\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.NE, fa, fpinf, (m) -> { return m.not(); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.NE, fa, fpinf);\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.NE, fa, fpinf, (m) -> { return F_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.NE, fa, fpinf);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareEQMaskNotFloatNegativeInfinity() {\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.EQ, fa, fninf, (m) -> { return m.not(); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.EQ, fa, fninf);\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.EQ, fa, fninf, (m) -> { return F_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.EQ, fa, fninf);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareNEMaskNotFloatNegativeInfinity() {\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.NE, fa, fninf, (m) -> { return m.not(); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.NE, fa, fninf);\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.NE, fa, fninf, (m) -> { return F_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.NE, fa, fninf);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareEQMaskNotDouble() {\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.EQ, da, db, (m) -> { return m.not(); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.EQ, da, db);\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.EQ, da, db, (m) -> { return D_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.EQ, da, db);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareNEMaskNotDouble() {\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.NE, da, db, (m) -> { return m.not(); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.NE, da, db);\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.NE, da, db, (m) -> { return D_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.NE, da, db);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareEQMaskNotDoubleNaN() {\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.EQ, da, dnan, (m) -> { return m.not(); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.EQ, da, dnan);\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.EQ, da, dnan, (m) -> { return D_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.EQ, da, dnan);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareNEMaskNotDoubleNaN() {\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.NE, da, dnan, (m) -> { return m.not(); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.NE, da, dnan);\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.NE, da, dnan, (m) -> { return D_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.NE, da, dnan);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareEQMaskNotDoublePositiveInfinity() {\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.EQ, da, dpinf, (m) -> { return m.not(); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.EQ, da, dpinf);\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.EQ, da, dpinf, (m) -> { return D_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.EQ, da, dpinf);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareNEMaskNotDoublePositiveInfinity() {\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.NE, da, dpinf, (m) -> { return m.not(); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.NE, da, dpinf);\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.NE, da, dpinf, (m) -> { return D_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.NE, da, dpinf);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareEQMaskNotDoubleNegativeInfinity() {\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.EQ, da, dninf, (m) -> { return m.not(); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.EQ, da, dninf);\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.EQ, da, dninf, (m) -> { return D_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.EQ, da, dninf);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareNEMaskNotDoubleNegativeInfinity() {\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.NE, da, dninf, (m) -> { return m.not(); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.NE, da, dninf);\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.NE, da, dninf, (m) -> { return D_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.NE, da, dninf);\n+    }\n+\n+    \/\/ negative tests\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\"  })\n+    @IR(counts = { IRNode.XOR_V, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.XOR_V, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\" })\n+    public static void testCompareMaskNotByteNegative() {\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.EQ, (m) -> {\n+            \/\/ The vector mask is used multiple times.\n+            ic[0] = m.trueCount();\n+            return m.not();\n+        });\n+        verifyResultsByte(B_SPECIES, VectorOperators.EQ);\n+\n+        \/\/ One of the operands of XOR is not all ones vector.\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.EQ, (m) -> { return B_SPECIES.maskAll(false).xor(m); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.NE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\"  })\n+    @IR(counts = { IRNode.XOR_V, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.XOR_V, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\" })\n+    public static void testCompareMaskNotShortNegative() {\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.EQ, (m) -> {\n+            \/\/ The vector mask is used multiple times.\n+            ic[0] = m.trueCount();\n+            return m.not();\n+        });\n+        verifyResultsShort(S_SPECIES, VectorOperators.EQ);\n+\n+        \/\/ One of the operands of XOR is not all ones vector.\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.EQ, (m) -> { return S_SPECIES.maskAll(false).xor(m); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.NE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\"  })\n+    @IR(counts = { IRNode.XOR_V, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.XOR_V, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\" })\n+    public static void testCompareMaskNotIntNegative() {\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.EQ, (m) -> {\n+            \/\/ The vector mask is used multiple times.\n+            ic[0] = m.trueCount();\n+            return m.not();\n+        });\n+        verifyResultsInt(I_SPECIES, VectorOperators.EQ);\n+\n+        \/\/ One of the operands of XOR is not all ones vector.\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.EQ, (m) -> { return I_SPECIES.maskAll(false).xor(m); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.NE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\"  })\n+    @IR(counts = { IRNode.XOR_V, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.XOR_V, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\" })\n+    public static void testCompareMaskNotLongNegative() {\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.EQ, (m) -> {\n+            \/\/ The vector mask is used multiple times.\n+            ic[0] = m.trueCount();\n+            return m.not();\n+        });\n+        verifyResultsLong(L_SPECIES, VectorOperators.EQ);\n+\n+        \/\/ One of the operands of XOR is not all ones vector.\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.EQ, (m) -> { return L_SPECIES.maskAll(false).xor(m); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.NE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 3\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\"  })\n+    @IR(counts = { IRNode.XOR_V, \"= 3\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.XOR_V, \"= 3\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\" })\n+    public static void testCompareMaskNotFloatNegative() {\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.EQ, fa, fb, (m) -> {\n+            \/\/ The vector mask is used multiple times.\n+            ic[0] = m.trueCount();\n+            return m.not();\n+        });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.EQ, fa, fb);\n+\n+        \/\/ One of the operands of XOR is not all ones vector.\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.EQ, fa, fb, (m) -> { return F_SPECIES.maskAll(false).xor(m); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.NE, fa, fb);\n+\n+        \/\/ Float vectors use the LT comparison.\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.LT, fa, fb, (m) -> { return m.not(); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.LT, fa, fb);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 3\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\"  })\n+    @IR(counts = { IRNode.XOR_V, \"= 3\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.XOR_V, \"= 3\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\" })\n+    public static void testCompareMaskNotDoubleNegative() {\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.EQ, da, db, (m) -> {\n+            \/\/ The vector mask is used multiple times.\n+            ic[0] = m.trueCount();\n+            return m.not();\n+        });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.EQ, da, db);\n+\n+        \/\/ One of the operands of XOR is not all ones vector.\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.EQ, da, db, (m) -> { return D_SPECIES.maskAll(false).xor(m); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.NE, da, db);\n+\n+        \/\/ Double vectors use the LT comparison.\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.LT, da, db, (m) -> { return m.not(); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.LT, da, db);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.setDefaultWarmup(5000)\n+                     .addFlags(\"--add-modules=jdk.incubator.vector\")\n+                     .start();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskCompareNotTest.java","additions":1259,"deletions":0,"binary":false,"changes":1259,"status":"added"},{"patch":"@@ -0,0 +1,377 @@\n+\/*\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+\n+import jdk.incubator.vector.*;\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(jvmArgs = { \"--add-modules=jdk.incubator.vector\" })\n+public class MaskCompareNotBenchmark {\n+    @Param({\"4096\"})\n+    private int ARRAYLEN;\n+    private static Random r = new Random();\n+\n+    private static final VectorSpecies<Byte> B_SPECIES = ByteVector.SPECIES_MAX;\n+    private static final VectorSpecies<Short> S_SPECIES = ShortVector.SPECIES_MAX;\n+    private static final VectorSpecies<Integer> I_SPECIES = IntVector.SPECIES_MAX;\n+    private static final VectorSpecies<Long> L_SPECIES = LongVector.SPECIES_MAX;\n+    private static final VectorSpecies<Float> F_SPECIES = FloatVector.SPECIES_MAX;\n+    private static final VectorSpecies<Double> D_SPECIES = DoubleVector.SPECIES_MAX;\n+\n+    boolean[] mr;\n+    byte[] ba;\n+    byte[] bb;\n+    short[] sa;\n+    short[] sb;\n+    int[] ia;\n+    int[] ib;\n+    long[] la;\n+    long[] lb;\n+    float[] fa;\n+    float[] fb;\n+    double[] da;\n+    double[] db;\n+\n+    @Setup\n+    public void init() {\n+        mr = new boolean[ARRAYLEN];\n+        ba = new byte[ARRAYLEN];\n+        bb = new byte[ARRAYLEN];\n+        sa = new short[ARRAYLEN];\n+        sb = new short[ARRAYLEN];\n+        ia = new int[ARRAYLEN];\n+        ib = new int[ARRAYLEN];\n+        la = new long[ARRAYLEN];\n+        lb = new long[ARRAYLEN];\n+        fa = new float[ARRAYLEN];\n+        fb = new float[ARRAYLEN];\n+        da = new double[ARRAYLEN];\n+        db = new double[ARRAYLEN];\n+\n+        for (int i = 0; i < ARRAYLEN; i++) {\n+            mr[i] = r.nextBoolean();\n+            ba[i] = (byte) r.nextInt();\n+            bb[i] = (byte) r.nextInt();\n+            sa[i] = (short) r.nextInt();\n+            sb[i] = (short) r.nextInt();\n+            ia[i] = r.nextInt();\n+            ib[i] = r.nextInt();\n+            la[i] = r.nextLong();\n+            lb[i] = r.nextLong();\n+            fa[i] = r.nextFloat();\n+            fb[i] = r.nextFloat();\n+            da[i] = r.nextDouble();\n+            db[i] = r.nextDouble();\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    private void testCompareMaskNotByte(VectorOperators.Comparison op) {\n+        ByteVector bv = ByteVector.fromArray(B_SPECIES, bb, 0);\n+        for (int j = 0; j < ARRAYLEN; j += B_SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(B_SPECIES, ba, j);\n+            VectorMask<Byte> m = av.compare(op, bv).not();\n+            m.intoArray(mr, j);\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    private void testCompareMaskNotShort(VectorOperators.Comparison op) {\n+        ShortVector bv = ShortVector.fromArray(S_SPECIES, sb, 0);\n+        for (int j = 0; j < ARRAYLEN; j += S_SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(S_SPECIES, sa, j);\n+            VectorMask<Short> m = av.compare(op, bv).not();\n+            m.intoArray(mr, j);\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    private void testCompareMaskNotInt(VectorOperators.Comparison op) {\n+        IntVector bv = IntVector.fromArray(I_SPECIES, ib, 0);\n+        for (int j = 0; j < ARRAYLEN; j += I_SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(I_SPECIES, ia, j);\n+            VectorMask<Integer> m = av.compare(op, bv).not();\n+            m.intoArray(mr, j);\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    private void testCompareMaskNotLong(VectorOperators.Comparison op) {\n+        LongVector bv = LongVector.fromArray(L_SPECIES, lb, 0);\n+        for (int j = 0; j < ARRAYLEN; j += L_SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(L_SPECIES, la, j);\n+            VectorMask<Long> m = av.compare(op, bv).not();\n+            m.intoArray(mr, j);\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    private void testCompareMaskNotFloat(VectorOperators.Comparison op) {\n+        FloatVector bv = FloatVector.fromArray(F_SPECIES, fb, 0);\n+        for (int j = 0; j < ARRAYLEN; j += F_SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(F_SPECIES, fa, j);\n+            VectorMask<Float> m = av.compare(op, bv).not();\n+            m.intoArray(mr, j);\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    private void testCompareMaskNotDouble(VectorOperators.Comparison op) {\n+        DoubleVector bv = DoubleVector.fromArray(D_SPECIES, db, 0);\n+        for (int j = 0; j < ARRAYLEN; j += D_SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(D_SPECIES, da, j);\n+            VectorMask<Double> m = av.compare(op, bv).not();\n+            m.intoArray(mr, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testCompareEQMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.EQ);\n+    }\n+\n+    @Benchmark\n+    public void testCompareNEMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.NE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareLTMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.LT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareGTMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.GT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareLEMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.LE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareGEMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.GE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareULTMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.ULT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareUGTMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.UGT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareULEMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.ULE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareUGEMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.UGE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareEQMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.EQ);\n+    }\n+\n+    @Benchmark\n+    public void testCompareNEMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.NE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareLTMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.LT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareGTMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.GT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareLEMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.LE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareGEMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.GE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareULTMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.ULT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareUGTMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.UGT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareULEMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.ULE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareUGEMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.UGE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareEQMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.EQ);\n+    }\n+\n+    @Benchmark\n+    public void testCompareNEMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.NE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareLTMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.LT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareGTMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.GT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareLEMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.LE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareGEMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.GE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareULTMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.ULT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareUGTMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.UGT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareULEMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.ULE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareUGEMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.UGE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareEQMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.EQ);\n+    }\n+\n+    @Benchmark\n+    public void testCompareNEMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.NE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareLTMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.LT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareGTMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.GT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareLEMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.LE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareGEMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.GE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareULTMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.ULT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareUGTMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.UGT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareULEMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.ULE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareUGEMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.UGE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareEQMaskNotFloat() {\n+        testCompareMaskNotFloat(VectorOperators.EQ);\n+    }\n+\n+    @Benchmark\n+    public void testCompareNEMaskNotFloat() {\n+        testCompareMaskNotFloat(VectorOperators.NE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareEQMaskNotDouble() {\n+        testCompareMaskNotDouble(VectorOperators.EQ);\n+    }\n+\n+    @Benchmark\n+    public void testCompareNEMaskNotDouble() {\n+        testCompareMaskNotDouble(VectorOperators.NE);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/MaskCompareNotBenchmark.java","additions":377,"deletions":0,"binary":false,"changes":377,"status":"added"}]}