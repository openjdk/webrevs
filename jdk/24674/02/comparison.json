{"files":[{"patch":"@@ -1219,0 +1219,7 @@\n+  } else if (n->Opcode() == Op_XorV || n->Opcode() == Op_XorVMask) {\n+    \/\/ Condition for removing an unnecessary not() following a compare(...)\n+    \/\/ operation. The predecessor of n (this XorV or XorVMask) may also be used\n+    \/\/ by a useless VectorBox node which will later be eliminated by\n+    \/\/ RemoveUseless. Return true to ensure that subgraph transformations are\n+    \/\/ performed on n.\n+    return true;\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2167,0 +2167,27 @@\n+\/\/ Returns whether (XorV (VectorMaskCmp) -1) can be optimized by performing the\n+\/\/ inverse of a comparison operation.\n+bool VectorMaskCmpNode::predicate_can_be_inverted() {\n+  switch (_predicate) {\n+    case BoolTest::eq:\n+    case BoolTest::ne:\n+      \/\/ eq and ne also apply to floating-point special values like NaN and infinities.\n+      return true;\n+    case BoolTest::le:\n+    case BoolTest::ge:\n+    case BoolTest::lt:\n+    case BoolTest::gt:\n+    case BoolTest::ule:\n+    case BoolTest::uge:\n+    case BoolTest::ult:\n+    case BoolTest::ugt: {\n+      BasicType bt = vect_type()->element_basic_type();\n+      \/\/ For float and double, we don't know if either comparison operand is a\n+      \/\/ NaN, NaN {le|ge|lt|gt} anything is false, resulting in inconsistent\n+      \/\/ results before and after negation.\n+      return is_integral_type(bt);\n+    }\n+    default:\n+      return false;\n+  }\n+}\n+\n@@ -2168,0 +2195,2 @@\n+  Node* in1 = in(1);\n+  Node* in2 = in(2);\n@@ -2175,1 +2204,1 @@\n-  if (!is_predicated_vector() && (in(1) == in(2))) {\n+  if (!is_predicated_vector() && (in1 == in2)) {\n@@ -2178,1 +2207,9 @@\n-    return VectorNode::scalar2vector(zero, length(), bt, bottom_type()->isa_vectmask() != nullptr);\n+    return VectorNode::scalar2vector(zero, length(), bt,\n+                                     bottom_type()->isa_vectmask() != nullptr);\n+  }\n+\n+  \/\/ Transformations for predicated IRs are not supported for now.\n+  bool with_predicated = false;\n+  if (is_predicated_vector() || in1->is_predicated_vector() ||\n+      in2->is_predicated_vector()) {\n+    with_predicated = true;\n@@ -2180,1 +2217,51 @@\n-  return VectorNode::Ideal(phase, can_reshape);\n+\n+  \/\/ For integer types:\n+  \/\/ (XorV (VectorMaskCmp src1 src2 cond) (Replicate -1))\n+  \/\/    => (VectorMaskCmp src1 src2 ncond)\n+  \/\/ (XorVMask (VectorMaskCmp src1 src2 cond) (MaskAll m1))\n+  \/\/    => (VectorMaskCmp src1 src2 ncond)\n+  \/\/ cond can be eq, ne, le, ge, lt, gt, ule, uge, ult and ugt, ncond is the\n+  \/\/ negative comparison of cond.\n+  \/\/\n+  \/\/ For float and double types:\n+  \/\/ (XorV (VectorMaskCast (VectorMaskCmp src1 src2 cond)) (Replicate -1))\n+  \/\/    => (VectorMaskCast (VectorMaskCmp src1 src2 ncond))\n+  \/\/ (XorVMask (VectorMaskCast (VectorMaskCmp src1 src2 cond)) (MaskAll m1))\n+  \/\/    => (VectorMaskCast (VectorMaskCmp src1 src2 ncond))\n+  \/\/ cond can be eq or ne.\n+  \/\/\n+  \/\/ XorV\/XorVMask is commutative, swap VectorMaskCmp\/Op_VectorMaskCast to in1.\n+  if (in1->Opcode() != Op_VectorMaskCmp && in1->Opcode() != Op_VectorMaskCast) {\n+    swap(in1, in2);\n+  }\n+\n+  const TypeVect* vmcast_vt = nullptr;\n+  if (in1->Opcode() == Op_VectorMaskCast && in1->outcnt() == 1 &&\n+      in1->in(1)->Opcode() == Op_VectorMaskCmp) {\n+    vmcast_vt = in1->as_Vector()->vect_type();\n+    in1 = in1->in(1);\n+  }\n+  if (with_predicated || in1->Opcode() != Op_VectorMaskCmp ||\n+      in1->outcnt() > 1 ||\n+      !((VectorMaskCmpNode*) in1)->predicate_can_be_inverted() ||\n+      !VectorNode::is_all_ones_vector(in2)) {\n+    return VectorNode::Ideal(phase, can_reshape);\n+  }\n+\n+  \/\/ This is the same with BoolTest::negate(), but we can't call it with a\n+  \/\/ BoolTest object because the comparison may be unsigned comparison, but\n+  \/\/ BoolTest doesn't support unsigned comparisons.\n+  BoolTest::mask neg_cond =\n+      (BoolTest::mask) (((VectorMaskCmpNode*) in1)->get_predicate() ^ 4);\n+\n+  ConINode* predicate_node = phase->intcon(neg_cond);\n+  const TypeVect* vt = in1->as_Vector()->vect_type();\n+  Node* vmcmp = new VectorMaskCmpNode(neg_cond, in1->in(1), in1->in(2),\n+                                      predicate_node, vt);\n+  if (vmcast_vt != nullptr) {\n+    \/\/ We optimized out an VectorMaskCast, and in order to ensure type\n+    \/\/ correctness, we need to regenerate one. VectorMaskCast will be encoded as\n+    \/\/ empty for types with the same size.\n+    vmcmp = new VectorMaskCastNode(phase->transform(vmcmp), vmcast_vt);\n+  }\n+  return vmcmp;\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":90,"deletions":3,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -1682,0 +1682,1 @@\n+  bool predicate_can_be_inverted();\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,578 @@\n+\/*\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.generators.*;\n+import jdk.incubator.vector.*;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8354242\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @summary test combining vector not operation with compare\n+ * @modules jdk.incubator.vector\n+ * @requires ((os.arch!=\"x86\" & os.arch!=\"i386\" & os.arch!=\"amd64\" & os.arch!=\"x86_64\") | vm.cpu.features ~= \".*avx.*\")\n+ *\n+ * @run driver compiler.vectorapi.VectorMaskCompareNotTest\n+ *\/\n+\n+public class VectorMaskCompareNotTest {\n+    private static int LENGTH = 128;\n+    private static final VectorSpecies<Byte> B_SPECIES = ByteVector.SPECIES_MAX;\n+    private static final VectorSpecies<Short> S_SPECIES = ShortVector.SPECIES_MAX;\n+    private static final VectorSpecies<Integer> I_SPECIES = IntVector.SPECIES_MAX;\n+    private static final VectorSpecies<Long> L_SPECIES = LongVector.SPECIES_MAX;\n+    private static final VectorSpecies<Float> F_SPECIES = FloatVector.SPECIES_MAX;\n+    private static final VectorSpecies<Double> D_SPECIES = DoubleVector.SPECIES_MAX;\n+    private static final Generators RD = Generators.G;\n+\n+    private static byte[] ba;\n+    private static byte[] bb;\n+    private static short[] sa;\n+    private static short[] sb;\n+    private static int[] ia;\n+    private static int[] ib;\n+    private static long[] la;\n+    private static long[] lb;\n+    private static float[] fa;\n+    private static float[] fb;\n+    private static float[] fnan;\n+    private static float[] fpinf;\n+    private static float[] fninf;\n+    private static double[] da;\n+    private static double[] db;\n+    private static double[] dnan;\n+    private static double[] dpinf;\n+    private static double[] dninf;\n+    private static boolean[] mr;\n+\n+    static {\n+        ba = new byte[LENGTH];\n+        bb = new byte[LENGTH];\n+        sa = new short[LENGTH];\n+        sb = new short[LENGTH];\n+        ia = new int[LENGTH];\n+        ib = new int[LENGTH];\n+        la = new long[LENGTH];\n+        lb = new long[LENGTH];\n+        fa = new float[LENGTH];\n+        fb = new float[LENGTH];\n+        fnan = new float[LENGTH];\n+        fpinf = new float[LENGTH];\n+        fninf = new float[LENGTH];\n+        da = new double[LENGTH];\n+        db = new double[LENGTH];\n+        dnan = new double[LENGTH];\n+        dpinf = new double[LENGTH];\n+        dninf = new double[LENGTH];\n+        mr = new boolean[LENGTH];\n+\n+        Generator<Integer> iGen = RD.uniformInts(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        Generator<Long> lGen = RD.uniformLongs(Long.MIN_VALUE, Long.MAX_VALUE);\n+        Generator<Float> fGen = RD.uniformFloats(Float.MIN_VALUE, Float.MAX_VALUE);\n+        Generator<Double> dGen = RD.uniformDoubles(Double.MIN_VALUE, Double.MAX_VALUE);\n+        for (int i = 0; i < LENGTH; i++) {\n+            ba[i] = iGen.next().byteValue();\n+            bb[i] = iGen.next().byteValue();\n+            sa[i] = iGen.next().shortValue();\n+            sb[i] = iGen.next().shortValue();\n+            ia[i] = iGen.next();\n+            ib[i] = iGen.next();\n+            la[i] = lGen.next();\n+            lb[i] = lGen.next();\n+            fa[i] = fGen.next();\n+            fb[i] = fGen.next();\n+            fnan[i] = Float.NaN;\n+            fpinf[i] = Float.POSITIVE_INFINITY;\n+            fninf[i] = Float.NEGATIVE_INFINITY;\n+            da[i] = dGen.next();\n+            db[i] = dGen.next();\n+            dnan[i] = Double.NaN;\n+            dpinf[i] = Double.POSITIVE_INFINITY;\n+            dninf[i] = Double.NEGATIVE_INFINITY;\n+        }\n+    }\n+\n+    public static int compareUnsigned(Number a, Number b) {\n+        if (a instanceof Byte) {\n+            return Integer.compareUnsigned(Byte.toUnsignedInt(a.byteValue()),\n+                    Byte.toUnsignedInt(b.byteValue()));\n+        } else if (a instanceof Short) {\n+            return Integer.compareUnsigned(Short.toUnsignedInt(a.shortValue()),\n+                    Short.toUnsignedInt(b.shortValue()));\n+        } else if (a instanceof Integer) {\n+            return Integer.compareUnsigned(a.intValue(), b.intValue());\n+        } else if (a instanceof Long) {\n+            return Long.compareUnsigned(a.longValue(), b.longValue());\n+        }\n+        return 0;\n+    }\n+\n+    public static <T extends Number & Comparable<T>> void verifyResults(T a, T b, boolean r,\n+            VectorOperators.Comparison op) {\n+        if (op == VectorOperators.EQ) {\n+            Asserts.assertEquals(a.compareTo(b) != 0, r);\n+        } else if (op == VectorOperators.NE) {\n+            Asserts.assertEquals(a.compareTo(b) == 0, r);\n+        } else if (op == VectorOperators.LE) {\n+            Asserts.assertEquals(a.compareTo(b) > 0, r);\n+        } else if (op == VectorOperators.GE) {\n+            Asserts.assertEquals(a.compareTo(b) < 0, r);\n+        } else if (op == VectorOperators.LT) {\n+            Asserts.assertEquals(a.compareTo(b) >= 0, r);\n+        } else if (op == VectorOperators.GT) {\n+            Asserts.assertEquals(a.compareTo(b) <= 0, r);\n+        } else if (op == VectorOperators.ULE) {\n+            Asserts.assertEquals(compareUnsigned(a, b) > 0, r);\n+        } else if (op == VectorOperators.UGE) {\n+            Asserts.assertEquals(compareUnsigned(a, b) < 0, r);\n+        } else if (op == VectorOperators.ULT) {\n+            Asserts.assertEquals(compareUnsigned(a, b) >= 0, r);\n+        } else if (op == VectorOperators.UGT) {\n+            Asserts.assertEquals(compareUnsigned(a, b) <= 0, r);\n+        }\n+    }\n+\n+    @ForceInline\n+    public static void testCompareMaskNotByte(VectorOperators.Comparison op) {\n+        ByteVector av = ByteVector.fromArray(B_SPECIES, ba, 0);\n+        ByteVector bv = ByteVector.fromArray(B_SPECIES, bb, 0);\n+        VectorMask<Byte> m1 = av.compare(op, bv);\n+        m1.not().intoArray(mr, 0);\n+\n+        for (int i = 0; i < B_SPECIES.length(); i++) {\n+            verifyResults(ba[i], bb[i], mr[i], op);\n+        }\n+    }\n+\n+    @ForceInline\n+    public static void testCompareMaskNotShort(VectorOperators.Comparison op) {\n+        ShortVector av = ShortVector.fromArray(S_SPECIES, sa, 0);\n+        ShortVector bv = ShortVector.fromArray(S_SPECIES, sb, 0);\n+        VectorMask<Short> m1 = av.compare(op, bv);\n+        m1.not().intoArray(mr, 0);\n+\n+        for (int i = 0; i < S_SPECIES.length(); i++) {\n+            verifyResults(sa[i], sb[i], mr[i], op);\n+        }\n+    }\n+\n+    @ForceInline\n+    public static void testCompareMaskNotInt(VectorOperators.Comparison op) {\n+        IntVector av = IntVector.fromArray(I_SPECIES, ia, 0);\n+        IntVector bv = IntVector.fromArray(I_SPECIES, ib, 0);\n+        VectorMask<Integer> m1 = av.compare(op, bv);\n+        m1.not().intoArray(mr, 0);\n+\n+        for (int i = 0; i < I_SPECIES.length(); i++) {\n+            verifyResults(ia[i], ib[i], mr[i], op);\n+        }\n+    }\n+\n+    @ForceInline\n+    public static void testCompareMaskNotLong(VectorOperators.Comparison op) {\n+        LongVector av = LongVector.fromArray(L_SPECIES, la, 0);\n+        LongVector bv = LongVector.fromArray(L_SPECIES, lb, 0);\n+        VectorMask<Long> m1 = av.compare(op, bv);\n+        m1.not().intoArray(mr, 0);\n+\n+        for (int i = 0; i < L_SPECIES.length(); i++) {\n+            verifyResults(la[i], lb[i], mr[i], op);\n+        }\n+    }\n+\n+    @ForceInline\n+    public static void testCompareMaskNotFloat(VectorOperators.Comparison op, float[] a, float[] b) {\n+        FloatVector av = FloatVector.fromArray(F_SPECIES, a, 0);\n+        FloatVector bv = FloatVector.fromArray(F_SPECIES, b, 0);\n+        VectorMask<Float> m1 = av.compare(op, bv);\n+        m1.not().intoArray(mr, 0);\n+\n+        for (int i = 0; i < F_SPECIES.length(); i++) {\n+            verifyResults(a[i], b[i], mr[i], op);\n+        }\n+    }\n+\n+    @ForceInline\n+    public static void testCompareMaskNotDouble(VectorOperators.Comparison op, double[] a, double[] b) {\n+        DoubleVector av = DoubleVector.fromArray(D_SPECIES, a, 0);\n+        DoubleVector bv = DoubleVector.fromArray(D_SPECIES, b, 0);\n+        VectorMask<Double> m1 = av.compare(op, bv);\n+        m1.not().intoArray(mr, 0);\n+\n+        for (int i = 0; i < D_SPECIES.length(); i++) {\n+            verifyResults(a[i], b[i], mr[i], op);\n+        }\n+    }\n+\n+    \/\/ Byte tests\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VB, \"= 0\" })\n+    public static void testCompareEQMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.EQ);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VB, \"= 0\" })\n+    public static void testCompareNEMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.NE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VB, \"= 0\" })\n+    public static void testCompareLTMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.LT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VB, \"= 0\" })\n+    public static void testCompareGTMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.GT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VB, \"= 0\" })\n+    public static void testCompareLEMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.LE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VB, \"= 0\" })\n+    public static void testCompareGEMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.GE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VB, \"= 0\" })\n+    public static void testCompareULTMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.ULT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VB, \"= 0\" })\n+    public static void testCompareUGTMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.UGT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VB, \"= 0\" })\n+    public static void testCompareULEMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.ULE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VB, \"= 0\" })\n+    public static void testCompareUGEMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.UGE);\n+    }\n+\n+    \/\/ Short tests\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VS, \"= 0\" })\n+    public static void testCompareEQMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.EQ);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VS, \"= 0\" })\n+    public static void testCompareNEMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.NE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VS, \"= 0\" })\n+    public static void testCompareLTMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.LT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VS, \"= 0\" })\n+    public static void testCompareGTMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.GT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VS, \"= 0\" })\n+    public static void testCompareLEMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.LE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VS, \"= 0\" })\n+    public static void testCompareGEMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.GE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VS, \"= 0\" })\n+    public static void testCompareULTMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.ULT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VS, \"= 0\" })\n+    public static void testCompareUGTMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.UGT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VS, \"= 0\" })\n+    public static void testCompareULEMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.ULE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VS, \"= 0\" })\n+    public static void testCompareUGEMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.UGE);\n+    }\n+\n+    \/\/ Int tests\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VI, \"= 0\" })\n+    public static void testCompareEQMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.EQ);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VI, \"= 0\" })\n+    public static void testCompareNEMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.NE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VI, \"= 0\" })\n+    public static void testCompareLTMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.LT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VI, \"= 0\" })\n+    public static void testCompareGTMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.GT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VI, \"= 0\" })\n+    public static void testCompareLEMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.LE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VI, \"= 0\" })\n+    public static void testCompareGEMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.GE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VI, \"= 0\" })\n+    public static void testCompareULTMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.ULT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VI, \"= 0\" })\n+    public static void testCompareUGTMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.UGT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VI, \"= 0\" })\n+    public static void testCompareULEMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.ULE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VI, \"= 0\" })\n+    public static void testCompareUGEMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.UGE);\n+    }\n+\n+    \/\/ Long tests\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\" })\n+    public static void testCompareEQMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.EQ);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\" })\n+    public static void testCompareNEMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.NE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\" })\n+    public static void testCompareLTMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.LT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\" })\n+    public static void testCompareGTMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.GT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\" })\n+    public static void testCompareLEMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.LE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\" })\n+    public static void testCompareGEMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.GE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\" })\n+    public static void testCompareULTMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.ULT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\" })\n+    public static void testCompareUGTMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.UGT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\" })\n+    public static void testCompareULEMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.ULE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\" })\n+    public static void testCompareUGEMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.UGE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VI, \"= 0\" })\n+    public static void testCompareEQMaskNotFloat() {\n+        testCompareMaskNotFloat(VectorOperators.EQ, fa, fb);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VI, \"= 0\" })\n+    public static void testCompareNEMaskNotFloat() {\n+        testCompareMaskNotFloat(VectorOperators.NE, fa, fb);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\" })\n+    public static void testCompareEQMaskNotFloatNaN() {\n+        testCompareMaskNotFloat(VectorOperators.EQ, fa, fnan);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\" })\n+    public static void testCompareNEMaskNotFloatNaN() {\n+        testCompareMaskNotFloat(VectorOperators.NE, fa, fnan);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\" })\n+    public static void testCompareEQMaskNotFloatPositiveInfinity() {\n+        testCompareMaskNotFloat(VectorOperators.EQ, fa, fpinf);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\" })\n+    public static void testCompareNEMaskNotFloatPositiveInfinity() {\n+        testCompareMaskNotFloat(VectorOperators.NE, fa, fpinf);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\" })\n+    public static void testCompareEQMaskNotFloatNegativeInfinity() {\n+        testCompareMaskNotFloat(VectorOperators.EQ, fa, fninf);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\" })\n+    public static void testCompareNEMaskNotFloatNegativeInfinity() {\n+        testCompareMaskNotFloat(VectorOperators.NE, fa, fninf);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\" })\n+    public static void testCompareEQMaskNotDouble() {\n+        testCompareMaskNotDouble(VectorOperators.EQ, da, db);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\" })\n+    public static void testCompareNEMaskNotDouble() {\n+        testCompareMaskNotDouble(VectorOperators.NE, da, db);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\" })\n+    public static void testCompareEQMaskNotDoubleNaN() {\n+        testCompareMaskNotDouble(VectorOperators.EQ, da, dnan);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\" })\n+    public static void testCompareNEMaskNotDoubleNaN() {\n+        testCompareMaskNotDouble(VectorOperators.NE, da, dnan);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\" })\n+    public static void testCompareEQMaskNotDoublePositiveInfinity() {\n+        testCompareMaskNotDouble(VectorOperators.EQ, da, dpinf);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\" })\n+    public static void testCompareNEMaskNotDoublePositiveInfinity() {\n+        testCompareMaskNotDouble(VectorOperators.NE, da, dpinf);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\" })\n+    public static void testCompareEQMaskNotDoubleNegativeInfinity() {\n+        testCompareMaskNotDouble(VectorOperators.EQ, da, dninf);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\", IRNode.XOR_VL, \"= 0\" })\n+    public static void testCompareNEMaskNotDoubleNegativeInfinity() {\n+        testCompareMaskNotDouble(VectorOperators.NE, da, dninf);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.addFlags(\"--add-modules=jdk.incubator.vector\");\n+        testFramework.setDefaultWarmup(10000);\n+        testFramework.start();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskCompareNotTest.java","additions":578,"deletions":0,"binary":false,"changes":578,"status":"added"},{"patch":"@@ -0,0 +1,376 @@\n+\/*\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+\n+import jdk.incubator.vector.*;\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(jvmArgs = { \"--add-modules=jdk.incubator.vector\" })\n+public class MaskCompareNotBenchmark {\n+    private static final int ARRAYLEN = 4096;\n+    private static Random r = new Random();\n+\n+    private static final VectorSpecies<Byte> B_SPECIES = ByteVector.SPECIES_MAX;\n+    private static final VectorSpecies<Short> S_SPECIES = ShortVector.SPECIES_MAX;\n+    private static final VectorSpecies<Integer> I_SPECIES = IntVector.SPECIES_MAX;\n+    private static final VectorSpecies<Long> L_SPECIES = LongVector.SPECIES_MAX;\n+    private static final VectorSpecies<Float> F_SPECIES = FloatVector.SPECIES_MAX;\n+    private static final VectorSpecies<Double> D_SPECIES = DoubleVector.SPECIES_MAX;\n+\n+    boolean[] mr;\n+    byte[] ba;\n+    byte[] bb;\n+    short[] sa;\n+    short[] sb;\n+    int[] ia;\n+    int[] ib;\n+    long[] la;\n+    long[] lb;\n+    float[] fa;\n+    float[] fb;\n+    double[] da;\n+    double[] db;\n+\n+    @Setup\n+    public void init() {\n+        mr = new boolean[ARRAYLEN];\n+        ba = new byte[ARRAYLEN];\n+        bb = new byte[ARRAYLEN];\n+        sa = new short[ARRAYLEN];\n+        sb = new short[ARRAYLEN];\n+        ia = new int[ARRAYLEN];\n+        ib = new int[ARRAYLEN];\n+        la = new long[ARRAYLEN];\n+        lb = new long[ARRAYLEN];\n+        fa = new float[ARRAYLEN];\n+        fb = new float[ARRAYLEN];\n+        da = new double[ARRAYLEN];\n+        db = new double[ARRAYLEN];\n+\n+        for (int i = 0; i < ARRAYLEN; i++) {\n+            mr[i] = r.nextBoolean();\n+            ba[i] = (byte) r.nextInt();\n+            bb[i] = (byte) r.nextInt();\n+            sa[i] = (short) r.nextInt();\n+            sb[i] = (short) r.nextInt();\n+            ia[i] = r.nextInt();\n+            ib[i] = r.nextInt();\n+            la[i] = r.nextLong();\n+            lb[i] = r.nextLong();\n+            fa[i] = r.nextFloat();\n+            fb[i] = r.nextFloat();\n+            da[i] = r.nextDouble();\n+            db[i] = r.nextDouble();\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    private void testCompareMaskNotByte(VectorOperators.Comparison op) {\n+        ByteVector bv = ByteVector.fromArray(B_SPECIES, bb, 0);\n+        for (int j = 0; j < ARRAYLEN; j += B_SPECIES.length()) {\n+            ByteVector av = ByteVector.fromArray(B_SPECIES, ba, j);\n+            VectorMask<Byte> m = av.compare(op, bv).not();\n+            m.intoArray(mr, j);\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    private void testCompareMaskNotShort(VectorOperators.Comparison op) {\n+        ShortVector bv = ShortVector.fromArray(S_SPECIES, sb, 0);\n+        for (int j = 0; j < ARRAYLEN; j += S_SPECIES.length()) {\n+            ShortVector av = ShortVector.fromArray(S_SPECIES, sa, j);\n+            VectorMask<Short> m = av.compare(op, bv).not();\n+            m.intoArray(mr, j);\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    private void testCompareMaskNotInt(VectorOperators.Comparison op) {\n+        IntVector bv = IntVector.fromArray(I_SPECIES, ib, 0);\n+        for (int j = 0; j < ARRAYLEN; j += I_SPECIES.length()) {\n+            IntVector av = IntVector.fromArray(I_SPECIES, ia, j);\n+            VectorMask<Integer> m = av.compare(op, bv).not();\n+            m.intoArray(mr, j);\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    private void testCompareMaskNotLong(VectorOperators.Comparison op) {\n+        LongVector bv = LongVector.fromArray(L_SPECIES, lb, 0);\n+        for (int j = 0; j < ARRAYLEN; j += L_SPECIES.length()) {\n+            LongVector av = LongVector.fromArray(L_SPECIES, la, j);\n+            VectorMask<Long> m = av.compare(op, bv).not();\n+            m.intoArray(mr, j);\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    private void testCompareMaskNotFloat(VectorOperators.Comparison op) {\n+        FloatVector bv = FloatVector.fromArray(F_SPECIES, fb, 0);\n+        for (int j = 0; j < ARRAYLEN; j += F_SPECIES.length()) {\n+            FloatVector av = FloatVector.fromArray(F_SPECIES, fa, j);\n+            VectorMask<Float> m = av.compare(op, bv).not();\n+            m.intoArray(mr, j);\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    private void testCompareMaskNotDouble(VectorOperators.Comparison op) {\n+        DoubleVector bv = DoubleVector.fromArray(D_SPECIES, db, 0);\n+        for (int j = 0; j < ARRAYLEN; j += D_SPECIES.length()) {\n+            DoubleVector av = DoubleVector.fromArray(D_SPECIES, da, j);\n+            VectorMask<Double> m = av.compare(op, bv).not();\n+            m.intoArray(mr, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testCompareEQMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.EQ);\n+    }\n+\n+    @Benchmark\n+    public void testCompareNEMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.NE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareLTMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.LT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareGTMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.GT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareLEMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.LE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareGEMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.GE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareULTMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.ULT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareUGTMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.UGT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareULEMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.ULE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareUGEMaskNotByte() {\n+        testCompareMaskNotByte(VectorOperators.UGE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareEQMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.EQ);\n+    }\n+\n+    @Benchmark\n+    public void testCompareNEMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.NE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareLTMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.LT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareGTMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.GT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareLEMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.LE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareGEMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.GE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareULTMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.ULT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareUGTMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.UGT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareULEMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.ULE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareUGEMaskNotShort() {\n+        testCompareMaskNotShort(VectorOperators.UGE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareEQMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.EQ);\n+    }\n+\n+    @Benchmark\n+    public void testCompareNEMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.NE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareLTMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.LT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareGTMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.GT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareLEMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.LE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareGEMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.GE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareULTMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.ULT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareUGTMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.UGT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareULEMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.ULE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareUGEMaskNotInt() {\n+        testCompareMaskNotInt(VectorOperators.UGE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareEQMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.EQ);\n+    }\n+\n+    @Benchmark\n+    public void testCompareNEMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.NE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareLTMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.LT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareGTMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.GT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareLEMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.LE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareGEMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.GE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareULTMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.ULT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareUGTMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.UGT);\n+    }\n+\n+    @Benchmark\n+    public void testCompareULEMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.ULE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareUGEMaskNotLong() {\n+        testCompareMaskNotLong(VectorOperators.UGE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareEQMaskNotFloat() {\n+        testCompareMaskNotFloat(VectorOperators.EQ);\n+    }\n+\n+    @Benchmark\n+    public void testCompareNEMaskNotFloat() {\n+        testCompareMaskNotFloat(VectorOperators.NE);\n+    }\n+\n+    @Benchmark\n+    public void testCompareEQMaskNotDouble() {\n+        testCompareMaskNotDouble(VectorOperators.EQ);\n+    }\n+\n+    @Benchmark\n+    public void testCompareNEMaskNotDouble() {\n+        testCompareMaskNotDouble(VectorOperators.NE);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/MaskCompareNotBenchmark.java","additions":376,"deletions":0,"binary":false,"changes":376,"status":"added"}]}