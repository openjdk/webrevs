{"files":[{"patch":"@@ -57,0 +57,2 @@\n+    private static final Pattern DF_PATTERN = Pattern.compile(\"([^\\\\s]+)\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s+\\\\d+%\\\\s+([^\\\\s].*)\\n\");\n+\n@@ -107,2 +109,11 @@\n-            if (getSpace0(name, sizes))\n-                System.err.println(\"WARNING: total space is estimated\");\n+            if (Platform.isWindows() & isCDDrive(name)) {\n+                try {\n+                    getCDDriveSpace(name, sizes);\n+                } catch (IOException e) {\n+                    e.printStackTrace();\n+                    throw new RuntimeException(\"can't get CDDrive sizes\");\n+                }\n+            } else {\n+                if (getSpace0(name, sizes))\n+                    System.err.println(\"WARNING: total space is estimated\");\n+            }\n@@ -170,1 +181,2 @@\n-        out.format(fmt, \"getSpace0\", s.total(), s.free(), s.available());\n+        String method = Platform.isWindows() & isCDDrive(s.name()) ? \"getCDDriveSpace\" : \"getSpace0\";\n+        out.format(fmt, method, s.total(), s.free(), s.available());\n@@ -327,1 +339,1 @@\n-        \/\/ returned by File::getXSpace are equivalent to those from getSpace0\n+        \/\/ returned by File::getXSpace are equivalent to those from getSpace0 or getCDDriveSpace\n@@ -400,0 +412,37 @@\n+\n+    private static native boolean isCDDrive(String root);\n+\n+    private static void getCDDriveSpace(String root, long[] sizes) throws IOException {\n+        String cmd = \"df -k -P \" + root;\n+        StringBuilder sb = new StringBuilder();\n+        ProcessBuilder pb = new ProcessBuilder(\"bash\", \"-c\", cmd);;\n+        pb.redirectErrorStream(true);\n+        Process p = pb.start();\n+\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream()))) {\n+            String s;\n+            int i = 0;\n+            while ((s = in.readLine()) != null) {\n+                \/\/ skip header\n+                if (i++ == 0) continue;\n+                sb.append(s).append(\"\\n\");\n+            }\n+        }\n+        out.println(sb);\n+\n+        Matcher m = DF_PATTERN.matcher(sb);\n+        int j = 0;\n+        while (j < sb.length()) {\n+            if (m.find(j)) {\n+                sizes[0] = Long.parseLong(m.group(2)) * 1024;\n+                sizes[1] = Long.parseLong(m.group(3)) * 1024;\n+                sizes[2] = sizes[0] - sizes[1];\n+                sizes[3] = Long.parseLong(m.group(4)) * 1024;\n+                j = m.end();\n+            } else {\n+                throw new RuntimeException(\"unrecognized df output format: \"\n+                                           + \"charAt(\" + j + \") = '\"\n+                                           + sb.charAt(j) + \"'\");\n+            }\n+        }\n+    }\n","filename":"test\/jdk\/java\/io\/File\/GetXSpace.java","additions":53,"deletions":4,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -162,0 +162,27 @@\n+\n+JNIEXPORT jboolean JNICALL\n+Java_GetXSpace_isCDDrive\n+    (JNIEnv *env, jclass cls, jstring root)\n+{\n+#ifdef WINDOWS\n+    const jchar* strchars = (*env)->GetStringChars(env, root, NULL);\n+    if (strchars == NULL) {\n+        JNU_ThrowByNameWithLastError(env, \"java\/lang\/RuntimeException\",\n+                                     \"GetStringChars\");\n+        return JNI_FALSE;\n+    }\n+\n+    LPCWSTR path = (LPCWSTR)strchars;\n+    UINT driveType = GetDriveTypeW(path);\n+\n+    (*env)->ReleaseStringChars(env, root, strchars);\n+\n+    if (driveType != DRIVE_CDROM) {\n+        return JNI_FALSE;\n+    }\n+\n+    return JNI_TRUE;\n+#else\n+    return JNI_FALSE;\n+#endif\n+}\n","filename":"test\/jdk\/java\/io\/File\/libGetXSpace.c","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"}]}