{"files":[{"patch":"@@ -2047,1 +2047,1 @@\n-  } else if (base_type == TypePtr::NULL_PTR) {\n+  } else if (_gvn.type(base->uncast()) == TypePtr::NULL_PTR) {\n@@ -2365,0 +2365,1 @@\n+  assert(!stopped(), \"Inlining of unsafe access failed: address construction stopped unexpectedly\");\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-applications\/ctw\/modules\/java_base.java 8340683 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8320308\n+ * @summary Unsafe::getShortUnaligned with base null hidden behind CheckCastPP nodes\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=quiet -XX:TypeProfileLevel=222\n+ *      -XX:+IgnoreUnrecognizedVMOptions -XX:+AlwaysIncrementalInline\n+ *      -XX:CompileCommand=compileonly,compiler.parsing.TestUnsafeArrayAccessWithNullBase::test*\n+ *      -XX:-TieredCompilation compiler.parsing.TestUnsafeArrayAccessWithNullBase\n+ * @run main\/othervm compiler.parsing.TestUnsafeArrayAccessWithNullBase\n+ *\/\n+\n+package compiler.parsing;\n+\n+import java.lang.reflect.*;\n+import jdk.internal.misc.Unsafe;\n+\n+public class TestUnsafeArrayAccessWithNullBase {\n+\n+    \/*\n+    Trigger bug when handling Unsafe.getShortUnaligned with null checks and inlined methods.\n+    The bug appears when the method is incrementally inlined and optimized based on the argument profile information.\n+\n+    Warmup Phase: By warming up with non-null values, the argument profile for the helper methods records non-null types.\n+        - insert CheckCastPP: speculative=byte[int:>=0] for return of getSmall\/getLarge\n+        - insert CheckCastPP: speculative=byte[int:>=0] for argument `Object array` in helperSmall\/helperLarge\n+    Trigger Phase: Calling test causes LibraryCallKit::inline_unsafe_access(..) for Unsafe::getShortUnaligned to fail:\n+        Reason: UNSAFE.getShortUnaligned(array, offset) is called with array=null,\n+        but ConP null is now hidden by two CheckCastPP with speculative=byte[int:>=0] in the graph\n+    *\/\n+\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    private static final Object byteArray = new byte[1_050_000];\n+\n+    public static Object getLarge(boolean useNull) {\n+        return useNull ? null : byteArray;\n+    }\n+\n+    public static Object getSmall(boolean useNull) {\n+        return useNull ? null : new byte[10];\n+    }\n+\n+    \/\/ use a helper to delay inlining of UNSAFE.getShortUnaligned\n+    public static int helperLarge(Object array, boolean run) {\n+        \/\/ offset >= os::vm_page_size(): LibraryCallKit::classify_unsafe_addr returns Type::AnyPtr\n+        return run ? UNSAFE.getShortUnaligned(array, 1_049_000) : 0; \/\/ after warmup CheckCastPP: speculative=byte[int:>=0]\n+    }\n+\n+    public static int accessLargeArray(boolean useNull, boolean run) {\n+        Object array = getLarge(useNull); \/\/ after warmup CheckCastPP: speculative=byte[int:>=0]\n+        \/\/ getLarge() ensures null is only visible after helperLarge was (incrementally) inlined\n+        return helperLarge(array, run);\n+    }\n+\n+    \/\/ use a helper to delay inlining of UNSAFE.getShortUnaligned\n+    \/\/ warmup adds argument profile information for array: CheckCastPP with type non null\n+    public static int helperSmall(Object array, boolean run) {\n+        \/\/ 0 <= offset < os::vm_page_size():  LibraryCallKit::classify_unsafe_addr returns Type::OopPtr\n+        return run ? UNSAFE.getShortUnaligned(array, 1) : 0; \/\/ after warmup CheckCastPP: speculative=byte[int:>=0]\n+    }\n+\n+    public static int accessSmallArray(boolean useNull, boolean run) {\n+        Object array = getSmall(useNull); \/\/ after warmup CheckCastPP: speculative=byte[int:>=0]\n+        return helperSmall(array, run);\n+    }\n+\n+    public static int test1(boolean run) {\n+        return accessLargeArray(true, run);\n+    }\n+\n+    public static int test2(boolean run) {\n+        return accessSmallArray(true, run);\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ Warmup to collect speculative types\n+        for (int i = 0; i < 10_000; i++) {\n+            accessLargeArray(false, true);\n+            accessSmallArray(false, true);\n+        }\n+\n+        \/\/ Trigger Compilation\n+        for (int i = 0; i < 10_000; ++i) {\n+            test1(false);\n+            test2(false);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/parsing\/TestUnsafeArrayAccessWithNullBase.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"}]}