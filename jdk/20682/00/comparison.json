{"files":[{"patch":"@@ -80,1 +80,1 @@\n-  EPOLLONESHOT = (int) (1U << 31)\n+  EPOLLONESHOT = (int) (1U << 30)\n@@ -94,1 +94,1 @@\n-#define EPOLLONESHOT (1U << 31)\n+#define EPOLLONESHOT (1U << 30)\n@@ -230,5 +230,0 @@\n-#define KEYEDEVENT_WAIT 0x00000001UL\n-#define KEYEDEVENT_WAKE 0x00000002UL\n-#define KEYEDEVENT_ALL_ACCESS \\\n-  (STANDARD_RIGHTS_REQUIRED | KEYEDEVENT_WAIT | KEYEDEVENT_WAKE)\n-\n@@ -258,8 +253,0 @@\n-  X(NTSTATUS,                             \\\n-    NTAPI,                                \\\n-    NtCreateKeyedEvent,                   \\\n-    (PHANDLE KeyedEventHandle,            \\\n-     ACCESS_MASK DesiredAccess,           \\\n-     POBJECT_ATTRIBUTES ObjectAttributes, \\\n-     ULONG Flags))                        \\\n-                                          \\\n@@ -280,16 +267,0 @@\n-  X(NTSTATUS,                             \\\n-    NTAPI,                                \\\n-    NtReleaseKeyedEvent,                  \\\n-    (HANDLE KeyedEventHandle,             \\\n-     PVOID KeyValue,                      \\\n-     BOOLEAN Alertable,                   \\\n-     PLARGE_INTEGER Timeout))             \\\n-                                          \\\n-  X(NTSTATUS,                             \\\n-    NTAPI,                                \\\n-    NtWaitForKeyedEvent,                  \\\n-    (HANDLE KeyedEventHandle,             \\\n-     PVOID KeyValue,                      \\\n-     BOOLEAN Alertable,                   \\\n-     PLARGE_INTEGER Timeout))             \\\n-                                          \\\n@@ -494,1 +465,1 @@\n-\/* The reflock is a special kind of lock that normally prevents a chunk of\n+\/* A reflock is a special kind of lock that normally prevents a chunk of\n@@ -507,1 +478,1 @@\n- * Attemmpting to lock or destroy a lock after reflock_unref_and_destroy() has\n+ * Attempting to lock or destroy a lock after reflock_unref_and_destroy() has\n@@ -514,0 +485,2 @@\n+  CONDITION_VARIABLE cv_signal;\n+  CONDITION_VARIABLE cv_await;\n@@ -1553,2 +1526,6 @@\n-#define REFLOCK__DESTROY_MASK ((long) 0xf0000000UL)\n-#define REFLOCK__POISON       ((long) 0x300dead0UL)\n+#define REFLOCK__DESTROY_MASK ((long) 0x10000000UL)\n+#define REFLOCK__SIGNAL       ((long) 0x20000000UL)\n+#define REFLOCK__SIGNAL_MASK  ((long) 0x20000000UL)\n+#define REFLOCK__AWAIT        ((long) 0x40000000UL)\n+#define REFLOCK__AWAIT_MASK   ((long) 0x40000000UL)\n+#define REFLOCK__POISON       ((long) 0x800dead0UL)\n@@ -1556,1 +1533,1 @@\n-static HANDLE reflock__keyed_event = NULL;\n+static CRITICAL_SECTION signalMutex;\n@@ -1559,4 +1536,1 @@\n-  NTSTATUS status = NtCreateKeyedEvent(\n-      &reflock__keyed_event, KEYEDEVENT_ALL_ACCESS, NULL, 0);\n-  if (status != STATUS_SUCCESS)\n-    return_set_error(-1, RtlNtStatusToDosError(status));\n+  InitializeCriticalSection(&signalMutex);\n@@ -1568,0 +1542,2 @@\n+  InitializeConditionVariable(&reflock->cv_signal);\n+  InitializeConditionVariable(&reflock->cv_await);\n@@ -1570,4 +1546,11 @@\n-static void reflock__signal_event(void* address) {\n-  NTSTATUS status =\n-      NtReleaseKeyedEvent(reflock__keyed_event, address, FALSE, NULL);\n-  if (status != STATUS_SUCCESS)\n+static void reflock__signal_event(reflock_t* reflock) {\n+  BOOL status = TRUE;\n+\n+  EnterCriticalSection(&signalMutex);\n+  long state = InterlockedOr(&reflock->state, REFLOCK__SIGNAL);\n+  while ((reflock->state & REFLOCK__AWAIT_MASK) == 0) {\n+    status = SleepConditionVariableCS(&reflock->cv_signal, &signalMutex, INFINITE);\n+  }\n+  LeaveCriticalSection(&signalMutex);\n+\n+  if (status != TRUE)\n@@ -1575,0 +1558,4 @@\n+\n+  \/* At most one reflock__await_event call per reflock. *\/\n+  WakeConditionVariable(&reflock->cv_await);\n+  unused_var(state);\n@@ -1577,4 +1564,11 @@\n-static void reflock__await_event(void* address) {\n-  NTSTATUS status =\n-      NtWaitForKeyedEvent(reflock__keyed_event, address, FALSE, NULL);\n-  if (status != STATUS_SUCCESS)\n+static void reflock__await_event(reflock_t* reflock) {\n+  BOOL status = TRUE;\n+\n+  EnterCriticalSection(&signalMutex);\n+  long state = InterlockedOr(&reflock->state, REFLOCK__AWAIT);\n+  while ((reflock->state & REFLOCK__SIGNAL_MASK) == 0) {\n+    status = SleepConditionVariableCS(&reflock->cv_await, &signalMutex, INFINITE);\n+  }\n+  LeaveCriticalSection(&signalMutex);\n+\n+  if (status != TRUE)\n@@ -1582,0 +1576,4 @@\n+\n+  \/* Multiple threads could be waiting. *\/\n+  WakeAllConditionVariable(&reflock->cv_signal);\n+  unused_var(state);\n@@ -1598,1 +1596,2 @@\n-  if (state == REFLOCK__DESTROY)\n+  if ((state & REFLOCK__DESTROY_MASK) == REFLOCK__DESTROY &&\n+      (state & REFLOCK__REF_MASK) == 0)\n@@ -1614,1 +1613,2 @@\n-  assert(state == REFLOCK__DESTROY);\n+  assert((state & REFLOCK__DESTROY_MASK) == REFLOCK__DESTROY);\n+  assert((state & REFLOCK__REF_MASK) == 0);\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/wepoll.c","additions":50,"deletions":50,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-  EPOLLONESHOT = (int) (1U << 31)\n+  EPOLLONESHOT = (int) (1U << 30)\n@@ -97,1 +97,1 @@\n-#define EPOLLONESHOT (1U << 31)\n+#define EPOLLONESHOT (1U << 30)\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/wepoll.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}