{"files":[{"patch":"@@ -389,10 +389,3 @@\n-            final Field field;\n-            final int modifiers;\n-            try {\n-                field = tclass.getDeclaredField(fieldName);\n-                modifiers = field.getModifiers();\n-                sun.reflect.misc.ReflectUtil.ensureMemberAccess(\n-                    caller, tclass, null, modifiers);\n-            } catch (Exception ex) {\n-                throw new RuntimeException(ex);\n-            }\n+            FieldUpdaterUtil.FieldAndModifiers fam =\n+                FieldUpdaterUtil.getFieldWithAccess(tclass, fieldName, caller);\n+            FieldUpdaterUtil.validateField(fam.field, int.class);\n@@ -400,20 +393,1 @@\n-            if (field.getType() != int.class)\n-                throw new IllegalArgumentException(\"Must be integer type\");\n-\n-            if (!Modifier.isVolatile(modifiers))\n-                throw new IllegalArgumentException(\"Must be volatile type\");\n-\n-            if (Modifier.isStatic(modifiers))\n-                throw new IllegalArgumentException(\"Must not be a static field\");\n-\n-            \/\/ Access to protected field members is restricted to receivers only\n-            \/\/ of the accessing class, or one of its subclasses, and the\n-            \/\/ accessing class must in turn be a subclass (or package sibling)\n-            \/\/ of the protected member's defining class.\n-            \/\/ If the updater refers to a protected field of a declaring class\n-            \/\/ outside the current package, the receiver argument will be\n-            \/\/ narrowed to the type of the accessing class.\n-            this.cclass = (Modifier.isProtected(modifiers) &&\n-                           tclass.isAssignableFrom(caller) &&\n-                           !isSamePackage(tclass, caller))\n-                          ? caller : tclass;\n+            this.cclass = FieldUpdaterUtil.computeAccessClass(tclass, caller, fam.modifiers);\n@@ -421,17 +395,1 @@\n-            this.offset = U.objectFieldOffset(field);\n-        }\n-\n-        \/**\n-         * Returns true if the second classloader can be found in the first\n-         * classloader's delegation chain.\n-         * Equivalent to the inaccessible: first.isAncestor(second).\n-         *\/\n-        private static boolean isAncestor(ClassLoader first, ClassLoader second) {\n-            ClassLoader acl = first;\n-            do {\n-                acl = acl.getParent();\n-                if (second == acl) {\n-                    return true;\n-                }\n-            } while (acl != null);\n-            return false;\n+            this.offset = U.objectFieldOffset(fam.field);\n@@ -440,8 +398,0 @@\n-        \/**\n-         * Returns true if the two classes have the same class loader and\n-         * package qualifier\n-         *\/\n-        private static boolean isSamePackage(Class<?> class1, Class<?> class2) {\n-            return class1.getClassLoader() == class2.getClassLoader()\n-                   && class1.getPackageName() == class2.getPackageName();\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicIntegerFieldUpdater.java","additions":5,"deletions":55,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -384,31 +384,5 @@\n-            final Field field;\n-            final int modifiers;\n-            try {\n-                field = tclass.getDeclaredField(fieldName);\n-                modifiers = field.getModifiers();\n-                sun.reflect.misc.ReflectUtil.ensureMemberAccess(\n-                    caller, tclass, null, modifiers);\n-            } catch (Exception ex) {\n-                throw new RuntimeException(ex);\n-            }\n-\n-            if (field.getType() != long.class)\n-                throw new IllegalArgumentException(\"Must be long type\");\n-\n-            if (!Modifier.isVolatile(modifiers))\n-                throw new IllegalArgumentException(\"Must be volatile type\");\n-\n-            if (Modifier.isStatic(modifiers))\n-                throw new IllegalArgumentException(\"Must not be a static field\");\n-\n-            \/\/ Access to protected field members is restricted to receivers only\n-            \/\/ of the accessing class, or one of its subclasses, and the\n-            \/\/ accessing class must in turn be a subclass (or package sibling)\n-            \/\/ of the protected member's defining class.\n-            \/\/ If the updater refers to a protected field of a declaring class\n-            \/\/ outside the current package, the receiver argument will be\n-            \/\/ narrowed to the type of the accessing class.\n-            this.cclass = (Modifier.isProtected(modifiers) &&\n-                           tclass.isAssignableFrom(caller) &&\n-                           !isSamePackage(tclass, caller))\n-                          ? caller : tclass;\n+            FieldUpdaterUtil.FieldAndModifiers fam =\n+                FieldUpdaterUtil.getFieldWithAccess(tclass, fieldName, caller);\n+            FieldUpdaterUtil.validateField(fam.field, long.class);\n+\n+            this.cclass = FieldUpdaterUtil.computeAccessClass(tclass, caller, fam.modifiers);\n@@ -416,1 +390,1 @@\n-            this.offset = U.objectFieldOffset(field);\n+            this.offset = U.objectFieldOffset(fam.field);\n@@ -502,24 +476,0 @@\n-    \/**\n-     * Returns true if the second classloader can be found in the first\n-     * classloader's delegation chain.\n-     * Equivalent to the inaccessible: first.isAncestor(second).\n-     *\/\n-    static boolean isAncestor(ClassLoader first, ClassLoader second) {\n-        ClassLoader acl = first;\n-        do {\n-            acl = acl.getParent();\n-            if (second == acl) {\n-                return true;\n-            }\n-        } while (acl != null);\n-        return false;\n-    }\n-\n-    \/**\n-     * Returns true if the two classes have the same class loader and\n-     * package qualifier\n-     *\/\n-    static boolean isSamePackage(Class<?> class1, Class<?> class2) {\n-        return class1.getClassLoader() == class2.getClassLoader()\n-               && class1.getPackageName() == class2.getPackageName();\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicLongFieldUpdater.java","additions":6,"deletions":56,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -345,12 +345,2 @@\n-            final Field field;\n-            final Class<?> fieldClass;\n-            final int modifiers;\n-            try {\n-                field = tclass.getDeclaredField(fieldName);\n-                modifiers = field.getModifiers();\n-                sun.reflect.misc.ReflectUtil.ensureMemberAccess(\n-                    caller, tclass, null, modifiers);\n-                fieldClass = field.getType();\n-            } catch (Exception ex) {\n-                throw new RuntimeException(ex);\n-            }\n+            FieldUpdaterUtil.FieldAndModifiers fam =\n+                FieldUpdaterUtil.getFieldWithAccess(tclass, fieldName, caller);\n@@ -358,1 +348,1 @@\n-            if (vclass != fieldClass)\n+            if (vclass != fam.field.getType())\n@@ -360,2 +350,0 @@\n-            if (vclass.isPrimitive())\n-                throw new IllegalArgumentException(\"Must be reference type\");\n@@ -363,2 +351,1 @@\n-            if (!Modifier.isVolatile(modifiers))\n-                throw new IllegalArgumentException(\"Must be volatile type\");\n+            FieldUpdaterUtil.validateField(fam.field, null);\n@@ -366,14 +353,1 @@\n-            if (Modifier.isStatic(modifiers))\n-                throw new IllegalArgumentException(\"Must not be a static field\");\n-\n-            \/\/ Access to protected field members is restricted to receivers only\n-            \/\/ of the accessing class, or one of its subclasses, and the\n-            \/\/ accessing class must in turn be a subclass (or package sibling)\n-            \/\/ of the protected member's defining class.\n-            \/\/ If the updater refers to a protected field of a declaring class\n-            \/\/ outside the current package, the receiver argument will be\n-            \/\/ narrowed to the type of the accessing class.\n-            this.cclass = (Modifier.isProtected(modifiers) &&\n-                           tclass.isAssignableFrom(caller) &&\n-                           !isSamePackage(tclass, caller))\n-                          ? caller : tclass;\n+            this.cclass = FieldUpdaterUtil.computeAccessClass(tclass, caller, fam.modifiers);\n@@ -382,17 +356,1 @@\n-            this.offset = U.objectFieldOffset(field);\n-        }\n-\n-        \/**\n-         * Returns true if the second classloader can be found in the first\n-         * classloader's delegation chain.\n-         * Equivalent to the inaccessible: first.isAncestor(second).\n-         *\/\n-        private static boolean isAncestor(ClassLoader first, ClassLoader second) {\n-            ClassLoader acl = first;\n-            do {\n-                acl = acl.getParent();\n-                if (second == acl) {\n-                    return true;\n-                }\n-            } while (acl != null);\n-            return false;\n+            this.offset = U.objectFieldOffset(fam.field);\n@@ -401,8 +359,0 @@\n-        \/**\n-         * Returns true if the two classes have the same class loader and\n-         * package qualifier\n-         *\/\n-        private static boolean isSamePackage(Class<?> class1, Class<?> class2) {\n-            return class1.getClassLoader() == class2.getClassLoader()\n-                   && class1.getPackageName() == class2.getPackageName();\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicReferenceFieldUpdater.java","additions":6,"deletions":56,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util.concurrent.atomic;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import jdk.internal.reflect.Reflection;\n+\n+\/**\n+ * Utility class containing common field validation and access checking logic\n+ * shared by AtomicIntegerFieldUpdater, AtomicLongFieldUpdater, and\n+ * AtomicReferenceFieldUpdater implementations.\n+ *\n+ * @since 26\n+ *\/\n+final class FieldUpdaterUtil {\n+\n+    private FieldUpdaterUtil() {} \/\/ Prevent instantiation\n+\n+    \/**\n+     * Looks up a field and ensures the caller has access to it.\n+     *\n+     * @param tclass the class holding the field\n+     * @param fieldName the name of the field\n+     * @param caller the class constructing the updater\n+     * @param <T> the type of instances of tclass\n+     * @return the field and its modifiers\n+     * @throws RuntimeException if the field cannot be found or accessed\n+     *\/\n+    static <T> FieldAndModifiers getFieldWithAccess(Class<T> tclass, String fieldName, Class<?> caller) {\n+        try {\n+            Field field = tclass.getDeclaredField(fieldName);\n+            int modifiers = field.getModifiers();\n+            Reflection.ensureMemberAccess(caller, tclass, null, modifiers);\n+            return new FieldAndModifiers(field, modifiers);\n+        } catch (Exception ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    \/**\n+     * Holds a field and its modifiers.\n+     *\n+     * @param field the field\n+     * @param modifiers the field's modifiers\n+     *\/\n+    static record FieldAndModifiers(Field field, int modifiers) {}\n+\n+    \/**\n+     * Validates that a field meets the basic requirements for atomic field updaters.\n+     * Checks that the field is volatile and not static. For primitive updaters,\n+     * validates the field type matches the expected type.\n+     *\n+     * @param field the field to validate\n+     * @param expectedType the expected field type (int.class, long.class),\n+     *                     or null for reference type updaters\n+     * @throws IllegalArgumentException if the field is not volatile, is static,\n+     *                                  or does not match the expected type\n+     *\/\n+    static void validateField(Field field, Class<?> expectedType) {\n+        Class<?> fieldType = field.getType();\n+        int modifiers = field.getModifiers();\n+\n+        \/\/ Type validation for primitive updaters\n+        if (expectedType == int.class && fieldType != int.class) {\n+            throw new IllegalArgumentException(\"Must be integer type\");\n+        } else if (expectedType == long.class && fieldType != long.class) {\n+            throw new IllegalArgumentException(\"Must be long type\");\n+        } else if (expectedType == null && fieldType.isPrimitive()) {\n+            \/\/ Reference updaters must not be used with primitive types\n+            throw new IllegalArgumentException(\"Must be reference type\");\n+        }\n+\n+        \/\/ Volatile check\n+        if (!Modifier.isVolatile(modifiers)) {\n+            throw new IllegalArgumentException(\"Must be volatile type\");\n+        }\n+\n+        \/\/ Static check\n+        if (Modifier.isStatic(modifiers)) {\n+            throw new IllegalArgumentException(\"Must not be a static field\");\n+        }\n+    }\n+\n+    \/**\n+     * Computes the appropriate class for access checking based on\n+     * protected field access rules.\n+     * <p>\n+     * Access to protected field members is restricted to receivers only\n+     * of the accessing class, or one of its subclasses, and the\n+     * accessing class must in turn be a subclass (or package sibling)\n+     * of the protected member's defining class.\n+     * If the updater refers to a protected field of a declaring class\n+     * outside the current package, the receiver argument will be\n+     * narrowed to the type of the accessing class.\n+     *\n+     * @param tclass the class holding the field\n+     * @param caller the class constructing the updater\n+     * @param modifiers the field modifiers\n+     * @param <T> the type of instances of tclass\n+     * @return the class to use for access checks (either caller or tclass)\n+     *\/\n+    static <T> Class<?> computeAccessClass(Class<T> tclass, Class<?> caller, int modifiers) {\n+        return (Modifier.isProtected(modifiers) &&\n+                tclass.isAssignableFrom(caller) &&\n+                !isSamePackage(tclass, caller))\n+               ? caller : tclass;\n+    }\n+\n+    \/**\n+     * Returns true if the two classes have the same class loader and\n+     * package qualifier.\n+     *\n+     * @param class1 the first class\n+     * @param class2 the second class\n+     * @return true if both classes are in the same package\n+     *\/\n+    static boolean isSamePackage(Class<?> class1, Class<?> class2) {\n+        return class1.getClassLoader() == class2.getClassLoader()\n+               && class1.getPackageName() == class2.getPackageName();\n+    }\n+\n+    \/**\n+     * Returns true if the second classloader can be found in the first\n+     * classloader's delegation chain.\n+     * Equivalent to the inaccessible: first.isAncestor(second).\n+     *\n+     * @param first the first classloader\n+     * @param second the second classloader\n+     * @return true if second is an ancestor of first\n+     *\/\n+    static boolean isAncestor(ClassLoader first, ClassLoader second) {\n+        ClassLoader acl = first;\n+        do {\n+            acl = acl.getParent();\n+            if (second == acl) {\n+                return true;\n+            }\n+        } while (acl != null);\n+        return false;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/FieldUpdaterUtil.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"}]}