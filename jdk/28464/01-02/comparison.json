{"files":[{"patch":"@@ -389,5 +389,2 @@\n-            FieldUpdaterUtil.FieldAndModifiers fam =\n-                FieldUpdaterUtil.getFieldWithAccess(tclass, fieldName, caller);\n-            FieldUpdaterUtil.validateField(fam.field, int.class);\n-\n-            this.cclass = FieldUpdaterUtil.computeAccessClass(tclass, caller, fam.modifiers);\n+            Field field = FieldUpdaterUtil.findValidatedField(tclass, fieldName, caller, int.class);\n+            this.cclass = FieldUpdaterUtil.computeAccessClass(tclass, caller, field.getModifiers());\n@@ -395,1 +392,1 @@\n-            this.offset = U.objectFieldOffset(fam.field);\n+            this.offset = U.objectFieldOffset(field);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicIntegerFieldUpdater.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -384,5 +384,2 @@\n-            FieldUpdaterUtil.FieldAndModifiers fam =\n-                FieldUpdaterUtil.getFieldWithAccess(tclass, fieldName, caller);\n-            FieldUpdaterUtil.validateField(fam.field, long.class);\n-\n-            this.cclass = FieldUpdaterUtil.computeAccessClass(tclass, caller, fam.modifiers);\n+            Field field = FieldUpdaterUtil.findValidatedField(tclass, fieldName, caller, long.class);\n+            this.cclass = FieldUpdaterUtil.computeAccessClass(tclass, caller, field.getModifiers());\n@@ -390,1 +387,1 @@\n-            this.offset = U.objectFieldOffset(fam.field);\n+            this.offset = U.objectFieldOffset(field);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicLongFieldUpdater.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -345,2 +345,1 @@\n-            FieldUpdaterUtil.FieldAndModifiers fam =\n-                FieldUpdaterUtil.getFieldWithAccess(tclass, fieldName, caller);\n+            Field field = FieldUpdaterUtil.findValidatedField(tclass, fieldName, caller, null);\n@@ -348,1 +347,1 @@\n-            if (vclass != fam.field.getType())\n+            if (vclass != field.getType())\n@@ -351,3 +350,1 @@\n-            FieldUpdaterUtil.validateField(fam.field, null);\n-\n-            this.cclass = FieldUpdaterUtil.computeAccessClass(tclass, caller, fam.modifiers);\n+            this.cclass = FieldUpdaterUtil.computeAccessClass(tclass, caller, field.getModifiers());\n@@ -356,1 +353,1 @@\n-            this.offset = U.objectFieldOffset(fam.field);\n+            this.offset = U.objectFieldOffset(field);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicReferenceFieldUpdater.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-    private FieldUpdaterUtil() {} \/\/ Prevent instantiation\n+    private FieldUpdaterUtil() {}\n@@ -43,1 +43,3 @@\n-     * Looks up a field and ensures the caller has access to it.\n+     * Finds a field and validates it meets the requirements for atomic field updaters.\n+     * Ensures the caller has access, the field is volatile and not static, and for\n+     * primitive updaters, that the field type matches the expected type.\n@@ -48,0 +50,2 @@\n+     * @param expectedType the expected field type (int.class, long.class),\n+     *                     or null for reference type updaters\n@@ -49,1 +53,1 @@\n-     * @return the field and its modifiers\n+     * @return the validated field\n@@ -51,0 +55,2 @@\n+     * @throws IllegalArgumentException if the field is not volatile, is static,\n+     *                                  or does not match the expected type\n@@ -52,1 +58,2 @@\n-    static <T> FieldAndModifiers getFieldWithAccess(Class<T> tclass, String fieldName, Class<?> caller) {\n+    static <T> Field findValidatedField(Class<T> tclass, String fieldName,\n+                                        Class<?> caller, Class<?> expectedType) {\n@@ -57,5 +64,0 @@\n-            return new FieldAndModifiers(field, modifiers);\n-        } catch (Exception ex) {\n-            throw new RuntimeException(ex);\n-        }\n-    }\n@@ -63,7 +65,1 @@\n-    \/**\n-     * Holds a field and its modifiers.\n-     *\n-     * @param field the field\n-     * @param modifiers the field's modifiers\n-     *\/\n-    static record FieldAndModifiers(Field field, int modifiers) {}\n+            Class<?> fieldType = field.getType();\n@@ -71,14 +67,7 @@\n-    \/**\n-     * Validates that a field meets the basic requirements for atomic field updaters.\n-     * Checks that the field is volatile and not static. For primitive updaters,\n-     * validates the field type matches the expected type.\n-     *\n-     * @param field the field to validate\n-     * @param expectedType the expected field type (int.class, long.class),\n-     *                     or null for reference type updaters\n-     * @throws IllegalArgumentException if the field is not volatile, is static,\n-     *                                  or does not match the expected type\n-     *\/\n-    static void validateField(Field field, Class<?> expectedType) {\n-        Class<?> fieldType = field.getType();\n-        int modifiers = field.getModifiers();\n+            if (expectedType == int.class && fieldType != int.class) {\n+                throw new IllegalArgumentException(\"Must be integer type\");\n+            } else if (expectedType == long.class && fieldType != long.class) {\n+                throw new IllegalArgumentException(\"Must be long type\");\n+            } else if (expectedType == null && fieldType.isPrimitive()) {\n+                throw new IllegalArgumentException(\"Must be reference type\");\n+            }\n@@ -86,9 +75,3 @@\n-        \/\/ Type validation for primitive updaters\n-        if (expectedType == int.class && fieldType != int.class) {\n-            throw new IllegalArgumentException(\"Must be integer type\");\n-        } else if (expectedType == long.class && fieldType != long.class) {\n-            throw new IllegalArgumentException(\"Must be long type\");\n-        } else if (expectedType == null && fieldType.isPrimitive()) {\n-            \/\/ Reference updaters must not be used with primitive types\n-            throw new IllegalArgumentException(\"Must be reference type\");\n-        }\n+            if (!Modifier.isVolatile(modifiers)) {\n+                throw new IllegalArgumentException(\"Must be volatile type\");\n+            }\n@@ -96,4 +79,3 @@\n-        \/\/ Volatile check\n-        if (!Modifier.isVolatile(modifiers)) {\n-            throw new IllegalArgumentException(\"Must be volatile type\");\n-        }\n+            if (Modifier.isStatic(modifiers)) {\n+                throw new IllegalArgumentException(\"Must not be a static field\");\n+            }\n@@ -101,3 +83,3 @@\n-        \/\/ Static check\n-        if (Modifier.isStatic(modifiers)) {\n-            throw new IllegalArgumentException(\"Must not be a static field\");\n+            return field;\n+        } catch (Exception ex) {\n+            throw new RuntimeException(ex);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/FieldUpdaterUtil.java","additions":28,"deletions":46,"binary":false,"changes":74,"status":"modified"}]}